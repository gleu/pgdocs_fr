<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/user-manag.sgml,v 1.11 2005/09/15 07:03:24 guillaume Exp $
-->

<chapter id="user-manag">
 <title>Rôles et droits de la base de données</title>

 <para>
  <productname>PostgreSQL</productname> gère les droits d'accès aux bases de
  données en utilisant le concept de <firstterm>rôles</>. Un rôle peut être
  vu comme soit un utilisateur de la base de données, soit comme un groupe
  d'utilisateurs de la base de données, suivant la façon dont le rôle est
  configuré. Les rôles peuvent posséder des objets de la base de données (par
  exemple des tables) et peuvent affecter des droits sur ces objets à d'autres
  rôles pour contrôler qui a accès à ces objets. De plus, il est possible de
  donner l'<firstterm>appartenance</> d'un rôle à un autre rôle, l'autorisant
  du coup à utiliser les droits affectés au rôle dont il est membre.
 </para>

 <para>
  Le concept des rôles comprends les concepts des <quote>utilisateurs</> et des
  <quote>groupes</>. Dans les versions de <productname>PostgreSQL</productname>
  antérieures à la 8.1, les utilisateurs et les groupes étaient des types
  d'entité distincts mais maintenant ce ne sont que des rôles. Tout rôle peut
  agir comme un utilisateur, un groupe ou les deux.
 </para>

 <para>
  Ce chapitre décrit comment créer et gérer des rôles et
  introduit le système de droits. Plus d'informations sur les
  différents types d'objets de la base de données et les effets des
  droits sont disponibles dans le <xref linkend="ddl">.
 </para>

 <sect1 id="database-roles">
  <title>Rôles de la base de données</title>

  <indexterm zone="database-roles">
   <primary>rôle</primary>
  </indexterm>

  <indexterm>
   <primary>CREATE ROLE</primary>
  </indexterm>

  <indexterm>
   <primary>DROP ROLE</primary>
  </indexterm>

  <para>
   Conceptuellement, les rôles de la base sont totalement
   séparés des utilisateurs du système d'exploitation. En pratique,
   il peut être commode de maintenir une correspondance mais cela
   n'est pas requis. Les rôles sont globaux à toute une
   installation de groupe de bases de données (et non individuelle pour
   chaque base). Pour créer un rôle, utilisez la commande SQL
   <xref linkend="sql-createrole" endterm="sql-createrole-title">&nbsp;:
<synopsis>
CREATE ROLE <replaceable>nom_utilisateur</replaceable>;
</synopsis>
   <replaceable>nom_utilisateur</replaceable> suit les règles des
   identifiants SQL&nbsp;: soit sans guillemets et sans caractères spéciaux,
   soit entre double-guillemets. (En pratique, vous voudrez surtout ajouter
   des options supplémentaires, comme <literal>LOGIN</>, à cette commande.
   Vous trouverez plus de détails ci-dessous.) Pour supprimer un rôle existant,
   utilisez la commande analogue <xref linkend="sql-droprole"
   endterm="sql-droprole-title">&nbsp;:
<synopsis>
DROP ROLE <replaceable>nom_utilisateur</replaceable>;
</synopsis>
  </para>

  <indexterm>
   <primary>createuser</primary>
  </indexterm>

  <indexterm>
   <primary>dropuser</primary>
  </indexterm>

  <para>
   Pour une certaine facilité d'utilisation, les programmes
   <xref linkend="app-createuser"> et <xref linkend="app-dropuser"> sont
   fournis comme emballage de ces commandes SQL et peuvent être appelées depuis
   la ligne de commande du shell&nbsp;:
<synopsis>
createuser <replaceable>nom_utilisateur</replaceable>
dropuser <replaceable>nom_utilisateur</replaceable>
</synopsis>
  </para>

  <para>
   Pour déterminer l'ensemble des rôles existants, examinez le catalogue
   système <structname>pg_role</> existant, par exemple
<synopsis>
SELECT rolname FROM pg_role;
</synopsis>
   La méta-commande <literal>\du</> du programme <xref linkend="app-psql"> est
   aussi utile pour lister les rôles existants.
  </para>

  <para>
   Afin d'amorcer le système de base de données, un système récemment
   installé contient toujours un rôle prédéfini. Cet
   rôle est un superutilisateur et aura par défaut (à moins
   que cela ne soit modifié en lançant la commande
   <command>initdb</command>) le même nom que l'utilisateur
   du système d'exploitation qui a initialisé le groupe de bases de
   données. Par habitude, ce rôle sera nommé
   <literal>postgres</literal>. Pour créer plus de rôles, vous devez
   d'abord vous connecter en temps que cet rôle initial.
  </para>

  <para>
   Chaque connexion au serveur de la base de données est fait au nom d'un
   certain rôle et ce rôle déterminer les droits d'accès initiaux pour les
   commandes lancées sur cette connexion. Le nom du rôle
   à employer pour une connexion à une base particulière est indiqué
   par le client initialisant la demande de connexion et ce, de la
   manière qui lui est propre.  Par exemple, le programme
   <command>psql</command> utilise l'option de ligne de commandes
   <option>-U</option> pour préciser sous quel rôle il se
   connecte. Beaucoup d'applications (incluant <command>createuser</>
   et <command>psql</>) utilisent par défaut le nom courant de
   l'utilisateur du système d'exploitation. Par conséquence, il peut souvent
   être pratique de maintenir une correspondance de nommage entre les rôles et
   les utilisateurs du système d'exploitation.
  </para>

  <para>
   La configuration de l'authentification du client détermine avec
   quel rôle de la base, la connexion cliente donnée se
   connectera, comme cela est expliqué dans le
   <xref linkend="client-authentication">. (Donc, un client n'est pas
   nécessairement obligé de se connecter avec le rôle du même nom que
   son nom d'utilisateur dans le système d'exploitation&nbsp;; de la même
   façon que le nom de connexion d'un utilisateur peut ne pas correspondre à
   son vrai nom.) Comme le rôle détermine l'ensemble des
   droits disponibles pour le client connecté, il est important de configurer
   cela soigneusement quand un environnement multi-utilisateurs est mis en
   place.
  </para>
 </sect1>

 <sect1 id="role-attributes">
  <title>Attributs des rôles</title>

   <para>
    Un rôle de bases de données peut avoir un certain nombre
    d'attributs qui définissent ses droits et interagissent avec
    le système d'authentification du client.

    <variablelist>
     <varlistentry>
      <term>droit de connexion<indexterm><primary>droit de connexion</></></term>
      <listitem>
       <para>
        Seuls les rôles disposant de l'attribut <literal>LOGIN</> peuvent être
        utilisés comme nom de rôle initial pour une connexion à une base de
        données. Un rôle avec l'attribut <literal>LOGIN</> peut être considéré
        de la même façon qu'un <quote>utilisateur de la base de données</>.
        Pour créer un rôle disposant du droit de connexion, utilisez
<programlisting>
CREATE ROLE <replaceable>nom</replaceable> LOGIN;
CREATE USER <replaceable>nom</replaceable>;
</programlisting>
        (<command>CREATE USER</> est équivalent à <command>CREATE ROLE</>
        sauf que <command>CREATE USER</> utilise <literal>LOGIN</> par défaut
        alors que <command>CREATE ROLE</> ne le fait pas.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>statut de superutilisateur<indexterm><primary>superutilisateur</></></term>
      <listitem>
       <para>
        Les superutilisateurs ne sont pas pris en compte dans les vérifications
        des droits. Ceci est un privilège dangereux et ne devrait pas être
        utilisé sans faire particulièrement attention&nbsp;; il est préférable
        de faire la grande majorité de votre travail avec un rôle qui n'est pas
        superutilisateur. Pour créer un nouveau superutilisateur, utilisez
        <literal>CREATE ROLE <replaceable>nom</replaceable>
        SUPERUSER</literal>. Vous devez le faire en tant que superutilisateur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>création de bases de données<indexterm><primary>base de
	données</><secondary>droit de création</></></term>
      <listitem>
       <para>
        Les droits de création de bases doivent être
        explicitement données à un rôle (à l'exception des
        super-utilisateurs qui passent au travers de toutes
        vérifications de droits). Pour créer un tel rôle,
        utilisez <literal>CREATE ROLE
        <replaceable>nom_utilisateur</replaceable> CREATEDB</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>création de rôle<indexterm><primary>role</><secondary>droit de création</></></term>
      <listitem>
       <para>
        Un rôle doit se voir explicitement donné le droit de créer plus de
        rôles (sauf pour les superutilisateurs vu qu'ils ne sont pas pris en
        compte lors des vérifications de droits). Pour créer un tel rôle,
        utilisez <literal>CREATE ROLE
        <replaceable>nom</replaceable> CREATEROLE</literal>.
        Un rôle disposant du droit <literal>CREATEROLE</> peut aussi modifier et
        supprimer d'autres rôles, as well as grant or revoke membership in them.
        However, to create, alter, drop, or change membership of a
        superuser role, superuser status is required;.
        <literal>CREATEROLE</> n'est pas suffisant pour cela.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>mot de passe<indexterm><primary>mot de passe</></></term>
      <listitem>
       <para>
        Un mot de passe est seulement significatif si la méthode
        d'authentification du client exige que le client fournisse
        un mot de passe quand il se connecte à la base.  Les
        méthodes d'authentification <option>mot de passe</>,
        <option>md5</> et <option>crypt</> utilisent les mots de
        passe.  Les mots de passe de la base de données ne sont pas
        les mêmes que ceux du système d'exploitation.  Indiquez un
        mots de passe lors de la création d'un rôle avec
        <literal>CREATE ROLE
        <replaceable>nom_utilisateur</replaceable> PASSWORD
        '<replaceable>le_mot_de_passe</>'</literal>. 
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    Les attributs d'un rôle peuvent être modifiés après sa
    création avec <command>ALTER ROLE</command>.<indexterm><primary>ALTER ROLE</></>
    Regardez les pages de références de <xref linkend="sql-createrole"
    endterm="sql-createrole-title"> et de <xref linkend="sql-alterrole"
    endterm="sql-alterrole-title"> pour plus de détails.
   </para>

  <tip>
   <para>
    It is good practice to create a role that has the <literal>CREATEDB</>
    and <literal>CREATEROLE</> privileges, but is not a superuser, and then
    use this role for all routine management of databases and roles.  This
    approach avoids the dangers of operating as a superuser for tasks that
    do not really require it.
   </para>
  </tip>

  <para>
   Un rôle peut aussi configurer ses options par défaut pour de
   nombreux paramètres de configuration décris dans la
   <xref linkend="runtime-config">. Par exemple, si pour une raison
   ou une autre vous voulez désactiver les parcours d'index (conseil&nbsp;:
   ce n'est pas une bonne idée) à chaque fois que vous vous connectez, vous
   pouvez utiliser
<programlisting>
ALTER ROLE nom_utilisateur SET enable_indexscan TO off;
</programlisting>
   Cela sauve les paramètres (mais ne les applique pas immédiatement)
   Dans les connexions ultérieures de ce rôle, c'est comme si 
   <literal>SET enable_indexscan TO off;</literal> avait été appelé
   juste avant le démarrage de la session. Vous pouvez toujours
   modifier les paramètres durant la session.  To remove a role-specific default setting, use
   <literal>ALTER ROLE <replaceable>rolename</> RESET <replaceable>varname</>;</literal>.
   Note that role-specific defaults attached to roles without
   <literal>LOGIN</> privilege are fairly useless, since they will never
   be invoked.
  </para>
 </sect1>

 <sect1 id="privileges">
  <title>Privileges</title>

  <indexterm zone="privileges">
   <primary>privilege</primary>
  </indexterm>

  <indexterm zone="privileges">
   <primary>owner</primary>
  </indexterm>

  <indexterm zone="privileges">
   <primary>GRANT</primary>
  </indexterm>

  <indexterm zone="privileges">
   <primary>REVOKE</primary>
  </indexterm>

  <para>
   When an object is created, it is assigned an owner. The
   owner is normally the role that executed the creation statement.
   For most kinds of objects, the initial state is that only the owner
   (or a superuser) can do anything with the object. To allow
   other roles to use it, <firstterm>privileges</firstterm> must be
   granted.
   There are several different kinds of privilege: <literal>SELECT</>,
   <literal>INSERT</>, <literal>UPDATE</>, <literal>DELETE</>,
   <literal>RULE</>, <literal>REFERENCES</>, <literal>TRIGGER</>,
   <literal>CREATE</>, <literal>TEMPORARY</>, <literal>EXECUTE</>,
   and <literal>USAGE</>. For more
   information on the different types of privileges supported by
   <productname>PostgreSQL</productname>, see the
   <xref linkend="sql-grant" endterm="sql-grant-title"> reference page.
  </para>

  <para>
   To assign privileges, the <command>GRANT</command> command is
   used. So, if <literal>joe</literal> is an existing role, and
   <literal>accounts</literal> is an existing table, the privilege to
   update the table can be granted with
<programlisting>
GRANT UPDATE ON accounts TO joe;
</programlisting>
   The special name <literal>PUBLIC</literal> can
   be used to grant a privilege to every role on the system. Writing
   <literal>ALL</literal> in place of a specific privilege specifies that all
   privileges that apply to the object will be granted.
  </para>

  <para>
   To revoke a privilege, use the fittingly named
   <xref linkend="sql-revoke" endterm="sql-revoke-title"> command:
<programlisting>
REVOKE ALL ON accounts FROM PUBLIC;
</programlisting>
  </para>

  <para>
   The special privileges of an object's owner (i.e., the right to modify
   or destroy the object) are always implicit in being the owner,
   and cannot be granted or revoked.  But the owner can choose
   to revoke his own ordinary privileges, for example to make a
   table read-only for himself as well as others.
  </para>

  <para>
   An object can be assigned to a new owner with an <command>ALTER</command>
   command of the appropriate kind for the object.  Superusers can always do
   this; ordinary roles can only do it if they are both the current owner
   of the object (or a member of the owning role) and a member of the new
   owning role.
  </para>
 </sect1>

 <sect1 id="role-membership">
  <title>Appartenance d'un rôle</title>

  <indexterm zone="role-membership">
   <primary>rôle</><secondary>appartenance</>
  </indexterm>

  <para>
   Il est souvent intéressant de grouper les utilisateurs pour faciliter la
   gestion des droits&nbsp;: de cette façon, les droits peuvent être donnés ou
   supprimés pour tout un groupe . Dans <productname>PostgreSQL</productname>,
   ceci se fait en créant un rôle représentant le groupe, puis en ajoutant
   les rôles utilisateurs individuels <firstterm>membres</> de ce groupe.
  </para>

  <para>
   Pour configurer un rôle en tant que groupe, créez tout d'abord le rôle&nbsp;:
<synopsis>
CREATE ROLE <replaceable>nom</replaceable>;
</synopsis>
   Typiquement, un rôle utilisé en tant que groupe n'aura pas l'attribut
   <literal>LOGIN</> bien que vous puissiez le faire si vous le souhaitez.
  </para>

  <para>
   Une fois que ce rôle existe, vous pouvez lui ajouter et lui supprimer des
   membres en utilisant les commandes <xref linkend="sql-grant"
   endterm="sql-grant-title"> et <xref linkend="sql-revoke"
   endterm="sql-revoke-title">&nbsp;:
<synopsis>
GRANT <replaceable>role_groupe</replaceable> TO <replaceable>role1</replaceable>, ... ;
REVOKE <replaceable>role_groupe</replaceable> FROM <replaceable>role1</replaceable>, ... ;
</synopsis>
   Vous pouvez aussi faire en sorte que d'autres rôles groupes appartiennent à
   ce groupe (car il n'y a pas réellement de distinction entre les rôles groupe
   et les rôles non groupe).  La seule restriction est que vous ne pouvez pas
   configurer de boucles d'appartenance.
  </para>

  <para>
   Les membres d'un rôle peuvent utiliser les droits du rôle de deux façons.
   Tout d'abord, chaque membre d'un groupe peut exécuter explicitement
   <xref linkend="sql-set-role" endterm="sql-set-role-title"> pour
   <quote>devenir</> temporairement le rôle groupe. Dans cet état, la session
   de la base de données a accès aux droits du rôle groupe plutôt qu'à ceux
   du rôle de connexion original et tous les objets créés sont considérés comme
   appartenant au rôle groupe, et non pas au rôle utilisé lors de la connexion.
   Deuxièmement, les rôles membres qui ont l'attribut <literal>INHERIT</>
   peuvent utiliser automatiquement les droits des rôles dont ils sont
   membres. Comme exemple, supposons que nous avons lancé les commandes
   suivantes
<programlisting>
CREATE ROLE joe LOGIN INHERIT;
CREATE ROLE admin NOINHERIT;
CREATE ROLE wheel NOINHERIT;
GRANT admin TO joe;
GRANT wheel TO admin;
</programlisting>
   Immédiatement après connexion en tant que <literal>joe</>, la session de la
   base de données pourra utiliser les droits donnés directement à
   <literal>joe</> ainsi que ceux donnés à <literal>admin</> parce que
   <literal>joe</> <quote>hérite</> des droits de <literal>admin</>. Néanmoins,
   les droits donnés à <literal>wheel</> ne sont pas disponibles parce que,
   même si <literal>joe</> est un membre indirect de <literal>wheel</>,
   l'appartenance se fait via <literal>admin</> qui dispose de l'attribut
   <literal>NOINHERIT</>. Après
<programlisting>
SET ROLE admin;
</programlisting>
   la session aura la possibilité d'utiliser les droits donnés à
   <literal>admin</>, mais n'aura plus accès à ceux de <literal>joe</>. Après
<programlisting>
SET ROLE wheel;
</programlisting>
   la session pourra utiliser uniquement ceux de <literal>wheel</>, mais ni
   ceux de <literal>joe</> ni ceux de <literal>admin</>. L'état du droit initial
   peut être restauré avec une des instructions suivantes
<programlisting>
SET ROLE joe;
SET ROLE NONE;
RESET ROLE;
</programlisting>
  </para>

  <note>
   <para>
    La commande <command>SET ROLE</> autorisera toujours la sélection de tout
    rôle dont le rôle de connexion est membre directement ou indirectement.
    Du coup, dans l'exemple précédent, il n'est pas nécessaire de devenir
    <literal>admin</> pour devenir <literal>wheel</>.
   </para>
  </note>

  <note>
   <para>
    Dans le standard SQL, il existe une distinction claire entre les
    utilisateurs et les rôles. Les utilisateurs ne peuvent pas hériter
    automatiquement alors que les rôles le peuvent. Ce comportement est obtenu
    dans <productname>PostgreSQL</productname> en donnant aux rôles utilisés
    comme des rôles SQL l'attribut <literal>INHERIT</>, mais en donnant aux
    rôles utilisés en tant qu'utilisateurs SQL l'attribut
    <literal>NOINHERIT</>. Néanmoins, par défaut,
    <productname>PostgreSQL</productname> donne à tous les rôles l'attribut
    <literal>INHERIT</> pour des raisons de compatibilité avec les versions
    précédant la 8.1 dans lesquelles les utilisateurs avaient toujours les
    droits des groupes dont ils étaient membres.
   </para>
  </note>

  <para>
   The role attributes <literal>LOGIN</>, <literal>SUPERUSER</>,
   <literal>CREATEDB</>, and <literal>CREATEROLE</> can be thought of as
   special privileges, but they are never inherited as ordinary privileges
   on database objects are.  You must actually <command>SET ROLE</> to a
   specific role having one of these attributes in order to make use of
   the attribute.  Continuing the above example, we might well choose to
   grant <literal>CREATEDB</> and <literal>CREATEROLE</> to the
   <literal>admin</> role.  Then a session connecting as role <literal>joe</>
   would not have these privileges immediately, only after doing
   <command>SET ROLE admin</>.
  </para>

  <para>
  </para>

  <para>
   Pour détruire un rôle groupe, utilisez <xref
   linkend="sql-droprole" endterm="sql-droprole-title">:
<synopsis>
DROP ROLE <replaceable>nom</replaceable>;
</synopsis>
   Toute appartenance à ce rôle est automatiquement supprimée (mais les rôles
   membres ne sont pas autrement affectés). Notez néanmoins que tous les objets
   dont le groupe était propriétaire doivent d'abord être supprimés ou
   réaffectés&nbsp;; et tous les droits accordés au rôle groupe doivent être
   supprimés.
  </para>
 </sect1>

 <sect1 id="perm-functions">
  <title>Fonctions et déclencheurs (triggers)</title>

  <para>
   Les fonctions et les déclencheurs autorisent à l'intérieur du
   serveur les utilisateurs à insérer du code que d'autres
   utilisateurs peuvent exécuter sans en avoir l'intention. Par
   conséquent, les deux mécanismes permettent aux utilisateurs
   d'utiliser un <quote>cheval de Troie</quote> contre d'autres avec
   une relative facilité. La seule protection réelle est d'effectuer
   un fort contrôle sur ceux qui peuvent définir des fonctions.
  </para>

  <para>
   Les fonctions sont exécutées à l'intérieur du processus serveur avec les
   droits au niveau système d'exploitation du démon serveur de la base de
   données. Si le langage de programmation utilisé par la fonction autorise les
   accès mémoire non contrôlés, il est possible de modifier les structures de
   données internes du serveur. Du coup, parmi d'autres choses, de telles
   fonctions peuvent dépasser les contrôles d'accès au système. Les langages de
   fonctions qui permettent un tel accès sont considérées <quote>sans
   confiance</> et <productname>PostgreSQL</productname> autorise uniquement les
   superutilisateurs à écrire des fonctions dans ces langages.
  </para>
 </sect1>

</chapter>