<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/queries.sgml,v 1.11 2005/07/15 06:14:26 guillaume Exp $ -->

<chapter id="queries">
 <title>Requêtes</title>

 <indexterm zone="queries">
  <primary>requête</primary>
 </indexterm>

 <indexterm zone="queries">
  <primary>SELECT</primary>
 </indexterm>

 <para>
  Les précédents chapitres ont expliqué comme créer des tables, comment 
  les remplir avec des données et comment manipuler ces données.
  Maintenant, nous discutons enfin de la façon de récupérer ces données
  depuis la base de données.
 </para>


 <sect1 id="queries-overview">
  <title>Survol</title>

  <para>
   Le processus et la commande de récupération des données sont appelés une
   <firstterm>requête</firstterm>. En SQL, la commande
   <command>SELECT</command> est utilisé pour spécifier des requêtes. La
   syntaxe générale de la commande <command>SELECT</command> est <synopsis>
SELECT <replaceable>liste_select</replaceable> FROM
<replaceable>expression_table</replaceable>
<optional><replaceable>_specification_tri</replaceable></optional>
</synopsis>
   Les sections suivantes décrivent le détail de la liste de sélection,
   l'expression des tables et la spécification du tri.
  </para>

  <para>
   Le type de requête le plus simple est de la forme
<programlisting>
SELECT * FROM table1;
</programlisting>
  En supposant qu'il existe une table appelée <literal>table1</literal>, cette
  commande récupérera toutes les lignes et toutes les colonnes de
  <literal>table1</literal>. (La méthode de récupération dépend de l'application
  cliente. Par exemple, le programme <application>psql</application> affichera
une table, façon art ASCII, alors que les bibliothèques du client offriront 
des fonctions d'extraction de valeurs individuelles à partir du résultat de
la requête.) <literal>*</literal> comme liste de sélection signifie que toutes
les colonnes de l'expression de table seront récupérées. Une liste de sélection
peut aussi être un sous-ensemble des colonnes disponibles ou effectuer 
un calcul en utilisant les colonnes. Par exemple, si <literal>table1</literal>
dispose des colonnes nommées <literal>a</>, <literal>b</> et <literal>c</> (et
peut-être d'autres), vous pouvez lancer la requête suivante&nbsp;:
<programlisting>
SELECT a, b + c FROM table1;
</programlisting>
  (en supposant que <literal>b</> et <literal>c</> soient de type numérique).
  Voir <xref linkend="queries-select-lists"> pour plus de détails.
 </para>

 <para>
  <literal>FROM table1</literal> est un type très simple d'expression de
tables&nbsp;: il lit une seule table. En général, les expressions de tables
sont des constructions complexes de tables de base, de jointures et de
sous-requêtes. Mais vous pouvez aussi entièrement omettre l'expression de table
et utiliser la commande <command>SELECT</command> comme une calculatrice&nbsp;:
<programlisting>
SELECT 3 * 4;
</programlisting>
  Ceci est plus utile si les expressions de la liste de sélection renvoient des
  résultats variants. Par exemple, vous pouvez appeler une fonction de cette
  façon&nbsp;:
<programlisting>
SELECT random();
</programlisting>
  </para>
 </sect1>


 <sect1 id="queries-table-expressions">
  <title>Expressions de table</title>

  <indexterm zone="queries-table-expressions">
   <primary>expression de table</primary>
  </indexterm>

  <para>
   Une <firstterm>expression de table</firstterm> calcule une table.
   L'expression de table contient une clause <literal>FROM</> qui peut être
   suivie des clauses <literal>WHERE</>, <literal>GROUP BY</> et
   <literal>HAVING</>. Les expressions de table triviales réfèrent simplement à
   une table sur le disque, une table de base, mais des expressions plus
   complexes peuvent être utilisées pour modifier ou combiner des tables de base
   de différentes façon.
  </para>

  <para>
   Les clauses optionnelles <literal>WHERE</>, <literal>GROUP BY</> et
   <literal>HAVING</> dans l'expression de table spécifient un tube de
   transformations successives réalisées sur la table dérivée de la
   clause <literal>FROM</>. Toutes ces transformations produisent une table
   virtuelle fournissant les lignes à passer à la liste de sélection qui
   choisira les lignes à afficher de la requête.
  </para>
	
  <sect2 id="queries-from">
   <title>La clause <literal>FROM</literal></title>
 
   <para>
    La clause <xref linkend="sql-from" endterm="sql-from-title"> dérive une
    table à partir d'une ou plusieurs tables données dans une liste de
    référence dont les tables sont séparées par des virgules.
<synopsis>
FROM <replaceable>reference_table</replaceable> <optional>,
<replaceable>reference_table</replaceable> <optional>, ...</optional></optional>
</synopsis>

    Une référence de table pourrait être un nom de table (avec en option
    le nom du schéma) ou une table dérivée comme une sous-requête, une table
    jointe ou une combinaison complexe de celles-ci. Si plus d'une référence de
    tables est listé dans la clause <literal>FROM</>, elle sont jointes pour
    former une table virtuelle intermédiaire qui pourrait être le sujet des
    transformations des clauses <literal>WHERE</>, <literal>GROUP BY</>,
    et <literal>HAVING</> et est finalement le résultat des expressions de
    table.
   </para>

   <indexterm>
    <primary>ONLY</primary>
   </indexterm>

   <para>
    Lorsqu'une référence de table nomme une table qui est la table parent d'une
    table suivant la hiérarchie de l'héritage, la référence de table produit les
    lignes non seulement de la table mais aussi des successeurs de cette table
    sauf si le mot clé <literal>ONLY</> précède le nom de la table. Néanmoins,
    la référence produit seulement les colonnes qui apparaissent dans la table
    nommée... toute colonne ajoutée dans une sous-table est ignorée.
   </para>

   <sect3 id="queries-join">
    <title>Tables jointes</title>

    <indexterm zone="queries-join">
     <primary>join</primary>
    </indexterm>

    <para>
     Une table jointe est une table dérivée de deux autres tables (réelles ou
     dérivées) suivant les règles du type de jointure particulier. Les
     jointures internes (inner), externes (outer) et croisées (cross) sont
     disponibles.
    </para>

    <variablelist>
     <title>Types de jointures</title>

     <varlistentry>
      <term>Jointure croisée (cross join)</term>

      <indexterm>
       <primary>jointure</primary>
       <secondary>croisée</secondary>
      </indexterm>

      <indexterm>
       <primary>join</primary>
       <secondary>cross</secondary>
      </indexterm>

      <indexterm>
       <primary>jointure croisée</primary>
      </indexterm>

      <indexterm>
       <primary>crossed joind</primary>
      </indexterm>

      <listitem>
<synopsis>
<replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</replaceable>
</synopsis>

       <para>
        Pour chaque combinaison de lignes provenant de
        <replaceable>T1</replaceable> et <replaceable>T2</replaceable>, la
        table dérivée contiendra une ligne consistant de toutes les colonnes de
        <replaceable>T1</replaceable> suivies de toutes les colonnes de
        <replaceable>T2</replaceable>. Si les tables ont respectivement N et M
        lignes, la table jointe en aura N * M.
       </para>

       <para>
        <literal>FROM <replaceable>T1</replaceable> CROSS JOIN
        <replaceable>T2</replaceable></literal> est équivalent à
        <literal>FROM <replaceable>T1</replaceable>,
        <replaceable>T2</replaceable></literal>.  C'est aussi équivalent à
        <literal>FROM <replaceable>T1</replaceable> INNER JOIN
        <replaceable>T2</replaceable> ON TRUE</literal> (voir ci-dessous).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Jointures qualifiées (qualified joins)</term>

      <indexterm>
       <primary>join</primary>
       <secondary>outer</secondary>
      </indexterm>

      <indexterm>
       <primary>outer join</primary>
      </indexterm>

      <indexterm>
       <primary>jointure</primary>
       <secondary>externe</secondary>
      </indexterm>

      <indexterm>
       <primary>jointure externe</primary>
      </indexterm>
      
      <listitem>
<synopsis>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> ON <replaceable>boolean_expression</replaceable>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> USING ( <replaceable>join column list</replaceable> )
<replaceable>T1</replaceable> NATURAL { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable>
</synopsis>
        
       <para>
        Les mots <literal>INNER</literal> et
        <literal>OUTER</literal> sont optionnelles dans toutes les formes.
        <literal>INNER</literal> est la valeur par défaut&nbsp;;
        <literal>LEFT</literal>, <literal>RIGHT</literal> et
        <literal>FULL</literal> impliquent une jointure externe.
       </para>

       <para>
        La <firstterm>condition de la jointure</firstterm> est spécifiée dans
        la clause <literal>ON</> ou <literal>USING</> ou implicitement par le
        mot <literal>NATURAL</>. La condition de jointure détermine les lignes
        des deux tables source considérées comme <quote>correspondante</quote>,
        comme l'explique le paragraphe ci-dessous.
       </para>

       <para>
        La clause <literal>ON</> est le type le plus général de condition de 
        jointure&nbsp;: il prend une expression booléenne du même genre que
        celui utilisée dans une clause <literal>WHERE</>. Une paires de lignes
        de <replaceable>T1</> et <replaceable>T2</> correspondent si
        l'expression <literal>ON</> est évaluée à vraie (true) pour ces deux
        lignes.
       </para>

       <para>
        <literal>USING</> est la notation raccourcie&nbsp;: elle prend une
        liste de noms de colonnes séparées par des virgules, que les tables
        jointes ont en commun, et forme une condition de jointure spécifiant
        l'égalité de chacune de ces paires de colonnes. De plus, la sortie de
        <literal>JOIN USING</> a une colonne pour chaque paires égales des
        colonnes en entrée, suivies par toutes les autres colonnes de chaque
        table. Du coup, <literal>USING (a, b, c)</literal> est équivalent à
        <literal>ON (t1.a = t2.a AND t1.b = t2.b AND t1.c = t2.c)</literal> avec
        l'exception que si <literal>ON</> est utilisé, il y aura deux colonnes
        <literal>a</>, <literal>b</>, puis <literal>c</> dans le résultat, alors
        qu'avec <literal>USING</>, il n'y en aurait eu qu'une de chaque.
       </para>

       <para>
        <indexterm>
	 <primary>join</primary>
	 <secondary>natural</secondary>
	</indexterm>
        <indexterm>
	 <primary>natural join</primary>
	</indexterm>
        <indexterm>
	 <primary>jointure</primary>
	 <secondary>naturelle</secondary>
	</indexterm>
        <indexterm>
	 <primary>jointure naturelle</primary>
	</indexterm>
        Enfin, <literal>NATURAL</> est un format raccourci de
        <literal>USING</>&nbsp;: il forme une liste <literal>USING</>
        consistant exactement des noms de colonnes apparaissant à la fois dans
        deux tables en entrée. Comme avec <literal>USING</>, ces colonnes
        apparaissent seulement une fois dans la table de sortie.
       </para>

       <para>
        Les types possibles de jointures qualifiées sont&nbsp;:

       <variablelist>
        <varlistentry>
         <term><literal>INNER JOIN</></term>

         <listitem>
          <para>
           Pour chaque ligne R1 de T1, la table jointe a une ligne pour chaque
           ligne de T2 satisfaisant la condition de jointure avec R1.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>LEFT OUTER JOIN</></term>

         <indexterm>
          <primary>join</primary>
          <secondary>left</secondary>
         </indexterm>

         <indexterm>
          <primary>left join</primary>
         </indexterm>

         <indexterm>
          <primary>jointure</primary>
          <secondary>gauche</secondary>
         </indexterm>

         <indexterm>
          <primary>jointure gauche</primary>
         </indexterm>

         <listitem>
          <para>
           Tout d'abord, une jointure interne est réalisée. Puis, pour chaque
           ligne de T1 qui ne satisfont pas la condition de jointure avec toutes
           les lignes de T2, une ligne jointe est ajoutée avec des valeurs
           NULL dans les colonnes de T2. Du coup, la table jointe a au moins
           une ligne pour chaque ligne de T1 quelque soient les conditions.
          </para>
         </listitem>
        </varlistentry>
         
        <varlistentry>
         <term><literal>RIGHT OUTER JOIN</></term>

         <indexterm>
          <primary>join</primary>
          <secondary>right</secondary>
         </indexterm>

         <indexterm>
          <primary>right join</primary>
         </indexterm>

         <indexterm>
          <primary>jointure</primary>
          <secondary>droite</secondary>
         </indexterm>

         <indexterm>
          <primary>jointure droite</primary>
         </indexterm>

         <listitem>
          <para>
           Tout d'abord, une jointure interne est réalisée. Puis, pour chaque
           ligne de T2 qui ne satisfait pas la condition de jointure avec une
           ligne de T1, une ligne jointe est ajoutée avec des valeurs NULL
           dans les colonnes de T1. C'est l'inverse d'une jointure gauche&nbsp;:
           la table résultante aura une ligne pour chaque ligne de T2 quelque
           soient les conditions.
          </para>
         </listitem>
        </varlistentry>
         
        <varlistentry>
         <term><literal>FULL OUTER JOIN</></term>

         <listitem>
          <para>
           Tout d'abord, une jointure interne est réalisée. Puis, pour chaque
           ligne de T1 qui ne satisfait pas la condition de jointure avec une
           ligne de T2, une ligne jointe est ajouté avec des valeurs NULL dans
           les colonnes de T2. De plus, pour chaque ligne de T2 qui ne satisfait
           pas la condition de jointure avec les lignes de T1, une ligne jointe
           est ajoutée avec des valeurs NULL dans les colonnes de T1.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    <para>
     Les jointures de tous les types peuvent être chaînées ensemble ou
     imbriquées&nbsp;: soit les deux soit une des deux, parmi
     <replaceable>T1</replaceable> et <replaceable>T2</replaceable>, pourraient
     être des tables. Les parenthèses peuvent être utilisées autour des clauses
     <literal>JOIN</> pour contrôler l'ordre de jointure. En l'absence de
     parenthèses, les clauses <literal>JOIN</> sont imbriquées de gauche à
     droite.
    </para>

    <para>
     Pour rassembler tout ceci, supposons que nous avons une table
     <literal>t1</literal>
<programlisting>
 num | name
-----+------
   1 | a
   2 | b
   3 | c
</programlisting>
     et une table <literal>t2</literal>
<programlisting>
 num | value
-----+-------
   1 | xxx
   3 | yyy
   5 | zzz
</programlisting>
     nous obtenons les résultats suivants des différentes jointures&nbsp;:
<screen>
<prompt>=&gt;</> <userinput>SELECT * FROM t1 CROSS JOIN t2;</>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   1 | a    |   3 | yyy
   1 | a    |   5 | zzz
   2 | b    |   1 | xxx
   2 | b    |   3 | yyy
   2 | b    |   5 | zzz
   3 | c    |   1 | xxx
   3 | c    |   3 | yyy
   3 | c    |   5 | zzz
(9 rows)

<prompt>=&gt;</> <userinput>SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;</>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
(2 rows)

<prompt>=&gt;</> <userinput>SELECT * FROM t1 INNER JOIN t2 USING (num);</>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<prompt>=&gt;</> <userinput>SELECT * FROM t1 NATURAL INNER JOIN t2;</>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<prompt>=&gt;</> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;</>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
(3 rows)

<prompt>=&gt;</> <userinput>SELECT * FROM t1 LEFT JOIN t2 USING (num);</>
 num | name | value
-----+------+-------
   1 | a    | xxx
   2 | b    |
   3 | c    | yyy
(3 rows)

<prompt>=&gt;</> <userinput>SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;</>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
     |      |   5 | zzz
(3 rows)

<prompt>=&gt;</> <userinput>SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;</>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
     |      |   5 | zzz
(4 rows)
</screen>
    </para>

    <para>
     La condition de jointure spécifiée avec <literal>ON</> peut aussi contenir
     des conditions sans relation directe avec la jointure. Ceci peut prouver
     son utilité pour quelques requêtes mais son utilisation doit avoir été
     réfléchie. Par exemple&nbsp;:
<screen>
	<prompt>=&gt;</> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';</>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |     |
(3 rows)
</screen>
    </para>
   </sect3>

   <sect3 id="queries-table-aliases">
    <title>Alias de table et de colonne</title>

    <indexterm zone="queries-table-aliases">
     <primary>alias</primary>
     <secondary>dans la clause FROM</secondary>
    </indexterm>

    <indexterm>
     <primary>label</primary>
     <see>alias</see>
    </indexterm>

    <para>
     Un nom temporaire peut être donné aux tables et aux références de tables
     complexe, qui sera ensuite utilisé pour référencer la table dérivée dans la
     suite de la requête. Cela s'appelle un <firstterm>alias de
     table</firstterm>.
    </para>

    <para>
     Pour créer un alias de table, écrivez
<synopsis>
FROM <replaceable>reference_table</replaceable> AS
<replaceable>alias</replaceable>
</synopsis>
     or
<synopsis>
FROM <replaceable>reference_table</replaceable> <replaceable>alias</replaceable>
</synopsis>
     Le mot clé <literal>AS</literal> est du bruit.
     <replaceable>alias</replaceable> peut être tout identifiant.
    </para>

    <para>
     Une application typique des alias de table est l'affectation d'identifieurs
     cours pour les noms de tables longs, ce qui permet de garder des clauses de
     jointures lisibles. Par exemple&nbsp;:
<programlisting>
SELECT * FROM nom_de_table_tres_tres_long s JOIN un_autre_nom_trs_long a ON
s.id = a.num;
</programlisting>
    </para>

    <para>
     L'alias devient le nouveau nom de la référence de la table pour la requête
     courante &mdash; il n'est plus possible de référencer la table avec son nom
     d'origine. Du coup,
<programlisting>
SELECT * FROM ma_table AS m WHERE ma_table.a &gt; 5;
</programlisting>
     n'est pas valide pour une syntaxe SQL. Ce qui va réellement se passer
     (c'est une extension de <productname>PostgreSQL</productname> au standard)
     est qu'une référence de table implicite est ajoutée à la clause
     <literal>FROM</literal>, de façon à ce que la requête soit exécutée comme
     si elle était écrite ainsi
<programlisting>
SELECT * FROM ma_table AS m, ma_table AS ma_table WHERE ma_table.a &gt; 5;
</programlisting>
     ce qui résultera en une jointure croisée, ce qui n'est habituellement pas
     ce que vous voulez.
    </para>

    <para>
     Les alias de table sont disponibles principalement pour aider à l'écriture
     de requête mais ils deviennent nécessaires pour joindre une table avec
     elle-même, par exemple
<programlisting>
SELECT * FROM ma_table AS a CROSS JOIN ma_table AS b ...
</programlisting>
     De plus, un alias est requis si la référence de la table est une
     sous-requête (voir <xref linkend="queries-subqueries">).
    </para>

    <para>
     Les parenthèses sont utilisées pour résoudre les ambiguïtés. L'instruction
     suivante affectera l'alias <literal>b</literal> au résultat de la jointure
     contrairement à l'exemple précédente&nbsp;:
<programlisting>
SELECT * FROM (ma_table AS a CROSS JOIN ma_table) AS b ...
</programlisting>
    </para>

    <para>
     Une autre forme d'alias de tables donne des noms temporaires aux colonnes
     de la table ainsi qu'à la table&nbsp;:
<synopsis>
FROM <replaceable>reference_table</replaceable> <optional>AS</optional>
<replaceable>alias</replaceable> ( <replaceable>colonne1</replaceable>
<optional>, <replaceable>colonne2</replaceable> <optional>,
...</optional></optional> )
</synopsis>
     Si le nombre d'alias de colonnes spécifié est plus petit que le nombre
     de colonnes dont dispose la table réelle, les colonnes suivantes ne sont
     pas renommées. Cette syntaxe est particulièrement utile dans le cas de
     jointure de même table ou dans le cas de sous-requêtes.
    </para>

    <para>
     Quand un alias est appliqué à la sortie d'une clause <literal>JOIN</> en
utilisant n'importe laquelle de ces formes, l'alias cache le nom original à
l'intérieur du <literal>JOIN</>. Par exemple,
<programlisting>
SELECT a.* FROM ma_table AS a JOIN ta_table AS b ON ...
</programlisting>
     est du SQL valide mais
<programlisting>
SELECT a.* FROM (ma_table AS a JOIN ta_table AS b ON ...) AS c
</programlisting>
     n'est pas valide&nbsp;: l'alias de table <literal>a</> n'est pas visible
     en dehors de l'alias <literal>c</>.
    </para>
   </sect3>

   <sect3 id="queries-subqueries">
    <title>Sous-requêtes</title>

    <indexterm zone="queries-subqueries">
     <primary>sous-requête</primary>
    </indexterm>

    <para>
     Une sous-requête spécifiant une table dérivée doit être enfermée 
     dans des parenthèses et <emphasis>doit</emphasis> se voir affecté un alias 
     de table. (Voir <xref linkend="queries-table-aliases">.) Par exemple&nbsp;:
<programlisting>
FROM (SELECT * FROM table1) AS nom_alias
</programlisting>
    </para>

    <para>
     Cette exemple est équivalent à <literal>FROM table1 AS
     nom_alias</literal>. Des cas plus intéressants, qui ne peuvent pas être
     réduit à une jointure pleine, arrivent quand la sous-requête implique un
     groupement ou une agrégat.
    </para>
   </sect3>

   <sect3 id="queries-tablefunctions">
    <title>Fonctions de table</title>

    <indexterm zone="queries-tablefunctions"><primary>fonction de table</></>

    <indexterm zone="queries-tablefunctions">
     <primary>fonction</>
     <secondary>dans la clause FROM</>
    </indexterm>

    <para>
     Les fonctions de table sont des fonctions produisant un ensemble de
     lignes composées de types de données de base (types scalaires) ou de types
     de données composés (lignes de table). Elles sont utilisées comme une
     table, une vue ou une sous-requête de la clause <literal>FROM</> d'une
     requête. Les colonnes renvoyées par les fonctions de table peuvent être
     incluses dans une clause <literal>SELECT</>, <literal>JOIN</> ou
     <literal>WHERE</> de la même manière qu'une colonne de table, vue ou
     sous-requête.
    </para>

    <para>
     Si une fonction de table renvoie un type de données de base, la colonne
     de résultat est nommée comme la fonction. Si la fonction renvoie un type
     composite, les colonnes résultants ont le même nom que les attributs
     individuels du type.
    </para>

    <para>
     Une fonction de table pourrait avoir un alias dans la clause
     <literal>FROM</> mais elle pourrait être laissée sans alias. Si une
     fonction est utilisée dans la clause <literal>FROM</> sans alias, le nom de
     la fonction est utilisé comme nom de table résultante.
    </para>

    <para>
     Quelques exemples&nbsp;:
<programlisting>
CREATE TABLE truc (trucid int, trucsousid int, trucnom text);

CREATE FUNCTION recuptruc(int) RETURNS SETOF foo AS $$
    SELECT * FROM truc WHERE trucid = $1;
$$ LANGUAGE SQL;

SELECT * FROM recuptruc(1) AS t1;

SELECT * FROM truc
    WHERE trucsousid IN (select trucsousid from recuptruc(truc.trucid) z
                           where z.trucid = truc.trucid);

CREATE VIEW vue_recuptruc AS SELECT * FROM recuptruc(1);
SELECT * FROM vue_recuptruc;
</programlisting>
    </para>

    <para>
     Dans certains cas, il est utile de définir des fonctions de table pouvant
     renvoyer des ensembles de colonnes différentes suivant la façon dont elles
     sont appelées. Pour supporter ceci, la fonction de table est déclarée comme
     renvoyant le pseudotype <type>record</>. Quand une telle fonction est
     utilisée dans une requête, la structure de ligne attendue doit être
     spécifiée dans la requête elle-même, de façon à ce que le système sache
     comment analyser et planifier la requête. Considérez cet exemple&nbsp;:
<programlisting>
SELECT *
    FROM dblink('dbname=mabd', 'select proname, prosrc from pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';
</programlisting>
     La fonction <literal>dblink</> exécute une requête distante (voir
     <filename>contrib/dblink</>). Elle déclare renvoyer le type
     <type>record</> car elle pourrait être utilisée pour tout type de requête.
     L'ensemble de colonnes réelles doit être spécifié dans la requête appelant
     de façon à ce que l'analyseur sache, par exemple, ce que comment
     étendre <literal>*</>.
    </para>
   </sect3>
  </sect2>

  <sect2 id="queries-where">
   <title>La clause <literal>WHERE</literal></title>

   <indexterm zone="queries-where">
    <primary>WHERE</primary>
   </indexterm>

   <para>
    La syntaxe de <xref linkend="sql-where" endterm="sql-where-title"> est
<synopsis>
WHERE <replaceable>condition_recherche</replaceable>
</synopsis>
    où <replaceable>condition_recherche</replaceable> est toute expression de
    valeur (voir <xref linkend="sql-expressions">) renvoyant une valeur
    de type <type>boolean</type>.
   </para>

   <para>
    Après la réalisation de la clause <literal>FROM</>, chaque ligne de la
    table virtuelle dérivée est vérifiée avec la condition de recherche. Si le
    résultat de la vérification est positive (true), la ligne est conservée dans
    la table de sortie, sinon (c'est-à-dire si le résultat est faux ou nul, la
    ligne est abandonnée. La condition de recherche référence typiquement au
    moins quelques colonnes de la table générée dans la clause
    <literal>FROM</>&nbsp;; ceci n'est pas requis mais, dans le cas contraire,
    la clause <literal>WHERE</> n'aurait aucune utilité.
   </para>

   <note>
    <para>
     La condition de jointure d'une jointure interne peut être écrite soit dans
     la clause <literal>WHERE</> soit dans la clause <literal>JOIN</>. Par
     exemple, ces expressions de tables sont équivalentes&nbsp;:
<programlisting>
FROM a, b WHERE a.id = b.id AND b.val &gt; 5
</programlisting>
     et
<programlisting>
FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5
</programlisting>
     ou même peut-être
<programlisting>
FROM a NATURAL JOIN b WHERE b.val &gt; 5
</programlisting>
     Laquelle vous utilisez est plutôt une affaire de style. La syntaxe
     <literal>JOIN</> dans la clause <literal>FROM</> n'est probablement pas
     aussi portable vers les autres systèmes de gestion de bases de données SQL.
     Pour les jointures externes, il n'y a pas d'autres choix&nbsp;: elles
     doivent être faites dans la clause <literal>FROM</> clause. Une clause
     <literal>ON</>/<literal>USING</> d'une jointure externe n'est
     <emphasis>pas</> équivalente à une condition <literal>WHERE</> parce
     qu'elle détermine l'ajout de lignes (pour les lignes qui ne correspondent
     pas en entrée) ainsi que pour la suppression de lignes dans le résultat
     final.
    </para>
   </note>

   <para>
    Voici quelques exemples de clauses <literal>WHERE</literal>&nbsp;:
<programlisting>
SELECT ... FROM fdt WHERE c1 &gt; 5

SELECT ... FROM fdt WHERE c1 IN (1, 2, 3)

SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)

SELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)

SELECT ... FROM fdt WHERE c1 BETWEEN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100

SELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &gt; fdt.c1)
</programlisting>
    <literal>fdt</literal> est la table dérivée dans la clause
    <literal>FROM</>. Les lignes qui ne correspondent pas à la condition de la
    recherche de la clause <literal>WHERE</> sont éliminées de la table
    <literal>fdt</literal>. Notez l'utilisation de sous-requêtes scalaires en
    tant qu'expressions de valeurs. Comme n'importe quelle autre requête, les
    sous-requêtes peuvent employer des expressions de tables complexes. Notez
    aussi comment <literal>fdt</literal> est référencée dans les sous-requêtes.
    Qualifier <literal>c1</> comme <literal>fdt.c1</> est seulement nécessaire
    si <literal>c1</> est aussi le nom d'une colonne dans la table d'entrée
    dérivée de la sous-requête. Mais qualifier le nom de colonne ajoute à la
    clarté même lorsque cela n'est pas nécessaire. Cet exemple montre comment
    le nom de colonne d'une requête externe est étendue dans les requêtes
    internes.
   </para>
  </sect2>


  <sect2 id="queries-group">
   <title>Les clauses <literal>GROUP BY</literal> et
<literal>HAVING</literal></title>

   <indexterm zone="queries-group">
    <primary>GROUP BY</primary>
   </indexterm>

   <indexterm zone="queries-group">
    <primary>groupement</primary>
   </indexterm>

   <para>
    Après avoir passé le filtre <literal>WHERE</>, la table d'entrée dérivée
    peut être sujette à un regroupement en utilisant la clause <literal>GROUP
    BY</> et à une élimination de groupe de lignes avec la clause
    <literal>HAVING</>.
   </para>

<synopsis>
SELECT <replaceable>liste_selection</replaceable>
    FROM ...
    <optional>WHERE ...</optional>
    GROUP BY <replaceable>reference_colonne_regroupement</replaceable>
<optional>,
<replaceable>reference_colonne_regroupement</replaceable></optional>...
</synopsis>

   <para>
    La clause <xref linkend="sql-groupby" endterm="sql-groupby-title"> est
    utilisée pour regrouper des lignes d'une table partageant les mêmes valeurs
    dans toutes les colonnes précisées. L'ordre dans lequel ces colonnes sont
    indiquées importe peu. L'effet est de combiner chaque ensemble de lignes
    partageant des valeurs communes en un seul groupe de ligne représentant
    toutes les lignes du groupe. Ceci se fait en éliminant les redondances dans
    la sortie et/ou pour calculer les agrégats s'appliquant à ces groupes. Par
    exemple&nbsp;:
<screen>
<prompt>=&gt;</> <userinput>SELECT * FROM test1;</>
 x | y
---+---
 a | 3
 c | 2
 b | 5
 a | 1
(4 rows)

<prompt>=&gt;</> <userinput>SELECT x FROM test1 GROUP BY x;</>
 x
---
 a
 b
 c
(3 rows)
</screen>
   </para>
	  
   <para>
    Dans la seconde requête, nous n'aurions pas pu écrire <literal>SELECT *
    FROM test1 GROUP BY x</literal> parce qu'il n'existe pas une seule valeur
    pour la colonne <literal>y</> pouvant être associé avec chaque autre groupe.
    Les colonnes de regroupement peuvent être référencées dans la liste de
    sélection car elles ont une valeur constante unique par groupe.
   </para>

   <para>
    En général, si une table est groupée, les colonnes qui ne sont pas
    utilisées dans le regroupement ne peuvent pas être référencées sauf dans les
    expressions d'agrégats. Voici un exemple d'expressions d'agrégat&nbsp;:
<screen>
<prompt>=&gt;</> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x;</>
 x | sum
---+-----
 a |   4
 b |   5
 c |   2
(3 rows)
</screen>
    Ici, <literal>sum</literal> est la fonction d'agrégat qui calcule une seule
    valeur pour le groupe entier. Plus d'informations sur les fonctions
    d'agrégats disponibles sont proposées dans <xref
    linkend="functions-aggregate">.
   </para>

   <tip>
    <para>
     Le regroupement sans expressions d'agrégats calcule effectivement
     l'ensemble les valeurs distinctes d'une colonne. Ceci peut aussi se faire
     en utilisant la clause <literal>DISTINCT</> (voir <xref
     linkend="queries-distinct">).
    </para>
   </tip>

   <para>
    Voici un autre exemple&nbsp;: il calcule les ventes totales pour chaque
    produit (plutôt que le total des ventes sur tous les produits).
<programlisting>
SELECT produit_id, p.nom, (sum(v.unite) * p.prix) AS ventes
    FROM produits p LEFT JOIN ventes v USING (produit_id)
    GROUP BY produit_id, p.nom, p.prix;
</programlisting>
    Dans cet exemple, les colonnes <literal>produit_id</literal>,
    <literal>p.nom</literal> et <literal>p.prix</literal> doivent être dans la
    clause <literal>GROUP BY</> car elles sont référencées dans la liste de
    sélection de la requête. (Suivant la façon dont est conçue la table
    produits, le nom et le prix pourraient être totalement dépendants de l'ID du
    produit, donc des regroupements supplémentaires pourraient théoriquement
    être inutiles mais ceci n'est pas encore implémenté.) La colonne
    <literal>s.unite</> n'a pas besoin d'être dans la liste <literal>GROUP
    BY</> car elle est seulement utilisée dans l'expression de l'agrégat
    (<literal>sum(...)</literal>) représentant les ventes d'un produit. Pour
    chaque produit, la requête renvoie une ligne de résumé sur les ventes de ce
    produit.
   </para>

   <para>
    En SQL strict, <literal>GROUP BY</> peut seulement grouper les colonnes de
    la table source mais <productname>PostgreSQL</productname> étend ceci en
    autorisant <literal>GROUP BY</> à grouper aussi les colonnes de la liste de
    sélection. Grouper par expressions de valeurs au lieu de simples noms de
    colonnes est aussi permis.
   </para>

   <indexterm>
    <primary>HAVING</primary>
   </indexterm>

   <para>
    Si une table a été groupée en utilisant la clause <literal>GROUP
    BY</literal> mais que seul certains groupes sont intéressants, la clause
    <literal>HAVING</literal> peut être utilisée, plus comme une clause
    <literal>WHERE</>, pour éliminer les groupes d'une table groupée. Voici la
    syntaxe&nbsp;:
<synopsis>
SELECT <replaceable>liste_selection</replaceable> FROM ... <optional>WHERE
...</optional> GROUP BY ... HAVING
<replaceable>expression_booléenne</replaceable>
</synopsis>
    Les expressions de la clause <literal>HAVING</> peuvent référer à la fois
    aux expressions groupées et aux expressions non groupées (ce qui impliquent
    nécessairement une fonction d'agrégat).
   </para>

   <para>
    Exemple&nbsp;:
<screen>
<prompt>=&gt;</> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) > 3;</>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)

<prompt>=&gt;</> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING x < 'c';</>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)
</screen>
   </para>

   <para>
    De nouveau, un exemple plus réaliste&nbsp;:
<programlisting>
SELECT produit_id, p.nom, (sum(v.unite) * (p.prix - p.cout)) AS profit
    FROM produits p LEFT JOIN ventes v USING (produit_id)
    WHERE v.date &gt; CURRENT_DATE - INTERVAL '4 weeks'
    GROUP BY produit_id, p.nom, p.prix, p.cout
    HAVING sum(p.prix * s.unite) &gt; 5000;
</programlisting>
    Dans l'exemple ci-dessus, la clause <literal>WHERE</> sélectionne les
    lignes par une colonne qui n'est pas groupée (l'expression est vraie
    seulement pour les ventes des quatre dernières semaines) alors que la
    clause <literal>HAVING</> restreint la sortie aux groupes dont le total des
    ventes dépasse 5000. Notez que les expressions d'agrégats n'ont pas besoin
    d'être identiques dans toutes les parties d'une requête.
   </para>
  </sect2>
 </sect1>


 <sect1 id="queries-select-lists">
  <title>Listes de sélection</title>

  <indexterm>
   <primary>SELECT</primary>
   <secondary>liste de sélection</secondary>
  </indexterm>

  <para>
   Comme montré dans la section précédente, l'expression de table pour la
commande <command>SELECT</command> construit une table virtuelle intermédiaire
en combinant les tables, vues, en éliminant les lignes, en groupant, etc. Cette
table est finalement passée à la réalisation de la <firstterm>liste de
sélection</firstterm>. Cette liste détermine les <emphasis>colonnes</emphasis>
de la table intermédiaire à afficher.
  </para>

  <sect2 id="queries-select-list-items">
   <title>Éléments de la liste de sélection</title>

   <indexterm>
    <primary>*</primary>
   </indexterm>

   <para>
    La forme la plus simple de liste de sélection est <literal>*</literal> qui
    émet toutes les colonnes que l'expression de table produit. Sinon, une liste
    de sélection est une liste d'expressions de valeurs séparées par des
    virgules (comme défini dans <xref linkend="sql-expressions">). Par exemple,
    cela pourrait être une liste des noms de colonnes&nbsp;:
<programlisting>
SELECT a, b, c FROM ...
</programlisting>
     Les noms de colonnes <literal>a</>, <literal>b</> et <literal>c</> sont
     soit les noms actuels des colonnes des tables référencées dans la clause
     <literal>FROM</> soit les alias qui leur ont été donnés (voir l'explication
     dans <xref linkend="queries-table-aliases">). L'espace de nom disponible
     dans la liste de sélection est le même que dans la clause <literal>WHERE</>
     sauf si le regroupement est utilisé, auquel cas c'est le même que dans la
     clause <literal>HAVING</>.
   </para>

   <para>
    Si plus d'une table a une colonne du même nom, le nom de la table doit
aussi être donné comme dans
<programlisting>
SELECT tbl1.a, tbl2.a, tbl1.b FROM ...
</programlisting>
    En travaillant avec plusieurs tables, il est aussi utile de demander toutes
    les colonnes d'une table particulière&nbsp;:
<programlisting>
SELECT tbl1.*, tbl2.a FROM ...
</programlisting>
    (Voir aussi <xref linkend="queries-where">.)
   </para>

   <para>
    Si une expression de valeur arbitraire est utilisée dans la liste de
    sélection, il ajoute conceptuellement une nouvelle colonne virtuelle dans la
    table renvoyée. L'expression de valeur est évaluée une fois pour chaque
    ligne avec une substitution des valeurs de lignes avec les références de
    colonnes. Mais les expressions de la liste de sélection n'ont pas à
    référencer les colonnes dans l'expression de la table de la clause
    <literal>FROM</>&nbsp;; elles pourrait être des expressions arithmétiques
    constantes, par exemple.
   </para>
  </sect2>

  <sect2 id="queries-column-labels">
   <title>Labels de colonnes</title>

   <indexterm zone="queries-column-labels">
    <primary>alias</primary>
    <secondary>dans la liste de sélection</secondary>
   </indexterm>

   <para>
    Les entrées dans la liste de sélection peuvent se voir affecter des noms
    pour la suite de l'exécution. La <quote>suite de l'exécution</quote> dans ce
    cas est une spécification optionnelle du tri et l'application client
    (c'est-à-dire les en-têtes de colonne pour l'affichage). Par exemple&nbsp;:
<programlisting>
SELECT a AS value, b + c AS sum FROM ...
</programlisting>
   </para>

   <para>
    Si aucun nom de colonne en sortie n'est spécifié en utilisant
    <literal>AS</>, le système affecte un nom par défaut. Pour les références de
    colonne simple, c'est le nom de la colonne référencée. Pour les appels de
    fonction, il s'agit du nom de la fonction. Pour les expressions complexes,
    le système générera un nom générique.
   </para>

   <note>
    <para>
     Le nom des colonnes en sortie est différent ici de ce qui est fait dans la
     clause <literal>FROM</> (voir <xref linkend="queries-table-aliases">). Ce
     tube vous permettra en fait de renommer deux fois la même colonne mais le
     nom choisi dans la liste de sélection est celui qui sera passé.
    </para>
   </note>
  </sect2>

  <sect2 id="queries-distinct">
   <title><literal>DISTINCT</literal></title>

   <indexterm zone="queries-distinct">
    <primary>DISTINCT</primary>
   </indexterm>

   <indexterm zone="queries-distinct">
    <primary>duplication</primary>
   </indexterm>

   <para>
    Après la réalisation de la liste de sélection, la table résultant pourrait
    être optionnellement sujet à l'élimination des lignes dupliquées. Le mot clé
    <literal>DISTINCT</literal> est écrit directement après
    <literal>SELECT</literal> pour spécifier ceci&nbsp;:
<synopsis>
SELECT DISTINCT <replaceable>liste_selection</replaceable> ...
</synopsis>
    (Au lieu de <literal>DISTINCT</>, le mot clé <literal>ALL</literal> peut être
    utilisé pour spécifier le comportement par défaut, la récupération de
    toutes les lignes.)
   </para>

   <para>
    <indexterm><primary>valeur NULL</><secondary sortas="DISTINCT">dans
    DISTINCT</></indexterm>
    Évidemment, les deux lignes sont considérées distinctes si elles diffèrent
    dans au moins une valeur de colonne. Les valeurs NULL sont considérées
    égales dans cette comparaison.
   </para>

   <para>
    Alternativement, une expression arbitraire peut déterminer quelles lignes
    doivent être considérées distinctes&nbsp;:
<synopsis>
SELECT DISTINCT ON (<replaceable>expression</replaceable> <optional>,
<replaceable>expression</replaceable> ...</optional>)
<replaceable>liste_selection</replaceable> ...
</synopsis>
    Ici, <replaceable>expression</replaceable> est une expression de valeur
    arbitraire, évaluée pour toutes les lignes. Les lignes dont toutes les
    expressions sont égales sont considérées comme dupliquées et seule la
    première ligne de cet ensemble est conservée dans la sortie. Notez que la
    <quote>première ligne</quote> d'un ensemble est non prévisible sauf si la
    requête est triée sur assez de colonnes pour garantir une ordre unique des
    colonnes arrivant dans le filtre <literal>DISTINCT</>. (Le traitement de
    <literal>DISTINCT ON</> parvient après le tri de <literal>ORDER BY</>.)
   </para>

   <para>
    La clause <literal>DISTINCT ON</> ne fait pas partie du standard SQL et est
    quelque fois considéré comme étant un mauvais style à cause de la nature
    potentiellement indéterminée de ses résultats. Avec l'utilisation judicieuse
    de <literal>GROUP BY</> et de sous-requêtes dans <literal>FROM</>, la
    construction peut être évitée mais elle représente souvent l'alternative la
    plus agréable.
   </para>
  </sect2>
 </sect1>


 <sect1 id="queries-union">
  <title>Combiner des requêtes</title>

  <indexterm zone="queries-union">
   <primary>UNION</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>INTERSECT</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>EXCEPT</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set union</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set intersection</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set difference</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set operation</primary>
  </indexterm>

  <para>
   Les résultats de deux requêtes peuvent être combinés en utilisant les 
   opérations d'ensemble&nbsp;: union, intersection et différence. La syntaxe
   est
<synopsis>
<replaceable>requete1</replaceable> UNION <optional>ALL</optional>
<replaceable>requete2</replaceable>
<replaceable>requete1</replaceable> INTERSECT <optional>ALL</optional>
<replaceable>requete2</replaceable>
<replaceable>requete1</replaceable> EXCEPT <optional>ALL</optional>
<replaceable>requete2</replaceable>
</synopsis>
   <replaceable>requete1</replaceable> et
   <replaceable>requete2</replaceable> sont les requêtes pouvant utiliser
   toutes les fonctionnalités discutées ici. Les opérations d'ensemble peuvent
   aussi être combinées et chaînées, par exemple
<synopsis>
<replaceable>requete1</replaceable> UNION <replaceable>requete2</replaceable>
UNION <replaceable>requete3</replaceable>
</synopsis>
   signifie réellement
<synopsis>
(<replaceable>requete1</replaceable> UNION <replaceable>requete2</replaceable>)
UNION <replaceable>requete3</replaceable>
</synopsis>
  </para>

  <para>
   <literal>UNION</> ajoute effectivement le résultat de
   <replaceable>requete2</replaceable> au résultat de
   <replaceable>requete1</replaceable> (bien qu'il n'y ait pas de garantie
   qu'il s'agit de l'ordre dans lequel les lignes sont réellement renvoyées). De
   plus, il élimine les lignes dupliquées du résultat, de la même façon que
   <literal>DISTINCT</>, sauf si <literal>UNION ALL</> est utilisée.
  </para>

  <para>
   <literal>INTERSECT</> renvoie toutes les lignes qui sont à la fois dans le
   résultat de <replaceable>requete1</replaceable> et dans le résultat de
   <replaceable>requete2</replaceable>. Les lignes dupliquées sont éliminées
   sauf si <literal>INTERSECT ALL</> est utilisé.
  </para>

  <para>
   <literal>EXCEPT</> renvoie toutes les lignes qui sont dans le résultat de
   <replaceable>requete1</replaceable> mais pas dans le résultat de
   <replaceable>requete2</replaceable>. (Ceci est quelque fois appelé la
   <firstterm>différence</> entre deux requêtes.) De nouveau, les lignes
   dupliquées sont éliminées sauf si <literal>EXCEPT ALL</> est utilisé.
  </para>

  <para>
   Pour calculer l'union, l'intersection ou la différence de deux requêtes, les
   deux requêtes doivent être <quote>compatibles pour une union</quote>, ce qui
   signifie qu'elles doivent renvoyer le même nombre de colonnes et que les
   colonnes correspondantes doivent avoir des types de données compatibles,
   comme décrit dans <xref linkend="typeconv-union-case">.
  </para>
 </sect1>


 <sect1 id="queries-order">
  <title>Tri de lignes</title>

  <indexterm zone="queries-order">
   <primary>tri</primary>
  </indexterm>

  <indexterm zone="queries-order">
   <primary>ORDER BY</primary>
  </indexterm>
	   
  <para>
   Après qu'une requête ait produit une table en sortie (après que la liste de
   sélection ait été traitée), elle peut être optionnellement triée. Si le tri
   n'a pas été choisi, les lignes sont renvoyées dans un ordre non spécifié.
   L'ordre réel dans ce cas dépendra des types de plan de parcours et de
   jointure et de l'ordre sur le disque mais vous ne devez pas vous y fier. Un
   tri particulier en sortie peut seulement être garantie si l'étape de tri est
   choisie explicitement.
  </para>

  <para>
   La clause <literal>ORDER BY</> spécifie l'ordre de tri&nbsp;:
<synopsis>
SELECT <replaceable>liste_selection</replaceable>
    FROM <replaceable>expression_table</replaceable>
    ORDER BY <replaceable>colonne1</replaceable> <optional>ASC | DESC</optional>
<optional>, <replaceable>colonne2</replaceable> <optional>ASC | DESC</optional>
...</optional>
</synopsis>
   <replaceable>colonne1</replaceable>, etc. réfèrent les colonnes de la liste
   de sélection. Ceci peut soit être le nom de sortie d'une colonne (voir
   <xref linkend="queries-column-labels">) ou le numéro d'une colonne. Voici
   quelques exemples&nbsp;:
<programlisting>
SELECT a, b FROM table1 ORDER BY a;
SELECT a + b AS sum, c FROM table1 ORDER BY sum;
SELECT a, sum(b) FROM table1 GROUP BY a ORDER BY 1;
</programlisting>
  </para>

  <para>
   Comme une extension du standard SQL, <productname>PostgreSQL</productname>
   autorise aussi l'ordre des expressions arbitraires&nbsp;:
<programlisting>
SELECT a, b FROM table1 ORDER BY a + b;
</programlisting>
   Les références des noms de colonnes dans la clause <literal>FROM</>,
   absentes de la liste de sélection, sont aussi autorisées&nbsp;:
<programlisting>
SELECT a FROM table1 ORDER BY b;
</programlisting>
   Mais ces extensions ne fonctionnent pas dans les requêtes impliquant
   <literal>UNION</>, <literal>INTERSECT</> ou <literal>EXCEPT</> et ne sont
   pas portables dans les autres bases de données SQL.
  </para>

  <para>
   Chaque spécification de colonne pourrait être suivie d'un
   <literal>ASC</> ou <literal>DESC</> optionnelle pour initialiser la
   direction du tri (ascendant ou descendant). L'ordre <literal>ASC</> est la
   valeur par défaut. L'ordre ascendant place les plus petites valeurs en
   premier où <quote>plus petit</quote> est défini en terme de l'opérateur
   <literal>&lt;</literal>. De façon similaire, l'ordre descendant est
   déterminé avec l'opérateur <literal>&gt;</literal>.
    <footnote>
     <para>
      En fait, <productname>PostgreSQL</> utilise la <firstterm>classe
      d'opérateur B-tree par défaut</> pour le type de données de la colonne 
      pour déterminer l'ordre de tri avec <literal>ASC</> et <literal>DESC</>.
      De façon conventionnelle, les types de données seront initialisés de
      façon à ce que les opérateurs <literal>&lt;</literal> et
      <literal>&gt;</literal> correspondent à cet ordre de tri mais un
      concepteur des types de données définis par l'utilisateur pourrait choisir
      de faire quelque chose de différent.
     </para>
    </footnote>
  </para>

  <para>
   Si plus d'une colonne de tri est spécifiée, les entrées suivantes sont
   utilisées pour trier les lignes qui sont égales sous l'ordre imposé par les
   colonnes de tri précédent.
  </para>
 </sect1>


 <sect1 id="queries-limit">
  <title><literal>LIMIT</literal> et <literal>OFFSET</literal></title>

  <indexterm zone="queries-limit">
   <primary>LIMIT</primary>
  </indexterm>

  <indexterm zone="queries-limit">
   <primary>OFFSET</primary>
  </indexterm>

  <para>
   <literal>LIMIT</> et <literal>OFFSET</> vous permet de retrouver seulement 
   une portion des lignes générées par le reste de la requête&nbsp;:
<synopsis>
SELECT <replaceable>liste_selection</replaceable>
    FROM <replaceable>expression_table</replaceable>
    <optional>LIMIT { <replaceable>numero</replaceable> | ALL }</optional>
<optional>OFFSET <replaceable>numero</replaceable></optional>
</synopsis>
  </para>

  <para>
   Si un nombre limite est donné, pas plus que ce nombre de lignes sera renvoyé
   (mais peut-être moins si la requête récupère moins de lignes). <literal>LIMIT
   ALL</> est indique à ne pas spécifier la clause <literal>LIMIT</>.
  </para>

  <para>
   <literal>OFFSET</> indique de passer ce nombre de lignes avant de renvoyer 
   les lignes restantes. <literal>OFFSET 0</> est identique à oublier la clause
   <literal>OFFSET</>. Si à la fois <literal>OFFSET</> et <literal>LIMIT</>
   apparaissent, alors les <literal>OFFSET</> lignes sont laissés avant de
   commencer le renvoi des <literal>LIMIT</> lignes.
  </para>

  <para>
   Lors de l'utilisation de <literal>LIMIT</>, il est important d'utiliser une
   clause <literal>ORDER BY</> contraignant les lignes résultantes dans un ordre
   unique. Sinon, vous obtiendrez un sous-ensemble non prévisible de lignes de
   la requête. Vous pourriez demander des lignes 10 à 20 mais dans quel
   ordre&nbsp;? L'ordre est inconnu si vous ne spécifiez pas <literal>ORDER
   BY</>.
  </para>

  <para>
   L'optimiseur de requêtes prend <literal>LIMIT</> en compte lors de la
   génération d'un plan de requêtes, de façon à ce que vous obtenez
   différents plans (avec différents ordres de lignes) suivant ce que vous
   donnez à <literal>LIMIT</> et <literal>OFFSET</>. Du coup, utiliser des
   valeurs <literal>LIMIT</>/<literal>OFFSET</> différentes pour sélectionner
   des sous-ensembles différents d'un résultat de requête <emphasis>donnera des
   résultats inconsistants</emphasis> sauf si vous forcez un ordre de
   résultat prévisible avec <literal>ORDER BY</>. Ceci n'est pas un bogue&nbsp;;
   c'est une conséquence inhérente du fait que le SQL ne promette par de
   délivrer les résultats d'une requête dans un ordre particulier sauf si
   <literal>ORDER BY</> est utilisé pour contraindre l'ordre.
  </para>

  <para>
   Les lignes passées par une clause <literal>OFFSET</> devront toujours être
   traitées à l'intérieur du serveur&nbsp;; du coup, un <literal>OFFSET</>
   important peut être inefficace.
  </para>
 </sect1>

</chapter>
