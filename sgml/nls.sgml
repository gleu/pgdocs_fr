<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/nls.sgml,v 1.8 2005/09/15 07:03:20 guillaume Exp $
-->

<chapter id="nls">
 <chapterinfo>
  <author>
   <firstname>Peter</firstname>
   <surname>Eisentraut</surname>
  </author>
 </chapterinfo>

 <title>Support natif des langues</title>

 <sect1 id="nls-translator">
  <title>Pour le traducteur</title>

  <para>
   Les programmes <productname>PostgreSQL</> (serveur et client) peuvent afficher
   leur message dans votre langue préférée &mdash; si les messages ont été
   traduits.
   Créer et maintenir les ensembles de messages traduits nécessite l'aide de
   personnes parlant leur propre langue et souhaitant contribuer à 
   <productname>PostgreSQL</>. Vous n'avez pas besoin d'être un développeur
   pour cela. Cette section explique comment vous pouvez aider.
  </para>

  <sect2>
   <title>Prérequis</title>

   <para>
    Nous ne jugerons pas vos compétences dans votre langue &mdash; cette
    section concerne uniquement les outils logiciels. Théoriquement, vous n'avez
    besoin que d'un éditeur de texte. Mais ceci est dans le cas improbable où
    vous ne voulez pas tester vos traductions des messages. Lorsque vous
    configurez les sources, assurez-vous d'utiliser l'option
    <option>--enable-nls</option>. Ceci vous assurera aussi de la présence de la
    bibliothèque <application>libintl</application> et du programme
    <filename>msgfmt</filename> dont tous les utilisateurs finaux ont indéniablement
    besoin. Pour tester votre travail, suivez les parties pertinentes
    des instructions d'installation.
   </para>

   <para>
    Si vous voulez commencer un nouvel effort de traduction ou si vous voulez
    faire un assemblage de catalogues de messages (décrit ci-après), vous
    aurez besoin respectivement des programmes <filename>xgettext</filename> et
    <filename>msgmerge</filename> dans une implémentation compatible GNU. Plus tard,
    nous essaierons d'arranger cela de façon à ce que, si vous utilisez une
    distribution packagée des sources, vous n'ayez pas besoin de
    <filename>xgettext</filename>. (À partir du CVS, vous en aurez toujours
    besoin.) <application>GNU Gettext 0.10.36</application> ou ultérieure est
     actuellement recommandé.
   </para>

   <para>
    Votre implémentation locale de gettext devrait être disponible avec sa
    propre documentation. Une partie en est certainement dupliquée dans ce qui suit mais
    vous devriez regarder là pour des détails complémentaires.
   </para>
  </sect2>

  <sect2>
   <title>Concepts</title>

   <para>
    Les paires de messages originaux (anglais) et de leurs (possibles)
    équivalents traduits sont conservées dans les <firstterm>catalogues de
    messages</firstterm>, une pour chaque programme (bien que des programmes liés
    puissent partager un catalogue de messages) et pour chaque langue cible. Il
    existe deux formats de fichiers pour les catalogues de messages&nbsp;: le
    premier est le fichier <quote>PO</quote> (pour "Portable Object" ou Objet Portable), 
    qui est un
    fichier texte muni d'une syntaxe spéciale et que les traducteurs éditent. Le
    second est un fichier <quote>MO</quote> (pour "Machine Object" ou Objet Machine), 
    qui est un
    fichier binaire généré à partir du fichier PO respectif et qui est utilisé
    lorsque le programme internationalisé est exécuté. Les traducteurs ne
    s'occupent pas des fichiers MO&nbsp;; en fait, quasiment personne ne s'en occupe.
   </para>

   <para>
    L'extension du fichier de catalogue de messages est sans surprise, soit
    <filename>.po</filename>, soit <filename>.mo</filename>. Le nom de base est
    soit le nom du programme qu'il accompagne soit la langue utilisée dans le
    fichier, suivant la situation. Ceci peut s'avérer être une source de
    confusion. Des exemples sont <filename>psql.po</filename> (fichier PO pour
    psql) ou <filename>fr.mo</filename> (fichier MO en français).
   </para>

   <para>
    Le format du fichier PO est illustré ici&nbsp;:
<programlisting>
# commentaire

msgid "chaîne originale"
msgstr "chaîne traduite"

msgid "encore une originale"
msgstr "encore une de traduite"
"les chaînes peuvent être sur plusieurs lignes, comme ceci"

...
</programlisting>
    Les chaînes msgid sont extraites des sources du programme. (Elles n'ont pas
    besoin de l'être mais c'est le moyen le plus commun). Les lignes msgstr sont
    initialement vides puis remplies avec les chaînes traduites. Les chaînes
    peuvent contenir des caractères d'échappement de style C et peuvent être sur
    plusieurs lignes comme le montre l'exemple ci-dessus. (La ligne suivante
    doit démarrer au début de la ligne.)
   </para>

   <para>
    Le caractère # introduit un commentaire. Si une espace fine suit 
    immédiatement le caractère #, c'est qu'il s'agit là d'un commentaire maintenu par le 
    traducteur. On trouve aussi des commentaires automatiques qui n'ont pas d'espace
    fine suivant immédiatement le #. Ils sont maintenus par les différents outils
    qui opèrent sur les fichiers PO et ont pour but d'aider le traducteur.
<programlisting>
#. commentaire automatique
#: fichier.c:1023
#, drapeau, drapeau
</programlisting>
    Les commentaires du style #. sont extraits du fichier source où le message
    est utilisé. Il est possible que le développeur ait ajouté des informations
    pour le traducteur, telles que l'alignement attendu. Le commentaire #:
    indique l'emplacement exact où le message est utilisé dans le source. Le
    traducteur n'a pas besoin de regarder le source du programme, mais il peut
    le faire s'il subsiste un doute sur l'exactitude d'une traduction. Le commentaire #,
    contient des drapeaux décrivant le message d'une certaine façon. Il existe
    actuellement deux drapeaux&nbsp;: <literal>fuzzy</literal> est positionné si le
    message risque d'être rendu obsolète du fait de changements dans les
    sources. Le traducteur peut alors vérifier ceci et supprimer ce drapeau.
    Notez que les messages <quote>fuzzy</quote> ne sont pas accessibles à
    l'utilisateur final. L'autre drapeau est <literal>c-format</literal>
    indiquant que le message utilise le format de la fonction C
    <function>printf</function>. Ceci signifie que la traduction devrait aussi
    être de ce format avec le même nombre et le même type de paramètres fictifs. Il
    existe des outils pour vérifier que le message est une chaîne au format 
    printf et valident le drapeau c-format en consequence. 
<!-- which key off the c-format flags -->
   </para>
  </sect2>

  <sect2>
   <title>Créer et maintenir des catalogues de messages</title>

   <para>
    OK, alors comment faire pour créer un catalogue de messages
    <quote>vide</quote>&nbsp;? Tout d'abord, allez dans le répertoire contenant
    le programme dont vous souhaitez traduire les messages. S'il existe un
    fichier <filename>nls.mk</filename>, alors ce programme est préparé pour la
    traduction.
   </para>

   <para>
    S'il y a déjà des fichiers <filename>.po</filename>, alors quelqu'un a
    déjà réalisé des travaux de traduction. Les fichiers sont nommés 
    <filename><replaceable>langue</replaceable>.po</filename>, où
    <replaceable>langue</replaceable> est le code de langue sur deux caractères 
    (en minuscules)
    d'après l'<ulink
    url="http://lcweb.loc.gov/standards/iso639-2/englangn.html">ISO
    639-1, le code du pays composé de deux lettres en minuscule</ulink>, c'est-à-dire
    <filename>fr.po</filename> pour le français. S'il existe réellement un besoin pour plus d'une
    traduction par langue, alors les fichiers peuvent être renommés
    <filename><replaceable>langue</replaceable>_<replaceable>region</replaceable>.po</filename>
    où <replaceable>region</replaceable> est le code de langue sur deux
    caractères (en majuscules) d'après l'<ulink
url="http://www.din.de/gremien/nas/nabd/iso3166ma/codlstp1/en_listp1.html">ISO
    3166-1, le code du payes sur deux lettres en majuscule</ulink>, c'est-à-dire
    <filename>pt_BR.po</filename> pour le portuguais du Brésil. Si vous 
    trouvez la langue que vous souhaitez, vous pouvez commencer à travailler
    sur ce fichier.
   </para>

   <para>
    Si vous voulez commencer une nouvelle traduction, alors lancez
    d'abord la commande
<programlisting>
gmake init-po
</programlisting>
    Ceci créera un fichier
    <filename><replaceable>nomprog</replaceable>.pot</filename>.
    (<filename>.pot</filename> pour le distinguer des fichiers PO qui sont
    <quote>en production</quote>. Le <literal>T</> signifie
    <quote>template</> (NdT&nbsp;: modèle en anglais).
    Copiez ce fichier sous le nom
    <filename><replaceable>langue</replaceable>.po</filename> et éditez-le.
    Pour faire savoir qu'une nouvelle langue est disponible, éditez aussi le
    fichier <filename>nls.mk</filename> et ajoutez le code de la langue (ou de
    la langue et du pays) avec une ligne ressemblant à ceci&nbsp;:
<programlisting>
AVAIL_LANGUAGES := de fr
</programlisting>
    (D'autres langues peuvent apparaître, bien entendu.)
   </para>

   <para>
    À mesure que le programme ou la bibliothèque change, des messages peuvent
    être modifiés ou ajoutés par les développeurs. Dans ce cas, vous n'avez pas
    besoin de tout recommencer depuis le début. À la place, lancez la commande
<programlisting>
gmake update-po
</programlisting>
    qui créera un nouveau catalogue de messages vides (le fichier pot avec
    lequel vous avez commencé) et le fusionnera avec les fichiers PO existants.
    Si l'algorithme de fusion a une incertitude sur un message particulier,
    il le marquera <quote>fuzzy</quote> comme expliqué ci-dessus. Dans la cas où
    quelque chose se passerait mal, l'ancien fichier PO est sauvegardé avec une
    extension <filename>.po.old</filename>.
   </para>
  </sect2>

  <sect2>
   <title>Éditer les fichiers PO</title>

   <para>
    Les fichiers PO sont éditables avec un éditeur de texte standard. Le traducteur
    doit seulement modifier l'emplacement entre les guillemets après la
    directive msgstr, peut ajouter des commentaires et modifier le drapeau fuzzy.
    Il existe, ce qui n'est pas surprenant, un mode PO pour Emacs, que je trouve assez
    utile.
   </para>

   <para>
    Les fichiers PO n'ont pas besoin d'être entièrement remplis. Le logiciel
    retournera automatiquement à la chaîne originale si une traduction n'est pas
    disponible ou est laissée vide. Soumettre des traductions incomplètes pour les
    inclure dans l'arborescence des sources n'est pas un problème&nbsp;; cela permet à d'autres
    personnes de récupérer votre travail pour le continuer. Néanmoins, vous êtes
    encouragé à donner une haute priorité à la suppression des entrées fuzzy
    après avoir fait une fusion. Rappelez-vous que les entrées fuzzy ne
    seront pas installées&nbsp;; elles servent seulement de référence à ce qui
    pourrait être une bonne traduction.
   </para>

   <para>
    Voici certaines choses à conserver en tête lors de l'édition des
    traductions&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       Assurez-vous que si la chaîne originale se termine par un retour chariot, la
       traduction le fasse bien aussi. De même pour les tabulations, etc.
      </para>
     </listitem>

     <listitem>
      <para>
       Si la chaîne originale est une chaîne au format <function>printf</>, la
       traduction doit l'être aussi. La traduction doit également avoir les
       même spécificateurs de format et dans le même ordre. Quelques fois, les
       règles naturelles de la langue rendent cela impossible ou tout au moins
       difficile. Dans ce cas, vous pouvez modifier les spécificateurs de format
       de cette façon&nbsp;:
<programlisting>
msgstr "Die Datei %2$s hat %1$u Zeichen."
</programlisting>
       Le premier paramètre fictif sera alors utilisé par le deuxième argument de la
       liste. Le <literal><replaceable>chiffre</replaceable>$</literal> a
       besoin de suivre immédiatement le %, avant tout autre manipulateur de
       format. (Cette fonctionnalité existe réellement dans la famille des
       fonctions <function>printf</function>. Vous pouvez ne pas en avoir
       entendu parler car elle a peu d'utilité en dehors de
       l'internationalisation des messages.)
      </para>
     </listitem>

     <listitem>
      <para>
       Si la chaîne originale contient une erreur linguistique, rapportez-la (ou
       corrigez-la vous-même dans le source du programme) et traduisez-la
       normalement. La chaîne corrigée peut être fusionnée lorsque les
       programmes sources auront été mis à jour. Si la chaîne originale contient
       une erreur factuelle, rapportez-la (ou corrigez-la vous-même) et ne la traduisez
       pas. À la place, marquez la chaîne avec un commentaire dans le fichier
       PO.
      </para>
     </listitem>

     <listitem>
      <para>
       Maintenez le style et le ton de la chaîne originale. Spécifiquement, les
       messages qui ne sont pas des phrases (<literal>cannot
       open file %s</literal>, soit <literal>ne peut pas ouvrir le fichier
       %s</literal>) ne devraient probablement pas commencer avec une lettre
       capitale (si votre langue distingue la casse des lettres) ou finir avec
       un point (si votre langue utilise des marques de ponctuation). Lire <xref
       linkend="error-style-guide"> pourrait vous aider.
      </para>
     </listitem>

     <listitem>
      <para>
       Si vous ne savez pas ce que signifie un message ou s'il est ambigü,
       demandez sa signification sur la liste de diffusion des développeurs. Il
       est possible qu'un anglophone puisse aussi ne pas le
       comprendre ou le trouver ambigü, il est donc préférable d'améliorer le
       message.
      </para>
     </listitem>

    </itemizedlist>
   </para>
  </sect2>

 </sect1>


 <sect1 id="nls-programmer">
  <title>Pour le développeur</title>

  <sect2 id="nls-mechanics">
   <title>Mécaniques</title>

  <para>
   Cette section décrit comment implémenter le support natif d'un langage dans
   un programme ou dans une bibliothèque qui fait partie de la distribution
   <productname>PostgreSQL</>. Actuellement, cela s'applique uniquement aux
   programmes C.
  </para>

  <procedure>
   <title>Ajouter le support NLS à un programme</title>

   <step>
    <para>
     Insérez le code suivant dans la séquence initiale du programme&nbsp;:
<programlisting>
#ifdef ENABLE_NLS
#include &lt;locale.h&gt;
#endif

...

#ifdef ENABLE_NLS
setlocale(LC_ALL, "");
bindtextdomain("<replaceable>nomprog</replaceable>", LOCALEDIR);
textdomain("<replaceable>nomprog</replaceable>");
#endif
</programlisting>
     (<replaceable>nomprog</replaceable> peut être choisi tout à fait librement.)
    </para>
   </step>

   <step>
    <para>
     Partout où un message candidat à la traduction est trouvé,
     un appel à <function>gettext()</function> doit être inséré.
     Par exemple&nbsp;:
<programlisting>
fprintf(stderr, "panic level %d\n", lvl);
</programlisting>
     devra être changé avec
<programlisting>
fprintf(stderr, gettext("panic level %d\n"), lvl);
</programlisting>
     (<symbol>gettext</symbol> est défini comme une opération nulle si NLS
     n'est pas configuré.)
    </para>

    <para>
     Cela peut engendrer du fouillis. Un raccourci commun
     est d'utiliser
<programlisting>
#define _(x) gettext(x)
</programlisting>
     Une autre solution est envisageable si le programme effectue la plupart de ses
     communications via une ou un nombre restreint de fonctions, telle 
     <function>ereport()</function> pour le moteur. Ainsi, 
     vous modifiez le fonctionnement interne de cette fonction pour qu'elle appelle
     <function>gettext</function> pour toutes les chaînes en entrée.
    </para>
   </step>

   <step>
    <para>
     Ajoutez un fichier <filename>nls.mk</filename> dans le répertoire des
     sources du programme. Ce fichier sera lu comme un makefile.  Les
     affectations des variables suivantes doivent être réalisées
     ici&nbsp;:

     <variablelist>
      <varlistentry>
       <term><varname>CATALOG_NAME</varname></term>

       <listitem>
        <para>
         Le nom du programme tel que fourni lors de l'appel à
         <function>textdomain()</function>.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>AVAIL_LANGUAGES</varname></term>

       <listitem>
        <para>
         Liste des traductions fournies &mdash; initialement vide.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>GETTEXT_FILES</varname></term>

       <listitem>
        <para>
         Liste des fichiers contenant les chaînes traduisibles, c'est-à-dire
         celles marquées avec <function>gettext</function> ou avec une 
         solution altenative. Éventuellement, ceci inclura pratiquement tous les fichiers
         sources du programme. Si cette liste est trop longue, vous pouvez remplacer
         le premier <quote>fichier</quote> par un <literal>+</literal> et
         laisser le deuxième mot représenter un fichier contenant un nom de fichier par
         ligne.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>GETTEXT_TRIGGERS</varname></term>

       <listitem>
        <para>
         Les outils qui génèrent des catalogues de messages pour les
         traducteurs ont besoin de connaître les appels de
         fonction contenant des chaînes à traduire. Par défaut, seuls les appels
         à <function>gettext()</function> sont reconnus. Si vous utilisez
         <function>_</function> ou d'autres identifiants, vous avez besoin de
         les lister ici. Si la chaîne traduisible n'est pas le premier argument,
         l'élément a besoin d'être de la forme <literal>func:2</literal> (pour
         le second argument).
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </step>

  </procedure>

  <para>
   Le système de construction s'occupera automatiquement de construire et
   installer les catalogues de messages.
  </para>
  </sect2>

  <sect2 id="nls-guidelines">
   <title>Guide d'écriture des messages</title>

  <para>
   Voici quelques lignes de conduite pour l'écriture de messages facilement
   traduisibles.

   <itemizedlist>
    <listitem>
     <para>
      Ne construisez pas de phrases à l'exécution, telles que 
<programlisting>
printf("Files were %s.\n", flag ? "copied" : "removed");
</programlisting>
      L'ordre des mots d'une phrase peut être différent dans d'autres langues.
      De plus, même si vous n'oubliez pas d'appeler gettext() sur chaque fragment, 
      il pourrait être difficile de traduire séparément les fragments. Il est
      préférable de dupliquer un peu de code de façon à ce que chaque message à
      traduire forme un tout cohérent. Seuls les nombres, noms de fichiers et
      autres variables d'exécution devraient être insérés au moment de
      l'exécution dans le texte d'un message.
     </para>
    </listitem>

    <listitem>
     <para>
      Pour des raisons similaires, ceci ne fonctionnera pas&nbsp;:
<programlisting>
printf("copied %d file%s", n, n!=1 ? "s" : "");
</programlisting>
      parce que cette forme présume de la façon dont la forme plurielle est obtenue. Si vous
      pensez pouvoir résoudre ceci ainsi
<programlisting>
if (n==1)
    printf("copied 1 file");
else
    printf("copied %d files", n):
</programlisting>
      alors soyez déçu. Certaines langues ont plus de deux formes avec 
      des règles particulières. Il se pourrait que nous ayons solution à ce problème dans
      le futur, mais actuellement le mieux est encore de l'éviter. Vous pouvez
      écrire&nbsp;:
<programlisting>
printf("number of copied files: %d", n);
</programlisting>
     </para>
    </listitem>

    <listitem>
     <para>
      Si vous voulez communiquer quelque chose au traducteur, telle que la façon
      dont un message doit être aligné avec quelque autre sortie, faîtes précéder
      l'occurrence de la chaîne d'un commentaire commençant par
      <literal>translator</literal>, par exemple
<programlisting>
/* translator: This message is not what it seems to be. */
</programlisting>
      Ces commentaires sont copiés dans les catalogues de messages de façon à
      ce que les traducteurs les voient.
     </para>
    </listitem>
   </itemizedlist>
  </para>
  </sect2>
 </sect1>

</chapter>
