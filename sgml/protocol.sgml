<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/protocol.sgml,v 1.10 2005/07/15 06:14:26 guillaume Exp $ -->

<chapter id="protocol">
 <title>Protocole client/serveur</title>

 <para>
  <productname>PostgreSQL</productname> utilise un protocole messages pour la
  communication entre les clients et les serveurs (<quote>frontend</> et
  <quote>backend</>). Le protocole est supporté par <acronym>TCP/IP</acronym>
  et par les sockets de domaine Unix. Le numéro de port 5432 a été enregistré
  par l'IANA comme numéro de port TCP personnalisé pour les serveurs supportant ce
  protocole mais en pratique tout numéro de port non privilégié peut être
  utilisé.
 </para>

 <para>
  Ce document décrit la version 3.0 de ce protocole, telle qu'implantée dans
  <productname>PostgreSQL</productname> depuis la version 7.4. Pour obtenir la
  description des versions précédentes du protocole, il faudra se reporter aux
  versions antérieures de la documentation de <productname>PostgreSQL</productname>. Un
  même serveur peut supporter plusieurs versions du protocole. Lors de l'établissement
  de la communication le client indique au serveur la version du protocole qu'il
  souhaite utiliser. Le serveur suivra ce protocole s'il en est capable.
 </para>

 <para>
  Les fonctionnalités de haut niveau construites sur ce protocole
  (par exemple, la façon dont <application>libpq</application> passe certaines
  variables d'environnement à l'établissement de la connexion) ne sont pas couvertes
  par ce chapitre.
 </para>

  <para>
   Pour répondre efficacement à de multiple clients, le serveur lance un
   nouveau serveur (<quote>backend</>) pour chaque client. Dans l'implémentation
   actuelle, un nouveau processus fils est créé immédiatement après la détection
   d'une connexion entrante. Et cela de façon transparente pour le
   protocole. Pour le protocole, les termes <quote>backend</> et
   <quote>serveur</> sont interchangeables&nbsp;; comme <quote>frontend</>,
   <quote>interface</> et <quote>client</>.
  </para>

 <sect1 id="protocol-overview">
  <title>Aperçu</title>

  <para>
   Le protocole utilise des phases distinctes pour le lancement et le fonctionnement
   habituel. Dans la phase de lancement, le client ouvre une connexion au
   serveur et s'authentifie. (Ce qui peut impliquer un message simple, ou plusieurs
   messages, en fonction de la méthode d'authentification utilisée.) En cas de
   réussite, le serveur
   envoie une information de statut au client et entre dans le mode normal de
   fonctionnement. Exception faite du message initial de demande de lancement, cette
   partie du protocole est conduite par le serveur.
  </para>

  <para>
   En mode de fonctionnement normal, le client envoie requêtes et commandes au
   serveur et celui-ci retourne les résultats de requêtes et autres réponses.
   Il existe quelques cas (comme <command>NOTIFY</>) pour lesquels le serveur
   enverra des messages non sollicités. Mais dans l'ensemble, cette partie
   de la session est conduite par les requêtes du client.
  </para>

  <para>
   En général, c'est le client qui décide de la clôture de la session. Il arrive,
   cependant, qu'elle soit forcée par le moteur. Dans tous les cas, lors de la
   fermeture de la connexion par le serveur, toute transaction ouverte (non terminée)
   sera annulée.
  </para>

  <para>
   En mode opérationnel normal, les commandes SQL peuvent être exécutées
   via deux sous-protocoles. Dans le protocole des <quote>requêtes simples</>,
   le client envoie juste une chaîne, la requête, qui est analysée et exécutée
   immédiatement par le serveur. Dans le protocole des <quote>requêtes
   étendues</>, le traitement des requêtes est découpé en de nombreuses
   étapes&nbsp;: l'analyse, le lien avec les valeurs de paramètres et
   l'exécution. Ceci offre flexibilité et gains en performances
   au prix d'une complexité supplémentaire.
  </para>

  <para>
   Le mode opérationnel normal offre des sous-protocoles supplémentaires pour
   certaines opérations comme <command>COPY</>.
  </para>

 <sect2 id="protocol-message-concepts">
  <title>Aperçu des messages</title>

  <para>
   Toute la communication s'effectue au travers d'un flux de messages. Le premier octet
   d'un message identifie le type de message et les quatre octets suivants
   spécifient la longueur du reste du message (cette longueur inclut les 4 octets
   de longueur, mais pas l'octet du type de message). Le reste du contenu du
   message est déterminé par le type de message. Pour des raisons historiques,
   le tout premier message envoyé par le client (le message de lancement) n'a
   pas l'octet initial de type du message.
  </para>

  <para>
   Pour éviter de perdre la synchronisation avec le flux de messages, le
   serveur et le client stocke le message complet dans un tampon
   (en utilisant le nombre d'octets) avant de tenter de traiter son contenu.
   Cela permet une récupération simple si une erreur est détectée lors du
   traitement du contenu. Dans les situations extrêmes (telles que de ne pas avoir
   assez de mémoire pour placer le message dans le tampon), le récepteur
   peut utiliser le nombre d'octets pour déterminer le nombre d'entrées à ignorer
   avant de continuer la lecture des messages.
  </para>

  <para>
   En revanche, serveurs et clients doivent être attentifs à ne pas envoyer
   de message incomplet. Ceci est habituellement obtenu en plaçant le message
   complet dans un tampon avant de commencer l'envoi. Si un échec de
   communications survient pendant l'envoi ou la réception d'un message, la
   seule réponse plausible est l'abandon de la connexion. Il y a, en effet, peu d'espoir
   de resynchronisation des messages.
  </para>
 </sect2>

  <sect2 id="protocol-query-concepts">
   <title>Aperçu des requêtes étendues</title>

   <para>
    Dans le protocole des requêtes étendues, l'exécution de commandes SQL est
    scindée en plusieurs étapes. L'état retenu entre les étapes est représenté
    par deux types d'objets&nbsp;: les <firstterm>instructions préparées</> et
    les <firstterm>portails</>. Une instruction préparée représente le résultat
    de l'analyse syntaxique, de l'analyse sémantique et de la planification d'une
    chaîne de requête textuelle. Une instruction préparée n'est pas nécessairement prête à
    être exécutée parce qu'il peut lui manquer certaines valeurs de
    <firstterm>paramètres</>. Un portail représente une instruction prête à être
    exécutée ou déjà partiellement exécutée, dont toutes les valeurs de
    paramètres manquant sont données. (Pour les instructions
    <command>SELECT</>, un portail est équivalent à un curseur ouvert. Il est
    choisi d'utiliser un terme différent car les curseurs ne gèrent pas les
    instructions autres que <command>SELECT</>.)
   </para>

   <para>
    Le cycle d'exécution complet consiste en une étape d'<firstterm>analyse syntaxique</>,
    qui crée une instruction préparée à partir d'une chaîne de requête textuelle&nbsp;;
    une étape de <firstterm>liaison</>, qui crée un portail à partir d'une
    instruction préparée et des valeurs pour les paramètres nécessaires&nbsp;;
    et une étape d'<firstterm>exécution</> qui exécute une requête du portail.
    Dans le cas d'une requête qui renvoie des lignes (<command>SELECT</>,
    <command>SHOW</>, etc), il peut être signalé à l'étape d'exécution
    que seul un certain nombre de lignes doivent être retournées, de sorte que
    de multiples étapes d'exécution seront nécessaires pour terminer l'opération.
   </para>

   <para>
    Le serveur peut garder la trace de multiples instructions préparées et
    portails (qui n'existent qu'à l'intérieur d'une session, et ne sont jamais
    partagés entre les sessions). Les instructions
    préparées et les portails sont référencés par les noms qui leur sont affectés
    à la création. De plus, il existe une instruction préparée et un portail
    <quote>non nommés</>. Bien qu'ils se comportent comme les
    objets nommés, les opérations y sont optimisées en vue d'une exécution unique
    de la requête avant son annulation puis est annulée. En revanche, les
    opérations sur les objets nommés sont optimisées pour des utilisations multiples.
   </para>
  </sect2>

  <sect2 id="protocol-format-codes">
   <title>Formats et codes de format</title>

   <para>
    Les données d'un type particulier pouvaient être transmises sous
    différents <firstterm>formats</>. Depuis <productname>PostgreSQL</> 7.4, les
    seuls formats supportés sont le <quote>texte</> et le <quote>binaire</> mais
    le protocole prévoit des extensions futures. Le format désiré pour toute valeur
    est spécifié par un <firstterm>code de format</>. Les clients peuvent spécifier
    un code de format pour chaque valeur de paramètre transmise et pour chaque
    colonne du résultat d'une requête. Le texte a zéro pour code de format zéro,
    le binaire un. Tous les autres codes de format sont réservés pour des
    définitions futures.
   </para>

   <para>
    La représentation au format texte des valeurs est toute chaîne produite et acceptée
    par les fonctions de conversion en entrée/sortie pour le type de données 
    particulier. Dans la représentation transmise, il n'y a pas de caractère nul
    de terminaison de chaîne&nbsp;; le client doit en ajouter un s'il
    souhaite traiter les valeurs comme des chaînes C (le format texte n'autorise pas
    les valeurs nulles intégrées).
   </para>

   <para>
    Les représentations binaires des entiers utilisent l'ordre d'octet
    réseau (octet le plus significatif en premier). Pour les autres types de
    données, il faudra consulter la documentation ou le code source pour connaître
    la représentation binaire. Les représentations binaires
    des types de données complexes changent parfois entre les versions du
    serveur&nbsp;; le format texte reste le choix le plus portable.
   </para>
  </sect2>
 </sect1>

 <sect1 id="protocol-flow">
  <title>Flux de messages</title>

  <para>
   Cette section décrit le flux des messages et la sémantique de chaque type
   de message (les détails concernant la représentation exacte de chaque message
   apparaît dans <xref linkend="protocol-message-formats">). Il existe
   différents sous-protocoles en fonction de l'état de la connexion&nbsp;: lancement,
   requête, appel de fonction, COPY et clôture. Il existe aussi des provisions
   spéciales pour les opérations asynchrones (incluant les
   réponses aux notifications et les annulations de commande), qui peuvent
   arriver à tout moment après la phase de lancement.
  </para>

  <sect2>
   <title>Lancement</Title>

   <para>
    Pour débuter une session, un client ouvre une connexion au serveur et
    envoie un message de démarrage. Ce message inclut les noms de l'utilisateur
    et de la base de données à laquelle le client souhaite se connecter&nbsp;; il
    identifie aussi la version particulière du protocole à utiliser.
    (Optionnellement, le message de démarrage peut inclure des précisions
    supplémentaires pour les paramètres d'exécution.) Le serveur utilise
    ces informations et le contenu des fichiers de configuration
    (tels que <filename>pg_hba.conf</filename>) pour déterminer si la connexion
    est acceptable et quelle éventuelle authentification supplémentaire est requise.
   </para>

   <para>
    Le serveur envoie ensuite le message de demande d'authentification
    approprié, auquel le client doit répondre avec le message de réponse
    d'authentification adapté (tel un mot de passe). En principe, le cycle
    demande/réponse d'authentification peut requérir plusieurs itérations
    mais aucune des méthodes d'authentification actuelles n'utilise plus d'un
    cycle. Avec certaines méthodes, aucune réponse du client n'est
    nécessaire&nbsp; aucune demande d'authentification n'est alors effectuée.
   </para>

   <para>
    Le cycle d'authentification se termine lorque le serveur rejette la tentative
    de connexion (ErrorResponse) ou l'accepte (AuthenticationOk).
   </para>

   <para>
    Les messages possibles du serveur dans cette phase sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
        La tentative de connexion a été rejetée.
        Le serveur ferme immédiatement la connexion.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationOk</term>
      <listitem>
       <para>
        L'échange d'authentification s'est terminé avec succès.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationKerberosV4</Term>
      <listitem>
           <para>
        Le client doit alors prendre part à un dialogue
        d'authentification Kerberos V4 (spécification Kerberos, non décrite ici)
        avec le serveur. En cas de succès, le serveur répond par
        AuthenticationOk, ErrorResponse sinon.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <Term>AuthenticationKerberosV5</Term>
      <ListItem>
       <Para>
        Le client doit alors prendre part à un dialogue
        d'authentification Kerberos V5 (spécification Kerberos, non décrite ici)
        avec le serveur. En cas de succès, le serveur répond AuthenticationOk,
        ErrorResponse sinon.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>AuthenticationCleartextPassword</Term>
      <ListItem>
       <Para>
        Le client doit alors envoyer un PasswordMessage contenant le mot
        de passe en clair. Si le mot de passe est correct, le serveur répond
        AuthenticationOk, ErrorResponse sinon.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>AuthenticationCryptPassword</Term>
      <ListItem>
       <Para>
        Le client doit alors envoyer un PasswordMessage contenant le mot
        de passe chiffré à l'aide de crypt(3), en utilisant le composant salt de deux
        caractères spécifié dans le message AuthenticationCryptPassword. Si le
        mot de passe est correct, le serveur répond AuthenticationOk,
        ErrorResponse sinon.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>AuthenticationMD5Password</Term>
      <ListItem>
       <Para>
        Le client doit alors envoyer un PasswordMessage contenant le mot
        de passe chiffré à l'aide de MD5, en utilisant le composant salt de quatre
        caractères spécifié dans le message AuthenticationMD5Password. Si le mot
        de passe est correct, le serveur répond AuthenticationOk,
        ErrorResponse sinon.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>AuthenticationSCMCredential</Term>
      <ListItem>
       <Para>
        Cette réponse est possible uniquement pour les connexions locales de
        domaine Unix sur les plateformes qui supportent les messages
        de légitimation SCM. Le client doit fournir un message de légitimation 
	SCM, puis envoyer une donnée d'un octet. Le contenu de cet octet 
	importe peu&nbsp;; il n'est utilisé que pour s'assurer que le serveur 
	attend assez longtemps pour recevoir le message de légitimation. 
	Si la légitimation est acceptable, le serveur répond AuthenticationOk, 
	ErrorResponse sinon.
       </Para>
      </ListItem>
     </VarListEntry>

    </VariableList>
   </Para>

   <para>
    Si le client ne supporte pas la méhode d'authentification demandée par le
    serveur, il doit immédiatement fermer la connexion.
   </para>

   <para>
    Après la réception du message AuthenticationOk, le client attend d'autres
    messages du serveur. Au cours de cette phase, un processus serveur est lancé 
    et le client est simplement en attente. Il est encore possible que la tentative de
    lancement échoue (ErrorResponse) mais, dans la plupart des cas, le serveur
    enverra les messages ParameterStatus, BackendKeyData et enfin ReadyForQuery.
   </para>

   <para>
    Durant cette phase, le serveur tentera d'appliquer tous les paramètres
    d'exécution supplémentaires qui ont été fournis par le message de lancement.
    En cas de succès, ces valeurs deviennent les valeurs par défaut de la session.
    Une erreur engendre ErrorResponse et déclenche la sortie.
   </para>

   <para>
    Les messages possibles du serveur dans cette phase sont&nbsp;:

    <VariableList>
     <VarListEntry>
      <Term>BackendKeyData</Term>
      <ListItem>
       <Para>
        Ce message fournit une clé secrète que le client doit conserver s'il 
        souhaite envoyer des annulations de requêtes par la suite.
        Le client ne devrait pas répondre à ce message, mais continuer à attendre
        un message ReadyForQuery.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>ParameterStatus</Term>
      <ListItem>
       <Para>
        Ce message informe le client de la configuration actuelle (initiale)
        des paramètres du serveur, tels <varname>client_encoding</> ou
        <varname>DateStyle</>. Le client peut ignorer ce message ou enregistrer
        la configuration pour ses besoins futurs&nbsp;; voir 
        <xref linkend="protocol-async"> pour plus de détails. Le client ne 
        devrait pas répondre à ce message mais continuer à attendre un message 
        ReadyForQuery.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>ReadyForQuery</Term>
      <ListItem>
       <Para>
        Le lancement est terminé. Le client peut dès lors envoyer des commandes.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>ErrorResponse</Term>
      <ListItem>
       <Para>
        Le lancement a échoué. La connexion est fermée après l'envoi de ce 
	message.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>NoticeResponse</Term>
      <ListItem>
       <Para>
        Un message d'avertissement a été envoyé. Le client devrait afficher ce 
	message mais continuer à attendre un ReadyForQuery ou un ErrorResponse.
       </Para>
      </ListItem>
     </VarListEntry>
    </VariableList>
   </Para>

   <para>
    Le même message ReadyForQuery est envoyé à chaque cycle de commande. 
    En fonction des besoins de codage du client, il est possible de 
    considérer ReadyForQuery comme le début d'un cycle de commande, ou de le 
    considérer comme terminant la phase de lancement et chaque cycle de commande.
   </para>
  </sect2>

  <Sect2>
   <Title>Requête simple</Title>

   <Para>
    Un cycle de requête simple est initié par le client qui envoie un message 
    Query au serveur. Le message inclut une commande SQL (ou plusieurs) exprimée 
    comme une chaîne texte. Le serveur envoie, alors, un ou plusieurs messages 
    de réponse dépendant du contenu de la chaîne représentant la requête et
    enfin un message ReadyForQuery. ReadyForQuery informe le client qu'il peut
    envoyer une nouvelle commande. Il n'est pas nécessaire que le client attende 
    ReadyForQuery avant de lancer une autre commande mais le client prend alors 
    la responsabilité de ce qui arrive si la commande précédente échoue et que 
    les commandes suivantes, déjà lancées, réussissent.
   </para>

   <Para>
    Les messages de réponse du serveur sont&nbsp;:

    <VariableList>
     <VarListEntry>
      <Term>CommandComplete</Term>
      <ListItem>
       <Para>
        Commande SQL terminée normalement.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>CopyInResponse</Term>
      <ListItem>
       <Para>
        Le serveur est prêt à copier des données du client vers une table&nbsp;
	voir <xref linkend="protocol-copy">.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>CopyOutResponse</Term>
      <ListItem>
       <Para>
        Le serveur est prêt à copier des données d'une table vers le client&nbsp;; 
	voir <xref linkend="protocol-copy">.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>RowDescription</Term>
      <ListItem>
       <Para>
        Indique que des lignes vont être envoyées en réponse à une
	requête <command>SELECT</command>, <command>FETCH</command>... 
	Le contenu de ce message décrit le placement des colonnes dans les 
	lignes. Le contenu est suivi d'un message DataRow pour chaque ligne envoyée 
	au client.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>DataRow</Term>
      <ListItem>
       <Para>
        Un des ensembles de lignes retournés par une requête 
	<command>SELECT</command>, <command>FETCH</command>...
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>EmptyQueryResponse</Term>
      <ListItem>
       <Para>
        Une chaîne de requête vide a été reconnue.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>ErrorResponse</Term>
      <ListItem>
       <Para>
        Une erreur est survenue.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>ReadyForQuery</Term>
      <ListItem>
       <Para>
        Le traitement d'une requête est terminé. Un message séparé est envoyé 
	pour l'indiquer parce qu'il se peut que la chaîne de la requête contienne
	plusieurs commandes SQL. CommandComplete marque la fin du traitement 
	d'une commande SQL, pas de la chaîne complète. ReadyForQuery sera 
	toujours envoyé que le traitement se termine avec succès ou non.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>NoticeResponse</Term>
      <ListItem>
       <Para>
        Un message d'avertissement concernant la requête a été envoyé. Les
	avertissements sont complémentaires des autres réponses, le serveur 
	continuera à traiter la commande.
       </Para>
      </ListItem>
     </VarListEntry>

    </VariableList>
   </Para>

     <Para>
      La réponse à une requête <command>SELECT</> (ou à d'autres requêtes, telles
      <command>EXPLAIN</> ou <command>SHOW</>, qui retournent des ensembles de 
      données) consiste normalement en un RowDescription, plusieurs messages 
      DataRow (ou aucun) et pour finir un CommandComplete. <command>COPY</> depuis
      ou vers le client utilise un protocole spécial décrit dans 
      <xref linkend="protocol-copy">. Tous les autres types de requêtes produisent 
      uniquement un message CommandComplete.
     </Para>

     <Para>
      Puisqu'une chaîne de caractères peut contenir plusieurs requêtes (séparées 
      par des points virgules), il peut y avoir plusieurs séquences de réponses 
      avant que le serveur ne finisse de traiter la chaîne. ReadyForQuery est 
      envoyé lorsque la chaîne complète a été traitée et que le serveur est prêt à 
      accepter une nouvelle chaîne de requêtes.
     </Para>

     <Para>
      Si une chaîne de requêtes complètement vide est reçue (aucun contenu autre 
      que des espaces fines), la réponse sera EmptyQueryResponse suivie de 
      ReadyForQuery.
     </Para>

     <Para>
      En cas d'erreur, ErrorResponse est envoyé suivi de ReadyForQuery. Tous les 
      traitements suivants de la chaîne sont annulés par ErrorResponse (quelque
      soit le nombre de requêtes restant à traiter). Ceci peut survenir au 
      milieu de la séquence de messages engendrés par une requête individuelle.
     </Para>

     <para>
      En mode de requêtage simple, les valeurs récupérées sont toujours au format
      texte, sauf si la commande est un <command>FETCH</> sur un curseur déclaré 
      avec l'option <literal>BINARY</>. Dans ce cas, les valeurs récupérées sont 
      au format binaire. Les codes de format donnés dans le message RowDescription 
      indiquent le format utilisé.
     </para>

     <para>
      Un client doit être préparé à accepter des messages ErrorResponse et
      NoticeResponse quand bien même il s'attendrait à un autre type de message. 
      Voir aussi <xref linkend="protocol-async"> concernant les messages que le 
      client pourrait engendrer du fait d'événements extérieurs.
     </para>

     <para>
      La bonne pratique consiste à coder les clients dans un style machine-état 
      qui acceptera tout type de message à tout moment plutôt que de parier sur 
      la séquence exacte des messages.
     </para>
    </sect2>

  <Sect2>
     <Title>Requête étendue</Title>
  
     <para>
      Le protocole de requête étendu divise le protocole de requêtage simple décrit 
      ci-dessus en plusieurs étapes. Les résultats des étapes de préparation 
      peuvent être réutilisés plusieurs fois pour plus d'efficacité. De plus, 
      des fonctionnalités supplémentaires sont disponibles, telles que la 
      possibilité de fournir les valeurs des données comme des paramètres séparés 
      au lieu d'avoir à les insérer directement dans une chaîne de requêtes.
     </para>
  
     <para>
      Dans le protocole étendu, le client envoie tout d'abord un message Parse 
      qui contient une chaîne de requête, optionnellement quelques informations 
      sur les types de données aux emplacements des paramètres, et le nom de 
      l'objet de destination d'une instruction préparée (une chaîne vide 
      sélectionne l'instruction préparée sans nom). La réponse est soit 
      ParseComplete soit ErrorResponse. Les types de données des paramètres 
      peuvent être spécifiés par l'OID&nbsp;; dans le cas contraire, l'analyseur 
      tente d'inférer les types de données de la même façon qu'il le ferait pour 
      les constantes chaînes littérales non typées.
     </para>
  
     <note>
      <para>
       La chaîne contenue dans un message Parse ne peut pas inclure plus d'une
       instruction SQL, sinon une erreur de syntaxe est rapportée. Cette
       restriction n'existe pas dans le protocole de requête simple, mais est
       présente dans le protocole étendu. En effet, permettre aux instructions 
       préparées ou aux portails de contenir de multiples commandes compliquerait 
       inutilement le procotole.
      </para>
     </note>
  
     <para>
      En cas de succès de sa création, une instruction préparée nommée dure 
      jusqu'à la fin de la session courante, sauf si elle est détruite
      explicitement. Une instruction préparée non nommée ne dure que jusqu'à 
      la prochaine instruction Parse spécifiant l'instruction non nommée comme 
      destination. Un simple message Query détruit également l'instruction non 
      nommée. Les instructions préparées nommées doivent être explicitement 
      closes avant de pouvoir être redéfinies par un message Parse. Ce n'est
      pas obligatoire pour une instruction non nommée. Il est également possible
      de créer des instructions préparées nommées, et d'y accéder, en ligne de 
      commandes SQL à l'aide des instructions <command>PREPARE</> et 
      <command>EXECUTE</>.
     </para>
  
     <para>
      Dès lors qu'une instruction préparée existe, elle est déclarée exécutable 
      par un message Bind. Le message Bind donne le nom de l'instruction préparée 
      source (une chaîne vide désigne l'instruction préparée non nommée), le nom 
      du portail destination (une chaîne vide désigne le portail non nommé) et les 
      valeurs à utiliser pour tout emplacement de paramètres présent dans 
      l'instruction préparée. L'ensemble des paramètres fournis doit
      correspondre à ceux nécessaires à l'instruction préparée. Bind spécifie aussi
      le format à utiliser pour toutes les données renvoyées par la requête&nbsp;; 
      le format peut être spécifié complètement ou par colonne. La réponse est, soit
      BindComplete, soit ErrorResponse.
     </para>
  
     <note>
      <para>
       Le choix entre sortie texte et binaire est déterminé par les codes
       de format donnés dans Bind, quelque soit la commande SQL impliquée. 
       L'attribut <literal>BINARY</> dans les déclarations du curseur n'est pas 
       pertinent lors de l'utilisation du protocole de requête étendue.
      </para>
     </note>
  
     <para>
      En cas de succès de sa création, un objet portail nommé dure jusqu'à la fin 
      de la transaction courante sauf s'il est explicitement détruit. Un 
      portail non nommé est détruit à la fin de la transaction ou dès la prochaine 
      instruction Bind spécifiant le portail non nommé comme destination.
      Un simple message Query détruit également le portail non nommé. Les
      portails nommés doivent être explicitement fermés avant de pouvoir être
      redéfinis par un message Bind. Cela n'est pas obligatoire pour le portail non
      nommé. Il est également possible de créer des portails nommés, et d'y 
      accéder, en ligne de commandes SQL à l'aide des instructions 
      <command>DECLARE CURSOR</> et <command>FETCH</>.
     </para>
  
     <para>
      Dès lors qu'un portail existe, il peut être exécuté à l'aide d'un message
      Execute. Ce message spécifie le nom du portail (une chaîne vide désigne le
      portail non nommé) et un nombre maximum de lignes de résultat (zéro 
      signifiant la <quote>récupération de toutes les lignes</>). Le nombre de lignes 
      de résultat a seulement un sens pour les portails contenant des commandes 
      qui renvoient des ensembles de lignes&nbsp;; dans les autres cas, la 
      commande est toujours exécutée jusqu'à la fin et le nombre de lignes est 
      ignoré. Les réponses possibles d'Execute sont les même que celles 
      décrites ci-dessus pour les requêtes lancées via le protocole de requête 
      simple, si ce n'est qu'Execute ne cause pas l'envoi de ReadyForQuery.
     </para>
  
     <para>
      Si Execute se termine avant la fin de l'exécution d'un portail (du fait 
      d'un nombre de lignes de résultats différent de zéro), il enverra un
      message PortalSuspended&nbsp;; la survenue de ce message indique au client
      qu'un autre Execute devrait être lancé sur le même portail pour terminer
      l'opération. Le message CommandComplete indiquant la fin de la commande
      SQL n'est pas envoyé avant l'exécution complète du portail. Une phase
      Execute est toujours terminée par la survenue d'un seul de ces
      messages&nbsp;: CommandComplete, EmptyQueryResponse (si le portail a été
      créé à partir d'une chaîne de requête vide), ErrorResponse ou PortalSuspended.
     </para>
  
     <para>
      À la réalisation complète de chaque série de messages de requêtes étendues, 
      le client doit lancer un message Sync. Ce message sans paramètre oblige 
      le serveur à fermer la transaction courante si elle n'est pas à l'intérieur 
      d'un bloc de transaction <command>BEGIN</>/<command>COMMIT</> 
      (<quote>fermer</> signifiant valider en l'absence d'erreur ou annuler sinon). 
      Une réponse ReadyForQuery est alors envoyée. Le but de Sync est de fournir 
      un point de resynchronisation pour les récupérations d'erreurs. Quand une 
      erreur est détectée lors du traitement d'un message de requête étendue, le 
      serveur lance ErrorResponse, puis lit et annule les messages jusqu'à ce 
      qu'un Sync soit atteint. Il envoie ensuite ReadyForQuery et retourne au 
      traitement normal des messages. Aucun échappement n'est réalisé si une erreur 
      est détectée <emphasis>lors</> du traitement de Sync --- l'unicité du 
      ReadyForQuery envoyé pour chaque Sync est ainsi assuré.
     </para>
  
     <note>
      <para>
       Sync n'impose pas la fermeture d'un bloc de transactions ouvert avec 
       <command>BEGIN</>. Cette situation est détectable car le message
       ReadyForQuery inclut le statut de la transaction.
      </para>
     </note>
  
     <para>
      En plus de ces opérations fondamentales, requises, il y a plusieurs opérations
      optionnelles qui peuvent être utilisées avec le protocole de requête étendue.
     </para>
  
     <para>
      Le message Describe (variante de portail) spécifie le nom d'un portail
      existant (ou une chaîne vide pour le portail non nommé). La réponse est un
      message RowDescription décrivant les lignes qui seront renvoyées par
      l'exécution du portail&nbsp;; ou un message NoData si le portail ne contient 
      pas de requête renvoyant des lignes&nbsp;; ou ErrorResponse le portail
      n'existe pas.
     </para>
  
     <para>
      Le message Describe (variante d'instruction) spécifie le nom d'une
      instruction préparée existante (ou une chaîne vide pour l'instruction 
      préparée non nommée). La réponse est un message ParameterDescription 
      décrivant les paramètres nécessaires à l'instruction, suivi d'un message 
      RowDescription décrivant les lignes qui seront renvoyées lors de l'éventuelle
      exécution de l'instrution (ou un message NoData si l'instruction ne renvoie pas
      de lignes). ErrorResponse est retourné si l'instruction préparée n'existe 
      pas. Comme Bind n'a pas encore été exécuté, les formats à utiliser
      pour les lignes retournées ne sont pas encore connues du serveur&nbsp;; dans
      ce cas, les champs du code de format dans le message RowDescription seront 
      composés de zéros.
     </para>
  
     <tip>
      <para>
       Dans la plupart des scénarios, le client devra exécuter une des variantes de 
       Describe avant de lancer Execute pour s'assurer qu'il sait interpréter 
       les résultats reçus.
      </para>
     </tip>
  
     <para>
      Le message Close ferme une instruction préparée ou un portail et libère les 
      ressources. L'exécution de Close sur une instruction ou un portail 
      inexistant ne constitue pas une erreur. La réponse est en général
      CloseComplete mais peut être ErrorResponse si une difficulté quelconque est
      rencontrée lors de la libération des ressources. Clore une instruction 
      préparée ferme implicitement  tout autre portail ouvert construit à partir 
      de cette instruction.
     </para>
  
     <para>
      Le message Flush n'engendre pas de sortie spécifique, mais
      force le serveur à délivrer toute donnée restante dans les tampons de
      sortie. Un Flush doit être envoyé après toute commande de requête étendue, 
      à l'exception de Sync, si le client souhaite examiner le résultat de cette 
      commande avant de lancer d'autres commandes. Sans Flush, les messages 
      retournés par le serveur seront combinés en un nombre minimum de paquets 
      pour minimiser la charge réseau.
     </para>
  
     <note>
      <para>
       Le message Query simple est approximativement équivalent aux séries Parse,
       Bind, Describe sur un portail, Execute, Close, Sync utilisant les
       objets de l'instruction préparée ou du portail, non nommés et sans 
       paramètres. Une différence est l'acceptation de plusieurs instructions SQL 
       dans la chaîne de requêtes, la séquence bind/describe/execute étant 
       automatiquement réalisée pour chacune, successivement. Il en diffère 
       également en ne retournant pas les messages ParseComplete, BindComplete, 
       CloseComplete ou NoData.
      </para>
     </note>
    </sect2>

  <Sect2>
   <Title>Appel de fonction</Title>

   <para>
    Le sous-protocole d'appel de fonction (NDT&nbsp;: Function Call dans la 
    version originale) permet au client d'effectuer un appel direct à toute 
    fonction du catalogue système <structname>pg_proc</structname> de la base de
    données. Le client doit avoir le droit d'exécution de la fonction.
   </para>

   <note>
    <para>
     Le sous-protocole d'appel de fonction est une fonctionnalité qu'il vaudrait
     probablement mieux éviter dans tout nouveau code. Des résultats similaires
     peuvent être obtenus en initialisant une instruction préparée qui lance
     <literal>SELECT function($1, ...)</>. Le cycle de l'appel de fonction peut
     alors être remplacé par Bind/Execute.
    </para>
   </note>

   <para>
    Un cycle d'appel de fonction est initié par le client envoyant un message
    FunctionCall au serveur. Le serveur envoie alors un ou plusieurs messages de
    réponse en fonction des résultats de l'appel de la fonction et finalement un
    message de réponse ReadyForQuery. ReadyForQuery informe le client qu'il
    peut envoyer en toute sécurité une nouvelle requête ou un nouvel appel de
    fonction.
   </para>

   <para>
    Les messages de réponse possibles du serveur sont&nbsp;:

    <VariableList>
     <VarListEntry>
      <Term>ErrorResponse</Term>
      <ListItem>
       <Para>
        Une erreur est survenue.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>FunctionCallResponse</Term>
      <ListItem>
       <Para>
        L'appel de la fonction est terminé et a retourné le résultat
	donné dans le message. Le protocole d'appel de fonction ne peut
	gérer qu'un résultat scalaire simple, pas un type ligne ou un
	ensemble de résultats.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>ReadyForQuery</Term>
      <ListItem>
       <Para>
        Le traitement de l'appel de fonction est terminé. ReadyForQuery sera
	toujours envoyé, que le traitement se termine avec succès ou avec une 
	erreur.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>NoticeResponse</Term>
      <ListItem>
       <Para>
        Un message d'avertissement relatif à l'appel de fonction a été retourné.
	Les avertissements sont complémentaires des autres réponses,
	c'est-à-dire que le seveur continuera à traiter la commande.
       </Para>
      </ListItem>
     </VarListEntry>
    </VariableList>
   </Para>
  </sect2>

  <sect2 id="protocol-copy">
   <title>Opérations COPY</title>

   <para>
    La commande <command>COPY</> permet des transferts rapides de données en lot 
    vers ou à partir du serveur. Les opérations Copy-in et Copy-out basculent 
    chacune la connexion dans un sous-protocole distinct qui existe jusqu'à la 
    fin de l'opération.
   </para>

   <para>
    Le mode Copy-in (transfert de données vers le serveur) est initié quand le
    serveur exécute une instruction SQL <command>COPY FROM STDIN</>. Le serveur
    envoie une message CopyInResponse au client. Le client peut alors envoyer
    zéro (ou plusieurs) message(s) CopyData, formant un flux de données en 
    entrée. (Il n'est pas nécessaire que les limites du message aient un 
    rapport avec les limites de la ligne, mais cela est souvent un choix 
    raisonnable.) Le client peut terminer le mode Copy-in en envoyant un 
    message CopyDone (permettant une fin avec succès) ou un message CopyFail 
    (qui causera l'échec de l'instruction SQL <command>COPY</> avec une erreur). 
    Le serveur retourne alors au mode de traitement de la commande précédant le 
    début de <command>COPY</>, protocole de requête simple ou étendu. Il
    enverra enfin CommandComplete (en cas de succès) ou ErrorResponse (sinon).
   </para>

   <para>
    Si le serveur détecte un erreur en mode copy-in (ce qui inclut la 
    réception d'un message CopyFail), il enverra un message ErrorResponse. 
    Si la commande <command>COPY</> a été lancée à l'aide d'un message de
    requête étendue, le serveur annulera les messages du client jusqu'à
    ce qu'un message Sync soit reçu. Il enverra alors un message ReadyForQuery 
    et retournera dans le mode de fonctionnement normal. Si la commande 
    <command>COPY</> a été lancée dans un message
    simple Query, le reste de ce message est annulé et ReadyForQuery est envoyé.
    Dans tous les cas, les messages CopyData, CopyDone ou CopyFail suivants
    envoyés par l'interface seront simplement annulés.
   </para>

   <para>
    Le serveur ignorera les messages Flush et Sync reçus en mode copy-in. La 
    réception de tout autre type de messages hors-copie constitue une
    erreur qui annulera l'état Copy-in, comme cela est décrit plus haut. 
    L'exception pour Flush et Sync est faite pour les bibliothèques clientes 
    qui envoient systématiquement Flush ou Sync après un message Execute sans 
    vérifier si la commande à exécuter est <command>COPY FROM STDIN</>.
   </para>

   <para>
    Le mode Copy-out (transfert de données à partir du serveur) est initié
    lorsque le serveur exécute une instruction SQL <command>COPY TO STDOUT</>. 
    Le moteur envoie un message CopyOutResponse au client suivi de zéro (ou
    plusieurs) message(s) CopyData (un par ligne), suivi de CopyDone.
    Le serveur retourne ensuite au mode de traitement de commande dans lequel il
    se trouvait avant le lancement de <command>COPY</> et envoie CommandComplete. 
    Le client ne peut pas annuler le tranfert (sauf en fermant la connexion ou en
    lançant une requête d'annulation, Cancel), mais il peut ignorer les messages 
    CopyData et CopyDone non souhaités.
   </para>

   <para>
    Si le serveur détecte une erreur en mode Copy-out, il enverra un message 
    ErrorResponse et retournera dans le mode de traitement normal. Le client 
    devrait traiter la réception d'un message ErrorResponse (ou en fait tout 
    type de message autre que CopyData ou CopyDone) par la clôture du mode
    Copy-out.
   </para>

   <para>
    Les messages CopyInResponse et CopyOutResponse incluent les champs qui
    informent le client du nombre de colonnes par ligne et des codes de format 
    de chaque colonne. Dans l'implantation actuelle, toutes les colonnes d'une 
    opération <command>COPY</> donnée utilisent le même format, mais la 
    conception du message n'en tient pas compte.
   </para>
  </sect2>

  <sect2 id="protocol-async">
     <title>Opérations asynchrones</title>
  
     <para>
      Il existe plusieurs cas pour lesquels le serveur enverra des messages qui ne
      sont pas spécifiquement demandés par le flux de commande du client. Les 
      clients doivent être préparés à gérer ces messages à tout moment même si 
      aucune requête n'est en cours. Vérifier ces cas avant de commencer à lire la 
      réponse d'une requête est un minimum.
     </para>
  
     <para>
      Il est possible que des messages NoticeResponse soient engendrés en dehors de
      toute activité&nbsp;; par exemple, si l'administrateur de la base de données 
      commande un arrêt <quote>rapide</> de la base de données, le serveur
      enverra un NoticeResponse l'indiquant avant de fermer la connexion. Les 
      clients devraient toujours être prêts à accepter et afficher ces messages, 
      même si la connexion est inactive.
     </para>
  
     <para>
      Des messages ParameterStatus seront engendrés à chaque fois que la valeur 
      active d'un paramètre est modifiée, et cela pour tout paramètre que le 
      serveur pense utile au client. Cela survient plus généralement en réponse à 
      une commande SQL <command>SET</> exécutée par le client. Ce cas est en fait
      synchrone --- mais il est possible aussi que le changement de statut d'un 
      paramètre survienne à la suite d'une modification par l'administrateur des 
      fichiers de configuration&nbsp;; changements suivis de l'envoi du signal 
      <systemitem>SIGHUP</systemitem> au postmaster. De plus, si une commande SET 
      est annulée, un message ParameterStatus approprié sera engendré pour 
      rapporter la valeur effective.
     </para>
  
     <para>
      À ce jour, il existe un certain nombre de paramètres codés en dur pour 
      lesquels des messages ParameterStatus seront engendrés&nbsp;: on trouve
      <literal>server_version</> (un pseudo paramètre non modifiable après le 
      lancement)&nbsp;;
      <literal>client_encoding</>&nbsp;;
      <literal>is_superuser</>&nbsp;;
      <literal>session_authorization</literal>&nbsp;;
      <literal>DateStyle</>.
      Cet ensemble pourrait changer dans le futur, voire devenir configurable.
      De toute façon, un client peut ignorer un message ParameterStatus
      pour les paramètres qu'il ne comprend pas ou qui ne le concernent pas.
     </para>
  
     <para>
      Si un client lance une commande <command>LISTEN</command>, alors le serveur
      enverra un message NotificationResponse (à ne pas confondre avec
      NoticeResponse&nbsp;!) à chaque fois qu'une commande 
      <command>NOTIFY</command> est exécutée pour la notification de même nom.
     </para>
  
     <note>
      <para>
       Actuellement, NotificationResponse ne peut être envoyé qu'à l'extérieur
       d'une transaction. Il ne surviendra donc pas au milieu d'une réponse à une 
       commande, mais il peut survenir juste avant ReadyForQuery.
       Il est toutefois déconseillé de concevoir un client en partant de ce 
       principe. La bonne pratique est d'être capable d'accepter 
       NotificationResponse à tout moment du protocole.
      </para>
     </note>
    </sect2>

  <Sect2>
     <Title>Annulation de requêtes en cours</Title>
  
     <Para>
      Pendant le traitement d'une requête, le client peut demander
      l'annulation de la requête. La demande d'annulation n'est pas envoyée
      directement au serveur par la connexion ouverte pour des raisons
      d'efficacité de l'implémentation&nbsp;: il n'est pas admissible que le 
      serveur vérifie constamment les messages émanant du client lors du
      traitement des requêtes. Les demandes d'annulation sont relativement
      inhabituelles&nbsp;; c'est pourquoi elles sont traitées de manière 
      relativement simple afin d'éviter que ce traitement ne pénalise le 
      fonctionnement normal.
     </para>
  
     <Para>
      Pour effectuer une demande d'annulation, le client ouvre une nouvelle
      connexion au serveur et envoie un message CancelRequest à la place du
      message StartupMessage envoyé habituellement à l'ouverture d'une connexion. 
      Le serveur traitera cette requête et fermera la connexion. Pour des raisons 
      de sécurité, aucune réponse directe n'est faite au message de requête 
      d'annulation.
     </para>
  
     <Para>
      Un message CancelRequest sera ignoré sauf s'il contient la même donnée clé
      (PID et clé secrète) que celle passée au client lors du démarrage de la 
      connexion. Si la donnée clé correspond, le traitement de la requête en cours 
      est annulé. (Dans l'implantation existante, ceci est obtenu en envoyant un 
      signal spécial au processus serveur qui traite la requête.)
     </para>
  
     <Para>
      Le signal d'annulation peut ou non être suivi d'effet --- par exemple, s'il 
      arrive après la fin du traitement de la requête par le serveur, il n'aura 
      alors aucun effet. Si l'annulation est effective, il en résulte la fin
      précoce de la commande accompagnée d'un message d'erreur.
     </para>
  
     <Para>
      De tout ceci, il ressort que, pour des raisons de sécurité et d'efficacité, 
      le client n'a aucun moyen de savoir si la demande d'annulation a abouti.
      Il continuera d'attendre que le serveur réponde à la requête. Effectuer une
      annulation permet simplement d'augmenter la probabilité de voir la requête 
      en cours finir rapidement et échouer accompagnée d'un message d'erreur 
      plutôt que réussir.
     </para>
  
     <Para>
      Comme la requête d'annulation est envoyée via une nouvelle connexion au
      serveur et non pas au travers du lien de communication client/serveur établi, 
      il est possible que la requête d'annulation soit lancée par un processus 
      quelconque, pas forcément celui du client pour lequel la requête doit être 
      annulée. Cela peut présenter quelques avantages de flexibilité dans la 
      construction d'applications multi-processus&nbsp;; mais également une faille
      de sécurité puisque des personnes non autorisées pourraient tenter d'annuler 
      des requêtes. La faille de sécurité est comblé par l'exigence d'une clé 
      secrète, engendrée dynamiquement, pour toute requête d'annulation.
     </para>
    </sect2>

  <Sect2>
     <Title>Fin</Title>
  
     <para>
      Lors de la procédure normale de fin le client envoie un message Terminate et 
      ferme immédiatement la connexion. &Aagrave; la réception de ce message, le 
      serveur ferme la connexion et s'arrête.
     </para>
  
     <para>
      Dans de rares cas (tel un arrêt de la base de données par l'administrateur), 
      le serveur peut se déconnecter sans demande du client. Dans de tels cas, 
      le serveur tentera d'envoyer un message d'erreur ou d'avertissement en 
      donnant la raison de la déconnexion avant de fermer la connexion.
     </para>
  
     <para>
      D'autres scénarios de fin peuvent être dus à différents cas d'échecs,
      tels qu'un <quote>core dump</quote> côté client ou serveur, la perte du lien 
      de communications, la perte de synchronisation des limites du message, etc. 
      Que le client ou le serveur s'aperçoive d'une fermeture de la connexion, le
      buffer sera vidé et le processus terminé. Le client a la possibilité de 
      lancer un nouveau processus serveur en recontactant le serveur s'il ne 
      souhaite pas se finir. Il peut également envisager de clore la
      connexion si un type de message non reconnu est reçu&nbsp;; en effet, ceci 
      est probablement le résultat de la perte de synchronisation des limite de 
      messages.
     </para>
  
     <para>
      Que la fin soit normale ou non, toute transaction ouverte est annulée, non 
      pas validée. Si un client se déconnecte alors qu'une requête autre que 
      SELECT est en cours de traitement, le serveur terminera probablement la 
      requête avant de prendre connaissance de la déconnexion. 
      Si la requête est en dehors d'un bloc de transaction (séquence 
      <command>BEGIN</> ... <command>COMMIT</>), il se peut que les résultats 
      soient validés avant que la connexion ne soit reconnue.
     </para>
    </sect2>
  
    <Sect2>
     <Title>Chiffrement SSL de session</Title>
  
     <Para>
      Si <productname>PostgreSQL</> a été construit avec le support de SSL, les
      communications client/serveur peuvent être chiffrées en l'utilisant. Ce 
      chiffrement assure la sécurité de la communication dans les environnements 
      où des agresseurs pourraient capturer le trafic de la session.
     </para>
  
     <para>
      Pour initier une connexion chiffrée par SSL, le client envoie initialement
      un message SSLRequest à la place d'un StartupMessage. Le serveur répond
      avec un seul octet contenant <literal>S</> ou <literal>N</> indiquant 
      respectivement s'il souhaite ou non utiliser le SSL. Le client peut alors 
      clore la connexion s'il n'est pas satisfait de la réponse. Pour continuer 
      après un <literal>S</>, il faut échanger une poignée de main SSL 
      (handshake) (non décrite ici car faisant partie de la spécification SSL) 
      avec le serveur. En cas de succès, le StartupMessage habituel est envoyé. 
      Dans ce cas, StartupMessage et toutes les données suivantes seront chiffrés 
      avec SSL. Pour continuer après un <literal>N</>, il suffit d'envoyer
      le StartupMessage habituel et de continuer sans chiffrage.
     </para>
  
     <para>
      Le client doit être préparé à gérer une réponse ErrorMessage à un SSLRequest 
      émanant du serveur. Ceci ne peut survenir que si le serveur ne dispose pas 
      du support de SSL. Dans ce cas, la connexion doit être fermée, mais le 
      client peut choisir d'ouvrir une nouvelle connexion et procéder sans SSL.
     </para>
  
     <para>
      Un SSLRequest initial peut également être utilisé dans une connexion en 
      cours d'ouverture pour envoyer un message CancelRequest.
     </para>
  
     <para>
      Alors que le protocole lui-même ne fournit pas au serveur de moyen de
      forcer le chiffrage SSL, l'administrateur peut configuer le serveur pour
      rejeter les sessions non chiffrées, ce qui est une autre façon de vérifier
      l'authentification.
     </para>
    </sect2>
   </sect1>

  <Sect1 id="protocol-message-types">
  <Title>Types de données des message</Title>

  <Para>
  Cette section décrit les types de données basiques utilisés dans les messages.

  <VariableList>

<VarListEntry>
<Term>
        Int<Replaceable>n</Replaceable>(<Replaceable>i</Replaceable>)
</Term>
<ListItem>
<Para>
                Un entier sur <Replaceable>n</Replaceable> bits dans l'odre des
		octets réseau (octet le plus significatif en premier). Si
		<Replaceable>i</Replaceable> est spécifié, c'est exactement 
		la valeur qui apparaîtra, sinon la valeur est 
		variable, par exemple Int16, Int32(42).
</Para>
</ListItem>
</VarListEntry>

<VarListEntry>
<Term>
        Int<Replaceable>n</Replaceable>[<Replaceable>k</Replaceable>]
</Term>
<ListItem>
<Para>
		Un tableau de <Replaceable>k</Replaceable> entiers sur
                <Replaceable>n</Replaceable> bits, tous dans l'ordre des octets
		réseau. La longueur <Replaceable>k</Replaceable> du tableau est 
		toujours déterminée par un champ précédent du message, par 
		exemple, Int16[M].
</Para>
</ListItem>
</VarListEntry>

<VarListEntry>
<Term>
        String(<Replaceable>s</Replaceable>)
</Term>
<ListItem>
<Para>
                Une chaîne terminée par un octet nul (chaîne style C). Il n'y
		a pas de limitation sur la longueur des chaînes. Si
		<Replaceable>s</Replaceable> est spécifié, c'est la valeur exacte 
		qui apparaîtra, sinon la valeur est variable. Par exemple, 
		String("utilisateur").
</Para>
                
<Note>
<Para>
<Emphasis>Il n'y a aucune limite prédéfinie</Emphasis> à la longueur d'une
chaîne retournée par le serveur. Une bonne stratégie de codage
de client consiste à utiliser un tampon dont la taille peut croître pour que
tout ce qui tient en mémoire puisse être accepté. Si cela n'est pas 
faisable, il faudra lire la chaîne complète et supprimer les caractères
qui ne tiennent pas dans le tampon de taille fixe.
</Para>
</Note>
</ListItem>
</VarListEntry>

<VarListEntry>
<Term>
        Byte<Replaceable>n</Replaceable>(<Replaceable>c</Replaceable>)
</Term>
<ListItem>
<Para>
                Exactement <Replaceable>n</Replaceable> octets. Si la largeur
		<Replaceable>n</Replaceable> du champ n'est pas une constante,
		elle peut toujours être déterminée à partir d'un champ précédent 
		du message. Si <Replaceable>c</Replaceable> est spécifié, c'est 
		la valeur exacte. Par exemple, Byte2, Byte1('\n').
</Para>
</ListItem>
</VarListEntry>

</VariableList>
</Para>
</sect1>

<Sect1 id="protocol-message-formats">
<Title>Formats de message</Title>

<Para>
Cette section décrit le format détaillé de chaque message. Chaque message est
marqué pour indiquer s'il peut être envoyé par un client (F pour
<foreignphrase>Frontend</foreignphrase>), un serveur (B pour
<foreignphrase>Backend</foreignphrase>) ou les deux (F &amp; B). Bien
que chaque message commence par son nombre d'octets, le format du message est
défini de telle sorte que la fin du message puisse être trouvée sans ce nombre. 
Cela contribue à la vérification de la validité. Le message CopyData
est une exception car il constitue une partie du flux de données&nbsp;; le contenu
d'un message CopyData individuel n'est, en soi, pas interprétable.
</para>

<VariableList>


<VarListEntry>
<Term>
AuthenticationOk (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('R')
</Term>
<ListItem>
<Para>
                Marqueur de demande d'authentification.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(8)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(0)
</Term>
<ListItem>
<Para>
                L'authentification a réussi.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
AuthenticationKerberosV4 (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('R')
</Term>
<ListItem>
<Para>
                Marqueur de demande d'authentification.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(8)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(1)
</Term>
<ListItem>
<Para>
                Une authentification Kerberos V4 est requise.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
AuthenticationKerberosV5 (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('R')
</Term>
<ListItem>
<Para>
                Marqueur de demande d'authentification.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(8)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(2)
</Term>
<ListItem>
<Para>
                Une authentification Kerberos V5 est requise.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
AuthenticationCleartextPassword (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('R')
</Term>
<ListItem>
<Para>
                Marqueur de demande d'authentification.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(8)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(3)
</Term>
<ListItem>
<Para>
                Un mot de passe en clair est requis.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
AuthenticationCryptPassword (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('R')
</Term>
<ListItem>
<Para>
                Marqueur de demande d'authentification.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(10)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(4)
</Term>
<ListItem>
<Para>
                Un mot de passe chiffré à l'aide de crypt() est requis.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Byte2
</Term>
<ListItem>
<Para>
                Composant (salt) à utiliser lors du chiffrement du mot de
		passe.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
AuthenticationMD5Password (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('R')
</Term>
<ListItem>
<Para>
                Marqueur de demande d'authentification.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(12)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(5)
</Term>
<ListItem>
<Para>
                Un mot de passe chiffré par MD5 est requis.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Byte4
</Term>
<ListItem>
<Para>
                Composant (salt) à utiliser lors du chiffrement du mot de passe.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
AuthenticationSCMCredential (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('R')
</Term>
<ListItem>
<Para>
                Marqueur de demande d'authentification.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(8)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(6)
</Term>
<ListItem>
<Para>
                Un message d'accréditation SCM est requis.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
BackendKeyData (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('K')
</Term>
<ListItem>
<Para>
                Marqueur de clé d'annulation. Le
		client doit sauvegarder ces valeurs s'il souhaite initier des 
		messages CancelRequest par la suite.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(12)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                ID du processus du serveur concerné.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Clé secrète du serveur concerné.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
Bind (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('B')
</Term>
<ListItem>
<Para>
                Marqueur de commande Bind.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                Nom du portail de destination 
		(une chaîne vide sélectionne le portail non-nommé).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                Nom de l'instruction source préparée
		(une chaîne vide sélectionne l'instruction préparée non-nommée).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int16
</Term>
<ListItem>
<Para>
		Nombre de codes de format de paramètres qui suivent (notés
		<replaceable>C</> ci-dessous). Peut valoir zéro pour indiquer 
		qu'il n'y a aucun paramètre ou que tous les paramètres utilisent 
		le format par défaut (texte)&nbsp;; ou un, auquel cas le code de 
		format spécifié est appliqué à tous les paramètres&nbsp;; il 
		peut aussi être égal au nombre courant de paramètres.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int16[<replaceable>C</>]
</Term>
<ListItem>
<Para>
                Codes de format des paramètres. Tous doivent valoir zéro 
		(texte) ou un (binaire).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int16
</Term>
<ListItem>
<Para>
                Nombre de valeurs de paramètres qui suivent (peut valoir zéro).
		Cela doit correspondre au nombre de paramètres nécessaires à la 
		requête.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
        Puis, le couple de champs suivant apparaît pour chaque paramètre&nbsp;:
<VariableList>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille de la valeur du paramètre, en octets (ce nombre 
		n'inclut pas la longueur elle-même). Peut valoir zéro. 
		Traité comme un cas spécial, -1 indique une valeur de paramètre 
		NULL. Aucun octet de valeur ne suit le cas NULL.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Byte<Replaceable>n</Replaceable>
</Term>
<ListItem>
<Para>
                Valeur du paramètre, dans le format indiqué par le code de
		format associé. <Replaceable>n</Replaceable> est la longueur ci-dessus.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
        Après le dernier paramètre, les champs suivants apparaissent&nbsp;:
<VariableList>
<VarListEntry>
<Term>
        Int16
</Term>
<ListItem>
<Para>
		Nombre de codes de format des colonnes de résultat qui
		suivent (noté <replaceable>R</> ci-dessous). Peut valoir zéro 
		pour indiquer qu'il n'y a pas de colonnes de résultat ou que les
		colonnes de résultat utilisent le format par défaut 
		(texte)&nbsp;; ou une, auquel cas le code de format spécifié est
		appliqué à toutes les colonnes de résultat (s'il y en a)&nbsp;; 
		il peut aussi être égal au nombre de colonnes de résultat de la 
		requête.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int16[<replaceable>R</>]
</Term>
<ListItem>
<Para>
                Codes de format des colonnes de résultat. Tous doivent 
		valoir zéro (texte) ou un (binaire).
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
BindComplete (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('2')
</Term>
<ListItem>
<Para>
                Indicateur de Bind complet.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(4)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
CancelRequest (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Int32(16)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(80877102)
</Term>
<ListItem>
<Para>
                Code d'annulation de la requête. La valeur est choisie pour
		contenir <literal>1234</> dans les 16 bits les plus 
		significatifs et <literal>5678</> dans les 16 bits les moins 
		significatifs. (Pour éviter toute confusion, ce code ne doit pas 
		être le même qu'un numéro de version de protocole.)
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                ID du processus du serveur cible.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Clé secrète du serveur cible.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
Close (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('C')
</Term>
<ListItem>
<Para>
                Marqueur de commande Close.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Byte1
</Term>
<ListItem>
<Para>
                '<literal>S</>' pour fermer une instruction préparée&nbsp;; ou
                '<literal>P</>' pour fermer un portail.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                Nom de l'instruction préparée ou du portail à fermer (une
		chaîne vide sélectionne l'instruction préparée ou le portail
		non-nommé(e)).
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
CloseComplete (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('3')
</Term>
<ListItem>
<Para>
                Indicateur de complétude de Close.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(4)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
CommandComplete (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('C')
</Term>
<ListItem>
<Para>
                Marqueur de réponse de complétude de commande.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
        Balise de la commande. Mot simple identifiant la commande SQL terminée.
       </Para>

       <Para>
        Pour une commande <command>INSERT</command>, la balise est
        <literal>INSERT <replaceable>oid</replaceable>
        <replaceable>lignes</replaceable></literal> où
        <replaceable>lignes</replaceable> est le nombre de lignes insérées.
        <replaceable>oid</replaceable> est l'ID de l'objet de la ligne insérée
        si <Replaceable>lignes</Replaceable> vaut 1 et que la table cible a des
	OID&nbsp;; sinon <Replaceable>oid</Replaceable> vaut 0.
       </Para>

       <Para>
        Pour une commande <command>DELETE</command>, la balise est
	<literal>DELETE <Replaceable>lignes</Replaceable></literal> où
        <Replaceable>lignes</Replaceable> est le nombre de lignes supprimées.
       </Para>

       <Para>
        Pour une commande <command>UPDATE</command>, la balise est
	<literal>UPDATE <Replaceable>lignes</Replaceable></literal> où
        <Replaceable>lignes</Replaceable> est le nombre de lignes mises à jour.
       </Para>

       <para>
        Pour une commande <command>MOVE</command>, la balise est
        <literal>MOVE <replaceable>lignes</replaceable></literal> où
        <replaceable>lignes</replaceable> est le nombre de lignes de déplacement
	du curseur.
       </para>

       <para>
        Pour une commande <command>FETCH</command>, la balise est
        <literal>FETCH <replaceable>lignes</replaceable></literal> où
        <replaceable>lignes</replaceable> est le nombre de lignes 
        récupérées à partir du curseur.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
CopyData (F &amp; B)
</Term>
<ListItem>
<Para>
<VariableList>
<VarListEntry>
<Term>
        Byte1('d')
</Term>
<ListItem>
<Para>
                Marqueur de données de COPY.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Byte<Replaceable>n</Replaceable>
</Term>
<ListItem>
<Para>
                Données formant une partie d'un flux de données 
		<command>COPY</command>. Les messages envoyés depuis le serveur
		correspondront toujours à des lignes uniques de données, mais 
		les messages envoyés par les clients peuvent diviser le flux de 
		données de façon arbitraire.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
CopyDone (F &amp; B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('c')
</Term>
<ListItem>
<Para>
                Indicateur de fin de COPY.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(4)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
CopyFail (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('f')
</Term>
<ListItem>
<Para>
                Indicateur d'échec de COPY.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                Message d'erreur rapportant la cause d'un échec.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
CopyInResponse (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('G')
</Term>
<ListItem>
<Para>
                Marqueur de réponse de Start Copy In.
                Le client doit alors envoyer des données de copie (s'il n'est 
		pas à cela, il enverra un message CopyFail).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int8
</Term>
<ListItem>
<Para>
                0 indique que le format de copie complet est textuel (lignes 
 		séparées par des retours chariot, colonnes séparées par des
 		caractères de séparation, etc). 1 indique que le format de copie 
 		complet est binaire (similaire au format DataRow). 
 		Voir <xref linkend="sql-copy" endterm="sql-copy-title"> pour 
 		plus d'informations.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int16
</Term>
<ListItem>
<Para>
		Nombre de colonnes dans les données à copier (noté
		<replaceable>N</> ci-dessous).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int16[<replaceable>N</>]
</Term>
<ListItem>
<Para>
                Codes de format à utiliser pour chaque colonne. Chacun doit
		valoir zéro (texte) ou un (binaire). Tous doivent valoir zéro si
		le format de copie complet est de type texte.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
CopyOutResponse (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('H')
</Term>
<ListItem>
<Para>
                Marqueur de réponse Start Copy Out.
                Ce message sera suivi de données copy-out.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int8
</Term>
<ListItem>
<Para>
                0 indique que le format de copie complet est textuel (lignes
		séparées par des retours chariots, colonnes séparées par des 
		caractères séparateur, etc). 1 indique que le format de copie 
		complet est binaire (similaire au format DataRow). 
		Voir <xref linkend="sql-copy" endterm="sql-copy-title"> pour 
		plus d'informations.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int16
</Term>
<ListItem>
<Para>
		Nombre de colonnes de données à copier (noté
		<replaceable>N</> ci-dessous).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int16[<replaceable>N</>]
</Term>
<ListItem>
<Para>
                Codes de format à utiliser pour chaque colonne. Chaque code
		doit valoir zéro (texte) ou un (binaire). Tous doivent valoir 
		zéro si le format de copie complet est de type texte.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
DataRow (B)
</Term>
<ListItem>
<Para>
<VariableList>
<VarListEntry>
<Term>
        Byte1('D')
</Term>
<ListItem>
<Para>
                Marqueur de ligne de données.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int16
</Term>
<ListItem>
<Para>
                Nombre de valeurs de colonnes qui suivent (peut valoir zéro).
</Para>
</ListItem>
</VarListEntry>
</VariableList>
        Apparaît ensuite le couple de champs suivant, pour chaque colonne&nbsp;:
<VariableList>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Longueur de la valeur de la colonne, en octets (ce nombre 
		n'inclut pas la longueur elle-même). Peut valoir zéro. 
		Traité comme un cas spécial, -1 indique une valeur NULL de 
		colonne. Aucun octet de valeur ne suit le cas NULL.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Byte<Replaceable>n</Replaceable>
</Term>
<ListItem>
<Para>
                Valeur de la colonne dans le format indiqué par le code de
		format associé. <Replaceable>n</Replaceable> est la longueur 
		ci-dessus.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
Describe (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('D')
</Term>
<ListItem>
<Para>
                Marqueur de commande Describe.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Byte1
</Term>
<ListItem>
<Para>
                '<literal>S</>' pour décrire une instruction préparée&nbsp;; ou
                '<literal>P</>' pour décrire un portail.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                Nom de l'instruction préparée ou du portail à décrire (une
		chaîne vide sélectionne l'instruction préparée ou le portail
		non-nommé(e)).
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
EmptyQueryResponse (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('I')
</Term>
<ListItem>
<Para>
                Marqueur de réponse à une chaîne de requête vide. (C'est un
		substitut de CommandComplete.)
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(4)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
ErrorResponse (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('E')
</Term>
<ListItem>
<Para>
                Marqueur d'erreur.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
        Le corps du message est constitué d'un ou plusieurs champs identifié(s), 
	suivi(s) d'un octet nul comme terminateur. L'ordre des champs n'est pas
	fixé. Pour chaque champ, on trouve les informations suivantes&nbsp;:
<VariableList>
<VarListEntry>
<Term>
        Byte1
</Term>
<ListItem>
<Para>
                Code identifiant le type de champ&nbsp;; s'il vaut zéro,
		c'est la fin du message et aucune chaîne ne suit. Les types de 
		champs définis sont listés dans 
		<xref linkend="protocol-error-fields">. De nouveaux types de
		champs pourraient être ajoutés dans le futur, les clients 
		doivent donc ignorer silencieusement les types non reconnus.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                Valeur du champ.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
Execute (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('E')
</Term>
<ListItem>
<Para>
                Marqueur de commande Execute.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                Nom du portail à exécuter (une chaîne vide sélectionne le
		portail non-nommé).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Nombre maximum de lignes à retourner si le portail contient une
		requête retournant des lignes (ignoré sinon). Zéro signifie 
		<quote>aucune limite</>.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
Flush (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('H')
</Term>
<ListItem>
<Para>
                Marqueur de commande Flush.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(4)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
FunctionCall (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('F')
</Term>
<ListItem>
<Para>
                Marqueur d'appel de fonction.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Spécifie l'ID de l'objet représentant la fonction à appeler.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int16
</Term>
<ListItem>
<Para>
 		Nombre de codes de format de l'argument qui suivent
 		(noté <replaceable>C</> ci-dessous). Cela peut être zéro pour
 		indiquer qu'il n'y a pas d'arguments ou que tous les arguments 
 		utilisent le format par défaut (texte)&nbsp;; un, auquel cas 
 		le code de format est appliqué à tous les arguments&nbsp;; il
 		peut aussi être égal au nombre réel d'arguments.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int16[<replaceable>C</>]
</Term>
<ListItem>
<Para>
                Les codes de format d'argument. Chacun doit valoir zéro
		(texte) ou un (binaire).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int16
</Term>
<ListItem>
<Para>
                Nombre d'arguments fournis à la fonction.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
        Apparaît ensuite, pour chaque argument, le couple de champs suivant&nbsp;:
<VariableList>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Longueur de la valeur de l'argument, en octets (ce nombre 
		n'inclut pas la longueur elle-même). Peut valoir zéro. 
		Traité comme un cas spécial, -1 indique une valeur NULL de 
		l'argument. Aucun octet de valeur ne suit le cas NULL.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Byte<Replaceable>n</Replaceable>
</Term>
<ListItem>
<Para>
                Valeur de l'argument dans le format indiqué par le code de
		format associé. <Replaceable>n</Replaceable> est la longueur 
		ci-dessus.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
        Après le dernier argument, le champ suivant apparaît&nbsp;:
<VariableList>
<VarListEntry>
<Term>
        Int16
</Term>
<ListItem>
<Para>
                Code du format du résultat de la fonction. Doit valoir zéro 
		(texte) ou un (binaire).
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
FunctionCallResponse (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('V')
</Term>
<ListItem>
<Para>
                Marqueur de résultat d'un appel de fonction.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Longueur de la valeur du résultat de la fonction, en octets 
		(ce nombre n'inclut pas la longueur elle-même). Peut valoir zéro. 
		Traité comme un cas spécial, -1 indique un résultat de fonction 
		NULL. Aucun octet de valeur ne suit le cas NULL.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Byte<Replaceable>n</Replaceable>
</Term>
<ListItem>
<Para>
                Valeur du résultat de la fonction, dans le format indiqué
		par le code de format associé. <Replaceable>n</Replaceable> est
		la longueur ci-dessus.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
NoData (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('n')
</Term>
<ListItem>
<Para>
                Indicateur d'absence de données.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(4)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
NoticeResponse (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('N')
</Term>
<ListItem>
<Para>
                Marqueur d'avertissement.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
        Le corps du message est constitué d'un ou plusieurs champs identifié(s),
	suivi(s) d'un octet zéro comme terminateur. L'ordre des champs n'est pas
	fixé. Pour chaque champ, on trouve les informations suivantes&nbsp;:
<VariableList>
<VarListEntry>
<Term>
        Byte1
</Term>
<ListItem>
<Para>
                Code identifiant le type de champ&nbsp;; s'il vaut zéro,
		c'est la fin du message et aucune chaîne ne suit. Les types de 
		champs déjà définis sont listés dans 
		<xref linkend="protocol-error-fields">. De nouveaux types de
		champs pourraient être ajoutés dans le futur, les clients doivent
		donc ignorer silencieusement les champs de type non reconnu.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                Valeur du champ.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
NotificationResponse (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('A')
</Term>
<ListItem>
<Para>
                Marqueur de réponse de notification.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                ID du processus serveur ayant procédé à la notification.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                Nom de la condition à l'origine de la notification.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                Information supplémentaire provenant du processus à l'origine de
		la notification. (Cette fonctionnalité n'est , à ce jour, pas 
		implantée, le champ est donc toujours constitué d'une chaîne vide.)
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
ParameterDescription (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('t')
</Term>
<ListItem>
<Para>
                Marqueur de description de paramètre.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int16
</Term>
<ListItem>
<Para>
                Nombre de paramètres utilisé par l'instruction (peut valoir 
		zéro).
</Para>
</ListItem>
</VarListEntry>
</VariableList>
        Pour chaque paramètre, suivent&nbsp;:
<VariableList>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                ID de l'objet du type de données du paramètre.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
ParameterStatus (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('S')
</Term>
<ListItem>
<Para>
                Marqueur de rapport d'état de paramètre 
		d'exécution.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                Nom du paramètre d'exécution dont le rapport est en cours.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                Valeur actuelle du paramètre.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
Parse (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('P')
</Term>
<ListItem>
<Para>
                Marqueur de commande Parse.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                Nom de l'instruction préparée de destination (une chaîne
		vide sélectionne l'instruction préparée non-nommée).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                Chaîne de requête à analyser.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int16
</Term>
<ListItem>
<Para>
                Nombre de types de données de paramètre spécifiés (peut
		valoir zéro). Ce n'est pas une indication du nombre de 
		paramètres pouvant apparaître dans la chaîne de requête, 
		mais simplement le nombre de paramètres pour lesquels le client 
		veut pré-spécifier les types.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
        Pour chaque paramètre, on trouve ensuite&nbsp;:
<VariableList>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                ID de l'objet du type de données du paramètre.
		la valeur zéro équivaut à ne pas spécifier le type.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
ParseComplete (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('1')
</Term>
<ListItem>
<Para>
                Indicateur de fin de Parse.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(4)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
PasswordMessage (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('p')
</Term>
<ListItem>
<Para>
                Marqueur de réponse de mot de passe.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                Mot de passe (chiffré à la demande).
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
PortalSuspended (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('s')
</Term>
<ListItem>
<Para>
                Indicateur de suspension du portail. 
		Apparaît seulement si la limite du nombre de lignes d'un
		message Execute a été atteint.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(4)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
Query (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('Q')
</Term>
<ListItem>
<Para>
                Marqueur de requête simple.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                La chaîne de requête elle-même.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
ReadyForQuery (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('Z')
</Term>
<ListItem>
<Para>
                Identifie le type du message. ReadyForQuery est envoyé à chaque
		fois que le serveur est prêt pour un nouveau cycle de requêtes.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(5)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Byte1
</Term>
<ListItem>
<Para>
                Indicateur de l'état transactionnel du serveur. 
		Les valeurs possibles sont '<literal>I</>' s'il est en pause 
		(en dehors d'un bloc de transaction)&nbsp;; '<literal>T</>' s'il
		est dans un bloc de transaction&nbsp;; ou '<literal>E</>' s'il 
		est dans un bloc de transaction échouée (les requêtes seront
		réjetées jusqu'à la fin du bloc).
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
RowDescription (B)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('T')
</Term>
<ListItem>
<Para>
                Marqueur de description de ligne.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int16
</Term>
<ListItem>
<Para>
                Nombre de champs dans une ligne (peut valoir zéro).
</Para>
</ListItem>
</VarListEntry>
</VariableList>
        On trouve, ensuite, pour chaque champ&nbsp;:
<VariableList>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                Nom du champ.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Si le champ peut être identifié comme colonne d'une table
		spécifique, l'ID de l'objet de la table&nbsp;; sinon zéro.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int16
</Term>
<ListItem>
<Para>
                Si le champ peut être identifié comme colonne d'une table 
		spécifique, le numéro d'attribut de la colonne&nbsp;; sinon zéro.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                ID de l'objet du type de données du champ.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int16
</Term>
<ListItem>
<Para>
                Taille du type de données (voir <varname>pg_type.typlen</>).
		Les valeurs négatives indiquent des types de largeur variable.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Modificateur de type (voir <varname>pg_attribute.atttypmod</>).
		La signification du modificateur est spécifique au type.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int16
</Term>
<ListItem>
<Para>
                Code de format utilisé pour le champ. Zéro (texte) ou un 
		(binaire), à l'heure actuelle. Dans un RowDescription retourné
		par la variante de l'instruction de Describe, le code du format 
		n'est pas encore connu et vaudra toujours zéro.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
SSLRequest (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Int32(8)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(80877103)
</Term>
<ListItem>
<Para>
                 Code de requête <acronym>SSL</acronym>. La valeur est choisie pour contenir
 		<literal>1234</> dans les 16 bits les plus significatifs, et 
 		<literal>5679</> dans les 16 bits les moins significatifs
 		(pour éviter toute confusion, ce code ne doit pas être le même 
 		que celui d'un numéro de version de protocole).
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
StartupMessage (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Int32
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(196608)
</Term>
<ListItem>
<Para>
                Numéro de version du protocole. Les 16 bits les plus
		significatifs représentent le numéro de version majeure (3 pour le 
		protocole décrit ici). Les 16 bits les moins significatifs représentent
		le numéro de version mineure (0 pour le protocole décrit ici).
</Para>
</ListItem>
</VarListEntry>
</VariableList>
        Le numéro de version du protocole est suivi par un ou plusieurs
	couple(s) nom de paramètre et chaîne de valeur. Un octet zéro est requis
	comme terminateur après le dernier couple nom/valeur. L'ordre des 
	paramètres n'est pas fixé. Le paramètre <literal>user</> est requis, 
	les autres sont optionnels. Chaque paramètre est spécifié de la façon 
	suivante&nbsp;:
<VariableList>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                Nom du paramètre. Les noms actuellement reconnus sont&nbsp;:

<VariableList>
<VarListEntry>
<Term>
                <literal>user</>
</Term>
<ListItem>
<Para>
                        Nom de l'utilisateur de base de données sous lequel se
			connecter. Requis&nbsp;; il n'y a pas de valeur par défaut.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
                <literal>database</>
</Term>
<ListItem>
<Para>
                        Base de données à laquelle se connecter. 
			Par défaut le nom de l'utilisateur.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
                <literal>options</>
</Term>
<ListItem>
<Para>
                        Arguments en ligne de commande pour le serveur. 
			(Rendu obsolète par l'utilisation de paramètres 
			individuels d'exécution.)
</Para>
</ListItem>
</VarListEntry>
</VariableList>

                En plus de ce qui précède, tout paramètre d'exécution 
		pouvant être initialisé au démarrage du serveur peut être listé.
		Ces paramètres seront appliqués au démarrage du serveur 
		(après analyse des options en ligne de commande, s'il y en a). 
		Leurs valeurs agiront comme valeurs de session par défaut.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        String
</Term>
<ListItem>
<Para>
                Valeur du paramètre.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
Sync (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('S')
</Term>
<ListItem>
<Para>
                Marqueur de commande Sync.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(4)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


<VarListEntry>
<Term>
Terminate (F)
</Term>
<ListItem>
<Para>

<VariableList>
<VarListEntry>
<Term>
        Byte1('X')
</Term>
<ListItem>
<Para>
                Marqueur de fin.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
        Int32(4)
</Term>
<ListItem>
<Para>
                Taille du message en octets, y compris la taille elle-même.
</Para>
</ListItem>
</VarListEntry>
</VariableList>

</Para>
</ListItem>
</VarListEntry>


</VariableList>

</sect1>


<Sect1 id="protocol-error-fields">
<Title>Champs des messages d'erreur et d'avertissement</Title>

<para>
Cette section décrit les champs qui peuvent apparaître dans les messages
ErrorResponse et NoticeResponse. Chaque type de champ a un motif
d'identification codé sur un octet. Tout type de champ donné doit apparaître au 
plus une fois par message.
</para>

<VariableList>

<VarListEntry>
<Term>
<literal>S</>
</Term>
<ListItem>
<Para>
        Gravité (Severity)&nbsp;: le contenu du champ peut être 
        <literal>ERROR</>, <literal>FATAL</> ou
        <literal>PANIC</> dans un message d'erreur, 
	<literal>WARNING</>, <literal>NOTICE</>, <literal>DEBUG</>,
	<literal>INFO</> ou <literal>LOG</> dans un message d'avertissement,
	ou la traduction régionale de l'un d'eux. Toujours présent.
</Para>
</ListItem>
</VarListEntry>

<VarListEntry>
<Term>
<literal>C</>
</Term>
<ListItem>
<Para>
        Code&nbsp;: code SQLSTATE de l'erreur (voir 
	<xref linkend="errcodes-appendix">). Non internationalisable. 
	Toujours présent.
</Para>
</ListItem>
</VarListEntry>

<VarListEntry>
<Term>
<literal>M</>
</Term>
<ListItem>
<Para>
        Message&nbsp;: premier message d'erreur, en clair.
	Doit être court et précis (typiquement une ligne). Toujours présent.
</Para>
</ListItem>
</VarListEntry>

<VarListEntry>
<Term>
<literal>D</>
</Term>
<ListItem>
<Para>
        Détail&nbsp;: deuxième message d'erreur, optionnel, apportant des
	informations supplémentaires sur le problème. Peut être sur plusieurs 
	lignes.
</Para>
</ListItem>
</VarListEntry>

<VarListEntry>
<Term>
<literal>H</>
</Term>
<ListItem>
<Para>
        Astuce (Hint)&nbsp;: suggestion optionnelle de résolution du
	problème. Différent de Détail parce qu'il offre un
	conseil (potentiellement inapproprié) plutôt que des faits réels. 
	Peut être sur plusieurs lignes.
</Para>
</ListItem>
</VarListEntry>

<VarListEntry>
<Term>
<literal>P</>
</Term>
<ListItem>
<Para>
        Position&nbsp;: valeur du champ, entier décimal ASCII indiquant
	un curseur sur la position de l'erreur dans la chaîne de requête 
	originale. Le premier caractère a l'index 1. Les positions sont mesurées
	en caractères, non pas en octets.
</Para>
</ListItem>
</VarListEntry>

<varlistentry>
  <term>
    <literal>p</>
</term>
<listitem>
  <para>
    Position interne&nbsp;: ceci est défini de la même façon que le champ
    <literal>P</> mais c'est utilisé quand la position du curseur se réfère
    à une commande générée en interne plutôt qu'une soumise par le client.
    Le champ <literal>q</> apparaîtra toujours quand ce champ apparaît.
</para>
</listitem>
</varlistentry>

<varlistentry>
  <term>
    <literal>q</>
</term>
<listitem>
  <para>
    Requête interne&nbsp;: le texte d'une commande générée en interne et qui a échoué.
    Ceci pourrait être, par exemple, une requête SQL lancée par une fonction PL/pgSQL.
  </para>
</listitem>
</varlistentry>

<VarListEntry>
<Term>
<literal>W</>
</Term>
<ListItem>
<Para>
Où (Where)&nbsp;: indication du contexte dans lequel l'erreur est
survenue. Inclut, actuellement, une trace de la pile des appels des
fonctions PL actives. Cette trace comprend une entrée par ligne, la plus
récente en premier.
</Para>
</ListItem>
</VarListEntry>

<VarListEntry>
<Term>
<literal>F</>
</Term>
<ListItem>
<Para>
        Fichier (File)&nbsp;: nom du fichier de code source comportant
	l'erreur.
</Para>
</ListItem>
</VarListEntry>

<VarListEntry>
<Term>
<literal>L</>
</Term>
<ListItem>
<Para>
        Ligne (Line)&nbsp;: numéro de ligne dans le fichier de code source 
	comportant l'erreur.
</Para>
</ListItem>
</VarListEntry>

<VarListEntry>
<Term>
<literal>R</>
</Term>
<ListItem>
<Para>
        Routine&nbsp;: nom de la routine dans le code source comportant
	l'erreur.
</Para>
</ListItem>
</VarListEntry>

</VariableList>

<para>
Le client est responsable du formatage adapté à ses besoins des informations
affichées&nbsp;; en particulier par l'ajout de retours chariots sur les lignes
longues, si cela s'avérait nécessaire. Les caractères de retour chariot
apparaissant dans les champs de messages d'erreur devraient être traités comme
des changements de paragraphes, non comme des changements de lignes.
</para>

</sect1>


<Sect1 id="protocol-changes">
<Title>Résumé des modifications depuis le protocole 2.0</Title>

<para>
Cette section fournit une liste rapide des modifications à l'attention des
développeurs essayant d'adapter au protocole 3.0 des bibliothèques client 
existantes.
</para>

<para>
Le paquet de démarrage initial utilise un format flexible de liste de chaînes
au lieu d'un format fixe. Les valeurs de session par défaut des paramètres 
d'exécution peuvent même être spécifiés directement dans le paquet de démarrage.
(En fait, cela était déjà possible en utilisant le champ <literal>options</>&nbsp;;
mais étant donné la largeur limitée d'<literal>options</> et l'impossibilité de 
mettre entre guillemets les espaces fines dans les valeurs, ce n'était pas une
technique très sûre.)
</para>

<para>
Tous les messages possèdent désormais une indication de longueur qui suit
immédiatement l'octet du type de message (sauf pour les paquets de démarrage qui
n'ont pas d'octet de type). PasswordMessage possède à présent un octet de type.
</para>

<para>
Les messages ErrorResponse et NoticeResponse ('<literal>E</>' et
'<literal>N</>') contiennent maintenant plusieurs champs, à partir desquels le
code client peut assembler un message d'erreur fonction du niveau de verbiage 
désiré. Des champs individuels ne se termineront plus par un retour chariot 
alors que la chaîne seule envoyée dans l'ancien protocole le faisait 
systématiquement.
</para>

<para>
Le message ReadyForQuery ('<literal>Z</>') inclut un indicateur d'état de
la transaction.
</para>

<para>
La distinction entre les types de messages BinaryRow et DataRow est supprimée&nbsp;;
le type de message DataRow seul sert à retourner les données dans tous les
formats. La disposition de DataRow a changé pour faciliter son analyse.
La représentation des valeurs binaires a également été modifiée&nbsp;: elle
n'est plus liée directement à la représentation interne du serveur.
</para>

<para>
Il existe un nouveau sous-protocole pour les <quote>requêtes étendues</> qui
ajoute les types de messages client Parse, Bind, Execute, Describe, Close,
Flush et Sync et les types de messages serveur ParseComplete, BindComplete,
PortalSuspended, ParameterDescription, NoData et CloseComplete. Les clients
existants ne sont pas directement concernés par ce sous-protocole, mais son
utilisation apportera des améliorations en terme de performances et de 
fonctionnalités.
</para>

<para>
Les données de COPY sont désormais encapsulées dans des messages CopyData et
CopyDone. Il y a une façon bien définie de réparer les erreurs lors du COPY.
La dernière ligne spéciale <quote><literal>\.</></quote> n'est plus nécessaire
et n'est pas envoyée lors de COPY OUT. (Elle est toujours reconnue comme un
indicateur de fin lors du COPY IN mais son utilisation est obsolète. Elle sera
éventuellement supprimée.) Le COPY binaire est supporté. Les messages
CopyInResponse et CopyOutResponse incluent les champs indiquant le nombre de
colonnes et le format de chaque colonne.
</para>

  <para>
  La disposition des messages FunctionCall et FunctionCallResponse a changé.
  FunctionCall supporte à présent le passage aux fonctions d'arguments NULL. Il
  peut aussi gérer le passage de paramètres et la récupération de résultats aux
  formats texte et binaire. Il n'y a plus aucune raison de considérer FunctionCall
  comme une faille potentielle de sécurité car il n'offre plus d'accès direct aux
  représentations internes des données du serveur.
  </para>
  
  <para>
  Le serveur envoie des messages ParameterStatus ('<literal>S</>') lors de
  l'initialisation de la connexion pour tous les paramètres qu'il considère
  intéressants pour la bibliothèque client. En conséquence, un message
  ParameterStatus est envoyé à chaque fois que la valeur active d'un de ces 
  paramètres change.
  </para>
  
  <para>
  Le message RowDescription ('<literal>T</>') contient les nouveaux champs OID
  de table et de numéro de colonne pour chaque colonne de la ligne décrite. Il
  affiche aussi le code de format pour chaque colonne.
  </para>
  
  <para>
  Le message CursorResponse ('<literal>P</>') n'est plus engendré par le serveur.
  </para>
  
  <para>
  Le message NotificationResponse ('<literal>A</>') a un champ de type chaîne
  supplémentaire, actuellement vide mais qui pourrait à terme transporter des
  données supplémentaires engendrées par l'émetteur de l'événement NOTIFY.
  </para>
  
  <para>
  Le message EmptyQueryResponse ('<literal>I</>') nécessitait un paramètre chaîne
  vide&nbsp;; ce n'est plus le cas.
  </para>
  
  </sect1>
  
  
  </Chapter>  
