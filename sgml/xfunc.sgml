<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/xfunc.sgml,v 1.10 2005/02/10 07:36:39 guillaume Exp $
-->

 <sect1 id="xfunc">
  <title>Fonctions définies par l'utilisateur</title>

  <indexterm zone="xfunc">
   <primary>fonction</primary>
   <secondary>définie par l'utilisateur</secondary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> propose quatre types de
    fonctions&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      fonctions en langage de requête (fonctions écrites en <acronym>SQL</acronym>) (<xref linkend="xfunc-sql">)
     </para>
    </listitem>
    <listitem>
     <para>
      fonctions en langage de procédures (fonctions écrites, par exemple, en
      <application>PL/Tcl</> ou <application>PL/pgSQL</>)
      (<xref linkend="xfunc-pl">)
     </para>
    </listitem>
    <listitem>
     <para>
      fonctions internes (<xref linkend="xfunc-internal">)
     </para>
    </listitem>
    <listitem>
     <para>
      fonctions en langage C (<xref linkend="xfunc-c">)
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Chaque sorte de fonction peut accepter comme arguments (paramètres) des types
   de base, des types composites ou une combinaison de ceux-ci. De plus, chaque
   sorte de fonction peut renvoyer un type de base ou un type composite.
  </para>

  <para>
   De nombreuses sortes de fonctions peuvent accepter ou renvoyer certains
   pseudo-types (comme les types polymorphes) mais avec des fonctionalités
   variées.
   Consultez la description de chaque type de fonction pour plus de détails.
  </para>

  <para>
   Il est plus facile de définir des fonctions <acronym>SQL</acronym> aussi
   allons-nous commencer par celles-ci. La plupart des concepts présentés pour
   les fonctions <acronym>SQL</acronym> seront aussi gérés par les autres types
   de fonctions.
  </para>

  <para>
   Lors de  la lecture de ce chapitre, il peut être utile de consulter la page
   de référence de la commande <command>CREATE FUNCTION</command> pour mieux
   comprendre les exemples. Quelques exemples extraits de ce chapitre peuvent 
   être trouvés dans les fichiers <filename>funcs.sql</filename> et
   <filename>funcs.c</filename> du répertoire du tutoriel de la distribution
   source de <productname>PostgreSQL</productname>.
  </para>

  </sect1>

  <sect1 id="xfunc-sql">
   <title>Fonctions en langage de requêtes (<acronym>SQL</acronym>)</title>

   <indexterm zone="xfunc-sql">
    <primary>fonction</primary>
    <secondary>définie par l'utilisateur</secondary>
    <tertiary>en SQL</tertiary>
   </indexterm>

   <para>
    Les fonctions SQL exécutent une liste arbitraire d'instructions SQL et
    renvoient le résultat de la dernière requête de cette liste. Dans le cas
    d'un résultat simple (pas d'ensemble), la première ligne du résultat de la
    dernière requête sera renvoyée (gardez à l'esprit que <quote>la première
    ligne</quote> d'un résultat multiligne n'est pas bien définie à moins
    d'utiliser <literal>ORDER BY</> ). Si la dernière requête de la liste ne
    renvoie aucune ligne, la valeur NULL est renvoyée.
   </para>

   <para>
    <indexterm><primary>SETOF</><seealso>fonction</></>
    Une fonction SQL peut être déclarée de façon à renvoyer un ensemble (set)
    en spécifiant le type renvoyé par la fonction comme <literal>SETOF
    <replaceable>untype</></literal>.<indexterm><primary>SETOF</></> Dans ce
    cas, toutes les lignes de la dernière requête sont renvoyées. Des détails
    supplémentaires sont donnés plus loin dans ce chapitre.
   </para>

   <para>
   Le corps d'une fonction SQL doit être constitué d'une liste d'une ou
   plusieurs instructions SQL séparées par des points-virgule. Notez que,
   puisque la syntaxe de la commande <command>CREATE FUNCTION</command> exige
   que le corps de la fonction soit enfermé entre des guillemets simples,
   ceux-ci (<literal>'</>) utilisés dans le corps de la fonction doivent être
   précédés par un autre guillemet simple (<literal>''</>) ou par un
   antislash (<literal>\'</>).
   </para>

   <para>
   Les arguments de la fonction SQL doivent être référencés dans le corps de la
   fonction en utilisant la syntaxe suivante.
   <literal>$<replaceable>n</></>:<literal>$1</> se référe au premier argument,
   <literal>$2</> au second et ainsi de suite. Si un argument est de type
   composite, on utilisera la notation par point, par exemple
   <literal>$1.name</literal>, pour accéder aux attributs de l'argument.
   </para>

   <sect2>
    <title>Fonctions <acronym>SQL</acronym> sur les types de base</title>

    <para>
    La fonction <acronym>SQL</acronym> la plus simple possible n'a pas
    d'argument et retourne un type de base tel que <type>integer</type>&nbsp;:
<screen>
CREATE FUNCTION un() RETURNS integer AS '
    SELECT 1 AS resultat;
' LANGUAGE SQL;

SELECT one();

 one
-----
   1
</screen>
    </para>

    <para>
    Notez que nous avons défini un alias de colonne avec le nom
    <literal>resultat</> dans le corps de la fonction pour se référer au
    résultat de la fonction mais cet alias n'est pas visible hors de la
    fonction. En effet, le résultat est nommé <literal>un</> au lieu de
    <literal>resultat</>.
    </para>

    <para>
    Il est presque aussi facile de définir des fonctions SQL acceptant des types
    de base comme arguments. Dans l'exemple suivant, remarquez comment nous
    faisons référence aux arguments dans le corps de la fonction avec  
    <literal>$1</> et <literal>$2</>. 

<screen>
CREATE FUNCTION ajoute(integer, integer) RETURNS integer AS '
    SELECT $1 + $2;
' LANGUAGE SQL;

SELECT ajoute(1, 2) AS reponse;

 answer
--------
      3
</screen>
    </para>

    <para>
    Voici une fonction plus utile, qui pourrait être utilisée pour débiter un
    compte bancaire&nbsp;:

<programlisting>
CREATE FUNCTION tf1 (integer, numeric) RETURNS integer AS '
    UPDATE bank 
        SET balance = balance - $2
        WHERE no_compte = $1;
    SELECT 1;
' LANGUAGE SQL;
</programlisting>

    Un utilisateur pourrait exécuter cette fonction pour débiter le compte 17 de
    100&nbsp;000&nbsp;euros ainsi&nbsp;:
<programlisting>SELECT tf1(17, 100.000);</programlisting>
    </para>
    
    <para>
    Dans la pratique, on préférera vraisemblablement un résultat plus utile que
    la constante 1. Une définition plus probable sera&nbsp;:

<programlisting>
CREATE FUNCTION tf1 (integer, numeric) RETURNS numeric AS '
    UPDATE bank 
        SET balance = balance - $2
        WHERE no_compte = $1;
    SELECT balance FROM banque WHERE no_compte = $1;
' LANGUAGE SQL;
</programlisting>

     qui ajuste le solde et renvoie sa nouvelle valeur.
    </para>

    <para>
    Une quelconque collection de commandes en langage <acronym>SQL</acronym>
    peut être rassemblée et définie comme une fonction. À côté des requêtes 
    <command>SELECT</command>, les commandes peuvent inclure la modification de
    données (c'est-à-dire <command>INSERT</command>, <command>UPDATE</command>,
    et <command>DELETE</command>). Toutefois, la commande finale doit être un
    <command>SELECT</command> qui renvoie un résultat du type spécifié par la
    fonction. Une autre solution, si vous voulez définir une fonction qui
    réalise une action mais n'a pas de valeur utile à renvoyer, est de la
    définir pour renvoyer un type  <type>void</>. Dans ce cas, le corps de la
    fonction ne doit pas finir par un <command>SELECT</command>. Par
    exemple&nbsp;:
<screen>
CREATE FUNCTION nettoie() RETURNS void AS '
    DELETE FROM emp
        WHERE salaire &lt;= 0;
' LANGUAGE SQL;

SELECT nettoie();

 clean_emp
-----------

(1 row)
</screen>
    </para>
   </sect2>

   <sect2>
    <title>Fonctions <acronym>SQL</acronym> sur les types composites</title>

    <para>
    Quand nous spécifions une fonction avec des arguments de types composite,
    nous devons non seulement spécifier quel argument utiliser (comme nous
    l'avons fait précédemment avec <literal>$1</> et <literal>$2</literal>),
    mais aussi spécifier l'attribut de cet argument. Par exemple, supposons que 
    <type>emp</type> soit le nom d'une table contenant des données sur les
    employés et donc également le nom du type composite correspondant à chaque
    ligne de la table. Voici une fonction <function>double_salaire</function>
    qui calcule ce que serait le salaire de quelqu'un s'il était doublé&nbsp;:

<screen>
CREATE TABLE emp (
    nom         text,
    salaire     integer,
    age         integer,
    cubicle     point
);

CREATE FUNCTION double_salaire(emp) RETURNS integer AS '
    SELECT $1.salaire * 2 AS salaire;
' LANGUAGE SQL;

SELECT name, double_salaire(emp) AS reve
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';

 name | reve
------+-------
 Sam  |  2400
</screen>
    </para>

    <para>
     Notez l'utilisation de la syntaxe <literal>$1.salaire</literal> pour
     sélectionner un champ dans la valeur de la ligne argument. Notez également
     comment la commande <command>SELECT</> utilise un nom de table pour
     définir la ligne courante de la table comme une valeur composite
     (<literal>emp</literal>). La ligne de la table peut aussi être référencée
     ainsi&nbsp;:
<screen>
SELECT name, double_salaire(emp.*) AS reve
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';
</screen>
     qui accentue sa nature 'ligne'.
    </para>

    <para>
    Il est aussi possible de construire une fonction qui renvoie un type
    composite. Voici un exemple de fonction renvoyant une seule ligne de type
    <type>emp</type>&nbsp;:

<programlisting>
CREATE FUNCTION nouvel_emp() RETURNS emp AS '
    SELECT text ''Aucun'' AS nom,
        1000 AS salaire,
        25 AS age,
        point ''(2,2)'' AS cubicle;
' LANGUAGE SQL;
</programlisting>

    Dans cet exemple, nous avons spécifié chacun des attributs avec une valeur
    constante, mais un quelconque calcul aurait pu être substitué à ces
    valeurs. 
    </para>

    <para>
    Notez deux aspects importants à propos de la définition de fonction&nbsp;:

     <itemizedlist>
      <listitem>
       <para>
       L'ordre de la liste du select doit être exactement le même que celui dans
       lequel les colonnes apparaissent dans la table associée au type
       composite (donner des noms aux colonnes dans le corps de la fonction,
       comme nous l'avons 
       fait dans l'exemple, n'a aucune interaction avec le système).
       </para>
      </listitem>
      <listitem>
       <para>
	Vous devez transtyper les expressions pour concorder avec la définition
       du type composite ou bien vous aurez l'erreur suivante&nbsp;:
<screen>
<computeroutput>
ERROR:  function declared to return emp returns varchar instead of text at
column 1
</computeroutput>
</screen>
       </para>
      </listitem>
     </itemizedlist>
    </para>     

    <para>
    Une fonction qui renvoie une ligne (type composite) peut être utilisée comme
    une fonction table, telle que celle décrite ci-dessous. Elle peut aussi être
    appellée dans le contexte d'une expression SQL, mais seulement si vous
    extrayez un seul attribut de la ligne ou si vous passez la ligne entière à
    une autre fonction qui accepte le même type composite.
   </para>

    <para>
     Voici un exemple d'extraction d'un attribut d'un type ligne&nbsp;:
<screen>
SELECT (nouveau_emp()).nom;

 name
------
 None
</screen>

    Nous avons besoin des parenthèses supplémentaires pour éviter une erreur de
    l'analyseur&nbsp;:
    <screen>
    SELECT 
nouveau_emp().nom;

ERROR:  syntax error at or near "." at character 17
</screen>
    </para>

    <para>
    Une autre option est d'utiliser la notation fonctionnelle pour extraire un
    attribut. La manière simple d'expliquer cela est de dire que nous pouvons
    échanger les notations <literal>attribut(table)</> et
    <literal>table.attribut</>.

<screen>
SELECT nom(nouveau_emp());

 name
------
 None
</screen>

<screen>
-- C'est la même chose que
-- SELECT emp.nom AS leplusjeune FROM emp WHERE emp.age &lt; 30

SELECT nom(emp) AS leplusjeune
    FROM emp
    WHERE age(emp) &lt; 30;

 leplusjeune
-------------
 Sam
</screen>
    </para>

    <para>
    L'autre façon d'utiliser une fonction renvoyant un résultat ligne est de
    déclarer une deuxième fonction acceptant un argument de type ligne et de lui
    passer le résultat de la première fonction&nbsp;:

<screen>
CREATE FUNCTION recupnom(emp) RETURNS text AS
'SELECT $1.nom;'
LANGUAGE SQL;

SELECT recupnom(nouveau_emp());
 recupnom
----------
 Aucun
(1 row)
</screen>
    </para>     
   </sect2>

   <sect2>
    <title>Fonctions <acronym>SQL</acronym> comme sources de table</title>

    <para>
    Toutes les fonctions SQL peuvent être utilisées dans la clause
    <literal>FROM</> d'une requête mais ceci est particulièrement utile pour les
    fonctions renvoyant des types composite. Si la fonction est définie pour
    renvoyer un type de base, la fonction table produit une table d'une seule
    colonne. Si la fonction est définie pour renvoyer un type composite, la
    fonction  table produit une colonne pour chaque attribut du type composite.
   </para>

    <para>
     Voici un exemple&nbsp;:

<screen>
CREATE TABLE foo (fooid int, foosousid int, foonom text);
INSERT INTO foo VALUES (1, 1, 'Joe');
INSERT INTO foo VALUES (1, 2, 'Ed');
INSERT INTO foo VALUES (2, 1, 'Mary');

CREATE FUNCTION recupfoo(int) RETURNS foo AS '
    SELECT * FROM foo WHERE fooid = $1;
' LANGUAGE SQL;

SELECT *, upper(fooname) FROM getfoo(1) AS t1;

 fooid | foosubid | fooname | upper
-------+----------+---------+-------
     1 |        1 | Joe     | JOE
(2 rows)
</screen>

    Comme le montre cet exemple, nous pouvons travailler avec les colonnes du
    résultat de la fonction comme s'il s'agissait des colonnes d'une table
    normale.
</para>

    <para>
    Notez que nous n'obtenons qu'une ligne comme résultat de la fonction. Ceci
    parce que nous n'avons pas utilisé l'instruction<literal>SETOF</>. Cette
    instruction est décrite dans la prochaine section.
    </para>
   </sect2>

   <sect2>
    <title>Fonctions <acronym>SQL</acronym> renvoyant un ensemble </title>

    <para>
     Quand une fonction SQL est déclarée renvoyer un <literal>SETOF
     <replaceable>untype</></literal>, la requête finale <command>SELECT</> de
     la fonction est complétement exécutée et chaque ligne extraite est renvoyée
     en tant qu'élément de l'ensemble résultat.
    </para>
    
    <para>
     Cette caractéristique est normalement utilisée lors de l'appel d'une
     fonction dans une clause <literal>FROM</>. Dans ce cas, chaque ligne
     renvoyée par la fonction devient une ligne de la table vue par la requête.
     Par exemple, supposons que la table <literal>foo</> ait le même contenu que
     précédemment et écrivons&nbsp;:

<programlisting>
CREATE FUNCTION recupfoo(int) RETURNS SETOF foo AS '
    SELECT * FROM foo WHERE fooid = $1;
' LANGUAGE SQL;

SELECT * FROM recupfoo(1) AS t1;
</programlisting>

     Alors nous obtenons&nbsp;:
<screen>
 fooid | foosousid | foonom
-------+-----------+--------
     1 |         1 | Joe
     1 |         2 | Ed
(2 rows)
</screen>
    </para>

    <para>
     Actuellement, les fonctions renvoyant des ensembles peuvent aussi être
     appelées dans la liste du select d'une requête. Pour chaque ligne générée
     par la requête, la fonction renvoyant un ensemble est appelée et une ligne
     est générée pour chaque élément de l'ensemble résultat. Notez cependant que
     cette fonctionnalité est déconseillée et pourra être supprimée dans des
     versions futures. Voici un exemple de fonction renvoyant un ensemble à
     partir de la liste d'un select&nbsp;:

<screen>
CREATE FUNCTION listeenfant(text) RETURNS SETOF text AS
'SELECT nom FROM noeuds WHERE parent = $1'
LANGUAGE SQL;

SELECT * FROM noeuds;
   nom        | parent
--------------+--------
 Haut         |
 Enfant1      | Haut
 Enfant2      | Haut
 Enfant3      | Haut
 Sous-Enfant1 | Enfant1
 Sous-Enfant2 | Enfant1
(6 rows)

SELECT listeenfant('Haut');
 listchildren
--------------
 Enfant1
 Enfant2
 Enfant3
(3 rows)

SELECT nom, listeenfant(nom) FROM noeuds;
  nom    | listchildren
---------+--------------
 Haut    | Enfant1
 Haut    | Enfant2
 Haut    | Enfant3
 Enfant1 | Sous-Enfant1
 Enfant1 | Sous-Enfant2
(5 rows)
</screen>

     Notez, dans le dernier <command>SELECT</command>, qu'aucune ligne n'est
     renvoyée pour <literal>Enfant2</>, <literal>Enfant3</>, etc. C'est parce
     que la fonction <function>listeenfant</function> renvoie un ensemble vide
     pour ces arguments et ainsi aucune ligne n'est générée.
 </para>
    </sect2>

   <sect2>
    <title>Fonctions <acronym>SQL</acronym> polymorphes</title>

    <para>
     Les fonctions <acronym>SQL</acronym> peuvent être déclarées pour accepter
     et renvoyer les types <quote>polymorphe</> <type>anyelement</type> et
     <type>anyarray</type>. Voyez la <xref linkend="types-polymorphic"> pour une
     explication plus approfondie. Voici une fonction polymorphe
     <function>cree_tableau</function> qui construit un tableau à partir de
     deux éléments de type arbitraire&nbsp;:

<screen>
CREATE FUNCTION cree_tableau(anyelement, anyelement) RETURNS anyarray AS '   
SELECT ARRAY[$1, $2];' 
LANGUAGE SQL;
SELECT cree_tableau(1, 2) AS tableau_entier, cree_tableau('a'::text, 'b') AS
tableau_texte;

 tableau_entier | tableau_texte
----------------+---------------
 {1,2}          | {a,b}
(1 row)
</screen>
    </para>

    <para>
     Notez l'utilisation du transtypage <literal>'a'::text</literal> pour
     spécifier le type <type>text</type> de l'argument. Ceci est nécessaire si
     l'argument est une chaîne de caractères car, autrement, il serait traité
     comme un type  <type>unknown</type>, et un tableau de type
     <type>unknown</type> n'est pas un type valide. Sans le transtypage, vous
     obtiendrez ce genre d'erreur&nbsp;:

<screen>
<computeroutput>
ERROR:  could not determine ANYARRAY/ANYELEMENT type because input is UNKNOWN
</computeroutput>
</screen>
    </para>

    <para>
     Il est permis d'avoir des arguments polymorphes avec un type de renvoi
     défini, mais non l'inverse. Par exemple&nbsp;:
 
<screen>
CREATE FUNCTION est_plus_grand(anyelement, anyelement) RETURNS bool AS '
    SELECT $1 > $2;
' LANGUAGE SQL;

SELECT est_plus_grand(1, 2);
 is_greater
------------
 f
(1 row)

CREATE FUNCTION fonction_invalide() RETURNS anyelement AS '
    SELECT 1;
' LANGUAGE SQL;
ERROR:  cannot determine result datatype
DETAIL:  A function returning ANYARRAY or ANYELEMENT must have at least one
argument of either type.
</screen>
    </para>
   </sect2>
  </sect1>

  <sect1 id="xfunc-pl">
   <title>Fonctions en langage de procédures</title>

   <para>
    Les langages de procédures ne sont pas compilés dans le serveur
    <productname>PostgreSQL</productname>&nbsp;; ils sont fournis comme des
    modules chargeables. Référez-vous à la documentation du langage concerné
    pour des précisions sur la syntaxe et sur la manière dont la fonction est
    interprétée.
   </para> 
     
   <para>
    Il y a actuellement quatre langages de procédures disponibles dans la
    distribution <productname>PostgreSQL</productname> standard&nbsp;:
     <application>PL/pgSQL</application>, <application>PL/Tcl</application>,
     <application>PL/Perl</application> et <application>PL/Python</application>.
 
    Référez-vous au <xref linkend="xplang"> pour plus d'informations. D'autres
    langages peuvent être définis par les utilisateurs. Les bases du
    développement d'un nouveau langage de procédures sont traitées dans le <xref
    linkend="plhandler">.   
   </para> 
 
 </sect1>
 
 <sect1 id="xfunc-internal">
   <title>Fonctions internes</title>

   <indexterm zone="xfunc-internal"><primary>fonction</><secondary>interne</></>

   <para>
    Les fonctions internes sont des fonctions écrites en C qui ont été liées de
    façon statique dans le serveur <productname>PostgreSQL</productname>. Le
    <quote>corps</quote> de la définition de la fonction spécifie le nom en 
    langage C de la fonction, qui n'est pas obligatoirement le même que le nom
    déclaré pour l'utilisation en SQL. (Pour des raisons de rétro compatibilité,
    un corps vide est accepté pour signifier que le nom de la fonction en
    langage C est le même que le nom SQL).

   </para>

   <para>
    Normalement, toutes les fonctions internes présentes dans le serveur sont
    déclarées pendant l'initialisation du groupe de base de données
    (<command>initdb</command>), mais un utilisateur peut utiliser la commande  
    <command>CREATE FUNCTION</command> pour créer des noms d'alias
    supplémentaires pour une fonction interne. Les fonctions internes sont
    déclarées dans la commande <command>CREATE FUNCTION</command> avec le nom
    de langage <literal>internal</literal>. Par exemple, pour créer un alias
    de la fonction <function>sqrt</function>&nbsp;:

<programlisting>
CREATE FUNCTION racine_carree(double precision) RETURNS double precision    AS
'dsqrt'    
LANGUAGE internal    STRICT;
</programlisting>
    
    (La plupart des fonctions internes doivent être déclarées 
    <quote>STRICT</quote>.)
   </para>

   <note>
    <para>
     Toutes les fonctions <quote>prédéfinies</quote> ne sont pas internes (au
     sens explicité ci-dessus). Quelques fonctions prédéfinies sont écrites en
     SQL.
    </para>
   </note>
  </sect1>

  <sect1 id="xfunc-c">
   <title>Fonctions en langage C</title>

   <indexterm zone="xfunc-sql">
    <primary>fonction</primary>
    <secondary>définie par l'utilisateur</secondary>
    <tertiary>en C</tertiary>
   </indexterm>

   <para>
    Les fonctions définies par l'utilisateur peuvent être écrites en C (ou dans
    un langage pouvant être rendu compatible avec C, comme C++). Ces fonctions
    sont compilées en objets dynamiques chargeables (encore appelés
    bibliothèques partagées) et sont chargées par le serveur à la demande. Cette
    caractéristique de chargement dynamique est ce qui distingue les fonctions
    en <quote>langage C</> des fonctions <quote>internes</> --- les véritables
    conventions de codage sont essentiellement les mêmes pour les deux. (C'est
    pourquoi la bibliothèque standard de fonctions internes est une source
    abondante d'exemples de code pour les fonctions C définies par
    l'utilisateur.)
  </para>
  
  <para>
    Deux différentes conventions d'appel sont actuellement en usage pour les
    fonctions C. La plus récente convention d'appel, <quote>version 1</quote>,
    est indiquée en écrivant une macro d'appel
    <literal>PG_FUNCTION_INFO_V1()</literal> comme illustré ci-après. L'absence
    d'une telle macro indique une fonction écrite selon l'ancien style
    (<quote>version 0</quote>). Le nom de langage spécifié dans la commande 
    <command>CREATE FUNCTION</command> est <literal>C</literal> dans les deux
    cas. Les fonctions suivant l'ancien style sont maintenant déconseillées en
    raison de problèmes de portanbilité et d'un manque de fonctionnalité, mais
    elles sont encore supportées pour des raisons de compatibilité.
 </para>  
 
  <sect2 id="xfunc-c-dynload">
   <title>Chargement dynamique</title>

   <indexterm zone="xfunc-c-dynload">
    <primary>dynamic loading</primary>
   </indexterm>
   
   <para>
    La première fois qu'une fonction définie par l'utilisateur dans un fichier
    objet particulier chargeable est appelée dans une session, le chargeur
    dynamique charge ce fichier objet en mémoire de telle sorte que la fonction 
    peut être appelée. La commande <command>CREATE FUNCTION</command> pour une
    fonction en C définie par l'utilisateur doit par conséquent spécifier deux
    éléments d'information pour la fonction&nbsp;: le nom du fichier objet
    chargeable et le nom en C (lien symbolique) de la fonction spécifique à
    appeler à l'intérieur de ce fichier objet. Si le nom en C n'est pas
    explicitement spécifié, il est supposé être le même que le nom de la
    fonction SQL. 
  </para> 
  
  <para>
    L'algorithme suivant, basé sur le nom donné dans la commande
    <command>CREATE FUNCTION</command>, est utilisé pour localiser le fichier
    objet partagé: &nbsp; 

    <orderedlist>
     <listitem>
      <para>
       Si le nom est un chemin absolu, le fichier est chargé.
      </para>
     </listitem>

     <listitem>
      <para>
       Si le nom commence par la chaîne <literal>$libdir</literal>, cette chaîne
       est remplacée par le nom du répertoire de la bibliothèque du paquetage
       <productname>PostgreSQL</>, qui est déterminé au moment de la 
       compilation. <indexterm><primary>$libdir</></>
      </para>
     </listitem>

     <listitem>
      <para>
       Si le nom ne contient pas de partie répertoire, le fichier est recherché
       par le chemin spécifié dans la variable de configuration
       <varname>dynamic_library_path</varname>.
       <indexterm><primary>dynamic_library_path</></>      
      </para>
     </listitem>

     <listitem>
      <para>
       Dans les autres cas, (nom de fichier non trouvé dans le chemin ou ne
       contenant pas de partie répertoire non absolu), le chargeur dynamique
       essaiera d'utiliser le nom donné, ce qui échouera très vraisemblablement.
       (Il n'est pas fiable de dépendre du répertoire de travail en cours.)
      </para>
     </listitem>
    </orderedlist>

    Si cette séquence ne fonctionne pas, l'extension pour les noms de fichier
    des bibliothèques partagées spécifique à la plateforme (souvent
    <filename>.so</filename>) est ajoutée au nom attribué et la séquence est à
    nouveau tentée. En cas de nouvel échec, le chargement échoue. 
 </para>

    <para>
     L'identifiant utilisateur sous lequel fonctionne le serveur
     <productname>PostgreSQL</productname> doit pouvoir suivre le chemin
     jusqu'au fichier que vous essayez de charger. C'est une erreur fréquente de
     définir le fichier ou un répertoire supérieur comme non lisible et/ou non
     exécutable par l'utilisateur <systemitem>postgres</systemitem>.
    </para>

   <para>
    Dans tous les cas, le nom de fichier donné dans la commande <command>CREATE
    FUNCTION</command> est enregistré littéralement dans les catalogues
    systèmes, de sorte que, si le fichier doit être à nouveau chargé, la même 
    procédure sera appliquée.
 </para>

   <note>
    <para>
     <productname>PostgreSQL</productname> ne compilera pas une fonction C
     automatiquement. Le fichier objet doit être compilé avant d'être référencé
     dans une commande <command>CREATE FUNCTION</>. Voir la <xref
    linkend="dfunc"> pour des informations complémentaires. 
   </para>
   </note>

   <para>
    Après avoir été utilisé pour la première fois, un fichier objet chargé
    dynamiquement est conservé en mémoire. Les futurs appels de fonction(s) dans
    ce fichier pendant la même session provoquerons seulement une légére
    surcharge due à la consultation d'une table de symboles. Si vous devez
    forcer le chargement d'un fichier objet, par exemple après une
    recompilation, utilisez la commande <command>LOAD</> ou commencez une
    nouvelle session.  
  </para>

   <para>
    Il est recommandé de localiser les bibliothèques dynamiques soit
    relativement à <literal>$libdir</literal> soit au moyen du chemin des
    bibliothèques dynamiques. Ceci simplifie la mise à jour dans le cas d'une
    nouvelle installation dans un endroit différent. Le répertoire effectif
    représenté par <literal>$libdir</literal> peut être retrouvé avec la
    commande <literal>pg_config --pkglibdir</literal>.  
   </para>

   <para>
    Avant la version 7.2 de <productname>PostgreSQL</productname>, seuls les
    chemins absolus exacts pouvaient être spécifiés dans la commande
    <command>CREATE FUNCTION</>. Cette approche est maintenant déconseillée car
    elle rend la définition de la fonction inutilement non portable. Il vaut
    mieux seulement spécifier le nom de la bibliothèque partagée sans chemin ni
    extension, et laisser le mécanisme de recherche générer cette information. 
   </para> 

  </sect2>

   <sect2 id="xfunc-c-basetype">
    <title>Types de base dans les fonctions en langage C</title>

    <indexterm zone="xfunc-c-basetype">
     <primary>type de données</primary>
     <secondary>organisation interne</secondary>
    </indexterm>

    <para>
     Pour savoir comment écrire des fonctions en langage C, vous devez savoir 
     comment <productname>PostgreSQL</productname> représente en interne les
     types de données de base et comment elles peuvent être passés vers et
     depuis les fonctions. En interne, <productname>PostgreSQL</productname>
     considère un type de base comme un <quote>blob de mémoire</quote>. Les
     fonctions que vous définissez sur un type définissent à leur tour la façon
     pour <productname>PostgreSQL</productname> d'opérer sur lui. C'est-à-dire
     que <productname>PostgreSQL</productname> ne fera que conserver et retouver
     les données sur le disque et utilisera votre fonction pour entrer, traiter
     et restituer les données.
    </para>
    
    <para>
     Les types de base peuvent avoir un des trois formats internes
     suivants&nbsp;:
     <itemizedlist>
      <listitem>
       <para>
	passage par valeur, longueur fixe&nbsp;;
       </para>
      </listitem>
      <listitem>
       <para>
	passage par référence, longueur fixe&nbsp;;
       </para>
      </listitem>
      <listitem>
       <para>
	passage par référence, longueur variable.
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     Les types par valeur peuvent seulement avoir une longueur de 1, 2 ou 4
     octets (également 8 octets si <literal>sizeof(Datum)</literal> est de huit
     octets sur votre machine). Vous devriez être attentif lors de la
     définition de vos types de sorte à qu'ils aient la même taille sur toutes
     les architectures. Par exemple, le type <literal>long</literal> est
     dangereux car il a une taille de quatre octets sur certaines machines et
     huit octets sur d'autres, alors que le type <type>int</type> est de quatre
     octets sur la plupart des machines Unix. Une implémentation raisonnable du
     type <type>int4</type> sur une machine Unix pourrait être
 
 <programlisting>
/* entier sur quatre octets, passé par valeur */
typedef int int4;
</programlisting>

    </para>

    <para>
     D'autre part, les types à longueur fixe d'une taille quelconque peuvent
     être passés par référence. Par exemple, voici l'implémentation d'un type
     <productname>PostgreSQL</productname>&nbsp;:

<programlisting>
/* structure de 16 octets, passée par référence */
typedef struct
{
    double  x, y;
} Point;
</programlisting>

     Seuls des pointeurs vers de tels types peuvent être utilisés en les passant
     dans et hors des fonctions <productname>PostgreSQL</productname>. Pour
     renvoyer une valeur d'un tel type, allouez la quantité appropriée de
     mémoire avec <literal>palloc</literal>, remplissez la mémoire allouée et
     renvoyez un pointeur vers elle. (Vous pouvez aussi renvoyer directement une
     valeur d'entrée qui a le même type que la valeur de retour en renvoyant le
     pointeur vers la valeur d'entrée. Cependant, <emphasis>ne jamais</>
     modifier le contenu d'une valeur d'entrée passée par référence.)
    </para>

    <para>
     Enfin, tous les types à longueur variable doivent aussi être passés par
     référence. Tous les types à longueur variable doivent commencer avec un
     champ d'une longueur d'exactement quatre octets et toutes les données
     devant être stockées dans ce type doivent être localisées dans la mémoire à
     la suite immédiate de ce champ longueur. Le champ longueur contient la
     longueur totale de la structure, c'est-à-dire incluant la longueur du
     champ longueur lui-même.
    </para>

    <para>
     Comme exemple, nous pouvons définir le type <type>text</type> comme
     ceci&nbsp;:

<programlisting>
typedef struct {
    int4 length;
    char data[1];
} text;
</programlisting>

     Il est évident que le champ déclaré ici n'est pas assez long pour contenir
     toutes les chaînes possibles. Comme il est impossible de déclarer une
     structure de taille variable en <acronym>C</acronym>, nous nous appuyons
     sur le fait que le compilateur  <acronym>C</acronym> ne vérifie pas la
     plage des indices de tableau. Nous allouons juste la quantité d'espace
     nécessaire et ensuite nous accédons au tableau comme s'il avait été déclaré
     avec la bonne longueur. (C'est une astuce courante que vous pouvez trouver
     dans beaucoup de manuels de C).
    </para>
    
    <para>
     En manipulant les types à longueur variable, nous devons être attentifs à
     allouer la quantité correcte de mémoire et à fixer correctement le champ
     longueur. Par exemple, si nous voulons stocker 40 octets dans une structure
     <structname>text</>, nous devrions utiliser un fragment de code comme
     celui-ci&nbsp;:

<programlisting>
#include "postgres.h"
...
char buffer[40]; /* notre donnée source */
...
text *destination = (text *) palloc(VARHDRSZ + 40);
destination-&gt;length = VARHDRSZ + 40;
memcpy(destination-&gt;data, buffer, 40);
...
</programlisting>

     <literal>VARHDRSZ</> est équivalent à <literal>sizeof(int4)</> mais
     est considéré comme une meilleure tournure de référence à la taille de
     l'overhead pour un type à longueur variable.
    </para>

    <para>
     <xref linkend="xfunc-c-type-table"> spécifie la correspondance entre
     les types C et les types SQL quand on écrit une fonction en langage C
     utilisant les types intégrés à <productname>PostgreSQL</>. La colonne
     <quote>Défini dans</quote> donne le fichier d'en-tête devant être inclus
     pour accéder à la définition du type. (La définition effective peut se
     trouver dans un fichier différent inclus dans le fichier indiqué. Il
     est recommandé que les utilisateurs s'en tiennent à l'interface définie.)
     Notez que vous devriez toujours inclure <filename>postgres.h</filename> en
     premier dans tout fichier source car il déclare un grand nombre d'éléments
     dont vous aurez besoin de toute façon. 
    </para>
    
    <table tocentry="1" id="xfunc-c-type-table">
      <title>Équivalence des types C et des types SQL intégrés</title>
      <tgroup cols="3">
       <thead>
	<row>
	 <entry>
	  Type SQL
	 </entry>
	 <entry>
	  Type C
	 </entry>
	 <entry>
	  Défini dans
	 </entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry><type>abstime</type></entry>
	 <entry><type>AbsoluteTime</type></entry>
	 <entry><filename>utils/nabstime.h</filename></entry>
	</row>
	<row>
	 <entry><type>boolean</type></entry>
	 <entry><type>bool</type></entry>
	 <entry><filename>postgres.h</filename> (intégration au
	  compilateur)</entry>
	</row>
	<row>
	 <entry><type>box</type></entry>
	 <entry><type>BOX*</type></entry>
	 <entry><filename>utils/geo_decls.h</filename></entry>
	</row>
	<row>
	 <entry><type>bytea</type></entry>
	 <entry><type>bytea*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>"char"</type></entry>
	 <entry><type>char</type></entry>
	 <entry>(intégré au compilateur)</entry>
	</row>
	<row>
	 <entry><type>character</type></entry>
	 <entry><type>BpChar*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>cid</type></entry>
	 <entry><type>CommandId</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>date</type></entry>
	 <entry><type>DateADT</type></entry>
	 <entry><filename>utils/date.h</filename></entry>
	</row>
	<row>
	 <entry><type>smallint</type> (<type>int2</type>)</entry>
	 <entry><type>int2</type> or <type>int16</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>int2vector</type></entry>
	 <entry><type>int2vector*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>integer</type> (<type>int4</type>)</entry>
	 <entry><type>int4</type> or <type>int32</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>real</type> (<type>float4</type>)</entry>
	 <entry><type>float4*</type></entry>
	<entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>double precision</type> (<type>float8</type>)</entry>
	 <entry><type>float8*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>interval</type></entry>
	 <entry><type>Interval*</type></entry>
	 <entry><filename>utils/timestamp.h</filename></entry>
	</row>
	<row>
	 <entry><type>lseg</type></entry>
	 <entry><type>LSEG*</type></entry>
	 <entry><filename>utils/geo_decls.h</filename></entry>
	</row>
	<row>
	 <entry><type>name</type></entry>
	 <entry><type>Name</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>oid</type></entry>
	 <entry><type>Oid</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>oidvector</type></entry>
	 <entry><type>oidvector*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>path</type></entry>
	 <entry><type>PATH*</type></entry>
	 <entry><filename>utils/geo_decls.h</filename></entry>
	</row>
	<row>
	 <entry><type>point</type></entry>
	 <entry><type>POINT*</type></entry>
	 <entry><filename>utils/geo_decls.h</filename></entry>
	</row>
	<row>
	 <entry><type>regproc</type></entry>
	 <entry><type>regproc</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>reltime</type></entry>
	 <entry><type>RelativeTime</type></entry>
	 <entry><filename>utils/nabstime.h</filename></entry>
	</row>
	<row>
	 <entry><type>text</type></entry>
	 <entry><type>text*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>tid</type></entry>
	 <entry><type>ItemPointer</type></entry>
	 <entry><filename>storage/itemptr.h</filename></entry>
	</row>
	<row>
	 <entry><type>time</type></entry>
	 <entry><type>TimeADT</type></entry>
	 <entry><filename>utils/date.h</filename></entry>
	</row>
	<row>
	 <entry><type>time with time zone</type></entry>
	 <entry><type>TimeTzADT</type></entry>
	 <entry><filename>utils/date.h</filename></entry>
	</row>
	<row>
	 <entry><type>timestamp</type></entry>
	 <entry><type>Timestamp*</type></entry>
	 <entry><filename>utils/timestamp.h</filename></entry>
	</row>
	<row>
	 <entry><type>tinterval</type></entry>
	 <entry><type>TimeInterval</type></entry>
	 <entry><filename>utils/nabstime.h</filename></entry>
	</row>
	<row>
	 <entry><type>varchar</type></entry>
	 <entry><type>VarChar*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>xid</type></entry>
	 <entry><type>TransactionId</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
       </tbody>
      </tgroup>
     </table>

    <para>
     Maintenant que nous avons passé en revue toutes les structures possibles
     pour les types de base, nous pouvons donner quelques exemples de vraies
     fonctions.
 </para>
   </sect2>

   <sect2>
    <title>Conventions d'appel de la version 0 pour les fonctions en langage
     C</title>

    <para>
     Nous présentons l'<quote>ancien style</quote> de convention d'appel en
     premier --- bien que cette approche soit maintenant déconseillée, elle est
     plus facile à maîtriser au début. Dans la méthode version-0, les arguments
     et résultats de la fonction C sont simplement déclarés dans le style C
     normal mais en faisant attention à utiliser la représentation C de chaque
     type de données SQL comme montré ci-dessus.
    </para>

    <para>
     Voici quelques exemples&nbsp;:

<programlisting>
#include "postgres.h"
#include &lt;string.h&gt;

/* par valeur */
         
int
add_one(int arg)
{
    return arg + 1;
}

/* par référence, taille fixe */

float8 *
add_one_float8(float8 *arg)
{
    float8    *result = (float8 *) palloc(sizeof(float8));

    *result = *arg + 1.0;
       
    return result;
}

Point *
makepoint(Point *pointx, Point *pointy)
{
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point->x = pointx->x;
    new_point->y = pointy->y;
       
    return new_point;
}

/* par référence, taille variable */

text *
copytext(text *t)
{
    /*
     * VARSIZE est la taille totale de la structure en octets.
     */
    text *new_t = (text *) palloc(VARSIZE(t));
    VARATT_SIZEP(new_t) = VARSIZE(t);
    /*
     * VARDATA est un pointeur sur la région de données de la structure.
     */
    memcpy((void *) VARDATA(new_t), /* destination */
           (void *) VARDATA(t),     /* source */
           VARSIZE(t)-VARHDRSZ);    /* nombre d'octets */
    return new_t;
}

text *
concat_text(text *arg1, text *arg2)
{
    int32 new_text_size = VARSIZE(arg1) + VARSIZE(arg2) - VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    VARATT_SIZEP(new_text) = new_text_size;
    memcpy(VARDATA(new_text), VARDATA(arg1), VARSIZE(arg1)-VARHDRSZ);
    memcpy(VARDATA(new_text) + (VARSIZE(arg1)-VARHDRSZ),
           VARDATA(arg2), VARSIZE(arg2)-VARHDRSZ);
    return new_text;
}
</programlisting>
    </para>

    <para>
     En supposant que le code ci-dessus ait été écrit dans le fichier
     <filename>funcs.c</filename> et compilé en objet partagé, nous pourrions
     définir les fonctions pour <productname>PostgreSQL</productname> avec des
     commandes comme ceci&nbsp;:
     
<programlisting>
CREATE FUNCTION add_one(integer) RETURNS integer
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one'
     LANGUAGE C STRICT;

-- notez la surcharge du nom de la fonction SQL "add_one"
CREATE FUNCTION add_one(double precision) RETURNS double precision
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one_float8'
     LANGUAGE C STRICT;

CREATE FUNCTION makepoint(point, point) RETURNS point
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'makepoint'
     LANGUAGE C STRICT;
                         
CREATE FUNCTION copytext(text) RETURNS text
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'copytext'
     LANGUAGE C STRICT;

CREATE FUNCTION concat_text(text, text) RETURNS text
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'concat_text',
     LANGUAGE C STRICT;
</programlisting>
    </para>

    <para>
     Ici, <replaceable>DIRECTORY</replaceable> représente le répertoire
     contenant le fichier de la bibliothèque partagée (par exemple le répertoire
     du tutoriel de <productname>PostgreSQL</productname>, qui contient le code
     des exemples utilisés dans cette section). (Un meilleur style aurait été
     d'écrire seulement <literal>'funcs'</> dans la clause <literal>AS</>, après
     avoir ajouté <replaceable>DIRECTORY</replaceable> au chemin de recherche.
     Dans tous les cas, nous pouvons omettre l'extension spécifique au système
     pour les bibliothèques partagées, communément <literal>.so</literal> ou    
     <literal>.sl</literal>.) 
    </para>

    <para>
     Remarquez que nous avons spécifié la fonction comme <quote>STRICT</quote>, 
     ce qui signifie que le système devra automatiquement supposer un résultat 
     NULL si n'importe quelle valeur d'entrée est NULL. Ainsi, nous évitons
     d'avoir à vérifier l'existence d'entrées NULL dans le code de la fonction.
     Sinon, nous aurions dû contôler explicitement les valeurs NULL en testant
     un pointeur NULL pour chaque argument passé par référence. (Pour les
     arguments passés par valeur, nous n'aurions même aucun moyen de contrôle!) 
    </para>

    <para>
     Bien que cette convention d'appel soit simple à utiliser, elle n'est pas
     très portable&nbsp;; sur certaines architectures,  il y a des problèmes
     pour passer de cette manière des types de données plus petits
     que <type>int</type>. De plus, il n'y a pas de moyen simple de renvoyer un
     résultat NULL, ni de traiter des arguments NULL autrement qu'en rendant la
     fonction strict. La convention version-1, présentée ci-après, permet de
     surmonter ces objections.
    </para>
    
   </sect2>
   
   <sect2>
    <title>Conventions d'appel de la version 1 pour les fonctions en langage
     C</title>

    <para>
     La convention d'appel version-1 repose sur des macros pour supprimer la
     plus grande partie de la complexité du passage d'arguments et de résultats.
     La déclaration C d'une fonction en version-1 est toujours&nbsp;:

<programlisting>
Datum funcname(PG_FUNCTION_ARGS)
</programlisting>

     De plus, la macro d'appel
<programlisting>
PG_FUNCTION_INFO_V1(funcname);
</programlisting>
     doit apparaître dans le même fichier source. (Par convention, elle est
     écrite juste avant la fonction elle-même.) Cette macro n'est pas nécessaire
     pour les fonctions <literal>internal</> puisque <productname>PostgreSQL</> 
     assume que toutes les fonctions internes utilisent la convention version-1.
     Elle est toutefois requise pour les fonctions chargées dynamiquement.
    </para>

    <para>
     Dans une fonction version-1, chaque argument existant est traité par une
     macro <function>PG_GETARG_<replaceable>xxx</replaceable>()</function> 
     correspondant au type de donnée de l'argument et le résultat est renvoyé
     par une macro
     <function>PG_RETURN_<replaceable>xxx</replaceable>()</function>
     correspondant au type renvoyé. 
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>
     prend comme argument le nombre d'arguments de la fonction à parcourir, le
     compteur commençant à 0.
     <function>PG_RETURN_<replaceable>xxx</replaceable>()</function> prend comme
     argument la valeur effective à renvoyer. 
    </para>

    <para>
     Voici la même fonction que précédement, codée en style version-1
     
<programlisting>
#include "postgres.h"
#include &lt;string.h&gt;
#include "fmgr.h"

/* par valeur */

PG_FUNCTION_INFO_V1(add_one);
         
Datum
add_one(PG_FUNCTION_ARGS)
{
    int32   arg = PG_GETARG_INT32(0);

    PG_RETURN_INT32(arg + 1);
}

/* par référence, longueur fixe */

PG_FUNCTION_INFO_V1(add_one_float8);

Datum
add_one_float8(PG_FUNCTION_ARGS)
{
    /* Les macros pou FLOAT8 cache sa nature de passage par référence. */
    float8   arg = PG_GETARG_FLOAT8(0);

    PG_RETURN_FLOAT8(arg + 1.0);
}

PG_FUNCTION_INFO_V1(makepoint);

Datum
makepoint(PG_FUNCTION_ARGS)
{
    /* Ici, la nature de passage par référence de Point n'est pas cachée. */
    Point     *pointx = PG_GETARG_POINT_P(0);
    Point     *pointy = PG_GETARG_POINT_P(1);
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point->x = pointx->x;
    new_point->y = pointy->y;
       
    PG_RETURN_POINT_P(new_point);
}

/* par référence, longueur variable */

PG_FUNCTION_INFO_V1(copytext);

Datum
copytext(PG_FUNCTION_ARGS)
{
    text     *t = PG_GETARG_TEXT_P(0);
    /*
     * VARSIZE est la longueur totale de la structure en octets.
     */
    text     *new_t = (text *) palloc(VARSIZE(t));
    VARATT_SIZEP(new_t) = VARSIZE(t);
    /*
     * VARDATA est un pointeur vers la région de données de la structure.
     */
    memcpy((void *) VARDATA(new_t), /* destination */
           (void *) VARDATA(t),     /* source */
           VARSIZE(t)-VARHDRSZ);    /* nombre d'octets */
    PG_RETURN_TEXT_P(new_t);
}

PG_FUNCTION_INFO_V1(concat_text);

Datum
concat_text(PG_FUNCTION_ARGS)
{
    text  *arg1 = PG_GETARG_TEXT_P(0);
    text  *arg2 = PG_GETARG_TEXT_P(1);
    int32 new_text_size = VARSIZE(arg1) + VARSIZE(arg2) - VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    VARATT_SIZEP(new_text) = new_text_size;
    memcpy(VARDATA(new_text), VARDATA(arg1), VARSIZE(arg1)-VARHDRSZ);
    memcpy(VARDATA(new_text) + (VARSIZE(arg1)-VARHDRSZ),
           VARDATA(arg2), VARSIZE(arg2)-VARHDRSZ);
    PG_RETURN_TEXT_P(new_text);
}
</programlisting>
    </para>

    <para>
     Les commandes <command>CREATE FUNCTION</command> sont les mêmes que pour
     leurs équivalents dans la version-0.
    </para>
        
    <para>
     Au premier coup d'oeil, les conventions de codage de la version-1 peuvent
     sembler inutilement obscures. Pourtant, elles offrent nombre
     d'améliorations car les macros peuvent cacher les détails superflus. Un
     exemple est donné par la fonction  <function>add_one_float8</> où nous
     n'avons plus besoin de prêter attention au fait que le type
     <type>float8</type> est passé par référence. Un autre exemple de
     simplification est donné par les macros pour les types à longueur variable
     <literal>GETARG</> qui permettent un traitement plus efficace des valeurs 
     <quote>toasted</quote> (compressées ou hors-ligne).  
    </para>
    
    <para>
     Une des grandes améliorations dans les fonctions version-1 est le meilleur
     traitement des entrées et des résultats NULL. La macro  
     <function>PG_ARGISNULL(<replaceable>n</>)</function> permet à une fonction
     de tester si chaque entrée est NULL. (Évidemment, ceci n'est nécessaire que
     pour les fonctions non déclarées <quote>STRICT</>.) Comme avec les macros 
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>, les
     arguments d'entrée sont comptés à partir de zéro. Notez qu'on doit se
     garder d'exécuter
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function> jusqu'à 
     ce qu'on ait vérifié que l'argument n'est pas NULL. Pour renvoyer un
     résultat NULL, exécutez la fonction
     <function>PG_RETURN_NULL()</function>&nbsp;; ceci convient aussi bien dans
     les fonctions STRICT que non STRICT.
    </para>
    
    <para>  
     Les autres options proposées dans l'interface du nouveau style sont deux
     variantes des macros 
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>. La
     première d'entre elles,
     <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>,  
     garantit le renvoi d'une copie de l'argument spécifié, où nous pouvons
     écrire en toute sécurité. (Les macros normales peuvent parfois renvoyer 
     un pointeur vers une valeur physiquement mise en mémoire dans une table qui
     ne doit pas être modifiée. En utilisant les macros
     <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>, on
     garantit l'écriture du résultat.) La seconde variante se compose des macros
     <function>PG_GETARG_<replaceable>xxx</replaceable>_SLICE()</function>
     qui prennent trois arguments. Le premier est le nombre d'argument de la
     fonction (comme ci-dessus). Le second et le troisième sont le décalage et
     la longueur du segment qui doit être renvoyé. Les décalages sont comptés à
     partir de zéro et une longueur négative demande le renvoi du reste de la
     valeur. Ces macros procurent un accès plus efficace à des parties de
     valeurs à grande dimension dans le cas où elles ont un type de stockage en
     mémoire <quote>external</quote>. (Le type de stockage d'une colonne peut
     être spécifié en utilisant <literal>ALTER TABLE
     <replaceable>tablename</replaceable> ALTER COLUMN
     <replaceable>colname</replaceable> SET STORAGE   
     <replaceable>typestockage</replaceable></literal>. 
     <replaceable>typestockage</replaceable> est un type parmi
     <literal>plain</>, <literal>external</>, <literal>extended</literal> ou
     <literal>main</>.)  
    </para>
    
    <para> 
     Enfin, les conventions d'appels de la version-1 rendent possible le renvoi
     de résultats d'ensemble (<xref linkend="xfunc-c-return-set">) et
     implémentent des fonctions trigger (déclencheur) (<xref
     linkend="triggers">) et des opérateurs d'appel de langage procédural (<xref
     linkend="plhandler">). Le code version-1 est aussi plus portable que celui
     de version-0 car il ne contrevient pas aux restrictions du protocole
     d'appel de fonction en C standard. Pour plus de détails, voyez 
     <filename>src/backend/utils/fmgr/README</filename> dans les fichiers 
     sources de la distribution.
    </para>
     
   </sect2>

   <sect2>
    <title>Écriture du code</title>

    <para>
     Avant de nous intéresser à des sujets plus avancés, nous devons discuter de
     quelques règles de codage des fonctions en langage C de
     <productname>PostgreSQL</productname>.  Bien qu'il soit possible de charger
     des fonctions écrites dans des langages autre que le C dans
     <productname>PostgreSQL</productname>, c'est habituellement difficile
     (quand c'est possible) parce que les autres langages comme C++, FORTRAN ou
     Pascal ne suivent pas fréquemment les mêmes conventions de nommage que le
     C. C'est-à-dire que les autres langages ne passent pas les arguments et ne 
     renvoient pas les valeurs entre fonctions de la même manière. Pour cette
     raison, nous supposerons que nos fonctions en langege C sont réellement
     écrites en C.
 </para>
    <para>
     Les règles de base pour l'écriture de fonctions C sont les suivantes&nbsp;:

     <itemizedlist>
      <listitem>
       <para>
        Utilisez <literal>pg_config
        --includedir-server</literal><indexterm><primary>pg_config</><secondary>
        avec des fonctions C définies par l'utilisateur</></> pour découvrir où
        sont installés les fichiers d'en-tête du serveur
        <productname>PostgreSQL</> sur votre système (ou sur le système de vos
        utilisateurs). Cette option est apparue dans <productname>PostgreSQL</>
        version 7.2. Pour <productname>PostgreSQL</> 7.1, vous devez utiliser
        l'option <option>--includedir</option>. (La commande
        <command>pg_config</command> terminera avec un statut différent de zéro
        si elle rencontre une option inconnue.) Pour les versions antérieures à
        la 7.1, vous devez deviner, mais puisque cela remonte avant
        l'introduction des conventions d'appel actuelles, il y a peu de chance
        que vous vouliez supporter ces versions.
       </para>
      </listitem>

      <listitem>
       <para>
        Quand vous allouez de la mémoire, utilisez les fonctions 
        <productname>PostgreSQL</productname>
        <function>palloc</function><indexterm><primary>palloc</></> et
        <function>pfree</function><indexterm><primary>pfree</></>
        au lieu des fonctions correspondantes <function>malloc</function> et
        <function>free</function> de la bibliothèque C. La mémoire allouée par
        <function>palloc</function> sera libérée automatiquement à la fin de
        chaque transaction, empêchant des débordements de mémoire. 
       </para>
      </listitem>

      <listitem>
       <para>
        Remettez toujours à zéro les octets de vos structures en utilisant
        <function>memset</function>. Sinon, il est difficile de supporter les
        index ou les jointures de découpage car vous devez retenir seulement
        les bits significatifs de votre structure de donnée pour calculer un
        découpage. Même si vous initialisez tous les champs de votre structure,
        il peut y avoir des remplissages d'alignement (trous dans la structure)
        pouvant contenir des valeurs parasites.
       </para>
      </listitem>

      <listitem>
       <para>
        La plupart des types internes <productname>PostgreSQL</productname>
        sont déclarés dans <filename>postgres.h</filename> alors que les
        interfaces de gestion des fonctions 
        (<symbol>PG_FUNCTION_ARGS</symbol>, etc.) sont dans 
        <filename>fmgr.h</filename>. Du coup, vous aurez besoin d'inclure au
        moins ces deux fichiers. Pour des raisons de portabilité, il vaut
        mieux inclure <filename>postgres.h</filename> <emphasis>en premier</>,
        avant tout autre fichier d'en-tête système ou utilisateur. En incluant
        <filename>postgres.h</filename>, il incluera également
        <filename>elog.h</filename> et <filename>palloc.h</filename> pour vous.
       </para>
      </listitem>

      <listitem>
       <para>
        Les noms de symboles définis dans les objets ne doivent pas entrer en
        conflit entre eux ou avec les symboles définis dans les exécutables du
        serveur <productname>PostgreSQL</productname>. Vous aurez à renommez vos
        fonctions ou variables si vous recevez un message d'erreur à cet effet.
       </para>
      </listitem>

      <listitem>
       <para>
        Compiler ou lier votre code pour qu'il soit chargé dynamiquement dans 
        <productname>PostgreSQL</productname> exige toujours des options
        spéciales. Voir la <xref linkend="dfunc"> pour une explication détaillée
        sur la meilleure façon de le faire sur votre système particulier. 
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>

&dfunc;

   <sect2>
    <title>Arguments de type composite dans les fonctions en langage C</title>
    
    <para>
     Les types composites n'ont pas une organisation fixe comme les structures
     en C. Des instances d'un type composite peuvent contenir des champs NULL.
     De plus, les types composites faisant partie d'une hiérarchie d'héritage
     peuvent avoir des champs différents des autres membres de la même
     hiérarchie. En conséquence, <productname>PostgreSQL</productname> propose
     une interface de fonction pour accéder depuis le C aux champs des types 
     composites. 
    </para>

    <para>
     Supposons que nous voulions écrire une fonction pour répondre à la requête
<programlisting>
SELECT nom, c_surpaye(emp, 1500) AS surpaye
    FROM emp
    WHERE nom = 'Bill' OR nom = 'Sam';
</programlisting>

     En utilisant les conventions d'appel de la version 0, nous pouvons définir
     <function>c_surpaye</> comme&nbsp;:
     
<programlisting>
#include "postgres.h"
#include "executor/executor.h"  /* pour GetAttributeByName() */

bool
c_surpaye(TupleTableSlot *t, /* la ligne courante d'emp */
           int32 limite)
{
    bool isNULL;
    int32 salaire;

    salaire = DatumGetInt32(GetAttributeByName(t, "salaire", &amp;isNULL));
    if (isNULL)
        return false;
    return salaire &gt; limite;
}
</programlisting>

     Dans le codage version-1, le code ci-dessus devient&nbsp;:

<programlisting>
#include "postgres.h"
#include "executor/executor.h"  /* pour GetAttributeByName() */

PG_FUNCTION_INFO_V1(c_overpaid);

Datum
c_overpaid(PG_FUNCTION_ARGS)
{
    TupleTableSlot  *t = (TupleTableSlot *) PG_GETARG_POINTER(0);
    int32            limite = PG_GETARG_INT32(1);
    bool isNULL;
    int32 salaire;

    salaire = DatumGetInt32(GetAttributeByName(t, "salaire", &amp;isNULL));
    if (isNULL)
        PG_RETURN_BOOL(false);
    /* Autrement, nous pourrions préférer de lancer PG_RETURN_NULL() pour un
       salaire NULL.
    */

    PG_RETURN_BOOL(salaire &gt; limite);
}
</programlisting>
    </para>

    <para>
     <function>GetAttributeByName</function> est la fonction système
     <productname>PostgreSQL</productname> qui renvoie les attributs depuis une
     colonne spécifiée. Elle a trois arguments&nbsp;: l'argument de type
     <type>TupleTableSlot*</type> passé à la fonction, le nom de l'attribut
     recherché et un paramètre renvoyé qui indique si l'attribut est NULL.  
     <function>GetAttributeByName</function> renvoie une valeur de type
     <type>Datum</type> que vous pouvez convertir dans un type voulu en
     utilisant la macro appropriée
     <function>DatumGet<replaceable>XXX</replaceable>()</function>.  
    </para> 
    
    <para> 
     La commande suivante déclare la fonction <function>c_surpaye</function>
     en SQL&nbsp;:

<programlisting>
CREATE FUNCTION c_surpaye(emp, integer) RETURNS boolean
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'c_surpaye'
    LANGUAGE C;
</programlisting>
    </para>
   </sect2>

   <sect2>
    <title>Renvoi de lignes (types composites) à partir de fonctions en langage
     C</title>
     
    <para>
     Pour renvoyer une ligne ou une valeur de type composite à partir d'une
     fonction en langage C, vous pouvez utiliser une API spéciale qui fournit
     les macros et les fonctions dissimulant en grande partie de la complexité
     liée à la construction de types de données composites. Pour utiliser cette
     API, le fichier source doit inclure&nbsp;:
 <programlisting>
 #include "funcapi.h"
</programlisting>
    </para>

    <para>
     L'assistance pour renvoyer des types de donnée composite (ou lignes)
     commence avec la structure <structname>AttInMetadata</>. Cette structure
     contient des tableaux d'information sur les attributs individuels,
     nécessaires pour créer une ligne à partir d'une chaîne C native.
     L'information contenue dans la structure est dérivée d'une structure
     <structname>TupleDesc</> mais elle est conservée de façon à éviter des
     calculs redondants à chaque appel d'une fonction renvoyant un ensemble
     (voir la section suivante). Dans le cas d'une fonction renvoyant un
     ensemble, la structure <structname>AttInMetadata</> doit être calculée une
     fois lors du premier appel et sauvegardée pour une réutilisation dans les
     appels ultérieurs. <structname>AttInMetadata</> conserve également un 
     pointeur vers la <structname>TupleDesc</> originale.

<programlisting>typedef struct AttInMetadata{
    /* TupleDesc complet */
    TupleDesc       tupdesc;

    /* tableau de type d'attributs en entrée pour la fonction finfo */
    FmgrInfo       *attinfuncs;

    /* tableau de type d'attributs typelem */
    Oid            *attelems;

    /* tableau d'attributs typmod */
    int32    	   *atttypmods;
}	AttInMetadata;
</programlisting>
    </para>

    <para>
     Pour vous aider à remplir cete structure, plusieurs fonctions et une macro
     sont disponibles. Utilisez
 
<programlisting>
TupleDesc RelationNameGetTupleDesc(const char *relname)
</programlisting>
    pour obtenir une <structname>TupleDesc</> pour une relation nommée ou
<programlisting>
TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)
</programlisting>
     pour obtenir une <structname>TupleDesc</> basée sur l'OID d'un type. Ceci
     peut être utilisé pour obtenir un <structname>TupleDesc</> soit pour un
     type de base, soit pour un type composite. Ensuite
<programlisting>
AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)
</programlisting>
     renverra un pointer vers une structure <structname>AttInMetadata</>,
     initialisée suivant la structure <structname>TupleDesc</> donnée.
     <structname>AttInMetadata</> peut être utilisée en conjonction avec des 
     chaînes C pour produire une valeur de ligne convenablement formée (appelée
     tuple en interne).
    </para>

    <para>
     Pour renvoyer un tuple, vous devez créer un emplacement basé sur
     <structname>TupleDesc</>. Vous pouvez utiliser
<programlisting>
TupleTableSlot *TupleDescGetSlot(TupleDesc tupdesc)
</programlisting>
     pour initialiser cet emplacement ou en obtenir un par d'autres moyens
     (fournis par l'utilisateur). L'emplacement est nécessaire pour créer un
     <type>Datum</> devant être renvoyé par la fonction. Le même emplacement
     peut (et doit) être réutilisé à chaque appel.
    </para>

    <para>
     Après avoir construit une structure <structname>AttInMetadata</>,
<programlisting>
HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)
</programlisting>
     peut être utilisé pour construire une structure <structname>HeapTuple</> 
     à partir de  données utilisateur sous forme de chaîne C.
     <literal>values</literal> est un tableau de chaînes C, une pour chaque
     attribut de la ligne renvoyée. Chaque chaîne C doit être de la forme
     attendue par la fonction d'entrée du type de donnée de l'attribut. Afin de
     renvoyer une valeur NULL pour un des attributs, le pointeur correspondant
     dans le tableau de valeurs (<parameter>values</>) doit être fixé à
     <symbol>NULL</>. Cette fonction demandera à être appelée pour chaque 
     ligne que vous renvoyez.
    </para>

    <para>
     La construction d'un tuple via <function>TupleDescGetAttInMetadata</> et
     <function>BuildTupleFromCStrings</> est appropriée seulement si votre
     fonction calcule naturellement les valeurs à renvoyer comme des chaînes de
     texte. Si votre code calcule naturellement les valeurs comme des ensembles
     de valeurs <type>Datum</>, vous devez à la place utiliser la fonction
     sous-jacente <function>heap_formtuple</> pour convertir directement les
     valeurs <type>Datum</type> en tuple. Vous aurez encore besoin de
     <structname>TupleDesc</> et d'un <structname>TupleTableSlot</>, mais non
     pas de <structname>AttInMetadata</>.
    </para>

    <para>
     Une fois que vous avez construit un tuple devant être renvoyé par votre
     fonction, vous devez le convertir en type <type>Datum</>. Utilisez
<programlisting>
TupleGetDatum(TupleTableSlot *slot, HeapTuple tuple)
</programlisting>
     pour obtenir un type <type>Datum</> pour un tuple et un emplacement donné.
     Ce <type>Datum</> peut être renvoyé directement si vous envisagez de
     renvoyer juste une simple ligne ou bien il peut être utilisé pour renvoyer
     la valeur courante dans une fonction renvoyant un ensemble.
  </para>

    <para>
     Un exemple figure dans la section suivante.
    </para>

   </sect2>

   <sect2 id="xfunc-c-return-set">
    <title>Renvoi d'ensembles depuis les fonctions en langage C</title>

    <para>
     Il existe aussi une API spéciale procurant le moyen de renvoyer des
     ensembles (lignes multiples) depuis une fonction en langage C. Une fonction
     renvoyant un ensemble doit suivre les conventions d'appel de la version-1. 
     Aussi, les fichiers source doivent inclure l'en-tête
     <filename>funcapi.h</filename>, comme ci-dessus.
    </para>

    <para>
     Une fonction renvoyant un ensemble (<acronym>SRF</> : <quote>set
     returning function</quote>) est appelée une fois pour chaque élément
     qu'elle renvoie. La <acronym>SRF</> doit donc sauvegarder suffisament
     l'état pour se rappeler ce qu'elle était en train de faire et renvoyer le
     prochain élément à chaque appel. La structure
     <structname>FuncCallContext</> est offerte pour assister le contrôle de ce
     processus. À l'intérieur d'une fonction,
     <literal>fcinfo-&gt;flinfo-&gt;fn_extra</> est utilisée pour conserver un
     pointeur vers <structname>FuncCallContext</> au cours des appels
     successifs.

<programlisting>
typedef struct
{
    /*
     * Number of times we've been called before
     * 
     * call_cntr is initialized to 0 for you by SRF_FIRSTCALL_INIT(), and
     * incremented for you every time SRF_RETURN_NEXT() is called.
     */
    uint32 call_cntr;

    /*
     * OPTIONAL maximum number of calls
     *
     * max_calls is here for convenience only and setting it is optional.
     * If not set, you must provide alternative means to know when the
     * function is done.
     */
    uint32 max_calls;

    /*
     * OPTIONAL pointer to result slot
     * 
     * slot is for use when returning tuples (i.e., composite data types)
     * and is not needed when returning base data types.
     */
    TupleTableSlot *slot;

    /*
     * OPTIONAL pointer to miscellaneous user-provided context information
     * 
     * user_fctx is for use as a pointer to your own data to retain
     * arbitrary context information between calls of your function.
     */
    void *user_fctx;

    /*
     * OPTIONAL pointer to struct containing attribute type input metadata
     * 
     * attinmeta is for use when returning tuples (i.e., composite data types)
     * and is not needed when returning base data types. It
     * is only needed if you intend to use BuildTupleFromCStrings() to create
     * the return tuple.
     */
    AttInMetadata *attinmeta;

    /*
     * memory context used for structures that must live for multiple calls
     *
     * multi_call_memory_ctx is set by SRF_FIRSTCALL_INIT() for you, and used
     * by SRF_RETURN_DONE() for cleanup. It is the most appropriate memory
     * context for any memory that is to be reused across multiple calls
     * of the SRF.
     */
    MemoryContext multi_call_memory_ctx;
} FuncCallContext;
</programlisting>
    </para>

    <para>
     Une <acronym>SRF</> utilise plusieurs fonctions et macros qui manipulent
     automatiquement la structure <structname>FuncCallContext</> (et s'attendent
     à la trouver via <literal>fn_extra</>). Utilisez
<programlisting>
SRF_IS_FIRSTCALL()
</programlisting>
     pour déterminer si votre fonction est appelée pour la première fois. Au
     premier appel, utilisez
<programlisting>
SRF_FIRSTCALL_INIT()
</programlisting>
     pour initialiser la structure <structname>FuncCallContext</>. À chaque
     appel de fonction, y compris le premier, utilisez 
<programlisting>
SRF_PERCALL_SETUP()
</programlisting>
     pour une mise à jour correcte en vue de l'utilisation de
     <structname>FuncCallContext</> et pour nettoyer toutes les données
     renvoyées précédemment et conservées depuis le dernier passage de la
     fonction.
    </para>

    <para>
     Si votre fonction a des données à renvoyer, utilisez 
<programlisting>
SRF_RETURN_NEXT(funcctx, result)
</programlisting>
     pour les renvoyer à l'appelant. (<literal>result</> doit être de type
     <type>Datum</>, soit une valeur simple, soit un tuple préparé comme décrit
     ci-dessus.) Enfin, quand votre fonction a fini de renvoyer des données,
     utilisez
<programlisting>
SRF_RETURN_DONE(funcctx)
</programlisting>
     pour nettoyer et terminer la <acronym>SRF</>.
    </para>

    <para>
     Le contexte mémoire courant lors de l'appel de la <acronym>SRF</> est un
     contexte transitoire qui est effacé entre les appels. Cela signifie que
     vous n'avez pas besoin d'appeler <function>pfree</> sur tout ce que vous
     avez alloué en utilisant <function>palloc</>&nbsp;; ce sera supprimé de
     toute façon. Toutefois, si vous voulez allouer des structures de données
     devant persister tout au long des appels, vous avez besoin de les conserver
     quelque part ailleurs. Le contexte mémoire référencé par
     <structfield>multi_call_memory_ctx</> est un endroit approprié pour toute
     donnée devant survivre jusqu'à l'achèvement de la fonction <acronym>SRF</>.
     Dans la plupart des cas, cela signifie que vous devrez basculer vers
     <structfield>multi_call_memory_ctx</> au moment de la préparation du
     premier appel.
 </para>  
   <para>
     Un exemple complet de pseudo-code ressemble à ceci&nbsp;:
<programlisting>
Datum
my_set_returning_function(PG_FUNCTION_ARGS)
{
    FuncCallContext  *funcctx;
    Datum             result;
    MemoryContext     oldcontext;
    <replaceable>further declarations as needed</replaceable>

    if (SRF_IS_FIRSTCALL())
    {
        funcctx = SRF_FIRSTCALL_INIT();
        oldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);
        /* One-time setup code appears here: */
        <replaceable>user code</replaceable>
        <replaceable>if returning composite</replaceable>
            <replaceable>build TupleDesc, and perhaps
AttInMetadata</replaceable>
            <replaceable>obtain slot</replaceable>
            funcctx-&gt;slot = slot;
        <replaceable>endif returning composite</replaceable>
        <replaceable>user code</replaceable>
        MemoryContextSwitchTo(oldcontext);
    }

    /* Each-time setup code appears here: */
    <replaceable>user code</replaceable>
    funcctx = SRF_PERCALL_SETUP();
    <replaceable>user code</replaceable>

    /* this is just one way we might test whether we are done: */
    if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)
    {
        /* Here we want to return another item: */
        <replaceable>user code</replaceable>
        <replaceable>obtain result Datum</replaceable>
        SRF_RETURN_NEXT(funcctx, result);
    }
    else
    {
        /* Here we are done returning items and just need to clean up: */
        <replaceable>user code</replaceable>
        SRF_RETURN_DONE(funcctx);
    }
}
</programlisting>
    </para>

    <para>
     Un exemple complet d'une simple <acronym>SRF</> retournant un type
     composite ressemble à ceci&nbsp;:
     <programlisting>
PG_FUNCTION_INFO_V1(testpassbyval);

Datum
testpassbyval(PG_FUNCTION_ARGS)
{
    FuncCallContext     *funcctx;
    int                  call_cntr;
    int                  max_calls;
    TupleDesc            tupdesc;
    TupleTableSlot      *slot;
    AttInMetadata       *attinmeta;

     /* stuff done only on the first call of the function */
     if (SRF_IS_FIRSTCALL())
     {
        MemoryContext	oldcontext;

        /* create a function context for cross-call persistence */
        funcctx = SRF_FIRSTCALL_INIT();

        /* switch to memory context appropriate for multiple function calls */
        oldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);

        /* total number of tuples to be returned */
        funcctx-&gt;max_calls = PG_GETARG_UINT32(0);

        /* Build a tuple description for a __testpassbyval tuple */
        tupdesc = RelationNameGetTupleDesc("__testpassbyval");

        /* allocate a slot for a tuple with this tupdesc */
        slot = TupleDescGetSlot(tupdesc);

        /* assign slot to function context */
        funcctx-&gt;slot = slot;

        /*
         * generate attribute metadata needed later to produce tuples from raw
         * C strings
         */
        attinmeta = TupleDescGetAttInMetadata(tupdesc);
        funcctx-&gt;attinmeta = attinmeta;

        MemoryContextSwitchTo(oldcontext);
    }

    /* stuff done on every call of the function */
    funcctx = SRF_PERCALL_SETUP();

    call_cntr = funcctx-&gt;call_cntr;
    max_calls = funcctx-&gt;max_calls;
    slot = funcctx-&gt;slot;
    attinmeta = funcctx-&gt;attinmeta;
 
    if (call_cntr &lt; max_calls)    /* do when there is more left to send */
    {
        char       **values;
        HeapTuple    tuple;
        Datum        result;

        /*
         * Prepare a values array for storage in our slot.
         * This should be an array of C strings which will
         * be processed later by the type input functions.
         */
        values = (char **) palloc(3 * sizeof(char *));
        values[0] = (char *) palloc(16 * sizeof(char));
        values[1] = (char *) palloc(16 * sizeof(char));
        values[2] = (char *) palloc(16 * sizeof(char));

        snprintf(values[0], 16, "%d", 1 * PG_GETARG_INT32(1));
        snprintf(values[1], 16, "%d", 2 * PG_GETARG_INT32(1));
        snprintf(values[2], 16, "%d", 3 * PG_GETARG_INT32(1));

        /* build a tuple */
        tuple = BuildTupleFromCStrings(attinmeta, values);

        /* make the tuple into a datum */
        result = TupleGetDatum(slot, tuple);

        /* clean up (this is not really necessary) */
        pfree(values[0]);
        pfree(values[1]);
        pfree(values[2]);
        pfree(values);

        SRF_RETURN_NEXT(funcctx, result);
    }
    else    /* do when there is no more left */
    {
        SRF_RETURN_DONE(funcctx);
    }
}
</programlisting>

     Le code SQL pour déclarer cette fonction est le suivant&nbsp;:
     
<programlisting>
CREATE TYPE __testpassbyval AS (f1 integer, f2 integer, f3 integer);

CREATE OR REPLACE FUNCTION testpassbyval(integer, integer) RETURNS SETOF
__testpassbyval
    AS '<replaceable>filename</>', 'testpassbyval'
    LANGUAGE C IMMUTABLE STRICT;
</programlisting>
    </para>

    <para>
     Le répertoire <filename>contrib/tablefunc</> situé dans les fichiers source
     de la distribution contient d'autres exemples de fonctions renvoyant des
     ensembles.</para>
   </sect2>

   <sect2>
    <title>Arguments polymorphes et types renvoyés</title>

    <para>
     Les fonctions en langage C peuvent être déclarées pour accepter et renvoyer
     les types <quote>polymorphes</> <type>anyelement</type> et
     <type>anyarray</type>. Voyez la <xref linkend="types-polymorphic"> pour une
     explication plus détaillée des fonctions polymorphes. Si les types des
     arguments ou du renvoi de la fonction sont définis comme polymorphes,
     l'auteur de la fonction ne peut pas savoir à l'avance quel type de données
     sera appelé ou bien quel type doit être renvoyé. Il y a deux routines
     offertes par <filename>fmgr.h</>  qui permettent à une fonction en
     version-1 de découvrir les types de données effectifs de ses arguments et
     le type qu'elle doit renvoyer. Ces routines s'appellent 
     <literal>get_fn_expr_rettype(FmgrInfo *flinfo)</> et 
     <literal>get_fn_expr_argtype(FmgrInfo *flinfo, int argnum)</>. Elles
     renvoient l'OID du type du résultat ou de l'argument ou InvalidOID si
     l'information n'est pas disponible. L'accès à la structure
     <literal>flinfo</> se fait normalement avec
     <literal>fcinfo-&gt;flinfo</>. Le paramètre <literal>argnum</> est basé à
     partir de zéro.
    </para>
    
    <para>
     Par exemple, supposons que nous voulions écrire une fonction qui accepte un
     argument de n'importe quel type et qui renvoie un tableau uni-dimensionnel
     de ce type&nbsp;:

<programlisting>
PG_FUNCTION_INFO_V1(make_array);
Datum
make_array(PG_FUNCTION_ARGS)
{
    ArrayType  *result;
    Oid         element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);
    Datum       element;
    int16       typlen;
    bool        typbyval;
    char        typalign;
    int         ndims;
    int         dims[MAXDIM];
    int         lbs[MAXDIM];

    if (!OidIsValid(element_type))
        elog(ERROR, "could not determine data type of input");

    /* get the provided element */
    element = PG_GETARG_DATUM(0);

    /* we have one dimension */
    ndims = 1;
    /* and one element */
    dims[0] = 1;
    /* and lower bound is 1 */
    lbs[0] = 1;

    /* get required info about the element type */
    get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval,
&amp;typalign);

    /* now build the array */
    result = construct_md_array(&amp;element, ndims, dims, lbs,
                                element_type, typlen, typbyval, typalign);

    PG_RETURN_ARRAYTYPE_P(result);
}
</programlisting>
    </para>

    <para>
     La commande suivante déclare la fonction <function>make_array</function> en
     SQL&nbsp;:

<programlisting>
CREATE FUNCTION make_array(anyelement) 
    RETURNS anyarray
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'make_array'
    LANGUAGE 'C' STRICT;
</programlisting>

     Notez l'utilisation de STRICT&nbsp;; ceci est primordial car le code ne se
     préoccupe pas de tester une entrée NULL.
    </para>
   </sect2>

   <sect2>
    <title>Arguments et codes de retour polymorphiques</title>

    <para>
     Les fonctions en langage C peuvent être déclarées pour accepter et recevoir
     des types polymorphiques <type>anyelement</type> et <type>anyarray</type>.
     Voir la <xref linkend="extend-types-polymorphic"> pour une explication plus
     détaillée des fonctions polymorphiques. Lorsque les arguments ou les codes
     de retour de la fonction sont définis comme des types polymorphiques,
     l'auteur de la fonction ne sait pas à l'avance avec quels types de données
     celle-ci sera appelée, ou quel type elle aura besoin de renvoyer. Il existe
     deux routines apportées par <filename>fmgr.h</> permettant à une fonction C
     en version 1 de découvrir les réels types de données des arguments et celui
     attendu en sortie. Les routines s'appellent
     <literal>get_fn_expr_rettype(FmgrInfo *flinfo)</> et
     <literal>get_fn_expr_argtype(FmgrInfo *flinfo, int argnum)</>. Elles
     renvoient le type de l'OID du résultat ou de l'argument. Si l'information
     n'est pas disponible, elles renvoient <symbol>InvalidOid</symbol>. La
     structure <literal>flinfo</> est normalement accédée comme
     <literal>fcinfo-&gt;flinfo</>. Le paramètre <literal>argnum</> commence à
     zéro.
    </para>

    <para>
     Par exemple, supposons que nous voulons écrire une fonction acceptant un
     seul élément de tout type et renvoyant un tableau à une dimension de ce
     type&nbsp;:

<programlisting>
PG_FUNCTION_INFO_V1(make_array);
Datum
make_array(PG_FUNCTION_ARGS)
{
    ArrayType  *result;
    Oid         element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);
    Datum       element;
    int16       typlen;
    bool        typbyval;
    char        typalign;
    int         ndims;
    int         dims[MAXDIM];
    int         lbs[MAXDIM];

    if (!OidIsValid(element_type))
        elog(ERROR, "could not determine data type of input");

    /* get the provided element */
    element = PG_GETARG_DATUM(0);

    /* we have one dimension */
    ndims = 1;
    /* and one element */
    dims[0] = 1;
    /* and lower bound is 1 */
    lbs[0] = 1;

    /* get required info about the element type */
    get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval,
&amp;typalign);

    /* now build the array */
    result = construct_md_array(&amp;element, ndims, dims, lbs,
                                element_type, typlen, typbyval, typalign);

    PG_RETURN_ARRAYTYPE_P(result);
}
</programlisting>
    </para>

    <para>
     La commande suivante déclare la fonction <function>make_array</function> en
     SQL&nbsp;:

<programlisting>
CREATE FUNCTION make_array(anyelement) RETURNS anyarray
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'make_array'
    LANGUAGE C STRICT;
</programlisting>

     Notez l'utilisation de <literal>STRICT</literal>&nbsp;; c'est essentiel car
     le code ne s'occupe pas de tester une entrée nulle.
    </para>
   </sect2>

  </sect1>

  <sect1 id="xfunc-overload">
   <title>Surcharge de fonction</title>

   <indexterm zone="xfunc-overload">
    <primary>surcharge</primary>
    <secondary>fonctions</secondary>
   </indexterm>

    <para>
     On peut définir plus d'une fonction avec le même nom SQL, à condition
     qu'elles acceptent des arguments différents. En d'autres termes, les noms
     de fonction peuvent être <firstterm>surchargés</firstterm>. Quand une 
     requête est exécutée, le serveur déterminera quelle fonction appeller en
     fonction du type de données et du nombre d'arguments fournis. La surcharge
     peut aussi être utilisée pour simuler des fonctions avec un nombre
     variable d'arguments, jusqu'à un nombre maximum fini.
    </para>
    
    <para>
     Une fonction peut aussi avoir le même nom qu'un attribut. (Rappelez-vous
     que <literal>attribute(table)</literal> est équivalent à
     <literal>table.attribute</literal>.) Dans le cas où il y a une ambiguité
     entre une fonction opérant sur un type complexe et un des attributs du type
     complexe, l'attribut sera toujours utilisé.
    </para>

    <para>
     Quand nous créons une famille de fonctions surchargées, il faut être
     attentif à ne pas créer d'ambiguités. Par exemple, pour les fonctions
<programlisting>
CREATE FUNCTION test(int, real) RETURNS ...
CREATE FUNCTION test(smallint, double precision) RETURNS ...
</programlisting>
     il n'est pas évident au premier abord de déterminer quelle fonction sera
     appelée par une entrée telle que <literal>test(1, 1.5)</literal>. Les
     règles de résolution implémentées actuellement sont décrites dans le <xref 
     linkend="typeconv"> mais il est peu judicieux de concevoir un système qui
     repose sur un comportement aussi subtil.
    </para>
    
    <para>
     Il existe une contrainte supplémentaire quand nous surchargeons une
     fonction C&nbsp;: le nom C de chaque fonction de la famille des fonctions
     surchargées doit être différent des noms C de toutes les autres fonctions,
     internes ou chargées dynamiquement. Si cette règle est violée, le
     comportement n'est pas portable. Vous pouvez avoir une erreur ou bien une
     des fonctions sera appelée (habituellement la fonction interne). La forme
     alternative de la clause <literal>AS</> de la commande SQL <command>CREATE
     FUNCTION</command> dissocie le nom SQL de la fonction du nom de la fonction
     dans le code source C. Par exemple, 

<programlisting>CREATE FUNCTION test(int) RETURNS int    AS 
'<replaceable>filename</>', 'test_1arg'    LANGUAGE C;
CREATE FUNCTION test(int, int) RETURNS int
    AS '<replaceable>filename</>', 'test_2arg'
    LANGUAGE C;
</programlisting>

     Les noms des fonctions C reflètent ici une des nombreuses conventions
     possibles.</para>
  </sect1>


<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-guillemet-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
