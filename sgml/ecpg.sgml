<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ecpg.sgml,v 1.7 2005/02/17 09:11:48 guillaume Exp $
-->

<chapter id="ecpg">
 <title><application>ECPG</application> - Embarquer <acronym>SQL</acronym> dans
  du C</title>

 <indexterm zone="ecpg"><primary>SQL embarqué</primary><secondary>dans du
  C</secondary></indexterm>
 <indexterm zone="ecpg"><primary>C</primary></indexterm>
 <indexterm zone="ecpg"><primary>ECPG</primary></indexterm>

 <para>
  Ce chapitre décrit le paquet <acronym>SQL</acronym> embarqué pour
  <productname>PostgreSQL</productname>. Il fonctionne avec le
  <acronym>C</acronym> et le <acronym>C++</acronym>. Il a été écrit par
  Linus Tolke (<email>linus@epact.se</email>) et Michael Meskes
  (<email>meskes@postgresql.org</email>).
 </para>

 <para>
  Il est clair que cette documentation est assez incomplète. Mais depuis que
  cette interface est standardisée, des informations supplémentaires sont
  disponibles grâce à de nombreuses ressources sur SQL.
 </para>

 <sect1 id="ecpg-concept">
  <title>Concept</title>

  <para>
   Un programme SQL embarqué consiste en du code écrit dans un langage de
   programmation ordinaire, dans ce cas le C, mixé avec des commandes SQL dans
   des sections spécialement marquées. Pour construire le programme, le code
   source est d'abord passé au préprocesseur SQL qui le convertit en un
   programme C ordinaire, puis il peut être traité par un outil de compilation
   C.
  </para>

  <para>
   Le <acronym>SQL</acronym> embarqué a des avantages sur les autres méthodes
   pour gérer les commandes <acronym>SQL</acronym> dans du code C. Tout d'abord,
   il s'ocuppe du passage ennuyant des informations de et vers les variables de
   votre programme <acronym>C</acronym>. Ensuite, le code SQL du programme est
   vérifié syntaxiquement au moment de la construction. Troisièmement, le
   <acronym>SQL</acronym> embarqué en C est spécifié dans le standard
   <acronym>SQL</acronym> et supporté par de nombreux systèmes de bases de
   données <acronym>SQL</acronym>. L'implémentation <productname>PostgreSQL</>
   est conçue pour correspondre à ce standard autant que possible, et il est
   habituellement possible de porter les programmes <acronym>SQL</acronym>
   embarqués écrit pour les autres bases de données SQL à
   <productname>PostgreSQL</productname> avec une relative facilité.
  </para>

  <para>
   Comme indiqué, les programmes écrit pour l'interface <acronym>SQL</acronym>
   embarquée sont des programmes C normaux avec un code spécial inséré pour
   réaliser les actions relatives à la base de données. Ce code spécial a
   toujours la forme
<programlisting>
EXEC SQL ...;
</programlisting>
   Ces instructions prennent syntaxiquement la place d'une instruction C.
   Suivant l'instruction particulière, elles pourraient apparaitre dans le
   contexte global ou à l'intérieur d'une fonction. Les instructions
   <acronym>SQL</acronym> embarquées suivent les règles de sensibilité à la
   casse d'un code <acronym>SQL</acronym> normal, et non pas ceux du C.
  </para>

  <para>
   Les sections suivantes expliquent toutes les instructions SQL embarquées.
  </para>
 </sect1>

 <sect1 id="ecpg-connect">
  <title>Se connecter au serveur de bases de données</title>

  <para>
   Vous vous connectez à une base de données en utilisant l'instruction
   suivante&nbsp;:
<programlisting>
EXEC SQL CONNECT TO <replaceable>cible</replaceable> <optional>AS
<replaceable>nom-connexion</replaceable></optional> <optional>USER
<replaceable>nom-utilisateur</replaceable></optional>;
</programlisting>
   La <replaceable>cible</replaceable> peut être spécifié par les façons
   suivantes&nbsp;:

   <itemizedlist>
    <listitem>
     <simpara><literal><replaceable>nombase</><optional>@<replaceable>nomhôte</>
      </optional><optional>:<replaceable>port</></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara><literal>tcp:postgresql://<replaceable>nomhôte</>
      <optional>:<replaceable>port</> </optional>
      <optional>/<replaceable>nombase</></optional><optional>?<replaceable>
      options</></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>unix:postgresql://<replaceable>nomhôte</><optional>:
      <replaceable>port</></optional><optional>/<replaceable>nombase</>
      </optional><optional>?<replaceable> options</></optional></literal>
     </simpara>
    </listitem>
 
    <listitem>
     <simpara>
      une chaîne SQL littérale contenant une des formes ci-dessus
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      une référence à une variable contenant une des formes ci-dessus (voir
      exemples)
     </simpara>
    </listitem>
 
    <listitem>
     <simpara>
      <literal>DEFAULT</literal>
     </simpara>
    </listitem>
   </itemizedlist>

   Si vous spécifiez la cible de connexion littéralement (c'est-à-dire via une
   variable de référence) et que vous ne mettez pas la valeur entre guillemets,
   alors les règles de sensibilité à la casse du SQL standard sont appliquées.
   Dans ce cas, vous pouvez aussi mettre entre guillemets doubles les paramètres
   individuels séparément si nécessaire. En pratique, utiliser des guillemets
   simples ou une variable de référence génère moins d'erreurs. La cible de
   connexion <literal>DEFAULT</literal> initie une connection sur la base de
   données par défaut de l'utilisateur par défaut. Aucun nom d'utilisateur ou
   nom de connexion ne pourrait être spécifié dans ce cas.
  </para>

  <para>
   Il existe différentes façons de donner le nom de l'utilisateur&nbsp;:

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>nomutilisateur</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>nomutilisateur</replaceable>/
      <replaceable>motdepasse</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>nomutilisateur</replaceable> IDENTIFIED BY
      <replaceable>motdepasse</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>nomutilisateur</replaceable> USING
      <replaceable>motdepasse</replaceable></literal>
     </simpara>
    </listitem>
   </itemizedlist>

   Comme indiqué ci-dessus, les paramètres
   <replaceable>nomutilisateur</replaceable> et
   <replaceable>motdepasse</replaceable> pourraient être un identifieur SQL, un
   littéral de type chaîne SQL string ou une référence à une variable de type
   caractère.
  </para>

  <para>
   <replaceable>nom-connexion</replaceable> est utilisé pour gérer plusieurs
   connexions dans un programme. Il peut être omis si un programme utilise
   seulement une connexion. La connexion la plus récemment ouverte devient la
   connexion courante, utilisée par défaut lorsqu'une instruction SQL est à
   exécuter (voir plus tard dans ce chapitre).
  </para>

  <para>
   Voici quelques exemples des instructions <command>CONNECT</command>&nbsp;:
<programlisting>
EXEC SQL CONNECT TO mabase@sql.mondomaine.com;

EXEC SQL CONNECT TO 'unix:postgresql://sql.mondomaine.com/mabase' AS
maconnexion USER john;

EXEC SQL BEGIN DECLARE SECTION;
const char *cible = "mabase@sql.mondomaine.com";
const char *utilisateur = "john";
EXEC SQL END DECLARE SECTION;
 ...
EXEC SQL CONNECT TO :cible USER :utilisateur;
</programlisting>
   La dernière forme utilise la variante référée ci-dessus comme
   variable de référence. Vous verrez dans les prochaines sections comment les
   variables C peuvent être utilisées dans des instructions SQL lorsque vous les
   préfixez avec un caractère deux-points.
  </para>

  <para>
   Soyez averti que le format de la cible de connexion n'est pas spécifié dans
   le standard SQL. Donc, si vous voulez développer des applications portables,
   vous devriez utiliser quelque chose basé sur le dernier exemple ci-dessus
   pour encapsuler la chaîne de la cible de connexion quelque part.
  </para>
 </sect1>

 <sect1 id="ecpg-disconnect">
  <title>Fermer une connexion</title>

  <para>
   Pour fermer une connexion, utilisez l'instruction suivante&nbsp;:
<programlisting>
EXEC SQL DISCONNECT <optional><replaceable>connexion</replaceable></optional>;
</programlisting>
   <replaceable>connexion</replaceable> peut être spécifié des façons
   suivantes&nbsp;:

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>nom-connexion</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>DEFAULT</literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>CURRENT</literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>ALL</literal>
     </simpara>
    </listitem>
   </itemizedlist>

   Si aucun nom de connexion n'est spécifié, la connexion en cours est fermée.
  </para>

  <para>
   Le style est meilleur si une application déconnecte toujours explicitement
   chaque connexion qu'elle a ouverte.
  </para>
 </sect1>

 <sect1 id="ecpg-commands">
  <title>Exécuter des commandes SQL</title>

  <para>
   Toute commande SQL peut être exécutée à l'intérieur d'une application SQL
   embarquée. Ci-dessous se trouvent quelques exemples de cela.
  </para>

  <para>
   Création d'une table&nbsp;:
<programlisting>
EXEC SQL CREATE TABLE foo (nombre integer, ascii char(16));
EXEC SQL CREATE UNIQUE INDEX num1 ON foo(nombre);
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
   Insérer des lignes&nbsp;:
<programlisting>
EXEC SQL INSERT INTO foo (nombre, ascii) VALUES (9999, 'doodad');
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
   Supprimer des lignes&nbsp;:
<programlisting>
EXEC SQL DELETE FROM foo WHERE nombre = 9999;
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
   Sélection d'une ligne&nbsp;:
<programlisting>
EXEC SQL SELECT foo INTO :FooBar FROM table1 WHERE ascii = 'doodad';
</programlisting>
  </para>

  <para>
   Sélection utilisant des curseurs&nbsp;:
<programlisting>
EXEC SQL DECLARE foo_bar CURSOR FOR
    SELECT nombre, ascii FROM foo
    ORDER BY ascii;
EXEC SQL OPEN foo_bar;
EXEC SQL FETCH foo_bar INTO :FooBar, DooDad;
...
EXEC SQL CLOSE foo_bar;
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
   Mises à jour&nbsp;:
<programlisting>
EXEC SQL UPDATE foo
    SET ascii = 'foobar'
    WHERE nombre = 9999;
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
   Les jetons de la forme
   <literal>:<replaceable>quelquechose</replaceable></literal> sont des
   <firstterm>variables hôte</firstterm>, c'est-à-dire qu'ils font référence
   à des variables dans le programme C. Ils sont expliqués dans <xref
   linkend="ecpg-variables">.
  </para>

  <para>
   Dans le mode par défaut, les instructions sont validées seulement lorsque
   <command>EXEC SQL COMMIT</command> est exécuté. L'interface SQL embarquée
   supporte aussi la validation automatique des transactions (aussi connue des
   autres interfaces) via l'option <option>-t</option> en ligne de commande pour
   <command>ecpg</command> (voir ci-dessous) ou via l'instruction <literal>EXEC
   SQL SET AUTOCOMMIT TO ON</literal>. En mode de validation automatique, chaque
   commande est automatiquement validée sauf si elle est à l'intérieur d'un bloc
   de transaction explicite. Ce mode peut être explicitement désactivé en
   utilisant <literal>EXEC SQL SET AUTOCOMMIT TO OFF</literal>.
  </para>
 </sect1>

 <sect1 id="ecpg-set-connection">
  <title>Choisir une connexion</title>

  <para>
   Les instructions SQL affichées dans la section précédente sont exécutées à
   partir de la connexion courante, c'est-à-dire celle qui a été ouverte la
   dernière. Si une application a besoin de gérer plusieurs connexions, alors il
   existe deux façons de gérer ceci.
  </para>

  <para>
   La première option est de choisir explicitement une connexion pour chaque
   instruction SQL, par exemple
<programlisting>
EXEC SQL AT <replaceable>nom-connexion</replaceable> SELECT ...;
</programlisting>
   Cette option est particulièrement intéressante si l'application a besoin
   d'utiliser plusieurs connexions en ordre divers.
  </para>

  <para>
   La seconde option est d'exécuter une instruction pour basculer la connexion
   courante. L'instruction est&nbsp;:
<programlisting>
EXEC SQL SET CONNECTION <replaceable>connection-name</replaceable>;
</programlisting>
   Cette option est particulièrement intéressante si un grand nombre
   d'instructions doivent être exécutées à partir de la même connexion. Il n'a
   pas conscience des threads.
  </para>
 </sect1>

 <sect1 id="ecpg-variables">
  <title>Utiliser des variables hôtes</title>

  <para>
   Dans <xref linkend="ecpg-commands">, vous avez vu comment exécuter des
   instructions SQL à partir d'un programme SQL embarqué. Quelques-unes de ces
   instructions utilisent seulement des valeurs fixes et ne fournissent pas de
   moyen pour insérer des valeurs fournies par l'utilisateur dans des
   instructions ou pour que le programme traite les valeurs renvoyées par la
   requête. Ces types d'instructions ne sont pas vraiment utiles dans les
   applications réelles. Cette section explique en détail comment vous pouvez
   passer des données entre votre programme C et les instructions SQL embarquées
   en utilisant un mécanisme simple appelé les <firstterm>variables
   hôtes</firstterm>.
  </para>

  <sect2>
   <title>Aperçu</title>

   <para>
    Passer des données entre le programme C et les instructions SQL est
    particulièrement simple en SQL embarqué. Au lieu que le programme copie les
    données dans l'instruction, ce qui implique plusieurs complications, telles
    que la bonne mise entre guillemets de la valeur, vous pouvez simplement
    écrire le nom de la variable C dans l'instruction SQL en la préfixant par un
    caractère deux-points. Par exemple:
<programlisting>
EXEC SQL INSERT INTO unetable VALUES (:v1, 'foo', :v2);
</programlisting>
    Cette instruction fait référence à deux variables C nommées
    <varname>v1</varname> et <varname>v2</varname> et utilise aussi une
    chaîne littérale SQL pour illustrer que vous n'êtes pas restreint à utiliser
    un type de données ou un autre.
   </para>

   <para>
    Ce style d'insertions de variables C dans des instructions SQL fonctionne
partout où une expression de valeur est attendue dans une instruction SQL. Dans
l'environemment SQL, nous appelons les références à des variables C
des <firstterm>variables hôte</firstterm>.
   </para>
  </sect2>

  <sect2>
   <title>Sections de déclaration</title>

   <para>
    Pour passer des données du programme à la base de données, par exemple
    comme paramètre d'une requête, ou pour passer des données de la base vers le
    programme, les variables C supposées contenir ces données doivent être
    déclarées dans des sections spécialement marquées pour que le préprocesseur
    du SQL embarqué soit averti de leur présence.
   </para>

   <para>
    Cette section commence avec
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
</programlisting>
    et se termine avec
<programlisting>
EXEC SQL END DECLARE SECTION;
</programlisting>
    Entre ces lignes, il y a des déclarations normales de variables C, comme
<programlisting>
int   x;
char  foo[16], bar[16];
</programlisting>
    Vous pouvez avoir autant de sections de déclaration dans un programme que
    vous le souhaitez.
   </para>

   <para>
    Les declarations sont aussi placées dans le fichier de sortie comme des
    variables C normales, du coup, il n'est plus besoin de les déclarer de
    nouveau. Les variables qui n'ont pas pour but d'être utilisées dans des
    commandes SQL peuvent être normalement déclarées en dehors des sections
    spéciales.
   </para>

   <para>
    La définition d'une structure ou union peut aussi être saisie dans une
    section <literal>DECLARE</>. Sinon, le préprocesseur ne peut pas
    gérer ces types car il ne connaît pas leur définition.
   </para>

   <para>
    Le type spécial <type>VARCHAR</type> est converti dans une <type>struct</>
    nommée pour chaque variable. Une déclaration comme
<programlisting>
VARCHAR var[180];
</programlisting>
    est convertie en
<programlisting>
struct varchar_var { int len; char arr[180]; } var;
</programlisting>
    Cette structure est convenable pour interface des données SQL de type
    <type>varchar</type>.
   </para>
  </sect2>

  <sect2>
   <title><command>SELECT INTO</command> et <command>FETCH
    INTO</command></title>

   <para>
    Maintenant, vous devez êter capable de passer des données générées par votre
    programme dans une commance SQL. Mais comment récupérer les résultats d'une
    requête&nbsp;? Dans ce but, le SQL embarqué fournit des variantes spéciales
    des commandes habituelles <command>SELECT</command> et
    <command>FETCH</command>. Ces commandes ont une clause
    <literal>INTO</literal> spéciale qui sépcifient les variables hôtes dans
    lesquelles seront stockée s les valeurs récupérées.
   </para>

   <para>
    Voici un exemple&nbsp;:
<programlisting>
/*
 * Supposons cette table :
 * CREATE TABLE test1 (a int, b varchar(50));
 */

EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL SELECT a, b INTO :v1, :v2 FROM test;
</programlisting>
    Donc, la clause <literal>INTO</literal> apparaît entre la liste select et
    la clause <literal>FROM</literal>. Le nombre d'éléments dans la liste select
    et celui de la liste après <literal>INTO</literal> (aussi appelée liste
    cible) doivent être identiques.
   </para>

   <para>
    Voici un exemple utilisant la commande <command>FETCH</command>&nbsp;:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL DECLARE foo CURSOR FOR SELECT a, b FROM test;

 ...

do {
    ...
    EXEC SQL FETCH NEXT FROM foo INTO :v1, :v2;
    ...
} while (...);
</programlisting>
    Ici, la clause <literal>INTO</literal> apparaît après toutes les autres
    clauses.
   </para>

   <para>
    Ces deux méthodes permettent seulement de récupérer une ligne à la
    fois. Si vous avez besoin de traiter des ensembles de résultats
    contentant potentiellement plus d'une ligne, vous devez utiliser un
    curseur, comme indiqué dans le second exemple.
   </para>
  </sect2>

  <sect2>
   <title>Indicateurs</title>

   <para>
    Les exemples ci-dessus ne gèrent pas les valeurs null. En fait, les
    exemples de récupération afficheront une erreur si elles récupèrent une
    valeur null à partir de la base de données. Pour être capable de passer des
    valeurs null à la base de données ou de récupérer des valeurs null de la
    base de données, vous avez besoin d'ajouter une deuxième spécification de
    variable hôte pour chaque variable hôte contenant des données. Cette seconde
    variable est appelée l'<firstterm>indicateur</firstterm> et contient un
    drapeau indiquant si la valeur est null, auquel cas le valeur de la variable
    hôte réelle est ignorée. Voici un exemple qui gère correctement la
    récupération de valeurs nulls&nbsp;:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
VARCHAR val;
int val_ind;
EXEC SQL END DECLARE SECTION:

 ...

EXEC SQL SELECT b INTO :val :val_ind FROM test1;
</programlisting>
    La variable indicateur <varname>val_ind</varname> sera zéro si la valeur
    est non nul et elle sera négative si la valeur est null.
   </para>

   <para>
    L'indicateur a une autre fonction&nbsp;: si la valeur de l'indicateur est
    positive, cela signifie que la valeur est non null mais elle a été
    tronquée lors de son stockage dans la variable hôte.
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-dynamic">
  <title>SQL dynamique</title>

  <para>
   Dans de nombreux cas, les instructions SQL particulières qu'une application
   doit exécuter sont connues au moment de l'écriture de l'application.
   Néanmoins, dans certains cas, les instructions SQL sont composées à
   l'exécution ou fournies par une source externe. Dans ces cas, vous ne pouvez
   pas embarqué directement les instructions SQL dans le code source C, mais il
   existe un moyen qui vous permet d'appeler des instructions SQL arbitraires
   que vous fournissez par l'intermédiaire d'une variable de type chaîne.
  </para>

  <para>
   La façon la plus simple d'exécuter une instruction SQL arbitraire est 
   d'utiliser la commande <command>EXECUTE IMMEDIATE</command>. Par
   exemple&nbsp;:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "CREATE TABLE test1 (...);";
EXEC SQL END DECLARE SECTION;

EXEC SQL EXECUTE IMMEDIATE :stmt;
</programlisting>
   Vous pourriez ne pas exécuter d'instructions de ce type pour récupérer des
   données (c'est-à-dire un <command>SELECT</command>).
  </para>

  <para>
   Une façon plus puissante d'exécuter des instructions SQL arbitraires est de
   les préparer une fois et de les exécuter aussi souvent que nécessaire. Il est
   aussi possible de préparer une version généralisée d'une instruction, puis
   d'exécuter les versions spécifiques en substituant les paramètres. Lors de la
   préparation de l'instruction, écrivez des points d'interrogation là où vous
   souhaitez substituer des paramètres plus tard. Par exemple&nbsp;:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "INSERT INTO test1 VALUES(?, ?);";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt USING 42, 'foobar';
</programlisting>
   Si l'instruction que vous exécutez renvoie des valeurs, alors ajoutez une
   clause <literal>INTO</literal>&nbsp;:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "SELECT a, b, c FROM test1 WHERE a > ?";
int v1, v2;
VARCHAR v3;
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt INTO v1, v2, v3 USING 37;
</programlisting>
   Une commande <command>EXECUTE</command> peut avoir une clause
   <literal>INTO</literal>, une clause <literal>USING</literal>, ou les deux ou
   encore aucune.
  </para>

  <para>
   Lorsque vous n'avez plus besoin de l'instruction préparée, vous devriez la
   désallouer&nbsp;:
<programlisting>
EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;
</programlisting>
  </para>
 </sect1>

 <sect1 id="ecpg-descriptors">
  <title>Utiliser les aires des descripteurs SQL</title>

  <para>
   Une aire d'un descripteur SQL est une méthode plus sophistiquée pour traiter
   le résultat d'un <command>SELECT</command> ou d'un <command>FETCH</command>.
   L'aire du descripteur SQL groupe les données d'une ligne avec les éléments de
   métadonnées en une structure de données. Les métadonnées sont
   particulièrement utiles lors de l'exécution d'instructions SQL dynamiques
   quand la nature des colonnes de résultats pourraient ne pas être connues à
   temps.
  </para>

  <para>
   Une aire d'un descripteur SQL consiste en un en-tête, contenant des
   informations concernant le descripteur entier, et un ou plusieurs éléments
   des aires du descripteur, décrivant basiquement une colonne de la ligne de
   résultat.
  </para>

  <para>
   Avant d'utiliser une aire d'un descripteur SQL, vous avez besoin d'en
   allouer une&nbsp;:
<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR <replaceable>identifier</replaceable>;
</programlisting>
   L'identifieur sert comme <quote>nom de variable</quote> de l'aire du
   descripteur. <comment>Quel est la portée du descripteur
   alloué&nbsp;?.</comment> Lorsque vous n'avez plus besoin du descripteur, vous
   devriez le libérer&nbsp;:
<programlisting>
EXEC SQL DEALLOCATE DESCRIPTOR <replaceable>identifieur</replaceable>;
</programlisting>
  </para>

  <para>
   Pour utiliser l'aire d'un descripteur, spécifiez-le comme cible de
   stockage dans une clause <literal>INTO</literal>, au lieu de lister les
   variables hôte&nbsp;:
<programlisting>
EXEC SQL FETCH NEXT FROM moncurseur INTO DESCRIPTOR mondesc;
</programlisting>
  </para>

  <para>
   Maintenant, comment récupérer les données de l'aire du descripteur&nbsp;?
   vous pouvez imaginer l'aire comme une structure avec des champs nommés. Pour 
   récupérer la valeur d'un champ à partir de l'en-tête et le stocker dans une
   variable hôte, utilisez la commande suivante&nbsp;:
<programlisting>
EXEC SQL GET DESCRIPTOR <replaceable>nom</replaceable>
:<replaceable>varhote</replaceable> = <replaceable>champ</replaceable>;
</programlisting>
   Actuellement, il n'existe qu'un seul champ d'en-tête défini&nbsp;:
   <replaceable>COUNT</replaceable>, qui indique le nombre d'éléments dans
   l'aire de descripteur (c'est-à-dire le nombre de colonnes contenues dans le
   résultat). La variable hôte a besoin d'être du type entier. Pour récupérer 
   un champ à partir de l'élément de l'aire du descripteur, utilisez la commande
   suivante&nbsp;:
<programlisting>
EXEC SQL GET DESCRIPTOR <replaceable>nom</replaceable> VALUE
<replaceable>numero</replaceable> :<replaceable>arhote</replaceable> =
<replaceable>champ</replaceable>;
</programlisting>
   <replaceable>numero</replaceable> peut être un entier litéral ou une
   variable hôte contenant un entier. Les champs possibles sont&nbsp;:

   <variablelist>
    <varlistentry>
     <term><literal>CARDINALITY</literal> (integer)</term>
     <listitem>
      <para>
       nombre de lignes dans l'ensemble du résultat
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>DATA</literal></term>
     <listitem>
      <para>
       élément de données en cours (de coup, le type de données de ce champ
       dépend de la requête)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>DATETIME_INTERVAL_CODE</literal> (integer)</term>
     <listitem>
      <para>
       ?
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>DATETIME_INTERVAL_PRECISION</literal> (integer)</term>
     <listitem>
      <para>
       non implémenté
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>INDICATOR</literal> (integer)</term>
     <listitem>
      <para>
       l'indicateur (indiquant une valeur null ou un tronquage de la
       valeur)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>KEY_MEMBER</literal> (integer)</term>
     <listitem>
      <para>
       non implémenté
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>LENGTH</literal> (integer)</term>
     <listitem>
      <para>
       longueur de la données en caractères
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>NAME</literal> (string)</term>
     <listitem>
      <para>
       nom de la colonne
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>NULLABLE</literal> (integer)</term>
     <listitem>
      <para>
       non implémenté
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>OCTET_LENGTH</literal> (integer)</term>
     <listitem>
      <para>
       longueur de la représentation caractères de la données en octets
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>PRECISION</literal> (integer)</term>
     <listitem>
      <para>
       précision (pour le type <type>numeric</type>)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>RETURNED_LENGTH</literal> (integer)</term>
     <listitem>
      <para>
       longueur de la donnée en caractère
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>RETURNED_OCTET_LENGTH</literal> (integer)</term>
     <listitem>
      <para>
       longueur de la représentation caractère de la données en octets
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>SCALE</literal> (integer)</term>
     <listitem>
      <para>
       échelle (pour le type <type>numeric</type>)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TYPE</literal> (integer)</term>
     <listitem>
      <para>
       code numérique du type de données de la colonne
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </sect1>

 <sect1 id="ecpg-errors">
  <title>Gestion des erreurs</title>

  <para>
   Cette section décrit comment vous pouvez gérer les conditions exceptionnelles
   et les avertissements dans un programme SQL embarqué. Il existe
   plusieurs possibilités non exclusives pour cela.
  </para>

  <sect2>
   <title>Configurer des rappels</title>

   <para>
    Une méthode simple de récupération des erreurs et des avertissements est de
    configurer une action spécifique à exécuter à chaque fois qu'une condition
    particulière survient. En général&nbsp;:
<programlisting>
EXEC SQL WHENEVER <replaceable>condition</replaceable> <replaceable>action</replaceable>;
</programlisting>
   </para>

   <para>
    <replaceable>condition</replaceable> peut avoir une des valeurs
    suivantes&nbsp;:

    <variablelist>
     <varlistentry>
      <term><literal>SQLERROR</literal></term>
      <listitem>
       <para>
        L'action spécifiée est appelée à chaque fois qu'une erreur survient
        pendant l'exécution d'une instruction SQL.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLWARNING</literal></term>
      <listitem>
       <para>
        L'action spécifiée est appelée à chaque fois qu'un avertissement
        survient lors de l'exécution d'une instruction SQL.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NOT FOUND</literal></term>
      <listitem>
       <para>
        L'action spécifiée est appelée à chaque fois qu'une instruction ne
        récupère ou n'affecte aucune ligne. (Cette condition n'est pas une
        erreur mais vous pourriez être intéresser pour la gérer de façon
        spéciale.)
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    <replaceable>action</replaceable> peut avoir une des valeurs
    suivantes&nbsp;:

    <variablelist>
     <varlistentry>
      <term><literal>CONTINUE</literal></term>
      <listitem>
       <para>
        Ceci signifie réellement que la condition est ignorée. Ceci est la
        valeur par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>GOTO <replaceable>label</replaceable></literal></term>
      <term><literal>GO TO <replaceable>label</replaceable></literal></term>
      <listitem>
       <para>
        Saute au label spécifié (en utilisant une instruction C
        <literal>goto</literal>).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLPRINT</literal></term>
      <listitem>
       <para>
        Affiche un message sur la sortie standard. Ceci est utile pour des
        programmes simples ou lors d'un prototypage. Les détails du message ne
        peuvent pas être configurés.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>STOP</literal></term>
      <listitem>
       <para>
        Appel de <literal>exit(1)</literal>, ce qui terminera le programme.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>BREAK</literal></term>
      <listitem>
       <para>
        Exécute l'instruction C <literal>break</literal>. Ceci devrait être
        seulement utilisée dans des boucles ou dans des instructions
        <literal>switch</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CALL <replaceable>nom</replaceable>
        (<replaceable>args</replaceable>)</literal></term>
      <term><literal>DO <replaceable>nom</replaceable>
        (<replaceable>args</replaceable>)</literal></term>
      <listitem>
       <para>
        Appelle les fonctions C spécifiées avec les arguments spécifiés.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    Le standard SQL s'occupe seulement des actions
    <literal>CONTINUE</literal> et <literal>GOTO</literal> (et
    <literal>GO TO</literal>).
   </para>

   <para>
    Voici un exemple que vous pourriez vouloir utiliser dans un programme
    simple. Il affiche un message à chaque fois qu'un avertissement survient et
    annule un programme quand une erreur se produit.
<programlisting>
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLERROR STOP;
</programlisting>
   </para>

   <para>
    L'instruction <literal>EXEC SQL WHENEVER</literal> est une directive du
    préprocesseur SQL, pas une instruction C. Les actions suite à une erreur ou
    à un avertissement qu'il configure s'appliquent à toutes les instructions
    SQL embarquées qui apparaissent après que le gestionnaire soit configuré
    sauf si une action différente a été configurée dans les mêmes conditions
    entre le premier <literal>EXEC SQL WHENEVER</literal> et l'instruction SQL
    qui exécute la condition, quelque soit le flux de contrôle du programme C.
    Donc, aucun des deux programmes C suivants auront l'effet désiré.
<programlisting>
/*
 * MAUVAIS
 */
int main(int argc, char *argv[])
{
    ...
    if (verbose) {
        EXEC SQL WHENEVER SQLWARNING SQLPRINT;
    }
    ...
    EXEC SQL SELECT ...;
    ...
}
</programlisting>

<programlisting>
/*
 * MAUVAIS
 */
int main(int argc, char *argv[])
{
    ...
    set_error_handler();
    ...
    EXEC SQL SELECT ...;
    ...
}

static void set_error_handler(void)
{
    EXEC SQL WHENEVER SQLERROR STOP;
}
</programlisting>
   </para>
  </sect2>

  <sect2>
   <title>sqlca</title>

   <para>
    Pour une gestion plus puissante des erreurs, l'interface du SQL embarqué
    fournit une variable globale de nom <varname>sqlca</varname> qui a la
    structure suivante&nbsp;:
<programlisting>
struct
{
    char sqlcaid[8];
    long sqlabc;
    long sqlcode;
    struct
    {
        int sqlerrml;
        char sqlerrmc[70];
    } sqlerrm;
    char sqlerrp[8];
    long sqlerrd[6];
    char sqlwarn[8];
    char sqlstate[5];
} sqlca;
</programlisting>
    (Dans un programme multithreadé, chaque thread obtient automatiquement sa
    propre copie de <varname>sqlca</varname>. Ceci fonctionne de façon similaire
    à la gestion de la variable globale C standard <varname>errno</varname>.)
   </para>

   <para>
    <varname>sqlca</varname> couvre à la fois les avertissements et les
    erreurs. Si plusieurs avertissements ou erreurs surviennent lors de
    l'exécution d'une instruction, alors <varname>sqlca</varname> contiendra
    seulement des informations sur la dernière.
   </para>

   <para>
    Si aucune erreur ne survient dans l'instruction <acronym>SQL</acronym>,
    <literal>sqlca.sqlcode</literal> vaudra 0 et
    <literal>sqlca.sqlstate</literal> <literal>"00000"</literal>. Si un
    avertissement ou une erreur a eu lieu, alors
    <literal>sqlca.sqlcode</literal> sera négatif et
    <literal>sqlca.sqlstate</literal> sera différent de
    <literal>"00000"</literal>. Un <literal>sqlca.sqlcode</literal> positif
    indique une condition sans problème, tel que <quote>aucune ligne renvoyée
    par la dernière requête</quote>. <literal>sqlcode</literal> et
    <literal>sqlstate</literal> sont deux schémas de code d'erreur
    différents&nbsp;; les détails apparaissent ci-dessous.
   </para>

   <para>
    Si la dernière instruction SQL a réussi, alors
    <literal>sqlca.sqlerrd[1]</literal> contient l'OID de la ligne traitée, si
    applicable, et <literal>sqlca.sqlerrd[2]</literal> contient le nombre de
    lignes traitées ou renvoyées, si applicable à la commande.
   </para>

   <para>
    Dans le cas d'une erreur ou d'un avertissement,
    <literal>sqlca.sqlerrm.sqlerrmc</literal> contiendra une chaîne décrivant
    l'erreur. Le champ <literal>sqlca.sqlerrm.sqlerrml</literal> contient la
    longueur du message d'erreur stocké dans
    <literal>sqlca.sqlerrm.sqlerrmc</literal> (le résultat de
    <function>strlen()</function>, pas réellement intéressant pour un
    programmeur C).
   </para>

   <para>
    Dans le cas d'un avertissement,
    <literal>sqlca.sqlwarn[2]</literal> est configuré à <literal>W</literal>.
    (Dans tous les autres cas, il est configuré à quelque chose de différent de
    <literal>W</literal>.) Si <literal>sqlca.sqlwarn[1]</literal> est configuré
    à <literal>W</literal>, alors une valeur a été tronquée lorsqu'elle a été
    stockée dans une variable hôte. <literal>sqlca.sqlwarn[0]</literal> est
    initialisé à <literal>W</literal> si aucun autre élément n'indique un
    avertissement.
   </para>

   <para>
    Les champs <structfield>sqlcaid</structfield>,
    <structfield>sqlcabc</structfield>,
    <structfield>sqlerrp</structfield>, et les éléments restant de
    <structfield>sqlerrd</structfield> et
    <structfield>sqlwarn</structfield> ne contiennent actuellement
    aucune information utile.
   </para>

   <para>
    La structure <varname>sqlca</varname> n'est pas définie dans le standard
    SQL mais est implémentée dans plusieurs autres systèmes de bases de données.
    Les définitions sont similaires dans le c&oelig;ur mais si vous voulez
    écrire des applications portables, alors vous devriez rechercher avec
    attention d'autres implémentations.
   </para>
  </sect2>

  <sect2>
   <title><literal>SQLSTATE</literal> contre <literal>SQLCODE</literal></title>

   <para>
    Les champs <literal>sqlca.sqlstate</literal> et
    <literal>sqlca.sqlcode</literal> sont deux schémas différents fournissant
    des codes d'erreur. Les deux sont spécifiés dans le standard SQL mais
    <literal>SQLCODE</literal> est indiqué obsolète dans l'édition de 1992 du
    standard et a été supprimé dans celle de 1999. Du coup, les nouvelles
    applications sont fortement encouragées à utiliser
    <literal>SQLSTATE</literal>.
   </para>

   <para>
    <literal>SQLSTATE</literal> est un tableau de cinq caractères. Ces cinq
    caractères contiennent des chiffres ou des lettres en majuscules
    représentant les codes de différentes conditions d'erreurs ou
    d'avertissements. <literal>SQLSTATE</literal> dispose d'un schéma
    hiérarchique&nbsp;: les deux premiers caractères indiquent la classe
    générale de la condition, les trois derniers caractères indiquent une
    sous-classe de la condition générale. Un état de succès est indiqué par le
    code <literal>00000</literal>. Les codes <literal>SQLSTATE</literal> sont
    pour la plupart définis dans le standard SQL. Le serveur
    <productname>PostgreSQL</productname> supporte nativement les codes
    d'erreurs <literal>SQLSTATE</literal>&nbsp;; du coup, un haut degré de
    cohérence peut être réalisé en utilisant ce schéma de code d'erreur au
    travers de vos applications. Pour plus d'informations, voir <xref
    linkend="errcodes-appendix">.
   </para>

   <para>
    <literal>SQLCODE</literal>, le schéma obsolète de codes d'erreurs, est un
    simple entier. Une valeur de 0 indique le succès, une valeur positive
    indique le succès avec des informations supplémentaires, une valeur négative
    indique une erreur. Le standard SQL définit seulement la valeur positive
    +100, qui indique que la dernière commande a renvoyé ou affecté zéro ligne,
    et aucune valeur négative. Du coup, ce schéma peut seulement avoir une
    pauvre portabilité et n'a pas d'affectation de code hiérarchique.
    Historiquement, le processeur SQL embarqué pour
    <productname>PostgreSQL</productname> a affecté quelques valeurs
    <literal>SQLCODE</literal> spécifique pour son utilisation, qui sont listées
    en-dessous avec leur valeur numérique et leur nom symbolique. Rappellez-vous
    qu'elles ne sont pas portables à d'autres implémentations SQL. Pour
    simplifier le portage d'applications au schéma <literal>SQLSTATE</literal>,
    le code <literal>SQLSTATE</literal> correspondant est aussi affiché.
    Néanmoins, il n'y a pas de correspondance un à un entre les deux schémas (en
    fait, c'est plutôt plusieurs à plusieurs), donc vous devriez consulter le
    schéma <literal>SQLSTATE</literal> global dans <xref
    linkend="errcodes-appendix"> pour chaque cas.
   </para>

   <para>
    Voici les valeurs affectées pour <literal>SQLCODE</literal>&nbsp;:

    <variablelist>
     <varlistentry>
      <term>-12 (<symbol>ECPG_OUT_OF_MEMORY</symbol>)</term>
      <listitem>
       <para>
        Indique que votre mémoire virtuelle est remplie. (SQLSTATE
        YE001)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-200 (<symbol>ECPG_UNSUPPORTED</symbol>)</term>
     <listitem>
      <para>
       Indique que le préprocesseur a généré quelque chose que la bibliothèque
       ne connaît pas. Peut-être que vous exécutez des versions incompatibles
       du préprocesseur et de la bibliothèque. (SQLSTATE YE002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-201 (<symbol>ECPG_TOO_MANY_ARGUMENTS</symbol>)</term>
     <listitem>
      <para>
       Ceci signifie que la commande spécifie plus de variables hôte que n'en
       attend la commande.  (SQLSTATE 07001 or 07002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-202 (<symbol>ECPG_TOO_FEW_ARGUMENTS</symbol>)</term>
     <listitem>
      <para>
       Ceci signifie que la commande spécifie moins de variables hôtes 
       que n'en attend la commande.  (SQLSTATE 07001 or 07002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-203 (<symbol>ECPG_TOO_MANY_MATCHES</symbol>)</term>
     <listitem>
      <para>
       Ceci signifie qu'une requête a renvoyé plusieurs lignes mais que
       l'instruction n'était préparée à ne stocker qu'une ligne de résultat (par
       exemple, parce que les variables spécifiées ne sont pas des tableaux).
       (SQLSTATE 21000)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-204 (<symbol>ECPG_INT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       La variable hôte est de type <type>int</type> et que la donnée de la base
       de données est d'un type différent et contient une valeur qui ne peut pas
       être interprétée comme un <type>int</type>. La bibliothèque utilise
       <function>strtol()</function> pour cette conversion.  (SQLSTATE
       42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-205 (<symbol>ECPG_UINT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       La variable hôte est de type <type>unsigned int</type> et la donnée de la
       base de données est d'un type différent et contient une valeur qui ne
       peut pas être interprétée comme un <type>unsigned int</type>. La
       bibliothèque utilise <function>strtoul()</function> pour cette
       conversion. (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-206 (<symbol>ECPG_FLOAT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       La variable hôte est de type <type>float</type> et la donnée de la
       base de données est d'un type différent et contient une valeur qui ne
       peut pas être interprétée comme un <type>float</type>. La
       bibliothèque utilise <function>strtod()</function> pour cette conversion.
       (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-207 (<symbol>ECPG_CONVERT_BOOL</symbol>)</term>
     <listitem>
      <para>
       Ceci signifie que la variable hôte est de type <type>bool</type> et que
       la donnée de la base de données n'est ni <literal>'t'</> ni
       <literal>'f'</>. (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-208 (<symbol>ECPG_EMPTY</symbol>)</term>
     <listitem>
      <para>
       L'instruction envoyée au serveur <productname>PostgreSQL</productname>
       était vide. (Ceci ne peut pas survenir normalement dans un programme SQL
       embarqué, donc il pourrait indiquer une erreur interne.)  (SQLSTATE
       YE002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-209 (<symbol>ECPG_MISSING_INDICATOR</symbol>)</term>
     <listitem>
      <para>
       Une valeur null a été renvoyée et aucun indicateur null de variable n'a
       été fourni.  (SQLSTATE 22002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-210 (<symbol>ECPG_NO_ARRAY</symbol>)</term>
     <listitem>
      <para>
       Une variable ordinaire a été utilisé à une place qui requiert un tableau.
       (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-211 (<symbol>ECPG_DATA_NOT_ARRAY</symbol>)</term>
     <listitem>
      <para>
       La base de données a renvoyé une variable ordinaire à un endroit qui
       requiert une valeur de tableau.  (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-220 (<symbol>ECPG_NO_CONN</symbol>)</term>
     <listitem>
      <para>
       Le programme a essayé d'accèder à une connexion qui n'existe pas.
       (SQLSTATE 08003)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-221 (<symbol>ECPG_NOT_CONN</symbol>)</term>
     <listitem>
      <para>
       Le programme a essayé d'accèder à une connexion qui existe mais n'est pas
       ouverte. (Ceci est une erreur interne.)  (SQLSTATE YE002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-230 (<symbol>ECPG_INVALID_STMT</symbol>)</term>
     <listitem>
      <para>
       L'instruction que vous avez essayer d'utiliser n'a pas été préparée.
       (SQLSTATE 26000)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-240 (<symbol>ECPG_UNKNOWN_DESCRIPTOR</symbol>)</term>
     <listitem>
      <para>
       Le descripteur spécifié n'a pas été trouvé. L'instruction que vous avez
       essayé d'utiliser n'a pas été préparée.  (SQLSTATE 33000)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-241 (<symbol>ECPG_INVALID_DESCRIPTOR_INDEX</symbol>)</term>
     <listitem>
      <para>
       L'index du descripteur spécifié est en dehors de l'échelle.  (SQLSTATE
       07009)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-242 (<symbol>ECPG_UNKNOWN_DESCRIPTOR_ITEM</symbol>)</term>
     <listitem>
      <para>
       Un élément invalide descripteur a été demandé. (Ceci est une erreur
       interne.)  (SQLSTATE YE002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-243 (<symbol>ECPG_VAR_NOT_NUMERIC</symbol>)</term>
     <listitem>
      <para>
       Lors de l'exécution d'une instruction dynamique, la base de données a
       renvoyé une valeur numérique et la variable hôte n'était pas numérique.
       (SQLSTATE 07006)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-244 (<symbol>ECPG_VAR_NOT_CHAR</symbol>)</term>
     <listitem>
      <para>
       Lors de l'exécution d'une instruction dynamique, la base de données a
       renvoyé une valeur non numérique et la variable hôte était numérique.
       (SQLSTATE 07006)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-400 (<symbol>ECPG_PGSQL</symbol>)</term>
     <listitem>
      <para>
       Une erreur a été causée par le serveur
       <productname>PostgreSQL</productname>. Le message contient le message
       d'erreur du serveur <productname>PostgreSQL</productname>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-401 (<symbol>ECPG_TRANS</symbol>)</term>
     <listitem>
      <para>
       Le serveur <productname>PostgreSQL</productname> a signalé que nous ne
       pouvons pas commencer, valider ou annuler la transaction.
       (SQLSTATE 08007)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-402 (<symbol>ECPG_CONNECT</symbol>)</term>
     <listitem>
      <para>
       La tentative de connexion à la base de données a échoué.
       (SQLSTATE 08001)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>100 (<symbol>ECPG_NOT_FOUND</symbol>)</term>
     <listitem>
      <para>
       Ceci est une condition sans gravité indiquant que la dernière commande
       n'a récupéré ou traité aucune ligne, ou que vous vous trouvez à la fin du
       curseur. (SQLSTATE 02000)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-include">
  <title>Inclure des fichiers</title>

  <para>
   Pour inclure un fichier externe dans votre programme SQL embarqué,
   utilisez&nbsp;:
<programlisting>
EXEC SQL INCLUDE <replaceable>nomfichier</replaceable>;
</programlisting>
   Le préprocesseur du SQL embarqué cherchera un fichier nommé
   <literal><replaceable>nomfichier</replaceable>.h</literal>, le traitera et
   l'incluera dans la sortie C résultante. Du coup, les instructions C
   embarquées du fichier inclus sont gérées correctement.
  </para>

  <para>
   Notez que ceci n'est <emphasis>pas</emphasis> la même chose que
<programlisting>
#include &lt;<replaceable>nomfichier</replaceable>.h&gt;
</programlisting>
   parce que ce fichier ne serait ps sujet au pré-traitement des commandes SQL.
   Naturellement, vous pouvez continuer à utiliser la directive C
   <literal>#include</literal> pour inclure d'autres fichiers d'en-tête.
  </para>

  <note>
   <para>
    Le nom du fichier inclus est sensible à la casse, même si le reste de la
    commande <literal>EXEC SQL INCLUDE</literal> suit les règles habituelles de
    sensibilité à la casse.
   </para>
  </note>
 </sect1>

 <sect1 id="ecpg-process">
  <title>Traiter les programmes comportant du SQL embarqué</title>

  <para>
   Maintenant que vous avez une idée de la façon de former des programmes C
   incluant du SQL embarqué, vous voulez probablement savoir comment les
   compiler. Avant de compiler, vous passer le fichier au travers du
   préprocesseur <acronym>C</acronym> pour le <acronym>SQL</acronym> embarqué,
   qui convertit les instructions <acronym>SQL</acronym> que vous avez utilisé
   en appels de fonctions spéciales. Après compilation, vous devez lier le
   programme avec une bibliothèque spéciale contenant les fonctions nécessaires.
   Ces fonctions récupèrent l'information provenant des arguments, exécutent la
   commande <acronym>SQL</acronym> en utilisant l'interface
   <application>libpq</application> et placent le résultat dans les arguments
   spécifiés en sortie.
  </para>

  <para>
   Le préprocesseur est appelé <filename>ecpg</filename> et est inclus dans une
   installation <productname>PostgreSQL</> normale. Les programmes SQL embarqué
   sont nommés typiquement avec une extension <filename>.pgc</filename>. Si vous
   avez un fichier programme nommé <filename>prog1.pgc</filename>, vous pouvez
   lancer le préprocesseur en appelant simplement
<programlisting>
ecpg prog1.pgc
</programlisting>
   Ceci créera un fichier nommé <filename>prog1.c</filename>. Si vos fichiers
   en entrée ne suivent pas le modèle de nommage suggéré, vous pouvez spécifier
   le fichier de sortie explicitement en utilisant l'option <option>-o</option>.
  </para>

  <para>
   Le fichier traité peut être compilé normalement, par exemple&nbsp;:
<programlisting>
cc -c prog1.c
</programlisting>
   Les fichiers générés en source C incluent les fichiers d'en-tête provenant
   de l'installation de <productname>PostgreSQL</>, donc si vous avez installé
   <productname>PostgreSQL</> à un emplacement qui n'est pas cherché par défaut,
   vous devez ajouter une option comme
   <literal>-I/usr/local/pgsql/include</literal> sur la ligne de commande de la
   compilation.
  </para>

  <para>
   Pour lier un programme SQL embarqué, vous aurez besoin d'inclure la
   bibliothèque <filename>libecpg</filename>, de cette façon&nbsp;:
<programlisting>
cc -o monprog prog1.o prog2.o ... -lecpg
</programlisting>
   De nouveau, vous pourriez avoir besoin d'ajouter une option comme
   <literal>-L/usr/local/pgsql/lib</literal> sur la ligne de commande.
  </para>

  <para>
   Si vous gérez le processus de construction d'un grand projet en utilisant
   <application>make</application>, il pourrait être plus agréable d'inclure la
   règle implicite suivante dans vos fichiers makefiles&nbsp;:
<programlisting>
ECPG = ecpg

%.c: %.pgc
        $(ECPG) $<
</programlisting>
  </para>

  <para>
   La syntaxe complète de la commande <command>ecpg</command> est détaillée dans
   <xref linkend="app-ecpg">.
  </para>

  <para>
   <application>ecpg</application> est compatible avec les threads s'il a été
   compilé en utilisant l'option en ligne de commande
   <option>--enable-thread-safety</> de <filename>configure</filename>. (Vous
   pourriez avoir besoin d'utiliser d'autres options de threading en ligne de
   commande pour votre code client.)
  </para>
 </sect1>

 <sect1 id="ecpg-library">
  <title>Fonctions de la bibliothèque</title>

  <para>
   La bibliothèque <filename>libecpg</filename> contient principalement des
   fonctions <quote>cachées</quote> utilisées pour implémenter les
   fonctionnalités exprimées par les commandes SQL embarquées. Mais il existe
   quelques fonctions pouvant être appelées directement avec raison. Notez que
   ceci rend votre code non portable.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     <function>ECPGdebogue(int <replaceable>on</replaceable>, FILE
     *<replaceable>flux</replaceable>)</function> active le débogage s'il est
     appelé avec le premier argument à une valeur différente de zéro. Les traces
     de débogages sont envoyées sur le <replaceable>flux</replaceable>. Les
     traces contiennent toutes les instructions <acronym>SQL</acronym> avec
     toutes les variables insérées en entrée et les résultats du serveur
     <productname>PostgreSQL</productname>. Ceci peut être très utile si vous
     recherchez des erreurs dans vos instructions <acronym>SQL</acronym>.
    </para>
   </listitem>

   <listitem>
    <para>
     <function>ECPGstatus()</function> renvoie vrai si vous êtes connecté à une
     base de données, faux sinon.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="ecpg-develop">
  <title>Internes</title>

  <para>
   Cette section explique comment <application>ECPG</application> fonctionne en
   interne. Cette information peut quelque fois être utile pour que les
   utilisateurs comprennent l'utilisation d'<application>ECPG</application>.
  </para>

   <para>
    Les quatres premières lignes écrites par <command>ecpg</command> sur la
    sortie sont des lignes fixes. Deux sont des commentaires et deux sont des
    lignes d'inclusion de fichiers d'en-tête nécessaires pour faire l'interface
    avec la bibliothèque. Ensuite, le préprocesseur lit tout le fichier et écrit
    la sortie. Normalement, il envoie tout sur la sortie.
   </para>

   <para>
    Quand il aperçoit une instruction <command>EXEC SQL</command>, il
    intervient et la change. La commande commence avec <command>EXEC
    SQL</command> et se termine avec <command>;</command>. Tout ce qui se trouve
    entre est traité comme une instruction <acronym>SQL</acronym> et est analysé
    pour une substitution de variable.
   </para>

   <para>
    La substitution de variable survient quand un symbole commence avec un
    caractère deux-points (<literal>:</literal>). La variable possédant ce nom
    est recherché parmi toutes les variables précédemment déclarées avec une
    section <literal>EXEC SQL DECLARE</>.
   </para>

   <para>
    La fonction la plus importante de la bibliothèque est
    <function>ECPGdo</function>, prenant charge de l'exécution de la plupart
    des commandes. Il prend un nombre variable d'arguments. Ceci permet d'aller
    jusqu'à 50 ou plus d'arguments, et nous espérons que cela ne soit pas un
    problème sur certaines plateformes.
   </para>

   <para>
    Les arguments sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term>Un numéro de ligne</term>
      <listitem>
       <para>
        Ceci est le numéro de ligne de la ligne originale&nbsp;; utilisé
	seulement dans les messages d'erreur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Une chaîne</term>
      <listitem>
       <para>
        C'est la commande <acronym>SQL</acronym> à exécuter. Elle est modifiée
	par les variables en entrée, c'est-à-dire que les variables qui
	n'étaient pas connues au moment de la compilation mais qui sont entrées
	dans la commande. Là où les variables devraient aller, la chaîne
	contient <literal>?</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Variables en entrée</term>
      <listitem>
       <para>
        Chaque variable en entrée est la cause de la création dix arguments.
	(Voir ci-dessous.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><parameter>ECPGt_EOIT</></term>
      <listitem>
       <para>
        Un <type>enum</> indiquant qu'il n'y a plus de variables en
	entrée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Variables en sortie</term>
      <listitem>
       <para>
        Chaque variable en sortie est la cause de la création de dix arguments.
        (Voir ci-dessous.) Ces variables sont remplies par la fonction.
       </para>
      </listitem>
     </varlistentry>

      <varlistentry>
       <term><parameter>ECPGt_EORT</></term>
       <listitem>
       <para>
        Un <type>enum</> indiquant qu'il n'y a plus de variables.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Pour chaque variable faisant parti de la commande <acronym>SQL</acronym>, la
    fonction obtient dix arguments&nbsp;:

    <orderedlist>
     <listitem>
      <para>
       Le type comme symbole spécial.
      </para>
     </listitem>

     <listitem>
      <para> 
       Un pointeur vers la valeur ou un pointeur vers le pointeur.
      </para>
     </listitem>

     <listitem>
      <para>
       La taille de la variable dans le cas d'un type <type>char</type> ou
       <type>varchar</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       Le nombre d'éléments du tableau (pour les récupérations de tableaux).
      </para>
     </listitem>

     <listitem>
      <para>
       Le décalage pour obtenir le prochain élément dans le tableau (pour les
       récupérations de tableaux).
      </para>
     </listitem>

     <listitem>
      <para>
       Le type de variable indicateur comme un symbole spécial.
      </para>
     </listitem>

     <listitem>
      <para>
       Un pointeur vers la variable indicateur.
      </para>
     </listitem>

     <listitem>
      <para>
       0
      </para>
     </listitem>

     <listitem>
      <para>
       Le nombre d'éléments dans le tableau indicateur (pour les récupérations
       de tableaux).
      </para>
     </listitem>

     <listitem>
      <para>
       Le décalage pour obtenir le prochain élément dans le tableau indicateur
       (pour les récupérations de tableaux).
      </para>
     </listitem>
    </orderedlist>
   </para>

   <para>
    Notez que toutes les commandes SQL ne sont pas traitées ainsi. Par exemple,
    une instruction de curseur ouvert comme
<programlisting>
EXEC SQL OPEN <replaceable>curseur</replaceable>;
</programlisting>
    n'est pas copié vers la sortie. À la place, la commande <command>DECLARE</>
    du curseur est utilisée à la position de la commande <command>OPEN</>
    car, en fait, il ouvre le curseur.
   </para>

   <para>
    Voici un exemple complet décrivant la sortie du préprocesseur d'un
    fichier <filename>foo.pgc</filename> (les détails pourraient varier avec
    chaque version particulière du préprocesseur)&nbsp;:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int index;
int resultat;
EXEC SQL END DECLARE SECTION;
...
EXEC SQL SELECT res INTO :resultat FROM matable WHERE index = :index;
</programlisting>
    est traduit en&nbsp;:
<programlisting>
/* Processed by ecpg (2.6.0) */
/* These two include files are added by the preprocessor */
#include &lt;ecpgtype.h&gt;;
#include &lt;ecpglib.h&gt;;

/* exec sql begin declare section */

#line 1 "foo.pgc"

 int index;
 int resultat;
/* exec sql end declare section */
...
ECPGdo(__LINE__, NULL, "SELECT res FROM matable WHERE index = ?     ",
        ECPGt_int,&amp;(index),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EOIT,
        ECPGt_int,&amp;(resultat),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
#line 147 "foo.pgc"
</programlisting>
    (Ici, l'indentation a été ajoutée pour la lisibilité et n'est pas 
    réalisée par le préprocesseur.)
   </para>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
