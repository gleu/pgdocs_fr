<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_type.sgml,v 1.10 2005/07/15 06:14:32 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-CREATETYPE">
 <refmeta>
  <refentrytitle id="sql-createtype-title">CREATE TYPE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TYPE</refname>
  <refpurpose>définit un nouveau type de donnée</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createtype">
  <primary>CREATE TYPE</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE TYPE <replaceable class="parameter">nom</replaceable> AS
    ( <replaceable class="PARAMETER">nom_attribut</replaceable> <replaceable
class="PARAMETER">type_donnée</replaceable> [, ... ] )

CREATE TYPE <replaceable class="parameter">nom</replaceable> (
    INPUT = <replaceable class="parameter">fonction_entrée</replaceable>,
    OUTPUT = <replaceable class="parameter">fonction_sortie</replaceable>
    [ , RECEIVE = <replaceable
class="parameter">fonction_réception</replaceable> ]
    [ , SEND = <replaceable class="parameter">fonction_envoi</replaceable> ]
    [ , ANALYZE = <replaceable class="parameter">fonction_analyze</replaceable> ]
    [ , INTERNALLENGTH = { <replaceable
class="parameter">longueurinterne</replaceable> | VARIABLE } ]
    [ , PASSEDBYVALUE ]
    [ , ALIGNMENT = <replaceable class="parameter">alignement</replaceable> ]
    [ , STORAGE = <replaceable class="parameter">stockage</replaceable> ]
    [ , DEFAULT = <replaceable class="parameter">défaut</replaceable> ]
    [ , ELEMENT = <replaceable class="parameter">élément</replaceable> ]
    [ , DELIMITER = <replaceable class="parameter">délimiteur</replaceable> ]
)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>CREATE TYPE</command> enregistre un nouveau type de données à
   utiliser dans la base de données actuelle. L'utilisateur qui définit un type
   devient son propriétaire.
  </para>

  <para>
   Si un nom de schéma est donné, alors le type est créé dans le schéma
   spécifié. Sinon, il est créé dans le schéma courant. Le nom du type doit être
   distinct du nom des types ou domaines existants dans le même schéma. (Comme
   les tables ont des types de données associés, le nom du type doit aussi être
   distinct du nom de toute table existante dans le même schéma.)
  </para>

  <refsect2>
   <title>Types composés</title>

  <para>
   La première forme <command>CREATE TYPE</command> crée un type composite. Le
   type composé est spécifié par une liste de noms d'attributs et de types de
   données. Ceci est essentiellement le même que le type row d'une table mais
   utiliser <command>CREATE TYPE</command> évite le besoin de créer une table
   réelle quand tout ce qui est souhaité est la définition d'un type. Un type
   composite autonome est utile comme type d'argument ou de retour d'une
   fonction.
  </para>
  </refsect2>

  <refsect2>
   <title>Types de base</title>

  <para>
   La seconde forme <command>CREATE TYPE</command> crée un nouveau type de base
   (type scalaire). Les paramètres pourraient apparaître dans n'importe quel
   ordre, pas seulement celui illustré ci-dessus, et la plupart sont optionnels.
   Vous devez enregistrer au moins deux fonctions (en utilisant <command>CREATE
   FUNCTION</command>) avant de définir le type. Les fonctions de support
   <replaceable class="parameter">fonction_entrée</replaceable> et <replaceable
   class="parameter">fonction_sortie</replaceable> sont requises alors que les
   fonctions <replaceable class="parameter">fonction_réception</replaceable>,
   <replaceable class="parameter">fonction_envoi</replaceable> et
   <replaceable class="parameter">fonction_analyze</replaceable> sont
   optionnelles. Généralement, ces fonctions doivent être codées en C ou dans un
   autre langage de bas niveau.
  </para>

  <para>
   La <replaceable class="parameter">fonction_entrée</replaceable> convertit la
   représentation textuelle externe du type avec la représentation interne
   utilisée par les opérateurs et fonctions définis pour le type. <replaceable
   class="parameter">fonction_sortie</replaceable> réalise la transformation
   inverse. La fonction en entrée pourrait être déclarée comme prenant un
   argument de type <type>cstring</type> ou comme prenant trois arguments de
   types <type>cstring</type>, <type>oid</type>, <type>integer</type>. Le
   premier argument est le texte en entrée en tant que chaîne C, le second
   argument est l'OID du type d'élément dans le cas où il s'agit d'un type
   tableau (ou le propre OID du type pour un type composite) et
   le troisième est le <literal>typmod</> de la colonne destination, s'il est
   connu (-1 sinon). La fonction en entrée devrait renvoyer une valeur du type
   de données lui-même. La fonction en sortie pourrait être déclarée comme
   prenant un argument du nouveau type de données ou comme prenant deux arguments
   dont le second est de type <type>oid</type>. Le second argument est de nouveau
   l'OID du type d'élément de tableau pour les types tableau ou l'OID du type pour
   les types composites. La fonction de sortie devrait renvoyer le type
   <type>cstring</type>.
  </para>

  <para>
   La <replaceable class="parameter">fonction_réception</replaceable>
   optionnelle convertit la représentation binaire externe du type vers la
   représentation interne. Si cette fonction n'est pas fournie, le type ne peut
   pas participer à l'entrée binaire. La représentation binaire devrait être
   choisie pour être peu coûteuse sur la conversion vers la forme interne tout
   en étant raisonnablement portable. (Par exemple, les types de données
   standard entiers utilisent l'ordre réseau des octets comme représentation
   binaire externe alors que la représentation interne est dans l'ordre natif
   des octets de la machine.) La fonction de réception devrait réaliser des
   vérifications adéquates pour s'assurer que la valeur est valide. La fonction
   de réception pourrait être déclarée comme prenant un argument de type
   <type>internal</type> ou deux arguments de types <type>internal</type> et
   <type>oid</type>. Elle doit renvoyer une valeur de type de données lui-même. 
   (Le premier argument est un pointeur vers un tampon <type>StringInfo</type>
   contenant la chaîne d'octets reçus&nbsp;; le second argument optionnel est
   soit l'OID du type d'élément dans le cas où il s'agit d'un tableau soit
   le propre OID du type pour un type composite.) De façon similaire, la
   <replaceable class="parameter">fonction_envoi</replaceable> optionnelle
   convertit à partir de la représentation interne vers la représentation
   binaire externe. Si cette fonction n'est pas fournie, le type ne peut pas
   participer dans la sortie binaire. La fonction d'envoi pourrait être déclarée
   comme prenant un argument du nouveau type de données ou comme prenant deux
   arguments dont le second est de type <type>oid</type>. Le second argument est
   encore l'OID du type d'élément du tableau pour les types tableau ou l'OID du
   type pour les types composites. La fonction
   d'envoi doit renvoyer le type <type>bytea</type>.
  </para>

  <para>
   La <replaceable class="parameter">fonction_analyse</replaceable> en option
   réalise des récupérations de statistiques spécifiques au type pour les
   colonnes de ce type de données. Par défaut, <command>ANALYZE</> tentera de
   récupérer des statistiques en utilisant les opérateurs d'<quote>égalité</> et
   d'<quote>infériorité</> du type, s'il existe une classe d'opérateur par défaut
   pour le B-tree de ce type. Pour les types non scalaires, ce comportement risque
   d'être moins convenable, donc il peut être surchargé en indiquant une fonction
   d'analyse personnalisée. La fonction d'analyse doit être déclarée comme prenant
   un seul argument de type <type>internal</> et renvoyer un résultat de type
   <type>boolean</>. L'API détaillée pour les fonctions d'analyses apparaît dans
   <filename>src/include/commands/vacuum.h</>.
  </para>

  <para>
   Maintenant, vous devriez vous demander comment les fonctions d'entrée et de
   sortie peuvent être déclarées pour avoir des résultats ou des arguments du
   nouveau type avant que le nouveau type soit créé. La réponse est que la
   fonction en entrée doit être créée en premier, puis la fonction de sortie (et
   les fonctions d'entrées/sorties binaires si souhaitées) et enfin le type de
   données. <productname>PostgreSQL</productname> verra tout d'abord le nom du
   nouveau type de données comme type de retour de la fonction en entrée. Il
   créera un type <quote>shell</>, qui est une simple entrée d'emplacement dans
   le catalogue système et lie la définition de fonction en entrée au type de
   shell. De façon similaire, les autres fonctions seront liées au (maintenant
   déjà existant) type de shell. Enfin, <command>CREATE TYPE</> remplace
   l'entrée de shell avec une définition complète du type et le nouveau type
   peut être utilisé.
  </para>

  <para>
   Alors que les détails de la représentation interne du nouveau type sont
   seulement connus des fonctions d'entrées/sorties et des autres fonctions que
   vous créez pour travailler avec le type, il existe plusieurs propriétés de
   représentation interne devant être déclarées à
   <productname>PostgreSQL</productname>. En premier lieu se trouve
   <replaceable class="parameter">longueurinterne</replaceable>. Les types de
   données de base peuvent avoir une longueur fixe auquel cas <replaceable
   class="parameter">longueurinterne</replaceable> est un entier positif, ou une
   longueur variable, indiquée en initialisant <replaceable
   class="parameter">longueurinterne</replaceable> à
   <literal>VARIABLE</literal>. (En interne, ceci est représenté en initialisant
   <literal>typlen</> à -1.) La représentation interne de tous les types de
   longueur variable doit commencer avec un entier de quatre octets donnant la
   longueur totale de cette valeur du type.
  </para>

  <para>
   Le drapeau optionnel <literal>PASSEDBYVALUE</literal> indique que les
   valeurs de ce type de données sont passées par valeur plutôt que par
   référence. Vous pourriez ne pas passer par les types de valeurs dont la
   représentation interne est plus importante que la taille du type
   <type>Datum</> (quatre octets sur la plupart des machines, huit sur
   quelques-unes).
  </para>

  <para>
   Le paramètre <replaceable class="parameter">alignement</replaceable>
   spécifie l'alignement de stockage requis pour le type de données. Les
   valeurs permises ont un alignement sur les limites de 1, 2, 4 ou 8 octets.
   Notez que les types de longueurs variables doivent avoir un alignement d'au
   moins quatre octets car ils contiennent nécessairement un <type>int4</> comme
   premier composant.
  </para>

  <para>
   Le paramètre <replaceable class="parameter">stockage</replaceable> permet la
   sélection de stratégies de stockage pour des types de données de longueur
   variable. (Seul <literal>plain</literal> est autorisé pour les types de
   longueur fixe.) <literal>plain</literal> spécifie que les données du type
   seront toujours stockées en ligne et non compressées.
   <literal>extended</literal> spécifie que le système essaiera tout d'abord de
   compresser une valeur longue de données et déplacera la valeur en dehors de
   la ligne de la table principale si elle est trop longue.
   <literal>external</literal> permet à la valeur d'être déplacée hors de la
   table principale mais le système ne tentera pas de la compresser.
   <literal>main</literal> autorise la compression mais décourage le déplacement
   de la valeur en dehors de la table principale. (Les éléments de données
   avec cette stratégie de stockage pourraient toujours être déplacés hors de la
   table principale s'il n'y a pas d'autres moyens d'y placer une ligne mais ils
   seront conservés de préférence dans la table principale sur les éléments
   <literal>extended</literal> et <literal>external</literal>.)
  </para>

  <para>
   Une valeur par défaut pourrait être spécifiée dans le cas où l'utilisateur
   souhaite que les colonnes du type de données aient pour valeur par défaut une
   valeur autre que NULL. Spécifiez la valeur par défaut avec le mot clé
   <literal>DEFAULT</literal>. (Une telle valeur par défaut peut être surchargée
   par une clause <literal>DEFAULT</literal> explicite attachée dans une colonne
   particulière.)
  </para>

  <para>
   Pour indiquer qu'un type est un tableau, spécifiez le type des éléments du
   tableau en utilisant le mot clé <literal>ELEMENT</>. Par exemple, pour
   définir un tableau d'entiers de quatre octets (<type>int4</type>),
   spécifiez <literal>ELEMENT = int4</literal>. Plus de détails sur les types
   tableau apparaissent ci-dessous.
  </para>

  <para>
   Pour indiquer le délimiteur à utiliser entre les valeurs dans la
   représentation externe des tableaux de ce type, <replaceable
   class="parameter">délimiteur</replaceable> peut être configuré à un
   caractère particulier. Le délimiteur par défaut est la virgule
   (<literal>,</literal>). Notez que le délimiteur est associé avec le type
   d'élément de tableau, pas le type tableau lui-même.
  </para>

  </refsect2>

  <refsect2>
   <title>Types de tableaux</title>

   <para>
    À chaque fois qu'un type de données de base défini par un utilisateur est
    créé, <productname>PostgreSQL</productname> crée automatiquement un type
    tableau associé dont le nom consiste du nom du type de base précédé d'un
    tiret base. L'analyseur comprend cette convention de nommage et traduit
    les requêtes pour les colonnes de type <literal>foo[]</> en requêtes pour le
    type <literal>_foo</>. Le type tableau créé implicitement est de longueur
    variable et utilise les fonctions entrée et sortie intégrée
    <literal>array_in</> et <literal>array_out</>.
   </para>

   <para>
    Vous pourriez raisonnablement vous demander pourquoi il existe une option
    <option>ELEMENT</> si le système fabrique automatiquement le bon type
    tableau. Le seul cas où il est utile d'utiliser <option>ELEMENT</> est
    lorsque vous réalisez un type de longueur fixe qui est en interne un tableau
   d'un nombre identique d'éléments et que vous souhaitez autoriser ces éléments
    à accéder directement aux indices, en plus de toute autre opération que vous
    pensiez fournir pour le type dans sa globalité. Par exemple, le type
    <type>name</> permet à ses éléments <type>char</> constituants d'être
    accessible de cette façon. Un type <type>point</> en 2-D pourrait autoriser
    les deux numéros de composant à être accédé ainsi&nbsp;:
    <literal>point[0]</> et <literal>point[1]</>. Notez que cette
    fonctionnalité fonctionne uniquement avec les types de longueur fixe dont la
    forme interne est exactement une séquence de champs de longueur variable.
    Un type longueur de variable à indice doit avoir la représentation interne
    généralisée utilisée par <literal>array_in</> et <literal>array_out</>.
    Pour des raisons historiques (c'est-à-dire qu'il est clairement mauvais
    parce qu'il est trop tard pour changer) s'abonner  à des types de longueur
    variable commence à partir de zéro plutôt que de un pour les tableaux de
    longueur variable.
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
     Le nom d'un type à créer (pouvant être qualifié par le nom du schéma).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_attribut</replaceable></term>
    <listitem>
     <para>
      Le nom d'un attribut (colonne) pour le type composé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_données</replaceable></term>
    <listitem>
     <para>
      Le nom d'un type de données existant qui deviendra une colonne du type
      composé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_entrée</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction qui convertit les données à partir de la forme
      textuelle externe du type en sa forme interne.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_sortie</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction qui convertit les données à partir de la forme
      interne du type dans sa forme textuelle externe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_réception</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction qui convertit la forme binaire externe du type dans
      sa forme interne.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_envoi</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction qui convertit les données à partir de la forme
      interne du type dans sa forme binaire externe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">analyze_function</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction qui réalise des analyses statistiques pour le type
      de données.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">longueurinterne</replaceable></term>
    <listitem>
     <para>
      Une constante numérique qui spécifie la longueur en octets de la
      représentation interne du nouveau type. La supposition par défaut est que
      la longueur est variable.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">alignement</replaceable></term>
    <listitem>
     <para>
      Le besoin d'alignement du stockage du type de données. Si spécifié, il
      doit être parmi <literal>char</literal>, <literal>int2</literal>,
      <literal>int4</literal> ou <literal>double</literal>&nbsp;; par défaut,
      il s'agit d'<literal>int4</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">stockage</replaceable></term>
    <listitem>
     <para>
      La stratégie de stockage pour le type de données. Si spécifiée, elle doit
      faire partie de <literal>plain</literal>, <literal>external</literal>,
      <literal>extended</literal> ou <literal>main</literal>&nbsp;; la valeur
      par défaut est <literal>plain</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">défaut</replaceable></term>
    <listitem>
     <para>
      La valeur par défaut pour le type de données. Si elle est omise, elle est
      NULL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">élément</replaceable></term>
    <listitem>
     <para>
      Le type en cours de création est un tableau&nbsp;; ceci spécifie le type
      des éléments du tableau.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">délimiteur</replaceable></term>
    <listitem>
     <para>
      Le caractère délimiteur à utiliser entre les valeurs des tableaux de ce
      type.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1 id="SQL-CREATETYPE-notes">
  <title>Notes</title>

  <para>
   Les noms de types définis par l'utilisateur ne peuvent pas
   commencer avec un tiret bas (<literal>_</literal>) et ont une longueur
   maximale de 62 caractères (ou en général <symbol>NAMEDATALEN</symbol> - 2,
   plutôt que <symbol>NAMEDATALEN</symbol> - 1 caractères autorisés pour les
   autres noms). Les noms de types commençant avec un tiret bas sont réservés
   par les noms de type tableau créés en interne.
  </para>

  <para>
   Dans les versions de <productname>PostgreSQL</productname> antérieures à la
   7.3, il était coutumier d'éviter de créer un type shell en remplaçant les
   références des fonctions au nom du type avec le pseudotype <type>opaque</>.
   Les arguments <type>cstring</> et les résultats doivent aussi être déclarés
   comme <type>opaque</> avant la 7.3. Pour supporter le chargement d'anciens
   fichiers de sauvegarde, <command>CREATE TYPE</> acceptera les fonctions
   déclarées avec <type>opaque</> mais il affichera un message d'avertissement
   et modifiera la déclaration de la fonction pour utiliser les bons types.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Cet exemple crée un type composite et l'utilise dans la définition d'une
   fonction&nbsp;:
<programlisting>
CREATE TYPE compfoo AS (f1 int, f2 text);

CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$
SELECT fooid, fooname FROM foo
$$ LANGUAGE SQL;
</programlisting>
  </para>

  <para>
   Cet exemple crée le type de données de base <type>box</type>, puis l'utilise
   dans une définition de table&nbsp;:
<programlisting>
CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = ma_fonction_entree_box,
    OUTPUT = ma_fonction_sortie_box
);

CREATE TABLE myboxes (
    id integer,
    description box
);
</programlisting>
  </para>

  <para>
   Si la structure interne de <type>box</type> était un tableau de quatre
   éléments <type>float4</>, nous pourrions faire
<programlisting>
CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = ma_fonction_entree_box,
    OUTPUT = ma_fonction_sortie_box,
    ELEMENT = float4
);
</programlisting>
   ce qui permettrait un accès aux nombres composant la valeur d'une boîte avec
   les indices. Sinon, le type se comporte de la même façon qu'avant.
  </para>

  <para>
   Cet exemple crée un objet large et l'utilise dans une définition de
   table&nbsp;:
<programlisting>
CREATE TYPE bigobj (
    INPUT = lo_filein, OUTPUT = lo_fileout,
    INTERNALLENGTH = VARIABLE
);
CREATE TABLE big_objs (
    id integer,
    obj bigobj
);
</programlisting>
  </para>

  <para>
   Vous trouverez plus d'exemples, intégrant des fonctions intéressantes en
   entrée et en sortie, dans <xref linkend="xtypes">.
  </para>
 </refsect1>

 <refsect1 id="SQL-CREATETYPE-compatibility">
  <title>Compatibilité</title>

  <para>
   Cette commande <command>CREATE TYPE</command> est une extension
   <productname>PostgreSQL</productname>. Il existe une instruction
   <command>CREATE TYPE</command> dans SQL:1999 et ses versions ultérieures
   qui est plutôt différente dans le détail.
  </para>
 </refsect1>

 <refsect1 id="SQL-CREATETYPE-see-also">
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createfunction" endterm="sql-createfunction-title"></member>
   <member><xref linkend="sql-droptype" endterm="sql-droptype-title"></member>
   <member><xref linkend="sql-altertype" endterm="sql-altertype-title"></member>
  </simplelist>
 </refsect1>

</refentry>


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
