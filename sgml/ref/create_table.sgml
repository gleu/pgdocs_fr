<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_table.sgml,v 1.7 2005/01/10 00:35:00 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-CREATETABLE">
 <refmeta>
  <refentrytitle id="sql-createtable-title">CREATE TABLE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TABLE</refname>
  <refpurpose>définit une nouvelle table</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createtable">
  <primary>CREATE TABLE</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } ] TABLE <replaceable
class="PARAMETER">nom_table</replaceable> (
  { <replaceable class="PARAMETER">nom_colonne</replaceable> <replaceable
class="PARAMETER">type_données</replaceable> [ DEFAULT
<replaceable>default_expr</> ] [ <replaceable
class="PARAMETER">contrainte_colonne</replaceable> [ ... ] ]
    | <replaceable>contrainte_table</replaceable>
    | LIKE <replaceable>table_parent</replaceable> [ { INCLUDING | EXCLUDING }
DEFAULTS ] } [, ... ]
)
[ INHERITS ( <replaceable>table_parent</replaceable> [, ... ] ) ]
[ WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]

où <replaceable class="PARAMETER">contrainte_colonne</replaceable>
est&nbsp;:

[ CONSTRAINT <replaceable class="PARAMETER">nom_contrainte</replaceable> ]
{ NOT NULL | NULL | UNIQUE | PRIMARY KEY |
  CHECK (<replaceable class="PARAMETER">expression</replaceable>) |
  REFERENCES <replaceable class="PARAMETER">table_reference</replaceable> [ (
<replaceable class="PARAMETER">colonne_reference</replaceable> ) ] [ MATCH FULL
| MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

et <replaceable class="PARAMETER">contrainte_table</replaceable> est&nbsp;:

[ CONSTRAINT <replaceable class="PARAMETER">nom_contrainte</replaceable> ]
{ UNIQUE ( <replaceable class="PARAMETER">nom_colonne</replaceable> [, ... ] ) |
  PRIMARY KEY ( <replaceable class="PARAMETER">nom_colonne</replaceable> [, ...
] ) |
  CHECK ( <replaceable class="PARAMETER">expression</replaceable> ) |
  FOREIGN KEY ( <replaceable class="PARAMETER">nom_colonne</replaceable> [, ...
] ) REFERENCES <replaceable class="PARAMETER">table_reference</replaceable> [ (
<replaceable class="PARAMETER">colonne_reference</replaceable> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <replaceable
class="parameter">action</replaceable> ] [ ON UPDATE <replaceable
class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
</synopsis>
  
 </refsynopsisdiv>

 <refsect1 id="SQL-CREATETABLE-description">
  <title>Description</title>

  <para>
   <command>CREATE TABLE</command> créera une nouvelle table initialement vide
   dans la base de données courante. La table sera la propriété par
   l'utilisateur lançant la commande.
  </para>

  <para>
   Si un nom de schéma est donné (par exemple, <literal>CREATE TABLE
   monschema.matable ...</>), alors la table est créée dans le schéma spécifié.
   Sinon, il est créé dans le schéma actuel. Les tables temporaires existent
   dans un schéma spécial, donc un nom de schéma pourrait ne pas être donné lors
   de la création d'une table temporaire. Le nom de la table doit être distinct
   des noms des autres tables, séquences, index ou vues dans le même schéma.
  </para>

  <para>
   <command>CREATE TABLE</command> crée aussi automatiquement un type de 
   données qui représente le type composé correspondant à une ligne de la
   table. Du coup, les tables ne peuvent pas avoir le même nom que tout type de
   données du même schéma.
  </para>

  <para>
   Une table ne peut pas avoir plus de 1600 colonnes. (En pratique, la limite
   effective est plus basse à cause des contraintes de longueur de la ligne).
  </para>

  <para>
   Les clauses de contrainte optionnelle spécifient les contraintes (ou 
   tests) que les nouvelles lignes ou les lignes mises à jour doivent satisfaire
   pour qu'une opération d'insertion ou de mise à jour réussisse. Une contrainte
   est un objet SQL qui aide à définir l'ensemble de valeurs valides de
   plusieurs façons.
  </para>

  <para>
   Il existe deux façons de définir des contraintes&nbsp;: les contraintes
   de table et celles des colonnes. Une contrainte de colonne est définie pour
   faire partie d'une définition de la colonne. Une définition de la contrainte
   des tables n'est pas liée à une colonne particulière et il comprend plus
   d'une colonne. Chaque contrainte de colonne peut aussi être écrite comme une
   contrainte de table&nbsp;; une colonne de contrainte est seulement un outil
   de notation si la contrainte affecte seulement une colonne.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>

   <varlistentry>
    <term><literal>TEMPORARY</> ou <literal>TEMP</></term>
    <listitem>
     <para>
      Si spécifié, la table est créée comme une table temporaire. Les tables
      temporaires sont automatiquement supprimées à la fin d'une session ou,
      optionnellement, à la fin de la transaction en cours (voir ON COMMIT
      ci-dessous). Les tables permanentes existantes avec le même nom ne sont
      pas visibles dans la session en cours alors que la table temporaire existe
      sauf si elles sont référencées avec les noms qualifiés du schéma. Tous les
      index créés sur une table temporaire sont aussi automatiquement
      temporaires.
     </para>

     <para>
      Optionellement, <literal>GLOBAL</literal> ou <literal>LOCAL</literal>
      peuvent être écrit avant <literal>TEMPORARY</> ou <literal>TEMP</>. Ceci
      ne fait pas de différence dans <productname>PostgreSQL</>, mais voir <xref
      linkend="sql-createtable-compatibility"
      endterm="sql-createtable-compatibility-title">.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">nom_table</replaceable></term>
    <listitem>
     <para>
      Le nom (peut-être qualifié par le nom du schéma) de la table à créer.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">nom_colonne</replaceable></term>
    <listitem>
     <para>
      Le nom d'une colonne à créer dans la nouvelle table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">type_données</replaceable></term>
    <listitem>
     <para>
      Le type de données de la colonne. Ceci pourrait inclure des
      spécificateurs de tableaux.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT
    <replaceable>default_expr</replaceable></literal></term>
    <listitem>
     <para>
      La clause <literal>DEFAULT</> affecte une valeur par défaut pour la
      colonne dont la définition apparait à l'intérieur. La valeur est toute
      expression libre de variable (les sous-requêtes et références croisées aux
      autres colonnes dans la table en cours ne sont pas autorisées). Le type de
      données de l'expression par défaut doit correspondre au type de données de
      la colonne.
     </para>

     <para>
      L'expression par défaut sera utilisée dans les opérations d'insertion 
      qui ne spécifient pas une valeur pour la colonne. S'il n'y a pas de valeur
      par défaut pour une colonne, alors la valeur par défaut est null.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>LIKE <replaceable>table_parent</replaceable> [ { INCLUDING |
EXCLUDING } DEFAULTS ]</literal></term>
    <listitem>
     <para>
      La clause <literal>LIKE</literal> spécifie une table à partir de laquelle
      la nouvelle table hérite automatiquement tous les noms de colonnes, leur
      types de données et les contraintes non null.
     </para>
     <para>
      Contrairement à <literal>INHERITS</literal>, la nouvelle table et la
      table héritée sont complètement découplées après la fin de la création.
      Les données insérées dans la nouvelle table ne sont pas reflétées dans la
      table parent.
     </para>
     <para>
      Les expressions par défaut pour les définitions des colonnes héritées
      seront seulement incluses si <literal>INCLUDING DEFAULTS</literal> est
      spécifié. Par défaut, il faut exclure les expressions par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INHERITS ( <replaceable>table_parent</replaceable> [, ... ]
)</literal></term>
    <listitem>
     <para>
      La clause optionnelle <literal>INHERITS</> spécifie une liste des tables
      à partir desquelles la nouvelle table hérite automatiquement de toutes les
      colonnes. Si le même nom de colonne existe dans plus d'une table parente,
      une erreur est rapportée sauf si les types de données des colonnes
      correspondent à chacune des tables parentes. S'il n'y a aucun conflit,
      alors les colonnes dupliquées sont assemblées pour former une seule
      colonne dans la nouvelle table. Si la liste de noms de colonnes de la
      nouvelle table contient une colonne qui est aussi héritée, le type de
      données doit correspondre aux colonnes héritées et les définitions de la
      colonne sont assemblées en une seule. Néanmoins, les déclarations des
      colonnes héritées et nouvelles du même nom ont besoin de ne pas spécifier
      des contraintes identiques&nbsp;: toutes les contraintes fournies par
      toute déclaration sont assemblées et sont toutes appliquées à la nouvelle
      table. Si la nouvelle table spécifie explicitement une valeur par défaut
      pour la colonne, cette valeur surcharge toute valeur par défaut des
      déclarations héritées pour la colonne.Sinon, tout parent spécifiant des
      valeurs par défaut pour la colonne doit spécifier la même valeur par
      défaut. Sinon une erreur sera rapportée.
     </para>
<!--
     <para>
      <productname>PostgreSQL</> automatically allows the
     created table to inherit
      functions on tables above it in the inheritance hierarchy; that
      is, if we create table <literal>foo</literal> inheriting from
      <literal>bar</literal>, then functions that accept the tuple
      type <literal>bar</literal> can also be applied to instances of
      <literal>foo</literal>.  (Currently, this works reliably for
      functions on the first or only parent table, but not so well for
      functions on additional parents.)
     </para>
-->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH OIDS</></term>
    <term><literal>WITHOUT OIDS</></term>
    <listitem>
     <para>
      Cette clause optionnelle spécifie si les lignes de la nouvelle table
      devraient avoir des OID (identifieurs d'objets) qui leur sont affectés.
      Par défaut, il y a des OID. (Si la nouvelle table hérite d'autres tables
      possédant des OID, alors <literal>WITH OIDS</> est forcé même si la
      commande indique <literal>WITHOUT OIDS</>.)
     </para>

     <para>
      Spécifier <literal>WITHOUT OIDS</> autorise l'utilisateur à supprimer
      la génération des OIDs pour les lignes d'une table. Ceci pourrait être
      intéressant pour les grosses tables car il réduit la consomnation d'OID
      et, du coup, annule pour cette table le problème du retour à zéro du
      compteur d'OID. Une fois que le compteur est revenu à zéro, l'unicité des
      OID ne peut plus être garantie, ce qui réduit considérablement leur
      utilité. Spécifier <literal>WITHOUT OIDS</literal> réduit aussi l'espace
      requis pour stocker la table sur disque de quatre octets par ligne de la
      table, améliorant ainsi leur performance.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CONSTRAINT <replaceable
class="PARAMETER">nom_contrainte</replaceable></literal></term>
    <listitem>
     <para>
      Un nom optionnel pour une contrainte de colonne ou de table. S'il n'est
      pas spécifié, le système génère un nom.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NOT NULL</></term>
    <listitem>
     <para>
      La colonne n'est pas autorisée à contenir des valeurs null.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NULL</></term>
    <listitem>
     <para>
      La colonne est autorisée pour contenir des valeurs null. Ceci est la
      valeur par défaut.
     </para>

     <para>
      Cette clause est seulement disponible pour la compatibilité avec les
      bases de données SQL non standards. Son utilisation n'est pas encouragée
      dans les nouvelles applications.
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
    <term><literal>UNIQUE</> (contrainte_colonne)</term>
    <term><literal>UNIQUE ( <replaceable
class="PARAMETER">nom_colonne</replaceable> [, ... ] )</> (contrainte
table)</term>

    <listitem>
     <para>
      La contrainte <literal>UNIQUE</literal> spécifie qu'un groupe d'une ou
      plusieurs colonnes d'une table pourrait seulement contenir des valeurs
      uniques. Le comportement de la contrainte de table unique est le même que
      pour les contraintes de colonnes avec la capacité supplémentaire de
      diviser les colonnes multiples.
     </para>

     <para>
      Dans le but d'une contrainte unique, les valeurs null ne sont pas
      considérées égales.
     </para>

     <para>
      Chaque contrainte de table unique doit nommer un ensemble de colonnes qui
      est différent de l'ensemble des colonnes nommées par toute autre
      contrainte unique ou de clé primaire définie pour la table. (Sinon, cela
      pourrait être juste la même contrainte donnée deux fois.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>PRIMARY KEY</> (contrainte colonne)</term>
    <term><literal>PRIMARY KEY ( <replaceable
class="PARAMETER">nom_colonne</replaceable> [, ... ] )</> (contrainte
table)</term>
    <listitem>
     <para>
      La contrainte de clé primaire spécifie qu'une ou plusieurs colonnes d'une
      table pourraient contenir seulement des valeurs uniques, non null.
      Techniquement, <literal>PRIMARY KEY</literal> est simplement une
      combinaison de <literal>UNIQUE</> et <literal>NOT NULL</>, mais identifier
      un ensemble de colonnes comme clé primaire fournit aussi des métadonnées
      sur le concept du schéma, car une clé primaire implique que d'autres
      tables pourraient se lier à cet ensemble de colonnes comme un unique
      identifieur pour les lignes.
     </para>

     <para>
      Seule une clé primaire peut être spécifiée pour une table, s'il s'agit
      d'une contrainte de colonne ou de table.
     </para>

     <para>
      La contrainte de clé primaire devrait nommer un ensemble de colonnes qui
      est différent des autres ensembles de colonnes nommés par une contrainte
      unique définie pour la même table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CHECK (<replaceable class="PARAMETER">expression</replaceable>)</literal></term>
    <listitem>
     <para>
      La clause <literal>CHECK</> spécifie une expression produisant un
      résultat booléen que les nouvelles lignes ou que les lignes mises à jour
      doivent satisfaire pour qu'une opération d'insertion ou de mise à jour
      réussisse. Une contrainte de vérification spécifiée comme une contrainte
      de colonne devrait seulement référencer la valeur de la colonne alors
      qu'une expression apparaissant dans une contrainte de table pourrait
      référencer plusieurs colonnes.
     </para>

     <para>
      Actuellement, les expressions <literal>CHECK</literal> ne peuvent ni
      contenir des sous-requêtes ni se référer à des variables autres que les
      colonnes de la ligne actuelle.
     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term><literal>REFERENCES <replaceable
class="parameter">table_reference</replaceable> [ ( <replaceable
class="parameter">colonne_reference</replaceable> ) ] [ MATCH <replaceable
class="parameter">matchtype</replaceable> ] [ ON DELETE <replaceable
class="parameter">action</replaceable> ] [ ON UPDATE <replaceable
class="parameter">action</replaceable> ]</literal> (contrainte de
colonne)</term>

   <term><literal>FOREIGN KEY ( <replaceable
class="parameter">colonne</replaceable> [, ... ] )
    REFERENCES <replaceable class="parameter">table_reference</replaceable> [ (
<replaceable class="parameter">colonne_reference</replaceable> [, ... ] ) ] 
    [ MATCH <replaceable class="parameter">matchtype</replaceable> ]
    [ ON DELETE <replaceable class="parameter">action</replaceable> ] 
    [ ON UPDATE <replaceable class="parameter">action</replaceable> ]</literal>
    (contrainte de colonne)</term>

    <listitem>
     <para>
      Ces clauses spécifient une contrainte de clé étrangère, ce qui spécifie
      qu'un groupe d'une ou plusieurs colonnes de la nouvelle table doit
      seulement contenir des valeurs correspondant aux valeurs dans le(s)
      colonne(s) référencée(s) <replaceable
      class="parameter">colonne_reference</replaceable> de la table référencée
      <replaceable class="parameter">table_reference</replaceable>. Si
      <replaceable class="parameter">colonne_reference</replaceable> est omis,
      la clé primaire de la <replaceable
      class="parameter">table_reference</replaceable> est utilisée. Les colonnes
      référencées doivent être les colonnes d'une contrainte unique ou de clé
      primaire dans la table référencée.
     </para>

     <para>
      Une valeur insérée dans ces colonnes est comparée aux valeurs de la
      table référencée et des colonnes référencées en utilisant le type
      correspondant donné. Il existe trois types de correspondance&nbsp;:
      <literal>MATCH FULL</>, <literal>MATCH PARTIAL</> et <literal>MATCH
      SIMPLE</literal>, qui est aussi la valeur par défaut. <literal>MATCH
      FULL</> n'autorisera pas une colonne d'une clé étrangère composée de
      plusieurs colonnes pour être null sauf si les colonnes de clés étrangères
      sont nulles. <literal>MATCH SIMPLE</literal> autorise quelques colonnes de
      clé étrangère pour être null alors que les autres parties de la clé
      étrangère ne sont pas nulles. <literal>MATCH PARTIAL</> n'est pas encore
      implémenté.
     </para>

     <para>
      En plus, lorsque les données des colonnes référencées sont modifiées,
      certaines actions sont réalisées sur les données dans les colonnes de
      cette table. La clause <literal>ON DELETE</literal> spécifie l'action à
      réaliser lorsqu'une ligne référencée de la table référencée est en cours
      de suppression. De la même façon, la clause <literal>ON UPDATE</literal>
      spécifie l'action à réaliser lorsqu'une colonne référencée dans la table
      référencée est en cours de mise à jour pour une nouvelle valeur. Si la
      ligne est mise à jour mais la colonne référencée n'est pas réellement
      modifiée, aucune action n'est réalisée. Il existe les actions possibles
      suivantes pour chaque clause&nbsp;:

      <variablelist>
       <varlistentry>
        <term><literal>NO ACTION</literal></term>
        <listitem>
         <para>
          Produit une erreur indiquant que la suppression ou la mise à jour 
          créerait une violation de la contrainte de clé étrangère. Ceci est
          l'action par défaut.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>RESTRICT</literal></term>
        <listitem>
         <para>
          De même que <literal>NO ACTION</literal> sauf que cette action ne
          sera pas déferrée même si le reste de la contrainte est déferrable
          et déferrée.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>CASCADE</literal></term>
        <listitem>
         <para>
          Supprime toute ligne référençant la ligne supprimée ou met à jour la
          valeur de la colonne référencée avec la nouvelle valeur de la
          colonne référencée, respectivement.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET NULL</literal></term>
        <listitem>
         <para>
          Initialise les valeurs de la colonne de référence à null.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET DEFAULT</literal></term>
        <listitem>
         <para>
          Initialise les valeurs de la colonne de référence à leur valeur par
          défaut.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>

     <para>
      Si la clé primaire est mise à jour fréquemment, il pourrait être
      conseillé d'ajouter un index vers la colonne de clé étrangère de façon à
      ce que les actions <literal>NO ACTION</literal> et
      <literal>CASCADE</literal> associées avec la colonne de clé étrangère
      puissent être réalisées avec efficacité.
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
    <term><literal>DEFERRABLE</literal></term>
    <term><literal>NOT DEFERRABLE</literal></term>
    <listitem>
     <para>
      Ceci contrôle si la contrainte peut être déferrée. Une contrainte qui
      n'est pas déferrable sera vérifiée immédiatement après chaque commande. La
      vérification des contraintes qui sont déferrables pourraient attendre la
      fin de la transaction (en utilisant la commande <xref
      linkend="sql-set-constraints" endterm="sql-set-constraints-title">).
      <literal>NOT DEFERRABLE</literal> est la valeur par défaut. Seulement des
      contraintes de clé étrangère acceptent réellement cette clause. Tous les
      autres types de contraintes ne sont pas déferrables.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INITIALLY IMMEDIATE</literal></term>
    <term><literal>INITIALLY DEFERRED</literal></term>
    <listitem>
     <para>
      Si une contrainte est déferrable, cette clause spécifie le temps par
      défaut pour vérifier la contrainte. Si la contrainte est
      <literal>INITIALLY IMMEDIATE</literal>, elle est vérifiée après chaque
      instruction. Si la contrainte est <literal>INITIALLY DEFERRED</literal>,
      elle est vérifiée seulement à la fin de la transaction. Le moment de
      vérification de la contrainte peut être modifié avec la commande <xref
      linkend="sql-set-constraints" endterm="sql-set-constraints-title">.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ON COMMIT</literal></term>
    <listitem>
     <para>
      Le comportement des tables temporaires à la fin d'un bloc de transaction
      peut se contrôler en utilisant <literal>ON COMMIT</literal>. Les trois
      options sont&nbsp;

      <variablelist>
       <varlistentry>
        <term><literal>PRESERVE ROWS</literal></term>
        <listitem>
         <para>
	  Aucune action n'est prise à la fin des transactions. Ceci est le
	  comportement par défaut.
         </para>
     	</listitem>
       </varlistentry>
           
       <varlistentry>
        <term><literal>DELETE ROWS</literal></term>
        <listitem>
         <para>
          Toutes les lignes dans la table temporaire seront détruites à la
	  fin de chaque bloc de transaction. En fait, un <xref
	  linkend="sql-truncate"> automatique est réalisé à chaque validation.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DROP</literal></term>
        <listitem>
         <para>
          La table temporaire sera supprimée à la fin du bloc de transaction.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>    

 <refsect1 id="SQL-CREATETABLE-notes">
  <title>Notes</title>

  <itemizedlist>
   <listitem>
    <para>
     À chaque fois qu'une application utilise les OID pour identifier des
     lignes spécifiques d'une table, il est recommandé de créer une contrainte
     unique sur la colonne <structfield>oid</> de cette table pour s'assurer
     que les OID de la table identifieront les lignes réellement de façon unique
     même après une remise à zéro du compteur. Évitez d'assumer que les OID sont
     uniques pour les différentes tables&nbsp;; si vous avez besoin d'un
     identifieur unique sur la base de données, utilisez une combinaison de
     <structfield>tableoid</> et de l'OID de la ligne dans ce but. (Il est
     probable que les versions futures de <productname>PostgreSQL</> utiliseront
     un compteur OID séparé pour chaque table, de façon à ce qu'il soit
     <emphasis>nécessaire</>, et non pas optionnel, d'inclure
     <structfield>tableoid</> pour avoir un identifieur unique pour la base de
     données.)
    </para>

    <tip>
     <para>
      L'utilisation de <literal>WITHOUT OIDS</literal> n'est pas recommandée
      pour les tables sans clé primaire car, sans soit un OID soit une clé de
      données unique, il est difficile d'identifier des lignes spécifiques.
     </para>
    </tip>
   </listitem>

   <listitem>
    <para>
     <productname>PostgreSQL</productname> crée automatiquement un index pour
     chaque contrainte unique et pour chaque contrainte de clé étrangère pour
     renforcer l'unicité. Du coup, il n'est pas nécessaire de créer un index
     spécifique pour les colonnes de clés primaires. (Voir <xref
     linkend="sql-createindex" endterm="sql-createindex-title"> pour plus
     d'informations.)
    </para>
   </listitem>

   <listitem>
    <para>
     Les contraintes uniques et les clés primaires ne sont pas héritées dans
     l'implémentation actuelle. Ceci rend la combinaison de l'héritage et des
     contraintes uniques assez disfonctionnelle.
    </para>
   </listitem>
  </itemizedlist>
 </refsect1>


 <refsect1 id="SQL-CREATETABLE-examples">
  <title>Exemples</title>

  <para>
   Créez une table <structname>films</> et une table
   <structname>distributeurs</>&nbsp;:

<programlisting>
CREATE TABLE films (
    code        char(5) CONSTRAINT firstkey PRIMARY KEY,
    titre       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    genre       varchar(10),
    duree       interval hour to minute
);
</programlisting>

<programlisting>
CREATE TABLE distributeurs (
     did    integer PRIMARY KEY DEFAULT nextval('serial'),
     nom    varchar(40) NOT NULL CHECK (nom &lt;&gt; '')
);
</programlisting>
  </para>

  <para>
   Crée une table avec un tableau à deux dimensions&nbsp;:

<programlisting>
CREATE TABLE array (
    vecteur  int[][]
);
</programlisting>
  </para>

  <para>
   Définir une contrainte unique de table pour la table
   <literal>films</literal>. Les contraintes uniques de table peuvent être
   définies sur une ou plusieurs colonnes de la table.

<programlisting>
CREATE TABLE films (
    code        char(5),
    titre       varchar(40),
    did         integer,
    date_prod   date,
    genre       varchar(10),
    duree       interval hour to minute,
    CONSTRAINT production UNIQUE(date_prod)
);
</programlisting>
  </para>
  
  <para>
   Définir une contrainte de colonne de vérification&nbsp;:

<programlisting>
CREATE TABLE distributeurs (
    did     integer CHECK (did > 100),
    nom    varchar(40)
);
</programlisting>
  </para>

  <para>
   Définir une contrainte de table de vérification&nbsp;:

<programlisting>
CREATE TABLE distributeurs (
    did     integer,
    nom     varchar(40)
    CONSTRAINT con1 CHECK (did > 100 AND nom &lt;&gt; '')
);
</programlisting>
  </para>
 
  <para>
   Définir une contrainte de clé primaire sur la table <structname>films</>.
   Les contraintes de clé primaire peuvent être définies sur une ou
   plusieurs colonnes de la table.

<programlisting>
CREATE TABLE films (
    code        char(5),
    titre       varchar(40),
    did         integer,
    date_prod   date,
    genre       varchar(10),
    duree       interval hour to minute,
    CONSTRAINT code_title PRIMARY KEY(code,title)
);
</programlisting>
  </para>

  <para>
   Définir une contrainte de clé primaire pour la table
   <structname>distributeurs</>. Les deux exemples suivants sont équivalents,
   le premier utilisant la syntaxe de contrainte de la table, le second la
   notation de contrainte de la colonne.

<programlisting>
CREATE TABLE distributeurs (
    did     integer,
    nom     varchar(40),
    PRIMARY KEY(did)
); 
</programlisting>

<programlisting>
CREATE TABLE distributeurs (
    did     integer PRIMARY KEY,
    nom     varchar(40)
);
</programlisting>
  </para>

  <para>
   Ceci affecte une valeur par défaut pour la colonne <literal>nom</literal>,
   arrange la valeur par défaut de la colonne <literal>did</literal> pour être
   générée en sélectionnant la prochaine valeur d'un objet séquence et fait que
   la valeur par défaut de <literal>modtime</literal> soit le moment où la ligne
   est insérée.

<programlisting>
CREATE TABLE distributeurs (
    name      varchar(40) DEFAULT 'Luso Films',
    did       integer DEFAULT nextval('distributeurs_serial'),
    modtime   timestamp DEFAULT current_timestamp
);
</programlisting>
  </para>

  <para>
   Définir deux contraintes de colonnes <literal>NOT NULL</> sur la table
   <classname>distributeurs</classname>, dont une se voit donner explicitement
   un nom&nbsp;:

<programlisting>
CREATE TABLE distributeurs (
    did     integer CONSTRAINT no_null NOT NULL,
    nom     varchar(40) NOT NULL
);
</programlisting>
    </para>

    <para>
     Définit une contrainte unique pour la colonne <literal>nom</literal>&nbsp;:

<programlisting>
CREATE TABLE distributeurs (
    did     integer,
    nom     varchar(40) UNIQUE
);
</programlisting>

     Ce qui se trouve ci-dessus est équivalent à ce qui suit, spécifié comme
     une contrainte de table&nbsp;:

<programlisting>
CREATE TABLE distributeurs (
    did     integer,
    nom     varchar(40),
    UNIQUE(name)
);
</programlisting>
  </para>

 </refsect1>
 
 <refsect1 id="SQL-CREATETABLE-compatibility">
  <title id="SQL-CREATETABLE-compatibility-title">Compatibilité</title>

  <para>
   La commande <command>CREATE TABLE</command> se conforme à SQL92 et à un
   sous-ensemble de SQL99, avec les exceptions indiquées ci-dessous.
  </para>

  <refsect2>
   <title>Tables temporaires</title>

   <para>
    Bien que la syntaxe de <literal>CREATE TEMPORARY TABLE</literal> ressemble
    à celle du SQL standard, l'effet n'est pas le même. Dans le standard, les
    tables temporaires sont définies seulement une fois et existent
    automatiquement (en commençant avec un contenu vide) dans chaque session qui
    en a besoin. À la place, <productname>PostgreSQL</productname> requiert que
    chaque session lance sa propre commande <literal>CREATE TEMPORARY
    TABLE</literal> pour chaque table temporaire à utiliser.  Ceci permet à
    différentes sessions d'utiliser le même nom de table temporaire dans des
    buts différentes alors que l'approche du standard contraint toutes les
    instances d'un nom de table temporaire donné pour avoir la même structure de
    table.
   </para>

   <para>
    La définition du standard pour le comportement des tables temporaires est
    largement ignorée. Le comportement de <productname>PostgreSQL</productname>
    sur ce point est similaire à celui de nombreuses autres bases de données
    SQL.
   </para>

   <para>
    La distinction du standard entre tables temporaires globales et locales
    n'est pas dans <productname>PostgreSQL</productname> car cette distinction
    dépend du concept de modules, que <productname>PostgreSQL</productname> ne
    possède pas. Pour le bien de la compatibilité,
    <productname>PostgreSQL</productname> acceptera les mots clés
    <literal>GLOBAL</literal> et <literal>LOCAL</literal> dans la déclaration
    d'une table temporaire mais cela n'aura aucun effet.
   </para>

   <para>
    La clause <literal>ON COMMIT</literal> pour les tables temporaires
    ressemble aussi au standard SQL mais a quelques différences. Si la clause
    <literal>ON COMMIT</> est omise, SQL spécifie que le comportement par défaut
    est <literal>ON COMMIT DELETE ROWS</>. Néanmoins, le comportement par défaut
    dans <productname>PostgreSQL</productname> est <literal>ON COMMIT PRESERVE
    ROWS</literal>. L'option <literal>ON COMMIT DROP</literal> n'existe pas en
    SQL.
   </para>
  </refsect2>

  <refsect2>
   <title>Contraintes de vérification de colonnes</title>

   <para>
    Le standard SQL dit que les contraintes de vérification <literal>CHECK</>
    de colonne pourraient seulement référencer la colonne à laquelle elles
    s'appliquent&nbsp;; seulement les contraintes de tables <literal>CHECK</>
    pourraient se référencer à de nombreuses colonnes.
    <productname>PostgreSQL</productname> ne force pas cette restriction&nbsp;;
    il traite de la même façon les contraintes de vérifications des colonnes et
    des tables.
   </para>
  </refsect2>

  <refsect2>
   <title>Contrainte <literal>NULL</literal></title>

   <para>
    La <quote>contrainte</quote> <literal>NULL</> (réellement une
    non-contrainte) est une extension <productname>PostgreSQL</productname> au
    standard SQL qui est inclus pour des raisons de compatibilité avec quelques
    autres systèmes de bases de données (et pour la symétrie avec la contrainte
    <literal>NOT NULL</literal>). Comme ceci est la valeur par défaut de cette
    colonnes, sa présence est un simple bruit.
   </para>
  </refsect2>
   
  <refsect2>
   <title>Héritage</title>

   <para>
    Plusieurs héritages via la clause <literal>INHERITS</literal> est une
    extension du langage <productname>PostgreSQL</productname>. SQL99 (et non
    pas SQL92) définit un héritage simple en utilisant une syntaxe et des
    sémantiques différentes. L'héritage style SQL99 n'est pas encore supporté 
    par <productname>PostgreSQL</productname>.
   </para>
  </refsect2>

  <refsect2>
   <title>Object IDs</title>

   <para>
    Le concept <productname>PostgreSQL</productname> des OID n'est pas
    standard.
   </para>
  </refsect2>

  <refsect2>
   <title>Tables à zéro colonne</title>

   <para>
    <productname>PostgreSQL</productname> autorise la création de tables sans
    colonnes (par exemple, <literal>CREATE TABLE foo();</>). Ceci est une
    extension du standard SQL, qui ne le permet pas. Les tables sans colonnes ne
    sont pas très utiles mais les désactiver pourrait apporter quelques cas
    bizarres spéciaux pour  <command>ALTER TABLE DROP COLUMN</>, donc il semble
    plus propre d'ignorer la restriction de cette spécification.
   </para>
  </refsect2>
 </refsect1>


 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-altertable" endterm="sql-altertable-title"></member>
   <member><xref linkend="sql-droptable" endterm="sql-droptable-title"></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
