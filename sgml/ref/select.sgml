<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/select.sgml,v 1.9.2.3 2005/07/15 06:33:55 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-SELECT">
 <refmeta>
  <refentrytitle id="sql-select-title">SELECT</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>SELECT</refname>
  <refpurpose>récupère des lignes d'une table ou vue</refpurpose>
 </refnamediv>

 <indexterm zone="sql-select">
  <primary>SELECT</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
SELECT [ ALL | DISTINCT [ ON ( <replaceable class="parameter">expression</replaceable> [, ...] ) ] ]
    * | <replaceable class="parameter">expression</replaceable> [ AS <replaceable class="parameter">nom_d_affichage</replaceable> ] [, ...]
    [ FROM <replaceable class="parameter">éléments_from</replaceable> [, ...] ]
    [ WHERE <replaceable class="parameter">condition</replaceable> ]
    [ GROUP BY <replaceable class="parameter">expression</replaceable> [, ...] ]
    [ HAVING <replaceable class="parameter">condition</replaceable> [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL ] <replaceable class="parameter">select</replaceable> ]
    [ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC |
DESC | USING <replaceable class="parameter">opérateur</replaceable> ] [, ...] ]
    [ LIMIT { <replaceable class="parameter">nombre</replaceable> | ALL } ]
    [ OFFSET <replaceable class="parameter">début</replaceable> ]
    [ FOR UPDATE [ OF <replaceable class="parameter">nom_table</replaceable> [,
...] ] ]

où <replaceable class="parameter">éléments_from</replaceable> fait partie de:

    [ ONLY ] <replaceable class="parameter">nom_table</replaceable> [ * ] [ [
AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable
class="parameter">alias_colonne</replaceable> [, ...] ) ] ]
    ( <replaceable class="parameter">select</replaceable> ) [ AS ] <replaceable
class="parameter">alias</replaceable> [ ( <replaceable
class="parameter">alias_colonne</replaceable> [, ...] ) ]
    <replaceable class="parameter">nom_fonction</replaceable> ( [ <replaceable
class="parameter">argument</replaceable> [, ...] ] ) [ AS ] <replaceable
class="parameter">alias</replaceable> [ ( <replaceable
class="parameter">alias_colonne</replaceable> [, ...] | <replaceable
class="parameter">définition_colonne</replaceable> [, ...] ) ]
    <replaceable class="parameter">nom_fonction</replaceable> ( [ <replaceable
class="parameter">argument</replaceable> [, ...] ] ) AS ( <replaceable
class="parameter">définition_colonne</replaceable> [, ...] )
    <replaceable class="parameter">éléments_from</replaceable> [ NATURAL ]
<replaceable class="parameter">type_jointure</replaceable> <replaceable
class="parameter">éléments_from</replaceable> [ ON <replaceable
class="parameter">condition_jointure</replaceable> | USING ( <replaceable
class="parameter">colonne_jointure</replaceable> [, ...] ) ]
</synopsis>

 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>SELECT</command> récupère des lignes à partir d'une ou plusieurs
   tables. Le traitement général de <command>SELECT</command> est le
   suivant&nbsp;:

   <orderedlist>
    <listitem>
     <para>
      Tous les éléments de la liste <literal>FROM</literal> sont calculés.
      (Chaque élément dans la liste <literal>FROM</literal> est une table réelle
      ou virtuelle.) Si plus d'un élément est spécifié dans la liste
      <literal>FROM</literal>, ils sont joints ensemble. (Voir <xref
      linkend="sql-from" endterm="sql-from-title"> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>WHERE</literal> est spécifiée, toutes les lignes
      qui ne satisfont pas les conditions sont éliminées de l'affichage. (Voir
      <xref linkend="sql-where" endterm="sql-where-title"> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>GROUP BY</literal> est spécifiée, l'affichage est
      divisée en groupes de lignes qui correspondent à une ou plusieurs valeurs.
      Si la clause <literal>HAVING</literal> est présente, elle élimine les
      groupes qui ne satisfont pas la condition donnée. (Voir <xref
      linkend="sql-groupby" endterm="sql-groupby-title"> et <xref
      linkend="sql-having" endterm="sql-having-title"> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      En utilisant les opérateurs <literal>UNION</literal>,
      <literal>INTERSECT</literal> et <literal>EXCEPT</literal>, l'affichage de
      plus d'une instruction <command>SELECT</command> peut être combiné pour
      former un ensemble de résultats. L'opérateur <literal>UNION</literal>
      renvoie toutes les lignes qui sont dans un ou plusieurs ensembles de
      résultats. L'opérateur <literal>INTERSECT</literal> renvoie toutes les
      lignes qui sont dans les deux ensembles de résultats.
      L'opérateur <literal>EXCEPT</literal> renvoie les lignes qui sont
      présentes dans le premier ensemble de résultats mais pas dans le deuxième.
      Dans les trois cas, les lignes dupliquées sont éliminées sauf si
      <literal>ALL</literal> est spécifié. (Voir <xref linkend="sql-union"
      endterm="sql-union-title">, <xref linkend="sql-intersect"
      endterm="sql-intersect-title"> et <xref linkend="sql-except"
      endterm="sql-except-title"> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Les lignes réellement affichées sont calculées en utilisant les
      expressions d'affichage de <command>SELECT</command> pour chaque ligne
      sélectionnée. (Voir <xref linkend="sql-select-list"
      endterm="sql-select-list-title"> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>ORDER BY</literal> est spécifiée, les lignes
      renvoyées sont triées dans l'ordre spécifié. Si <literal>ORDER
      BY</literal> n'est pas indiqué, les lignes sont renvoyées dans l'ordre que
      le système trouve le plus rapide à fournir. (Voir <xref
      linkend="sql-orderby" endterm="sql-orderby-title"> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      <literal>DISTINCT</literal> élimine les lignes dupliquées du résultat.
      <literal>DISTINCT ON</literal> élimine les lignes qui correspondent à
      toutes les expressions données. <literal>ALL</literal> (la valeur par
      défaut) renvoie toutes les lignes candidates, même les lignes
      dupliquées. (Voir <xref linkend="sql-distinct"
      endterm="sql-distinct-title"> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>LIMIT</literal> ou <literal>OFFSET</literal> est
      spécifiée, l'instruction <command>SELECT</command> renvoiret seulement un
      sous-ensemble de lignes de résultats. (Voir <xref linkend="sql-limit"
      endterm="sql-limit-title"> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      La clause <literal>FOR UPDATE</literal> fait que l'instruction verrouille
      les lignes sélectionnées contre les mises à jour concurrentes. (Voir <xref
      linkend="sql-for-update" endterm="sql-for-update-title"> ci-dessous.)
     </para>
    </listitem>
   </orderedlist>
  </para>
   
  <para>
   Vous devez avoir le droit <literal>SELECT</literal> sur une table pour lire
   ses valeurs. L'utilisation de <literal>FOR UPDATE</literal> requiert de
   plus le droit <literal>UPDATE</literal>.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <refsect2 id="SQL-FROM">
   <title id="sql-from-title">Clause <literal>FROM</literal></title>

   <para>
    La clause <literal>FROM</literal> spécifie une ou plusieurs tables source
    pour <command>SELECT</command>. Si plusieurs sources sont spécifiées, le
    résultat est un produit cartésien (jointure croisée) de toutes les sources.
    Mais habituellement, des conditions de qualification sont ajoutées pour
    restreindre les lignes renvoyées à un petit sous-ensemble du produit
    cartésien.
   </para>

   <para>
    Les éléments de la clause <literal>FROM</literal> peuvent contenir&nbsp;:

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">nom_table</replaceable></term>
      <listitem>
       <para>
        Le nom (pouvant être qualifié du nom du schéma) d'une table existante
	ou d'une vue. Si <literal>ONLY</> est spécifié, seule cette table est
	parcourue. Si <literal>ONLY</> n'est pas spécifié, la table et toutes ses
	descendantes (si elles existent) sont parcourues. <literal>*</> peut
	être ajouté au nom de la table pour indiquer que les tables descendantes
	doivent être parcourues mais, dans la version actuelle, c'est le
	comportement par défaut. (Dans les versions précédant la 7.1,
	<literal>ONLY</> était le comportement par défaut.) Le comportement par
	défaut peut être modifié en changeant l'option de configuration
	<varname>sql_inheritance</varname>.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><replaceable class="parameter">alias</replaceable></term>
      <listitem>
       <para>
        Un nom de substitution pour l'élément <literal>FROM</> contenant
	l'alias. Un alias est utilisé par brièveté ou pour éliminer toute
	ambiguïté pour les jointures où la même table est parcourue plusieurs
	fois. Quand un alias est fourni, il cache complètement le nom réel de
	la table ou fonction&nbsp; ; par exemple, avec <literal>FROM foo AS
	f</>, le reste du <command>SELECT</command> doit faire référence à cet
	élément de <literal>FROM</> par <literal>f</> et non pas par
	<literal>foo</>. Si un alias est écrit, une liste d'alias de colonnes
	peut aussi être saisie pour fournir des noms de substitution pour une ou
	plusieurs colonnes de la table.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><replaceable class="parameter">select</replaceable></term>
      <listitem>
       <para>
        Un sous-<command>SELECT</command> peut apparaître dans la clause
        <literal>FROM</literal>. Ceci agit comme si sa sortie était transformée en
	une table temporaire pour la durée de cette seule commande
	<command>SELECT</command>. Notez que le sous-<command>SELECT</command>
	doit être entouré par des parenthèses et un alias
	<emphasis>doit</emphasis> être fourni pour lui.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nom_fonction</replaceable></term>
      <listitem>
       <para>
        Des appels de fonction peuvent apparaître dans la clause
	<literal>FROM</literal>. (Ceci est particulièrement utile pour les
	fonctions renvoyant des ensembles de résultats mais toute fonction peut
	être utilisée.) Ceci agit comme si sa sortie était transformée en une table
	temporaire pour la durée de cette seule commande
	<command>SELECT</command>. Un alias peut aussi être utilisé. Si un
	alias est donné, une liste d'alias de colonnes peut être ajouté pour
	fournir des noms de substitution pour un ou plusieurs attributs du type
	composé de retour de la fonction. Si la fonction a été définie comme
	renvoyant le type de données <type>record</>, alors un alias ou un mot
	clé <literal>AS</> doit être présent, suivi par une liste de définitions
	de colonnes de la forme <literal>( <replaceable
	class="parameter">nom_colonne</replaceable> <replaceable
	class="parameter">type_données</replaceable> <optional>, ... </>
	)</literal>. La liste de définitions de colonnes doit correspondre au
	nombre réel et aux types réels des colonnes renvoyées par la fonction.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><replaceable class="parameter">type_jointure</replaceable></term>
      <listitem>
       <para>
        Fait partie de
        <itemizedlist>
         <listitem>
          <para><literal>[ INNER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>LEFT [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>RIGHT [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>FULL [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>CROSS JOIN</literal></para>
         </listitem>
        </itemizedlist>

        Pour les types de jointures <literal>INNER</> et <literal>OUTER</>, une
	et une seule condition de jointure doit être spécifiée, parmi
        <literal>NATURAL</>, <literal>ON <replaceable
        class="parameter">condition_jointure</replaceable></literal> ou
        <literal>USING (<replaceable
        class="parameter">colonne_jointure</replaceable> [, ...])</literal>.
        Voir ci-dessous pour la signification. Pour <literal>CROSS
	JOIN</literal>, aucune de ces clause ne doit apparaître.
       </para>

       <para>
        Une clause <literal>JOIN</literal> combine deux éléments
        <literal>FROM</>. Utilisez les parenthèses si nécessaire pour
	déterminer l'ordre d'imbrication. En l'absence de parenthèses,
	les <literal>JOIN</literal> sont imbriqués de gauche à droite. Dans
	tous les cas, <literal>JOIN</literal> est plus prioritaire que les
	virgules séparant les éléments <literal>FROM</>.
       </para>

       <para>
        <literal>CROSS JOIN</> et <literal>INNER JOIN</literal> produisent un
	simple produit cartésien, le même résultat que vous obtenez à partir de
	la liste de deux éléments au niveau haut du <literal>FROM</>, mais
	restreint par la condition de jointure (si elle existe). <literal>CROSS
	JOIN</> est équivalent à <literal>INNER JOIN ON (TRUE)</>, c'est-à-dire
	qu'aucune ligne n'est supprimée par qualification. Ces types de
	jointure sont juste une aide à la notation car elles ne font rien de
	plus qu'un simple <literal>FROM</> et <literal>WHERE</>.
       </para>

       <para>
        <literal>LEFT OUTER JOIN</> renvoie toutes les lignes dans le produit
	cartésien indiqué (c'est-à-dire toutes les lignes combinées qui
	réussissent la condition de jointure), plus une copie de chaque ligne
	dans le côté gauche de la table pour laquelle il n'y a pas de côté droit
	qui a réussi la condition de jointure. Cette ligne coité gauche est
	étendue à la largeur complète de la table jointe par insertion de
	valeurs NULL pour les colonnes côté droit. Notez que seule la 
	condition de la clause <literal>JOIN</> est considérée pour décider des
	lignes qui correspondent. Les conditions externes sont appliquées après
	coup.
       </para>

       <para>
        Au contraire, <literal>RIGHT OUTER JOIN</> renvoie toutes les lignes
	jointes plus une ligne pour chaque ligne côté droit sans correspondance
	(étendue par des NULL pour le côté gauche). Ceci est une simple aide à
	la notation car vous pourriez la convertir en <literal>LEFT</> en 
        inversant les tables gauche et droite.
       </para>

       <para>
        <literal>FULL OUTER JOIN</> renvoie toutes les lignes jointes, plus
	chaque ligne gauche sans correspondance (étendue par des NULL à droite),
	plus chaque ligne droite sans correspondance (étendue par des NULL à
	gauche).
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><literal>ON <replaceable
class="parameter">condition_jointure</replaceable></literal></term>
      <listitem>
       <para>
        <replaceable class="parameter">condition_jointure</replaceable> est une
        expression qui renvoie une valeur de type <type>boolean</type>
	(similaire à une clause <literal>WHERE</literal>) qui spécifie quelles
	lignes d'une jointure doivent correspondre.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><literal>USING (<replaceable
	class="parameter">colonne_jointure</replaceable> [,
	...])</literal></term>
      <listitem>
       <para>
        Une clause <literal>USING ( a, b, ... )</literal> est un
	raccourci pour <literal>ON left_table.a = right_table.a AND left_table.b
	= right_table.b ...</literal>. De plus, <literal>USING</> implique que
	seule une des paires de colonnes équivalentes est inclue dans la sortie
	de la jointure, pas les deux.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NATURAL</literal></term>
      <listitem>
       <para>
        <literal>NATURAL</literal> est un raccourci pour une liste
        <literal>USING</> qui mentionne toutes les colonnes dans les deux tables
	qui ont le même nom.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>
   
  <refsect2 id="SQL-WHERE">
   <title id="sql-where-title">Clause <literal>WHERE</literal></title>

   <para>
    La clause <literal>WHERE</literal> optionnelle a la forme générale
<synopsis>
WHERE <replaceable class="parameter">condition</replaceable>
</synopsis>
    où <replaceable class="parameter">condition</replaceable> est une expression
    qui s'évalue en un résultat de type <type>boolean</type>. Toute ligne ne
    satisfaisant pas cette condition est éliminée de la sortie. Une ligne
    satisfait la condition si elle renvoie vrai quand les valeurs réelles
    de la ligne sont substituées à toute référence de variable.
   </para>
  </refsect2>
  
  <refsect2 id="SQL-GROUPBY">
   <title id="sql-groupby-title">Clause <literal>GROUP BY</literal></title>

   <para>
    La clause <literal>GROUP BY</literal> optionnelle a la forme générale
<synopsis>
GROUP BY <replaceable class="parameter">expression</replaceable> [, ...]
</synopsis>
   </para>

   <para>
    <literal>GROUP BY</literal> condense en une seule ligne toutes les lignes
    sélectionnées qui partagent les mêmes valeurs pour les expressions
    groupées. <replaceable class="parameter">expression</replaceable> peut être
    un nom de colonne en entrée, ou le nom ou le nombre ordinal d'une colonne
    en sortie (élément de la liste <command>SELECT</command>), ou une expression
    arbitraire formée par des valeurs de colonnes en entrée. Dans le cas d'une
    ambiguïté, un nom <literal>GROUP BY</literal> est interprété comme un nom
    de colonne en entrée plutôt qu'un nom de colonne en sortie.
   </para>

   <para>
    Les fonctions d'agrégat, si elles sont utilisées, sont calculées pour
    toutes les lignes composant chaque groupe, produisant une valeur séparée
    pour chaque groupe (alors que sans <literal>GROUP BY</literal>, un agrégat
    produit une valeur unique calculée avec toutes les lignes
    sélectionnées). Quand <literal>GROUP BY</literal> est présent, il n'est pas
    valide que les expressions de liste <command>SELECT</command> fassent
    référence aux colonnes non groupées sauf à l'intérieur de fonctions
    d'agrégat car il y aurait plus d'une valeur possible à renvoyer pour une
    colonne non groupée.
   </para>
  </refsect2>

  <refsect2 id="SQL-HAVING">
   <title id="sql-having-title">Clause <literal>HAVING</literal></title>

   <para>
    La clause <literal>HAVING</literal> optionnelle a la forme générale
<synopsis>
HAVING <replaceable class="parameter">condition</replaceable>
</synopsis>
    où <replaceable class="parameter">condition</replaceable> est identique à
    celle spécifiée pour la clause <literal>WHERE</literal>.
   </para>
    
   <para>
    <literal>HAVING</literal> élimine les lignes groupées qui ne satisfont
    pas à la condition. <literal>HAVING</literal> est différent de
    <literal>WHERE</literal>&nbsp;: <literal>WHERE</literal> filtre les lignes
    individuelles avant l'application de <literal>GROUP BY</literal> alors que
    <literal>HAVING</literal> filtre les lignes groupées créées par
    <literal>GROUP BY</literal>. Chaque colonne référencée dans <replaceable
    class="parameter">condition</replaceable> doit référencer sans ambiguïté une
    colonne groupée, sauf si la référence apparaît dans une fonction d'agrégat.
   </para>
  </refsect2>
  
  <refsect2 id="SQL-UNION">
   <title id="sql-union-title">Clause <literal>UNION</literal></title>

   <para>
    La clause <literal>UNION</literal> a la forme générale&nbsp;:
<synopsis>
<replaceable class="parameter">instruction_select</replaceable> UNION [ ALL ]
<replaceable class="parameter">instruction_select</replaceable>
</synopsis>
    <replaceable class="parameter">instruction_select</replaceable> est toute
    instruction <command>SELECT</command> sans clause <literal>ORDER BY</>,
    <literal>LIMIT</> ou <literal>FOR UPDATE</literal>. (<literal>ORDER BY</> et
    <literal>LIMIT</> peuvent être attachés à une sous-expression si elle est
    englobée dans des parenthèses. Sans parenthèses, ces clauses
    s'appliquent au résultat de l'<literal>UNION</literal>, et non pas à son
    expression côté droit.)
   </para>
    
   <para>
    L'opérateur <literal>UNION</literal> calcule l'union ensembliste des
    lignes renvoyées par les instructions <command>SELECT</command> impliquées.
    Une ligne est dans l'union de deux ensembles de résultats si elle apparaît
    dans au moins un des ensembles de résultats. Les deux instructions
    <command>SELECT</command> qui représentent les opérandes directs de
    l'<literal>UNION</literal> doivent produire le même nombre de colonnes et
    les colonnes correspondantes doivent être d'un type de données compatible.
   </para>
    
   <para>
    Le résultat de <literal>UNION</> ne contient pas de lignes
    dupliquées sauf si l'option <literal>ALL</> est specifiée. <literal>ALL</>
    empêche l'élimination des lignes dupliquées.
   </para>
    
   <para>
    Plusieurs opérateurs <literal>UNION</> dans la même instruction
    <command>SELECT</command> sont évalués de gauche à droite sauf si c'est
    indiqué autrement par des parenthèses.
   </para>
    
   <para>
    Actuellement, <literal>FOR UPDATE</> ne peut pas être indiqué pour un
    résultat <literal>UNION</> ou pour toute entrée d'un <literal>UNION</>.
   </para>
  </refsect2>

  <refsect2 id="SQL-INTERSECT">
   <title id="sql-intersect-title">Clause <literal>INTERSECT</literal></title>

   <para>
    La clause <literal>INTERSECT</literal> a cette forme générale&nbsp;:
<synopsis>
<replaceable class="parameter">instruction_select</replaceable> INTERSECT [ ALL
] <replaceable class="parameter">instruction_select</replaceable>
</synopsis>
    <replaceable class="parameter">instruction_select</replaceable> est toute
    instruction <command>SELECT</command> sans clause <literal>ORDER BY</>,
    <literal>LIMIT</> ou <literal>FOR UPDATE</literal>.
   </para>

   <para>
    L'opérateur <literal>INTERSECT</literal> calcule l'intersection des lignes
    renvoyées par les instructions <command>SELECT</command> impliquées. Une
    ligne est dans l'intersection des deux ensembles de résultats si elle
    apparaît dans chacun des deux ensembles.
   </para>
    
   <para>
    Le résultat d'<literal>INTERSECT</literal> ne contient pas de lignes
    dupliquées sauf si l'option <literal>ALL</> est spécifiée. Avec
    <literal>ALL</>, une ligne qui a m lignes dupliquées dans la table gauche et
    n lignes dupliquées dans la table droite apparaît min(m,n) fois dans
    l'ensemble de résultats.
   </para>
    
   <para>
    Plusieurs <literal>INTERSECT</literal> dans la même instruction
    <command>SELECT</command> sont évalués de gauche à droite sauf si des
    parenthèses dictent le contraire. <literal>INTERSECT</literal> est plus 
    prioritaire que <literal>UNION</literal>. C'est-à-dire que <literal>A UNION B
    INTERSECT C</literal> est lu comme <literal>A UNION (B INTERSECT
    C)</literal>.
   </para>
  </refsect2>

  <refsect2 id="SQL-EXCEPT">
   <title id="sql-except-title">Clause <literal>EXCEPT</literal></title>

   <para>
    La clause <literal>EXCEPT</literal> a cette forme générale&nbsp;:
<synopsis>
<replaceable class="parameter">instruction_select</replaceable> EXCEPT [ ALL ]
<replaceable class="parameter">instruction_select</replaceable>
</synopsis>
    <replaceable class="parameter">instruction_select</replaceable> est toute
    instruction <command>SELECT</command> sans clause <literal>ORDER
    BY</>, <literal>LIMIT</> ou <literal>FOR UPDATE</literal>.
   </para>

   <para>
    L'opérateur <literal>EXCEPT</literal> calcule l'ensemble de lignes qui sont
    dans le résultat de l'instruction <command>SELECT</command> de gauche mais
    pas dans le résultat de celle de droite.
   </para>
    
   <para>
    Le résultat de <literal>EXCEPT</literal> ne contient aucune ligne dupliquée
    sauf si l'option <literal>ALL</> est spécifiée. Avec <literal>ALL</>, une
    ligne qui a m dupliquées dans la table gauche et n dupliquées dans la table
    droite apparaît max(m-n,0) fois dans l'ensemble de résultat.
   </para>
    
   <para>
    Plusieurs opérateurs <literal>EXCEPT</literal> dans la même instruction
    <command>SELECT</command> sont évalués de gauche à droite sauf si des
    parenthèses dictent le contraire. <literal>EXCEPT</> a la même priorité
    qu'<literal>UNION</>.
   </para>
  </refsect2>

  <refsect2 id="sql-select-list">
   <title id="sql-select-list-title">Liste <command>SELECT</command></title>

   <para>
    La liste <command>SELECT</command> (entre les mots clés
    <literal>SELECT</> et <literal>FROM</>) indique les expressions qui
    forment les lignes en sortie de l'instruction <command>SELECT</command>. Les
    expressions peuvent faire (et habituellement font) référence aux colonnes
    calculées dans la clause <literal>FROM</>. En utilisant la clause
    <literal>AS <replaceable
    class="parameter">nom_sortie</replaceable></literal>, un autre nom peut être
    indiqué pour une colonne en sortie. Ce nom est utilisé principalement pour
    nommer la colonne à l'affichage. Il peut aussi être utilisé pour référencer
    la valeur de la colonne dans les clauses <literal>ORDER BY</> et
    <literal>GROUP BY</> mais pas dans les clauses <literal>WHERE</> ou
    <literal>HAVING</>&nbsp;; là, vous devez écrire l'expression à la place.
   </para>

   <para>
    Au lieu d'une expression, on peut utiliser <literal>*</literal> dans la
    liste de sortie comme raccourci pour toutes les colonnes des lignes
    sélectionnées. De plus, vous pouvez écrire <literal><replaceable
    class="parameter">nom_table</replaceable>.*</literal> comme raccourci pour
    toutes les colonnes provenant de cette table.
   </para>
  </refsect2>

  <refsect2 id="SQL-ORDERBY">
   <title id="sql-orderby-title">Clause <literal>ORDER BY</literal></title>

   <para>
    La clause optionnelle <literal>ORDER BY</literal> a cette forme
    générale&nbsp;:
<synopsis>
ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC |
USING <replaceable class="parameter">opérateur</replaceable> ] [, ...]
</synopsis>
    <replaceable class="parameter">expression</replaceable> peut être le nom ou
    le numéro ordinal d'une colonne en sortie (élément de la liste
    <command>SELECT</command>) ou il peut être une expression quelconque formée
    à partir des valeurs des colonnes en entrée.
   </para>

   <para>
    La clause <literal>ORDER BY</literal> fait que les lignes de résultat 
    sont triées suivant les expressions spécifiées. Si deux lignes sont
    identiques suivant l'expression la plus à gauche, elles sont comparées avec
    la prochaine expression et ainsi de suite. Si elles sont identiques pour
    toutes les expressions spécifiées, elles sont renvoyées dans un ordre
    dépendant de l'implémentation.
   </para>

   <para>
    Le numéro ordinal fait référence à la position ordinale (de gauche à droite) de la
    colonne de résultat. Cette fonctionnalité rend possible de définir un ordre
    sur la base d'une colonne qui n'a pas un nom unique. Ceci n'est jamais
    absolument nécessaire parce qu'il est toujours possible d'affecter un nom à
    une colonne résultat en utilisant la clause <literal>AS</>.
   </para>
    
   <para>
    Il est aussi possible d'utiliser des expressions quelconques dans la clause
    <literal>ORDER BY</literal>, incluant des colonnes qui n'apparaissent pas
    dans la liste de résultat du <command>SELECT</command>. Du coup,
    l'instruction suivante est valide&nbsp;:
<programlisting>
SELECT nom FROM distributeurs ORDER BY code;
</programlisting>
    Une limitation de cette fonctionnalité est que la clause <literal>ORDER
    BY</> s'appliquant au résultat d'une clause <literal>UNION</>,
    <literal>INTERSECT</> ou <literal>EXCEPT</> peut seulement spécifier
    un nom ou numéro de colonne en sortie, pas une expression.
   </para>
    
   <para>
    Si une expression <literal>ORDER BY</> est un simple nom qui correspond à
    la fois à un nom de colonne résultat et à un nom de colonne en entrée,
    <literal>ORDER BY</> l'interprète comme le nom de la colonne résultat.
    Ceci est le contraire du choix que <literal>GROUP BY</> fait dans la même
    situation. Cette incohérence est nécessaire pour être compatible avec le
    standard SQL.
   </para>
    
   <para>
    Optionnellement, vous pourriez ajouter le mot clé <literal>ASC</>
    (ascendant) ou <literal>DESC</> (descendant) après toute expression de la
    clause <literal>ORDER BY</>. Sans indication, <literal>ASC</> est la valeur
    supposée par défaut. Autrement, un nom d'opérateur d'ordre spécifique
    peut être fourni dans la clause <literal>USING</>. <literal>ASC</> est
    habituellement équivalent à <literal>USING &lt;</> et <literal>DESC</> est
    habituellement équivalent à <literal>USING &gt;</>. (Mais le créateur d'un
    type de données défini par l'utilisateur peut définir à sa guise le tri par
    défaut et il pourrait correspondre à des opérateurs de nom différent.)
   </para>

   <para>
    La valeur NULL est triée plus haut que toute autre valeur. En d'autres termes,
    avec un ordre de tri ascendant, les valeurs NULL sont triées à la fin et
    avec un ordre de tri descendant, elles sont triées au début.
   </para>

   <para>
    Les données de chaînes de caractères sont triées suivant
    l'ordre spécifique à la locale, ordre établi au moment de la création du
    groupe de bases de données.
   </para>
  </refsect2>
  
  <refsect2 id="SQL-LIMIT">
   <title id="sql-limit-title">Clause <literal>LIMIT</literal></title>

   <para>
    La clause <literal>LIMIT</literal> consiste en deux sous-clauses
    indépendantes&nbsp;:
<synopsis>
LIMIT { <replaceable class="parameter">nombre</replaceable> | ALL }
OFFSET <replaceable class="parameter">début</replaceable>
</synopsis>
    <replaceable class="parameter">nombre</replaceable> spécifie le nombre
    maximum de lignes à renvoyer alors que <replaceable
    class="parameter">début</replaceable> spécifie le nombre de lignes à passer
    avant de commencer à renvoyer des lignes. Quand les deux sont spécifiés,
    <replaceable class="parameter">début</replaceable> lignes sont passées avant
    de commencer à compter les <replaceable
    class="parameter">nombre</replaceable> lignes à renvoyer.
   </para>

   <para>
    Lors de l'utilisation de <literal>LIMIT</>, utiliser la clause
    <literal>ORDER BY</> est une bonne idée pour contraindre les lignes de
    résultat en un ordre unique. Sinon, vous obtenez un sous-ensemble non
    prévisible de lignes de la requête --- vous pourriez demander les lignes 10
    à 20 mais de la 10 à la 20 dans quel ordre&nbsp;? Vous ne savez pas l'ordre
    tant que vous ne le spécifiez pas avec <literal>ORDER BY</>.
   </para>

   <para>
    Le planificateur de requêtes prend <literal>LIMIT</> en compte lors de
    la génération d'un plan de requêtes, donc vous avez beaucoup de chances
    d'obtenir des plans différents (récupération d'ordre de lignes différents)
    suivant ce que vous utilisez pour <literal>LIMIT</> et <literal>OFFSET</>.
    Du coup, l'utilisation de valeurs différentes pour
    <literal>LIMIT</>/<literal>OFFSET</> pour sélectionner des sous-ensembles
    d'un résultat de requête <emphasis>donne éventuellement des résultats
    incohérents</emphasis> sauf si vous forcez un ordre de résultat prévisible
    avec <literal>ORDER BY</>. Ceci n'est pas un bogue&nbsp;; c'est une
    conséquence inhérente au fait que SQL ne promet pas de délivrer les
    résultats d'une requête dans un ordre particulier sauf si <literal>ORDER
    BY</> est utilisé pour forcer cet ordre.
   </para>
  </refsect2>

  <refsect2 id="sql-distinct">
   <title id="sql-distinct-title">Clause <literal>DISTINCT</literal></title>

   <para>
    Si <literal>DISTINCT</> est spécifié, toutes les lignes dupliquées sont
    supprimées de l'ensemble de résultat (une ligne est conservée pour chaque
    groupe de lignes dupliquées). <literal>ALL</> spécifie le contraire&nbsp;:
    toutes les lignes sont conservées&nbsp;;ceci est la valeur par défaut.
   </para>

   <para>
    <literal>DISTINCT ON ( <replaceable
    class="parameter">expression</replaceable> [, ...] )</literal>
    conserve seulement la première ligne de chaque ensemble de lignes où les
expressions sont évaluées comme identiques. Les expressions <literal>DISTINCT
ON</literal> sont interprétées en utilisant les mêmes règles que pour
<literal>ORDER BY</> (voir ci-dessus). Notez que la <quote>première
ligne</quote> de chaque ensemble n'est pas prévisible sauf si <literal>ORDER
BY</> est utilisé pour s'assurer que la ligne désirée apparaît en premier. Par
exemple,
<programlisting>
SELECT DISTINCT ON (emplacement) emplacement, heure, rapport
    FROM rapports_meteo
    ORDER BY emplacement, heure DESC;
</programlisting>
    récupère le rapport météo le plus récent pour chaque emplacement. Mais si
    nous n'avions pas utilisé <literal>ORDER BY</> pour forcer l'ordre
    descendant des valeurs heure pour chaque emplacement, nous aurions obtenu un
    rapport à partir d'une heure non prévisible pour chaque emplacement.
   </para>

   <para>
    Le(s) expression(s) <literal>DISTINCT ON</> doi(ven)t correspondre à
    l'ordre des expression <literal>ORDER BY</>. La clause <literal>ORDER
    BY</> contient normalement des expressions supplémentaires qui déterminent
    la précédence désirée des lignes à l'intérieur de chaque groupe
    <literal>DISTINCT ON</>.
   </para>
  </refsect2>

  <refsect2 id="SQL-FOR-UPDATE">
   <title id="sql-for-update-title">Clause <literal>FOR UPDATE</literal></title>

   <para>
    La clause <literal>FOR UPDATE</literal> a cette forme&nbsp;:
<synopsis>
FOR UPDATE [ OF <replaceable class="parameter">nom_table</replaceable> [, ...] ]
</synopsis>
   </para>

   <para>
    <literal>FOR UPDATE</literal> fait que les lignes récupérées par
    l'instruction <command>SELECT</command> sont verrouillées pour modification.
    Ceci les empêche d'être modifiées ou supprimées par les autres transactions
    jusqu'à la fin de la transaction en cours. C'est-à-dire que les autres
    transactions tentant des <command>UPDATE</command>,
    <command>DELETE</command> ou <command>SELECT FOR UPDATE</command> de ces
    lignes sont bloquées jusqu'à ce que la transaction en cours se termine. De
    plus, si un <command>UPDATE</command>, <command>DELETE</command> ou
    <command>SELECT FOR UPDATE</command> à partir d'une autre transaction a déjà
    verrouillé une ligne ou un ensemble de lignes, <command>SELECT FOR
    UPDATE</command> attend la fin de l'autre transaction puis verrouille et
    renvoie la ligne modifiée (ou aucune ligne si elle a été supprimée). Pour
    plus d'informations, voir <xref linkend="mvcc">.
   </para>

   <para>
    Si des tables spécifiques sont nommées dans <literal>FOR UPDATE</literal>,
    alors seules les lignes provenant de ces tables sont verrouillées&nbsp;
    toute autre table utilisée dans le <command>SELECT</command> est simplement
    lue comme d'habitude.
   </para>

   <para>
    <literal>FOR UPDATE</literal> ne peut pas être utilisé dans les contextes où
    les lignes renvoyées peuvent pas être clairement identifiées avec des lignes
    uniques d'une table&nbsp;; par exemple, elle ne peut pas être utilisée
    avec des agrégats.
   </para>

   <para>
    <literal>FOR UPDATE</literal> peut apparaître avant
    <literal>LIMIT</literal> pour la compatibilité avec les versions de
    <productname>PostgreSQL</productname> antérieures à la 7.3.  Il s'exécute
    néanmoins après <literal>LIMIT</literal>, et c'est donc l'emplacement
    recommandée pour l'écrire.
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Pour joindre la table <literal>films</literal> avec la table
   <literal>distributeurs</literal>&nbsp;:

<programlisting>
SELECT f.titre, f.did, d.nom, f.date_prod, f.genre
    FROM distributeurs d, films f
    WHERE f.did = d.did

       titre       | did |     nom      | date_prod  |   genre
-------------------+-----+--------------+------------+------------
 The Third Man     | 101 | British Lion | 1949-12-23 | Drame
 The African Queen | 101 | British Lion | 1951-08-11 | Romantique
 ...
</programlisting>
  </para>

  <para>
   Pour additionner la colonne <literal>longueur</literal> de tous les films,
   grouper les résultats par <literal>genre</literal>&nbsp;:

<programlisting>
SELECT genre, sum(longueur) AS total FROM films GROUP BY genre;

   genre    | total
------------+-------
 Action     | 07:34
 Comédie    | 02:58
 Drame      | 14:28
 Musical    | 06:42
 Romantique | 04:38
</programlisting>
  </para>

  <para>
   Pour additionner la colonne <literal>longueur</literal> de tous les films,
   grouper les résultats par <literal>genre</literal> et afficher les groupes
   dont les totaux font moins de cinq heures&nbsp;:
 
<programlisting>
SELECT genre, sum(longueur) AS total
    FROM films
    GROUP BY genre
    HAVING sum(longueur) &lt; interval '5 hours';

   genre    | total
------------+-------
 Comedie    | 02:58
 Romantique | 04:38
</programlisting>
  </para>

  <para>
   Les deux exemples suivants sont des façons identiques de trier les résultats
   individuels suivant le contenu de la deuxième colonne
   (<literal>nom</literal>)&nbsp;:

<programlisting>
SELECT * FROM distributeurs ORDER BY nom;
SELECT * FROM distributeurs ORDER BY 2;

 did |       nom
-----+------------------
 109 | 20th Century Fox
 110 | Bavaria Atelier
 101 | British Lion
 107 | Columbia
 102 | Jean Luc Godard
 113 | Luso films
 104 | Mosfilm
 103 | Paramount
 106 | Toho
 105 | United Artists
 111 | Walt Disney
 112 | Warner Bros.
 108 | Westward
</programlisting>
  </para>

  <para>
   Le prochain exemple montre comment obtenir l'union des tables
   <literal>distributeurs</literal> et <literal>acteurs</literal>, restreignant
   les résultats à ceux commençant avec la lettre W dans chaque table. Seules
   les lignes distinctes sont voulues, du coup le mot clé <literal>ALL</literal>
   est omis.

<programlisting>
distributeurs:               acteurs:
 did |     nom               id |     nom
-----+--------------        ----+----------------
 108 | Westward               1 | Woody Allen
 111 | Walt Disney            2 | Warren Beatty
 112 | Warner Bros.           3 | Walter Matthau
 ...                         ...

SELECT distributeurs.nom
    FROM distributeurs
    WHERE distributeurs.nom LIKE 'W%'
UNION
SELECT actors.nom
    FROM acteurs
    WHERE acteurs.nom LIKE 'W%';

      nom
----------------
 Walt Disney
 Walter Matthau
 Warner Bros.
 Warren Beatty
 Westward
 Woody Allen
</programlisting>
  </para>

  <para>
   Cet exemple montre comment utiliser une fonction dans la clause
   <literal>FROM</>, à la fois avec et sans une liste de définition de
   colonnes&nbsp;:

<programlisting>
CREATE FUNCTION distributeurs(int) RETURNS SETOF distributeurs AS '
    SELECT * FROM distributeurs WHERE did = $1;
' LANGUAGE SQL;

SELECT * FROM distributeurs(111);
 did |    nom
-----+-------------
 111 | Walt Disney

CREATE FUNCTION distributeurs_2(int) RETURNS SETOF record AS '
    SELECT * FROM distributeurs WHERE did = $1;
' LANGUAGE SQL;

SELECT * FROM distributeurs_2(111) AS (f1 int, f2 text);
 f1  |     f2
-----+-------------
 111 | Walt Disney
</programlisting>
  </para>
 </refsect1>
 
 <refsect1>
  <title>Compatibilité</title>

  <para>
   Bien sûr, l'instruction <command>SELECT</command> est compatible avec le
   standard SQL. Mais il y a des extensions et quelques fonctionnalités
   manquantes.
  </para>
  
  <refsect2>
   <title>Clauses <literal>FROM</literal> omises</title>

   <para>
    <productname>PostgreSQL</productname> vous permet d'omettre la clause
    <literal>FROM</literal>. Cela permet par exemple de calculer le
    résultat d'expressions simples&nbsp;:
<programlisting>
SELECT 2+2;

 ?column?
----------
        4
</programlisting>
    D'autre bases de données <acronym>SQL</acronym> ne le permettent pas,
    sauf en introduisant une table d'une seule ligne à partir de laquelle la
    commande <command>SELECT</command> s'exécute.
   </para>

   <para>
    Une utilisation moins évidente est de raccourcir un 
    <command>SELECT</command> normal à partir des tables&nbsp;:
<programlisting>
SELECT distributeurs.* WHERE distributeurs.nom = 'Westward';

 did |   nom
-----+----------
 108 | Westward
</programlisting>
    Ceci fonctionne parce qu'un élément <literal>FROM</literal> implicite est
    ajouté pour chaque table référencée dans d'autres parties de l'instruction
    <command>SELECT</command> mais non mentionnée dans <literal>FROM</literal>.
   </para>

   <para>
    Bien qu'il s'agisse d'un raccourci agréable, sa mauvaise utilisation est
    facile. Par exemple, la commande
<programlisting>
SELECT distributeurs.* FROM distributeurs d;
</programlisting>
    est probablement une erreur&nbsp;; il est probable que l'utilisateur
    souhaitait
<programlisting>
SELECT d.* FROM distributeurs d;
</programlisting>
    plutôt que la jointure sans contrainte
<programlisting>
SELECT distributeurs.* FROM distributeurs d, distributeurs distributeurs;
</programlisting>
    qu'il obtient réellement. Pour aider à la détection de ce type d'erreur,
    <productname>PostgreSQL</productname> avertit de l'utilisation de la
    fonctionnalité du <literal>FROM</literal> implicite dans une instruction
    <command>SELECT</command> qui contient aussi une clause
    <literal>FROM</literal> explicite. De plus, il est possible de désactiver la
    fonctionnalité du <literal>FROM</literal> implicite en initialisant le
    paramètre <varname>ADD_MISSING_FROM</> à false.
   </para>
  </refsect2>

  <refsect2>
   <title>Mot clé <literal>AS</literal></title>

   <para>
    Dans le SQL standard, le mot clé optionnel <literal>AS</> est seulement du
    bruit et peut être omis sans affecter la signification. L'analyseur 
    <productname>PostgreSQL</productname> requiert ce mot clé lors du renommage
    des colonnes en sortie parce que les fonctionnalités d'extension du type
    créent des ambiguïtés en son absence. <literal>AS</literal>
    est néanmoins optionnel pour les éléments <literal>FROM</literal>.
   </para>
  </refsect2>

  <refsect2>
   <title>Espace logique disponible pour <literal>GROUP BY</literal> et
    <literal>ORDER BY</literal></title>

   <para>
    Dans le standard SQL92, une clause <literal>ORDER BY</literal> peut
    seulement utiliser des noms ou des numéros de colonnes alors qu'une clause
    <literal>GROUP BY</literal> peut seulement utiliser des expressions
    basées sur les noms de colonne en entrée.
    <productname>PostgreSQL</productname> étend chacune de ces clauses pour   
    permettre aussi un autre choix (mais il utilise l'interprétation du
    standard s'il y a ambiguïté). <productname>PostgreSQL</productname>
    autorise aussi les deux clauses à spécifier des expressions quelconques.
    Notez que les noms apparaissant dans une expression sont toujours pris en
    tant que noms des colonnes en entrée, et non pas en tant que noms des
    colonnes du résultat.
   </para>

   <para>
    SQL99 utilise une définition légèrement différente qui n'est pas totalement
    compatible avec SQL92. Néanmoins, dans la plupart des cas,
    <productname>PostgreSQL</productname> interpréte une expression
    <literal>ORDER BY</literal> ou <literal>GROUP BY</literal> de la même façon
    que ce que fait SQL99.
   </para>
  </refsect2>

  <refsect2>
   <title>Clauses non standard</title>

   <para>
    Les clauses <literal>DISTINCT ON</literal>,
    <literal>LIMIT</literal> et <literal>OFFSET</literal> ne sont pas définies
    dans le standard SQL.
   </para>
  </refsect2>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
