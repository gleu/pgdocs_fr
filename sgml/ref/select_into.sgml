<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/select_into.sgml,v 1.11 2005/05/26 07:17:14 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-SELECTINTO">
 <refmeta>
  <refentrytitle id="SQL-SELECTINTO-TITLE">SELECT INTO</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>SELECT INTO</refname>
  <refpurpose>définit une nouvelle table à partir des résultats d'une
   requête</refpurpose>
 </refnamediv>

 <indexterm zone="sql-selectinto">
  <primary>SELECT INTO</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
SELECT [ ALL | DISTINCT [ ON ( <replaceable class="PARAMETER">expression</replaceable> [, ...] ) ] ]
    * | <replaceable class="PARAMETER">expression</replaceable> [ AS
<replaceable class="PARAMETER">nom_en_sortie</replaceable> ] [, ...]
    INTO [ TEMPORARY | TEMP ] [ TABLE ] <replaceable
class="PARAMETER">nouvelle_table</replaceable>
    [ FROM <replaceable class="PARAMETER">élément_from</replaceable> [, ...] ]
    [ WHERE <replaceable class="PARAMETER">condition</replaceable> ]
    [ GROUP BY <replaceable class="PARAMETER">expression</replaceable> [, ...] ]
    [ HAVING <replaceable class="PARAMETER">condition</replaceable> [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL ] <replaceable class="PARAMETER">select</replaceable> ]
    [ ORDER BY <replaceable class="PARAMETER">expression</replaceable> [ ASC |
DESC | USING <replaceable class="PARAMETER">opérateur</replaceable> ] [, ...] ]
    [ LIMIT { <replaceable class="PARAMETER">nombre</replaceable> | ALL } ]
    [ OFFSET <replaceable class="PARAMETER">début</replaceable> ]
    [ FOR UPDATE [ OF <replaceable class="PARAMETER">nomtable</replaceable>
[, ...] ] ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>SELECT INTO</command> crée une nouvelle table en la remplissant avec des
   données récupérées par une requête. Les données ne sont pas renvoyées au
   client comme le fait habituellement l'instruction <command>SELECT</command>.
   Les nouvelles colonnes de la table ont les noms et les types de données
   associés avec les colonnes en sortie du <command>SELECT</command>.
  </para>
 </refsect1>
  
 <refsect1>
  <title>Paramètres</title>

  <variablelist>
  <varlistentry>
   <term><literal>TEMPORARY</literal> or <literal>TEMP</literal></term>
   <listitem>
    <para>
     Si spécifié, la table est créée comme une table temporaire. Référez-vous à
     <xref linkend="sql-createtable" endterm="sql-createtable-title"> pour plus
     de détails.
    </para>
   </listitem>
  </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">new_table</replaceable></term>
    <listitem>
     <para>
      Le nom de la table à créer (pouvant être qualifié par le nom du schéma).
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Tous les autres paramètres sont décrits en détail dans <xref
   linkend="sql-select" endterm="sql-select-title">.
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   <xref linkend="sql-createtableas" endterm="sql-createtableas-title">
   est fonctionnellement équivalent à <command>SELECT INTO</command>.
   <command>CREATE TABLE AS</command> est la syntaxe recommandée car cette
   forme de <command>SELECT INTO</command> n'est pas disponible dans
   <application>ECPG</application> ou <application>PL/pgSQL</application>. En
   effet, ils interprètent la clause <literal>INTO</literal> différemment.
   De plus, <command>CREATE TABLE AS</command> offre un ensemble de
   fonctionnalités plus important que celui de <command>SELECT INTO</command>.
  </para>

  <para>
   Avant <productname>PostgreSQL</> 8.0, la table créée par
   <command>SELECT INTO</command> incluait toujours des OID. À partir de
   <productname>PostgreSQL</> 8.0, l'ajout des OID dans la table créée par
   <command>SELECT INTO</command> est contrôlé par la variable de configuration
   <xref linkend="guc-default-with-oids">. Cette variable est à true par défaut
   mais cette valeur pourrait changer dans une prochaine version de
   <productname>PostgreSQL</>.
  </para>
 </refsect1>

 <refsect1>
  <title>Examples</title>

  <para>
   Crée une nouvelle table <literal>films_recent</literal> ne contenant que les
   entrées récentes de la table <literal>films</literal>:

<programlisting>
SELECT * INTO films_recent FROM films WHERE date_prod &gt;= '2002-01-01';
</programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Le standard SQL utilise <command>SELECT INTO</command> pour représenter
   la sélection de valeurs dans des variables scalaires d'un programme hôte
   plutôt que la création d'une nouvelle table. Ceci est en fait l'utilisation
   trouvée dans <application>ECPG</application> (voir <xref linkend="ecpg">) et
   dans <application>PL/pgSQL</application> (voir <xref linkend="plpgsql">).
   L'usage de <productname>PostgreSQL</productname> de <command>SELECT
   INTO</command> pour représenter une création de table est historique. Il est
   préférable d'utiliser <command>CREATE TABLE AS</command> dans un
   nouveau programme.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createtableas"
    endterm="sql-createtableas-title"></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
