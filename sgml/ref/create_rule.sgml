<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_rule.sgml,v 1.8 2005/03/14 06:03:52 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060227 pour la relecture -->

<refentry id="SQL-CREATERULE">
 <refmeta>
  <refentrytitle id="sql-createrule-title">CREATE RULE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE RULE</refname>
  <refpurpose>définit une nouvelle règle de réécriture</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createrule">
  <primary>CREATE RULE</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE [ OR REPLACE ] RULE <replaceable class="parameter">nom</replaceable> AS
ON <replaceable class="parameter">événement</replaceable>
    TO <replaceable class="parameter">table</replaceable> [ WHERE <replaceable class="parameter">condition</replaceable> ]
    DO [ ALSO | INSTEAD ] { NOTHING | <replaceable
class="parameter">commande</replaceable> | ( <replaceable
class="parameter">commande</replaceable> ; <replaceable
class="parameter">commande</replaceable> ... ) }
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>CREATE RULE</command> définit une nouvelle règle sur une
   table ou une vue. <command>CREATE OR REPLACE RULE</command> crée une nouvelle 
   règle ou remplace cette règle sur la table.
  </para>

  <para>
   Le système de règles de <productname>PostgreSQL</productname> autorise la
   définition d'actions alternatives sur les insertions, mises à jour
   ou suppressions dans les tables. 
  </para>
  <para>
   En résumé, une règle impose des commandes supplémentaires lors de l'exécution
   d'une instruction sur une table donnée. 
   De plus, une règle <literal>INSTEAD</literal> permet de remplacer une commande,
   voire d'empêcher sa réalisation.
   Ce sont également les règles qui sont utilisées pour implanter les vues.
  </para>
  <para>
   Une règle est un mécanisme de transformation de commandes, une
   &laquo;&nbsp;macro&nbsp;&raquo;. La transformation
   intervient avant l'exécution de la commande.
   Pour obtenir une opération qui s'exécute indépendamment
   pour chaque ligne physique, il faut utiliser des déclencheurs.
   On trouvera plus d'informations sur le système des règles dans <xref
   linkend="rules">.
  </para>
  
  <para>
   À l'heure actuelle, les règles <literal>ON SELECT</literal> doivent être des règles
   <literal>INSTEAD</literal> inconditionnelles. Chacune de leurs actions ne peut être constituée
   que d'une simple commande <command>SELECT</command>.
   Ainsi, une règle <literal>ON SELECT</literal> a pour résultat la transformation
   effective d'une table en une vue dont le contenu visible est composé
   des lignes retournées par la commande <command>SELECT</command> de la règle&nbsp;;
   ce ne sont pas les lignes stockées dans la table (s'il y en a) qui sont retournées.
   Le création d'une vue à l'aide de la commande
   <command>CREATE VIEW</command> est toujours préférable à la création d'une table réelle
   sur laquelle on définirait une règle <literal>ON SELECT</literal>.
  </para>

  <para>
   On peut donner l'illusion d'une vue modifiable
   (&laquo;&nbsp;updatable view&nbsp;&raquo;)
   par la définition de règles <literal>ON INSERT</literal>, <literal>ON
   UPDATE</literal> et <literal>ON DELETE</literal> (ou tout sous-ensemble de
   celles-ci) pour remplacer les actions de mises à jour
   de la vue par des mises à jours des tables adéquates.
  </para>

  <para>
   Il y a quelque chausse-trappe lors de l'utilisation de 
   règles conditionnelles pour la mise à jour de vues&nbsp;:
   à chaque action autorisée sur la vue <emphasis>doit</> 
   correspondre une règle <literal>INSTEAD</literal> inconditionnelle.
   Si la règle est conditionnelle ou n'est pas une règle <literal>INSTEAD</literal>,
   alors le système rejettera toute tentative de mise à jour, pour éviter le 
   risque d'avoir à exécuter l'action sur la table virtuelle de la vue.
   <!-- ICI -->
   pour chaque action que vous
   souhaitez autoriser sur la vue. Si la règle est conditionnelle ou si elle
   n'est pas <literal>INSTEAD</literal>, alors le système rejettera toutes
   tentatives d'exécution de l'action de mise à jour parce qu'il pense qu'il
   pourrait finir par essayer de réaliser l'action sur la table de la vue dans
   certains cas. Si vous souhaitez gérer tous les cas utiles dans les règles
   conditionnelles, ajoutez une règle <literal>DO
   INSTEAD NOTHING</literal> sans condition pour vous assurer que le système 
   comprend qu'il ne sera jamais appelé pour modifier la table. Puis, rendez les
   règles conditionnelles en non <literal>INSTEAD</literal>&nbsp;; dans les cas
   où cela s'applique, elles ajoutent à l'action <literal>INSTEAD
   NOTHING</literal> par défaut.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
      Le nom d'une règle à créer. Elle doit être distincte du nom de toute autre
      règle sur la même table. Les règles multiples sur la même table et le même
      type d'événement sont appliquées dans l'ordre alphabétique des noms.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">événement</replaceable></term>
    <listitem>
     <para>
      L'événement est un de ceux-ci&nbsp;: <literal>SELECT</literal>,
      <literal>INSERT</literal>, <literal>UPDATE</literal> ou
      <literal>DELETE</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">table</replaceable></term>
    <listitem>
     <para>
      Le nom (pouvant être qualifié par le nom du schéma) de la table ou de la
      vue où s'applique la règle.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">condition</replaceable></term>
    <listitem>
     <para>
      Toute expression <acronym>SQL</acronym> conditionnelle (renvoyant le type
      <type>boolean</type>). L'expression de condition ne peut pas
      référer à une table autre que <literal>NEW</literal> et
      <literal>OLD</literal> et ne peut pas contenir de fonction d'agrégat.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><option>INSTEAD</option></term>
    <listitem>
     <para>
      <literal>INSTEAD</literal> indique que les commandes devraient être
      exécutées <emphasis>à la place de</> la commande originale.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><option>ALSO</option></term>
    <listitem>
     <para>
      <literal>ALSO</literal> indique que les commandes devraient être exécutées
      <emphasis>en plus de</emphasis> la commande originale.
     </para>

     <para>
      Si ni <literal>ALSO</literal> ni <literal>INSTEAD</literal> ne sont
      spécifiés, <literal>ALSO</literal> est la valeur par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">commande</replaceable></term>
    <listitem>
     <para>
      La où les commandes réalisant l'action de la règle. Les commandes valides
      sont <command>SELECT</command>, <command>INSERT</command>,
      <command>UPDATE</command>, <command>DELETE</command> ou
      <command>NOTIFY</command>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   À l'intérieur d'une <replaceable class="parameter">condition</replaceable>
   et d'une  <replaceable class="parameter">commande</replaceable>, les noms de
   tables spéciales <literal>NEW</literal> et <literal>OLD</literal> pourraient
   être utilisés pour se référer aux valeurs de la table référencée.
   <literal>NEW</literal> est valide dans les règles <literal>ON
   INSERT</literal> et <literal>ON UPDATE</literal> pour référencer la nouvelle
   ligne en cours d'insertion ou de mise à jour. <literal>OLD</literal> est
   valide dans les règles <literal>ON UPDATE</literal> et <literal>ON
   DELETE</literal> pour référencer la ligne existante en cours de modification
   ou de suppression.
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   Vous devez avoir le droit <literal>RULE</literal> sur une table pour être
   autorisé à définir une règle sur elle.
  </para>

  <para>
   Il est très important de faire attention aux règles circulaires. Par
   exemple, bien que chacune des deux définitions de règles est acceptée par
   <productname>PostgreSQL</productname>, la commande <command>SELECT</command>
   fera que <productname>PostgreSQL</productname> rapportera une erreur parce
   que la requête sera en boucle trop longtemps&nbsp;:

<programlisting>
CREATE RULE "_RETURN" AS
    ON SELECT TO t1
    DO INSTEAD 
	SELECT * FROM t2;

CREATE RULE "_RETURN" AS
    ON SELECT TO t2
    DO INSTEAD 
	SELECT * FROM t1;

SELECT * FROM t1;
</programlisting>
  </para>

  <para>
   Actuellement, si l'action d'une règle contient une commande
   <command>NOTIFY</command>, cette commande sera exécutée sans condition,
   c'est-à-dire que le <command>NOTIFY</command> sera envoyé même si aucune
   lignes de la règle ne s'applique. Par exemple, dans
<programlisting>
CREATE RULE notify_me AS ON UPDATE TO matable DO ALSO NOTIFY matable;

UPDATE matable SET name = 'foo' WHERE id = 42;
</programlisting>
   un événement <command>NOTIFY</command> sera lancé durant un
   <command>UPDATE</command>, qu'il y ait ou non des lignes satisfaisant la
   condition <literal>id = 42</literal>. L'implémentation de cette restriction
   pourrait être corrigée dans les prochaines versions.
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   <command>CREATE RULE</command> est une extension du langage de
   <productname>PostgreSQL</productname> ainsi que tout le système de
   réécriture de requêtes.
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
