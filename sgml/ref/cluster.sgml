<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/cluster.sgml,v 1.8 2005/02/17 09:11:55 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-CLUSTER">
 <refmeta>
  <refentrytitle id="sql-cluster-title">CLUSTER</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CLUSTER</refname>
  <refpurpose>Réorganise une table suivant un index</refpurpose>
 </refnamediv>

 <indexterm zone="sql-cluster">
  <primary>CLUSTER</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CLUSTER <replaceable class="PARAMETER">nomindex</replaceable> ON <replaceable
class="PARAMETER">nomtable</replaceable>
CLUSTER <replaceable class="PARAMETER">nomtable</replaceable>
CLUSTER
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>CLUSTER</command> demande à <productname>PostgreSQL</productname>
   de réorganiser (regrouper) la table spécifiée par <replaceable
   class="parameter">nomtable</replaceable> en se basant sur l'index spécifié
   par <replaceable class="parameter">nomindex</replaceable>. L'index doit déjà
   avoir été défini sur <replaceable class="parameter">nomtable</replaceable>.
  </para>

  <para>
   Quand une table est réorganisée, elle est physiquement réordonnée en se basant
   sur les informations de l'index. Ce groupement est une opération unique&nbsp;:
   quand une table est mise à jour après coup, les modifications ne
   tiennent pas compte de la réorganisation. C'est-à-dire qu'aucune tentative n'est
   réalisée pour stocker les nouvelles données ou les données mises à jour
   suivant l'ordre de l'index. Si vous le souhaitez, vous pouvez grouper
   périodiquement en lançant de nouveau la commande.
  </para>

  <para>
   Quand une table est groupée, <productname>PostgreSQL</productname> se
   rappelle de l'index avec lequel elle a été réorganisée. La forme
   <command>CLUSTER <replaceable
   class="parameter">nomtable</replaceable></command> groupe de nouveau la
   table avec le même index qu'auparavant.
  </para>

  <para>
   <command>CLUSTER</command> sans aucun paramètre groupe toutes les
   tables de la base de données courante et dont l'utilisateur est
   propriétaire, ou toutes les tables s'il s'agit d'un superutilisateur. (Les
   tables qui n'ont jamais été groupées sont ignorées.) Cette forme de
   <command>CLUSTER</command> ne peut pas être appelée à partir d'une
   transaction ou d'une fonction.
  </para>

  <para>
   Quand une table est en cours de groupement, un verrou <literal>ACCESS
   EXCLUSIVE</literal> est acquis. Ceci empêche toute opération
   sur la table (à la fois en lecture et en écriture) tant que la commande
   <command>CLUSTER</command> n'est pas terminée.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="PARAMETER">nomindex</replaceable></term>
    <listitem>
     <para>
      Le nom d'un index.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">nomtable</replaceable></term>
    <listitem>
     <para>
      Le nom d'une table (pouvant être qualifié du nom du schéma).
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

   <para>
    Dans les cas où vous accédez aux lignes d'une table de façon aléatoire,
    et une par une, l'ordre réel des données dans la table n'est pas
    important. Néanmoins, si vous avez tendance à accéder à certaines données
    plus qu'à d'autres et qu'il existe un index qui les groupe ensemble, vous
    bénéficierez de l'utilisation de <command>CLUSTER</command>. Si vous
    demandez un ensemble de valeurs indexées à partir d'une table, ou une seule
    valeur indexée correspondant à plusieurs lignes, <command>CLUSTER</command>
    vous aidera car une fois que l'index a identifié la page principale pour la
    première ligne correspondante, toutes les autres lignes correspondantes
    sont déjà probablement sur la même page et vous économisez du coup des accès
    disque et accélérez ainsi la requête.
   </para>

   <para>
    Lors de l'opération de réorganisation, une copie temporaire de la table 
    est créée
    pour contenir les données de la table dans l'ordre de l'index. Des copies
    temporaires de chaque index de la table sont aussi créées. Du coup, vous
    avez besoin d'un espace libre sur le disque au moins égal à la somme de la
    taille de la table et des tailles des index.
   </para>

   <para>
    Comme <command>CLUSTER</command> se rappelle des informations de
    réorganisation, vous pouvez réorganiser les tables que vous voulez la
    première fois manuellement et planifier régulièrement une réorganisation
    de la même façon que vous faites un <command>VACUUM</command> de façon 
    à ce que les tables soient périodiquement groupées de nouveau.
   </para>

   <para>
    Comme le planificateur enregistre les statistiques des enregistrements
    suivant l'ordre des tables, il est conseillé de lancer
    <command>ANALYZE</command> sur la table réorganisée. Sinon, le
    planificateur pourrait faire de mauvais choix pour les plans de requêtes.
   </para>

   <para>
    Il existe une autre façon de grouper les données. La commande
    <command>CLUSTER</command> réordonne la table originale en utilisant
    l'ordre de l'index que vous spécifiez. Ceci peut être lent sur les grandes
    tables parce que les lignes sont récupérées dans
    l'ordre de l'index et que si la table n'est pas ordonnée, les entrées sont
    dans des pages aléatoires, donc il y a une page disque lue pour chaque
    ligne déplacée. (<productname>PostgreSQL</productname> a un cache mais la
    totalité d'une grande table ne tiendra pas dans le cache.) L'autre moyen de
    réorganiser une table est d'utiliser

<programlisting>
CREATE TABLE <replaceable class="parameter">nouvelletable</replaceable> AS
    SELECT <replaceable class="parameter">listecolonnes</replaceable> FROM
<replaceable class="parameter">table</replaceable> ORDER BY <replaceable
class="parameter">listecolonnes</replaceable>;
</programlisting>

    qui utilise le code de tri de <productname>PostgreSQL</productname> dans la
    clause <literal>ORDER BY</literal> pour créer l'ordre désiré&nbsp;; ceci est
    généralement bien plus rapide qu'un parcours d'index pour des données non 
    triées. Vous pouvez alors supprimer l'ancienne table, utiliser <command>ALTER
    TABLE ... RENAME</command> pour renommer <replaceable
    class="parameter">nouvelletable</replaceable> par l'ancien nom et recréer
    les index de la table. Néanmoins, cette approche ne préserve pas les OID,
    les contraintes, les relations de clés étrangères, les droits donnés et
    d'autres propriétés de la table --- tous ces éléments devront être recréés
    manuellement.
   </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Grouper la table <literal>employes</literal> sur la base de son index
   <literal>emp_ind</literal>&nbsp;:
<programlisting>
CLUSTER emp_ind ON emp;
</programlisting>
  </para>

  <para>
   Grouper la relation <literal>employes</literal> en utilisant le même index
   qu'auparavant&nbsp;:
<programlisting>
CLUSTER emp;
</programlisting>
  </para>

  <para>
   Grouper toutes les tables de la base de données qui ont déjà été
   groupées&nbsp;:
<programlisting>
CLUSTER;
</programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Il n'existe pas d'instruction <command>CLUSTER</command> dans le standard
   SQL.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="app-clusterdb" endterm="app-clusterdb-title"></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->

