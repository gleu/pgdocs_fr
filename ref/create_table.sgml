<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_table.sgml,v 1.11 2005/09/15 07:03:26 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060327 : Relecture -->

<refentry id="SQL-CREATETABLE">
 <refmeta>
  <refentrytitle id="sql-createtable-title">CREATE TABLE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TABLE</refname>
  <refpurpose>définit une nouvelle table</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createtable">
  <primary>CREATE TABLE</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } ] TABLE <replaceable class="PARAMETER">nom_table</replaceable> ( [
  { <replaceable class="PARAMETER">nom_colonne</replaceable> <replaceable class="PARAMETER">type_donnees</replaceable> [ DEFAULT <replaceable>default_expr</replaceable> ] [ <replaceable class="PARAMETER">contrainte_colonne</replaceable> [ ... ] ]
    | <replaceable>contrainte_table</replaceable>
    | LIKE <replaceable>table_parent</replaceable> [ { INCLUDING | EXCLUDING } DEFAULTS ] }
    [, ... ]
] )
[ INHERITS ( <replaceable>table_parent</replaceable> [, ... ] ) ]
[ WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="PARAMETER">espace_logique</replaceable> ]

où <replaceable class="PARAMETER">contrainte_colonne</replaceable>
est&nbsp;:

[ CONSTRAINT <replaceable class="PARAMETER">nom_contrainte</replaceable> ]
{ NOT NULL | NULL | UNIQUE [ USING INDEX TABLESPACE <replaceable class="PARAMETER">espacelogique</replaceable> ] |
PRIMARY KEY [ USING INDEX TABLESPACE <replaceable class="PARAMETER">espacelogique</replaceable> ] |
  CHECK (<replaceable class="PARAMETER">expression</replaceable>) |
  REFERENCES <replaceable class="PARAMETER">table_reference</replaceable> [ ( <replaceable class="PARAMETER">colonne_reference</replaceable> ) ] [ MATCH FULL
| MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

et <replaceable class="PARAMETER">contrainte_table</replaceable> est&nbsp;:

[ CONSTRAINT <replaceable class="PARAMETER">nom_contrainte</replaceable> ]
{ UNIQUE ( <replaceable class="PARAMETER">nom_colonne</replaceable> [, ... ] ) [ USING INDEX TABLESPACE <replaceable class="PARAMETER">espacelogique</replaceable> ] |
  PRIMARY KEY ( <replaceable class="PARAMETER">nom_colonne</replaceable> [, ...
  ] ) [ USING INDEX TABLESPACE <replaceable class="PARAMETER">espacelogique</replaceable> ] |
  CHECK ( <replaceable class="PARAMETER">expression</replaceable> ) |
  FOREIGN KEY ( <replaceable class="PARAMETER">nom_colonne</replaceable> [, ...
] ) REFERENCES <replaceable class="PARAMETER">table_reference</replaceable> [ (
<replaceable class="PARAMETER">colonne_reference</replaceable> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
</synopsis>
  
 </refsynopsisdiv>

 <refsect1 id="SQL-CREATETABLE-description">
  <title>Description</title>

  <para>
   <command>CREATE TABLE</command> crée une nouvelle table initialement vide
   dans la base de données courante. La table appartient à 
   l'utilisateur qui exécute cette commande.
  </para>

  <para>
   Si un nom de schéma est donné (par exemple, <literal>CREATE TABLE
   monschema.matable ...</literal>), alors la table est créée dans le schéma spécifié.
   Dans le cas contraire, il est créé dans le schéma courant. Les tables temporaires existent
   dans un schéma spécial, il n'est donc pas nécessaire de fournir un nom de schéma 
   lors de la création d'une table temporaire. Le nom de la table doit être distinct
   des noms des autres tables, séquences, index ou vues dans le même schéma.
  </para>

  <para>
   <command>CREATE TABLE</command> crée aussi automatiquement un type de 
   données qui représente le type composé correspondant à une ligne de la
   table. Ainsi, les tables doivent avoir un nom distinct de tout type de
   données du même schéma.
  </para>

  <para>
   Les clauses de contrainte optionnelles spécifient les contraintes (ou 
   tests) que les nouvelles lignes ou les lignes mises à jour doivent satisfaire
   pour qu'une opération d'insertion ou de mise à jour réussisse. Une contrainte
   est un objet SQL qui aide à définir l'ensemble des valeurs valides de
   plusieurs façons.
  </para>

  <para>
   Il existe deux façons de définir des contraintes&nbsp;: celles
   de table et celles de colonnes. Une contrainte de colonne fait partie
   de la définition de la colonne. Une définition de contrainte
   de tables n'est pas liée à une colonne particulière et peut englober plusieurs
   colonnes. Chaque contrainte de colonne peut être écrite comme une
   contrainte de table&nbsp;; une contrainte de colonne n'est qu'un outil
   de notation utilisé lorsque la contrainte n'affecte qu'une colonne.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>

   <varlistentry>
    <term><literal>TEMPORARY</literal> ou <literal>TEMP</literal></term>
    <listitem>
     <para>
      Si spécifié, la table est créée comme une table temporaire. Les tables
      temporaires sont automatiquement supprimées à la fin d'une session ou,
      optionnellement, à la fin de la transaction en cours (voir <command>ON COMMIT</command>
      ci-dessous). Les tables permanentes qui portent le même nom ne sont
      pas visibles dans la session courante tant que la table temporaire existe
      sauf s'il y est fait référence par leur nom qualifié du schéma. Tous les
      index créés sur une table temporaire sont automatiquement
      temporaires.
     </para>

     <para>
      On peut éventuellement écrire <literal>GLOBAL</literal> ou <literal>LOCAL</literal>
      avant <literal>TEMPORARY</literal> ou <literal>TEMP</literal>. Cela
      ne fait pas de différence dans <productname>PostgreSQL</productname>, mais voir <xref
      linkend="sql-createtable-compatibility"
      endterm="sql-createtable-compatibility-title">.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">nom_table</replaceable></term>
    <listitem>
     <para>
      Le nom (éventuellement qualifié du nom du schéma) de la table à créer.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">nom_colonne</replaceable></term>
    <listitem>
     <para>
      Le nom d'une colonne à créer dans la nouvelle table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">type_données</replaceable></term>
    <listitem>
     <para>
      Le type de données de la colonne. Cela peutt inclure des
      spécificateurs de tableaux. Pour plus d'informations sur les types de
      données supportés par <productname>PostgreSQL</productname>, on se référera 
      à <xref linkend="datatype">.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT
    <replaceable>default_expr</replaceable></literal></term>
    <listitem>
     <para>
      La clause <literal>DEFAULT</literal>, apparaissant dans la définition
      d'une colonne, permet de lui affecter une valeur par défaut. La valeur est une
      expression libre de variable (les sous-requêtes et références croisées aux
      autres colonnes de la table courante ne sont pas autorisées). Le type de
      données de l'expression par défaut doit correspondre au type de données de
      la colonne.
     </para>

     <para>
      L'expression par défaut sera utilisée dans les opérations d'insertion 
      qui ne spécifient pas de valeur pour la colonne. S'il n'y a pas de valeur
      par défaut pour une colonne, elle est NULL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INHERITS ( <replaceable>table_parent</replaceable> [, ... ])</literal></term>
    <listitem>
     <para>
      La clause optionnelle <literal>INHERITS</literal> spécifie une liste de tables
      dont les colonnes sont automatiquement héritées par la nouvelle table.
     </para>

     <para>
      L'utilisation d'<literal>INHERITS</literal> crée une relation persistante entre
      la nouvelle table enfant et sa table parent. Les modifications de schéma
      du(des) parent(s) se propagent normalement aux enfants et, par défaut,
      les données de la table enfant sont incluses dans les parcours de(s)
      parent(s).
     </para>

     <para>
      Si un même nom de colonne existe dans plusieurs tables parentes,
      une erreur est rapportée, à moins que les types de données des colonnes
      ne correspondent dans toutes les tables parentes. S'il n'y a pas de conflit,
      alors les colonnes dupliquées sont assemblées pour former une seule
      colonne dans la nouvelle table. Si la liste des noms de colonnes de la
      nouvelle table contient un nom de colonne hérité, le type
      de données doit correspondre à celui des colonnes héritées et les définitions des
      colonnes sont fusionnées. Néanmoins, les déclarations des
      colonnes héritées et des nouvelles de même nom n'ont pas l'obligation de spécifier
      des contraintes identiques&nbsp;: toutes les contraintes sont assemblées et appliquées à la nouvelle
      table. Si la nouvelle table spécifie explicitement une valeur par défaut
      pour la colonne, cette valeur surcharge toute valeur par défaut héritée.
      Dans le cas contraire, les parents qui spécifient une valeur par défaut doivent
      tous spécifier la même, sans quoi une erreur est rapportée.
     </para>
<!--
     <para>
      <productname>PostgreSQL</productname> automatically allows the
     created table to inherit
      functions on tables above it in the inheritance hierarchy; that
      is, if we create table <literal>foo</literal> inheriting from
      <literal>bar</literal>, then functions that accept the tuple
      type <literal>bar</literal> can also be applied to instances of
      <literal>foo</literal>.  (Currently, this works reliably for
      functions on the first or only parent table, but not so well for
      functions on additional parents.)
     </para>
-->
    </listitem>
   </varlistentry>

   <varlistentry>
     <term><literal>LIKE <replaceable>table_parent</replaceable> [ { INCLUDING | EXCLUDING } DEFAULTS ]</literal></term>
     <listitem>
       <para>
         La clause <literal>LIKE</literal> spécifie une table à partir de laquelle
         la nouvelle table copie automatiquement tous les noms de colonnes, leur
         types de données et les contraintes non NULL.
       </para>
       <para>
         Contrairement à <literal>INHERITS</literal>, la nouvelle table et la
         table oroginale sont complètement découplées à la fin de la création.
         Les modifications sur la table originale ne sont pas appliquées à la
	 nouvelle table et less données de la
	 nouvelle table sont pas prises en compte lors du parcours de l'ancienne table.
       </para>
       <para>
         Les expressions par défaut des définitions de colonnes
         ne seront copiées que si <literal>INCLUDING DEFAULTS</literal> est
         spécifié. Le comportement par défaut les exclut, ce qui conduit à
	 des valeurs par défaut NULL pour toutes les colonnes de la nouvelle table.
       </para>
     </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH OIDS</literal></term>
    <term><literal>WITHOUT OIDS</literal></term>
    <listitem>
     <para>
      Cette clause optionnelle spécifie si les lignes de la nouvelle table
      se voient affecter des OID (identifiants d'objets).
      Si ni <literal>WITH OIDS</literal> ni <literal>WITHOUT OIDS</literal>
      ne sont spécifiés, la valeur par défaut dépend du
      paramètre de configuration <xref linkend="guc-default-with-oids">. Si
      la nouvelle table hérite d'autres tables possédant des OID, alors
      <literal>WITH OIDS</literal> est imposé même si la
      commande indique <literal>WITHOUT OIDS</literal>.
     </para>

     <para>
      Si <literal>WITHOUT OIDS</literal> est spécifié (même implicitemnt), la nouvelle
      table ne stocke pas les OID et aucun OID ne sera affecté à une ligne
      qui y est insérée. C'est généralement intéressant pour les grosses tables
      car cela réduit la consommation d'OID. De ce fait, il n'y a pas, pour cette 
      table de risque de collision (NDT&nbsp;: wraparound, en VO) du compteur d'OID, compteur sur 32 bits.
      Lorsque le compteur revient à zéro, l'unicité des
      OID ne peut plus être garantie, ce qui en réduit considérablement l'utilité. 
      De plus, exclure les OID d'une table réduit l'espace
      requis pour stocker la table sur disque de quatre octets par ligne de 
      table (sur la plupart des machines), améliorant ainsi leur performance.
     </para>

     <para>
      Pour supprimer les OID d'une table après sa création, on utilise
      <xref linkend="sql-altertable" endterm="sql-altertable-title">.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CONSTRAINT <replaceable
class="PARAMETER">nom_contrainte</replaceable></literal></term>
    <listitem>
     <para>
      Le nom optionnel d'une contrainte de colonne ou de table. S'il n'est
      pas spécifié, le système engendre un nom.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NOT NULL</literal></term>
    <listitem>
     <para>
      Interdiction des valeurs NULL dans la colonne.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NULL</literal></term>
    <listitem>
     <para>
      Les valeurs NULL sont autorisées pour la colonne. Valeur par défaut.
     </para>

     <para>
      Cette clause n'est fournie que pour des raisons de compatibilité avec les
      bases de données SQL non standard. Son utilisation n'est pas encouragée
      dans les nouvelles applications.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>UNIQUE</literal> (contrainte_colonne)</term>
    <term><literal>UNIQUE ( <replaceable class="PARAMETER">nom_colonne</replaceable> [, ... ] )</literal> (contrainte table)</term>

    <listitem>
     <para>
      La contrainte <literal>UNIQUE</literal> spécifie qu'un groupe de
      colonnes d'une table ne peut contenir que des valeurs
      uniques. Le comportement de la contrainte de table est le même que
      celui des contraintes de colonnes avec la possibilité supplémentaire de
      grouper des colonnes.
     </para>

     <para>
      Les valeurs NULL ne sont pas considérées égales dans le cas d'une contrainte d'unicité.
     </para>

     <para>
      Toute contrainte d'unicité sur la table doit nommer un ensemble de colonnes 
      différent de celui utilisé par quelque autre
      contrainte d'unicité ou de clé primaire sur la table. Dans le cas contraire, cela
      revient à définir deux fois la même contrainte.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>PRIMARY KEY</literal> (contrainte colonne)</term>
    <term><literal>PRIMARY KEY ( <replaceable class="PARAMETER">nom_colonne</replaceable> [, ... ] )</literal> (contrainte table)</term>
    <listitem>
     <para>
      Une contrainte de clé primaire est utiliser pour spécifier des colonnes
      qui ne peuvent contenir que des valeurs uniques, non NULL. Techniquement,
      <literal>PRIMARY KEY</literal> n'est qu'une combinaison de <literal>UNIQUE</literal>
      et <literal>NOT NULL</literal>. Toutefois, identifier un ensemble de colonnes 
      comme clé primaire fournit des informations sur les schémas. En effet, une
      clé primaire implique que d'autres tables puissent utiliser cet ensemble de colonnes
      comme identifiant unique de ligne.
     </para>

     <para>
      Seule une clé primaire peut être spécifiée par table, qu'il s'agisse
      d'une contrainte de colonne ou de table.
     </para>

     <para>
      La contrainte de clé primaire doit nommer un ensemble de colonnes
      différent de tout autre ensemble de colonnes utilisé par une contrainte
      d'unicité sur la table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CHECK (<replaceable class="PARAMETER">expression</replaceable>)</literal></term>
    <listitem>
     <para>
      La clause <literal>CHECK</literal> spécifie une expression de
      résultat booléen que les nouvelles lignes ou celles mises à jour
      doivent satisfaire pour qu'une opération d'insertion ou de mise à jour
      réussisse. Les expressions de résultat TRUE ou UNKNOWN réussissent. 
      Si une des lignes de l'opération d'insertion ou de mise à jour produit un résultat
      FALSE, une exception est levée et la base de données n'est pas modifiée. 
      Une contrainte de vérification sur une colonne ne fait référence qu'à la valeur de la colonne
      tandis qu'une contrainte sur la table fait référence à plusieurs colonnes.
     </para>

     <para>
      Actuellement, les expressions <literal>CHECK</literal> ne peuvent ni
      contenir des sous-requêtes ni faire référence à des variables autres que les
      colonnes de la ligne courante.
     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term><literal>REFERENCES <replaceable class="parameter">table_reference</replaceable> [ ( <replaceable class="parameter">colonne_reference</replaceable> ) ] 
     [ MATCH <replaceable class="parameter">matchtype</replaceable> ]
     [ ON DELETE <replaceable class="parameter">action</replaceable> ]
     [ ON UPDATE <replaceable class="parameter">action</replaceable> ]</literal> (contrainte de colonne)</term>

   <term><literal>FOREIGN KEY ( <replaceable
class="parameter">colonne</replaceable> [, ... ] )
    REFERENCES <replaceable class="parameter">table_reference</replaceable> [ (
<replaceable class="parameter">colonne_reference</replaceable> [, ... ] ) ] 
    [ MATCH <replaceable class="parameter">matchtype</replaceable> ]
    [ ON DELETE <replaceable class="parameter">action</replaceable> ] 
    [ ON UPDATE <replaceable class="parameter">action</replaceable> ]</literal>
    (contrainte de colonne)</term>

    <listitem>
     <para>
      Ces clauses spécifient une contrainte de clé étrangère. Cela signifie
      qu'un groupe de colonnes de la nouvelle table ne peut contenir que 
      des valeurs correspondant à celles des colonnes de référence de la table
      de référence. Si
      <replaceable class="parameter">colonne_reference</replaceable> est omis,
      la clé primaire de la <replaceable class="parameter">table_reference</replaceable>
      est utilisée. Les colonnes
      référencées doivent être celles d'une contrainte d'unicité ou de clé
      primaire dans la table référencée. Les contraintes de type clé
      étrangère ne peuvent pas être définies entre des tables temporaires et des
      tables permanentes.
     </para>

     <para>
      Une valeur insérée dans les colonnes de la nouvelle table est comparée aux valeurs
      des colonnes de référence dans la table de référence à l'aide du type de concordance
      fourni. Il existe trois types de correspondance&nbsp;:
      <literal>MATCH FULL</literal> (NDT&nbsp;: concordance totale),
      <literal>MATCH PARTIAL</literal> (NDT&nbsp;: concordance partielle) et
      <literal>MATCH SIMPLE</literal> (NDT&nbsp;: concordance simple), qui est aussi la valeur par défaut.
      <literal>MATCH FULL</literal> n'autorise une colonne d'une clé étrangère composite à être NULL
      que si l'ensemble des colonnes de la clé étrangère sont NULL.
      <literal>MATCH SIMPLE</literal> autorise une colonne de clé étrangère
      à être NULL même si les autres parties de la clé étrangère ne sont pas nulles.
      <literal>MATCH PARTIAL</literal> n'est pas encore implanté.
     </para>

     <para>
      Lorsque les données des colonnes référencées sont modifiées,
      des actions sont réalisées sur les données de la table référençant.
      La clause <literal>ON DELETE</literal> spécifie l'action à
      réaliser lorsqu'une ligne référencée de la table de référence est supprimée.
      De la même façon, la clause <literal>ON UPDATE</literal>
      spécifie l'action à réaliser lorsqu'une colonne référencée est mise à jour.
      Si la ligne est mise à jour sans que la valeur de la colonne référencée ne soit
      modifiée, aucune action n'est réalisée. Les actions référentielles autres
      que la vérification <literal>NO ACTION</literal> ne peuvent
      pas être déferrées même si la contrainte est déclarée déferrable.
      Les actions suivantes sont possibles pour chaque clause&nbsp;:

      <variablelist>
       <varlistentry>
        <term><literal>NO ACTION</literal></term>
        <listitem>
         <para>
	  Une erreur est produite pour indiquer que la suppression ou la mise à jour 
	  entraîne une violation de la contrainte de clé étrangère. Si la
	  contrainte est déferrée, cette erreur est produite au moment
	  de la vérification, si toutefois il existe encore des lignes
	  de référence. C'est le comportement par défaut.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>RESTRICT</literal></term>
        <listitem>
         <para>
	  Une erreur est produite pour indiquer que la suppression ou la mise à jour
	  entraîne une violation de la contrainte de clé étrangère. Ce comportement
	  est identique à <literal>NO ACTION</literal>, si ce n'est que la vérification
	  n'est pas déferrable.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>CASCADE</literal></term>
        <listitem>
         <para>
	  La mise à jour ou la suppression de la ligne de référence est propagée
	  à l'ensemble des lignes qui la référencent, qui sont, respectivement,
	  mises à jour ou supprimées.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET NULL</literal></term>
        <listitem>
         <para>
          La valeur de la colonne qui référence est positionnée à NULL.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET DEFAULT</literal></term>
        <listitem>
         <para>
	  La valeur de la colonne qui référence est positionnée à 
	  celle par défaut.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>

     <para>
      Si les colonnes référencées sont modifiées fréquemment, il est 
      conseillé d'ajouter un index sur la colonne de clé étrangère de façon à
      améliorer la réalisation des actions référentielles associées à la colonne de clé étrangère.
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
    <term><literal>DEFERRABLE</literal></term>
    <term><literal>NOT DEFERRABLE</literal></term>
    <listitem>
     <para>
      Ces clauses contrôlent la diferrabilité de la contrainte. Une contrainte qui
      n'est pas déferrable est vérifiée immédiatement après chaque commande. La
      vérification des contraintes déferrables est repoussée à la
      fin de la transaction (à l'aide de la commande
      <xref linkend="sql-set-constraints" endterm="sql-set-constraints-title">).
      <literal>NOT DEFERRABLE</literal> est la valeur par défaut. Seules les
      contraintes de clé étrangère acceptent cette clause. Les
      autres types de contraintes ne sont pas déferrables.
     </para>
    </listitem>
   </varlistentry>

<!-- ICI -->
   <varlistentry>
    <term><literal>INITIALLY IMMEDIATE</literal></term>
    <term><literal>INITIALLY DEFERRED</literal></term>
    <listitem>
     <para>
      Si une contrainte est déferrable, cette clause spécifie le temps par
      défaut pour vérifier la contrainte. Si la contrainte est
      <literal>INITIALLY IMMEDIATE</literal>, elle est vérifiée après chaque
      instruction. Si la contrainte est <literal>INITIALLY DEFERRED</literal>,
      elle est vérifiée seulement à la fin de la transaction. Le moment de
      vérification de la contrainte peut être modifié avec la commande <xref
      linkend="sql-set-constraints" endterm="sql-set-constraints-title">.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ON COMMIT</literal></term>
    <listitem>
     <para>
      Le comportement des tables temporaires à la fin d'un bloc de transaction
      peut se contrôler en utilisant <literal>ON COMMIT</literal>. Les trois
      options sont&nbsp;

      <variablelist>
       <varlistentry>
        <term><literal>PRESERVE ROWS</literal></term>
        <listitem>
         <para>
	  Aucune action n'est prise à la fin des transactions. Ceci est le
	  comportement par défaut.
         </para>
     	</listitem>
       </varlistentry>
           
       <varlistentry>
        <term><literal>DELETE ROWS</literal></term>
        <listitem>
         <para>
          Toutes les lignes dans la table temporaire seront détruites à la
	  fin de chaque bloc de transaction. En fait, un <xref
	  linkend="sql-truncate"> automatique est réalisé à chaque validation.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DROP</literal></term>
        <listitem>
         <para>
          La table temporaire sera supprimée à la fin du bloc de transaction.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
     <term><literal>TABLESPACE <replaceable class="PARAMETER">espacelogique</replaceable></literal></term>
     <listitem>
       <para>
         L'<replaceable class="PARAMETER">espacelogique</replaceable> est le
	 nom de l'espace logique dans lequel est créée la nouvelle table. Si
	 elle n'est pas spécifiée, <xref linkend="guc-default-tablespace"> est
	 utilisée ou l'espace logique par défaut de la base de données si
         <varname>default_tablespace</varname> est une chaîne vide.
       </para>
     </listitem>
   </varlistentry>

   <varlistentry>
     <term><literal>USING INDEX TABLESPACE <replaceable class="PARAMETER">espacelogique</replaceable></literal></term>
     <listitem>
       <para>
         Cette clause permet la sélection de l'espace logique dans lequel les
	 index associés à une contrainte <literal>UNIQUE</literal> ou
	 <literal>PRIMARY KEY</literal> seront créés. Si elle n'est pas
	 spécifiée, <xref linkend="guc-default-tablespace"> est utilisée ou
	 l'espace logique par défaut de la base de données si
         <varname>default_tablespace</varname> est une chaîne vide.
       </para>
     </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>    

 <refsect1 id="SQL-CREATETABLE-notes">
  <title>Notes</title>

    <para>
     Utiliser les OID dans les nouvelles applications n'est pas recommandé :
     si possible, utilisez de préférence un type <literal>SERIAL</literal> ou un autre
     générateur de séquence comme clé primaire de la table.
     Néanmoins, si votre application utilise les OID pour identifier des
     lignes spécifiques d'une table, il est recommandé de créer une contrainte
     unique sur la colonne <structfield>oid</structfield> de cette table afin de s'assurer
     que les OID de la table identifieront les lignes réellement de façon unique
     même après une remise à zéro du compteur. Évitez d'assimiler que les OID sont
     uniques pour les différentes tables, si vous avez besoin d'un
     identifiant unique sur la base de données, utilisez une combinaison de
     <structfield>tableoid</structfield> et de l'OID de la ligne dans ce but.
    </para>

    <tip>
     <para>
      L'utilisation de <literal>WITHOUT OIDS</literal> n'est pas recommandée
      pour les tables sans clé primaire, effectivement sans OID ou clé de
      données unique, il est difficile d'identifier des lignes spécifiques.
     </para>
    </tip>

    <para>
     <productname>PostgreSQL</productname> crée automatiquement un index pour
     chaque contrainte unique et pour chaque contrainte de clé étrangère pour
     renforcer l'unicité. Du coup, il n'est pas nécessaire de créer un index
     spécifiquement pour les colonnes de clés primaires. (Voir <xref
     linkend="sql-createindex" endterm="sql-createindex-title"> pour plus
     d'informations.)
    </para>

    <para>
     Les contraintes uniques et les clés primaires ne sont pas héritées dans
     l'implémentation actuelle. Ceci rend la combinaison de l'héritage et des
     contraintes uniques assez disfonctionnelle.
    </para>

    <para>
     Une table ne peut pas avoir plus de 1600 colonnes (en pratique, la limite
     réelle est plus basse à cause de contraintes sur la longueur des lignes).
    </para>

 </refsect1>


 <refsect1 id="SQL-CREATETABLE-examples">
  <title>Exemples</title>

  <para>
   Créez une table <structname>films</structname> et une table
   <structname>distributeurs</structname>&nbsp;:

<programlisting>
CREATE TABLE films (
    code        char(5) CONSTRAINT premierecle PRIMARY KEY,
    titre       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    genre       varchar(10),
    duree       interval hour to minute
);
</programlisting>

<programlisting>
CREATE TABLE distributeurs (
     did    integer PRIMARY KEY DEFAULT nextval('serial'),
     nom    varchar(40) NOT NULL CHECK (nom &lt;&gt; '')
);
</programlisting>
  </para>

  <para>
   Crée une table avec un tableau à deux dimensions&nbsp;:

<programlisting>
CREATE TABLE array_int (
    vecteur  int[][]
);
</programlisting>
  </para>

  <para>
   Définir une contrainte unique de table pour la table
   <literal>films</literal>. Les contraintes uniques de table peuvent être
   définies sur une ou plusieurs colonnes de la table.

<programlisting>
CREATE TABLE films (
    code        char(5),
    titre       varchar(40),
    did         integer,
    date_prod   date,
    genre       varchar(10),
    duree       interval hour to minute,
    CONSTRAINT production UNIQUE(date_prod)
);
</programlisting>
  </para>
  
  <para>
   Définir une contrainte de colonne de vérification&nbsp;:

<programlisting>
CREATE TABLE distributeurs (
    did     integer CHECK (did &gt; 100),
    nom    varchar(40)
);
</programlisting>
  </para>

  <para>
   Définir une contrainte de table de vérification&nbsp;:

<programlisting>
CREATE TABLE distributeurs (
    did     integer,
    nom     varchar(40)
    CONSTRAINT con1 CHECK (did &gt; 100 AND nom &lt;&gt; '')
);
</programlisting>
  </para>
 
  <para>
   Définir une contrainte de clé primaire sur la table <structname>films</structname>.
   Les contraintes de clé primaire peuvent être définies sur une ou
   plusieurs colonnes de la table.

<programlisting>
CREATE TABLE films (
    code        char(5),
    titre       varchar(40),
    did         integer,
    date_prod   date,
    genre       varchar(10),
    duree       interval hour to minute,
    CONSTRAINT code_titre PRIMARY KEY(code,titre)
);
</programlisting>
  </para>

  <para>
   Définir une contrainte de clé primaire pour la table
   <structname>distributeurs</structname>. Les deux exemples suivants sont équivalents,
   le premier utilisant la syntaxe de contrainte de la table, le second la
   syntaxe de contrainte de la colonne.

<programlisting>
CREATE TABLE distributeurs (
    did     integer,
    nom     varchar(40),
    PRIMARY KEY(did)
); 
</programlisting>

<programlisting>
CREATE TABLE distributeurs (
    did     integer PRIMARY KEY,
    nom     varchar(40)
);
</programlisting>
  </para>

  <para>
   Ceci affecte une valeur par défaut pour la colonne <literal>nom</literal>,
   arrange la valeur par défaut de la colonne <literal>did</literal> pour être
   générée en sélectionnant la prochaine valeur d'un objet séquence et fait que
   la valeur par défaut de <literal>modtime</literal> soit le moment où la ligne
   est insérée.

<programlisting>
CREATE TABLE distributeurs (
    name      varchar(40) DEFAULT 'Luso Films',
    did       integer DEFAULT nextval('distributeurs_serial'),
    modtime   timestamp DEFAULT current_timestamp
);
</programlisting>
  </para>

  <para>
   Définir deux contraintes de colonnes <literal>NOT NULL</literal> sur la table
   <classname>distributeurs</classname>, dont une se voit donner explicitement
   un nom&nbsp;:

<programlisting>
CREATE TABLE distributeurs (
    did     integer CONSTRAINT no_null NOT NULL,
    nom     varchar(40) NOT NULL
);
</programlisting>
    </para>

    <para>
     Définit une contrainte unique pour la colonne <literal>nom</literal>&nbsp;:

<programlisting>
CREATE TABLE distributeurs (
    did     integer,
    nom     varchar(40) UNIQUE
);
</programlisting>

     Ce qui se trouve ci-dessus est équivalent à ce qui suit, spécifié comme
     une contrainte de table&nbsp;:

<programlisting>
CREATE TABLE distributeurs (
    did     integer,
    nom     varchar(40),
    UNIQUE(nom)
);
</programlisting>

    <para>
     Créer une table <structname>cinemas</structname> dans l'espace logique
     <structname>diskvol1</structname>&nbsp;:

<programlisting>
CREATE TABLE cinemas (
    id serial,
    nom text,
    emplacement text
) TABLESPACE diskvol1;
</programlisting>
  </para>

 </refsect1>
 
 <refsect1 id="SQL-CREATETABLE-compatibility">
  <title id="SQL-CREATETABLE-compatibility-title">Compatibilité</title>

  <para>
   La commande <command>CREATE TABLE</command> est conforme au standard
   <acronym>SQL</acronym>, avec les exceptions indiquées ci-dessous.
  </para>

  <refsect2>
   <title>Tables temporaires</title>

   <para>
    Bien que la syntaxe de <literal>CREATE TEMPORARY TABLE</literal> ressemble
    à celle du SQL standard, l'effet n'est pas le même. Dans le standard, les
    tables temporaires sont définies seulement une fois et existent
    automatiquement (en commençant avec un contenu vide) dans chaque session qui
    en a besoin. À la place, <productname>PostgreSQL</productname> requiert que
    chaque session lance sa propre commande <literal>CREATE TEMPORARY
    TABLE</literal> pour chaque table temporaire à utiliser.  Ceci permet à
    différentes sessions d'utiliser le même nom de table temporaire dans des
    buts différents alors que l'approche du standard contraint toutes les
    instances d'un nom de table temporaire donné pour avoir la même structure de
    table.
   </para>

   <para>
    La définition du standard pour le comportement des tables temporaires est
    largement ignorée. Le comportement de <productname>PostgreSQL</productname>
    sur ce point est similaire à celui de nombreuses autres bases de données
    SQL.
   </para>

   <para>
    La distinction du standard entre tables temporaires globales et locales
    n'est pas dans <productname>PostgreSQL</productname> car cette distinction
    dépend du concept de modules, que <productname>PostgreSQL</productname> ne
    possède pas. Pour le bien de la compatibilité,
    <productname>PostgreSQL</productname> acceptera les mots clés
    <literal>GLOBAL</literal> et <literal>LOCAL</literal> dans la déclaration
    d'une table temporaire mais cela n'aura aucun effet.
   </para>

   <para>
    La clause <literal>ON COMMIT</literal> pour les tables temporaires
    ressemble aussi au standard SQL mais a quelques différences. Si la clause
    <literal>ON COMMIT</literal> est omise, SQL spécifie que le comportement par défaut
    est <literal>ON COMMIT DELETE ROWS</literal>. Néanmoins, le comportement par défaut
    dans <productname>PostgreSQL</productname> est <literal>ON COMMIT PRESERVE
    ROWS</literal>. L'option <literal>ON COMMIT DROP</literal> n'existe pas en
    SQL.
   </para>
  </refsect2>

  <refsect2>
   <title>Contraintes de vérification de colonnes</title>

   <para>
    Le standard SQL dit que les contraintes de vérification <literal>CHECK</literal>
    de colonne pourraient seulement référencer la colonne à laquelle elles
    s'appliquent&nbsp;; seulement les contraintes de tables <literal>CHECK</literal>
    pourraient se référencer à de nombreuses colonnes.
    <productname>PostgreSQL</productname> ne force pas cette restriction,
    il traite de la même façon les contraintes de vérifications des colonnes et
    des tables.
   </para>
  </refsect2>

  <refsect2>
   <title>Contrainte <literal>NULL</literal></title>

   <para>
    La <quote>contrainte</quote> <literal>NULL</literal> (réellement une
    non-contrainte) est une extension <productname>PostgreSQL</productname> au
    standard SQL qui est inclus pour des raisons de compatibilité avec quelques
    autres systèmes de bases de données (et pour la symétrie avec la contrainte
    <literal>NOT NULL</literal>). Comme ceci est la valeur par défaut de cette
    colonnes, sa présence est un simple bruit.
   </para>
  </refsect2>
   
  <refsect2>
   <title>Héritage</title>

   <para>
    Plusieurs héritages via la clause <literal>INHERITS</literal> est une
    extension du langage <productname>PostgreSQL</productname>. SQL:1999 et
    les versions ultérieures définissent un héritage simple en utilisant une
    syntaxe et des sémantiques différentes. L'héritage style SQL:1999 n'est pas
    encore supporté par <productname>PostgreSQL</productname>.
   </para>
  </refsect2>

  <refsect2>
   <title>Object ID</title>

   <para>
    Le concept <productname>PostgreSQL</productname> des OID n'est pas
    standard.
   </para>
  </refsect2>

  <refsect2>
   <title>Tables à zéro colonne</title>

   <para>
    <productname>PostgreSQL</productname> autorise la création de tables sans
    colonnes (par exemple, <literal>CREATE TABLE foo();</literal>). Ceci est une
    extension du standard SQL, qui ne le permet pas. Les tables sans colonnes ne
    sont pas très utiles mais les désactiver pourrait apporter quelques cas
    bizarres spéciaux pour  <command>ALTER TABLE DROP COLUMN</command>, donc il semble
    plus propre d'ignorer la restriction de cette spécification.
   </para>
  </refsect2>

  <refsect2>
    <title>Espaces logiques</title>

    <para>
      Le concept <productname>PostgreSQL</productname> d'espaces logiques n'est
      pas celui du standard. Du coup, les clauses <literal>TABLESPACE</literal>
      et <literal>USING INDEX TABLESPACE</literal> sont des extensions.
    </para>
  </refsect2>
 </refsect1>


 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-altertable" endterm="sql-altertable-title"></member>
   <member><xref linkend="sql-droptable" endterm="sql-droptable-title"></member>
   <member><xref linkend="sql-createtablespace" endterm="sql-createtablespace-title"></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
