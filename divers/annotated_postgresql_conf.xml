<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" >

<article id="postgresqlconf" lang="fr">
 <articleinfo>
  <title>Fichier postgresql.conf et guide de configuration utilisateur générale 
   (<foreignphrase>Global User Configuration (GUC)</foreignphrase>) annotés</title>
  <subtitle>PostgreSQL 8.1.x</subtitle>
 </articleinfo>

<sect1>
<title>Emplacement des fichiers</title>

<table>
  <title>Fichier postgresql.conf et guide de configuration utilisateur générale 
  (<foreignphrase>Global User Configuration (GUC)</foreignphrase>) annotés</title>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>Échelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>data_directory</entry>
  <entry>Répertoire</entry>
  <entry>ConfigDir</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Répertoire de stockage des données
  </entry>
  <entry>
  Ces nouveaux paramètres de configuration des emplacements de fichiers facilitent l'administration
  d'une installation de PostgreSQL lorsque les fichiers de configuration et de surveillance
  sont séparés de la base, généralement dans un but d'ajustement à une spécification particulière
  du fichier d'administration ou pour automatiser la conduite de tests avec plusieurs configurations.
  Lorsque ce paramètre est utilisé, seul l'emplacement du fichier postgresql.conf doit être
  précisé au démarrage du postmaster (à l'aide de -D ou PGDATA). Cette approche est supérieure
  à l'utilisation de lien symbolique, unique option jusque là disponible.
  </entry>
 </row>
 <row>
  <entry>config_file</entry>
  <entry>Nom de fichier</entry>
  <entry>ConfigDir/postgresql.conf</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
   Fichier de configuration principal du serveur (initialement 
   <filename>postgresql.conf</filename>).
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>hba_file</entry>
  <entry>Nom de fichier</entry>
  <entry>ConfigDir/pg_hba.conf</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
   Fichier de configuration pour l'authentification par hôte
   (habituellement pg_hba.conf).
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>ident_file</entry>
  <entry>Nom de fichier</entry>
  <entry>ConfigDir/pg_ident.conf</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Fichier de configuration pour l'authentification par <emphasis>ident</emphasis>
  (habituellement pg_ident.conf).
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>external_pid_file</entry>
  <entry>Nom de fichier</entry>
  <entry>Aucun</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
   Fichier additionnel d'identifiant de processus (PID) que le
  postmaster crée pour les programmes d'administration serveur.
  </entry>
  <entry>
  Ce paramètre est utile pour les programmes d'administration et les interfaces utilisateur 
  graphiques qui s'attendent à trouver le PID de PostgreSQL à un emplacement particulier, en général
  /var. Ce n'est qu'une copie du PID, en aucun cas le fichier utilisé par pg_ctl au démarrage. 
  Ce dernier est situé dans le répertoire des données.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect1>

<sect1>
<title>Connexions et authentification</title>

<sect2>
<title>Paramètres de connexion</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>Échelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>listen_addresses</entry>
  <entry></entry>
  <entry>localhost</entry>
  <entry>Démarrage</entry>
  <entry>-h x -i</entry>
  <entry>
  Adresse(s) TCP/IP sur la(es)quelle(s) le serveur écoute les connexions en provenance
  des clients. La valeur a la forme d'une liste de noms d'hôte ou d'adresses IP séparés par des
  virgules. La valeur spéciale '*' correspond à toutes les interfaces IP disponibles. 
  Si la liste est vide, le serveur n'écoute aucune interface IP. Dans ce cas, seules les
  sockets de domaine UNIX peuvent être utilisées pour se connecter. La valeur par défaut est
  'localhost', ce qui n'autorise que les connexions &laquo;&nbsp;loopback&nbsp;&raquo;.
  </entry>
  <entry>
  <para>
  Ce paramètre remplace les deux paramètres &laquo;&nbsp;tcp_ip&nbsp;&raquo; et 
  &laquo;&nbsp;virtual_host&nbsp;&raquo; de la version 7.4. La plupart des utilisateurs peuvent
  utiliser '*' pour écouter toutes les adresses, ou laisser 'localhost' pour une machine sécurisée.
  À la différence des versions précédentes, la valeur par défaut autorise désormais les connexions
  TCP/IP sur 127.0.0.1. Le serveur web local peut ainsi se connecter sans paramétrage particulier.
  </para>
  <para>
  Pour un accès sécurisé, ce paramètre doit être modifié <emphasis>après</emphasis>
  la configuration du fichier pg_hba.conf.
  </para>
  </entry>
 </row>
 <row>
  <entry>port</entry>
  <entry>129 à 32768</entry>
  <entry>5432</entry>
  <entry>Démarrage</entry>
  <entry>-p #</entry>
  <entry>
  Le port TCP sur lequel le serveur écoute. Ce port est utilisé pour toutes les 
  adresses IP que le serveur écoute.
  </entry>
  <entry>
  <para>
  Un port alternatif est essentiellement utilisé lorsque plusieurs serveurs
  PostgreSQL tournent sur la même machine, pendant une mise à niveau par exemple.
  </para>
  <para>
  Une alternative à cette configuration est l'utilisation de l'option de compilation
  &laquo;&nbsp;--with-port&nbsp;&raquo;.
  Cette option fixe le port alternatif dans tous les binaires évitant ainsi de
  préciser l'option -p pour tous les clients.
  </para>
  </entry>
 </row>
 <row>
  <entry>max_connections</entry>
  <entry>2 à 262143</entry>
  <entry>100</entry>
  <entry>Démarrage</entry>
  <entry>-N #</entry>
  <entry>
  Nombre maximum de connexions concurrentes à un serveur de bases de données.
  Typiquement 100 par défaut, il peut être réduit si la configuration du noyau
  l'impose (initdb tente de le déterminer).
  </entry>
  <entry>
  Ce paramètre doit être maintenu près du minimum requis par l'application.
  En effet, chaque connexion nécessite des ressources
  système significatives. Les applications web qui servent des centaines
  d'utilisateurs peuvent utiliser une réserve de connexions
  (<foreignphrase>connection pool</foreignphrase>) pour réduire le nombre 
  de connexions demandées. L'augmentation du paramètre demande un ajustement des
  limites mémoire du système.
  </entry>
 </row>
 <row>
  <entry>superuser_reserved_connections</entry>
  <entry>0 à max_connections - 1</entry>
  <entry>2</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Nombre de connexions réservées aux superutilisateurs PostgreSQL et au démon autovacuum. Au plus
  max_connections connexions peuvent être actives simultanément. Lorsque
  le nombre de connexions concurrentes atteint max_connections moins
  superuser_reserved_connections, seules les connexions de superutilisateurs
  sont encore autorisées.
  </entry>
  <entry>
  Cela protège l'accès des superutilisateurs en cas d'engorgement de la base.
  Ce paramètre ne doit être positionné à 0 que lorsqu'il est certain que
  toutes les connexions ne sont jamais utilisées. (NDR&nbsp;: Je positionne
  souvent ce paramètre à 1 puisque je ne me connecte en superutilisateur
  à la base qu'en cas de problème.) Le paramétrage à 2 par défaut prévoit le 
  cas d'utilitaire administratif connecté en permanence, autovacuum par exemple.
  </entry>
 </row>
 <row>
  <entry>unix_socket_directory</entry>
  <entry></entry>
  <entry>''</entry>
  <entry>Démarrage</entry>
  <entry>-k $</entry>
  <entry>
  Répertoire du socket de domaine Unix sur lequel le serveur écoute
  les connexions de clients. /tmp par défaut, mais le paramètre
  peut être modifié à la compilation.
  </entry>
  <entry>
  Aucune recommandation particulière.
  </entry>
 </row>
 <row>
  <entry>unix_socket_group</entry>
  <entry></entry>
  <entry>''</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Groupe propriétaire du socket de domaine Unix. (L'utilisateur propriétaire
  de ce socket est toujours celui qui exécute le serveur.) Combiné avec l'option
  UNIX_SOCKET_PERMISSIONS, ce paramètre peut être utilisé comme mécanisme
  supplémentaire de contrôle des accès pour ce type de socket. Par défaut, 
  c'est une chaîne vide, donc le groupe par défaut de l'utilisateur.
  </entry>
  <entry>
  Aucune recommandation particulière.</entry>
 </row>
 <row>
  <entry>unix_socket_permissions</entry>
  <entry></entry>
  <entry>0777</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  <para>
  Droits d'accès au socket de domaine Unix. Les sockets de domaine Unix
  utilisent le système habituel de gestion des droits des systèmes de 
  fichier Unix. La valeur de l'option doit être précisée sous la forme numérique
  acceptée par les outils système chmod et umask. L'utilisation du format 
  octal impose un 0 (zéro) en début de nombre.
  </para>
  <para>
  Les droits par défaut sont 0777, tout le monde peut se connecter.
  Des alternatives acceptables sont 0770 (droits pour l'utilisateur
  et le groupe, voir aussi unix_socket_group), et 0700 (utilisateur seul).
  En général, dans le cas d'une socket de domaine Unix, seul le droit
  d'écriture importe. Il n'y a donc aucun intérêt à positionner ou supprimer
  les droits d'écriture ou de lecture.
  </para>
  </entry>
  <entry>
  Aucune recommandation particulière.</entry>
 </row>
 <row>
  <entry>bonjour_name</entry>
  <entry></entry>
  <entry>''</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Nom du diffuseur Bonjour. La valeur par défaut, indiquée par une chaîne
  vide '', est le nom de l'ordinateur. Cette option n'a d'intérêt que pour les
  plateformes qui supportent Rendezvous.
  </entry>
  <entry>
  Aucune recommandation particulière.
  </entry>
 </row>
 <row>
  <entry>tcp_keepalives_idle</entry>
  <entry></entry>
  <entry>0</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
   Indique l'interval (en secondes) entre l'envoi de deux instructions
   &laquo;&nbsp;d'entretien&nbsp;&raquo; (keepalive) sur une connexion autrement
   inactive. Valable pour les systèmes qui acceptent l'option de socket
   <symbol>TCP_KEEPIDLE</symbol>.
   Une valeur nulle (0) impose l'utilisation de la valeur par défaut du système. Si 
   <symbol>TCP_KEEPIDLE</symbol> n'est pas supporté, ce paramètre doit être
   positionné à 0. Cette option est sans effet lors de connexions par la socket
   de domaine UNIX.
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>tcp_keepalives_interval</entry>
  <entry></entry>
  <entry>0</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
   Indique le délai d'attente (en secondes) d'une réponse à un keepalive avant
   retransmission. Valable pour les systèmes qui acceptent l'option de socket
   <symbol>TCP_KEEPINTVL</symbol>. Une valeur nulle (0) impose l'utilisation de
   la valeur par défaut du système. Si <symbol>TCP_KEEPINTVL</symbol> n'est pas
   supporté, ce paramètre doit être positionné à 0. Cette option est sans effet
   lors de connexions par la socket de domaine UNIX.
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>tcp_keepalives_count</entry>
  <entry></entry>
  <entry>0</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
   Indique le nombre de keepalives qui peuvent être perdus avant de considérer
   la connexion perdue. Valable sur les système qui acceptent l'option de socket
   <symbol>TCP_KEEPCNT</symbol>. Une valeur nulle (0) impose l'utilisation de
   la valeur par défaut du système. Si <symbol>TCP_KEEPCNT</symbol> n'est pas
   supporté, ce paramètre doit être positionné à 0. Cette option est sans
   effet lors de connexions par la socket de domaine UNIX.
  </entry>
  <entry>
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Securité et authentification</title>

<table>
<title>Sécurité et authentification (Fichier postgresql.conf et guide de configuration utilisateur générale (<foreignphrase>Global User Configuration (GUC)</foreignphrase>) annotés)</title>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>Échelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>authentication_timeout</entry>
  <entry>1-600 sec</entry>
  <entry>600</entry>
  <entry>Rechargement</entry>
  <entry></entry>
  <entry>
  Temps maximum laissé à un client pour réussir l'authentification, en secondes.
  Si un client potentiel n'a pas terminé la séquence d'authentification
  pendant ce temps, le serveur met fin à la connexion. Cela permet 
  d'éviter qu'un client bloqué n'occupe indéfiniment une connexion.
  </entry>
  <entry>
  Le temps d'attente peut être réduit s'il s'agit d'exécuter un site web
  à grand traffic. Afin d'éviter une indisponibilité non souhaitée,
  ou une attente trop longue lorsque le serveur est chargé, il peut
  être utile de faire correspondre ce temps d'attente avec celui de l'intergiciel.
  </entry>
 </row>
 <row>
  <entry>ssl</entry>
  <entry>true, false</entry>
  <entry>false</entry>
  <entry>Démarrage</entry>
  <entry>-l</entry>
  <entry>Active les connexions SSL</entry>
  <entry>
  SSL est une alternative chiffrée à l'accès direct au port TCP/IP, nécessaire
  pour les clients accédant à des données sécurisées, en particulier à travers
  un réseau sans fil. PostgreSQL envoie les requêtes et les données en texte,
  même lors de l'utilisation d'un mot de passe chiffré. SSL peut être difficile
  à configurer et tous les clients ne supportent pas l'accès SSL.
  </entry>
 </row>
 <row>
  <entry>password_encryption</entry>
  <entry>true, false</entry>
  <entry>true</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
  Détermine le chiffrement du mot de passe lorsque ni ENCRYPTED ni UNENCRYPTED
  ne sont précisés lors de l'indication d'un mot de passe avec les commandes
  <ulink url="http://docs.postgresqlfr.org/8.1/sql-createuser.html">CREATE USER</ulink>
  et <ulink url="http://docs.postgresqlfr.org/8.1/sql-alteruser.html">ALTER USER</ulink>.
  </entry>
  <entry>
  Il est préférable de laisser la valeur à <foreignphrase>true</foreignphrase> (vrai),
  à la fois dans le fichier de configuration et à la connexion. Il n'y a quasiment
  jamais de raison de ne pas chiffrer les mots de passe des utilisateurs de la base de
  données.
  </entry>
 </row>
 <row>
  <entry>krb_server_keyfile</entry>
  <entry></entry>
  <entry>''</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Positionne l'implantation du fichier de clés du serveur Kerberos.
  </entry>
  <entry>
  Utilisé uniquement pour l'authentification Kerberos des utilisateurs.
  </entry>
 </row>
 <row>
  <entry>krb_srvname</entry>
  <entry></entry>
  <entry>''</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>Positionne le nom du service Kerberos.</entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>krb_server_hostname</entry>
  <entry></entry>
  <entry>''</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  <para>
   Positionne la partie nom d'hôte du service principal. En combinaison avec
   <varname>krb_srvname</varname>, il est utilisé pour engendrer le service
   principal complet, c'est-à-dire
   <varname>krb_srvname</varname><literal>/</literal><varname>krb_server_hostname</varname><literal>@</literal>REALM.
  </para>
  <para>
   En l'absence de précision, la valeur par défaut est le nom d'hôte du serveur.
  </para>
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>krb_caseins_users</entry>
  <entry></entry>
  <entry>''</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
   Règle la sensibilité à la casse des noms d'utilisateur Kerberos. La valeur
   par défaut est <literal>off</literal> (sensibilité à la casse).
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>db_user_namespace</entry>
  <entry>true, false</entry>
  <entry>false</entry>
  <entry>Rechargement</entry>
  <entry></entry>
  <entry>
  Lorsque cette option est activée, les utilisateurs doivent être créés comme
  nom_utilisateur@nom_base. Lorsque le nom d'utilisateur est fourni par un client, 
  @ et le nom de la base sont ajoutés au nom de l'utilisateur.
  C'est ce nom d'utilisateur, dépendant d'une base de données, qui est
  ensuite recherché par le serveur. Lors de la création dans l'environnement
  SQL d'utilisateurs dont le nom contient @, il est nécessaire de placer le
  nom de l'utilisateur entre des guillemets simples.
  </entry>
  <entry>
  Cette option prend en charge les installations (telles que les FAI)
  qui nécessitent des utilisateurs définis par base de données. C'est
  assez contraignant, et cela devrait être supprimé lorsqu'une meilleure
  solution sera créée. Il est ainsi préférable de ne pas utiliser cette option
  lorsqu'elle n'est pas vitale.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Utilisation des ressources</title>

<sect2>
<title>Mémoire</title>

<note>
 <para>
  Augmenter la valeur de la plupart des paramètres suivants
  oblige à modifier les options du noyau du système d'exploitation 
  pour augmenter la mémoire allouée à un processus ou à un utilisateur.
  La documentation en ligne fournit des <ulink
  url="http://docs.postgresqlfr.org/8.1/kernel-resources.html">informations sur
  les commandes à utiliser pour de nombreux systèmes d'exploitation</ulink>. Sauf indication
  contraire, la plupart de ces options s'additionnent pour déterminer 
  la quantité totale de mémoire utilisée par PostgreSQL.
 </para>
</note>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>Échelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>shared_buffers</entry>
  <entry>16 à 262143</entry>
  <entry>1000</entry>
  <entry>
  Démarrage
  </entry>
  <entry>-B x</entry>
  <entry>
  Positionne le nombre de tampons de mémoire partagée utilisés par le
  serveur de bases de données. Le minimum est 2 X max_connections.
  La valeur par défaut est généralement 1000 mais elle peut être
  inférieure si la configuration du noyau l'impose (ce qu'initdb détermine). 
  Chaque tampon représente 8192 octets, à moins qu'une valeur
  différente de BLCKSZ n'ait été choisie à la compilation. La valeur
  minimale est de 16 et de deux fois la valeur de max_connections.
  Néanmoins, un paramétrage significativement supérieur au minimum
  est souvent nécessaire pour assurer des performances satisfaisantes.
  En production, il est recommandé d'utiliser une valeur de quelques
  milliers.
  </entry>
  <entry>
  <para>
  Le paramétrage de shared_buffers nécessite une discussion bien plus complète
  que ne l'autorise la place ici disponible. On peut se référer à d'autres
  articles sur le sujet.
  </para>
  <para>
  Quelques règles empiriques&nbsp;:
  Sur un serveur PostgreSQL dédié, une valeur convenable se situe en général entre 
  1&nbsp;000 et 50&nbsp;000 (8Mo et 400Mo). Les facteurs qui incitent à augmenter
  la valeur sont des connexions plus nombreuses, des parties actives de la base
  plus grandes, des requêtes longues et complexes, et des grandes tables. La
  RAM disponible limite le nombre maximum de shared_buffers&nbsp;; 1/3 de la RAM
  disponible est la limite maximale à utiliser.
  </para>
  </entry>
 </row>
 <row>
  <entry>temp_buffers</entry>
  <entry></entry>
  <entry>1000</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
  <para>
   Positionne le nombre maximum de tampons temporaires utilisés par chaque
   session de la base. Ce sont des tampons spécifiques à la session utilisés
   uniquement pour accéder aux tables temporaires. La valeur par défaut est
   1&nbsp;000. Le paramètre peut être modifié au cours de la session, tant
   qu'aucune table temporaire n'a été utilisée&nbsp;; toute tentative ultérieure
   n'aura aucun effet sur cette session.
  </para>
  <para>
   Une session alloue les tampons temporaires nécessaires dans la limite de
   <varname>temp_buffers</varname>. Positionner une grande valeur
   pour des sessions qui ne nécessitent en fait que peu de tampons temporaires 
   ne coûte qu'un descripteur de tampon, soit 64 octets, par incrément de
   <varname>temp_buffers</varname>. Toutefois, un tampon utilisé consomme
   8&nbsp;192 octets (ou, en général, <symbol>BLCKSZ</symbol> octets).
  </para>
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>max_prepared_transactions</entry>
  <entry></entry>
  <entry>5</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  <para>
   Positionne le nombre maximum de transactions pouvant être simultanément
   <quote>préparées</quote>. Positionner ce paramètre à 0 désactive la
   fonctionnalité des transactions préparées.
  </para>
  <para>
   Lorsque les transactions préparées ne sont pas utilisées, ce paramètre peut
   être positionné à 0. Lorsqu'elles sont utilisées,
   <varname>max_prepared_transactions</varname> est positionnée à une valeur au
   minimum égale à max_connections, afin d'éviter les erreurs dans la phase
   de préparation.
  </para>
  <para>
   L'augmentation de ce paramètre peut obliger
   <productname>PostgreSQL</productname> à réclamer plus de mémoire partagée
   <systemitem class="osname">System V</systemitem> que la configuration par
   défaut du système n'en autorise.
  </para>
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>
  work_mem
  </entry>
  <entry>64 à Int Max</entry>
  <entry>1024</entry>
  <entry>
  Exécution
  </entry>
  <entry>-S #</entry>
  <entry>
  <para>
  Précise la quantité de mémoire utisable par les opérations de tri interne et
  les tables de hachage avant d'utiliser des fichiers temporaires. La valeur
  est indiquée en Ko, la valeur par défaut est 1024 Ko (soit 1 Mo).
  En cas de requête complexe, de nombreuses opérations de tri ou de hachage
  peuvent s'exécuter en parallèle&nbsp;; chacune peut utiliser la quantité
  de mémoire indiquée par la valeur de ce paramètre avant de commencer à
  utiliser des fichiers temporaires. De plus, de nombreuses sessions
  peuvent effectuer ces opérations en parallèle. La mémoire totale
  utilisée peut être plusieurs fois la valeur de work_mem&nbsp;; il faut
  en tenir compte lors du choix de la valeur. Les opérations de tri sont 
  utilisées par ORDER BY, DISTINCT et les jointures. Les tables de hachage
  sont utilisées dans les jointures de hachage, les aggrégations par hachage
  et la résolution par hachage des sous-requêtes IN.
  </para>
  </entry>
  <entry>
  <para>
  À l'origine appelé sort_mem, le paramètre a été renommé pour refléter
  l'extension de son rôle au-delà des simples tris.
  </para>
  <para>
  work_mem est un compromis. Une plus grande valeur est utilisée pour&nbsp;: les
  bases de données volumineuses, les requêtes complexes, une grande quantité de 
  RAM disponible. Une plus petite valeur est recherchée pour&nbsp;: une faible
  quantité de RAM ou de nombreux accès concurrents. Trouver le bon compromis
  peut s'avérer délicat.
  </para>
  <para>
  Une autre façon d'ajuster cette valeur consiste à surveiller les fichiers
  temporaires de PostgreSQL (dans PGDATA/base/OID_BASE/pgsql_tmp) et d'accroître
  la valeur de sort_mem si de nombreuses requêtes permutent avec ces fichiers.
  </para>
  <para>
  Il ne faut pas oublier que ce paramètre peut être positionné par connexion.
  Ainsi, dans le cas où seules quelques requêtes très complexes sont à
  exécuter, la valeur peut être augmentée avant leur exécution, mais conservée
  basse pour les autres connexions.
  </para>
  </entry>
 </row>
 <row>
  <entry>
  maintenance_work_mem
  </entry>
  <entry>1024 à Int Max</entry>
  <entry>8192</entry>
  <entry>
  Exécution
  </entry>
  <entry></entry>
  <entry>
  Indique la quantité maximale de mémoire à utiliser dans les opérations
  de maintenance, telles que VACUUM, CREATE INDEX et ALTER TABLE ADD FOREIGN KEY.
  La valeur est précisée en Ko. La valeur par défaut est 16384 Ko
  (16 Mo). Puisque seule une de ces opérations peut être effectuée à la fois
  au cours d'une session, et qu'en général peu se produisent simultanément
  sur une même installation, il n'y a aucun risque à positionner ce paramètre
  à une valeur nettement supérieure à celle de work_mem. Une valeur élevée
  peut améliorer les performances du nettoyage (vacuum) et de la restauration
  des sauvegardes.
  </entry>
  <entry>
  <para>
  À l'origine appelé vacuum_mem, le paramètre a été renommé pour refléter l'extension
  de son rôle à l'allocation de mémoire lors du chargement des index.
  </para>
  <para>
  La valeur par défaut est généralement trop basse. Il en résulte un blocage
  des E/S du système par les opérations de VACUUM et de créations d'index et/ou
  des blocages d'objets pendant la permutation. Une valeur convenable est généralement
  comprise entre 32&nbsp;Mo et 256&nbsp;Mo&nbsp;; cela dépend autant de la RAM
  disponible que du plus grand volume (attendu) des objets de la base. 
  </para>
  <para>
  Tout comme work_mem, ce paramètre peut être fixé à l'exécution, ce qui permet 
  de l'accroître temporairement lors du chargement d'index ou de la création 
  de clés sur des tables volumineuses.
  </para>
  </entry>
 </row>
 <row>
  <entry>max_stack_depth</entry>
  <entry></entry>
  <entry></entry>
  <entry></entry>
  <entry></entry>
  <entry>
  Indique la profondeur maximale que peut atteindre la pile d'exécution du serveur
  en toute sécurité. Le réglage idéal du paramètre correspond à la limite réelle
  de la pile imposée par le noyau (positionné par ulimit -s ou équivalent), diminué
  d'une marge de sécurité d'un Mo environ. Cette marge de sécurité est nécessaire
  parce que la profondeur de la pile n'est pas vérifiée pour chaque routine du
  serveur, mais uniquement pour les routines potentiellement récursives, telles
  que les évaluations d'expressions. Une valeur plus grande
  que la limite réelle du noyau peut conduire une fonction récursive à
  occasionner un plantage d'un processus serveur. La valeur par défaut de 2048 Ko
  (2 Mo) est résolument basse et ne risque pas d'occasionner un plantage. Néanmoins, 
  elle peut s'avérer trop petite pour autoriser l'exécution de fonctions complexes.
  </entry>
  <entry>
  <para>
  Le paramètre s'est appelé max_expr_depth et son unité ne correspondait pas 
  à celle utilisée par la plupart des noyaux systèmes.
  </para>
  <para>
  En cas de dépassement de ce paramètre, un message d'erreur spécifique est
  produit. À ce moment-là, il peut être augmenté
  <emphasis>avec précaution</emphasis>&nbsp;; de nombreux systèmes d'exploitation
  ont des limites aussi basses que 8&nbsp;Mo.
  </para>
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Carte de l'espace libre (<foreignphrase>Free Space Map</foreignphrase>)</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>Échelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>max_fsm_pages</entry>
  <entry>1000 à Int Max</entry>
  <entry>20000</entry>
  <entry>
  Démarrage
  </entry>
  <entry></entry>
  <entry>
  Positionne le nombre maximum de pages disque pour lesquelles l'espace
  libre est recherché dans la carte de l'espace libre partagé.
  Six octets de mémoire partagée sont consommés pour chaque connecteur
  de page. La valeur doit être supérieure à 16 X max_fsm_relations.
  </entry>
  <entry>
  <para>
  Un paramétrage correct de la FSM peut éliminer, ou au moins, retarder
  l'obligation d'exécuter VACUUM FULL et REINDEX. La meilleure façon de le régler 
  est la suivante&nbsp;:
  <orderedlist>
    <itemizedlist><para>calculer la fréquence du VACUUM (normal) de la
  base en fonction des écritures&nbsp;;</para></itemizedlist>
    <itemizedlist><para>utiliser la base en fonctionnement
  normal et exécuter VACUUM VERBOSE ANALYZE à la place de VACUUM, en sauvegardant
  la sortie dans un fichier&nbsp;;</para></itemizedlist>
    <itemizedlist><para>calculer le nombre de pages maximum réclamé
  par VACUUM et utiliser ce chiffre.</para></itemizedlist>
  </orderedlist>
  </para>
  <para>
  Alternativement, en cas d'utilisation d'autovacuum, la valeur peut être
  issue d'un pourcentage du nombre total de pages dans la base, pour coïncider
  avec le pourcentage d'autovacuum. Quoiqu'il en soit, une page demande peu
  de mémoire (environ 6 octets). Il est donc préférable d'être généreux plutôt 
  que radin.
  </para>
  <para>
  Pour les base de données qui connaissent des &laquo;&nbsp;pics&nbsp;&raquo;
  d'activité (rafales d'un million de mises à jour mais pas d'autre
  activité des minutes ou des heures durant), ce nombre peut être 
  impossible à optimiser. Les lignes insérées n'ont pas d'impact
  sur la FSM. Enfin, si le serveur est peu fourni en RAM, augmenter
  cette valeur peut s'avérer contre-productif.
  </para>
  </entry>
 </row>
 <row>
  <entry>max_fsm_relations</entry>
  <entry>10 à Int Max</entry>
  <entry>1000</entry>
  <entry>
  Démarrage
  </entry>
  <entry></entry>
  <entry>
  Positionne le nombre maximum de relations (tables et index) pour
  lesquelles l'espace libre est recherché dans la carte de l'espace libre
  partagé. Chaque connecteur utilise approximativement 50 octets de mémoire.
  </entry>
  <entry>
  Peu d'utilisateurs peuvent avoir besoin d'ajuster ce paramètre mais il est
  intéressant de le considérer. FSM_relations doit être au moins équivalent
  au nombre de tables dans l'ensemble des bases, bases squelettes et schéma
  système compris. PostgreSQL peut avoir des performances aléatoires 
  si le nombre de FSM_relations est trop faible.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Utilisation des ressources du noyau</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>Échelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>max_files_per_process</entry>
  <entry>25 à Int Max</entry>
  <entry>1000</entry>
  <entry>
  Démarrage
  </entry>
  <entry></entry>
  <entry>
  Fixe le nombre maximum de fichiers simultanément ouverts par chaque
  sous-processus du serveur. La valeur par défaut est 1&nbsp;000. 
  Si le noyau impose une limite par processus, il n'est pas nécessaire
  de s'inquiéter de ce paramètre. Mais sur la plupart des plateformes
  (et notamment BSD), le noyau autorise des processus individuels à ouvrir
  beaucoup plus de fichiers que le système ne peut en prendre en charge
  lorsque de nombreux processus essayent tous d'ouvrir ce nombre de fichiers.
  Si le message d'erreur &laquo;&nbsp;Trop de fichiers ouverts&nbsp;&raquo;
  (<foreignphrase>"Too many open files"</foreignphrase>) apparaît, 
  il faut alors essayer de réduire ce paramètre. Il ne peut être
  fixé qu'au démarrage du serveur.
  </entry>
  <entry>
  D'après la documentation, utiliser essentiellement pour BSD. À considérer uniquement
  lors de l'apparition de messages &laquo;&nbsp;Trop de fichiers ouverts&nbsp;&raquo;
  (<foreignphrase>"Too many open files"</foreignphrase>).
  </entry>
 </row>
 <row>
  <entry>preload_libraries</entry>
  <entry>Chemin de fichier</entry>
  <entry>Vide</entry>
  <entry>
  Démarrage
  </entry>
  <entry></entry>
  <entry>
  <para>
  Indique les bibliothèques à précharger au démarrage du serveur. Une
  fonction d'initialisation sans paramètre peut optionnellement être
  appelée pour chaque bibliothèque. Pour cela, il suffit d'ajouter un 
  double-point et le nom de la fonction d'initialisation après le
  nom de la bibliothèque. '$libdir/mylib:mylib_init' implique, par exemple,
  le préchargement de mylib et l'exécution de la fonction mylib_init.
  Si plusieurs bibliothèques doivent être chargées, leurs noms
  sont séparés par des virgules.
  </para>
  <para>
  Si une bibliothèque ou une fonction d'initialisation ainsi indiquée
  n'est pas trouvée, le serveur ne peut pas démarrer. Les bibliothèques
  du langage procédural de PostgreSQL peuvent être préchargées de cette 
  façon, typiquement en utilisant la syntaxe '$libdir/plXXX:plXXX_init'
  avec XXX qui peut être pgsql, perl, tcl ou python.
  </para>
  <para>
  Le préchargement (et l'initialisation éventuelle) d'une bibliothèque
  partagée permet d'éviter le temps de chargement de la bibliothèque
  la première fois qu'elle est utilisée. Néanmoins, le temps de démarrage
  de chaque processus serveur peut croître légèrement, même si ce
  processus n'utilise jamais cette bibliothèque. Cette option n'est
  donc recommandée que pour les bibliothèques utilisées dans la plupart
  des sessions.
  </para>
  </entry>
  <entry>
  Cela n'est utile que dans le cas de bases de données spécialisées.
  Une base de cartographie peut, par exemple, gagner légèrement en performances
  en préchargeant les bibliothèques GIS. Pour la plupart des systèmes, il est
  préférable de ne pas renseigner cette option.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Délai de nettoyage (<foreignphrase>vacuum</foreignphrase>)</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>vacuum_cost_delay</entry>
  <entry></entry>
  <entry>0</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
  Le temps, en millisecondes, pendant lequel le processus est endormi lorsque
  la limite de coût est atteinte. La valeur par défaut est 0, ce qui désactive
  la fonctionnalité de délai de nettoyage en fonction du coût. Une valeur
  positive active le nettoyage fonction du coût. Sur la plupart des systèmes,
  la résolution réelle du délai est de 10 millisecondes&nbsp;; une valeur
  de vacuum_cost_delay qui n'est pas un multiple de 10 a le même comportement
  que le plus petit multiple de 10 supérieur à cette valeur.
  </entry>
  <entry>
  Ce paramètre est très utile lors du nettoyage de tables volumineuses, qui
  autrement, peut bloquer les E/S pendant de longues périodes ou maintenir
  des verrous bloquant de nombreuses requêtes. Pour l'essentiel, l'activation
  de ce paramètre découpe le nettoyage d'une table volumineuse en segments
  définis comme des unités de travail spécifiques, entre lesquelles le
  nettoyage est mis en veille pour le temps défini par le paramètre. Cela a pour
  effet d'augmenter parfois considérablement le temps nécessaire au nettoyage, 
  mais aussi de réduire l'impact du nettoyage sur le système, de l'ordre de 85%.
  Une valeur raisonnable est comprise entre 50&nbsp;ms et 200&nbsp;ms.
  </entry>
 </row>
 <row>
  <entry>vacuum_cost_page_hit</entry>
  <entry></entry>
  <entry>1</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
  Indique le coût estimé de nettoyage d'un tampon trouvé dans le cache de
  tampon partagé. Ce paramètre représente le coût du verrouillage du groupe de
  tampons, la recherche de la table de hachage partagée et le parcours du
  contenu de la page.
  </entry>
  <entry>
  Il est préférable de ne pas modifier ce paramètre, mais plutôt
  vacuum_cost_limit.
  </entry>
 </row>
 <row>
  <entry>vacuum_cost_page_miss</entry>
  <entry></entry>
  <entry>10</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
  Indique le coût estimé de nettoyage d'un tampon à lire sur le disque. Ce
  paramètre représente le coût de verrouillage du groupe de tampons, la recherche de la
  table de hachage partagée, la lecture du bloc souhaité sur le disque et le
  parcours de son contenu.
  </entry>
  <entry>
  Il est préférable de ne pas modifier ce paramètre, mais plutôt
  vacuum_cost_limit.
  </entry>
 </row>
 <row>
  <entry>vacuum_cost_page_dirty</entry>
  <entry></entry>
  <entry>20</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
  Indique le coût estimé de la modification par le nettoyeur d'un bloc
  précédemment nettoyé. Ce paramètre représente les E/S supplémentaires requises
  pour supprimer une nouvelle fois du disque les blocs inutiles.
  </entry>
  <entry>
  Il est préférable de ne pas modifier ce paramètre, mais plutôt
  vacuum_cost_limit.
  </entry>
 </row>
 <row>
  <entry>vacuum_cost_limit</entry>
  <entry></entry>
  <entry>200</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
  Indique le coût cumulé qui impose la mise en sommeil du processus de
  nettoyage.
  </entry>
  <entry>
  La valeur de ce paramètre est diminuée pour fragmenter le nettoyage en des
  &laquo;&nbsp;segments&nbsp;&raquo; plus nombreux. Une combinaison très
  aggressive consiste à positionner vacuum_cost_delay à 200&nbsp;ms et
  vacuum_cost_limit à 50&nbsp;ms&nbsp;; cela implique un nettoyage 10 fois plus
  long mais sans impact sur les performances de la base de données. Dans la
  plupart des cas, le DBA peut être plus modéré.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Processus d'écriture en arrière-plan (<foreignphrase>Background
Writer</foreignphrase>)</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>Échelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>bgwriter_delay</entry>
  <entry></entry>
  <entry>200</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Indique le délai entre les périodes d'activité du processus d'écriture en arrière-plan. À
  chaque tour, ce processus écrit sur le disque un certain nombre de tampons
  modifiés (nombre ajustable à l'aide des paramètres qui suivent). Les tampons
  sélectionnés sont toujours les plus anciens des tampons modifiés. Le processus d'écriture
  est alors mis en veille pour bgwriter_delay millisecondes, et ainsi de suite.
  </entry>
  <entry>
  <para>
  Fonctionnalité nouvelle, le processus d'écriture en arrière-plan est destiné à
  alléger les pics de contrôle.
  </para>
  <para>
  L'OSDL effectue toujours des tests de configuration du bgwriter&nbsp;; aucune
  recommandation ne peut être faite à ce jour.
  </para>
  </entry>
 </row>
 <row>
  <entry>bgwriter_lru_percent</entry>
  <entry></entry>
  <entry>1.0</entry>
  <entry>Redémarrage</entry>
  <entry></entry>
  <entry>
   Pour réduire la probabilité que les processus serveur n'effectuent leurs
   propres écritures, le processus d'écriture en arrière-plan tente d'écrire les tampons
   prochainement recyclés. &Agrave; chaque tour, il examine jusqu'à
   <varname>bgwriter_lru_percent</varname> des tampons les plus proches d'un
   recyclage et écrit les tampons modifiés. La valeur par défaut est 1.0
   (pourcentage du nombre total de tampons partagés).
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>bgwriter_lru_maxpages</entry>
  <entry></entry>
  <entry>5</entry>
  <entry>Redémarrage</entry>
  <entry></entry>
  <entry>
   &Agrave; chaque tour, seul ce nombre de tampons, au maximum, peuvent être écrits
   à la suite d'une recherche de tampons &laquo;&nbsp;proches du
   recyclage&nbsp;&raquo;.
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>bgwriter_all_percent</entry>
  <entry></entry>
  <entry>0.333</entry>
  <entry>Redémarrage</entry>
  <entry></entry>
  <entry>
   Pour réduire la quantité de travail nécessaire à chaque point de contrôle, le
   processus d'écriture en arrière-plan effectue également un parcours circulaire de tout le
   groupe de tampons, et écrit ceux qui sont modifiés. À chaque tour, il examine
   jusqu'à <varname>bgwriter_all_percent</varname> des tampons. La
   valeur par défaut est 0.333 (pourcentage du nombre total de tampons
   partagés). En combinaison avec le paramètrage par défaut de
   <varname>bgwriter_delay</varname>, cela permet de parcourir l'intégralité du
   groupe de tampons partagés toutes les minutes environ.
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>bgwriter_all_maxpages</entry>
  <entry></entry>
  <entry>5</entry>
  <entry>Redémarrage</entry>
  <entry></entry>
  <entry>
   Nombre maximal de tampons écrits, à chaque tour, à la suite du parcours de
   l'intégralité du groupe de tampons. Si la limite est atteinte, le parcours
   cesse et reprend au prochain tampon au tour suivant.
  </entry>
  <entry>
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Options WAL</title>

<sect2>
<title>Paramétrage</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>Échelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>fsync</entry>
  <entry>true, false</entry>
  <entry>true</entry>
  <entry>Démarrage</entry>
  <entry>-F (off)</entry>
  <entry>
  <para>
  Lorsque cette option est activée, le serveur PostgreSQL utilise les appels
  système fsync() pour s'assurer que les mises à jour sont physiquement écrites
  sur le disque. Cela garantit la récupération d'une bases de données
  cohérente après une panne matérielle ou système.
  </para>
  <para>
  Néanmoins, l'utilisation de fsync() implique une baisse de performances&nbsp;:
  lorsqu'une transaction est validée, PostgreSQL doit attendre que le système
  purge le journal d'écriture anticipée. Lorsque fsync est désactivé, a toute
  latitude dans la mise en mémoire tampon, le tri et le report des écritures. 
  Il peut en découler des performances accrues. Toutefois, si le système plante,
  le résultat des dernières transactions validées peut être perdu, en tout ou
  partie. Dans le pire des cas, les données peuvent être irrémédiablement
  corrompues. Les plantages du serveur de base de données ne présentent ici
  aucun risque&nbsp;; seul un plantage du système d'exploitation présente un
  risque de corruption.
  </para>
  </entry>
  <entry>
  <para>
  La journalisation des écritures anticipées (<foreignphrase>Write-Ahead
  Logging ou WAL</foreignphrase>) ne doit être désactivée que sur les bases en
  écriture seule ou celles qu'il est possible de régénérer à l'aide de logiciels
  externes. Tandis que du RAID associé à un système de haute-disponibilité
  électrique peuvent aider à la protection des données, la désactivation de
  fsync <emphasis>impose</emphasis> la restauration des données à partir de
  sauvegardes en cas de pannes matériel ou électrique.
  </para>
  <para>
  D'un autre côté, le WAL implique une baisse de performances lors des écritures, à
  plus forte raison sur des systèmes mono-disques. Pour l'essentiel, l'activité
  nécessaire aux opérations de lecture/écriture est doublée à chaque mise à
  jour. De plus, les fonctionnalités d'amélioration des performances par cache
  disque matériel ou logiciel sont désactivées. C'est pourquoi, dans le cas de
  données dont la conservation n'est pas une priorité, il est intéressant de
  considérer la désactivation de fsync.
  </para>
  <para>
  Si le WAL est arrêté, les options qui suivent n'ont pas d'intérêt.
  </para>
  </entry>
 </row>
 <row>
  <entry>wal_sync_method</entry>
  <entry>fsync, fdatasync, open_sync, open_datasync</entry>
  <entry>Dépend de la plateforme</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Méthode utilisée pour forcer la mise à jour des WAL sur le disque. Les valeurs
  possibles sont FSYNC (fsync() est appelé à chaque validation), FDATASYNC
  (fdatasync() est appelé à chaque validation), OPEN_SYNC (écrit les fichiers
  WAL avec l'option O_SYNC d'open()) et OPEN_DATASYNC (écrit les fichiers WAL
  avec l'option O_DSYNC d'open()). Ces choix ne sont pas tous disponibles sur
  toutes les plateformes.
  </entry>
  <entry>
  Il s'agit de l'appel système utilisé pour synchroniser les WAL sur disque. La
  valeur par défaut a été réglée pour chaque système d'exploitation en fonction
  de la documentation du système. En revanche, aucun test comparatif n'a été mené.
  Il est possible que
  le changement de méthode accélère l'écriture sur une plateforme spécifique
  mais cela ne doit être tenté que si les ressources nécessaires à des tests
  comparatifs et de régression sont disponibles.
  </entry>
 </row>
 <row>
  <entry>full_page_writes</entry>
  <entry>True/false</entry>
  <entry>True</entry>
  <entry></entry>
  <entry></entry>
  <entry>
  <para>
   Lorsque cette option est activée, le serveur
   <productname>PostgreSQL</productname> écrit l'intégralité de chaque page
   disque dans le WAL lors de la première modification de la page après un point
   de contrôle.
  </para>
  <para>
   Ce paramètre est, à l'heure actuelle ignoré (traité comme toujours
   <literal>true</literal>). En effet, le désactiver peut entraîner des
   difficultés à récupérer d'un crash même en l'absence d'erreur matériel ou
   système. Cela sera réparé ou le paramètre abandonné dans les prochaines versions.
  </para>
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>wal_buffers</entry>
  <entry>4 à Int Max</entry>
  <entry>8</entry>
  <entry>Startup</entry>
  <entry></entry>
  <entry>
  indique le nombre de tampons de pages disque alloués dans la mémoire partagée
  pour les données du WAL. La valeur par défaut est 8. La valeur doit juste être
  assez grande pour contenir la quantité de données WAL engendrée par une
  transaction.
  </entry>
  <entry>
  L'accroissement de ce paramètre n'a que peu d'influence, même dans le cas de
  systèmes OLTP (On-Line Transaction Processing) chargés. Dans le cas de
  transactions conséquentes, on peut accroître ce paramètre par sécurité (de 16
  à 64) mais il est préférable de se concentrer sur checkpoint_segments.
  </entry>
 </row>
 <row>
  <entry>commit_delay</entry>
  <entry>0 - 100000</entry>
  <entry>0</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Indique le délai, en microsecondes, entre l'écriture d'une validation dans le
  tampon WAL et la purge du tampon sur disque. Un délai positif peut permettre
  la validation de plusieurs transactions avec un seul appel système fsync() si
  la charge système est suffisamment élevée pour que de nouvelles transactions
  soient prêtes pendant cet interval. Mais ce délai est perdu dans le cas
  contraire. Ainsi, le délai n'est exécuté que si au moins commit_siblings autres
  transactions sont actives au moment où le processus serveur a écrit sa
  validation.
  </entry>
  <entry>
  Ces deux paramètres sont configurés ensemble pour un environnement à fort
  volume de petites transactions. Activés, ils permettent de purger en même
  temps sur disques des transactions sans relation entre elles, qui autrement ne
  le seraient pas, avec à la clé un potentiel accroissement des performances.
  Néanmoins, c'est une manière de pallier l'attente de quelques millisecondes
  supplémentaires entre chaque transaction. Afin de tester l'amélioration des
  performances dans un cas précis, un point de départ peut être un commit_delay
  de 500 (soit ½ milliseconde).
  </entry>
 </row>
 <row>
  <entry>commit_siblings</entry>
  <entry>1 - 1000</entry>
  <entry>5</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Indique le nombre minimum de transactions concurrentes ouvertes avant
  l'exécution du délai COMMIT_DELAY. Plus la valeur est grande, plus la
  probabilité de valider une autre transaction pendant cet interval grandit.
  </entry>
  <entry>
  Si commit_delay est utilisé, ce paramètre peut être modifié en fonction de la
  longueur moyenne d'une transaction. Dans le cas de transactions courtes
  (requêtes insert/update d'une ligne) une valeur basse peut être utilisée
  puisque des validations simultanées sont possibles&nbsp;; s'il existe des
  transactions plus longues, la valeur peut être augmentée pour éviter
  d'inutiles commit_delay.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Points de contrôle</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>Échelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>checkpoint_segments</entry>
  <entry>1 à Int Max</entry>
  <entry>3</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Distance maximale entre deux points de contôle WAL automatiques, en segments de
  fichier journal (chaque segment représente normalement 16 Mo).
  </entry>
  <entry>
  C'est le paramètre qui permet d'ajuster le plus finement le comportement lors de
  mises à jour volumineuses, de chargements de données et de grande activité OLTP.
  Sur les systèmes où les écritures sont nombreuses, ce paramètre peut être
  poussé à 8, au moins&nbsp;; sur les systèmes où sont chargés de grandes
  volumétries (telles que le chargement de plusieurs Go de données), cela peut
  aller jusqu'à 128 (256 est
  la valeur utilisée lors des tests DBT2). Cela requiert toutefois une quantité
  non négligeable d'espace disque pour les fichiers xlog ( ( 2  x segments  + 1
  )  x 16Mo, pour être précis). Si les fichiers xlog ne sont pas sur un disque
  distinct de celui des données, l'amélioration est minime.
  </entry>
 </row>
 <row>
  <entry>checkpoint_timeout</entry>
  <entry>30 à 3600</entry>
  <entry>300</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Temps maximal entre deux points de contôle WAL automatiques, en secondes.
  </entry>
  <entry>
  Ce paramètre peut être augmenté fortement (jusqu'à 30 minutes) pour les
  chargements de gros volumes. Dans les autres cas, un réglage entre 3
  et 10 minutes représente une bonne échelle. Lorsque des bloquages d'écriture
  apparaissent, ce paramètre peut être augmenté. L'augmentation de la valeur du
  paramètre est actuellement limitée par l'impact croissant que cela engendre
  sur la synchronisation du disque.
  </entry>
 </row>
 <row>
  <entry>checkpoint_warning</entry>
  <entry>0 à Int Max</entry>
  <entry>0</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Un message est envoyé dans les journaux du serveur si la fréquence des points de contrôle
  engendrés par le remplissage des fichiers de segments de points de contrôle 
  est supérieure à ce temps, en secondes. Zéro désactive les alertes.
  </entry>
  <entry>
  Ce paramètre permet de détecter si checkpoint_segments doit être augmenté.
  Ce paramètre peut être activé pendant la phase de développement. Des alertes
  nombreuses dans les journaux incitent alors à accroître ce paramètre.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Archivage</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>Échelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>archive_command</entry>
  <entry>Commande shell</entry>
  <entry>''</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  <para>
  Indique la commande shell à exécuter pour archiver un segment terminé des
  séries de fichiers WAL. Une chaîne vide (défaut) désactive l'archivage des
  WAL. %p dans la chaîne est remplacé par le chemin absolu du fichier à archiver,
  %f par le nom du fichier seul. %% permet d'échapper un caractère %. Pour de
  plus amples informations, on peut se reporter à la <ulink url="http://docs.postgresqlfr.org/8.1/backup-online.html#backup-archiving-wal">section
  23.3.1, « Configurer l'archivage WAL »</ulink>..
  </para>
  <para>
  Cette commande doit impérativement ne retourner une valeur de sortie nulle
  qu'en cas de succès.
  </para>
  </entry>
  <entry>
  Ce paramètre active la nouvelle fonctionnalité de restauration à un instant
  donné (<foreignphrase>Point In Time Recovery, PITR</foreignphrase>) en
  fournissant une commande shell d'archivage (copie) des segments WAL finalisés
  vers une autre destination. De plus amples informations concernant leur
  utilisation sont disponibles dans les discussions sur la sauvegarde et la
  récupération.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Optimisation des requêtes</title>

<sect2>
<title>Méthodes de planification</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>Échelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>enable_bitmapscan</para>
  <para>enable_hashagg</para>
  <para>enable_hashjoin</para>
  <para>enable_indexscan</para>
  <para>enable_mergejoin</para>
  <para>enable_nestloop</para>
  <para>enable_seqscan</para>
  <para>enable_sort</para>
  <para>enable_tidscan</para>
  </entry>
  <entry>true, false</entry>
  <entry>true</entry>
  <entry>Exécution</entry>
  <entry>
  <para></para>
  <para></para>
  <para>-fi</para>
  <para>-fm</para>
  <para>-fn</para>
  <para>-fs</para>
  <para></para>
  <para>-ft*</para>
  <para></para>
  </entry>
  <entry>
  Active ou désactive l'utilisation par le planificateur de requêtes des types
  de plan respectifs. Par défaut, ils sont actifs. Cela permet de déboguer le
  planificateur de requêtes.
  </entry>
  <entry>
  <para>
  Ces options ne devraient être utilisées que pour tester les requêtes&nbsp;; il
  est courant, par exemple, de positionner &laquo;&nbsp;enable_seqscan = false&nbsp;&raquo;
  pour déterminer si le planificateur n'omet pas inutilement un index. Quoi
  qu'il en soit, seules des circonstances extraordinaires nécessitent qu'un
  de ces paramètres soit positionné à <foreignphrase>false</foreignphrase> dans
  le fichier de configuration. En fait, si cela devait arriver, c'est probablement que
  d'autres paramètres d'optimisation ont été négligés. 
  </para>
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Constantes de coût du planificateur</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>Échelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>effective_cache_size</entry>
  <entry>0 à Double</entry>
  <entry>1000</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
  Fournit à l'optimiseur une estimation de la taille efficace du cache
  disque (c'est-à-dire la partie du cache disque du noyau utilisée pour les
  fichiers de données PostgreSQL). Elle est mesurée en pages disque, chacune
  de 8 ko.
  </entry>
  <entry>
  Fournir au planificateur une hypothèse concernant la probabilité
  qu'un index ou une table particulière se trouve en mémoire a une forte
  influence sur le choix par le planificateur des index
  préférentiellement aux parcours séquentiels, et sur quelques autres
  structures de requête. De ce fait, positionner ce paramètre à environ
  2/3 de la RAM disponible permet de s'assurer que le planificateur est
  correctement informé. La plupart du temps, les DBA qui souhaitent désactiver
  enable_seqscan peuvent commencer par modifier ce paramètre.
  </entry>
 </row>
 <row>
  <entry>
  <para>random_page_cost</para>
  </entry>
  <entry>0 à Double</entry>
  <entry>4</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
  Fournit au planificateur une estimation du coût de récupération non
  séquentielle d'une page disque. Elle est mesurée en multiples du coût de
  récupération séquentielle d'une page. Plus grande est la valeur, plus grande
  est la probabilité d'un parcours séquentiel. Plus petite est la valeur, plus
  grande est la probabilité d'utilisation des index.
  </entry>
  <entry>
  <para>
  L'échelle utile se situe entre 2.0 et 4.0. La valeur la plus basse
  pour un CPU rapide, des E/S rapides et une base de données qui
  tient entièrement en mémoire. La valeur haute lorsque le CPU ou le disque sont
  limités, ou si les tables principales et leurs index ont une taille beaucoup
  plus grande que la RAM disponible (plusieurs fois). Ce paramètre ne doit
  jamais être positionné à une valeur inférieure à 1.5&nbsp;; si des problèmes
  avec certaines requêtes semblent obliger à étudier cette possibilité, c'est
  qu'il y a probablement d'autres paramètres à régler (effective_cache_size, par
  exemple).
  </para>
  <para>
  Lorsque l'effet de différents réglages est testé, il est important de tester
  plusieurs requêtes, et pas uniquement celle qui pose problème. 
  </para>
  </entry>
 </row>
 <row>
  <entry>
  <para>cpu_tuple_cost</para>
  <para>cpu_index_tuple_cost</para>
  <para>cpu_operator_cost</para>
  </entry>
  <entry>0 à Double</entry>
  <entry>
  <para>0.01</para>
  <para>0.001</para>
  <para>0.0025</para>
  </entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
  Fournit à l'optimiseur une estimation du coût CPU de traitement de chaque
  tuple, le parcours des index et le traitement de chaque élément
  where pendant la requête. La mesure s'effectue en fraction du coût de parcours
  séquentiel d'une page.
  </entry>
  <entry>
  Les coûts par défaut sont assez arbitraires&nbsp;; c'est pourquoi ils sont
  modifiables. Toutefois, personne, au sein de la communauté, n'a pu présenté de
  meilleurs coûts par défaut et, la plupart du temps, les modifications ont un
  effet inverse sur quelques requêtes. Ainsi, à moins de disposer de beaucoup de
  temps pour tester les requêtes, il est préférable de ne pas toucher à ces
  trois paramètres.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Optimisation génétique de requêtes (<foreignphrase>Genetic Estimate Query Optimizer, GEQO</foreignphrase>)</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>Échelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>geqo</entry>
  <entry>true, false</entry>
  <entry>true</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
  Active ou désactive l'optimisation génétique de requêtes. Il s'agit en fait
  d'un algorithme génétique de planification de requêtes qui tente d'éviter
  les recherches exhaustives. Activé par défaut. Divers paramètres GEQO_
  permettent d'en affiner le comportement.
  </entry>
  <entry>
  <para>
  GEQO a été introduit dans PostgreSQL 6.5 pour optimiser les requêtes de
  jointures qui utilisent trop de tables pour permettre une analyse exhaustive
  par le planificateur. Par définition, les requêtes GEQO sont plus lentes que
  les requêtes habituelles. Son but est d'intervenir quand la planification
  d'une requête peut réquisitionner toute la CPU.
  </para>
  <para>
  Lorsque l'application semble faire un usage immodéré de GEQO, il peut être
  intéressant d'écrire les requêtes en explicitant l'ordre de la jointure.
  L'utilisateur a, en effet, un pouvoir discriminant plus grand que l'algorithme.
  </para>
  </entry>
 </row>
 <row>
  <entry>geqo_threshold</entry>
  <entry>2 à Int Max</entry>
  <entry>11</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
  L'optimisation génétique de requête est utilisée pour planifier les requêtes
  qui contiennent au minimum ce nombre d'éléments dans la clause FROM. Une jointure
  compte pour un élément FROM. La valeur par défaut est 11. Pour les requêtes plus
  simples, il est généralement plus efficace d'utiliser une stratégie de
  planification déterministique, exhaustive. Ce paramètre contrôle également la
  façon dont l'optimiseur tente de fusionner les sous-requêtes de clause FROM
  avec la requête principale.
  </entry>
  <entry>
  S'il est possible d'augmenter légèrement ce seuil (jusqu'à 14) sur les machines à CPU
  rapides (dual Opteron par exemple), le conseil précédent de le monter à 20 se
  fondait sur un cas très particulier et a été depuis désapprouvé.
  </entry>
 </row>
 <row>
  <entry>
  <para>geqo_selection_bias</para>
  <para>geqo_pool_size</para>
  <para>geqo_effort</para>
  <para>geqo_generations</para>
  </entry>
  <entry>1.5-2.0</entry>
  <entry>
  <para>2.0</para>
  <para>0</para>
  <para>1</para>
  <para>0</para>
  </entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
  Divers paramètres d'affinage de l'algorithme d'optimisation génétique&nbsp;:
  la taille du <emphasis>pool</emphasis> correspond au nombre d'individus d'une population. L'échelle
  s'étend de 128 à 1024. Lorsqu'elle est positionnée à 0 (valeur par défaut), la
  taille du pool est obtenue par le calcul. Elle vaut alors 2^(QS+1), avec QS le nombre
  d'éléments FROM de la requête.
  L'<emphasis>effort</emphasis> est utilisé pour calculer une valeur par défaut pour les générations.
  L'échelle s'étend de 1 à 80, 40 étant la valeur par défaut.
  <emphasis>generations</emphasis> précise le nombre d'itérations de l'algorithme. Ce nombre
  doit être entier et positif. Si une valeur nulle est utilisée,
  <emphasis>generations</emphasis> est calculé. Le nombre vaut alors effort * Log2(PoolSize). 
  Le temps d'exécution de l'algorithme est approximativement proportionnel à la somme
  de la taille du <emphasis>pool</emphasis> et de <emphasis>generations</emphasis>. <foreignphrase>selection
  bias</foreignphrase> affine la sélectivité au sein d'une population. Ses
  valeurs vont de 1.5 à 2.0 (2.0 étant la valeur par défaut).
  <foreignphrase>random seed</foreignphrase> permet d'ajuster l'algorithme pour
  obtenir des résultats reproductibles. Positionné à -1, l'algorithme a un
  comportement non déterministe.
  </entry>
  <entry></entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Autres modificateurs de requête</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>Échelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>default_statistics_target</entry>
  <entry>1-1000</entry>
  <entry>10</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
  Positionne la cible par défaut des statistiques pour les tables dont la cible
  spécifique à la colonne n'a pas été positionnée à l'aide de <ulink
  url="http://docs.postgresqlfr.org/8.1/sql-altertable.html">ALTER TABLE SET
  STATISTICS</ulink>. 
  Plus la valeur est grande, plus long est le temps nécessaire à l'<ulink
  url="http://docs.postgresqlfr.org/8.1/sql-analyze.html">ANALYZE</ulink>.
  En revanche, la qualité des estimations du planificateur s'améliore.
  </entry>
  <entry>
  N'a aucun effet jusqu'au prochain ANALYZE. Il est en général déconseillé
  d'utiliser cette option pour améliorer l'ensemble des statistiques, sauf dans
  des cas particuliers&nbsp;; la collecte de statistiques sur de grandes
  colonnes (large text, par exemple) peut devenir excessive et donc
  contre-productive. Pour une base quasiment entièrement numérique, une
  augmentation modeste (jusqu'à 100, par exemple) peut être globalement
  positive&nbsp;; dans les autres cas, l'augmentation des statistiques sur des
  colonnes spécifiques peut être envisagée.
  </entry>
 </row>
 <row>
  <entry>constraint_exclusion</entry>
  <entry>True, false</entry>
  <entry>False</entry>
  <entry></entry>
  <entry></entry>
  <entry>
  <para>
  Active ou désactive l'utilisation par le planificateur des contraintes de
  table pour l'optimisation des requêtes.
  </para>
  <para>
   Lorsque ce paramètre est actif, le planificateur compare les conditions de la
   requête avec les contraintes <literal>CHECK</literal> de la table, et évite
   le parcours des tables dont les contraintes ne correspondent pas aux
   conditions.
   À l'heure actuelle, cela n'est valable que pour les parcours des tables fille
   d'un héritage. Par exemple&nbsp;:
<programlisting>
CREATE TABLE parent(clef integer, ...);
CREATE TABLE fils1000(check (clef between 1000 and 1999)) INHERITS(parent);
CREATE TABLE fils2000(check (clef between 2000 and 2999)) INHERITS(parent);
...
SELECT * FROM parent WHERE clef = 2400;
</programlisting>
   Lorsque l'exclusion par contrainte est active, cette commande
   <command>SELECT</command> ne parcourt pas <structname>fils1000</structname>.
   Cela peut améliorer les performances lorsque l'héritage est utilisé pour
   partitionner des tables.
  </para>
  <para>
  &Agrave; l'heure actuelle, <varname>constraint_exclusion</varname> est
  désactivé par défaut, du fait des risques de résultats incorrects lorsque les
  plans de requête sont mis en cache &mdash; si une contrainte de table est
  modifiée ou supprimée, le plan préalablement engendré peut devenir erroné, et
  aucun mécanisme n'est prévu pour forcer une replanification. (Cette carence
  sera peut-être corrigée dans une future version de
  <productname>PostgreSQL</productname>.) Une autre raison pour le garder
  inactif est le coût relativement élevé des contrôles de contraintes et, dans
  la plupart des cas, aucun gain ne sera obtenu. L'activation de ce paramètre
  n'est recommandée que lors de l'utilisation de tables partitionnées conçues
  pour utiliser cette fonctionnalité.
  </para>
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>from_collapse_limit</entry>
  <entry>0 à Int Max</entry>
  <entry>8</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
  Le planificateur fusionne les sous-requêtes dans la requête principale si la
  liste FROM résultante ne contient pas plus de ce nombre d'éléments. Une valeur
  inférieure réduit le temps de planification mais peut conduire à des plans de
  moindre qualité. 8 est la valeur par défaut. Il est préférable de conserver
  une valeur inférieure à GEQO_THRESHOLD.
  </entry>
  <entry>
  Comme pour la plupart des autres paramètres de cette section, il est
  préférable de ne changer sa valeur à l'exécution que pour certaines requêtes
  insolubles.
  </entry>
 </row>
 <row>
  <entry>join_collapse_limit</entry>
  <entry>1 à Int Max</entry>
  <entry>8</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
  Le planificateur résout les jointures internes (<foreignphrase>inner
  JOIN</foreignphrase>) explicites en listes d'éléments FROM si
  la liste résultante ne contient pas plus de ce nombre d'éléments. En général, ce
  paramètre a la même valeur que FROM_COLLAPSE_LIMIT. Le positionner à 1 empêche
  toute résolution des jointures internes, ce qui permet d'utiliser la syntaxe
  JOIN explicitement pour contrôler l'ordre de la jointure. Les valeurs
  intermédiaires permettent d'arbitrer entre le temps de planification et la
  qualité du plan.
  </entry>
  <entry>
  Cette option est conçue pour ceux qui préfèrent écrire leurs requêtes en
  utilisant la syntaxe des jointures explicites (e.g. &laquo;&nbsp;a join b
  using (1) join c using (2)&nbsp;&raquo;), mais apprécient néanmoins que le
  planificateur choisisse le meilleur ordre de jointure. En particulier, les
  gens migrant de MS SQL Server peuvent utiliser ce paramètre en le positionnant
  à une valeur modérément élevée, puisque ce genre de bases trie les jointures
  automatiquement. Comme vu plus haut, ce paramètre est maintenu à une valeur
  inférieure à geqo_threshold.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Options de journalisation et de débogage</title>

<sect2>
<title>Où journaliser ?</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>log_destination</entry>
  <entry>stderr, syslog, eventlog</entry>
  <entry>stderr</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  PostgreSQL accepte différentes méthodes de journalisation des messages du
  serveur, y compris stderr et syslog. Sous Windows, eventlog est également
  accepté. Ce paramètre est composé d'une liste, séparée par des virgules, de
  destinations souhaitées.
  </entry>
  <entry>
  Ce paramètre est analogue à l'ancien &laquo;&nbsp;syslog&nbsp;&raquo;, mais en
  plus compréhensible. Il supporte également
  l'&laquo;&nbsp;eventlog&nbsp;&raquo; Win32. Il est important de décider de la
  journalisation au moment de l'installation&nbsp;: soit avec syslog, ce qui
  facilite la gestion globale du système, soit vers un fichier propre à
  PostgreSQL, ce qui facilite le débogage du serveur de bases de données. Il est
  évidemment possible d'utiliser les deux mais la sortie est certainement
  excessive.
  </entry>
 </row>
 <row>
  <entry>redirect_stderr</entry>
  <entry></entry>
  <entry></entry>
  <entry></entry>
  <entry></entry>
  <entry>
  Cette option permet de capturer les messages envoyés sur stderr et de les
  rediriger vers les fichiers de journalisation. La
  journalisation vers stderr est souvent plus utile que la journalisation vers
  syslog puisque certains types de messages peuvent ne pas apparaître dans la
  sortie de syslog (les messages de défaillance de l'éditeur de liens dynamiques
  en est un bon exemple).
  </entry>
  <entry>
  C'est la nouvelle fonctionnalité de rotation de journaux.
  Elle remplace également l'option -l de la ligne de commande de pg_ctl et/ou
  la redirection de la ligne de commande. Elle ne s'applique que lorsque
  &laquo;&nbsp;stderr&nbsp;&raquo; est choisi plus haut. Les cinq options qui
  suivent ne s'appliquent que si cette option est positionnée. Le comportement
  de l'ancienne option -l peut être reproduit avec redirect_stderr et en
  annulant la rotation.
  </entry>
 </row>
 <row>
  <entry>log_directory</entry>
  <entry>répertoire</entry>
  <entry>pg_log</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Lorsque redirect_stderr est activé, cette option précise le répertoire de
  création des journaux. Il peut être précisé comme un chemin absolu ou relatif
  au répertoire de données du cluster.
  </entry>
  <entry>
  Par défaut, il s'agit du répertoire &laquo;&nbsp;pg_log&nbsp;&raquo; dans
  PGDATA, ce qui n'est probablement pas le meilleur choix lorsque d'autres
  disques/baies sont disponibles. /var/pg_log est fréquemment rencontré.
  </entry>
 </row>
 <row>
  <entry>log_filename</entry>
  <entry>Spécial</entry>
  <entry>postgresql-%Y-%m-%d_%H%M%S.log</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Lorsque redirect_stderr est activé, cette option définit les noms des
  journaux créés. La valeur est traitée comme un motif strftime, ce qui permet
  d'utiliser les caractères d'échappement % pour préciser des noms dépendant du
  temps. En l'absence de caractères d'échappement, PostgreSQL ajoute l'époque
  d'ouverture du nouveau fichier. Ainsi, dans le cas où log_filename est
  server_log, le nom de fichier est server_log.1093827753 pour un journal
  démarrant à 19:02:33 le dimanche 29 août 2004 (MST).
  </entry>
  <entry>
  Nom de fichier pour chaque segment de journal rotationnel, avec les caractères
  d'échappement. La valeur par défaut peut convenir à tout DBA. Si les journaux
  ne grandissent pas trop, il peut être plus simple de n'ajouter que la date.
  Une autre possibilité consiste à n'utiliser que l'heure ou le jour de la
  semaine pour restreindre le nombre de journaux. Voir log_truncate plus bas.
  </entry>
 </row>
 <row>
  <entry>log_rotation_age</entry>
  <entry>0 à Int Max</entry>
  <entry>1440</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Lorsque redirect_stderr est activé, cette option précise la durée de vie
  maximale d'un journal individuel. Après ce temps (en minutes), un nouveau
  fichier est créé. La positionner à zéro désactive la création de nouveaux journaux en
  fonction du temps.
  </entry>
  <entry>
  La valeur par défaut (24 heure) convient pour la plupart des installations.
  </entry>
 </row>
 <row>
  <entry>log_rotation_size</entry>
  <entry>0 à Int Max</entry>
  <entry>10240</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Lorsque redirect_stderr est activé, cette option précise la taille maximale
  d'un journal individuel. Lorsqu'il atteint cette taille (en Ko), un
  nouveau fichier est créé. La positionner à zéro désactive la création de
  fichiers en fonction de la taille.
  </entry>
  <entry>
  La valeur par défaut (10 Mo) convient pour la plupart des installations.
  </entry>
 </row>
 <row>
  <entry>log_truncate_on_rotation</entry>
  <entry>True, False</entry>
  <entry>False</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Lorsque redirect_stderr est activé, cette option impose à PostgreSQL de
  tronquer (réécrire), plutôt qu'ajouter, tout journal du même nom. Néanmoins,
  la troncature n'intervient que lorsqu'un nouveau fichier est ouvert par
  rotation fondée sur le temps, pas au démarrage ou lors d'une rotation fondée
  sur la taille du fichier. Lorsqu'elle est positionnée à False, l'adjonction
  est faite au fichier existant, dans tous les cas. Ainsi, utiliser cette option
  en combinaison avec un log_filename tel que postgresql-%H.log consiste à
  engendrer des journaux de 24 heures et à les réécrire cycliquement.
  </entry>
  <entry>
  Ce paramètre peut être combiné à log_filename, plus haut, pour créer un
  remplacement continu de 7 jours, 24 heures (ou 60 minutes) des journaux.
  </entry>
 </row>
 <row>
  <entry>syslog_facility</entry>
  <entry>LOCAL#</entry>
  <entry>LOCAL0</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Lorsque la journalisation utilise syslog, cette option précise la
  &laquo;&nbsp;fonction&nbsp;&raquo; de syslog à utiliser. LOCAL0, LOCAL1,
  LOCAL2, LOCAL3, LOCAL4, LOCAL5, LOCAL6 et LOCAL7 sont possibles. La valeur par
  défaut est LOCAL0. Plus d'informations dans la documentation du daemon syslog
  du système.
  </entry>
  <entry>
  Pas de recommandation particulière.
  </entry>
 </row>
 <row>
  <entry>syslog_ident</entry>
  <entry></entry>
  <entry>postgres</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Lorsque la journalisation utilise syslog, cette option précise le nom à
  utiliser pour identifier les messages de PostgreSQL dans le journal. Par
  défaut, il s'agit de <emphasis>postgres</emphasis>.
  </entry>
  <entry>
  Lorsque plusieurs instances de PostgreSQL tournent sur le même serveur, la
  personnalisation de cette chaîne permet d'identifier les serveurs.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Quand journaliser ?</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>client_min_messages</para>
  <para>log_min_messages</para>
  <para>log_min_error_statement</para>
  </entry>
  <entry>
  debug5, debug4, debug3, debug2, debug1,
  info, notice, warning, error, log, fatal, panic
  </entry>
  <entry>
  <para>notice</para>
  <para>notice</para>
  <para>panic</para>
  </entry>
  <entry>
  <para>Exécution</para>
  <para>Superutilisateur</para>
  <para>Superutilisateur</para>
  </entry>
  <entry>-d x</entry>
  <entry>
  <para>
  Permet de contrôler le détail des messages écrits dans les journaux du serveur
  et sur le client. Les valeurs valides sont DEBUG5, DEBUG4, DEBUG3, DEBUG2,
  DEBUG1, INFO, NOTICE, WARNING, ERROR, LOG, FATAL et PANIC. Les dernières
  envoient moins de détails dans les journaux. La valeur par défaut est NOTICE.
  LOG n'a pas le même comportement ici que dans CLIENT_MIN_MESSAGES.
  </para>
  <para>
  client_min_messages envoie vers la session cliente, log_min_messages
  vers le journal et log_min_error_statement contrôle l'enregistrement des
  erreurs SQL dans le journal.
  </para>
  </entry>
  <entry>
  <para>
  Les niveaux debug sont intéressant en phase de test des applications&nbsp;;
  DEBUG1 est un paramètre satisfaisant pour les problèmes généraux. NOTICE
  convient en environnement de production. Les environnements éprouvés peuvent
  passer à ERROR ou FATAL.
  </para>
  <para>
  Le coût en est une plus grande occupation du disque et un léger impact sur les
  performances (généralement inférieur à 5%). Néanmoins, l'impact sur les
  performances augmente considérablement si les journaux se situent sur le même
  disque/la même baie que les WAL de la base, puisqu'une forte sortie de
  débogage ampute l'activité E/S de la base. L'impact de DEBUG5 sur un système
  monodisque fortement transactionnel peut être très élevé. Cet avertissement
  vaut pour toutes les options de journalisation vues plus haut.
  </para>
  </entry>
 </row>
 <row>
  <entry>log_error_verbosity</entry>
  <entry>terse, default, verbose</entry>
  <entry>default</entry>
  <entry>Superutilisateur</entry>
  <entry></entry>
  <entry>
  Contrôle la quantité de détails écrit dans les journaux pour chaque message.
  Les valeurs valides sont TERSE, DEFAULT et VERBOSE. Chacune ajoute des champs
  aux messages affichés.
  </entry>
  <entry>
  Le paramétrage utilisé dépend de l'environnement de production et des outils
  de surveillance des journaux.
  </entry>
 </row>
 <row>
  <entry>log_min_duration_statement</entry>
  <entry>-1 à Int Max</entry>
  <entry>-1</entry>
  <entry>Superutilisateur</entry>
  <entry></entry>
  <entry>
  Définit le temps d'exécution minimum (en millisecondes) d'une requête avant
  sa journalisation. Toutes les requêtes SQL qui durent au moins aussi longtemps
  sont journalisées avec le temps d'exécution. Lorsque le paramètre est
  positionné à 0, toutes les requêtes, et leur temps d'exécution, sont écrites.
  -1 (valeur par défaut) désactive la fonctionnalité. Ainsi, positionné à 250,
  toutes les requêtes qui durent 250 ms ou plus sont journalisées. Ce paramètre
  peut être utilisé pour trouver les requêtes d'une application qui n'ont pas
  été optimisées.
  </entry>
  <entry>
  Ce paramètre est très utile pour l'optimisation secondaire de bases de
  données. Lorsque les problèmes d'indexation et de performance sont résolus,
  log_min_duration_statement permet de tracer les requêtes les plus lentes (et
  probablement celles qui ne fonctionnent toujours pas).
  </entry>
 </row>
 <row>
  <entry>silent_mode</entry>
  <entry>True, False</entry>
  <entry>False</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Le serveur tourne en silence. Lorsque cette option est positionnée, le serveur
  tourne en tâche de fond, les terminaux de contrôle étant dissociés (même
  résultat que lors de l'utilisation de l'option -S du postmaster). Les sorties
  standard et d'erreur du serveur sont redirigées vers /dev/null, tout message qui
  leur est envoyé est de fait perdu. Il est préférable de ne pas utiliser cette
  option si ni la journalisation par syslog, ni redirect_stderr ne sont activés,
  les messages d'erreur n'étant alors plus visibles.
  </entry>
  <entry>
  La documentation couvre assez bien ce sujet.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Que journaliser ?</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>debug_print_parse</para>
  <para>debug_print_rewritten</para>
  <para>debug_print_plan</para>
  <para>debug_pretty_print</para>
  </entry>
  <entry>true, false</entry>
  <entry>false</entry>
  <entry></entry>
  <entry></entry>
  <entry>
  Ces drapeaux activent la sortie d'informations de débogage vers les journaux du
  serveur. Pour chaque requête exécutée, écrit soit le texte de la requête,
  soit l'arbre syntaxique résultant, soit la sortie du rédacteur de requête soit
  le plan d'exécution. DEBUG_PRETTY_PRINT indente les affichages pour faciliter la
  lecture, au prix d'une écriture plus longue. 
  </entry>
  <entry>
  Utile pour détecter les requêtes lentes, sous réserve de réussir à parcourir
  un journal volumineux. Particulièrement utile dans un mode interactif de
  surveillance des journaux lorsque les procédures stagnent&nbsp;; il est
  parfois possible de voir à quel endroit la procédure stagne (parfois, cela
  n'est pas possible, parce que le journal attend une information de la base).
  </entry>
 </row>
 <row>
  <entry>
  <para>log_connections</para>
  <para>log_disconnections</para>
  </entry>
  <entry>true, false</entry>
  <entry>false</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  log_connections envoie une ligne au journal du serveur détaillant toute
  connexion réussie. log_disconnections envoie une ligne similaire à
  log_connections au journal du serveur à la fin de la session. Il ajoute
  également la durée de la session.
  </entry>
  <entry>
  Cette journalisation est essentielle pour toute application sécurisée.
  </entry>
 </row>
 <row>
  <entry>log_duration</entry>
  <entry>True, False</entry>
  <entry>False</entry>
  <entry>Superutilisateur</entry>
  <entry></entry>
  <entry>
  La durée de toute instruction réalisée qui satisfait log_statement est
  enregistrée. Il est recommandé, lorsque cette option est utilisée sans syslog,
  d'enregistrer également le PID ou l'ID de session à l'aide de log_line_prefix.
  Cela permet ainsi de faire le lien entre l'instruction et la durée à l'aide du
  PID ou de l'ID de session.
  </entry>
  <entry>
  Essentiel lors de l'optimisation de premier niveau de la base. L'outil PQA de
  traitement de journaux, par exemple, nécessite log_statement et log_duration
  pour extraire la liste des requêtes les plus lentes et les plus fréquentes.
  Ne prend effet que si log_statement est positionné au minimum à
  &laquo;&nbsp;DDL&nbsp;&raquo;.
  </entry>
 </row>
 <row>
  <entry>log_line_prefix</entry>
  <entry>Spécial</entry>
  <entry>''</entry>
  <entry>Superutilisateur</entry>
  <entry></entry>
  <entry>
  Chaîne de style printf écrite au début de chaque ligne de journal. Par défaut,
  une chaîne vide. Tout caractère d'échappement reconnu est remplacé comme
  indiqué dans la documentation - tout autre caractère qui ressemblerait à un
  caractère d'échappement est ignoré. Les autres caractères sont directement
  copiés dans la ligne du journal. Certains caractères d'échappement ne sont
  interprétés que par les processus de session et ne s'appliquent pas aux
  processus d'arrière-plan tel que postmaster. Syslog produit ces propres
  estampilles temporelles et ID de processus. Il est alors préférable de ne pas
  utiliser ces caractères en combinaison avec syslog.
  </entry>
  <entry>
  <para>
  Remplace log_pid, log_source_port, log_timestamp et un ensemble de techniques
  de journalisation maison pour fournir le niveau de détails souhaité pour
  chaque ligne du journal.
  </para>
  <para>
  Ainsi, pour diagnostiquer un problème de verrou mort, on peut utiliser
  &laquo;&nbsp;%t %p %u %d %x&nbsp;&raquo; pour récupérer l'information
  intéressante. Il ne fait aucun doute que les futurs outils de journalisation
  contiendront les formats spécifiques à ces informations mais, à ce jour,
  aucun ne le propose.
  </para>
  </entry>
 </row>
 <row>
  <entry>log_statement</entry>
  <entry>none, ddl, mod, all</entry>
  <entry>False</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  <para>
  Contrôle les instructions SQL à journaliser. Les valeurs valides sont
  <literal>none</literal>,
  <literal>ddl</literal>, <literal>mod</literal> et <literal>all</literal>.
  <literal>ddl</literal> enregistre toutes les
  commandes de définition des données, telles que <literal>CREATE</literal>,
  <literal>ALTER</literal> et <literal>DROP</literal>.
  <literal>mod</literal> enregistre toutes les instructions
  <literal>ddl</literal> ainsi que <literal>INSERT</literal>,
  <literal>UPDATE</literal>, <literal>DELETE</literal>,
  <literal>TRUNCATE</literal> et <literal>COPY FROM</literal>.
  <literal>PREPARE</literal> et <literal>EXPLAIN ANALYZE</literal> sont
  également enregistrées si les commandes qu'elles contiennent sont d'un type
  approprié.
  </para>
  <para>
  Seuls les superutilisateurs peuvent modifier ce paramètre.
  </para>
  <note>
  <para>
   L'instruction <command>EXECUTE</command> n'est pas considérée comme une
   instruction <literal>ddl</literal> ou <literal>mod</literal>. Les
   instructions qui engendrent des erreurs de syntaxe ne sont pas journalisées.
   Pour ce faire, il faut positionner <varname>log_min_error_statement</varname>
   à <literal>error</literal>.
  </para>
  <para>
   Lorsqu'une fonction est définie dans le langage serveur
   <application>PL/pgSQL</application>, toute requête exécutée par la fonction
   n'est enregistrée que la première fois qu'elle est appelée au cours d'une
   session. Cela tient au fait que <application>PL/pgSQL</application> conserve
   un cache des plans de requête produit pour les instructions SQL de la
   fonction.
  </para>
  </note>
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>log_hostname</entry>
  <entry>true, false</entry>
  <entry>false</entry>
  <entry>Redémarrage</entry>
  <entry></entry>
  <entry>
  Par défaut, les journaux de connexions ne présentent que l'adresse IP de
  provenance de la connexion. En activant cette option, le nom de l'hôte est
  également présenté. Mais, en fonction du paramétrage de la résolution de noms,
  cela peut induire une baisse non négligeable des performances.
  </entry>
  <entry></entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Statistiques</title>

<sect2>
<title>Journalisation des statistiques</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>log_parser_stats</para>
  <para>log_planner_stats</para>
  <para>log_executor_stats</para>
  <para>log_statement_stats</para>
  </entry>
  <entry>true, false</entry>
  <entry>false</entry>
  <entry>Superutilisateur</entry>
  <entry>
  <para>-tpa</para>
  <para>-tpl</para>
  <para>-te</para>
  <para>-s</para>
  </entry>
  <entry>
  Pour chaque requête, les statistiques de performance du module respectif sont
  écrites dans le journal du serveur. C'est un outil d'analyse redoutable.
  log_statement_stats fournit l'ensemble des statistiques de l'instruction, les
  autres des statistiques par état. log_statement_stats ne peut être activé en
  même temps que les autres options. Toutes sont désactivées par défaut. Seuls
  les superutilisateurs peuvent désactiver ces options si elles sont activées
  par l'administrateur.
  </entry>
  <entry>
  En l'absence d'un outil performant d'analyse des journaux engendrés par ces
  options, le volume important des journaux en limite l'utilité.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Statistiques de requête et d'index</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>stats_start_collector</entry>
  <entry>true, false</entry>
  <entry>true</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
   Contrôle le démarrage par le serveur du processus de collecte des
   statistiques.
  </entry>
  <entry>
   Sauf si les quelques 5% de surcroit d'activité créés par le collecteur de
   statistiques sont critiques pour le système, il n'est pas inutile d'activer
   au minimum start_collector et stats_command_string.
  </entry>
 </row>
 <row>
  <entry>stats_reset_on_server_start</entry>
  <entry></entry>
  <entry>true</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
   Activé, les statistiques sont réinitialisées au redémarrage du
   serveur.
   Désactivé, les statistiques sont cumulatives.
  </entry>
  <entry>
  Si les redémarrages de la base font partie du plan de maintenance, il est
  probablement utile de désactiver cette option&nbsp;; cela permet d'accumuler
  une quantité utile de statistiques. Dans le cas contraire, la laisser active.
  </entry>
 </row>
 <row>
  <entry>stats_command_string</entry>
  <entry></entry>
  <entry>false</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Active la collecte de statistiques sur la commande en cours d'exécution, avec
  sa date de démarrage, pour chaque session. Cette option est désactivée par
  défaut. Même activée, l'information qu'elle produit n'est pas visible par tous
  les utilisateurs, mais uniquement par les superutilisateurs et l'utilisateur
  propriétaire de la session. Cela ne représente donc pas un risque de sécurité.
  Ces données sont accessibles au travers de la vue système pg_stat_activity.
  </entry>
  <entry>
  Cette option permet d'utiliser la vue pg_stat_activity pour analyser les
  requêtes en cours. L'aide apportée à la résolution de problèmes est
  inestimable pour la plupart des DBA.
  </entry>
 </row>
 <row>
  <entry>stats_row_level</entry>
  <entry></entry>
  <entry>false</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Active la collecte des statistiques d'activité de la base au niveau des lignes.
  Désactivée par défaut, cette option produit des données accessibles par les
  vues systèmes de la famille pg_stat et pg_statio.
  </entry>
  <entry>
  Cette option active la collecte de quelques statistiques sur l'utilisation des
  index et tables. D'une importance vitale lors de l'optimisation initiale de la
  base, elle l'est beaucoup moins en production et peut alors être désactivée.
  </entry>
 </row>
 <row>
  <entry>stats_block_level</entry>
  <entry></entry>
  <entry>false</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  Active la collecte des statistiques d'activité de la base au niveau des blocs.
  Désactivée par défaut.
  </entry>
  <entry>
  Fournit des statistiques de niveau bloc, utiles pour surveiller les E/S et les
  performance du cache. Cela permet de configurer les variables système et
  matériel. Une fois encore, peut être activée lors des tests et désactivée en
  production.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Nettoyage automatique</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>autovacuum</entry>
  <entry>True, false</entry>
  <entry>False</entry>
  <entry>Redémarrage</entry>
  <entry></entry>
  <entry>
   Contrôle le démarrage par le serveur du sous-processus d'auto-nettoyage.
   <varname>stats_start_collector</varname> et
   <varname>stats_row_level</varname> doivent également être activés pour ce
   démarrage.
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>autovacuum_naptime</entry>
  <entry></entry>
  <entry>60</entry>
  <entry>Redémarrage</entry>
  <entry></entry>
  <entry>
   Précise le délai entre deux tours d'activité pour le sous-processus
   d'autonettoyage. &Agrave; chaque tour, le sous-processus examine une base de
   données et lance les commandes <command>VACUUM</command> et
   <command>ANALYZE</command> pour les tables de la base. Le délai se mesure en
   secondes.
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>autovacuum_vacuum_threshold</entry>
  <entry></entry>
  <entry>1000</entry>
  <entry>Redémarrage</entry>
  <entry></entry>
  <entry>
   Précise le nombre minimum de tuples actualisés ou supprimés au sein d'une
   table pour déclencher un <command>VACUUM</command>. Ce paramètre peut être
   surchargé pour des tables particulières par les entrées de
   <structname>pg_autovacuum</structname>.
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>autovacuum_analyze_threshold</entry>
  <entry></entry>
  <entry>500</entry>
  <entry>Restart</entry>
  <entry></entry>
  <entry>
   Précise le nombre minimum de tuples insérés, actualisés ou supprimés
   au sein d'une table pour déclencher un <command>ANALYZE</command>. Ce
   paramètre peut être surchargé pour des tables particulières par les entrées
   de <structname>pg_autovacuum</structname>.
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>autovacuum_vacuum_scale_factor</entry>
  <entry></entry>
  <entry>0.4</entry>
  <entry>Redémarrage</entry>
  <entry></entry>
  <entry>
   Précise une fraction de la taille de la table à ajouter à
   <varname>autovacuum_vacuum_threshold</varname> lors de la décision de
   déclencher un <command>VACUUM</command>. Ce paramètre peut être surchargé
   pour des tables particulières par les entrées de
   <structname>pg_autovacuum</structname>.
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>autovacuum_analyze_scale_factor</entry>
  <entry></entry>
  <entry>0.2</entry>
  <entry>Redémarrage</entry>
  <entry></entry>
  <entry>
   Précise une fraction de la taille de la table à ajouter à
   <varname>autovacuum_analyze_threshold</varname> lors de la décision de
   déclencher un <command>ANALYZE</command>. Ce paramètre peut être surchargé
   pour des tables particulières par les entrées de
   <structname>pg_autovacuum</structname>.
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>autovacuum_vacuum_cost_delay</entry>
  <entry></entry>
  <entry>-1</entry>
  <entry>Restart</entry>
  <entry></entry>
  <entry>
   Précise la valeur du délai de coût utilisée lors des opérations automatiques
   de <command>VACUUM</command>. Si -1 est précisé, la valeur normale de
   <varname>vacuum_cost_delay</varname> est utilisée. Ce paramètre peut être
   surchargé pour des tables particulières par les entrées de
   <structname>pg_autovacuum</structname>.
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>autovacuum_vacuum_cost_limit</entry>
  <entry></entry>
  <entry>-1</entry>
  <entry>Restart</entry>
  <entry></entry>
  <entry>
   Précise la valeur limite de coût utilisée lors des opérations automatiques
   de <command>VACUUM</command>. Si -1 est précisé (valeur par défaut), la
   valeur normale de <varname>vacuum_cost_delay</varname> est utilisée. Ce
   paramètre peut être surchargé pour des tables particulières par les entrées
   de <structname>pg_autovacuum</structname>.
  </entry>
  <entry>
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect1>

<sect1>
<title>Valeurs par défaut des connexions client</title>

<sect2>
<title>Comportement des instructions</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>search_path</entry>
  <entry>path</entry>
  <entry>'$user,public'</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
  <para>
   Cette variable précise l'ordre de consultation des schémas lorsqu'il est fait
   référence à un objet (table, type de données, fonction...) par un nom simple,
   sans composante schéma. Lorsque plusieurs objets portent le même nom dans
   différents schémas, le premier trouvé dans l'ordre du chemin est utilisé.
   Il ne peut être fait référence à un objet qui ne se trouve dans aucun des 
   schémas du chemin qu'en qualifiant son nom avec le schéma qui le contient
   (schema.objet).
  </para>
  <para>
   La valeur de search_path est une liste de noms de schéma séparés par des
   virgules. Si un des éléments de la liste est la valeur spéciale $user, alors
   le schéma dont le nom correspond à la valeur retournée par SESSION_USER est
   utilisé s'il existe (sinon $user est ignoré). Le schéma du catalogue
   système, pg_catalog, est toujours parcouru, qu'il soit ou non mentionné dans
   le chemin.
  </para>
  </entry>
  <entry>
  <para>
   Cette variable doit être modifiée après la création du schéma de la base, mais
   pas nécessairement dans ce fichier. La définition, par exemple, de 
   search_path par utilisateur se fait à l'aide de la commande <ulink
   url="http://docs.postgresqlfr.org/8.1/sql-alteruser.html">ALTER USER</ulink>, et
   non par le fichier de configuration générale.
  </para>
  <para>
   Lorsque plusieurs schémas doivent être visibles par tous les utilisateurs, il
   est nécessaire de les ajouter tous au search_path du fichier postgresql.conf.
  </para>
  </entry>
 </row>
 <row>
  <entry>default_tablespace</entry>
  <entry></entry>
  <entry>''</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
   Cette variable précise le tablespace par défaut dans lequel seront créés tous
   les objets (tables et index) créés à l'aide d'une commande CREATE qui
   n'explicite pas le tablespace. La valeur peut être le nom d'un tablespace ou
   une chaîne vide signifiant l'utilisation du tablespace par défaut de la base
   utilisée. Si la valeur ne correspond à aucun tablespace, PostgreSQL utilise
   automatiquement le tablespace par défaut de la base.
  </entry>
  <entry>
   Il est peu vraisemblable que le tablespace soit précisé dans le fichier de
   configuration. La documentation de la commande <ulink
   url="http://docs.postgresqlfr.org/8.1/sql-alterdatabase.html">ALTER
   DATABASE</ulink> explique comment préciser le tablespace d'une base.
  </entry>
 </row>
 <row>
  <entry>check_function_bodies</entry>
  <entry>True, False</entry>
  <entry>True</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
   Ce paramètre est normalement positionné à true. Dans le cas contraire, la
   validation du corps d'une fonction lors de sa création avec CREATE FUNCTION
   est désactivée. Cela peut s'avérer utile pour éviter les problèmes (références,
   par exemple) lors de la restauration des définitions de fonction à
   partir d'une sauvegarde.
  </entry>
  <entry>
   Comme pour les autres paramètres, il ne faut pas le positionner dans le
   fichier de configuration dans le cadre d'une utilisation générale.
  </entry>
 </row>
 <row>
  <entry>default_transaction_isolation</entry>
  <entry>read committed, serializable</entry>
  <entry>'read committed'</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
   Chaque transaction SQL dispose d'un niveau d'isolation. Il peut être 
   &laquo;&nbsp;read uncommitted&nbsp;&raquo; (lecture des entrées non validées), 
   &laquo;&nbsp;read committed&nbsp;&raquo; (lecture des entrées validées), 
   &laquo;&nbsp;repeatable read&nbsp;&raquo; (lecture reproductible) ou
   &laquo;&nbsp;serializable&nbsp;&raquo; (sérialisable). Ce paramètre contrôle
   le niveau d'isolation par défaut de chaque nouvelle transaction. La valeur
   par défaut est &laquo;&nbsp;read committed&nbsp;&raquo;.
  </entry>
  <entry>
   La valeur par défaut, ici, est en accord avec le comportement MVCC.
   &laquo;&nbsp;serializable&nbsp;&raquo; est surtout utile lors du lancement de
   procédures longues et éventuellement successives, ou lorsqu'une mise à jour
   entraîne un risque conséquent et régulier de verrou mort. En environnement
   fortement concurrentiel (nombreux utilisateurs), son utilisation peut
   avoir des conséquences sur les performances puisque de nombreuses
   transactions doivent attendre la fin de la transaction sérialisée. Dans le
   cas d'une base mono-utilisateur, cela n'a que peu de conséquence. Dans tous
   les cas, il est préférable de positionner ce paramètre à l'exécution plutôt
   que dans le fichier de configuration.
  </entry>
 </row>
 <row>
  <entry>default_transaction_read_only</entry>
  <entry>true, false</entry>
  <entry>false</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
   Une transaction SQL en lecture seule ne peut modifier une table temporaire.
   Ce paramètre contrôle le statut de lecture seule par défaut de toute nouvelle
   transaction. Par défaut à false (lecture/écriture).
  </entry>
  <entry>
   &Eacute;ventuellement utile pour les connexions individuelles. En revanche,
   le positionner dans le fichier de configuration n'est pas d'un grand intérêt, 
   à moins de vouloir forcer un grand nombre d'utilisateurs en mode lecture
   seule (à supposer également qu'ils ne sachent pas se servir de la commande
   SET).
  </entry>
 </row>
 <row>
  <entry>statement_timeout</entry>
  <entry>0 à Int Max</entry>
  <entry>0</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
   Interrompt toute instruction qui dure plus que le nombre de millisecondes
   précisées. La valeur zéro désactive le chronomètre.
  </entry>
  <entry>
   Conçu pour faciliter le fonctionnement d'une application lorsque les
   utilisateurs peuvent exécuter des requêtes qui monopolisent la CPU pendant
   plusieurs minutes, telles que les applications qui autorisent les requêtes
   dynamiques. Positionner ce paramètre à une valeur finie peut empêcher les
   utilisateurs de monopoliser les ressources mais il faut alors gérer
   l'exception, qui est la même erreur que &laquo;&nbsp;query cancelled by
   user&nbsp;&raquo; (requête annulée par l'utilisateur).
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Locale et formatage</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>datestyle</para>
  <para>timezone</para>
  <para>australian_timezones</para>
  </entry>
  <entry></entry>
  <entry>
  <para>'iso, us'</para>
  <para>unknown</para>
  <para>false</para>
  </entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  <para>
   Positionne le format d'affichage des dates et les règles d'interprétation des
   dates ambigues en entrée .
  </para>
  <para>
   Positionne le fuseau horaire pour l'affichage et l'interprétation des
   estampilles temporelles. Le comportement par défaut utilise le fuseau horaire
   fourni par le système.
  </para>
  <para>
   Positionné à true, CST, EST et SAT sont interprétés comme des fuseaux
   horaires australiens et non comme des fuseaux North American Central/Eastern
   et samedi (Saturday).
  </para>
  </entry>
  <entry>
   Permet de modifier l'affichage par défaut des dates et l'interprétation des
   fuseaux horaires pour coller aux standard et à la
   localisation de l'utilisateur.
  </entry>
 </row>
 <row>
  <entry>extra_float_digits</entry>
  <entry>-14 à 2</entry>
  <entry>0</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
   Ce paramètre permet d'ajuster le nombre de chiffres affichés pour les valeurs
   à virgule flottante, ce qui inclut les float4, float8 et les types de données
   géométriques. La valeur du paramètre est ajoutée au nombre standard de
   chiffres (FLT_DIG ou DBL_DIG, selon les cas). La valeur 2, la plus haute
   possible, permet d'inclure les chiffres partiellement significatifs&nbsp;;
   cela est particulièrement utile pour copier des flottants dont la
   restauration doit être exacte. Les valeurs négatives permettent de supprimer
   les chiffres non souhaités.
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>
  <para>lc_messages</para>
  <para>lc_monetary</para>
  <para>lc_time</para>
  <para>lc_numeric</para>
  </entry>
  <entry>Dépendant du système</entry>
  <entry>Special</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
   Positionne la locale à utiliser pour le formatage des messages d'erreur, des
   valeurs monétaires, des valeurs de temps et des valeurs numériques. Les
   valeurs acceptables dépendent du système. Lorsque la valeur est constituée
   d'une chaîne vide (valeur par défaut),
   la valeur est héritée de l'environnement d'exécution du serveur.
  </entry>
  <entry>
   Ces paramètres sont positionnés par le script initdb lors de la création du
   répertoire PGDATA. Correspond en général à la langue, la monnaie... de
   l'utilisateur. Pour certaines installations, la locale 'C' est utilisée.
  </entry>
 </row>
 <row>
  <entry>client_encoding</entry>
  <entry>Dépendant du système d'exploitation</entry>
  <entry>sql_ascii</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
   Positionne le codage côté client pour les jeux de caractères multi-octet.
   Par défaut, le codage de la base est utilisé.
  </entry>
  <entry>
   Généralement ignoré au profit du codage de la base. Ne doit être positionné par
   client que dans les applications multilingues, ce qui requiert un effort
   considérable de gestion des différents codages.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Autres valeurs par défaut</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>explain_pretty_print</entry>
  <entry>True,False</entry>
  <entry>False</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
   Règle le format de sortie d'EXPLAIN VERBOSE, indenté ou non, pour l'affichage
   des arbres de requête détaillés.
  </entry>
  <entry>
   Lors de l'utilisation de EXPLAIN VERBOSE, pretty_print est essentiel à la
   facilité de lecture. Le paramètre peut alors être positionné à true.
   Quoiqu'il en soit, VERBOSE est rarement nécessaire.
  </entry>
 </row>
 <row>
  <entry>dynamic_library_path</entry>
  <entry>path</entry>
  <entry>'$libdir'</entry>
  <entry>Superutilisateur</entry>
  <entry></entry>
  <entry>
   Si un module chargeable dynamiquement doit être ouvert et que le nom ne
   précise pas le répertoire (i.e. le nom ne contient pas de slash), le système
   recherche le fichier dans ce chemin. Le nom utilisé est celui précisé par la
   commande CREATE FUNCTION ou LOAD.
  </entry>
  <entry>
   Peut être positionné par le superutilisateur.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Gestion des verrous</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>deadlock_timeout</entry>
  <entry>1 à Int Max</entry>
  <entry>1000</entry>
  <entry>No</entry>
  <entry></entry>
  <entry>
   Temps d'attente, en millisecondes, avant de vérifier qu'un verrou est en
   condition de verrou mort. La recherche de verrou mort étant relativement lente,
   le serveur ne la lance pas à chaque fois qu'il attend le relâchement d'un verrou. Les auteurs
   estiment (de façon optimiste ?) que les verrous morts ne sont pas légion en
   production et de fait patientent quelques instants après la pose d'un verrou 
   avant de rechercher les verrous morts. L'augmentation de cette valeur réduit
   le temps perdu à rechercher inutilement les verrous morts, mais retarde la
   découverte des erreurs de verrous réellement morts. La valeur par défaut est
   1000 (i.e., une seconde), ce qui est probablement la plus petite valeur
   acceptable en production. Sur un serveur en charge, cette valeur peut être
   augmentée. Dans l'idéal, la valeur dépasse le temps habituel d'une
   transaction, de façon à accroître les chances que le verrou soit relâcher
   avant que le serveur ne recherche les verrous morts.
  </entry>
  <entry>
   Pas de recommandations autres que celles dans la documentation.
  </entry>
 </row>
 <row>
  <entry>max_locks_per_transaction</entry>
  <entry>10 à Int Max</entry>
  <entry>64</entry>
  <entry>No</entry>
  <entry></entry>
  <entry>
   La table partagée de verrous est dimensionnée d'après l'hypothèse qu'au
   maximum max_locks_per_transaction * max_connections objets distincts sont
   verrouillés au même moment. La valeur par défaut, 64, qui a prouvé au fil des
   ans qu'elle était suffisante, peut toutefois être augmenté lorsque différents
   clients attaquent de nombreuses tables au sein d'une même transaction.
   L'option ne peut être positionnée qu'au démarrage du serveur.
  </entry>
  <entry>
   Parfois, il peut être nécessaire d'augmenter ce paramètre pour les bases à
   schéma étoilé, qui contiennent des centaines de tables parcourues. Il est
   préférable, toutefois, d'agir en réponse à une erreur plutôt que de chercher à
   l'anticiper.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Compatibilité entre versions et plateformes</title>

<sect2>
<title>Versions antérieures de PostgreSQL</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>add_missing_from</entry>
  <entry>true, false</entry>
  <entry>true</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
   Autorise le planificateur à &laquo;&nbsp;ajouter les clauses FROM
   manquantes&nbsp;&raquo; (add missing from clause) lorsqu'une table est
   omise dans la requête. Sera positionné à false dans les prochaines versions.
   Lorsqu'il est positionné à true, les tables référencées par une requête sont
   automatiquement ajoutées à la clause FROM si elles n'y figurent pas déjà. La
   valeur par défaut, true, assure la compatibilité avec les versions
   précédentes de PostgreSQL. Toutefois, ce comportement ne respecte pas le
   standard SQL. De plus, de nombreuses personnes déteste cette option parce
   qu'elle risque de masquer des erreurs (référencer une table au lieu de son
   alias, par exemple). Positionné à false, il permet de respecter le
   comportement prescrit par le standard, à savoir rejeter les références aux
   tables qui n'apparaissent pas dans la clause FROM.
  </entry>
  <entry>
   Toujours positionner ce paramètre à false. Positionné à true, la moindre
   erreur de référence d'un alias de table peut résulter en une jointure non
   contrainte et conduire à une requête folle qui va monopoliser les ressources
   système. Heureusement, il sera positionné à false par défaut dans les
   prochaines versions.
  </entry>
 </row>
 <row>
  <entry>regex_flavor</entry>
  <entry>advanced, extended, basic</entry>
  <entry>advanced</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
   La &laquo;&nbsp;flavor&nbsp;&raquo; d'une expression rationnelle peut être
   positionnée à advanced (avancée), extended (étendue) ou basic (basique). La
   valeur par défaut est advanced. L'option extended peut être utile pour une
   compatibilité exacte avec les versions pré-7.4 de PostgreSQL.
  </entry>
  <entry>
   Le réglage fait ici correspond aux habitudes de l'utilisateur concernant le
   comportement des expressions rationelles. Les programmeurs Perl, Java ou
   d'autres langages sont plus familier avec advanced&nbsp;; les autres
   utilisateurs peuvent préférer la syntaxe moins complexe de basic. Ce paramètre
   ne devra pas être changé après des tests concluants sur la base puisqu'il
   peut influer sur les résultats des requêtes.
  </entry>
 </row>
 <row>
  <entry>sql_inheritance</entry>
  <entry>true, false</entry>
  <entry>true</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
   Contrôle la sémantique de l'héritage, en particulier l'inclusion par défaut
   ou non des tables filles par diverses commandes. Elles ne l'étaient pas dans
   les versions antérieures à la 7.1. Pour retrouver l'ancien comportement, ce
   paramètre est positionné à off. Toutefois, sur le long terme, il est
   préférable de modifier les applications afin d'utiliser le mot-clé ONLY pour
   exclure les tables filles.
  </entry>
  <entry>
   Nécessaire uniquement pour les personnes effectuant une montée de version
   depuis des applications 7.0.
  </entry>
 </row>
 <row>
  <entry>backslash_quote</entry>
  <entry>on, off, safe_encoding</entry>
  <entry>safe_encoding</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
  <para>
   Contrôle si un guillemet simple peut être représenté par <literal>\'</literal>
   dans une chaîne littérale. Il est préférable, et d'après le standard
   SQL, de le représenter en le doublant (<literal>''</literal>) bien que
   <productname>PostgreSQL</productname> accepte également, pour des raisons
   historiques, <literal>\'</literal>. Toutefois, l'utilisation de
   <literal>\'</literal> engendre un risque de sécurité du fait du codage de
   certains clients. Il existe, en effet, des codages multioctets pour lesquels
   le dernier octet est numériquement équivalent au <literal>\</literal> ASCII.
   Si le code client n'effectue pas correctement l'échappement, une attaque par
   injection de SQL est possible. Ce risque peut être évité en interdisant
   l'acceptation par le serveur des requêtes contenant un guillemet simple
   échappé par un antislash. Les valeurs autorisées de
   <varname>backslash_quote</varname> sont <literal>on</literal> (autorise
   toujours <literal>\'</literal>), <literal>off</literal> (toujours rejeté) et 
   <literal>safe_encoding</literal> (autorisé uniquement si le codage client
   n'autorise pas les <literal>\</literal> ASCII dans un caractère multioctet).
   <literal>safe_encoding</literal> est le réglage par défaut.
  </para>
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>default_with_oids</entry>
  <entry>True, false</entry>
  <entry>False</entry>
  <entry>Exécution</entry>
  <entry></entry>
  <entry>
   Contrôle l'incusion de colonnes OID dans les tables nouvellement créées par
   CREATE TABLE et CREATE TABLE AS lorsque ni WITH OIDS ni WITHOUT OIDS ne sont
   précisés. Détermine également si les OID doivent être inclus dans les tables
   créées par SELECT INTO. La valeur par défaut sous PostgreSQL 8.1.0 est false
   contrairement aux versions précédentes.
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>escape_string_warning</entry>
  <entry></entry>
  <entry></entry>
  <entry></entry>
  <entry></entry>
  <entry>
  <para>
   Activé, une alerte est lancée lorsqu'un backslash (<literal>\</literal>)
   apparaît dans une chaîne littérale ordinaire (syntaxe
   <literal>'...'</literal>). &Agrave; <literal>off</literal> par défaut.
  </para>
  <para>
   La syntaxe d'échappement de chaîne (<literal>E'...'</literal>) devrait être
   utilisée pour les échappements, parce que dans les prochaines versions de 
   <productname>PostgreSQL</productname> les chaînes ordinaires auront un
   comportement conforme au standard dans le traitement littéral des antislashs.
  </para>
  </entry>
  <entry>
  </entry>
 </row>

</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Compatibilité entre plateformes et clients</title>

<table>
<tgroup cols="7" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionné au</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>transform_null_equals</entry>
  <entry>true, false</entry>
  <entry>false</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
   Lorsque ce paramètre est positionné, les expressions de la forme expr = NULL
   (ou NULL = expr) sont traitées comme expr IS NULL, c'est-à-dire qu'elles
   retournent true si expr s'évalue à null et false dans le cas contraire. Le
   comportement correct de expr = NULL est de toujours retourner NULL (unknown).
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>custom_variable_classes</entry>
  <entry></entry>
  <entry>''</entry>
  <entry>Démarrage</entry>
  <entry></entry>
  <entry>
   Précisent un ou plusieurs noms de classe à utiliser pour les variables
   personnalisées, sous la forme d'une liste séparée par des virgules. Une
   variable personnalisée est une variable que PostgreSQL ne connaît pas mais
   qui est utilisée par certains modules supplémentaires. Le nom de telles
   variables doit être constitué d'un nom de classe, un point et un nom de
   variable.
   custom_variable_classes précise tous les noms de classes utilisables dans une
   installation particulière.
  </entry>
  <entry>
   Les modules supplémentaires qui requièrent ce paramètre (PL/java, par exemple)
   doivent expliquer comment le positionner.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

</article>
