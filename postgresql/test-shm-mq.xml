<?xml version="1.0" encoding="UTF-8"?>
<!-- doc/src/sgml/test-shm-mq.sgml -->

<sect1 id="test-shm-mq" xreflabel="test_shm_mq">
 <title>test_shm_mq</title>

 <indexterm zone="test-shm-mq">
  <primary>test_shm_mq</primary>
 </indexterm>

 <para>
  <filename>test_shm_mq</filename> est un exemple illustrant l'utilisation de la
  mémoire partagée dynamique et de la file d'attente de message pour la mémoire
  partagée pour coordonner un processus client avec le travail d'un ou plusieurs
  processus en tâche de fond.  Il n'a pas pour but de faire quoi que ce soit
  d'utile, mais visent plutôt un exemple de comment ces fonctionnalités peuvent
  être utilisées, ainsi qu'un test unitaire de celles-ci.
 </para>

 <para>
  La fonction dans cette extension envoie le même message en boucle au travers
  d'une boucle sur les processus.  Le contenu utile du message, la taille de la
  file de message au travers de laquelle il est envoyé ainsi que le nombre de
  processus dans la boucle sont configurables.  À la fin, le message peut être
  vérifié pour s'assurer qu'il n'a pas été corrompu durant la transmission.
 </para>

 <sect2>
  <title>Fonctions</title>

<synopsis>
test_shm_mq(queue_size int8, message text,
            repeat_count int4 default 1, num_workers int4 default 1)
    RETURNS void
</synopsis>

  <para>
   Cette fonction envoie et reçoit des message de manière synchrone.  Le
   processus client utilisateur envoie le message fourni au premier processus en
   tâche de fond utilisant une file d'attente de message de la taille spécifiée.
   Ce premier processus en tâche de fond envoie le message au second, si le
   nombre de processus en tâche de fond est supérieur à un, et ainsi
   de suite.  Pour finir, le dernier processus en tâche de fond renvoie le
   message au processus client.  Si le nombre de répétition est supérieur à un,
   le processus client renvoie alors le message au premier processus en tâche de
   fond.  Une fois que le message a été envoyé et reçu par tous les processus
   impliqués un nombre de fois égal au nombre de répétition, le processus
   utilisateur vérifie que le message finalement reçu corrrespond à celui envoyé
   en premier lieu, et renvoie une erreur si ce n'est pas le cas.
  </para>

<synopsis>
test_shm_mq_pipelined(queue_size int8, message text,
                      repeat_count int4 default 1, num_workers int4 default 1,
                      verify bool default true)
    RETURNS void
</synopsis>

  <para>
   Cette fonction envoie le même message plusieurs fois, comme spécifié par le
   nombre de répétition, au premier processus en tâche de fond utilisant une
   file d'attente de la taille spécifiée.  Ces messages sont ensuite retransmis
   à chaque processus en tâche de fond chacun à leur tour, si ceux-ci utilisent
   une file d'attente de la taille spécifiée.  Pour finir, le derniers processus
   en tâche de fond renvoie le message au processus client.  Celui-ci utilise
   des envois et réceptions non bloquants, si bien qu'il pourrait commencer à
   recevoir des copies du messages avant d'avoir fini d'envoyer toutes les
   copies du message.  L'argument <literal>verify</literal> contrôle si les
   copies reçues doivent être comparées au message original ou non.  (Cela prend
   un temps non négligeable, il peut donc être utile de le désactiver lors de
   tests de performances.)
  </para>

 </sect2>
</sect1>
