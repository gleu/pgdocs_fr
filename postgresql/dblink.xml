<?xml version="1.0" encoding="UTF-8"?>
<sect1 id="dblink" xreflabel="dblink">
 <title>dblink</title>

 <indexterm zone="dblink">
  <primary>dblink</primary>
 </indexterm>

 <para>
  <filename>dblink</filename> est un module qui permet de se connecter à
  d'autres bases de données <productname>PostgreSQL</productname> depuis
  une session de base de données.
 </para>

 <refentry id="contrib-dblink-connect">
  <refmeta>
   <refentrytitle>dblink_connect</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_connect</refname>
   <refpurpose>ouvre une connexion persistante vers une base de données
    distante.</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_connect(text connstr) returns text
    dblink_connect(text connname, text connstr) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_connect()</function> établit une connexion à une
    base de données <productname>PostgreSQL</productname> distante. Le
    serveur et la base de données à contacter sont identifiées par
    une chaine de connexion standard de la
    <application>libpq</application>. Il est possible d'affecter un nom
    à la connexion. Plusieurs connexions nommées peuvent être ouvertes 
    en une seule fois, mais il ne peut y avoir qu'une seule connexion
    anonyme à la fois. Toute connexion est maintenue jusqu'à ce qu'elle
    soit close ou que la session de base de données soit terminée.
   </para>

   <para>
    La chaîne de connexion peut aussi être le nom d'un serveur distant existant.
    Il est recommandé d'utiliser <function>postgresql_fdw_validator</function>
    lors de la définition d'un wrapper de données distantes correspondant. Voir
    l'exemple ci-dessous, ainsi que&nbsp;:
    <simplelist type="inline">
     <member><xref linkend="sql-createforeigndatawrapper"/></member>
     <member><xref linkend="sql-createserver"/></member>
     <member><xref linkend="sql-createusermapping"/></member>
    </simplelist>
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Le nom à utiliser pour la connexion&nbsp;; en cas d'omission,
       une connexion sans nom est ouverte, qui remplace toute autre connexion
       sans nom.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>connstr</parameter></term>
     <listitem>
      <para>
       Chaîne de connexion au format standard de la
       <application>libpq</application>, par exemple
       <literal>hostaddr=127.0.0.1 port=5432 dbname=mabase user=postgres
       password=monmotdepasse</literal>.
       Pour les détails, voir <function>PQconnectdb</function> dans
       <xref linkend="libpq-connect"/>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Renvoie le statut qui est toujours <literal>OK</literal> (puisque toute
    erreur amène la fonction à lever une erreur, sans retour).
   </para>
  </refsect1>

  <refsect1>
   <title>Notes</title>

   <para>
    Seuls les super-utilisateurs peuvent utiliser
    <function>dblink_connect</function> pour créer des connexions authentifiées
    sans mot de passe. Si des utilisateurs standard ont ce besoin, il faut
    utiliser la fonction <function>dblink_connect_u</function> à sa place.
   </para>

   <para>
    Il est déconseillé de choisir des noms de connexion contenant
    des signes d'égalité car ils peuvent introduire des risques de confusion
    avec les chaînes de connexion dans les autres fonctions
    <filename>dblink</filename>.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <screen>
SELECT dblink_connect('dbname=postgres');
  dblink_connect
 ----------------
  OK
 (1 row)

 SELECT dblink_connect('myconn', 'dbname=postgres');
  dblink_connect
 ----------------
  OK
 (1 row)

 -- Fonctionnalité FOREIGN DATA WRAPPER
 -- Note : la connexion locale nécessite l'authentification password pour que
 --        cela fonctionne correctement
 --        Sinon, vous recevrez le message d'erreur suivant provenant de
 --        dblink_connect() :
 --       ----------------------------------------------------------------------
 --       ERROR:  password is required
 --       DETAIL:  Non-superuser cannot connect if the server does not request a password.
 --       HINT:  Target server's authentication method must be changed.
 CREATE USER dblink_regression_test WITH PASSWORD 'secret';
 CREATE FOREIGN DATA WRAPPER postgresql VALIDATOR postgresql_fdw_validator;
 CREATE SERVER fdtest FOREIGN DATA WRAPPER postgresql OPTIONS (hostaddr '127.0.0.1', dbname 'contrib_regression');

 CREATE USER MAPPING FOR dblink_regression_test SERVER fdtest OPTIONS (user 'dblink_regression_test', password 'secret');
 GRANT USAGE ON FOREIGN SERVER fdtest TO dblink_regression_test;
 GRANT SELECT ON TABLE foo TO dblink_regression_test;

 \set ORIGINAL_USER :USER
 \c - dblink_regression_test
 SELECT dblink_connect('myconn', 'fdtest');
  dblink_connect 
 ----------------
  OK
 (1 row)

 SELECT * FROM dblink('myconn','SELECT * FROM foo') AS t(a int, b text, c text[]);
  a  | b |       c       
 ----+---+---------------
   0 | a | {a0,b0,c0}
   1 | b | {a1,b1,c1}
   2 | c | {a2,b2,c2}
   3 | d | {a3,b3,c3}
   4 | e | {a4,b4,c4}
   5 | f | {a5,b5,c5}
   6 | g | {a6,b6,c6}
   7 | h | {a7,b7,c7}
   8 | i | {a8,b8,c8}
   9 | j | {a9,b9,c9}
  10 | k | {a10,b10,c10}
 (11 rows)

 \c - :ORIGINAL_USER
 REVOKE USAGE ON FOREIGN SERVER fdtest FROM dblink_regression_test;
 REVOKE SELECT ON TABLE foo FROM  dblink_regression_test;
 DROP USER MAPPING FOR dblink_regression_test SERVER fdtest;
 DROP USER dblink_regression_test;
 DROP SERVER fdtest;
 DROP FOREIGN DATA WRAPPER postgresql;
   </screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-connect-u">
  <refmeta>
   <refentrytitle>dblink_connect_u</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_connect_u</refname>
   <refpurpose>ouvre une connexion distante à une base de données de
    façon non sécurisée.</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_connect_u(text connstr) returns text
    dblink_connect_u(text connname, text connstr) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_connect_u()</function> est identique à
    <function>dblink_connect()</function>, à ceci près qu'elle permet à des
    utilisateurs non-privilégiés de se connecter par toute méthode
    d'authentification.
   </para>

   <para>
    Si le serveur distant sélectionne une méthode d'authentification qui
    n'implique pas de mot de passe, une impersonnalisation et une escalade
    de droits peut survenir car la session semble émaner de l'utilisateur
    qui exécute le serveur <productname>PostgreSQL</productname> local.
    De plus, même si le serveur distant réclame un mot de passe, il est
    possible de fournir le mot de passe à partir de l'environnement du serveur,
    par exemple en utilisant un fichier <filename>~/.pgpass</filename>
    appartenant à l'utilisateur du serveur. Cela apporte un risque
    supplémentaire d'impersonnification, sans parler de la possibilité d'exposer
    un mot de passe sur un serveur distant qui ne mérite pas votre confiance.
    C'est pourquoi,
    <function>dblink_connect_u()</function> est installé initialement sans
    aucun droit pour <literal>PUBLIC</literal>, ce qui restreint son
    utilisation aux seuls super-utilisateurs. Dans certaines cas,
    le droit <literal>EXECUTE</literal> sur
    <function>dblink_connect_u()</function> peut être accordé à quelque
    utilisateur spécifique digne de confiance, mais cela doit se faire
    avec une extrême prudence. Il est aussi recommandé que tout fichier
    <filename>~/.pgpass</filename> appartenant à l'utilisateur du serveur ne
    contienne <emphasis>pas</emphasis> de joker dans le nom de l'hôte.
   </para>

   <para>
    Pour plus de détails, voir <function>dblink_connect()</function>.
   </para>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-disconnect">
  <refmeta>
   <refentrytitle>dblink_disconnect</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_disconnect</refname>
   <refpurpose>ferme une connexion persistante vers une base de données
    distante.</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_disconnect() returns text
    dblink_disconnect(text connname) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_disconnect()</function> ferme une connexion ouverte
    par <function>dblink_connect()</function>. La forme sans argument
    ferme une connexion non nommée.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Le nom de la connexion à fermer
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Renvoie le statut qui est toujours <literal>OK</literal> (puisque toute
    erreur amène la fonction à lever une erreur, sans retour).
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <screen>
SELECT dblink_disconnect();
  dblink_disconnect
 -------------------
  OK
 (1 row)

 SELECT dblink_disconnect('myconn');
  dblink_disconnect
 -------------------
  OK
 (1 row)
   </screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-function">
  <refmeta>
   <refentrytitle>dblink</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink</refname>
   <refpurpose>exécute une requête sur une base de données
   distante</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink(text connname, text sql [, bool fail_on_error]) returns setof record
    dblink(text connstr, text sql [, bool fail_on_error]) returns setof record
    dblink(text sql [, bool fail_on_error]) returns setof record
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink</function> exécute une requête (habituellement un
    <command>SELECT</command>, mais toute instruction
    SQL qui renvoie des lignes est valable) sur une base de données distante.
   </para>

   <para>
    Si deux arguments <type>text</type> sont présents, le premier est d'abord
    considéré comme nom de connexion persistante&nbsp;; si cette connexion
    est trouvée, la commande est exécutée sur cette connexion. Dans le cas
    contraire, le premier argument est considéré être une chaîne de connexion
    comme dans le cas de <function>dblink_connect</function>, et la connexion
    indiquée n'est conservée que pour la durée d'exécution de cette commande.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Le nom de la connexion à utiliser&nbsp;; ce paramètre doit être omis
       pour utiliser une connexion sans nom.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>connstr</parameter></term>
     <listitem>
      <para>
       Une chaîne de connexion similaire à celle décrite précédemment pour
       <function>dblink_connect</function>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>sql</parameter></term>
     <listitem>
      <para>
        L'instruction SQL à exécuter sur l'hôte distant, par exemple
	<literal>select * from foo</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <para>
       Si true (valeur par défaut en cas d'omission), une erreur distante
       est reportée localement comme une erreur. Dans le cas contraire, un
       message d'erreur distant est traité localement comme un message de type 
       NOTICE, et la fonction ne retourne aucune ligne.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    La fonction renvoie les lignes produites par la requête. Comme
    <function>dblink</function> peut être utilisée avec toute requête, elle
    est déclarée comme renvoyant le type <type>record</type>, plutôt que de
    préciser un ensemble particulier de colonnes. Cela signifie que
    l'ensemble des colonnes attendues doit être précisé dans la
    requête appelante &mdash; sinon <productname>PostgreSQL</productname>
    ne sait pas quoi attendre. Voici un exemple&nbsp;:

<programlisting>
SELECT *
    FROM dblink('dbname=mydb', 'select proname, prosrc from pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';
</programlisting>

    La partie <quote>alias</quote> de la clause <literal>FROM</literal> doit
    spécifier les noms et types des colonnes retournés par la fonction.
    (La précision des noms des colonnes dans un alias est une syntaxe
    du standard SQL mais la précision des types des colonnes est une extension
    <productname>PostgreSQL</productname>.) Cela permet au système de
    savoir comment étendre <literal>*</literal>, et à quoi correspond
    <structname>proname</structname> dans la clause
    <literal>WHERE</literal> 
    avant de tenter l'exécution de la fonction. À l'exécution, une erreur
    est renvoyée si le nombre de colonnes du résultat effectif de la requête
    sur la base de données distante diffère de celui indiqué
    dans la clause <literal>FROM</literal>. Les noms de colonnes n'ont pas
    besoin de correspondre et <function>dblink</function> n'impose pas
    une correspondance exacte des types. L'opération réussit
    si les chaînes de données renvoyées sont valides pour le type déclaré
    dans la clause <literal>FROM</literal>.
   </para>
  </refsect1>

  <refsect1>
   <title>Notes</title>

   <para>
    Il est souvent plus pratique de créer une vue pour utiliser
    <function>dblink</function> avec des requêtes prédéterminées.
    Cela permet de laisser la vue gérer le type de la colonne plutôt que
    d'avoir à le saisir pour chaque requête. Par exemple&nbsp;:

    <programlisting>
CREATE VIEW myremote_pg_proc AS
  SELECT *
    FROM dblink('dbname=postgres', 'select proname, prosrc from pg_proc')
    AS t1(proname name, prosrc text);

SELECT * FROM myremote_pg_proc WHERE proname LIKE 'bytea%';
    </programlisting>
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

<screen>
SELECT * FROM dblink('dbname=postgres', 'select proname, prosrc from pg_proc')
  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
  proname   |   prosrc
------------+------------
 byteacat   | byteacat
 byteaeq    | byteaeq
 bytealt    | bytealt
 byteale    | byteale
 byteagt    | byteagt
 byteage    | byteage
 byteane    | byteane
 byteacmp   | byteacmp
 bytealike  | bytealike
 byteanlike | byteanlike
 byteain    | byteain
 byteaout   | byteaout
(12 rows)

SELECT dblink_connect('dbname=postgres');
 dblink_connect
----------------
 OK
(1 row)

SELECT * FROM dblink('select proname, prosrc from pg_proc')
  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
  proname   |   prosrc
------------+------------
 byteacat   | byteacat
 byteaeq    | byteaeq
 bytealt    | bytealt
 byteale    | byteale
 byteagt    | byteagt
 byteage    | byteage
 byteane    | byteane
 byteacmp   | byteacmp
 bytealike  | bytealike
 byteanlike | byteanlike
 byteain    | byteain
 byteaout   | byteaout
(12 rows)

SELECT dblink_connect('myconn', 'dbname=regression');
 dblink_connect
----------------
 OK
(1 row)

SELECT * FROM dblink('myconn', 'select proname, prosrc from pg_proc')
  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
  proname   |   prosrc
------------+------------
 bytearecv  | bytearecv
 byteasend  | byteasend
 byteale    | byteale
 byteagt    | byteagt
 byteage    | byteage
 byteane    | byteane
 byteacmp   | byteacmp
 bytealike  | bytealike
 byteanlike | byteanlike
 byteacat   | byteacat
 byteaeq    | byteaeq
 bytealt    | bytealt
 byteain    | byteain
 byteaout   | byteaout
(14 rows)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-exec">
  <refmeta>
   <refentrytitle>dblink_exec</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_exec</refname>
   <refpurpose>exécute une commande sur une base de données
    distante</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_exec(text connname, text sql [, bool fail_on_error]) returns text
    dblink_exec(text connstr, text sql [, bool fail_on_error]) returns text
    dblink_exec(text sql [, bool fail_on_error]) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_exec</function> exécute une commande (c'est-à-dire toute
    instruction SQL qui ne renvoie pas de lignes) dans une base de données
    distante.
   </para>

   <para>
    Quand deux arguments de type <type>text</type> sont fournis, le premier
    est d'abord considéré comme nom d'une connexion persistante&nbsp;; si cette
    connexion est trouvée, la commande est exécutée sur cette connexion. Dans
    le cas contraire, le premier argument est traitée comme une chaîne de
    connexion pour <function>dblink_connect</function>, et la connexion
    indiquée n'est maintenue que pour la durée d'exécution de cette
    commande.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Le nom de la connexion à utiliser&nbsp;; ce paramètre doit être omis 
       pour utiliser une connexion sans nom.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>connstr</parameter></term>
     <listitem>
      <para>
        Une chaîne de connexion similaire à celle décrite précédemment pour
	<function>dblink_connect</function>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>sql</parameter></term>
     <listitem>
      <para>
       La commande SQL à exécuter sur la base de données
       distante&nbsp;; par exemple
       <literal>INSERT INTO foo VALUES(0,'a','{"a0","b0","c0"}')</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <para>
       Si true (valeur par défaut en cas d'omission), une erreur distante
       est reportée localement comme une erreur locale. Dans le cas contraire, un
       message d'erreur distant est traité localement comme un message de type 
       NOTICE, et la valeur de retour de la fonction est positionné à
       <literal>ERROR</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Renvoie le statut de la commande ou <literal>ERROR</literal> en cas
    d'échec.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

<screen>
SELECT dblink_connect('dbname=dblink_test_standby');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_exec('insert into foo values(21,''z'',''{"a0","b0","c0"}'');');
   dblink_exec
-----------------
 INSERT 943366 1
(1 row)

SELECT dblink_connect('myconn', 'dbname=regression');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_exec('myconn', 'insert into foo values(21,''z'',''{"a0","b0","c0"}'');');
   dblink_exec
------------------
 INSERT 6432584 1
(1 row)

SELECT dblink_exec('myconn', 'insert into pg_class values (''foo'')',false);
NOTICE:  sql error
DETAIL:  ERROR:  null value in column "relnamespace" violates not-null constraint

 dblink_exec
-------------
 ERROR
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-open">
  <refmeta>
   <refentrytitle>dblink_open</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_open</refname>
   <refpurpose>ouvre un curseur sur une base de données distante</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_open(text cursorname, text sql [, bool fail_on_error]) returns text
    dblink_open(text connname, text cursorname, text sql [, bool fail_on_error]) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_open()</function> ouvre un curseur sur une base de
    données distante. Le curseur peut ensuite être manipulé avec
    <function>dblink_fetch()</function> et
    <function>dblink_close()</function>.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Le nom de la connexion à utiliser&nbsp;; ce paramètre doit être omis 
       pour utiliser une connexion sans nom.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>cursorname</parameter></term>
     <listitem>
      <para>
       Nom à affecter au curseur.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>sql</parameter></term>
     <listitem>
      <para>
       L'instruction <command>SELECT</command> à exécuter sur l'hôte distant,
       par exemple <literal>SELECT * FROM pg_class</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <para>
       Si true (valeur par défaut en cas d'omission), une erreur distante
       est reportée localement comme une erreur locale. Dans le cas contraire, un
       message d'erreur distant est traité localement comme un message de type 
       NOTICE, et la valeur de retour de la fonction est positionné à
       <literal>ERROR</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Renvoie le statut, soit <literal>OK</literal> soit
    <literal>ERROR</literal>.
   </para>
  </refsect1>

  <refsect1>
   <title>Notes</title>

   <para>
    Puisqu'un curseur ne peut persister qu'au sein d'une transaction,
    <function>dblink_open</function> lance un bloc de transaction explicite
    (<command>BEGIN</command>) côté distant, si le côté distant n'est
    pas déjà à l'intérieur d'une transaction. Cette transaction est refermée
    à l'exécution de l'instruction <function>dblink_close</function>.
    Si <function>dblink_exec</function> est utilisée
    pour modifier les données entre <function>dblink_open</function> et
    <function>dblink_close</function>, et qu'une erreur survient ou
    que <function>dblink_disconnect</function> est utilisé avant
    <function>dblink_close</function>, les modifications <emphasis>sont
    perdues</emphasis> car la transaction est annulée.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

<screen>
SELECT dblink_connect('dbname=postgres');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_open('foo', 'select proname, prosrc from pg_proc');
 dblink_open
-------------
 OK
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-fetch">
  <refmeta>
   <refentrytitle>dblink_fetch</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv>
   <refname>dblink_fetch</refname>
   <refpurpose>renvoie des lignes à partir d'un curseur ouvert sur une
    base de données distante</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_fetch(text cursorname, int howmany [, bool fail_on_error]) returns setof record
    dblink_fetch(text connname, text cursorname, int howmany [, bool fail_on_error]) returns setof record
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_fetch</function> récupère des lignes à partir d'un
    curseur déjà ouvert par <function>dblink_open</function>.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Nom de la connexion à utiliser&nbsp;; ce paramètre doit être omis pour
       utiliser une connexion sans nom.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>cursorname</parameter></term>
     <listitem>
      <para>
       Le nom du curseur à partir duquel récupérer les lignes.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>howmany</parameter></term>
     <listitem>
      <para>
       Nombre maximum de lignes à récupérer. Les
       <parameter>howmany</parameter> lignes suivantes sont récupérées, en
       commençant à la position actuelle du curseur, vers l'avant. Une fois
       le curseur arrivé à la fin, aucune ligne supplémentaire n'est
       renvoyée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <para>
       Si true (valeur par défaut en cas d'omission), une erreur distante
       est reportée localement comme une erreur locale. Dans le cas contraire, un
       message d'erreur distant est traité localement comme un message de type 
       NOTICE, et la fonction ne retourne aucune ligne.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    La fonction renvoie les lignes récupérées à partir du curseur. Pour
    utiliser cette fonction, l'ensemble des colonnes 
    attendues doit être spécifié, comme décrit précédemment pour
    <function>dblink</function>. 
   </para>
  </refsect1>

  <refsect1>
   <title>Notes</title>

   <para>
    Si le nombre de colonnes de retour spécifiées dans
    la clause <literal>FROM</literal>, et le nombre réel de colonnes renvoyées
    par le curseur distant diffèrent, une erreur est remontée. Dans ce cas, le curseur
    distant est tout de même avancé du nombre de lignes indiqué, comme si
    l'erreur n'avait pas eu lieu. Il en est de même pour toute autre erreur
    survenant dans la requête locale après l'exécution
    du <command>FETCH</command> distant.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

<screen>
SELECT dblink_connect('dbname=postgres');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_open('foo', 'select proname, prosrc from pg_proc where proname like ''bytea%''');
 dblink_open
-------------
 OK
(1 row)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
 funcname |  source
----------+----------
 byteacat | byteacat
 byteacmp | byteacmp
 byteaeq  | byteaeq
 byteage  | byteage
 byteagt  | byteagt
(5 rows)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
 funcname  |  source
-----------+-----------
 byteain   | byteain
 byteale   | byteale
 bytealike | bytealike
 bytealt   | bytealt
 byteane   | byteane
(5 rows)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
  funcname  |   source
------------+------------
 byteanlike | byteanlike
 byteaout   | byteaout
(2 rows)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
 funcname | source
----------+--------
(0 rows)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-close">
  <refmeta>
   <refentrytitle>dblink_close</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv>
   <refname>dblink_close</refname>
   <refpurpose>ferme un curseur sur une base de données distante</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_close(text cursorname [, bool fail_on_error]) returns text
    dblink_close(text connname, text cursorname [, bool fail_on_error]) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_close</function> ferme un curseur précédemment ouvert
    avec <function>dblink_open</function>.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Le nom de la connexion à utiliser&nbsp;; ce paramètre doit être omis pour
       utiliser une connexion sans nom.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>cursorname</parameter></term>
     <listitem>
      <para>
       Nom du curseur à fermer.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <para>
       Si true (valeur par défaut en cas d'omission), une erreur distante
       est reportée localement comme une erreur. Dans le cas contraire, un
       message d'erreur distant est traité localement comme un message de type 
       NOTICE, et la valeur de retour est positionnée à 
       <literal>ERROR</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Renvoie le statut, soit <literal>OK</literal> soit
    <literal>ERROR</literal>.
   </para>
  </refsect1>

  <refsect1>
   <title>Notes</title>

   <para>
    Si <function>dblink_open</function> a ouvert un bloc de transaction
    explicite, et que c'est le dernier curseur ouvert restant dans cette
    connexion, <function>dblink_close</function> exécute le
    <command>COMMIT</command> correspondant.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

<screen>
SELECT dblink_connect('dbname=postgres');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_open('foo', 'select proname, prosrc from pg_proc');
 dblink_open
-------------
 OK
(1 row)

SELECT dblink_close('foo');
 dblink_close
--------------
 OK
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-get-connections">
  <refmeta>
   <refentrytitle>dblink_get_connections</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv>
   <refname>dblink_get_connections</refname>
   <refpurpose>renvoie les noms de toutes les connexions nommées
   ouvertes</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_get_connections() returns text[]
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_get_connections</function> renvoie un tableau contenant
    le nom de toutes les connexions nommées ouvertes de
    <filename>dblink</filename>.
   </para>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>Renvoie un tableau texte des noms des connexions, ou NULL s'il n'y
   en a pas.</para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
   SELECT dblink_get_connections();
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-error-message">
  <refmeta>
   <refentrytitle>dblink_error_message</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv>
   <refname>dblink_error_message</refname>
   <refpurpose>récupère le dernier message d'erreur sur la connexion
    nommée</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_error_message(text connname) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_error_message</function> récupère le dernier message
    d'erreur sur une connexion donnée.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Nom de la connexion à utiliser.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Return Value</title>

   <para>
    Renvoie le dernier message, ou une chaîne vide s'il n'y a pas eu
    d'erreur sur cette connexion.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
    SELECT dblink_error_message('dtest1');
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-send-query">
  <refmeta>
   <refentrytitle>dblink_send_query</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv>
   <refname>dblink_send_query</refname>
   <refpurpose>envoie une requête asynchrone à une base de données
    distante</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_send_query(text connname, text sql) returns int
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_send_query</function> envoie une requête à exécuter
    de façon asynchrone, c'est-à-dire sans attendre immédiatement le résultat.
    Il ne doit pas déjà exister de requête asynchrone en exécution sur la
    connexion.
   </para>

   <para>
    Après l'envoi réussi d'une requête asynchrone, le statut de fin
    d'exécution de la requête se vérifie avec
    <function>dblink_is_busy</function>, et les résultats sont finalement
    récupérés avec <function>dblink_get_result</function>. Il est
    aussi possible de tenter l'annulation d'une rquête asynchrone
    active en utilisant  <function>dblink_cancel_query</function>. 
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Le nom de la connexion à utiliser.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>sql</parameter></term>
     <listitem>
      <para>
       L'instruction SQL à exécuter dans la base de données
       distante, par exemple <literal>select * from pg_class</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Renvoie 1 si la requête a été envoyée avec succès, 0 sinon.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
    SELECT dblink_send_query('dtest1', 'SELECT * FROM foo WHERE f1 &lt; 3');
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-is-busy">
  <refmeta>
   <refentrytitle>dblink_is_busy</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv>
   <refname>dblink_is_busy</refname>
   <refpurpose>vérifie si la connexion est occupée par le traitement d'une requête
   asynchrone</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_is_busy(text connname) returns int
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_is_busy</function> teste si une requête asynchrone est
    en cours d'exécution.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Le nom de la connexion à vérifier.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Renvoie 1 si la connexion est occupée, 0 dans le cas contraire.
    Si cette fonction renvoie 0, il est garanti que l'appel à
    <function>dblink_get_result</function> ne bloque pas.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
    SELECT dblink_is_busy('dtest1');
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-get-notify">
  <refmeta>
   <refentrytitle>dblink_get_notify</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_get_notify</refname>
   <refpurpose>récupère les notifications asynchrones sur une
     connection</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_get_notify() returns setof (notify_name text, be_pid int, extra text)
    dblink_get_notify(text connname) returns setof (notify_name text, be_pid int, extra text)
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_get_notify</function> récupère les notifications soit
    sur une connexion anonyme (sans nom), soit sur une connexion nommée si le
    nom est précisé. Pour recevoir des notifications via dblink,
    <function>LISTEN</function> doit d'abord être lancé en utilisant
    <function>dblink_exec</function>. Pour les détails, voir <xref
    linkend="sql-listen"/> et <xref linkend="sql-notify"/>.
   </para>

  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Le nom d'une connexion nommée qui veut récupérer les notifications.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>
    <para>Renvoit <type>setof (notify_name text, be_pid int, extra text)</type>
      ou un ensemble vide.</para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

<screen>
SELECT dblink_exec('LISTEN virtual');
 dblink_exec 
-------------
 LISTEN
(1 row)

SELECT * FROM dblink_get_notify();
 notify_name | be_pid | extra
-------------+--------+-------
(0 rows)

NOTIFY virtual;
NOTIFY

SELECT * FROM dblink_get_notify();
 notify_name | be_pid | extra
-------------+--------+-------
 virtual     |   1229 |
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-get-result">
  <refmeta>
   <refentrytitle>dblink_get_result</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv>
   <refname>dblink_get_result</refname>
   <refpurpose>récupère le résultat d'une requête asynchrone</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_get_result(text connname [, bool fail_on_error]) returns setof record
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_get_result</function> récupère le résultat d'une
    requête asynchrone précédemment envoyée avec
    <function>dblink_send_query</function>. Si la requête n'est pas 
    terminée, <function>dblink_get_result</function> en attend la fin.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Le nom de la connexion à utiliser.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <para>
       Si true (valeur par défaut en cas d'omission), une erreur distante
       est reportée localement comme une erreur locale. Dans le cas contraire, un
       message d'erreur distant est traité localement comme un message de type 
       NOTICE, et la fonction ne retourne aucune ligne.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

<!-- statement : instruction -->
   <para>
    Pour une requête asynchrone (c'est-à-dire une instruction SQL renvoyant des
    lignes), la fonction renvoie les lignes produites par la requête. Pour
    utiliser cette fonction, il faut spécifier l'ensemble des colonnes
    attendues, comme indiqué pour <function>dblink</function>.
   </para>

   <para>
    Pour une commande asynchrone (c'est-à-dire une instruction SQL ne renvoyant aucune
    ligne), la fonction renvoie une seule ligne avec une colonne texte
    contenant la chaîne de statut de la commande. Il est impératif
    d'indiquer dans la clause <literal>FROM</literal> appelante que le résultat
    est constitué d'une unique colonne texte .
   </para>
  </refsect1>

  <refsect1>
   <title>Notes</title>

   <para>
    Cette fonction <emphasis>doit</emphasis> être appelée si
    <function>dblink_send_query</function> a renvoyé 1. Elle doit l'être
    une fois pour chaque requête envoyée, et une fois de plus pour obtenir
    un ensemble vide, avant de pouvoir utiliser à nouveau la connexion.
   </para>

   <para>
    Lorsqu'on utilise <function>dblink_send_query</function> et
    <function>dblink_get_result</function>, <application>dblink</application> récupère
    l'intégralité de la requête avant de les renvoyer au système local. Si la requête
	renvoit un grand nombre de lignes, cela peut conduire à une surcharge temporaire
	de la mémoire dans la session locale. Il peut être préférable d'ouvrir un curseur
	avec <function>dblink_open</function> puis de récupérer un nombre gérable de lignes.
	Sinon, vous pouvez utiliser un simple <function>dblink()</function>, qui évite la
	surcharge de la mémoire en mettant en attente de gros ensembles de résultats sur disque.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

<screen>
contrib_regression=# SELECT dblink_connect('dtest1', 'dbname=contrib_regression');
 dblink_connect
----------------
 OK
(1 row)

contrib_regression=# SELECT * FROM
contrib_regression-# dblink_send_query('dtest1', 'select * from foo where f1 &lt; 3') AS t1;
 t1
----
  1
(1 row)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 |     f3
----+----+------------
  0 | a  | {a0,b0,c0}
  1 | b  | {a1,b1,c1}
  2 | c  | {a2,b2,c2}
(3 rows)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 | f3
----+----+----
(0 rows)

contrib_regression=# SELECT * FROM
contrib_regression-# dblink_send_query('dtest1', 'select * from foo where f1 &lt; 3; select * from foo where f1 &gt; 6') AS t1;
 t1
----
  1
(1 row)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 |     f3
----+----+------------
  0 | a  | {a0,b0,c0}
  1 | b  | {a1,b1,c1}
  2 | c  | {a2,b2,c2}
(3 rows)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 |      f3
----+----+---------------
  7 | h  | {a7,b7,c7}
  8 | i  | {a8,b8,c8}
  9 | j  | {a9,b9,c9}
 10 | k  | {a10,b10,c10}
(4 rows)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 | f3
----+----+----
(0 rows)
</screen>
  </refsect1>
 </refentry>
<!-- JCA::TAG RELECTURE -->
 <refentry id="contrib-dblink-cancel-query">
  <refmeta>
   <refentrytitle>dblink_cancel_query</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv>
   <refname>dblink_cancel_query</refname>
   <refpurpose>annule toute requête en cours d'exécution sur la connexion
    nommée</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_cancel_query(text connname) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_cancel_query</function> tente d'annuler toute requête
    en cours d'exécution sur la connexion nommée. La réussite de
    la fonction n'est pas assurée (la requête distante pourrait, par exemple, 
    être déjà terminée). Une demande d'annulation augmente simplement
    la probabilité que la requête échoue rapidement. Le protocoel de requête
    normal doit toujours être terminé, par exemple en appelant
    <function>dblink_get_result</function>.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Le nom de la connexion à utiliser.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Renvoie <literal>OK</literal> si la demande d'annulation a été
    envoyée, ou le texte d'un message d'erreur en cas d'échec.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
    SELECT dblink_cancel_query('dtest1');
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-get-pkey">
  <refmeta>
   <refentrytitle>dblink_get_pkey</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv>
   <refname>dblink_get_pkey</refname>
   <refpurpose>renvoie la position et le nom des champs de clé primaire
    d'une relation
   </refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_get_pkey(text relname) returns setof dblink_pkey_results
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_get_pkey</function> fournit des informations sur la clé
    primaire d'une relation de la base de données locale. Il est parfois
    utile de produire des requêtes à transmettre à des bases distantes.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>relname</parameter></term>
     <listitem>
      <para>
       Le nom d'une relation locale, par exemple <literal>foo</literal> ou
       <literal>monschema.matable</literal>. Ajouter des guillemets doubles
       si le nom a une casse mixte, ou contient des
       caractères spéciaux, par exemple <literal>"FooBar"</literal>&nbsp;;
       sans guillemets, la chaîne est forcée en minuscule.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Renvoie une ligne pour chaque champ de clé primaire, ou aucune ligne
    si la relation n'a pas de clé primaire. Le type de ligne résultante
    est défini ainsi&nbsp;:

    <programlisting>
CREATE TYPE dblink_pkey_results AS (position int, colname text);
    </programlisting>

    La colonne <literal>position</literal> comme à 1 et va jusqu'à
    <replaceable>N</replaceable>&nbsp;; elle correspond au numéro du champ
    dans la clé primaire, pas au numéro de colonne dans la liste des colonnes
    de la table.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

<screen>
CREATE TABLE foobar (
    f1 int,
    f2 int,
    f3 int,
    PRIMARY KEY (f1, f2, f3)
);
CREATE TABLE

SELECT * FROM dblink_get_pkey('foobar');
 position | colname
----------+---------
        1 | f1
        2 | f2
        3 | f3
(3 rows)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-build-sql-insert">
  <refmeta>
   <refentrytitle>dblink_build_sql_insert</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv>
   <refname>dblink_build_sql_insert</refname>
   <refpurpose>
    construit une instruction d'insertion en utilisant un tuple local,
    remplaçant les valeurs des champs de la clé primaire 
    avec les valeurs fournies
   </refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_build_sql_insert(text relname,
                            int2vector primary_key_attnums,
                            integer num_primary_key_atts,
                            text[] src_pk_att_vals_array,
                            text[] tgt_pk_att_vals_array) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_build_sql_insert</function> peut être utile pour réaliser
    une réplication sélective d'une table locale vers une base distante.
    Elle sélectionne une ligne de la table locale sur la base de la clé primaire
    et construit une commande SQL <command>INSERT</command> qui duplique
    cette ligne, mais avec pour valeurs de clé primaire celles
    du dernier argument. (Pour réaliser une copie exacte de la ligne,
    il suffit d'indiquer les mêmes valeurs pour les deux derniers arguments.)
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>relname</parameter></term>
     <listitem>
      <para>
       Le nom d'une relation locale, par exemple <literal>foo</literal> ou
       <literal>monschema.matable</literal>. Ajouter des guillemets doubles
       si le nom est en casse mixte ou contient des
       caractères spéciaux, par exemple <literal>"FooBar"</literal>&nbsp;;
       sans guillemets, la chaîne est forcée en minuscule.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>primary_key_attnums</parameter></term>
     <listitem>
      <para>
       Les numéros des attributs (commençant à 1) des champs de la clé primaire,
       par exemple <literal>1 2</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>num_primary_key_atts</parameter></term>
     <listitem>
      <para>
       Le nombre de champs de la clé primaire.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>src_pk_att_vals_array</parameter></term>
     <listitem>
      <para>
       Les valeurs des champs de la clé primaire à utiliser pour identifier 
       le tuple local. Chaque champ est représenté dans sa forme textuelle. Une
       erreur est renvoyée s'il n'y a pas de lignes locales avec ces valeurs
       de clé primaire.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>tgt_pk_att_vals_array</parameter></term>
     <listitem>
      <para>
       Les valeurs des champs de la clé primaire à placer dans la commande
       <command>INSERT</command> résultante. Chaque champ est représenté dans
       sa forme textuelle.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>Renvoie l'instruction SQL demandée en tant que texte.</para>
  </refsect1>

  <refsect1>
   <title>Notes</title>

   <para>
    À partir de <productname>PostgreSQL</productname> 9.0, les numéros des
    attributs dans <parameter>primary_key_attnums</parameter> sont interprétés
    comme des numéros logiques de colonnes correspondant à la position de la
    colonne dans <literal>SELECT * FROM relation</literal>. Les versions
    précédentes interprétaient les numéros comme des positions physiques de
    colonnes. Une différence existe si une des colonnes à gauche de la colonne
    indiquée a été supprimé de la table.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

<screen>
SELECT dblink_build_sql_insert('foo', '1 2', 2, '{"1", "a"}', '{"1", "b''a"}');
             dblink_build_sql_insert
--------------------------------------------------
 INSERT INTO foo(f1,f2,f3) VALUES('1','b''a','1')
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-build-sql-delete">
  <refmeta>
   <refentrytitle>dblink_build_sql_delete</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv>
   <refname>dblink_build_sql_delete</refname>
   <refpurpose>construit une instruction de suppression en utilisant 
    les valeurs fournies pour les champs de la clé primaire
   </refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_build_sql_delete(text relname,
                            int2vector primary_key_attnums,
                            integer num_primary_key_atts,
                            text[] tgt_pk_att_vals_array) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_build_sql_delete</function> peut être utile pour réaliser
    une réplication sélective d'une table locale vers une base distante.
    Elle construit une commande SQL <command>DELETE</command> qui supprime
    la ligne avec les valeurs indiquées de clé primaire.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>relname</parameter></term>
     <listitem>
      <para>
       Le nom d'une relation locale, par exemple <literal>foo</literal> ou
       <literal>monschema.matable</literal>. Ajouter des guillemets doubles
       si le nom est en casse mixte ou contient des
       caractères spéciaux, par exemple <literal>"FooBar"</literal>&nbsp;;
       sans guillemets, la chaîne est forcée en minuscule.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>primary_key_attnums</parameter></term>
     <listitem>
      <para>
       Les numéros des attributs (commençant à 1) des champs de la clé primaire,
       par exemple <literal>1 2</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>num_primary_key_atts</parameter></term>
     <listitem>
      <para>
       Le nombre de champs de la clé primaire.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>tgt_pk_att_vals_array</parameter></term>
     <listitem>
      <para>
       Les valeurs de champs de la clé primaire, à utiliser dans la commande
       <command>DELETE</command> résultante. Chaque champ est représenté dans
       sa forme textuelle.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>Renvoie l'instruction SQL demandée en tant que texte.</para>
  </refsect1>

  <refsect1>
   <title>Notes</title>

   <para>
    À partir de <productname>PostgreSQL</productname> 9.0, les numéros des
    attributs dans <parameter>primary_key_attnums</parameter> sont interprétés
    comme des numéros logiques de colonnes correspondant à la position de la
    colonne dans <literal>SELECT * FROM relation</literal>. Les versions
    précédentes interprétaient les numéros comme des positions physiques de
    colonnes. Une différence existe si une des colonnes à gauche de la colonne
    indiquée a été supprimé de la table.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

<screen>
SELECT dblink_build_sql_delete('"MyFoo"', '1 2', 2, '{"1", "b"}');
           dblink_build_sql_delete
---------------------------------------------
 DELETE FROM "MyFoo" WHERE f1='1' AND f2='b'
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="contrib-dblink-build-sql-update">
  <refmeta>
   <refentrytitle>dblink_build_sql_update</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv>
   <refname>dblink_build_sql_update</refname>
   <refpurpose>construit une instruction de mise à jour à partir d'un tuple
    local, en remplaçant les valeurs des champs de la clé primaire par celles
    fournies
   </refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_build_sql_update(text relname,
                            int2vector primary_key_attnums,
                            integer num_primary_key_atts,
                            text[] src_pk_att_vals_array,
                            text[] tgt_pk_att_vals_array) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_build_sql_update</function> peut être utile pour réaliser
    une réplication sélective d'une table locale vers une base de donnée
    distante. Elle sélectionne une ligne à partir de la table locale en se
    basant sur la clé primaire, puis construit une commande SQL
    <command>UPDATE</command> qui duplique cette ligne, mais avec pour valeurs
    de clé primaire celles du dernier argument.
    (Pour faire une copie exacte de la ligne, on indique les mêmes valeurs
    pour les deux derniers arguments.) La commande <command>UPDATE</command>
    affecte toujours tous les champs de la ligne &mdash; la différence
    principale entre cette instruction et <function>dblink_build_sql_insert</function> est
    l'hypothèse de l'existence de la ligne cible dans la table distante.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>relname</parameter></term>
     <listitem>
      <para>
       Le nom d'une relation locale, par exemple <literal>foo</literal> ou
       <literal>monschema.matable</literal>. Ajouter des guillemets doubles
       si le nom est en casse mixte ou contient des
       caractères spéciaux, par exemple <literal>"FooBar"</literal>&nbsp;;
       sans guillemets, la chaîne est forcée en minuscule.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>primary_key_attnums</parameter></term>
     <listitem>
      <para>
       Les numéros des attributs (commençant à 1) des champs de la clé primaire,
       par exemple <literal>1 2</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>num_primary_key_atts</parameter></term>
     <listitem>
      <para>
       Le nombre de champs de la clé primaire.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>src_pk_att_vals_array</parameter></term>
     <listitem>
      <para>
       Les valeurs des champs de la clé primaire à utiliser pour identifier le
       tuple local. Chaque champ est représenté dans sa forme textuelle. Une
       erreur est renvoyée s'il n'y a pas de lignes locales avec ces valeurs
       de clé primaire.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>tgt_pk_att_vals_array</parameter></term>
     <listitem>
      <para>
       Les valeurs des champs de la clé primaire à placer dans la commande
       <command>UPDATE</command> résultante. Chaque champ est représenté dans
       sa forme textuelle.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>Renvoie l'instruction SQL demandée en tant que texte.</para>
  </refsect1>

  <refsect1>
   <title>Notes</title>

   <para>
    À partir de <productname>PostgreSQL</productname> 9.0, les numéros des
    attributs dans <parameter>primary_key_attnums</parameter> sont interprétés
    comme des numéros logiques de colonnes correspondant à la position de la
    colonne dans <literal>SELECT * FROM relation</literal>. Les versions
    précédentes interprétaient les numéros comme des positions physiques de
    colonnes. Une différence existe si une des colonnes à gauche de la colonne
    indiquée a été supprimé de la table.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

<screen>
SELECT dblink_build_sql_update('foo', '1 2', 2, '{"1", "a"}', '{"1", "b"}');
                   dblink_build_sql_update
-------------------------------------------------------------
 UPDATE foo SET f1='1',f2='b',f3='1' WHERE f1='1' AND f2='b'
(1 row)
</screen>
  </refsect1>
 </refentry>

</sect1>
