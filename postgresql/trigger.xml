<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

 <chapter id="triggers">
  <title>Déclencheurs (triggers)</title>

  <indexterm zone="triggers">
   <primary>trigger</primary>
  </indexterm>

  <para>
   Ce chapitre fournit des informations générales sur l'écriture des fonctions
   pour déclencheur. Les fonctions pour déclencheurs peuvent être écrites dans
   la plupart des langages de procédure disponibles incluant
   <application>PL/pgSQL</application> (<xref linkend="plpgsql"/>),
   <application>PL/Tcl</application> (<xref linkend="pltcl"/>),
   <application>PL/Perl</application> (<xref linkend="plperl"/>) et
   <application>PL/Python</application> (<xref linkend="plpython"/>). Après avoir
   lu ce chapitre, vous devriez consulter le chapitre sur votre langage de
   procédure favori pour découvrir les spécificités de l'écriture de déclencheurs dans ce langage.
  </para>

  <para>
   Il est aussi possible d'écrire une fonction déclencheur en C, bien que la plupart
   des gens trouvent plus facile d'utiliser un des langages de procédure. Il est 
   actuellement impossible d'écrire une fonction déclencheur dans le langage de
   fonction simple SQL.
  </para>

  <sect1 id="trigger-definition">
   <title>Aperçu du comportement des déclencheurs</title>

   <para>
    Un déclencheur spécifie que la base de données doit
    exécuter automatiquement une fonction donnée chaque fois qu'un certain type d'opération est
    exécuté. Les fonctions déclencheur peuvent être attachées à une table ou
    à une vue.
  </para>

  <para>
    Sur des tables, les triggers peuvent être définies pour s'exécuter
    avant ou après une commande <command>INSERT</command>,
    <command>UPDATE</command> ou <command>DELETE</command>, soit une fois par
    ligne modifiée, soit une fois par expression <acronym>SQL</acronym>.
    Les triggers <command>UPDATE</command> peuvent en plus être configurées
    pour n'être déclenchés que si certaines colonnes sont mentionnées dans la
    clause <literal>SET</literal> de l'instruction <command>UPDATE</command>.
    Les triggers peuvent aussi se déclencher pour des instructions
    <command>TRUNCATE</command>. Si un événement d'un trigger intervient, la
    fonction du trigger est appelée au moment approprié pour gérer
    l'événement.
    </para>

   <para>
    Des triggers peuvent être définies sur des vues pour exécuter des opérations
    à la place des commandes <command>INSERT</command>, <command>UPDATE</command>
    ou <command>DELETE</command>. Les triggers <literal>INSTEAD OF</literal>
    sont déclenchés une fois par ligne devant être modifiée dans la vue. C'est
    de la responsabilité de la fonction trigger de réaliser les modifications
    nécessaires pour que les tables de base sous-jacentes et, si approprié,
    de renvoyer la ligne modifiée comme elle apparaîtra dans la vue. Les
    triggers sur les vues peuvent aussi être définis pour s'exécuter une
    fois par requête <acronym>SQL</acronym> statement, avant ou après des
    opérations <command>INSERT</command>, <command>UPDATE</command> ou
    <command>DELETE</command> operations.
   </para>

   <para>
    La fonction déclencheur doit être définie avant que le déclencheur lui-même
    puisse être créé. La fonction déclencheur doit être déclarée comme une
    fonction ne prenant aucun argument et retournant un type <literal>trigger</literal>
    (la fonction déclencheur reçoit ses entrées via une structure
    <structname>TriggerData</structname> passée spécifiquement, et non pas sous la forme
    d'arguments ordinaires de fonctions).
   </para>

   <para>
    Une fois qu'une fonction déclencheur est créée, le déclencheur (trigger)
    est créé avec <xref linkend="sql-createtrigger"/>.
    La même fonction déclencheur est utilisable par plusieurs déclencheurs.
   </para>

   <para>
    <productname>PostgreSQL</productname> offre des déclencheurs
    <firstterm>par ligne</firstterm> et <firstterm>par instruction</firstterm>. Avec un
    déclencheur mode ligne, la fonction du
    déclencheur est appelée une fois pour chaque ligne affectée par
    l'instruction qui a lancé le déclencheur. Au contraire, un déclencheur mode
    instruction n'est appelé qu'une seule fois lorsqu'une instruction appropriée
    est exécutée, quelque soit le nombre de lignes affectées par cette
    instruction. En particulier, une instruction n'affectant aucune ligne
    résultera toujours en l'exécution de tout déclencheur mode instruction
    applicable. Ces deux types sont quelque fois appelés respectivement des
    <firstterm>déclencheurs niveau ligne</firstterm> et des
    <firstterm>déclencheurs niveau instruction</firstterm>.
    Les triggers sur <command>TRUNCATE</command> peuvent seulement être définis
    au niveau instruction. Sur des vues, les triggers qui se déclenchent avant
    ou après peuvent être seulement définis au niveau instruction alors que
    les triggers qui ont un déclenchement <quote>à la place</quote> d'un
    <command>INSERT</command>, <command>UPDATE</command> ou
    <command>DELETE</command> peuvent seulement être définis au niveau ligne.
   </para>

   <para>
    Les triggers sont aussi classifiées suivant qu'ils se déclenchent avant
    (<firstterm>before</firstterm>), après (<firstterm>after</firstterm>) ou
    à la place (<firstterm>instead of</firstterm>) de l'opération. Ils sont
    référencés respectivement comme des triggers <literal>BEFORE</literal>,
    <literal>AFTER</literal> et <literal>INSTEAD OF</literal>. Les triggers
    <literal>BEFORE</literal> au niveau requête se déclenchent avant que la
    requête ne commence quoi que ce soit alors que les triggers
    <literal>AFTER</literal> au niveau requête se déclenchent tout à la fin de
    la requête. Ces types de triggers peuvent être définis sur les tables et
    vues. Les triggers <literal>BEFORE</literal> au niveau ligne se déclenchent
    immédiatement avant l'opération sur une ligne particulière alors que les
    triggers <literal>AFTER</literal> au niveau ligne se déclenchent à la fin
    de la requête (mais avant les triggers <literal>AFTER</literal> au niveau
    requête). Ces types de triggers peuvent seulement être définis sur les
    tables. Les triggers <literal>INSTEAD OF</literal> au niveau ligne
    peuvent seulement être définis sur des vues et se déclenchent immédiatement
    sur chaque ligne de la vue qui est identifiée comme nécessitant cette
    opération.
   </para>

   <para>
   Les fonctions déclencheurs appelées par des déclencheurs niveau instruction
   devraient toujours renvoyer <symbol>NULL</symbol>. Les fonctions déclencheurs
   appelées par des déclencheurs niveau ligne peuvent renvoyer une ligne de la
   table (une valeur de type <structname>HeapTuple</structname>) vers
   l'exécuteur appelant, s'ils le veulent. Un déclencheur niveau ligne exécuté
   avant une opération a les choix suivants&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       Il peut retourner un pointeur <symbol>NULL</symbol> pour sauter l'opération
       pour la ligne courante. Ceci donne comme instruction à l'exécuteur de ne pas exécuter
       l'opération niveau ligne qui a lancé le déclencheur (l'insertion, la
       modification ou la suppression d'une ligne particulière de la table).
       </para>
     </listitem>

     <listitem>
      <para>
       Pour les déclencheurs <command>INSERT</command> et
       <command>UPDATE</command> de niveau ligne uniquement, la valeur de retour devient la
       ligne qui sera insérée ou remplacera la ligne en cours de mise à jour.
       Ceci permet à la fonction déclencheur de modifier la ligne en cours
       d'insertion ou de mise à jour.
      </para>
     </listitem>
    </itemizedlist>


    Un déclencheur <literal>BEFORE</literal> niveau ligne qui ne serait pas conçu pour avoir l'un de
    ces comportements doit prendre garde à retourner la même ligne que celle
    qui lui a été passée comme nouvelle ligne (c'est-à-dire : pour des déclencheurs
    <command>INSERT</command> et <command>UPDATE</command> : la nouvelle
    (<varname>NEW</varname>) ligne ,et pour les déclencheurs
    <command>DELETE</command>) : l'ancienne
    (<varname>OLD</varname>) ligne .
   </para>

   <para>
    Un trigger <literal>INSTEAD OF</literal> niveau ligne devrait renvoyer
    soit <symbol>NULL</symbol> pour indiquer qu'il n'a pas modifié de données
    des tables de base sous-jacentes de la vue, soit la ligne de la vue qui lui
    a été passé (la ligne <varname>NEW</varname> pour les opérations
    <command>INSERT</command> et <command>UPDATE</command>, ou la ligne
    <varname>OLD</varname> pour l'opération <command>DELETE</command>). Une
    valeur de retour différent de NULL est utilisée comme signal indiquant que
    le trigger a réalisé les modifications de données nécessaires dans la vue.
    Ceci causera l'incrémentation du nombre de lignes affectées par la commande.
    Pour les opérations <command>INSERT</command> et <command>UPDATE</command>,
    le trigger peut modifier la ligne <varname>NEW</varname> avant de la
    renvoyer. Ceci modifiera les données renvoyées par <command>INSERT
    RETURNING</command> ou <command>UPDATE RETURNING</command>, et est utile
    quand la vue n'affichera pas exactement les données fournies.
   </para>

   <para>
    La valeur de retour est ignorée pour les déclencheurs niveau ligne lancés
    après une opération. Ils peuvent donc renvoyer la valeur
    <symbol>NULL</symbol>.
   </para>

   <para>
    Si plus d'un déclencheur est défini pour le même événement sur la même
    relation, les déclencheurs seront lancés dans l'ordre alphabétique de leur
    nom. Dans le cas de déclencheurs <literal>BEFORE</literal> et
    <literal>INSTEAD OF</literal>, la ligne 
    renvoyée par chaque déclencheur, qui a éventuellement été modifiée, devient l'argument du
    prochain déclencheur. Si un des déclencheurs <literal>BEFORE</literal> ou
    <literal>INSTEAD OF</literal> renvoie un pointeur
    <symbol>NULL</symbol>, l'opération est abandonnée pour cette ligne et les
    déclencheurs suivants ne sont pas lancés (pour cette ligne).
   </para>

   <para>
    Une définition de trigger peut aussi spécifier une condition booléenne
    <literal>WHEN</literal> qui sera testée pour savoir si le trigger doit
    bien être déclenché. Dans les triggers de niveau ligne, la condition
    <literal>WHEN</literal> peut examiner l'ancienne et la nouvelle valeur
    des colonnes de la ligne. (les triggers de niveau instruction peuvent
    aussi avoir des conditions <literal>WHEN</literal> mais cette fonctionnalité
    est moins intéressante pour elles). Dans un trigger
    <firstterm>avant</firstterm>, la condition <literal>WHEN</literal> est
    évaluée juste avant l'exécution de la fonction, donc l'utilisation de
    <literal>WHEN</literal> n'est pas réellement différente du test de la même
    condition au début de la fonction trigger. Néanmoins, dans un tigger
    <literal>AFTER</literal>, la condition <literal>WHEN</literal> est
    évaluée juste avant la mise à jour de la ligne et détermine si un événement
    va déclencher le trigger à la fin de l'instruction. Donc, quand la
    condition <literal>WHEN</literal> d'un trigger <literal>AFTER</literal>
    ne renvoie pas true, il n'est pas nécessaire de mettre en queue un
    événement ou de récupérer de nouveau la ligne à la fin de l'instriction.
    Ceci permet une amélioration conséquente des performances pour les
    instructions qui modifient un grand nombre de lignes si le trigger a
    seulement besoin d'être exécuté que sur quelques lignes. Les triggers
    <literal>INSTEAD OF</literal> n'acceptent pas les conditions
    <literal>WHEN</literal>.
   </para>

   <para>
    Les déclencheurs <literal>BEFORE</literal> en mode ligne sont typiquement utilisés pour
    vérifier ou modifier les données qui seront insérées ou mises à jour. Par
    exemple, un déclencheur <literal>BEFORE</literal> pourrait être utilisé pour insérer l'heure
    actuelle dans une colonne de type <type>timestamp</type> ou pour vérifier que deux
    éléments d'une ligne sont cohérents. Les déclencheurs <literal>AFTER</literal> en mode ligne
    sont pour la plupart utilisés pour propager des mises à jour vers d'autres
    tables ou pour réaliser des tests de cohérence avec d'autres tables. La
    raison de cette division du travail est qu'un déclencheur <literal>AFTER</literal> peut être
    certain qu'il voit la valeur finale de la ligne alors qu'un déclencheur
    <literal>BEFORE</literal> ne l'est pas&nbsp;; il pourrait exister d'autres déclencheurs <literal>BEFORE</literal>
    qui seront exécutés après lui. Si vous n'avez aucune raison spéciale pour le
    moment du déclenchement, le cas <literal>BEFORE</literal> est plus efficace car l'information
    sur l'opération n'a pas besoin d'être sauvegardée jusqu'à la fin du
    traitement.
   </para>

   <para>
    Si une fonction déclencheur exécute des commandes SQL,
    alors ces commandes peuvent lancer à leur tour des déclencheurs. On appelle ceci un
    déclencheur en cascade. Il n'y a pas de limitation directe du nombre de
    niveaux de cascade. Il est possible que les cascades causent un appel
    récursif du même déclencheur&nbsp;; par exemple, un déclencheur
    <command>INSERT</command> pourrait exécuter une commande qui insère une
    ligne supplémentaire dans la même table, entraînant un nouveau lancement du
    déclencheur <command>INSERT</command>. Il est de la responsabilité du
    programmeur d'éviter les récursions infinies dans de tels scénarios.
   </para>

    <indexterm>
     <primary>trigger</primary>
     <secondary>arguments pour la fonction trigger</secondary>
    </indexterm>

   <para>
    Quand un déclencheur est défini, des arguments peuvent être spécifiés pour
    lui. L'objectif de l'inclusion d'arguments dans la définition du
    déclencheur est de permettre à différents déclencheurs ayant des exigences
    similaires d'appeler la même fonction. Par exemple, il pourrait y avoir une
    fonction déclencheur généralisée qui prend comme arguments deux noms de
    colonnes et place l'utilisateur courant dans l'une et un horodatage dans
    l'autre. Correctement écrit, cette fonction déclencheur serait indépendante
    de la table particulière sur laquelle il se déclenche. Ainsi, la même
    fonction pourrait être utilisée pour des événements
    <command>INSERT</command> sur n'importe quelle table ayant des colonnes
    adéquates, pour automatiquement suivre les créations d'enregistrements dans
    une table de transactions par exemple. Elle pourrait aussi être utilisée
    pour suivre les dernières mises à jours si elle est définie comme un
    déclencheur <command>UPDATE</command>.
   </para>

   <para>
    Chaque langage de programmation supportant les déclencheurs a sa propre
    méthode pour rendre les données en entrée disponible à la fonction du
    déclencheur. Cette donnée en entrée inclut le type d'événement du
    déclencheur (c'est-à-dire <command>INSERT</command> ou
    <command>UPDATE</command>) ainsi que tous les arguments listés dans
    <command>CREATE TRIGGER</command>. Pour un déclencheur niveau ligne, la donnée en
    entrée inclut aussi la ligne <varname>NEW</varname> pour les déclencheurs
    <command>INSERT</command> et <command>UPDATE</command> et/ou la ligne
    <varname>OLD</varname> pour les déclencheurs <command>UPDATE</command> et
    <command>DELETE</command>. Les déclencheurs niveau instruction n'ont
    actuellement aucun moyen pour examiner le(s) ligne(s) individuelle(s)
    modifiées par l'instruction.
   </para>

  </sect1>

  <sect1 id="trigger-datachanges">
   <title>Visibilité des modifications des données</title>

   <para>
    Si vous exécutez des commandes SQL dans votre fonction SQL et que ces
    commandes accèdent à la table pour laquelle vous créez ce déclencheur,
    alors vous avez besoin de connaître les règles de visibilité des données
    car elles déterminent si les commandes SQL voient les modifications de données pour
    lesquelles est exécuté le déclencheur. En bref&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
      Les déclencheurs niveau instruction suivent des règles de visibilité
      simples&nbsp;: aucune des modifications réalisées par une instruction
      n'est visible aux déclencheurs niveau instruction appelés avant
      l'instruction alors que toutes les modifications sont visibles aux
      déclencheurs <literal>AFTER</literal> niveau instruction.
	     </para>
     </listitem>
     
     <listitem>
      <para>
      Les modifications de données (insertion, mise à jour ou suppression)
      lançant le déclencheur ne sont naturellement <emphasis>pas</emphasis>
      visibles aux commandes SQL exécutées dans un déclencheur <literal>BEFORE</literal> en mode
      ligne parce qu'elles ne sont pas encore survenues.
      </para>
     </listitem>
     
     <listitem>
      <para>
      Néanmoins, les commandes SQL exécutées par un déclencheur <literal>BEFORE</literal> en mode
      ligne <emphasis>verront</emphasis> les effets des modifications de données
      pour les lignes précédemment traitées dans la même commande externe. Ceci
      requiert une grande attention car l'ordre des événements de modification
      n'est en général pas prévisible&nbsp;; une commande SQL affectant
      plusieurs lignes pourrait visiter les lignes dans n'importe quel ordre.
      </para>
     </listitem>
     
     <listitem>
      <para>
       De façon similaire, un trigger niveau ligne de type <literal>INSTEAD
       OF</literal> verra les effets des modifications de données réalisées
       par l'exécution des autres triggers <literal>INSTEAD
       OF</literal> dans la même commande.
      </para>
     </listitem>

     <listitem>
      <para>
      Quand un déclencheur <literal>AFTER</literal> en mode ligne est exécuté, toutes les
      modifications de données réalisées par la commande externe sont déjà
      terminées et sont visibles par la fonction appelée par le déclencheur.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Si votre fonction trigger est écrite dans un des langages de procédures
    standard, alors les instructions ci-desus s'appliquent seulement si la
    fonction est déclarée <literal>VOLATILE</literal>. Les fonctions déclarées
    <literal>STABLE</literal> ou <literal>IMMUTABLE</literal> ne verront pas
    les modifications réalisées par la commande appelante dans tous les cas.
   </para>

   <para>
    Il existe plus d'informations sur les règles de visibilité des données dans
    la <xref linkend="spi-visibility"/>. L'exemple dans la <xref
    linkend="trigger-example"/> contient une démonstration de ces règles.
   </para>
  </sect1>

  <sect1 id="trigger-interface">
   <title>Écrire des fonctions déclencheurs en C</title>

   <indexterm zone="trigger-interface">
    <primary>trigger</primary>
    <secondary>en C</secondary>
   </indexterm>

   <para>
    Cette section décrit les détails de bas niveau de l'interface d'une fonction
    déclencheur. Ces informations ne sont nécessaires que lors de l'écriture
    d'une fonction déclencheur en C. Si vous utilisez un langage de plus haut
    niveau, ces détails sont gérés pour vous. Dans la plupart des cas, vous
    devez considérer l'utilisation d'un langage de procédure avant d'écrire
    vos déclencheurs en C. La documentation de chaque langage de procédures
    explique comment écrire un déclencheur dans ce langage.
   </para>

   <para>
    Les fonctions déclencheurs doivent utiliser la <quote>version 1</quote> de
    l'interface du gestionnaire de fonctions.
   </para>

   <para>
    Quand une fonction est appelée par le gestionnaire de déclencheur, elle ne
    reçoit aucun argument classique, mais un pointeur de <quote>contexte</quote>
    pointant sur une structure <structname>TriggerData</structname>. Les fonctions C
    peuvent vérifier si elles sont appelées par le gestionnaire de déclencheurs
    ou pas en exécutant la macro&nbsp;:
<programlisting>CALLED_AS_TRIGGER(fcinfo)
</programlisting>
    qui se décompose en&nbsp;:
<programlisting>((fcinfo)-&gt;context != NULL &amp;&amp; IsA((fcinfo)-&gt;context, TriggerData))
</programlisting>
    Si elle retourne la valeur vraie, alors il est bon de convertir
    <literal>fcinfo-&gt;context</literal> en type <literal>TriggerData *</literal> et
de
    faire usage de la structure pointée <structname>TriggerData</structname>. La fonction
    <emphasis>ne</emphasis> doit <emphasis>pas</emphasis> modifier la
    structure <structname>TriggerData</structname> ou une donnée quelconque vers laquelle
    elle pointe.
   </para>

   <para>
    <structname>struct TriggerData</structname> est définie dans
    <filename>commands/trigger.h</filename>&nbsp;:

<programlisting>typedef struct TriggerData
{
    NodeTag       type;
    TriggerEvent  tg_event;
    Relation      tg_relation;
    HeapTuple     tg_trigtuple;
    HeapTuple     tg_newtuple;
    Trigger      *tg_trigger;
    Buffer        tg_trigtuplebuf;
    Buffer        tg_newtuplebuf;
} TriggerData;
</programlisting>

    où les membres sont définis comme suit&nbsp;:

    <variablelist>
     <varlistentry>
      <term><structfield>type</structfield></term>
      <listitem>
       <para>
        Toujours <literal>T_TriggerData</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_event</structfield></term>
      <listitem>
       <para>
	Décrit l'événement pour lequel la fonction est appelée. Vous pouvez utiliser
	les macros suivantes pour examiner <literal>tg_event</literal>&nbsp;:

	<variablelist>
	 <varlistentry>
	  <term><literal>TRIGGER_FIRED_BEFORE(tg_event)</literal></term>
	  <listitem>
	   <para>
	    Renvoie vrai si le déclencheur est lancé avant l'opération.
	   </para>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term><literal>TRIGGER_FIRED_AFTER(tg_event)</literal></term>
	  <listitem>
	   <para>
	    Renvoie vrai si le déclencheur est lancé après l'opération.
	   </para>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
      <term><literal>TRIGGER_FIRED_INSTEAD(tg_event)</literal></term>
      <listitem>
       <para>
        Renvoie vrai si le trigger a été lancé à la place de l'opération.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
	  <term><literal>TRIGGER_FIRED_FOR_ROW(tg_event)</literal></term>
	  <listitem>
	   <para>
	    Renvoie vrai si le déclencheur est lancé pour un événement en
            mode ligne.
	   </para>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term><literal>TRIGGER_FIRED_FOR_STATEMENT(tg_event)</literal></term>
	  <listitem>
	   <para>
	    Renvoie vrai si le déclencheur est lancé pour un événement en
            mode instruction.
           </para>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term><literal>TRIGGER_FIRED_BY_INSERT(tg_event)</literal></term>
	  <listitem>
	   <para>
	    Retourne vrai si le déclencheur est lancé par une commande 
	    <command>INSERT</command>.
	   </para>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term><literal>TRIGGER_FIRED_BY_UPDATE(tg_event)</literal></term>
	  <listitem>
	   <para>
	    Retourne vrai si le déclencheur est lancé par une commande
            <command>UPDATE</command>.
	   </para>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term><literal>TRIGGER_FIRED_BY_DELETE(tg_event)</literal></term>
	  <listitem>
	   <para>
	    Retourne vrai si le déclencheur est lancé par une commande
            <command>DELETE</command>.
	   </para>
	  </listitem>
	 </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_TRUNCATE(tg_event)</literal></term>
          <listitem>
           <para>
            Renvoie true si le trigger a été déclenché par une commande
	    <command>TRUNCATE</command>.
           </para>
          </listitem>
         </varlistentry>
	</variablelist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_relation</structfield></term>
      <listitem>
       <para>
	Un pointeur vers une structure décrivant la relation pour laquelle le
        déclencheur est lancé. Voir <filename>utils/reltrigger.h</filename> pour les détails
        de cette structure. Les choses les plus intéressantes sont 
	<literal>tg_relation-&gt;rd_att</literal> (descripteur de nuplets de la
	relation) et <literal>tg_relation-&gt;rd_rel-&gt;relname</literal> (nom de la
	relation&nbsp;;
        le type n'est pas <type>char*</type> mais <type>NameData</type>&nbsp;; utilisez
        <literal>SPI_getrelname(tg_relation)</literal> pour obtenir un <type>char*</type>
	si vous avez besoin d'une copie du nom).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_trigtuple</structfield></term>
      <listitem>
       <para>
	Un pointeur vers la ligne pour laquelle le déclencheur a été lancé. Il
        s'agit de la ligne étant insérée, mise à jour ou effacée. Si ce
	déclencheur a été lancé pour une commande <command>INSERT</command> ou
        <command>DELETE</command>, c'est cette valeur que la fonction doit retourner si
        vous ne voulez pas remplacer la ligne par une ligne différente (dans le
        cas d'un <command>INSERT</command>) ou sauter l'opération.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_newtuple</structfield></term>
      <listitem>
       <para>
	Un pointeur vers la nouvelle version de la ligne, si le déclencheur a
        été lancé pour un <command>UPDATE</command> et <symbol>NULL</symbol> si c'est
        pour un <command>INSERT</command> ou un <command>DELETE</command>.
        C'est ce que la fonction doit retourner si l'événement est un
        <command>UPDATE</command> et que vous ne voulez pas remplacer cette
        ligne par une ligne différente ou bien sauter l'opération.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_trigger</structfield></term>
      <listitem>
       <para>
	Un pointeur vers une structure de type <structname>Trigger</structname>, définie
        dans <filename>utils/rel.h</filename>&nbsp;:

<programlisting>typedef struct Trigger
{
    Oid         tgoid;
    char       *tgname;
    Oid         tgfoid;
    int16       tgtype;
    char        tgenabled;
    bool        tgisinternal;
    Oid         tgconstrrelid;
    Oid         tgconstrindid;
    Oid         tgconstraint;
    bool        tgdeferrable;
    bool        tginitdeferred;
    int16       tgnargs;
    int16       tgnattr;
    int16      *tgattr;
    char      **tgargs;
    char       *tgqual;
} Trigger;
</programlisting>

       où <structfield>tgname</structfield> est le nom du déclencheur,
       <structfield>tgnargs</structfield> est le nombre d'arguments dans
       <structfield>tgargs</structfield> et <structfield>tgargs</structfield> est un tableau de
       pointeurs vers les arguments spécifiés dans l'expression contenant la
       commande <command>CREATE TRIGGER</command>. Les autres membres ne sont
       destinés qu'à un usage interne.
       </para>
      </listitem>
      </varlistentry>

      <varlistentry>
       <term><structfield>tg_trigtuplebuf</structfield></term>
        <listitem>
         <para>
          Le tampon contenant <structfield>tg_trigtuple</structfield> ou
          <symbol>InvalidBuffer</symbol> s'il n'existe pas une telle ligne ou si
          elle n'est pas stockée dans un tampon du disque.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><structfield>tg_newtuplebuf</structfield></term>
         <listitem>
          <para>
           Le tampon contenant <structfield>tg_newtuple</structfield> ou
           <symbol>InvalidBuffer</symbol> s'il n'existe pas une telle ligne ou
           si elle n'est pas stockée dans un tampon du disque.
	  </para>
         </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Une fonction déclencheur doit retourner soit un pointeur
    <structname>HeapTuple</structname> soit un pointeur <symbol>NULL</symbol> (<emphasis>pas</emphasis>
    une valeur SQL NULL, donc ne positionnez pas <parameter>isNull</parameter> à
    true). Faites attention de renvoyer soit un
    <structfield>tg_trigtuple</structfield> soit un <structfield>tg_newtuple</structfield>,
    comme approprié, si vous ne voulez pas changer la ligne en cours de
    modification.
   </para>

  </sect1>

  <sect1 id="trigger-example">
   <title>Un exemple complet de trigger</title>

   <para>
    Voici un exemple très simple de fonction déclencheur écrite en C (les
    exemples de déclencheurs écrits avec différents langages de procédures
    se trouvent dans la documentation de ceux-ci).
   </para>

   <para>
    La fonction <function>trigf</function> indique le nombre de lignes de la table
    <structname>ttest</structname> et saute l'opération si la commande tente d'insérer une
    valeur NULL dans la colonne <structfield>x</structfield> (ainsi le déclencheur agit
    comme une contrainte non NULL mais n'annule pas la transaction).
   </para>

   <para>
    Tout d'abord, la définition des tables&nbsp;:
<programlisting>CREATE TABLE ttest (
    x integer
);
</programlisting>
   </para>

   <para>
    Voici le code source de la fonction trigger :
<programlisting><![CDATA[#include "postgres.h"
#include "executor/spi.h"       /* nécessaire pour fonctionner avec SPI */
#include "commands/trigger.h"   /* ... les déclencheurs */
#include "utils/rel.h"          /* ... et relations */

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

extern Datum trigf(PG_FUNCTION_ARGS);

PG_FUNCTION_INFO_V1(trigf);

Datum
trigf(PG_FUNCTION_ARGS)
{
    TriggerData *trigdata = (TriggerData *) fcinfo->context;
    TupleDesc   tupdesc;
    HeapTuple   rettuple;
    char       *when;
    bool        checkNULL = false;
    bool        isNULL;
    int         ret, i;

    /* on s'assure que la fonction est appelée en tant que déclencheur */
    if (!CALLED_AS_TRIGGER(fcinfo))
        elog(ERROR, "trigf: not called by trigger manager");

    /* nuplet à retourner à l'exécuteur */
    if (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))
        rettuple = trigdata->tg_newtuple;
    else
        rettuple = trigdata->tg_trigtuple;

    /* vérification des valeurs NULL */
    if (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event)
        && TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        checkNULL = true;

    if (TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        when = "before";
    else
        when = "after ";

    tupdesc = trigdata->tg_relation->rd_att;

    /* connexion au gestionnaire SPI */
    if ((ret = SPI_connect()) < 0)
        elog(ERROR, "trigf (fired %s): SPI_connect returned %d", when, ret);

    /* obtient le nombre de lignes dans la table */
    ret = SPI_exec("SELECT count(*) FROM ttest", 0);

    if (ret < 0)
        elog(ERROR, "trigf (fired %s): SPI_exec returned %d", when, ret);

    /* count(*) renvoie int8, prenez garde à bien convertir */
    i = DatumGetInt64(SPI_getbinval(SPI_tuptable->vals[0],
                                    SPI_tuptable->tupdesc,
                                    1,
                                    &isNULL));

    elog (INFO, "trigf (fired %s): there are %d rows in ttest", when, i);

    SPI_finish();

    if (checkNULL)
    {
        SPI_getbinval(rettuple, tupdesc, 1, &isNULL);
        if (isNULL)
            rettuple = NULL;
    }

    return PointerGetDatum(rettuple);
}
]]></programlisting>
   </para>

   <para>
    Après avoir compilé le code source (voir <xref
    linkend="dfunc"/>), déclarez la fonction et les
    déclencheurs&nbsp;:
<programlisting>CREATE FUNCTION trigf() RETURNS trigger
    AS '<replaceable>nomfichier</replaceable>'
    LANGUAGE C;

CREATE TRIGGER tbefore BEFORE INSERT OR UPDATE OR DELETE ON ttest 
    FOR EACH ROW EXECUTE PROCEDURE trigf();

CREATE TRIGGER tafter AFTER INSERT OR UPDATE OR DELETE ON ttest 
    FOR EACH ROW EXECUTE PROCEDURE trigf();
</programlisting>
   </para>

   <para>
    À présent, testez le fonctionnement du déclencheur&nbsp;:
<screen>=&gt; INSERT INTO ttest VALUES (NULL);
INFO:  trigf (fired before): there are 0 rows in ttest
INSERT 0 0

-- Insertion supprimée et déclencheur APRES non exécuté

=&gt; SELECT * FROM ttest;
 x
---
(0 rows)

=&gt; INSERT INTO ttest VALUES (1);
INFO:  trigf (fired before): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 1 rows in ttest
                                       ^^^^^^^^
                       souvenez-vous de ce que nous avons dit sur la visibilité.
INSERT 167793 1
vac=&gt; SELECT * FROM ttest;
 x
---
 1
(1 row)

=&gt; INSERT INTO ttest SELECT x * 2 FROM ttest;
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
                                       ^^^^^^
                       souvenez-vous de ce que nous avons dit sur la visibilité.
INSERT 167794 1
=&gt; SELECT * FROM ttest;
 x
---
 1
 2
(2 rows)

=&gt; UPDATE ttest SET x = NULL WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
UPDATE 0
=&gt; UPDATE ttest SET x = 4 WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
UPDATE 1
vac=&gt; SELECT * FROM ttest;
 x
---
 1
 4
(2 rows)

=&gt; DELETE FROM ttest;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
                                       ^^^^^^
                       souvenez-vous de ce que nous avons dit sur la visibilité.
DELETE 2
=&gt; SELECT * FROM ttest;
 x
---
(0 rows)
</screen>

   </para>

   <para>
    Vous trouverez des exemples plus complexes dans 
    <filename>src/test/regress/regress.c</filename> et dans
    <xref linkend="contrib-spi"/>.
   </para>
  </sect1>
 </chapter>
