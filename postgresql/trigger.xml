<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="triggers">
 <title>Déclencheurs (triggers)</title>

 <indexterm zone="triggers">
  <primary>trigger</primary>
 </indexterm>

 <para>
  Ce chapitre fournit des informations générales sur l'écriture des fonctions
  pour déclencheur. Les fonctions pour déclencheurs peuvent être écrites dans
  la plupart des langages de procédure disponibles incluant
  <application>PL/pgSQL</application> (<xref linkend="plpgsql"/>),
  <application>PL/Tcl</application> (<xref linkend="pltcl"/>),
  <application>PL/Perl</application> (<xref linkend="plperl"/>) et
  <application>PL/Python</application> (<xref linkend="plpython"/>). Après avoir
  lu ce chapitre, vous devriez consulter le chapitre sur votre langage de
  procédure favori pour découvrir les spécificités de l'écriture de déclencheurs dans ce langage.
 </para>

 <para>
  Il est aussi possible d'écrire une fonction déclencheur en C, bien que la plupart
  des gens trouvent plus facile d'utiliser un des langages de procédure. Il est
  actuellement impossible d'écrire une fonction déclencheur dans le langage de
  fonction simple SQL.
 </para>

 <sect1 id="trigger-definition">
  <title>Aperçu du comportement des déclencheurs</title>

  <para>
   Un déclencheur spécifie que la base de données doit
   exécuter automatiquement une fonction donnée chaque fois qu'un certain type d'opération est
   exécuté. Les fonctions déclencheur peuvent être attachées à une table (partitionnée ou non),
   une vue ou une table distante.
  </para>

  <para>
   Sur des tables et tables distantes, les triggers peuvent être définies pour s'exécuter
   avant ou après une commande <command>INSERT</command>,
   <command>UPDATE</command> ou <command>DELETE</command>, soit une fois par
   ligne modifiée, soit une fois par expression <acronym>SQL</acronym>.
   Les triggers <command>UPDATE</command> peuvent en plus être
   configurées pour n'être déclenchés que si certaines colonnes sont
   mentionnées dans la clause <literal>SET</literal> de l'instruction
   <command>UPDATE</command>.  Les triggers peuvent aussi se déclencher
   pour des instructions
   <command>TRUNCATE</command>. Si un événement d'un trigger intervient, la
   fonction du trigger est appelée au moment approprié pour gérer
   l'événement.
  </para>

  <para>
   Des triggers peuvent être définies sur des vues pour exécuter des opérations
   à la place des commandes <command>INSERT</command>, <command>UPDATE</command>
   ou <command>DELETE</command>. Les triggers <literal>INSTEAD OF</literal>
   sont déclenchés une fois par ligne devant être modifiée dans la vue. C'est
   de la responsabilité de la fonction trigger de réaliser les modifications
   nécessaires pour que les tables de base sous-jacentes d'une vue et, si approprié,
   de renvoyer la ligne modifiée comme elle apparaîtra dans la vue. Les
   triggers sur les vues peuvent aussi être définis pour s'exécuter une
   fois par requête <acronym>SQL</acronym> statement, avant ou après des
   opérations <command>INSERT</command>, <command>UPDATE</command> ou
   <command>DELETE</command>. Néanmoins, de tels triggers sont déclenchés
   seulement s'il existe aussi un trigger <literal>INSTEAD OF</literal> sur
   la vue. Dans le cas contraire, toute requête ciblant la vue doit être
   réécrite en une requête affectant sa (ou ses) table(s) de base. Les
   triggers déclenchés seront ceux de(s) table(s) de base.
  </para>

  <para>
   La fonction déclencheur doit être définie avant que le déclencheur lui-même
   puisse être créé. La fonction déclencheur doit être déclarée comme une
   fonction ne prenant aucun argument et retournant un type <literal>trigger</literal>
   (la fonction déclencheur reçoit ses entrées via une structure
   <structname>TriggerData</structname> passée spécifiquement, et non pas sous la forme
   d'arguments ordinaires de fonctions).
  </para>

  <para>
   Une fois qu'une fonction déclencheur est créée, le déclencheur (trigger)
   est créé avec <xref linkend="sql-createtrigger"/>.
   La même fonction déclencheur est utilisable par plusieurs déclencheurs.
  </para>

  <para>
   <productname>PostgreSQL</productname> offre des déclencheurs
   <firstterm>par ligne</firstterm> et <firstterm>par instruction</firstterm>. Avec un
   déclencheur mode ligne, la fonction du
   déclencheur est appelée une fois pour chaque ligne affectée par
   l'instruction qui a lancé le déclencheur. Au contraire, un déclencheur mode
   instruction n'est appelé qu'une seule fois lorsqu'une instruction appropriée
   est exécutée, quelque soit le nombre de lignes affectées par cette
   instruction. En particulier, une instruction n'affectant aucune ligne
   résultera toujours en l'exécution de tout déclencheur mode instruction
   applicable. Ces deux types sont quelque fois appelés respectivement des
   <firstterm>déclencheurs niveau ligne</firstterm> et des
   <firstterm>déclencheurs niveau instruction</firstterm>.
   Les triggers sur <command>TRUNCATE</command> peuvent seulement être définis
   au niveau instruction, et non pas au niveau ligne.
  </para>

  <para>
   Les triggers sont aussi classifiées suivant qu'ils se déclenchent avant
   (<firstterm>before</firstterm>), après (<firstterm>after</firstterm>) ou
   à la place (<firstterm>instead of</firstterm>) de l'opération. Ils sont
   référencés respectivement comme des triggers <literal>BEFORE</literal>,
   <literal>AFTER</literal> et <literal>INSTEAD OF</literal>. Les triggers
   <literal>BEFORE</literal> au niveau requête se déclenchent avant que la
   requête ne commence quoi que ce soit alors que les triggers
   <literal>AFTER</literal> au niveau requête se déclenchent tout à la fin de
   la requête. Ces types de triggers peuvent être définis sur les tables,
   vues et tables externes. Les triggers <literal>BEFORE</literal> au niveau ligne se déclenchent
   immédiatement avant l'opération sur une ligne particulière alors que les
   triggers <literal>AFTER</literal> au niveau ligne se déclenchent à la fin
   de la requête (mais avant les triggers <literal>AFTER</literal> au niveau
   requête). Ces types de triggers peuvent seulement être définis sur les
   tables non partitionnées et tables distantes, et non pas les vues. Les
   triggers <literal>INSTEAD OF</literal> peuvent seulement être définis sur
   des vues, et seulement au niveau ligne. Ils se déclenchent immédiatement
   pour chaque ligne de la vue identifiée comme nécessitant une action.
   </para>

   <para>
    Une instruction qui cible une table parent dans un héritage ou une
    hiérarchie de partitionnement ne cause pas le déclenchement des tiggers au
    niveau requête des tables filles affectées. Seuls les triggers au niveau
    requête de la table parent sont déclenchés. Néanmoins, les triggers niveau
    ligne de toute table fille affecté seront déclenchés.
   </para>

   <para>
     Si une commande <command>INSERT</command> contient une clause
     <literal>ON CONFLICT DO UPDATE</literal>, il est possible que les
     effets des déclencheurs niveau ligne
     <literal>BEFORE</literal> <command>INSERT</command> et
     <literal>BEFORE</literal> <command>UPDATE</command> puissent être
     tous les deux appliqués de telle sorte que leurs effets soient
     visibles dans la version finale de la ligne mise à jour, si une
     colonne <varname>EXCLUDED</varname> est référencée. Il n'est
     néanmoins pas nécessaire qu'il soit fait référence à une colonne
     <varname>EXCLUDED</varname> pour que les deux types de déclencheurs
     BEFORE s'exécutent tout de même. La possibilité d'avoir des
     résultats surprenants devrait être prise en compte quand il existe
     des déclencheurs niveau ligne <literal>BEFORE</literal>
     <command>INSERT</command> et <literal>BEFORE</literal>
     <command>UPDATE</command> qui tous les deux modifient la ligne sur le
     point d'être insérée ou mise à jour (ceci peut être problématique
     si les modifications sont plus ou moins équivalentes et si elles ne
     sont pas idempotente). Notez que les déclencheurs
     <command>UPDATE</command> niveau instruction sont exécutés lorsque
     la clause <literal>ON CONFLICT DO UPDATE</literal> est spécifiée,
     quand bien même aucune ligne ne serait affectée par la commande
     <command>UPDATE</command> (et même si la commande
     <command>UPDATE</command> n'est pas exécutée). Une commande
     <command>INSERT</command> avec une clause <literal>ON CONFLICT DO
     UPDATE</literal> exécutera d'abord les déclencheurs niveau
     instruction <literal>BEFORE</literal> <command>INSERT</command>,
     puis les déclencheurs niveau instruction <literal>BEFORE</literal>
     <command>UPDATE</command>, suivis par les déclencheurs niveau
     instruction <literal>AFTER</literal> <command>UPDATE</command>,
     puis finalement les déclencheurs niveau instruction
     <literal>AFTER</literal> <command>INSERT</command>.
   </para>

   <para>
    Si un <command>UPDATE</command> sur une table partitionnée implique le
    déplacement d'une ligne vers une autre partition, il sera réalisé comme un
    <command>DELETE</command> de la partition originale, suivi d'un
    <command>INSERT</command> dans la nouvelle partition. Dans ce cas, les
    triggers <literal>BEFORE</literal> <command>UPDATE</command> niveau ligne
    et tous les triggers <literal>BEFORE</literal> <command>DELETE</command>
    niveau ligne sont déclenchés sur la partition originale. Puis tous les
    triggers <literal>BEFORE</literal> <command>INSERT</command> niveau ligne
    sont déclenchés sur la partition destination. La possibilité de résultats
    surprenants doit être considéré quand tous les triggers affectent la ligne
    déplacée. En ce qui concerne les triggers <literal>AFTER ROW</literal>,
    les triggers <literal>AFTER</literal> <command>DELETE</command> et
    <literal>AFTER</literal> <command>INSERT</command> sont appliqués mais les
    triggers <literal>AFTER</literal> <command>UPDATE</command> ne le sont pas
    car <command>UPDATE</command> a été convertis en un
    <command>DELETE</command> et un <command>INSERT</command>. Quant aux
    triggers niveau instruction, aucun des triggers <command>DELETE</command>
    et <command>INSERT</command> ne sont déclenchés, y compris en cas de
    déplacement de lignes. Seuls les triggers <command>UPDATE</command>
    définis sur la table cible utilisés dans une instruction
    <command>UPDATE</command> seront déclenchés.
   </para>

   <para>
   Les fonctions déclencheurs appelées par des déclencheurs niveau instruction
   devraient toujours renvoyer <symbol>NULL</symbol>. Les fonctions déclencheurs
   appelées par des déclencheurs niveau ligne peuvent renvoyer une ligne de la
   table (une valeur de type <structname>HeapTuple</structname>) vers
   l'exécuteur appelant, s'ils le veulent. Un déclencheur niveau ligne exécuté
   avant une opération a les choix suivants&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Il peut retourner un pointeur <symbol>NULL</symbol> pour sauter l'opération
      pour la ligne courante. Ceci donne comme instruction à l'exécuteur de ne pas exécuter
      l'opération niveau ligne qui a lancé le déclencheur (l'insertion, la
      modification ou la suppression d'une ligne particulière de la table).
     </para>
    </listitem>

    <listitem>
     <para>
      Pour les déclencheurs <command>INSERT</command> et
      <command>UPDATE</command> de niveau ligne uniquement, la valeur de retour devient la
      ligne qui sera insérée ou remplacera la ligne en cours de mise à jour.
      Ceci permet à la fonction déclencheur de modifier la ligne en cours
      d'insertion ou de mise à jour.
     </para>
    </listitem>
   </itemizedlist>


   Un déclencheur <literal>BEFORE</literal> niveau ligne qui ne serait pas conçu pour avoir l'un de
   ces comportements doit prendre garde à retourner la même ligne que celle
   qui lui a été passée comme nouvelle ligne (c'est-à-dire : pour des déclencheurs
   <command>INSERT</command> et <command>UPDATE</command> : la nouvelle
   (<varname>NEW</varname>) ligne, et pour les déclencheurs
   <command>DELETE</command>)&nbsp;: l'ancienne
   (<varname>OLD</varname>) ligne .
  </para>

  <para>
   Un trigger <literal>INSTEAD OF</literal> niveau ligne devrait renvoyer
   soit <symbol>NULL</symbol> pour indiquer qu'il n'a pas modifié de données
   des tables de base sous-jacentes de la vue, soit la ligne de la vue qui lui
   a été passé (la ligne <varname>NEW</varname> pour les opérations
   <command>INSERT</command> et <command>UPDATE</command>, ou la ligne
   <varname>OLD</varname> pour l'opération <command>DELETE</command>). Une
   valeur de retour différent de NULL est utilisée comme signal indiquant que
   le trigger a réalisé les modifications de données nécessaires dans la vue.
   Ceci causera l'incrémentation du nombre de lignes affectées par la commande.
   Pour les opérations <command>INSERT</command> et <command>UPDATE</command>
   seulement,
   le trigger peut modifier la ligne <varname>NEW</varname> avant de la
   renvoyer. Ceci modifiera les données renvoyées par <command>INSERT
    RETURNING</command> ou <command>UPDATE RETURNING</command>, et est utile
   quand la vue n'affichera pas exactement les données fournies.
  </para>

  <para>
   La valeur de retour est ignorée pour les déclencheurs niveau ligne lancés
   après une opération. Ils peuvent donc renvoyer la valeur
   <symbol>NULL</symbol>.
  </para>

  <para>
   Certaines considérations s'appliquent pour les colonnes générées.
   <indexterm><primary>volonne générée</primary><secondary>dans les
   triggers</secondary></indexterm> Les colonnes générées sont calculées après
   les triggers <literal>BEFORE</literal> et avant les triggers
   <literal>AFTER</literal>. De ce fait, la valeur générée peut être inspectée
   dans les triggers <literal>AFTER</literal>. Dans les triggers
   <literal>BEFORE</literal>, la ligne <literal>OLD</literal> contient
   l'ancienne valeur générée, comme on pourrait s'y attendre, mais la ligne
   <literal>NEW</literal> ne contient pas encore la nouvelle valeur générée et
   ne doit pas être accédée. Dans l'interface en langage C, le contenu de la
   colonne est non défini à ce moment&nbsp;; un langage de programmation de
   plus haut niveau doit empêcher l'accès à une colonne générée dans la ligne
   <literal>NEW</literal> pour un trigger <literal>BEFORE</literal>. Les
   modifications de la valeur d'une colonne générée dans un trigger
   <literal>BEFORE</literal> sont ignorées et seront écrasées.
  </para>

  <para>
   Si plus d'un déclencheur est défini pour le même événement sur la même
   relation, les déclencheurs seront lancés dans l'ordre alphabétique de leur
   nom. Dans le cas de déclencheurs <literal>BEFORE</literal> et
   <literal>INSTEAD OF</literal>, la ligne
   renvoyée par chaque déclencheur, qui a éventuellement été modifiée, devient l'argument du
   prochain déclencheur. Si un des déclencheurs <literal>BEFORE</literal> ou
   <literal>INSTEAD OF</literal> renvoie un pointeur
   <symbol>NULL</symbol>, l'opération est abandonnée pour cette ligne et les
   déclencheurs suivants ne sont pas lancés (pour cette ligne).
  </para>

  <para>
   Une définition de trigger peut aussi spécifier une condition booléenne
   <literal>WHEN</literal> qui sera testée pour savoir si le trigger doit
   bien être déclenché. Dans les triggers de niveau ligne, la condition
   <literal>WHEN</literal> peut examiner l'ancienne et la nouvelle valeur
   des colonnes de la ligne. (les triggers de niveau instruction peuvent
   aussi avoir des conditions <literal>WHEN</literal> mais cette fonctionnalité
   est moins intéressante pour elles). Dans un trigger
   <firstterm>avant</firstterm>, la condition <literal>WHEN</literal> est
   évaluée juste avant l'exécution de la fonction, donc l'utilisation de
   <literal>WHEN</literal> n'est pas réellement différente du test de la même
   condition au début de la fonction trigger. Néanmoins, dans un tigger
   <literal>AFTER</literal>, la condition <literal>WHEN</literal> est
   évaluée juste avant la mise à jour de la ligne et détermine si un événement
   va déclencher le trigger à la fin de l'instruction. Donc, quand la
   condition <literal>WHEN</literal> d'un trigger <literal>AFTER</literal>
   ne renvoie pas true, il n'est pas nécessaire de mettre en queue un
   événement ou de récupérer de nouveau la ligne à la fin de l'instriction.
   Ceci permet une amélioration conséquente des performances pour les
   instructions qui modifient un grand nombre de lignes si le trigger a
   seulement besoin d'être exécuté que sur quelques lignes. Les triggers
   <literal>INSTEAD OF</literal> n'acceptent pas les conditions
   <literal>WHEN</literal>.
  </para>

  <para>
   Les déclencheurs <literal>BEFORE</literal> en mode ligne sont typiquement utilisés pour
   vérifier ou modifier les données qui seront insérées ou mises à jour. Par
   exemple, un déclencheur <literal>BEFORE</literal> pourrait être utilisé pour insérer l'heure
   actuelle dans une colonne de type <type>timestamp</type> ou pour vérifier que deux
   éléments d'une ligne sont cohérents. Les déclencheurs <literal>AFTER</literal> en mode ligne
   sont pour la plupart utilisés pour propager des mises à jour vers d'autres
   tables ou pour réaliser des tests de cohérence avec d'autres tables. La
   raison de cette division du travail est qu'un déclencheur <literal>AFTER</literal> peut être
   certain qu'il voit la valeur finale de la ligne alors qu'un déclencheur
   <literal>BEFORE</literal> ne l'est pas&nbsp;; il pourrait exister d'autres déclencheurs <literal>BEFORE</literal>
   qui seront exécutés après lui. Si vous n'avez aucune raison spéciale pour le
   moment du déclenchement, le cas <literal>BEFORE</literal> est plus efficace car l'information
   sur l'opération n'a pas besoin d'être sauvegardée jusqu'à la fin du
   traitement.
  </para>

  <para>
   Si une fonction déclencheur exécute des commandes SQL,
   alors ces commandes peuvent lancer à leur tour des déclencheurs. On appelle ceci un
   déclencheur en cascade. Il n'y a pas de limitation directe du nombre de
   niveaux de cascade. Il est possible que les cascades causent un appel
   récursif du même déclencheur&nbsp;; par exemple, un déclencheur
   <command>INSERT</command> pourrait exécuter une commande qui insère une
   ligne supplémentaire dans la même table, entraînant un nouveau lancement du
   déclencheur <command>INSERT</command>. Il est de la responsabilité du
   programmeur d'éviter les récursions infinies dans de tels scénarios.
  </para>

  <indexterm>
   <primary>trigger</primary>
   <secondary>arguments pour la fonction trigger</secondary>
  </indexterm>

  <para>
   Quand un déclencheur est défini, des arguments peuvent être spécifiés pour
   lui. L'objectif de l'inclusion d'arguments dans la définition du
   déclencheur est de permettre à différents déclencheurs ayant des exigences
   similaires d'appeler la même fonction. Par exemple, il pourrait y avoir une
   fonction déclencheur généralisée qui prend comme arguments deux noms de
   colonnes et place l'utilisateur courant dans l'une et un horodatage dans
   l'autre. Correctement écrit, cette fonction déclencheur serait indépendante
   de la table particulière sur laquelle il se déclenche. Ainsi, la même
   fonction pourrait être utilisée pour des événements
   <command>INSERT</command> sur n'importe quelle table ayant des colonnes
   adéquates, pour automatiquement suivre les créations d'enregistrements dans
   une table de transactions par exemple. Elle pourrait aussi être utilisée
   pour suivre les dernières mises à jours si elle est définie comme un
   déclencheur <command>UPDATE</command>.
  </para>

  <para>
   Chaque langage de programmation supportant les déclencheurs a sa propre
   méthode pour rendre les données en entrée disponible à la fonction du
   déclencheur. Cette donnée en entrée inclut le type d'événement du
   déclencheur (c'est-à-dire <command>INSERT</command> ou
   <command>UPDATE</command>) ainsi que tous les arguments listés dans
   <command>CREATE TRIGGER</command>. Pour un déclencheur niveau ligne, la donnée en
   entrée inclut aussi la ligne <varname>NEW</varname> pour les déclencheurs
   <command>INSERT</command> et <command>UPDATE</command> et/ou la ligne
   <varname>OLD</varname> pour les déclencheurs <command>UPDATE</command> et
   <command>DELETE</command>.
  </para>

  <para>
   Par défaut, les triggers niveau instruction n'ont aucun moyen d'examiner le
   ou les lignes individuelles modifiées par la requête. Mais un trigger
   <literal>AFTER STATEMENT</literal> peut demander que des <firstterm>tables
   de transition</firstterm> soient créées pour rendre disponible les
   ensembles de lignes affectées au trigger. <literal>AFTER ROW</literal> peut
   aussi demander les tables de transactions, pour accéder au changement
   global dans la table, ainsi qu'au changement de lignes individuelles pour
   lesquels ils ont été déclenchés. La méthode d'examen des tables de
   transition dépend là-aussi du langage de programmation utilisé mais
   l'approche typique est de transformer les tables de transition en tables
   temporaires en lecture seule pouvant être accédées par des commandes SQL
   lancées par la fonction trigger.
  </para>

 </sect1>

 <sect1 id="trigger-datachanges">
  <title>Visibilité des modifications des données</title>

  <para>
   Si vous exécutez des commandes SQL dans votre fonction SQL et que ces
   commandes accèdent à la table pour laquelle vous créez ce déclencheur,
   alors vous avez besoin de connaître les règles de visibilité des données
   car elles déterminent si les commandes SQL voient les modifications de données pour
   lesquelles est exécuté le déclencheur. En bref&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Les déclencheurs niveau instruction suivent des règles de visibilité
      simples&nbsp;: aucune des modifications réalisées par une instruction
      n'est visible aux déclencheurs niveau instruction appelés avant
      l'instruction alors que toutes les modifications sont visibles aux
      déclencheurs <literal>AFTER</literal> niveau instruction.
     </para>
    </listitem>

    <listitem>
     <para>
      Les modifications de données (insertion, mise à jour ou suppression)
      lançant le déclencheur ne sont naturellement <emphasis>pas</emphasis>
      visibles aux commandes SQL exécutées dans un déclencheur <literal>BEFORE</literal> en mode
      ligne parce qu'elles ne sont pas encore survenues.
     </para>
    </listitem>

    <listitem>
     <para>
      Néanmoins, les commandes SQL exécutées par un déclencheur <literal>BEFORE</literal> en mode
      ligne <emphasis>verront</emphasis> les effets des modifications de données
      pour les lignes précédemment traitées dans la même commande externe. Ceci
      requiert une grande attention car l'ordre des événements de modification
      n'est en général pas prévisible&nbsp;; une commande SQL affectant
      plusieurs lignes pourrait visiter les lignes dans n'importe quel ordre.
     </para>
    </listitem>

    <listitem>
     <para>
      De façon similaire, un trigger niveau ligne de type <literal>INSTEAD
       OF</literal> verra les effets des modifications de données réalisées
      par l'exécution des autres triggers <literal>INSTEAD
       OF</literal> dans la même commande.
     </para>
    </listitem>

    <listitem>
     <para>
      Quand un déclencheur <literal>AFTER</literal> en mode ligne est exécuté, toutes les
      modifications de données réalisées par la commande externe sont déjà
      terminées et sont visibles par la fonction appelée par le déclencheur.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Si votre fonction trigger est écrite dans un des langages de procédures
   standard, alors les instructions ci-desus s'appliquent seulement si la
   fonction est déclarée <literal>VOLATILE</literal>. Les fonctions déclarées
   <literal>STABLE</literal> ou <literal>IMMUTABLE</literal> ne verront pas
   les modifications réalisées par la commande appelante dans tous les cas.
  </para>

  <para>
   Il existe plus d'informations sur les règles de visibilité des données dans
   la <xref linkend="spi-visibility"/>. L'exemple dans la <xref
   linkend="trigger-example"/> contient une démonstration de ces règles.
  </para>
 </sect1>

 <sect1 id="trigger-interface">
  <title>Écrire des fonctions déclencheurs en C</title>

  <indexterm zone="trigger-interface">
   <primary>trigger</primary>
   <secondary>en C</secondary>
  </indexterm>

   <indexterm>
    <primary>tables de transition</primary>
    <secondary>référencées à partir d'un trigger C</secondary>
   </indexterm>

  <para>
   Cette section décrit les détails de bas niveau de l'interface d'une fonction
   déclencheur. Ces informations ne sont nécessaires que lors de l'écriture
   d'une fonction déclencheur en C. Si vous utilisez un langage de plus haut
   niveau, ces détails sont gérés pour vous. Dans la plupart des cas, vous
   devez considérer l'utilisation d'un langage de procédure avant d'écrire
   vos déclencheurs en C. La documentation de chaque langage de procédures
   explique comment écrire un déclencheur dans ce langage.
  </para>

  <para>
   Les fonctions déclencheurs doivent utiliser la <quote>version 1</quote> de
   l'interface du gestionnaire de fonctions.
  </para>

  <para>
   Quand une fonction est appelée par le gestionnaire de déclencheur, elle ne
   reçoit aucun argument classique, mais un pointeur de <quote>contexte</quote>
   pointant sur une structure <structname>TriggerData</structname>. Les fonctions C
   peuvent vérifier si elles sont appelées par le gestionnaire de déclencheurs
   ou pas en exécutant la macro&nbsp;:
   <programlisting>CALLED_AS_TRIGGER(fcinfo)
   </programlisting>
   qui se décompose en&nbsp;:
   <programlisting>((fcinfo)-&gt;context != NULL &amp;&amp; IsA((fcinfo)-&gt;context, TriggerData))
   </programlisting>
   Si elle retourne la valeur vraie, alors il est bon de convertir
   <literal>fcinfo-&gt;context</literal> en type <literal>TriggerData *</literal> et
   de
   faire usage de la structure pointée <structname>TriggerData</structname>. La fonction
   <emphasis>ne</emphasis> doit <emphasis>pas</emphasis> modifier la
   structure <structname>TriggerData</structname> ou une donnée quelconque vers laquelle
   elle pointe.
  </para>

  <para>
   <structname>struct TriggerData</structname> est définie dans
   <filename>commands/trigger.h</filename>&nbsp;:

   <programlisting>typedef struct TriggerData
{
    NodeTag          type;
    TriggerEvent     tg_event;
    Relation         tg_relation;
    HeapTuple        tg_trigtuple;
    HeapTuple        tg_newtuple;
    Trigger         *tg_trigger;
    Buffer           tg_trigtuplebuf;
    Buffer           tg_newtuplebuf;
    Tuplestorestate *tg_oldtable;
    Tuplestorestate *tg_newtable;
} TriggerData;
   </programlisting>

   où les membres sont définis comme suit&nbsp;:

   <variablelist>
    <varlistentry>
     <term><structfield>type</structfield></term>
     <listitem>
      <para>
       Toujours <literal>T_TriggerData</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><structfield>tg_event</structfield></term>
     <listitem>
      <para>
       Décrit l'événement pour lequel la fonction est appelée. Vous pouvez utiliser
       les macros suivantes pour examiner <literal>tg_event</literal>&nbsp;:

       <variablelist>
        <varlistentry>
         <term><literal>TRIGGER_FIRED_BEFORE(tg_event)</literal></term>
         <listitem>
          <para>
           Renvoie vrai si le déclencheur est lancé avant l'opération.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TRIGGER_FIRED_AFTER(tg_event)</literal></term>
         <listitem>
          <para>
           Renvoie vrai si le déclencheur est lancé après l'opération.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TRIGGER_FIRED_INSTEAD(tg_event)</literal></term>
         <listitem>
          <para>
           Renvoie vrai si le trigger a été lancé à la place de l'opération.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TRIGGER_FIRED_FOR_ROW(tg_event)</literal></term>
         <listitem>
          <para>
           Renvoie vrai si le déclencheur est lancé pour un événement en
           mode ligne.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TRIGGER_FIRED_FOR_STATEMENT(tg_event)</literal></term>
         <listitem>
          <para>
           Renvoie vrai si le déclencheur est lancé pour un événement en
           mode instruction.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TRIGGER_FIRED_BY_INSERT(tg_event)</literal></term>
         <listitem>
          <para>
           Retourne vrai si le déclencheur est lancé par une commande
           <command>INSERT</command>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TRIGGER_FIRED_BY_UPDATE(tg_event)</literal></term>
         <listitem>
          <para>
           Retourne vrai si le déclencheur est lancé par une commande
           <command>UPDATE</command>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TRIGGER_FIRED_BY_DELETE(tg_event)</literal></term>
         <listitem>
          <para>
           Retourne vrai si le déclencheur est lancé par une commande
           <command>DELETE</command>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TRIGGER_FIRED_BY_TRUNCATE(tg_event)</literal></term>
         <listitem>
          <para>
           Renvoie true si le trigger a été déclenché par une commande
           <command>TRUNCATE</command>.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><structfield>tg_relation</structfield></term>
     <listitem>
      <para>
       Un pointeur vers une structure décrivant la relation pour laquelle le
       déclencheur est lancé. Voir <filename>utils/reltrigger.h</filename> pour les détails
       de cette structure. Les choses les plus intéressantes sont
       <literal>tg_relation-&gt;rd_att</literal> (descripteur de nuplets de la
       relation) et <literal>tg_relation-&gt;rd_rel-&gt;relname</literal> (nom de la
       relation&nbsp;;
       le type n'est pas <type>char*</type> mais <type>NameData</type>&nbsp;; utilisez
       <literal>SPI_getrelname(tg_relation)</literal> pour obtenir un <type>char*</type>
       si vous avez besoin d'une copie du nom).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><structfield>tg_trigtuple</structfield></term>
     <listitem>
      <para>
       Un pointeur vers la ligne pour laquelle le déclencheur a été lancé. Il
       s'agit de la ligne étant insérée, mise à jour ou effacée. Si ce
       déclencheur a été lancé pour une commande <command>INSERT</command> ou
       <command>DELETE</command>, c'est cette valeur que la fonction doit retourner si
       vous ne voulez pas remplacer la ligne par une ligne différente (dans le
       cas d'un <command>INSERT</command>) ou sauter l'opération. Dans le cas de
       déclencheurs sur tables distantes, les valeurs des colonnes systèmes ne sont
       pas spécifiées ici.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><structfield>tg_newtuple</structfield></term>
     <listitem>
      <para>
       Un pointeur vers la nouvelle version de la ligne, si le déclencheur a
       été lancé pour un <command>UPDATE</command> et <symbol>NULL</symbol> si c'est
       pour un <command>INSERT</command> ou un <command>DELETE</command>.
       C'est ce que la fonction doit retourner si l'événement est un
       <command>UPDATE</command> et que vous ne voulez pas remplacer cette
       ligne par une ligne différente ou bien sauter l'opération. Dans le cas de
       déclencheurs sur tables distantes, les valeurs des colonnes systèmes ne sont
       pas spécifiées ici.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><structfield>tg_trigger</structfield></term>
     <listitem>
      <para>
       Un pointeur vers une structure de type <structname>Trigger</structname>, définie
       dans <filename>utils/rel.h</filename>&nbsp;:

       <programlisting>typedef struct Trigger
{
    Oid         tgoid;
    char       *tgname;
    Oid         tgfoid;
    int16       tgtype;
    char        tgenabled;
    bool        tgisinternal;
    Oid         tgconstrrelid;
    Oid         tgconstrindid;
    Oid         tgconstraint;
    bool        tgdeferrable;
    bool        tginitdeferred;
    int16       tgnargs;
    int16       tgnattr;
    int16      *tgattr;
    char      **tgargs;
    char       *tgqual;
    char       *tgoldtable;
    char       *tgnewtable;
} Trigger;
       </programlisting>

       où <structfield>tgname</structfield> est le nom du déclencheur,
       <structfield>tgnargs</structfield> est le nombre d'arguments dans
       <structfield>tgargs</structfield> et <structfield>tgargs</structfield> est un tableau de
       pointeurs vers les arguments spécifiés dans l'expression contenant la
       commande <command>CREATE TRIGGER</command>. Les autres membres ne sont
       destinés qu'à un usage interne.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><structfield>tg_trigtuplebuf</structfield></term>
     <listitem>
      <para>
       Le tampon contenant <structfield>tg_trigtuple</structfield> ou
       <symbol>InvalidBuffer</symbol> s'il n'existe pas une telle ligne ou si
       elle n'est pas stockée dans un tampon du disque.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><structfield>tg_newtuplebuf</structfield></term>
     <listitem>
      <para>
       Le tampon contenant <structfield>tg_newtuple</structfield> ou
       <symbol>InvalidBuffer</symbol> s'il n'existe pas une telle ligne ou
       si elle n'est pas stockée dans un tampon du disque.
      </para>
     </listitem>
    </varlistentry>

     <varlistentry>
      <term><structfield>tg_oldtable</structfield></term>
      <listitem>
       <para>
        Un pointeur vers une structure de type
        <structname>Tuplestorestate</structname> contenant zéro ou plusieurs
        lignes dans le format spécifié par
        <structfield>tg_relation</structfield>, ou un pointeur
        <symbol>NULL</symbol> s'il n'y a pas de relation de transition
        <literal>OLD TABLE</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_newtable</structfield></term>
      <listitem>
       <para>
        Un pointeur vers une structure de type
        <structname>Tuplestorestate</structname> contenant zéro ou plusieurs
        lignes dans le format spécifié par
        <structfield>tg_relation</structfield>, ou un pointeur
        <symbol>NULL</symbol> s'il n'y a pas de relation de transition
        <literal>NEW TABLE</literal>.
       </para>
      </listitem>
     </varlistentry>

   </variablelist>
  </para>

  <para>
    Pour permettre aux requêtes exécutées via SPI de référencer les tables de
    transition, voir <xref linkend="spi-spi-register-trigger-data"/>.
   </para>

   <para>
   Une fonction déclencheur doit retourner soit un pointeur
   <structname>HeapTuple</structname> soit un pointeur <symbol>NULL</symbol> (<emphasis>pas</emphasis>
   une valeur SQL NULL, donc ne positionnez pas <parameter>isNull</parameter> à
   true). Faites attention de renvoyer soit un
   <structfield>tg_trigtuple</structfield> soit un <structfield>tg_newtuple</structfield>,
   comme approprié, si vous ne voulez pas changer la ligne en cours de
   modification.
  </para>

 </sect1>

 <sect1 id="trigger-example">
  <title>Un exemple complet de trigger</title>

  <para>
   Voici un exemple très simple de fonction déclencheur écrite en C (les
   exemples de déclencheurs écrits avec différents langages de procédures
   se trouvent dans la documentation de ceux-ci).
  </para>

  <para>
   La fonction <function>trigf</function> indique le nombre de lignes de la table
   <structname>ttest</structname> et saute l'opération si la commande tente d'insérer une
   valeur NULL dans la colonne <structfield>x</structfield> (ainsi le déclencheur agit
   comme une contrainte non NULL mais n'annule pas la transaction).
  </para>

  <para>
   Tout d'abord, la définition des tables&nbsp;:
   <programlisting>CREATE TABLE ttest (
    x integer
);
   </programlisting>
  </para>

  <para>
   Voici le code source de la fonction trigger :
   <programlisting><![CDATA[#include "postgres.h"
#include "fmgr.h"
#include "executor/spi.h"       /* nécessaire pour fonctionner avec SPI */
#include "commands/trigger.h"   /* ... les déclencheurs */
#include "utils/rel.h"          /* ... et relations */

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(trigf);

Datum
trigf(PG_FUNCTION_ARGS)
{
    TriggerData *trigdata = (TriggerData *) fcinfo->context;
    TupleDesc   tupdesc;
    HeapTuple   rettuple;
    char       *when;
    bool        checkNULL = false;
    bool        isNULL;
    int         ret, i;

    /* on s'assure que la fonction est appelée en tant que déclencheur */
    if (!CALLED_AS_TRIGGER(fcinfo))
        elog(ERROR, "trigf: not called by trigger manager");

    /* nuplet à retourner à l'exécuteur */
    if (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))
        rettuple = trigdata->tg_newtuple;
    else
        rettuple = trigdata->tg_trigtuple;

    /* vérification des valeurs NULL */
    if (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event)
        && TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        checkNULL = true;

    if (TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        when = "before";
    else
        when = "after ";

    tupdesc = trigdata->tg_relation->rd_att;

    /* connexion au gestionnaire SPI */
    if ((ret = SPI_connect()) < 0)
        elog(ERROR, "trigf (fired %s): SPI_connect returned %d", when, ret);

    /* obtient le nombre de lignes dans la table */
    ret = SPI_exec("SELECT count(*) FROM ttest", 0);

    if (ret < 0)
        elog(ERROR, "trigf (fired %s): SPI_exec returned %d", when, ret);

    /* count(*) renvoie int8, prenez garde à bien convertir */
    i = DatumGetInt64(SPI_getbinval(SPI_tuptable->vals[0],
                                    SPI_tuptable->tupdesc,
                                    1,
                                    &isNULL));

    elog (INFO, "trigf (fired %s): there are %d rows in ttest", when, i);

    SPI_finish();

    if (checkNULL)
    {
        SPI_getbinval(rettuple, tupdesc, 1, &isNULL);
        if (isNULL)
            rettuple = NULL;
    }

    return PointerGetDatum(rettuple);
}
]]></programlisting>
   </para>

   <para>
    Après avoir compilé le code source (voir <xref
    linkend="dfunc"/>), déclarez la fonction et les
    déclencheurs&nbsp;:
<programlisting>CREATE FUNCTION trigf() RETURNS trigger
    AS '<replaceable>nomfichier</replaceable>'
    LANGUAGE C;

CREATE TRIGGER tbefore BEFORE INSERT OR UPDATE OR DELETE ON ttest
    FOR EACH ROW EXECUTE FUNCTION trigf();

CREATE TRIGGER tafter AFTER INSERT OR UPDATE OR DELETE ON ttest
    FOR EACH ROW EXECUTE FUNCTION trigf();
   </programlisting>
  </para>

  <para>
   À présent, testez le fonctionnement du déclencheur&nbsp;:
   <screen>=&gt; INSERT INTO ttest VALUES (NULL);
INFO:  trigf (fired before): there are 0 rows in ttest
INSERT 0 0

-- Insertion supprimée et déclencheur APRES non exécuté

=&gt; SELECT * FROM ttest;
 x
---
(0 rows)

=&gt; INSERT INTO ttest VALUES (1);
INFO:  trigf (fired before): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 1 rows in ttest
                                       ^^^^^^^^
                       souvenez-vous de ce que nous avons dit sur la visibilité.
INSERT 167793 1
vac=&gt; SELECT * FROM ttest;
 x
---
 1
(1 row)

=&gt; INSERT INTO ttest SELECT x * 2 FROM ttest;
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
                                       ^^^^^^
                       souvenez-vous de ce que nous avons dit sur la visibilité.
INSERT 167794 1
=&gt; SELECT * FROM ttest;
 x
---
 1
 2
(2 rows)

=&gt; UPDATE ttest SET x = NULL WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
UPDATE 0
=&gt; UPDATE ttest SET x = 4 WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
UPDATE 1
vac=&gt; SELECT * FROM ttest;
 x
---
 1
 4
(2 rows)

=&gt; DELETE FROM ttest;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
                                       ^^^^^^
                       souvenez-vous de ce que nous avons dit sur la visibilité.
DELETE 2
=&gt; SELECT * FROM ttest;
 x
---
(0 rows)
   </screen>

  </para>

  <para>
   Vous trouverez des exemples plus complexes dans
   <filename>src/test/regress/regress.c</filename> et dans
   <xref linkend="contrib-spi"/>.
  </para>
 </sect1>
</chapter>
