<?xml version="1.0" encoding="UTF-8"?>
<chapter id="triggers">
 <title>Triggers (triggers)</title>

 <indexterm zone="triggers">
  <primary>trigger</primary>
 </indexterm>

 <para>
  Ce chapitre fournit des informations générales sur l'écriture des fonctions
  pour trigger. Ces fonctions peuvent être écrites dans
  la plupart des langages de procédure disponibles incluant
  <application>PL/pgSQL</application> (<xref linkend="plpgsql"/>),
  <application>PL/Tcl</application> (<xref linkend="pltcl"/>),
  <application>PL/Perl</application> (<xref linkend="plperl"/>) et
  <application>PL/Python</application> (<xref linkend="plpython"/>). Après avoir
  lu ce chapitre, vous devriez consulter le chapitre sur votre langage de
  procédure favori pour découvrir les spécificités de l'écriture de triggers dans ce langage.
 </para>

 <para>
  Il est aussi possible d'écrire une fonction trigger en C, bien que la plupart
  des gens trouvent plus facile d'utiliser un des langages de procédure. Il est
  actuellement impossible d'écrire une fonction trigger en simple SQL.
 </para>

 <sect1 id="trigger-definition">
  <title>Aperçu du comportement des triggers</title>

  <para>
   Un trigger spécifie que la base de données doit
   exécuter automatiquement une fonction donnée chaque fois qu'un certain type d'opération est
   exécuté. Les fonctions trigger peuvent être attachées à une table (partitionnée ou non),
   une vue ou une table distante.
  </para>

  <para>
   Sur des tables et tables distantes, les triggers peuvent être définies pour s'exécuter
   avant ou après une commande <command>INSERT</command>,
   <command>UPDATE</command> ou <command>DELETE</command>, soit une fois par
   ligne modifiée, soit une fois par expression <acronym>SQL</acronym>.
   Les triggers <command>UPDATE</command> peuvent en plus être
   configurées pour n'être déclenchés que si certaines colonnes sont
   mentionnées dans la clause <literal>SET</literal> de l'instruction
   <command>UPDATE</command>.  Les triggers peuvent aussi se déclencher
   pour des instructions
   <command>TRUNCATE</command>. Si un événement d'un trigger intervient, la
   fonction du trigger est appelée au moment approprié pour gérer
   l'événement.
  </para>

  <para>
   Des triggers peuvent être définies sur des vues pour exécuter des opérations
   à la place des commandes <command>INSERT</command>, <command>UPDATE</command>
   ou <command>DELETE</command>. Les triggers <literal>INSTEAD OF</literal>
   sont déclenchés une fois par ligne devant être modifiée dans la vue. C'est
   de la responsabilité de la fonction trigger de réaliser les modifications
   nécessaires pour que les tables de base sous-jacentes d'une vue et, si approprié,
   de renvoyer la ligne modifiée comme elle apparaîtra dans la vue. Les
   triggers sur les vues peuvent aussi être définis pour s'exécuter une
   fois par requête <acronym>SQL</acronym> statement, avant ou après des
   opérations <command>INSERT</command>, <command>UPDATE</command> ou
   <command>DELETE</command>. Néanmoins, de tels triggers sont déclenchés
   seulement s'il existe aussi un trigger <literal>INSTEAD OF</literal> sur
   la vue. Dans le cas contraire, toute requête ciblant la vue doit être
   réécrite en une requête affectant sa (ou ses) table(s) de base. Les
   triggers déclenchés seront ceux de(s) table(s) de base.
  </para>

  <para>
   La fonction trigger doit être définie avant que le trigger lui-même
   puisse être créé. La fonction trigger doit être déclarée comme une
   fonction ne prenant aucun argument et retournant un type <literal>trigger</literal>
   (la fonction trigger reçoit ses entrées via une structure
   <structname>TriggerData</structname> passée spécifiquement, et non pas sous la forme
   d'arguments ordinaires de fonctions).
  </para>

  <para>
   Une fois qu'une fonction trigger est créée, le trigger
   est créé avec <xref linkend="sql-createtrigger"/>.
   La même fonction trigger est utilisable par plusieurs triggers.
  </para>

  <para>
   <productname>PostgreSQL</productname> offre des triggers
   <firstterm>par ligne</firstterm> et <firstterm>par instruction</firstterm>. Avec un
   trigger en mode ligne, la fonction du
   trigger est appelée une fois pour chaque ligne affectée par
   l'instruction qui a lancé le trigger. Au contraire, un trigger en mode
   instruction n'est appelé qu'une seule fois lorsqu'une instruction appropriée
   est exécutée, quel que soit le nombre de lignes affectées par cette
   instruction. En particulier, une instruction n'affectant aucune ligne
   résultera toujours en l'exécution de tout trigger en mode instruction
   applicable. Ces deux types sont parfois appelés respectivement des
   <firstterm>triggers niveau ligne</firstterm> et des
   <firstterm>triggers niveau instruction</firstterm>.
   Les triggers sur <command>TRUNCATE</command> peuvent seulement être définis
   au niveau instruction, et non pas au niveau ligne.
  </para>

  <para>
   Les triggers sont aussi classifiées suivant qu'ils se déclenchent avant
   (<firstterm>before</firstterm>), après (<firstterm>after</firstterm>) ou
   à la place (<firstterm>instead of</firstterm>) de l'opération. Ils sont
   référencés respectivement comme des triggers <literal>BEFORE</literal>,
   <literal>AFTER</literal> et <literal>INSTEAD OF</literal>. Les triggers
   <literal>BEFORE</literal> au niveau requête se déclenchent avant que la
   requête ne commence quoi que ce soit alors que les triggers
   <literal>AFTER</literal> au niveau requête se déclenchent tout à la fin de
   la requête. Ces types de triggers peuvent être définis sur les tables,
   vues et tables externes. Les triggers <literal>BEFORE</literal> au niveau ligne se déclenchent
   immédiatement avant l'opération sur une ligne particulière alors que les
   triggers <literal>AFTER</literal> au niveau ligne se déclenchent à la fin
   de la requête (mais avant les triggers <literal>AFTER</literal> au niveau
   requête). Ces types de triggers peuvent seulement être définis sur les
   tables et sur les tables distantes, et non pas sur les vues. Les triggers
   <literal>INSTEAD OF</literal>
   peuvent seulement être définis sur des vues, et seulement au niveau ligne.
   Ils se déclenchent immédiatement pour chaque ligne de la vue identifiée
   comme nécessitant une action.
  </para>

  <para>
   L'exécution d'un trigger <literal>AFTER</literal> peut être reporté à la
   fin de la transaction, plutôt qu'à la fin de la requête, s'il a été défini
   comme un <firstterm>trigger de contrainte</firstterm>. Dans tous les cas,
   un trigger est exécuté comme faisant partie de la même transaction que la
   requête qui l'a exécuté, donc si soit la requête soit le trigger renvoie
   une erreur, l'effet sera une annulation par ROLLBACK.
  </para>

  <para>
   Si un <command>INSERT</command> contient une clause <literal>ON CONFLICT DO
   UPDATE</literal>, il est possible pour les triggers niveau ligne
   <literal>BEFORE</literal> <command>INSERT</command> puis
   <literal>BEFORE</literal> <command>UPDATE</command> d'être exécutés sur
   les lignes cibles. De telles interactions peuvent être complexes si les
   triggers ne sont pas idempotents parce que les modifications réalisées par
   les triggers <literal>BEFORE</literal> <command>INSERT</command> seront
   vus par les triggers <literal>BEFORE</literal> <command>UPDATE</command>,
   ceci inclut les modifications sur les colonnes
   <varname>EXCLUDED</varname>.
  </para>

  <para>
   Notez que les triggers
   <command>UPDATE</command> niveau instruction sont exécutés lorsque
   la clause <literal>ON CONFLICT DO UPDATE</literal> est spécifiée,
   quand bien même aucune ligne ne serait affectée par la commande
   <command>UPDATE</command> (et même si la commande
   <command>UPDATE</command> n'est pas exécutée). Une commande
   <command>INSERT</command> avec une clause <literal>ON CONFLICT DO
    UPDATE</literal> exécutera d'abord les triggers niveau
   instruction <literal>BEFORE</literal> <command>INSERT</command>,
   puis les triggers niveau instruction <literal>BEFORE</literal>
   <command>UPDATE</command>, suivis par les triggers niveau
   instruction <literal>AFTER</literal> <command>UPDATE</command>,
   puis finalement les triggers niveau instruction
   <literal>AFTER</literal> <command>INSERT</command>.
  </para>

  <para>
   Une instruction qui cible une table parente dans une hiérarchie d'héritage
   ou de partitionnement ne cause pas le déclenchement des triggers niveau
   instruction des tables enfants affectées&nbsp;; seuls les triggers niveau
   instruction de la table parent sont déclenchés. Néanmoins, les triggers
   niveau ligne de toute table enfant affectée seront déclenchés.
  </para>

  <para>
   Si un <command>UPDATE</command> sur une table partitionnée implique le
   déplacement d'une ligne vers une autre partition, il sera réalisé comme un
   <command>DELETE</command> de la partition originale, suivi d'un
   <command>INSERT</command> dans la nouvelle partition. Dans ce cas, les
   triggers <literal>BEFORE</literal> <command>UPDATE</command> niveau ligne
   et tous les triggers <literal>BEFORE</literal> <command>DELETE</command>
   niveau ligne sont déclenchés sur la partition originale. Puis tous les
   triggers <literal>BEFORE</literal> <command>INSERT</command> niveau ligne
   sont déclenchés sur la partition destination. La possibilité de résultats
   surprenants doit être considéré quand tous les triggers affectent la ligne
   déplacée. En ce qui concerne les triggers <literal>AFTER ROW</literal>,
   les triggers <literal>AFTER</literal> <command>DELETE</command> et
   <literal>AFTER</literal> <command>INSERT</command> sont appliqués mais les
   triggers <literal>AFTER</literal> <command>UPDATE</command> ne le sont pas
   car <command>UPDATE</command> a été convertis en un
   <command>DELETE</command> et un <command>INSERT</command>. Quant aux
   triggers niveau instruction, aucun des triggers <command>DELETE</command>
   et <command>INSERT</command> ne sont déclenchés, y compris en cas de
   déplacement de lignes. Seuls les triggers <command>UPDATE</command>
   définis sur la table cible utilisée dans une instruction
   <command>UPDATE</command> seront déclenchés.
  </para>

  <para>
   Aucun trigger spécifique n'est défini pour <command>MERGE</command>. À la
   place, des triggers niveau instruction ou niveau ligne sont déclenchés pour
   les instructions <command>UPDATE</command>, <command>DELETE</command> et
   <command>INSERT</command> suivant l'action indiquée dans la requête
   <command>MERGE</command> (pour les triggers niveau instruction) et suivant
   les actions réellement exécutées (pour les triggers niveau instruction).
  </para>

  <para>
   Lors de l'exécution d'une commande <command>MERGE</command>, les triggers
   <literal>BEFORE</literal> and <literal>AFTER</literal> au niveau instruction
   sont déclenchées pour les événements spécifiés dans les actions de la
   commande <command>MERGE</command>, que l'action soit exécutée ou non au
   final. C'est identique à l'instruction <command>UPDATE</command> qui ne met à
   jour aucune ligne, mais pour laquelle, néanmoins, les triggers niveau
   instruction ont été exécutés. Les triggers niveau ligne sont déclenchés
   uniquement quand une ligne est réellement mise à jour, insérée ou supprimée.
   Donc il est parfaitement normal que, bien que les triggers niveau instruction
   soient déclenchés pour certains types d'action, les triggers niveau ligne ne
   le soient pas pour les mêmes actions.
  </para>

  <para>
   Les fonctions triggers appelées par des triggers niveau instruction
   devraient toujours renvoyer <symbol>NULL</symbol>. Les fonctions triggers
   appelées par des triggers niveau ligne peuvent renvoyer une ligne de la
   table (une valeur de type <structname>HeapTuple</structname>) vers
   l'exécuteur appelant, s'ils le veulent. Un trigger niveau ligne exécuté
   avant une opération a les choix suivants&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Il peut retourner un pointeur <symbol>NULL</symbol> pour sauter l'opération
      pour la ligne courante. Ceci donne comme instruction à l'exécuteur de ne pas exécuter
      l'opération niveau ligne qui a lancé le trigger (l'insertion, la
      modification ou la suppression d'une ligne particulière de la table).
     </para>
    </listitem>

    <listitem>
     <para>
      Pour les triggers <command>INSERT</command> et
      <command>UPDATE</command> de niveau ligne uniquement, la valeur de retour devient la
      ligne qui sera insérée ou remplacera la ligne en cours de mise à jour.
      Ceci permet à la fonction trigger de modifier la ligne en cours
      d'insertion ou de mise à jour.
     </para>
    </listitem>
   </itemizedlist>


   Un trigger <literal>BEFORE</literal> niveau ligne qui ne serait pas conçu pour avoir l'un de
   ces comportements doit prendre garde à retourner la même ligne que celle
   qui lui a été passée comme nouvelle ligne (c'est-à-dire&nbsp;: pour des triggers
   <command>INSERT</command> et <command>UPDATE</command> : la nouvelle
   (<varname>NEW</varname>) ligne, et pour les triggers
   <command>DELETE</command>)&nbsp;: l'ancienne
   (<varname>OLD</varname>) ligne .
  </para>

  <para>
   Un trigger <literal>INSTEAD OF</literal> niveau ligne devrait renvoyer
   soit <symbol>NULL</symbol> pour indiquer qu'il n'a pas modifié de données
   des tables de base sous-jacentes de la vue, soit la ligne de la vue qui lui
   a été passé (la ligne <varname>NEW</varname> pour les opérations
   <command>INSERT</command> et <command>UPDATE</command>, ou la ligne
   <varname>OLD</varname> pour l'opération <command>DELETE</command>). Une
   valeur de retour différent de NULL est utilisée comme signal indiquant que
   le trigger a réalisé les modifications de données nécessaires dans la vue.
   Ceci causera l'incrémentation du nombre de lignes affectées par la commande.
   Pour les opérations <command>INSERT</command> et <command>UPDATE</command>
   seulement,
   le trigger peut modifier la ligne <varname>NEW</varname> avant de la
   renvoyer. Ceci modifiera les données renvoyées par <command>INSERT
    RETURNING</command> ou <command>UPDATE RETURNING</command>, et est utile
   quand la vue n'affichera pas exactement les données fournies.
  </para>

  <para>
   La valeur de retour est ignorée pour les triggers niveau ligne lancés
   après une opération. Ils peuvent donc renvoyer la valeur
   <symbol>NULL</symbol>.
  </para>

  <para>
   Certaines considérations s'appliquent pour les colonnes générées.
   <indexterm><primary>colonne générée</primary><secondary>dans les
     triggers</secondary></indexterm> Les colonnes générées sont calculées après
   les triggers <literal>BEFORE</literal> et avant les triggers
   <literal>AFTER</literal>. De ce fait, la valeur générée peut être inspectée
   dans les triggers <literal>AFTER</literal>. Dans les triggers
   <literal>BEFORE</literal>, la ligne <literal>OLD</literal> contient
   l'ancienne valeur générée, comme on pourrait s'y attendre, mais la ligne
   <literal>NEW</literal> ne contient pas encore la nouvelle valeur générée et
   ne doit pas être accédée. Dans l'interface en langage C, le contenu de la
   colonne est non défini à ce moment&nbsp;; un langage de programmation de
   plus haut niveau doit empêcher l'accès à une colonne générée dans la ligne
   <literal>NEW</literal> pour un trigger <literal>BEFORE</literal>. Les
   modifications de la valeur d'une colonne générée dans un trigger
   <literal>BEFORE</literal> sont ignorées et seront écrasées.
  </para>

  <para>
   Si plus d'un trigger est défini pour le même événement sur la même
   relation, les triggers seront lancés dans l'ordre alphabétique de leur
   nom. Dans le cas de triggers <literal>BEFORE</literal> et
   <literal>INSTEAD OF</literal>, la ligne
   renvoyée par chaque trigger, qui a éventuellement été modifiée, devient l'argument du
   prochain trigger. Si un des triggers <literal>BEFORE</literal> ou
   <literal>INSTEAD OF</literal> renvoie un pointeur
   <symbol>NULL</symbol>, l'opération est abandonnée pour cette ligne et les
   triggers suivants ne sont pas lancés (pour cette ligne).
  </para>

  <para>
   Une définition de trigger peut aussi spécifier une condition booléenne
   <literal>WHEN</literal> qui sera testée pour savoir si le trigger doit
   bien être déclenché. Dans les triggers de niveau ligne, la condition
   <literal>WHEN</literal> peut examiner l'ancienne et la nouvelle valeur
   des colonnes de la ligne. (les triggers de niveau instruction peuvent
   aussi avoir des conditions <literal>WHEN</literal> mais cette fonctionnalité
   est moins intéressante pour elles). Dans un trigger
   <firstterm>avant</firstterm>, la condition <literal>WHEN</literal> est
   évaluée juste avant l'exécution de la fonction, donc l'utilisation de
   <literal>WHEN</literal> n'est pas réellement différente du test de la même
   condition au début de la fonction trigger. Néanmoins, dans un tigger
   <literal>AFTER</literal>, la condition <literal>WHEN</literal> est
   évaluée juste avant la mise à jour de la ligne et détermine si un événement
   va déclencher le trigger à la fin de l'instruction. Donc, quand la
   condition <literal>WHEN</literal> d'un trigger <literal>AFTER</literal>
   ne renvoie pas true, il n'est pas nécessaire de mettre en queue un
   événement ou de récupérer de nouveau la ligne à la fin de l'instruction.
   Ceci permet une amélioration conséquente des performances pour les
   instructions qui modifient un grand nombre de lignes si le trigger a
   seulement besoin d'être exécuté que sur quelques lignes. Les triggers
   <literal>INSTEAD OF</literal> n'acceptent pas les conditions
   <literal>WHEN</literal>.
  </para>

  <para>
   Les triggers <literal>BEFORE</literal> en mode ligne sont typiquement utilisés pour
   vérifier ou modifier les données qui seront insérées ou mises à jour. Par
   exemple, un trigger <literal>BEFORE</literal> pourrait être utilisé pour insérer l'heure
   actuelle dans une colonne de type <type>timestamp</type> ou pour vérifier que deux
   éléments d'une ligne sont cohérents. Les triggers <literal>AFTER</literal> en mode ligne
   sont pour la plupart utilisés pour propager des mises à jour vers d'autres
   tables ou pour réaliser des tests de cohérence avec d'autres tables. La
   raison de cette division du travail est qu'un trigger <literal>AFTER</literal> peut être
   certain qu'il voit la valeur finale de la ligne alors qu'un trigger
   <literal>BEFORE</literal> ne l'est pas&nbsp;; il pourrait exister d'autres triggers <literal>BEFORE</literal>
   qui seront exécutés après lui. Si vous n'avez aucune raison spéciale pour le
   moment du déclenchement, le cas <literal>BEFORE</literal> est plus efficace car l'information
   sur l'opération n'a pas besoin d'être sauvegardée jusqu'à la fin du
   traitement.
  </para>

  <para>
   Si une fonction trigger exécute des commandes SQL,
   alors ces commandes peuvent lancer à leur tour des triggers. On appelle ceci un
   trigger en cascade. Il n'y a pas de limitation directe du nombre de
   niveaux de cascade. Il est possible que les cascades causent un appel
   récursif du même trigger&nbsp;; par exemple, un trigger
   <command>INSERT</command> pourrait exécuter une commande qui insère une
   ligne supplémentaire dans la même table, entraînant un nouveau lancement du
   trigger <command>INSERT</command>. Il est de la responsabilité du
   programmeur d'éviter les récursions infinies dans de tels scénarios.
  </para>

  <para>
   Si une clé étrangère indique des actions référentielles (autrement dit,
   des mises à jour ou des suppressions en cascade), ces actions seront
   réalisées via des commandes SQL ordinaires de mise à jour ou de suppression
   sur la table référençante. En particulier, tout trigger qui existe sur la
   table référençante sera déclenché pour ces modifications. Si un trigger
   modifie ou bloque l'effet d'une de ces commandes, le résultat final
   pourrait casser l'intégrité référentielle. C'est de la responsabilité
   du développeur du trigger d'éviter cela.
  </para>

  <indexterm>
   <primary>trigger</primary>
   <secondary>arguments pour la fonction trigger</secondary>
  </indexterm>

  <para>
   Quand un trigger est défini, des arguments peuvent être spécifiés pour
   lui. L'objectif de l'inclusion d'arguments dans la définition du
   trigger est de permettre à différents triggers ayant des exigences
   similaires d'appeler la même fonction. Par exemple, il pourrait y avoir une
   fonction trigger généralisée qui prend comme arguments deux noms de
   colonnes et place l'utilisateur courant dans l'une et un horodatage dans
   l'autre. Correctement écrit, cette fonction trigger serait indépendante
   de la table particulière sur laquelle il se déclenche. Ainsi, la même
   fonction pourrait être utilisée pour des événements
   <command>INSERT</command> sur n'importe quelle table ayant des colonnes
   adéquates, pour automatiquement suivre les créations d'enregistrements dans
   une table de transactions par exemple. Elle pourrait aussi être utilisée
   pour suivre les dernières mises à jour si elle est définie comme un
   trigger <command>UPDATE</command>.
  </para>

  <para>
   Chaque langage de programmation supportant les triggers à sa propre
   méthode pour rendre les données en entrée disponible à la fonction du
   trigger. Cette donnée en entrée inclut le type d'événement du
   trigger (c'est-à-dire <command>INSERT</command> ou
   <command>UPDATE</command>) ainsi que tous les arguments listés dans
   <command>CREATE TRIGGER</command>. Pour un trigger niveau ligne, la donnée en
   entrée inclut aussi la ligne <varname>NEW</varname> pour les triggers
   <command>INSERT</command> et <command>UPDATE</command> et/ou la ligne
   <varname>OLD</varname> pour les triggers <command>UPDATE</command> et
   <command>DELETE</command>.
  </para>

  <para>
   Par défaut, les triggers niveau instruction n'ont aucun moyen d'examiner le
   ou les lignes individuelles modifiées par la requête. Mais un trigger
   <literal>AFTER STATEMENT</literal> peut demander que des <firstterm>tables
    de transition</firstterm> soient créées pour rendre disponible les
   ensembles de lignes affectées au trigger. <literal>AFTER ROW</literal> peut
   aussi demander les tables de transactions, pour accéder au changement
   global dans la table, ainsi qu'au changement de lignes individuelles pour
   lesquels ils ont été déclenchés. La méthode d'examen des tables de
   transition dépend là-aussi du langage de programmation utilisé mais
   l'approche typique est de transformer les tables de transition en tables
   temporaires en lecture seule pouvant être accédées par des commandes SQL
   lancées par la fonction trigger.
  </para>

 </sect1>

 <sect1 id="trigger-datachanges">
  <title>Visibilité des modifications des données</title>

  <para>
   Si vous exécutez des commandes SQL dans votre fonction SQL et que ces
   commandes accèdent à la table pour laquelle vous créez ce trigger,
   alors vous avez besoin de connaître les règles de visibilité des données
   car elles déterminent si les commandes SQL voient les modifications de données pour
   lesquelles est exécuté le trigger. En bref&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Les triggers niveau instruction suivent des règles de visibilité
      simples&nbsp;: aucune des modifications réalisées par une instruction
      n'est visible aux triggers niveau instruction appelés avant
      l'instruction alors que toutes les modifications sont visibles aux
      triggers <literal>AFTER</literal> niveau instruction.
     </para>
    </listitem>

    <listitem>
     <para>
      Les modifications de données (insertion, mise à jour ou suppression)
      lançant le trigger ne sont naturellement <emphasis>pas</emphasis>
      visibles aux commandes SQL exécutées dans un trigger <literal>BEFORE</literal> en mode
      ligne parce qu'elles ne sont pas encore survenues.
     </para>
    </listitem>

    <listitem>
     <para>
      Néanmoins, les commandes SQL exécutées par un trigger <literal>BEFORE</literal> en mode
      ligne <emphasis>verront</emphasis> les effets des modifications de données
      pour les lignes précédemment traitées dans la même commande externe. Ceci
      requiert une grande attention car l'ordre des événements de modification
      n'est en général pas prévisible&nbsp;; une commande SQL affectant
      plusieurs lignes pourrait visiter les lignes dans n'importe quel ordre.
     </para>
    </listitem>

    <listitem>
     <para>
      De façon similaire, un trigger niveau ligne de type <literal>INSTEAD
       OF</literal> verra les effets des modifications de données réalisées
      par l'exécution des autres triggers <literal>INSTEAD
       OF</literal> dans la même commande.
     </para>
    </listitem>

    <listitem>
     <para>
      Quand un trigger <literal>AFTER</literal> en mode ligne est exécuté, toutes les
      modifications de données réalisées par la commande externe sont déjà
      terminées et sont visibles par la fonction appelée par le trigger.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Si votre fonction trigger est écrite dans un des langages de procédures
   standard, alors les instructions ci-desus s'appliquent seulement si la
   fonction est déclarée <literal>VOLATILE</literal>. Les fonctions déclarées
   <literal>STABLE</literal> ou <literal>IMMUTABLE</literal> ne verront pas
   les modifications réalisées par la commande appelante dans tous les cas.
  </para>

  <para>
   Il existe plus d'informations sur les règles de visibilité des données dans
   la <xref linkend="spi-visibility"/>. L'exemple dans la <xref
   linkend="trigger-example"/> contient une démonstration de ces règles.
  </para>
 </sect1>

 <sect1 id="trigger-interface">
  <title>Écrire des fonctions triggers en C</title>

  <indexterm zone="trigger-interface">
   <primary>trigger</primary>
   <secondary>en C</secondary>
  </indexterm>

  <indexterm>
   <primary>tables de transition</primary>
   <secondary>référencées à partir d'un trigger C</secondary>
  </indexterm>

  <para>
   Cette section décrit les détails de bas niveau de l'interface d'une fonction
   trigger. Ces informations ne sont nécessaires que lors de l'écriture
   d'une fonction trigger en C. Si vous utilisez un langage de plus haut
   niveau, ces détails sont gérés pour vous. Dans la plupart des cas, vous
   devez considérer l'utilisation d'un langage de procédure avant d'écrire
   vos triggers en C. La documentation de chaque langage de procédures
   explique comment écrire un trigger dans ce langage.
  </para>

  <para>
   Les fonctions triggers doivent utiliser la <quote>version 1</quote> de
   l'interface du gestionnaire de fonctions.
  </para>

  <para>
   Quand une fonction est appelée par le gestionnaire de trigger, elle ne
   reçoit aucun argument classique, mais un pointeur de <quote>contexte</quote>
   pointant sur une structure <structname>TriggerData</structname>. Les fonctions C
   peuvent vérifier si elles sont appelées par le gestionnaire de triggers
   ou pas en exécutant la macro&nbsp;:
   <programlisting>CALLED_AS_TRIGGER(fcinfo)
   </programlisting>
   qui se décompose en&nbsp;:
   <programlisting>((fcinfo)-&gt;context != NULL &amp;&amp; IsA((fcinfo)-&gt;context, TriggerData))
   </programlisting>
   Si elle retourne la valeur vraie, alors il est bon de convertir
   <literal>fcinfo-&gt;context</literal> en type <literal>TriggerData *</literal> et
   de
   faire usage de la structure pointée <structname>TriggerData</structname>. La fonction
   <emphasis>ne</emphasis> doit <emphasis>pas</emphasis> modifier la
   structure <structname>TriggerData</structname> ou une donnée quelconque vers laquelle
   elle pointe.
  </para>

  <para>
   <structname>struct TriggerData</structname> est définie dans
   <filename>commands/trigger.h</filename>&nbsp;:

   <programlisting>typedef struct TriggerData
{
    NodeTag          type;
    TriggerEvent     tg_event;
    Relation         tg_relation;
    HeapTuple        tg_trigtuple;
    HeapTuple        tg_newtuple;
    Trigger         *tg_trigger;
    TupleTableSlot  *tg_trigslot;
    TupleTableSlot  *tg_newslot;
    Tuplestorestate *tg_oldtable;
    Tuplestorestate *tg_newtable;
    const Bitmapset *tg_updatedcols;
} TriggerData;
   </programlisting>

   où les membres sont définis comme suit&nbsp;:

   <variablelist>
    <varlistentry>
     <term><structfield>type</structfield></term>
     <listitem>
      <para>
       Toujours <literal>T_TriggerData</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><structfield>tg_event</structfield></term>
     <listitem>
      <para>
       Décrit l'événement pour lequel la fonction est appelée. Vous pouvez utiliser
       les macros suivantes pour examiner <literal>tg_event</literal>&nbsp;:

       <variablelist>
        <varlistentry>
         <term><literal>TRIGGER_FIRED_BEFORE(tg_event)</literal></term>
         <listitem>
          <para>
           Renvoie vrai si le trigger est lancé avant l'opération.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TRIGGER_FIRED_AFTER(tg_event)</literal></term>
         <listitem>
          <para>
           Renvoie vrai si le trigger est lancé après l'opération.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TRIGGER_FIRED_INSTEAD(tg_event)</literal></term>
         <listitem>
          <para>
           Renvoie vrai si le trigger a été lancé à la place de l'opération.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TRIGGER_FIRED_FOR_ROW(tg_event)</literal></term>
         <listitem>
          <para>
           Renvoie vrai si le trigger est lancé pour un événement en
           mode ligne.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TRIGGER_FIRED_FOR_STATEMENT(tg_event)</literal></term>
         <listitem>
          <para>
           Renvoie vrai si le trigger est lancé pour un événement en
           mode instruction.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TRIGGER_FIRED_BY_INSERT(tg_event)</literal></term>
         <listitem>
          <para>
           Retourne vrai si le trigger est lancé par une commande
           <command>INSERT</command>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TRIGGER_FIRED_BY_UPDATE(tg_event)</literal></term>
         <listitem>
          <para>
           Retourne vrai si le trigger est lancé par une commande
           <command>UPDATE</command>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TRIGGER_FIRED_BY_DELETE(tg_event)</literal></term>
         <listitem>
          <para>
           Retourne vrai si le trigger est lancé par une commande
           <command>DELETE</command>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TRIGGER_FIRED_BY_TRUNCATE(tg_event)</literal></term>
         <listitem>
          <para>
           Renvoie true si le trigger a été déclenché par une commande
           <command>TRUNCATE</command>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><structfield>tg_updatedcols</structfield></term>
         <listitem>
          <para>
           Pour les triggers <literal>UPDATE</literal>, un champ bitmap
           indique les colonnes mises à jour par la commande qui a déclenché
           le trigger. Les fonctions des triggers génériques peuvent utiliser
           ce champ pour optimiser les actions en n'ayant pas à s'occuper des
           colonnes qui n'ont pas été modifiées.
          </para>

          <para>
           Par exemple, pour déterminer si la colonne de numéro d'attribut
           <varname>attnum</varname> (commençant à 1) est un membre de ce
           champ, appelez <literal>bms_is_member(attnum -
            FirstLowInvalidHeapAttributeNumber,
            trigdata->tg_updatedcols))</literal>.
          </para>

          <para>
           Pour les triggers autres que ceux en <literal>UPDATE</literal>, ce
           champ sera à la valeur <symbol>NULL</symbol>.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><structfield>tg_relation</structfield></term>
     <listitem>
      <para>
       Un pointeur vers une structure décrivant la relation pour laquelle le
       trigger est lancé. Voir <filename>utils/reltrigger.h</filename> pour les détails
       de cette structure. Les choses les plus intéressantes sont
       <literal>tg_relation-&gt;rd_att</literal> (descripteur de nuplets de la
       relation) et <literal>tg_relation-&gt;rd_rel-&gt;relname</literal> (nom de la
       relation&nbsp;;
       le type n'est pas <type>char*</type> mais <type>NameData</type>&nbsp;; utilisez
       <literal>SPI_getrelname(tg_relation)</literal> pour obtenir un <type>char*</type>
       si vous avez besoin d'une copie du nom).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><structfield>tg_trigtuple</structfield></term>
     <listitem>
      <para>
       Un pointeur vers la ligne pour laquelle le trigger a été lancé. Il
       s'agit de la ligne étant insérée, mise à jour ou effacée. Si ce
       trigger a été lancé pour une commande <command>INSERT</command> ou
       <command>DELETE</command>, c'est cette valeur que la fonction doit retourner si
       vous ne voulez pas remplacer la ligne par une ligne différente (dans le
       cas d'un <command>INSERT</command>) ou sauter l'opération. Dans le cas de
       triggers sur tables distantes, les valeurs des colonnes systèmes ne sont
       pas spécifiées ici.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><structfield>tg_newtuple</structfield></term>
     <listitem>
      <para>
       Un pointeur vers la nouvelle version de la ligne, si le trigger a
       été lancé pour un <command>UPDATE</command> et <symbol>NULL</symbol> si c'est
       pour un <command>INSERT</command> ou un <command>DELETE</command>.
       C'est ce que la fonction doit retourner si l'événement est un
       <command>UPDATE</command> et que vous ne voulez pas remplacer cette
       ligne par une ligne différente ou bien sauter l'opération. Dans le cas de
       triggers sur tables distantes, les valeurs des colonnes systèmes ne sont
       pas spécifiées ici.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><structfield>tg_trigger</structfield></term>
     <listitem>
      <para>
       Un pointeur vers une structure de type <structname>Trigger</structname>, définie
       dans <filename>utils/rel.h</filename>&nbsp;:

       <programlisting>typedef struct Trigger
{
    Oid         tgoid;
    char       *tgname;
    Oid         tgfoid;
    int16       tgtype;
    char        tgenabled;
    bool        tgisinternal;
    bool        tgisclone;
    Oid         tgconstrrelid;
    Oid         tgconstrindid;
    Oid         tgconstraint;
    bool        tgdeferrable;
    bool        tginitdeferred;
    int16       tgnargs;
    int16       tgnattr;
    int16      *tgattr;
    char      **tgargs;
    char       *tgqual;
    char       *tgoldtable;
    char       *tgnewtable;
} Trigger;
       </programlisting>

       où <structfield>tgname</structfield> est le nom du trigger,
       <structfield>tgnargs</structfield> est le nombre d'arguments dans
       <structfield>tgargs</structfield> et <structfield>tgargs</structfield> est un tableau de
       pointeurs vers les arguments spécifiés dans l'expression contenant la
       commande <command>CREATE TRIGGER</command>. Les autres membres ne sont
       destinés qu'à un usage interne.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><structfield>tg_trigslot</structfield></term>
     <listitem>
      <para>
       Le slot contenant <structfield>tg_trigtuple</structfield>, ou un
       pointeur <symbol>NULL</symbol> si cette ligne n'existe pas.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><structfield>tg_newslot</structfield></term>
     <listitem>
      <para>
       Le slot contenant <structfield>tg_newtuple</structfield>, ou un
       pointeur <symbol>NULL</symbol> si cette ligne n'existe pas.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><structfield>tg_oldtable</structfield></term>
     <listitem>
      <para>
       Un pointeur vers une structure de type
       <structname>Tuplestorestate</structname> contenant zéro ou plusieurs
       lignes dans le format spécifié par
       <structfield>tg_relation</structfield>, ou un pointeur
       <symbol>NULL</symbol> s'il n'y a pas de relation de transition
       <literal>OLD TABLE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><structfield>tg_newtable</structfield></term>
     <listitem>
      <para>
       Un pointeur vers une structure de type
       <structname>Tuplestorestate</structname> contenant zéro ou plusieurs
       lignes dans le format spécifié par
       <structfield>tg_relation</structfield>, ou un pointeur
       <symbol>NULL</symbol> s'il n'y a pas de relation de transition
       <literal>NEW TABLE</literal>.
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>

  <para>
   Pour permettre aux requêtes exécutées via SPI de référencer les tables de
   transition, voir <xref linkend="spi-spi-register-trigger-data"/>.
  </para>

  <para>
   Une fonction trigger doit retourner soit un pointeur
   <structname>HeapTuple</structname> soit un pointeur <symbol>NULL</symbol> (<emphasis>pas</emphasis>
   une valeur SQL NULL, donc ne positionnez pas <parameter>isNull</parameter> à
   true). Faites attention de renvoyer soit un
   <structfield>tg_trigtuple</structfield> soit un <structfield>tg_newtuple</structfield>,
   comme approprié, si vous ne voulez pas changer la ligne en cours de
   modification.
  </para>

 </sect1>

 <sect1 id="trigger-example">
  <title>Un exemple complet de trigger</title>

  <para>
   Voici un exemple très simple de fonction trigger écrite en C (les
   exemples de triggers écrits avec différents langages de procédures
   se trouvent dans la documentation de ceux-ci).
  </para>

  <para>
   La fonction <function>trigf</function> indique le nombre de lignes de la table
   <structname>ttest</structname> et saute l'opération si la commande tente d'insérer une
   valeur NULL dans la colonne <structfield>x</structfield> (ainsi le trigger agit
   comme une contrainte non NULL mais n'annule pas la transaction).
  </para>

  <para>
   Tout d'abord, la définition des tables&nbsp;:
   <programlisting>CREATE TABLE ttest (
    x integer
);
   </programlisting>
  </para>

  <para>
   Voici le code source de la fonction trigger :
   <programlisting><![CDATA[#include "postgres.h"
#include "fmgr.h"
#include "executor/spi.h"       /* nécessaire pour fonctionner avec SPI */
#include "commands/trigger.h"   /* ... les triggers */
#include "utils/rel.h"          /* ... et relations */

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(trigf);

Datum
trigf(PG_FUNCTION_ARGS)
{
    TriggerData *trigdata = (TriggerData *) fcinfo->context;
    TupleDesc   tupdesc;
    HeapTuple   rettuple;
    char       *when;
    bool        checkNULL = false;
    bool        isNULL;
    int         ret, i;

    /* on s'assure que la fonction est appelée en tant que trigger */
    if (!CALLED_AS_TRIGGER(fcinfo))
        elog(ERROR, "trigf: not called by trigger manager");

    /* nuplet à retourner à l'exécuteur */
    if (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))
        rettuple = trigdata->tg_newtuple;
    else
        rettuple = trigdata->tg_trigtuple;

    /* vérification des valeurs NULL */
    if (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event)
        && TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        checkNULL = true;

    if (TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        when = "before";
    else
        when = "after ";

    tupdesc = trigdata->tg_relation->rd_att;

    /* connexion au gestionnaire SPI */
    if ((ret = SPI_connect()) < 0)
        elog(ERROR, "trigf (fired %s): SPI_connect returned %d", when, ret);

    /* obtient le nombre de lignes dans la table */
    ret = SPI_exec("SELECT count(*) FROM ttest", 0);

    if (ret < 0)
        elog(ERROR, "trigf (fired %s): SPI_exec returned %d", when, ret);

    /* count(*) renvoie int8, prenez garde à bien convertir */
    i = DatumGetInt64(SPI_getbinval(SPI_tuptable->vals[0],
                                    SPI_tuptable->tupdesc,
                                    1,
                                    &isNULL));

    elog (INFO, "trigf (fired %s): there are %d rows in ttest", when, i);

    SPI_finish();

    if (checkNULL)
    {
        SPI_getbinval(rettuple, tupdesc, 1, &isNULL);
        if (isNULL)
            rettuple = NULL;
    }

    return PointerGetDatum(rettuple);
}
]]></programlisting>
   </para>

   <para>
    Après avoir compilé le code source (voir <xref
    linkend="dfunc"/>), déclarez la fonction et les
    triggers&nbsp;:
<programlisting>CREATE FUNCTION trigf() RETURNS trigger
    AS '<replaceable>nomfichier</replaceable>'
    LANGUAGE C;

CREATE TRIGGER tbefore BEFORE INSERT OR UPDATE OR DELETE ON ttest
    FOR EACH ROW EXECUTE FUNCTION trigf();

CREATE TRIGGER tafter AFTER INSERT OR UPDATE OR DELETE ON ttest
    FOR EACH ROW EXECUTE FUNCTION trigf();
   </programlisting>
  </para>

  <para>
   À présent, testez le fonctionnement du trigger&nbsp;:
   <screen>=&gt; INSERT INTO ttest VALUES (NULL);
INFO:  trigf (fired before): there are 0 rows in ttest
INSERT 0 0

-- Insertion supprimée et trigger AFTER non exécuté

=&gt; SELECT * FROM ttest;
 x
---
(0 rows)

=&gt; INSERT INTO ttest VALUES (1);
INFO:  trigf (fired before): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 1 rows in ttest
                                       ^^^^^^^^
                       souvenez-vous de ce que nous avons dit sur la visibilité.
INSERT 167793 1
vac=&gt; SELECT * FROM ttest;
 x
---
 1
(1 row)

=&gt; INSERT INTO ttest SELECT x * 2 FROM ttest;
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
                                       ^^^^^^
                       souvenez-vous de ce que nous avons dit sur la visibilité.
INSERT 167794 1
=&gt; SELECT * FROM ttest;
 x
---
 1
 2
(2 rows)

=&gt; UPDATE ttest SET x = NULL WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
UPDATE 0
=&gt; UPDATE ttest SET x = 4 WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
UPDATE 1
vac=&gt; SELECT * FROM ttest;
 x
---
 1
 4
(2 rows)

=&gt; DELETE FROM ttest;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
                                       ^^^^^^
                       souvenez-vous de ce que nous avons dit sur la visibilité.
DELETE 2
=&gt; SELECT * FROM ttest;
 x
---
(0 rows)
   </screen>

  </para>

  <para>
   Vous trouverez des exemples plus complexes dans
   <filename>src/test/regress/regress.c</filename> et dans
   <xref linkend="contrib-spi"/>.
  </para>
 </sect1>
</chapter>
