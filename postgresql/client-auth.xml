<?xml version="1.0" encoding="UTF-8"?>
<chapter id="client-authentication">
 <title>Authentification du client</title>

 <indexterm zone="client-authentication">
  <primary>authentification client</primary> </indexterm>

 <para>Quand une application client se connecte au serveur de bases de données,
  elle indique le nom de l'utilisateur de base de données
  à utiliser pour la connexion, de la même façon qu'on se connecte à un ordinateur
  Unix sous un nom d'utilisateur particulier. Au sein de l'environnement SQL, le
  nom d'utilisateur de la base de données active détermine les droits
  régissant l'accès aux objets de la base de données &mdash; voir le
  <xref linkend="user-manag"/> pour plus d'informations. Ainsi, il est essentiel de
  limiter le nombre de bases de données auxquelles les utilisateurs peuvent se
  connecter.</para>

 <note>
  <para>
   Comme expliqué dans le <xref linkend="user-manag"/>,
   <productname>PostgreSQL</productname> gère les droits par l'intermédiaire
   des <quote>rôles</quote>. Dans ce chapitre, le terme
   <firstterm>utilisateur de bases de données</firstterm> est utilisé pour
   signifier <quote>rôle disposant du droit <literal>LOGIN</literal></quote>.
  </para>
 </note>

 <para>L'<firstterm>authentification</firstterm> est le processus par lequel le
  serveur de bases de données établit l'identité du client et, par extension,
  détermine si l'application client (ou l'utilisateur qui l'utilise) est
  autorisée à se connecter avec le nom d'utilisateur de bases de données
  indiqué.</para>

 <para><productname>PostgreSQL</productname> offre quantité de méthodes
  d'authentification différentes. La méthode utilisée pour authentifier une connexion
  client particulière peut être sélectionnée d'après l'adresse (du client), la base de
  données et l'utilisateur.</para>

 <para>Les noms d'utilisateur de bases de données sont
  séparés de façon logique des noms d'utilisateur du système d'exploitation sur
  lequel tourne le serveur. Si tous les utilisateurs d'un serveur donné ont
  aussi des comptes sur la machine serveur, il peut être pertinent d'attribuer
  aux utilisateurs de bases de données des noms qui correspondent à ceux
  des utilisateurs du système d'exploitation. Cependant, un serveur qui
  accepte des connexions
  distantes peut avoir des utilisateurs de bases de données dépourvus de
  compte correspondant sur le système d'exploitation. Dans ce cas, aucune
  correspondance entre les noms n'est nécessaire.</para>

 <sect1 id="auth-pg-hba-conf"> <title>Le fichier <filename>pg_hba.conf</filename></title>

  <indexterm zone="auth-pg-hba-conf"> <primary>pg_hba.conf</primary>
  </indexterm>

  <para>L'authentification du client est contrôlée par un fichier,
   traditionnellement nommé <filename>pg_hba.conf</filename> et situé dans le
   répertoire data du groupe de bases de données, par exemple
   <filename>/usr/local/pgsql/data/pg_hba.conf</filename> (<acronym>HBA</acronym>
   signifie <quote>host-based authentication</quote>&nbsp;: authentification
   fondée sur l'hôte.) Un
   fichier <filename>pg_hba.conf</filename> par défaut est installé lorsque le
   répertoire data est initialisé par <command>initdb</command>. Néanmoins, il
   est possible de placer le fichier de configuration de l'authentification
   ailleurs&nbsp;; voir le paramètre de configuration <xref linkend="guc-hba-file"/>.
  </para>

  <para>
   Le format général du fichier <filename>pg_hba.conf</filename> est un
   ensemble d'enregistrements, un par ligne. Les lignes vides sont ignorées tout
   comme n'importe quel texte placé après le caractère de commentaire
   <literal>#</literal>. Un enregistrement est constitué d'un certain nombre de
   champs séparés par des espace et/ou des tabulations. Les enregistrements
   ne peuvent pas être continués sur plusieurs lignes. Les champs peuvent
   contenir des espaces si la valeur du champ est mise entre guillemets doubles.
   Mettre entre guillemets un des mots-clés dans un champ base de données,
   utilisateur ou adresse (par exemple, <literal>all</literal> ou
   <literal>replication</literal>) fait que le mot perd son interprétation
   spéciale, ou correspond à la base de données, à l'utilisateur ou à l'hôte
   ayant ce nom.
  </para>

  <para>
   Chaque enregistrement précise un type de connexion, une plage
   d'adresses IP (si approprié au type de connexion), un nom de base de données, un
   nom d'utilisateur et la méthode d'authentification à utiliser pour les
   connexions correspondant à ces paramètres. Le premier enregistrement
   qui correspond au type de connexion, à l'adresse client, à la base de données
   demandée et au nom d'utilisateur est utilisé pour effectuer l'authentification.
   Il n'y a pas de suite après une erreur (<quote>fall-through</quote> ou
   <quote>backup</quote>)&nbsp;: si un enregistrement est choisi et que l'authentification
   échoue, les enregistrements suivants ne sont pas considérés. Si aucun
   enregistrement ne correspond, l'accès est refusé.</para>

  <para>Un enregistrement peut avoir différents formats&nbsp;:
   <synopsis>
+local         <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>auth-method</replaceable> <optional><replaceable>auth-options</replaceable></optional>
+host          <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
+hostssl       <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
+hostnossl     <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
+hostgssenc    <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
+hostnogssenc  <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
+host          <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
+hostssl       <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
+hostnossl     <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
+hostgssenc    <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
+hostnogssenc  <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
   </synopsis>

   La signification des champs est la suivante&nbsp;:

   <variablelist>
    <varlistentry> <term><literal>local</literal></term>
     <listitem><para>Cet enregistrement intercepte les tentatives de connexion
       qui utilise les sockets du domaine Unix. Sans enregistrement de ce type, les
       connexions de sockets du domaine Unix ne sont pas autorisées.</para>
     </listitem></varlistentry>

    <varlistentry>
     <term><literal>host</literal></term>
     <listitem>
      <para>
       Cet enregistrement intercepte les tentatives de connexion par TCP/IP.
       Les lignes <literal>host</literal> s'appliquent à toute tentative de
       connexion, <acronym>SSL</acronym> ou non, ainsi qu'à toute tentative de
       connexion <acronym>GSSAPI</acronym> chiffrée ou non.
      </para>

      <note>
       <para>
        Les connexions TCP/IP ne sont pas autorisées si le serveur
        n'est pas démarré avec la valeur appropriée du paramètre de configuration
        <xref linkend="guc-listen-addresses"/>. En effet, par défaut, le
        serveur n'écoute que les connexions TCP/IP en provenance de
        l'adresse <literal>loopback</literal> locale, <literal>localhost</literal>.
       </para>
      </note>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostssl</literal></term>
     <listitem>
      <para>
       Cet enregistrement intercepte les seules tentatives de connexions par TCP/IP
       qui utilisent le chiffrement <acronym>SSL</acronym>.
      </para>

      <para>
       Pour utiliser cette fonction, le serveur
       doit être compilé avec le support de <acronym>SSL</acronym>. De plus,
       <acronym>SSL</acronym> doit être activé en
       positionnant le paramètre de configuration <xref linkend="guc-ssl"/>
       (voir la <xref linkend="ssl-tcp"/> pour plus d'informations).
       Dans le cas contraire, l'enregistrement <literal>hostssl</literal> est
       ignoré à l'exception d'une alerte dans les traces indiquant qu'il n'y a
       aucune connexion correspondante.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostnossl</literal></term>
     <listitem>
      <para>
       Cet enregistrement a un comportement opposé à <literal>hostssl</literal>&nbsp;: il
       n'intercepte que les tentatives de connexion qui n'utilisent pas
       <acronym>SSL</acronym>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostgssenc</literal></term>
     <listitem>
      <para>
       Cet enregistrement intercepte les tentatives de connexions par TCP/IP,
       mais seulement si la connexion est faite avec un chiffrement
       <acronym>GSSAPI</acronym>
       encryption.
      </para>

      <para>
       Pour utiliser cette fonction, le serveur doit être compilé avec le
       support de <acronym>GSSAPI</acronym> activé. Dans le cas contraire,
       l'enregistrement <literal>hostgssenc</literal> est ignoré à l'exception
       d'une alerte dans les traces indiquant qu'il n'y a aucune connexion
       correspondante.
      </para>

      <para>
       Veuillez noter que les seules <link linkend="auth-methods">méthodes
        d'authentification</link> supportées pour l'utilisation d'un
       chiffrement <acronym>GSSAPI</acronym> sont <literal>gss</literal>,
       <literal>reject</literal>, et <literal>trust</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostnogssenc</literal></term>
     <listitem>
      <para>
       Cet enregistrement a un comportement opposé à <literal>hostgssenc</literal>;
       il n'intercepte que les tentatives de connexion qui n'utilisent pas le
       chiffrement <acronym>GSSAPI</acronym>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>database</replaceable></term>
     <listitem>
      <para>
       Indique les noms des bases de données concernées par l'enregistrement. La
       valeur <literal>all</literal> indique qu'il concerne toutes les bases
       de données.
       Le terme <literal>sameuser</literal> indique que l'enregistrement
       coïncide si la base de données demandée a le même nom que l'utilisateur
       demandé.
       Le terme <literal>samerole</literal> indique que l'utilisateur demandé doit
       être membre du rôle portant le même nom que la base de données demandée
       (<literal>samegroup</literal> est obsolète bien qu'il soit toujours accepté
       comme écriture alternative de <literal>samerole</literal>.).
       Les super-utilisateurs ne sont pas considérés comme membres d'un rôle dans le
       cadre de <literal>samerole</literal> à moins qu'ils ne soient explicitement
       membres du rôle, de manière directe ou indirecte, et non pas juste par ses
       droits de super-utilisateur.
       La valeur <literal>replication</literal> indique que l'enregistrement
       établit une correspondance si une connexion de réplication physique est demandée
       (notez que les connexions de réplication ne ciblent pas une base de
       données particulière). Dans tous les autres cas,
       c'est le nom d'une base de données particulière. Plusieurs noms de base de
       données peuvent être fournis en les séparant par des virgules. Un fichier contenant
       des noms de base de données peut être indiqué en faisant précéder le
       nom du fichier de <literal>@</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>user</replaceable></term>
     <listitem>
      <para>
       Indique les utilisateurs de bases de données auxquels cet enregistrement
       correspond. La valeur <literal>all</literal> indique qu'il concerne tous
       les utilisateurs. Dans le cas contraire, il s'agit soit du nom d'un utilisateur
       spécifique de bases de données ou d'un nom de groupe précédé par un
       <literal>+</literal> (il n'existe pas de véritable distinction
       entre les utilisateurs et les groupes dans
       <productname>PostgreSQL</productname>&nbsp;; un <literal>+</literal>
       signifie exactement
       <quote>établit une correspondance pour tous les rôles faisant parti
        directement ou indirectement de ce rôle</quote> alors qu'un nom sans
       <literal>+</literal> établit une correspondance avec ce rôle spécifique).
       Ainsi, un super-utilisateur n'est considéré comme membre d'un rôle que s'il
       est explicitement membre du rôle, directement ou indirectement, et non pas
       juste par ses droits de super-utilisateur.
       Plusieurs noms d'utilisateurs peuvent être fournis en les séparant
       par des virgules. Un fichier contenant des noms d'utilisateurs peut
       être indiqué en faisant précéder le nom du fichier de <literal>@</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>address</replaceable></term>
     <listitem>
      <para>
       Indique l'adresse IP ou la plage d'adresses IP à laquelle correspond
       cet enregistrement. Ce champ peut contenir soit un nom de machine
       (FQDN), soit le suffixe d'un domaine (sous la forme .exemple.com),
       soit une adresse ou une plage d'adresses IP, soit enfin l'un des mots-clés
       mentionnés ci-après.
      </para>

      <para>
       Une plage d'adresses IP est spécifiée en utilisant la notation
       numérique standard (adresse de début de plage, suivi d'un slash
       (<literal>/</literal>) et suivi de la longueur du masque
       <acronym>CIDR</acronym>. La longueur du masque indique le nombre de
       bits forts pour lesquels une correspondance doit être trouvée avec
       l'adresse IP du client. Les bits de droite doivent valoir zéro dans
       l'adresse IP indiquée. Il ne doit y avoir aucune espace entre l'adresse
       IP, le <literal>/</literal> et la longueur du masque CIDR.
      </para>

      <para>
       À la place du <replaceable>CIDR-address</replaceable>, vous pouvez
       écrire <literal>samehost</literal> pour correspondre aux adresses IP du
       serveur ou <literal>samenet</literal> pour correspondre à toute adresse
       du sous-réseau auquel le serveur est directement connecté.
      </para>

      <para>
       Une plage d'adresses IPv4 spécifiée au format CIDR est typiquement
       <literal>172.20.143.89/32</literal> pour un hôte seul,
       <literal>172.20.143.0/24</literal> pour un petit réseau ou
       <literal>10.6.0.0/16</literal> pour un réseau plus grand. Une plage
       d'adresses IPv6 spécifiée au format CIDR est par exemple
       <literal>::1/128</literal> pour un hôte seul (dans ce cas la boucle
       locale IPv6) ou <literal>fe80::7a31:c1ff:0000:0000/96</literal> pour un
       petit réseau. <literal>0.0.0.0/0</literal> représente toutes les adresses
       IPv4, et <literal>::0/0</literal> représente l'ensemble des adresses
       IPv6. Pour n'indiquer qu'un seul hôte, on utilise une longueur de masque
       de 32 pour IPv4 ou 128 pour IPv6. Dans une adresse réseau, ne pas oublier
       les zéros terminaux.
      </para>

      <para>
       Une entrée donnée dans le format IPv4 correspondra seulement aux
       connexions IPv4, et une entrée donnée dans le format IPv6 correspondra
       seulement aux connexions IPv6, même si l'adresse représentée est dans
       la plage IPv4-in-IPv6. Notez que les entrées au format IPv6 seront
       rejetées si la bibliothèque C du système n'a pas de support des adresses
       IPv6.
      </para>

      <para>
       La valeur <literal>all</literal> permet de cibler n'importe quelle
       adresse IP cliente, <literal>samehost</literal> n'importe quelle adresse
       IP du serveur ou <literal>samenet</literal> pour toute adresse IP
       faisant partie du même sous-réseau que le serveur.
      </para>

      <para>
       Si un nom d'hôte est renseigné (dans les faits tout ce qui ne correspond pas
       à une plage d'adresse ou une plage d'adresses IP, ni à un mot clé, sera traité
       comme un nom d'hôte), ce nom est comparé au résultat d'une
       résolution de nom inverse de l'adresse IP du client (ou une recherche
       DNS inverse si un DNS est utilisé). Les comparaisons de noms d'hôtes
       ne sont pas sensibles à la casse. En cas de correspondance, une nouvelle
       recherche récursive de nom sera lancée afin de déterminer que
       le nom d'hôte concorde bel et bien avec l'adresse IP du client. L'enregistrement
       n'est validé qu'en cas de concordance entre la résolution inverse et la
       résolution récursive pour l'adresse IP cliente. (Le nom d'hôte fourni dans
       le fichier <filename>pg_hba.conf</filename> doit donc correspondre à
       au moins l'une des adresses IP fournies par le mécanisme de résolution de
       noms, sinon l'enregistrement ne sera pas pris en considération. Certains
       serveurs de noms réseau permettent d'associer une adresse IP à de multiples
       noms d'hôtes (alias DNS), mais bien souvent le système d'exploitation ne
       retourne qu'un seul nom d'hôte lors de la résolution d'une adresse IP.)
      </para>

      <para>
       Un nom d'hôte débutant par un point (<literal>.</literal>) ciblera le
       suffixe du nom d'hôte du poste client. Du coup, indiquer <literal>.exemple.com</literal>
       correspondra à la machine <literal>foo.exemple.com</literal> (mais pas
       au client <literal>exemple.com</literal>).
      </para>

      <para>
       Lorsque vous spécifiez des noms d'hôtes dans le fichier <filename>pg_hba.conf</filename>,
       vous devez vous assurer que la résolution de noms soit raisonnablement rapide.
       À défaut, il peut être avantageux de configurer un serveur-cache local pour
       effectuer la résolution de noms, tel que <command>nscd</command>.
       Vous pouvez également valider le paramètre de configuration <varname>log_hostname</varname>
       afin de retrouver dans les journaux le nom d'hôte du client au lieu de sa
       simple adresse IP.
      </para>

      <para>
       Ces champs ne concernent pas les enregistrements
       <literal>local</literal>.
      </para>

      <note>
       <para>
        Les utilisateurs se demandent parfois pourquoi les noms d'hôte sont
        gérés de cette manière apparemment si compliquée, avec deux résolutions
        de nom incluant une résolution inverse de l'adresse IP du client.  Cela
        complique l'utilisation de cette fonctionnalité dans le cas  où l'entrée
        de reverse-DNS n'est pas remplie ou retourne un nom d'hôte indésirable.
        Cela est fait essentiellement pour raison d'efficacité&nbsp;: de cette
        manière, une tentative de connexion nécessite au plus deux recherches de
        résolution, dont une inversée.  S'il y a un problème de résolution avec
        une adresse, cela devient le problème du client.  Une alternative
        d'implémentation hypothétique qui ne ferait pas de recherche inverse se
        verrait obligée de résoudre chaque nom d'hôte mentionné dans
        <filename>pg_hba.conf</filename> à chaque tentative de connexion.  Cela
        serait plutôt lent si de nombreux noms étaient listés.  De plus, s'il y
        a un problème de résolution pour un seul des noms d'hôte, cela devient
        le problème de tout le monde.
       </para>

       <para>
        De plus, une résolution inverse est nécessaire pour implémenter
        la fonctionnalité de correspondance par suffixe dans la mesure où
        le nom d'hôte du candidat à la connexion doit être connu afin de
        pouvoir effectuer cette comparaison.
       </para>

       <para>
        Enfin, cette méthode est couramment adoptée par d'autres implémentations
        du contrôle d'accès basé sur les noms d'hôtes, tels que le serveur web
        Apache ou TCP-wrapper.
       </para>
      </note>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>IP-address</replaceable></term>
     <term><replaceable>IP-mask</replaceable></term>
     <listitem>
      <para>
       Ces champs peuvent être utilisés comme alternative à la notation
       <replaceable>adresse IP</replaceable><literal>/</literal><replaceable>longueur
        masque</replaceable>. Au lieu de spécifier la longueur
       du masque, le masque réel est indiquée dans une colonne distincte. Par
       exemple, <literal>255.0.0.0</literal> représente une longueur de masque CIDR
       IPv4 de 8, et <literal>255.255.255.255</literal> représente une longueur de
       masque de 32.
      </para>

      <para>
       Ces champs ne concernent pas les enregistrements
       <literal>local</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry> <term><replaceable>auth-method</replaceable></term>
     <listitem>
      <para>
       Indique la méthode d'authentification à utiliser lors d'une
       connexion via cet enregistrement. Les choix possibles sont résumés ici&nbsp;; les
       détails se trouvent dans la <xref linkend="auth-methods"/>.

       <variablelist>
        <varlistentry>
         <term><literal>trust</literal></term>
         <listitem>
          <para>
           Autorise la connexion sans condition. Cette méthode permet à
           quiconque peut se connecter au serveur de bases de données
           de s'enregistrer sous n'importe quel utilisateur
           <productname>PostgreSQL</productname> de son choix sans
           mot de passe ou autre authentification. Voir la <xref
           linkend="auth-trust"/> pour les détails.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>reject</literal></term>
         <listitem>
          <para>
           Rejette la connexion sans condition. Ce cas est utile
           pour <quote>filtrer</quote> certains hôtes d'un groupe, par exemple une
           ligne <literal>reject</literal> peut bloquer la connexion d'un hôte
           spécifique alors qu'une ligne plus bas permettra aux autres hôtes de
           se connecter à partir d'un réseau spécifique.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>scram-sha-256</literal></term>
         <listitem>
          <para>
           Réalise une authentification SCRAM-SHA-256 afin de vérifier le
           mot de passe utilisateur. Voir <xref linkend="auth-password"/> pour les détails.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>md5</literal></term>
         <listitem>
          <para>
           Réalise une authentification SCRAM-SHA-256 ou MD5 afin de vérifier le
           mot de passe utilisateur. Voir <xref linkend="auth-password"/>
           pour les détails.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>password</literal></term>
         <listitem>
          <para>
           Requiert que le client fournisse un mot de passe non chiffré pour
           l'authentification. Comme le mot de passe est envoyé en clair sur
           le réseau, ceci ne doit pas être utilisé sur des réseaux non
           dignes de confiance. Voir la <xref linkend="auth-password"/> pour
           les détails.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>gss</literal></term>
         <listitem>
          <para>
           Utilise GSSAPI pour authentifier l'utilisateur. Disponible uniquement
           pour les connexions TCP/IP. Voir <xref
           linkend="gssapi-auth"/> pour les détails. Il peut être utilisé
           conjointement avec le chiffrement GSSAPI.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>sspi</literal></term>
         <listitem>
          <para>
           Utilise SSPI pour authentifier l'utilisateur. Disponible uniquement
           sur Windows. Voir <xref
           linkend="sspi-auth"/> pour plus de détails.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>ident</literal></term>
         <listitem>
          <para>
           Récupère le nom de l'utilisateur en contactant le serveur d'identification
           sur le poste client, et vérifie que cela correspond au nom d'utilisateur de
           base de données demandé.
           L'authentification Ident ne peut être utilisée que pour les connexions TCP/IP.
           Pour les connexions locales, elle sera remplacée par l'authentification peer.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>peer</literal></term>
         <listitem>
          <para>
           Récupère le nom d'utilisateur identifié par le système d'exploitation
           du client et vérifie que cela correspond au nom d'utilisateur de
           base de données demandé.
           Peer ne peut être utilisée que pour les connexions locales.
           Voir la <xref linkend="auth-peer"/> ci-dessous pour les details.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>ldap</literal></term>
         <listitem>
          <para>
           Authentification par un serveur <acronym>LDAP</acronym>. Voir la
           <xref linkend="auth-ldap"/> pour les détails.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>radius</literal></term>
         <listitem>
          <para>
           Authentification par un serveur RADIUS. Voir <xref
           linkend="auth-radius"/> pour les détails.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>cert</literal></term>
         <listitem>
          <para>
           Authentification par certificat client SSL. Voir
           <xref linkend="auth-cert"/> pour les détails.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>pam</literal></term>
         <listitem>
          <para>
           Authentification par les Pluggable Authentification Modules (PAM)
           fournis par le système d'exploitation. Voir la <xref linkend="auth-pam"/>
           pour les détails.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>bsd</literal></term>
         <listitem>
          <para>
           Authentification utilisant le service BSD Authentication fourni par
           le système d'exploitation. Voir <xref linkend="auth-bsd"/> pour plus
           de détails.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>auth-options</replaceable></term>
     <listitem>
      <para>
       Après le champ <replaceable>auth-method</replaceable>, on peut trouver
       des champs de la forme
       <replaceable>nom</replaceable><literal>=</literal><replaceable>valeur</replaceable>
       qui spécifient des options pour la méthode d'authentification. Les
       détails sur les options disponibles apparaissent ci-dessous pour chaque
       méthode d'authentification.
      </para>

      <para>
       En plus des options spécifiques à une méthode listées ci-dessous, il
       existe une option d'authentification indépendante de la méthode,
       appelée <literal>clientcert</literal>, qui peut être indiquée dans tout
       enregistrement <literal>hostssl</literal>.
       Cette option peut être positionnée à <literal>verify-ca</literal> ou
       <literal>verify-full</literal>. Ces deux options nécessitent que le
       client présente un certificat valide (de confiance), alors que
       <literal>verify-full</literal> valide également que le
       <literal>cn</literal> (Common Name) dans le certificat corresponde au
       nom d'utilisateur ou a une correspondance adéquate.
       Ce comportement est similaire à la méthode d'authentification <literal>cert</literal>
       (voir <xref linkend="auth-cert"/> ) mais autorise à appairer la
       vérification du certificat client avec toute méthode d'authentification
       qui supporte les entrées <literal>hostssl</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Les fichiers inclus par les constructions <literal>@</literal> sont lus comme des
   listes de noms, séparés soit par des espaces soit par
   des virgules. Les commentaires sont introduits par le caractère
   <literal>#</literal> comme dans <filename>pg_hba.conf</filename>, et les
   constructions <literal>@</literal> imbriquées sont autorisées. À moins
   que le nom du fichier qui suit <literal>@</literal> ne soit un chemin absolu,
   il est supposé relatif au répertoire contenant le fichier le référençant.
  </para>

  <para>
   Les enregistrements du fichier <filename>pg_hba.conf</filename> sont
   examinés séquentiellement à chaque tentative de connexion, l'ordre des
   enregistrements est donc significatif. Généralement, les premiers enregistrements
   ont des paramètres d'interception de connexions stricts et des méthodes
   d'authentification peu restrictives tandis que les
   enregistrements suivants ont des paramètres plus larges et des méthodes
   d'authentification plus fortes. Par exemple, on peut souhaiter utiliser
   l'authentification <literal>trust</literal> pour les connexions TCP/IP locales mais
   demander un mot de passe pour les connexion TCP/IP distantes. Dans ce cas,
   l'enregistrement précisant une authentification <literal>trust</literal> pour les
   connexions issues de 127.0.0.1 apparaît avant un enregistrement indiquant
   une authentification par mot de passe pour une plage plus étendue d'adresses IP
   client autorisées.
  </para>

  <para>
   Le fichier <filename>pg_hba.conf</filename> est lu au démarrage et
   lorsque le processus serveur principal reçoit un signal
   <systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm>.
   Si le fichier est édité sur un système actif, on peut signaler au
   postmaster (en utilisant <literal>pg_ctl reload</literal>, en appelant la
   fonction SQL <function>pg_reload_conf()</function>, ou <literal>kill
    -HUP</literal>) de relire le fichier.
  </para>

  <note>
   <para>
    L'information précédente n'est pas vraie sous Microsoft Windows&nbsp;: ici, tout
    changement dans le fichier <filename>pg_hba.conf</filename> est immédiatement
    appliqué à toute nouvelle connexion.
   </para>
  </note>

  <para>
   La vue système
   <link linkend="view-pg-hba-file-rules"><structname>pg_hba_file_rules</structname></link>
   peut aider pour pré-tester les changements dans le fichier <filename>pg_hba.conf</filename>,
   ou pour diagnostiquer des problèmes si le rechargement du fichier n'a pas eu les
   effets escomptés.  Les lignes dans la vue avec
   des champs <structfield>error</structfield> non vides indiquent des problèmes dans
   les lignes correspondantes du fichier.
  </para>

  <tip>
   <para>
    Pour se connecter à une base particulière, un utilisateur doit non
    seulement passer les vérifications de <filename>pg_hba.conf</filename> mais doit
    également avoir le droit <literal>CONNECT</literal> sur cette base. Pour
    contrôler qui peut se connecter à quelles bases, il est en général plus
    facile de le faire en donnant ou retirant le privilège
    <literal>CONNECT</literal> plutôt qu'en
    plaçant des règles dans le fichier <filename>pg_hba.conf</filename>.
   </para>
  </tip>

  <para>
   Quelques exemples d'entrées de <filename>pg_hba.conf</filename> sont
   donnés ci-dessous dans l'<xref linkend="example-pg-hba.conf"/>. Voir la
   section suivante pour les détails des méthodes d'authentification.  </para>

  <example id="example-pg-hba.conf">
   <title>Exemple d'entrées de <filename>pg_hba.conf</filename></title>
   <programlisting># Permettre à n'importe quel utilisateur du système local de se connecter
# à la base de données sous n'importe quel nom d'utilisateur au travers
# des sockets de domaine Unix (par défaut pour les connexions locales).
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   all             all                                     trust

# La même chose en utilisant les connexions TCP/IP locales loopback.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             127.0.0.1/32            trust

# Pareil mais en utilisant une colonne netmask distincte.
#
# TYPE  DATABASE    USER        IP-ADDRESS          IP-mask              METHOD
host    all         all         127.0.0.1           255.255.255.255      trust

# Pareil mais en IPv6.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             ::1/128                 trust

# À l'identique en utilisant le nom d'hôte (qui doit typiquement fonctionner en IPv4 et IPv6).
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             localhost               trust

# Permettre à n'importe quel utilisateur de n'importe quel hôte d'adresse IP
# 192.168.93.x de se connecter à la base de données "postgres" sous le nom
# d'utilisateur qu'ident signale à la connexion (généralement le
# nom utilisateur du système d'exploitation).
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    postgres        all             192.168.93.0/24         ident

# Permet à un utilisateur de l'hôte 192.168.12.10 de se connecter à la base de
# données "postgres" si le mot de passe de l'utilisateur est correctement fourni.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    postgres        all             192.168.12.10/32        scram-sha-256

# Permet la connexion à n'importe quel utilisateur depuis toutes les machines du
# domaine exemple.com à n'importe quelle base de données si le mot de passe
# correct est fourni.
#
# Require SCRAM authentication for most users, but make an exception
# for user 'mike', who uses an older client that doesn't support SCRAM
# authentication.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             mike            .example.com            md5
host    all             all             .example.com            scram-sha-256

# Si aucune ligne "host" ne précède, ces trois lignes rejettent toutes
# les connexions en provenance de 192.168.54.1 (puisque cette entrée déclenche
# en premier), mais autorisent les connexions chiffrées GSSAPI de n'importe où
# ailleurs sur l'Internet. Le masque zéro signifie qu'aucun bit de l'ip de
# l'hôte n'est considéré, de sorte à correspondre à tous les hôtes. Les
# connexions GSSAPI non chiffrée (qui "échouent" jusqu'à la troisième ligne
# puisque "hostgssenc" ne correspond qu'aux connections GSSAPI chiffrées) sont
# autorisées, mais seulement depuis 192.168.12.10.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.54.1/32         reject
hostgssenc all          all             0.0.0.0/0               gss
host    all             all             192.168.12.10/32        gss

# Permettre à tous les utilisateurs de se connecter depuis 192.168.x.x à n'importe
# quelle base de données s'ils passent la vérification d'identification. Si,
# par exemple, ident indique que l'utilisateur est "bryanh" et qu'il
# demande à se connecter en tant qu'utilisateur PostgreSQL "guest1", la
# connexion n'est permise que s'il existe une entrée dans pg_ident.conf pour la
# correspondance "omicron" disant que "bryanh" est autorisé à se connecter en
# tant que "guest1".
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.0.0/16          ident map=omicron

# Si ces trois lignes traitent seules les connexions locales, elles
# n'autorisent les utilisateurs locaux qu'à se connecter à leur propre
# base de données (base ayant le même nom que leur nom
# d'utilisateur) exception faite des administrateurs
# et des membres du rôle "support" qui peuvent se connecter à toutes les bases
# de données. Le fichier $PGDATA/admins contient une liste de noms
# d'administrateurs. Un mot de passe est requis dans tous les cas.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   sameuser        all                                     md5
local   all             @admins                                 md5
local   all             +support                                md5

# Les deux dernières lignes ci-dessus peuvent être combinées en une seule ligne :
local   all         @admins,+support                  md5

# La colonne database peut aussi utiliser des listes et des noms de fichiers :
local   db1,db2,@demodbs  all                         md5</programlisting>
</example>

 </sect1>

 <sect1 id="auth-username-maps">
  <title>Correspondances d'utilisateurs</title>

  <indexterm zone="auth-username-maps">
   <primary>Correspondance d'identités</primary>
  </indexterm>

  <para>
   Lorsqu'on utilise une authentification externe telle que Ident ou GSSAPI,
   le nom de l'utilisateur du système d'exploitation qui a initié la connexion
   peut ne pas être le même que celui de l'utilisateur de la base à laquelle il
   tente de se connecter. Dans ce cas, une table de correspondance d'identités
   peut être mise en place pour faire correspondre le nom d'utilisateur système
   au nom d'utilisateur base de donnée. Pour utiliser une table de correspondance
   d'identités, spécifiez <literal>map</literal>=<replaceable>nom-table</replaceable>
   dans le champ options de <filename>pg_hba.conf</filename>. Cette option est supportée
   pour toutes les méthodes d'authentification qui reçoivent des noms d'utilisateurs
   externes. Comme différentes correspondances peuvent être nécessaires pour différentes
   connexions, le nom de la table à utiliser doit être spécifié dans le paramètre
   <replaceable>nom-table</replaceable> de <filename>pg_hba.conf</filename> afin
   d'indiquer quelle table utiliser pour chaque connexion.
  </para>

  <para>
   Les tables de correspondance de noms d'utilisateurs sont définies dans le fichier de
   correspondance, qui par défaut s'appelle
   <filename>pg_ident.conf</filename><indexterm><primary>pg_ident.conf</primary></indexterm>
   et est stocké dans le répertoire de données du cluster. (Toutefois, il est
   possible de placer la table de correspondance ailleurs&nbsp;; voir le
   paramètre de configuration <xref linkend="guc-ident-file"/>.)
   Le fichier de table de correspondance contient des lignes de la forme
   suivante&nbsp;:
<synopsis>
<replaceable>nom-table</replaceable> <replaceable>nom-d-utilisateur-systeme</replaceable> <replaceable>nom-d-utilisateur-base</replaceable>
   </synopsis>
   Les commentaires et les blancs sont traités de la même façon que dans
   <filename>pg_hba.conf</filename>. Le <replaceable>nom-table</replaceable>
   est un nom arbitraire qui sera utilisé pour faire référence à cette table
   de correspondance dans <filename>pg_hba.conf</filename>. Les deux autres
   champs spécifient un nom d'utilisateur du système d'exploitation et un nom
   d'utilisateur de la base de données correspondant. Le même
   <replaceable>nom-correspondance</replaceable> peut être utilisé de façon
   répétée pour indiquer plusieurs correspondances d'utilisateur dans la
   même carte.
  </para>

  <para>
   Il n'y a aucune restriction sur le nombre d'utilisateurs de base de données
   auxquels un utilisateur du système d'exploitation peut correspondre et
   vice-versa. Du coup, les entrées dans une carte signifient que
   <quote>cet utilisateur du système d'exploitation est autorisé à se connecter
    en tant que cet utilisateur de la base de données</quote>, plutôt que
   supposer qu'ils sont équivalents. La connexion sera autorisée s'il existe
   une entrée dans la carte qui correspond au nom d'utilisateur obtenu à partir
   du système d'authentification externe pour le nom de l'utilisateur de la base
   de données que l'utilisateur a indiqué.
  </para>

  <para>
   Si le champ <replaceable>system-username</replaceable> commence avec un
   slash (<literal>/</literal>), le reste du champ est traité comme une
   expression rationnelle. (Voir <xref linkend="posix-syntax-details"/> pour les
   détails de la syntaxe des expressions rationnelles avec
   <productname>PostgreSQL</productname>.). L'expression rationnelle peut inclure une copie
   (sous-expression entre parenthèses), qui peut ensuite être référencée dans
   le champ <replaceable>database-username</replaceable> avec le joker
   <literal>\1</literal> (antislash-un). Ceci permet la correspondance de
   plusieurs noms d'utilisateurs sur une seule ligne, ce qui est particulièrement
   utile pour les substitutions simples. Par exemple, ces entrées
   <programlisting>
mymap   /^(.*)@mydomain\.com$      \1
mymap   /^(.*)@otherdomain\.com$   guest
   </programlisting>
   supprimeront la partie domaine pour les utilisateurs de système d'exploitation
   dont le nom finissent avec <literal>@mydomain.com</literal>, et permettront aux
   utilisateurs dont le nom se termine avec <literal>@otherdomain.com</literal> de
   se connecter en tant que <literal>guest</literal>.
  </para>

  <tip>
   <para>
    Gardez en tête que, par défaut, une expression rationnelle peut correspondre
    à une petite partie d'une chaîne. Il est généralement conseillé d'utiliser
    les jokers <literal>^</literal> et <literal>$</literal>, comme indiqué dans
    l'exemple ci-dessus, pour forcer une correspondance sur le nom entier de
    l'utilisateur du système d'exploitation.
   </para>
  </tip>

  <para>
   Le fichier <filename>pg_ident.conf</filename> est lu au démarrage et
   quand le processus principal du serveur reçoit un signal
   <systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm>.
   Si vous éditez le fichier sur un système en cours d'utilisation, vous devez
   notifier le postmaster (en utilisant<literal>pg_ctl reload</literal>, en
   appelant la fonction SQL <function>pg_reload_conf()</function>, ou
   <literal>kill -HUP</literal>) pour lui faire relire le fichier.
  </para>

  <para>
   Un fichier <filename>pg_ident.conf</filename> qui pourrait être utilisé
   avec le fichier <filename>pg_hba.conf</filename> de
   <xref linkend="example-pg-hba.conf"/> est montré en
   <xref linkend="example-pg-ident.conf"/>. Dans cet exemple,
   toute personne connectée sur une machine du réseau 192.168 qui n'a pas
   le nom d'utilisateur du système d'exploitation <literal>bryanh</literal>, <literal>ann</literal>,
   ou <literal>robert</literal> verrait son accès refusé. L'utilisateur Unix
   <literal>robert</literal> ne verrait son accès autorisé que lorsqu'il essaie
   de se connecter en tant qu'utilisateur <productname>PostgreSQL</productname>
   <literal>bob</literal>, pas en tant que <literal>robert</literal> ou
   qui que ce soit d'autre. <literal>ann</literal> ne serait autorisée à se connecter
   qu'en tant que <literal>ann</literal>. L'utilisateur <literal>bryanh</literal>
   aurait le droit de se connecter soit en tant que <literal>bryanh</literal>,
   soit en tant que <literal>guest1</literal>.
  </para>

  <example id="example-pg-ident.conf">
   <title>Un exemple de fichier <filename>pg_ident.conf</filename></title>
   <programlisting>
# MAPNAME     SYSTEM-USERNAME   PG-USERNAME

omicron       bryanh            bryanh
omicron       ann               ann
# bob has user name robert on these machines
omicron       robert            bob
# bryanh can also connect as guest1
omicron       bryanh            guest1
   </programlisting>
  </example>
 </sect1>

 <sect1 id="auth-methods">
  <title>Méthodes d'authentification</title>
  <para>
   <productname>PostgreSQL</productname> fournit différentes méthodes pour
   l'authentification des utilisateurs&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      <link linkend="auth-trust">Authentification Trust</link>, qui fait
      confiance aux utilisateurs à l'identification connue.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-password">Authentification Password</link>, qui
      réclame un mot de passe aux utilisateurs.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="gssapi-auth">Authentification GSSAPI</link>, qui se base
      sur une bibliothèque de sécurité compatible GSSAPI. C'est typiquement
      utilisé pour accéder à un serveur d'authentification tel que Kerberos ou
      Microsoft Active Directory server.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="sspi-auth">Authentification SSPI</link>, qui utilise un
      protocole spécifique Windows similaire à GSSAPI.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-ident">Authentification Ident</link>, qui se base
      sur le service <quote>Identification Protocol</quote> (RFC 1413) de
      la machine cliente. (Pour des connexions locales par socket Unix,
      ceci est traité comme une authentification peer.)
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-peer">Authentification Peer</link>, qui se base
      sur les capacités du système d'exploitation pour identifier le processus
      à l'autre bout d'une connexion locale. Ceci n'est pas supporté pour
      les connexions distantes.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-ldap">Authentification LDAP</link>, qui se base sur
      un serveur d'authentification LDAP.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-radius">Authentification RADIUS</link>,
      un serveur d'authentification RADIUS.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-cert">Authentification Certificate</link>, qui
      nécessite une connexion SSL et authentifie les utilisateurs en vérifiant
      le certificat SSL qu'ils envoient.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-pam">Authentification PAM</link>, qui se base sur
      la bibliothèque PAM (Pluggable Authentication Modules).
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-bsd">Authentification BSD</link>, qui se base sur
      le système d'authentification BSD (actuellement seulement disponible sur
      OpenBSD).
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   L'authentification peer est recommandable généralement pour les connexions
   locales, même si l'authentification trust pourrait être suffisante dans
   certains contextes. L'authentification password est le choix le plus simple
   pour les connexions distantes. Toutes les autres options nécessitent une
   forme d'infrastructure de sécurité externe (habituellement un serveur
   d'authentification ou une autorité de certificat pour créer des certificats
   SSL) ou sont spécifiques à la plateforme.
  </para>

  <para>
   Les sections suivantes décrivent chacune des méthodes d'authentification en
   détail.
  </para>
 </sect1>

 <sect1 id="auth-trust">
  <title>Authentification trust</title>

  <para>
   Quand l'authentification <literal>trust</literal> est utilisée,
   <productname>PostgreSQL</productname> considère que quiconque peut se
   connecter au serveur est autorisé à accéder à la base de données quel que
   soit le nom d'utilisateur de bases de données qu'il fournit (même les noms
   des super-utilisateurs). Les restrictions apportées dans les
   colonnes <literal>database</literal> et <literal>user</literal>
   continuent évidemment de s'appliquer. Cette méthode ne doit être utilisée
   que si le système assure un contrôle adéquat des connexions au serveur.
  </para>

  <para>
   L'authentification <literal>trust</literal> est appropriée et très pratique
   pour les connexions locales sur une station de travail mono-utilisateur. Elle
   n'est généralement <emphasis>pas</emphasis> appropriée en soi sur une machine
   multi-utilisateur. Cependant, <literal>trust</literal> peut tout de même
   être utilisé sur une machine multi-utilisateur, si l'accès au fichier
   socket de domaine Unix est restreint par les permissions du système de
   fichiers. Pour ce faire, on peut positionner les paramètres de configuration
   <varname>unix_socket_permissions</varname> (et au besoin
   <varname>unix_socket_group</varname>) comme cela est décrit dans la
   <xref linkend="runtime-config-connection"/>.
   On peut également positionner le paramètre de configuration
   <varname>unix_socket_directories</varname> pour placer le fichier de socket
   dans un répertoire à l'accès convenablement restreint.
  </para>

  <para>
   Le réglage des droits du système de fichiers n'a d'intérêt que le cas de
   connexions par les sockets Unix. Les droits du système de fichiers ne
   restreignent pas les connexions TCP/IP locales. Ainsi, pour utiliser les
   droits du système de
   fichiers pour assurer la sécurité locale, il faut supprimer la ligne
   <literal>host ...127.0.0.1 ...</literal> de
   <filename>pg_hba.conf</filename> ou la modifier pour utiliser une méthode
   d'authentification différente de <literal>trust</literal>.
  </para>

  <para>
   L'authentification <literal>trust</literal> n'est envisageable, pour les
   connexions TCP/IP, que si chaque utilisateur de chaque machine autorisée
   à se connecter au serveur par les lignes <literal>trust</literal> du
   fichier <filename>pg_hba.conf</filename> est digne de confiance. Il est
   rarement raisonnable d'utiliser <literal>trust</literal> pour les
   connexions autres que celles issues de
   <systemitem>localhost</systemitem> (127.0.0.1).
  </para>

 </sect1>

 <sect1 id="auth-password"> <title>Authentification par mot de passe</title>

  <indexterm>
   <primary>MD5</primary>
  </indexterm>
  <indexterm>
   <primary>SCRAM</primary>
  </indexterm>
  <indexterm>
   <primary>password</primary>
   <secondary>authentification</secondary>
  </indexterm>
  <indexterm>
   <primary>mot de passe</primary>
   <secondary>authentification</secondary>
  </indexterm>

  <para>
   Il existe plusieurs méthodes d'authentification basées sur un mot de passe.
   Ces méthodes opèrent de façon similaire mais diffèrent sur la façon dont les
   mots de passe des utilisateurs sont enregistrés sur le serveur et comment le
   mot de passe fourni par un client est envoyé au serveur.
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>scram-sha-256</literal></term>
    <listitem>
     <para>
      La méthode <literal>scram-sha-256</literal> réalise une
      authentification SCRAM-SHA-256, tel qu'elle est décrite dans la <ulink
      url="https://tools.ietf.org/html/rfc7677">RFC 7677</ulink>. Il s'agit
      d'un système de question/réponse qui empêche la récupération du mot de
      passe sur des connexions non sécurisées et supporte l'enregistrement
      des mots de passe sur le serveur avec un hachage cryptographique
      normalement sécurisé.
     </para>

     <para>
      C'est actuellement la méthode interne la plus sécurisée, mais elle
      n'est pas supportée par les anciennes bibliothèques clients.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>md5</literal></term>
    <listitem>
     <para>
      La méthode <literal>md5</literal> utilise un mécanisme de
      question/réponse moins sécurisé. Il empêche la récupération du mot de
      passe et évite d'enregistrer les mots de passe en clair sur le serveur,
      mais ne fournit aucune protection si l'attaquant réussit à voler le mot
      de passe haché du serveur. De plus, l'algorithme de hachage MD5 n'est
      plus considéré de nos jours comme suffisamment sécurisé avec des
      attaques déterminées.
     </para>

     <para>
      La méthode <literal>md5</literal> ne peut pas être utilisé avec la
      fonctionnalité <xref linkend="guc-db-user-namespace"/>.
     </para>

     <para>
      Pour faciliter la transition de la méthode <literal>md5</literal> à la
      méthode SCRAM, si <literal>md5</literal> est indiqué comme méthode
      d'authentification dans <filename>pg_hba.conf</filename> mais que le
      mot de passe de l'utilisateur sur le serveur est chiffré avec SCRAM
      (voir ci-dessous), l'authentification SCRAM est automatiquement
      utilisée à la place.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>password</literal></term>
    <listitem>
     <para>
      La méthode <literal>password</literal> envoie le mot de passe en clair
      et est de ce fait vulnérable aux attaques de type
      <quote>sniffing</quote>. Elle doit être évitée chaque fois que
      possible. Si la connexion est protégée par le chiffrage SSL, alors
      <literal>password</literal> peut être utilisé de façon sécurisée. (Ceci
      étant dit, l'authentification par certificat SSL serait un meilleur
      choix en cas d'utilisation de SSL).
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Les mots de passe <productname>PostgreSQL</productname> sont distincts des
   mots de passe du système d'exploitation. Le mot de passe de chaque
   utilisateur est enregistré dans le catalogue système
   <literal>pg_authid</literal>. Ils peuvent être gérés avec les commandes
   SQL <xref linkend="sql-createrole"/> et <xref linkend="sql-alterrole"/>.
   Ainsi, par exemple, <userinput>CREATE ROLE foo WITH LOGIN PASSWORD
    'secret';</userinput> ou la méta-commande <literal>\password</literal> de
   <application>psql</application>. Si aucun mot de passe n'est enregistré
   pour un utilisateur, le mot de passe enregistré est nul et
   l'authentification par mot de passe échoue systématiquement pour cet
   utilisateur.
  </para>

  <para>
   La disponibilité des différentes méthodes d'authentification basées sur
   des mots de passe dépend de comment un mot de passe utilisateur est
   chiffré sur le serveur (ou haché pour être plus précis). Ceci est contrôlé
   par le paramètre de configuration <xref
   linkend="guc-password-encryption"/> au moment où le mot de passe est
   configuré. Si un mot de passe est chiffré en utilisant le paramètre
   <literal>scram- sha-256</literal>, alors il peut être utilisé par les
   méthodes d'authentification <literal>scram-sha-256</literal> et
   <literal>password</literal> (mais la transmission du mot de passe sera en
   clair dans ce dernier cas). La méthode d'authentification
   <literal>md5</literal> sera automatiquement basculée vers la méthode
   <literal>scram-sha-256</literal> dans ce cas, comme expliqué ci-dessus,
   donc cela fonctionnera aussi. Si un mot de passe était chiffré en
   utilisant la configuration <literal>md5</literal>, alors il peut seulement
   être utilisé pour les méthodes d'authentification <literal>md5</literal>
   et <literal>password</literal> (de nouveau, avec le mot de passe transmis
   en clair dans ce dernier cas). (Les anciennes versions de PostgreSQL
   supportaient le stockage en clair du mot de passe sur le serveur. Ceci
   n'est plus possible.) Pour vérifier les hachages de mot de passe
   actuellement enregistrés, voir le catalogue système
   <literal>pg_authid</literal>.
  </para>

  <para>
   Pour mettre à jour une installation existante de <literal>md5</literal>
   vers <literal>scram-sha-256</literal>, après s'être assuré que toutes les
   bibliothèques courantes sont suffisamment récentes pour supporter SCRAM,
   configurez <literal>password_encryption = 'scram-sha-256'</literal> dans
   <filename>postgresql.conf</filename>, demandez à chaque utilisateur de
   configurer un nouveau mot de passe, et modifiez la méthode
   d'authentification dans <filename>pg_hba.conf</filename> avec
   <literal>scram-sha-256</literal>.
  </para>
 </sect1>

 <sect1 id="gssapi-auth">
  <title>Authentification GSSAPI</title>

  <indexterm zone="gssapi-auth">
   <primary>GSSAPI</primary>
  </indexterm>

  <para>
   <productname>GSSAPI</productname> est un protocole du standard de
   l'industrie pour l'authentification sécurisée définie dans RFC 2743.

   <productname>PostgreSQL</productname>
   supporte <productname>GSSAPI</productname> pour l'utilisation de soit une
   couche d'authentification, chiffrée, soit uniquement une authentification.
   <productname>GSSAPI</productname> fournit une authentification automatique
   (single sign-on) pour les systèmes qui le supportent.  L'authentification
   elle-même est sécurisée. Si le chiffrement  <productname>GSSAPI</productname>
   (voir <literal>hostgssenc</literal>) ou le chiffrement <acronym>SSL</acronym>
   sont utilisés, les données envoyées au travers de la connexion à la base de
   données seront chiffrées, sinon elles ne le seront pas.
  </para>

  <para>
   Le support de GSSAPI doit être activé quand
   <productname>PostgreSQL</productname> est compilé&nbsp;; voir
   <xref linkend="installation"/> pour plus d'informations.
  </para>

  <para>
   Quand <productname>GSSAPI</productname> passe par
   <productname>Kerberos</productname>, il utilise un service principal standard
   au format
   <literal><replaceable>nom_service</replaceable>/<replaceable>nom_hôte</replaceable>@<replaceable>domaine</replaceable></literal>.
   Le serveur PostgreSQL acceptera n'importe quel service principal inclus dans le
   fichier de clés utilisé par le serveur, mais il est nécessaire de faire attention de
   spécifier les détails du bon service principal quand une connexion est effectuée
   depuis le client utilisant le paramètre de connexion
   <literal>krbsrvname</literal>.  (Voir aussi <xref linkend="libpq-paramkeywords"/>.)
   La valeur par défaut à l'installation, <literal>postgres</literal>,
   peut être changée lors de la compilation en utilisant
   <literal>./configure --with-krb-srvnam=</literal><replaceable>autrechose</replaceable>.
   Dans la plupart des environnements, ce paramètre n'a jamais besoin d'être
   changé.  Quelques implémentations de Kerberos peuvent nécessiter un nom de
   service différent, par exemple Microsoft Active Directory qui réclame que
   le nom de service soit en majuscule (<literal>POSTGRES</literal>).
  </para>
  <para>
   <replaceable>nom_hôte</replaceable> est le nom d'hôte pleinement qualifié
   (<foreignphrase>fully qualified host name</foreignphrase>)
   de la machine serveur.  Le domaine du service principal est le domaine
   préféré du serveur.
  </para>

  <para>
   Les principals du client peuvent être mis en correspondance avec
   différents noms d'utilisateurs <productname>PostgreSQL</productname> grâce
   au fichier de configuration <filename>pg_ident.conf</filename>. Par
   exemple, <literal>pgusername@realm</literal> pourrait correspondre à
   <literal>pgusername</literal>. De la même façon, vous pouvez utiliser le
   principal complet <literal>username@realm</literal> comme nom de rôle dans
   <productname>PostgreSQL</productname> sans aucune correspondance.
  </para>

  <para>
   <productname>PostgreSQL</productname> supporte aussi un paramètre pour
   supprimer le royaume du principal. Cette méthode est supportée pour des
   raisons de compatibilité ascendante et est fortement déconseillé car il
   est ensuite impossible de distinguer différents utilisateurs avec le même
   nom d'utilisateur mais un domaine différent. Pour l'activer, configurez
   <literal>include_realm</literal> à 0. Pour des installations simples à un
   seul royaume, le faire en combinant avec la configuration du paramètre
   <literal>krb_realm</literal> (qui vérifie que le royaume du principal
   correspond exactement à ce qui est dans le paramètre
   <literal>krb_realm</literal>) est toujours sécurisé mais cette approche
   offre moins de possibilités en comparaison à la spécification d'une
   correspondance explicite.
  </para>

  <para>
   Le fichier de clés du serveur doit être lisible (et de préférence
   uniquement lisible, donc sans écriture possible) par le compte serveur
   <productname>PostgreSQL</productname> (voir aussi la
   <xref linkend="postgres-user"/>).  L'emplacement du fichier de clés est
   indiqué grâce au paramètre de configuration
   <xref linkend="guc-krb-server-keyfile"/>. La valeur par défaut est
   <filename>/usr/local/pgsql/etc/krb5.keytab</filename> (ou tout autre
   répertoire indiqué comme <varname>sysconfdir</varname> lors de la
   compilation).  Pour des raisons de sécurité, il est recommandé d'utiliser un
   fichier de clés séparé pour <productname>PostgreSQL</productname>
   uniquement plutôt que d'ouvrir les droits sur le fichier de clés du
   système.
  </para>
  <para>
   Le fichier de clés est généré pour le logiciel Kerberos&nbsp;; voir la
   documentation de Kerberos pour plus de détails.  L'exemple suivant est
   valable pour des implémentations de Kerberos 5 compatible MIT&nbsp;:
   <screen>
<prompt>kadmin% </prompt><userinput>ank -randkey postgres/server.my.domain.org</userinput>
<prompt>kadmin% </prompt><userinput>ktadd -k krb5.keytab postgres/server.my.domain.org</userinput>
   </screen>
  </para>

  <para>
   Lors de la connexion à la base de données, il faut s'assurer de posséder
   un ticket pour le service principal correspondant au nom d'utilisateur de base
   de données souhaité. Par exemple, pour le nom d'utilisateur PostgreSQL
   <literal>fred</literal>, le service principal <literal>fred@EXAMPLE.COM</literal>
   pourrait se connecter. Pour autoriser aussi le service principal
   <literal>fred/users.example.com@EXAMPLE.COM</literal>, il faut utiliser une
   correspondance de nom d'utilisateur, comme décrit dans <xref
   linkend="auth-username-maps"/>.
  </para>

  <para>
   Le support de GSSAPI doit être activé lors de la construction de
   <productname>PostgreSQL</productname>&nbsp;; voir
   <xref linkend="installation"/> pour plus d'informations.
  </para>

  <para>
   Les options de configuration suivantes sont supportées pour
   <productname>GSSAPI</productname>&nbsp;:
   <variablelist>
    <varlistentry>
     <term><literal>include_realm</literal></term>
     <listitem>
      <para>
       Si configuré à 0, le nom du royaume provenant du principal de
       l'utilisateur authentifié est supprimé avant d'être passé à la
       correspondance du nom d'utilisateur (<xref
       linkend="auth-username-maps"/>). Ceci n'est pas conseillé mais reste
       disponible principalement pour des raisons de compatibilité ascendante
       car ce n'est pas sûr dans des environnements avec plusieurs royaumes
       sauf si <literal>krb_realm</literal> est aussi utilisé. Il est
       recommandé de laisser <literal>include_realm</literal> configurer à sa
       valeur par défaut et de fournir une correspondance explicite dans
       <filename>pg_ident.conf</filename> pour convertir les noms de principaux
       en noms d'utilisateurs <productname>PostgreSQL</productname>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>compat_realm</literal></term>
     <listitem>
      <para>
       Si configuré à 1, le nom, compatible SAM, du domaine (aussi connu en
       tant que nom NetBIOS) est utilisé pour l'option
       <literal>include_realm</literal>. C'est la valeur par défaut. Si
       configuré à 0, le vrai nom de royaume provenant de nom du principal
       Kerberos est utilisé.
      </para>
      <para>
       Ne désactivez pas cette option sauf si votre serveur est exécuté sous
       un compte domaine (ceci inclut les comptes de service virtuels sur un
       système membre du domaine) et si tous les clients s'authentifiant via
       SSPI utilisent aussi des comptes domaines. Dans le cas contraire,
       l'authentification va échouer.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>upn_username</literal></term>
     <listitem>
      <para>
       Si cette option est activée avec <literal>compat_realm</literal>, le
       nom de l'utilisateur provenant du UPN Kerberos est utilisé pour
       l'authentification. Si elle est désactivée (par défaut), le nom
       d'utilisateur provenant de l'UPN Kerberos est utilisé pour
       l'authentification. Si elle est désactivée (par défaut), le nom
       d'utilisateur compatible SAM est utilisé. Par défaut, ces deux noms
       sont identiques pour les nouveaux comptes utilisateurs.
      </para>
      <para>
       Notez que <application>libpq</application> utilise le nom compatible SAM
       si aucun nom d'utilisateur explicite n'est spécifié. Si vous utilisez la
       <application>libpq</application> ou un connecteur basé sur cette
       bibliothèque, vous devriez laisser cette option désactivée ou indiquer
       explicitement le nom d'utilisateur dans la chaîne de connexion.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>map</literal></term>
     <listitem>
      <para>
       Permet la mise en correspondance entre les noms système et base de
       données. Voir <xref linkend="auth-username-maps"/> pour plus de détails.
       Pour un principal GSSAPI/Kerberos, tel que
       <literal>username@EXAMPLE.COM</literal> (ou, moins communément,
       <literal>username/hostbased@EXAMPLE.COM</literal>), le nom d'utilisateur
       utilisé pour la correspondance est
       <literal>username@EXAMPLE.COM</literal> (ou
       <literal>username/hostbased@EXAMPLE.COM</literal>, respectivement),
       sauf si <literal>include_realm</literal> a été configuré à 0, auquel
       cas <literal>username</literal> (ou
       <literal>username/hostbased</literal>) est ce qui est vu comme le nom
       d'utilisateur du système lors de la recherche de correspondance.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>krb_realm</literal></term>
     <listitem>
      <para>
       Configure le domaine pour la correspondance du principal de l'utilisateur.
       Si ce paramètre est configuré, seuls les utilisateurs de ce domaine
       seront acceptés. S'il n'est pas configuré, les utilisateurs de tout
       domaine peuvent se connecter, à condition que la correspondance du nom
       de l'utilisateur est faite.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

 </sect1>

 <sect1 id="sspi-auth">
  <title>Authentification SSPI</title>

  <indexterm zone="sspi-auth">
   <primary>SSPI</primary>
  </indexterm>

  <para>
   <productname>SSPI</productname> est une technologie
   <productname>Windows</productname> pour l'authentification sécurisée avec
   <foreignphrase>single sign-on</foreignphrase>.
   <productname>PostgreSQL</productname> utilise SSPI dans un mode de
   négociation (<literal>negotiate</literal>) qui utilise
   <productname>Kerberos</productname> si possible et
   <productname>NTLM</productname> sinon. L'authentification
   <productname>SSPI</productname> ne fonctionne que lorsque serveur et
   client utilisent <productname>Windows</productname> ou, sur les
   autres plateformes, quand <productname>GSSAPI</productname> est
   disponible.
  </para>

  <para>
   Lorsque <productname>Kerberos</productname> est utilisé,
   <productname>SSPI</productname> fonctionne de la même façon que
   <productname>GSSAPI</productname>.
   Voir <xref linkend="gssapi-auth"/> pour les détails.
  </para>

  <para>
   Les options de configuration suivantes sont supportées pour
   <productname>SSPI</productname>&nbsp;:
   <variablelist>
    <varlistentry>
     <term><literal>include_realm</literal></term>
     <listitem>
      <para>
       Si configuré à 0, le nom du royaume provenant du principal de
       l'utilisateur authentifié est supprimé avant d'être passé à la
       correspondance du nom d'utilisateur (<xref
       linkend="auth-username-maps"/>). Ceci n'est pas conseillé mais reste
       disponible principalement pour des raisons de compatibilité ascendante
       car ce n'est pas sûr dans des environnements avec plusieurs royaumes
       sauf si <literal>krb_realm</literal> est aussi utilisé. Il est
       recommandé aux utilisateurs de laisser include_realm configuré à sa
       valeur par défaut (1) et de fournir une correspondance explicite dans
       <filename>pg_ident.conf</filename>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>map</literal></term>
     <listitem>
      <para>
       Permet la mise en correspondance entre les noms système et base de
       données. Voir <xref linkend="auth-username-maps"/> pour plus de détails.
       Pour un principal GSSAPI/Kerberos, tel que
       <literal>username@EXAMPLE.COM</literal> (ou, moins communément,
       <literal>username/hostbased@EXAMPLE.COM</literal>), le nom d'utilisateur
       utilisé pour la correspondance est
       <literal>username@EXAMPLE.COM</literal> (ou
       <literal>username/hostbased@EXAMPLE.COM</literal>, respectivement),
       sauf si <literal>include_realm</literal> a été configuré à 0, auquel
       cas <literal>username</literal> (ou
       <literal>username/hostbased</literal>) est ce qui est vu comme le nom
       d'utilisateur du système lors de la recherche de correspondance.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>krb_realm</literal></term>
     <listitem>
      <para>
       Configure le domaine pour la correspondance du principal de l'utilisateur.
       Si ce paramètre est configuré, seuls les utilisateurs de ce domaine
       seront acceptés. S'il n'est pas configuré, les utilisateurs de tout
       domaine peuvent se connecter, à condition que la correspondance du nom
       de l'utilisateur est faite.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

 </sect1>

 <sect1 id="auth-ident"> <title>Authentification fondée sur ident</title>

  <indexterm> <primary>ident</primary> </indexterm>

  <para>
   La méthode d'authentification ident fonctionne en obtenant le nom
   de l'opérateur du système depuis le serveur ident distant et en l'appliquant comme
   nom de l'utilisateur de la base de données (et après une éventuelle mise en
   correspondance). Cette méthode n'est supportée que pour les connexions TCP/IP.
  </para>

  <note>
   <para>
    Lorsqu'ident est spécifié pour une connexion locale (c'est-à-dire
    non TCP/IP), l'authentification peer (voir <xref linkend="auth-peer"/>)
    lui est automatiquement substituée.
   </para>
  </note>

  <para>
   Les options de configuration suivantes sont supportées pour
   <productname>ident</productname>&nbsp;:
   <variablelist>
    <varlistentry>
     <term><literal>map</literal></term>
     <listitem>
      <para>
       Permet la mise en correspondance entre les noms système et base de données.
       Voir <xref linkend="auth-username-maps"/> pour plus de détails.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Le <quote>protocole d'identification</quote> est décrit dans la
   RFC 1413. Théoriquement, chaque système
   d'exploitation de type Unix contient un serveur ident
   qui écoute par défaut sur le port TCP 113. La fonctionnalité basique
   d'un serveur ident est de répondre aux questions telles que&nbsp;:
   <quote>Quel utilisateur a initié la connexion qui sort du port
    <replaceable>X</replaceable> et se connecte à mon port
    <replaceable>Y</replaceable>?</quote>.
   Puisque <productname>PostgreSQL</productname> connaît
   <replaceable>X</replaceable> et <replaceable>Y</replaceable> dès lors
   qu'une connexion physique est établie, il peut interroger le serveur
   ident de l'hôte du client qui se connecte et peut ainsi théoriquement
   déterminer l'utilisateur du système d'exploitation pour n'importe quelle
   connexion.
  </para>

  <para>
   Le revers de cette procédure est qu'elle dépend de l'intégrité du
   client&nbsp;: si la machine cliente est douteuse ou compromise, un attaquant
   peut lancer n'importe quel programme sur le port 113 et retourner un nom
   d'utilisateur de son choix. Cette méthode d'authentification n'est, par
   conséquent, appropriée que dans le cas de réseaux fermés dans lesquels
   chaque machine cliente est soumise à un contrôle strict et dans lesquels
   les administrateurs système et de bases de données opèrent en étroite
   collaboration. En d'autres mots, il faut pouvoir faire confiance à la
   machine hébergeant le serveur d'identification. Cet avertissement doit
   être gardé à l'esprit&nbsp;:
   <blockquote>
    <attribution>RFC 1413</attribution>
    <para>
     Le protocole d'identification n'a pas vocation à être un protocole
     d'autorisation ou de contrôle d'accès.
    </para>
   </blockquote>
  </para>

  <para>
   Certains serveurs ident ont une option non standard qui chiffre le nom de
   l'utilisateur retourné à l'aide d'une clé connue du seul administrateur
   de la machine dont émane la connexion. Cette option <emphasis>ne
    doit pas</emphasis> être employée lorsque le serveur ident est utilisé avec
   <productname>PostgreSQL</productname> car <productname>PostgreSQL</productname>
   n'a aucun moyen de déchiffrer la chaîne renvoyée pour déterminer le nom réel
   de l'utilisateur.
  </para>

 </sect1>

 <sect1 id="auth-peer">
  <title>Authentification Peer</title>

  <indexterm>
   <primary>peer</primary>
  </indexterm>

  <para>
   La méthode d'authentification peer utilise les services du système d'exploitation
   afin d'obtenir le nom de l'opérateur ayant lancé la commande client de connexion
   et l'utilise (après une éventuelle mise en correspondance) comme nom d'utilisateur
   de la base de données. Cette méthode n'est supportée que pour les connexions
   locales.
  </para>

  <para>
   Les options de configuration suivantes sont supportées pour
   l'authentification <productname>peer</productname>&nbsp;:
   <variablelist>
    <varlistentry>
     <term><literal>map</literal></term>
     <listitem>
      <para>
       Autorise la mise en correspondance entre le nom d'utilisateur
       fourni par le système d'exploitation et
       le nom d'utilisateur pour la base de données. Voir
       <xref linkend="auth-username-maps"/> pour plus de détails.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   L'authentification peer n'est disponible que sur les systèmes
   d'exploitation fournissant la fonction <function>getpeereid()</function>,
   le paramètre <symbol>SO_PEERCRED</symbol> pour les sockets ou un
   mécanisme similaire. Actuellement, cela inclut <systemitem
   class="osname">Linux</systemitem>, la plupart des variantes
   <systemitem class="osname">BSD</systemitem> (et donc <systemitem
   class="osname">macOS</systemitem>), ainsi que <systemitem
   class="osname">Solaris</systemitem>.
  </para>
 </sect1>

 <sect1 id="auth-ldap">
  <title>Authentification LDAP</title>

  <indexterm zone="auth-ldap">
   <primary>LDAP</primary>
  </indexterm>

  <para>
   Ce mécanisme d'authentification opère de façon similaire à
   <literal>password</literal> à ceci près qu'il utilise LDAP comme
   méthode de vérification des mots de passe.
   LDAP n'est utilisé que pour valider les paires
   nom d'utilisateur/mot de passe. De ce fait, pour pouvoir utiliser LDAP
   comme méthode d'authentification, l'utilisateur doit préalablement exister
   dans la base.
  </para>

  <para>
   L'authentification LDAP peut opérer en deux modes. Dans le premier mode,
   que nous appelerons le mode « simple bind », le serveur fera un « bind »
   sur le nom distingué comme <replaceable>préfixe</replaceable>
   <replaceable>nom_utilisateur</replaceable> <replaceable>suffixe</replaceable>.
   Typiquement, le paramètre <replaceable>prefix</replaceable> est utilisé pour spécifier
   <literal>cn=</literal> ou <replaceable>DOMAIN</replaceable><literal>\</literal> dans un
   environnement Active Directory. <replaceable>suffix</replaceable> est utilisé pour spécifier le reste
   du DN dans un environnement autre qu'Active Directory.
  </para>

  <para>
   Dans le second mode, que nous appelerons mode « search+bind »,
   le serveur commence un « bind » sur le répertoire
   LDAP avec un nom d'utilisateur et un mot de passe fixés, qu'il indique à
   <replaceable>ldapbinddn</replaceable> et
   <replaceable>ldapbindpasswd</replaceable>. Il réalise une recherche de
   l'utilisateur en essayant de se connecter à la base de données. Si aucun
   utilisateur et aucun mot de passe n'est configuré, un « bind » anonyme
   sera tenté sur le répertoire. La recherche sera réalisée sur le sous-arbre
   sur <replaceable>ldapbasedn</replaceable>, et essaiera une correspondance
   exacte de l'attribut indiqué par
   <replaceable>ldapsearchattribute</replaceable>. Une fois que
   l'utilisateur a été trouvé lors de cette recherche, le serveur se
   déconnecte et effectue un nouveau « bind » au répertoire en tant que
   cet utilisateur, en utilisant le mot de passe indiqué par le client pour
   vérifier que la chaîne de connexion est correcte. Ce mode est identique à
   celui utilisé par les schémas d'authentification LDAP dans les autres
   logiciels, tels que les modules Apache <literal>mod_authnz_ldap</literal>
   et <literal>pam_ldap</literal>. Cette méthode permet une plus grande
   flexibilité sur l'emplacement des objets utilisateurs dans le répertoire
   mais demandera deux connexions au serveur LDAP.
  </para>

  <para>
   Les options de configuration suivantes sont utilisées dans les deux modes&nbsp;:
   <variablelist>
    <varlistentry>
     <term><literal>ldapserver</literal></term>
     <listitem>
      <para>
       Noms ou adresses IP des serveurs LDAP auxquels se connecter.
       Plusieurs serveurs peuvent être indiqués, en les séparant par
       des espaces.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>ldapport</literal></term>
     <listitem>
      <para>
       Numéro de port du serveur LDAP auquel se connecter. Si aucun port
       n'est spécifié, le port par défaut de la bibliothèque LDAP sera utilisé.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>ldapscheme</literal></term>
     <listitem>
      <para>
       Positionner à <literal>ldaps</literal> pour utiliser LDAPS.  Il s'agit
       d'une utilisation non standard de LDAP sur SSL, supportée par certaines
       implémentations de serveurs LDAP.  Voir aussi l'option
       <literal>ldaptls</literal> pour une méthode alternative.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>ldaptls</literal></term>
     <listitem>
      <para>
       Positionnez à 1 pour que la connexion entre PostgreSQL et le serveur
       LDAP utilise du chiffrage TLS. Ceci utilise l'opération <literal>StartTLS</literal>
       d'après la RFC 4513. Voir aussi l'option <literal>ldapscheme</literal>
       pour une alternative.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Veuillez noter que l'utilisation de <literal>ldapscheme</literal> ou de
   <literal>ldaptls</literal> ne chiffre que le trafic entre le serveur
   PostgreSQL et le serveur LDAP. La connexion entre le serveur PostgreSQL et
   le client PostgreSQL ne sera pas pour autant chiffée, à moins que SSL ne
   soit également utilisé pour la connexion.
  </para>

  <para>
   Les options suivantes sont utilisées uniquement dans le mode « simple
   bind »&nbsp;:
   <variablelist>
    <varlistentry>
     <term><literal>ldapprefix</literal></term>
     <listitem>
      <para>
       Chaîne à préfixer au nom de l'utilisateur pour former le DN utilisé
       comme lien lors d'une simple authentification
       <foreignphrase>bind</foreignphrase>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>ldapsuffix</literal></term>
     <listitem>
      <para>
       Chaîne à suffixer au nom de l'utilisateur pour former le DN utilisé
       comme lien lors d'une simple authentification
       <foreignphrase>bind</foreignphrase>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Les options suivantes sont utilisées uniquement dans le mode «
   search+bind »&nbsp;:
   <variablelist>
    <varlistentry>
     <term><literal>ldapbasedn</literal></term>
     <listitem>
      <para>
       Racine DN pour commencer la recherche de l'utilisateur lors d'une
       authentification <foreignphrase>search+bind</foreignphrase>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>ldapbinddn</literal></term>
     <listitem>
      <para>
       DN de l'utilisateur pour se lier au répertoire avec lequel effectuer
       la recherche lors d'une authentification
       <foreignphrase>search+bind</foreignphrase>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>ldapbindpasswd</literal></term>
     <listitem>
      <para>
       Mot de passe de l'utilisateur pour se lier au répertoire avec lequel
       effectuer la recherche lors d'une authentification
       <foreignphrase>search+bind</foreignphrase>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>ldapsearchattribute</literal></term>
     <listitem>
      <para>
       Attribut à faire correspondre au nom d'utilisateur dans la recherche
       lors d'une authentification <foreignphrase>search+bind</foreignphrase>.
       Si aucun attribut n'est indiqué, l'attribut <literal>uid</literal>
       sera utilisé.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>ldapsearchfilter</literal></term>
     <listitem>
      <para>
       Le filtre de recherche à utiliser lors d'une authentification
       search+bind.  Toutes les occurences de <literal>$username</literal>
       seront remplacées par le nom d'utilisateur.  Cela permet des filtres de
       recherche plus flexibles que <literal>ldapsearchattribute</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>ldapurl</literal></term>
     <listitem>
      <para>
       Une URL LDAP dont le format est spécifié par la RFC 4516. C'est une
       autre façon d'écrire certaines options LDAP d'une façon plus compacte
       et standard. Le format est&nbsp;:
       <synopsis>
ldap[s]://<replaceable>hote</replaceable>[:<replaceable>port</replaceable>]/<replaceable>basedn</replaceable>[?[<replaceable>attribut</replaceable>][?[<replaceable>scope</replaceable>][?[<replaceable>filtre</replaceable>]]]]
       </synopsis>
       <replaceable>scope</replaceable> doit faire partie des possibilités
       suivantes&nbsp;: <literal>base</literal>, <literal>one</literal>,
       <literal>sub</literal>. Ce sera généralement la dernière possibilité.
       (La valeur par défaut est <literal>base</literal>, qui n'est
       généralement pas utile dans ce cadre là.)
       <replaceable>attribute</replaceable> peut désigner un unique attribut,
       auquel cas il sera utilisé comme valeur pour
       <literal>ldapsearchattribute</literal>.  Si
       <replaceable>attribute</replaceable> est vide, alors
       <replaceable>filter</replaceable> peut être utilisé comme valeur pour
       <literal>ldapsearchfilter</literal>.
      </para>

      <para>
       Le schéma d'URL <literal>ldaps</literal> choisit la méthode LDAPS pour
       établir une connexion LDAP sur SSL, qui est équivalent à l'utilisation
       de <literal>ldapscheme=ldaps</literal>.  Pour utiliser une connexion
       LDAP chiffrée en utilisant l'opération <literal>StartTLS</literal>,
       utilisez le schéma d'URL normal <literal>ldap</literal> et spécifiez
       l'option <literal>ldaptls</literal> en plus de
       <literal>ldapurl</literal>.
      </para>

      <para>
       Pour les « bind » non anonymes, <literal>ldapbinddn</literal> et
       <literal>ldapbindpasswd</literal> doivent être spécifiées comme des
       options séparées.
      </para>

      <para>
       Les URL LDAP sont actuellement seulement supportées par
       <productname>OpenLDAP</productname>, et pas sous Windows.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Mixer les options de configurations du mode « simple bind » et du mode
   « search+bind » est une erreur.
  </para>

  <para>
   Lorsque vous utilisez le mode search+bind mode, la recherche peut être
   effectuée en utilisant l'attribut unique spécifié avec
   <literal>ldapsearchattribute</literal>, ou en utilisant un filtre de
   recherche personnalisé avec <literal>ldapsearchfilter</literal>.
   Spécifier <literal>ldapsearchattribute=foo</literal> est équivalent à
   spécifier <literal>ldapsearchfilter="(foo=$username)"</literal>.  Si aucune
   de ces options n'est spécifiée, le comportement par défaut est
   <literal>ldapsearchattribute=uid</literal>.
  </para>

  <para>
   Si <productname>PostgreSQL</productname> a été compilé avec
   <productname>OpenLDAP</productname> comme bibliothèque LDAP cliente,
   l'option de configuration <literal>ldapserver</literal> peut être omise.
   Dans ce cas, une liste de noms d'hôtes et ports sera recherchée via les
   enregistrements RFC 2782 DNS SRV.  Le nom
   <literal>_ldap._tcp.DOMAIN</literal> est recherché, où
   <literal>DOMAIN</literal> est extrait de <literal>ldapbasedn</literal>.
  </para>

  <para>
   Voici un exemple de configuration LDAP pour le mode « simple bind »&nbsp;:
   <programlisting>
host ... ldap ldapserver=ldap.example.net ldapprefix="cn=" ldapsuffix=", dc=example, dc=net"
   </programlisting>
   Quand une connexion au serveur de base de données est demandée en tant que
   <literal>un_utilisateur</literal>, PostgreSQL tentera un « bind » vers le
   serveur LDAP en utilisant le DN <literal>cn=un_utilisateur, dc=example,
    dc=net</literal> et le mot de passe fourni par le client. Si cette connexion
   réussit, l'accès à la base de données est accepté.
  </para>

  <para>
   Voici un exemple de configuration LDAP pour le mode « search+bind »&nbsp;:
   <programlisting>
host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchattribute=uid
   </programlisting>
   Quand une connexion au serveur de base de données est tentée en tant que
   <literal>un_utilisateur</literal>, PostgreSQL tentera un « bind » anonyme
   (car <literal>ldapbinddn</literal> n'a pas été précisé) au serveur LDAP,
   effectuera une recherche pour <literal>(uid=un_utilisateur)</literal> sous
   le DN de base spécifié. Si une entrée est trouvée, il tentera alors de faire un
   « bind » en utilisant l'information trouvée et le mot de passe fourni par le
   client. Si cette deuxième connexion réussit, l'accès à la base est autorisé.
  </para>

  <para>
   Voici la même configuration « search+bind » écrite sous la forme d'une
   URL&nbsp;:
   <programlisting>
host ... ldap ldapurl="ldap://ldap.example.net/dc=example,dc=net?uid?sub"
   </programlisting>
   D'autres logiciels qui supportent l'authentification LDAP utilisent le
   même format d'URL donc cela facilitera le partage de configuration.
  </para>

  <para>
   Voici un exemple de configuration search+bind configuration qui utilise
   <literal>ldapsearchfilter</literal> plutôt que
   <literal>ldapsearchattribute</literal> pour permettre l'authentification
   par nom d'utilisateur ou adresse mail&nbsp;:
   <programlisting>
host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchfilter="(|(uid=$username)(mail=$username))"
   </programlisting>
  </para>

  <para>
   Voici un exemple de configuration search+bind qui utilise la découverte DNS
   SRV pour trouver le(s) nom(s) d'hôte et port(s) pour le service LDAP pour
   le nom de domaine <literal>example.net</literal>&nbsp;:
   <programlisting>
host ... ldap ldapbasedn="dc=example,dc=net"
   </programlisting>
  </para>

  <tip>
   <para>
    Comme LDAP utilise souvent des virgules et des espaces pour séparer
    les différentes parties d'un DN, il est souvent nécessaire d'utiliser
    des paramètres entourés de guillemets durant le paramétrage des options
    LDAP, comme montré dans les exemples.
   </para>
  </tip>

 </sect1>

 <sect1 id="auth-radius">
  <title>Authentification RADIUS</title>

  <indexterm zone="auth-radius">
   <primary>RADIUS</primary>
  </indexterm>

  <para>
   Cette méthode d'authentification opère de façon similaire à
   <literal>password</literal> sauf qu'il existe la méthode RADIUS pour la
   vérification du mot de passe. RADIUS est seulement utilisé pour valider
   des pairs nom utilisateur / mot de passe. Du coup, l'utilisateur doit déjà
   exister dans la base de données avant que RADIUS puisse être utilisé pour
   l'authentification.
  </para>

  <para>
   Lors de l'utilisation de l'authentification RADIUS, un message de demande
   d'accès (<foreignphrase>Access Request</foreignphrase>) sera envoyé au
   serveur RADIUS configuré. Cette demande sera du type
   <quote>authentification seule</quote> (<literal>Authenticate
    Only</literal>) et incluera les paramètres pour le nom de l'utilisateur,
   son mot de passe (chiffré) et un identifiant NAS (<literal>NAS
    Identifier</literal>). La demande sera chiffrée en utilisant un secret
   partagé avec le serveur. Le serveur RADIUS répond à cette demande avoir
   soit <literal>Access Accept</literal> soit <literal>Access
    Reject</literal>. Il n'y a pas de support des comptes RADIUS.
  </para>

  <para>
   Plusieurs serveurs RADIUS peuvent être spécifiés, auquel cas ils seront
   testés de manière séquentielle. Si une réponse négative est reçue d'un
   serveur, l'authentification échouera. Si aucune réponse n'est reçue, le
   serveur qui suit dans la liste sera essayé. Pour spécifier plusieurs
   serveurs, séparez les noms de serveurs par des virgules et placez la liste
   entre guillemets double. Si plusieurs serveurs sont spécifiés, toutes les
   autres options RADIUS peuvent également être indiquées en tant que liste
   séparée par des virgules, pour s'appliquer individuellement à chaque
   serveur. Elles peuvent également être spécifiées indépendemment. Dans ce
   cas, elles seront appliquées à tous les serveurs.
  </para>

  <para>
   Les options de configuration suivantes sont supportées par RADIUS&nbsp;:
   <variablelist>
    <varlistentry>
     <term><literal>radiusservers</literal></term>
     <listitem>
      <para>
       Les noms DNS et/ou adresses IP des serveurs RADIUS pour
       l'authentification. Ce paramètre est requis.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>radiussecrets</literal></term>
     <listitem>
      <para>
       Les secrets partagés utilisés lors de discussions sécurisées avec les
       serveurs RADIUS. Il doit y avoir exactement la même valeur sur le
       serveur PostgreSQL et sur le serveur RADIUS. Il est recommandé
       d'utiliser une chaîne d'au moins 16 caractères. Ce paramètre est
       requis.
       <note>
        <para>
         Le vecteur de chiffrement utilisé sera un chiffrement fort seulement
         si <productname>PostgreSQL</productname> a été compilé avec le
         support d'<productname>OpenSSL</productname>. Dans les autres cas,
         la transmission au serveur RADIUS peut seulement être considérée
         comme caché, et non pas sécurisé, et des mesures de sécurité
         externes doivent être appliquées si nécessaire.
        </para>
       </note>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>radiusports</literal></term>
     <listitem>
      <para>
       Les numéros de port sur les serveurs RADIUS pour la connexion. Si aucun
       port n'est indiqué, le port RADIUS par défaut (<literal>1812</literal>)
       sera utilisé.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>radiusidentifiers</literal></term>
     <listitem>
      <para>
       Les chaînes à utiliser comme identifiants NAS (<literal>NAS
        Identifier</literal>) dans les demandes RADIUS. Ce paramètre peut être
       utilisé, par exemple, pour identifier l'instance auquel l'utilisateur
       tente de se connecter. C'est utilisable pour des vérifications sur les
       serveurs RADIUS. Si aucune identifiant n'est spécifié, la valeur par
       défaut, <literal>postgresql</literal>, sera utilisée.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   S'il est nécessaire d'avoir une virgule ou un espace blanc dans la valeur
   d'un paramètre RADIUS, ceci peut se faire en entourant la valeur de
   guillemets doubles, mais ceci peut devenir compliqué car deux niveaux de
   guillemets doubles sont maintenant nécessaires. Voici un exemple d'espace
   bland dans les chaînes de secret RADIUS&nbsp;:
   <programlisting>
host ... radius radiusservers="server1,server2" radiussecrets="""secret one"",""secret two"""
   </programlisting>
  </para>
 </sect1>

 <sect1 id="auth-cert">
  <title>Authentification de certificat</title>

  <indexterm zone="auth-cert">
   <primary>Certificat</primary>
  </indexterm>

  <para>
   Cette méthode d'authentification utilise des clients SSL pour procéder
   à l'authentification. Elle n'est par conséquent disponible que pour
   les connexions SSL. Quand cette méthode est utilisée, le serveur
   exigera que le client fournisse un certificat valide et de confiance. Aucune invite de saisie
   de mot de passe ne sera envoyée au client. L'attribut <literal>cn</literal>
   (<acronym>Common Name</acronym>) du certificat sera comparé au nom
   d'utilisateur de base de données demandé.
   S'ils correspondent, la connexion sera autorisée. La correspondance des
   noms d'utilisateurs peut être utilisé pour permettre au
   <literal>cn</literal> d'être différent du nom d'utilisateur de la base de
   données.
  </para>

  <para>
   Les options de configuration suivantes sont supportées pour
   l'authentification par certificat SSL&nbsp;:
   <variablelist>
    <varlistentry>
     <term><literal>map</literal></term>
     <listitem>
      <para>
       Permet la correspondance entre les noms d'utilisateur système et les
       noms d'utilisateurs de bases de données. Voir <xref
       linkend="auth-username-maps"/> pour les détails.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Il est redondant d'utiliser l'option <literal>clientcert</literal> avec
   l'authentification <literal>cert</literal> parce que l'authentification
   <literal>cert</literal> est réellement l'authentification
   <literal>trust</literal> avec <literal>clientcert=verify-full</literal>.
  </para>
 </sect1>

 <sect1 id="auth-pam"> <title>Authentification PAM</title>

  <indexterm zone="auth-pam">
   <primary>PAM</primary>
  </indexterm>

  <para>
   Ce mécanisme d'authentification fonctionne de façon similaire à
   <literal>password</literal> à ceci près qu'il utilise PAM (Pluggable
   Authentication Modules) comme méthode d'authentification. Le nom du
   service PAM par défaut est <literal>postgresql</literal>. PAM n'est utilisé
   que pour valider des paires nom utilisateur/mot de passe et en option le
   nom de l'hôte distant connecté ou de l'adresse IP. De ce fait, avant de
   pouvoir utiliser PAM pour l'authentification, l'utilisateur doit
   préalablement exister dans la base de données. Pour plus d'informations sur
   PAM, merci de lire la <ulink
   url="https://www.kernel.org/pub/linux/libs/pam/">page
    <productname>Linux-PAM</productname></ulink>.
  </para>

  <para>
   Les options suivantes sont supportées pour PAM&nbsp;:
   <variablelist>
    <varlistentry>
     <term><literal>pamservice</literal></term>
     <listitem>
      <para>
       Nom de service PAM.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>pam_use_hostname</literal></term>
     <listitem>
      <para>
       Détermine si l'adresse IP ou le nom d'hôte distant est fourni aux
       modules PAM via l'élément <symbol>PAM_RHOST</symbol>. Par défaut,
       l'adresse IP est utilisé. Configurez cette option à 1 pour utiliser
       à la place le nom d'hôte résolu. La résolution de nom d'hôte peut
       amener des délais de connexion. (La plupart des configurations PAM
       n'utilise pas cette information, donc il est seulement nécessaire
       de considérer ce paramètre si une configuration PAM a été créée
       spécifiquement pour l'utiliser.)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <note>
   <para>
    Si PAM est configuré pour lire <filename>/etc/shadow</filename>,
    l'authentification échoue car le serveur PostgreSQL est exécuté en
    tant qu'utilisateur standard. Ce n'est toutefois pas un problème
    quand PAM est configuré pour utiliser LDAP ou les autres méthodes
    d'authentification.
   </para>
  </note>
 </sect1>

 <sect1 id="auth-bsd">
  <title>Authentification BSD</title>

  <indexterm zone="auth-bsd">
   <primary>Authentification BSD</primary>
  </indexterm>

  <para>
   Cette méthode d'authentification opère de façon similaire à
   <literal>password</literal> sauf qu'elle utilise l'authentification BSD
   pour vérifier le mot de passe. L'authentification BSD est seulement
   utilisée pour valider la paire nom d'utilisateur/mot de passe. De ce fait,
   le rôle de l'utilisation doit déjà exister dans la base de données avant
   que l'authentification BSD puisse être utilisée pour l'authentification.
   Cette méthode est actuellement uniquement disponible sur OpenBSD.
  </para>

  <para>
   L'authentification BSD dans <productname>PostgreSQL</productname> utilise
   le type de login <literal>auth-postgresql</literal> et s'authentifie avec
   la classe de login <literal>postgresql</literal> si c'est défini dans
   <filename>login.conf</filename>. Par défaut, cette classe de login n'existe
   pas, et <productname>PostgreSQL</productname> utilisera la classe de login
   par défaut.
  </para>

  <note>
   <para>
    Pour utiliser l'authentification BSD, le compte utilisateur PostgreSQL
    (c'est-à-dire l'utilisateur système qui exécute le serveur) doit d'abord
    être ajouté dans le groupe <literal>auth</literal>. Le groupe
    <literal>auth</literal> existe par défaut sur les systèmes OpenBSD.
   </para>
  </note>
 </sect1>

 <sect1 id="client-authentication-problems"> <title>Problèmes d'authentification</title>

  <para>
   Les erreurs et problèmes d'authentification se manifestent
   généralement par des messages d'erreurs tels que ceux qui suivent.
  </para>

  <para>
   <programlisting>FATAL:  no pg_hba.conf entry for host "123.123.123.123", user "andym", database "testdb"</programlisting>
    ou, en français,
<programlisting>FATAL:  pas d'entrée pg_hba.conf pour l'hôte "123.123.123.123", utilisateur "andym", base "testdb"</programlisting>
    C'est le message le plus probable lorsque le contact peut être établi avec le
    serveur mais qu'il refuse de communiquer. Comme le suggère le message,
    le serveur a refusé la demande de connexion parce qu'il n'a trouvé aucune
    entrée correspondante dans son fichier de configuration
    <filename>pg_hba.conf</filename>.
   </para>

   <para>
<programlisting>FATAL:  password authentication failed for user "andym"</programlisting>
    ou, en français,
<programlisting>FATAL:  l'authentification par mot de passe a échoué pour l'utilisateur "andym"</programlisting>
    Les messages de ce type indiquent que le serveur a été contacté et
    qu'il accepte la communication, mais pas avant que la méthode
    d'authentification indiquée dans le fichier
    <filename>pg_hba.conf</filename> n'ait été franchie avec succès.
    Le mot de passe fourni, le logiciel d'identification ou le logiciel
    Kerberos doivent être vérifiés en fonction du type d'authentification
    mentionné dans le message d'erreur.
   </para>

   <para>
<programlisting>FATAL:  user "andym" does not exist</programlisting>
    ou, en français,
<programlisting>FATAL:  l'utilisateur "andym" n'existe pas</programlisting>
    Le nom d'utilisateur indiqué n'a pas été trouvé.
   </para>

   <para>
<programlisting>FATAL:  database "testdb" does not exist</programlisting>
    ou, en français,
<programlisting>FATAL:  la base "testdb" n'existe pas</programlisting>
    La base de données utilisée pour la tentative de connexion n'existe pas.
    Si aucune base n'est précisée, le nom de la base par défaut est le
    nom de l'utilisateur, ce qui peut être approprié ou non.
   </para>

   <tip>
    <para>
     Les traces du serveur contiennent plus d'informations sur une erreur
     d'authentification que ce qui est rapporté au client. En cas de doute
     sur les raisons d'un échec, il peut s'avérer utile de les consulter.
    </para>
   </tip>

</sect1>

</chapter>
