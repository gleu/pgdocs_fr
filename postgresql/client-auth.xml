<?xml version="1.0" encoding="UTF-8"?>
<chapter id="client-authentication">
<title>Authentification du client</title>

 <indexterm zone="client-authentication">
 <primary>authentification client</primary> </indexterm>

 <para>Quand une application client se connecte au serveur de bases de données,
  elle indique le nom de l'utilisateur de base de données
  à utiliser pour la connexion, de la même façon qu'on se connecte à un ordinateur
  Unix sous un nom d'utilisateur particulier. Au sein de l'environnement SQL, le
  nom d'utilisateur de la base de données active détermine les droits
  régissant l'accès aux objets de la base de données &mdash; voir le
  <xref linkend="user-manag"/> pour plus d'informations. Ainsi, il est essentiel de
  limiter le nombre de bases de données auxquelles les utilisateurs peuvent se
  connecter.</para>

 <note>
  <para>
   Comme expliqué dans le <xref linkend="user-manag"/>,
   <productname>PostgreSQL</productname> gère les droits par l'intermédiaire
   des <quote>rôles</quote>. Dans ce chapitre, le terme 
   <firstterm>utilisateur de bases de données</firstterm> est utilisé pour
   signifier <quote>rôle disposant du droit <literal>LOGIN</literal></quote>.
  </para>
 </note>

 <para>L'<firstterm>authentification</firstterm> est le processus par lequel le
  serveur de bases de données établit l'identité du client et, par extension,
  détermine si l'application client (ou l'utilisateur qui l'utilise) est
  autorisée à se connecter avec le nom d'utilisateur de bases de données
  indiqué.</para>

 <para><productname>PostgreSQL</productname> offre quantité de méthodes
  d'authentification différentes. La méthode utilisée pour authentifier une connexion
  client particulière peut être sélectionnée d'après l'adresse (du client), la base de
  données et l'utilisateur.</para>

 <para>Les noms d'utilisateur de bases de données sont
  séparés de façon logique des noms d'utilisateur du système d'exploitation sur
  lequel tourne le serveur. Si tous les utilisateurs d'un serveur donné ont
  aussi des comptes sur la machine serveur, il peut être pertinent d'attribuer
  aux utilisateurs de bases de données des noms qui correspondent à ceux
  des utilisateurs du système d'exploitation. Cependant, un serveur qui
  accepte des connexions
  distantes peut avoir des utilisateurs de bases de données dépourvus de
  compte correspondant sur le système d'exploitation. Dans ce cas, aucune
  correspondance entre les noms n'est nécessaire.</para>

 <sect1 id="auth-pg-hba-conf"> <title>Le fichier <filename>pg_hba.conf</filename></title>

  <indexterm zone="auth-pg-hba-conf"> <primary>pg_hba.conf</primary>
</indexterm>

  <para>L'authentification du client est contrôlée par un fichier,
   traditionnellement nommé <filename>pg_hba.conf</filename> et situé dans le
   répertoire data du groupe de bases de données, par exemple
   <filename>/usr/local/pgsql/data/pg_hba.conf</filename> (<acronym>HBA</acronym>
   signifie <quote>host-based authentication</quote>&nbsp;: authentification
   fondée sur l'hôte.) Un
   fichier <filename>pg_hba.conf</filename> par défaut est installé lorsque le
   répertoire data est initialisé par <command>initdb</command>. Néanmoins, il
   est possible de placer le fichier de configuration de l'authentification
   ailleurs&nbsp;; voir le paramètre de configuration <xref linkend="guc-hba-file"/>.
  </para>

  <para>
   Le format général du fichier <filename>pg_hba.conf</filename> est un
   ensemble d'enregistrements, un par ligne. Les lignes vides sont ignorées tout
   comme n'importe quel texte placé après le caractère de commentaire
   <literal>#</literal>. Un enregistrement est constitué d'un certain nombre de
   champs séparés par des espace et/ou des tabulations. Les enregistrements
   ne peuvent pas être continués sur plusieurs lignes. Les champs peuvent
   contenir des espaces si la valeur du champ est mise entre guillemets doubles.
   Mettre entre guillemets un des mots-clés dans un champ base de données,
   utilisateur ou adresse (par exemple, <literal>all</literal> ou
   <literal>replication</literal>) fait que le mot perd son interprétation
   spéciale, ou correspond à la base de données, à l'utilisateur ou à l'hôte
   ayant ce nom.
  </para>

  <para>
   Chaque enregistrement précise un type de connexion, une plage
   d'adresses IP (si approprié au type de connexion), un nom de base de données, un
   nom d'utilisateur et la méthode d'authentification à utiliser pour les
   connexions correspondant à ces paramètres. Le premier enregistrement
   qui correspond au type de connexion, à l'adresse client, à la base de données
   demandée et au nom d'utilisateur est utilisé pour effectuer l'authentification.
   Il n'y a pas de suite après une erreur (<quote>fall-through</quote> ou
   <quote>backup</quote>)&nbsp;: si un enregistrement est choisi et que l'authentification
   échoue, les enregistrements suivants ne sont pas considérés. Si aucun
   enregistrement ne correspond, l'accès est refusé.</para>

  <para>Un enregistrement peut avoir l'un des sept formats suivants.
<synopsis>
local      <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
host       <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostssl    <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnossl  <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
host       <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostssl    <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnossl  <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
</synopsis>

   La signification des champs est la suivante&nbsp;: 

   <variablelist>
    <varlistentry> <term><literal>local</literal></term>
     <listitem><para>Cet enregistrement intercepte les tentatives de connexion
     qui utilise les sockets du domaine Unix. Sans enregistrement de ce type, les
     connexions de sockets du domaine Unix ne sont pas autorisées.</para>
     </listitem></varlistentry>

    <varlistentry>
     <term><literal>host</literal></term>
     <listitem>
      <para>
       Cet enregistrement intercepte les tentatives de connexion par TCP/IP.
       Les lignes <literal>host</literal> s'appliquent à toute tentative de
       connexion, <acronym>SSL</acronym> ou non.
      </para>

      <note>
       <para>
        Les connexions TCP/IP ne sont pas autorisées si le serveur
	n'est pas démarré avec la valeur appropriée du paramètre de configuration
	<xref linkend="guc-listen-addresses"/>. En effet, par défaut, le
	serveur n'écoute que les connexions TCP/IP en provenance de
	l'adresse <literal>loopback</literal> locale, <literal>localhost</literal>.
       </para>
      </note>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostssl</literal></term>
     <listitem>
      <para>
       Cet enregistrement intercepte les seules tentatives de connexions par TCP/IP
       qui utilisent le chiffrement <acronym>SSL</acronym>.
      </para>

      <para>
       Pour utiliser cette fonction, le serveur
       doit être compilé avec le support de <acronym>SSL</acronym>. De plus,
       <acronym>SSL</acronym> doit être activé au démarrage du serveur en
       positionnant le paramètre de configuration <xref linkend="guc-ssl"/>
       (voir la <xref linkend="ssl-tcp"/> pour plus d'informations).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostnossl</literal></term>
     <listitem>
      <para>
       Cet enregistrement a un comportement opposé à <literal>hostssl</literal>&nbsp;: il
       n'intercepte que les tentatives de connexion qui n'utilisent pas
       <acronym>SSL</acronym>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>database</replaceable></term>
     <listitem>
      <para>
       Indique les noms des bases de données concernées par l'enregistrement. La 
       valeur <literal>all</literal> indique qu'il concerne toutes les bases
       de données.
       Le terme <literal>sameuser</literal> indique que l'enregistrement
       coïncide si la base de données demandée a le même nom que l'utilisateur
       demandé.
       Le terme <literal>samerole</literal> indique que l'utilisateur demandé doit
       être membre du rôle portant le même nom que la base de données demandée
       (<literal>samegroup</literal> est obsolète bien qu'il soit toujours accepté
       comme écriture alternative de <literal>samerole</literal>.).
       Les super-utilisateurs ne sont pas considérés comme membres d'un rôle dans le
	   cadre de <literal>samerole</literal> à moins qu'ils ne soient explicitement
	   membres du rôle, de manière directe ou indirecte, et non pas juste par ses
	   droits de super-utilisateur.
       La valeur <literal>replication</literal> indique que l'enregistrement
       établit une correspondance si une connexion de réplication est demandée
       (notez que les connexions de réplication ne ciblent pas une base de
       données particulière). Dans tous les autres cas,
       c'est le nom d'une base de données particulière. Plusieurs noms de base de
       données peuvent être fournis en les séparant par des virgules. Un fichier contenant
       des noms de base de données peut être indiqué en faisant précéder le
       nom du fichier de <literal>@</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>user</replaceable></term>
     <listitem>
      <para>
       Indique les utilisateurs de bases de données auxquels cet enregistrement
       correspond. La valeur <literal>all</literal> indique qu'il concerne tous
       les utilisateurs. Dans le cas contraire, il s'agit soit du nom d'un utilisateur
       spécifique de bases de données ou d'un nom de groupe précédé par un
       <literal>+</literal> (il n'existe pas de véritable distinction
       entre les utilisateurs et les groupes dans
       <productname>PostgreSQL</productname>&nbsp;; un <literal>+</literal>
       signifie exactement
       <quote>établit une correspondance pour tous les rôles faisant parti
       directement ou indirectement de ce rôle</quote> alors qu'un nom sans
       <literal>+</literal> établit une correspondance avec ce rôle spécifique).
	   Ainsi, un super-utilisateur n'est considéré comme membre d'un rôle que s'il
	   est explicitement membre du rôle, directement ou indirectement, et non pas
	   juste par ses droits de super-utilisateur.
       Plusieurs noms d'utilisateurs peuvent être fournis en les séparant
       par des virgules. Un fichier contenant des noms d'utilisateurs peut
       être indiqué en faisant précéder le nom du fichier de <literal>@</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>address</replaceable></term>
     <listitem>
      <para>
       Indique l'adresse IP ou la plage d'adresses IP à laquelle correspond
       cet enregistrement. Ce champ peut contenir soit un nom de machine
       (FQDN), soit le suffixe d'un domaine (sous la forme .exemple.com), 
       soit une adresse ou une plage d'adresses IP, soit enfin l'un des mots-clés 
       mentionnés ci-après.
      </para>

      <para>
       Les adresses IP doivent être écrites sous la notation décimale standard avec
       une longueur de masque <acronym>CIDR</acronym>. La longueur du masque indique le nombre de
       bits forts pour lesquels une correspondance doit être trouvée avec l'adresse
       IP du client. Les bits de droite doivent valoir zéro dans l'adresse IP
       indiquée. Il ne doit y avoir aucune espace entre l'adresse IP, le
       <literal>/</literal> et la longueur du masque CIDR.
      </para>

      <para>
       À la place du <replaceable>CIDR-address</replaceable>, vous pouvez
       écrire <literal>samehost</literal> pour correspondre aux adresses IP du
       serveur ou <literal>samenet</literal> pour correspondre à toute adresse
       du sous-réseau auquel le serveur est directement connecté.
      </para>

      <para>
      Une adresse CIDR (<replaceable>CIDR-address</replaceable>) est typiquement
      <literal>172.20.143.89/32</literal> pour un hôte seul,
      <literal>172.20.143.0/24</literal> pour un petit réseau ou
      <literal>10.6.0.0/16</literal> pour un réseau plus grand.
      <literal>0.0.0.0/0</literal> représente toutes les adresses IPv4, et
      <literal>::/0</literal> représente l'ensemble des adresses IPv6.
      Pour n'indiquer qu'un seul hôte, on utilise un masque de 32 pour IPv4 ou 128 pour
      IPv6. Dans une adresse réseau, ne pas oublier les zéros terminaux.
      </para>

      <para>
       Une adresse IP indiquée au format IPv4 coïncide avec les connexions IPv6 
       d'adresse correspondante. Par exemple, <literal>127.0.0.1</literal> correspond
       à l'adresse IPv6 <literal>::ffff:127.0.0.1</literal>. Une entrée donnée au
       format IPv6 correspond uniquement aux connexions IPv6 même si l'adresse
       représentée est dans le domaine IPv4-vers-IPv6. Les adresses au
       format IPv6 sont rejetées si la bibliothèque système C ne supporte pas
       les adresses IPv6.
      </para>

      <para>
       La valeur <literal>all</literal> permet de cibler n'importe quelle adresse IP cliente,
       <literal>samehost</literal> n'importe quelle adresse IP du serveur ou <literal>samenet</literal> pour 
       toute adresse IP faisant partie du même sous-réseau que le serveur.
      </para>

      <para>
       Si un nom d'hôte est renseigné (dans les faits tout ce qui ne correspond pas 
       à une adresse ou une plage d'adresses IP, ni à un mot clé, sera traité 
       comme un nom d'hôte potentiel), ce nom est comparé au résultat d'une
       résolution de nom inverse de l'adresse IP du client (ou une recherche
       DNS inverse si un DNS est utilisé). Les comparaisons de noms d'hôtes
       ne sont pas sensibles à la casse. En cas de correspondance, une nouvelle
       recherche récursive de nom sera lancée afin de déterminer que 
       le nom d'hôte concorde bel et bien avec l'adresse IP du client. L'enregistrement
       n'est validé qu'en cas de concordance entre la résolution inverse et la
       résolution récursive pour l'adresse IP cliente. (Le nom d'hôte fourni dans
       le fichier <filename>pg_hba.conf</filename> doit donc correspondre à 
       au moins l'une des adresses IP fournies par le mécanisme de résolution de
       noms, sinon l'enregistrement ne sera pas pris en considération. Certains
       serveurs de noms réseau permettent d'associer une adresse IP à de multiples
       noms d'hôtes (alias DNS), mais bien souvent le système d'exploitation ne
       retourne qu'un seul nom d'hôte lors de la résolution d'une adresse IP.)
      </para>

      <para>
       Un nom d'hôte débutant par un point (<literal>.</literal>) ciblera le
       suffixe du nom d'hôte du poste client. Du coup, indiquer <literal>.exemple.com</literal>
       correspondra à la machine <literal>foo.exemple.com</literal> (mais pas
       au client <literal>exemple.com</literal>).
      </para>

      <para>
       Lorsque vous spécifiez des noms d'hôtes dans le fichier <filename>pg_hba.conf</filename>, 
       vous devez vous assurer que la résolution de noms soit raisonnablement rapide. 
       À défaut, il peut être avantageux de configurer un serveur-cache local pour 
       effectuer la résolution de noms, tel que <command>nscd</command>.
       Vous pouvez également valider le paramètre de configuration <varname>log_hostname</varname>
       afin de retrouver dans les journaux le nom d'hôte du client au lieu de sa 
       simple adresse IP.
      </para>

      <sidebar>
       <para>
        À différentes occasions, des utilisateurs ont demandé pourquoi les
	demandes d'authentification par noms d'hôtes sont gérées de manière
	aussi complexe&nbsp;: deux requêtes de résolution du nom d'hôte dont
	une résolution inverse qui n'est parfois pas configurée ou peut pointer
	vers un nom d'hôte indésirable. Son but premier réside dans l'efficacité
	de l'authentification&nbsp;: une tentative de connexion nécessite deux résolutions
	de l'adresse du client, et s'il survient un problème de résolution de nom, 
	cela devient le problème de ce client particulier. Une hypothétique implémentation
	alternative ne se basant que sur la seule résolution de nom récursive 
	devrait résoudre tous les noms d'hôte mentionnés dans le fichier
	 <filename>pg_hba.conf</filename> pour chacune des tentatives
	 de connexion au serveur. Ce qui s'avèrerait lent par nature, et dans le
	 cas d'un problème à la résolution d'un nom d'hôte, deviendrait un
	 problème pour tout le monde.
       </para>

       <para>
        De plus, une résolution inverse est nécessaire pour implémenter
	la fonctionnalité de correspondance par suffixe dans la mesure où
	le nom d'hôte du candidat à la connexion doit être connu afin de 
	pouvoir effectuer cette comparaison.
       </para>

       <para>
        Enfin, cette méthode est couramment adoptée par d'autres implémentations
	du contrôle d'accès basé sur les noms d'hôtes, tels que le serveur web
	Apache ou TCP-wrapper.
       </para>
      </sidebar>

      <para>Ce champ ne concerne que les enregistrements
       <literal>host</literal>, <literal>hostssl</literal> et
       <literal>hostnossl</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>IP-address</replaceable></term>
     <term><replaceable>IP-mask</replaceable></term>
     <listitem>
      <para>
       Ces champs peuvent être utilisés comme alternative à la notation
       <replaceable>CIDR-address</replaceable>. Au lieu de spécifier la longueur
       du masque, le masque réel est indiquée dans une colonne distincte. Par
       exemple, <literal>255.0.0.0</literal> représente une longueur de masque CIDR
       IPv4 de 8, et <literal>255.255.255.255</literal> représente une longueur de
       masque de 32.
      </para>

      <para>Ces champs ne concernent que les enregistrements 
      <literal>host</literal>, <literal>hostssl</literal> et
      <literal>hostnossl</literal>.
    </para> 
    </listitem> 
    </varlistentry>  

    <varlistentry> <term><replaceable>auth-method</replaceable></term>
    <listitem> 
     <para>
      Indique la méthode d'authentification à utiliser lors d'une
      connexion via cet enregistrement. Les choix possibles sont résumés ici&nbsp;; les
      détails se trouvent dans la <xref linkend="auth-methods"/>.

       <variablelist>
        <varlistentry>
	 <term><literal>trust</literal></term>
	  <listitem>
	   <para>
	    Autorise la connexion sans condition. Cette méthode permet à
	    quiconque peut se connecter au serveur de bases de données
	    de s'enregistrer sous n'importe quel utilisateur
	    <productname>PostgreSQL</productname> de son choix sans 
	    mot de passe ou autre authentification. Voir la <xref
        linkend="auth-trust"/> pour les détails.
	   </para>
	  </listitem>
	 </varlistentry>

       <varlistentry>
        <term><literal>reject</literal></term>
	 <listitem>
	  <para>
	   Rejette la connexion sans condition. Ce cas est utile
	   pour <quote>filtrer</quote> certains hôtes d'un groupe, par exemple une
       ligne <literal>reject</literal> peut bloquer la connexion d'un hôte
       spécifique alors qu'une ligne plus bas permettra aux autres hôtes de
       se connecter à partir d'un réseau spécifique.
	  </para>
	 </listitem>
	</varlistentry>

       <varlistentry>
       <term><literal>md5</literal></term>
       <listitem>
       <para>
       Demande au client de fournir un mot de passe chiffré MD5 pour
       l'authentification. Voir la <xref linkend="auth-password"/> pour
       les détails.
       </para>
       </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>password</literal></term>
	<listitem>
	 <para>
          Requiert que le client fournisse un mot de passe non chiffré pour
	  l'authentification. Comme le mot de passe est envoyé en clair sur
	  le réseau, ceci ne doit pas être utilisé sur des réseaux non
	  dignes de confiance. Voir la <xref linkend="auth-password"/> pour
	  les détails.
	 </para>
	</listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>gss</literal></term>
        <listitem>
         <para>
          Utilise GSSAPI pour authentifier l'utilisateur. Disponible uniquement
          pour les connexions TCP/IP. Voir <xref
          linkend="gssapi-auth"/> pour les détails.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>sspi</literal></term>
        <listitem>
         <para>
          Utilise SSPI pour authentifier l'utilisateur. Disponible uniquement
          sur Windows. Voir <xref
          linkend="sspi-auth"/> pour plus de détails.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>krb5</literal></term>
	<listitem>
	 <para>
	  Utilise Kerberos V5 pour authentifier l'utilisateur. Ceci n'est
	  disponible que pour les connexions TCP/IP. Voir la
	  <xref linkend="kerberos-auth"/> pour les détails.
	 </para>
	</listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>ident</literal></term>
	<listitem>
	 <para>
          Récupère le nom de l'utilisateur en contactant le serveur d'identification 
          sur le poste client, et vérifie que cela correspond au nom d'utilisateur de 
          base de données demandé.
          L'authentification Ident ne peut être utilisée que pour les connexions TCP/IP.
          Pour les connexions locales, elle sera remplacée par l'authentification peer.
	 </para>
	</listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>peer</literal></term>
        <listitem>
         <para>          
	      Récupère le nom d'utilisateur identifié par le système d'exploitation
          du client et vérifie que cela correspond au nom d'utilisateur de 
          base de données demandé.
          Peer ne peut être utilisée que pour les connexions locales.
          Voir la <xref linkend="auth-peer"/> ci-dessous pour les details.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>ldap</literal></term>
        <listitem>
         <para>
          Authentification par un serveur <acronym>LDAP</acronym>. Voir la
	  <xref linkend="auth-ldap"/> pour les détails.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>radius</literal></term>
        <listitem>
         <para>
          Authentification par un serveur RADIUS. Voir <xref
          linkend="auth-radius"/> pour les détails.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>cert</literal></term>
        <listitem>
         <para>
          Authentification par certificat client SSL. Voir
          <xref linkend="auth-cert"/> pour les détails.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>pam</literal></term>
	<listitem>
	 <para>
	  Authentification par les Pluggable Authentification Modules (PAM)
	  fournis par le système d'exploitation. Voir la <xref linkend="auth-pam"/>
	  pour les détails.
	 </para>
	</listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable>auth-options</replaceable></term>
     <listitem>
      <para>
       Après le champ <replaceable>auth-method</replaceable>, on peut trouver
       des champs de la forme
       <replaceable>nom</replaceable><literal>=</literal><replaceable>valeur</replaceable>
       qui spécifient des options pour la méthode d'authentification. Les
       détails sur les options disponibles apparaissent ci-dessous pour chaque
       méthode d'authentification.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Les fichiers inclus par les constructions <literal>@</literal> sont lus comme des
   listes de noms, séparés soit par des espaces soit par
   des virgules. Les commentaires sont introduits par le caractère
   <literal>#</literal> comme dans <filename>pg_hba.conf</filename>, et les
   constructions <literal>@</literal> imbriquées sont autorisées. À moins
   que le nom du fichier qui suit <literal>@</literal> ne soit un chemin absolu,
   il est supposé relatif au répertoire contenant le fichier le référençant.
  </para>

  <para>
   Les enregistrements du fichier <filename>pg_hba.conf</filename> sont
   examinés séquentiellement à chaque tentative de connexion, l'ordre des
   enregistrements est donc significatif. Généralement, les premiers enregistrements
   ont des paramètres d'interception de connexions stricts et des méthodes
   d'authentification peu restrictives tandis que les
   enregistrements suivants ont des paramètres plus larges et des méthodes
   d'authentification plus fortes. Par exemple, on peut souhaiter utiliser
   l'authentification <literal>trust</literal> pour les connexions TCP/IP locales mais
   demander un mot de passe pour les connexion TCP/IP distantes. Dans ce cas, 
   l'enregistrement précisant une authentification <literal>trust</literal> pour les
   connexions issues de 127.0.0.1 apparaît avant un enregistrement indiquant
   une authentification par mot de passe pour une plage plus étendue d'adresses IP
   client autorisées.
  </para>

  <para>
   Le fichier <filename>pg_hba.conf</filename> est lu au démarrage et
   lorsque le processus serveur principal reçoit un signal
   <systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm>.
   Si le fichier est édité sur un système actif, on peut signaler au
   postmaster (en utilisant <literal>pg_ctl reload</literal> ou 
   <literal>kill -HUP</literal>) de relire le fichier.
  </para>

  <tip>
   <para>
    Pour se connecter à une base particulière, un utilisateur doit non
    seulement passer les vérifications de <filename>pg_hba.conf</filename> mais doit
    également avoir le droit <literal>CONNECT</literal> sur cette base. Pour
    contrôler qui peut se connecter à quelles bases, il est en général plus
    facile de le faire en donnant ou retirant le privilège 
    <literal>CONNECT</literal> plutôt qu'en
    plaçant des règles dans le fichier <filename>pg_hba.conf</filename>.
   </para>
  </tip>

  <para>
   Quelques exemples d'entrées de <filename>pg_hba.conf</filename> sont
   donnés ci-dessous dans l'<xref linkend="example-pg-hba.conf"/>. Voir la
   section suivante pour les détails des méthodes d'authentification.  </para>

   <example id="example-pg-hba.conf">
   <title>Exemple d'entrées de <filename>pg_hba.conf</filename></title>
<programlisting># Permettre à n'importe quel utilisateur du système local de se connecter
# à la base de données sous n'importe quel nom d'utilisateur au travers
# des sockets de domaine Unix (par défaut pour les connexions locales).
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   all             all                                     trust

# La même chose en utilisant les connexions TCP/IP locales loopback.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             127.0.0.1/32            trust

# Pareil mais en utilisant une colonne netmask distincte.
#
# TYPE  DATABASE    USER        IP-ADDRESS          IP-mask              METHOD
host    all         all         127.0.0.1           255.255.255.255      trust

# Pareil mais en IPv6.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             ::1/128                 trust

# À l'identique en utilisant le nom d'hôte (qui doit typiquement fonctionner en IPv4 et IPv6).
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             localhost               trust

# Permettre à n'importe quel utilisateur de n'importe quel hôte d'adresse IP
# 192.168.93.x de se connecter à la base de données "postgres" sous le nom
# d'utilisateur qu'ident signale à la connexion (généralement le
# nom utilisateur du système d'exploitation).
# 
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    postgres        all             192.168.93.0/24         ident

# Permet à un utilisateur de l'hôte 192.168.12.10 de se connecter à la base de
# données "postgres" si le mot de passe de l'utilisateur est correctement fourni.
# 
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    postgres        all             192.168.12.10/32        md5

# Permet la connexion à n'importe quel utilisateur depuis toutes les machines du 
# domaine exemple.com à n'importe quelle base de données si le mot de passe
# correct est fourni.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             .exemple.com            md5

# Si aucune ligne "host" ne précède, ces deux lignes rejettent toutes
# les connexions en provenance de 192.168.54.1 (puisque cette entrée déclenche
# en premier), mais autorisent les connexions Kerberos 5 de n'importe où
# ailleurs sur l'Internet. Le masque zéro signifie qu'aucun bit de l'ip de
# l'hôte n'est considéré, de sorte à correspondre à tous les hôtes.
# 
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.54.1/32         reject
host    all             all             0.0.0.0/0               krb5

# Permettre à tous les utilisateurs de se connecter depuis 192.168.x.x à n'importe
# quelle base de données s'ils passent la verification d'identification. Si,
# par exemple, ident indique que l'utilisateur est "bryanh" et qu'il
# demande à se connecter en tant qu'utilisateur PostgreSQL "guest1", la
# connexion n'est permise que s'il existe une entrée dans pg_ident.conf pour la
# correspondance "omicron" disant que "bryanh" est autorisé à se connecter en
# tant que "guest1".
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.0.0/16          ident map=omicron

# Si ces trois lignes traitent seules les connexions locales, elles
# n'autorisent les utilisateurs locaux qu'à se connecter à leur propre
# base de données (base ayant le même nom que leur nom
# d'utilisateur) exception faite des administrateurs
# et des membres du rôle "support" qui peuvent se connecter à toutes les bases
# de données. Le fichier $PGDATA/admins contient une liste de noms
# d'administrateurs. Un mot de passe est requis dans tous les cas.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   sameuser        all                                     md5
local   all             @admins                                 md5
local   all             +support                                md5

# Les deux dernières lignes ci-dessus peuvent être combinées en une seule ligne :
local   all         @admins,+support                  md5

# La colonne database peut aussi utiliser des listes et des noms de fichiers :
local   db1,db2,@demodbs  all                         md5</programlisting>
</example>

 </sect1>

 <sect1 id="auth-username-maps">
  <title>Correspondances d'utilisateurs</title>

  <indexterm zone="auth-username-maps">
   <primary>Correspondance d'identités</primary>
  </indexterm>

  <para>
   Lorsqu'on utilise une authentification externe telle que Ident ou GSSAPI,
   le nom de l'utilisateur du système d'exploitation qui a initié la connexion
   peut ne pas être le même que celui de l'utilisateur de la base à laquelle il
   tente de se connecter. Dans ce cas, une table de correspondance d'identités
   peut être mise en place pour faire correspondre le nom d'utilisateur système
   au nom d'utilisateur base de donnée. Pour utiliser une table de correspondance
   d'identités, spécifiez <literal>map</literal>=<replaceable>nom-table</replaceable>
   dans le champ options de <filename>pg_hba.conf</filename>. Cette option est supportée
   pour toutes les méthodes d'authentification qui reçoivent des noms d'utilisateurs
   externes. Comme différentes correspondances peuvent être nécessaires pour différentes
   connexions, le nom de la table à utiliser doit être spécifié dans le paramètre
   <replaceable>nom-table</replaceable> de <filename>pg_hba.conf</filename> afin
   d'indiquer quelle table utiliser pour chaque connexion.
  </para>

  <para>
   Les tables de correspondance de noms d'utilisateurs sont définies dans le fichier de
   correspondance, qui par défaut s'appelle
   <filename>pg_ident.conf</filename><indexterm><primary>pg_ident.conf</primary></indexterm>
   et est stocké dans le répertoire de données du cluster. (Toutefois, il est
   possible de placer la table de correspondance ailleurs&nbsp;; voir le
   paramètre de configuration <xref linkend="guc-ident-file"/>.)
   Le fichier de table de correspondance contient des lignes de la forme
   suivante&nbsp;:
<synopsis>
<replaceable>nom-table</replaceable> <replaceable>nom-d-utilisateur-systeme</replaceable> <replaceable>nom-d-utilisateur-base</replaceable>
</synopsis>
   Les commentaires et les blancs sont traités de la même façon que dans
   <filename>pg_hba.conf</filename>. Le <replaceable>nom-table</replaceable>
   est un nom arbitraire qui sera utilisé pour faire référence à cette table
   de correspondance dans <filename>pg_hba.conf</filename>. Les deux autres
   champs spécifient un nom d'utilisateur du système d'exploitation et un nom
   d'utilisateur de la base de données correspondant. Le même
   <replaceable>nom-correspondance</replaceable> peut être utilisé de façon
   répétée pour indiquer plusieurs correspondances d'utilisateur dans la
   même carte.
  </para>
  
  <para>
   Il n'y a aucune restriction sur le nombre d'utilisateurs de base de données
   auxquels un utilisateur du système d'exploitation peut correspondre et
   vice-versa. Du coup, les entrées dans une carte signifient que
   <quote>cet utilisateur du système d'exploitation est autorisé à se connecter
   en tant que cet utilisateur de la base de données</quote>, plutôt que
   supposer qu'ils sont équivalents. La connexion sera autorisée s'il existe
   une entrée dans la carte qui correspond au nom d'utilisateur obtenu à partir
   du système d'authentification externe pour le nom de l'utilisateur de la base
   de données que l'utilisateur a indiqué.
  </para>
  
  <para>
   Si le champ <replaceable>system-username</replaceable> commence avec un
   slash (<literal>/</literal>), le reste du champ est traité comme une
   expression rationnelle. (Voir <xref linkend="posix-syntax-details"/> pour les
   détails de la syntaxe des expressions rationnelles avec
   <productname>PostgreSQL</productname>.). L'expression rationnelle peut inclure une copie
   (sous-expression entre parenthèses), qui peut ensuite être référencée dans
   le champ <replaceable>database-username</replaceable> avec le joker
   <literal>\1</literal> (antislash-un). Ceci permet la correspondance de
   plusieurs noms d'utilisateurs sur une seule ligne, ce qui est particulièrement
   utile pour les substitutions simples. Par exemple, ces entrées
<programlisting>
mymap   /^(.*)@mydomain\.com$      \1
mymap   /^(.*)@otherdomain\.com$   guest
</programlisting>
   supprimeront la partie domaine pour les utilisateurs de système d'exploitation
   dont le nom finissent avec <literal>@mydomain.com</literal>, et permettront aux
   utilisateurs dont le nom se termine avec <literal>@otherdomain.com</literal> de
   se connecter en tant que <literal>guest</literal>.
  </para>

  <tip>
   <para>
    Gardez en tête que, par défaut, une expression rationnelle peut correspondre
    à une petite partie d'une chaîne. Il est généralement conseillé d'utiliser
    les jokers <literal>^</literal> et <literal>$</literal>, comme indiqué dans
    l'exemple ci-dessus, pour forcer une correspondance sur le nom entier de
    l'utilisateur du système d'exploitation.
   </para>
  </tip>

  <para>
   Le fichier <filename>pg_ident.conf</filename> est lu au démarrage et
   quand le processus principal du serveur reçoit un signal
   <systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm>.
   Si vous éditez le fichier sur un système en cours d'utilisation, vous devez
   notifier le postmaster (en utilisant<literal>pg_ctl reload</literal> ou
   <literal>kill -HUP</literal>) pour lui faire relire le fichier.
  </para>

  <para>
   Un fichier <filename>pg_ident.conf</filename> qui pourrait être utilisé
   avec le fichier <filename>pg_hba.conf</filename> de
   <xref linkend="example-pg-hba.conf"/> est montré en
   <xref linkend="example-pg-ident.conf"/>. Dans cet exemple,
   toute personne connectée sur une machine du réseau 192.168 qui n'a pas
   le nom d'utilisateur du système d'exploitation <literal>bryanh</literal>, <literal>ann</literal>,
   ou <literal>robert</literal> verrait son accès refusé. L'utilisateur Unix
   <literal>robert</literal> ne verrait son accès autorisé que lorsqu'il essaye
   de se connecter en tant qu'utilisateur <productname>PostgreSQL</productname>
   <literal>bob</literal>, pas en tant que <literal>robert</literal> ou
   qui que ce soit d'autre. <literal>ann</literal> ne serait autorisée à se connecter
   qu'en tant que <literal>ann</literal>. L'utilisateur <literal>bryanh</literal>
   aurait le droit de se connecter soit en tant que <literal>bryanh</literal>,
   soit en tant que <literal>guest1</literal>.
  </para>

  <example id="example-pg-ident.conf">
   <title>Un exemple de fichier <filename>pg_ident.conf</filename></title>
<programlisting>
# MAPNAME     SYSTEM-USERNAME   PG-USERNAME

omicron       bryanh            bryanh
omicron       ann               ann
# bob has user name robert on these machines
omicron       robert            bob
# bryanh can also connect as guest1
omicron       bryanh            guest1
</programlisting>
  </example>
 </sect1>

 <sect1 id="auth-methods">
 <title>Méthodes d'authentification</title>
 <para>
  Les sous-sections suivantes décrivent les méthodes d'authentification en détail.
 </para>

  <sect2 id="auth-trust">
  <title>Authentification trust</title>

   <para>
    Quand l'authentification <literal>trust</literal> est utilisée,
    <productname>PostgreSQL</productname> considère que quiconque peut se
    connecter au serveur est autorisé à accéder à la base de données quel que
    soit le nom d'utilisateur de bases de données qu'il fournit (même les noms
    des super-utilisateurs). Les restrictions apportées dans les
    colonnes <literal>database</literal> et <literal>user</literal>
    continuent évidemment de s'appliquer. Cette méthode ne doit être utilisée
    que si le système assure un contrôle adéquat des connexions au serveur.
   </para>

   <para>
    L'authentification <literal>trust</literal> est appropriée et très pratique
    pour les connexions locales sur une station de travail mono-utilisateur. Elle
    n'est généralement <emphasis>pas</emphasis> appropriée en soi sur une machine
    multi-utilisateur. Cependant, <literal>trust</literal> peut tout de même 
    être utilisé sur une machine multi-utilisateur, si l'accès au fichier
    socket de domaine Unix est restreint par les permissions du système de
    fichiers. Pour ce faire, on peut positionner les paramètres de configuration
    <varname>unix_socket_permissions</varname> (et au besoin
    <varname>unix_socket_group</varname>) comme cela est décrit dans la
    <xref linkend="runtime-config-connection"/>. 
    On peut également positionner le paramètre de configuration
    <varname>unix_socket_directories</varname> pour placer le fichier de socket
    dans un répertoire à l'accès convenablement restreint.
   </para>

   <para>
    Le réglage des droits du système de fichiers n'a d'intérêt que le cas de
    connexions par les sockets Unix. Les droits du système de fichiers ne
    restreignent pas les connexions TCP/IP locales. Ainsi, pour utiliser les
    droits du système de
    fichiers pour assurer la sécurité locale, il faut supprimer la ligne
    <literal>host ...127.0.0.1 ...</literal> de
    <filename>pg_hba.conf</filename> ou la modifier pour utiliser une méthode
    d'authentification différente de <literal>trust</literal>.
   </para>

   <para>
    L'authentification <literal>trust</literal> n'est envisageable, pour les
    connexions TCP/IP, que si chaque utilisateur de chaque machine autorisée
    à se connecter au serveur par les lignes <literal>trust</literal> du
    fichier <filename>pg_hba.conf</filename> est digne de confiance. Il est
    rarement raisonnable d'utiliser <literal>trust</literal> pour les
    connexions autres que celles issues de
    <systemitem>localhost</systemitem> (127.0.0.1).
   </para>

  </sect2>

  <sect2 id="auth-password"> <title>Authentification par mot de passe</title>

   <indexterm>
    <primary>MD5</primary>
   </indexterm>

   <indexterm>
     <primary>password</primary>
     <secondary>authentification</secondary>
   </indexterm>
   <indexterm>
    <primary>mot de passe</primary>
    <secondary>authentification</secondary>
   </indexterm>

   <para>
    Les méthodes fondées sur une authentification par mot de passe sont
    <literal>md5</literal> et
    <literal>password</literal>. Ces méthodes
    fonctionnent de façon analogue à l'exception du mode d'envoi du mot de passe
    à travers la connexion&nbsp;: respectivement, hachage MD5 et texte en clair.
   </para>

   <para>
    S'il existe un risque d'attaque par <quote>interception (sniffing)</quote>
    des mots de passe, il est préférable d'utiliser <literal>md5</literal>.
    L'utilisation de <literal>password</literal>, en clair, est toujours à
    éviter quand c'est possible. Néanmoins, <literal>md5</literal> ne peut pas
    être utilisé avec la fonctionnalité <xref linkend="guc-db-user-namespace"/>.
    Si la connexion est protégée par un chiffrement SSL, alors
    <literal>password</literal> peut être utilisé avec sûreté (bien que
    l'authentification par certificat SSL pourrait être un meilleur choix s'il
    y a dépendance au sujet de l'utilisation de SSL).
   </para>

   <para>
    Les mots de passe <productname>PostgreSQL</productname>
    sont distincts des mots de passe du système d'exploitation. Le mot de passe
    de chaque utilisateur est enregistré dans le catalogue système
    <literal>pg_authid</literal>. Ils peuvent être gérés avec les
    commandes SQL <xref linkend="sql-createuser"/>
    et <xref linkend="sql-alterrole"/>. Ainsi, par
    exemple, <userinput>CREATE USER foo WITH PASSWORD 'secret';</userinput>. Si
    aucun mot de passe n'est enregistré pour un utilisateur, le mot de passe enregistré
    est nul et l'authentification par mot de passe échoue systématiquement pour
    cet utilisateur.
   </para>

  </sect2>

  <sect2 id="gssapi-auth">
   <title>Authentification GSSAPI</title>

   <indexterm zone="gssapi-auth">
    <primary>GSSAPI</primary>
   </indexterm>

   <para>
    <productname>GSSAPI</productname> est un protocole du standard de
    l'industrie pour l'authentification sécurisée définie dans RFC 2743.
    <productname>PostgreSQL</productname> supporte
    <productname>GSSAPI</productname> avec l'authentification
    <productname>Kerberos</productname> suivant la RFC 1964.
    <productname>GSSAPI</productname> fournit une authentification
    automatique (<foreignphrase>single sign-on</foreignphrase>) pour les
    systèmes qui le supportent. L'authentification elle-même est sécurisée
    mais les données envoyées sur la connexion seront en clair sauf si
    <acronym>SSL</acronym> est utilisé.
   </para>

   <para>
    Quand <productname>GSSAPI</productname> passe par
    <productname>Kerberos</productname>, il utilise un principal standard
    dans le format
	<literal><replaceable>nomservice</replaceable>/<replaceable>nomhôte</replaceable>@<replaceable>domaine</replaceable></literal>.
    Pour des informations sur les parties du principal et sur la façon de
    configurer les clés requises, voir <xref linkend="kerberos-auth"/>.
   </para>

   <para>
    Le support de GSSAPI doit être activé lors de la construction de
    <productname>PostgreSQL</productname>&nbsp;; voir
    <xref linkend="installation"/> pour plus d'informations.
   </para>

   <para>
    Les options de configuration suivantes sont supportées pour
    <productname>GSSAPI</productname>&nbsp;:
   <variablelist>
     <varlistentry>
      <term><literal>include_realm</literal></term>
      <listitem>
       <para>
        Si configuré à 1, le nom du royaume provenant du
	principal de l'utilisateur authentifié est inclus dans le nom de
	l'utilisateur système qui est passé au système de correspondance
	d'utilisateur (<xref linkend="auth-username-maps"/>). Ceci est utile
	pour gérer des utilisateurs provenant de plusieurs royaumes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        Permet la mise en correspondance entre les noms système et base de données.
        Voir <xref linkend="auth-username-maps"/> pour plus de détails. Pour
        un principal Kerberos <literal>username/hostbased@EXAMPLE.COM</literal>,
        le nom d'utilisateur utilisé pour la correspondance est
        <literal>nomutilisateur/hote</literal> si
        <literal>include_realm</literal> est désactivé, et 
        <literal>username/hostbased@EXAMPLE.COM</literal> si
        <literal>include_realm</literal> est activé.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>krb_realm</literal></term>
      <listitem>
       <para>
        Configure le royaume pour la correspondance du principal de l'utilisateur.
	Si ce paramètre est configuré, seuls les utilisateurs de ce royaume
	seront acceptés. S'il n'est pas configuré, les utilisateurs de tout
	royaume peuvent se connecter, à condition que la correspondance du nom
	de l'utilisateur est faite.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   
  </sect2>

  <sect2 id="sspi-auth">
   <title>Authentification SSPI</title>

   <indexterm zone="sspi-auth">
    <primary>SSPI</primary>
   </indexterm>

   <para>
    <productname>SSPI</productname> est une technologie
    <productname>Windows</productname> pour l'authentification sécurisée avec
    <foreignphrase>single sign-on</foreignphrase>.
    <productname>PostgreSQL</productname> utilise SSPI dans un mode de
    négociation (<literal>negotiate</literal>) qui utilise
    <productname>Kerberos</productname> si possible et
    <productname>NTLM</productname> sinon. L'authentification
    <productname>SSPI</productname> ne fonctionne que lorsque serveur et
    client utilisent <productname>Windows</productname> ou, sur les
    autres plateformes, quand <productname>GSSAPI</productname> est
    disponible.
   </para>

   <para>
    Lorsque <productname>Kerberos</productname> est utilisé,
    <productname>SSPI</productname> fonctionne de la même façon que
    <productname>GSSAPI</productname>.
    Voir <xref linkend="gssapi-auth"/> pour les détails.
   </para>
   
   <para>
    Les options de configuration suivantes sont supportées pour
    <productname>SSPI</productname>&nbsp;:
    <variablelist>
     <varlistentry>
      <term><literal>include_realm</literal></term>
      <listitem>
       <para>
        Si configuré à 1, le nom du royaume provenant du
	principal de l'utilisateur authentifié est inclus dans le nom de
	l'utilisateur système qui est passé au système de correspondance
	d'utilisateur (<xref linkend="auth-username-maps"/>). Ceci est utile
	pour gérer des utilisateurs provenant de plusieurs royaumes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        Permet la mise en correspondance entre les noms système et base de données.
        Voir <xref linkend="auth-username-maps"/> pour plus de détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>krb_realm</literal></term>
      <listitem>
       <para>
        Configure le royaume pour la correspondance du principal de l'utilisateur.
	Si ce paramètre est configuré, seuls les utilisateurs de ce royaume
	seront acceptés. S'il n'est pas configuré, les utilisateurs de tout
	royaume peuvent se connecter, à condition que la correspondance du nom
	de l'utilisateur est faite.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

  </sect2>

  <sect2 id="kerberos-auth"> <title>Authentification Kerberos</title>

   <indexterm zone="kerberos-auth"> <primary>Kerberos</primary> </indexterm>

   <note>
    <para>
     L'authentification Kerberos native est obsolète et ne doit être
     utilisée que pour assurer la compatibilité ascendante. 
     Les nouvelles installations et les mises à jour utiliseront
     préférentiellement le standard d'authentification
     de l'industrie, <productname>GSSAPI</productname> (voir <xref
     linkend="gssapi-auth"/>).
    </para>
   </note>

   <para>
    <productname>Kerberos</productname> est un système d'authentification
    sécurisée de standard industriel destiné à l'informatique distribuée sur un
    réseau public. La description de <productname>Kerberos</productname>
    dépasse les objectifs de ce document&nbsp; même dans les
    généralités, c'est assez complexe (bien que puissant). La
    <ulink url="http://www.cmf.navy.mil/CCS/people/kenh/kerberos-faq.html">
    <acronym>FAQ</acronym> Kerberos</ulink> ou la
    <ulink url="http://web.mit.edu/kerberos/www/">page Kerberos du
    MIT</ulink> sont un bon point de départ à l'exploration. Il existe plusieurs
    sources de distribution <productname>Kerberos</productname>.
    <productname>Kerberos</productname> fournit une authentification sécurisée
    mais ne chiffre pas les requêtes ou les données passées sur le réseau&nbsp;;
    pour cela, <acronym>SSL</acronym> doit être utilisé.
   </para>

   <para>
    <productname>PostgreSQL</productname> supporte Kerberos version 5. Le
    support de Kerberos doit être activé lors de la construction de
    <productname>PostgreSQL</productname>&nbsp;; voir le
    <xref linkend="installation"/> pour plus d'informations.
   </para>

   <para>
    <productname>PostgreSQL</productname> opère comme un service Kerberos normal.
    Le nom du service principal est
    <literal><replaceable>nomservice</replaceable>/<replaceable>nomhôte</replaceable>@<replaceable>domaine</replaceable></literal>.
   </para>

   <para>
    <replaceable>nomservice</replaceable> peut être configuré du côté serveur en utilisant
    le paramètre de configuration <xref linkend="guc-krb-srvname"/> (voir
    aussi <xref linkend="libpq-paramkeywords"/>). La valeur par défaut à
    l'installation, <literal>postgres</literal>, peut être modifiée lors
    de la construction avec
    <literal>./configure --with-krb-srvnam=</literal><replaceable>quelquechose</replaceable>. Dans la
    plupart des environnements, il est inutile de modifier cette valeur.
    Néanmoins, cela devient nécessaire pour supporter plusieurs installations
    de <productname>PostgreSQL</productname> sur le même hôte.
    Quelques implantations de Kerberos peuvent
    imposer un nom de service différent, comme Microsoft Active
    Directory qui réclame un nom du service en majuscules
    (<literal>POSTGRES</literal>).
   </para>

   <para>
    <replaceable>nom_hote</replaceable> est le nom de l'hôte pleinement
    qualifié (<foreignphrase>fully qualified host name</foreignphrase>)
    de la machine serveur. Le domaine du service principal (client)
    est le domaine préféré du serveur.
   </para>

   <para>
    Les principaux (clients) doivent contenir le nom de leur utilisateur
    <productname>PostgreSQL</productname> comme premier composant,
    <literal>nomutilisateurpg@domaine</literal>, par exemple.
    Sinon, vous pouvez utiliser une correspondance du nom d'utilisateur qui
    établit la correspondance à partir du premier composant du nom du principal
    vers le nom d'utilisateur de la base de données 
    Par défaut, le domaine du client n'est pas vérifié par
    <productname>PostgreSQL</productname>. Si l'authentification inter-domaine
    (<foreignphrase>cross-realm</foreignphrase>) est activée, on utilise le
    paramètre <literal>krb_realm</literal> ou activer <literal>include_realm</literal>
    et utiliser la correspondance du nom d'utilisateur pour vérifier le royaume.
   </para>

   <para>
    Le fichier de clés du serveur doit être lisible (et de préférence
    uniquement lisible) par le compte serveur
    <productname>PostgreSQL</productname> (voir aussi la
    <xref linkend="postgres-user"/>). L'emplacement du fichier de clés est
    indiqué grâce au paramètre de configuration
    <xref linkend="guc-krb-server-keyfile"/> fourni à l'exécution. La valeur
    par défaut est <filename>/etc/srvtab</filename>, si Kerberos 4 est
    utilisé, et <filename>/usr/local/pgsql/etc/krb5.keytab</filename> sinon
    (ou tout autre répertoire indiqué comme <varname>sysconfdir</varname> à
    la compilation).
   </para>

   <para>
    Le fichier de clés est engendré par le logiciel Kerberos&nbsp;; voir la
    documentation de Kerberos pour les détails. L'exemple suivant correspond
    à des implantations de Kerberos 5 compatibles avec MIT&nbsp;:
<screen><prompt>kadmin% </prompt><userinput>ank -randkey postgres/server.my.domain.org</userinput>
<prompt>kadmin% </prompt><userinput>ktadd -k krb5.keytab postgres/server.my.domain.org</userinput></screen>
   </para>

   <para>
    Lors de la connexion à la base de données, il faut s'assurer de posséder
    un ticket pour le principal correspondant au nom d'utilisateur de base
    de données souhaité. Par exemple, pour le nom d'utilisateur PostgreSQL
    <literal>fred</literal>, le principal <literal>fred@EXAMPLE.COM</literal>
    pourrait se connecter. Pour autoriser aussi le principal
    <literal>fred/users.example.com@EXAMPLE.COM</literal>, utiliser une
    correspondance de nom d'utilisateur, comme décrit dans <xref
    linkend="auth-username-maps"/>.
   </para>

   <para>
    Si <ulink url="http://modauthkerb.sf.net">mod_auth_kerb</ulink> et
    <application>mod_perl</application> sont utilisés sur le serveur web
    <productname>Apache</productname>, 
    <literal>AuthType KerberosV5SaveCredentials</literal> peut être utilisé
    avec un script <application>mod_perl</application>. Cela fournit un accès
    sûr aux bases de données, sans demander de mot de passe supplémentaire.
   </para>
   
   <para>
    Les options de configuration suivantes sont supportées pour
    <productname>Kerberos</productname>&nbsp;:
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        Permet la mise en correspondance entre les noms système et base de données.
        Voir <xref linkend="auth-username-maps"/> pour plus de détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>include_realm</literal></term>
      <listitem>
       <para>
        Si configuré à 1, le nom du royaume provenant du
	principal de l'utilisateur authentifié est inclus dans le nom de
	l'utilisateur système qui est passé au système de correspondance
	d'utilisateur (<xref linkend="auth-username-maps"/>). Ceci est utile
	pour gérer des utilisateurs provenant de plusieurs royaumes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>krb_realm</literal></term>
      <listitem>
       <para>
        Configure le royaume pour la correspondance du principal de l'utilisateur.
	Si ce paramètre est configuré, seuls les utilisateurs de ce royaume
	seront acceptés. S'il n'est pas configuré, les utilisateurs de tout
	royaume peuvent se connecter, à condition que la correspondance du nom
	de l'utilisateur est faite.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>krb_server_hostname</literal></term>
      <listitem>
       <para>
        Précise le nom d'hôte du service principal. Cela, combiné avec
	<varname>krb_srvname</varname>, est utilisé pour généré le nom complet
	du service principal, qui est
	<varname>krb_srvname</varname><literal>/</literal><varname>krb_server_hostname</varname><literal>@</literal>REALM.
        S'il n'est pas renseigné, la valeur par défaut est le nom d'hôte du serveur.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

  </sect2>

  <sect2 id="auth-ident"> <title>Authentification fondée sur ident</title>

   <indexterm> <primary>ident</primary> </indexterm>

   <para>
    La méthode d'authentification ident fonctionne en obtenant le nom
    de l'opérateur du système depuis le serveur ident distant et en l'appliquant comme
    nom de l'utilisateur de la base de données (et après une éventuelle mise en 
    correspondance). Cette méthode n'est supportée que pour les connexions TCP/IP.
   </para>
 
   <note>
    <para>
     Lorsqu'ident est spécifié pour une connexion locale (c'est-à-dire
     non TCP/IP), l'authentification peer (voir <xref linkend="auth-peer"/>)
     lui est automatiquement substituée.
    </para>
   </note>

   <para>
    Les options de configuration suivantes sont supportées pour
    <productname>ident</productname>&nbsp;:
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        Permet la mise en correspondance entre les noms système et base de données.
        Voir <xref linkend="auth-username-maps"/> pour plus de détails.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Le <quote>protocole d'identification</quote> est décrit dans la
    RFC 1413. Théoriquement, chaque système
    d'exploitation de type Unix contient un serveur ident
    qui écoute par défaut sur le port TCP 113. La fonctionnalité basique
    d'un serveur ident est de répondre aux questions telles que&nbsp;:
    <quote>Quel utilisateur a initié la connexion qui sort du port
    <replaceable>X</replaceable> et se connecte à mon port
    <replaceable>Y</replaceable>?</quote>.
    Puisque <productname>PostgreSQL</productname> connaît
    <replaceable>X</replaceable> et <replaceable>Y</replaceable> dès lors
    qu'une connexion physique est établie, il peut interroger le serveur
    ident de l'hôte du client qui se connecte et peut ainsi théoriquement
    déterminer l'utilisateur du système d'exploitation pour n'importe quelle
    connexion.
   </para>

   <para>
    Le revers de cette procédure est qu'elle dépend de l'intégrité du
    client&nbsp;: si la machine cliente est douteuse ou compromise, un attaquant
    peut lancer n'importe quel programme sur le port 113 et retourner un nom
    d'utilisateur de son choix. Cette méthode d'authentification n'est, par
    conséquent, appropriée que dans le cas de réseaux fermés dans lesquels
    chaque machine cliente est soumise à un contrôle strict et dans lesquels
    les administrateurs système et de bases de données opèrent en étroite
    collaboration. En d'autres mots, il faut pouvoir faire confiance à la
    machine hébergeant le serveur d'identification. Cet avertissement doit
    être gardé à l'esprit&nbsp;:
    <blockquote>
     <attribution>RFC 1413</attribution>
     <para>
      Le protocole d'identification n'a pas vocation à être un protocole
      d'autorisation ou de contrôle d'accès.
     </para>
    </blockquote>
   </para>

   <para>
    Certains serveurs ident ont une option non standard qui chiffre le nom de
    l'utilisateur retourné à l'aide d'une clé connue du seul administrateur
    de la machine dont émane la connexion. Cette option <emphasis>ne
    doit pas</emphasis> être employée lorsque le serveur ident est utilisé avec
    <productname>PostgreSQL</productname> car <productname>PostgreSQL</productname>
    n'a aucun moyen de déchiffrer la chaîne renvoyée pour déterminer le nom réel
    de l'utilisateur.
   </para>

  </sect2>

  <sect2 id="auth-peer">
   <title>Peer Authentication</title>

   <indexterm>
    <primary>peer</primary>
   </indexterm>

   <para>
    La méthode d'authentification peer utilise les services du système d'exploitation
    afin d'obtenir le nom de l'opérateur ayant lancé la commande client de connexion
    et l'utilise (après une éventuelle mise en correspondance) comme nom d'utilisateur
    de la base de données. Cette méthode n'est supportée que pour les connexions
    locales.
   </para>

   <para>
    Les options de configuration suivantes sont supportées pour
    l'authentification <productname>peer</productname>&nbsp;:
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        Autorise la mise en correspondance entre le nom d'utilisateur
        fourni par le système d'exploitation et 
	le nom d'utilisateur pour la base de données. Voir 
        <xref linkend="auth-username-maps"/> pour plus de détails.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
 
   <para>
    L'authentification peer n'est disponible que sur les systèmes
    d'exploitation fournissant la fonction <function>getpeereid()</function>,
    le paramètre <symbol>SO_PEERCRED</symbol> pour les sockets ou un
    mécanisme similaire. Actuellement, cela inclut <systemitem
    class="osname">Linux</systemitem>, la plupart des variantes
    <systemitem class="osname">BSD</systemitem> (et donc <systemitem
    class="osname">Mac OS X</systemitem>), ainsi que <systemitem
    class="osname">Solaris</systemitem>.
   </para>
  </sect2>

  <sect2 id="auth-ldap">
   <title>Authentification LDAP</title>

   <indexterm zone="auth-ldap">
    <primary>LDAP</primary>
   </indexterm>

   <para>
    Ce mécanisme d'authentification opère de façon similaire à
    <literal>password</literal> à ceci près qu'il utilise LDAP comme
    méthode de vérification des mots de passe.
    LDAP n'est utilisé que pour valider les paires
    nom d'utilisateur/mot de passe. De ce fait, pour pouvoir utiliser LDAP
    comme méthode d'authentification, l'utilisateur doit préalablement exister
    dans la base. 
   </para>

   <para>
    L'authentification LDAP peut opérer en deux modes. Dans le premier mode,
    which we will call the simple bind mode,
    le serveur fera un « bind » sur le nom distingué comme
    <replaceable>préfixe</replaceable> <replaceable>nom_utilisateur</replaceable>
    <replaceable>suffixe</replaceable>.
    Typiquement, le paramètre <replaceable>prefix</replaceable> est utilisé pour spécifier
    <literal>cn=</literal> ou <replaceable>DOMAIN</replaceable><literal>\</literal> dans un
    environnement Active Directory. <replaceable>suffix</replaceable> est utilisé pour spécifier le reste
    du DN dans un environnement autre qu'Active Directory.
   </para>

   <para>
    Dans le second mode, which we will call the search+bind mode,
    le serveur commence un « bind » sur le répertoire
    LDAP avec un nom d'utilisateur et un mot de passe fixés, qu'il indique à
    <replaceable>ldapbinddn</replaceable> et
    <replaceable>ldapbindpasswd</replaceable>. Il réalise une recherche de
    l'utilisateur en essayant de se connecter à la base de données. Si aucun
    utilisateur et aucun mot de passe n'est configuré, un « bind » anonyme
    sera tenté sur le répertoire. La recherche sera réalisée sur le sous-arbre
    sur <replaceable>ldapbasedn</replaceable>, et essaiera une correspondance
    exacte de l'attribut indiqué par
    <replaceable>ldapsearchattribute</replaceable>. Une fois que
    l'utilisateur a été trouvé lors de cette recherche, le serveur se
    déconnecte et effectue un nouveau « bind » au répertoire en tant que
    cet utilisateur, en utilisant le mot de passe indiqué par le client pour
    vérifier que la chaîne de connexion est correcte. This mode is the same as
    that used by LDAP authentication schemes in other software, such as Apache
    mod_authnz_ldap and pam_ldap. Cette méthode permet
    une plus grande flexibilité sur l'emplacement des objets utilisateurs dans
    le répertoire mais demandera deux connexions au serveur LDAP.
   </para>

	<para>
    Les options de configuration suivantes sont utilisées dans les deux modes&nbsp;:
    <variablelist>
     <varlistentry>
      <term><literal>ldapserver</literal></term>
      <listitem>
       <para>
        Noms ou adresses IP des serveurs LDAP auxquels se connecter.
        Plusieurs serveurs peuvent être indiqués, en les séparant par
        des espaces.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapport</literal></term>
      <listitem>
       <para>
        Numéro de port du serveur LDAP auquel se connecter. Si aucun port
        n'est spécifié, le port par défaut de la bibliothèque LDAP sera utilisé.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldaptls</literal></term>
      <listitem>
       <para>
        Positionnez à 1 pour que la connexion entre PostgreSQL et le serveur
        LDAP utilise du chiffrage TLS. Notez que ceci ne chiffre que le trafic
        jusqu'au serveur LDAP &mdash; la connexion vers le client peut toujours ne
        pas être chiffrée sauf si SSL est utilisé.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    The following options are used in simple bind mode only:
    <variablelist>
     <varlistentry>
      <term><literal>ldapprefix</literal></term>
      <listitem>
       <para>
        Chaîne à préfixer au nom de l'utilisateur pour former le DN utilisé
        comme lien lors d'une simple authentification
        <foreignphrase>bind</foreignphrase>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapsuffix</literal></term>
      <listitem>
       <para>
        Chaîne à suffixer au nom de l'utilisateur pour former le DN utilisé
        comme lien lors d'une simple authentification
        <foreignphrase>bind</foreignphrase>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    The following options are used in search+bind mode only:
    <variablelist>
     <varlistentry>
      <term><literal>ldapbasedn</literal></term>
      <listitem>
       <para>
        Racine DN pour commencer la recherche de l'utilisateur lors d'une
        authentification <foreignphrase>search+bind</foreignphrase>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapbinddn</literal></term>
      <listitem>
       <para>
        DN de l'utilisateur pour se lier au répertoire avec lequel effectuer
        la recherche lors d'une authentification
        <foreignphrase>search+bind</foreignphrase>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapbindpasswd</literal></term>
      <listitem>
       <para>
        Mot de passe de l'utilisateur pour se lier au répertoire avec lequel
        effectuer la recherche lors d'une authentification
        <foreignphrase>search+bind</foreignphrase>.
       </para>
      </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapsearchattribute</literal></term>
       <listitem>
        <para>
         Attribut à faire correspondre au nom d'utilisateur dans la recherche
         lors d'une authentification <foreignphrase>search+bind</foreignphrase>.
         If no attribute is specified, the
         <literal>uid</literal> attribute will be used.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapurl</literal></term>
       <listitem>
        <para>
         An RFC 4516 LDAP URL.  This is an alternative way to write some of the
         other LDAP options in a more compact and standard form.  The format is
<synopsis>
ldap://<replaceable>host</replaceable>[:<replaceable>port</replaceable>]/<replaceable>basedn</replaceable>[?[<replaceable>attribute</replaceable>][?[<replaceable>scope</replaceable>]]]
</synopsis>
         <replaceable>scope</replaceable> must be one
         of <literal>base</literal>, <literal>one</literal>, <literal>sub</literal>,
         typically the latter.  Only one attribute is used, and some other
         components of standard LDAP URLs such as filters and extensions are
         not supported.
        </para>

        <para>
         For non-anonymous binds, <literal>ldapbinddn</literal>
         and <literal>ldapbindpasswd</literal> must be specified as separate
         options.
        </para>

        <para>
         To use encrypted LDAP connections, the <literal>ldaptls</literal>
         option has to be used in addition to <literal>ldapurl</literal>.
         The <literal>ldaps</literal> URL scheme (direct SSL connection) is not
         supported.
        </para>

        <para>
         LDAP URLs are currently only supported with OpenLDAP, not on Windows.
        </para>
       </listitem>
      </varlistentry>
    </variablelist>
   </para>

   <para>
    It is an error to mix configuration options for simple bind with options
    for search+bind.
   </para>

   <para>
    Here is an example for a simple-bind LDAP configuration:
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapprefix="cn=" ldapsuffix=", dc=example, dc=net"
</programlisting>
    When a connection to the database server as database
    user <literal>someuser</literal> is requested, PostgreSQL will attempt to
    bind to the LDAP server using the DN <literal>cn=someuser, dc=example,
    dc=net</literal> and the password provided by the client.  If that connection
    succeeds, the database access is granted.
   </para>

   <para>
    Here is an example for a search+bind configuration:
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchattribute=uid
</programlisting>
    When a connection to the database server as database
    user <literal>someuser</literal> is requested, PostgreSQL will attempt to
    bind anonymously (since <literal>ldapbinddn</literal> was not specified) to
    the LDAP server, perform a search for <literal>(uid=someuser)</literal>
    under the specified base DN.  If an entry is found, it will then attempt to
    bind using that found information and the password supplied by the client.
    If that second connection succeeds, the database access is granted.
   </para>

   <para>
    Here is the same search+bind configuration written as a URL:
<programlisting>
host ... ldap lapurl="ldap://ldap.example.net/dc=example,dc=net?uid?sub"
</programlisting>
    Some other software that supports authentication against LDAP uses the
    same URL format, so it will be easier to share the configuration.
   </para>

   <tip>
    <para>
     Comme LDAP utilise souvent des virgules et des espaces pour séparer
     les différentes parties d'un DN, il est souvent nécessaire d'utiliser
     des paramètres entourés de guillements durant le paramétrage des options
     LDAP, comme montré dans les exemples.
    </para>
   </tip>

  </sect2>

  <sect2 id="auth-radius">
   <title>Authentification RADIUS</title>

   <indexterm zone="auth-radius">
    <primary>RADIUS</primary>
   </indexterm>

   <para>
    Cette méthode d'authentification opère de façon similaire à
    <literal>password</literal> sauf qu'il existe la méthode RADIUS pour la
    vérification du mot de passe. RADIUS est seulement utilisé pour valider
    des pairs nom utilisateur / mot de passe. Du coup, l'utilisateur doit déjà
    exister dans la base de données avant que RADIUS puisse être utilisé pour
    l'authentification.
   </para>

   <para>
    Lors de l'utilisation de l'authentification RADIUS, un message de demande
    d'accès (<foreignphrase>Access Request</foreignphrase>) sera envoyé au
    serveur RADIUS configuré. Cette demande sera du type
    <quote>authentification seule</quote> (<literal>Authenticate Only</literal>)
    et incluera les paramètres pour le nom de l'utilisateur, son mot de passe
    (chiffré) et un identifiant NAS (<literal>NAS Identifier</literal>). La
    demande sera chiffrée en utilisant un secret partagé avec le serveur. Le
    serveur RADIUS répondre au serveur soit la réussite (<literal>Access
    Accept</literal>) soit l'échec (<literal>Access Reject</literal>) de
    l'accès. Il n'y a pas de support des comptes RADIUS.
   </para>

   <para>
    Les options de configuration suivantes sont supportées par RADIUS&nbsp;:
     <variablelist>
      <varlistentry>
       <term><literal>radiusserver</literal></term>
       <listitem>
        <para>
         Le nom ou l'adresse IP sur serveur RADIUS pour l'authentification. Ce
         paramètre est requis.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiussecret</literal></term>
       <listitem>
        <para>
         Le secret partagé utilisé lors de discussions sécurisées avec le
         serveur RADIUS. Il doit y avoir exactement la même valeur sur le
         serveur PostgreSQL et sur le serveur RADIUS. Il est recommandé
         d'utiliser une chaîne d'au moins 16 caractères. Ce paramètre est
         requis.
         <note>
         <para>
          Le vecteur de chiffrement utilisé sera un chiffrement fort seulement
          si <productname>PostgreSQL</productname> a été compilé avec le
          support d'<productname>OpenSSL</productname>. Dans les autres cas,
          la transmission au serveur RADIUS peut seulement être considérée
          comme caché, et non pas sécurisé, et des mesures de sécurité
          externes doivent être appliquées si nécessaire.
         </para>
         </note>
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiusport</literal></term>
       <listitem>
        <para>
         Le numéro de port sur le serveur RADIUS pour la connexion. Si aucun
         port n'est indiqué, le port par défaut, <literal>1812</literal>, sera
         utilisé.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiusidentifier</literal></term>
       <listitem>
        <para>
         La chaîne utilisée comme identifiant NAS (<literal>NAS
         Identifier</literal>) dans les demandes RADIUS. Ce paramètre peut
         être utilisé comme second paramètre identifiant par exemple
         l'utilisateur de bases de données pour la connexion. C'est utilisable
         pour des vérifications sur le serveur RADIUS. Si aucune identifiant
         n'est spécifié, la valeur par défaut, <literal>postgresql</literal>,
         sera utilisée.
        </para>
       </listitem>
      </varlistentry>

     </variablelist>
   </para>
  </sect2>

  <sect2 id="auth-cert">
   <title>Authentification de certificat</title>

   <indexterm zone="auth-cert">
    <primary>Certificat</primary>
   </indexterm>

   <para>
    Cette méthode d'authentification utilise des clients SSL pour procéder
    à l'authentification. Elle n'est par conséquent disponible que pour
    les connexions SSL. Quand cette méthode est utilisée, le serveur
    exigera que le client fournisse un certificat valide. Aucune invite de saisie
    de mot de passe ne sera envoyée au client. L'attribut <literal>cn</literal>
    (<acronym>Common Name</acronym>) du certificat sera comparé au nom
    d'utilisateur de base de données demandé.
    S'ils correspondent, la connexion sera autorisée. La correspondance des
    noms d'utilisateurs peut être utilisé pour permettre au
    <literal>cn</literal> d'être différent du nom d'utilisateur de la base de
    données.
   </para>

   <para>
    Les options de configuration suivantes sont supportées pour
    l'authentification par certificat SSL&nbsp;:
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        Permet la correspondance entre les noms d'utilisateur système et les
	noms d'utilisateurs de bases de données. Voir <xref
	linkend="auth-username-maps"/> pour les détails.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   
  </sect2>

  <sect2 id="auth-pam"> <title>Authentification PAM</title>

   <indexterm zone="auth-pam">
    <primary>PAM</primary>
   </indexterm>

   <para>
    Ce mécanisme d'authentification fonctionne de façon similaire à
    <literal>password</literal> à ceci près qu'il utilise PAM (Pluggable
    Authentication Modules) comme méthode d'authentification. Le nom du
    service PAM par défaut est <literal>postgresql</literal>. PAM n'est utilisé que pour valider
    des paires nom utilisateur/mot de passe. De ce fait, avant de pouvoir
    utiliser PAM pour l'authentification, l'utilisateur doit préalablement
    exister dans la base de données. Pour plus d'informations sur PAM,
    merci de lire la
    <ulink url="http://www.kernel.org/pub/linux/libs/pam/">page
    <productname>Linux-PAM</productname></ulink>.
   </para>

   <para>
    Les options suivantes sont supportées pour PAM&nbsp;:
    <variablelist>
     <varlistentry>
      <term><literal>pamservice</literal></term>
      <listitem>
       <para>
        Nom de service PAM.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <note>
    <para>
     Si PAM est configuré pour lire <filename>/etc/shadow</filename>,
     l'authentification échoue car le serveur PostgreSQL est exécuté en
     tant qu'utilisateur standard. Ce n'est toutefois pas un problème
     quand PAM est configuré pour utiliser LDAP ou les autres méthodes
     d'authentification.
    </para>
   </note>
  </sect2>
 </sect1>

  <sect1 id="client-authentication-problems"> <title>Problèmes d'authentification</title>

   <para>
    Les erreurs et problèmes d'authentification se manifestent
    généralement par des messages d'erreurs tels que ceux qui suivent.
   </para>

   <para>
<programlisting>FATAL:  no pg_hba.conf entry for host "123.123.123.123", user "andym", database "testdb"</programlisting>
    ou, en français, 
<programlisting>FATAL:  pas d'entrée pg_hba.conf pour l'hôte "123.123.123.123", utilisateur "andym", base "testdb"</programlisting>
    C'est le message le plus probable lorsque le contact peut être établi avec le
    serveur mais qu'il refuse de communiquer. Comme le suggère le message,
    le serveur a refusé la demande de connexion parce qu'il n'a trouvé aucune
    entrée correspondante dans son fichier de configuration
    <filename>pg_hba.conf</filename>.
   </para>

   <para>
<programlisting>FATAL:  password authentication failed for user "andym"</programlisting>
    ou, en français, 
<programlisting>FATAL:  l'authentification par mot de passe a échoué pour l'utilisateur "andym"</programlisting>
    Les messages de ce type indiquent que le serveur a été contacté et
    qu'il accepte la communication, mais pas avant que la méthode
    d'authentification indiquée dans le fichier
    <filename>pg_hba.conf</filename> n'ait été franchie avec succès.
    Le mot de passe fourni, le logiciel d'identification ou le logiciel
    Kerberos doivent être vérifiés en fonction du type d'authentification
    mentionné dans le message d'erreur.
   </para>

   <para>
<programlisting>FATAL:  user "andym" does not exist</programlisting>
    ou, en français, 
<programlisting>FATAL:  l'utilisateur "andym" n'existe pas</programlisting>
    Le nom d'utilisateur indiqué n'a pas été trouvé.
   </para>

   <para>
<programlisting>FATAL:  database "testdb" does not exist</programlisting>
    ou, en français,
<programlisting>FATAL:  la base "testdb" n'existe pas</programlisting>
    La base de données utilisée pour la tentative de connexion n'existe pas.
    Si aucune base n'est précisée, le nom de la base par défaut est le
    nom de l'utilisateur, ce qui peut être approprié ou non.
   </para>

   <tip>
    <para>
     Les traces du serveur contiennent plus d'informations sur une erreur
     d'authentification que ce qui est rapporté au client. En cas de doute
     sur les raisons d'un échec, il peut s'avérer utile de les consulter.
    </para>
   </tip>

</sect1>

</chapter>
