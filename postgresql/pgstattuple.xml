<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<sect1 id="pgstattuple" xreflabel="pgstattuple">
 <title>pgstattuple</title>

 <para>
  Le module <filename>pgstattuple</filename> fournit plusieurs fonctions pour
  obtenir des statistiques au niveau ligne.
 </para>

 <sect2>
  <title>Fonctions</title>

  <variablelist>
   <varlistentry>
    <term>
     <function>pgstattuple(text) returns record</function>
     <indexterm zone="pgstattuple">
      <primary>pgstattuple</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>pgstattuple</function> renvoie la longueur physique d'une
      relation, le pourcentage des lignes <quote>mortes</quote>, et d'autres
      informations. Ceci peut aider les utilisateurs à déterminer si une
      opération de VACUUM est nécessaire. L'argument est le nom de la relation
      cible (qui peut être qualifié par le nom du schéma) ou l'OID.
      Par exemple&nbsp;:
      <programlisting>
test=> SELECT * FROM pgstattuple('pg_catalog.pg_proc');
-[ RECORD 1 ]------+-------
table_len          | 458752
tuple_count        | 1470
tuple_len          | 438896
tuple_percent      | 95.67
dead_tuple_count   | 11
dead_tuple_len     | 3157
dead_tuple_percent | 0.69
free_space         | 8932
free_percent       | 1.95
      </programlisting>
      Les colonnes en sortie sont décrites dans <xref linkend="pgstattuple-columns"/>.
     </para>

     <table id="pgstattuple-columns">
      <title>Colonnes de <function>pgstattuple</function></title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Colonne</entry>
         <entry>Type</entry>
         <entry>Description</entry>
        </row>
       </thead>

       <tbody>
        <row>
         <entry><structfield>table_len</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Longueur physique de la relation en octets</entry>
        </row>
        <row>
         <entry><structfield>tuple_count</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Nombre de lignes vivantes</entry>
        </row>
        <row>
         <entry><structfield>tuple_len</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Longueur totale des lignes vivantes en octets</entry>
        </row>
        <row>
         <entry><structfield>tuple_percent</structfield></entry>
         <entry><type>float8</type></entry>
         <entry>Pourcentage des lignes vivantes</entry>
        </row>
        <row>
         <entry><structfield>dead_tuple_count</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Nombre de lignes mortes</entry>
        </row>
        <row>
         <entry><structfield>dead_tuple_len</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Longueur totale des lignes mortes en octets</entry>
        </row>
        <row>
         <entry><structfield>dead_tuple_percent</structfield></entry>
         <entry><type>float8</type></entry>
         <entry>Pourcentage des lignes mortes</entry>
        </row>
        <row>
         <entry><structfield>free_space</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Espace libre total en octets</entry>
        </row>
        <row>
         <entry><structfield>free_percent</structfield></entry>
         <entry><type>float8</type></entry>
         <entry>Pourcentage de l'espace libre</entry>
        </row>

       </tbody>
      </tgroup>
     </table>

     <para>
      <function>pgstattuple</function> acquiert seulement un verrou en lecture
      sur la relation. Donc les relations ne reflètent pas une image
      instantanée&nbsp; des mises à jour en parallèle peuvent les affecter.
     </para>

     <para>
      <function>pgstattuple</function> juge qu'une ligne est
      <quote>morte</quote> si <function>HeapTupleSatisfiesDirty</function> renvoie
      false.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <indexterm>
     <primary>pgstattuple</primary>
    </indexterm>

    <term>
     <function>pgstattuple(text) returns record</function>
    </term>

    <listitem>
     <para>
      Identique à <function>pgstattuple(regclass)</function>, sauf que la relation
      cible est désignée en tant que TEXT.  Cette fonction est conservée pour
      raison de compatibilité ascendante, et sera dépréciée dans la prochaine
      version.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <indexterm>
     <primary>pgstatindex</primary>
    </indexterm>
    <term>
     <function>pgstatindex(regclass) returns record</function>
    </term>

    <listitem>
     <para>
      <function>pgstatindex</function> renvoie un enregistrement affichant des
      informations sur un index B-Tree. Par exemple&nbsp;:
     </para>
     <programlisting>
test=> SELECT * FROM pgstatindex('pg_cast_oid_index');
-[ RECORD 1 ]------+------
version            | 2
tree_level         | 0
index_size         | 8192
root_block_no      | 1
internal_pages     | 0
leaf_pages         | 1
empty_pages        | 0
deleted_pages      | 0
avg_leaf_density   | 50.27
leaf_fragmentation | 0
     </programlisting>

     <para>
      En voici les colonnes:
     </para>

     <informaltable>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Colonne</entry>
         <entry>Type</entry>
         <entry>Description</entry>
        </row>
       </thead>

       <tbody>
        <row>
         <entry><structfield>version</structfield></entry>
         <entry><type>integer</type></entry>
         <entry>Numéro de version du B-tree</entry>
        </row>

        <row>
         <entry><structfield>tree_level</structfield></entry>
         <entry><type>integer</type></entry>
         <entry>Niveau de l'arbre pour la page racine</entry>
        </row>

        <row>
         <entry><structfield>index_size</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Nombre total de page dans l'index</entry>
        </row>

        <row>
         <entry><structfield>root_block_no</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Enmplacement du bloc racine</entry>
        </row>

        <row>
         <entry><structfield>internal_pages</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Nombre de pages <quote>internes</quote> (niveau
          supérieur)</entry>
        </row>

        <row>
         <entry><structfield>leaf_pages</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Nombre de pages feuilles</entry>
        </row>

        <row>
         <entry><structfield>empty_pages</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Nombre de pages vides</entry>
        </row>

        <row>
         <entry><structfield>deleted_pages</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Nombre de pages supprimées</entry>
        </row>

        <row>
         <entry><structfield>avg_leaf_density</structfield></entry>
         <entry><type>float8</type></entry>
         <entry>Densité moyenne des pages feuilles</entry>
        </row>

        <row>
         <entry><structfield>leaf_fragmentation</structfield></entry>
         <entry><type>float8</type></entry>
         <entry>Fragmentation des pages feuilles</entry>
        </row>

       </tbody>
      </tgroup>
     </informaltable>

     <para>
      Comme pour <function>pgstattuple</function>, les résultats sont
      accumulés page par page, et ne représentent pas forcément une image
      instantanée de l'index complet.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>pgstatindex(text) returns record</function>
    </term>

    <listitem>
     <para>
      Identique à <function>pgstatindex(regclass)</function>, sauf que l'index
      cible est spécifié en tant que TEXT.  Cette fonction est conservée pour
      raison de compatibilité ascendante, et sera dépréciée dans la prochaine
      version.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <indexterm>
      <primary>pgstatginindex</primary>
     </indexterm>
     <function>pgstatginindex(regclass) returns record</function>
    </term>

    <listitem>
     <para>
      <function>pgstatginindex</function> renvoie un enregistrement montrant
      les informations sur un index GIN. Par exemple&nbsp;:
      <programlisting>
test=> SELECT * FROM pgstatginindex('test_gin_index');
-[ RECORD 1 ]--+--
version        | 1
pending_pages  | 0
pending_tuples | 0
      </programlisting>
     </para>

     <para>
      Les colonnes en sortie sont&nbsp;:

      <informaltable>
       <tgroup cols="3">
        <thead>
         <row>
          <entry>Colonne</entry>
          <entry>Type</entry>
          <entry>Description</entry>
         </row>
        </thead>

        <tbody>
         <row>
          <entry><structfield>version</structfield></entry>
          <entry><type>integer</type></entry>
          <entry>Numéro de version GIN</entry>
         </row>

         <row>
          <entry><structfield>pending_pages</structfield></entry>
          <entry><type>integer</type></entry>
          <entry>Nombre de pages dans la liste en attente</entry>
         </row>

         <row>
          <entry><structfield>pending_tuples</structfield></entry>
          <entry><type>bigint</type></entry>
          <entry>Nombre de lignes dans la liste en attente</entry>
         </row>

        </tbody>
       </tgroup>
      </informaltable>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <indexterm>
     <primary>pg_relpages</primary>
    </indexterm>
    <term>
     <function>pg_relpages(regclass) returns bigint</function>
    </term>

    <listitem>
     <para>
      <function>pg_relpages</function> renvoie le nombre de pages dans la
      relation.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>pg_relpages(text) returns bigint</function>
    </term>

    <listitem>
     <para>
      Identique à <function>pg_relpages(regclass)</function>, sauf que la
      relation cible est spécifiée en tant que TEXT. Cette fonction est
      conservée pour raison de compatibilité ascendante, et sera
      dépréciée dans la prochaine version.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <indexterm>
      <primary>pgstattuple_approx</primary>
     </indexterm>
     <function>pgstattuple_approx(regclass) returns record</function>
    </term>

    <listitem>
     <para>
      <function>pgstattuple_approx</function> is a faster alternative to
      <function>pgstattuple</function> that returns approximate results.
      The argument is the target relation's OID.
      For example:
<programlisting>
test=> SELECT * FROM pgstattuple_approx('pg_catalog.pg_proc'::regclass);
-[ RECORD 1 ]--------+-------
table_len            | 573440
scanned_percent      | 2
approx_tuple_count   | 2740
approx_tuple_len     | 561210
approx_tuple_percent | 97.87
dead_tuple_count     | 0
dead_tuple_len       | 0
dead_tuple_percent   | 0
approx_free_space    | 11996
approx_free_percent  | 2.09
</programlisting>
      The output columns are described in <xref linkend="pgstatapprox-columns"/>.
     </para>

     <para>
      Whereas <function>pgstattuple</function> always performs a
      full-table scan and returns an exact count of live and dead tuples
      (and their sizes) and free space, <function>pgstattuple_approx</function>
      tries to avoid the full-table scan and returns exact dead tuple
      statistics along with an approximation of the number and
      size of live tuples and free space.
     </para>

     <para>
      It does this by skipping pages that have only visible tuples
      according to the visibility map (if a page has the corresponding VM
      bit set, then it is assumed to contain no dead tuples). For such
      pages, it derives the free space value from the free space map, and
      assumes that the rest of the space on the page is taken up by live
      tuples.
     </para>

     <para>
      For pages that cannot be skipped, it scans each tuple, recording its
      presence and size in the appropriate counters, and adding up the
      free space on the page. At the end, it estimates the total number of
      live tuples based on the number of pages and tuples scanned (in the
      same way that VACUUM estimates pg_class.reltuples).
     </para>

     <table id="pgstatapprox-columns">
      <title><function>pgstattuple_approx</function> Output Columns</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Column</entry>
         <entry>Type</entry>
         <entry>Description</entry>
        </row>
       </thead>

       <tbody>
        <row>
         <entry><structfield>table_len</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Physical relation length in bytes (exact)</entry>
        </row>
        <row>
         <entry><structfield>scanned_percent</structfield></entry>
         <entry><type>float8</type></entry>
         <entry>Percentage of table scanned</entry>
        </row>
        <row>
         <entry><structfield>approx_tuple_count</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Number of live tuples (estimated)</entry>
        </row>
        <row>
         <entry><structfield>approx_tuple_len</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Total length of live tuples in bytes (estimated)</entry>
        </row>
        <row>
         <entry><structfield>approx_tuple_percent</structfield></entry>
         <entry><type>float8</type></entry>
         <entry>Percentage of live tuples</entry>
        </row>
        <row>
         <entry><structfield>dead_tuple_count</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Number of dead tuples (exact)</entry>
        </row>
        <row>
         <entry><structfield>dead_tuple_len</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Total length of dead tuples in bytes (exact)</entry>
        </row>
        <row>
         <entry><structfield>dead_tuple_percent</structfield></entry>
         <entry><type>float8</type></entry>
         <entry>Percentage of dead tuples</entry>
        </row>
        <row>
         <entry><structfield>approx_free_space</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Total free space in bytes (estimated)</entry>
        </row>
        <row>
         <entry><structfield>approx_free_percent</structfield></entry>
         <entry><type>float8</type></entry>
         <entry>Percentage of free space</entry>
        </row>

       </tbody>
      </tgroup>
     </table>

     <para>
      In the above output, the free space figures may not match the
      <function>pgstattuple</function> output exactly, because the free
      space map gives us an exact figure, but is not guaranteed to be
      accurate to the byte.
     </para>

    </listitem>
   </varlistentry>

  </variablelist>
 </sect2>

 <sect2>
  <title>Auteurs</title>

  <para>
   Tatsuo Ishii, Satoshi Nagayasu et Abhijit Menon-Sen
  </para>
 </sect2>

</sect1>
