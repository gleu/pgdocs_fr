<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<sect1 id="xml2" xreflabel="xml2">
 <title>xml2</title>

 <indexterm zone="xml2">
  <primary>xml2</primary>
 </indexterm>

 <para>
  Le module <filename>xml2</filename> fournit des fonctionnalités pour les
  requêtes XPath et pour XSLT.
 </para>

 <sect2>
  <title>Notice d'obsolescence</title>

  <para>
   À partir de <productname>PostgreSQL</productname> 8.3, les fonctionnalités
   XML basées sur le standard SQL/XML sont dans le cœur du serveur. Cela couvre
   la vérification de la syntaxe XML et les requêtes XPath, ce que fait aussi
   ce module (en dehors d'autres choses) mais l'API n'est pas du tout
   compatible. Il est prévu que ce module soit supprimé dans une future version
   de PostgreSQL
   pour faire place à une nouvelle API standard, donc vous êtes encouragés à
   convertir vos applications. Si vous trouvez que des fonctionnalités de ce
   module ne sont pas disponibles dans un format adéquat avec la nouvelle API,
   merci d'expliquer votre problème sur la liste <email>pgsql-hackers@lists.postgresql.org</email>
   pour que ce problème soit corrigé.
  </para>
 </sect2>

 <sect2>
  <title>Description des fonctions</title>

  <para>
   <xref linkend="xml2-functions-table"/> montre les fonctions fournies par ce
   module. Ces fonctions fournissent une analyse XML et les requêtes XPath.
  </para>

  <table id="xml2-functions-table">
   <title>Fonctions <filename>xml2</filename></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Fonction
       </para>
       <para>
        Description
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>xml_valid</function> ( <parameter>document</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Parses the given document and returns true if the
        document is well-formed XML.  (Note: this is an alias for the standard
        PostgreSQL function <function>xml_is_well_formed()</function>.  The
        name <function>xml_valid()</function> is technically incorrect since validity
        and well-formedness have different meanings in XML.)
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>xpath_string</function> ( <parameter>document</parameter> <type>text</type>, <parameter>query</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Evaluates the XPath query on the supplied document, and
        casts the result to <type>text</type>.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>xpath_number</function> ( <parameter>document</parameter> <type>text</type>, <parameter>query</parameter> <type>text</type> )
        <returnvalue>real</returnvalue>
       </para>
       <para>
        Evaluates the XPath query on the supplied document, and
        casts the result to <type>real</type>.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>xpath_bool</function> ( <parameter>document</parameter> <type>text</type>, <parameter>query</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Evaluates the XPath query on the supplied document, and
        casts the result to <type>boolean</type>.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>xpath_nodeset</function> ( <parameter>document</parameter> <type>text</type>, <parameter>query</parameter> <type>text</type>, <parameter>toptag</parameter> <type>text</type>, <parameter>itemtag</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Evaluates the query on the document and wraps the result in XML
        tags. If the result is multivalued, the output will look like:
<synopsis>
&lt;toptag&gt;
&lt;itemtag&gt;Value 1 which could be an XML fragment&lt;/itemtag&gt;
&lt;itemtag&gt;Value 2....&lt;/itemtag&gt;
&lt;/toptag&gt;
</synopsis>
        If either <parameter>toptag</parameter>
        or <parameter>itemtag</parameter> is an empty string, the relevant tag
        is omitted.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>xpath_nodeset</function> ( <parameter>document</parameter> <type>text</type>, <parameter>query</parameter> <type>text</type>, <parameter>itemtag</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Like <function>xpath_nodeset(document, query, toptag, itemtag)</function> but result omits <parameter>toptag</parameter>.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>xpath_nodeset</function> ( <parameter>document</parameter> <type>text</type>, <parameter>query</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Like <function>xpath_nodeset(document, query, toptag, itemtag)</function> but result omits both tags.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>xpath_list</function> ( <parameter>document</parameter> <type>text</type>, <parameter>query</parameter> <type>text</type>, <parameter>separator</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Evaluates the query on the document and returns multiple values
        separated by the specified separator, for example <literal>Value
        1,Value 2,Value 3</literal> if <parameter>separator</parameter>
        is <literal>,</literal>.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>xpath_list</function> ( <parameter>document</parameter> <type>text</type>, <parameter>query</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        This is a wrapper for the above function that uses <literal>,</literal>
        as the separator.
       </para></entry>
      </row>
     </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2>
  <title><literal>xpath_table</literal></title>

  <indexterm>
   <primary>xpath_table</primary>
  </indexterm>

  <synopsis>
   xpath_table(text key, text document, text relation, text xpaths, text criteria) returns setof record
  </synopsis>

  <para>
   <function>xpath_table</function> est une fonction <acronym>SRF</acronym>
   qui évalue un ensemble
   de requêtes XPath sur chaque ensemble de documents et renvoie les résultats
   comme une table. Le champ de clé primaire de la table des documents est
   renvoyé comme première colonne des résultats pour que les résultats
   puissent être utilisés dans des jointures. Les pamraètres sont décrits dans
   <xref linkend="xml2-xpath-table-parameters"/>.
  </para>

  <table id="xml2-xpath-table-parameters">
   <title>Paramètres de <function>xpath_table</function></title>
   <tgroup cols="2">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="2*"/>
    <thead>
     <row>
      <entry>Paramètre</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><parameter>key</parameter></entry>
      <entry>
       <para>
        Le nom du champ de la clé primaire (<quote>key</quote>). C'est
        simplement le champ à utiliser comme première colonne de la table en
        sortie, autrement dit celle qui identifie l'enregistrement (voir la
        note ci-dessous sur les valeurs multiples).
       </para>
      </entry>
     </row>
     <row>
      <entry><parameter>document</parameter></entry>
      <entry>
       <para>
        Le nom du champ contenant le document XML.
       </para>
      </entry>
     </row>
     <row>
      <entry><parameter>relation</parameter></entry>
      <entry>
       <para>
        Le nom de la table ou de la vue contenant les documents.
       </para>
      </entry>
     </row>
     <row>
      <entry><parameter>xpaths</parameter></entry>
      <entry>
       <para>
        Une ou plusieurs expressions XPath séparées par des <literal>|</literal>
       </para>
      </entry>
     </row>
     <row>
      <entry><parameter>criteria</parameter></entry>
      <entry>
       <para>
        Le contenu de la clause WHERE. Elle doit être spécifiée, donc
        utilisez <literal>true</literal> ou <literal>1=1</literal> si vous
        voulez traiter toutes les lignes de la relation.
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Ces paramètres (en dehors des chaînes XPath) sont simplement substitués dans
   une instruction SELECT, donc vous avez de la flexibilité. L'instruction
   est celle qui suit&nbsp;:
  </para>

  <para>
   <literal>
    SELECT &lt;key&gt;, &lt;document&gt; FROM &lt;relation&gt; WHERE &lt;criteria&gt;
   </literal>
  </para>

  <para>
   Donc les paramètres peuvent être <emphasis>tout</emphasis> ce qui est
   valide dans ces
   emplacements particuliers. Le résultat de ce SELECT a besoin de renvoyer
   exactement deux colonnes (ce qu'il fera sauf si vous essayez d'indiquer
   plusieurs champs pour la clé ou le document). Cette approche simpliste
   implique que vous validiez avant tout valeur fournie par un utilisateur
   pour éviter les attaques par injection de code SQL.
  </para>

  <para>
   La fonction doit être utilisée dans une expression <literal>FROM</literal>
   avec une clause <literal>AS</literal> pour indiquer les colonnes en sortie.
   Par exemple&nbsp;:
  </para>

  <programlisting>
SELECT * FROM
xpath_table('article_id',
            'article_xml',
            'articles',
            '/article/author|/article/pages|/article/title',
            'date_entered > ''2003-01-01'' ')
AS t(article_id integer, author text, page_count integer, title text);
  </programlisting>

  <para>
   La clause <literal>AS</literal> définit les noms et types des colonnes de
   la table en sortie. La première est le champ <quote>key</quote> et le reste
   correspond à la requête XPath.
   S'il y a plus de requêtes XPath que de colonnes résultats, les requêtes
   supplémentaires seront ignorées, S'il y a plus de colonnes résultats que
   de requêtes XPath, les colonnes supplémentaires seront NULL.
  </para>

  <para>
   Notez que cet exemple définit la colonne résultat
   <structname>page_count</structname> en tant qu'entier (integer). La
   fonction gère en interne les représentations textes, donc quand vous
   dites que vous voulez un entier en sortie, il prendra la représentation
   texte du résultat XPath et utilisera les fonctions en entrée de
   PostgreSQL pour la transformer en entier (ou tout type que la clause
   <type>AS</type> réclame). Vous obtiendrez une erreur s'il ne peut pas le
   faire &mdash; par exemple si le résultat est vide &mdash; donc rester sur
   du texte est préférable si vous pensez que vos données peuvent poser
   problème.
  </para>

  <para>
   L'instruction SELECT n'a pas besoin d'être un <literal>SELECT *</literal>.
   Elle peut référencer les colonnes par nom ou les joindre à d'autres tables.
   La fonction produit une table virtuelle avec laquelle vous pouvez réaliser
   toutes les opérations que vous souhaitez (c'est-à-dire agrégation, jointure,
   tri, etc.)
   Donc nous pouvons aussi avoir&nbsp;:
  </para>

  <programlisting>
SELECT t.title, p.fullname, p.email
FROM xpath_table('article_id', 'article_xml', 'articles',
                 '/article/title|/article/author/@id',
                 'xpath_string(article_xml,''/article/@date'') > ''2003-03-20'' ')
       AS t(article_id integer, title text, author_id integer),
     tblPeopleInfo AS p
WHERE t.author_id = p.person_id;
  </programlisting>

  <para>
   comme exemple plus compliqué. Bien sûr, vous pouvez placer tout ceci dans
   une vue pour une utilisation plus simple.
  </para>

  <sect3>
   <title>Résultats à plusieurs valeurs</title>

   <para>
    La fonction <function>xpath_table</function> suppose que les résultats de
    chaque requête XPath ramènent plusieurs valeurs, donc le nombre de lignes
    renvoyées par la fonction pourrait ne pas être le même que le nombre de
    documents en entrée. La première ligne renvoyée contient le premier
    résultat de chaque requête, la deuxième le second résultat de chaque
    requête. Si une res requêtes a moins de valeur que les autres, des valeurs
    NULL seront renvoyées.
   </para>

   <para>
    Dans certains cas, un utilisateur saura qu'une requête XPath renverra
    seulement un seul résultat, peut-être un identifiant unique de document)
    &mdash; si elle est utilisée avec une requête XPath renvoyant plusieurs
    résultats, le résultat sur une ligne apparaîtra seulement sur la première
    ligne du résultat. La solution à cela est d'utiliser le champ clé pour
    une jointure avec une requête XPath. Comme exemple&nbsp;:
   </para>

   <programlisting>
    CREATE TABLE test (
        id int PRIMARY KEY,
        xml text
    );

    INSERT INTO test VALUES (1, '&lt;doc num="C1"&gt;
    &lt;line num="L1"&gt;&lt;a&gt;1&lt;/a&gt;&lt;b&gt;2&lt;/b&gt;&lt;c&gt;3&lt;/c&gt;&lt;/line&gt;
    &lt;line num="L2"&gt;&lt;a&gt;11&lt;/a&gt;&lt;b&gt;22&lt;/b&gt;&lt;c&gt;33&lt;/c&gt;&lt;/line&gt;
    &lt;/doc&gt;');

    INSERT INTO test VALUES (2, '&lt;doc num="C2"&gt;
    &lt;line num="L1"&gt;&lt;a&gt;111&lt;/a&gt;&lt;b&gt;222&lt;/b&gt;&lt;c&gt;333&lt;/c&gt;&lt;/line&gt;
    &lt;line num="L2"&gt;&lt;a&gt;111&lt;/a&gt;&lt;b&gt;222&lt;/b&gt;&lt;c&gt;333&lt;/c&gt;&lt;/line&gt;
    &lt;/doc&gt;');

    SELECT * FROM
      xpath_table('id','xml','test',
                  '/doc/@num|/doc/line/@num|/doc/line/a|/doc/line/b|/doc/line/c',
                  'true')
      AS t(id int, doc_num varchar(10), line_num varchar(10), val1 int4, val2 int4, val3 int4)
    WHERE id = 1 ORDER BY doc_num, line_num

     id | doc_num | line_num | val1 | val2 | val3
    ----+---------+----------+------+------+------
      1 | C1      | L1       |    1 |    2 |    3
      1 |         | L2       |   11 |   22 |   33
   </programlisting>

   <para>
    Pour obtenir <literal>doc_num</literal> sur chaque ligne, la solution est
    d'utiliser deux appels à <function>xpath_table</function> et joindre les résultats&nbsp;:
   </para>

   <programlisting>
   SELECT t.*,i.doc_num FROM
     xpath_table('id', 'xml', 'test',
                 '/doc/line/@num|/doc/line/a|/doc/line/b|/doc/line/c',
                 'true')
       AS t(id int, line_num varchar(10), val1 int4, val2 int4, val3 int4),
     xpath_table('id', 'xml', 'test', '/doc/@num', 'true')
       AS i(id int, doc_num varchar(10))
   WHERE i.id=t.id AND i.id=1
   ORDER BY doc_num, line_num;

    id | line_num | val1 | val2 | val3 | doc_num
   ----+----------+------+------+------+---------
     1 | L1       |    1 |    2 |    3 | C1
     1 | L2       |   11 |   22 |   33 | C1
   (2 rows)
   </programlisting>
  </sect3>
 </sect2>

 <sect2>
  <title>Fonctions XSLT</title>

  <para>
   Les fonctions suivantes sont disponibles si libxslt est installé.
  </para>

  <sect3>
   <title><literal>xslt_process</literal></title>

   <indexterm>
    <primary>xslt_process</primary>
   </indexterm>

   <synopsis>
    xslt_process(text document, text stylesheet, text paramlist) returns text
   </synopsis>

   <para>
    Cette fonction applique la feuille de style XSLT au document et renvoie
    le résultat transformé. Le paramètre <literal>paramlist</literal> est une
    liste de paramètres
    à utiliser dans la transformation, spécifiée sous la forme
    'a=1,b=2'. Notez que l'analyse des paramètres est simpliste&nbsp;: les
    valeurs des paramètres ne peuvent pas contenir de virgules&nbsp;!
   </para>

   <para>
    Il existe aussi une version de <function>xslt_process</function> à deux
    paramètres qui ne passe pas de paramètres pour la transformation.
   </para>
  </sect3>
 </sect2>

 <sect2>
  <title>Auteur</title>

  <para>
   John Gray <email>jgray@azuli.co.uk</email>
  </para>

  <para>
   Le développement de ce module a été sponsorisé par Torchbox Ltd.
   (www.torchbox.com)
   Il utilise la même licence BSD que PostgreSQL.
  </para>
 </sect2>

</sect1>
