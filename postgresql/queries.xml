<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="queries">
 <title>Requêtes</title>

 <indexterm zone="queries">
  <primary>requête</primary>
 </indexterm>

 <indexterm zone="queries">
  <primary>SELECT</primary>
 </indexterm>

 <para>
  Les précédents chapitres ont expliqué comme créer des tables, comment
  les remplir avec des données et comment manipuler ces données.
  Maintenant, nous discutons enfin de la façon de récupérer ces données
  depuis la base de données.
 </para>


 <sect1 id="queries-overview">
  <title>Aperçu</title>

  <para>
   Le processus et la commande de récupération des données sont appelés une
   <firstterm>requête</firstterm>. En SQL, la commande <xref
   linkend="sql-select"/> est utilisée pour spécifier des requêtes. La
   syntaxe générale de la commande <command>SELECT</command> est
   <synopsis>
<optional>WITH <replaceable>with_requêtes</replaceable></optional> SELECT <replaceable>liste_select</replaceable> FROM <replaceable>expression_table</replaceable> <optional><replaceable>specification_tri</replaceable></optional>
   </synopsis>
   Les sections suivantes décrivent le détail de la liste de sélection,
   l'expression des tables et la spécification du tri. Les requêtes
   <literal>WITH</literal> sont traitées en dernier car il s'agit d'une
   fonctionnalité avancée.
  </para>

  <para>
   Un type de requête simple est de la forme&nbsp;:
   <programlisting>SELECT * FROM table1;</programlisting>
  En supposant qu'il existe une table appelée <literal>table1</literal>, cette
  commande récupérera toutes les lignes et toutes les colonnes, définies par
  l'utilisateur, de
  <literal>table1</literal>. La méthode de récupération dépend de l'application
  cliente. Par exemple, le programme <application>psql</application> affichera
  une table, façon art ASCII, alors que les bibliothèques du client offriront
  des fonctions d'extraction de valeurs individuelles à partir du résultat de
  la requête. <literal>*</literal> comme liste de sélection signifie que toutes
  les colonnes de l'expression de table seront récupérées. Une liste de sélection
  peut aussi être un sous-ensemble des colonnes disponibles ou effectuer
  un calcul en utilisant les colonnes. Par exemple, si <literal>table1</literal>
  dispose des colonnes nommées <literal>a</literal>, <literal>b</literal> et <literal>c</literal> (et
  peut-être d'autres), vous pouvez lancer la requête suivante&nbsp;:
<programlisting>SELECT a, b + c FROM table1;</programlisting>
  (en supposant que <literal>b</literal> et <literal>c</literal> soient de type numérique).
  Voir la <xref linkend="queries-select-lists"/> pour plus de détails.
 </para>

 <para>
  <literal>FROM table1</literal> est un type très simple d'expression de
tables&nbsp;: il lit une seule table. En général, les expressions de tables
sont des constructions complexes de tables de base, de jointures et de
sous-requêtes. Mais vous pouvez aussi entièrement omettre l'expression de table
et utiliser la commande <command>SELECT</command> comme une calculatrice&nbsp;:
<programlisting>SELECT 3 * 4;</programlisting>
  Ceci est plus utile si les expressions de la liste de sélection renvoient des
  résultats variants. Par exemple, vous pouvez appeler une fonction de cette
  façon&nbsp;:
<programlisting>SELECT random();</programlisting>
  </para>
 </sect1>


 <sect1 id="queries-table-expressions">
  <title>Expressions de table</title>

  <indexterm zone="queries-table-expressions">
   <primary>expression de table</primary>
  </indexterm>

  <para>
   Une <firstterm>expression de table</firstterm> calcule une table.
   L'expression de table contient une clause <literal>FROM</literal> qui peut être
   suivie des clauses <literal>WHERE</literal>, <literal>GROUP BY</literal> et
   <literal>HAVING</literal>. Les expressions triviales de table font simplement
   référence à une table sur le disque, une table de base, mais des expressions
   plus complexes peuvent être utilisées pour modifier ou combiner des tables
   de base de différentes façons.
  </para>

  <para>
   Les clauses optionnelles <literal>WHERE</literal>, <literal>GROUP BY</literal> et
   <literal>HAVING</literal> dans l'expression de table spécifient un tube de
   transformations successives réalisées sur la table dérivée de la
   clause <literal>FROM</literal>. Toutes ces transformations produisent une table
   virtuelle fournissant les lignes à passer à la liste de sélection qui
   choisira les lignes à afficher de la requête.
  </para>
	
  <sect2 id="queries-from">
   <title>Clause <literal>FROM</literal></title>

   <para>
    La <xref linkend="sql-from"/> dérive une
    table à partir d'une ou plusieurs tables données dans une liste de
    référence dont les tables sont séparées par des virgules.
<synopsis>FROM <replaceable>reference_table</replaceable> <optional>, <replaceable>reference_table</replaceable> <optional>, ...</optional></optional></synopsis>

    Une référence de table pourrait être un nom de table (avec en option
    le nom du schéma)
    or a derived table such as a subquery, a <literal>JOIN</literal> construct, or
    complex combinations of these.  If more than one table reference is
    listed in the <literal>FROM</literal> clause, the tables are cross-joined
    (that is, the Cartesian product of their rows is formed; see below).
    The result of the <literal>FROM</literal> list is an intermediate virtual
    table that can then be subject to
    transformations des clauses <literal>WHERE</literal>, <literal>GROUP BY</literal>
    et <literal>HAVING</literal>, et est finalement le résultat des expressions de
    table.
   </para>

   <indexterm>
    <primary>ONLY</primary>
   </indexterm>

   <para>
    Lorsqu'une référence de table nomme une table qui est la table parent d'une
    table suivant la hiérarchie de l'héritage, la référence de table produit les
    lignes non seulement de la table mais aussi des descendants de cette table
    sauf si le mot clé <literal>ONLY</literal> précède le nom de la table. Néanmoins,
    la référence produit seulement les colonnes qui apparaissent dans la table
    nommée... toute colonne ajoutée dans une sous-table est ignorée.
   </para>

   <para>
    Au lieu d'écrire <literal>ONLY</literal> avant le nom de la table, vous pouvez
    écrire <literal>*</literal> après le nom de la table pour indiquer
    spécifiquement que les tables filles sont inclues. Écrire <literal>*</literal>
    n'est pas nécessaire car il s'agit du comportement par défaut (sauf si vous
    avez choisi de modifier la configuration de <xref
    linkend="guc-sql-inheritance"/>). Néanmoins, écrire <literal>*</literal>
    peut être utile pour indiquer fortement que les tables filles seront
    parcourues.
   </para>

   <sect3 id="queries-join">
    <title>Tables jointes</title>

    <indexterm zone="queries-join">
     <primary>join</primary>
    </indexterm>

    <para>
     Une table jointe est une table dérivée de deux autres tables (réelles ou
     dérivées) suivant les règles du type de jointure particulier. Les
     jointures internes (inner), externes (outer) et croisées (cross) sont
     disponibles.
     La syntaxe générale d'une table jointe est&nbsp;:
<synopsis>
<replaceable>T1</replaceable> <replaceable>type_jointure</replaceable> <replaceable>T2</replaceable> <optional> <replaceable>condition_jointure</replaceable> </optional>
   </synopsis>
   Des jointures de tous types peuvent être chaînées ensemble ou
   imbriquées&nbsp;: une des deux tables ou les deux tables peuvent être
   des tablees jointes. Des parenthèses peuvent être utilisées autour des
   clauses <literal>JOIN</literal> pour contrôler l'ordre de jointure. Dans
   l'absence des parenthèses, les clauses <literal>JOIN</literal> s'imbriquent
   de gauche à droite.
  </para>

  <variablelist>
   <title>Types de jointures</title>

   <varlistentry>
    <term>Jointure croisée (cross join)</term>

    <listitem>
     <indexterm>
      <primary>jointure</primary>
      <secondary>croisée</secondary>
     </indexterm>

     <indexterm>
      <primary>join</primary>
      <secondary>cross</secondary>
     </indexterm>

     <indexterm>
      <primary>jointure croisée</primary>
     </indexterm>

     <indexterm>
      <primary>crossed joind</primary>
     </indexterm>

     <synopsis><replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</replaceable></synopsis>

       <para>
        Pour chaque combinaison possible de lignes provenant de
        <replaceable>T1</replaceable> et <replaceable>T2</replaceable>
	(c'est-à-dire un produit cartésien), la table jointe contiendra
	une ligne disposant de toutes les colonnes de
	<replaceable>T1</replaceable> suivies par toutes les colonnes de
	<replaceable>T2</replaceable>.
	Si les tables ont respectivement N et M lignes, la table jointe en
	aura N * M.
       </para>

       <para>
        <literal>FROM <replaceable>T1</replaceable> CROSS JOIN
        <replaceable>T2</replaceable></literal> est équivalent à
        <literal>FROM <replaceable>T1</replaceable> INNER JOIN
        <replaceable>T2</replaceable> ON TRUE</literal> (voir ci-dessous).
        C'est aussi équivalent à&nbsp;:
        <literal>FROM <replaceable>T1</replaceable>,
        <replaceable>T2</replaceable></literal>.
        <note>
        <para>
         Cette dernière équivalence ne convient pas exactement quand plusieurs
         tables apparaissent car <literal>JOIN</literal> lie de façon plus
         profonde que la virgule. Par exemple
         <literal>FROM <replaceable>T1</replaceable> CROSS JOIN
         <replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable>
         ON <replaceable>condition</replaceable></literal>
         n'est pas identique à
         <literal>FROM <replaceable>T1</replaceable>,
         <replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable>
         ON <replaceable>condition</replaceable></literal>
         car <replaceable>condition</replaceable> peut faire référence à
         <replaceable>T1</replaceable> dans le premier cas mais pas dans le
         second.
        </para>
        </note>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Jointures qualifiées (qualified joins)</term>

      <listitem>

      <indexterm>
       <primary>join</primary>
       <secondary>outer</secondary>
      </indexterm>

      <indexterm>
       <primary>outer join</primary>
      </indexterm>

      <indexterm>
       <primary>jointure</primary>
       <secondary>externe</secondary>
      </indexterm>

      <indexterm>
       <primary>jointure externe</primary>
      </indexterm>

<synopsis><replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> ON <replaceable>expression_booleenne</replaceable>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> USING ( <replaceable>liste des colonnes jointes</replaceable> )
<replaceable>T1</replaceable> NATURAL { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable></synopsis>

       <para>
        Les mots <literal>INNER</literal> et
        <literal>OUTER</literal> sont optionnels dans toutes les formes.
        <literal>INNER</literal> est la valeur par défaut&nbsp;;
        <literal>LEFT</literal>, <literal>RIGHT</literal> et
        <literal>FULL</literal> impliquent une jointure externe.
       </para>

       <para>
        La <firstterm>condition de la jointure</firstterm> est spécifiée dans
        la clause <literal>ON</literal> ou <literal>USING</literal>, ou implicitement par le
        mot <literal>NATURAL</literal>. La condition de jointure détermine les lignes
        des deux tables source considérées comme <quote>correspondante</quote>,
        comme l'explique le paragraphe ci-dessous.
       </para>

       <para>
        Les types possibles de jointures qualifiées sont&nbsp;:

       <variablelist>
        <varlistentry>
         <term><literal>INNER JOIN</literal></term>

         <listitem>
          <para>
           Pour chaque ligne R1 de T1, la table jointe a une ligne pour chaque
           ligne de T2 satisfaisant la condition de jointure avec R1.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>LEFT OUTER JOIN</literal></term>

         <listitem>
         <indexterm>
          <primary>join</primary>
          <secondary>left</secondary>
         </indexterm>

         <indexterm>
          <primary>left join</primary>
         </indexterm>

         <indexterm>
          <primary>jointure</primary>
          <secondary>gauche</secondary>
         </indexterm>

         <indexterm>
          <primary>jointure gauche</primary>
         </indexterm>

          <para>
           Tout d'abord, une jointure interne est réalisée. Puis, pour chaque
           ligne de T1 qui ne satisfait pas la condition de jointure avec
           les lignes de T2, une ligne jointe est ajoutée avec des valeurs
           NULL dans les colonnes de T2. Du coup, la table jointe a toujours au moins
           une ligne pour chaque ligne de T1 quelque soient les conditions.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>RIGHT OUTER JOIN</literal></term>

         <listitem>
         <indexterm>
          <primary>join</primary>
          <secondary>right</secondary>
         </indexterm>

         <indexterm>
          <primary>right join</primary>
         </indexterm>

         <indexterm>
          <primary>jointure</primary>
          <secondary>droite</secondary>
         </indexterm>

         <indexterm>
          <primary>jointure droite</primary>
         </indexterm>

          <para>
           Tout d'abord, une jointure interne est réalisée. Puis, pour chaque
           ligne de T2 qui ne satisfait pas la condition de jointure avec les
           lignes de T1, une ligne jointe est ajoutée avec des valeurs NULL
           dans les colonnes de T1. C'est l'inverse d'une jointure gauche&nbsp;:
           la table résultante aura toujours une ligne pour chaque ligne de T2 quelque
           soient les conditions.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>FULL OUTER JOIN</literal></term>

         <listitem>
          <para>
           Tout d'abord, une jointure interne est réalisée. Puis, pour chaque
           ligne de T1 qui ne satisfait pas la condition de jointure avec les
           lignes de T2, une ligne jointe est ajoutée avec des valeurs NULL dans
           les colonnes de T2. De plus, pour chaque ligne de T2 qui ne satisfait
           pas la condition de jointure avec les lignes de T1, une ligne jointe
           est ajoutée avec des valeurs NULL dans les colonnes de T1.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
       </para>
       <para>
        La clause <literal>ON</literal> est le type de condition de jointure le
        plus utilisé&nbsp;: elle prend une valeur booléenne du même type que
        celle utilisée dans une clause <literal>WHERE</literal>. Une paire de
        lignes provenant de <replaceable>T1</replaceable> et de
        <replaceable>T2</replaceable> correspondent si l'expression de la clause
        <literal>ON</literal> vaut true.
       </para>

       <para>
        La clause <literal>USING</literal> est un raccourci qui vous permet de
        prendre avantage d'une situation spécifique où les deux côtés de la
        jointure utilisent le même nom pour la colonne jointe. Elle prend
        une liste de noms de colonnes partagées, en séparant les noms par des
        virgules et forme une condition de jointure qui inclut une comparaison
        d'égalité entre chaque. Par exemple, joindre <replaceable>T1</replaceable>
        et <replaceable>T2</replaceable> avec <literal>USING (a, b)</literal>
        produit la même condition de jointure que la condition
        <literal>ON <replaceable>T1</replaceable>.a
        = <replaceable>T2</replaceable>.a AND <replaceable>T1</replaceable>.b
        = <replaceable>T2</replaceable>.b</literal>.
       </para>

       <para>
        De plus, la sortie de <literal>JOIN USING</literal> supprime les
        colonnes redondantes&nbsp;: il n'est pas nécessaire d'imprimer
        les colonnes de correspondance, puisqu'elles doivent avoir des
        valeurs identiques. Alors que <literal>JOIN ON</literal> produit
        toutes les colonnes de <replaceable>T2</replaceable>, <literal>JOIN
        USING</literal> produces produit une seule colonne pour chaque paire
        de colonnes listées (dans l'ordre listé), suivi par chaque colonne
        restante provenant de <replaceable>T1</replaceable>, suivi par chaque
        colonne restante provenant de <replaceable>T2</replaceable>.
       </para>

       <para>
        <indexterm>
         <primary>join</primary>
         <secondary>natural</secondary>
        </indexterm>
        <indexterm>
         <primary>natural join</primary>
        </indexterm>
        Enfin, <literal>NATURAL</literal> est un raccourci de
        <literal>USING</literal>&nbsp;: il forme une liste
        <literal>USING</literal> consistant de tous les noms de colonnes
        apparaissant dans les deux tables en entrée. Comme avec
        <literal>USING</literal>, ces colonnes apparaissent seulement dans la
        table en sortie. S'il n'existe aucun nom commun de colonne,
        <literal>NATURAL</literal> se comporte comme
        <literal>CROSS JOIN</literal>.
       </para>

       <note>
        <para>
         <literal>USING</literal> est raisonnablement protégé contre les
         changements de colonnes dans les relations jointes car seuls les noms
         de colonnes listés sont combinés. <literal>NATURAL</literal> est
         considéré comme plus risqué car toute modification de schéma causant
         l'apparition d'un nouveau nom de colonne correspondant fera en sorte
         de joindre la nouelle colonne.
        </para>
       </note>
      </listitem>
     </varlistentry>
    </variablelist>

    <para>
     Pour rassembler tout ceci, supposons que nous avons une table
     <literal>t1</literal>&nbsp;:
<programlisting> no | nom
----+------
  1 | a
  2 | b
  3 | c</programlisting>
     et une table <literal>t2</literal>&nbsp;:
<programlisting> no | valeur
----+-------
  1 | xxx
  3 | yyy
  5 | zzz</programlisting>
     nous obtenons les résultats suivants pour les différentes jointures&nbsp;:
<screen><prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 CROSS JOIN t2;</userinput>
 no | nom | no | valeur
----+-----+----+-------
  1 | a   |  1 | xxx
  1 | a   |  3 | yyy
  1 | a   |  5 | zzz
  2 | b   |  1 | xxx
  2 | b   |  3 | yyy
  2 | b   |  5 | zzz
  3 | c   |  1 | xxx
  3 | c   |  3 | yyy
  3 | c   |  5 | zzz
(9 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 ON t1.no = t2.no;</userinput>
 no | nom | no | valeur
----+-----+----+-------
  1 | a   |  1 | xxx
  3 | c   |  3 | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 USING (no);</userinput>
 no | nom | valeur
----+-----+-------
  1 | a   | xxx
  3 | c   | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 NATURAL INNER JOIN t2;</userinput>
 no | nom | valeur
----+-----+-------
  1 | a   | xxx
  3 | c   | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.no = t2.no;</userinput>
 no | nom | no | valeur
----+-----+----+-------
  1 | a   |  1 | xxx
  2 | b   |    |
  3 | c   |  3 | yyy
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 USING (no);</userinput>
 no | nom | valeur
----+-----+-------
  1 | a   | xxx
  2 | b   |
  3 | c   | yyy
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 RIGHT JOIN t2 ON t1.no = t2.no;</userinput>
 no | nom | no | valeur
----+-----+----+-------
  1 | a   |  1 | xxx
  3 | c   |  3 | yyy
    |     |  5 | zzz
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 FULL JOIN t2 ON t1.no = t2.no;</userinput>
 no | nom | no | valeur
----+-----+----+-------
  1 | a   |  1 | xxx
  2 | b   |    |
  3 | c   |  3 | yyy
    |     |  5 | zzz
(4 rows)</screen>
    </para>

    <para>
     La condition de jointure spécifiée avec <literal>ON</literal> peut aussi contenir
     des conditions sans relation directe avec la jointure. Ceci est utile
     pour quelques requêtes mais son utilisation doit avoir été réfléchie. Par
     exemple&nbsp;:
<screen><prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.no = t2.no AND t2.valeur = 'xxx';</userinput>
 no | nom | no | valeur
----+-----+----+-------
  1 | a   |  1 | xxx
  2 | b   |    |
  3 | c   |    |
(3 rows)</screen>
     Notez que placer la restriction dans la clause <literal>WHERE</literal>
     donne un résultat différent&nbsp;:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = 'xxx';</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
(1 row)
     </screen>
     Ceci est dû au fait qu'une restriction placée dans la clause
     <literal>ON</literal> est traitée <emphasis>avant</emphasis> la jointure
     alors qu'une restriction placée dans la clause <literal>WHERE</literal>
     est traitée <emphasis>après</emphasis> la jointure.
     Ceci n'a pas d'importance avec les jointures internes, mais en a une grande
     avec les jointures externes.
    </para>
   </sect3>

   <sect3 id="queries-table-aliases">
    <title>Alias de table et de colonne</title>

    <indexterm zone="queries-table-aliases">
     <primary>alias</primary>
     <secondary>dans la clause FROM</secondary>
    </indexterm>

    <indexterm>
     <primary>label</primary>
     <see>alias</see>
    </indexterm>

    <para>
     Un nom temporaire peut être donné aux tables et aux références de tables
     complexe, qui sera ensuite utilisé pour référencer la table dérivée dans la
     suite de la requête. Cela s'appelle un <firstterm>alias de
      table</firstterm>.
    </para>

    <para>
     Pour créer un alias de table, écrivez
     <synopsis>FROM <replaceable>reference_table</replaceable> AS <replaceable>alias</replaceable></synopsis>
     ou
<synopsis>FROM <replaceable>reference_table</replaceable> <replaceable>alias</replaceable></synopsis>
     Le mot clé <literal>AS</literal> n'est pas obligatoire.
     <replaceable>alias</replaceable> peut être tout identifiant.
    </para>

    <para>
     Une application typique des alias de table est l'affectation d'identifieurs
     courts pour les noms de tables longs, ce qui permet de garder des clauses de
     jointures lisibles. Par exemple&nbsp;:
<programlisting>SELECT * FROM nom_de_table_tres_tres_long s
  JOIN un_autre_nom_tres_long a ON s.id = a.no;</programlisting>
    </para>

    <para>
     L'alias devient le nouveau nom de la table en ce qui concerne la requête
     en cours &mdash; il n'est pas autorisé de faire référence à la table par
     son nom original où que ce soit dans la requête. Du coup, ceci n'est pas
     valide&nbsp;:
<programlisting>
SELECT * FROM mon_table AS m WHERE mon_table.a &gt; 5;    -- mauvais
     </programlisting>
    </para>

    <para>
     Les alias de table sont disponibles principalement pour aider à l'écriture
     de requête mais ils deviennent nécessaires pour joindre une table avec
     elle-même, par exemple&nbsp;:
     <programlisting>SELECT * FROM personnes AS mere JOIN personnes AS enfant ON mere.id = enfant.mere_id;
     </programlisting>
     De plus, un alias est requis si la référence de la table est une
     sous-requête (voir la <xref linkend="queries-subqueries"/>).
    </para>

    <para>
     Les parenthèses sont utilisées pour résoudre les ambiguïtés. Dans l'exemple
     suivant, la première instruction affecte l'alias <literal>b</literal> à la
     deuxième instance de <literal>ma_table</literal> mais la deuxième instruction
     affecte l'alias au résultat de la jonction&nbsp;:
     <programlisting>SELECT * FROM ma_table AS a CROSS JOIN ma_table AS b ...
SELECT * FROM (ma_table AS a CROSS JOIN ma_table) AS b ...</programlisting>
    </para>

    <para>
     Une autre forme d'alias de tables donne des noms temporaires aux colonnes
     de la table ainsi qu'à la table&nbsp;:
<synopsis>FROM <replaceable>reference_table</replaceable> <optional>AS</optional> <replaceable>alias</replaceable> ( <replaceable>colonne1</replaceable> <optional>, <replaceable>colonne2</replaceable> <optional>, ...</optional></optional> )</synopsis>
     Si le nombre d'alias de colonnes spécifié est plus petit que le nombre
     de colonnes dont dispose la table réelle, les colonnes suivantes ne sont
     pas renommées. Cette syntaxe est particulièrement utile dans le cas de
     jointure avec la même table ou dans le cas de sous-requêtes.
    </para>

    <para>
     Quand un alias est appliqué à la sortie d'une clause <literal>JOIN</literal>,
     l'alias cache le nom original référencé à l'intérieur du
     <literal>JOIN</literal>. Par exemple&nbsp;:
<programlisting>SELECT a.* FROM ma_table AS a JOIN ta_table AS b ON ...</programlisting>
     est du SQL valide mais&nbsp;:
<programlisting>SELECT a.* FROM (ma_table AS a JOIN ta_table AS b ON ...) AS c</programlisting>
     n'est pas valide&nbsp; l'alias de table <literal>a</literal> n'est pas visible
     en dehors de l'alias <literal>c</literal>.
    </para>
   </sect3>

   <sect3 id="queries-subqueries">
    <title>Sous-requêtes</title>

    <indexterm zone="queries-subqueries">
     <primary>sous-requête</primary>
    </indexterm>

    <para>
     Une sous-requête spécifiant une table dérivée doit être enfermée
     dans des parenthèses et <emphasis>doit</emphasis> se voir affecté un alias
     de table (comme dans <xref linkend="queries-table-aliases"/>). Par
     exemple&nbsp;:
<programlisting>FROM (SELECT * FROM table1) AS nom_alias</programlisting>
    </para>

    <para>
     Cet exemple est équivalent à <literal>FROM table1 AS
     nom_alias</literal>. Des cas plus intéressants, qui ne peuvent pas être
     réduit à une jointure pleine, surviennent quand la sous-requête implique un
     groupement ou un agrégat.
    </para>

    <para>
     Uns sous-requête peut aussi être une liste <command>VALUES</command>&nbsp;:
<programlisting>
FROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow'))
     AS noms(prenom, nom)
     </programlisting>
     De nouveau, un alias de table est requis. Affecter des noms d'alias aux
     colonnes de la liste <command>VALUES</command> est en option mais c'est
     une bonne pratique. Pour plus d'informations, voir
     <xref linkend="queries-values"/>.
    </para>
   </sect3>

   <sect3 id="queries-tablefunctions">
    <title>Fonctions de table</title>

    <indexterm zone="queries-tablefunctions"><primary>fonction de table</primary></indexterm>

    <indexterm zone="queries-tablefunctions">
     <primary>fonction</primary>
     <secondary>dans la clause FROM</secondary>
    </indexterm>

    <para>
     Les fonctions de table sont des fonctions produisant un ensemble de
     lignes composées de types de données de base (types scalaires) ou de types
     de données composites (lignes de table). Elles sont utilisées comme une
     table, une vue ou une sous-requête de la clause <literal>FROM</literal> d'une
     requête. Les colonnes renvoyées par les fonctions de table peuvent être
     incluses dans une clause <literal>SELECT</literal>, <literal>JOIN</literal> ou
     <literal>WHERE</literal> de la même manière que les colonnes d'une table, vue ou
     sous-requête.
    </para>

    <para>
     Les fonctions de table peuvent aussi être combinées en utilisant la syntaxe
     <literal>ROWS FROM</literal>, avec les résultats renvoyés dans des colonnes
     parallèles&nbsp;; le nombre de lignes résultantes dans ce cas est celui du
     résultat de fonction le plus large. Les résultats ayant moins de colonnes
     sont alignés avec des valeurs NULL.
    </para>

    <synopsis>
<replaceable>appel_fonction</replaceable> <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>alias_table</replaceable> <optional>(<replaceable>alias_colonne</replaceable> <optional>, ... </optional>)</optional></optional>
ROWS FROM( <replaceable>appel_fonction</replaceable> <optional>, ... </optional> ) <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>alias_table</replaceable> <optional>(<replaceable>alias_colonne</replaceable> <optional>, ... </optional>)</optional></optional>
    </synopsis>

    <para>
     Si la clause <literal>WITH ORDINALITY</literal> est ajoutée, une colonne
     supplémentaire de type <type>bigint</type> sera ajoutée aux colonnes de
     résultat de la fonction. Cette colonne numérote les lignes de l'ensemble
     de résultats de la fonction, en commençant à 1. (Ceci est une généralisation
     de la syntaxe du standard SQL pour <literal>UNNEST ... WITH ORDINALITY</literal>.)
     Par défaut, la colonne ordinale est appelée <literal>ordinality</literal>,
     mais un nom de colonne différent peut être affecté en utilisant une clause
     <literal>AS</literal>.
    </para>

    <para>
     La fonction de table <literal>UNNEST</literal> peut être appelée avec tout
     nombre de paramètres tableaux, et envoie un nombre correspondant de colonnes
     comme si la fonction <literal>UNNEST</literal> avait été appelée sur chaque
     paramètre séparément (<xref linkend="functions-array"/>) et combinée en
     utilisant la construction <literal>ROWS FROM</literal>.
    </para>

    <synopsis>
UNNEST( <replaceable>expression_tableau</replaceable> <optional>, ... </optional> ) <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>alias_table</replaceable> <optional>(<replaceable>alias_colonne</replaceable> <optional>, ... </optional>)</optional></optional>
    </synopsis>

    <para>
     Si aucun <replaceable>alias_table</replaceable> n'est précisé, le nom de la
     fonction est utilisé comme nom de table&nbsp;; dans le cas d'une construction
     <literal>ROWS FROM()</literal>, le nom de la première fonction est utilisé.
    </para>

    <para>
     Si des alias de colonnes ne sont pas fournies pour une fonction renvoyant
     un type de données de base, alors le nom de la colonne est aussi le même
     que le nom de la fonction. Pour une fonction renvoyant un type composite,
     les colonnes résultats obtiennent les noms des attributs individuels du
     type.
    </para>

    <para>
     Quelques exemples&nbsp;:
     <programlisting>CREATE TABLE truc (trucid int, trucsousid int, trucnom text);

CREATE FUNCTION recuptruc(int) RETURNS SETOF foo AS $$
    SELECT * FROM truc WHERE trucid = $1;
$$ LANGUAGE SQL;

SELECT * FROM recuptruc(1) AS t1;

SELECT * FROM truc
    WHERE trucsousid IN (
                        SELECT trucsousid
                        FROM recuptruc(truc.trucid) z
                        WHERE z.trucid = truc.trucid);

CREATE VIEW vue_recuptruc AS SELECT * FROM recuptruc(1);
SELECT * FROM vue_recuptruc;</programlisting>
    </para>

    <para>
     Dans certains cas, il est utile de définir des fonctions de table pouvant
     renvoyer des ensembles de colonnes différentes suivant la façon dont elles
     sont appelées. Pour supporter ceci, la fonction de table est déclarée comme
     renvoyant le pseudotype <type>record</type>. Quand une telle fonction est
     utilisée dans une requête, la structure de ligne attendue doit être
     spécifiée dans la requête elle-même, de façon à ce que le système sache
     comment analyser et planifier la requête. Cette syntaxe ressemble à
     ceci&nbsp;:
    </para>

<synopsis>
<replaceable>appel_fonction</replaceable> <optional>AS</optional> <replaceable>alias</replaceable> (<replaceable>définition_colonne</replaceable> <optional>, ... </optional>)
<replaceable>appel_fonction</replaceable> AS <optional><replaceable>alias</replaceable></optional> (<replaceable>définition_colonne</replaceable> <optional>, ... </optional>)
ROWS FROM( ... <replaceable>appel_fonction</replaceable> AS (<replaceable>définition_colonne</replaceable> <optional>, ... </optional>) <optional>, ... </optional> )
     </synopsis>

     <para>
      Lorsque la syntaxe <literal>ROWS FROM()</literal> n'est pas utilisée, la
      liste <replaceable>définition_colonne</replaceable> remplace la liste
      d'alias de colonnes qui aurait été autrement attachée à la clause
      <literal>FROM</literal>&nbsp;; les noms dans les définitions de colonnes
      servent comme alias de colonnes. Lors de l'utilisation de la syntaxe
      <literal>ROWS FROM()</literal>, une liste
      <replaceable>définition_colonne</replaceable> peut être attachée à chaque
      fonction membre séparément&nbsp;; ou s'il existe seulement une fonction
      membre et pas de clause <literal>WITH ORDINALITY</literal>, une liste
      <replaceable>column_definition</replaceable> peut être écrite au lieu de
      la liste d'alias de colonnes suivant <literal>ROWS FROM()</literal>.
     </para>

     <para>
      Considérez cet exemple&nbsp;:
      <programlisting>SELECT *
    FROM dblink('dbname=mabd', 'SELECT proname, prosrc FROM pg_proc')
      AS t1(proname nom, prosrc text)
    WHERE proname LIKE 'bytea%';</programlisting>
     La fonction <xref linkend="contrib-dblink-function"/> (part of the <xref linkend="dblink"/> module>)
     exécute une requête distante. Elle déclare renvoyer le type
     <type>record</type> car elle pourrait être utilisée pour tout type de requête.
     L'ensemble de colonnes réelles doit être spécifié dans la requête
     appelante de façon à ce que l'analyseur sache, par exemple, comment
     étendre <literal>*</literal>.
    </para>
   </sect3>

   <sect3 id="queries-lateral">
    <title>Sous-requêtes <literal>LATERAL</literal></title>

    <indexterm zone="queries-lateral">
     <primary>LATERAL</primary>
     <secondary>dans la clause FROM</secondary>
    </indexterm>

    <para>
     Les sous-requêtes apparaissant dans la clause <literal>FROM</literal> peuvent
     être précédées du mot clé <literal>LATERAL</literal>. Ceci leur permet de
     référencer les colonnes fournies par les éléments précédents dans le
     <literal>FROM</literal>. (Sans <literal>LATERAL</literal>, chaque sous-requête
     est évaluée indépendamment et ne peut donc pas référencer les autres éléments
     de la clause <literal>FROM</literal>.)
    </para>

    <para>
     Les fonctions renvoyant des ensembles et apparaissant dans le
     <literal>FROM</literal> peuvent aussi être précédées du mot clé
     <literal>LATERAL</literal>, mais, pour les fonctions, le mot clé est
     optionnel. Les arguments de la fonction peuvent contenir des références aux
     colonnes fournies par les éléments précédents dans le <literal>FROM</literal>.
    </para>

    <para>
     Un élément <literal>LATERAL</literal> peut apparaître au niveau haut dans
     la liste <literal>FROM</literal> ou dans un arbre de jointures
     (<literal>JOIN</literal>). Dans ce dernier cas, cela peut aussi faire
     référence à tout élément qui sont sur le côté gauche d'un
     <literal>JOIN</literal> alors qu'il est positionné sur sa droite.
    </para>

    <para>
     Quand un élément <literal>FROM</literal> contient des références croisées
     <literal>LATERAL</literal>, l'évaluation se fait ainsi&nbsp;: pour chaque
     ligne d'un élément <literal>FROM</literal> fournissant les colonnes
     référencées, ou pour chaque ensemble de lignes de plusieurs éléments
     <literal>FROM</literal> fournissant les colonnes, l'élément
     <literal>LATERAL</literal> est évalué en utilisant cette valeur de ligne ou
     cette valeur d'ensembles de lignes. Les lignes résultantes sont jointes
     comme d'habitude aux lignes résultants du calcul. C'est répété pour chaque
     ligne ou ensemble de lignes provenant de la table source.
    </para>

    <para>
     Un exemple trivial de <literal>LATERAL</literal> est
<programlisting>
SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;
      </programlisting>
      Ceci n'est pas vraiment utile car cela revient exactement au même résultat
      que cette écriture plus conventionnelle&nbsp;:
      <programlisting>
SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;
      </programlisting>
      <literal>LATERAL</literal> est principalement utile lorsqu'une colonne
      référencée est nécessaire pour calculer la colonne à joindre. Une
      utilisation habituelle est de fournir une valeur d'un argument à une
      fonction renvoyant un ensemble de lignes. Par exemple, supposons que
      <function>vertices(polygon)</function> renvoit l'ensemble de sommets d'un
      polygone, nous pouvons identifier les sommets proches des polygones
      stockés dans une table avec la requête suivante&nbsp;:
      <programlisting>
SELECT p1.id, p2.id, v1, v2
FROM polygones p1, polygones p2,
     LATERAL vertices(p1.poly) v1,
     LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;
      </programlisting>
      Cette requête pourrait aussi être écrite ainsi&nbsp;:
      <programlisting>
SELECT p1.id, p2.id, v1, v2
FROM polygons p1 CROSS JOIN LATERAL vertices(p1.poly) v1,
     polygons p2 CROSS JOIN LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;
      </programlisting>
      ou dans diverses autres formulations équivalentes. (Nous l'avons déjà
      mentionné, le mot clé <literal>LATERAL</literal> est inutile dans cet
      exemple mais nous l'utilisons pour plus de clareté.)
     </para>

     <para>
      Il est souvent particulièrement utile d'utiliser <literal>LEFT JOIN</literal>
      sur une sous-requête <literal>LATERAL</literal>, pour que les lignes sources
      apparaissent dans le résultat même si la sous-requête
      <literal>LATERAL</literal> ne produit aucune ligne pour elles. Par exemple,
      si <function>get_product_names()</function> renvoit les noms des produits
      réalisés par un manufacturier mais que quelques manufacturiers dans
      notre table ne réalisent aucun produit, nous pourrions les trouver avec
      cette requête&nbsp;:
      <programlisting>
SELECT m.name
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true
WHERE pname IS NULL;
      </programlisting>
     </para>
    </sect3>
   </sect2>

   <sect2 id="queries-where">
    <title>Clause <literal>WHERE</literal></title>

    <indexterm zone="queries-where">
     <primary>WHERE</primary>
    </indexterm>

    <para>
     La syntaxe de la <xref linkend="sql-where"/> est
     <synopsis>WHERE <replaceable>condition_recherche</replaceable></synopsis>
    où <replaceable>condition_recherche</replaceable> est toute expression de
    valeur (voir la <xref linkend="sql-expressions"/>) renvoyant une valeur
    de type <type>boolean</type>.
   </para>

   <para>
    Après le traitement de la clause <literal>FROM</literal>, chaque ligne de la
    table virtuelle dérivée est vérifiée avec la condition de recherche. Si le
    résultat de la vérification est positif (true), la ligne est conservée dans
    la table de sortie, sinon (c'est-à-dire si le résultat est faux ou nul), la
    ligne est abandonnée. La condition de recherche référence typiquement au
    moins une colonne de la table générée dans la clause
    <literal>FROM</literal>&nbsp;; ceci n'est pas requis mais, dans le cas contraire,
    la clause <literal>WHERE</literal> n'aurait aucune utilité.
   </para>

   <note>
    <para>
     La condition de jointure d'une jointure interne peut être écrite soit dans
     la clause <literal>WHERE</literal> soit dans la clause <literal>JOIN</literal>. Par
     exemple, ces expressions de tables sont équivalentes&nbsp;:
<programlisting>FROM a, b WHERE a.id = b.id AND b.val &gt; 5</programlisting>
     et&nbsp;:
<programlisting>FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5</programlisting>
     ou même peut-être&nbsp;:
<programlisting>FROM a NATURAL JOIN b WHERE b.val &gt; 5</programlisting>
     Laquelle vous utilisez est plutôt une affaire de style. La syntaxe
     <literal>JOIN</literal> dans la clause <literal>FROM</literal> n'est probablement pas
     aussi portable vers les autres systèmes de gestion de bases de données SQL,
     même si cela fait partie du standard SQL.
     Pour les jointures externes, il n'y a pas d'autres choix&nbsp;: elles
     doivent être faites dans la clause <literal>FROM</literal>. La clause
     <literal>ON</literal> ou <literal>USING</literal> d'une jointure externe n'est
     <emphasis>pas</emphasis> équivalente à une condition <literal>WHERE</literal> parce
     qu'elle détermine l'ajout de lignes (pour les lignes qui ne correspondent
     pas en entrée) ainsi que pour la suppression de lignes dans le résultat
     final.
    </para>
   </note>

   <para>
    Voici quelques exemples de clauses <literal>WHERE</literal>&nbsp;:
<programlisting>SELECT ... FROM fdt WHERE c1 &gt; 5

SELECT ... FROM fdt WHERE c1 IN (1, 2, 3)

SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)

SELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)

SELECT ... FROM fdt WHERE c1 BETWEEN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100

SELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &gt; fdt.c1)</programlisting>
    <literal>fdt</literal> est la table dérivée dans la clause
    <literal>FROM</literal>. Les lignes qui ne correspondent pas à la condition de
    recherche de la clause <literal>WHERE</literal> sont éliminées de la table
    <literal>fdt</literal>. Notez l'utilisation de sous-requêtes scalaires en
    tant qu'expressions de valeurs. Comme n'importe quelle autre requête, les
    sous-requêtes peuvent employer des expressions de tables complexes. Notez
    aussi comment <literal>fdt</literal> est référencée dans les sous-requêtes.
    Qualifier <literal>c1</literal> comme <literal>fdt.c1</literal> est seulement nécessaire
    si <literal>c1</literal> est aussi le nom d'une colonne dans la table d'entrée
    dérivée de la sous-requête. Mais qualifier le nom de colonne ajoute à la
    clarté même lorsque cela n'est pas nécessaire. Cet exemple montre comment
    le nom de colonne d'une requête externe est étendue dans les requêtes
    internes.
   </para>
  </sect2>


  <sect2 id="queries-group">
   <title>Clauses <literal>GROUP BY</literal> et
<literal>HAVING</literal></title>

   <indexterm zone="queries-group">
    <primary>GROUP BY</primary>
   </indexterm>

   <indexterm zone="queries-group">
    <primary>groupement</primary>
   </indexterm>

   <para>
    Après avoir passé le filtre <literal>WHERE</literal>, la table d'entrée dérivée
    peut être sujette à un regroupement en utilisant la clause <literal>GROUP
    BY</literal> et à une élimination de groupe de lignes avec la clause
    <literal>HAVING</literal>.
   </para>

<synopsis>SELECT <replaceable>liste_selection</replaceable>
    FROM ...
    <optional>WHERE ...</optional>
    GROUP BY <replaceable>reference_colonne_regroupement</replaceable><optional>,<replaceable>reference_colonne_regroupement</replaceable></optional>...</synopsis>

   <para>
    La <xref linkend="sql-groupby"/> est
    utilisée pour regrouper les lignes d'une table qui ont les mêmes valeurs
    dans toutes les colonnes précisées. L'ordre dans lequel ces colonnes sont
    indiquées importe peu. L'effet est de combiner chaque ensemble de lignes
    partageant des valeurs communes en un seul groupe de ligne représentant
    toutes les lignes du groupe. Ceci est fait pour éliminer les redondances dans
    la sortie et/ou pour calculer les agrégats s'appliquant à ces groupes. Par
    exemple&nbsp;:
<screen><prompt>=&gt;</prompt> <userinput>SELECT * FROM test1;</userinput>
 x | y
---+---
 a | 3
 c | 2
 b | 5
 a | 1
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT x FROM test1 GROUP BY x;</userinput>
 x
---
 a
 b
 c
(3 rows)</screen>
   </para>
	
   <para>
    Dans la seconde requête, nous n'aurions pas pu écrire <literal>SELECT *
    FROM test1 GROUP BY x</literal> parce qu'il n'existe pas une seule valeur
    pour la colonne <literal>y</literal> pouvant être associé avec chaque autre groupe.
    Les colonnes de regroupement peuvent être référencées dans la liste de
    sélection car elles ont une valeur constante unique par groupe.
   </para>

   <para>
    En général, si une table est groupée, les colonnes qui ne sont pas
    listées dans le <literal>GROUP BY</literal> ne peuvent pas être référencées
    sauf dans les expressions d'agrégats. Voici un exemple d'expressions
    d'agrégat&nbsp;:
<screen><prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x;</userinput>
 x | sum
---+-----
 a |   4
 b |   5
 c |   2
(3 rows)</screen>
    Ici, <literal>sum</literal> est la fonction d'agrégat qui calcule une seule
    valeur pour le groupe entier. La <xref linkend="functions-aggregate"/>
    propose plus d'informations sur les fonctions d'agrégats disponibles.
   </para>

   <tip>
    <para>
     Le regroupement sans expressions d'agrégats calcule effectivement
     l'ensemble les valeurs distinctes d'une colonne. Ceci peut aussi se faire
     en utilisant la clause <literal>DISTINCT</literal> (voir la <xref
     linkend="queries-distinct"/>).
    </para>
   </tip>

   <para>
    Voici un autre exemple&nbsp;: il calcule les ventes totales pour chaque
    produit (plutôt que le total des ventes sur tous les produits)&nbsp;:
<programlisting>SELECT produit_id, p.nom, (sum(v.unite) * p.prix) AS ventes
    FROM produits p LEFT JOIN ventes v USING (produit_id)
    GROUP BY produit_id, p.nom, p.prix;</programlisting>
    Dans cet exemple, les colonnes <literal>produit_id</literal>,
    <literal>p.nom</literal> et <literal>p.prix</literal> doivent être dans la
    clause <literal>GROUP BY</literal> car elles sont référencées dans la liste de
    sélection de la requête (but see below). La colonne
    <literal>s.unite</literal> n'a pas besoin d'être dans la liste <literal>GROUP
    BY</literal> car elle est seulement utilisée dans l'expression de l'agrégat
    (<literal>sum(...)</literal>) représentant les ventes d'un produit. Pour
    chaque produit, la requête renvoie une ligne de résumé sur les ventes de ce
    produit.
   </para>

   <indexterm><primary>dépendance fonctionnel</primary></indexterm>

   <para>
    Si la table produits est configuré de façon à ce que
    <literal>id_produit</literal> soit la clé primaire, alors il serait suffisant
    de grouper par la colonne <literal>id_produit</literal> dans l'exemple
    ci-dessus, car le nom et le prix seraient <firstterm>dépendants
    fonctionnellement</firstterm> de l'identifiant du produit, et donc il n'y
    aurait pas d'ambiguité sur le nom et le prix à renvoyer pour chaque groupe
    d'identifiant de produit.
   </para>

   <para>
    En SQL strict, <literal>GROUP BY</literal> peut seulement grouper les colonnes de
    la table source mais <productname>PostgreSQL</productname> étend ceci en
    autorisant <literal>GROUP BY</literal> à grouper aussi les colonnes de la liste de
    sélection. Grouper par expressions de valeurs au lieu de simples noms de
    colonnes est aussi permis.
   </para>

   <indexterm>
    <primary>HAVING</primary>
   </indexterm>

   <para>
    Si une table a été groupée en utilisant la clause <literal>GROUP
    BY</literal> mais que seuls certains groupes sont intéressants, la clause
    <literal>HAVING</literal> peut être utilisée, comme une clause
    <literal>WHERE</literal>, pour éliminer les groupes du résultat. Voici la
    syntaxe&nbsp;:
<synopsis>SELECT <replaceable>liste_selection</replaceable> FROM ... <optional>WHERE ...</optional> GROUP BY ... HAVING <replaceable>expression_booléenne</replaceable></synopsis>
    Les expressions de la clause <literal>HAVING</literal> peuvent référer à la fois
    aux expressions groupées et aux expressions non groupées (ce qui impliquent
    nécessairement une fonction d'agrégat).
   </para>

   <para>
    Exemple&nbsp;:
<screen><prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) &gt; 3;</userinput>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING x &lt; 'c';</userinput>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)</screen>
   </para>

   <para>
    De nouveau, un exemple plus réaliste&nbsp;:
<programlisting>SELECT produit_id, p.nom, (sum(v.unite) * (p.prix - p.cout)) AS profit
    FROM produits p LEFT JOIN ventes v USING (produit_id)
    WHERE v.date &gt; CURRENT_DATE - INTERVAL '4 weeks'
    GROUP BY produit_id, p.nom, p.prix, p.cout
    HAVING sum(p.prix * s.unite) &gt; 5000;</programlisting>
    Dans l'exemple ci-dessus, la clause <literal>WHERE</literal> sélectionne les
    lignes par une colonne qui n'est pas groupée (l'expression est vraie
    seulement pour les ventes des quatre dernières semaines) alors que la
    clause <literal>HAVING</literal> restreint la sortie aux groupes dont le total des
    ventes dépasse 5000. Notez que les expressions d'agrégats n'ont pas besoin
    d'être identiques dans toutes les parties d'une requête.
   </para>

   <para>
    Si une requête contient des appels à des fonctions d'aggrégat, mais pas
    de clause <literal>GROUP BY</literal>, le regroupement a toujours lieu&nbsp;:
    le résultat est une seule ligne de regroupement (ou peut-être pas de ligne
    du tout si la ligne unique est ensuite éliminée par la clause
    <literal>HAVING</literal>).
    Ceci est vrai aussi si elle comporte une clause <literal>HAVING</literal>,
    même sans fonction d'aggrégat ou <literal>GROUP BY</literal>.
   </para>
  </sect2>

  <sect2 id="queries-grouping-sets">
   <title><literal>GROUPING SETS</literal>, <literal>CUBE</literal>, et <literal>ROLLUP</literal></title>

   <indexterm zone="queries-grouping-sets">
    <primary>GROUPING SETS</primary>
   </indexterm>
   <indexterm zone="queries-grouping-sets">
    <primary>CUBE</primary>
   </indexterm>
   <indexterm zone="queries-grouping-sets">
    <primary>ROLLUP</primary>
   </indexterm>

   <para>
    Des opérations de regroupements plus complexes que celles décrites
    ci-dessus sont possibles en utilisant la notion d'<firstterm>ensembles
    de regroupement</firsterm>. Les données sélectionnées par
    les clauses <literal>FROM</literal> et <literal>WHERE</literal>
    sont regroupées séparément pour chaque ensemble de regroupement
    indiqué, les agrégats calculés pour chaque ensemble de la même
    manière que pour la clause simple <literal>GROUP BY</literal>,
    puis le résultat est retourné.
    Par exemple:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM ventes;</userinput>
 produit | taille | vendus
-------+------+-------
 Foo   | L    |  10
 Foo   | M    |  20
 Bar   | M    |  15
 Bar   | L    |  5
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT produit, taille, sum(vendus) FROM ventes GROUP BY GROUPING SETS ((produit), (taille), ());</userinput>
 produit | taille | sum
-------+------+-----
 Foo   |      |  30
 Bar   |      |  20
       | L    |  15
       | M    |  35
       |      |  50
(5 rows)
</screen>
   </para>

   <para>
   Chaque sous liste de <literal>GROUPING SETS</literal> peut indiquer 0
   ou plusieurs colonnes ou expressions et est interprétée de la même
   manière que si elle était directement dans la clause <literal>GROUP
   BY</literal>. Un ensemble de regroupement vide signifie que toutes
   les lignes sont agrégées pour former un simple groupe (qui est
   renvoyé quand bien même aucune ligne ne serait sélectionnée),
   comme décrit ci-dessus dans le cas de fonctions d'agrégat sans
   clause <literal>GROUP BY</literal>.
   </para>

   <para>
    Les références aux colonnes de regroupement ou expressions
    sont remplacées par des valeurs NULL dans les lignes
    renvoyées pour les ensembles de regroupement où ces colonnes
    n'apparaissent pas. Pour identifier à quel ensemble de
    regroupement une ligne en particulier appartient voyez <xref linkend="functions-grouping-table"/>.
   </para>

   <para>
    Une notation raccourcie est fournie pour indiquer deux types classiques d'ensemble de regroupement.
    Une clause sous la forme
<programlisting>
ROLLUP ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, <replaceable>e3</replaceable>, ... )
</programlisting>
    représente la liste indiquée d'expressions ainsi que l'ensemble
    des préfixes de la liste, y compris la liste vide. C'est donc
    équivalent à
<programlisting>
GROUPING SETS (
    ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, <replaceable>e3</replaceable>, ... ),
    ...
    ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable> ),
    ( <replaceable>e1</replaceable> ),
    ( )
)
</programlisting>
    Cette notation est communément utilisée avec des données
    hiérarchiques; exemple total des salaires par département, division
    et ensemble de l'entreprise.
   </para>

   <para>
    Une clause sous la forme
<programlisting>
CUBE ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, ... )
</programlisting>
    représente la liste indiquée ainsi que l'ensemble des
    sous-ensembles possibles. Aussi
<programlisting>
CUBE ( a, b, c )
</programlisting>
    est équivalent à
<programlisting>
GROUPING SETS (
    ( a, b, c ),
    ( a, b    ),
    ( a,    c ),
    ( a       ),
    (    b, c ),
    (    b    ),
    (       c ),
    (         )
)
</programlisting>
   </para>

   <para>
    Les éléments individuels des clauses <literal>CUBE</literal> ou
    <literal>ROLLUP</literal> peuvent être des expressions individuelles,
    ou des sous-listes d'éléments entre parenthèses. Dans ce dernier
    cas, les sous-listes sont traitées comme simple élément pour la
    génération des ensembles de regroupement individuels.
    Par exemple:
<programlisting>
CUBE ( (a, b), (c, d) )
</programlisting>
    est équivalent à
<programlisting>
GROUPING SETS (
    ( a, b, c, d ),
    ( a, b       ),
    (       c, d ),
    (            )
)
</programlisting>
    et
<programlisting>
ROLLUP ( a, (b, c), d )
</programlisting>
    est équivalent à
<programlisting>
GROUPING SETS (
    ( a, b, c, d ),
    ( a, b, c    ),
    ( a          ),
    (            )
)
</programlisting>
   </para>

   <para>
    Les éléments <literal>CUBE</literal> et <literal>ROLLUP</literal>
    peuvent être utilisés directement dans la clause <literal>GROUP
    BY</literal>, ou imbriqués à l'intérieur d'une clause
    <literal>GROUPING SETS</literal>. Si une clause <literal>GROUPING
    SETS</literal> est imbriquée dans une autre, l'effet est le même
    que si tous les éléments de la clause la plus imbriquée avaient
    été écrits directement dans la clause de niveau supérieure.
   </para>

   <para>
    Si de multiples clauses de regroupement sont indiquées dans une
    simple clause <literal>GROUP BY</literal>, alors la liste finale des
    ensembles de regroupement est le produit cartésien des éléments
    individuels. Par exemple:
<programlisting>
GROUP BY a, CUBE (b, c), GROUPING SETS ((d), (e))
</programlisting>
    est équivalent à
<programlisting>
GROUP BY GROUPING SETS (
    (a, b, c, d), (a, b, c, e),
    (a, b, d),    (a, b, e),
    (a, c, d),    (a, c, e),
    (a, d),       (a, e)
)
</programlisting>
   </para>

  <note>
   <para>
    La syntaxe <literal>(a, b)</literal> est normalement
    reconnue dans les expressions comme un <link linkend="sql-syntax-row-constructors">
    constructeur de ligne</link>. À l'intérieur d'une clause
    <literal>GROUP BY</literal>, cette règle ne s'applique pas au 1er
    niveau d'expressions, et <literal>(a, b)</literal> est reconnu
    comme une liste d'expressions comme décrit ci-dessus. Si pour
    une quelconque raison vous avez <emphasis>besoin</emphasis> d'un
    constructeur de ligne dans une expression de regroupement, utilisez
    <literal>ROW(a, b)</literal>.
   </para>
  </note>
  </sect2>

  <sect2 id="queries-window">
   <title>Traitement de fonctions Window</title>

   <indexterm zone="queries-window">
    <primary>fonction window</primary>
    <secondary>ordre d'exécution</secondary>
   </indexterm>

   <para>
    Si la requête contient une des fonctions Window (voir
    <xref linkend="tutorial-window"/>, <xref linkend="functions-window"/> et
    <xref linkend="syntax-window-functions"/>),
    ces fonctions sont évaluées après que soient effectués les regroupements,
    les aggrégations, les filtrages par <literal>HAVING</literal>.
    C'est-à-dire que si la requête comporte des aggrégat, <literal>GROUP
    BY</literal> ou <literal>HAVING</literal>, alors les enregistrements vus
    par les fonctions window sont les lignes regroupées à la place des
    enregistrements originaux provenant de
    <literal>FROM</literal>/<literal>WHERE</literal>.
   </para>

   <para>
    Quand des fonctions Window multiples sont utilisées, toutes les fonctions
    Window ayant des clauses <literal>PARTITION BY</literal> et <literal>ORDER BY</literal>
    syntaxiquement équivalentes seront à coup sûr évaluées en une seule passe sur
    les données.
    Par conséquent, elles verront le même ordre de tri, même si
    <literal>ORDER BY</literal> ne détermine pas de façon unique un tri.
    Toutefois, aucune garantie n'est faite à propos de l'évaluation de fonctions
    ayant des spécifications de <literal>PARTITION BY</literal> ou
    <literal>ORDER BY</literal> différentes.
    (Dans ces cas, une étape de tri est généralement nécessaire entre les passes
    d'évaluations de fonctions Window, et le tri ne garantit pas la préservation
    de l'ordre des enregistrements que son <literal>ORDER BY</literal> estime
    comme identiques.)
   </para>

   <para>
    À l'heure actuelle, les fonctions window nécessitent toujours des données
    pré-triées, ce qui fait que la sortie de la requête sera triée suivant
    l'une ou l'autre des clauses <literal>PARTITION BY</literal>/<literal>ORDER BY</literal>
    des fonctions Window.
    Il n'est toutefois pas recommandé de s'en servir. Utilisez une clause
    <literal>ORDER BY</literal> au plus haut niveau de la requête si vous
    voulez être sûr que vos résultats soient triés d'une certaine façon.
   </para>
  </sect2>
 </sect1>


 <sect1 id="queries-select-lists">
  <title>Listes de sélection</title>

  <indexterm>
   <primary>SELECT</primary>
   <secondary>liste de sélection</secondary>
  </indexterm>

  <para>
   Comme montré dans la section précédente, l'expression de table pour la
commande <command>SELECT</command> construit une table virtuelle intermédiaire
en combinant les tables, vues, en éliminant les lignes, en groupant, etc. Cette
table est finalement passée à la réalisation de la <firstterm>liste de
sélection</firstterm>. Cette liste détermine les <emphasis>colonnes</emphasis>
de la table intermédiaire à afficher.
  </para>

  <sect2 id="queries-select-list-items">
   <title>Éléments de la liste de sélection</title>

   <indexterm>
    <primary>*</primary>
   </indexterm>

   <para>
    La forme la plus simple de liste de sélection est <literal>*</literal>.
    C'est un raccourci pour indiquer toutes les colonnes que l'expression de
    table produit. Sinon, une liste de sélection est une liste d'expressions
    de valeurs séparées par des virgules (comme défini dans la <xref
    linkend="sql-expressions"/>). Par exemple, cela pourrait être une liste des
    noms de colonnes&nbsp;:
<programlisting>SELECT a, b, c FROM ...</programlisting>
     Les noms de colonnes <literal>a</literal>, <literal>b</literal> et <literal>c</literal> sont
     soit les noms actuels des colonnes des tables référencées dans la clause
     <literal>FROM</literal> soit les alias qui leur ont été donnés (voir l'explication
     dans <xref linkend="queries-table-aliases"/>). L'espace de nom disponible
     dans la liste de sélection est le même que dans la clause <literal>WHERE</literal>
     sauf si le regroupement est utilisé, auquel cas c'est le même que dans la
     clause <literal>HAVING</literal>.
   </para>

   <para>
    Si plus d'une table a une colonne du même nom, le nom de la table doit
aussi être donné comme dans&nbsp;:
<programlisting>SELECT tbl1.a, tbl2.a, tbl1.b FROM ...</programlisting>
    En travaillant avec plusieurs tables, il est aussi utile de demander toutes
    les colonnes d'une table particulière&nbsp;:
<programlisting>SELECT tbl1.*, tbl2.a FROM ...</programlisting>
    (voir aussi la <xref linkend="queries-where"/>)
   </para>

   <para>
    Si une expression de valeur arbitraire est utilisée dans la liste de
    sélection, il ajoute conceptuellement une nouvelle colonne virtuelle dans la
    table renvoyée. L'expression de valeur est évaluée une fois pour chaque
    ligne avec une substitution des valeurs de lignes avec les références de
    colonnes. Mais les expressions de la liste de sélection n'ont pas à
    référencer les colonnes dans l'expression de la table de la clause
    <literal>FROM</literal>&nbsp;; elles pourrait être des expressions arithmétiques
    constantes, par exemple.
   </para>
  </sect2>

  <sect2 id="queries-column-labels">
   <title>Labels de colonnes</title>

   <indexterm zone="queries-column-labels">
    <primary>alias</primary>
    <secondary>dans la liste de sélection</secondary>
   </indexterm>

   <para>
    Les entrées de la liste de sélection peuvent se voir affecter des noms
    pour la suite de l'exécution, peut-être pour référence dans une clause
    <literal>ORDER BY</literal> ou pour affichage par l'application cliente.
    Par exemple&nbsp;:
<programlisting>SELECT a AS valeur, b + c AS sum FROM ...</programlisting>
   </para>

   <para>
    Si aucun nom de colonne en sortie n'est spécifié en utilisant
    <literal>AS</literal>, le système affecte un nom de colonne par défaut.
    Pour les références de colonne simple, c'est le nom de la colonne
    référencée. Pour les appels de fonction, il s'agit du nom de la fonction.
    Pour les expressions complexes, le système générera un nom générique.
   </para>

   <para>
    Le mot clé <literal>AS</literal> est optionnel, mais seulement si le
    nouveau nom de colonne ne correspond à aucun des mots clés
    <productname>PostgreSQL</productname> (voir <xref
    linkend="sql-keywords-appendix"/>). Pour éviter une correspondance
    accidentelle à un mot clé, vous pouvez mettre le nom de colonne entre
    guillemets. Par exemple, <literal>VALUE</literal> est un mot clé, ce qui
    fait que ceci ne fonctionne pas&nbsp;:
<programlisting>
SELECT a valeur, b + c AS somme FROM ...
     </programlisting>
     mais ceci fonctionne&nbsp;:
     <programlisting>
SELECT a "valeur", b + c AS somme FROM ...
     </programlisting>
     Pour vous protéger de possibles ajouts futurs de mots clés, il est recommandé
     de toujours écrire <literal>AS</literal> ou de mettre le nom de colonne de
     sortie entre guillemets.
    </para>

    <note>
     <para>
      Le nom des colonnes en sortie est différent ici de ce qui est fait dans la
      clause <literal>FROM</literal> (voir la <xref linkend="queries-table-aliases"/>).
      Il est possible de renommer deux fois la même colonne mais le nom affecté
      dans la liste de sélection est celui qui sera passé.
     </para>
    </note>
   </sect2>

   <sect2 id="queries-distinct">
    <title><literal>DISTINCT</literal></title>

    <indexterm zone="queries-distinct">
     <primary>DISTINCT</primary>
    </indexterm>

    <indexterm zone="queries-distinct">
     <primary>duplication</primary>
    </indexterm>

    <para>
     Après le traitement de la liste de sélection, la table résultant pourrait
     être optionnellement sujet à l'élimination des lignes dupliquées. Le mot clé
     <literal>DISTINCT</literal> est écrit directement après
     <literal>SELECT</literal> pour spécifier ceci&nbsp;:
     <synopsis>SELECT DISTINCT <replaceable>liste_selection</replaceable> ...</synopsis>
    (au lieu de <literal>DISTINCT</literal>, le mot clé <literal>ALL</literal> peut être
    utilisé pour spécifier le comportement par défaut, la récupération de
    toutes les lignes)
   </para>

   <indexterm>
    <primary>null value</primary>
    <secondary sortas="DISTINCT">in DISTINCT</secondary>
   </indexterm>

   <para>
    Évidemment, les deux lignes sont considérées distinctes si elles diffèrent
    dans au moins une valeur de colonne. Les valeurs NULL sont considérées
    égales dans cette comparaison.
   </para>

   <para>
    Autrement, une expression arbitraire peut déterminer quelles lignes
    doivent être considérées distinctes&nbsp;:
<synopsis>SELECT DISTINCT ON (<replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ...</optional>) <replaceable>liste_selection</replaceable> ... </synopsis>
    Ici, <replaceable>expression</replaceable> est une expression de valeur
    arbitraire, évaluée pour toutes les lignes. Les lignes dont toutes les
    expressions sont égales sont considérées comme dupliquées et seule la
    première ligne de cet ensemble est conservée dans la sortie. Notez que la
    <quote>première ligne</quote> d'un ensemble est non prévisible sauf si la
    requête est triée sur assez de colonnes pour garantir un ordre unique des
    colonnes arrivant dans le filtre <literal>DISTINCT</literal> (le traitement de
    <literal>DISTINCT ON</literal> parvient après le tri de <literal>ORDER BY</literal>).
   </para>

   <para>
    La clause <literal>DISTINCT ON</literal> ne fait pas partie du standard SQL et est
    quelque fois considérée comme étant un mauvais style à cause de la nature
    potentiellement indéterminée de ses résultats. Avec l'utilisation judicieuse
    de <literal>GROUP BY</literal> et de sous-requêtes dans <literal>FROM</literal>, la
    construction peut être évitée mais elle représente souvent l'alternative la
    plus agréable.
   </para>
  </sect2>
 </sect1>


 <sect1 id="queries-union">
  <title>Combiner des requêtes</title>

  <indexterm zone="queries-union">
   <primary>UNION</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>INTERSECT</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>EXCEPT</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set union</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set intersection</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set difference</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set operation</primary>
  </indexterm>

  <para>
   Les résultats de deux requêtes peuvent être combinés en utilisant les
   opérations d'ensemble&nbsp;: union, intersection et différence. La syntaxe
   est
<synopsis><replaceable>requete1</replaceable> UNION <optional>ALL</optional> <replaceable>requete2</replaceable>
<replaceable>requete1</replaceable> INTERSECT <optional>ALL</optional> <replaceable>requete2</replaceable>
<replaceable>requete1</replaceable> EXCEPT <optional>ALL</optional> <replaceable>requete2</replaceable></synopsis>
   <replaceable>requete1</replaceable> et
   <replaceable>requete2</replaceable> sont les requêtes pouvant utiliser
   toutes les fonctionnalités discutées ici. Les opérations d'ensemble peuvent
   aussi être combinées et chaînées, par exemple
<synopsis><replaceable>requete1</replaceable> UNION <replaceable>requete2</replaceable> UNION <replaceable>requete3</replaceable></synopsis>
   est exécuté ainsi&nbsp;:
<synopsis>(<replaceable>requete1</replaceable> UNION <replaceable>requete2</replaceable>) UNION <replaceable>requete3</replaceable></synopsis>
  </para>

  <para>
   <literal>UNION</literal> ajoute effectivement le résultat de
   <replaceable>requete2</replaceable> au résultat de
   <replaceable>requete1</replaceable> (bien qu'il n'y ait pas de garantie
   qu'il s'agit de l'ordre dans lequel les lignes sont réellement renvoyées). De
   plus, il élimine les lignes dupliquées du résultat, de la même façon que
   <literal>DISTINCT</literal>, sauf si <literal>UNION ALL</literal> est utilisée.
  </para>

  <para>
   <literal>INTERSECT</literal> renvoie toutes les lignes qui sont à la fois dans le
   résultat de <replaceable>requete1</replaceable> et dans le résultat de
   <replaceable>requete2</replaceable>. Les lignes dupliquées sont éliminées
   sauf si <literal>INTERSECT ALL</literal> est utilisé.
  </para>

  <para>
   <literal>EXCEPT</literal> renvoie toutes les lignes qui sont dans le résultat de
   <replaceable>requete1</replaceable> mais pas dans le résultat de
   <replaceable>requete2</replaceable> (ceci est quelque fois appelé la
   <firstterm>différence</firstterm> entre deux requêtes). De nouveau, les lignes
   dupliquées sont éliminées sauf si <literal>EXCEPT ALL</literal> est utilisé.
  </para>

  <para>
   Pour calculer l'union, l'intersection ou la différence de deux requêtes, les
   deux requêtes doivent être <quote>compatibles pour une union</quote>, ce qui
   signifie qu'elles doivent renvoyer le même nombre de colonnes et que les
   colonnes correspondantes doivent avoir des types de données compatibles,
   comme décrit dans la <xref linkend="typeconv-union-case"/>.
  </para>
 </sect1>


 <sect1 id="queries-order">
  <title>Tri des lignes</title>

  <indexterm zone="queries-order">
   <primary>tri</primary>
  </indexterm>

  <indexterm zone="queries-order">
   <primary>ORDER BY</primary>
  </indexterm>
	
  <para>
   Après qu'une requête ait produit une table en sortie (après que la liste de
   sélection ait été traitée), elle peut être optionnellement triée. Si le tri
   n'a pas été choisi, les lignes sont renvoyées dans un ordre non spécifié.
   Dans ce cas, l'ordre réel dépendra des types de plan de parcours et de
   jointure et de l'ordre sur le disque mais vous ne devez pas vous y fier. Un
   tri particulier en sortie peut seulement être garantie si l'étape de tri est
   choisie explicitement.
  </para>

  <para>
   La clause <literal>ORDER BY</literal> spécifie l'ordre de tri&nbsp;:
<synopsis>SELECT <replaceable>liste_selection</replaceable>
    FROM <replaceable>expression_table</replaceable>
    ORDER BY <replaceable>expression_tri1</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional>
<optional>, <replaceable>expression_tri2</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional> ...</optional>
     </synopsis>

     Les expressions de tri peuvent être toute expression qui serait valide dans
     la liste de sélection des requêtes. Voici un exemple&nbsp;:
     <programlisting>
SELECT a, b FROM table1 ORDER BY a + b, c;
     </programlisting>
     Quand plus d'une expression est indiquée, les valeurs suivantes sont
     utilisées pour trier les lignes qui sont identiques aux valeurs précédentes.
     Chaque expression pourrait être suivie d'un
     <literal>ASC</literal> ou <literal>DESC</literal> optionnel pour configurer la
     direction du tri (ascendant ou descendant). L'ordre <literal>ASC</literal> est la
     valeur par défaut. L'ordre ascendant place les plus petites valeurs en
     premier où <quote>plus petit</quote> est défini avec l'opérateur
     <literal>&lt;</literal>. De façon similaire, l'ordre descendant est
     déterminé avec l'opérateur <literal>&gt;</literal>.
     <footnote>
      <para>
       En fait, <productname>PostgreSQL</productname> utilise la <firstterm>classe
        d'opérateur B-tree par défaut</firstterm> pour le type de données de
       l'expression pour déterminer l'ordre de tri avec <literal>ASC</literal>
       et <literal>DESC</literal>.
       De façon conventionnelle, les types de données seront initialisés de
       façon à ce que les opérateurs <literal>&lt;</literal> et
       <literal>&gt;</literal> correspondent à cet ordre de tri mais un
       concepteur des types de données définis par l'utilisateur pourrait choisir
       de faire quelque chose de différent.
      </para>
     </footnote>
    </para>

    <para>
     Les options <literal>NULLS FIRST</literal> et <literal>NULLS LAST</literal>
     sont utilisées pour déterminer si les valeurs NULL apparaissent avant ou
     après les valeurs non NULL après un tri. Par défaut, les valeurs NULL sont
     triées comme si elles étaient plus grandes que toute valeur non NULL.
     Autrement dit, <literal>NULLS FIRST</literal> est la valeur par défaut pour
     l'ordre descendant (<literal>DESC</literal>) et <literal>NULLS LAST</literal>
     est la valeur utilisée sinon.
    </para>

    <para>
     Notez que les options de tri sont considérées indépendament pour chaque
     colonne triée. Par exemple, <literal>ORDER BY x, y DESC</literal> signifie
     en fait <literal>ORDER BY x ASC, y DESC</literal>, ce qui est différent de
     <literal>ORDER BY x DESC, y DESC</literal>.
    </para>

    <para>
     Une <replaceable>expression_tri</replaceable> peut aussi être à la place
     le nom ou le numéro d'une colonne en sortie, par exemple&nbsp;:
     <programlisting>SELECT a + b AS sum, c FROM table1 ORDER BY sum;
SELECT a, max(b) FROM table1 GROUP BY a ORDER BY 1;
     </programlisting>
     les deux triant par la première colonne en sortie. Notez qu'un nom de colonne
     en sortie doit être unique, il ne doit pas être utilisé dans une expression
     &mdash; par exemple, ceci n'est <emphasis>pas</emphasis> correct&nbsp;:
     <programlisting>
SELECT a + b AS sum, c FROM table1 ORDER BY sum + c;          -- mauvais
     </programlisting>
     Cette restriction est là pour réduire l'ambiguïté. Il y en a toujours si un
     élément <literal>ORDER BY</literal> est un simple nom qui pourrait
     correspondre soit à un nom de colonne en sortie soit à une colonne d'une
     expression de table. La colonne en sortie est utilisée dans de tels cas.
     Cela causera seulement de la confusion si vous utilisez <literal>AS</literal>
     pour renommer une colonne en sortie qui correspondra à un autre nom de
     colonne d'une table.
    </para>

    <para>
     <literal>ORDER BY</literal> peut être appliqué au résultat d'une combinaison
     <literal>UNION</literal>, d'une combinaison<literal>INTERSECT</literal> ou
     d'une combinaison <literal>EXCEPT</literal> mais, dans ce cas, il est
     seulement permis de trier par les noms ou numéros de colonnes, pas par les
     expressions.
    </para>
   </sect1>


   <sect1 id="queries-limit">
    <title><literal>LIMIT</literal> et <literal>OFFSET</literal></title>

    <indexterm zone="queries-limit">
     <primary>LIMIT</primary>
    </indexterm>

    <indexterm zone="queries-limit">
     <primary>OFFSET</primary>
    </indexterm>

    <para>
     <literal>LIMIT</literal> et <literal>OFFSET</literal> vous permet de retrouver seulement
     une portion des lignes générées par le reste de la requête&nbsp;:
     <synopsis>SELECT <replaceable>liste_selection</replaceable>
    FROM <replaceable>expression_table</replaceable>
    <optional> ORDER BY ...</optional>
    <optional> LIMIT { <replaceable>nombre</replaceable> | ALL } </optional> <optional>OFFSET <replaceable>nombre</replaceable></optional></synopsis>
  </para>

  <para>
   Si un nombre limite est donné, pas plus que ce nombre de lignes sera renvoyé
   (mais peut-être moins si la requête récupère moins de lignes). <literal>LIMIT
   ALL</literal> revient à ne pas spécifier la clause <literal>LIMIT</literal>.
  </para>

  <para>
   <literal>OFFSET</literal> indique de passer ce nombre de lignes avant de renvoyer
   les lignes restantes. <literal>OFFSET 0</literal> revient à oublier la clause
   <literal>OFFSET</literal>, et <literal>LIMIT NULL</literal> revient à oublier
   la clause <literal>LIMIT</literal>. Si à la fois <literal>OFFSET</literal> et <literal>LIMIT</literal>
   apparaissent, alors les <literal>OFFSET</literal> lignes sont laissées avant de
   commencer le renvoi des <literal>LIMIT</literal> lignes.
  </para>

  <para>
   Lors de l'utilisation de <literal>LIMIT</literal>, il est important d'utiliser une
   clause <literal>ORDER BY</literal> contraignant les lignes résultantes dans un ordre
   unique. Sinon, vous obtiendrez un sous-ensemble non prévisible de lignes de
   la requête. Vous pourriez demander les lignes de 10 à 20 mais dans quel
   ordre&nbsp;? L'ordre est inconnu si vous ne spécifiez pas <literal>ORDER
   BY</literal>.
  </para>

  <para>
   L'optimiseur de requêtes prend <literal>LIMIT</literal> en compte lors de la
   génération des plans de requêtes, de façon à ce que vous obteniez
   différents plans (avec différents ordres de lignes) suivant ce que vous
   donnez à <literal>LIMIT</literal> et <literal>OFFSET</literal>. Du coup, utiliser des
   valeurs <literal>LIMIT</literal>/<literal>OFFSET</literal> différentes pour sélectionner
   des sous-ensembles différents d'un résultat de requête <emphasis>donnera des
   résultats inconsistants</emphasis> sauf si vous forcez un ordre de
   résultat prévisible avec <literal>ORDER BY</literal>. Ceci n'est pas un bogue&nbsp;;
   c'est une conséquence inhérente du fait que le SQL ne promette par de
   délivrer les résultats d'une requête dans un ordre particulier sauf si
   <literal>ORDER BY</literal> est utilisé pour contraindre l'ordre.
  </para>

  <para>
   Les lignes passées par une clause <literal>OFFSET</literal> devront toujours être
   traitées à l'intérieur du serveur&nbsp;; du coup, un <literal>OFFSET</literal>
   important peut être inefficace.
  </para>
 </sect1>


 <sect1 id="queries-values">
  <title>Listes <literal>VALUES</literal></title>

  <indexterm zone="queries-values">
   <primary>VALUES</primary>
  </indexterm>

  <para>
   <literal>VALUES</literal> fournit une façon de générer une table de
   <quote>constantes</quote> qui peut être utilisé dans une requête sans
   avoir à réellement créer et peupler une table sur disque. La syntaxe est
<synopsis>
VALUES ( <replaceable class="parameter">expression</replaceable> [, ...] ) [, ...]
     </synopsis>
     Chaque liste d'expressions entre parenthèses génère une ligne dans la table.
     Les listes doivent toutes avoir le même nombre d'éléments (c'est-à-dire une
     liste de colonnes dans la table), et les entrées correspondantes dans chaque
     liste doivent avoir des types compatibles. Le type réel affecté à chaque colonne
     du résultat est déterminé en utilisant les mêmes règles que pour
     <literal>UNION</literal> (voir <xref linkend="typeconv-union-case"/>).
    </para>

    <para>
     Voici un exemple&nbsp;:

     <programlisting>VALUES (1, 'un'), (2, 'deux'), (3, 'trois');
     </programlisting>

     renverra une table de deux colonnes et trois lignes. C'est équivalent à&nbsp;:

     <programlisting>SELECT 1 AS column1, 'un' AS column2
UNION ALL
SELECT 2, 'deux'
UNION ALL
SELECT 3, 'trois';
     </programlisting>

     Par défaut, <productname>PostgreSQL</productname> affecte les noms
     <literal>column1</literal>, <literal>column2</literal>, etc. aux colonnes
     d'une table <literal>VALUES</literal>. Les noms des colonnes ne sont pas
     spécifiés par le standard SQL et les différents SGBD le font de façon
     différente. Donc, il est généralement mieux de surcharger les noms par
     défaut avec une liste d'alias, comme ceci&nbsp;:
     <programlisting>
=> SELECT * FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three')) AS t (num,letter);
 num | letter
-----+--------
   1 | one
   2 | two
   3 | three
(3 rows)
     </programlisting>
    </para>

    <para>
     Syntaxiquement, <literal>VALUES</literal> suivi par une liste d'expressions
     est traité de la même façon que
     <synopsis>SELECT <replaceable>liste_select</replaceable> FROM <replaceable>expression_table</replaceable>
     </synopsis>
     et peut apparaître partout où un <literal>SELECT</literal> le peut. Par
     exemple, vous pouvez l'utiliser comme élément d'un <literal>UNION</literal>
     ou y attacher une <replaceable>spécification de tri</replaceable>
     (<literal>ORDER BY</literal>, <literal>LIMIT</literal> et/ou <literal>OFFSET</literal>).
     <literal>VALUES</literal> est habituellement utilisée comme source de données
     dans une commande <command>INSERT</command> command, mais aussi dans une
     sous-requête.
    </para>

    <para>
     Pour plus d'informations, voir <xref linkend="sql-values"/>.
    </para>

   </sect1>


   <sect1 id="queries-with">
    <title>Requêtes <literal>WITH</literal> (<foreignphrase>Common Table
      Expressions</foreignphrase>)</title>

    <indexterm zone="queries-with">
     <primary>WITH</primary>
     <secondary>dans SELECT</secondary>
    </indexterm>

    <indexterm>
     <primary>common table expression</primary>
     <see>WITH</see>
    </indexterm>

    <para>
     <literal>WITH</literal> fournit un moyen d'écrire des ordres
     auxiliaires pour les util ser dans des requêtes plus importantes. Ces
     requêtes, qui sont souvent appelées Common Table Expressions ou
     <acronym>CTE</acronym>, peuvent être vues comme des tables temporaires
     qui n'existent que pour une requête. Chaque ordre auxiliaire dans une
     clause <literal>WITH</literal> peut être un <command>SELECT</command>,
     <command>INSERT</command>, <command>UPDATE</command>, ou
     <command>DELETE</command>; et la clause <literal>WITH</literal>
     elle même est attachée à un ordre primaire qui peut lui aussi
     être un <command>SELECT</command>, <command>INSERT</command>,
     <command>UPDATE</command>, ou <command>DELETE</command>.
    </para>

    <sect2 id="queries-with-select">
     <title><command>SELECT</command> dans <literal>WITH</literal></title>

     <para>
      L'intérêt de <command>SELECT</command> dans <literal>WITH</literal> est de
      diviser des requêtes complexes en parties plus simples. Un exemple est:

      <programlisting>WITH ventes_regionales AS (
        SELECT region, SUM(montant) AS ventes_totales
        FROM commandes
        GROUP BY region
     ), meilleures_regions AS (
        SELECT region
        FROM ventes_regionales
        WHERE ventes_totales &gt; (SELECT SUM(ventes_totales)/10 FROM ventes_regionales)
     )
SELECT region,
       produit,
       SUM(quantite) AS unites_produit,
       SUM(montant) AS ventes_produit
FROM commandes
WHERE region IN (SELECT region FROM meilleures_regions)
GROUP BY region, produit;</programlisting>

   qui affiche les totaux de ventes par produit dans seulement les régions
   ayant les meilleures ventes.
   La clause <literal>WITH</literal> définit deux ordres
   auxiliaires appelés <structname>ventes_regionales</structname>
   et <structname>meilleures_regions</structname>, où la sortie
   de <structname>ventes_regionales</structname> est utilisé dans
   <structname>meilleures_regions</structname> et la sortie de
   <structname>meilleures_regions</structname> est utilisée dans la
   requête <command>SELECT</command> primaire.
   Cet exemple aurait pu être écrit sans
   <literal>WITH</literal>, mais aurait alors nécessité deux niveaux de
   sous-<command>SELECT</command> imbriqués. Les choses sont un peu plus faciles à suivre de cette
   façon.
  </para>

  <para>
   Le modificateur optionnel <literal>RECURSIVE</literal> fait passer
   <literal>WITH</literal> du statut de simple aide syntaxique à celui de
   quelque chose qu'il serait impossible d'accomplir avec du SQL standard.
   Grâce à <literal>RECURSIVE</literal>, une requête <literal>WITH</literal>
   peut utiliser sa propre sortie. Un exemple très simple se trouve dans cette
   requête, qui ajoute les nombres de 1 à 100&nbsp;:

<programlisting>WITH RECURSIVE t(n) AS (
    VALUES (1)
  UNION ALL
    SELECT n+1 FROM t WHERE n &lt; 100
)
SELECT sum(n) FROM t;</programlisting>

   La forme générale d'une requête <literal>WITH</literal> est toujours un
   <firstterm>terme non-recursif</firstterm>, puis <literal>UNION</literal> (ou
   <literal>UNION ALL</literal>), puis un <firstterm>terme récursif</firstterm>.
   Seul le terme récursif peut contenir une référence à la sortie propre de la
   requête. Une requête de ce genre est exécutée comme suit&nbsp;:
  </para>

  <procedure>
   <title>Évaluation de requête récursive</title>

   <step performance="required">
    <para>
     Évaluer le terme non récursif. Pour <literal>UNION</literal> (mais pas
     <literal>UNION ALL</literal>), supprimer les enregistrements en double.
     Inclure le reste dans le résultat de la requête récursive et le mettre
     aussi dans une table temporaire de travail (<firstterm>working table</firstterm>.)
    </para>
   </step>

   <step performance="required">
    <para>
     Tant que la table de travail n'est pas vide, répéter ces étapes&nbsp;:
    </para>
    <substeps>
     <step performance="required">
      <para>
       Évaluer le terme récursif, en substituant à la référence récursive
       le contenu courant de la table de travail.
       Pour <literal>UNION</literal> (mais pas <literal>UNION ALL</literal>),
       supprimer les doublons, ainsi que les enregistrements en doublon des
       enregistrements déjà obtenus. Inclure les enregistrements restants dans
       le résultat de la requête récursive, et les mettre aussi dans une table
       temporaire intermédiaire (<firstterm>intermediate table</firstterm>).
      </para>
     </step>

     <step performance="required">
      <para>
       Remplacer le contenu de la table de travail par celui de la table
       intermédiaire, puis supprimer la table intermédiaire.
      </para>
     </step>
    </substeps>
   </step>
  </procedure>

  <note>
   <para>
    Dans son appellation stricte, ce processus est une itération, pas une
    récursion, mais <literal>RECURSIVE</literal> est la terminologie choisie
    par le comité de standardisation de SQL.
   </para>
  </note>

  <para>
   Dans l'exemple précédent, la table de travail a un seul enregistrement à
   chaque étape, et il prend les valeurs de 1 à 100 en étapes successives.
   À la centième étape, il n'y a plus de sortie en raison de la clause
   <literal>WHERE</literal>, ce qui met fin à la requête.
  </para>

  <para>
   Les requêtes récursives sont utilisées généralement pour traiter des données
   hiérarchiques ou sous forme d'arbres. Cette requête est un exemple utile
   pour trouver toutes les sous-parties directes et indirectes d'un produit,
   si seule une table donne toutes les inclusions immédiates&nbsp;:

<programlisting>WITH RECURSIVE parties_incluses(sous_partie, partie, quantite) AS (
    SELECT sous_partie, partie, quantite FROM parties WHERE partie = 'notre_produit'
  UNION ALL
    SELECT p.sous_partie, p.partie, p.quantite
    FROM parties_incluses pr, parties p
    WHERE p.partie = pr.sous_partie
  )
SELECT sous_partie, SUM(quantite) as quantite_totale
FROM parties_incluses
GROUP BY sous_partie</programlisting>
  </para>

  <para>
   Quand on travaille avec des requêtes récursives, il est important d'être sûr
   que la partie récursive de la requête finira par ne retourner aucun enregistrement,
   au risque sinon de voir la requête boucler indéfiniment. Quelquefois, utiliser
   <literal>UNION</literal> à la place de <literal>UNION ALL</literal> peut
   résoudre le problème en supprimant les enregistrements qui doublonnent ceux déjà
   retournés. Toutefois, souvent, un cycle ne met pas en jeu des enregistrements de
   sortie qui sont totalement des doublons&nbsp;: il peut s'avérer nécessaire de
   vérifier juste un ou quelques champs, afin de s'assurer que le même point a déjà
   été atteint précédemment. La méthode standard pour gérer ces situations est de
   calculer un tableau de valeurs déjà visitées. Par exemple, observez la requête
   suivante, qui parcourt une table <structname>graphe</structname> en utilisant
   un champ <structfield>lien</structfield>&nbsp;:

<programlisting>
WITH RECURSIVE parcourt_graphe(id, lien, donnee, profondeur) AS (
        SELECT g.id, g.lien, g.donnee, 1
        FROM graphe g
      UNION ALL
        SELECT g.id, g.lien, g.donnee, sg.profondeur + 1
        FROM graphe g, parcourt_graphe sg
        WHERE g.id = sg.lien
)
SELECT * FROM parcourt_graphe;
      </programlisting>

      Cette requête va boucler si la liaison <structfield>lien</structfield>
      contient des boucles. Parce que nous avons besoin de la sortie
      <quote>profondeur</quote>, simplement remplacer <literal>UNION ALL</literal>
      par <literal>UNION</literal> ne résoudra pas le problème.
      À la place, nous avons besoin d'identifier si nous avons atteint un enregistrement
      que nous avons déjà traité pendant notre parcours des liens. Nous ajoutons
      deux colonnes <structfield>chemin</structfield> et <structfield>boucle</structfield>
      à la requête&nbsp;:
      <programlisting>
WITH RECURSIVE parcourt_graphe(id, lien, donnee, profondeur, chemin, boucle) AS (
        SELECT g.id, g.lien, g.donnee, 1,
          ARRAY[g.id],
          false
        FROM graphe g
      UNION ALL
        SELECT g.id, g.lien, g.donnee, sg.profondeur + 1,
          chemin || g.id,
          g.id = ANY(chemin)
        FROM graphe g, parcourt_graphe sg
        WHERE g.id = sg.lien AND NOT boucle
)
SELECT * FROM parcourt_graphe;
      </programlisting>

      En plus de prévenir les boucles, cette valeur de tableau est souvent pratique
      en elle-même pour représenter le <quote>chemin</quote> pris pour atteindre
      chaque enregistrement.
     </para>

     <para>
      De façon plus générale, quand plus d'un champ a besoin d'être vérifié pour
      identifier une boucle, utilisez un tableau d'enregistrements. Par exemple,
      si nous avions besoin de comparer les champs <structfield>f1</structfield> et
      <structfield>f2</structfield>&nbsp;:

      <programlisting>
WITH RECURSIVE parcourt_graphe(id, lien, donnee, profondeur, chemin, boucle) AS (
        SELECT g.id, g.lien, g.donnee, 1,
          ARRAY[ROW(g.f1, g.f2)],
          false
        FROM graphe g
      UNION ALL
        SELECT g.id, g.lien, g.donnee, sg.profondeur + 1,
          chemin || ROW(g.f1, g.f2),
          ROW(g.f1, g.f2) = ANY(path)
        FROM graphe g, parcourt_graphe sg
        WHERE g.id = sg.link AND NOT boucle
)
SELECT * FROM parcourt_graphe;
      </programlisting>
     </para>

     <tip>
      <para>
       Omettez la syntaxe <literal>ROW()</literal> dans le cas courant où un seul
       champ a besoin d'être testé pour déterminer une boucle. Ceci permet, par
       l'utilisation d'un tableau simple plutôt que d'un tableau de type composite,
       de gagner en efficacité.
      </para>
     </tip>

     <tip>
      <para>
       L'algorithme d'évaluation récursive de requête produit sa sortie en ordre
       de parcours en largeur (algorithme <foreignphrase>breadth-first</foreignphrase>).
       Vous pouvez afficher les résultats en ordre de parcours en profondeur
       (<foreignphrase>depth-first</foreignphrase>) en faisant sur la requête
       externe un <literal>ORDER BY</literal> sur une colonne <quote>chemin</quote>
       construite de cette façon.
      </para>
     </tip>

     <para>
      Si vous n'êtes pas certain qu'une requête peut boucler, une astuce pratique
      pour la tester est d'utiliser <literal>LIMIT</literal> dans la requête parente.
      Par exemple, cette requête bouclerait indéfiniment sans un
      <literal>LIMIT</literal>&nbsp;:

      <programlisting>
WITH RECURSIVE t(n) AS (
    SELECT 1
  UNION ALL
    SELECT n+1 FROM t
)
SELECT n FROM t LIMIT 100;
      </programlisting>

      Ceci fonctionne parce que l'implémentation de <productname>PostgreSQL</productname>
      n'évalue que le nombre d'enregistrements de la requête <literal>WITH</literal>
      récupérés par la requête parente. L'utilisation de cette astuce en production
      est déconseillée parce que d'autres systèmes pourraient fonctionner différemment.
      Par ailleurs, cela ne fonctionnera pas si vous demandez à la requête externe
      de trier les résultats de la requête récursive, ou si vous les joignez à une
      autre table, parce dans ces cas, la requête exterieure essaiera habituellement
      de récupérer toute la sortie de la requête <literal>WITH</literal> de toutes façons.
     </para>

     <para>
      Une propriété intéressante des requêtes <literal>WITH</literal> est qu'elles
      ne sont évaluées qu'une seule fois par exécution de la requête parente ou
      des requêtes <literal>WITH</literal> s&oelig;urs.
      Par conséquent, les calculs coûteux qui sont nécessaires à plusieurs endroits
      peuvent être placés dans une requête <literal>WITH</literal> pour éviter le
      travail redondant. Un autre intérêt peut être d'éviter l'exécution multiple
      d'une fonction ayant des effets de bord.
      Toutefois, le revers de la médaille est que l'optimiseur est moins capable
      d'extrapoler les restrictions de la requête parente vers une requête
      <literal>WITH</literal> que vers une sous-requête classique. La requête
      <literal>WITH</literal> sera généralement exécutée telle quelle, sans
      suppression d'enregistrements, que la requête parente devra supprimer ensuite.
      (Mais, comme mentionné précédemment, l'évaluation pourrait s'arrêter rapidement
      si la (les) référence(s) à la requête ne demande(nt) qu'un nombre limité
      d'enregistrements).
     </para>

     <para>
      Les exemples précédents ne montrent que des cas d'utilisation de <literal>WITH</literal>
      avec <command>SELECT</command>, mais on peut les attacher de la même façon à un
      <command>INSERT</command>, <command>UPDATE</command>, ou <command>DELETE</command>.
      Dans chaque cas, le mécanisme fournit en fait des tables temporaires auxquelles on
      peut faire référence dans la commande principale.
     </para>
    </sect2>

    <sect2 id="queries-with-modifying">
     <title>Ordres de Modification de Données avec <literal>WITH</literal></title>

     <para>
      Vous pouvez utiliser des ordres de modification de données (<command>INSERT</command>,
      <command>UPDATE</command>, ou <command>DELETE</command>) dans <literal>WITH</literal>. Cela
      vous permet d'effectuer plusieurs opérations différentes dans la même requête.
      Par exemple:

      <programlisting>
WITH lignes_deplacees AS (
    DELETE FROM produits
    WHERE
        "date" &gt;= '2010-10-01' AND
        "date" &lt; '2010-11-01'
    RETURNING *
)
INSERT INTO log_produits
SELECT * FROM lignes_deplacees;
      </programlisting>

      Cette requête déplace les enregistrements de <structname>produits</structname> vers
      <structname>log_produits</structname>. Le <structname>DELETE</structname> du <literal>WITH</literal>
      supprime les enregistrements spécifiés de <structname>produits</structname>, en retournant leurs
      contenus par la clause <literal>RETURNING</literal>; puis la requête primaire lit cette sortie et
      l'insère dans <structname>log_produits</structname>.
     </para>

     <para>
      Un point important à noter de l'exemple précédent est que la clause <literal>WITH</literal>
      est attachée à l'<command>INSERT</command>, pas au sous-<command>SELECT</command> de l'
      <command>INSERT</command>. C'est nécessaire parce que les ordres de modification de données
      ne sont autorisés que dans les clauses <literal>WITH</literal> qui sont attachées à l'ordre de
      plus haut niveau. Toutefois, les règles de visibilité normales de <literal>WITH</literal>
      s'appliquent, il est donc possible de faire référence à la sortie du <literal>WITH</literal>
      dans le sous-<command>SELECT</command>.
     </para>

     <para>
      Les ordres de modification de données dans <literal>WITH</literal> ont habituellement
      des clauses <literal>RETURNING</literal>, comme dans l'exemple précédent.
      C'est la sortie de la clause <literal>RETURNING</literal> <emphasis>pas</emphasis> la
      table cible de l'ordre de modification de données, qui forme la table temporaire à laquelle
      on pourra faire référence dans le reste de la requête. Si un ordre de
      modification de données dans <literal>WITH</literal> n'a pas de clause <literal>RETURNING</literal>,
      alors il ne produit pas de table temporaire et ne peut pas être utilisé dans le reste de la requête.
      Un ordre de ce type sera toutefois exécuté.
      En voici un exemple (dénué d'intérêt):

      <programlisting>
WITH t AS (
    DELETE FROM foo
)
DELETE FROM bar;
      </programlisting>

      Cet exemple supprimerait tous les éléments des tables <structname>foo</structname> et
      <structname>bar</structname>. Le nombre d'enregistrements retourné au client n'incluerait
      que les enregistrements supprimés de <structname>bar</structname>.
     </para>

     <para>
      Les auto-références récursives dans les ordres de modification de données ne
      sont pas autorisées. Dans certains cas, il est possible de contourner cette limitation
      en faisant référence à la sortie d'un <literal>WITH</literal>, par exemple:

      <programlisting>
WITH RECURSIVE pieces_incluses(sous_piece, piece) AS (
    SELECT sous_piece, piece FROM pieces WHERE piece = 'notre_produit'
  UNION ALL
    SELECT p.sous_piece, p.piece
    FROM pieces_incluses pr, pieces p
    WHERE p.piece = pr.sous_piece
  )
DELETE FROM pieces
  WHERE piece IN (SELECT piece FROM pieces_incluses);
      </programlisting>
      Cette requête supprimerait toutes les pièces directes et indirectes d'un produit.
     </para>

     <para>
      Les ordres de modification de données dans <literal>WITH</literal> sont exécutées exactement
      une fois, et toujours jusqu'à la fin, indépendamment du fait que la requête primaire
      lise tout (ou même une partie) de leur sortie. Notez que c'est différent de la règle pour
      <command>SELECT</command> dans <literal>WITH</literal>: comme précisé dans la section précédente,
      l'exécution d'un <command>SELECT</command> est n'est poursuivie que tant que la requête primaire
      consomme sa sortie.
     </para>

     <para>
      Les sous-requêtes du <literal>WITH</literal> sont toutes exécutées simultanément et
      simultanément avec la requête principale. Par conséquent, quand vous utilisez un ordre de
      modification de données avec <literal>WITH</literal>, l'ordre dans lequel les mises à jour
      sont effectuées n'est pas prévisible. Toutes les requêtes sont exécutées dans le même
      <firstterm>instantané</firstterm> (voyez <xref linkend="mvcc" />), elles ne peuvent donc pas
      voir les effets des autres sur les tables cibles. Ceci rend sans importance le problème de
      l'imprévisibilité de l'ordre des mises à jour, et signifie que <literal>RETURNING</literal> est
      la seule façon de communiquer les modifications entre les difféntes sous-requêtes
      <literal>WITH</literal> et la requête principale. En voici un exemple:

      <programlisting>
WITH t AS (
    UPDATE produits SET prix = prix * 1.05
    RETURNING *
)
SELECT * FROM produits;
      </programlisting>

      le <command>SELECT</command> externe retournerait les prix originaux avant
      l'action de <command>UPDATE</command>, alors que

      <programlisting>
WITH t AS (
    UPDATE produits SET prix = prix * 1.05
    RETURNING *
)
SELECT * FROM t;
      </programlisting>

      le <command>SELECT</command> externe retournerait les données mises à jour.
     </para>

     <para>
      Essayer de mettre à jour le même enregistrement deux fois dans le même ordre
      n'est pas supporté. Seule une des deux modifications a lieu, mais il n'est pas
      aisé (et quelquefois pas possible) de déterminer laquelle. Ceci s'applique aussi
      pour la suppression d'un enregistrement qui a déjà été mis à jour dans le même ordre:
      seule la mise à jour est effectuée. Par conséquent, vous devriez éviter en règle
      générale de mettre à jour le même enregistrement deux fois en un seul ordre. En
      particulier, évitez d'écrire des sous-requêtes qui modifieraient les mêmes enregistrements
      que la requête principale ou une autre sous-requête. Les effets d'un ordre de ce type seraient
      imprévisibles.
     </para>

     <para>
      À l'heure actuelle, les tables utilisées comme cibles d'un ordre modifiant les données
      dans un <literal>WITH</literal> ne doivent avoir ni règle conditionnelle, ni règle
      <literal>ALSO</literal>, ni une règle <literal>INSTEAD</literal> qui génère plusieurs ordres.
     </para>

    </sect2>

   </sect1>

  </chapter>
