<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="maintenance">
 <title>Planifier les tâches de maintenance</title>

 <indexterm zone="maintenance">
  <primary>maintenance</primary>
 </indexterm>

 <indexterm zone="maintenance">
  <primary>routine maintenance</primary>
 </indexterm>

  <para>
   <productname>PostgreSQL</productname>, comme tout SGBD, requiert que certains
   tâches soient réalisées de façon régulière pour atteindre les performances
   optimales. Ces tâches sont <emphasis>requises</emphasis>,
   mais elles sont répétitives par nature et peuvent être facilement automatisées
   en utilisant des outils standard comme les scripts
   <application>cron</application> ou le <application>Task Scheduler</application>
   de Windows. La responsabilité de la mise en place de ces
   scripts et du contrôle de leur bon fonctionnement relève de l'administrateur
   de la base.
  </para>

  <para>
   Une opération de maintenance évidente est la sauvegarde régulière des
   données. Sans une sauvegarde récente, il est impossible de restaurer après
   un dommage grave (perte d'un disque, incendie, table supprimée par erreur,
   etc.). Les mécanismes de sauvegarde et restauration disponibles dans
   <productname>PostgreSQL</productname> sont détaillés dans le <xref
   linkend="backup"/>.
  </para>

  <para>
   L'autre tâche primordiale est la réalisation périodique d'un <quote>vacuum</quote>,
   c'est à dire <quote>faire le vide</quote> dans la base de données.
   Cette opération est détaillée dans la <xref linkend="routine-vacuuming"/>.
   La mise à jour des statistiques utilisées par le planificateur de
   requêtes sera discutée dans <xref linkend="vacuum-for-statistics"/>.
  </para>

  <para>
   La gestion du fichier de traces mérite aussi une attention régulière.
   Cela est détaillé dans la <xref linkend="logfile-maintenance"/>.
  </para>

  <para>
   <ulink
   url="http://bucardo.org/wiki/Check_postgres"><application>check_postgres</application></ulink>
   est disponible pour surveiller la santé des bases de données et pour
   rapporter des conditions inhabituelles. <application>check_postgres</application>
   s'intègre bien avec Nagios et MRTG, mais il peut aussi fonctionner de façon autonome.
  </para>

  <para>
   <productname>PostgreSQL</productname> demande peu de maintenance par rapport
   à d'autres SGBD. Néanmoins, un suivi vigilant de ces tâches participera
   beaucoup à rendre le système productif et agréable à utiliser.
  </para>

 <sect1 id="routine-vacuuming">
  <title>Nettoyages réguliers</title>

  <indexterm zone="routine-vacuuming">
   <primary>vacuum</primary>
  </indexterm>

  <para>
   Le SGBD <productname>PostgreSQL</productname> nécessite des opérations de
   maintenance périodiques, connues sous le nom de <firstterm>VACUUM</firstterm>.
   Pour de nombreuses installations, il est suffisant de laisser travailler le
   <firstterm>démon autovacuum</firstterm>, qui est décrit dans <xref
   linkend="autovacuum"/>. En fonction des cas, les paramètres
   de cet outil peuvent être optimisés pour obtenir de meilleurs résultats.
   Certains administrateurs de bases de données voudront suppléer ou remplacer
   les activités du démon avec une gestion manuelle des commandes
   <command>VACUUM</command>, qui seront typiquement exécutées suivant un
   planning par des scripts <application>cron</application> ou par le
   <application>Task Scheduler</application>. Pour configurer une gestion
   manuelle et correcte du VACUUM, il est essentiel de bien comprendre les
   quelques sous-sections suivantes. Les administrateurs qui se basent sur
   l'autovacuum peuvent toujours lire ces sections pour les aider à comprendre
   et à ajuster l'autovacuum.
  </para>

  <sect2 id="vacuum-basics">
   <title>Bases du VACUUM</title>

  <para>
   La commande <xref linkend="sql-vacuum"/> de
   <productname>PostgreSQL</productname> doit traiter chaque table régulièrement
   pour plusieurs raisons&nbsp;:

    <orderedlist>
     <listitem>
      <simpara>pour récupérer ou ré-utiliser l'espace disque occupé par les lignes supprimées
      ou mises à jour&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>pour mettre à jour les statistiques utilisées par l'optimiseur de
      <productname>PostgreSQL</productname>&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>pour prévenir la perte des données les plus anciennes à cause
      d'un <firstterm>cycle de l'identifiant de transaction (XID)</firstterm>.</simpara>
     </listitem>
    </orderedlist>

    Chacune de ces raisons impose de réaliser des opérations <command>VACUUM</command>
    de différentes fréquences et portées, comme expliqué dans les sous-sections
    suivantes.
   </para>

   <para>
    Il y a deux variantes de la commande <command>VACUUM</command>&nbsp;:
    <command>VACUUM</command> standard et <command>VACUUM FULL</command>.
    <command>VACUUM FULL</command> peut récupérer davantage d'espace disque mais
    s'exécute beaucoup plus lentement. Par ailleurs, la forme standard de
    <command>VACUUM</command> peut s'exécuter en parallèle avec les opérations
    de production des bases. Des commandes comme <command>SELECT</command>,
    <command>INSERT</command>, <command>UPDATE</command> et
    <command>DELETE</command> continuent de fonctionner de façon normale,
    mais la définition d'une table ne peut être modifiée avec des
    commandes telles que <command>ALTER TABLE</command> pendant le <command>VACUUM</command>.
    <command>VACUUM FULL</command> nécessite un verrou exclusif sur la table sur
    laquelle il travaille, et ne peut donc pas être exécuté en parallèle avec une
    autre activité sur la table. En règle générale,
    par conséquent, les administrateurs doivent s'efforcer d'utiliser la commande
    standard <command>VACUUM</command> et éviter <command>VACUUM FULL</command>.
   </para>

   <para>
    <command>VACUUM</command> produit un nombre important d'entrées/sorties,
    ce qui peut entraîner de mauvaises performances pour les autres sessions
    actives. Des paramètres de configuration peuvent être ajustés pour réduire
    l'impact d'une opération VACUUM en arrière plan sur les
    performances&nbsp;&mdash; voir
    <xref linkend="runtime-config-resource-vacuum-cost"/>.
   </para>
  </sect2>

  <sect2 id="vacuum-for-space-recovery">
   <title>Récupérer l'espace disque</title>

   <indexterm zone="vacuum-for-space-recovery">
    <primary>espace disque</primary>
   </indexterm>

   <para>
    Avec <productname>PostgreSQL</productname>, les versions périmées des
    lignes ne sont pas immédiatement supprimées après une commande
    <command>UPDATE</command> ou <command>DELETE</command>.  Cette approche est
    nécessaire pour la consistance des accès
    concurrents (<acronym>MVCC</acronym>, voir le <xref linkend="mvcc"/>)&nbsp;: la version de la ligne ne
    doit pas être supprimée tant qu'elle est susceptible d'être lue par une
    autre transaction. Mais finalement, une ligne qui est plus vieille que
    toutes les transactions en cours n'est plus utile du tout. La place qu'elle
    utilise doit être rendue pour être réutilisée par d'autres lignes afin
    d'éviter un accroissement constant, sans limite, du volume occupé sur le disque. Cela est
    réalisé en exécutant <command>VACUUM</command>.
   </para>

   <para>
    La forme standard de <command>VACUUM</command> élimine les versions 
    d'enregistrements morts dans les tables et les index, et marque l'espace
    comme réutilisable. Néanmoins, il ne rend pas cet espace au système
    d'exploitation, sauf dans le cas spécial où des pages à la fin d'une table
    deviennent totalement vides et qu'un verrou exclusif
    sur la table peut être obtenu aisément. Par opposition, <command>VACUUM FULL</command> compacte
    activement les tables en écrivant une nouvelle version complète du fichier
    de la table, sans espace vide. Ceci réduit la taille de la table mais peut
    prendre beaucoup de temps. Cela requiert aussi un espace disque
    supplémentaire pour la nouvelle copie de la table jusqu'à la fin de
    l'opération.
   </para>

   <para>
    Le but habituel d'un vacuum régulier est de lancer des <command>VACUUM</command>
    standard suffisamment souvent pour éviter d'avoir recours à
    <command>VACUUM FULL</command>. Le démon autovacuum essaie de fonctionner de
    cette façon, et n'exécute jamais de <command>VACUUM FULL</command>. Avec
    cette approche, l'idée directrice n'est pas de maintenir les tables à leur
    taille minimale, mais de maintenir l'utilisation de l'espace disque à un niveau
    constant&nbsp;: chaque table occupe l'espace équivalent à sa taille minimum plus
    la quantité d'espace consommée entre deux vacuums. Bien que <command>VACUUM FULL</command>
    puisse être utilisé pour retourner une table à sa taille minimale et rendre
    l'espace disque au système d'exploitation, cela ne sert pas à grand chose,
    si cette table recommence à grossir dans un futur proche. Par conséquent,
    cette approche s'appuyant sur des commandes <command>VACUUM</command>
    exécutées à intervalles modérément rapprochés est une meilleure approche que
    d'exécuter des <command>VACUUM FULL</command> espacés pour des tables
    mises à jour de façon intensive.
   </para>

   <para>
    Certains administrateurs préfèrent planifier le passage de <command>VACUUM</command>
    eux-mêmes, par exemple faire le travail de nuit, quand la charge est faible.
    La difficulté avec cette stratégie est que si une table a un pic d'activité
    de mise à jour inattendu, elle peut grossir au point qu'un
    <command>VACUUM FULL</command> soit vraiment nécessaire pour récupérer
    l'espace. L'utilisation du démon d'autovacuum minore ce problème, puisque
    le démon planifie les vacuum de façon dynamique, en réponse à l'activité
    de mise à jour. Il est peu raisonnable de désactiver totalement le démon,
    sauf si l'activité de la base est extrêmement prévisible. Un compromis possible
    est de régler les paramètres du démon afin qu'il ne réagisse qu'à une activité
    exceptionnellement lourde de mise à jour, de sorte à éviter seulement de perdre
    totalement le contrôle de la volumétrie, tout en laissant les 
    <command>VACUUM</command> planifiés faire le gros du travail quand la charge
    est normale.
   </para>

   <para>
    Pour ceux qui n'utilisent pas autovacuum, une approche typique alternative est de
    planifier un <command>VACUUM</command> sur la base complète une fois
    par jour lorsque l'utilisation n'est pas grande, avec en plus des
    opérations de <command>VACUUM</command> plus fréquentes pour les tables
    très impactées par des mises à jour, de la façon adéquate.
    (Certaines installations avec énormément de mises à jour peuvent exécuter
    des VACUUM toutes les quelques minutes.) Lorsqu'il y a plusieurs bases dans
    un cluster, il faut penser à exécuter un <command>VACUUM</command> sur
    chacune d'elles&nbsp;; le programme <xref
    linkend="app-vacuumdb"/> peut être utile.
   </para>

   <tip>
   <para>
    Le <command>VACUUM</command> simple peut ne pas suffire
    quand une table contient un grand nombre d'enregistrements morts comme
    conséquence d'une mise à jour ou suppression massive. Dans ce cas, s'il est
    nécessaire de récupérer l'espace disque
    gaspillé, <command>VACUUM FULL</command> peut être utilisé,
    <xref linkend="sql-cluster"/> ou une des variantes de <xref
    linkend="sql-altertable"/>.
    Ces commandes écrivent une nouvelle copie de la table et lui adjoignent de nouveaux
    index. Toutes ces options nécessitent un verrou exclusif.
    Elles utilisent aussi temporairement un espace disque supplémentaire,
    approximativement égal à la taille de la table, car les anciennes copies de
    la table et des index ne peuvent pas être supprimées avant la fin de
    l'opération.
   </para>
   </tip>

   <tip>
   <para>
    Si le contenu d'une table est supprimé périodiquement, il est préférable
    d'envisager l'utilisation de <xref linkend="sql-truncate"/>, plutôt que
    <command>DELETE</command> suivi de <command>VACUUM</command>.
    <command>TRUNCATE</command> supprime le contenu entier de la table
    immédiatement sans nécessiter de <command>VACUUM</command> ou
    <command>VACUUM FULL</command> pour réclamer l'espace disque maintenant
    inutilisé.
    L'inconvénient est la violation des sémantiques MCC strictes.
   </para>
   </tip>
  </sect2>

  <sect2 id="vacuum-for-statistics">
   <title>Maintenir les statistiques du planificateur</title>

   <indexterm zone="vacuum-for-statistics">
    <primary>statistiques</primary>
    <secondary>du planificateur</secondary>
   </indexterm>

   <indexterm zone="vacuum-for-statistics">
    <primary>ANALYZE</primary>
   </indexterm>

   <para>
    L'optimiseur de requêtes de <productname>PostgreSQL</productname> s'appuie
    sur des informations statistiques sur le contenu des tables dans l'optique
    de produire des plans d'exécutions efficaces pour les requêtes. Ces
    statistiques sont collectées par la commande <xref linkend="sql-analyze"/>, qui peut
    être invoquée seule ou comme option de <command>VACUUM</command>. Il est
    important d'avoir des statistiques relativement à jour, ce qui permet d'éviter les
    choix de mauvais plans d'exécution, pénalisant les performances de la
    base.
   </para>

   <para>
    Le démon d'autovacuum, si activé, va automatiquement exécuter des commandes
    <command>ANALYZE</command> à chaque fois que le contenu d'une table aura
    changé suffisamment. Toutefois, un administrateur peut préférer se fier
    à des opérations <command>ANALYZE</command> planifiées manuellement,
    en particulier s'il est connu que l'activité de mise à jour de la table
    n'a pas d'impact sur les statistiques des colonnes <quote>intéressantes</quote>.
    Le démon planifie des <command>ANALYZE</command> uniquement en fonction
    du nombre d'enregistrements insérés, mis à jour ou supprimés&nbsp;
   </para>

<!-- SAS:ICI -->
   <para>
    À l'instar du nettoyage pour récupérer l'espace, les statistiques doivent
    être plus souvent collectées pour les tables intensément modifiées que pour
    celles qui le sont moins. Mais même si la table est très modifiée, il se
    peut que ces collectes soient inutiles si la distribution probabiliste des
    données évolue peu. Une règle simple pour décider est de voir comment
    évoluent les valeurs minimum et maximum des données. Par exemple, une
    colonne de type <type>timestamp</type> qui contient la date de mise à jour
    de la ligne aura une valeur maximum en continuelle croissance au fur et à
    mesure des modifications&nbsp;; une telle colonne nécessitera plus de
    collectes statistiques qu'une colonne qui contient par exemple les URL des
    pages accédées sur un site web. La colonne qui contient les URL peut très
    bien être aussi souvent modifiée mais la distribution probabiliste des
    données changera certainement moins rapidement.
   </para>

   <para>
    Il est possible d'exécuter <command>ANALYZE</command> sur des tables spécifiques,
    voire des colonnes spécifiques&nbsp;; il a donc toute flexibilité pour
    mettre à jour certaines statistiques plus souvent que les autres en
    fonction des besoins de l'application. Quoi qu'il en soit, dans la pratique,
    il est généralement mieux de simplement analyser la base entière car il s'agit
    d'une opération rapide. <command>ANALYZE</command> utilise un système d'échantillonage des lignes d'une
    table, ce qui lui évite de lire chaque ligne.
   </para>

   <tip>
    <para>
     Même si il n'est pas très productif de règler précisément la fréquence de
     <command>ANALYZE</command> pour chaque colonne, il peut être intéressant d'ajuster
     le niveau de détail des statistiques collectées pour chaque colonne. Les
     colonnes très utilisées dans les clauses <literal>WHERE</literal> et dont la
     distribution n'est pas uniforme requièrent des histogrammes plus précis
     que les autres colonnes. Voir <command>ALTER TABLE SET STATISTICS</command>,
     ou modifier les paramètres par défaut de la base de données en utilisant le
     paramètre de configuration <xref linkend="guc-default-statistics-target"/>.
    </para>

    <para>
     De plus, par défaut, il existe peu d'informations sur la sélectivité des
     fonctions. Néanmoins, si vous créez un index qui utilise une fonction,
     des statistiques utiles seront récupérées de la fonction, ce qui peut
     grandement améliorer les plans de requêtes qui utilisent l'index.
    </para>
   </tip>
  </sect2>

  <sect2 id="vacuum-for-wraparound">
   <title>Éviter les cycles des identifiants de transactions</title>

   <indexterm zone="vacuum-for-wraparound">
    <primary>identifiant de transaction</primary>
    <secondary>cycle</secondary>
   </indexterm>

   <para>
    Le mécanisme de contrôle de concurrence multiversion (<acronym>MVCC</acronym>) de
    <productname>PostgreSQL</productname> s'appuie sur la possibilité de
    comparer des identifiants de transactions (<acronym>XID</acronym>)&nbsp;; c'est un
    nombre croissant&nbsp;: la version d'une ligne dont le XID d'insertion est
    supérieur au XID de la transaction en cours est <quote>dans le futur</quote> et
    ne doit pas être visible de la transaction courante. Comme les identifiants
    ont une taille limitée (32 bits), un groupe qui est en activité
    depuis longtemps (plus de 4 milliards de transactions) pourrait connaître un
    cycle des identifiants de transaction&nbsp;: le XID reviendra à 0 et
    soudainement les transactions du passé sembleront appartenir au futur - ce
    qui signifie qu'elles deviennent invisibles. En bref, perte de données
    totale. (En réalité, les données sont toujours là mais c'est un piètre
    réconfort puisqu'elles resteront inaccessibles.) Pour éviter ceci, il est
    nécessaire d'exécuter un VACUUM sur chaque table de chaque base au moins
    au moins une fois à chaque milliard de transactions.
   </para>

   <para>
    La raison pour laquelle un VACUUM périodique résout le problème est que
    <productname>PostgreSQL</productname> réserve un ID de transaction spécial,
    <literal>FrozenXID</literal>. Ce XID ne suit pas les règles standards de
    comparaison des identifiants de transactions et est toujours considéré
    comme plus âgé que les XID normaux. Les XID normaux sont comparés sur une
    base modulo-2<superscript>31</superscript>. Cela signifie
    que pour chaque XID normal, il y en a deux milliards qui sont plus vieux et
    deux milliards qui sont plus récents. Une autre manière de le dire est que
    l'ensemble de définition des XID est circulaire et sans limite. De plus,
    une ligne créée avec un XID normal donné, la version de la ligne apparaîtra
    comme appartenant au passé pour les deux milliards de transactions qui
    suivront quelque soit le XID. Si la ligne existe encore après deux milliards
    de transactions, elle apparaîtra soudainement comme appartenant au futur.
    Pour éviter ceci, les versions trop anciennes doivent
    se voir affecter le XID <literal>FrozenXID</literal> avant d'atteindre le seuil
    fatidique des deux milliards de transactions. Une fois qu'elles ont ce XID
    spécifique, elles appartiendront au passé pour toutes les transactions même
    en cas de cycle. Cette affectation des anciens XID est réalisée par
    <command>VACUUM</command>.
   </para>

   <para>
    <xref linkend="guc-vacuum-freeze-min-age"/> contrôle l'âge que doit avoir une
    valeur XID avant qu'elle soit remplacée par <literal>FrozenXID</literal>. Les
    valeurs plus importantes de ces deux paramètres préservent l'information
    transactionnelle plus longtemps alors que les valeurs plus petites
    augmentent le nombre de transactions qui peuvent survenir avant un nouveau
    VACUUM de la table.
   </para>

   <para>
    <command>VACUUM</command> ignore habituellement les pages qui n'ont pas de
    lignes mortes, mais ces pages pourraient toujours avoir des versions de
    lignes avec d'anciennes valeurs XID. Pour s'assurer que tous les anciens
    XID ont été remplacés par <literal>FrozenXID</literal>, un parcours complet
    de la table est nécessaire. <xref linkend="guc-vacuum-freeze-table-age"/>
    contrôle quand <command>VACUUM</command> fait cela&nbsp;: un parcours
    complet est forcé si la table n'a pas été parcourue complètement pendant
    <varname>vacuum_freeze_table_age</varname> -
    <varname>vacuum_freeze_min_age</varname> transactions. En le configurant à
    zéro, cela force <command>VACUUM</command> à toujours parcourir toutes les
    pages, ignorant de ce fait la carte de visibilité.
   </para>

   <para>
    Le temps maximum où une table peut rester sans VACUUM est de deux millions
    de transactions moins <varname>vacuum_freeze_min_age</varname> quand
    <command>VACUUM</command> a parcouru la table complètement pour la dernière
    fois. Si elle devait rester sans VACUUM après
    cela, des pertes de données pourraient survenir. Pour s'assurer que cela
    n'arrive pas, autovacuum est appelé sur chaque table qui pourrait
    contenir des XID plus âgés que ne l'indique le paramètre de configuration
    <xref linkend="guc-autovacuum-freeze-max-age"/>. (Ceci arrivera même si
    autovacuum est désactivé.)
   </para>

   <para>
    Ceci implique que, si aucune opération de VACUUM n'est demandée sur une
    table, l'autovacuum sera automatiquement déclenché une fois toutes les
    <varname>autovacuum_freeze_max_age</varname> moins
    <varname>vacuum_freeze_min_age</varname> transactions. Pour les tables qui
    ont régulièrement l'opération de VACUUM pour réclamer l'espace perdu, ceci
    a peu d'importance. Néanmoins, pour les tables statiques (ceci incluant les
    tables qui ont des INSERT mais pas d'UPDATE ou de DELETE), il n'est pas
    nécessaire d'exécuter un VACUUM pour récupérer de la place et donc il
    peut être utile d'essayer de maximiser l'interval entre les autovacuums
    forcés sur de très grosses tables statiques. Évidemment, vous pouvez le
    faire soit en augmentant <varname>autovacuum_freeze_max_age</varname> soit
    en diminuant <varname>vacuum_freeze_min_age</varname>.
   </para>

   <para>
    Le maximum efficace pour <varname>vacuum_freeze_table_age</varname> est 0.95 * 
    <varname>autovacuum_freeze_max_age</varname>&nbsp;; un paramétrage plus haut
    que ça sera limité à ce maximum. Une valeur plus importante qie
    <varname>autovacuum_freeze_max_age</varname> n'aurait pas de sens car un
    autovacuum de préservation contre la ré-utilisation des identifiants de
    transactions serait déclenché, et le multiplicateur 0,95 laisse un peu de
    place pour exécuter un <command>VACUUM</command> manuel avant que cela ne
    survienne. Comme règle d'or, <command>vacuum_freeze_table_age</command> devrait
    être configuré à une valeur légèrement inférieure à
    <varname>autovacuum_freeze_max_age</varname>, laissant suffisamment d'espace
    pour qu'un <command>VACUUM</command> planifié régulièrement ou pour qu'un
    autovacuum déclenché par des activités normales de suppression et de mise à
    jour puissent être activés pendant ce laps de temps. Le configurer de façon
    trop proche pourrait déclencher des autovacuum de protection contre la
    ré-utilisation des identifiants de transactions, même si la table a été
    récemment l'objet d'un VACUUM pour récupérer l'espace, alors que des valeurs
    basses amènent à des parcours complets de table plus fréquents.
   </para>

   <para>
    Le seul inconvénient à augmenter <varname>autovacuum_freeze_max_age</varname>
    (et <varname>vacuum_freeze_table_age</varname> avec elle)
    est que le sous-répertoire <filename>pg_clog</filename> du cluster prendre
    plus de place car il doit stocker le statut du COMMIT pour toutes les
    transactions depuis <varname>autovacuum_freeze_max_age</varname>. L'état de
    COMMIT utilise deux bits par transaction, donc si
    <varname>autovacuum_freeze_max_age</varname> et
    <varname>vacuum_freeze_table_age</varname> ont une valeur maximum permise
    d'un peu moins que deux billion, <filename>pg_clog</filename> peut grossir
    jusqu'à la moitié d'un Go. Si c'est rien comparé à votre taille de base
    totale, configurer <varname>autovacuum_freeze_max_age</varname> à son
    maximum permis est recommandé. Sinon, le configurer suivant ce que vous
    voulez comme stockage maximum dans <filename>pg_clog</filename>.
    (La valeur par défaut, 200 millions de transactions, se traduit en à peu près
    50&nbsp;Mo de stockage dans <filename>pg_clog</filename>.)
   </para>

   <para>
    Un inconvénient causé par la diminution de
    <varname>vacuum_freeze_min_age</varname> est que cela pourrait faire que
    <command>VACUUM</command> travaille sans raison&nbsp;: modifier le XID de
    la ligne d'une table à <literal>FrozenXID</literal> est une perte de temps
    si la ligne est modifiée rapidement après (ce qui fait qu'elle obtiendra
    un nouveau XID). Donc ce paramètre doit être suffisamment important pour
    que les lignes ne soient pas gelées jusqu'à ce qu'il soit pratiquement
    certain qu'elles ne seront plus modifiées. Un autre inconvénient en
    diminuant ce paramètre est que les détails sur la transaction exacte
    qui a inséré ou modifié une ligne seront perdus plus tôt. Cette information
    est quelque fois utile, particulièrement lors d'une analyse de ce qui s'est
    mal passé sur une base après un problème. Pour ces deux raisons, baisser
    ce paramètre n'est pas recommandé sauf pour les tables entièrement statiques.
   </para>

   <para>
    Pour tracer l'âge des plus anciens XID de la base, <command>VACUUM</command>
    stocke les statistiques sur XID dans les tables systèmes
    <structname>pg_class</structname> et <structname>pg_database</structname>.
    En particulier, la colonne <structfield>relfrozenxid</structfield> de la
    ligne <structname>pg_class</structname> d'une table contient le XID final
    du gel qui a été utilisé par le dernier <command>VACUUM</command> pour cette
    table. Il est garanti que tous les XID plus anciens que ce XID ont été
    remplacés par <literal>FrozenXID</literal> pour cette table. De façon
    similaire, la colonne <structfield>datfrozenxid</structfield> de la ligne
    <structname>pg_database</structname> de la base est une limite inférieure des
    XID normaux apparaissant dans cette base &mdash; c'est tout simplement le
    minimum des valeurs <structfield>relfrozenxid</structfield> par table dans
    cette base. Pour examiner cette information, le plus simple est d'exécuter
    des requêtes comme&nbsp;:

<programlisting>SELECT relname, age(relfrozenxid) FROM pg_class WHERE relkind = 'r';
SELECT datname, age(datfrozenxid) FROM pg_database;</programlisting>

    La colonne <literal>age</literal> mesure le nombre de transactions à partir
    du XID final vers le XID de transaction en cours.
   </para>

   <para>
    <command>VACUUM</command>
    parcourt habituellement seulement les pages qui ont été modifiées depuis le
    dernier VACUUM mais <structfield>relfrozenxid</structfield> peut seulement
    être avancé quand la table est parcourue complètement. La table est parcourue
    entièrement quand <structfield>relfrozenxid</structfield> est agée de plus
    de <varname>vacuum_freeze_table_age</varname> transactions, quand l'option
    <literal>FREEZE</literal> de la commande <command>VACUUM</command> est utilisée ou quand toutes les pages se
    trouvent nécessiter un VACUUM pour supprimer les versions mortes des lignes.
    Après que <command>VACUUM</command> ait parcouru la table complète
    <literal>age(relfrozenxid)</literal> devrait être un peu plus grande que
    le paramètre <varname>vacuum_freeze_min_age</varname> qui a été utilisé
    (la différence étant due au nombre de transactions démarrées depuis que
    <command>VACUUM</command> a commencé son travail). Si aucun parcours de
    table complet ne se trouve exécuté via un <command>VACUUM</command> sur
    cette table, lorsque <varname>autovacuum_freeze_max_age</varname> est
    atteint, un autovacuum sera rapidement forcé sur la table.
   </para>

   <para>
    Si, pour une certaine raison, l'autovacuum échoue à effacer les anciens XID
    d'une table, le système commencera à émettre des messages d'avertissement
    comme ceci quand les plus anciens XID de la base atteignent les 10 millions
    de transactions à partir du point de réinitialisation&nbsp;:

<programlisting>
WARNING:  database "mydb" must be vacuumed within 177009986 transactions
HINT:  To avoid a database shutdown, execute a database-wide VACUUM in "mydb".
</programlisting>
    (Une commande <command>VACUUM</command> manuelle devrait résoudre le problème,
    comme suggéré par l'indice&nbsp;; mais notez que la commande
    <command>VACUUM</command> doit être exécutée par un superutilisateur, sinon
    elle échouera à mettre à jour les catalogues systèmes et ne pourra donc pas faire
    avancer le <structfield>datfrozenxid</structfield> de la base.)
    Si ces avertissements sont ignorés, le système s'arrêtera et refusera
    de commencer toute nouvelle transaction dès qu'il n'en restera qu'un
    million avant la réinitialisation&nbsp;:

<programlisting>
ERROR:  database is not accepting commands to avoid wraparound data loss in database "mydb"
HINT:  Stop the postmaster and use a standalone backend to VACUUM in "mydb".
</programlisting>

    La marge de sécurité de un million de transactions existe pour permettre à
    l'administrateur de récupérer ces données sans perte en exécutant
    manuellement les commandes <command>VACUUM</command> requises. Néanmoins, comme le
    système n'exécute pas de commandes tant qu'il n'est pas sorti du mode
    d'arrêt par sécurité, la seule façon de le faire est de stopper le
    serveur et d'utiliser un moteur simple utilisateur pour exécuter le
    <command>VACUUM</command>. Le mode d'arrêt n'est pas pris en compte par le moteur
    simple utilisateur. Voir la page de référence de <xref linkend="app-postgres"/> pour
    des détails sur l'utilisation du moteur simple utilisateur.
   </para>
  </sect2>

  <sect2 id="autovacuum">
   <title>Le démon auto-vacuum</title>

   <indexterm>
    <primary>autovacuum</primary>
    <secondary>information générale</secondary>
   </indexterm>
   <para>
    <productname>PostgreSQL </productname> dispose d'une fonctionnalité
    optionnelle mais hautement recommandée appelée <firstterm>autovacuum</firstterm>,
    dont le but est d'automatiser l'exécution des commandes
    <command>VACUUM</command> et <command>ANALYZE </command>. Une fois activé,
    autovacuum vérifie les tables ayant un grand nombre de lignes insérées,
    mises à jour ou supprimées. Ces vérifications utilisent la fonctionnalité
    de récupération de statistiques&nbsp;; du coup, autovacuum ne peut
    pas être utilisé sauf si <xref linkend="guc-track-counts"/> est configuré
    à <literal>true</literal>.
    Dans la configuration par défaut, l'autovacuum est activé et les
    paramètres liés sont correctement configurés.
   </para>

   <para>
    Le <quote>démon autovacuum</quote> est constitué de plusieurs processus.
    Un processus démon permanent appelé <firstterm>autovacuum launcher</firstterm>
    (autrement dit le lanceur d'autovacuum)
    est en charge de lancer des processus travailleur (<firstterm>autovacuum
    worker</firstterm>) pour toutes les bases de données. Le lanceur distribuera
    le travail dans le temps mais essaiera de lancer un nouveau travailleur sur
    chaque base de données chaque <xref linkend="guc-autovacuum-naptime"/>
    secondes. (Du coup, si l'installation a <replaceable>N</replaceable> bases
    de données, un nouveau <firstterm>autovacuum worker</firstterm> sera
    lancé tous les
    <varname>autovacuum_naptime</varname>/<replaceable>N</replaceable>
    secondes.) Un maximum de <xref linkend="guc-autovacuum-max-workers"/>
    processus <firstterm>autovacuum worker</firstterm> est autorisé à
    s'exécuter en même temps. S'il y a plus de
    <varname>autovacuum_max_workers</varname>
    bases à traiter, la prochaine base de données sera traitée dès qu'un autre
    travailleur a terminé. Chaque processus travailleur vérifiera chaque table de
    leur base de données et exécutera un <command>VACUUM</command> et/ou un
    <command>ANALYZE</command> suivant les besoins.
   </para>

   <para>
    Si plusieurs grosses tables deviennent toutes éligibles pour un VACUUM dans
    un court espace de temps, tous les processus travailleurs pourraient avoir
    à exécuter des VACUUM sur ces tables pendant un long moment.
    Ceci aura pour résultat que d'autres tables et d'autres bases de
    données ne pourront pas être traitées tant qu'un processus travailleur
    ne sera pas disponible. Il n'y a pas de limite sur le nombre de processus
    travailleurs sur une seule base, mais ils essaient d'éviter de répéter le
    travail qui a déjà été fait par d'autres. Notez que le nombre de processus
    travailleurs en cours d'exécution n'est pas décompté des limites <xref
    linkend="guc-max-connections"/> et <xref
    linkend="guc-superuser-reserved-connections"/>.
   </para>

   <para>
    Les tables dont la valeur de <structfield>relfrozenxid</structfield> est
    plus importante que <xref linkend="guc-autovacuum-freeze-max-age"/> sont
    toujours l'objet d'un VACUUM (cela s'applique aux tables dont le 'freeze max age'
    a été modifié par les paramètres de stockage&nbsp;; voyez plus bas).
    Sinon, si le nombre de lignes obsolètes
    depuis le dernier <command>VACUUM</command> dépasse une <quote>limite de
    vacuum</quote>, la table bénéficie d'un VACUUM. La limite est définie
    ainsi&nbsp;:
<programlisting>limite du vacuum = limite de base du vacuum + facteur d'échelle du vacuum * nombre de lignes</programlisting>
    où la limite de base du vacuum est
    <xref linkend="guc-autovacuum-vacuum-threshold"/>,
    le facteur d'échelle du vacuum est
    <xref linkend="guc-autovacuum-vacuum-scale-factor"/>
    et le nombre de lignes est
    <structname>pg_class</structname>.<structfield>reltuples</structfield>.
    Le nombre de lignes obsolètes est obtenu à partir du récupérateur de
    statistiques&nbsp;; c'est un nombre à peu près précis, mis à jour après
    chaque instruction <command>UPDATE</command> et <command>DELETE</command>
    (il est seulement à peu près précis car certaines informations pourraient
    être perdues en cas de grosse charge). Si la valeur de
    <structfield>relfrozenxid</structfield> pour la table est supérieure à
    <varname>vacuum_freeze_table_age</varname>, la table complète est parcourue
    pour geler les anciennes lignes et pour avancer
    <structfield>relfrozenxid</structfield>, sinon seules les pages qui ont été
    modifiées depuis le dernier VACUUM sont parcourues par l'opération de
    VACUUM.
   </para>

   <para>
    Pour ANALYZE, une condition similaire
    est utilisée&nbsp;: la limite, définie comme
<programlisting>limite du analyze = limite de base du analyze + facteur d'échelle du analyze * nombre de lignes</programlisting>
    est comparée au nombre de lignes insérées, mises à jour et supprimées depuis
    le dernier <command>ANALYZE</command>.
   </para>

   <para>
    Les tables temporaires ne peuvent pas être accédées par l'autovacuum. Du
    coup, les opérations appropriées de VACUUM et d'ANALYZE devraient être
    traitées par des commandes SQL de session.
   </para>

   <para>
    Les limites et facteurs d'échelle par défaut sont pris dans
    <filename>postgresql.conf</filename>, mais il est possible de les surcharger
    table par table&nbsp;; voir
    <xref linkend="sql-createtable-storage-parameters"
    endterm="sql-createtable-storage-parameters-title"/> pour plus d'informations.
    Si un paramètre a été modifié via les paramètres de stockage, cette valeur
    est utilisée&nbsp;; sinon les paramètres globaux sont utilisés. Voir
    <xref linkend="runtime-config-autovacuum"/> pour plus d'informations sur les
    paramètres globaux.
   </para>

   <para>
    En plus des valeurs de la limite de base et des facteurs d'échelle, il
    existe six autres paramètres autovacuum pouvant être configurés pour chaque table
    via les paramètres de stockage. Le premier paramètre,
    <literal>autovacuum_enabled</literal>,
    peut être configuré à <literal>false</literal> pour instruire le démon
    autovacuum de laisser cette table particulière. Dans ce cas, autovacuum
    touchera seulement la table quand il devra le faire pour prévenir la
    réinitialisation de l'ID de transaction. Deux autres paramètres, le
    délai du coût du VACUUM (<varname>autovacuum_vacuum_cost_delay</varname>)
    et la limite du coût du VACUUM
    (<varname>autovacuum_vacuum_cost_limit</varname>),
    sont utilisés pour configurer des valeurs spécifiques aux tables pour la
    fonctionnalité de délai de VACUUM basé sur le coût (voir <xref
    linkend="runtime-config-resource-vacuum-cost"/>).
    <varname>autovacuum_freeze_min_age</varname>,
    <varname>autovacuum_freeze_max_age</varname> et
    <varname>autovacuum_freeze_table_age</varname>
    sont utilisés pour configurer des valeurs par table, respectivement
    <xref linkend="guc-vacuum-freeze-min-age"/>,
    <xref linkend="guc-autovacuum-freeze-max-age"/> et
    <xref linkend="guc-vacuum-freeze-table-age"/>.
   </para>

   <para>
    Lorsque plusieurs processus autovacuum sont en cours d'exécution, la
    limite de coût est <quote>répartie</quote> parmi tous les processus pour
    que l'impact total sur le système soit identique quelque soit le nombre
    de processus en cours d'exécution.
   </para>
  </sect2>
 </sect1>


 <sect1 id="routine-reindex">
  <title>Ré-indexation régulière</title>

  <indexterm zone="routine-reindex">
   <primary>ré-indexation</primary>
  </indexterm>

  <para>
   Dans certains cas, reconstruire périodiquement les index par la commande
   <xref linkend="sql-reindex"/> vaut la peine.
  </para>

  <para>
   Les pages de l'index B-tree, qui sont devenues complètement vides, sont
   réclamées pour leur ré-utilisation. Mais, il existe toujours une
   possibilité d'utilisation peu efficace de l'espace : si, sur une page,
   seulement plusieurs clés d'index ont été supprimés, la page reste allouée.
   En conséquence, si seulement quelques clés sont supprimées, vous devrez
   vous attendre à ce que l'espace disque soit très mal utilisé. Dans de tels
   cas, la réindexation périodique est recommandée.
  </para>

  <para>
   Le potentiel d'inflation des index qui ne sont pas des index B-tree n'a pas
   été particulièrement analysé. Surveiller périodiquement la taille physique de
   ces index est une bonne idée.
  </para>

  <para>
   De plus, pour les index B-tree, un index tout juste construit est légèrement
   plus rapide qu'un index qui a été mis à jour plusieurs fois parce que
   les pages adjacentes logiquement sont habituellement aussi physiquement
   adjacentes dans un index nouvellement créé (cette considération ne s'applique
   pas aux index non B-tree). Il pourrait être intéressant de ré-indexer
   périodiquement simplement pour améliorer la vitesse d'accès.
  </para>
 </sect1>


 <sect1 id="logfile-maintenance">
  <title>Maintenance du fichier de traces</title>

  <indexterm zone="logfile-maintenance">
   <primary>traces serveur</primary>
   <secondary>maintenance du fichier de traces</secondary>
  </indexterm>

  <para>
   Sauvegarder les journaux de trace du serveur de bases de données dans un
   fichier plutôt que dans <filename>/dev/NULL</filename> est une bonne idée. Les
   journaux sont d'une utilité incomparable lorsqu'arrive le moment où des
   problèmes surviennent. Néanmoins, les journaux ont tendance à être
   volumineux (tout spécialement à des niveaux de débogage importants) et vous
   ne voulez pas les sauvegarder indéfiniment. Vous avez besoin de faire une
   <quote>rotation</quote> des journaux pour que les nouveaux journaux sont
   commencés et que les anciens soient supprimés après une période de temps
   raisonnable.
  </para>

  <para>
   Si vous redirigez simplement <systemitem>stderr</systemitem> du
   <command>postgres</command> dans un fichier, vous aurez un journal des
   traces mais la seule façon de le tronquer sera d'arrêter et de relancer
   le serveur. Ceci peut convenir si vous utilisez
   <productname>PostgreSQL</productname> dans un environnement de développement
   mais peu de serveurs de production trouveraient ce comportement acceptable.
  </para>

  <para>
   Une meilleure approche est d'envoyer la sortie
   <systemitem>stderr</systemitem> du serveur dans un programme de rotation de
   journaux. Il existe un programme interne de rotation que vous pouvez
   utiliser en configurant le paramètre <varname>logging_collector</varname> à
   <literal>true</literal> dans <filename>postgresql.conf</filename>. Les
   paramètres de contrôle pour ce programme sont décrits dans <xref
   linkend="runtime-config-logging-where"/>. Vous pouvez aussi utiliser cette
   approche pour capturer les données des journaux applicatifs dans un format
   <acronym>CSV</acronym> (valeurs séparées par des virgules) lisible par une
   machine
  </para>

  <para>
   Sinon, vous pourriez préférer utiliser un programme externe de rotation de
   journaux si vous en utilisez déjà un avec d'autres serveurs. Par exemple,
   l'outil <application>rotatelogs</application> inclus dans la distribution
   <productname>Apache</productname> peut être utilisé avec
   <productname>PostgreSQL</productname>. Pour cela, envoyez via un tube la
   sortie <systemitem>stderr</systemitem> du serveur dans le programme
   désiré. Si vous lancez le serveur avec <command>pg_ctl</command>, alors
   <systemitem>stderr</systemitem> est déjà directement renvoyé dans
   <systemitem>stdout</systemitem>, donc vous avez juste besoin d'ajouter la commande via
   un tube, par exemple&nbsp;:

<programlisting>pg_ctl start | rotatelogs /var/log/pgsql_log 86400</programlisting>
</para>

  <para>
   Une autre approche de production pour la gestion des journaux de trace est
   de les envoyer à <application>syslog</application> et de laisser <application>syslog</application>
   gérer la rotation des fichiers. Pour cela, initialisez le paramètre de
   configuration <varname>log_destination</varname> à <literal>syslog</literal> (pour tracer
   uniquement via <application>syslog</application>) dans <filename>postgresql.conf</filename>.
   Ensuite, vous pouvez envoyer un signal <literal>SIGHUP</literal> au démon
   <application>syslog</application> quand vous voulez le forcer à écrire dans un nouveau
   fichier. Si vous voulez automatiser la rotation des journaux, le programme
   <application>logrotate</application> peut être configuré pour fonctionner
   avec les journaux de traces provenant de <application>syslog</application>.
  </para>

  <para>
   Néanmoins, sur beaucoup de systèmes, <application>syslog</application> n'est pas très
   fiable, particulièrement avec les messages très gros&nbsp;; il pourrait
   tronquer ou supprimer des messages au moment où vous en aurez le plus besoin.
   De plus, sur <productname>Linux</productname>, <application>syslog</application> synchronisera tout
   message sur disque, amenant des performances assez pauvres. (Vous pouvez
   utiliser un <quote><literal>-</literal></quote> au début du nom de fichier dans le fichier de
   configuration <application>syslog</application> pour désactiver la synchronisation.)
  </para>

  <para>
   Notez que toutes les solutions décrites ci-dessus font attention à lancer de
   nouveaux journaux de traces à des intervalles configurables mais ils ne
   gèrent pas la suppression des vieux fichiers de traces, qui ne sont
   probablement plus très utiles. Vous voudrez probablement configurer
   un script pour supprimer périodiquement les anciens journaux. Une autre
   possibilité est de configurer le programme de rotation pour que les anciens
   journaux de traces soient écrasés de façon cyclique.
  </para>

  <para>
   <ulink url="http://pgfouine.projects.postgresql.org/">pgFouine</ulink>
   est un projet externe qui analyse les journaux applicatifs d'une façon très
   poussée. <ulink
   url="http://bucardo.org/wiki/Check_postgres">check_postgres</ulink> fournit
   des alertes Nagios quand des messages importants apparaît dans les journaux
   applicatifs, mais détecte aussi de nombreux autres cas.
  </para>
 </sect1>
</chapter>
