<?xml version="1.0" encoding="UTF-8"?>
<chapter id="maintenance">
 <title>Planifier les tâches de maintenance</title>

 <indexterm zone="maintenance">
  <primary>maintenance</primary>
 </indexterm>

 <indexterm zone="maintenance">
  <primary>routine maintenance</primary>
 </indexterm>

 <para>
  <productname>PostgreSQL</productname>, comme tout SGBD, requiert que certains
  tâches soient réalisées de façon régulière pour atteindre les performances
  optimales. Ces tâches sont <emphasis>requises</emphasis>,
  mais elles sont répétitives par nature et peuvent être facilement automatisées
  en utilisant des outils standard comme les scripts
  <application>cron</application> ou le <application>Task Scheduler</application>
  de Windows. La responsabilité de la mise en place de ces
  scripts et du contrôle de leur bon fonctionnement relève de l'administrateur
  de la base.
 </para>

 <para>
  Une opération de maintenance évidente est la sauvegarde régulière des
  données. Sans une sauvegarde récente, il est impossible de restaurer après
  un dommage grave (perte d'un disque, incendie, table supprimée par erreur,
  etc.). Les mécanismes de sauvegarde et restauration disponibles dans
  <productname>PostgreSQL</productname> sont détaillés dans le <xref
  linkend="backup"/>.
 </para>

 <para>
  L'autre tâche primordiale est la réalisation périodique d'un <quote>vacuum</quote>,
  c'est à dire <quote>faire le vide</quote> dans la base de données.
  Cette opération est détaillée dans la <xref linkend="routine-vacuuming"/>.
  La mise à jour des statistiques utilisées par le planificateur de
  requêtes sera discutée dans <xref linkend="vacuum-for-statistics"/>.
 </para>

 <para>
  La gestion du fichier de traces mérite aussi une attention régulière.
  Cela est détaillé dans la <xref linkend="logfile-maintenance"/>.
 </para>

 <para>
  <ulink
  url="https://bucardo.org/check_postgres/"><application>check_postgres</application></ulink>
  est disponible pour surveiller la santé des bases de données et pour
  rapporter des conditions inhabituelles. <application>check_postgres</application>
  s'intègre bien avec Nagios et MRTG, mais il peut aussi fonctionner de façon autonome.
 </para>

 <para>
  <productname>PostgreSQL</productname> demande peu de maintenance par rapport
  à d'autres SGBD. Néanmoins, un suivi vigilant de ces tâches participera
  beaucoup à rendre le système productif et agréable à utiliser.
 </para>

 <sect1 id="routine-vacuuming">
  <title>Nettoyages réguliers</title>

  <indexterm zone="routine-vacuuming">
   <primary>vacuum</primary>
  </indexterm>

  <para>
   Le SGBD <productname>PostgreSQL</productname> nécessite des opérations de
   maintenance périodiques, connues sous le nom de <firstterm>VACUUM</firstterm>.
   Pour de nombreuses installations, il est suffisant de laisser travailler le
   <firstterm>démon autovacuum</firstterm>, qui est décrit dans <xref
   linkend="autovacuum"/>. En fonction des cas, les paramètres
   de cet outil peuvent être optimisés pour obtenir de meilleurs résultats.
   Certains administrateurs de bases de données voudront suppléer ou remplacer
   les activités du démon avec une gestion manuelle des commandes
   <command>VACUUM</command>, qui seront typiquement exécutées suivant un
   planning par des scripts <application>cron</application> ou par le
   <application>Task Scheduler</application>. Pour configurer une gestion
   manuelle et correcte du VACUUM, il est essentiel de bien comprendre les
   quelques sous-sections suivantes. Les administrateurs qui se basent sur
   l'autovacuum peuvent toujours lire ces sections pour les aider à comprendre
   et à ajuster l'autovacuum.
  </para>

  <sect2 id="vacuum-basics">
   <title>Bases du VACUUM</title>

   <para>
    La commande <xref linkend="sql-vacuum"/> de
    <productname>PostgreSQL</productname> doit traiter chaque table régulièrement
    pour plusieurs raisons&nbsp;:

    <orderedlist>
     <listitem>
      <simpara>pour récupérer ou ré-utiliser l'espace disque occupé par les lignes supprimées
       ou mises à jour&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>pour mettre à jour les statistiques utilisées par l'optimiseur de
       <productname>PostgreSQL</productname>&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>Pour mettre à jour la carte de visibilité qui accélère les
       <link linkend="indexes-index-only-scans">parcours d'index seuls</link>.
      </simpara>
     </listitem>

     <listitem>
      <simpara>pour prévenir la perte des données les plus anciennes à cause
       d'un <firstterm>cycle de l'identifiant de transaction (XID)</firstterm>
       ou d'un <firstterm>cycle de l'identifiant de multixact</firstterm>.</simpara>
     </listitem>
    </orderedlist>

    Chacune de ces raisons impose de réaliser des opérations <command>VACUUM</command>
    de différentes fréquences et portées, comme expliqué dans les sous-sections
    suivantes.
   </para>

   <para>
    Il y a deux variantes de la commande <command>VACUUM</command>&nbsp;:
    <command>VACUUM</command> standard et <command>VACUUM FULL</command>.
    <command>VACUUM FULL</command> peut récupérer davantage d'espace disque mais
    s'exécute beaucoup plus lentement. Par ailleurs, la forme standard de
    <command>VACUUM</command> peut s'exécuter en parallèle avec les opérations
    de production des bases. Des commandes comme <command>SELECT</command>,
    <command>INSERT</command>, <command>UPDATE</command> et
    <command>DELETE</command> continuent de fonctionner de façon normale,
    mais la définition d'une table ne peut être modifiée avec des
    commandes telles que <command>ALTER TABLE</command> pendant le <command>VACUUM</command>.
    <command>VACUUM FULL</command> nécessite un verrou exclusif sur la table sur
    laquelle il travaille, et ne peut donc pas être exécuté en parallèle avec une
    autre activité sur la table. En règle générale,
    par conséquent, les administrateurs doivent s'efforcer d'utiliser la commande
    standard <command>VACUUM</command> et éviter <command>VACUUM FULL</command>.
   </para>

   <para>
    <command>VACUUM</command> produit un nombre important d'entrées/sorties,
    ce qui peut entraîner de mauvaises performances pour les autres sessions
    actives. Des paramètres de configuration peuvent être ajustés pour réduire
    l'impact d'une opération VACUUM en arrière plan sur les
    performances&nbsp;&mdash; voir
    <xref linkend="runtime-config-resource-vacuum-cost"/>.
   </para>
  </sect2>

  <sect2 id="vacuum-for-space-recovery">
   <title>Récupérer l'espace disque</title>

   <indexterm zone="vacuum-for-space-recovery">
    <primary>espace disque</primary>
   </indexterm>

   <para>
    Avec <productname>PostgreSQL</productname>, les versions périmées des
    lignes ne sont pas immédiatement supprimées après une commande
    <command>UPDATE</command> ou <command>DELETE</command>.  Cette approche est
    nécessaire pour la consistance des accès
    concurrents (<acronym>MVCC</acronym>, voir le <xref linkend="mvcc"/>)&nbsp;: la version de la ligne ne
    doit pas être supprimée tant qu'elle est susceptible d'être lue par une
    autre transaction. Mais finalement, une ligne qui est plus vieille que
    toutes les transactions en cours n'est plus utile du tout. La place qu'elle
    utilise doit être rendue pour être réutilisée par d'autres lignes afin
    d'éviter un accroissement constant, sans limite, du volume occupé sur le disque. Cela est
    réalisé en exécutant <command>VACUUM</command>.
   </para>

   <para>
    La forme standard de <command>VACUUM</command> élimine les versions
    d'enregistrements morts dans les tables et les index, et marque l'espace
    comme réutilisable. Néanmoins, il ne rend pas cet espace au système
    d'exploitation, sauf dans le cas spécial où des pages à la fin d'une table
    deviennent totalement vides et qu'un verrou exclusif
    sur la table peut être obtenu aisément. Par opposition, <command>VACUUM FULL</command> compacte
    activement les tables en écrivant une nouvelle version complète du fichier
    de la table, sans espace vide. Ceci réduit la taille de la table mais peut
    prendre beaucoup de temps. Cela requiert aussi un espace disque
    supplémentaire pour la nouvelle copie de la table jusqu'à la fin de
    l'opération.
   </para>

   <para>
    Le but habituel d'un vacuum régulier est de lancer des <command>VACUUM</command>
    standard suffisamment souvent pour éviter d'avoir recours à
    <command>VACUUM FULL</command>. Le démon autovacuum essaie de fonctionner de
    cette façon, et n'exécute jamais de <command>VACUUM FULL</command>. Avec
    cette approche, l'idée directrice n'est pas de maintenir les tables à leur
    taille minimale, mais de maintenir l'utilisation de l'espace disque à un niveau
    constant&nbsp;: chaque table occupe l'espace équivalent à sa taille minimum plus
    la quantité d'espace consommée entre deux vacuums. Bien que <command>VACUUM FULL</command>
    puisse être utilisé pour retourner une table à sa taille minimale et rendre
    l'espace disque au système d'exploitation, cela ne sert pas à grand chose,
    si cette table recommence à grossir dans un futur proche. Par conséquent,
    cette approche s'appuyant sur des commandes <command>VACUUM</command>
    exécutées à intervalles modérément rapprochés est une meilleure approche que
    d'exécuter des <command>VACUUM FULL</command> espacés pour des tables
    mises à jour de façon intensive.
   </para>

   <para>
    Certains administrateurs préfèrent planifier le passage de <command>VACUUM</command>
    eux-mêmes, par exemple faire le travail de nuit, quand la charge est faible.
    La difficulté avec cette stratégie est que si une table a un pic d'activité
    de mise à jour inattendu, elle peut grossir au point qu'un
    <command>VACUUM FULL</command> soit vraiment nécessaire pour récupérer
    l'espace. L'utilisation du démon d'autovacuum minore ce problème, puisque
    le démon planifie les vacuum de façon dynamique, en réponse à l'activité
    de mise à jour. Il est peu raisonnable de désactiver totalement le démon,
    sauf si l'activité de la base est extrêmement prévisible. Un compromis possible
    est de régler les paramètres du démon afin qu'il ne réagisse qu'à une activité
    exceptionnellement lourde de mise à jour, de sorte à éviter seulement de perdre
    totalement le contrôle de la volumétrie, tout en laissant les
    <command>VACUUM</command> planifiés faire le gros du travail quand la charge
    est normale.
   </para>

   <para>
    Pour ceux qui n'utilisent pas autovacuum, une approche typique alternative est de
    planifier un <command>VACUUM</command> sur la base complète une fois
    par jour lorsque l'utilisation n'est pas grande, avec en plus des
    opérations de <command>VACUUM</command> plus fréquentes pour les tables
    très impactées par des mises à jour, de la façon adéquate.
    (Certaines installations avec énormément de mises à jour peuvent exécuter
    des VACUUM toutes les quelques minutes.) Lorsqu'il y a plusieurs bases dans
    un cluster, il faut penser à exécuter un <command>VACUUM</command> sur
    chacune d'elles&nbsp;; le programme <xref
    linkend="app-vacuumdb"/> peut être utile.
   </para>

   <tip>
    <para>
     Le <command>VACUUM</command> simple peut ne pas suffire
     quand une table contient un grand nombre d'enregistrements morts comme
     conséquence d'une mise à jour ou suppression massive. Dans ce cas, s'il est
     nécessaire de récupérer l'espace disque
     gaspillé, <command>VACUUM FULL</command> peut être utilisé,
     <xref linkend="sql-cluster"/> ou une des variantes de <xref
     linkend="sql-altertable"/>.
     Ces commandes écrivent une nouvelle copie de la table et lui adjoignent de nouveaux
     index. Toutes ces options nécessitent un verrou exclusif.
     Elles utilisent aussi temporairement un espace disque supplémentaire,
     approximativement égal à la taille de la table, car les anciennes copies de
     la table et des index ne peuvent pas être supprimées avant la fin de
     l'opération.
    </para>
   </tip>

   <tip>
    <para>
     Si le contenu d'une table est supprimé périodiquement, il est préférable
     d'envisager l'utilisation de <xref linkend="sql-truncate"/>, plutôt que
     <command>DELETE</command> suivi de <command>VACUUM</command>.
     <command>TRUNCATE</command> supprime le contenu entier de la table
     immédiatement sans nécessiter de <command>VACUUM</command> ou
     <command>VACUUM FULL</command> pour réclamer l'espace disque maintenant
     inutilisé.
     L'inconvénient est la violation des sémantiques MCC strictes.
    </para>
   </tip>
  </sect2>

  <sect2 id="vacuum-for-statistics">
   <title>Maintenir les statistiques du planificateur</title>

   <indexterm zone="vacuum-for-statistics">
    <primary>statistiques</primary>
    <secondary>du planificateur</secondary>
   </indexterm>

   <indexterm zone="vacuum-for-statistics">
    <primary>ANALYZE</primary>
   </indexterm>

   <para>
    L'optimiseur de requêtes de <productname>PostgreSQL</productname> s'appuie
    sur des informations statistiques sur le contenu des tables dans l'optique
    de produire des plans d'exécutions efficaces pour les requêtes. Ces
    statistiques sont collectées par la commande <xref linkend="sql-analyze"/>, qui peut
    être invoquée seule ou comme option de <command>VACUUM</command>. Il est
    important d'avoir des statistiques relativement à jour, ce qui permet d'éviter les
    choix de mauvais plans d'exécution, pénalisant les performances de la
    base.
   </para>

   <para>
    Le démon d'autovacuum, si activé, va automatiquement exécuter des commandes
    <command>ANALYZE</command> à chaque fois que le contenu d'une table aura
    changé suffisamment. Toutefois, un administrateur peut préférer se fier
    à des opérations <command>ANALYZE</command> planifiées manuellement,
    en particulier s'il est connu que l'activité de mise à jour de la table
    n'a pas d'impact sur les statistiques des colonnes <quote>intéressantes</quote>.
    Le démon planifie des <command>ANALYZE</command> uniquement en fonction
    du nombre d'enregistrements insérés, mis à jour ou supprimés&nbsp;
   </para>

   <para>
    À l'instar du nettoyage pour récupérer l'espace, les statistiques doivent
    être plus souvent collectées pour les tables intensément modifiées que pour
    celles qui le sont moins. Mais même si la table est très modifiée, il se
    peut que ces collectes soient inutiles si la distribution probabiliste des
    données évolue peu. Une règle simple pour décider est de voir comment
    évoluent les valeurs minimum et maximum des données. Par exemple, une
    colonne de type <type>timestamp</type> qui contient la date de mise à jour
    de la ligne aura une valeur maximum en continuelle croissance au fur et à
    mesure des modifications&nbsp;; une telle colonne nécessitera plus de
    collectes statistiques qu'une colonne qui contient par exemple les URL des
    pages accédées sur un site web. La colonne qui contient les URL peut très
    bien être aussi souvent modifiée mais la distribution probabiliste des
    données changera certainement moins rapidement.
   </para>

   <para>
    Il est possible d'exécuter <command>ANALYZE</command> sur des tables spécifiques,
    voire des colonnes spécifiques&nbsp;; il a donc toute flexibilité pour
    mettre à jour certaines statistiques plus souvent que les autres en
    fonction des besoins de l'application. Quoi qu'il en soit, dans la pratique,
    il est généralement mieux de simplement analyser la base entière car il s'agit
    d'une opération rapide. <command>ANALYZE</command> utilise un système d'échantillonage des lignes d'une
    table, ce qui lui évite de lire chaque ligne.
   </para>

   <tip>
    <para>
     Même si il n'est pas très productif de règler précisément la fréquence de
     <command>ANALYZE</command> pour chaque colonne, il peut être intéressant d'ajuster
     le niveau de détail des statistiques collectées pour chaque colonne. Les
     colonnes très utilisées dans les clauses <literal>WHERE</literal> et dont la
     distribution n'est pas uniforme requièrent des histogrammes plus précis
     que les autres colonnes. Voir <command>ALTER TABLE SET STATISTICS</command>,
     ou modifier les paramètres par défaut de la base de données en utilisant le
     paramètre de configuration <xref linkend="guc-default-statistics-target"/>.
    </para>

    <para>
     De plus, par défaut, il existe peu d'informations sur la sélectivité des
     fonctions. Néanmoins, si vous créez un index qui utilise une fonction,
     des statistiques utiles seront récupérées de la fonction, ce qui peut
     grandement améliorer les plans de requêtes qui utilisent l'index.
    </para>
   </tip>

   <tip>
    <para>
     Le démon autovacuum ne lance pas de commandes <command>ANALYZE</command>
     sur les tables distantes car il n'a aucun moyen de déterminer la fréquence
     à laquelle la mise à jour des statistiques serait utile. Si vos requêtes
     ont besoin des statistiques sur les tables distantes pour disposer d'un plan
     d'exécution correct, il s'avérera être une bonne idée de lancer manuellement
     des commandes <command>ANALYZE</command> sur ces tables au moment adéquat.
    </para>
   </tip>
  </sect2>

  <sect2 id="vacuum-for-visibility-map">
   <title>Mettre à jour la carte de visibilité</title>

   <para>
    La commande VACUUM maintient le contenu de la <link linkend="storage-vm">carte
     de visibilité</link> pour chaque table, pour conserver la trace de chaque
    page contenant seulement des lignes connues pour être visibles par toutes les
    transactions actives (ainsi que les futures transactions, jusqu'à la
    prochaine modification de la page). Cette carte a deux buts. Tout d'abord,
    le VACUUM peut ignorer ce type de pages à sa prochaine exécution comme il
    n'y a rien à nettoyer dans ces pages.
   </para>

   <para>
    Ensuite, il permet à <productname>PostgreSQL</productname> de répondre à
    certaines requêtes en utilisant seulement l'index, et donc sans faire
    référence à la table sous-jacente. Comme les index de
    <productname>PostgreSQL</productname> ne contiennent pas d'informations
    sur la visibilité des lignes, un parcours d'index normal récupère la ligne
    de la table pour chaque entrée d'index correspondante, ce qui permet de
    vérifier si la ligne correspondante est bien visible par la transaction
    en cours. Un <link linkend="indexes-index-only-scans">parcours d'index
     seuls</link> vérifie en
    premier lieu la carte de visibilité. S'il est connu que toutes les lignes
    de la page sont visibles, la lecture de la table peut être évitée. Ceci
    est très utile sur les gros ensembles de données où la carte
    de visibilité peut éviter des accès disques. La carte de visibilité est
    très largement plus petite que la table, donc elle peut facilement être
    mise en cache même quand la table est très grosse.
   </para>

   <para>
    Les autovacuum workers ne bloquent généralement pas d'autres commandes. Si
    un processus tente d'acquérir un verrou qui entre en conflit avec le verrou
    <literal>SHARE UPDATE EXCLUSIVE</literal> détenu par autovacuum, l'acquisition
    du verrou interrompera l'autovacuum. Pour les modes de verrou en conflit,
    voir <xref linkend="table-lock-compatibility"/>. Néanmoins, si l'autovacuum
    est en cours d'exécution pour empêcher un bouclage des identifiants de
    transaction (autrement dit, nom de la requête de l'autovacuum dans la vue
    <structname>pg_stat_activity</structname> se termine avec
    <literal>(to prevent wraparound)</literal>), l'autovacuum n'est pas
    automatiquement interrompu.
   </para>

   <warning>
    <para>
     Exécuter régulièrement des commandes qui acquièrent des verrous entrant
     en conflit avec un verrou <literal>SHARE UPDATE EXCLUSIVE</literal> (par
     exemple ANALYZE) peut fortement empêcher les autovacuum de se terminer
     correctement.
    </para>
   </warning>
  </sect2>

  <sect2 id="vacuum-for-wraparound">
   <title>Éviter les cycles des identifiants de transactions</title>

   <indexterm zone="vacuum-for-wraparound">
    <primary>identifiant de transaction</primary>
    <secondary>cycle</secondary>
   </indexterm>

   <indexterm>
    <primary>ré-utilisation</primary>
    <secondary>des identifiants de transaction</secondary>
   </indexterm>

   <para>
    Le mécanisme de contrôle de concurrence multiversion (<link linkend="mvcc-intro">MVCC</link>) de
    <productname>PostgreSQL</productname> s'appuie sur la possibilité de
    comparer des identifiants de transactions (<acronym>XID</acronym>)&nbsp;; c'est un
    nombre croissant&nbsp;: la version d'une ligne dont le XID d'insertion est
    supérieur au XID de la transaction en cours est <quote>dans le futur</quote> et
    ne doit pas être visible de la transaction courante. Comme les identifiants
    ont une taille limitée (32 bits), un groupe qui est en activité
    depuis longtemps (plus de 4 milliards de transactions) pourrait connaître un
    cycle des identifiants de transaction&nbsp;: le XID reviendra à 0 et
    soudainement les transactions du passé sembleront appartenir au futur - ce
    qui signifie qu'elles deviennent invisibles. En bref, perte de données
    totale. (En réalité, les données sont toujours là mais c'est un piètre
    réconfort puisqu'elles resteront inaccessibles.) Pour éviter ceci, il est
    nécessaire d'exécuter un VACUUM sur chaque table de chaque base au moins
    une fois à chaque milliard de transactions.
   </para>

   <para>
    <command>VACUUM</command> marquera les lignes comme <emphasis>gelées</emphasis>,
    indiquant qu'elles ont été insérées par une transaction qui les a validé
    suffisamment loin dans le passé pour que les effets de cette transaction
    soient visibles à coup sûr pour toutes les transactions
    actuelles et futures. Les XID normaux sont comparés sur une
    base modulo-2<superscript>32</superscript>. Cela signifie
    que pour chaque XID normal, il y en a deux milliards qui sont plus vieux et
    deux milliards qui sont plus récents. Une autre manière de le dire est que
    l'ensemble de définition des XID est circulaire et sans limite. De plus,
    une ligne créée avec un XID normal donné, la version de la ligne apparaîtra
    comme appartenant au passé pour les deux milliards de transactions qui
    suivront quelque soit le XID. Si la ligne existe encore après deux milliards
    de transactions, elle apparaîtra soudainement comme appartenant au futur.
    Pour empêcher cela, <productname>PostgreSQL</productname> réserve un XID
    spécial, <literal>FrozenTransactionId</literal>, qui ne suit pas les
    règles normales de comparaison de XID et qui est toujours considéré comme
    plus ancien que chaque XID normal.
    Les versions de lignes gelées sont traitées comme si la XID d'insertion
    était <literal>FrozenTransactionId</literal>, pour qu'elles apparaissent dans
    le passé pour les autres transactions normales, quelque soit les soucis de
    bouclage d'identifiant de transactions, et donc ces versions de lignes seront
    valides jusqu'à leur suppression, quelque soit la durée que cela représente.
   </para>

   <note>
    <para>
     Dans les versions de <productname>PostgreSQL</productname> antérieures à
     la 9.4, le gel était implémenté en remplaçant le XID d'insertion d'une
     ligne avec <literal>FrozenTransactionId</literal>, qui était visible dans
     la colonne système <structname>xmin</structname> de la ligne. Les
     nouvelles versions ajoutent un drapeau, préservant le
     <structname>xmin</structname> original de la ligne pour une utilisation
     ultérieure (notamment pour du débugage). Néanmoins, il est toujours
     possible d'avoir des lignes pour lesquelles <structname>xmin</structname>
     vaut <literal>FrozenTransactionId</literal> (2) dans les bases de données
     antérieures à la version 9.4 traitées par
     <application>pg_upgrade</application>.
    </para>

    <para>
     De plus, les catalogues systèmes pourraient contenir des lignes avec
     <structname>xmin</structname> égale à
     <literal>BootstrapTransactionId</literal> (1), indiquant qu'elles ont été
     insérées lors de la première phase d'<application>initdb</application>.
     Comme <literal>FrozenTransactionId</literal>, cet XID spécial est traité
     comme étant plus ancien que tout autre XID normal.
    </para>
   </note>

   <para>
    <xref linkend="guc-vacuum-freeze-min-age"/> contrôle l'âge que doit avoir
    une valeur XID avant que des lignes comportant cet XID ne soient gelées. Augmenter ce paramètre peut
    permettre d'éviter un travail inutile si les lignes à geler vont bientôt
    être modifiées. Diminuer ce paramètre augmente le nombre de transactions qui
    peuvent survenir avant un nouveau VACUUM de la table.
   </para>

   <para>
    <command>VACUUM</command> utilise la <link linkend="storage-vm">carte de
     visibilité</link> pour déterminer les pages d'une table à parcourir.
    Habituellement, il ignore les pages qui n'ont aucune ligne morte même si
    ces pages pourraient toujours avoir des versions de lignes avec des
    identifiants très anciens de transactions. De ce fait, les
    <command>VACUUM</command> normaux ne vont pas toujours geler chaque
    ancienne version de ligne dans la table. De temps en temps,
    <command>VACUUM</command> réalise un <firstterm>vacuum
     agressif</firstterm>, ignorant seulement les pages contenant aucune ligne
    morte et aucune valeur XID ou MXID non gelé.
    <xref linkend="guc-vacuum-freeze-table-age"/> contrôle quand
    <command>VACUUM</command> se comporte ainsi&nbsp;: les blocs ne contenant
    que des lignes vivantes mais non gelées sont parcourus si le nombre de
    transactions exécutées depuis le dernier parcours de ce type est plus
    grand que <varname>vacuum_freeze_table_age</varname> moins
    <varname>vacuum_freeze_min_age</varname>. Configurer
    <varname>vacuum_freeze_table_age</varname> à 0 force <command>VACUUM</command>
    à utiliser cette stratégie plus agressive pour tous les parcours.
   </para>

   <para>
    Le temps maximum où une table peut rester sans VACUUM est de deux millions
    de transactions moins <varname>vacuum_freeze_min_age</varname> lors du
    dernier <command>VACUUM</command> agressif. Si elle devait rester sans
    VACUUM après
    cela, des pertes de données pourraient survenir. Pour s'assurer que cela
    n'arrive pas, autovacuum est appelé sur chaque table qui pourrait
    contenir des lignes non gelées dont les XID ont un âge plus avancé que le paramètre de configuration
    <xref linkend="guc-autovacuum-freeze-max-age"/>. (Ceci arrivera même si
    autovacuum est désactivé.)
   </para>

   <para>
    Ceci implique que, si aucune opération de VACUUM n'est demandée sur une
    table, l'autovacuum sera automatiquement déclenché une fois toutes les
    <varname>autovacuum_freeze_max_age</varname> moins
    <varname>vacuum_freeze_min_age</varname> transactions. Pour les tables qui
    ont régulièrement l'opération de VACUUM pour réclamer l'espace perdu, ceci
    a peu d'importance. Néanmoins, pour les tables statiques (ceci incluant les
    tables qui ont des INSERT mais pas d'UPDATE ou de DELETE), il n'est pas
    nécessaire d'exécuter un VACUUM pour récupérer de la place et donc il
    peut être utile d'essayer de maximiser l'interval entre les autovacuums
    forcés sur de très grosses tables statiques. Évidemment, vous pouvez le
    faire soit en augmentant <varname>autovacuum_freeze_max_age</varname> soit
    en diminuant <varname>vacuum_freeze_min_age</varname>.
   </para>

   <para>
    Le maximum efficace pour <varname>vacuum_freeze_table_age</varname> est 0.95 *
    <varname>autovacuum_freeze_max_age</varname>&nbsp;; un paramétrage plus haut
    que ça sera limité à ce maximum. Une valeur plus importante que
    <varname>autovacuum_freeze_max_age</varname> n'aurait pas de sens car un
    autovacuum de préservation contre la ré-utilisation des identifiants de
    transactions serait déclenché, et le multiplicateur 0,95 laisse un peu de
    place pour exécuter un <command>VACUUM</command> manuel avant que cela ne
    survienne. Comme règle d'or, <command>vacuum_freeze_table_age</command> devrait
    être configuré à une valeur légèrement inférieure à
    <varname>autovacuum_freeze_max_age</varname>, laissant suffisamment d'espace
    pour qu'un <command>VACUUM</command> planifié régulièrement ou pour qu'un
    autovacuum déclenché par des activités normales de suppression et de mise à
    jour puissent être activés pendant ce laps de temps. Le configurer de façon
    trop proche pourrait déclencher des autovacuum de protection contre la
    ré-utilisation des identifiants de transactions, même si la table a été
    récemment l'objet d'un VACUUM pour récupérer l'espace, alors que des valeurs
    basses amènent à des VACUUM agressifs plus fréquents.
   </para>

   <para>
    Le seul inconvénient à augmenter
    <varname>autovacuum_freeze_max_age</varname> (et
    <varname>vacuum_freeze_table_age</varname> avec elle) est que les sous-
    répertoires <filename>pg_xact</filename> et
    <filename>pg_commit_ts</filename> de l'instance prendront plus de place
    car il doit stocker le statut et l'horodatage (si
    <varname>track_commit_timestamp</varname> est activé) du COMMIT pour
    toutes les transactions depuis
    <varname>autovacuum_freeze_max_age</varname>. L'état de COMMIT utilise
    deux bits par transaction, donc si
    <varname>autovacuum_freeze_max_age</varname> et
    <varname>vacuum_freeze_table_age</varname> ont une valeur maximum permise
    de deux milliards, <filename>pg_xact</filename> peut grossir jusqu'à la
    moitié d'un Go et <filename>pg_commit_ts</filename> jusqu'à 20 Go. Si
    c'est rien comparé à votre taille de base totale, configurer
    <varname>autovacuum_freeze_max_age</varname> à son maximum permis est
    recommandé. Sinon, le configurer suivant ce que vous voulez comme stockage
    maximum dans <filename>pg_xact</filename> et dans
    <filename>pg_commit_ts</filename>. (La valeur par défaut, 200 millions de
    transactions, se traduit en à peu près 50&nbsp;Mo de stockage dans
    <filename>pg_xact</filename> et à peu près 2 Go de stockage pour
    <filename>pg_commit_ts</filename>.)
   </para>

   <para>
    Un inconvénient causé par la diminution de
    <varname>vacuum_freeze_min_age</varname> est que cela pourrait faire que
    <command>VACUUM</command> travaille sans raison&nbsp;: geler une version de
    ligne est une perte de temps
    si la ligne est modifiée rapidement après (ce qui fait qu'elle obtiendra
    un nouveau XID). Donc ce paramètre doit être suffisamment important pour
    que les lignes ne soient pas gelées jusqu'à ce qu'il soit pratiquement
    certain qu'elles ne seront plus modifiées.
   </para>

   <para>
    Pour tracer l'âge des plus anciens XID non gelés de la base, <command>VACUUM</command>
    stocke les statistiques sur XID dans les tables systèmes
    <structname>pg_class</structname> et <structname>pg_database</structname>.
    En particulier, la colonne <structfield>relfrozenxid</structfield> de la
    ligne <structname>pg_class</structname> d'une table contient le XID final
    du gel qui a été utilisé par le dernier <command>VACUUM</command> agressif
    pour cette
    table. Il est garanti que tous les XID plus anciens que ce XID ont été
    remplacés par <literal>FrozenXID</literal> pour cette table. Toutes les
    lignes insérées par des transactions dont le XID est plus ancien que ce XID
    sont garanties d'avoir été gelées. De façon
    similaire, la colonne <structfield>datfrozenxid</structfield> de la ligne
    <structname>pg_database</structname> de la base est une limite inférieure des
    XID non gelés apparaissant dans cette base &mdash; c'est tout simplement le
    minimum des valeurs <structfield>relfrozenxid</structfield> par table dans
    cette base. Pour examiner cette information, le plus simple est d'exécuter
    des requêtes comme&nbsp;:

    <programlisting>SELECT c.oid::regclass as table_name,
       greatest(age(c.relfrozenxid),age(t.relfrozenxid)) as age
FROM pg_class c
LEFT JOIN pg_class t ON c.reltoastrelid = t.oid
WHERE c.relkind IN ('r', 'm');

SELECT datname, age(datfrozenxid) FROM pg_database;</programlisting>

    La colonne <literal>age</literal> mesure le nombre de transactions à partir
    du XID final vers le XID de transaction en cours.
   </para>

   <para>
    Habituellement, <command>VACUUM</command> parcourt seulement les blocs qui
    ont été modifiés depuis le dernier vacuum mais
    <structfield>relfrozenxid</structfield> peut seulement être avancé quand
    tous les blocs d'une table pouvant contenir des XID gelés sont parcourus.
    Ceci survient quand <structfield>relfrozenxid</structfield> a plus de
    <varname>vacuum_freeze_table_age</varname> transactions antérieures, quand
    l'option <literal>FREEZE</literal> de <command>VACUUM</command> est
    utilisée ou quand tous les blocs qui ne sont pas encore gelés nécessitent
    un nettoyage pour supprimer les versions de lignes mortes. Quand
    <command>VACUUM</command> parcourt chaque bloc d'une table qui n'est pas
    déjà entièrement gelé, il doit configurer <literal>age(relfrozenxid)</literal>
    à une valeur un peu au-dessus de la configuration utilisée pour
    <varname>vacuum_freeze_min_age</varname> (plus par le nombre de transactions
    démarrées depuis le lancement de <command>VACUUM</command>). Si aucun
    <command>VACUUM</command> avec avancement de <structfield>relfrozenxid</structfield>
    n'est lancé sur la table, une fois arrivé à
    <varname>autovacuum_freeze_max_age</varname>, un autovacuum est forcé sur la
    table.
   </para>

   <para>
    Si, pour une certaine raison, l'autovacuum échoue à effacer les anciens XID
    d'une table, le système commencera à émettre des messages d'avertissement
    comme ceci quand les plus anciens XID de la base atteignent les 11 millions
    de transactions à partir du point de réinitialisation&nbsp;:

<programlisting>
WARNING:  database "mydb" must be vacuumed within 10985967 transactions
HINT:  To avoid a database shutdown, execute a database-wide VACUUM in that database.
    </programlisting>
    (Une commande <command>VACUUM</command> manuelle devrait résoudre le problème,
    comme suggéré par l'indice&nbsp;; mais notez que la commande
    <command>VACUUM</command> doit être exécutée par un superutilisateur, sinon
    elle échouera à mettre à jour les catalogues systèmes et ne pourra donc pas faire
    avancer le <structfield>datfrozenxid</structfield> de la base.)
    Si ces avertissements sont ignorés, le système s'arrêtera et refusera
    de commencer toute nouvelle transaction dès qu'il n'en restera qu'un
    million avant la réinitialisation&nbsp;:

    <programlisting>
ERROR:  database is not accepting commands to avoid wraparound data loss in database "mydb"
HINT:  Stop the postmaster and vacuum that database in single-user mode.
    </programlisting>

    La marge de sécurité de un million de transactions existe pour permettre à
    l'administrateur de récupérer ces données sans perte en exécutant
    manuellement les commandes <command>VACUUM</command> requises. Néanmoins, comme le
    système n'exécute pas de commandes tant qu'il n'est pas sorti du mode
    d'arrêt par sécurité, la seule façon de le faire est de stopper le
    serveur et de démarrer le serveur en mode simple utilisateur pour exécuter le
    <command>VACUUM</command>. Le mode d'arrêt n'est pas pris en compte par le moteur
    en mode simple utilisateur. Voir la page de référence de <xref linkend="app-postgres"/> pour
    des détails sur l'utilisation du moteur en mode simple utilisateur.
   </para>

   <sect3 id="vacuum-for-multixact-wraparound">
    <title>Multixacts et cycle</title>

    <indexterm>
     <primary>MultiXactId</primary>
    </indexterm>

    <indexterm>
     <primary>cycle</primary>
     <secondary>d'identifiants multixact</secondary>
    </indexterm>

    <para>
     Les <firstterm>identifiants multixact</firstterm> sont utilisés pour
     supporter le verrouillage de lignes par des transactions multiples.
     Comme l'espace est limité dans un en-tête de ligne pour y stocker des
     informations, cette information est codée sous la forme d'un
     <quote>identifiant de transaction multiple</quote>, ou ID multixact
     pour faire court, à chaque fois qu'il y a plus d'une transaction
     cherchant à verrouiller en parallèle une ligne. Les informations sur les
     identifiants de transactions inclus dans tout identifiant multixact sont
     enregistrées séparément dans le sous-répertoire
     <filename>pg_multixact</filename> et seul l'identifiant multixact apparaît
     dans le champ <structfield>xmax</structfield> de l'en-tête de ligne.
     Comme les identifiants de transactions, les identifiants multi-transactions
     sont implémentés avec un compteur 32 bits et le stockage correspondant,
     ce qui nécessite une gestion attentive, un nettoyage du stockage et la
     gestion du cycle (plus exactement de la ré-utilisation des identifiants).
     Il existe un espace de stockage séparé qui détient la liste des membres
     dans chaque multixact, qui utilise aussi un compteur sur 32 bits et qui
     doit aussi être géré.
    </para>

    <para>
     Quand <command>VACUUM</command> parcourt une partie d'une table, il
     remplacera tout ID multixact qu'il rencontre, plus âgé que
     <xref linkend="guc-vacuum-multixact-freeze-min-age"/>, par
     une valeur différente, qui peut être la valeur zéro, un identifiant de
     transaction ou un nouvel identifiant multixact. Pour chaque table,
     <structname>pg_class</structname>.<structfield>relminmxid</structfield>
     enregistre le plus ancien identifiant multixact possible apparaissant déjà
     dans un enregistrement de cette table. Si cette valeur est plus ancienne
     que <xref linkend="guc-vacuum-multixact-freeze-table-age"/>, un vacuum
     agressif est forcé. Comme indiqué dans la section précédente, un vacuum
     agressif signifie que seuls les blocs connus pour être entièrement gelés
     seront ignorés. <function>mxid_age()</function> peut être utilisé sur
     <structname>pg_class</structname>.<structfield>relminmxid</structfield>
     pour trouver son âge.
    </para>

    <para>
     Les <command>VACUUM</command> agressifs, quelqu'en soit la cause, permet
     d'avancer la
     valeur pour cette table. Comme toutes les tables de toutes les bases sont
     parcourues et que leur plus anciennes valeurs multixact sont avancées,
     le stockage sur disque pour les anciens multixacts peut être supprimé.
    </para>

    <para>
     Comme moyen de sécurité supplémentaire, un VACUUM agressif surviendra pour
     toute table dont l'âge en identifiant multixact est supérieur à <xref
     linkend="guc-autovacuum-multixact-freeze-max-age"/>. Des VACUUM agressifs
     surviendront aussi progressivement pour toutes
     les tables, en commençant par ceux qui ont le multixact le plus ancien, si
     la quantité d'espace disque utilisé pour le membre dépasse 50% de l'espace
     de stockage accessible. Ces deux types de parcours agressifs de tables
     surviendront seulement si l'autovacuum est désactivé spécifiquement.
    </para>
   </sect3>
  </sect2>

  <sect2 id="autovacuum">
   <title>Le démon auto-vacuum</title>

   <indexterm>
    <primary>autovacuum</primary>
    <secondary>information générale</secondary>
   </indexterm>
   <para>
    <productname>PostgreSQL </productname> dispose d'une fonctionnalité
    optionnelle mais hautement recommandée appelée <firstterm>autovacuum</firstterm>,
    dont le but est d'automatiser l'exécution des commandes
    <command>VACUUM</command> et <command>ANALYZE </command>. Une fois activé,
    autovacuum vérifie les tables ayant un grand nombre de lignes insérées,
    mises à jour ou supprimées. Ces vérifications utilisent la fonctionnalité
    de récupération de statistiques&nbsp;; du coup, autovacuum ne peut
    pas être utilisé sauf si <xref linkend="guc-track-counts"/> est configuré
    à <literal>true</literal>.
    Dans la configuration par défaut, l'autovacuum est activé et les
    paramètres liés sont correctement configurés.
   </para>

   <para>
    Le <quote>démon autovacuum</quote> est constitué de plusieurs processus.
    Un processus démon permanent appelé <firstterm>autovacuum launcher</firstterm>
    (autrement dit le lanceur d'autovacuum)
    est en charge de lancer des processus travailleur (<firstterm>autovacuum
     worker</firstterm>) pour toutes les bases de données. Le lanceur distribuera
    le travail dans le temps mais essaiera de lancer un nouveau travailleur sur
    chaque base de données chaque <xref linkend="guc-autovacuum-naptime"/>
    secondes. (Du coup, si l'installation a <replaceable>N</replaceable> bases
    de données, un nouveau <firstterm>autovacuum worker</firstterm> sera
    lancé tous les
    <varname>autovacuum_naptime</varname>/<replaceable>N</replaceable>
    secondes.) Un maximum de <xref linkend="guc-autovacuum-max-workers"/>
    processus <firstterm>autovacuum worker</firstterm> est autorisé à
    s'exécuter en même temps. S'il y a plus de
    <varname>autovacuum_max_workers</varname>
    bases à traiter, la prochaine base de données sera traitée dès qu'un autre
    travailleur a terminé. Chaque processus travailleur vérifiera chaque table de
    leur base de données et exécutera un <command>VACUUM</command> et/ou un
    <command>ANALYZE</command> suivant les besoins.
    <xref linkend="guc-log-autovacuum-min-duration"/> peut être utilisé pour
    superviser l'activité des processus autovacuum worker.
   </para>

   <para>
    Si plusieurs grosses tables deviennent toutes éligibles pour un VACUUM dans
    un court espace de temps, tous les processus travailleurs pourraient avoir
    à exécuter des VACUUM sur ces tables pendant un long moment.
    Ceci aura pour résultat que d'autres tables et d'autres bases de
    données ne pourront pas être traitées tant qu'un processus travailleur
    ne sera pas disponible. Il n'y a pas de limite sur le nombre de processus
    travailleurs sur une seule base, mais ils essaient d'éviter de répéter le
    travail qui a déjà été fait par d'autres. Notez que le nombre de processus
    travailleurs en cours d'exécution n'est pas décompté des limites <xref
    linkend="guc-max-connections"/> et <xref
    linkend="guc-superuser-reserved-connections"/>.
   </para>

   <para>
    Les tables dont la valeur de <structfield>relfrozenxid</structfield> est
    plus importante que <xref linkend="guc-autovacuum-freeze-max-age"/> sont
    toujours l'objet d'un VACUUM (cela s'applique aux tables dont le 'freeze max age'
    a été modifié par les paramètres de stockage&nbsp;; voyez plus bas).
    Sinon, si le nombre de lignes obsolètes
    depuis le dernier <command>VACUUM</command> dépasse une <quote>limite de
     vacuum</quote>, la table bénéficie d'un VACUUM. La limite est définie
    ainsi&nbsp;:
    <programlisting>limite du vacuum = limite de base du vacuum + facteur d'échelle du vacuum * nombre de lignes</programlisting>
    où la limite de base du vacuum est
    <xref linkend="guc-autovacuum-vacuum-threshold"/>,
    le facteur d'échelle du vacuum est
    <xref linkend="guc-autovacuum-vacuum-scale-factor"/>
    et le nombre de lignes est
    <structname>pg_class</structname>.<structfield>reltuples</structfield>.
   </para>

   <para>
    La table est aussi traitée si le nombre de lignes insérées depuis le
    dernier VACUUM a dépassé la limite d'insertion définie, d'après cette
    formule&nbsp;:
<programlisting>
limite insertion vacuum = limite insertion base vacuum + facteur échelle insertion vacuum * nombre de lignes
    </programlisting>
    où la limite d'insertion de base du VACUUM correspond au paramètre <xref
    linkend="guc-autovacuum-vacuum-insert-threshold"/>, et le facteur
    d'échelle d'insertion du VACUUM correspond au paramètre <xref
    linkend="guc-autovacuum-vacuum-insert-scale-factor"/>. De tels VACUUM
    permettent de marquer des portions de la table comme <firstterm>tout
     visible</firstterm> et permettent aussi de geler les lignes, ce qui peut
    réduire le travail requis par les VACUUM suivant. Pour les tables recevant
    des opérations <command>INSERT</command> mais aucune ou très peu
    d'opérations <command>UPDATE</command>/<command>DELETE</command>, il peut
    être bénéfique de diminuer la valeur du paramètre <xref
    linkend="reloption-autovacuum-freeze-min-age"/> pour la table car cela
    permet le gel des lignes par des VACUUM rapides. Le nombre de lignes
    obsolètes et le nombre de lignes insérées sont obtenus via le collecteur
    de statistiques&nbsp;; ce décompte moyennement précis est mis à jour par
    chaque opération <command>UPDATE</command>, <command>DELETE</command> et
    <command>INSERT</command>. (C'est seulement moyennement précis car
    certaines informations pourraient être perdues en cas de fortes charges.)
    Si la valeur du champ <structfield>relfrozenxid</structfield> pour la
    table est supérieure à <varname>vacuum_freeze_table_age</varname>, un
    VACUUM agressif est réalisé pour geler les anciennes lignes et avancer la
    valeur de <structfield>relfrozenxid</structfield>, sinon seules les pages
    qui ont été modifiées depuis le dernier VACUUM sont parcourues par
    l'opération de VACUUM.
   </para>

   <para>
    Pour ANALYZE, une condition similaire
    est utilisée&nbsp;: la limite, définie comme
    <programlisting>limite du analyze = limite de base du analyze + facteur d'échelle du analyze * nombre de lignes</programlisting>
    est comparée au nombre de lignes insérées, mises à jour et supprimées depuis
    le dernier <command>ANALYZE</command>.
   </para>

   <para>
    Les tables temporaires ne peuvent pas être accédées par l'autovacuum. Du
    coup, les opérations appropriées de VACUUM et d'ANALYZE devraient être
    traitées par des commandes SQL de session.
   </para>

   <para>
    Les limites et facteurs d'échelle par défaut (et beaucoup d'autres
    paramètres de contrôle de l'autovacuum) sont pris dans
    <filename>postgresql.conf</filename>, mais il est possible de les
    surcharger table par table&nbsp;; voir
    <xref linkend="sql-createtable-storage-parameters"/> pour plus d'informations.
   </para>

   <para>
    Si une configuration a été modifié via les paramètres de stockage d'une
    table, cette valeur est utilisée lors du traitement de cette table. Dans
    le cas contraire, les paramètres globaux sont utilisés. Voir <xref
    linkend="runtime-config-autovacuum"/> pour plus de détails sur les
    paramètres globaux.
   </para>

   <para>
    Quand plusieurs autovacuum workers travaillent, les paramètres de délai de
    coût de l'autovacuum (voir <xref
    linkend="runtime-config-resource-vacuum-cost"/>) sont
    <quote>réparties</quote> parmi tous les processus pour que l'impact total
    en entrée/sortie sur le système soit identique quelque soit le nombre de
    processus en cours d'exécution. Néanmoins, tout autovacuum worker traitant
    des tables et dont les paramètres de stockage
    <literal>autovacuum_vacuum_cost_delay</literal> ou
    <literal>autovacuum_vacuum_cost_limit</literal> ont été configurés
    spécifiquement ne sont pas considérés dans l'algorithme de balance.
   </para>

   <para>
    Les workers de l'autovacuum ne bloquent généralement pas les autres
    commandes. Si un processus tente d'acquérir un verrou qui entre en conflit
    avec le verrou <literal>SHARE UPDATE EXCLUSIVE</literal> détenu par
    autovacuum, la demande de verrou interrompra l'autovacuum. Pour les modes
    de verrou entrant en conflit, voir <xref
    linkend="table-lock-compatibility"/>. Néanmoins, si l'autovacuum s'exécute
    pour empêcher une réutilisation des identifiants de transaction
    (c'est-à-dire si le texte de la requête de l'autovacuum dans la vue
    <structname>pg_stat_activity</structname> se termine avec le texte
    <literal>(to prevent wraparound)</literal>), l'autovacuum n'est pas
    automatiquement interrompu.
   </para>

   <warning>
    <para>
     Exécuter régulièrement des commandes qui acquièrent des verrous en
     conflit avec un verrou <literal>SHARE UPDATE EXCLUSIVE</literal> (par
     exemple ANALYZE) peut empêcher fortement le traitement réalisé par
     l'autovacuum.
    </para>
   </warning>
  </sect2>
 </sect1>


 <sect1 id="routine-reindex">
  <title>Ré-indexation régulière</title>

  <indexterm zone="routine-reindex">
   <primary>ré-indexation</primary>
  </indexterm>

  <para>
   Dans certains cas, reconstruire périodiquement les index par la commande
   <xref linkend="sql-reindex"/> ou une série d'étapes individuelles de
   reconstruction en vaut la peine.
  </para>

  <para>
   Les pages de l'index B-tree, qui sont devenues complètement vides, sont
   réclamées pour leur ré-utilisation. Mais, il existe toujours une
   possibilité d'utilisation peu efficace de l'espace : si, sur une page,
   seulement plusieurs clés d'index ont été supprimés, la page reste allouée.
   En conséquence, si seulement quelques clés sont supprimées, vous devrez
   vous attendre à ce que l'espace disque soit très mal utilisé. Dans de tels
   cas, la réindexation périodique est recommandée.
  </para>

  <para>
   Le potentiel d'inflation des index qui ne sont pas des index B-tree n'a pas
   été particulièrement analysé. Surveiller périodiquement la taille physique de
   ces index est une bonne idée.
  </para>

  <para>
   De plus, pour les index B-tree, un index tout juste construit est légèrement
   plus rapide qu'un index qui a été mis à jour plusieurs fois parce que
   les pages adjacentes logiquement sont habituellement aussi physiquement
   adjacentes dans un index nouvellement créé (cette considération ne s'applique
   pas aux index non B-tree). Il pourrait être intéressant de ré-indexer
   périodiquement simplement pour améliorer la vitesse d'accès.
  </para>

  <para>
   <xref linkend="sql-reindex"/> peut être utilisé en toute sécurité et très
   facilement dans tous les cas. Cette commande nécessite un verrou
   <literal>ACCESS EXCLUSIVE</literal> par défaut. De ce fait, il est souvent
   préférable de l'exécuter avec l'option <literal>CONCURRENTLY</literal> qui
   requiert seulement un verrou <literal>SHARE UPDATE EXCLUSIVE</literal>.
  </para>
 </sect1>


 <sect1 id="logfile-maintenance">
  <title>Maintenance du fichier de traces</title>

  <indexterm zone="logfile-maintenance">
   <primary>traces serveur</primary>
   <secondary>maintenance du fichier de traces</secondary>
  </indexterm>

  <para>
   Sauvegarder les journaux de trace du serveur de bases de données dans un
   fichier plutôt que dans <filename>/dev/NULL</filename> est une bonne idée. Les
   journaux sont d'une utilité incomparable lorsqu'arrive le moment où des
   problèmes surviennent. Néanmoins, les journaux ont tendance à être
   volumineux (tout spécialement à des niveaux de débogage importants) et vous
   ne voulez pas les sauvegarder indéfiniment. Vous avez besoin de faire une
   <quote>rotation</quote> des journaux pour que les nouveaux journaux sont
   commencés et que les anciens soient supprimés après une période de temps
   raisonnable.
  </para>

  <para>
   Si vous redirigez simplement <systemitem>stderr</systemitem> du
   <command>postgres</command> dans un fichier, vous aurez un journal des
   traces mais la seule façon de le tronquer sera d'arrêter et de relancer
   le serveur. Ceci peut convenir si vous utilisez
   <productname>PostgreSQL</productname> dans un environnement de développement
   mais peu de serveurs de production trouveraient ce comportement acceptable.
  </para>

  <para>
   Une meilleure approche est d'envoyer la sortie
   <systemitem>stderr</systemitem> du serveur dans un programme de rotation de
   journaux. Il existe un programme interne de rotation que vous pouvez
   utiliser en configurant le paramètre <varname>logging_collector</varname> à
   <literal>true</literal> dans <filename>postgresql.conf</filename>. Les
   paramètres de contrôle pour ce programme sont décrits dans <xref
   linkend="runtime-config-logging-where"/>. Vous pouvez aussi utiliser cette
   approche pour capturer les données des journaux applicatifs dans un format
   <acronym>CSV</acronym> (valeurs séparées par des virgules) lisible par une
   machine
  </para>

  <para>
   Sinon, vous pourriez préférer utiliser un programme externe de rotation de
   journaux si vous en utilisez déjà un avec d'autres serveurs. Par exemple,
   l'outil <application>rotatelogs</application> inclus dans la distribution
   <productname>Apache</productname> peut être utilisé avec
   <productname>PostgreSQL</productname>. Pour cela, envoyez via un tube la
   sortie <systemitem>stderr</systemitem> du serveur dans le programme
   désiré. Si vous lancez le serveur avec <command>pg_ctl</command>, alors
   <systemitem>stderr</systemitem> est déjà directement renvoyé dans
   <systemitem>stdout</systemitem>, donc vous avez juste besoin d'ajouter la commande via
   un tube, par exemple&nbsp;:

<programlisting>pg_ctl start | rotatelogs /var/log/pgsql_log 86400</programlisting>
</para>

  <para>
   Vous pouvez combiner ces approches en configurant
   <application>logrotate</application> pour qu'il récupère les fichiers de
   trace produits par le collecteur de trace de
   <productname>PostgreSQL</productname>. Dans ce cas, le collecteur définit
   les noms et emplacement des fichiers de trace, alors que
   <application>logrotate</application> les archive périodiquement. Lors d'une
   rotation de fichier de traces, <application>logrotate</application> doit
   s'assurer que l'application envoie les nouvelles traces dans le nouveau
   fichier. Ceci se fait habituellement avec un script
   <literal>postrotate</literal> qui envoie un signal
   <literal>SIGHUP</literal> à l'application, qui ouvre ensuite de nouveau le
   fichier de traces. Dans <productname>PostgreSQL</productname>, vous pouvez
   exécuter <command>pg_ctl</command> avec l'option
   <literal>logrotate</literal>. Quand le serveur reçoit cette commande, soit
   le serveur bascule vers un nouveau fichier de trace soit il ouvre le
   fichier existant, suivant la configuration des traces (voir <xref
   linkend="runtime-config-logging-where"/>).
  </para>

  <note>
   <para>
    Lors de l'utilisation de noms de fichier statique, le serveur pourrait
    échouer lors de la réouverture du fichier de trace si la limite du nombre
    maximum de fichiers ouvert est atteint ou qu'un dépassement de la table de
    fichiers survient. Dans ce cas, les traces sont envoyées à l'ancien
    fichier de traces jusqu'à la réussite de la rotation du fichier de trace.
    Si <application>logrotate</application> est configuré pour compresser le
    fichier de trace et le supprimer, le serveur pourrait perdre les messages
    tracées pendant cette fenêtre de temps. Pour éviter ce problème, vous
    pouvez configurer le collecteur de traces pour qu'il affecte dynamiquement
    les noms des fichiers de trace et utilise un script
    <literal>prerotate</literal> pour ignorer les fichiers de trace ouverts.
    </para>
  </note>

  <para>
   Une autre approche de production pour la gestion des journaux de trace est
   de les envoyer à <application>syslog</application> et de laisser <application>syslog</application>
   gérer la rotation des fichiers. Pour cela, initialisez le paramètre de
   configuration <varname>log_destination</varname> à <literal>syslog</literal> (pour tracer
   uniquement via <application>syslog</application>) dans <filename>postgresql.conf</filename>.
   Ensuite, vous pouvez envoyer un signal <literal>SIGHUP</literal> au démon
   <application>syslog</application> quand vous voulez le forcer à écrire dans un nouveau
   fichier. Si vous voulez automatiser la rotation des journaux, le programme
   <application>logrotate</application> peut être configuré pour fonctionner
   avec les journaux de traces provenant de <application>syslog</application>.
  </para>

  <para>
   Néanmoins, sur beaucoup de systèmes, <application>syslog</application> n'est pas très
   fiable, particulièrement avec les messages très gros&nbsp;; il pourrait
   tronquer ou supprimer des messages au moment où vous en aurez le plus besoin.
   De plus, sur <productname>Linux</productname>, <application>syslog</application> synchronisera tout
   message sur disque, amenant des performances assez pauvres. (Vous pouvez
   utiliser un <quote><literal>-</literal></quote> au début du nom de fichier dans le fichier de
   configuration <application>syslog</application> pour désactiver la synchronisation.)
  </para>

  <para>
   Notez que toutes les solutions décrites ci-dessus font attention à lancer de
   nouveaux journaux de traces à des intervalles configurables mais ils ne
   gèrent pas la suppression des vieux fichiers de traces, qui ne sont
   probablement plus très utiles. Vous voudrez probablement configurer
   un script pour supprimer périodiquement les anciens journaux. Une autre
   possibilité est de configurer le programme de rotation pour que les anciens
   journaux de traces soient écrasés de façon cyclique.
  </para>

  <para>
   <ulink url="https://pgbadger.darold.net/"><productname>pgBadger</productname></ulink>
   est un projet externe qui analyse les journaux applicatifs d'une façon très
   poussée. <ulink
   url="https://bucardo.org/check_postgres/"><productname>check_postgres</productname></ulink> fournit
   des alertes Nagios quand des messages importants apparaît dans les journaux
   applicatifs, mais détecte aussi de nombreux autres cas.
  </para>
 </sect1>
</chapter>
