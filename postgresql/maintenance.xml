<?xml version="1.0" encoding="UTF-8"?>
<chapter id="maintenance">
 <title>Planifier les tâches de maintenance</title>

 <indexterm zone="maintenance">
  <primary>maintenance</primary>
 </indexterm>

 <indexterm zone="maintenance">
  <primary>routine maintenance</primary>
 </indexterm>

 <para>
  <productname>PostgreSQL</productname>, comme tout SGBD, requiert que
  certaines tâches soient réalisées de façon régulière pour atteindre des
  performances optimales. Ces tâches sont <emphasis>requises</emphasis>, mais
  elles sont répétitives par nature et peuvent être facilement automatisées
  en utilisant des outils standard comme les scripts
  <application>cron</application> ou le <application>Task
  Scheduler</application> de Windows. La responsabilité de la mise en place
  de ces scripts et du contrôle de leur bon fonctionnement relève de
  l'administrateur de la base.
 </para>

 <para>
  Une opération de maintenance évidente est la sauvegarde régulière des
  données. Sans une sauvegarde récente, il est impossible de restaurer après
  un dommage grave (perte d'un disque, incendie, table supprimée par erreur,
  etc.). Les mécanismes de sauvegarde et restauration disponibles dans
  <productname>PostgreSQL</productname> sont détaillés dans le <xref
  linkend="backup"/>.
 </para>

 <para>
  L'autre tâche primordiale est la réalisation périodique d'un
  <quote>vacuum</quote>, c'est-à-dire un <quote>nettoyage</quote> de la base
  de données. Cette opération est détaillée dans la <xref
  linkend="routine-vacuuming"/>. De la même façon, la mise à jour des
  statistiques utilisées par l'optimiseur de requêtes sera discutée dans
  <xref linkend="vacuum-for-statistics"/>.
 </para>

 <para>
  La gestion des fichiers de traces mérite aussi une attention régulière. Cela
  est détaillé dans la <xref linkend="logfile-maintenance"/>.
 </para>

 <para>
  <ulink
  url="https://bucardo.org/check_postgres/"><application>check_postgres</application></ulink>
  est disponible pour surveiller la santé des bases de données et pour
  rapporter des conditions inhabituelles.
  <application>check_postgres</application> s'intègre bien avec Nagios et
  MRTG, mais il peut aussi fonctionner de façon autonome.
 </para>

 <para>
  <productname>PostgreSQL</productname> demande peu de maintenance par rapport
  à d'autres SGBD. Néanmoins, un suivi vigilant de ces tâches participera
  beaucoup à rendre le système productif et agréable à utiliser.
 </para>

 <sect1 id="routine-vacuuming">
  <title>Nettoyages réguliers</title>

  <indexterm zone="routine-vacuuming">
   <primary>vacuum</primary>
  </indexterm>

  <para>
   Les bases de données de <productname>PostgreSQL</productname> nécessitent
   des opérations de maintenance périodiques, connues sous le nom de
   <firstterm>VACUUM</firstterm>. Pour de nombreuses installations, il est
   suffisant de laisser travailler le <firstterm>démon
   autovacuum</firstterm>, qui est décrit dans <xref linkend="autovacuum"/>.
   En fonction des cas, les paramètres de cet outil peuvent être optimisés
   pour obtenir de meilleurs résultats. Certains administrateurs de bases de
   données voudront suppléer ou remplacer les activités du démon avec une
   gestion manuelle des commandes <command>VACUUM</command>, qui seront
   typiquement exécutées suivant un planning par des scripts
   <application>cron</application> ou par le <application>Task
   Scheduler</application>. Pour configurer une gestion manuelle et correcte
   du VACUUM, il est essentiel de bien comprendre les quelques sous-sections
   suivantes. Les administrateurs qui se basent sur l'autovacuum peuvent
   toujours lire ces sections pour les aider à comprendre et à ajuster
   l'autovacuum.
  </para>

  <sect2 id="vacuum-basics">
   <title>Bases du VACUUM</title>

   <para>
    La commande <link linkend="sql-vacuum"><command>VACUUM</command></link> de
    <productname>PostgreSQL</productname> doit traiter chaque table
    régulièrement pour plusieurs raisons&nbsp;:

    <orderedlist>
     <listitem>
      <simpara>pour récupérer ou ré-utiliser l'espace disque occupé par les
      lignes supprimées ou mises à jour&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>pour mettre à jour les statistiques utilisées par l'optimiseur
      de <productname>PostgreSQL</productname>&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>Pour mettre à jour la carte de visibilité qui accélère les
      <link linkend="indexes-index-only-scans">parcours d'index
      seuls</link>&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>pour prévenir la perte des données les plus anciennes à cause
      d'un <firstterm>cycle de l'identifiant de transaction
      (XID)</firstterm> ou d'un <firstterm>cycle de l'identifiant
      multixact</firstterm>.</simpara>
     </listitem>
    </orderedlist>

    Chacune de ces raisons impose de réaliser des opérations
    <command>VACUUM</command> de différentes fréquences et portées, comme
    expliqué dans les sous-sections suivantes.
   </para>

   <para>
    Il existe deux variantes de la commande <command>VACUUM</command>&nbsp;:
    le <command>VACUUM</command> standard et le <command>VACUUM
    FULL</command>. <command>VACUUM FULL</command> peut récupérer davantage
    d'espace disque mais s'exécute beaucoup plus lentement. Par ailleurs, la
    forme standard de <command>VACUUM</command> peut s'exécuter en parallèle
    avec les opérations de production des bases. Des commandes comme
    <command>SELECT</command>, <command>INSERT</command>,
    <command>UPDATE</command> et <command>DELETE</command> continuent de
    fonctionner de façon normale, mais la définition d'une table ne peut être
    modifiée avec des commandes telles que <command>ALTER TABLE</command>
    pendant le <command>VACUUM</command>. <command>VACUUM FULL</command>
    nécessite un verrou de type <literal>ACCESS EXCLUSIVE</literal> sur la
    table sur laquelle il travaille, et ne peut donc pas être exécuté en
    parallèle avec une autre activité sur la table. Par conséquent, en règle
    générale, les administrateurs doivent s'efforcer d'utiliser la commande
    standard <command>VACUUM</command> et éviter <command>VACUUM
    FULL</command>.
   </para>

   <para>
    <command>VACUUM</command> génère un nombre important d'entrées/sorties, ce
    qui peut entraîner de mauvaises performances pour les autres sessions
    actives. Des paramètres de configuration peuvent être ajustés pour
    réduire l'impact d'un nettoyage en arrière plan sur les
    performances&nbsp;&mdash; voir <xref
    linkend="runtime-config-resource-vacuum-cost"/>.
   </para>
  </sect2>

  <sect2 id="vacuum-for-space-recovery">
   <title>Récupérer l'espace disque</title>

   <indexterm zone="vacuum-for-space-recovery">
    <primary>espace disque</primary>
   </indexterm>

   <para>
    Avec <productname>PostgreSQL</productname>, les versions périmées des
    lignes ne sont pas immédiatement supprimées après une commande
    <command>UPDATE</command> ou <command>DELETE</command>. Cette approche
    est nécessaire pour la cohérence des accès concurrents
    (<acronym>MVCC</acronym>, voir le <xref linkend="mvcc"/>)&nbsp;: la
    version de la ligne ne doit pas être supprimée tant qu'elle est
    susceptible d'être lue par une autre transaction. Mais en fin de compte,
    une ligne qui est plus vieille que toutes les transactions en cours n'est
    plus utile du tout. La place qu'elle utilise doit être rendue pour être
    réutilisée par d'autres lignes afin d'éviter un accroissement constant,
    sans limite, du volume occupé sur le disque. Cela se fait en exécutant
    un <command>VACUUM</command>.
   </para>

   <para>
    La forme standard de <command>VACUUM</command> élimine les versions
    d'enregistrements morts dans les tables et les index, et marque l'espace
    comme réutilisable. Néanmoins, il ne rend pas cet espace au système
    d'exploitation, sauf dans le cas spécial où des pages à la fin d'une
    table deviennent totalement vides et qu'un verrou exclusif sur la table
    peut être obtenu aisément. Par opposition, <command>VACUUM FULL</command>
    compacte activement les tables en écrivant une nouvelle version complète
    du fichier de la table, sans espace vide. Ceci réduit la taille de la
    table mais peut prendre beaucoup de temps. Cela requiert aussi un espace
    disque supplémentaire pour la nouvelle copie de la table jusqu'à la fin
    de l'opération.
   </para>

   <para>
    Le but habituel d'un nettoyage régulier est de lancer des
    <command>VACUUM</command> standard suffisamment souvent pour éviter
    d'avoir recours à un <command>VACUUM FULL</command>. Le démon autovacuum
    essaie de fonctionner de cette façon, et n'exécute jamais de
    <command>VACUUM FULL</command>. Avec cette approche, l'idée directrice
    n'est pas de maintenir les tables à leur taille minimale, mais de
    maintenir l'utilisation de l'espace disque à un niveau constant&nbsp;:
    chaque table occupe l'espace équivalent à sa taille minimale plus la
    quantité d'espace consommée entre deux nettoyages. Bien que
    <command>VACUUM FULL</command> puisse être utilisé pour qu'une table
    retrouve sa taille minimale et rendre l'espace disque au système
    d'exploitation, cela ne sert pas à grand chose, si cette table recommence
    à grossir rapidement après. Par conséquent, cette approche s'appuyant sur
    des commandes <command>VACUUM</command> exécutées à intervalles
    modérément rapprochés est une meilleure approche que d'exécuter des
    <command>VACUUM FULL</command> espacés pour des tables mises à jour de
    façon intensive.
   </para>

   <para>
    Certains administrateurs préfèrent planifier le passage de
    <command>VACUUM</command> eux-mêmes, par exemple faire le travail de
    nuit, quand la charge est faible. La difficulté avec cette stratégie est
    que si une table a un pic d'activité de mise à jour inattendu, elle peut
    grossir au point qu'un <command>VACUUM FULL</command> soit vraiment
    nécessaire pour récupérer l'espace. L'utilisation du démon d'autovacuum
    minore ce problème, puisque le démon planifie les nettoyages de façon
    dynamique, en réponse à l'activité de mise à jour. Il est peu raisonnable
    de désactiver totalement le démon, sauf si l'activité de la base est
    extrêmement prévisible. Un compromis possible est de régler les
    paramètres du démon afin qu'il ne réagisse qu'à une activité
    exceptionnellement lourde de mise à jour, de sorte à seulement éviter de
    perdre totalement le contrôle de la volumétrie, tout en laissant les
    <command>VACUUM</command> planifiés faire le gros du travail quand la
    charge est normale.
   </para>

   <para>
    Pour ceux qui n'utilisent pas autovacuum, une approche typique alternative
    est de planifier un <command>VACUUM</command> sur la base complète une
    fois par jour lorsque l'utilisation n'est pas forte, avec en plus des
    opérations de <command>VACUUM</command> plus fréquentes pour les tables
    très impactées par des mises à jour, de la façon adéquate.
    (Certaines installations avec énormément de mises à jour peuvent exécuter
    des nettoyages toutes les quelques minutes.) Lorsqu'il y a plusieurs
    bases dans une instance, il faut penser à exécuter un
    <command>VACUUM</command> sur chacune d'elles&nbsp;; le programme <xref
    linkend="app-vacuumdb"/> peut se révéler utile dans ce contexte.
   </para>

   <tip>
    <para>
     Le <command>VACUUM</command> standard peut ne pas suffire quand une table
     contient un grand nombre d'enregistrements morts comme conséquence d'une
     mise à jour ou d'une suppression massive. Dans ce cas, s'il est
     nécessaire de récupérer l'espace disque gaspillé, plusieurs commandes
     sont utilisables&nbsp;: <command>VACUUM FULL</command>, <link
     linkend="sql-cluster"><command>CLUSTER</command></link> ou une des
     variantes de <link linkend="sql-altertable"><command>ALTER
     TABLE</command></link>. Ces commandes écrivent une nouvelle copie de la
     table et reconstruisent ses index. Toutes ces options nécessitent un
     verrou de type <literal>ACCESS EXCLUSIVE</literal>. Elles utilisent
     aussi temporairement un espace disque supplémentaire, approximativement
     égal à la taille de la table, car les anciennes copies de la table et
     des index ne peuvent pas être supprimées avant la fin de l'opération.
    </para>
   </tip>

   <tip>
    <para>
     Si le contenu d'une table est supprimé périodiquement, il est préférable
     d'envisager l'utilisation de <link
     linkend="sql-truncate"><command>TRUNCATE</command></link>, plutôt que
     <command>DELETE</command> suivi de <command>VACUUM</command>.
     <command>TRUNCATE</command> supprime le contenu entier de la table
     immédiatement sans nécessiter de <command>VACUUM</command> ou
     <command>VACUUM FULL</command> pour réclamer l'espace disque maintenant
     inutilisé. L'inconvénient est la violation des sémantiques MVCC
     strictes.
    </para>
   </tip>
  </sect2>

  <sect2 id="vacuum-for-statistics">
   <title>Maintenir les statistiques de l'optimiseur</title>

   <indexterm zone="vacuum-for-statistics">
    <primary>statistiques</primary>
    <secondary>de l'optimiseur</secondary>
   </indexterm>

   <indexterm zone="vacuum-for-statistics">
    <primary>ANALYZE</primary>
   </indexterm>

   <para>
    L'optimiseur de requêtes de <productname>PostgreSQL</productname> s'appuie
    sur des informations statistiques produites à partir du contenu des
    tables dans l'optique de produire des plans d'exécutions efficaces pour
    les requêtes. Ces statistiques sont collectées par la commande <link
    linkend="sql-analyze"><command>ANALYZE</command></link> , qui peut être
    invoquée seule ou comme option de <command>VACUUM</command>. Il est
    important d'avoir des statistiques relativement à jour, ce qui permet
    d'éviter les choix de mauvais plans d'exécution, pénalisant les
    performances de la base.
   </para>

   <para>
    Si activé, le démon autovacuum va automatiquement exécuter des commandes
    <command>ANALYZE</command> à chaque fois que le contenu d'une table aura
    changé suffisamment. Toutefois, un administrateur peut préférer se fier à
    des opérations <command>ANALYZE</command> planifiées manuellement, en
    particulier s'il est connu que l'activité de mise à jour de la table n'a
    pas d'impact sur les statistiques des colonnes
    <quote>intéressantes</quote>. Le démon planifie des
    <command>ANALYZE</command> en fonction du nombre d'enregistrements
    insérés, mis à jour ou supprimés&nbsp;; il n'a aucune connaissance du
    fait que cela générera ou pas des modifications intéressantes au niveau
    des statistiques.
   </para>

   <para>
    À l'instar du nettoyage pour récupérer l'espace, les statistiques doivent
    être plus souvent collectées pour les tables intensément modifiées que
    pour celles qui le sont moins. Mais même si la table est très modifiée,
    il se peut que ces collectes soient inutiles si la distribution
    probabiliste des données évolue peu. Une règle simple pour décider est de
    voir comment évoluent les valeurs minimale et maximale des données. Par
    exemple, une colonne de type <type>timestamp</type> qui contient la date
    de mise à jour de la ligne aura une valeur maximale en continuelle
    croissance au fur et à mesure des modifications&nbsp;; une telle colonne
    nécessitera plus de collectes statistiques qu'une colonne qui contient
    par exemple les URL des pages accédées sur un site web. La colonne qui
    contient les URL peut très bien être aussi souvent modifiée mais la
    distribution probabiliste des données changera certainement moins
    rapidement.
   </para>

   <para>
    Il est possible d'exécuter <command>ANALYZE</command> sur des tables
    spécifiques, voire des colonnes spécifiques&nbsp;; il y a donc une grande
    flexibilité pour mettre à jour certaines statistiques plus souvent que
    les autres en fonction des besoins de l'application. Quoi qu'il en soit,
    dans la pratique, il est généralement mieux de simplement analyser la
    base entière car il s'agit d'une opération rapide.
    <command>ANALYZE</command> utilise un système d'échantillonage des lignes
    d'une table, ce qui lui évite de lire chaque ligne.
   </para>

   <tip>
    <para>
     Même si il n'est pas très productif de règler précisément la fréquence de
     <command>ANALYZE</command> pour chaque colonne, il peut être intéressant
     d'ajuster le niveau de détail des statistiques collectées pour chaque
     colonne. Les colonnes très utilisées dans les clauses
     <literal>WHERE</literal> et dont la distribution n'est pas uniforme
     requièrent des histogrammes plus précis que les autres colonnes. Voir
     <command>ALTER TABLE SET STATISTICS</command>, ou modifier les
     paramètres par défaut de la base de données en utilisant le paramètre de
     configuration <xref linkend="guc-default-statistics-target"/>.
    </para>

    <para>
     De plus, par défaut, il existe peu d'informations sur la sélectivité des
     fonctions. Néanmoins, si vous créez un objet statistique ou un index sur
     une fonction, des statistiques utiles seront récupérées sur la fonction,
     ce qui peut grandement améliorer les plans de requêtes qui utilisent
     l'index.
    </para>
   </tip>

   <tip>
    <para>
     Le démon autovacuum ne lance pas de commandes <command>ANALYZE</command>
     sur les tables distantes car il n'a aucun moyen de déterminer la
     fréquence à laquelle la mise à jour des statistiques serait utile. Si
     vos requêtes ont besoin des statistiques sur les tables distantes pour
     disposer d'un plan d'exécution correct, une bonne idée serait de lancer
     manuellement des commandes <command>ANALYZE</command> sur ces tables au
     moment adéquat.
    </para>
   </tip>
  </sect2>

  <sect2 id="vacuum-for-visibility-map">
   <title>Mettre à jour la carte de visibilité</title>

   <para>
    La commande VACUUM maintient le contenu de la <link
    linkend="storage-vm">carte de visibilité</link> de chaque table, pour
    conserver la trace de chaque bloc contenant seulement des lignes connues
    pour être visibles par toutes les transactions actives (ainsi que les
    futures transactions, jusqu'à la prochaine modification de la page).
    Cette carte a deux buts. Tout d'abord, le nettoyage peut ignorer ce type
    de blocs à la prochaine exécution du VACUUM comme il n'y a rien à
    nettoyer dans ces blocs.
   </para>

   <para>
    Ensuite, il permet à <productname>PostgreSQL</productname> de répondre à
    certaines requêtes en utilisant seulement l'index, et donc sans faire
    référence à la table sous-jacente. Comme les index dans
    <productname>PostgreSQL</productname> ne contiennent pas d'informations
    sur la visibilité des lignes, un parcours d'index normal récupère la
    ligne de la table pour chaque entrée d'index correspondante, ce qui
    permet de vérifier si la ligne correspondante est bien visible par la
    transaction en cours. Un <link
    linkend="indexes-index-only-scans">parcours d'index seuls</link> vérifie
    en premier lieu la carte de visibilité. S'il est connu que toutes les
    lignes du bloc sont visibles, la lecture de la table peut être évitée.
    Ceci est très utile sur les gros ensembles de données où la carte de
    visibilité peut éviter des accès disques. La carte de visibilité est bien
    plus petite que la table, donc elle peut facilement être mise en cache
    même quand la table est très grosse.
   </para>
  </sect2>

  <sect2 id="vacuum-for-wraparound">
   <title>Éviter les cycles des identifiants de transactions</title>

   <indexterm zone="vacuum-for-wraparound">
    <primary>identifiant de transaction</primary>
    <secondary>cycle</secondary>
   </indexterm>

   <indexterm>
    <primary>ré-utilisation</primary>
    <secondary>des identifiants de transaction</secondary>
   </indexterm>

   <para>
    Le mécanisme de contrôle de concurrence multiversion
    (<link linkend="mvcc-intro">MVCC</link>) de
    <productname>PostgreSQL</productname> s'appuie sur la possibilité de
    comparer des identifiants de transactions
    (<acronym>XID</acronym>)&nbsp;: la version d'une ligne dont le XID
    d'insertion est supérieur au XID de la transaction en cours est
    <quote>dans le futur</quote> et ne doit pas être visible de la
    transaction courante. Comme les identifiants ont une taille limitée
    (32 bits), une instance qui est en activité depuis longtemps (plus de 4
    milliards de transactions) pourrait connaître un cycle complet des
    identifiants de transaction&nbsp;: le XID reviendra à 0 et soudainement
    les transactions du passé sembleront appartenir au futur - ce qui
    signifie qu'elles deviennent invisibles. En bref, perte de données
    totale. (En réalité, les données sont toujours là mais c'est un piètre
    réconfort puisqu'elles restent inaccessibles.) Pour éviter ceci, il est
    nécessaire d'exécuter un VACUUM sur chaque table de chaque base au moins
    une fois tous les deux milliards de transactions.
   </para>

   <para>
    La raison pour laquelle un nettoyage régulier résout le problème est qu'un
    <command>VACUUM</command> marquera les lignes comme
    <emphasis>gelées</emphasis>, indiquant qu'elles ont été insérées par une
    transaction suffisamment ancienne pour que les effets de cette
    transaction soient visibles à coup sûr par toutes les transactions
    actuelles et futures. Les XID normaux sont comparés sur une base
    modulo-2<superscript>32</superscript>. Cela signifie que pour chaque XID
    normal, il y en a deux milliards qui sont plus vieux et deux milliards
    qui sont plus récents. Une autre manière de le dire est que l'ensemble de
    définition des XID est circulaire et sans limite. De ce fait, pour une
    ligne créée avec un XID normal donné, cette version de la ligne apparaît
    comme appartenant au passé pour les deux milliards de transactions qui
    suivront quelque soit le XID de ces transactions. Si cette version de
    ligne existe toujours après deux milliards de transactions, elle
    apparaîtra soudainement comme appartenant au futur. Pour empêcher cela,
    <productname>PostgreSQL</productname> réserve un XID spécial, appelé
    <literal>FrozenTransactionId</literal>, qui ne suit pas les règles
    normales de comparaison de XID et qui est toujours considéré comme plus
    ancien que chaque XID normal. Les versions de lignes gelées sont traitées
    comme si la XID d'insertion était <literal>FrozenTransactionId</literal>,
    pour qu'elles apparaissent dans le passé pour les autres transactions
    normales, quelque soit les soucis de cycle d'identifiants de
    transactions, et donc ces versions de lignes seront valides jusqu'à leur
    suppression, quelque soit la durée que cela représente.
   </para>

   <note>
    <para>
     Dans les versions de <productname>PostgreSQL</productname> antérieures à
     la 9.4, le gel était implémenté en remplaçant le XID d'insertion d'une
     ligne avec <literal>FrozenTransactionId</literal>, qui était visible
     dans la colonne système <structname>xmin</structname> de la ligne. Les
     nouvelles versions ajoutent un drapeau, préservant le
     <structname>xmin</structname> original de la ligne pour une utilisation
     ultérieure (notamment pour du débugage). Néanmoins, il est toujours
     possible d'avoir des lignes pour lesquelles
     <structname>xmin</structname> vaut
     <literal>FrozenTransactionId</literal> (2) dans les bases de données
     antérieures à la version 9.4 traitées par
     <application>pg_upgrade</application>.
    </para>

    <para>
     De plus, les catalogues systèmes pourraient contenir des lignes avec
     <structname>xmin</structname> égale à
     <literal>BootstrapTransactionId</literal> (1), indiquant qu'elles ont
     été insérées lors de la première phase
     d'<application>initdb</application>. Comme
     <literal>FrozenTransactionId</literal>, cet XID spécial est traité comme
     étant plus ancien que tout autre XID normal.
    </para>
   </note>

   <para>
    <xref linkend="guc-vacuum-freeze-min-age"/> contrôle l'âge que doit avoir
    une valeur XID avant que des lignes comportant ce XID ne soient gelées.
    Augmenter la valeur de ce paramètre peut permettre d'éviter un travail
    inutile si les lignes à geler vont bientôt être modifiées. Diminuer ce
    paramètre augmente le nombre de transactions qui peuvent survenir avant
    un nouveau nettoyage de la table.
   </para>

   <para>
    <command>VACUUM</command> utilise la <link linkend="storage-vm">carte de
    visibilité</link> pour déterminer les blocs à parcourir sur une table.
    Habituellement, il ignore les blocs qui n'ont aucune ligne morte même si
    ces blocs pourraient toujours avoir des versions de lignes avec des
    identifiants très anciens de transactions. De ce fait, les
    <command>VACUUM</command> normaux ne vont pas toujours geler chaque
    ancienne version de ligne dans la table. De temps en temps,
    <command>VACUUM</command> réalise un <firstterm>vacuum
    agressif</firstterm>, ignorant seulement les blocs contenant aucune ligne
    morte et aucune valeur XID ou MXID non gelé. <xref
    linkend="guc-vacuum-freeze-table-age"/> contrôle quand
    <command>VACUUM</command> se comporte ainsi&nbsp;: les blocs ne contenant
    que des lignes vivantes mais non gelées sont parcourus si le nombre de
    transactions exécutées depuis le dernier parcours de ce type est plus
    grand que <varname>vacuum_freeze_table_age</varname> moins
    <varname>vacuum_freeze_min_age</varname>. Configurer
    <varname>vacuum_freeze_table_age</varname> à 0 force
    <command>VACUUM</command> à utiliser cette stratégie plus agressive pour
    tous les parcours.
   </para>

   <para>
    Le délai maximum où une table peut rester sans nettoyage est de deux
    millions de transactions moins <varname>vacuum_freeze_min_age</varname>
    lors du dernier <command>VACUUM</command> agressif. Si elle devait rester
    sans nettoyage après cela, des pertes de données pourraient survenir.
    Pour s'assurer que cela n'arrive pas, autovacuum est appelé sur chaque
    table qui pourrait contenir des lignes non gelées dont les XID ont un âge
    plus avancé que le paramètre de configuration <xref
    linkend="guc-autovacuum-freeze-max-age"/>. (Ceci arrivera même si
    autovacuum est désactivé.)
   </para>

   <para>
    Ceci implique que, si aucune opération de VACUUM n'est demandée sur une
    table, l'autovacuum sera automatiquement déclenché une fois toutes les
    <varname>autovacuum_freeze_max_age</varname> moins
    <varname>vacuum_freeze_min_age</varname> transactions. Pour les tables
    qui bénéficient régulièrement de l'opération de VACUUM pour réclamer
    l'espace perdu, ceci a peu d'importance. Néanmoins, pour les tables
    statiques (en incluant les tables qui ont des insertions mais pas de
    mises à jour et de suppressions), il n'est pas nécessaire d'exécuter un
    VACUUM pour récupérer de la place et donc il peut être utile d'essayer de
    maximiser le délai entre les autovacuums forcés sur de très grosses
    tables statiques. Évidemment, vous pouvez le faire soit en augmentant
    <varname>autovacuum_freeze_max_age</varname> soit en diminuant
    <varname>vacuum_freeze_min_age</varname>.
   </para>

   <para>
    Le maximum efficace pour <varname>vacuum_freeze_table_age</varname> est
    0.95 * <varname>autovacuum_freeze_max_age</varname>&nbsp;; un paramétrage
    plus haut que ça sera limité à ce maximum. Une valeur plus importante que
    <varname>autovacuum_freeze_max_age</varname> n'aurait pas de sens car un
    autovacuum de préservation contre le cycle des identifiants de
    transactions serait déclenché, et le multiplicateur 0,95 laisse un peu de
    place pour exécuter un <command>VACUUM</command> manuel avant que cela ne
    survienne. Comme règle d'or, <command>vacuum_freeze_table_age</command>
    devrait être configuré à une valeur légèrement inférieure à
    <varname>autovacuum_freeze_max_age</varname>, laissant suffisamment
    d'espace pour qu'un <command>VACUUM</command> planifié régulièrement ou
    pour qu'un autovacuum déclenché par des activités normales de suppression
    et de mise à jour puissent être activés pendant ce laps de temps. Le
    configurer de façon trop proche pourrait déclencher des autovacuum de
    protection contre la ré-utilisation des identifiants de transactions,
    même si la table a été récemment l'objet d'un VACUUM pour récupérer
    l'espace, alors que des valeurs basses amènent à des VACUUM agressifs
    plus fréquents.
   </para>

   <para>
    Le seul inconvénient à augmenter
    <varname>autovacuum_freeze_max_age</varname>
    (et <varname>vacuum_freeze_table_age</varname> avec elle) est que les
    sous- répertoires <filename>pg_xact</filename> et
    <filename>pg_commit_ts</filename> de l'instance prendront plus de place
    car ils doivent stocker le statut et l'horodatage
    (si <varname>track_commit_timestamp</varname> est activé) du COMMIT pour
    toutes les transactions depuis
    <varname>autovacuum_freeze_max_age</varname>. L'état de COMMIT utilise
    deux bits par transaction, donc si
    <varname>autovacuum_freeze_max_age</varname> et
    <varname>vacuum_freeze_table_age</varname> ont une valeur maximale
    permise de deux milliards, <filename>pg_xact</filename> peut grossir
    jusqu'à la moitié d'un Go et <filename>pg_commit_ts</filename> jusqu'à 20
    Go. Si c'est rien comparé à votre taille de base totale, configurer
    <varname>autovacuum_freeze_max_age</varname> à son maximum permis est
    recommandé. Sinon, le configurer suivant ce que vous voulez comme
    stockage maximum dans <filename>pg_xact</filename> et dans
    <filename>pg_commit_ts</filename>. (La valeur par défaut, 200 millions de
    transactions, se traduit en à peu près 50&nbsp;Mo de stockage dans
    <filename>pg_xact</filename> et à peu près 2 Go de stockage pour
    <filename>pg_commit_ts</filename>.)
   </para>

   <para>
    Un inconvénient causé par la diminution de
    <varname>vacuum_freeze_min_age</varname> est que cela pourrait faire que
    <command>VACUUM</command> travaille sans raison&nbsp;: geler une version
    de ligne est une perte de temps si la ligne est modifiée rapidement
    après (ce qui fait qu'elle obtiendra un nouveau XID). Donc ce paramètre
    doit être suffisamment important pour que les lignes ne soient pas gelées
    jusqu'à ce qu'il soit pratiquement certain qu'elles ne seront plus
    modifiées.
   </para>

   <para>

    Pour tracer l'âge des plus anciens XID non gelés de la base,
    <command>VACUUM</command> stocke les statistiques sur XID dans les tables
    systèmes <structname>pg_class</structname> et
    <structname>pg_database</structname>. En particulier, la colonne
    <structfield>relfrozenxid</structfield> de la ligne
    <structname>pg_class</structname> d'une table contient le XID final du
    gel qui a été utilisé par le dernier <command>VACUUM</command> agressif
    pour cette table. Il est garanti que tous les XID plus anciens que ce XID
    ont été remplacés par <literal>FrozenXID</literal> pour cette table.
    Toutes les lignes insérées par des transactions dont le XID est plus
    ancien que ce XID sont garanties d'avoir été gelées. De façon similaire,
    la colonne <structfield>datfrozenxid</structfield> de la ligne
    <structname>pg_database</structname> de la base est une limite inférieure
    des XID non gelés apparaissant dans cette base &mdash; c'est tout
    simplement le minimum des valeurs <structfield>relfrozenxid</structfield>
    par table dans cette base. Pour examiner cette information, le plus
    simple est d'exécuter des requêtes comme&nbsp;:

    <programlisting>SELECT c.oid::regclass as table_name,
       greatest(age(c.relfrozenxid),age(t.relfrozenxid)) as age
FROM pg_class c
LEFT JOIN pg_class t ON c.reltoastrelid = t.oid
WHERE c.relkind IN ('r', 'm');

SELECT datname, age(datfrozenxid) FROM pg_database;</programlisting>

    La colonne <literal>age</literal> mesure le nombre de transactions à
    partir du XID final vers le XID de transaction en cours.
   </para>

   <para>
    Habituellement, <command>VACUUM</command> parcourt seulement les blocs qui
    ont été modifiés depuis le dernier nettoyage mais
    <structfield>relfrozenxid</structfield> peut seulement être avancé quand
    tous les blocs d'une table pouvant contenir des XID gelés sont parcourus.
    Ceci survient quand <structfield>relfrozenxid</structfield> a plus de
    <varname>vacuum_freeze_table_age</varname> transactions antérieures,
    quand l'option <literal>FREEZE</literal> de <command>VACUUM</command> est
    utilisée ou quand tous les blocs qui ne sont pas encore gelés nécessitent
    un nettoyage pour supprimer les versions de lignes mortes. Quand
    <command>VACUUM</command> parcourt chaque bloc d'une table qui n'est pas
    déjà entièrement gelé, il doit configurer <literal>age
    (relfrozenxid)</literal> à une valeur un peu au-dessus de la
    configuration utilisée pour <varname>vacuum_freeze_min_age</varname>
    (plus par le nombre de transactions démarrées depuis le lancement de
    <command>VACUUM</command>). Si aucun <command>VACUUM</command> avec
    avancement de <structfield>relfrozenxid</structfield> n'est lancé sur la
    table, une fois arrivé à <varname>autovacuum_freeze_max_age</varname>, un
    autovacuum est forcé sur la table.
   </para>

   <para>
    Si, pour une certaine raison, l'autovacuum échoue à effacer les anciens
    XID d'une table, le système commencera à émettre des messages
    d'avertissement comme ceci quand les plus anciens XID de la base
    atteignent les 40 millions de transactions à partir du point de
    réinitialisation&nbsp;:

<programlisting>
WARNING:  database "mydb" must be vacuumed within 39985967 transactions
HINT:  To avoid a database shutdown, execute a database-wide VACUUM in that database.
</programlisting>

    (Une commande <command>VACUUM</command> manuelle devrait résoudre le
    problème, comme suggéré par le message HINT&nbsp;; mais notez que la
    commande <command>VACUUM</command> doit être exécutée par un
    super-utilisateur, sinon elle échouera à mettre à jour les catalogues
    systèmes et ne pourra donc pas faire avancer le
    <structfield>datfrozenxid</structfield> de la base.) Si ces
    avertissements sont ignorés, le système s'arrêtera et refusera de
    commencer toute nouvelle transaction dès qu'il n'en restera que trois
    millions avant la réinitialisation&nbsp;:

    <programlisting>
ERROR:  database is not accepting commands to avoid wraparound data loss in database "mydb"
HINT:  Stop the postmaster and vacuum that database in single-user mode.
    </programlisting>

    La marge de sécurité de trois millions de transactions existe pour
    permettre à l'administrateur de récupérer ces données sans perte en
    exécutant manuellement les commandes <command>VACUUM</command> requises.
    Néanmoins, comme le système n'exécute pas de commandes tant qu'il n'est
    pas sorti du mode d'arrêt par sécurité, la seule façon de le faire est de
    stopper le serveur et de démarrer le serveur en mode simple utilisateur
    pour exécuter un <command>VACUUM</command>. Le mode d'arrêt n'est pas
    pris en compte par le moteur en mode simple utilisateur. Voir la page de
    référence de <xref linkend="app-postgres"/> pour des détails sur
    l'utilisation du moteur en mode simple utilisateur.
   </para>

   <sect3 id="vacuum-for-multixact-wraparound">
    <title>Multixacts et cycle</title>

    <indexterm>
     <primary>MultiXactId</primary>
    </indexterm>

    <indexterm>
     <primary>cycle</primary>
     <secondary>d'identifiants multixact</secondary>
    </indexterm>

    <para>
     Les <firstterm>identifiants multixact</firstterm> sont utilisés pour
     supporter le verrouillage de lignes par des transactions multiples.
     Comme l'espace est limité dans un en-tête de ligne pour y stocker des
     informations, cette information est codée sous la forme d'un
     <quote>identifiant de transaction multiple</quote>, ou ID multixact pour
     faire court, à chaque fois qu'il y a plus d'une transaction cherchant à
     verrouiller en parallèle une ligne. Les informations sur les
     identifiants de transactions inclus dans tout identifiant multixact sont
     enregistrées séparément dans le sous-répertoire
     <filename>pg_multixact</filename> et seul l'identifiant multixact
     apparaît dans le champ <structfield>xmax</structfield> de l'en-tête de
     ligne. Comme les identifiants de transactions, les identifiants
     multi-transactions sont implémentés avec un compteur 32 bits et le
     stockage correspondant, ce qui nécessite une gestion attentive, un
     nettoyage du stockage et la gestion du cycle (plus exactement de la
     ré-utilisation des identifiants). Il existe un espace de stockage séparé
     qui détient la liste des membres dans chaque multixact, qui utilise
     aussi un compteur sur 32 bits et qui doit aussi être géré.
    </para>

    <para>
     Quand <command>VACUUM</command> parcourt une partie d'une table, il
     remplacera tout ID multixact qu'il rencontre, plus âgé que <xref
     linkend="guc-vacuum-multixact-freeze-min-age"/>, par une valeur
     différente, qui peut être la valeur zéro, un identifiant de transaction
     ou un nouvel identifiant multixact. Pour chaque table,
     <structname>pg_class</structname>.<structfield>relminmxid</structfield>
     enregistre le plus ancien identifiant multixact possible apparaissant
     déjà dans un enregistrement de cette table. Si cette valeur est plus
     ancienne que <xref linkend="guc-vacuum-multixact-freeze-table-age"/>, un
     vacuum agressif est forcé. Comme indiqué dans la section précédente, un
     vacuum agressif signifie que seuls les blocs connus pour être
     entièrement gelés sont ignorés. <function>mxid_age()</function> peut
     être utilisé sur
     <structname>pg_class</structname>.<structfield>relminmxid</structfield>
     pour trouver son âge.
    </para>

    <para>
     Les <command>VACUUM</command> agressifs, quelqu'en soit la cause,
     permettent d'avancer la valeur pour cette table. Comme toutes les tables
     de toutes les bases sont parcourues et que leurs plus anciennes valeurs
     multixact sont avancées, le stockage sur disque pour les anciens
     multixacts peut être supprimé.
    </para>

    <para>
     Comme moyen de sécurité supplémentaire, un VACUUM agressif surviendra
     pour toute table dont l'âge en identifiant multixact (voir <xref
     linkend="vacuum-for-multixact-wraparound"/>) est supérieur à <xref
     linkend="guc-autovacuum-multixact-freeze-max-age"/>. De plus, si le
     stockage occupé par les membres multixacts dépasse 2 Go, des parcours de
     vacuum agressif surviendront plus fréquemment pour toutes les tables, en
     commençant par celles qui ont le plus ancien multixact-age. Ces deux
     types de parcours agressifs de tables surviendront seulement si
     l'autovacuum est désactivé spécifiquement.
    </para>
   </sect3>
  </sect2>

  <sect2 id="autovacuum">
   <title>Le démon auto-vacuum</title>

   <indexterm>
    <primary>autovacuum</primary>
    <secondary>information générale</secondary>
   </indexterm>

   <para>
    <productname>PostgreSQL </productname> dispose d'une fonctionnalité
    optionnelle mais hautement recommandée appelée
    <firstterm>autovacuum</firstterm>, dont le but est d'automatiser
    l'exécution des commandes <command>VACUUM</command> et
    <command>ANALYZE</command>. Quand il est activé, autovacuum vérifie les
    tables ayant un grand nombre de lignes insérées, mises à jour ou
    supprimées. Ces vérifications utilisent la fonctionnalité de récupération
    de statistiques&nbsp;; du coup, autovacuum ne peut être utilisé que si
    <xref linkend="guc-track-counts"/> est configuré à
    <literal>true</literal>. Dans la configuration par défaut, l'autovacuum
    est activé et les paramètres liés sont correctement configurés.
   </para>

   <para>
    Le <quote>démon autovacuum</quote> est constitué de plusieurs processus.
    Un processus démon permanent appelé <firstterm>autovacuum
    launcher</firstterm>(autrement dit le lanceur d'autovacuum) est en charge
    de lancer des processus de traitement
    (<firstterm>autovacuum worker</firstterm>) pour toutes les bases de
    données. Le lanceur distribue le travail dans le temps en lançant un
    nouveau processus de traitement sur chaque base de données chaque <xref
    linkend="guc-autovacuum-naptime"/> secondes. (Du coup, si l'installation
    a <replaceable>N</replaceable> bases de données, un nouveau
    <firstterm>autovacuum worker</firstterm> sera lancé tous les
    <varname>autovacuum_naptime</varname>/<replaceable>N</replaceable>
    secondes.) Un maximum de <xref linkend="guc-autovacuum-max-workers"/>
    processus <firstterm>autovacuum worker</firstterm> est autorisé à
    s'exécuter en même temps. S'il y a plus de
    <varname>autovacuum_max_workers</varname> bases à traiter, la prochaine
    base de données sera traitée dès qu'un autre processus de traitement a
    terminé. Chaque processus de traitement vérifie chaque table de la base
    de données de connexion et exécute un <command>VACUUM</command> et/ou un
    <command>ANALYZE</command> suivant les besoins. <xref
    linkend="guc-log-autovacuum-min-duration"/> peut être utilisé pour
    superviser l'activité des processus autovacuum worker.
   </para>

   <para>
    Si plusieurs grosses tables deviennent toutes éligibles à un VACUUM dans
    un court espace de temps, tous les processus de traitement pourraient
    avoir à exécuter des VACUUM sur ces tables pendant un long moment. Ceci
    pourraient avoir pour résultat que d'autres tables et d'autres bases de
    données ne puissent pas être traitées tant qu'un processus de traitement
    ne sera pas disponible. Il n'y a pas de limite sur le nombre de processus
    de traitement sur une seule base, mais ils essaient d'éviter de répéter
    le travail qui a déjà été fait par d'autres. Notez que le nombre de
    processus de traitement en cours d'exécution n'est pas décompté des
    limites <xref linkend="guc-max-connections"/> et <xref
    linkend="guc-superuser-reserved-connections"/>.
   </para>

   <para>

    Les tables dont la valeur de <structfield>relfrozenxid</structfield> est
    supérieure à <xref linkend="guc-autovacuum-freeze-max-age"/> font
    toujours l'objet d'un VACUUM (cela s'applique aussi aux tables dont le <foreignphrase>freeze max age</foreignphrase>
    a été modifié avec les paramètres de stockage&nbsp;; voir plus bas).
    Sinon, si le nombre de lignes obsolètes
    depuis le dernier <command>VACUUM</command> dépasse une <quote>limite de
    vacuum</quote>, la table bénéficie d'un VACUUM. La limite est définie
    ainsi&nbsp;:
    <programlisting>limite du vacuum = limite de base du vacuum + facteur d'échelle du vacuum * nombre de lignes</programlisting>
    où la limite de base du vacuum est
    <xref linkend="guc-autovacuum-vacuum-threshold"/>,
    le facteur d'échelle du vacuum est
    <xref linkend="guc-autovacuum-vacuum-scale-factor"/>
    et le nombre de lignes est
    <structname>pg_class</structname>.<structfield>reltuples</structfield>.
   </para>

   <para>
    La table est aussi traitée si le nombre de lignes insérées depuis le
    dernier VACUUM a dépassé la limite d'insertion définie d'après cette
    formule&nbsp;:
<programlisting>
limite insertion vacuum = limite insertion base vacuum + facteur échelle insertion vacuum * nombre de lignes
    </programlisting>
    où la limite d'insertion de base du VACUUM correspond au paramètre <xref
    linkend="guc-autovacuum-vacuum-insert-threshold"/>, et le facteur
    d'échelle d'insertion du VACUUM correspond au paramètre <xref
    linkend="guc-autovacuum-vacuum-insert-scale-factor"/>. De tels VACUUM
    permettent de marquer des portions de la table comme <firstterm>tout
    visible</firstterm> et permettent aussi de geler les lignes, ce qui peut
    réduire le travail requis par les VACUUM suivant. Pour les tables
    recevant des opérations <command>INSERT</command> mais aucune ou très peu
    d'opérations <command>UPDATE</command>/<command>DELETE</command>, il peut
    être bénéfique de diminuer la valeur du paramètre <xref
    linkend="reloption-autovacuum-freeze-min-age"/> pour la table car cela
    permet le gel des lignes par des VACUUM rapides. Le nombre de lignes
    obsolètes et le nombre de lignes insérées sont obtenus via le collecteur
    de statistiques&nbsp;; ce décompte moyennement précis est mis à jour par
    chaque opération <command>UPDATE</command>, <command>DELETE</command> et
    <command>INSERT</command>. (C'est seulement moyennement précis car
    certaines informations pourraient être perdues en cas de fortes charges.)
    Si la valeur du champ <structfield>relfrozenxid</structfield> pour la
    table est supérieure à <varname>vacuum_freeze_table_age</varname>, un
    VACUUM agressif est réalisé pour geler les anciennes lignes et avancer la
    valeur de <structfield>relfrozenxid</structfield>, sinon seules les blocs
    qui ont été modifiés depuis le dernier VACUUM sont parcourues par
    l'opération de VACUUM.
   </para>

   <para>
    Pour ANALYZE, une condition similaire est utilisée&nbsp;: la limite,
    définie comme <programlisting>limite du analyze = limite de base du
    analyze + facteur d'échelle du analyze * nombre de
    lignes</programlisting> est comparée au nombre de lignes insérées, mises
    à jour et supprimées depuis le dernier <command>ANALYZE</command>.
   </para>

   <para>
    Les tables temporaires ne peuvent pas être accédées par l'autovacuum. De
    ce fait, les opérations appropriées de VACUUM et d'ANALYZE devraient être
    traitées par des commandes SQL de session.
   </para>

   <para>
    Les limites et facteurs d'échelle par défaut sont pris dans
    <filename>postgresql.conf</filename>, mais il est possible de les
    surcharger table par table (ainsi que beaucoup d'autres paramètres de
    contrôle de l'autovacuum)&nbsp;; voir <xref
    linkend="sql-createtable-storage-parameters"/> pour plus d'informations.
    Si une configuration a été modifiée via les paramètres de stockage d'une
    table, cette valeur est utilisée lors du traitement de cette table. Dans
    le cas contraire, les paramètres globaux sont utilisés. Voir <xref
    linkend="runtime-config-autovacuum"/> pour plus de détails sur les
    paramètres globaux.
   </para>

   <para>
    Quand plusieurs autovacuum workers travaillent, les paramètres de délai de
    coût de l'autovacuum (voir <xref
    linkend="runtime-config-resource-vacuum-cost"/>) sont
    <quote>réparties</quote> parmi tous les processus pour que l'impact total
    en entrée/sortie sur le système soit identique quelque soit le nombre de
    processus en cours d'exécution. Néanmoins, tout autovacuum worker
    traitant des tables et dont les paramètres de stockage
    <literal>autovacuum_vacuum_cost_delay</literal> ou
    <literal>autovacuum_vacuum_cost_limit</literal> ont été configurés
    spécifiquement ne sont pas considérés dans l'algorithme de répartition.
   </para>

   <para>
    Les processus de traitement de l'autovacuum ne bloquent généralement pas
    les autres commandes. Si un processus tente d'acquérir un verrou qui
    entre en conflit avec le verrou <literal>SHARE UPDATE EXCLUSIVE</literal>
    détenu par autovacuum, la demande de verrou interrompra l'autovacuum.
    Pour les modes de verrou entrant en conflit, voir <xref
    linkend="table-lock-compatibility"/>. Néanmoins, si l'autovacuum
    s'exécute pour empêcher une réutilisation des identifiants de transaction
    (c'est-à-dire si le texte de la requête de l'autovacuum dans la vue
    <structname>pg_stat_activity</structname> se termine avec le texte
    <literal>(to prevent wraparound)</literal>), l'autovacuum n'est pas
    automatiquement interrompu.
   </para>

   <warning>
    <para>
     Exécuter régulièrement des commandes qui acquièrent des verrous en
     conflit avec un verrou <literal>SHARE UPDATE EXCLUSIVE</literal>
     (par exemple ANALYZE) peut gêner fortement le traitement réalisé par
     l'autovacuum.
    </para>
   </warning>
  </sect2>
 </sect1>


 <sect1 id="routine-reindex">
  <title>Ré-indexation régulière</title>

  <indexterm zone="routine-reindex">
   <primary>ré-indexation</primary>
  </indexterm>

  <para>
   Dans certains cas, il est intéressant de reconstruire périodiquement les
   index par la commande <xref linkend="sql-reindex"/> ou par une série
   d'étapes individuelles de reconstruction.
  </para>

  <para>
   Les blocs devenues complètement vides d'un index B-tree sont réclamées pour
   leur ré-utilisation. Mais, il existe toujours une possibilité
   d'utilisation peu efficace de l'espace&nbsp;: si, sur un bloc, seulement
   quelques clés d'index ont été supprimés, le bloc reste alloué. En
   conséquence, si seulement quelques clés sont supprimées, vous devrez vous
   attendre à ce que l'espace disque soit très mal utilisé. Dans de tels cas,
   la réindexation périodique est recommandée.
  </para>

  <para>
   Le potentiel d'inflation des index qui ne sont pas des index B-tree n'a pas
   été particulièrement analysé. Surveiller périodiquement la taille physique
   de ces index est une bonne idée.
  </para>

  <para>
   De plus, pour les index B-tree, un index tout juste construit est
   légèrement plus rapide qu'un index qui a été mis à jour plusieurs fois
   parce que les blocs adjacents logiquement sont habituellement aussi
   physiquement adjacents dans un index nouvellement créé(cette considération
   ne s'applique pas aux index non B-tree). Il pourrait être intéressant de
   ré-indexer périodiquement simplement pour améliorer la vitesse d'accès.
  </para>

  <para>
   <xref linkend="sql-reindex"/> peut être utilisé en toute sécurité et très
   facilement dans tous les cas. Cette commande nécessite un verrou
   <literal>ACCESS EXCLUSIVE</literal> par défaut. De ce fait, il est souvent
   préférable de l'exécuter avec l'option <literal>CONCURRENTLY</literal> qui
   requiert seulement un verrou <literal>SHARE UPDATE EXCLUSIVE</literal>.
  </para>
 </sect1>

 <sect1 id="logfile-maintenance">
  <title>Maintenance du fichier de traces</title>

  <indexterm zone="logfile-maintenance">
   <primary>traces serveur</primary>
   <secondary>maintenance du fichier de traces</secondary>
  </indexterm>

  <para>
   Sauvegarder les journaux de trace du serveur de bases de données dans un
   fichier plutôt que dans <filename>/dev/null</filename> est une bonne idée.
   Les journaux sont d'une utilité incomparable lorsqu'arrive le moment où
   des problèmes surviennent. Néanmoins, les journaux ont tendance à être
   volumineux (tout spécialement à des niveaux de débogage importants) et
   vous ne voulez pas les sauvegarder indéfiniment. Vous avez besoin de faire
   une <quote>rotation</quote> des journaux pour que les nouveaux journaux
   sont commencés et que les anciens soient supprimés après une période de
   temps raisonnable.
  </para>

  <para>
   Si vous redirigez simplement la sortie <systemitem>stderr</systemitem> du
   processus <command>postgres</command> dans un fichier, vous aurez un
   journal des traces mais la seule façon de le tronquer sera d'arrêter et de
   relancer le serveur. Ceci peut convenir si vous utilisez
   <productname>PostgreSQL</productname> dans un environnement de
   développement mais peu de serveurs de production trouveraient ce
   comportement acceptable.
  </para>

  <para>
   Une meilleure approche est d'envoyer la sortie
   <systemitem>stderr</systemitem> du serveur dans un programme de rotation
   de journaux. Il existe un programme interne de rotation que vous pouvez
   utiliser en configurant le paramètre <varname>logging_collector</varname>
   à <literal>true</literal> dans <filename>postgresql.conf</filename>. Les
   paramètres de contrôle pour ce programme sont décrits dans <xref
   linkend="runtime-config-logging-where"/>. Vous pouvez aussi utiliser cette
   approche pour capturer les données des journaux applicatifs dans un format
   <acronym>CSV</acronym> (valeurs séparées par des virgules) lisible par une
   machine
  </para>

  <para>
   Sinon, vous pourriez préférer utiliser un programme externe de rotation de
   journaux si vous en utilisez déjà un avec d'autres serveurs. Par exemple,
   l'outil <application>rotatelogs</application> inclus dans la distribution
   <productname>Apache</productname> peut être utilisé avec
   <productname>PostgreSQL</productname>. Pour cela, envoyez via un tube la
   sortie <systemitem>stderr</systemitem> du serveur dans le programme
   désiré. Si vous lancez le serveur avec <command>pg_ctl</command>, alors
   <systemitem>stderr</systemitem> est déjà directement renvoyé dans
   <systemitem>stdout</systemitem>, donc vous avez juste besoin d'ajouter la
   commande via un tube, par exemple&nbsp;:
  </para>

<programlisting>pg_ctl start | rotatelogs /var/log/pgsql_log 86400</programlisting>

  <para>
   Vous pouvez combiner ces approches en configurant
   <application>logrotate</application> pour qu'il récupère les fichiers de
   trace produits par le collecteur de trace de
   <productname>PostgreSQL</productname>. Dans ce cas, le collecteur définit
   les noms et emplacement des fichiers de trace, alors que
   <application>logrotate</application> les archive périodiquement. Lors
   d'une rotation de fichier de traces, <application>logrotate</application>
   doit s'assurer que l'application envoie les nouvelles traces dans le
   nouveau fichier. Ceci se fait habituellement avec un script
   <literal>postrotate</literal> qui envoie un signal
   <literal>SIGHUP</literal> à l'application, qui ouvre ensuite de nouveau le
   fichier de traces. Dans <productname>PostgreSQL</productname>, vous pouvez
   exécuter <command>pg_ctl</command> avec l'option
   <literal>logrotate</literal>. Quand le serveur reçoit cette commande, soit
   le serveur bascule vers un nouveau fichier de trace soit il ré-ouvre le
   fichier existant, suivant la configuration des traces (voir <xref
   linkend="runtime-config-logging-where"/>).
  </para>

  <note>
   <para>
    Lors de l'utilisation de noms de fichier statique, le serveur pourrait
    échouer lors de la réouverture du fichier de trace si la limite du nombre
    maximum de fichiers ouvert est atteint ou qu'un dépassement de la table
    de fichiers survient. Dans ce cas, les traces sont envoyées à l'ancien
    fichier de traces jusqu'à la réussite de la rotation du fichier de trace.
    Si <application>logrotate</application> est configuré pour compresser le
    fichier de trace et le supprimer, le serveur pourrait perdre les messages
    tracées pendant cette fenêtre de temps. Pour éviter ce problème, vous
    pouvez configurer le collecteur de traces pour qu'il affecte
    dynamiquement les noms des fichiers de trace et utilise un script
    <literal>prerotate</literal> pour ignorer les fichiers de trace ouverts.
   </para>
  </note>

  <para>
   Une autre approche de production pour la gestion des journaux de trace est
   de les envoyer à <application>syslog</application> et de laisser
   <application>syslog</application> gérer la rotation des fichiers. Pour
   cela, initialisez le paramètre de configuration
   <varname>log_destination</varname> à <literal>syslog</literal>(pour tracer
   uniquement via <application>syslog</application>) dans
   <filename>postgresql.conf</filename>. Ensuite, vous pouvez envoyer un
   signal <literal>SIGHUP</literal> au démon
   <application>syslog</application> quand vous voulez le forcer à écrire
   dans un nouveau fichier. Si vous voulez automatiser la rotation des
   journaux, le programme <application>logrotate</application> peut être
   configuré pour fonctionner avec les journaux de traces provenant de
   <application>syslog</application>.
  </para>

  <para>
   Néanmoins, sur beaucoup de systèmes, <application>syslog</application>
   n'est pas très fiable, particulièrement avec les messages très gros&nbsp;;
   il pourrait tronquer ou supprimer des messages au moment où vous en aurez
   le plus besoin. De plus, sur <productname>Linux</productname>,
   <application>syslog</application> synchronisera tout message sur disque,
   amenant à des performances assez pauvres. (Vous pouvez utiliser un
   <quote><literal>-</literal></quote> au début du nom de fichier dans le
   fichier de configuration <application>syslog</application> pour désactiver
   la synchronisation.)
  </para>

  <para>
   Notez que toutes les solutions décrites ci-dessus font attention à lancer
   de nouveaux journaux de traces à des intervalles configurables mais ils ne
   gèrent pas la suppression des vieux fichiers de traces, qui ne sont
   probablement plus très utiles. Vous voudrez probablement configurer un
   script pour supprimer périodiquement les anciens journaux. Une autre
   possibilité est de configurer le programme de rotation pour que les
   anciens journaux de traces soient écrasés de façon cyclique.
  </para>

  <para>
   <ulink
   url="https://pgbadger.darold.net/"><productname>pgBadger</productname></ulink>
   est un projet externe qui analyse les journaux applicatifs d'une façon
   très poussée. <ulink
   url="https://bucardo.org/check_postgres/"><productname>check_postgres</productname></ulink>
   fournit des alertes Nagios quand des messages importants apparaissent dans
   les journaux applicatifs, mais détecte aussi de nombreux autres cas.
  </para>
 </sect1>
</chapter>
