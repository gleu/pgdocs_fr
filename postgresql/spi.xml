<?xml version="1.0" encoding="UTF-8"?>
<chapter id="spi">
 <title>Interface de programmation serveur</title>

 <indexterm zone="spi">
  <primary>SPI</primary>
 </indexterm>

 <para>
  L'<firstterm>interface de programmation serveur</firstterm>
  (<acronym>SPI</acronym>) donne aux auteurs de fonctions
  <acronym>C</acronym> la capacité de lancer des commandes
  <acronym>SQL</acronym> au sein de leurs fonctions ou procédures.
  <acronym>SPI</acronym> est une série de
  fonctions d'interface simplifiant l'accès à l'analyseur, au planificateur
  et au lanceur. <acronym>SPI</acronym> fait aussi de la
  gestion de mémoire.
 </para>

 <note>
  <para>
   Les langages procéduraux disponibles donnent plusieurs moyens
   de lancer des commandes SQL à partir de fonctions. La plupart est basée
   à partir de SPI. Cette documentation présente donc également un intérêt pour
   les utilisateurs de ces langages.
  </para>
 </note>

 <para>
  Notez que si une commande appelée via SPI échoue, alors le contrôle ne sera
  pas redonné à votre fonction C. Au contraire, la transaction ou
  sous-transaction dans laquelle est exécutée votre fonction C sera annulée.
  (Ceci pourrait être surprenant étant donné que les fonctions SPI ont pour
  la plupart des conventions documentées de renvoi d'erreur. Ces conventions
  s'appliquent seulement pour les erreurs détectées à l'intérieur des
  fonctions SPI.) Il est possible de récupérer le contrôle après une erreur
  en établissant votre propre sous-transaction englobant les appels SPI qui
  pourraient échouer.
 </para>

 <para>
  Les fonctions <acronym>SPI</acronym> renvoient un résultat positif en cas de
  succès (soit par une valeur de retour entière, soit dans la variable
  globale <varname>SPI_result</varname> comme décrit ci-dessous). En cas
  d'erreur, un résultat négatif ou <symbol>NULL</symbol> sera retourné.
 </para>

 <para>
  Les fichiers de code source qui utilisent SPI doivent inclure le fichier
  d'en-tête <filename>executor/spi.h</filename>.
 </para>


 <sect1 id="spi-interface">
  <title>Fonctions d'interface</title>

  <refentry id="spi-spi-connect">
   <indexterm><primary>SPI_connect_ext</primary></indexterm>

   <refmeta>
    <refentrytitle>SPI_connect_ext</refentrytitle>
    <manvolnum>3</manvolnum>
   </refmeta>

   <refnamediv>
    <refname>SPI_connect_ext</refname>
    <refpurpose>connecter une fonction C au gestionnaire SPI</refpurpose>
   </refnamediv>


   <refsynopsisdiv>
    <synopsis>int SPI_connect(void)</synopsis>
    <synopsis>int SPI_connect_ext(int <parameter>options</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_connect</function> ouvre une connexion au gestionnaire SPI
   lors de l'appel d'une fonction C. Vous devez appeler cette fonction si vous
   voulez lancer des commandes au travers du SPI. Certaines fonctions SPI
   utilitaires peuvent être appelées à partir de fonctions C non connectées.
  </para>

  <para>
   <function>SPI_connect_ext</function> fait la même chose mais dispose d'un argument
   permettant de passer les options. Actuellement, les valeurs possibles des options
   sont&nbsp;:
   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OPT_NONATOMIC</symbol></term>
     <listitem>
      <para>
       Configure la connexion SPI comme <firstterm>non atomique</firstterm>,
       ce qui signifie que les appels de contrôle de transaction,
       <function>SPI_commit</function>, <function>SPI_rollback</function> et
       <function>SPI_start_transaction</function>, sont autorisés. Dans le cas
       contraire, un appel à ces fonctions renverra immédiatement une erreur.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   <literal>SPI_connect()</literal> est équivalent à
   <literal>SPI_connect_ext(0)</literal>.
  </para>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <variablelist>
   <varlistentry>
    <term><symbol>SPI_OK_CONNECT</symbol></term>
    <listitem>
     <para>
      en cas de succès
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><symbol>SPI_ERROR_CONNECT</symbol></term>
    <listitem>
     <para>
      en cas d'échec
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

    <refentry id="spi-spi-finish">
     <indexterm><primary>SPI_finish</primary></indexterm>

     <refmeta>
      <refentrytitle>SPI_finish</refentrytitle>
      <manvolnum>3</manvolnum>
     </refmeta>

     <refnamediv>
      <refname>SPI_finish</refname>
      <refpurpose>déconnecter une fonction C du gestionnaire SPI</refpurpose>
     </refnamediv>


     <refsynopsisdiv>
      <synopsis>int SPI_finish(void)
      </synopsis>
     </refsynopsisdiv>

     <refsect1>
      <title>Description</title>

      <para>
       <function>SPI_finish</function> ferme une connexion existante au
       gestionnaire SPI. Vous devez appeler cette fonction après avoir terminé les
       opérations SPI souhaitées pendant l'invocation courante de votre fonction C.
       Vous n'avez pas à vous préoccuper de ceci, sauf si vous
       terminez la transaction via <literal>elog(ERROR)</literal>. Dans ce
       cas, SPI terminera automatiquement.
      </para>
     </refsect1>

     <refsect1>
      <title>Valeur de retour</title>

      <variablelist>
       <varlistentry>
        <term><symbol>SPI_OK_FINISH</symbol></term>
        <listitem>
         <para>
          si déconnectée correctement
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
        <listitem>
         <para>
          si appel à partir d'une fonction C non connectée
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </refsect1>
    </refentry>

    <!-- *********************************************** -->

    <refentry id="spi-spi-execute">
     <indexterm><primary>SPI_execute</primary></indexterm>

     <refmeta>
      <refentrytitle>SPI_execute</refentrytitle>
      <manvolnum>3</manvolnum>
     </refmeta>

     <refnamediv>
      <refname>SPI_execute</refname>
      <refpurpose>exécute une commande</refpurpose>
     </refnamediv>

     <refsynopsisdiv>
      <synopsis>int SPI_execute(const char * <parameter>command</parameter>, bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
      </synopsis>
     </refsynopsisdiv>

     <refsect1>
      <title>Description</title>

      <para>
       <function>SPI_exec</function> lance la commande SQL spécifiée
       pour <parameter>count</parameter> lignes. Si <parameter>read_only</parameter>
       est <literal>true</literal>, la commande doit être en lecture seule et la surcharge
       de l'exécution est quelque peu réduite.
      </para>

      <para>
       Cette fonction ne devrait être appelée qu'à partir d'une fonction C connectée.
      </para>

      <para>
       Si <parameter>count</parameter> vaut zéro, alors la commande est exécutée
       pour toutes les lignes auxquelles elle s'applique. Si
       <parameter>count</parameter> est supérieur à 0, alors pas plus de
       <parameter>count</parameter> lignes seront récupérées. L'exécution s'arrêtera
       quand le compte est atteint, un peu comme l'ajout d'une clause
       <literal>LIMIT</literal> à une requête. Par exemple&nbsp;:
       <programlisting>SPI_execute("SELECT * FROM foo", true, 5);
       </programlisting>
       récupérera 5 lignes tout au plus à partir de la table. Notez qu'une telle
       limite n'est efficace qu'à partir du moment où la requête renvoie des lignes.
       Par exemple :
       <programlisting> SPI_execute("INSERT INTO foo SELECT * FROM bar", false, 5);
       </programlisting>
       insérera toutes les lignes de <structname>bar</structname>, en ignorant le
       paramètre <parameter>count</parameter>. Cependant, avec
       <programlisting>SPI_execute("INSERT INTO foo SELECT * FROM bar RETURNING *", false, 5);
       </programlisting>
       au plus cinq lignes seront insérées car l'exécution s'arrêtera après la
       cinquième ligne renvoyée par <literal>RETURNING</literal>.
      </para>

      <para>
       Vous pourriez passer plusieurs commandes dans une chaîne.
       <function>SPI_execute</function> renvoie le résultat pour la dernière
       commande exécutée. La limite <parameter>count</parameter> s'applique à
       chaque commande séparément (même si seul le dernier résultat sera renvoyé).
       La limite n'est pas appliquée à toute commande cachée générée par les règles.
      </para>

      <para>
       Quand <parameter>read_only</parameter> vaut <literal>false</literal>,
       <function>SPI_execute</function> incrémente le compteur de la commande
       et calcule une nouvelle <firstterm>image</firstterm> avant d'exécuter chaque
       commande dans la chaîne. L'image n'est pas réellement modifiée si le
       niveau d'isolation de la transaction en cours est
       <literal>SERIALIZABLE</literal> ou <literal>REPEATABLE READ</literal> mais, en mode
       <literal>READ COMMITTED</literal>, la mise
       à jour de l'image permet à chaque commande de voir les résultats des
       transactions nouvellement validées à partir des autres sessions. Ceci est
       essentiel pour un comportement cohérent quand les commandes modifient la
       base de données.
      </para>

      <para>
       Quand <parameter>read_only</parameter> vaut <literal>true</literal>,
       <function>SPI_execute</function> ne met à jour ni l'image ni le compteur de
       commandes, et il autorise seulement les commandes <command>SELECT</command> dans
       la chaîne des commandes. Elles sont exécutées en utilisant l'image
       précédemment établie par la requête englobante. Ce mode d'exécution est
       un peu plus rapide que le mode lecture/écriture à cause de l'élimination
       de la surcharge par commande. Il autorise aussi directement la construction
       des fonctions <firstterm>stable</firstterm>&nbsp; comme les exécutions successives
       utiliseront toutes la même image, il n'y aura aucune modification dans les
       résultats.
      </para>

      <para>
       Il n'est généralement pas conseillé de mixer les commandes en lecture
       seule et les commandes en lecture/écriture à l'intérieur d'une seule
       fonction utilisant SPI&nbsp;; ceci pourrait causer un comportement portant
       confusion car les requêtes en mode lecture seule devraient ne pas voir les
       résultats de toute mise à jour de la base de données effectuées par les
       requêtes en lecture/écriture.
      </para>

      <para>
       Le nombre réel de lignes pour lesquelles la (dernière) commande a été
       lancée
       est retourné dans la variable globale <varname>SPI_processed</varname>.
       Si la valeur de retour de la fonction est <symbol>SPI_OK_SELECT</symbol>,
       <symbol>SPI_OK_INSERT_RETURNING</symbol>, <symbol>SPI_OK_DELETE_RETURNING</symbol>
       ou <symbol>SPI_OK_UPDATE_RETURNING</symbol>, alors vous pouvez utiliser le
       pointeur global <literal>SPITupleTable *SPI_tuptable</literal> pour
       accéder aux lignes de résultat. Quelques commandes (comme
       <command>EXPLAIN</command>) renvoient aussi des ensembles de lignes et
       <literal>SPI_tuptable</literal> contiendra aussi le résultat dans ces cas.
       Certaines commandes utilitaires (<command>COPY</command>, <command>CREATE
        TABLE AS</command>) ne renvoient pas un ensemble de lignes, donc
       <literal>SPI_tuptable</literal> est NULL, mais elles renvoient malgré tout
       le nombre de lignes traitées dans <varname>SPI_processed</varname>.
      </para>

      <para>
       La structure <structname>SPITupleTable</structname> est définie
       comme suit&nbsp;:
       <programlisting>+typedef struct SPITupleTable
 {
    /* Membres publics */
    TupleDesc   tupdesc;        /* descripteur de ligne */
    HeapTuple  *vals;           /* tableau de lignes */
    uint64      numvals;        /* nombre de lignes valides */

    /* Membres privés, non destinés aux appelants externes */
    uint64      alloced;        /* longueur alloué au tableau de valeurs */
    MemoryContext tuptabcxt;    /* contexte mémoire de la table résultante */
    slist_node  next;           /* lien pour la mécanique interne */
    SubTransactionId subid;     /* sous-transaction dans laquelle le tuptable a été créé */
 } SPITupleTable;
       </programlisting>
       Les champs <structfield>tupdesc</structfield>,
       <structfield>vals</structfield>, et <structfield>numvals</structfield>
       peuvent être utilisés par les appelants SPI&nbsp;; les champs restants
       sont internes. <structfield>vals</structfield> est un tableau de
       pointeurs vers des lignes. Le nombre de lignes est donné par
       <structfield>numvals</structfield> (pour des raisons un peu
       historiques, ce nombre est aussi renvoyé dans
       <varname>SPI_processed</varname>). <structfield>tupdesc</structfield>
       est un descripteur de ligne que vous pouvez passer aux fonctions SPI
       qui traitent des lignes.
      </para>

      <para>
       <function>SPI_finish</function> libère tous les
       <structname>SPITupleTable</structname>s allouées pendant la fonction C
       courante. Vous pouvez libérer une table de résultats donnée plus tôt, si vous
       en avez terminé avec elle, en appelant <function>SPI_freetuptable</function>.
      </para>
     </refsect1>

     <refsect1>
      <title>Arguments</title>

      <variablelist>
       <varlistentry>
        <term><literal>const char * <parameter>command</parameter></literal></term>
        <listitem>
         <para>
          chaîne contenant la commande à exécuter
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>bool <parameter>read_only</parameter></literal></term>
        <listitem>
         <para>
          <literal>true</literal> en cas d'exécution en lecture seule
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>long <parameter>count</parameter></literal></term>
        <listitem>
         <para>
          nombre maximum de lignes à traiter ou <literal>0</literal> pour aucune
          limite
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </refsect1>

     <refsect1>
      <title>Valeur de retour</title>

      <para>
       Si l'exécution de la commande a réussi, alors l'une des
       valeurs (positives) suivantes sera renvoyée&nbsp;:

       <variablelist>
        <varlistentry>
         <term><symbol>SPI_OK_SELECT</symbol></term>
         <listitem>
          <para>
           si un <command>SELECT</command> (mais pas <command>SELECT
            INTO</command>) a été lancé
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><symbol>SPI_OK_SELINTO</symbol></term>
         <listitem>
          <para>
           si un <command>SELECT INTO</command> a été lancé
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><symbol>SPI_OK_INSERT</symbol></term>
         <listitem>
          <para>
           si un <command>INSERT</command> a été lancé
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><symbol>SPI_OK_DELETE</symbol></term>
         <listitem>
          <para>
           si un <command>DELETE</command> a été lancé
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><symbol>SPI_OK_UPDATE</symbol></term>
         <listitem>
          <para>
           si un <command>UPDATE</command> a été lancé
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><symbol>SPI_OK_INSERT_RETURNING</symbol></term>
         <listitem>
          <para>
           si un <command>INSERT RETURNING</command> a été lancé
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><symbol>SPI_OK_DELETE_RETURNING</symbol></term>
         <listitem>
          <para>
           si un <command>DELETE RETURNING</command> a été lancé
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><symbol>SPI_OK_UPDATE_RETURNING</symbol></term>
         <listitem>
          <para>
           si un <command>UPDATE RETURNING</command> a été lancé
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><symbol>SPI_OK_UTILITY</symbol></term>
         <listitem>
          <para>
           si une commande utilitaire (c'est-à-dire <command>CREATE TABLE</command>)
           a été lancée
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><symbol>SPI_OK_REWRITTEN</symbol></term>
         <listitem>
          <para>
           si la commande a été réécrite dans un autre style de commande
           (c'est-à-dire que <command>UPDATE</command> devient un
           <command>INSERT</command>) par une <link linkend="rules">règle</link>.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>

      <para>
       Sur une erreur, l'une des valeurs négatives suivante est renvoyée&nbsp;:

       <variablelist>
        <varlistentry>
         <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
         <listitem>
          <para>
           si <parameter>command</parameter> est <symbol>NULL</symbol> ou
           <parameter>count</parameter> est inférieur à 0
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><symbol>SPI_ERROR_COPY</symbol></term>
         <listitem>
          <para>
           si <command>COPY TO stdout</command> ou <command>COPY FROM stdin</command>
           ont été tentés
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><symbol>SPI_ERROR_TRANSACTION</symbol></term>
         <listitem>
          <para>
           Si une commande de manipulation de transaction a été
           tentée
           (<command>BEGIN</command>,
           <command>COMMIT</command>,
           <command>ROLLBACK</command>,
           <command>SAVEPOINT</command>,
           <command>PREPARE TRANSACTION</command>,
           <command>COMMIT PREPARED</command>,
           <command>ROLLBACK PREPARED</command>
           ou toute variante de ces dernières)
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><symbol>SPI_ERROR_OPUNKNOWN</symbol></term>
         <listitem>
          <para>
           si le type de commande est inconnu (ce qui ne devrait pas arriver)
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
         <listitem>
          <para>
           si appel à partir d'une fonction C non connectée
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
     </refsect1>

     <refsect1>
      <title>Notes</title>

      <para>
       Toutes les fonctions d'exécution de requêtes SPI changent à la fois
       <varname>SPI_processed</varname> et
       <varname>SPI_tuptable</varname> (juste le pointeur, pas le contenu
       de la structure).  Sauvegardez ces deux variables globales dans des variables
       locales de fonctions C si vous voulez accéder à la table des résultats de
       <function>SPI_execute</function> ou d'une fonction d'exécution de requêtes
       sur plusieurs appels.
      </para>
     </refsect1>
    </refentry>

    <!-- *********************************************** -->

    <refentry id="spi-spi-exec">
     <indexterm><primary>SPI_exec</primary></indexterm>

     <refmeta>
      <refentrytitle>SPI_exec</refentrytitle>
      <manvolnum>3</manvolnum>
     </refmeta>

     <refnamediv>
      <refname>SPI_exec</refname>
      <refpurpose>exécute une commande en lecture/écriture</refpurpose>
     </refnamediv>

     <refsynopsisdiv>
      <synopsis>int SPI_exec(const char * <parameter>command</parameter>, long <parameter>count</parameter>)</synopsis>
  </refsynopsisdiv>

  <refsect1>
    <title>Description</title>

    <para>
      <function>SPI_exec</function> est identique à
      <function>SPI_execute</function>, mais le paramètre
      <parameter>read_only</parameter> de ce dernier est bloqué sur la valeur
      <literal>false</literal>.
  </para>
</refsect1>

<refsect1>
  <title>Arguments</title>

  <variablelist>
    <varlistentry>
      <term><literal>const char * <parameter>command</parameter></literal></term>
      <listitem>
        <para>
          chaîne contenant la commande à exécuter
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><literal>long <parameter>count</parameter></literal></term>
      <listitem>
        <para>
          nombre maximum de lignes à renvoyer ou <literal>0</literal> pour
          aucune limite
        </para>
      </listitem>
    </varlistentry>
  </variablelist>
</refsect1>

<refsect1>
  <title>Valeur de retour</title>

  <para>
    Voir <function>SPI_execute</function>.
  </para>
</refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-extended">
 <indexterm><primary>SPI_execute_extended</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_execute_extended</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_execute_extended</refname>
  <refpurpose>Exécute une commande avec des paramètres hors ligne</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
int SPI_execute_extended(const char *<parameter>command</parameter>,
                         const SPIExecuteOptions * <parameter>options</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_execute_extended</function> exécute une commande qui peut inclure
   des références à des paramètres fournis en externe. Le texte de commande
   se réfère à un paramètre sous la forme <literal>$<replaceable>n</replaceable></literal>,
   et l'objet <parameter>options-&gt;params</parameter> (si fourni) donne des informations sur
   les valeurs et le type de chacun des symboles.
   De nombreuses options d'exécution peuvent aussi être spécifiées dans la structure
   <parameter>options</parameter>
  </para>

  <para>
   L'objet <parameter>options-&gt;params</parameter> doit normalement
   marquer chaque paramètre avec le drapeau <literal>PARAM_FLAG_CONST</literal>,
   dès qu'un plan unique est toujours utilisé pour cette requête.
  </para>

  <para>
   Si <parameter>options-&gt;dest</parameter> n'est pas NULL, alors les lignes de
   résultats
   sont passées à cet objet lors de leur génération par l'exécuteur, au lieu
   d'être accumulées dans <varname>SPI_tuptable</varname>. Employer un objet
   <literal>DestReceiver</literal> fourni par l'appelant est particulièrement
   utile pour les requêtes qui peuvent générer de nombreuses lignes, dès lors que
   les données sont traitées à la volée au lieu de s'accumuler en mémoire.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <para>
      Chaîne de caractères de la commande
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const SPIExecuteOptions * <parameter>options</parameter></literal></term>
    <listitem>
     <para>
      Structure contenant les arguments optionnels
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Les codes appelants doivent toujours mettre à zéro l'entièreté de la
   structure <parameter>options</parameter>, et ensuite remplir les champs
   souhaités. Ceci permet d'assurer la compatibilité ascendante
   du code, car tous les champs ajoutés à la structure dans le futur
   seront définis comme étant rétro-compatibles s'ils sont mis à zéro.
   Les champs de <parameter>options</parameter> actuellement disponibles
   sont&nbsp;:
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
    <listitem>
     <para>
      Structure de données contenant les types et valeurs des paramètres de
      requêtes&nbsp;; NULL si aucun.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <para><literal>true</literal> pour les exécutions en lecture seule</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>no_snapshots</parameter></literal></term>
    <listitem>
     <para>
      à <literal>true</literal>, autorise l'exécution non atomique des
      instructions CALL et DO
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>must_return_tuples</parameter></literal></term>
    <listitem>
     <para>
      si <literal>true</literal>, lève une erreur si la requête n'est pas d'un
      type qui renvoie des lignes (ceci n'interdit pas le cas où elle
      pourrait renvoyer zéro lignes)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>uint64 <parameter>tcount</parameter></literal></term>
    <listitem>
     <para>
      Nombre maximum de lignes à retourner, ou <literal>0</literal> pour aucune
      limite
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DestReceiver * <parameter>dest</parameter></literal></term>
    <listitem>
     <para>
      L'objet <literal>DestReceiver</literal> qui recevra toutes les lignes
      émises par la requête&nbsp;; si NULL, les lignes de résultats sont
      accumulés dans une structure <varname>SPI_tuptable</varname>, comme avec
      <function>SPI_execute</function>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ResourceOwner <parameter>owner</parameter></literal></term>
    <listitem>
     <para>
      Ce champ est présent pour la cohérence avec
      <function>SPI_execute_plan_extended</function>, mais est ignoré, puisque
      le plan utilisé par <function>SPI_execute_extended</function> n'est
      jamais sauvegardé.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   La valeur de retour est la même que pour <function>SPI_execute</function>.
  </para>

  <para>
   Quand <parameter>options-&gt;dest</parameter> est NULL,
   <varname>SPI_processed</varname> et <varname>SPI_tuptable</varname>
   sont affectés comme dans <function>SPI_execute</function>.
   Quand <parameter>options-&gt;dest</parameter> n'est pas NULL,
   <varname>SPI_processed</varname> est mis à zéro et
   <varname>SPI_tuptable</varname> est mis à NULL. Si un comptage de lignes
   est requis, l'objet <literal>DestReceiver</literal> appelant doit s'en
   occuper.
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

      <refentry id="spi-spi-execute-with-args">
       <indexterm><primary>SPI_execute_with_args</primary></indexterm>

       <refmeta>
        <refentrytitle>SPI_execute_with_args</refentrytitle>
        <manvolnum>3</manvolnum>
       </refmeta>

       <refnamediv>
        <refname>SPI_execute_with_args</refname>
        <refpurpose>exécute une commande avec des paramètres hors ligne</refpurpose>
       </refnamediv>

       <refsynopsisdiv>
        <synopsis>
int SPI_execute_with_args(const char *<parameter>command</parameter>,
                          int <parameter>nargs</parameter>, Oid *<parameter>argtypes</parameter>,
                          Datum *<parameter>values</parameter>, const char *<parameter>nulls</parameter>,
                          bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
        </synopsis>
       </refsynopsisdiv>

       <refsect1>
        <title>Description</title>

        <para>
         <function>SPI_execute_with_args</function> exécute une commande qui pourrait
         inclure des références à des paramètres fournis en externe. Le texte de
         commande fait référence à un paramètre avec
         <literal>$<replaceable>n</replaceable></literal> et l'appel spécifie les
         types et valeurs des données pour chaque symbole de ce type.
         <parameter>read_only</parameter> et <parameter>count</parameter> ont la
         même interprétation que dans <function>SPI_execute</function>.
        </para>

        <para>
         Le principal avantage de cette routine comparé à
         <function>SPI_execute</function> est que les valeurs de données peuvent être
         insérées dans la commande sans mise entre guillemets et échappements, et donc
         avec beaucoup moins de risques d'attaques du type injection SQL.
        </para>

        <para>
         Des résultats similaires peuvent être réalisés avec <function>SPI_prepare</function>
         suivi par <function>SPI_execute_plan</function>&nbsp;; néanmoins, lors de
         l'utilisation de cette fonction, le plan de requête est toujours personnalisé avec les
         valeurs de paramètres spécifiques fournies. Pour une exécution simple, cette
         fonction doit être préférée. Si la même commande doit être exécutée avec
         plusieurs paramètres différents, chaque méthode peut être la plus rapide,
         le coût de la planification pouvant contre-balancer les bénéfices des plans
         personnalisés.
        </para>
       </refsect1>

       <refsect1>
        <title>Arguments</title>

        <variablelist>
         <varlistentry>
          <term><literal>const char * <parameter>command</parameter></literal></term>
          <listitem>
           <para>
            chaîne de commande
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>int <parameter>nargs</parameter></literal></term>
          <listitem>
           <para>
            nombre de paramètres en entrée (<literal>$1</literal>, <literal>$2</literal>, etc.)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
          <listitem>
           <para>
            un tableau de longueur <parameter>nargs</parameter>, contenant les
            <acronym>OID</acronym> des types de données des paramètres
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>Datum * <parameter>values</parameter></literal></term>
          <listitem>
           <para>
            un tableau de longueur <parameter>nargs</parameter>, containing des
            valeurs réelles des paramètres
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>const char * <parameter>nulls</parameter></literal></term>
          <listitem>
           <para>
            un tableau décrivant les paramètres NULL
           </para>

           <para>
            Si <parameter>nulls</parameter> vaut <symbol>NULL</symbol>, alors
            <function>SPI_execute_with_args</function> suppose qu'aucun paramètre
            n'est NULL. Dans le cas contraire, chaque entrée du tableau
            <parameter>nulls</parameter> doit valoir <literal>'&nbsp;'</literal> si
            le paramètre correspondant est non NULL et <literal>'n'</literal> si le
            paramètre correspondant est NULL (dans ce dernier cas, la valeur réelle
            de l'entrée <parameter>values</parameter> correspondante n'a pas
            d'importance). Notez que <parameter>nulls</parameter> n'est pas une chaîne
            de texte. C'est un tableau et, de ce fait, il n'a pas besoin d'un
            caractère de fin <literal>'\0'</literal>.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>bool <parameter>read_only</parameter></literal></term>
          <listitem>
           <para>
            <literal>true</literal> pour les exécutions en lecture seule
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>long <parameter>count</parameter></literal></term>
          <listitem>
           <para>
            nombre maximum de lignes à renvoyer ou <literal>0</literal> pour aucune
            limite
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </refsect1>

       <refsect1>
        <title>Valeur de retour</title>

        <para>
         La valeur de retour est identique à celle de <function>SPI_execute</function>.
        </para>

        <para>
         <varname>SPI_processed</varname> et
         <varname>SPI_tuptable</varname> sont configurés comme dans
         <function>SPI_execute</function> en cas de succès.
        </para>
       </refsect1>
      </refentry>

      <!-- *********************************************** -->

      <refentry id="spi-spi-prepare">
       <indexterm><primary>SPI_prepare</primary></indexterm>

       <refmeta>
        <refentrytitle>SPI_prepare</refentrytitle>
        <manvolnum>3</manvolnum>
       </refmeta>

       <refnamediv>
        <refname>SPI_prepare</refname>
        <refpurpose>prépare une instruction sans l'exécuter tout de
         suite</refpurpose>
       </refnamediv>

       <refsynopsisdiv>
        <synopsis>SPIPlanStr SPI_prepare(const char * <parameter>command</parameter>, int <parameter>nargs</parameter>, Oid * <parameter>argtypes</parameter>)
        </synopsis>
       </refsynopsisdiv>

       <refsect1>
        <title>Description</title>

        <para>
         <function>SPI_prepare</function> crée et retourne une requête préparée
         pour la commande spécifiée mais ne lance pas la commande.
         La requête préparée peut être appelée plusieurs fois en utilisant
         <function>SPI_execute_plan</function>.
        </para>

        <para>
         Lorsque la même commande ou une commande semblable doit être lancée à
         plusieurs reprises, il est généralement avantageux de réaliser une
         analyse du plan d'exécution une fois et de ré-utiliser le plan
         d'exécution pour la commande.
         <function>SPI_prepare</function> convertit une chaîne de commande en une
         requête préparée qui encapsule le résultat de l'analyse du plan. La
         requête préparée fournit aussi une place pour mettre en cache un plan
         d'exécution s'il s'avère que la génération d'un plan personnalisé pour
         chaque exécution n'est pas utile.
        </para>

        <para>
         Une commande préparée peut être généralisée en utilisant les paramètres
         (<literal>$1</literal>, <literal>$2</literal>, etc.) en lieu et place de ce qui serait des
         constantes dans une commande normale. Les valeurs actuelles des paramètres
         sont alors spécifiées lorsque <function>SPI_executeplan</function> est appelée.
         Ceci permet à la commande préparée d'être utilisée sur une plage plus grande
         de situations que cela ne serait possible sans paramètres.
        </para>

        <para>
         La requête renvoyée par <function>SPI_prepare</function> ne peut être utilisé
         que dans l'invocation courante de la fonction C puisque
         <function>SPI_finish</function> libère la mémoire allouée pour la requête.
         Mais l'instruction peut être sauvegardée plus longtemps par l'utilisation des
         fonctions <function>SPI_keepplan</function> ou <function>SPI_saveplan</function>.
        </para>
       </refsect1>

       <refsect1>
        <title>Arguments</title>

        <variablelist>
         <varlistentry>
          <term><literal>const char * <parameter>command</parameter></literal></term>
          <listitem>
           <para>
            chaîne contenant la commande à planifier
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>int <parameter>nargs</parameter></literal></term>
          <listitem>
           <para>
            nombre de paramètres d'entrée (<literal>$1</literal>, <literal>$2</literal>, etc.)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
          <listitem>
           <para>
            pointeur vers un tableau contenant les <acronym>OID</acronym>
            des types de données des paramètres
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </refsect1>

       <refsect1>
        <title>Valeurs de retour</title>

        <para>
         <function>SPI_prepare</function> retourne un pointeur non nul vers un
         plan d'exécution. En cas d'erreur, <symbol>NULL</symbol> sera retourné
         et <varname>SPI_result</varname> sera positionnée à un des mêmes codes
         d'erreur utilisés par <function>SPI_execute</function> sauf qu'il
         est positionné à <symbol>SPI_ERROR_ARGUMENT</symbol> si
         <parameter>command</parameter> est <symbol>NULL</symbol> ou si
         <parameter>nargs</parameter> est inférieur à 0 ou si <parameter>nargs</parameter> est
         supérieur à 0 et <parameter>typesargs</parameter> est <symbol>NULL</symbol>.
        </para>
       </refsect1>

       <refsect1>
        <title>Notes</title>

        <para>
         Si aucun paramètre n'est défini, un plan générique sera créé lors de la
         première utilisation de <function>SPI_execute_plan</function>, et utilisé
         aussi pour toutes les exécutions suivantes. Si des paramètres sont fournis,
         les premières utilisations de <function>SPI_execute_plan</function> génèreront
         des plans personnalisés qui sont spécifiques aux valeurs fournies pour les
         paramètres. Après suffisamment d'utilisation de la même requête préparée,
         <function>SPI_execute_plan</function> construira un plan générique et, si
         ce n'est pas beaucoup plus coûteux que les plans personnalisés, cette fonction
         commencera à utiliser le plan générique au lieu de re-planifier à chaque fois.
         Si le comportement par défaut n'est pas tenable, vous pouvez le modifier en
         passant le drapeau <literal>CURSOR_OPT_GENERIC_PLAN</literal> ou
         <literal>CURSOR_OPT_CUSTOM_PLAN</literal> à
         <function>SPI_prepare_cursor</function> pour forcer l'utilisation,
         respectivement, de plans génériques ou personnalisés.
        </para>

        <para>
         Bien que le but principal d'une requête préparée est d'éviter les étapes
         d'analyse et de planification d'une requête,
         <productname>PostgreSQL</productname> forcera l'analyse et la planification
         de la requête avant de l'utiliser quand les objets de la base utilisés
         dans la requête ont subi des changements de définition (à partir de
         requêtes DDL) depuis la dernière utilisation de la requête préparée. De
         plus, si la valeur de <xref linkend="guc-search-path"/> change d'une
         exécution à une autre, la requête sera de nouveau planifiée en utilisant
         le nouveau <varname>search_path</varname> (ce dernier comportement est une
         nouveauté de la version 9.3 de <productname>PostgreSQL</productname>). Voir
         <xref linkend="sql-prepare"/> pour plus d'informations sur le comportement
         des requêtes préparées.
        </para>

        <para>
         Cette fonction doit seulement être appelée à partir d'une fonction C connectée.
        </para>

        <para>
         <type>SPIPlanPtr</type> est déclaré comme un pointeur vers un type de
         structure opaque dans <filename>spi.h</filename>. Il est déconseillé d'essayer
         d'accéder à son contenu directement car cela rend votre code plus fragile aux
         futures versions de <productname>PostgreSQL</productname>.
        </para>

        <para>
         Le nom <type>SPIPlanPtr</type> est historique principalement car la structure
         des données ne contient plus nécessairement un plan d'exécution.
        </para>
       </refsect1>
      </refentry>

      <!-- *********************************************** -->

      <refentry id="spi-spi-prepare-cursor">
       <indexterm><primary>SPI_prepare_cursor</primary></indexterm>

       <refmeta>
        <refentrytitle>SPI_prepare_cursor</refentrytitle>
        <manvolnum>3</manvolnum>
       </refmeta>

       <refnamediv>
        <refname>SPI_prepare_cursor</refname>
        <refpurpose>prépare une requête, sans l'exécuter pour l'instant</refpurpose>
       </refnamediv>

       <refsynopsisdiv>
        <synopsis>
SPIPlanPtr SPI_prepare_cursor(const char * <parameter>command</parameter>, int <parameter>nargs</parameter>, Oid * <parameter>argtypes</parameter>, int <parameter>cursorOptions</parameter>)
        </synopsis>
       </refsynopsisdiv>

       <refsect1>
        <title>Description</title>

        <para>
         <function>SPI_prepare_cursor</function> est identique à
         <function>SPI_prepare</function>, sauf qu'il permet aussi la spécification
         du paramètre des <quote>options du curseur</quote> du planificateur. Il
         s'agit d'un champ de bits dont les valeurs sont indiquées dans
         <filename>nodes/parsenodes.h</filename> pour le champ
         <structfield>options</structfield> de <structname>DeclareCursorStmt</structname>.
         <function>SPI_prepare</function> utilise zéro pour les options du curseur.
        </para>

        <para>
         Cette fonction est dépréciée en faveur de
         <function>SPI_prepare_extended</function>.
        </para>
       </refsect1>

       <refsect1>
        <title>Arguments</title>

        <variablelist>
         <varlistentry>
          <term><literal>const char * <parameter>command</parameter></literal></term>
          <listitem>
           <para>
            chaîne commande
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>int <parameter>nargs</parameter></literal></term>
          <listitem>
           <para>
            nombre de paramètres en entrée (<literal>$1</literal>, <literal>$2</literal>, etc.)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
          <listitem>
           <para>
            pointeur vers un tableau contenant l'<acronym>OID</acronym> des types
            de données des paramètres
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>int <parameter>cursorOptions</parameter></literal></term>
          <listitem>
           <para>
            champ de bits précisant les options du curseur&nbsp;; zéro est le
            comportement par défaut
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </refsect1>

       <refsect1>
        <title>Valeur de retour</title>

        <para>
         <function>SPI_prepare_cursor</function> a les mêmes conventions pour la
         valeur de retour que <function>SPI_prepare</function>.
        </para>
       </refsect1>

       <refsect1>
        <title>Notes</title>

        <para>
         Les bits utiles pour <parameter>cursorOptions</parameter> incluent
         <symbol>CURSOR_OPT_NO_SCROLL</symbol>,
         <symbol>CURSOR_OPT_FAST_PLAN</symbol>,
         <symbol>CURSOR_OPT_GENERIC_PLAN</symbol> et
         <symbol>CURSOR_OPT_CUSTOM_PLAN</symbol>. Notez en particulier que
         <symbol>CURSOR_OPT_HOLD</symbol> est ignoré.
        </para>
       </refsect1>
      </refentry>

      <!-- *********************************************** -->

<refentry id="spi-spi-prepare-extended">
 <indexterm><primary>SPI_prepare_extended</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_prepare_extended</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_prepare_extended</refname>
  <refpurpose>prépare une instruction, sans l'exécuter tout de suite</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
SPIPlanPtr SPI_prepare_extended(const char * <parameter>command</parameter>,
                                const SPIPrepareOptions * <parameter>options</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_prepare_extended</function> crée et retourne une requête
   préparée pour une commande donnée, mais n'exécute pas la commande.
   Cette fonction est équivalente à <function>SPI_prepare</function>,
   avec en plus le fait que l'appelant peut spécifier des options pour contrôler
   l'analyse (<quote>parsing</quote>) des paramètres en référence externes,
   aussi bien que d'autres aspects de l'analyse et de la planification des requêtes.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <para>
      Chaîne de la commande
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const SPIPrepareOptions * <parameter>options</parameter></literal></term>
    <listitem>
     <para>
      Structure contenant les arguments optionnels
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Les codes appelant doivent toujours mettre à zéro la structure
   <parameter>options</parameter> entière, puis remplir les champs souhaités
   avec les valeurs à affecter. Ceci permet d'assurer une compatibilité
   ascendante du code, car tous les champs ajoutés à la structure dans le
   futur seront définis comme étant rétro-compatibles s'ils sont mis à zéro.
   Les champs de <parameter>options</parameter>  actuellement disponibles
   sont&nbsp;:
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>ParserSetupHook <parameter>parserSetup</parameter></literal></term>
    <listitem>
     <para>
      Fonction de configuration de l'analyseur
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>void * <parameter>parserSetupArg</parameter></literal></term>
    <listitem>
     <para>
      Argument passé à <parameter>parserSetup</parameter>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RawParseMode <parameter>parseMode</parameter></literal></term>
    <listitem>
     <para>
      Mode pour l'analyse brute&nbsp;; <literal>RAW_PARSE_DEFAULT</literal> (zéro) génère
      le comportement par défaut
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
     <para>
      Masque de bits des options du curseur, sous la forme d'un entier&nbsp;;
      zéro indique le comportement par défaut
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur retournée</title>

  <para>
   <function>SPI_prepare_extended</function> a la même convention de retour que
   <function>SPI_prepare</function>.
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

      <refentry id="spi-spi-prepare-params">
       <indexterm><primary>SPI_prepare_params</primary></indexterm>

       <refmeta>
        <refentrytitle>SPI_prepare_params</refentrytitle>
        <manvolnum>3</manvolnum>
       </refmeta>

       <refnamediv>
        <refname>SPI_prepare_params</refname>
        <refpurpose>prépare une requête, mais sans l'exécuter</refpurpose>
       </refnamediv>

       <refsynopsisdiv>
        <synopsis>
SPIPlanPtr SPI_prepare_params(const char * <parameter>command</parameter>,
                              ParserSetupHook <parameter>parserSetup</parameter>,
                              void * <parameter>parserSetupArg</parameter>,
                              int <parameter>cursorOptions</parameter>)
        </synopsis>
       </refsynopsisdiv>

       <refsect1>
        <title>Description</title>

        <para>
         <function>SPI_prepare_params</function> crée et renvoie une requête
         préparée
         pour la commande indiquée mais n'exécute pas la commande. Cette fonction
         est équivalente à <function>SPI_prepare_cursor</function> avec en plus le
         fait que l'appelant peut indiquer des fonctions pour contrôler l'analyse
         de références de paramètres externes.
        </para>

  <para>
   Cette fonction est maintenant dépréciée en faveur de
   <function>SPI_prepare_extended</function>.
  </para>
       </refsect1>

       <refsect1>
        <title>Arguments</title>

        <variablelist>
         <varlistentry>
          <term><literal>const char * <parameter>command</parameter></literal></term>
          <listitem>
           <para>
            chaîne correspondant à la commande
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>ParserSetupHook <parameter>parserSetup</parameter></literal></term>
          <listitem>
           <para>
            fonction de configuration de l'analyseur
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>void * <parameter>parserSetupArg</parameter></literal></term>
          <listitem>
           <para>
            argument passé à <parameter>parserSetup</parameter>
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>int <parameter>cursorOptions</parameter></literal></term>
          <listitem>
           <para>
            masque de bits des options du curseur, sous la forme d'un entier&nbsp;;
            zéro indique le comportement par défaut
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </refsect1>

       <refsect1>
        <title>Code de retour</title>

        <para>
         <function>SPI_prepare_params</function> a les mêmes conventions de retour
         que <function>SPI_prepare</function>.
        </para>
       </refsect1>
      </refentry>

      <!-- *********************************************** -->

      <refentry id="spi-spi-getargcount">
       <indexterm><primary>SPI_getargcount</primary></indexterm>

       <refmeta>
        <refentrytitle>SPI_getargcount</refentrytitle>
        <manvolnum>3</manvolnum>
       </refmeta>

       <refnamediv>
        <refname>SPI_getargcount</refname>
        <refpurpose>renvoie le nombre d'arguments nécessaire à une requête
         par <function>SPI_prepare</function></refpurpose>
       </refnamediv>

       <refsynopsisdiv>
        <synopsis>int SPI_getargcount(SPIPlanPtr <parameter>plan</parameter>)</synopsis>
  </refsynopsisdiv>

  <refsect1>
    <title>Description</title>

    <para>
      <function>SPI_getargcount</function> renvoie le nombre d'arguments
      nécessaires pour exécuter une requête préparée par
      <function>SPI_prepare</function>.
    </para>
  </refsect1>

  <refsect1>
    <title>Arguments</title>

    <variablelist>
      <varlistentry>
        <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
        <listitem>
          <para>
            requête préparée (renvoyée par <function>SPI_prepare</function>)
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsect1>

  <refsect1>
    <title>Code de retour</title>
    <para>
      Le nombre d'arguments attendus par le <parameter>plan</parameter>.
      Si <parameter>plan</parameter> est <symbol>NULL</symbol> ou invalide,
    <varname>SPI_result</varname> est initialisé à <symbol>SPI_ERROR_ARGUMENT</symbol>
    et -1 est renvoyé.
    </para>
  </refsect1>
</refentry>

<!-- *********************************************** -->

        <refentry id="spi-spi-getargtypeid">
         <indexterm><primary>SPI_getargtypeid</primary></indexterm>

         <refmeta>
          <refentrytitle>SPI_getargtypeid</refentrytitle>
          <manvolnum>3</manvolnum>
         </refmeta>

         <refnamediv>
          <refname>SPI_getargtypeid</refname>
          <refpurpose>renvoie l'OID du type de données pour un argument de la
           requête préparée par <function>SPI_prepare</function></refpurpose>
         </refnamediv>

         <refsynopsisdiv>
          <synopsis>Oid SPI_getargtypeid(SPIPlanPtr <parameter>plan</parameter>, int <parameter>argIndex</parameter>)</synopsis>
  </refsynopsisdiv>

  <refsect1>
    <title>Description</title>

    <para>
      <function>SPI_getargtypeid</function> renvoie l'OID représentant
      le type pour le <parameter>argIndex</parameter>-ième
      argument d'une requête préparée par <function>SPI_prepare</function>. Le
      premier argument se trouve à l'index zéro.
    </para>
  </refsect1>

  <refsect1>
    <title>Arguments</title>

    <variablelist>
      <varlistentry>
        <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
        <listitem>
          <para>
            requête préparée (renvoyée par <function>SPI_prepare</function>)
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>int <parameter>argIndex</parameter></literal></term>
        <listitem>
          <para>
            index de l'argument (à partir de zéro)
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsect1>

  <refsect1>
    <title>Code de retour</title>
    <para>
      L'OID du type de l'argument à l'index donné.
      Si le <parameter>plan</parameter> est <symbol>NULL</symbol> ou invalide,
      ou <parameter>argIndex</parameter> inférieur à 0 ou pas moins que le
      nombre d'arguments déclaré pour le <parameter>plan</parameter>,
      <varname>SPI_result</varname> est initialisé à
      <symbol>SPI_ERROR_ARGUMENT</symbol> et <symbol>InvalidOid</symbol> est
      renvoyé.
    </para>
  </refsect1>
</refentry>

<!-- *********************************************** -->

          <refentry id="spi-spi-is-cursor-plan">
           <indexterm><primary>SPI_is_cursor_plan</primary></indexterm>

           <refmeta>
            <refentrytitle>SPI_is_cursor_plan</refentrytitle>
            <manvolnum>3</manvolnum>
           </refmeta>

           <refnamediv>
            <refname>SPI_is_cursor_plan</refname>
            <refpurpose>renvoie <symbol>true</symbol> si la requête préparée par
             <function>SPI_prepare</function> peut être utilisé avec
             <function>SPI_cursor_open</function></refpurpose>
           </refnamediv>

           <refsynopsisdiv>
            <synopsis>bool SPI_is_cursor_plan(SPIPlanPtr <parameter>plan</parameter>)</synopsis>
  </refsynopsisdiv>

  <refsect1>
    <title>Description</title>

    <para>
      <function>SPI_is_cursor_plan</function> renvoie <symbol>true</symbol>
      si une requête préparée par <function>SPI_prepare</function> peut être
      passé comme un argument à <function>SPI_cursor_open</function> ou
      <symbol>false</symbol> si ce n'est pas le cas. Les critères sont que le
      <parameter>plan</parameter> représente une seule commande et que cette
      commande renvoit des lignes à l'appelant&nbsp;; par l'exemple,
      <command>SELECT</command> est autorisé sauf s'il contient une clause
      <literal>INTO</literal> et <command>UPDATE</command> est autorisé seulement
      s'il contient un <literal>RETURNING</literal>
    </para>
  </refsect1>

  <refsect1>
    <title>Arguments</title>

    <variablelist>
      <varlistentry>
		  <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
        <listitem>
          <para>
            requête préparée (renvoyée par <function>SPI_prepare</function>)
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsect1>

  <refsect1>
    <title>Valeur de retour</title>
    <para>
      <symbol>true</symbol> ou <symbol>false</symbol> pour indiquer si
      <parameter>plan</parameter> peut produire un curseur ou non, avec
      <varname>SPI_result</varname> initialisé à zéro. S'il nest pas
      possible de déterminer la réponse (par exemple, si le
      <parameter>plan</parameter> vaut <symbol>NULL</symbol> ou est invalide,
      ou s'il est appelé en étant déconnecté de SPI), alors
      <varname>SPI_result</varname> est configuré avec un code d'erreur
      convenable et <symbol>false</symbol> est renvoyé.
    </para>
  </refsect1>
</refentry>

<!-- *********************************************** -->

            <refentry id="spi-spi-execute-plan">
             <indexterm><primary>SPI_execute_plan</primary></indexterm>

             <refmeta>
              <refentrytitle>SPI_execute_plan</refentrytitle>
              <manvolnum>3</manvolnum>
             </refmeta>

             <refnamediv>
              <refname>SPI_execute_plan</refname>
              <refpurpose>exécute une requête préparée par
               <function>SPI_prepare</function></refpurpose>
             </refnamediv>

             <refsynopsisdiv>
              <synopsis>int SPI_execute_plan(SPIPlanPtr <parameter>plan</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>, bool <parameter>read_only</parameter>, long <parameter>count</parameter>)</synopsis>
  </refsynopsisdiv>

  <refsect1>
    <title>Description</title>

    <para>
      <function>SPI_execute_plan</function> exécute une requête préparée par
      <function>SPI_prepare</function> ou une fonction du même type.
      <parameter>read_only</parameter> et
      <parameter>count</parameter> ont la même interprétation que dans
      <function>SPI_execute</function>.
    </para>
  </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
      requête préparée (retournée par <function>SPI_prepare</function>)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum *<parameter>values</parameter></literal></term>
    <listitem>
     <para>
      Un tableau des vraies valeurs des paramètres. Doit avoir la même longueur
      que le nombre d'arguments de la requête.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <para>
      Un tableau décrivant les paramètres nuls. Doit avoir la même longueur que
      le nombre d'arguments de la requête.
     </para>

     <para>
      Si <parameter>nulls</parameter> vaut <symbol>NULL</symbol>, alors
      <function>SPI_execute_plan</function> suppose qu'aucun paramètre
      n'est NULL. Dans le cas contraire, chaque entrée du tableau
      <parameter>nulls</parameter> doit valoir <literal>'&nbsp;'</literal> si
      le paramètre correspondant est non NULL et <literal>'n'</literal> si le
      paramètre correspondant est NULL (dans ce dernier cas, la valeur réelle
      de l'entrée <parameter>values</parameter> correspondante n'a pas
      d'importance). Notez que <parameter>nulls</parameter> n'est pas une chaîne
      de texte. C'est un tableau et, de ce fait, il n'a pas besoin d'un
      caractère de fin <literal>'\0'</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <para>
      <literal>true</literal> pour une exécution en lecture seule
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
      nombre maximum de lignes à renvoyer ou <literal>0</literal> pour aucune
      ligne à renvoyer
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   La valeur de retour est la même que pour <function>SPI_execute</function>
   avec les résultats d'erreurs (négatif) possibles&nbsp;:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       si <parameter>plan</parameter> est <symbol>NULL</symbol> ou invalide
       ou <parameter>count</parameter> est inférieur à 0
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_PARAM</symbol></term>
     <listitem>
      <para>
       si <parameter>values</parameter> est <symbol>NULL</symbol> et
       <parameter>plan</parameter> est préparé avec des paramètres
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   <varname>SPI_processed</varname> et
   <varname>SPI_tuptable</varname> sont positionnés comme dans
   <function>SPI_execute</function> en cas de réussite.
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-plan-extended">
 <indexterm><primary>SPI_execute_plan_extended</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_execute_plan_extended</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_execute_plan_extended</refname>
  <refpurpose>exécute une requête préparée par <function>SPI_prepare</function></refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
int SPI_execute_plan_extended(SPIPlanPtr <parameter>plan</parameter>,
                              const SPIExecuteOptions * <parameter>options</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_execute_plan_extended</function> exécute une requête
   préparée par <function>SPI_prepare</function> ou une similaire.
   La fonction est l'équivalent de <function>SPI_execute_plan</function>,
   à l'exception que l'information sur les valeurs des paramètres passées à
   la requête est présentée différemment, et des options supplémentaires
   de contrôle d'exécution peuvent être fournies.
  </para>

  <para>
   Les valeurs des paramètres de requêtes sont représentées par
   une structure <literal>ParamListInfo</literal>, ce qui est pratique pour
   fournir les valeurs qui sont déjà disponibles dans ce format. Des ensembles
   de paramètres dynamiques peuvent aussi être utilisées, à travers des fonctions
   d'accrochage spécifiées dans <literal>ParamListInfo</literal>.
  </para>

  <para>
   De plus, au lieu de toujours accumuler les lignes de résultats dans une structure
   <varname>SPI_tuptable</varname>, les lignes peuvent être passées à un
   objet <literal>DestReceiver</literal> fourni par l'appelant au fur et à
   mesure de leur génération par l'exécuteur de requête. Ceci est particulièrement
   utile pour les requêtes qui peuvent générer de nombreuses lignes, comme les données
   peuvent être traitées au fur et à mesure au lieu d'être accumulées en mémoire.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
      Expression préparée (retournée par <function>SPI_prepare</function>)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const SPIExecuteOptions * <parameter>options</parameter></literal></term>
    <listitem>
     <para>
      Structure contenant les arguments optionnels
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Les appelants doivent toujours mettre l'entièreté de la structure
   <parameter>options</parameter> à zéro, puis remplir les champs nécessaires
   à affecter. Ceci assure une compatibilité ascendante du code, car tous les
   champs qui seront ajoutés à la structure dans le futur seront
   rétro-compatibles s'ils sont mis à zéro. Les champs de
   <parameter>options</parameter> actuellement disponbiles sont&nbsp;:
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
    <listitem>
     <para>
      Structure de données contenant les types et valeurs des paramètres de
      requêtes&nbsp;; NULL si aucun
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <para><literal>true</literal> pour les exécution en lecture seule</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>no_snapshots</parameter></literal></term>
    <listitem>
     <para>
      <literal>true</literal> autorise l'exécution non atomique des instructions
      CALL et DO
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>must_return_tuples</parameter></literal></term>
    <listitem>
     <para>
      si <literal>true</literal>, lève une erreur si la requête n'est pas d'un
      type qui renvoie des lignes (ceci n'interdit pas le cas où elle
      pourrait renvoyer zéro lignes)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>uint64 <parameter>tcount</parameter></literal></term>
    <listitem>
     <para>
      Nombre maximal de lignes à retourner ou <literal>0</literal> pour illimité
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DestReceiver * <parameter>dest</parameter></literal></term>
    <listitem>
     <para>
      L'objet <literal>DestReceiver</literal> qui va recevoir toutes les
      lignes émises par la requête&nbsp;; si NULL, les lignes des résultats
      sont accumulées dans une structure <varname>SPI_tuptable</varname>,
      comme dans <function>SPI_execute_plan</function>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ResourceOwner <parameter>owner</parameter></literal></term>
    <listitem>
     <para>
      Le propriétaire de ressources qui va garder un compteur de référence sur
      le plan pendant qu'il est exécuté. Si NULL, CurrentResourceOwner est
      utilisé. Ce champ est ignoré pour les plans non sauvegardés, comme SPI
      n'acquiert pas de compteur de référence dessus.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur retournée</title>

  <para>
   La valeur retournée est la même que pour <function>SPI_execute_plan</function>.
  </para>

  <para>
   Quand <parameter>options-&gt;dest</parameter> est NULL,
   <varname>SPI_processed</varname> et <varname>SPI_tuptable</varname> sont
   affectés comme dans <function>SPI_execute_plan</function>. Quand
   <parameter>options-&gt;dest</parameter> n'est pas NULL,
   <varname>SPI_processed</varname> est mis à zéro et
   <varname>SPI_tuptable</varname> est mis à NULL.  Si un comptage de lignes
   est requis, l'appellant de l'objet <literal>DestReceiver</literal> doit
   s'en charger.
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

              <refentry id="spi-spi-execute-plan-with-paramlist">
               <indexterm><primary>SPI_execute_plan_with_paramlist</primary></indexterm>

               <refmeta>
                <refentrytitle>SPI_execute_plan_with_paramlist</refentrytitle>
                <manvolnum>3</manvolnum>
               </refmeta>

               <refnamediv>
                <refname>SPI_execute_plan_with_paramlist</refname>
                <refpurpose>exécute une requête préparée par <function>SPI_prepare</function></refpurpose>
               </refnamediv>

               <refsynopsisdiv>
                <synopsis>
int SPI_execute_plan_with_paramlist(SPIPlanPtr <parameter>plan</parameter>,
                                    ParamListInfo <parameter>params</parameter>,
                                    bool <parameter>read_only</parameter>,
                                    long <parameter>count</parameter>)
                </synopsis>
               </refsynopsisdiv>

               <refsect1>
                <title>Description</title>

                <para>
                 <function>SPI_execute_plan_with_paramlist</function> exécute une requête
                 préparée par <function>SPI_prepare</function>. Cette fonction est
                 l'équivalent de <function>SPI_execute_plan</function>, sauf que les
                 informations sur les valeurs des paramètres à passer à la requête sont
                 présentées différemment. La représentation <literal>ParamListInfo</literal>
                 peut être utilisée pour passer des valeurs qui sont déjà disponibles dans ce
                 format. Elle supporte aussi l'utilisation d'ensemble de paramètres
                 dynamiques indiqués via des fonctions dans <literal>ParamListInfo</literal>.
                </para>

  <para>
   This function is now deprecated in favor
   of <function>SPI_execute_plan_extended</function>.
  </para>
               </refsect1>

               <refsect1>
                <title>Arguments</title>

                <variablelist>
                 <varlistentry>
                  <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
                  <listitem>
                   <para>
                    requête préparée (renvoyée par <function>SPI_prepare</function>)
                   </para>
                  </listitem>
                 </varlistentry>

                 <varlistentry>
                  <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
                  <listitem>
                   <para>
                    structure de données contenant les types et valeurs de paramètres&nbsp;;
                    NULL si aucune structure
                   </para>
                  </listitem>
                 </varlistentry>

                 <varlistentry>
                  <term><literal>bool <parameter>read_only</parameter></literal></term>
                  <listitem>
                   <para>
                    <literal>true</literal> pour une exécution en lecture seule
                   </para>
                  </listitem>
                 </varlistentry>

                 <varlistentry>
                  <term><literal>long <parameter>count</parameter></literal></term>
                  <listitem>
                   <para>
                    nombre maximum de lignes à renvoyer ou <literal>0</literal> pour aucune
                    ligne à renvoyer
                   </para>
                  </listitem>
                 </varlistentry>
                </variablelist>
               </refsect1>

               <refsect1>
                <title>Code de retour</title>

                <para>
                 La valeur de retour est identique à celle de <function>SPI_execute_plan</function>.
                </para>

                <para>
                 <varname>SPI_processed</varname> et <varname>SPI_tuptable</varname> sont
                 initialisés de la même façon que pour <function>SPI_execute_plan</function>
                 en cas de réussite.
                </para>
               </refsect1>
              </refentry>

              <!-- *********************************************** -->

              <refentry id="spi-spi-execp">
               <indexterm><primary>SPI_execp</primary></indexterm>

               <refmeta>
                <refentrytitle>SPI_execp</refentrytitle>
                <manvolnum>3</manvolnum>
               </refmeta>

               <refnamediv>
                <refname>SPI_execp</refname>
                <refpurpose>exécute une requête en mode lecture/écriture</refpurpose>
               </refnamediv>

               <refsynopsisdiv>
                <synopsis>int SPI_execp(SPIPlanPtr <parameter>plan</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>, long <parameter>count</parameter>)</synopsis>
  </refsynopsisdiv>

  <refsect1>
    <title>Description</title>

    <para>
      <function>SPI_execp</function> est identique à
      <function>SPI_execute_plan</function> mais le paramètre
      <parameter>read_only</parameter> de ce dernier vaut toujours
      <literal>false</literal>.
  </para>
</refsect1>

<refsect1>
  <title>Arguments</title>

  <variablelist>
    <varlistentry>
      <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
      <listitem>
        <para>
          requête préparée (renvoyée par <function>SPI_prepare</function>)
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><literal>Datum * <parameter>values</parameter></literal></term>
      <listitem>
        <para>
          Un tableau des vraies valeurs de paramètre. Doit avoir la même
          longueur que le nombre d'arguments de la requête.
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><literal>const char * <parameter>nulls</parameter></literal></term>
      <listitem>
        <para>
          Un tableau décrivant les paramètres NULL. Doit avoir la même
          longueur que le nombre d'arguments de la requête.
        </para>

        <para>
      Si <parameter>nulls</parameter> vaut <symbol>NULL</symbol>, alors
      <function>SPI_executep</function> suppose qu'aucun paramètre
      n'est NULL. Dans le cas contraire, chaque entrée du tableau
      <parameter>nulls</parameter> doit valoir <literal>'&nbsp;'</literal> si
      le paramètre correspondant est non NULL et <literal>'n'</literal> si le
      paramètre correspondant est NULL (dans ce dernier cas, la valeur réelle
      de l'entrée <parameter>values</parameter> correspondante n'a pas
      d'importance). Notez que <parameter>nulls</parameter> n'est pas une chaîne
      de texte. C'est un tableau et, de ce fait, il n'a pas besoin d'un
      caractère de fin <literal>'\0'</literal>.
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><literal>long <parameter>count</parameter></literal></term>
      <listitem>
        <para>
          nombre maximum de lignes à renvoyer ou <literal>0</literal> pour aucune
          ligne à renvoyer
        </para>
      </listitem>
    </varlistentry>
    </variablelist>
</refsect1>

<refsect1>
  <title>Valeur de retour</title>

  <para>
    Voir <function>SPI_execute_plan</function>.
  </para>

  <para>
    <varname>SPI_processed</varname> et <varname>SPI_tuptable</varname> sont
    initialisées comme dans <function>SPI_execute</function> en cas de succès.
  </para>
</refsect1>
</refentry>

<!-- *********************************************** -->

                <refentry id="spi-spi-cursor-open">
                 <indexterm><primary>SPI_cursor_open</primary></indexterm>

                 <refmeta>
                  <refentrytitle>SPI_cursor_open</refentrytitle>
                  <manvolnum>3</manvolnum>
                 </refmeta>

                 <refnamediv>
                  <refname>SPI_cursor_open</refname>
                  <refpurpose>met en place un curseur en utilisant une requête créée avec
                   <function>SPI_prepare</function></refpurpose>
                 </refnamediv>

                 <refsynopsisdiv>
                  <synopsis>Portal SPI_cursor_open(const char * <parameter>name</parameter>, SPIPlanPtr <parameter>plan</parameter>,
Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>,
bool <parameter>read_only</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_cursor_open</function> met en place un curseur (en interne,
   un portail) qui lancera une requête préparée par
   <function>SPI_prepare</function>. Les paramètres ont la même signification
   que les paramètres correspondant à <function>SPI_execute_plan</function>.
  </para>

  <para>
   Utiliser un curseur au lieu de lancer une requête directement a deux
   avantages. Premièrement, les lignes de résultats peuvent être récupérées un
   certain nombre à la fois, évitant la saturation de mémoire pour les requêtes
   qui retournent trop de lignes. Deuxièmement,
   un portail peut survivre à la fonction C courante (elle peut, en fait, vivre
   jusqu'à la fin de la transaction courante). Renvoyer le nom du portail
   à l'appelant de la fonction C donne un moyen de retourner une série de ligne
   en tant que résultat.
  </para>

  <para>
   Les données passées seront copiées dans le portail du curseur, donc il peut
   être libéré alors que le curseur existe toujours.
  </para>

  <para>
   Cette fonction est maintenant dépréciée en faveur de
   <function>SPI_cursor_parse_open</function>, qui fournit une
   fonctionnalité équivalente en utilisant une API plus moderne
   pour gérer les paramètres de requêtes.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
     <para>
      nom pour le portail ou <symbol>NULL</symbol> pour laisser le système
      choisir un nom
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
      requête préparée (retournée par <function>SPI_prepare</function>)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <para>
      Un tableau des valeurs de paramètres actuelles. Doit avoir la même
      longueur que le nombre d'arguments de la requête.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char *<parameter>nulls</parameter></literal></term>
    <listitem>
     <para>
      Un tableau décrivant quels paramètres sont NULL. Doit avoir la même
      longueur que le nombre d'arguments de la requête.
     </para>
     <para>
      Si <parameter>nulls</parameter> vaut <symbol>NULL</symbol>, alors
      <function>SPI_cursor_open</function> suppose qu'aucun paramètre
      n'est NULL. Dans le cas contraire, chaque entrée du tableau
      <parameter>nulls</parameter> doit valoir <literal>'&nbsp;'</literal> si
      le paramètre correspondant est non NULL et <literal>'n'</literal> si le
      paramètre correspondant est NULL (dans ce dernier cas, la valeur réelle
      de l'entrée <parameter>values</parameter> correspondante n'a pas
      d'importance). Notez que <parameter>nulls</parameter> n'est pas une chaîne
      de texte. C'est un tableau et, de ce fait, il n'a pas besoin d'un
      caractère de fin <literal>'\0'</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <para>
      <literal>true</literal> pour les exécutions en lecture seule
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   Pointeur vers le portail contenant le curseur. Notez qu'il n'y a pas de
   convention pour le renvoi d'une erreur&nbsp;; toute erreur sera rapportée
   via <function>elog</function>.
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                  <refentry id="spi-spi-cursor-open-with-args">
                   <indexterm><primary>SPI_cursor_open_with_args</primary></indexterm>

                   <refmeta>
                    <refentrytitle>SPI_cursor_open_with_args</refentrytitle>
                    <manvolnum>3</manvolnum>
                   </refmeta>

                   <refnamediv>
                    <refname>SPI_cursor_open_with_args</refname>
                    <refpurpose>ouvre un curseur en utilisant une requête et des paramètres</refpurpose>
                   </refnamediv>

                   <refsynopsisdiv>
                    <synopsis>
Portal SPI_cursor_open_with_args(const char *<parameter>name</parameter>,
                                 const char *<parameter>command</parameter>,
                                 int <parameter>nargs</parameter>, Oid *<parameter>argtypes</parameter>,
                                 Datum *<parameter>values</parameter>, const char *<parameter>nulls</parameter>,
                                 bool <parameter>read_only</parameter>, int <parameter>cursorOptions</parameter>)
                    </synopsis>
                   </refsynopsisdiv>

                   <refsect1>
                    <title>Description</title>

                    <para>
                     <function>SPI_cursor_open_with_args</function> initialise un curseur
                     (en interne, un portail) qui exécutera la requête spécifié. La plupart des
                     paramètres ont la même signification que les paramètres correspondant de
                     <function>SPI_prepare_cursor</function> et <function>SPI_cursor_open</function>.
                    </para>

                    <para>
                     Pour une exécution seule, cette fonction sera préférée à
                     <function>SPI_prepare_cursor</function> suivie de
                     <function>SPI_cursor_open</function>. Si la même commande doit être exécutée
                     avec plusieurs paramètres différents, il n'y a pas de différences sur les
                     deux méthode, la replanification a un coût mais bénéficie de plans
                     personnalisés.
                    </para>

                    <para>
                     Les données passées seront copiées dans le portail du curseur, donc elles
                     seront libérées alors que le curseur existe toujours.
                    </para>
                   </refsect1>

                   <refsect1>
                    <title>Arguments</title>

                    <variablelist>
                     <varlistentry>
                      <term><literal>const char * <parameter>name</parameter></literal></term>
                      <listitem>
                       <para>
                        nom du portail, ou <symbol>NULL</symbol> pour que le système sélectionne
                        un nom de lui-même
                       </para>
                      </listitem>
                     </varlistentry>

                     <varlistentry>
                      <term><literal>const char * <parameter>command</parameter></literal></term>
                      <listitem>
                       <para>
                        chaîne de commande
                       </para>
                      </listitem>
                     </varlistentry>

                     <varlistentry>
                      <term><literal>int <parameter>nargs</parameter></literal></term>
                      <listitem>
                       <para>
                        nombre de paramètres en entrée (<literal>$1</literal>,
                        <literal>$2</literal>, etc.)
                       </para>
                      </listitem>
                     </varlistentry>

                     <varlistentry>
                      <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
                      <listitem>
                       <para>
                        un tableau de longueur <parameter>nargs</parameter>, contenant les
                        <acronym>OID</acronym> des types de données des paramètres
                       </para>
                      </listitem>
                     </varlistentry>

                     <varlistentry>
                      <term><literal>Datum * <parameter>values</parameter></literal></term>
                      <listitem>
                       <para>
                        un tableau de longueur <parameter>nargs</parameter>, contenant les valeurs
                        actuelles des paramètres
                       </para>
                      </listitem>
                     </varlistentry>

                     <varlistentry>
                      <term><literal>const char * <parameter>nulls</parameter></literal></term>
                      <listitem>
                       <para>
                        un tableau de longueur <parameter>nargs</parameter>, décrivant les
                        paramètres NULL
                       </para>

                       <para>
                        Si <parameter>nulls</parameter> vaut <symbol>NULL</symbol>, alors
                        <function>SPI_cursor_open_with_args</function> suppose qu'aucun paramètre
                        n'est NULL. Dans le cas contraire, chaque entrée du tableau
                        <parameter>nulls</parameter> doit valoir <literal>'&nbsp;'</literal> si
                        le paramètre correspondant est non NULL et <literal>'n'</literal> si le
                        paramètre correspondant est NULL (dans ce dernier cas, la valeur réelle
                        de l'entrée <parameter>values</parameter> correspondante n'a pas
                        d'importance). Notez que <parameter>nulls</parameter> n'est pas une chaîne
                        de texte. C'est un tableau et, de ce fait, il n'a pas besoin d'un
                        caractère de fin <literal>'\0'</literal>.
                       </para>
                      </listitem>
                     </varlistentry>

                     <varlistentry>
                      <term><literal>bool <parameter>read_only</parameter></literal></term>
                      <listitem>
                       <para>
                        <literal>true</literal> pour une exécution en lecture seule
                       </para>
                      </listitem>
                     </varlistentry>

                     <varlistentry>
                      <term><literal>int <parameter>cursorOptions</parameter></literal></term>
                      <listitem>
                       <para>
                        masque de bits des options du curseur&nbsp;: zéro cause le comportement
                        par défaut
                       </para>
                      </listitem>
                     </varlistentry>
                    </variablelist>
                   </refsect1>

                   <refsect1>
                    <title>Valeur de retour</title>

                    <para>
                     Pointeur du portail contenant le curseur. Notez qu'il n'y a pas de convention
                     pour le renvoi des erreurs&nbsp;; toute erreur sera rapportée par
                     <function>elog</function>.
                    </para>
                   </refsect1>
                  </refentry>

                  <!-- *********************************************** -->

                  <refentry id="spi-spi-cursor-open-with-paramlist">
                   <indexterm><primary>SPI_cursor_open_with_paramlist</primary></indexterm>

                   <refmeta>
                    <refentrytitle>SPI_cursor_open_with_paramlist</refentrytitle>
                    <manvolnum>3</manvolnum>
                   </refmeta>

                   <refnamediv>
                    <refname>SPI_cursor_open_with_paramlist</refname>
                    <refpurpose>ouvre un curseur en utilisant les paramètres</refpurpose>
                   </refnamediv>

                   <refsynopsisdiv>
                    <synopsis>
Portal SPI_cursor_open_with_paramlist(const char *<parameter>name</parameter>,
                                      SPIPlanPtr <parameter>plan</parameter>,
                                      ParamListInfo <parameter>params</parameter>,
                                      bool <parameter>read_only</parameter>)
                    </synopsis>
                   </refsynopsisdiv>

                   <refsect1>
                    <title>Description</title>

                    <para>
                     <function>SPI_cursor_open_with_paramlist</function> prépare un curseur (en
                     interne un portail), qui exécutera une requête préparée par
                     <function>SPI_prepare</function>. Cette fonction est équivalente à
                     <function>SPI_cursor_open</function> sauf que les informations sur les
                     valeurs des paramètres passées à la requête sont présentées différemment.
                     La représentation de <literal>ParamListInfo</literal> peut être utile pour
                     fournir des valeurs déjà disponibles dans ce format. Elle supporte aussi
                     l'utilisation d'ensemble de paramètres dynamiques via des fonctions
                     spécifiées dans <literal>ParamListInfo</literal>.
                    </para>

                    <para>
                     Les données passées en paramètre seront copiées dans le portail du curseur
                     et peuvent donc être libérées alors que le curseur existe toujours.
                    </para>
                   </refsect1>

                   <refsect1>
                    <title>Arguments</title>

                    <variablelist>
                     <varlistentry>
                      <term><literal>const char * <parameter>name</parameter></literal></term>
                      <listitem>
                       <para>
                        nom d'un portail ou <symbol>NULL</symbol> pour que le système en
                        choisisse un lui-même
                       </para>
                      </listitem>
                     </varlistentry>

                     <varlistentry>
                      <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
                      <listitem>
                       <para>
                        requête préparée (renvoyée par <function>SPI_prepare</function>)
                       </para>
                      </listitem>
                     </varlistentry>

                     <varlistentry>
                      <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
                      <listitem>
                       <para>
                        structure de données contenant les types et valeurs de paramètres&nbsp;;
                        NULL sinon
                       </para>
                      </listitem>
                     </varlistentry>

                     <varlistentry>
                      <term><literal>bool <parameter>read_only</parameter></literal></term>
                      <listitem>
                       <para>
                        <literal>true</literal> pour une exécution en lecture seule
                       </para>
                      </listitem>
                     </varlistentry>
                    </variablelist>
                   </refsect1>

                   <refsect1>
                    <title>Valeur de retour</title>

                    <para>
                     Pointeur vers le portail contenant le curseur. Notez qu'il n'existe pas de
                     convention pour le retour d'erreur&nbsp;; toute erreur sera renvoyée via
                     <function>elog</function>.
                    </para>
                   </refsect1>
                  </refentry>

                  <!-- *********************************************** -->

<refentry id="spi-spi-cursor-parse-open">
 <indexterm><primary>SPI_cursor_parse_open</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_cursor_parse_open</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_parse_open</refname>
  <refpurpose>provisionne un curseur en utilisant une requête sous forme chaîne et des paramètres</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
Portal SPI_cursor_parse_open(const char *<parameter>name</parameter>,
                             const char *<parameter>command</parameter>,
                             const SPIParseOpenOptions * <parameter>options</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   La fonction <function>SPI_cursor_parse_open</function> provisionne un
   curseur (en interne, un portail) qui exécutera une requête spécifiée dans
   une chaine. Elle est comparable à l'appel de
   <function>SPI_prepare_cursor</function> suivie de
   <function>SPI_cursor_open_with_paramlist</function>, à l'exception que les
   références des paramètres dans la chaine de la requête sont entièrement
   gérées en fournissant un objet <literal>ParamListInfo</literal>.
  </para>

  <para>
   Pour une exécution unique d'une requête, cette fonction devrait être préférée
   à l'appel de <function>SPI_prepare_cursor</function> suivie par
   <function>SPI_cursor_open_with_paramlist</function>.
   Si la même commande doit être exécutée avec de nombreux paramètres différents,
   l'une ou l'autre méthode pourrait être plus rapide, en fonction du coût de
   recalcul du plan par rapport aux bénéfices des plans personnalisés.
  </para>

  <para>
   L'objet <parameter>options-&gt;params</parameter> doit normalement
   marqué chaque paramètre avec le drapeau <literal>PARAM_FLAG_CONST</literal>,
   comme un plan unique est toujours utilisé par la requête.
  </para>

  <para>
   Le paramètre passée en entrée sera copié dans le portail du curseur, ainsi il
   peut être libéré alors que le curseur existe toujours.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
     <para>
      Nom du portail, ou <symbol>NULL</symbol> pour laisser le système
      choisir un nom
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <para>
      Chaîne de la commande
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const SPIParseOpenOptions * <parameter>options</parameter></literal></term>
    <listitem>
     <para>
      Structure contenant les arguments optionnels
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Les appelants doivent toujours mettre à zéro la structure entière
   <parameter>options</parameter>, puis remplir les champs nécessaires à
   affecter. Ceci assure la compatibilité ascendante du code, comme tout
   champ ajouté à la structure dans le futur sera défini comme
   rétro-compatible s'il est mis à zéro. Les champs de
   <parameter>options</parameter> actuellement disponibles sont&nbsp;:
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
    <listitem>
     <para>
      Structure de données contenant les types et valeurs de paramètres de la
      requête&nbsp;; NULL si aucun
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
     <para>
      Masque de bits entiers des options de curseur&nbsp;; zéro génère le
      comportement par défaut
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <para><literal>true</literal> pour une exécution en lecture seule</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   Pointeur de portail contenant le curseur. Notez qu'il n'y a pas de
   convention de retour d'erreur&nbsp;;
   n'importe quelle erreur sera affichée via <function>elog</function>.
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                  <refentry id="spi-spi-cursor-find">
                   <indexterm><primary>SPI_cursor_find</primary></indexterm>

                   <refmeta>
                    <refentrytitle>SPI_cursor_find</refentrytitle>
                    <manvolnum>3</manvolnum>
                   </refmeta>

                   <refnamediv>
                    <refname>SPI_cursor_find</refname>
                    <refpurpose>recherche un curseur existant par nom</refpurpose>
                   </refnamediv>

                   <refsynopsisdiv>
                    <synopsis>Portal SPI_cursor_find(const char * <parameter>name</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_cursor_find</function> recherche un portail par nom.
   Ceci est principalement utile pour résoudre un nom de curseur renvoyé
   en tant que texte par une autre fonction.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
     <para>
      nom du portail
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   Pointeur vers le portail portant le nom spécifié ou
   <symbol>NULL</symbol> si aucun n'a été trouvé
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                    <refentry id="spi-spi-cursor-fetch">
                     <indexterm><primary>SPI_cursor_fetch</primary></indexterm>

                     <refmeta>
                      <refentrytitle>SPI_cursor_fetch</refentrytitle>
                      <manvolnum>3</manvolnum>
                     </refmeta>

                     <refnamediv>
                      <refname>SPI_cursor_fetch</refname>
                      <refpurpose>extrait des lignes à partir d'un curseur</refpurpose>
                     </refnamediv>

                     <refsynopsisdiv>
                      <synopsis>void SPI_cursor_fetch(Portal <parameter>portal</parameter>, bool <parameter>forward</parameter>, long <parameter>count</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_cursor_fetch</function> extrait des lignes à partir d'un
   curseur. Ceci est équivalent à un sous-ensemble de la commande SQL
   <command>FETCH</command> (voir <function>SPI_scroll_cursor_fetch</function>
   pour plus de détails).
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
     <para>
      portail contenant le curseur
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>forward</parameter></literal></term>
    <listitem>
     <para>
     vrai pour une extraction en avant, faux pour une extraction en arrière
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
      nombre maximum de lignes à récupérer
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   <varname>SPI_processed</varname> et
   <varname>SPI_tuptable</varname> sont positionnés comme dans
   <function>SPI_execute</function> en cas de réussite.
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   Récupérer en sens inverse pourrait échouer si le plan du curseur n'était pas
   créé avec l'option <symbol>CURSOR_OPT_SCROLL</symbol>.
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                      <refentry id="spi-spi-cursor-move">
                       <indexterm><primary>SPI_cursor_move</primary></indexterm>

                       <refmeta>
                        <refentrytitle>SPI_cursor_move</refentrytitle>
                        <manvolnum>3</manvolnum>
                       </refmeta>

                       <refnamediv>
                        <refname>SPI_cursor_move</refname>
                        <refpurpose>déplace un curseur</refpurpose>
                       </refnamediv>

                       <refsynopsisdiv>
                        <synopsis>void SPI_cursor_move(Portal <parameter>portal</parameter>, bool <parameter>forward</parameter>, long <parameter>count</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_cursor_move</function> saute un certain nombre de lignes
   dans un curseur. Ceci est équivalent à un sous-ensemble de la commande SQL
   <command>MOVE</command> (voir <function>SPI_scroll_cursor_move</function>
   pour plus de détails).
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
     <para>
      portail contenant le curseur
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>forward</parameter></literal></term>
    <listitem>
     <para>
      vrai pour un saut en avant, faux pour un saut en arrière
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
      nombre maximum de lignes à déplacer
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   Se déplacer en sens inverse pourrait échouer si le plan du curseur n'a pas
   été créé avec l'option <symbol>CURSOR_OPT_SCROLL</symbol> option.
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                        <refentry id="spi-spi-scroll-cursor-fetch">
                         <indexterm><primary>SPI_scroll_cursor_fetch</primary></indexterm>

                         <refmeta>
                          <refentrytitle>SPI_scroll_cursor_fetch</refentrytitle>
                          <manvolnum>3</manvolnum>
                         </refmeta>

                         <refnamediv>
                          <refname>SPI_scroll_cursor_fetch</refname>
                          <refpurpose>récupère quelques lignes à partir d'un curseur</refpurpose>
                         </refnamediv>

                         <refsynopsisdiv>
                          <synopsis>
void SPI_scroll_cursor_fetch(Portal <parameter>portal</parameter>, FetchDirection <parameter>direction</parameter>, long <parameter>count</parameter>)
                          </synopsis>
                         </refsynopsisdiv>

                         <refsect1>
                          <title>Description</title>

                          <para>
                           <function>SPI_scroll_cursor_fetch</function> récupère quelques lignes à
                           partir d'un curseur. C'est équivalent à la commande SQL <command>FETCH</command>.
                          </para>
                         </refsect1>

                         <refsect1>
                          <title>Arguments</title>

                          <variablelist>
                           <varlistentry>
                            <term><literal>Portal <parameter>portal</parameter></literal></term>
                            <listitem>
                             <para>
                              portail contenant le curseur
                             </para>
                            </listitem>
                           </varlistentry>

                           <varlistentry>
                            <term><literal>FetchDirection <parameter>direction</parameter></literal></term>
                            <listitem>
                             <para>
                              un parmi <symbol>FETCH_FORWARD</symbol>,
                              <symbol>FETCH_BACKWARD</symbol>,
                              <symbol>FETCH_ABSOLUTE</symbol> ou
                              <symbol>FETCH_RELATIVE</symbol>
                             </para>
                            </listitem>
                           </varlistentry>

                           <varlistentry>
                            <term><literal>long <parameter>count</parameter></literal></term>
                            <listitem>
                             <para>
                              nombre de lignes à récupérer pour <symbol>FETCH_FORWARD</symbol> ou
                              <symbol>FETCH_BACKWARD</symbol>&nbsp;; nombre de lignes absolu à récupérer
                              pour <symbol>FETCH_ABSOLUTE</symbol>&nbsp;; ou nombre de lignes relatif
                              à récupérer pour <symbol>FETCH_RELATIVE</symbol>
                             </para>
                            </listitem>
                           </varlistentry>
                          </variablelist>
                         </refsect1>

                         <refsect1>
                          <title>Valeur de retour</title>

                          <para>
                           <varname>SPI_processed</varname> et
                           <varname>SPI_tuptable</varname> sont configurés comme
                           <function>SPI_execute</function> en cas de succès.
                          </para>
                         </refsect1>

                         <refsect1>
                          <title>Notes</title>

                          <para>
                           Voir la commande SQL <xref linkend="sql-fetch"/>
                           pour des détails sur l'interprétation des paramètres
                           <parameter>direction</parameter> et <parameter>count</parameter>.
                          </para>

                          <para>
                           Les valeurs de direction autres que <symbol>FETCH_FORWARD</symbol>
                           peuvent échouer si le plan du curseur n'a pas été créé avec l'option
                           <symbol>CURSOR_OPT_SCROLL</symbol>.
                          </para>
                         </refsect1>
                        </refentry>

                        <!-- *********************************************** -->

                        <refentry id="spi-spi-scroll-cursor-move">
                         <indexterm><primary>SPI_scroll_cursor_move</primary></indexterm>

                         <refmeta>
                          <refentrytitle>SPI_scroll_cursor_move</refentrytitle>
                          <manvolnum>3</manvolnum>
                         </refmeta>

                         <refnamediv>
                          <refname>SPI_scroll_cursor_move</refname>
                          <refpurpose>déplacer un curseur</refpurpose>
                         </refnamediv>

                         <refsynopsisdiv>
                          <synopsis>
void SPI_scroll_cursor_move(Portal <parameter>portal</parameter>, FetchDirection <parameter>direction</parameter>, long <parameter>count</parameter>)
                          </synopsis>
                         </refsynopsisdiv>

                         <refsect1>
                          <title>Description</title>

                          <para>
                           <function>SPI_scroll_cursor_move</function> ignore un certain nombre de
                           lignes dans un curseur. C'est l'équivalent de la commande SQL
                           <command>MOVE</command>.
                          </para>
                         </refsect1>

                         <refsect1>
                          <title>Arguments</title>

                          <variablelist>
                           <varlistentry>
                            <term><literal>Portal <parameter>portal</parameter></literal></term>
                            <listitem>
                             <para>
                              portail contenant le curseur
                             </para>
                            </listitem>
                           </varlistentry>

                           <varlistentry>
                            <term><literal>FetchDirection <parameter>direction</parameter></literal></term>
                            <listitem>
                             <para>
                              un parmi <symbol>FETCH_FORWARD</symbol>,
                              <symbol>FETCH_BACKWARD</symbol>,
                              <symbol>FETCH_ABSOLUTE</symbol> et
                              <symbol>FETCH_RELATIVE</symbol>
                             </para>
                            </listitem>
                           </varlistentry>

                           <varlistentry>
                            <term><literal>long <parameter>count</parameter></literal></term>
                            <listitem>
                             <para>
                              nombre de lignes à déplacer pour <symbol>FETCH_FORWARD</symbol> ou
                              <symbol>FETCH_BACKWARD</symbol>&nbsp;; nombre de lignes absolu à déplacer
                              pour <symbol>FETCH_ABSOLUTE</symbol>&nbsp;; ou nombre de lignes relatif
                              à déplacer pour <symbol>FETCH_RELATIVE</symbol>
                             </para>
                            </listitem>
                           </varlistentry>
                          </variablelist>
                         </refsect1>

                         <refsect1>
                          <title>Valeur de retour</title>

                          <para>
                           <varname>SPI_processed</varname> est configuré comme
                           <function>SPI_execute</function> en cas de succès.
                           <varname>SPI_tuptable</varname> est configuré à <symbol>NULL</symbol> car
                           aucune ligne n'est renvoyée par cette fonction.
                          </para>
                         </refsect1>

                         <refsect1>
                          <title>Notes</title>

                          <para>
                           Voir la commande SQL <xref linkend="sql-fetch"/>
                           pour des détails sur l'interprétation des paramètres
                           <parameter>direction</parameter> et <parameter>count</parameter>.
                          </para>

                          <para>
                           Les valeurs de direction autres que <symbol>FETCH_FORWARD</symbol> peuvent
                           échouer si le plan du curseur n'a pas été créé avec l'option
                           <symbol>CURSOR_OPT_SCROLL</symbol>.
                          </para>
                         </refsect1>
                        </refentry>

                        <!-- *********************************************** -->

                        <refentry id="spi-spi-cursor-close">
                         <indexterm><primary>SPI_cursor_close</primary></indexterm>

                         <refmeta>
                          <refentrytitle>SPI_cursor_close</refentrytitle>
                          <manvolnum>3</manvolnum>
                         </refmeta>

                         <refnamediv>
                          <refname>SPI_cursor_close</refname>
                          <refpurpose>ferme un curseur</refpurpose>
                         </refnamediv>

                         <refsynopsisdiv>
                          <synopsis>void SPI_cursor_close(Portal <parameter>portal</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_cursor_close</function> ferme un curseur créé précédemment
   et libère la mémoire du portail.
  </para>

  <para>
   Tous les curseurs ouverts sont fermés automatiquement à la fin de la
   transaction. <function>SPI_cursor_close</function> n'a besoin d'être
   invoqué que s'il est désirable de libérer les ressources plus tôt.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
     <para>
      portail contenant le curseur
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                          <refentry id="spi-spi-keepplan">
                           <indexterm><primary>SPI_keepplan</primary></indexterm>

                           <refmeta>
                            <refentrytitle>SPI_keepplan</refentrytitle>
                            <manvolnum>3</manvolnum>
                           </refmeta>

                           <refnamediv>
                            <refname>SPI_keepplan</refname>
                            <refpurpose>sauvegarde une instruction préparée</refpurpose>
                           </refnamediv>

                           <refsynopsisdiv>
                            <synopsis>
int SPI_keepplan(SPIPlanPtr <parameter>plan</parameter>)
                            </synopsis>
                           </refsynopsisdiv>

                           <refsect1>
                            <title>Description</title>

                            <para>
                             <function>SPI_keepplan</function> sauvegarde une instruction passée (préparée
                             par <function>SPI_prepare</function>) pour qu'elle ne soit pas libérée par
                             <function>SPI_finish</function> ou par le gestionnaire des transactions.
                             Cela vous donne la possibilité de ré-utiliser les instructions préparées dans
                             les prochains appels à votre fonction C dans la session courante.
                            </para>
                           </refsect1>

                           <refsect1>
                            <title>Arguments</title>

                            <variablelist>
                             <varlistentry>
                              <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
                              <listitem>
                               <para>
                                l'instruction préparée à sauvegarder
                               </para>
                              </listitem>
                             </varlistentry>
                            </variablelist>
                           </refsect1>

                           <refsect1>
                            <title>Valeur de retour</title>

                            <para>
                             0 en cas de succès&nbsp;;
                             <symbol>SPI_ERROR_ARGUMENT</symbol> si <parameter>plan</parameter>
                             vaut <symbol>NULL</symbol> ou est invalide
                            </para>
                           </refsect1>

                           <refsect1>
                            <title>Notes</title>

                            <para>
                             L'instruction passée est relocalisée dans un stockage permanent par
                             l'ajustement de pointeur (pas de copie de données requise). Si vous souhaitez
                             la supprimer plus tard, utilisez <function>SPI_freeplan</function>.
                            </para>
                           </refsect1>
                          </refentry>

                          <!-- *********************************************** -->

                          <refentry id="spi-spi-saveplan">
                           <indexterm><primary>SPI_saveplan</primary></indexterm>

                           <refmeta>
                            <refentrytitle>SPI_saveplan</refentrytitle>
                            <manvolnum>3</manvolnum>
                           </refmeta>

                           <refnamediv>
                            <refname>SPI_saveplan</refname>
                            <refpurpose>sauvegarde une requête préparée</refpurpose>
                           </refnamediv>

                           <refsynopsisdiv>
                            <synopsis>SPIPlanPtr SPI_saveplan(SPIPlanPtr <parameter>plan</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_saveplan</function> copie une instruction passée (préparée par
   <function>SPI_prepare</function>) en mémoire qui ne serait pas libérée par
   <function>SPI_finish</function> ou par le gestionnaire de transactions, et
   renvoie un pointeur vers l'instruction copiée. Cela vous donne la possibilité
   de réutiliser des instructions préparées dans les appels suivants de votre
   fonction C dans la session courante.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
      la requête préparée à sauvegarder
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   Pointeur vers la requête copiée&nbsp;; <symbol>NULL</symbol> en cas d'échec.
   En cas d'erreur, <varname>SPI_result</varname> est positionnée comme
   suit&nbsp;:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       si <parameter>plan</parameter> est <symbol>NULL</symbol> ou invalide
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       si appelé d'une fonction C non connectée
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   La requête passée n'est pas libérée, donc vous pouvez souhaiter exécuter
   <function>SPI_freeplan</function> sur ce dernier pour éviter des pertes
   mémoire jusqu'à <function>SPI_finish</function>.
  </para>

  <para>
   Dans la plupart des cas, <function>SPI_keepplan</function> est préférée à
   cette fonction car elle accomplit largement le même résultat sans avoir
   besoin de copier physiquement la structure de données des instructions
   préparées.
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                            <refentry id="spi-spi-register-relation">
                             <indexterm><primary>SPI_register_relation</primary></indexterm>

                             <indexterm>
                              <primary>relation nommée éphémère</primary>
                              <secondary>s'enregistre auprès de SPI</secondary>
                             </indexterm>

                             <refmeta>
                              <refentrytitle>SPI_register_relation</refentrytitle>
                              <manvolnum>3</manvolnum>
                             </refmeta>

                             <refnamediv>
                              <refname>SPI_register_relation</refname>
                              <refpurpose>rend une relation nommée éphémère disponible par son nom dans les requêtes SPI</refpurpose>
                             </refnamediv>

                             <refsynopsisdiv>
                              <synopsis>
int SPI_register_relation(EphemeralNamedRelation <parameter>enr</parameter>)
                              </synopsis>
                             </refsynopsisdiv>

                             <refsect1>
                              <title>Description</title>

                              <para>
                               <function>SPI_register_relation</function> rends une relation nommée éphémère
                               - tout comme son information associée - disponible aux requêtes
                               planifiées et exécutées par la connexion SPI en cours.
                              </para>
                             </refsect1>

                             <refsect1>
                              <title>Arguments</title>

                              <variablelist>
                               <varlistentry>
                                <term><literal>EphemeralNamedRelation <parameter>enr</parameter></literal></term>
                                <listitem>
                                 <para>
                                  l'entrée du registre de la relation nommée éphémère
                                 </para>
                                </listitem>
                               </varlistentry>
                              </variablelist>
                             </refsect1>

                             <refsect1>
                              <title>Valeur de retour</title>

                              <para>
                               Si l'exécution de la commande a réussi, alors la valeur (non négative)
                               suivante sera retournée&nbsp;:
                               <variablelist>
                                <varlistentry>
                                 <term><symbol>SPI_OK_REL_REGISTER</symbol></term>
                                 <listitem>
                                  <para>
                                   si la relation a bien été enregistrée avec succès par son nom
                                  </para>
                                 </listitem>
                                </varlistentry>
                               </variablelist>
                              </para>

                              <para>
                               En cas d'erreur, une des valeurs négatives suivantes sera retournée&nbsp;:

                               <variablelist>
                                <varlistentry>
                                 <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
                                 <listitem>
                                  <para>
                                   si <parameter>enr</parameter> est <symbol>NULL</symbol> ou si son champ
                                   <varname>name</varname> est <symbol>NULL</symbol>
                                  </para>
                                 </listitem>
                                </varlistentry>

                                <varlistentry>
                                 <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
                                 <listitem>
                                  <para>
                                   en cas d'appel par une fonction C non connectée
                                  </para>
                                 </listitem>
                                </varlistentry>

                                <varlistentry>
                                 <term><symbol>SPI_ERROR_REL_DUPLICATE</symbol></term>
                                 <listitem>
                                  <para>
                                   si le nom spécifié dans le champ <varname>name</varname> de
                                   <parameter>enr</parameter> est déjà enregistré pour cette connexion
                                  </para>
                                 </listitem>
                                </varlistentry>
                               </variablelist>
                              </para>
                             </refsect1>
                            </refentry>

                            <!-- *********************************************** -->

                            <refentry id="spi-spi-unregister-relation">
                             <indexterm><primary>SPI_unregister_relation</primary></indexterm>

                             <indexterm>
                              <primary>relation nommée éphémère</primary>
                              <secondary>désinscription de SPI</secondary>
                             </indexterm>

                             <refmeta>
                              <refentrytitle>SPI_unregister_relation</refentrytitle>
                              <manvolnum>3</manvolnum>
                             </refmeta>

                             <refnamediv>
                              <refname>SPI_unregister_relation</refname>
                              <refpurpose>supprime une relation nommée éphémère du registre</refpurpose>
                             </refnamediv>

                             <refsynopsisdiv>
                              <synopsis>
int SPI_unregister_relation(const char * <parameter>name</parameter>)
                              </synopsis>
                             </refsynopsisdiv>

                             <refsect1>
                              <title>Description</title>

                              <para>
                               <function>SPI_unregister_relation</function> supprime une relation nommée
                               éphémère du registre pour la connexion courante
                              </para>
                             </refsect1>

                             <refsect1>
                              <title>Arguments</title>

                              <variablelist>
                               <varlistentry>
                                <term><literal>const char * <parameter>name</parameter></literal></term>
                                <listitem>
                                 <para>
                                  le nom de l'entrée du registre de la relation
                                 </para>
                                </listitem>
                               </varlistentry>
                              </variablelist>
                             </refsect1>

                             <refsect1>
                              <title>Valeur de retour</title>

                              <para>
                               Si l'exécution de la commande a été réussie, alors la valeur (non négative)
                               suivante sera retournée&nbsp;:

                               <variablelist>
                                <varlistentry>
                                 <term><symbol>SPI_OK_REL_UNREGISTER</symbol></term>
                                 <listitem>
                                  <para>
                                   si le tuplestore a été correctement supprimé du registre
                                  </para>
                                 </listitem>
                                </varlistentry>
                               </variablelist>
                              </para>

                              <para>
                               En cas d'erreur, une valeur négative sera retournée, parmi&nbsp;:

                               <variablelist>
                                <varlistentry>
                                 <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
                                 <listitem>
                                  <para>
                                   si <parameter>name</parameter> est <symbol>NULL</symbol>
                                  </para>
                                 </listitem>
                                </varlistentry>

                                <varlistentry>
                                 <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
                                 <listitem>
                                  <para>
                                   si appelé par une fonction C non connectée
                                  </para>
                                 </listitem>
                                </varlistentry>

                                <varlistentry>
                                 <term><symbol>SPI_ERROR_REL_NOT_FOUND</symbol></term>
                                 <listitem>
                                  <para>
                                   si <parameter>name</parameter> est absent du registre pour la connexion
                                   courante
                                  </para>
                                 </listitem>
                                </varlistentry>
                               </variablelist>
                              </para>
                             </refsect1>
                            </refentry>

                            <!-- *********************************************** -->

                            <refentry id="spi-spi-register-trigger-data">
                             <indexterm><primary>SPI_register_trigger_data</primary></indexterm>

                             <indexterm>
                              <primary>relation nommée éphémère</primary>
                              <secondary>s'enregistre auprès de SPI</secondary>
                             </indexterm>

                             <indexterm>
                              <primary>tables de transition</primary>
                              <secondary>implémentation en PL</secondary>
                             </indexterm>

                             <refmeta>
                              <refentrytitle>SPI_register_trigger_data</refentrytitle>
                              <manvolnum>3</manvolnum>
                             </refmeta>

                             <refnamediv>
                              <refname>SPI_register_trigger_data</refname>
                              <refpurpose>rends les données de triggers disponibles dans les requêtes SPI</refpurpose>
                             </refnamediv>

                             <refsynopsisdiv>
                              <synopsis>
int SPI_register_trigger_data(TriggerData *<parameter>tdata</parameter>)
                              </synopsis>
                             </refsynopsisdiv>

                             <refsect1>
                              <title>Description</title>

                              <para>
                               Avec <function>SPI_register_trigger_data</function>, toutes les relations
                               éphémères capturées par un trigger sont disponibles pour les requêtes
                               planifiées et exécutées par la connexion SPI courante. Actuellement, cela
                               concerne les tables de transition capturées par un trigger <literal>AFTER</literal>
                               défini avec une clause <literal>REFERENCING OLD/NEW TABLE AS</literal> ...
                               Cette fonction doit être appelée par une fonction PL de gestion de trigger
                               après connexion.
                              </para>
                             </refsect1>

                             <refsect1>
                              <title>Arguments</title>

                              <variablelist>
                               <varlistentry>
                                <term><literal>TriggerData *<parameter>tdata</parameter></literal></term>
                                <listitem>
                                 <para>
                                  L'objet <structname>TriggerData</structname> passé à une fonction de
                                  gestion de trigger en tant que <literal>fcinfo->context</literal>
                                 </para>
                                </listitem>
                               </varlistentry>
                              </variablelist>
                             </refsect1>

                             <refsect1>
                              <title>Valeur de retour</title>

                              <para>
                               Si l'exécution de la commande est réussie, alors la valeur (non négative)
                               suivante sera retournée&nbsp;:

                               <variablelist>
                                <varlistentry>
                                 <term><symbol>SPI_OK_TD_REGISTER</symbol></term>
                                 <listitem>
                                  <para>
                                   si les données capturées par le trigger (s'il y en a) ont été
                                   correctement enregistrées
                                  </para>
                                 </listitem>
                                </varlistentry>
                               </variablelist>
                              </para>

                              <para>
                               En cas d'erreur, une valeur négative sera retournée, parmi&nbsp;:

                               <variablelist>
                                <varlistentry>
                                 <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
                                 <listitem>
                                  <para>
                                   si <parameter>tdata</parameter> est <symbol>NULL</symbol>
                                  </para>
                                 </listitem>
                                </varlistentry>

                                <varlistentry>
                                 <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
                                 <listitem>
                                  <para>
                                   si appelé par une fonction C non connectée
                                  </para>
                                 </listitem>
                                </varlistentry>

                                <varlistentry>
                                 <term><symbol>SPI_ERROR_REL_DUPLICATE</symbol></term>
                                 <listitem>
                                  <para>
                                   si le nom d'une relation éphémère de données de trigger est déjà
                                   enregistré pour cette connexion
                                  </para>
                                 </listitem>
                                </varlistentry>
                               </variablelist>
                              </para>
                             </refsect1>
                            </refentry>

                            <!-- *********************************************** -->


                           </sect1>

                           <sect1 id="spi-interface-support">
                            <title>Fonctions de support d'interface</title>

                            <para>
                             Les fonctions décrites ici donnent une interface pour extraire
                             les informations des séries de résultats renvoyés par <function>SPI_execute</function> et
                             les autres fonctions SPI.
                            </para>

                            <para>
                             Toutes les fonctions décrites dans cette section peuvent être utilisées par
                             toutes les fonctions C, connectées et non connectées.
                            </para>

                            <!-- *********************************************** -->

                            <refentry id="spi-spi-fname">
                             <indexterm><primary>SPI_fname</primary></indexterm>

                             <refmeta>
                              <refentrytitle>SPI_fname</refentrytitle>
                              <manvolnum>3</manvolnum>
                             </refmeta>

                             <refnamediv>
                              <refname>SPI_fname</refname>
                              <refpurpose>détermine le nom de colonne pour le numéro de colonne
                               spécifié</refpurpose>
                             </refnamediv>

                             <refsynopsisdiv>
                              <synopsis>char * SPI_fname(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_fname</function> retourne une copie du nom de colonne d'une
   colonne spécifiée (vous pouvez utiliser <function>pfree</function> pour
   libérer la copie du nom lorsque vous n'en avez plus besoin).
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
      description de rangée d'entrée
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <para>
      nombre de colonne (le compte commence à 1)
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   Le nom de colonne&nbsp;; <symbol>NULL</symbol> si
   <parameter>colnumber</parameter> est hors de portée.
   <varname>SPI_result</varname> est positionnée à
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol> en cas d'échec.
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                              <refentry id="spi-spi-fnumber">
                               <indexterm><primary>SPI_fnumber</primary></indexterm>

                               <refmeta>
                                <refentrytitle>SPI_fnumber</refentrytitle>
                                <manvolnum>3</manvolnum>
                               </refmeta>

                               <refnamediv>
                                <refname>SPI_fnumber</refname>
                                <refpurpose>détermine le numéro de colonne pour le nom de colonne
                                 spécifiée</refpurpose>
                               </refnamediv>

                               <refsynopsisdiv>
                                <synopsis>int SPI_fnumber(TupleDesc <parameter>rowdesc</parameter>, const char * <parameter>colname</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_fnumber</function> renvoie le numéro de colonne pour la
   colonne portant le nom spécifié.
  </para>

  <para>
   Si <parameter>colname</parameter> réfère à une colonne système
   (c'est-à-dire <literal>ctid</literal>), alors le numéro de colonne négatif approprié
   sera renvoyé. L'appelant devra faire attention à tester la valeur de retour
   pour égalité exacte à <symbol>SPI_ERROR_NOATTRIBUTE</symbol> pour
   détecter une erreur&nbsp;; tester le résultat pour une valeur inférieure ou
   égale à 0 n'est pas correcte sauf si les colonnes systèmes doivent être
   rejetées.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
      description de la rangée d'entrée
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char *
     <parameter>colname</parameter></literal></term>
    <listitem>
     <para>
      nom de colonne
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   Numéro de colonne (le compte commence à 1 pour les colonnes utilisateurs) ou
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol> si la colonne nommée n'est pas
   trouvée.
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                                <refentry id="spi-spi-getvalue">
                                 <indexterm><primary>SPI_getvalue</primary></indexterm>

                                 <refmeta>
                                  <refentrytitle>SPI_getvalue</refentrytitle>
                                  <manvolnum>3</manvolnum>
                                 </refmeta>

                                 <refnamediv>
                                  <refname>SPI_getvalue</refname>
                                  <refpurpose>renvoie la valeur de chaîne de la colonne spécifiée</refpurpose>
                                 </refnamediv>

                                 <refsynopsisdiv>
                                  <synopsis>char * SPI_getvalue(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_getvalue</function> retourne la représentation chaîne
   de la valeur de la colonne spécifiée.
  </para>

  <para>
   Le résultat est retourné en mémoire allouée en utilisant
   <function>palloc</function> (vous pouvez utiliser
   <function>pfree</function> pour libérer la mémoire lorsque vous n'en avez
   plus besoin).
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <para>
      ligne d'entrée à examiner
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
      description de la ligne en entrée
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <para>
      numéro de colonne (le compte commence à 1)
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   Valeur de colonne ou <symbol>NULL</symbol> si la colonne est NULL,
   si <parameter>colnumber</parameter> est hors de portée
   (<varname>SPI_result</varname> est positionnée à
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>) ou si aucune fonction de sortie
   n'est disponible (<varname>SPI_result</varname> est positionnée à
   <symbol>SPI_ERROR_NOOUTFUNC</symbol>).
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                                  <refentry id="spi-spi-getbinval">
                                   <indexterm><primary>SPI_getbinval</primary></indexterm>

                                   <refmeta>
                                    <refentrytitle>SPI_getbinval</refentrytitle>
                                    <manvolnum>3</manvolnum>
                                   </refmeta>

                                   <refnamediv>
                                    <refname>SPI_getbinval</refname>
                                    <refpurpose>retourne la valeur binaire de la colonne spécifiée</refpurpose>
                                   </refnamediv>

                                   <refsynopsisdiv>
                                    <synopsis>Datum SPI_getbinval(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>, bool * <parameter>isNULL</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_getbinval</function> retourne la valeur de la
   colonne spécifiée dans le format interne (en tant que type
   <type>Datum</type>).
  </para>

  <para>
   Cette fonction n'alloue pas de nouvel espace pour le datum. Dans le
   cas d'un type de données passé par référence, la valeur de retour sera un
   pointeur dans la ligne passée.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <para>
      ligne d'entrée à examiner
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
      description de la ligne d'entrée
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <para>
      numéro de colonne (le compte commence à 1)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool * <parameter>isNULL</parameter></literal></term>
    <listitem>
     <para>
      indique une valeur NULL dans la colonne
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   La valeur binaire de la colonne est retournée. La variable vers laquelle
   pointe <parameter>isNULL</parameter> est positionnée à vrai si la colonne
   est NULL et sinon à faux.
  </para>

  <para>
   <varname>SPI_result</varname> est positionnée à
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol> en cas d'erreur.
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                                    <refentry id="spi-spi-gettype">
                                     <indexterm><primary>SPI_gettype</primary></indexterm>

                                     <refmeta>
                                      <refentrytitle>SPI_gettype</refentrytitle>
                                      <manvolnum>3</manvolnum>
                                     </refmeta>

                                     <refnamediv>
                                      <refname>SPI_gettype</refname>
                                      <refpurpose>retourne le nom du type de donnée de la colonne
                                       spécifiée</refpurpose>
                                     </refnamediv>

                                     <refsynopsisdiv>
                                      <synopsis>char * SPI_gettype(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_gettype</function> retourne une copie du nom du type de donnée de la
   colonne spécifiée (vous pouvez utiliser <function>pfree</function> pour
   libérer la copie du nom lorsque vous n'en avez plus besoin).
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
      description de ligne d'entrée
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <para>
      numéro de colonne (le compte commence à 1)
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   Le nom de type de donnée de la colonne spécifiée ou
   <symbol>NULL</symbol> en cas d'erreur.  <varname>SPI_result</varname> est
   positionnée à <symbol>SPI_ERROR_NOATTRIBUTE</symbol> en cas d'erreur.
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                                      <refentry id="spi-spi-gettypeid">
                                       <indexterm><primary>SPI_gettypeid</primary></indexterm>

                                       <refmeta>
                                        <refentrytitle>SPI_gettypeid</refentrytitle>
                                        <manvolnum>3</manvolnum>
                                       </refmeta>

                                       <refnamediv>
                                        <refname>SPI_gettypeid</refname>
                                        <refpurpose>retourne l'<acronym>OID</acronym> de type de donnée de la colonne
                                         spécifiée</refpurpose>
                                       </refnamediv>

                                       <refsynopsisdiv>
                                        <synopsis>Oid SPI_gettypeid(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_gettypeid</function> retourne
   l'<acronym>OID</acronym> du type de donnée de la colonne spécifiée.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
      description de ligne d'entrée
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <para>
      numéro de colonne (le compte commence à 1)
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   L'<acronym>OID</acronym> du type de donnée de la colonne spécifiée
   ou <symbol>InvalidOid</symbol> en cas d'erreur. En cas d'erreur,
   <varname>SPI_result</varname> est positionnée à
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>.
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                                        <refentry id="spi-spi-getrelname">
                                         <indexterm><primary>SPI_getrelname</primary></indexterm>

                                         <refmeta>
                                          <refentrytitle>SPI_getrelname</refentrytitle>
                                          <manvolnum>3</manvolnum>
                                         </refmeta>

                                         <refnamediv>
                                          <refname>SPI_getrelname</refname>
                                          <refpurpose>retourne le nom de la relation spécifiée</refpurpose>
                                         </refnamediv>

                                         <refsynopsisdiv>
                                          <synopsis>char * SPI_getrelname(Relation <parameter>rel</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>


  <para>
   <function>SPI_getrelname</function> retourne une copie du nom de la
   relation spécifiée (vous pouvez utiliser <function>pfree</function> pour
   libérer la copie du nom lorsque vous n'en avez plus besoin).
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>Relation <parameter>rel</parameter></literal></term>
    <listitem>
     <para>
      relation d'entrée
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   Le nom de la relation spécifiée.
  </para>
 </refsect1>
</refentry>

<refentry id="spi-spi-getnspname">
 <indexterm><primary>SPI_getnspname</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_getnspname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getnspname</refname>
  <refpurpose>renvoie l'espace de noms de la relation spécifiée</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>char * SPI_getnspname(Relation <parameter>rel</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_getnspname</function> renvoie une copie du nom de l'espace de
   nom auquel appartient la <structname>Relation</structname> spécifiée. Ceci
   est équivalent au schéma de la relation. Vous devriez libérer
   (<function>pfree</function>) la valeur de retour de cette fonction lorsque
   vous en avez fini avec elle.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>Relation <parameter>rel</parameter></literal></term>
    <listitem>
     <para>
      relation en entrée
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   Le nom de l'espace de noms de la relation spécifiée.
  </para>
 </refsect1>
</refentry>

<refentry id="spi-spi-result-code-string">
 <indexterm><primary>SPI_result_code_string</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_result_code_string</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_result_code_string</refname>
  <refpurpose>renvoie un code d'erreur sous la forme d'une chaîne de caractères</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
const char * SPI_result_code_string(int <parameter>code</parameter>);
                                          </synopsis>
                                         </refsynopsisdiv>

                                         <refsect1>
                                          <title>Description</title>

                                          <para>
                                           <function>SPI_result_code_string</function> renvoie une chaîne contenant la
                                           représentation du code résultat renvoyé par différentes fonctions ou
                                           procédures SPI dans <varname>SPI_result</varname>.
                                          </para>
                                         </refsect1>

                                         <refsect1>
                                          <title>Arguments</title>

                                          <variablelist>
                                           <varlistentry>
                                            <term><literal>int <parameter>code</parameter></literal></term>
                                            <listitem>
                                             <para>
                                              code résultat
                                             </para>
                                            </listitem>
                                           </varlistentry>
                                          </variablelist>
                                         </refsect1>

                                         <refsect1>
                                          <title>Valeur de retour</title>

                                          <para>
                                           Une chaîne représentant le code résultat.
                                          </para>
                                         </refsect1>
                                        </refentry>

                                       </sect1>

                                       <sect1 id="spi-memory">
                                        <title>Gestion de la mémoire</title>

                                        <para>
                                         <indexterm>
                                          <primary>contexte mémoire</primary>
                                          <secondary>dans SPI</secondary>
                                         </indexterm>
                                         <productname>PostgreSQL</productname> alloue de la mémoire dans des
                                         <firstterm>contextes mémoire</firstterm> qui
                                         donnent une méthode pratique pour
                                         gérer les allocations faites dans plusieurs endroits qui ont besoin de
                                         vivre pour des durées différentes. Détruire un contexte libère
                                         toute la mémoire qui y était allouée. Donc, il n'est pas nécessaire
                                         de garder la trace des objets individuels pour éviter les fuites de
                                         mémoire&nbsp;; à la place,
                                         seul un petit nombre de contextes doivent être gérés.
                                         <function>palloc</function> et les fonctions liées allouent de la mémoire
                                         du contexte <quote>courant</quote>.
                                        </para>

                                        <para>
                                         <function>SPI_connect</function> crée un nouveau contexte mémoire et
                                         le rend courant. <function>SPI_finish</function> restaure le
                                         contexte mémoire précédant et détruit le contexte créé par
                                         <function>SPI_connect</function>. Ces actions garantissent que les
                                         allocations temporaires de mémoire faites dans votre fonction C soient
                                         réclamées lors de la sortie de la fonction C, évitant les fuites de mémoire.
                                        </para>

                                        <para>
                                         En revanche, si votre fonction C a besoin de renvoyer un objet dans de la
                                         mémoire allouée (tel que la valeur d'un type de donné passé par référence),
                                         vous ne pouvez pas allouer cette mémoire en utilisant
                                         <function>palloc</function>, au
                                         moins pas tant que vous êtes connecté à SPI. Si vous essayez, l'objet
                                         sera désalloué par <function>SPI_finish</function> et votre fonction C
                                         ne fonctionnera pas de manière fiable. Pour résoudre ce problème, utilisez
                                         <function>SPI_palloc</function> pour allouer de la mémoire pour votre objet
                                         de retour. <function>SPI_palloc</function> alloue de la mémoire dans le
                                         <quote>contexte de mémoire courant</quote>, c'est-à-dire le contexte de
                                         mémoire qui était courant lorsque <function>SPI_connect</function> a été
                                         appelée, ce qui est précisément le bon contexte pour une valeur renvoyée à
                                         partir de votre fonction C. Plusieurs autres procédures utilitaires décrites
                                         dans cette section renvoient également des objets créés dans le contexte
                                         mémoire de l'appelant.
                                        </para>

                                        <para>
                                         Quand <function>SPI_connect</function> est appelée, le contexte
                                         privé de la fonction C, qui est créé par
                                         <function>SPI_connect</function>, est nommé le contexte courant. Toute
                                         allocation faîte par <function>palloc</function>,
                                         <function>repalloc</function> ou une fonction utilitaire SPI (à part celles
                                         décrites dans cette section) sont faites dans ce contexte. Quand une
                                         fonction C se déconnecte du gestionnaire SPI (via
                                         <function>SPI_finish</function>), le contexte courant est restauré au
                                         contexte de mémoire courant et toutes les allocations faites dans
                                         le contexte de mémoire de la fonction C sont libérées et ne peuvent plus être
                                         utilisées.
                                        </para>

                                        <!-- *********************************************** -->

                                        <refentry id="spi-spi-palloc">
                                         <indexterm><primary>SPI_palloc</primary></indexterm>

                                         <refmeta>
                                          <refentrytitle>SPI_palloc</refentrytitle>
                                          <manvolnum>3</manvolnum>
                                         </refmeta>

                                         <refnamediv>
                                          <refname>SPI_palloc</refname>
                                          <refpurpose>alloue de la mémoire dans le contexte de mémoire
                                           courant</refpurpose>
                                         </refnamediv>

                                         <refsynopsisdiv>
                                          <synopsis>void * SPI_palloc(Size <parameter>size</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_palloc</function> alloue de la mémoire dans le contexte
   de mémoire courant.
  </para>

  <para>
   Cette fonction peut seulement être utilisée durant une connexion SPI.
   Sinon, elle renvoie une erreur.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>Size <parameter>size</parameter></literal></term>
    <listitem>
     <para>
      taille en octets du stockage à allouer
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   Pointeur vers le nouvel espace de stockage de la taille spécifiée
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                                          <refentry id="spi-realloc">
                                           <indexterm><primary>SPI_repalloc</primary></indexterm>

                                           <refmeta>
                                            <refentrytitle>SPI_repalloc</refentrytitle>
                                            <manvolnum>3</manvolnum>
                                           </refmeta>

                                           <refnamediv>
                                            <refname>SPI_repalloc</refname>
                                            <refpurpose>ré-alloue de la mémoire dans le contexte de mémoire
                                             courant</refpurpose>
                                           </refnamediv>

                                           <refsynopsisdiv>
                                            <synopsis>void * SPI_repalloc(void * <parameter>pointer</parameter>, Size <parameter>size</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_repalloc</function> change la taille d'un segment de mémoire
   alloué auparavant en utilisant <function>SPI_palloc</function>.
  </para>

  <para>
   Cette fonction n'est plus différente du <function>repalloc</function>
   standard. Elle n'est gardée que pour la compatibilité
   du code existant.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>void * <parameter>pointer</parameter></literal></term>
    <listitem>
     <para>
      pointeur vers l'espace de stockage à modifier
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Size <parameter>size</parameter></literal></term>
    <listitem>
     <para>
      taille en octets du stockage à allouer
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   Pointeur vers le nouvel espace de stockage de taille spécifiée avec le
   contenu copié de l'espace existant
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                                            <refentry id="spi-spi-pfree">
                                             <indexterm><primary>SPI_pfree</primary></indexterm>

                                             <refmeta>
                                              <refentrytitle>SPI_pfree</refentrytitle>
                                              <manvolnum>3</manvolnum>
                                             </refmeta>

                                             <refnamediv>
                                              <refname>SPI_pfree</refname>
                                              <refpurpose>libère de la mémoire dans le contexte de mémoire
                                               courant</refpurpose>
                                             </refnamediv>

                                             <refsynopsisdiv>
                                              <synopsis>void SPI_pfree(void * <parameter>pointer</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_pfree</function> libère de la mémoire allouée auparavant
   par <function>SPI_palloc</function> ou
   <function>SPI_repalloc</function>.
  </para>

  <para>
   Cette fonction n'est plus différente du <function>pfree</function>
   standard. Elle n'est conservée que pour la compatibilité
   du code existant.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>void * <parameter>pointer</parameter></literal></term>
    <listitem>
     <para>
      pointeur vers l'espace de stockage à libérer
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                                              <refentry id="spi-spi-copytuple">
                                               <indexterm><primary>SPI_copytuple</primary></indexterm>

                                               <refmeta>
                                                <refentrytitle>SPI_copytuple</refentrytitle>
                                                <manvolnum>3</manvolnum>
                                               </refmeta>

                                               <refnamediv>
                                                <refname>SPI_copytuple</refname>
                                                <refpurpose>effectue une copie d'une ligne dans le contexte de mémoire
                                                 courant</refpurpose>
                                               </refnamediv>

                                               <refsynopsisdiv>
                                                <synopsis>HeapTuple SPI_copytuple(HeapTuple <parameter>row</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_copytuple</function> crée une copie d'une ligne dans le
   contexte de mémoire courant. Ceci est normalement utilisé pour renvoyer une
   ligne modifiée à partir d'un déclencheur. Dans une fonction déclarée pour
   renvoyer un type composite, utilisez <function>SPI_returntuple</function> à
   la place.
  </para>

  <para>
   Cette fonction peut seulement être utilisée durant une connexion SPI.
   Sinon, elle renvoie NULL et affecte <symbol>SPI_ERROR_UNCONNECTED</symbol>
   à <varname>SPI_result</varname>.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <para>
      ligne à copier
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   la ligne copiée ou <symbol>NULL</symbol> en cas d'erreur
   (voir <varname>SPI_result</varname> pour une indication sur l'erreur)
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                                                <refentry id="spi-spi-returntuple">
                                                 <indexterm><primary>SPI_returntuple</primary></indexterm>

                                                 <refmeta>
                                                  <refentrytitle>SPI_returntuple</refentrytitle>
                                                  <manvolnum>3</manvolnum>
                                                 </refmeta>

                                                 <refnamediv>
                                                  <refname>SPI_returntuple</refname>
                                                  <refpurpose>prépare le renvoi d'une ligne en tant que Datum</refpurpose>
                                                 </refnamediv>

                                                 <refsynopsisdiv>
                                                  <synopsis>HeapTupleHeader SPI_returntuple(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>)</synopsis>
  </refsynopsisdiv>

  <refsect1>
    <title>Description</title>

    <para>
      <function>SPI_returntuple</function> crée une copie d'une ligne dans
      le contexte de l'exécuteur supérieur, la renvoyant sous la forme d'une
      ligne de type <type>Datum</type>. Le pointeur renvoyé a seulement besoin
      d'être converti en <type>Datum</type> via
      <function>PointerGetDatum</function> avant d'être renvoyé.
    </para>

    <para>
   Cette fonction ne peut être utilisée que pendant une connexion SPI.
   Sinon, elle renvoie NULL et affecte <symbol>SPI_ERROR_UNCONNECTED</symbol> à
   <varname>SPI_result</varname>.

  </para>

  <para>
      Notez que ceci devrait être utilisé pour les fonctions qui déclarent
      renvoyer des types composites. Ce n'est pas utilisé pour les
      déclencheurs&nbsp;; utilisez <function>SPI_copytuple</function> pour renvoyer une ligne modifiée
      dans un déclencheur.
    </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <para>
      ligne à copier
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
      descripteur pour la ligne (passez le même descripteur chaque fois pour un
      cache plus efficace)
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   <type>HeapTupleHeader</type> pointant vers la ligne copiée
   ou <symbol>NULL</symbol> en cas d'erreur
   (voir <varname>SPI_result</varname> pour une indication sur l'erreur)
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                                                  <refentry id="spi-spi-modifytuple">
                                                   <indexterm><primary>SPI_modifytuple</primary></indexterm>

                                                   <refmeta>
                                                    <refentrytitle>SPI_modifytuple</refentrytitle>
                                                    <manvolnum>3</manvolnum>
                                                   </refmeta>

                                                   <refnamediv>
                                                    <refname>SPI_modifytuple</refname>
                                                    <refpurpose>crée une ligne en remplaçant les champs sélectionnés d'une ligne
                                                     donnée</refpurpose>
                                                   </refnamediv>

                                                   <refsynopsisdiv>
                                                    <synopsis>HeapTuple SPI_modifytuple(Relation <parameter>rel</parameter>, HeapTuple <parameter>row</parameter>, <parameter>ncols</parameter>, <parameter>colnum</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_modifytuple</function> crée une nouvelle ligne en
   retirant les nouvelles valeurs pour les colonnes sélectionnées et en copiant
   les colonnes de la ligne d'origine à d'autres positions. La ligne d'entrée
   n'est pas modifiée.
   La nouvelle ligne est retournée dans le contexte de l'exécuteur supérieur.
  </para>

  <para>
   Cette fonction ne peut être utilisée que pendant une connexion SPI.
   Sinon, elle renvoie NULL et affecte <symbol>SPI_ERROR_UNCONNECTED</symbol> à
   <varname>SPI_result</varname>.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>Relation <parameter>rel</parameter></literal></term>
    <listitem>
     <para>
      Utilisé seulement en tant que source du descripteur de ligne pour la
      ligne (passez une relation plutôt qu'un descripteur de ligne est une
      erreur).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <para>
      rangée à modifier
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>ncols</parameter></literal></term>
    <listitem>
     <para>
      nombre de numéros de colonnes à changer
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int * <parameter>colnum</parameter></literal></term>
    <listitem>
     <para>
      tableau de longueur <parameter>ncols</parameter>, contenant les numéros
      de colonnes à modifier (le numéro des colonnes commence à 1)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <para>
      tableau de longueur <parameter>ncols</parameter>, contenant les nouvelles
      valeurs pour les colonnes spécifiées
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <para>
      tableau de longueur <parameter>ncols</parameter>, décrivant les nouvelles
      valeurs NULL
     </para>

     <para>
      Si <parameter>nulls</parameter> vaut <symbol>NULL</symbol>, alors
      <function>SPI_modifytuple</function> suppose qu'aucune valeur
      n'est NULL. Dans le cas contraire, chaque entrée du tableau
      <parameter>nulls</parameter> doit valoir <literal>'&nbsp;'</literal> si
      la nouvelle valeur correspondante est non NULL et <literal>'n'</literal>
      si la nouvelle valeur correspondante est NULL (dans ce dernier cas, la
      valeur réelle de l'entrée <parameter>values</parameter> correspondante
      n'a pas d'importance). Notez que <parameter>nulls</parameter> n'est pas
      une chaîne de texte. C'est un tableau et, de ce fait, il n'a pas besoin
      d'un caractère de fin <literal>'\0'</literal>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   nouvelle ligne avec modifications, allouée dans le contexte de mémoire
   courant, ou <symbol>NULL</symbol> en cas d'erreur (voir
   <varname>SPI_result</varname> pour une indication de l'erreur)
  </para>

  <para>
   En cas d'erreur, <varname>SPI_result</varname> est positionnée comme
   suit&nbsp;:
   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
        si <parameter>colnum</parameter> contient un numéro de colonne invalide
	(0 ou moins, ou plus que le nombre de colonnes dans <parameter>row</parameter>)
        <parameter>row</parameter>)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_NOATTRIBUTE</symbol></term>
     <listitem>
      <para>
       si <parameter>nocolonne</parameter> contient un numéro de colonne invalide
       (inférieur ou égal à 0 ou supérieur au numéro de colonne dans
       <parameter>row</parameter>)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       si SPI n'est pas actif
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                                                    <refentry id="spi-spi-freetuple">
                                                     <indexterm><primary>SPI_freetuple</primary></indexterm>

                                                     <refmeta>
                                                      <refentrytitle>SPI_freetuple</refentrytitle>
                                                      <manvolnum>3</manvolnum>
                                                     </refmeta>

                                                     <refnamediv>
                                                      <refname>SPI_freetuple</refname>
                                                      <refpurpose>libère une ligne allouée dans le contexte de mémoire
                                                       courant</refpurpose>
                                                     </refnamediv>

                                                     <refsynopsisdiv>
                                                      <synopsis>void SPI_freetuple(HeapTuple <parameter>row</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_freetuple</function> libère une rangée allouée auparavant
   dans le contexte de mémoire courant.
  </para>

  <para>
   Cette fonction n'est plus différente du standard
   <function>heap_freetuple</function>. Elle est gardée juste pour la
   compatibilité du code existant.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <para>
      rangée à libérer
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                                                      <refentry id="spi-spi-freetupletable">
                                                       <indexterm><primary>SPI_freetuptable</primary></indexterm>

                                                       <refmeta>
                                                        <refentrytitle>SPI_freetuptable</refentrytitle>
                                                        <manvolnum>3</manvolnum>
                                                       </refmeta>

                                                       <refnamediv>
                                                        <refname>SPI_freetuptable</refname>
                                                        <refpurpose>libère une série de lignes créée par <function>SPI_execute</function> ou une
                                                         fonction semblable</refpurpose>
                                                       </refnamediv>

                                                       <refsynopsisdiv>
                                                        <synopsis>void SPI_freetuptable(SPITupleTable * <parameter>tuptable</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_freetuptable</function> libère une série de lignes créée
   auparavant par une fonction d'exécution de commandes SPI, tel que
   <function>SPI_execute</function>. Par conséquent, cette fonction est souvent appelée
   avec la variable globale <varname>SPI_tupletable</varname> comme
   argument.
  </para>

  <para>
   Cette fonction est utile si une fonction C SPI a besoin d'exécuter
   de multiples commandes et ne veut pas garder les résultats de commandes
   précédentes en mémoire jusqu'à sa fin. Notez que toute série de lignes non
   libérées est libérée quand même lors de <function>SPI_finish</function>.
   De plus, si une sous-transaction est commencée puis annulée lors de l'exécution
   d'une fonction C SPI, SPI libère automatiquement tous les ensembles de lignes
   créés lors de l'exécution de la sous-transaction.
  </para>

  <para>
   À partir de <productname>PostgreSQL</productname> 9.3,
   <function>SPI_freetuptable</function> contient la logique de sécurité pour
   protéger contre les demandes dupliquées de suppression à partir du même
   ensemble de lignes. Avec les versions précédentes, les suppressions
   dupliquées auraient amenées à des crashs.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPITupleTable * <parameter>tuptable</parameter></literal></term>
    <listitem>
     <para>
      pointeur vers la série de lignes à libérer, ou NULL pour ne rien faire
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

                                                        <refentry id="spi-spi-freeplan">
                                                         <indexterm><primary>SPI_freeplan</primary></indexterm>

                                                         <refmeta>
                                                          <refentrytitle>SPI_freeplan</refentrytitle>
                                                          <manvolnum>3</manvolnum>
                                                         </refmeta>

                                                         <refnamediv>
                                                          <refname>SPI_freeplan</refname>
                                                          <refpurpose>libère une requête préparée sauvegardée auparavant</refpurpose>
                                                         </refnamediv>

                                                         <refsynopsisdiv>
                                                          <synopsis>int SPI_freeplan(SPIPlanPtr <parameter>plan</parameter>)</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>SPI_freeplan</function> libère une requête préparée
   retournée auparavant par <function>SPI_prepare</function> ou sauvegardée par
   <function>SPI_keepplan</function> ou <function>SPI_saveplan</function>.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
      pointeur vers la requête à libérer
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Valeur de retour</title>

  <para>
   0 en cas de succès&nbsp;;
   <symbol>SPI_ERROR_ARGUMENT</symbol> si <parameter>plan</parameter>
   est <symbol>NULL</symbol> ou invalide.
  </para>
 </refsect1>
</refentry>

 </sect1>

 <sect1 id="spi-transaction">
  <title>Gestion des transactions</title>

  <para>
   Il n'est pas possible d'exécuter des commandes de contrôle des
   transactions, telles que <command>COMMIT</command> et
   <command>ROLLBACK</command> via une fonction SPI comme
   <function>SPI_execute</function>. Cependant, il existe des fonctions
   d'interface séparées qui permettent le contrôle des transactions via SPI.
  </para>

  <para>
   Il n'est généralement pas sûr et sensible de démarrer et terminer des
   transactions dans des fonctions définies par l'utilisateur et appelables en
   SQL sans prendre en compte le contexte dans lequel elles sont appelées. Par
   exemple, une limite de transaction dans le milieu d'une fonction qui fait
   partie d'une expression SQL complexe, elle-même partie d'une commande SQL,
   aura probablement comme résultat des erreurs internes obscures ou des
   crashs. Les fonctions d'interface présentées ici ont principalement comme
   but d'être utilisées par les implémentations de langage de procédure pour
   supporter la gestion des transactions dans les procédures niveau SQL appelées par la
   commande <command>CALL</command>, en prenant en compte le contexte de
   l'appel à <command>CALL</command>. Les procédures utilisant SPI implémentées en C
   peuvent implémenter la même logique mais les détails de cette
   implémentation dépassent le cadre de cette documentation.
  </para>

<!-- *********************************************** -->

                                                          <refentry id="spi-spi-commit">
                                                           <indexterm><primary>SPI_commit</primary></indexterm>
                                                           <indexterm><primary>SPI_commit_and_chain</primary></indexterm>

                                                           <refmeta>
                                                            <refentrytitle>SPI_commit</refentrytitle>
                                                            <manvolnum>3</manvolnum>
                                                           </refmeta>

                                                           <refnamediv>
                                                            <refname>SPI_commit</refname>
                                                            <refpurpose>valider la transaction courante</refpurpose>
                                                           </refnamediv>

                                                           <refsynopsisdiv>
                                                            <synopsis>
void SPI_commit(void)
                                                            </synopsis>

                                                            <synopsis>
void SPI_commit_and_chain(void)
                                                            </synopsis>
                                                           </refsynopsisdiv>

                                                           <refsect1>
                                                            <title>Description</title>

                                                            <para>
                                                             <function>SPI_commit</function> valide la transaction en cours. C'est
                                                             approximativement équivalent à exécuter la commande SQL
                                                             <command>COMMIT</command>. Après la validation d'une transaction, une
                                                             nouvelle transaction doit être démarrée en utilisant la fonction
                                                             <function>SPI_start_transaction</function> avant que d'autres actions
                                                             puissent être exécutées sur la base.
                                                            </para>

                                                            <para>
                                                             <function>SPI_commit_and_chain</function> est identique mais une nouvelle
                                                             transaction est immédiatement démarrée avec les mêmes caractéristiques que
                                                             la transaction qui vient de se terminer, tout comme avec la commande SQL
                                                             <command>COMMIT AND CHAIN</command>.
                                                            </para>

                                                            <para>
                                                             Ces fonction peuvent seulement être exécutées si la connexion SPI a été
                                                             configurée comme non atomique dans l'appel à
                                                             <function>SPI_connect_ext</function>.
                                                            </para>
                                                           </refsect1>
                                                          </refentry>

                                                          <!-- *********************************************** -->

                                                          <refentry id="spi-spi-rollback">
                                                           <indexterm><primary>SPI_rollback</primary></indexterm>
                                                           <indexterm><primary>SPI_rollback_and_chain</primary></indexterm>

                                                           <refmeta>
                                                            <refentrytitle>SPI_rollback</refentrytitle>
                                                            <manvolnum>3</manvolnum>
                                                           </refmeta>

                                                           <refnamediv>
                                                            <refname>SPI_rollback</refname>
                                                            <refname>SPI_rollback_and_chain</refname>
                                                            <refpurpose>annuler la transaction courante</refpurpose>
                                                           </refnamediv>

                                                           <refsynopsisdiv>
                                                            <synopsis>
void SPI_rollback(void)
                                                            </synopsis>

                                                            <synopsis>
void SPI_rollback_and_chain(void)
                                                            </synopsis>
                                                           </refsynopsisdiv>

                                                           <refsect1>
                                                            <title>Description</title>

                                                            <para>
                                                             <function>SPI_rollback</function> annule la transaction en cours. C'est
                                                             approximativement équivalent à exécuter la commande SQL
                                                             <command>ROLLBACK</command>. Après l'annulation d'une transaction, une
                                                             nouvelle transaction doit être démarrée en utilisant la fonction
                                                             <function>SPI_start_transaction</function> avant que d'autres actions ne
                                                             puissent être exécutées sur la base de données.
                                                            </para>

                                                            <para>
                                                             <function>SPI_rollback_and_chain</function> est identique mais une nouvelle
                                                             transaction est immédiatement démarrée avec les mêmes caractéristiques que
                                                             la transaction qui vient de se terminer, tout comme avec la commande SQL
                                                             <command>ROLLBACK AND CHAIN</command>.
                                                            </para>

                                                            <para>
                                                             Ces fonctions peuvent seulement être exécutées si la connexion SPI a été
                                                             configurée comme non atomique dans l'appel à
                                                             <function>SPI_connect_ext</function>.
                                                            </para>
                                                           </refsect1>
                                                          </refentry>

                                                          <!-- *********************************************** -->

                                                          <refentry id="spi-spi-start-transaction">
                                                           <indexterm><primary>SPI_start_transaction</primary></indexterm>

                                                           <refmeta>
                                                            <refentrytitle>SPI_start_transaction</refentrytitle>
                                                            <manvolnum>3</manvolnum>
                                                           </refmeta>

                                                           <refnamediv>
                                                            <refname>SPI_start_transaction</refname>
                                                            <refpurpose>démarrer une nouvelle transaction</refpurpose>
                                                           </refnamediv>

                                                           <refsynopsisdiv>
                                                            <synopsis>
void SPI_start_transaction(void)
                                                            </synopsis>
                                                           </refsynopsisdiv>

                                                           <refsect1>
                                                            <title>Description</title>

                                                            <para>
                                                             <function>SPI_start_transaction</function> démarre une nouvelle
                                                             transaction. Cette fonction peut seulement être appelée après
                                                             <function>SPI_commit</function> ou <function>SPI_rollback</function>, car
                                                             il n'y a plus de transaction active à ce moment-là. Habituellement, quand
                                                             une procédure utilisant SPI est appelée, il existe déjà une transaction active, donc
                                                             tenter d'en démarrer une autre avant de fermer celle en cours se terminera
                                                             par une erreur.
                                                            </para>

                                                            <para>
                                                             Cette fonction peut seulement être exécutées si la connexion SPI a été
                                                             configurée comme non atomique dans l'appel à
                                                             <function>SPI_connect_ext</function>.
                                                            </para>
                                                           </refsect1>
                                                          </refentry>

                                                         </sect1>

                                                         <sect1 id="spi-visibility">
                                                          <title>Visibilité des modifications de données</title>

                                                          <para>
                                                           Les règles suivantes gouvernent la visibilité des modifications de données dans
                                                           les fonctions qui utilisent SPI (ou tout autre fonction C)&nbsp;:

                                                           <itemizedlist>
                                                            <listitem>
                                                             <para>
                                                              Pendant l'exécution de la commande SQL, toute modification de données faite par
                                                              la commande est invisible à la commande. Par exemple, dans la commande&nbsp;:
                                                              <programlisting>INSERT INTO a SELECT * FROM a;
                                                              </programlisting>
                                                              les lignes insérées sont invisibles à la partie <command>SELECT</command>.
                                                             </para>
                                                            </listitem>

                                                            <listitem>
                                                             <para>
                                                              Les modifications effectuées par une commande C sont visibles par toutes
                                                              les commandes qui sont lancées après C, peu importe qu'elles soient
                                                              lancées à l'intérieur de C (pendant l'exécution de C) ou après que C soit
                                                              terminée.
                                                             </para>
                                                            </listitem>

                                                            <listitem>
                                                             <para>
                                                              Les commandes exécutées via SPI à l'intérieur d'une fonction appelée
                                                              par une commande SQL (soit une fonction ordinaire soit un déclencheur)
                                                              suivent une des règles ci-dessus suivant le commutateur
                                                              lecture/écriture passé à SPI. Les commandes exécutées en mode lecture
                                                              seule suivent la première règle&nbsp;: elles ne peuvent pas voir
                                                              les modifications de la commande appelante. Les commandes exécutées
                                                              en mode lecture/écriture suivent la deuxième règle&nbsp;: elles
                                                              peuvent voir toutes les modifications réalisées jusqu'à maintenant.
                                                             </para>
                                                            </listitem>

                                                            <listitem>
                                                             <para>
                                                              Tous les langages standards de procédures initialisent le mode
                                                              lecture/écriture suivant l'attribut de volatilité de la fonction.
                                                              Les commandes des fonctions <literal>STABLE</literal> et
                                                              <literal>IMMUTABLE</literal> sont réalisées en mode lecture seule alors que
                                                              les fonctions <literal>VOLATILE</literal> sont réalisées en mode
                                                              lecture/écriture. Alors que les auteurs de fonctions C sont capables
                                                              de violer cette convention, il est peu probable que cela soit une
                                                              bonne idée de le faire.
                                                             </para>
                                                            </listitem>
                                                           </itemizedlist>
                                                          </para>

                                                          <para>
                                                           La section suivante contient un exemple qui illustre
                                                           l'application de ces règles.
                                                          </para>
                                                         </sect1>

                                                         <sect1 id="spi-exemples">
                                                          <title>Exemples</title>

                                                          <para>
                                                           Cette section contient un exemple très simple d'utilisation de SPI. La
                                                           fonction C <function>execq</function> prend une commande SQL comme
                                                           premier argument et un compteur de lignes comme second, exécute la commande
                                                           en utilisant <function>SPI_exec</function> et renvoie le nombre de lignes
                                                           qui ont été traitées par la commande. Vous trouverez des exemples plus
                                                           complexes pour SPI dans l'arborescence source dans
                                                           <filename>src/test/regress/regress.c</filename> et dans le module
                                                           <xref linkend="contrib-spi"/>.
                                                          </para>

                                                          <programlisting>#include "postgres.h"

#include "executor/spi.h"
#include "utils/builtins.h"

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(execq);

Datum
execq(PG_FUNCTION_ARGS)
{
    char *command;
    int cnt;
    int ret;
    uint64 proc;

    /* Convert given text object to a C string */
    command = text_to_cstring(PG_GETARG_TEXT_PP(0));
    cnt = PG_GETARG_INT32(1);

    SPI_connect();

    ret = SPI_exec(command, cnt);

    proc = SPI_processed;

    /*
     * Si des lignes ont été récupérées,
     * alors les afficher via elog(INFO).
     */
    if (ret &gt; 0 &amp;&amp; SPI_tuptable != NULL)
    {
        SPITupleTable *tuptable = SPI_tuptable;
        TupleDesc tupdesc = tuptable-&gt;tupdesc;
        char buf[8192];
        int64 j;

        for (j = 0; j &lt; tuptable-&gt;numvals; j++)
        {
            HeapTuple tuple = tuptable-&gt;vals[j];
            int i;

            for (i = 1, buf[0] = 0; i &lt;= tupdesc-&gt;natts; i++)
                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), " %s%s",
                        SPI_getvalue(tuple, tupdesc, i),
                        (i == tupdesc-&gt;natts) ? " " : " |");
            elog(INFO, "EXECQ: %s", buf);
        }
    }

    SPI_finish();
    pfree(command);

    PG_RETURN_INT64(proc);
}
                                                          </programlisting>

                                                          <para>
                                                           Voici comment déclarer la fonction après l'avoir compilée en
                                                           une bibliothèque partagée (les détails sont dans <xref
                                                           linkend="dfunc"/>)&nbsp;:

                                                           <programlisting>CREATE FUNCTION execq(text, integer) RETURNS int8
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C STRICT;
                                                           </programlisting>
                                                          </para>

                                                          <para>
                                                           Voici une session d'exemple&nbsp;:

                                                           <programlisting>=&gt; SELECT execq('CREATE TABLE a (x integer)', 0);
 execq
-------
     0
(1 row)

=&gt; INSERT INTO a VALUES (execq('INSERT INTO a VALUES (0)', 0));
INSERT 0 1
=&gt; SELECT execq('SELECT * FROM a', 0);
INFO:  EXECQ:  0    -- inséré par execq
INFO:  EXECQ:  1    -- retourné par execq et inséré par l'INSERT précédant

 execq
-------
     2
(1 row)

=&gt; SELECT execq('INSERT INTO a SELECT x + 2 FROM a', 1);
 execq
-------
     1
(1 row)

=&gt; SELECT execq('SELECT * FROM a', 10);
INFO:  EXECQ:  0
INFO:  EXECQ:  1
INFO:  EXECQ:  2    -- 0 + 2, une seule ligne insérée - comme spécifié

 execq
-------
     3              -- 10 est la valeur max seulement, 3 est le nombre réel de rangées
(1 row)

=&gt; DELETE FROM a;
DELETE 3
=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);
INSERT 0 1
=&gt; SELECT * FROM a;
 x
---
 1                  -- aucune rangée dans a (0) + 1
(1 row)

=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);
INFO:  EXECQ:  1
INSERT 0 1
=&gt; SELECT * FROM a;
 x
---
 1
 2                  -- il y a une rangée dans a + 1
(2 rows)

-- Ceci montre la règle de visibilité de modifications de données :

=&gt; INSERT INTO a SELECT execq('SELECT * FROM a', 0) * x FROM a;
INFO:  EXECQ:  1
INFO:  EXECQ:  2
INFO:  EXECQ:  1
INFO:  EXECQ:  2
INFO:  EXECQ:  2
INSERT 0 2
=&gt; SELECT * FROM a;
 x
---
 1
 2
 2                  -- 2 rangées * 1 (x dans la première rangée)
 6                  -- 3 rangées (2 + 1 juste insérée) * 2 (x dans la deuxième rangée)
(4 rows)                 ^^^^^^^
                         rangées visible à execq() dans des invocations différentes
                                                           </programlisting>
                                                          </para>
                                                         </sect1>
                                                        </chapter>
