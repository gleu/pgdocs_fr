<?xml version="1.0" encoding="UTF-8"?>
<chapter id="pltcl">
 <title>PL/Tcl &mdash; Langage de procédures Tcl</title>

 <indexterm zone="pltcl">
  <primary>PL/Tcl</primary>
 </indexterm>

 <indexterm zone="pltcl">
  <primary>Tcl</primary>
 </indexterm>

 <para>
  PL/Tcl est un langage de procédures chargeable pour le système de bases de
  données <productname>PostgreSQL</productname>, activant l'utilisation du
  <ulink url="https://www.tcl.tk/">langage Tcl</ulink> pour l'écriture de
  fonctions et de procédures <productname>PostgreSQL</productname>.
 </para>

 <!-- **** PL/Tcl overview **** -->

 <sect1 id="pltcl-overview">
  <title>Aperçu</title>

  <para>
   PL/Tcl offre un grand nombre de fonctionnalités qu'un codeur de
   fonctions dispose avec le langage C, avec quelques restrictions
   et couplé à de puissantes bibliothèques de traitement de chaînes de caractères
   disponibles pour Tcl.
  </para>
  <para>
   Une <emphasis>bonne</emphasis> restriction est que tout est exécuté dans
   le contexte de l'interpréteur Tcl.
   En plus de l'ensemble sûr de commandes limitées de Tcl, seules quelques
   commandes sont disponibles pour accéder à la base via SPI et pour envoyer
   des messages via <function>elog()</function>. PL/Tcl ne fournit aucun
   moyen pour accèder aux internes du serveur de bases ou pour gagner un accès
   au niveau système d'exploitation avec les droits du processus serveur
   <productname>PostgreSQL</productname> comme le fait une fonction C. Du coup,
   les utilisateurs de la base, sans droits, peuvent utiliser ce langage en
   toute confiance&nbsp;; il ne leur donne pas une autorité illimitée.
  </para>
  <para>
   L'autre restriction d'implémentation est que les fonctions Tcl ne peuvent
   pas être utilisées pour créer des fonctions d'entrées/sorties pour les
   nouveaux types de données.
  </para>
  <para>
   Quelques fois, il est préférable d'écrire des fonctions Tcl non
   restreintes par le Tcl sûr. Par exemple, vous pourriez vouloir une fonction
   Tcl pour envoyer un courrier électronique. Pour gérer ces cas, il existe une
   variante de <application>PL/Tcl</application> appelée <literal>PL/TclU</literal> (Tcl non
   accrédité). C'est exactement le même langage sauf qu'un interpréteur Tcl
   complet est utilisé. <emphasis>Si <application>PL/TclU</application> est utilisé, il
    doit être installé comme langage de procédures non accrédité</emphasis> de
   façon à ce que seuls les super-utilisateurs de la base de données puissent
   créer des fonctions avec lui. Le codeur d'une fonction
   <application>PL/TclU</application> doit faire attention au fait que la fonction ne
   pourra pas être utilisé pour faire autre chose que son but initial, car il
   sera possible de faire tout ce qu'un administrateur de la base de données
   peut faire.
  </para>
  <para>
   Le code de l'objet partagé pour les gestionnaires d'appel <application>PL/Tcl</application> et
   <application>PL/TclU</application> est automatiquement construit et installé dans le
   répertoire des bibliothèques de <productname>PostgreSQL</productname> si le
   support de Tcl est spécifié dans l'étape de configuration de la procédure
   d'installation. Pour installer <application>PL/Tcl</application> et/ou
   <application>PL/TclU</application> dans une base de données particulière,
   utilisez la commande <command>CREATE EXTENSION</command>, par exemple
   <literal>CREATE EXTENSION pltcl</literal> ou
   <literal>CREATE EXTENSION pltclu</literal>.
  </para>
 </sect1>

 <!-- **** PL/Tcl description **** -->

 <sect1 id="pltcl-functions">
  <title>Fonctions et arguments PL/Tcl</title>

  <para>
   Pour créer une fonction dans le langage <application>PL/Tcl</application>, utilisez
   la syntaxe standard de <xref linkend="sql-createfunction"/>&nbsp;:

   <programlisting>CREATE FUNCTION <replaceable>nom_fonction</replaceable> (<replaceable>types_arguments</replaceable>) RETURNS
<replaceable>type_en_retour</replaceable> AS $$
    # corps de la fonction PL/Tcl
$$ LANGUAGE pltcl;
   </programlisting>

   <application>PL/TclU</application> est identique sauf que le langage doit être
   <literal>pltclu</literal>.
  </para>

  <para>
   Le corps de la fonction est simplement un bout de script Tcl.  Quand la
   fonction est appelée, les valeurs d'argument sont passées au script Tcl
   comme des variables nommées <literal>1</literal>...
   <literal><replaceable>n</replaceable></literal>.  Le résultat est retournée
   depuis le code Tcl de la manière habituelle, avec un ordre
   <literal>return</literal>. Pour une procédure, la valeur de retour du code
   Tcl est ignorée.
  </para>

  <para>
   Par exemple, une fonction renvoyant le plus grand de deux valeurs entières
   pourrait être définie ainsi&nbsp;:

   <programlisting>CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$
    if {$1 &gt; $2} {return $1}
    return $2
$$ LANGUAGE pltcl STRICT;
   </programlisting>

   Notez la clause <literal>STRICT</literal> qui nous permet d'éviter de penser aux
   valeurs NULL en entrées&nbsp;: si une valeur NULL est passée, la
   fonction ne sera pas appelée du tout mais renverra automatiquement un
   résultat nul.
  </para>

  <para>
   Dans une fonction non stricte, si la valeur réelle d'un argument est
   NULL, la variable <literal>$<replaceable>n</replaceable></literal>
   correspondante sera initialisée avec une chaîne vide. Pour détecter si un
   argument particulier est NULL, utilisez la fonction <literal>argisnull</literal>.
   Par exemple, supposez que nous voulons <function>tcl_max</function> avec un
   argument NULL et un non NULL pour renvoyer l'argument non NULL plutôt que
   NULL&nbsp;:

   <programlisting>CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$
    if {[argisnull 1]} {
        if {[argisnull 2]} { return_null }
        return $2
    }
    if {[argisnull 2]} { return $1 }
    if {$1 &gt; $2} {return $1}
    return $2
$$ LANGUAGE pltcl;
   </programlisting>
  </para>

  <para>
   Comme indiqué ci-dessus, pour renvoyer une valeur NULL à partir d'une
   fonction PL/Tcl, exécutez <literal>return_null</literal>. Ceci
   peut être fait que la fonction soit stricte ou non.
  </para>

  <para>
   Les arguments de type composé sont passés à la fonction comme des
   tableaux Tcl. Les noms des éléments du tableau sont les noms d'attribut du
   type composite. Si un attribut dans la ligne passée a la valeur NULL, il
   n'apparaîtra pas dans le tableau. Voici un exemple&nbsp;:

   <programlisting>CREATE TABLE employe (
    nom text,
    salaire integer,
    age integer
);

CREATE FUNCTION surpaye(employe) RETURNS boolean AS $$
    if {200000.0 &lt; $1(salaire)} {
        return "t"
    }
    if {$1(age) &lt; 30 &amp;&amp; 100000.0 &lt; $1(salaire)} {
        return "t"
    }
    return "f"
$$ LANGUAGE pltcl;
   </programlisting>
  </para>

  <para>
   Les fonctions PL/Tcl peuvent également retourner des résultats de type
   composite.  Pour cela, le code Tcl doit retourner une liste de paires nom
   de colonnes / valeurs correspondant au type de résultat attendu.  Tout nom
   de colonne omis de la liste sera retourné comme NULL, et une erreur est
   levée s'il y a un nom de colonne inattendu.  Voici un exemple :

   <programlisting>
CREATE FUNCTION square_cube(in int, out squared int, out cubed int) AS $$
    return [list squared [expr {$1 * $1}] cubed [expr {$1 * $1 * $1}]]
$$ LANGUAGE pltcl;
   </programlisting>
  </para>

  <para>
   Les arguments en sortie des procédures sont renvoyées de la même façon.
   Par exemple&nbsp;:

   <programlisting>
CREATE PROCEDURE tcl_triple(INOUT a integer, INOUT b integer) AS $$
    return [list a [expr {$1 * 3}] b [expr {$2 * 3}]]
$$ LANGUAGE pltcl;

CALL tcl_triple(5, 10);
   </programlisting>
  </para>

  <tip>
   <para>
    La liste résultat peut être faite à partir d'une représentation de
    tableau du tuple désiré avec la commande Tcl <literal>array
     get</literal>.  Par exemple:

    <programlisting>
CREATE FUNCTION raise_pay(employee, delta int) RETURNS employee AS $$
    set 1(salary) [expr {$1(salary) + $2}]
    return [array get 1]
$$ LANGUAGE pltcl;
    </programlisting>
   </para>
  </tip>

  <para>
   Les fonctions PL/Tcl peuvent retourner des ensembles.  Pour cela, le code
   Tcl devrait appeler <function>return_next</function> une fois par ligne à
   être retournée, passant soit la valeur appropriée quand un type scalaire
   est retourné, soit une liste de paires de nom de colonne / valeur quand un
   type composite est retourné.  Voici un exemple retournant un type scalaire
   :

   <programlisting>
CREATE FUNCTION sequence(int, int) RETURNS SETOF int AS $$
    for {set i $1} {$i &lt; $2} {incr i} {
        return_next $i
    }
$$ LANGUAGE pltcl;
   </programlisting>

   et voici un exemple retournant un type composite :

   <programlisting>
CREATE FUNCTION table_of_squares(int, int) RETURNS TABLE (x int, x2 int) AS $$
    for {set i $1} {$i &lt; $2} {incr i} {
        return_next [list x $i x2 [expr {$i * $i}]]
    }
$$ LANGUAGE pltcl;
   </programlisting>
  </para>
 </sect1>

 <sect1 id="pltcl-data">
  <title>Valeurs des données avec PL/Tcl</title>

  <para>
   Les valeurs des arguments fournies au code d'une fonction PL/Tcl sont
   simplement les arguments en entrée convertis au format texte (comme s'ils
   avaient été affichés par une instruction <command>SELECT</command>).  Les
   commandes <literal>return</literal> et <literal>return_next</literal>
   accepteront toute chaîne qui est un format d'entrée acceptable pour le type
   de résultat déclaré pour la fonction, ou pour la colonne spécifiée d'un type
   de retour composite.
  </para>

 </sect1>

 <sect1 id="pltcl-global">
  <title>Données globales avec PL/Tcl</title>

  <indexterm zone="pltcl-global">
   <primary>donnée globale</primary>
   <secondary>in PL/Tcl</secondary>
  </indexterm>

  <para>
   Quelque fois, il est utile d'avoir des données globales qui sont
   conservées entre deux appels à une fonction ou qui sont partagées entre
   plusieurs fonctions. Ceci peut être facilement obtenu car toutes les
   fonctions PL/Tcl exécutées dans une session partagent le même interpréteur
   Tcl sûr. Donc, toute variable globale Tcl est accessible aux appels de
   fonctions PL/Tcl et persisteront pour la durée de la session SQL (notez
   que les fonctions <application>PL/TclU</application> partagent de la même façon les
   données globales mais elles sont dans un interpréteur Tcl différent et ne
   peuvent pas communiquer avec les fonctions PL/Tcl).
   C'est facile à faire en PL/Tcl mais il existe quelques restrictions qui
   doivent être comprises.
  </para>

  <para>
   Pour des raisons de sécurité, PL/Tcl exécute les fonctions appelées par
   tout rôle SQL dans un interpréteur Tcl séparé pour ce rôle. Ceci empêche
   une interférence accidentelle ou malicieuse d'un utilisateur avec le
   comportement des fonctions PL/Tcl d'un autre utilisateur. Chaque
   interpréteur aura ses propres valeurs pour toutes les variables globales
   Tcl. Du coup, deux fonctions PL/Tcl partageront les mêmes variables
   globales si et seulement si elles sont exécutées par le même rôle SQL.
   Dans une application où une seule session exécute du code sous plusieurs
   rôles SQL(via des fonctions <literal>SECURITY DEFINER</literal>, l'utilisation
   de <command>SET ROLE</command>, etc), vous pouvez avoir besoin de mettre des
   étapes explicites pour vous assurer que les fonctions PL/Tcl peuvent
   partager des données. Pour cela, assurez-vous que les fonctions qui doivent
   communiques ont pour propriétaire le même utilisateur et marquez-les avec
   l'option <literal>SECURITY DEFINER</literal>. Bien sûr, vous devez faire attention
   à ce que de telles fonctions ne puissent pas être utilisées pour faire
   des choses non souhaitées.
  </para>

  <para>
   Toutes les fonctions PL/TclU utilisées dans une session s'exécutent avec
   le même interpréteur Tcl, qui est bien sûr différent des interpréteurs
   utilisées pour les fonctions PL/Tcl. Donc les données globales sont
   automatiquement partagées entre des fonctions PL/TclU. Ceci n'est pas
   considéré comme un risque de sécurité parce que toutes les fonctions
   PL/TclU s'exécutent dans le même niveau de confiance, celui d'un
   super-utilisateur.
  </para>

  <para>
   Pour aider à la protection des fonctions PL/Tcl sur les interférences non
   intentionnelles, un tableau global est rendu disponible pour chaque
   fonction via la commande <function>upvar</function>. Le nom global de cette
   variable est le nom interne de la fonction alors que le nom local est
   <literal>GD</literal>. Il est recommandé d'utiliser <literal>GD</literal> pour les
   données privées persistantes d'une fonction. Utilisez les variables globales
   Tcl uniquement pour les valeurs que vous avez l'intention de partager avec
   les autres fonctions. (Notez que les tableaux
   <literal>GD</literal> sont seulement globaux à l'intérieur d'un interpréteur
   particulier, pour qu'ils ne franchissent pas les restrictions de sécurité
   mentionnées ci-dessus.)
  </para>

  <para>
   Un exemple de l'utilisation de <literal>GD</literal> apparaît dans l'exemple
   <function>spi_execp</function> ci-dessous.
  </para>
 </sect1>

 <sect1 id="pltcl-dbaccess">
  <title>Accès à la base de données depuis PL/Tcl</title>

  <para>
   Dans cette section, nous suivons la convention Tcl habituelle pour
   l'utilisation des points d'interrogation, plutôt que les crochets, pour
   indiquer un élément optionnel dans un synopsis de syntaxe.  Les commandes
   suivantes sont disponibles pour accéder à la base de données depuis le corps
   d'une fonction PL/Tcl&nbsp;:

   <variablelist>

    <varlistentry>
     <term><literal><function>spi_exec</function> <optional role="tcl">-count <replaceable>n</replaceable></optional> <optional role="tcl">-array <replaceable>name</replaceable></optional> <replaceable>command</replaceable> <optional role="tcl"><replaceable>loop-body</replaceable></optional></literal></term>
     <listitem>
      <para>
       Exécute une commande SQL donnée en tant que chaîne. Une erreur dans la
       commande lève une erreur. Sinon, la valeur de retour de
       <function>spi_exec</function> est le nombre de lignes intéressées dans
       le processus (sélection, insertion, mise à jour ou suppression) par la
       commande ou zéro si la commande est une instruction utilitaire. De plus,
       si la commande est une instruction <command>SELECT</command>, les valeurs des
       données sélectionnées sont placées dans des variables Tcl décrites
       ci-dessous.
      </para>
      <para>
       La valeur optionnelle <literal>-count</literal> indique à
       <function>spi_exec</function> le nombre maximum de lignes à travailler
       dans la commande. L'effet de ceci est comparable à l'initialisation
       d'une requête en tant que curseur et de dire <literal>FETCH
        <replaceable>n</replaceable></literal>.
      </para>
      <para>
       Si la commande est une instruction <command>SELECT</command>, les
       valeurs des colonnes de résultat sont placées dans les variables Tcl
       nommées d'après les colonnes. Si l'option <literal>-array</literal>
       est donnée, les valeurs de colonnes sont stockées à la place dans les
       éléments d'un tableau associatif nommé, les noms des colonnes étant
       utilisés comme index du tableau. De plus, le numéro de ligne courant
       dans le résultat (en commençant par zéro) est enregistré dans
       l'élément de tableau nommé <quote><literal>.tupno</literal></quote>,
       sauf si ce nom est utilisé comme nom de colonne dans le résultat.
      </para>
      <para>
       Si la commande est une instruction <command>SELECT</command> et
       qu'aucun script <replaceable>loop-body</replaceable> n'est donné,
       alors seule la première ligne de résultats est stockée dans des
       variables Tcl ou des éléments de tableau&nbsp;; les lignes suivantes
       sont ignorées. Aucun stockage n'intervient si la requête ne renvoie
       pas de ligne (ce cas est détectable avec le résultat de la fonction
       <function>spi_exec</function>). Par exemple&nbsp;:

       <programlisting>spi_exec "SELECT count(*) AS cnt FROM pg_proc"
       </programlisting>

       initialisera la variable Tcl <literal>$cnt</literal> avec le nombre de
       lignes dans le catalogue système <structname>pg_proc</structname>.
      </para>
      <para>
       Si l'argument <replaceable>loop-body</replaceable> optionnel est donné, il existe un
       morceau de script Tcl qui est exécuté une fois pour chaque ligne du
       résultat de la requête (<replaceable>loop-body</replaceable> est ignoré si la
       commande donnée n'est pas un <command>SELECT</command>). Les valeurs des
       colonnes de la ligne actuelle sont stockées dans des variables Tcl avant
       chaque itération. Par exemple&nbsp;:

       <programlisting>spi_exec -array C "SELECT * FROM pg_class" {
    elog DEBUG "have table $C(relname)"
}
       </programlisting>

       affichera un message de trace pour chaque ligne de <literal>pg_class</literal>.
       Cette fonctionnalité travaille de façon similaire aux autres
       constructions de boucles de Tcl&nbsp;; en particulier,
       <literal>continue</literal> et <literal>break</literal> fonctionnent de la même façon
       à l'intérieur de <replaceable>loop-body</replaceable>.
      </para>
      <para>
       Si une colonne d'un résultat de la requête est NULL, la variable cible
       est <quote>dés-initialisée</quote> plutôt qu'initialisée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>spi_prepare</function> <replaceable>query</replaceable> <replaceable>typelist</replaceable></term>
     <listitem>
      <para>
       Prépare et sauvegarde un plan de requête pour une exécution future. Le
       plan sauvegardé sera conservé pour la durée de la session
       actuelle.<indexterm><primary>préparer une requête</primary><secondary>en
         PL/Tcl</secondary></indexterm>
      </para>
      <para>
       La requête peut utiliser des paramètres, c'est-à-dire des emplacements
       pour des valeurs à fournir lorsque le plan sera réellement exécuté. Dans
       la chaîne de requête, faites référence aux paramètres avec les symboles
       <literal>$1</literal> ...
       <literal>$<replaceable>n</replaceable></literal>. Si la requête utilise
       les paramètres, les noms des types de paramètre doivent être donnés dans
       une liste Tcl (écrivez une liste vide pour
       <replaceable>typelist</replaceable> si aucun paramètre n'est utilisé).
      </para>
      <para>
       La valeur de retour de <function>spi_prepare</function> est
       l'identifiant de la requête à utiliser dans les appels suivants à
       <function>spi_execp</function>. Voir <function>spi_execp</function> pour
       un exemple.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal><function>spi_execp</function> <optional role="tcl">-count <replaceable>n</replaceable></optional> <optional role="tcl">-array <replaceable>name</replaceable></optional> <optional role="tcl">-nulls <replaceable>string</replaceable></optional> <replaceable>queryid</replaceable> <optional role="tcl"><replaceable>value-list</replaceable></optional> <optional role="tcl"><replaceable>loop-body</replaceable></optional></literal></term>
     <listitem>
      <para>
       Exécute une requête préparée précédemment avec <function>spi_prepare</function>.
       <replaceable>queryid</replaceable> est l'identifiant renvoyé par
       <function>spi_prepare</function>. Si la requête fait référence à des
       paramètres, une liste de valeurs (<replaceable>value-list</replaceable>)
       doit être fournie. C'est une liste Tcl des valeurs réelles des
       paramètres. La liste doit être de la même longueur que la liste de types
       de paramètres donnée précédemment lors de l'appel à
       <function>spi_prepare</function>. Oubliez-la si la requête n'a pas de
       paramètres.
      </para>
      <para>
       La valeur optionnelle pour <literal>-nulls</literal> est une chaîne d'espaces
       et de caractères <literal>'n'</literal> indiquant à
       <function>spi_execp</function> les paramètres nuls. Si indiqué, elle doit
       avoir exactement la même longueur que
       <replaceable>value-list</replaceable>. Si elle est omise, toutes les
       valeurs de paramètres sont non NULL.
      </para>
      <para>
       Sauf si la requête et ses paramètres sont spécifiés,
       <function>spi_execp</function> fonctionne de la même façon que
       <function>spi_exec</function>. Les options <literal>-count</literal>,
       <literal>-array</literal> et <replaceable>loop-body</replaceable> sont
       identiques. Du coup, la valeur du résultat l'est aussi.
      </para>
      <para>
       Voici un exemple d'une fonction PL/Tcl utilisant un plan préparé&nbsp;:

       <programlisting>CREATE FUNCTION t1_count(integer, integer) RETURNS integer AS $$
    if {![ info exists GD(plan) ]} {
        # prépare le plan sauvegardé au premier appel
        set GD(plan) [ spi_prepare \
                "SELECT count(*) AS cnt FROM t1 WHERE num &gt;= \$1 AND num &lt;= \$2" \
                [ list int4 int4 ] ]
    }
    spi_execp -count 1 $GD(plan) [ list $1 $2 ]
    return $cnt
$$ LANGUAGE pltcl;
       </programlisting>

       Nous avons besoin des antislashs à l'intérieur de la chaîne de la
       requête passée à <function>spi_prepare</function> pour s'assurer que les
       marqueurs <literal>$<replaceable>n</replaceable></literal> sont passés
       au travers de <function>spi_prepare</function> sans transformation et ne sont
       pas remplacés avec la substitution de variables de Tcl.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>subtransaction</function> <replaceable>command</replaceable></term>
     <listitem>
      <para>
       Le script Tcl contenu dans <replaceable>command</replaceable> est
       exécuté à l'intérieur d'une sous-transaction SQL. Si le script renvoie
       une erreur, la sous-transaction entière est annulée avant de renvoyer
       une erreur au code Tcl appelant. Voir <xref
       linkend="pltcl-subtransactions"/> pour plus de détails et un exemple.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>quote</function> <replaceable>string</replaceable></term>
     <listitem>
      <para>
       Double toutes les occurrences de guillemet simple et d'antislash
       dans la chaîne donnée. Ceci peut être utilisé pour mettre entre
       guillemets des chaînes de façon sûr et pour qu'elles puissent être
       insérées dans des commandes SQL passées à <function>spi_exec</function>
       ou <function>spi_prepare</function>. Par exemple, pensez à une
       chaîne de commande SQL comme&nbsp;:

       <programlisting>"SELECT '$val' AS ret"
       </programlisting>

       où la variable Tcl <literal>val</literal> contient actuellement le mot
       <literal>doesn't</literal>. Ceci finirait avec la chaîne de
       commande&nbsp;:

       <programlisting>SELECT 'doesn't' AS ret
       </programlisting>

       qui va causer une erreur d'analyse lors de
       <function>spi_exec</function> ou de
       <function>spi_prepare</function>. Pour fonctionner correctement, la
       commande soumise devrait contenir&nbsp;:

       <programlisting>SELECT 'doesn''t' AS ret
       </programlisting>

       qui peut-être créé avec PL/Tcl en utilisant&nbsp;:

       <programlisting>"SELECT '[ quote $val ]' AS ret"
       </programlisting>

       Un avantage de <function>spi_execp</function> est que vous n'avez pas à
       mettre entre guillemets des valeurs de paramètres comme ceux-ci car les
       paramètres ne sont jamais analysés comme faisant partie de la chaîne de
       la commande SQL.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <function>elog</function> <replaceable>level</replaceable> <replaceable>msg</replaceable>
      <indexterm>
       <primary>elog</primary>
       <secondary>in PL/Tcl</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
       Émet une trace ou un message d'erreur. Les niveaux possibles sont
       <literal>DEBUG</literal>, <literal>LOG</literal>, <literal>INFO</literal>,
       <literal>NOTICE</literal>, <literal>WARNING</literal>, <literal>ERROR</literal> et
       <literal>FATAL</literal>. <literal>ERROR</literal> élève
       une condition d'erreur&nbsp;; si elle n'est pas récupérée par le code
       Tcl, l'erreur est propagée à la requête appelante, causant l'annulation
       de la transaction ou sous-transaction en cours. Ceci est en fait
       identique à la commande <literal>error</literal>. <literal>FATAL</literal>
       annule la transaction et fait que la session courante s'arrête (il
       n'existe probablement aucune raison d'utiliser ce niveau d'erreur dans
       les fonctions PL/Tcl mais il est fourni pour que tous les messages
       soient tout de même disponibles). Les autres niveaux génèrent seulement
       des messages de niveaux de priorité différent. Le fait que les
       messages d'un niveau de priorité particulier sont reportés au client,
       écrit dans les journaux du serveur ou les deux à la fois, est contrôlé
       par les variables de configuration <xref linkend="guc-log-min-messages"/>
       et <xref linkend="guc-client-min-messages"/>. Voir le <xref
       linkend="runtime-config"/> et <xref linkend="pltcl-error-handling"/>
       pour plus d'informations.
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>

 </sect1>

 <sect1 id="pltcl-trigger">
  <title>Fonctions triggers en PL/Tcl</title>

  <indexterm>
   <primary>déclencheur</primary>
   <secondary>en PL/Tcl</secondary>
  </indexterm>

  <para>
   Les fonctions trigger peuvent être écrites en PL/Tcl.
   <productname>PostgreSQL</productname> requiert qu'une fonction, devant
   être appelée en tant que déclencheur, doit être déclarée comme une fonction
   sans arguments et retourner une valeur de type <literal>trigger</literal>.
  </para>
  <para>
   L'information du gestionnaire de déclencheur est passée au corps de la
   fonction avec les variables suivantes&nbsp;:

   <variablelist>

    <varlistentry>
     <term><varname>$TG_name</varname></term>
     <listitem>
      <para>
       Nom du déclencheur provenant de l'instruction <command>CREATE
        TRIGGER</command>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>$TG_relid</varname></term>
     <listitem>
      <para>
       L'identifiant objet de la table qui est à la cause du lancement
       du déclencheur.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>$TG_table_name</varname></term>
     <listitem>
      <para>
       Le nom de la table qui est à la cause du lancement
       du déclencheur.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>$TG_table_schema</varname></term>
     <listitem>
      <para>
       Le schéma de la table qui est à la cause du lancement
       du déclencheur.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>$TG_relatts</varname></term>
     <listitem>
      <para>
       Une liste Tcl des noms des colonnes de la table, préfixée avec un
       élément de liste vide. Donc, rechercher un nom de colonne dans la liste
       avec la commande <function>lsearch</function> de <application>Tcl</application> renvoie le
       numéro de l'élément, en commençant à 1 pour la première colonne, de la
       même façon que les colonnes sont numérotées personnellement avec
       <productname>PostgreSQL</productname>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>$TG_when</varname></term>
     <listitem>
      <para>
       La chaîne <literal>BEFORE</literal>, <literal>AFTER</literal> ou
       <literal>INSTEAD OF</literal> suivant le type
       de l'événement du déclencheur.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>$TG_level</varname></term>
     <listitem>
      <para>
       La chaîne <literal>ROW</literal> ou <literal>STATEMENT</literal> suivant le type
       de l'événement du déclencheur.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>$TG_op</varname></term>
     <listitem>
      <para>
       La chaîne <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal> ou <literal>TRUNCATE</literal> suivant le
       type de l'événement du déclencheur.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>$NEW</varname></term>
     <listitem>
      <para>
       Un tableau associatif contenant les valeurs de la nouvelle ligne de la
       table pour les actions <command>INSERT</command> ou <command>UPDATE</command>
       ou vide pour <command>DELETE</command>. Le tableau est indexé par nom de
       colonne. Les colonnes NULL n'apparaissent pas dans le tableau.
       Ce paramètre n'est pas initialisé pour les triggers de niveau instruction.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>$OLD</varname></term>
     <listitem>
      <para>
       Un tableau associatif contenant les valeurs de l'ancienne ligne de la
       table pour les actions <command>UPDATE</command> or <command>DELETE</command> ou vide
       pour <command>INSERT</command>. Le tableau est indexé par nom de colonne. Les
       colonnes NULL n'apparaissent pas dans le tableau.
       Ce paramètre n'est pas initialisé pour les triggers de niveau instruction.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>$args</varname></term>
     <listitem>
      <para>
       Une liste Tcl des arguments de la fonction ainsi que
       l'instruction <command>CREATE TRIGGER</command>. Ces arguments sont
       aussi accessibles par <literal>$1</literal> ...
       <literal>$<replaceable>n</replaceable></literal> dans le corps de la
       fonction.
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>

  <para>
   Le code de retour d'une fonction trigger peut être faite avec une
   des chaînes <literal>OK</literal> ou <literal>SKIP</literal> ou une liste
   de paires nom de colonne/valeur renvoyée par la commande Tcl
   <literal>array get</literal>. Si la valeur de retour est
   <literal>OK</literal>, l'opération (<command>INSERT</command>/<command>UP
    DATE</command>/<command>DELETE</command>) qui a lancé le déclencheur
   continuera normalement. <literal>SKIP</literal> indique au gestionnaire
   de déclencheurs de supprimer silencieusement l'opération pour cette
   ligne. Si une liste est renvoyée, elle indique à PL/Tcl de renvoyer la
   ligne modifiée au gestionnaire de déclencheurs&nbsp;; le contenu de la
   ligne modifiée est spécifié par les noms de colonne et par les valeurs
   dans la liste. Toute colonne non mentionné dans la liste est configuré à
   NULL. Renvoyer une ligne modifiée n'a un intérêt que pour les triggers
   niveau ligne pour <literal>BEFORE</literal>, <command>INSERT</command> ou
   <command>UPDATE</command> pour laquelle la ligne modifiée sera insérée au
   lieu de celle donnée dans <varname>$NEW</varname>&nbsp;; ou pour les
   triggers niveau ligne <literal>INSTEAD OF</literal>,
   <command>INSERT</command> ou <command>UPDATE</command> où la ligne
   renvoyée est utilisée comme données sources pour les clauses
   <command>INSERT RETURNING</command> ou <command>UPDATE
    RETURNING</command>. Dans les triggers <literal>BEFORE</literal>
   <command>DELETE</command> ou <literal>INSTEAD OF</literal>
   <command>DELETE</command> de niveau ligne, renvoyer une ligne modifiée a
   le même effet que renvoyer <literal>OK</literal>, autrement dit
   l'opération continue. La valeur de retour est ignorée pour les autres
   types de triggers.
  </para>

  <tip>
   <para>
    La liste de résultats peut être réalisée à partie une représentation en
    tableau de la ligne modifiée avec la commande Tcl <literal>array
     get</literal>.
   </para>
  </tip>

  <para>
   Voici un petit exemple de fonction trigger qui force une valeur
   entière dans une table pour garder trace du nombre de mises à jour
   réalisées sur la ligne. Pour les nouvelles lignes insérées, la valeur est
   initialisée à 0 puis incrémentée à chaque opération de mise à jour.

   <programlisting>CREATE FUNCTION trigfunc_modcount() RETURNS trigger AS $$
    switch $TG_op {
        INSERT {
            set NEW($1) 0
        }
        UPDATE {
            set NEW($1) $OLD($1)
            incr NEW($1)
        }
        default {
            return OK
        }
    }
    return [array get NEW]
$$ LANGUAGE pltcl;

CREATE TABLE mytab (num integer, description text, modcnt integer);

CREATE TRIGGER trig_mytab_modcount BEFORE INSERT OR UPDATE ON mytab
    FOR EACH ROW EXECUTE FUNCTION trigfunc_modcount('modcnt');
   </programlisting>

   Notez que la fonction trigger elle-même ne connaît pas le nom de la
   colonne&nbsp;; c'est fourni avec les arguments du déclencheur. Ceci permet
   à la fonction trigger d'être ré-utilisée avec différentes tables.
  </para>
 </sect1>

 <sect1 id="pltcl-event-trigger">
  <title>Fonctions trigger sur événement en PL/Tcl</title>

  <indexterm>
   <primary>trigger sur événement</primary>
   <secondary>en PL/Tcl</secondary>
  </indexterm>

  <para>
   Les fonctions triggers sur événement peuvent être écrites en PL/Tcl.
   <productname>PostgreSQL</productname> requiert qu'une fonction qui doit
   être appelée comme trigger sur événement doit être déclarée comme une
   fonction sans arguments et comme renvoyant le type
   <literal>event_trigger</literal>.
  </para>

  <para>
   L'information provenant du gestionnaire des triggers est passée au corps
   de la fonction avec les variables suivantes&nbsp;:

   <variablelist>

    <varlistentry>
     <term><varname>$TG_event</varname></term>
     <listitem>
      <para>
       Le nom de l'événement pour lequel le trigger a été déclenché.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>$TG_tag</varname></term>
     <listitem>
      <para>
       La balise de la commande pour laquelle le trigger a été déclenché.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   La valeur de retour de la fonction trigger est ignorée.
  </para>

  <para>
   Voici un petit exemple de fonction trigger sur événement qui lève un
   message <literal>NOTICE</literal> à chaque fois qu'une commande supportée
   est exécutée&nbsp;:

   <programlisting>
CREATE OR REPLACE FUNCTION tclsnitch() RETURNS event_trigger AS $$
  elog NOTICE "tclsnitch: $TG_event $TG_tag"
$$ LANGUAGE pltcl;

CREATE EVENT TRIGGER tcl_a_snitch ON ddl_command_start EXECUTE FUNCTION tclsnitch();
   </programlisting>
  </para>
 </sect1>

 <sect1 id="pltcl-error-handling">
  <title>Gestion des erreurs avec PL/Tcl</title>

  <indexterm>
   <primary>exceptions</primary>
   <secondary>in PL/Tcl</secondary>
  </indexterm>

  <para>
   Le code Tcl contenu ou appelé à partir d'une fonction PL/Tcl peut lever
   une erreur, soit en exécutant des opérations invalides ou en générant
   une erreur en utilisant la commande Tcl <function>error</function> ou la
   commande PL/Tcl <function>elog</function>. Si une erreur n'est pas
   rattrapée mais est autorisée à être propagée en dehors du niveau racine de
   l'exécution de la fonction PL/Tcl, elle est rapportée comme une erreur SQL
   dans la requête appelant la fonction.
  </para>

  <para>
   Les erreurs SQL survenant dans les commandes PL/Tcl
   <function>spi_exec</function>, <function>spi_prepare</function>
   et <function>spi_execp</function> sont rapportées comme des erreurs Tcl,
   donc elles sont récupérables par la commande Tcl <function>catch</function>.
   (Chacune des ces commandes PL/Tcl exécutent leurs opérations SQL dans une
   sous transaction, qui est annulée en cas d'erreur, si bien que n'importe
   quelle opération partiellement terminée sera automatiquement nettoyée.)
   De la même façon, si une erreur se propage en dehors du niveau racine sans
   avoir été rattrapée, elle sera rapportée en erreur SQL.
  </para>

  <para>
   Tcl fournit une variable <varname>errorCode</varname> pouvant représenter
   des informations supplémentaires sur une erreur dans un format qui est
   simple à interpréter pour les programmes Tcl. Le contenu est dans le format
   liste Tcl, et le premier mot identifie le sous-système ou la bibliothèque
   rapportant l'errer&nbsp;; au delà, le contenu est laissé au sous-système
   individuel ou à la bibliothèque. Pour les erreurs au niveau base rapportées
   par les commandes PL/Tcl commands, le premier mot est
   <literal>POSTGRES</literal>, le second est le numéro de version du serveur,
   et les mots supplémentaires sont les paires nom/valeur des champs fournissant
   des informations détaillées sur l'erreur.
   Les champs <varname>SQLSTATE</varname>, <varname>condition</varname>
   et <varname>message</varname> sont toujours fournies (les deux premiers
   représentent le code d'erreur et le nom de la condition comme indiqués dans
   <xref linkend="errcodes-appendix"/>). Les champs potentiellement présents
   incluent
   <varname>detail</varname>, <varname>hint</varname>, <varname>context</varname>,
   <varname>schema</varname>, <varname>table</varname>, <varname>column</varname>,
   <varname>datatype</varname>, <varname>constraint</varname>,
   <varname>statement</varname>, <varname>cursor_position</varname>,
   <varname>filename</varname>, <varname>lineno</varname> et
   <varname>funcname</varname>.
  </para>

  <para>
   Une façon agréable de travailler avec l'information
   <varname>errorCode</varname> de PL/Tcl est de la charger dans un tableau
   pour que les noms du champ deviennent des indices du tableau. Un code
   relatif ressemblerait à ceci&nbsp;:
   <programlisting>
if {[catch { spi_exec $sql_command }]} {
    if {[lindex $::errorCode 0] == "POSTGRES"} {
        array set errorArray $::errorCode
        if {$errorArray(condition) == "undefined_table"} {
            # gestion de la table manquante
        } else {
            # gestion des autres types d'erreur SQL
        }
    }
}
   </programlisting>
   (Les symboles deux-points spécifient explicitement que
   <varname>errorCode</varname> est une variable globale.)
  </para>
 </sect1>

 <sect1 id="pltcl-subtransactions">
  <title>Sous-transactions explicites dans PL/Tcl</title>

  <indexterm>
   <primary>sous-transactions</primary>
   <secondary>dans PL/Tcl</secondary>
  </indexterm>

  <para>
   Récupérer des erreurs causées par des à la base de données comme décris
   dans <xref linkend="pltcl-error-handling"/> peut mener à une situation
   indésirable où certaines opérations réussissent avant que l'une d'entre
   elles échoue, et après avoir récupéré cette erreur la donnée est laissé
   dans un état incohérent.  PL/Tcl offre une solution à ce problème sous la
   forme de sous-transactions explicites :
  </para>

  <para>
   Étudions une fonction qui implémente un transfert entre deux compte :
   <programlisting>
CREATE FUNCTION transfer_funds() RETURNS void AS $$
    if [catch {
        spi_exec "UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'"
        spi_exec "UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'"
    } errormsg] {
        set result [format "error transferring funds: %s" $errormsg]
    } else {
        set result "funds transferred successfully"
    }
    spi_exec "INSERT INTO operations (result) VALUES ('[quote $result]')"
$$ LANGUAGE pltcl;
   </programlisting>
   Si le deuxième ordre <command>UPDATE</command> échoue en levant une
   exception, cette fonction tracera l'échec, mais le résultat du premier
   <command>UPDATE</command> sera néanmoins validé.  Concrètement, le montant
   sera débité du compte de Joe, mais ne sera pas transféré sur le compte de
   Mary.  C'est le cas car chaque appel à <function>spi_exec</function> est
   une sous-transaction séparé, et seule l'une de ces sous-transactions est
   annulée.
  </para>

  <para>
   Pour gérer un cas comme ça, vous pouvez entourer vos opération sur la base
   d'une sous-transaction explicite, qui sera annulée ou validée comme un
   tour.  PL/Tcl fournit une commande <function>subtransaction</function>
   pour gérer ça.  Nous pouvons réécrire notre fonction ainsi :
   <programlisting>
CREATE FUNCTION transfer_funds2() RETURNS void AS $$
    if [catch {
        subtransaction {
            spi_exec "UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'"
            spi_exec "UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'"
        }
    } errormsg] {
        set result [format "error transferring funds: %s" $errormsg]
    } else {
        set result "funds transferred successfully"
    }
    spi_exec "INSERT INTO operations (result) VALUES ('[quote $result]')"
$$ LANGUAGE pltcl;
   </programlisting>
   Veuillez noter que l'utilisation de <function>catch</function> est
   toujours nécessaire pour gérer ce cas.  Autrement l'erreur se propagerait
   jusqu'au niveau racine de la fonction, ce qui empêcherait l'insertion
   voulue dans la table <structname>operations</structname>.  La commande
   <function>subtransaction</function> ne récupère pas les erreurs, elle
   s'assure seulement que tous les ordres sur la base exécutés dans sa portée
   seront annulés ensemble si une erreur survient.
  </para>

  <para>
   L'annulation d'une sous-transaction explicite arrive lors de n'importe
   quelle erreur rapportée par le code Tcl contenu, pas uniquement pour celle
   en provenance de la base de données.  Ainsi une exception standard Tcl
   levée dans une commande <function>subtransaction</function> aura également
   pour effet d'annuler la sous-transaction.  Toutefois, les sortie du code
   Tcl contenu sans erreur (par exemple, du fait d'un
   <function>return</function>) ne déclencheront pas d'annulation.
  </para>
 </sect1>

 <sect1 id="pltcl-transactions">
  <title>Gestion des transactions</title>

  <para>
   Dans une procédure appelée au haut niveau ou dans un bloc de code anonyme
   (commande <command>DO</command>) appelé au haut niveau, il est possible
   de contrôler les transactions. Pour valider la transaction en cours,
   appelez la commande <literal>commit</literal> command. Pour annuler la
   transaction en cours, appelez la commande <literal>rollback</literal>.
   (Notez qu'il n'est pas possible d'exécuter les commandes SQL
   <command>COMMIT</command> ou <command>ROLLBACK</command> via
   <function>spi_exec</function> ou similaire. Cela doit se faire en
   utilisant ces fonctions.) À la fin d'une transaction, une nouvelle
   transaction est automatiquement démarrée, donc il n'existe pas de
   commande séparée pour ça.
  </para>

  <para>
   Voici un exemple&nbsp;:
   <programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE pltcl
AS $$
for {set i 0} {$i &lt; 10} {incr i} {
    spi_exec "INSERT INTO test1 (a) VALUES ($i)"
    if {$i % 2 == 0} {
        commit
    } else {
        rollback
    }
}
$$;

CALL transaction_test1();
   </programlisting>
  </para>

  <para>
   Les transactions ne peuvent pas être terminées quand une sous-transaction
   explicite est active.
  </para>
 </sect1>

 <sect1 id="pltcl-config">
  <title>Configuration PL/Tcl</title>

  <para>
   Cette section liste les paramètre de configuration qui affectent
   <application>PL/Tcl</application>.
  </para>

  <variablelist>

   <varlistentry id="guc-pltcl-start-proc" xreflabel="pltcl.start_proc">
    <term>
     <varname>pltcl.start_proc</varname> (<type>string</type>)
     <indexterm>
      <primary>paramètre de configuration <varname>pltcl.start_proc</varname> </primary>
     </indexterm>
    </term>
    <listitem>
     <para>
      Ce paramètre, s'il est positionné à autre chose qu'une chaîne vide,
      spécifie le nom (potentiellement qualifié du schéma) d'ue fonction
      PL/Tcl sans paramètre qui doit être exécutée chaque fois qu'un nouvel
      interpréteur Tcl est crée pour Pl/Tcl.  Une telle fonction peut
      effectuer une initialisation pour la session, comme charger du code Tcl
      additionnel.  Un nouvel interpréteur Tcl est créé wuen une fonction
      PL/Tcl est exécutée pour la première fois dans une session, ou quand un
      autre interpréteur doit être crée du fait de l'appel à une fonction
      PL/Tcl par un nouveau rôle SQL.
     </para>
     <para>
      La fonction référencée doit être écrite dans le langage
      <literal>pltcl</literal>, et ne doit pas être marquée comme
      <literal>SECURITY DEFINER</literal>.  (Ces restrictions s'assurent que
      la fonction est lancée dans l'interpréteur qu'elle est censée
      initialisée.)  L'utilisateur courant doit avoir l'autorisation
      d'appeler cette fonction également.
     </para>
     <para>
      Si la fonction échoue avec une erreur cela annulera l'appel à la
      fonction qui a causée la création du nouvel interpréteur et l'erreur
      sera propagée jusqu'à la requête appelante, annulant de fait la
      transaction ou sous transaction courante.  Toute action déjà effectuée
      au sein de Tcl ne sera pas annulée; toutefois, cette interpréteur ne
      sera jamais réutilisé.  Si le langage est utilisé à nouveau
      l'initialisation sera de nouveau tentée avec une nouvel interpréteur
      Tcl.
     </para>
     <para>
      Seuls les super-utilisateurs peuvent modifier ce paramètre.  Bien que ce
      paramètre puisse être changé au sein d'une session, un tel changement
      n'affectera pas les interpréteurs Tcl qui ont déjà été créés.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="guc-pltclu-start-proc" xreflabel="pltclu.start_proc">
    <term>
     <varname>pltclu.start_proc</varname> (<type>string</type>)
     <indexterm>
      <primary>paramètre de configuration <varname>pltclu.start_proc</varname></primary>
     </indexterm>
    </term>
    <listitem>
     <para>
      Ce paramètre est exactement comme <varname>pltcl.start_proc</varname>,
      sauf qu'il s'applique à PL/TclU.  La fonction référencée doit être
      écrite dans le langage <literal>pltclu</literal>.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
 </sect1>

 <sect1 id="pltcl-procnames">
  <title>Noms de procédure Tcl</title>

  <para>
   Avec <productname>PostgreSQL</productname>, le même nom de fonction peut être
   utilisé par plusieurs fonctions tant que le nombre d'arguments ou leurs
   types diffèrent. Néanmoins, Tcl requiert que les noms de procédure soient
   distincts. PL/Tcl gère ceci en faisant en sorte que les noms de procédures
   Tcl internes contiennent l'identifiant de l'objet de la fonction depuis la
   table système <structname>pg_proc</structname>. Du coup, les fonctions
   <productname>PostgreSQL</productname> avec un nom identique et des types
   d'arguments différents seront aussi des procédures Tcl différentes. Ceci
   ne concerne normalement pas le développeur PL/Tcl mais cela pourrait
   apparaître dans une session de débogage.
  </para>

 </sect1>
</chapter>
