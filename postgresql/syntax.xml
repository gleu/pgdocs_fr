<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="sql-syntax">
 <title>Syntaxe SQL</title>

 <indexterm zone="sql-syntax">
  <primary>syntaxe</primary>
  <secondary>SQL</secondary>
 </indexterm>

 <para>
  Ce chapitre décrit la syntaxe de SQL. Il donne les fondements pour comprendre
  les chapitres suivants qui iront plus en détail sur la façon dont les
  commandes SQL sont appliquées pour définir et modifier des données.
 </para>

 <para>
  Nous avertissons aussi nos utilisateurs, déjà familiers avec le SQL, qu'ils 
  doivent lire ce chapitre très attentivement car il existe plusieurs règles et
  concepts implémentés différemment suivant les bases de données SQL ou
  spécifiques à <productname>PostgreSQL</productname>.
 </para>

 <sect1 id="sql-syntax-lexical">
  <title>Structure lexicale</title>

  <indexterm>
   <primary>token</primary>
  </indexterm>

  <para>
   Une entrée SQL consiste en une séquence de <firstterm>commandes</firstterm>.
   Une commande est composée d'une séquence de <firstterm>jetons</firstterm>,
   terminés par un point-virgule (<quote>;</quote>). La fin du flux en entrée
   termine aussi une commande. Les jetons valides dépendent de la
   syntaxe particulière de la commande.
  </para>

  <para>
   Un jeton peut être un <firstterm>mot clé</firstterm>, un
   <firstterm>identifieur</firstterm>, un <firstterm>identifieur entre
   guillemets</firstterm>, un <firstterm>littéral</firstterm> (ou une
   constante) ou un symbole de caractère spécial. Les jetons sont normalement
   séparés par des espaces blancs (espace, tabulation, nouvelle ligne) mais
   n'ont pas besoin de l'être s'il n'y a pas d'ambiguïté (ce qui est seulement
   le cas si un caractère spécial est adjacent à des jetons d'autres types).
  </para>

   <para>
    Par exemple, ce qui suit est (syntaxiquement) valide pour une entrée
    SQL&nbsp;:
<programlisting>SELECT * FROM MA_TABLE;
UPDATE MA_TABLE SET A = 5;
INSERT INTO MA_TABLE VALUES (3, 'salut ici');</programlisting>
    C'est une séquence de trois commandes, une par ligne (bien que cela ne soit
    pas requis&nbsp;; plusieurs commandes peuvent se trouver sur une même ligne et
    une commande peut se répartir sur plusieurs lignes).
   </para>

  <para>
   De plus, des <firstterm>commentaires</firstterm> peuvent se trouver dans
   l'entrée SQL. Ce ne sont pas des jetons, ils sont réellement équivalents à un
   espace blanc.
  </para>

  <para>
   La syntaxe SQL n'est pas très cohérente en ce qui concerne les jetons
   identifieurs des commandes et lesquels sont des opérandes ou des paramètres.
   Les premiers jetons sont généralement le nom de la commande. Dans 
   l'exemple ci-dessus, nous parlons d'une commande
   <quote>SELECT</quote>, d'une commande <quote>UPDATE</quote> et d'une commande
   <quote>INSERT</quote>. Mais en fait, la commande <command>UPDATE</command>
   requiert toujours un jeton <token>SET</token> apparaissant dans une certaine
   position, et cette variante particulière de <command>INSERT</command>
   requiert aussi un <token>VALUES</token> pour être complète. Les règles précises
   de syntaxe pour chaque commande sont décrites dans la <xref
   linkend="reference"/>.
  </para>

  <sect2 id="sql-syntax-identifiers">
   <title>Identifieurs et mots clés</title>

   <indexterm zone="sql-syntax-identifiers">
    <primary>identifieur</primary>
    <secondary>syntaxe de</secondary>
   </indexterm>

   <indexterm zone="sql-syntax-identifiers">
    <primary>nom</primary>
    <secondary>syntaxe de</secondary>
   </indexterm>

   <indexterm zone="sql-syntax-identifiers">
    <primary>mot clé</primary>
    <secondary>syntaxe de</secondary>
   </indexterm>

   <para>
    Les jetons tels que <token>SELECT</token>, <token>UPDATE</token> ou
    <token>VALUES</token> dans l'exemple ci-dessus sont des exemples de
    <firstterm>mots clés</firstterm>, c'est-à-dire des mots qui ont une
    signification dans le langage SQL. Les jetons <token>MA_TABLE</token> et
    <token>A</token> sont des exemples d'<firstterm>identifieurs</firstterm>.
    Ils identifient des noms de tables, colonnes ou d'autres objets de la base
    de données suivant la commande qui a été utilisée. Du coup, ils sont
    quelques fois simplement nommés des <quote>noms</quote>. Les mots clés et
    les identifieurs ont la même structure lexicale, signifiant que quelqu'un ne
    peut pas savoir si un jeton est un identifieur ou un mot clé sans connaître
    le langage. Une liste complète des mots clé est disponible dans l'<xref
    linkend="sql-keywords-appendix"/>.
   </para>

   <para>
    Les identifieurs et les mots clés SQL doivent commencer avec une lettre
    (<literal>a</literal>-<literal>z</literal>, mais aussi des lettres de
    marques diacritiques différentes et des lettres non latines) ou un tiret bas
    (<literal>_</literal>). Les caractères suivants dans un identifieur ou dans
    un mot clé peuvent être des lettres, des tirets-bas, des chiffres
    (<literal>0</literal>-<literal>9</literal>) ou des signes dollar
    (<literal>$</literal>). Notez que les signes dollar ne sont pas autorisés en tant
    qu'identifieur suivant le standard SQL, donc leur utilisation pourrait
    rendre les applications moins portables. Le standard SQL ne définira pas un
    mot clé contenant des chiffres ou commençant ou finissant par un tiret bas,
    donc les identifieurs de cette forme sont sûr de passer les conflits
    possibles avec les futures extensions du standard.
   </para>

   <para>
   
<indexterm><primary>identifieur</primary><secondary>longueur</secondary>
</indexterm>
    Le système utilise au plus <symbol>NAMEDATALEN</symbol>-1 octets
    d'un identifieur&nbsp;; les noms longs peuvent être écrits dans des
    commandes mais ils seront tronqués. Par défaut, <symbol>NAMEDATALEN</symbol>
    vaut 64. Du coup, la taille maximum de l'identifieur est de 63 octets. Si cette
    limite est problématique, elle peut être élevée en modifiant
    <symbol>NAMEDATALEN</symbol> dans
    <filename>src/include/pg_config_manual.h</filename>.
   </para>

   <para>
    <indexterm>
     <primary>sensibilité à la casse</primary>
     <secondary>des commandes SQL</secondary>
    </indexterm>
    Les mots clés et les identifiants sans guillemets doubles sont insensibles
    à la casse. Du coup&nbsp;:
<programlisting>UPDATE MA_TABLE SET A = 5;</programlisting>
    peut aussi s'écrire de cette façon&nbsp;:
<programlisting>uPDaTE ma_TabLE SeT a = 5;</programlisting>
    Une convention couramment utilisée revient à écrire les mots clés en
    majuscule et les noms en minuscule, c'est-à-dire&nbsp;:
<programlisting>UPDATE ma_table SET a = 5;</programlisting>
   </para>

   <para>
    <indexterm>
     <primary>marques de citation</primary>
     <secondary>et identifieurs</secondary>
    </indexterm>
    Voici un deuxième type d'identifieur&nbsp;: l'<firstterm>identifieur
    délimité</firstterm> ou l'<firstterm>identifieur entre
    guillemets</firstterm>. Il est formé en englobant une séquence arbitraire de
    caractères entre des guillemets doubles (<literal>"</literal>). <!-- "
    font-lock mania --> Un identifieur délimité est toujours un identifieur,
    jamais un mot clé. Donc, <literal>"select"</literal> pourrait être utilisé
    pour faire référence à une colonne ou à une table nommée
    <quote>select</quote>, alors qu'un <literal>select</literal> sans guillemets
    sera pris pour un mot clé et du coup, pourrait provoquer une erreur
    d'analyse lorsqu'il est utilisé alors qu'un nom de table ou de colonne est
    attendu. L'exemple peut être écrit avec des identifieurs entre guillemets
    comme ceci&nbsp;:
<programlisting>UPDATE "ma_table" SET "a" = 5;</programlisting>
   </para>

   <para>
    Les identifieurs entre guillemets peuvent contenir tout caractère autre
    que celui de code 0. (Pour inclure un guillemet double, écrivez deux
    guillemets doubles.) Ceci permet la construction de noms de tables et de
    colonnes qui ne seraient pas possible autrement, comme des noms
    contenant des espaces ou des arobases. La limitation de la longueur
    s'applique toujours.
   </para>

   <indexterm>
     <primary>échappement Unicode</primary>
     <secondary>dans les identifiants</secondary>
   </indexterm>

   <para>
    Une variante des identifiants entre
    guillemets permet d'inclure des caractères Unicode échappés en les
    identifiant par leur code. Cette variante commence par
    <literal>U&amp;</literal> (U en majuscule ou minuscule suivi par un « et »)
    immédiatement suivi par un guillemet double d'ouverture, sans espace
    entre eux. Par exemple <literal>U&amp;"foo"</literal>. (Notez que c'est
    source d'ambiguïté avec l'opérateur <literal>&amp;</literal>. Utilisez les
    espaces autour de l'opérateur pouréviter ce problème.) À l'intérieur des
    guillemets, les caractères Unicode peuvent être indiqués dans une forme
    échappée en écrivant un antislash suivi par le code hexadécimal sur quatre
    chiffres ou, autre possibilité, un antislash suivi du signe plus suivi
    d'un code hexadécimal sur six chiffres. Par exemple, l'identifiant
    <literal>"data"</literal> peut être écrit ainsi&nbsp;:
<programlisting>
U&amp;"d\0061t\+000061"
</programlisting>
    L'exemple suivant, moisn trivial, écrit le mot russe
    <quote>slon</quote> (éléphant) en lettres cyrilliques&nbsp;:
<programlisting>
U&amp;"\0441\043B\043E\043D"
</programlisting>
   </para>

   <para>
    Si un caractère d'échappement autre que l'antislash est désiré, il peut
    être indiqué en utilisant la clause <literal>UESCAPE</literal>
    <indexterm><primary>UESCAPE</primary></indexterm> après la chaîne. Par
    exemple&nbsp;:
<programlisting>
U&amp;"d!0061t!+000061" UESCAPE '!'
</programlisting>
    La chaîne d'échappement peut être tout caractère simple autre qu'un chiffre
    hexadécimal, le signe plus, un guillemet simple ou double, ou un espace
    blanc. Notez que le caractère d'échappement est écrit entre guillemets
    simples, pas entre guillemets doubles.
   </para>

   <para>
    Pour inclure le caractère d'échappement en litéral dans l'identifiant,
    écrivez-le deux fois.
   </para>

   <para>
    La syntaxe d'échappement Unicode fonctionne seulement quand l'encodage
    serveur est <literal>UTF8</literal>. Quand d'autres encodages clients sont
    utilisés, seuls les codes dans l'échelle ASCII (jusqu'à
    <literal>\007F</literal>) peuvent être utilisés.
    La forme sur quatre chiffres et la forme sur six chiffres peuvent être
    utilisées pour indiquer des paires UTF-16 composant ainsi des caractères
    comprenant des points de code plus grands que U+FFFF (et ce, bien que la
    disponibilité de la forme sur six chiffres ne le nécessite pas
    techniquement). (Les pairs surrogates ne sont pas stockées directement
    mais combinées dans un point de code seul qui est ensuite encodé en UTF-8.)
   </para>

   <para>
    Mettre un identifieur entre guillemets le rend sensible à la casse
    alors que les noms sans guillemets sont toujours convertis en minuscules. Par
    exemple, les identifieurs <literal>FOO</literal>, <literal>foo</literal> et
    <literal>"foo"</literal> sont considérés identiques par
    <productname>PostgreSQL</productname> mais <literal>"Foo"</literal> et
    <literal>"FOO"</literal> sont différents des trois autres et entre eux. La
    mise en minuscule des noms sans guillemets avec <productname>PostgreSQL</productname>
    n'est pas compatible avec le standard SQL qui indique que les noms sans
    guillemets devraient être mis en majuscule. Du coup, <literal>foo</literal>
    devrait être équivalent à <literal>"FOO"</literal> et non pas à
    <literal>"foo"</literal> en respect avec le standard. Si vous voulez écrire
    des applications portables, nous vous conseillons de toujours mettre entre
    guillemets un nom particulier ou de ne jamais le mettre. 
   </para>
  </sect2>


  <sect2 id="sql-syntax-constants">
   <title>Constantes</title>

   <indexterm zone="sql-syntax-constants">
    <primary>constante</primary>
   </indexterm>

   <para>
    Il existe trois <firstterm>types implicites de constantes</firstterm> dans
    <productname>PostgreSQL</productname>&nbsp;: les chaînes, les chaînes de
    bits et les nombres. Les constantes peuvent aussi être spécifiées avec des
    types explicites, ce qui peut activer des représentations plus précises 
    et gérées plus efficacement par le système. Les constantes implicites sont
    décrites ci-dessous&nbsp;; ces constantes sont discutées dans les
    sous-sections suivantes.
   </para>

   <sect3 id="sql-syntax-strings">
    <title>Constantes de chaînes</title>

    <indexterm zone="sql-syntax-strings">
     <primary>chaîne de caractère</primary>
     <secondary>constante</secondary>
    </indexterm>

    <para>
     <indexterm>
      <primary>marques de citation</primary>
      <secondary>échappement</secondary>
     </indexterm>
     Une constante de type chaîne en SQL est une séquence arbitraire de
     caractères entourée par des guillemets simples (<literal>'</literal>),
     c'est-à-dire <literal>'Ceci est une chaîne'</literal>. Pour inclure un
     guillemet simple dans une chaîne constante, saisissez deux
     guillemets simples adjacents, par exemple <literal>'Le cheval
     d''Anne'</literal>. Notez que ce n'est <emphasis>pas</emphasis> au
     guillemet double (<literal>"</literal>).
    </para>

    <para>
     Deux constantes de type chaîne séparées par un espace blanc
     <emphasis>avec au moins une nouvelle ligne</emphasis> sont concaténées et
     traitées réellement comme si la chaîne avait été écrite dans une constante.
     Par exemple&nbsp;:
<programlisting>SELECT 'foo'
'bar';</programlisting>
     est équivalent à&nbsp;:
<programlisting>SELECT 'foobar';</programlisting>
     mais&nbsp;:
<programlisting>SELECT 'foo'      'bar';</programlisting>
     n'a pas une syntaxe valide (ce comportement légèrement bizarre est
     spécifié par le standard <acronym>SQL</acronym>&nbsp;;
     <productname>PostgreSQL</productname> suit le standard).
    </para>
   </sect3>

   <sect3 id="sql-syntax-strings-escape">
    <title>Constantes chaîne avec des échappements de style C</title>

     <indexterm zone="sql-syntax-strings-escape">
      <primary>syntaxe d'échappement de chaîne</primary>
     </indexterm>
     <indexterm zone="sql-syntax-strings-escape">
      <primary>échappements d'antislash</primary>
     </indexterm>

    <para>
     <productname>PostgreSQL</productname> accepte aussi les constantes de
     chaîne d'<quote>échappement</quote> qui sont une extension au standard SQL.
     Une constante de type chaîne d'échappement est indiquée en écrivant la
     lettre <literal>E</literal> (en majuscule ou minuscule) juste avant le
     guillemet d'ouverture, par exemple <literal>E'foo'</literal>. (Pour continuer
     une constante de ce type sur plusieurs lignes, écrire <literal>E</literal>
     seulement avant le premier guillemet d'ouverture.)
     À l'intérieur d'une chaîne d'échappement, un caractère antislash
     (<literal>\</literal>) comme une séquence type C
     d'<firstterm>échappement d'antislash</firstterm> avec laquelle la combinaison
     d'antislash et du (ou des) caractère(s) suivant représente une valeur
     spéciale, comme indiqué dans <xref linkend="sql-backslash-table"/>.
    </para>

     <table id="sql-backslash-table">
      <title>Séquences d'échappements d'antislash</title>
      <tgroup cols="2">
      <thead>
       <row>
        <entry>Séquence d'échappement d'antislash</entry>
        <entry>Interprétation</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>\b</literal></entry>
        <entry>suppression</entry>
       </row>
       <row>
        <entry><literal>\f</literal></entry>
        <entry>retour en début de ligne</entry>
       </row>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>saut de ligne</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>saut de ligne</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>tabulation</entry>
       </row>
       <row>
        <entry>
         <literal>\<replaceable>o</replaceable></literal>,
         <literal>\<replaceable>oo</replaceable></literal>,
         <literal>\<replaceable>ooo</replaceable></literal>
         (<replaceable>o</replaceable> = 0 - 7)
        </entry>
        <entry>valeur octale</entry>
       </row>
       <row>
        <entry>
         <literal>\x<replaceable>h</replaceable></literal>,
         <literal>\x<replaceable>hh</replaceable></literal>
         (<replaceable>h</replaceable> = 0 - 9, A - F)
        </entry>
        <entry>valeur hexadécimale</entry>
       </row>
       <row>
        <entry>
         <literal>\u<replaceable>xxxx</replaceable></literal>,
         <literal>\U<replaceable>xxxxxxxx</replaceable></literal>
         (<replaceable>x</replaceable> = 0 - 9, A - F)
        </entry>
        <entry>caractère Unicode hexadécimal sur 16 ou 32 bits</entry>
       </row>
      </tbody>
      </tgroup>
     </table>

    <para>
     Tout autre caractère suivi d'un antislash est
     pris littéralement. Du coup, pour inclure un caractère antislash, écrivez
     deux antislashs (<literal>\\</literal>). De plus, un guillemet simple
     peut être inclus dans une chaîne d'échappement en écrivant
     <literal>\'</literal>, en plus de la façon normale <literal>''</literal>.
    </para>

    <para>
     Il est de votre responsabilité que les séquences d'octet que vous créez,
     tout spécialement lorsque vous utilisez les échappements octaux et
     hexadécimaux,
     soient des caractères valides dans l'encodage du jeu de caractères du
     serveur. Quand l'encodage est UTF-8, alors les échappements Unicode ou
     l'autre syntaxe déchappement Unicode, expliqués dans <xref
     linkend="sql-syntax-strings-uescape"/>, devraient être utilisés.
     (L'alternative serait de réaliser l'encodage UTF-8 manuellement et
     d'écrire les octets, ce qui serait très lourd.)
    </para>

    <para>
     La syntaxe d'échappement Unicode fonctionne complètement mais seulement
     quand l'encodage du serveur est justement <literal>UTF8</literal>. Lorsque d'autres
     encodages serveur sont utilisés, seuls les points de code dans l'échelle
     ASCII (jusqu'à <literal>\u007F</literal>) peuvent être utilisé. 
     La forme sur quatre chiffres et la forme sur six chiffres peuvent être
     utilisées pour indiquer des paires UTF-16 composant ainsi des caractères
     comprenant des points de code plus grands que U+FFFF et ce, bien que la
     disponibilité de la forme sur six chiffres ne le nécessite pas
     techniquement. (Quand des paires de substitution sont utilisée et que
    l'encodage du serveur est <literal>UTF8</literal>, elles sont tout d'abord
    combinées en un point code seul qui est ensuite encodé en UTF-8.)
    </para>

    <caution>
    <para>
     Si le paramètre de configuration
     <xref linkend="guc-standard-conforming-strings"/> est désactivé
     (<literal>off</literal>),
     alors <productname>PostgreSQL</productname> reconnaît les échappements
     antislashs dans les constantes traditionnelles de type chaînes et celles
     échappées. Néanmoins, à partir de <productname>PostgreSQL</productname>
     9.1, la valeur par défaut est <literal>on</literal>, ce qui signifie que
     les échappements par antislash sont reconnus seulement dans les constantes
     de chaînes d'échappement. Ce comportement est plus proche du standard
     SQL mais pourrait causer des problèmes aux applications qui se basent sur
     le comportement historique où les échappements par antislash étaient
     toujours reconnus. Pour contourner ce problème, vous pouvez configurer ce
     paramètre à <literal>off</literal> bien qu'il soit préférable de ne plus
     utiliser les échappements par antislash. Si vous avez besoin d'un
     échappement par antislash pour représenter un caractère spécial, écrivez
     la chaîne fixe avec un <literal>E</literal>.
    </para>

    <para>
     En plus de <varname>standard_conforming_strings</varname>, les paramètres
     de configuration <xref linkend="guc-escape-string-warning"/> et
     <xref linkend="guc-backslash-quote"/> imposent le traitement des antislashs
     dans les constantes de type chaîne.
    </para>
    </caution>

    <para>
     Le caractère de code zéro ne peut être placé dans une constante de type
     chaîne.
    </para>
   </sect3>

   <sect3 id="sql-syntax-strings-uescape">
    <title>Constantes de chaînes avec des échappements Unicode</title>

    <indexterm  zone="sql-syntax-strings-uescape">
     <primary>Échappement Unicode</primary>
     <secondary>dans des constantes de chaîne</secondary>
    </indexterm>

    <para>
     <productname>PostgreSQL</productname> supporte aussi un autre type de
     syntaxe d'échappement pour les chaînes qui permettent d'indiquer des
     caractères Unicode arbitraires par code. Une constante de chaîne
     d'échappement Unicode commence avec <literal>U&amp;</literal>
     (U en majuscule ou minuscule suivi par un « et »)
    immédiatement suivi par un guillemet double d'ouverture, sans espace
    entre eux. Par exemple <literal>U&amp;"foo"</literal>. (Notez que c'est
    source d'ambiguïté avec l'opérateur <literal>&amp;</literal>. Utilisez les
    espaces autour de l'opérateur pouréviter ce problème.) À l'intérieur des
    guillemets, les caractères Unicode peuvent être indiqués dans une forme
    échappée en écrivant un antislash suivi par le code hexadécimal sur quatre
    chiffres ou, autre possibilité, un antislash suivi du signe plus suivi
    d'un code hexadécimal sur six chiffres. Par exemple, l'identifiant
    <literal>'data'</literal> peut être écrit ainsi&nbsp;:
<programlisting>
U&amp;'d\0061t\+000061'
</programlisting>
     L'exemple suivant, moins trivial, écrit le mot russe
     <quote>slon</quote> (éléphant) en lettres cyrilliques&nbsp;:
<programlisting>
U&amp;'\0441\043B\043E\043D'
</programlisting>
    </para>

    <para>
     Si un caractère d'échappement autre que l'antislash est souhaité, il peut
     être indiqué en utilisant la clause <literal>UESCAPE</literal>
     <indexterm><primary>UESCAPE</primary></indexterm> après la chaîne. Par
     exemple&nbsp;:
<programlisting>
U&amp;'d!0061t!+000061' UESCAPE '!'
</programlisting>
     Le caractère d'échappement peut être tout caractère simple autre qu'un
     chiffre hexadécimal, le signe plus, un guillement simple ou double, ou
     un espace blanc.
    </para>

    <para>
     La syntaxe d'échappement Unicode fonctionne seulement quand l'encodage du
     serveur est <literal>UTF8</literal>. Quand d'autres encodages de serveur sont utilisés, seuls
     les codes dans l'échelle ASCII (jusqu'à <literal>\007F</literal>) peuvent
     être utilisés.
     La forme sur quatre chiffres et la forme sur six chiffres peuvent être
     utilisées pour indiquer des paires UTF-16 composant ainsi des caractères
     comprenant des points de code plus grands que U+FFFF (et ce, bien que la
     disponibilité de la forme sur six chiffres ne le nécessite pas
     techniquement). (When surrogate
     pairs are used when the server encoding is <literal>UTF8</literal>, they
     are first combined into a single code point that is then encoded
     in UTF-8.)
    </para>

    <para>
     De plus, la syntaxe d'échappement de l'Unicode pour les constantes de
     chaînes fonctionne seulement quand le paramètre de configuration
     <xref linkend="guc-standard-conforming-strings"/> est activé. Dans le
     cas contraire, cette syntaxe est confuse pour les clients qui analysent
     les instructions SQL au point que cela pourrait amener des injections
     SQL et des problèmes de sécurité similaires. Si le paramètre est désactivé,
     cette syntaxe sera rejetée avec un message d'erreur.
    </para>

    <para>
     Pour inclure le caractère d'échappement littéralement dans la chaîne,
     écrivez-le deux fois.
    </para>
   </sect3>

   <sect3 id="sql-syntax-dollar-quoting">
     <title>Constantes de chaînes avec guillemet dollar</title>

     <indexterm>
       <primary>guillemet dollar</primary>
     </indexterm>

     <para>
       Alors que la syntaxe standard pour la spécification des constantes de
       chaînes est généralement agréable, elle peut être difficile à comprendre
       quand la chaîne désirée contient un grand nombre de guillemets ou
       d'antislashs car chacun d'entre eux doit être doublé. Pour permettre la
       saisie de requêtes plus lisibles dans de telles situations,
       <productname>PostgreSQL</productname> fournit une autre façon, appelée
       <quote>guillemet dollar</quote>, pour écrire des constantes de chaînes.
       Une constante de chaîne avec guillemet dollar consiste en un signe
       dollar (<literal>$</literal>), une <quote>balise</quote> optionnelle
       de zéro ou plus de caractères, un autre signe dollar, une séquence
       arbitraire de caractères qui constitue le contenu de la chaîne, un signe
       dollar, la même balise et un signe dollar. Par exemple, voici deux
       façons de spécifier la chaîne <quote>Le cheval d'Anne</quote> en utilisant
       les guillemets dollar&nbsp;:
     <programlisting>$$Le cheval d'Anne$$
$UneBalise$Le cheval d'Anne$UneBalise$</programlisting>
       Notez qu'à l'intérieur de la chaîne avec guillemet dollar, les
       guillemets simples peuvent être utilisés sans devoir être échappés. En
       fait, aucun caractère à l'intérieur d'une chaîne avec guillemet dollar
       n'a besoin d'être échappé&nbsp;: le contenu est toujours écrit
       littéralement. Les antislashs ne sont pas spéciaux, pas plus que les
       signes dollar, sauf s'ils font partie d'une séquence correspondant à
       la balise ouvrante.
     </para>
   
     <para>
       Il est possible d'imbriquer les constantes de chaînes avec guillemets
       dollar en utilisant différentes balises pour chaque niveau
       d'imbrication. Ceci est habituellement utilisé lors de l'écriture de
       définition de fonctions. Par exemple&nbsp;:
     <programlisting>$fonction$
BEGIN
  RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$fonction$</programlisting>
       Ici, la séquence <literal>$q$[\t\r\n\v\\]$q$</literal> représente une chaîne
       littérale avec guillemet dollar <literal>[\t\r\n\v\\]</literal>, qui sera
       reconnu quand le corps de la fonction est exécuté par
       <productname>PostgreSQL</productname>. Mais comme la séquence ne correspond pas au
       délimiteur <literal>$fonction$</literal>, il s'agit juste de quelques
       caractères à l'intérieur de la constante pour ce qu'en sait la
       chaîne externe.
     </para>

     <para>
      La balise d'une chaîne avec guillemets dollar, si elle existe, suit les
      mêmes règles qu'un identificateur sans guillemets, sauf qu'il ne peut
      pas contenir de signes dollar. Les balises sont sensibles à la casse,
      du coup <literal>$balise$Contenu de la chaîne$balise$</literal> est
      correct mais <literal>$BALISE$Contenu de la chaîne$balise$</literal> ne
      l'est pas.
     </para>

     <para>
      Une chaîne avec guillemets dollar suivant un mot clé ou un identifieur
      doit en être séparé par un espace blanc&nbsp;; sinon, le délimiteur du
      guillemet dollar serait pris comme faisant parti de l'identifieur
      précédent.
     </para>

     <para>
      Le guillemet dollar ne fait pas partie du standard SQL mais c'est un
      moyen bien plus agréable pour écrire des chaînes littérales que 
      d'utiliser la syntaxe des guillemets simples, bien que compatible avec
      le standard. Elle est particulièrement utile  pour représenter des
      constantes de type chaîne à l'intérieur d'autres constantes, comme cela
      est souvent le cas avec les définitions de fonctions. Avec la syntaxe des
      guillemets simples, chaque antislash dans l'exemple précédent devrait
      avoir été écrit avec quatre antislashs, ce qui sera réduit à deux
      antislashs dans l'analyse de la constante originale, puis à un lorsque
      la constante interne est analysée de nouveau lors de l'exécution de la
      fonction.
     </para>
   </sect3>

   <sect3 id="sql-syntax-bit-strings">
    <title>Constantes de chaînes de bits</title>

    <indexterm zone="sql-syntax-bit-strings">
     <primary>chaîne de bit</primary>
     <secondary>constante</secondary>
    </indexterm>

    <para>
     Les constantes de chaînes de bits ressemblent aux constantes de chaînes
     standards avec un <literal>B</literal> (majuscule ou minuscule) juste avant le
     guillemet du début (sans espace blanc), c'est-à-dire
     <literal>B'1001'</literal>. Les seuls caractères autorisés dans les
     constantes de type chaîne de bits sont <literal>0</literal> et
     <literal>1</literal>.
    </para>

    <para>
     Autrement, les constantes de chaînes de bits peuvent être spécifiées en
     notation hexadécimale en utilisant un <literal>X</literal> avant (minuscule
     ou majuscule), c'est-à-dire <literal>X'1FF'</literal>. Cette notation est
     équivalente à une constante de chaîne de bits avec quatre chiffres binaires
     pour chaque chiffre hexadécimal.
    </para>

    <para>
     Les deux formes de constantes de chaînes de bits peuvent être continuées 
     sur plusieurs lignes de la même façon que les constantes de chaînes
     habituelles. Le guillemet dollar ne peut pas être utilisé dans une constante
     de chaîne de bits.
    </para>
   </sect3>

   <sect3 id="sql-syntax-constants-numeric">
    <title>Constantes numériques</title>

    <indexterm>
     <primary>nombre</primary>
     <secondary>constante</secondary>
    </indexterm>

    <para>
     Les constantes numériques sont acceptées dans ces formes générales&nbsp;:
<synopsis><replaceable>chiffres</replaceable>
<replaceable>chiffres</replaceable>.<optional><replaceable>chiffres</replaceable></optional><optional>e<optional>+-</optional><replaceable>chiffres</replaceable></optional>
<optional><replaceable>chiffres</replaceable></optional>.<replaceable>chiffres</replaceable><optional>e<optional>+-</optional><replaceable>chiffres</replaceable></optional>
<replaceable>chiffres</replaceable>e<optional>+-</optional><replaceable>chiffres</replaceable>
</synopsis>
     où <replaceable>chiffres</replaceable> est un ou plusieurs chiffres
     décimaux (de 0 à 9). Au moins un chiffre doit être avant ou après le point
     décimal, s'il est utilisé. Au moins un chiffre doit suivre l'indicateur
     d'exponentiel (<literal>e</literal>), s'il est présent. Il peut ne pas
     y avoir d'espaces ou d'autres caractères imbriqués dans la constante. Notez
     que tout signe plus ou moins en avant n'est pas forcément considéré comme
     faisant part de la constante&nbsp;; il est un opérateur appliqué à la
     constante.
    </para>

    <para>
     Voici quelques exemples de constantes numériques valides&nbsp;:
<literallayout>42
3.5
4.
.001
5e2
1.925e-3
</literallayout>
    </para>

    <para>
     <indexterm><primary>integer</primary></indexterm>
     <indexterm><primary>bigint</primary></indexterm>
     <indexterm><primary>numeric</primary></indexterm>
     Une constante numérique contenant soit un point décimal soit un
     exposant est tout d'abord présumée du type <type>integer</type> si sa valeur
     est contenue dans le type <type>integer</type> (32 bits)&nbsp;; sinon, il est
     présumé de type <type>bigint</type> si sa valeur entre dans un type
     <type>bigint</type> (64 bits)&nbsp;; sinon, il est pris pour un type
     <type>numeric</type>. Les constantes contenant des poins décimaux et/ou des
     exposants sont toujours présumées de type <type>numeric</type>.
    </para>

    <para>
     Le type de données affecté initialement à une constante numérique 
     est seulement un point de départ pour les algorithmes de résolution de
     types. Dans la plupart des cas, la constante sera automatiquement convertie
     dans le type le plus approprié suivant le contexte. Si nécessaire, vous
     pouvez forcer l'interprétation d'une valeur numérique sur un type de
     données spécifiques en la convertissant. <indexterm><primary>conversion de
     type</primary></indexterm> Par exemple, vous pouvez forcer une valeur
     numérique à être traitée comme un type <type>real</type> (<type>float4</type>) en
     écrivant&nbsp;:

<programlisting>REAL '1.23'  -- style chaîne
1.23::REAL   -- style PostgreSQL (historique)</programlisting>

      Ce sont en fait des cas spéciaux des notations de conversion générales
      discutées après.
     </para>
    </sect3>

   <sect3 id="sql-syntax-constants-generic">
    <title>Constantes d'autres types</title>

    <indexterm>
     <primary>type de données</primary>
     <secondary>constante</secondary>
    </indexterm>

    <para>
     Une constante de type <emphasis>arbitrary</emphasis> peut être saisie en
     utilisant une des notations suivantes&nbsp;:
<synopsis><replaceable>type</replaceable> '<replaceable>chaîne</replaceable>'
'<replaceable>chaîne</replaceable>'::<replaceable>type</replaceable>
CAST ( '<replaceable>chaîne</replaceable>' AS <replaceable>type</replaceable> )</synopsis>
     Le texte de la chaîne constante est passé dans la routine de conversion
     pour le type
     appelé <replaceable>type</replaceable>. Le résultat est une constante du
     type indiqué. La conversion explicite de type peut être omise s'il n'y
     a pas d'ambiguïté sur le type de la constante (par exemple, lorsqu'elle est
     affectée directement à une colonne de la table), auquel cas elle est
     convertie automatiquement.
    </para>


    <para>
     La constante chaîne peut être écrite en utilisant soit la notation SQL
     standard soit les guillemets dollar.
    </para>
    <para>
     Il est aussi possible de spécifier une conversion de type en utilisant une
     syntaxe style fonction&nbsp;:
<synopsis><replaceable>nom_type</replaceable> ( '<replaceable>chaîne</replaceable>' )</synopsis>
     mais tous les noms de type ne peuvent pas être utilisés ainsi&nbsp;; voir
     la <xref linkend="sql-syntax-type-casts"/> pour plus de détails.
    </para>

    <para>
     Les syntaxes <literal>::</literal>, <literal>CAST()</literal> et d'appels
     de fonctions sont aussi utilisables pour spécifier les conversions de
     type à l'exécution d'expressions arbitraires, comme discuté dans la <xref
     linkend="sql-syntax-type-casts"/>. Pour éviter une ambiguïté syntaxique,
     la syntaxe <literal><replaceable>type</replaceable>
     '<replaceable>chaîne</replaceable>'</literal> peut seulement être utilisée
     pour spécifier le type d'une constante littérale. Une autre restriction sur
     la syntaxe <literal><replaceable>type</replaceable>
     '<replaceable>chaîne</replaceable>'</literal> est qu'il ne fonctionne pas
     pour les types de tableau&nbsp;; utilisez <literal>::</literal> ou
     <literal>CAST()</literal> pour spécifier le type d'une constante de type
     tableau.
    </para>

    <para>
     La syntaxe de <literal>CAST()</literal> est conforme au standard SQL.  La syntaxe
     <literal><replaceable>type</replaceable> '<replaceable>chaine</replaceable>'</literal>
     est une généralisation du standard&nbsp;: SQL spécifie cette syntaxe
     uniquement pour quelques types de données mais
     <productname>PostgreSQL</productname> l'autorise pour tous les types. La
     syntaxe <literal>::</literal> est un usage historique dans
     <productname>PostgreSQL</productname>, comme l'est la syntaxe d'appel de
     fonction.
    </para>
   </sect3>
  </sect2>

  <sect2 id="sql-syntax-operators">
   <title>Opérateurs</title>

   <indexterm zone="sql-syntax-operators">
    <primary>opérateur</primary>
    <secondary>syntaxe</secondary>
   </indexterm>

   <para>
    Un nom d'opérateur est une séquence d'au plus <symbol>NAMEDATALEN</symbol>-1
    (63 par défaut) caractères provenant de la liste suivante&nbsp;:
<literallayout>+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?</literallayout>

    Néanmoins, il existe quelques restrictions sur les noms d'opérateurs&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       <literal>--</literal> et <literal>/*</literal> ne peuvent pas apparaître
       quelque part dans un nom d'opérateur car ils seront pris pour le début
       d'un commentaire.
      </para>
     </listitem>

     <listitem>
      <para>
       Un nom d'opérateur à plusieurs caractères ne peut pas finir avec
       <literal>+</literal> ou <literal>-</literal>, sauf si le nom contient aussi un de ces
       caractères&nbsp;:
<literallayout>~ ! @ # % ^ &amp; | ` ?</literallayout>
       Par exemple, <literal>@-</literal> est un nom d'opérateur autorisé mais
       <literal>*-</literal> ne l'est pas. Cette restriction permet à
       <productname>PostgreSQL</productname> d'analyser des requêtes
       compatibles avec SQL sans requérir des espaces entre les jetons.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Lors d'un travail avec des noms d'opérateurs ne faisant pas partie du
    standard SQL, vous aurez habituellement besoin de séparer les opérateurs
    adjacents avec des espaces pour éviter toute ambiguïté. Par exemple, si
    vous avez défini un opérateur unaire gauche nommé <literal>@</literal>,
    vous ne pouvez pas écrire <literal>X*@Y</literal>&nbsp;; vous devez écrire
    <literal>X* @Y</literal> pour vous assurer que
    <productname>PostgreSQL</productname> le lit comme deux noms d'opérateurs,
    et non pas comme un seul.
   </para>
  </sect2>

  <sect2 id="sql-syntax-special-chars">
   <title>Caractères spéciaux</title>

  <para>
   Quelques caractères non alphanumériques ont une signification spéciale,
   différente de celui d'un opérateur. Les détails sur leur utilisation sont
   disponibles à l'endroit où l'élément de syntaxe respectif est décrit. Cette
   section existe seulement pour avertir de leur existence et pour résumer le
   but de ces caractères.

   <itemizedlist>
    <listitem>
     <para>
      Un signe dollar (<literal>$</literal>) suivi de chiffres est utilisé pour
      représenter un paramètre de position dans le corps de la définition d'une
      fonction ou d'une instruction préparée. Dans d'autres contextes, le signe
      dollar pourrait faire partie d'un identifieur ou d'une constante de type
      chaîne utilisant le dollar comme guillemet.
     </para>
    </listitem>

    <listitem>
     <para>
      Les parenthèses (<literal>()</literal>) ont leur signification habituelle
      pour grouper leurs expressions et renforcer la précédence. Dans certains
      cas, les parenthèses sont requises car faisant partie de la syntaxe fixée
      d'une commande SQL particulière.
     </para>
    </listitem>

    <listitem>
     <para>
      Les crochets (<literal>[]</literal>) sont utilisés pour sélectionner les
      éléments d'un tableau. Voir la <xref linkend="arrays"/> pour plus
      d'informations sur les tableaux.
     </para>
    </listitem>

    <listitem>
     <para>
      Les virgules (<literal>,</literal>) sont utilisées dans quelques
      constructions syntaxiques pour séparer les éléments d'une liste.
     </para>
    </listitem>

    <listitem>
     <para>
      Le point-virgule (<literal>;</literal>) termine une commande SQL. Il ne
      peut pas apparaître quelque part dans une commande, sauf à l'intérieur
      d'une constante de type chaîne ou d'un identifieur entre guillemets.
     </para>
    </listitem>

    <listitem>
     <para>
      Le caractère deux points (<literal>:</literal>) est utilisé pour
      sélectionner des <quote>morceaux</quote> de tableaux (voir la <xref
      linkend="arrays"/>). Dans certains dialectes SQL (tel que le SQL embarqué),
      il est utilisé pour préfixer les noms de variable.
     </para>
    </listitem>

    <listitem>
     <para>
      L'astérisque (<literal>*</literal>) est utilisé dans certains contextes
      pour indiquer tous les champs de la ligne d'une table ou d'une valeur
      composite. Elle a aussi une signification spéciale lorsqu'elle est
      utilisée comme argument d'une fonction d'agrégat. Cela signifie que
      l'agrégat ne requiert par de paramètre explicite.
     </para>
    </listitem>

    <listitem>
     <para>
      Le point (<literal>.</literal>) est utilisé dans les constantes
      numériques et pour séparer les noms de schéma, table et colonne.
     </para>
    </listitem>
   </itemizedlist>

   </para>
  </sect2>

  <sect2 id="sql-syntax-comments">
   <title>Commentaires</title>

   <indexterm zone="sql-syntax-comments">
    <primary>commentaire</primary>
    <secondary sortas="SQL">en SQL</secondary>
   </indexterm>

   <para>
    Un commentaire est une séquence de caractères commençant avec
    deux tirets et s'étendant jusqu'à la fin de la ligne, par exemple&nbsp;:
<programlisting>-- Ceci est un commentaire standard en SQL</programlisting>
   </para>

   <para>
    Autrement, les blocs de commentaires style C peuvent être utilisés&nbsp;:
<programlisting>/* commentaires multilignes
 * et imbriqués: /* bloc de commentaire imbriqué */
 */</programlisting>
    où le commentaire commence avec <literal>/*</literal> et s'étend jusqu'à
    l'occurrence de <literal>*/</literal>. Ces blocs de commentaires
    s'imbriquent, comme spécifié dans le standard SQL mais pas comme dans le
    langage C. De ce fait, vous pouvez commenter des blocs importants de code
    pouvant contenir des blocs de commentaires déjà existants.
   </para>

   <para>
    Un commentaire est supprimé du flux en entrée avant une analyse plus
    poussée de la syntaxe et est remplacé par un espace blanc.
   </para>
  </sect2>

  <sect2 id="sql-precedence">
   <title>Précédence d'opérateurs</title>

   <indexterm zone="sql-precedence">
    <primary>opérateur</primary>
    <secondary>précédence</secondary>
   </indexterm>

   <para>
    Le <xref linkend="sql-precedence-table"/> affiche la précédence et
l'associativité des opérateurs dans <productname>PostgreSQL</productname>. La plupart des
opérateurs ont la même précédence et sont associatifs par la gauche. La
précédence et l'associativité des opérateurs sont codées en dur dans
l'analyseur. Ceci pourrait conduire à un comportement non intuitif&nbsp;; par
exemple, les opérateurs booléens <literal>&lt;</literal> et <literal>&gt;</literal> ont une
précédence différente des opérateurs booléens <literal>&lt;=</literal> et
<literal>&gt;=</literal>. De même, vous aurez quelque fois besoin d'ajouter des
parenthèses lors de l'utilisation de combinaisons d'opérateurs binaires et
unaires. Par exemple&nbsp;:
<programlisting>SELECT 5 ! - 6;</programlisting>
   sera analysé comme&nbsp;:
<programlisting>SELECT 5 ! (- 6);</programlisting>
    parce que l'analyseur n'a aucune idée, jusqu'à ce qu'il soit trop
    tard, que <token>!</token> est défini comme un opérateur suffixe, et non pas
    préfixe. Pour obtenir le comportement désiré dans ce cas, vous devez
    écrire&nbsp;:
<programlisting>SELECT (5 !) - 6;</programlisting>
    C'est le prix à payer pour l'extensibilité.
   </para>

   <table id="sql-precedence-table">
    <title>Précédence des opérateurs (en ordre décroissant)</title>

    <tgroup cols="3">
     <colspec colnum="1" colwidth="2*"/>
     <colspec colnum="2" colwidth="1*"/>
     <colspec colnum="3" colwidth="4*"/>
     <thead>
      <row>
       <entry>Opérateur/Élément</entry>
       <entry>Associativité</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><token>.</token></entry>
       <entry>gauche</entry>
       <entry>séparateur de noms de table et de colonne</entry>
      </row>

      <row>
       <entry><token>::</token></entry>
       <entry>gauche</entry>
       <entry>conversion de type,
        style <productname>PostgreSQL</productname></entry>
      </row>

      <row>
       <entry><token>[</token> <token>]</token></entry>
       <entry>gauche</entry>
       <entry>sélection d'un élément d'un tableau</entry>
      </row>

      <row>
       <entry><token>+</token> <token>-</token></entry>
       <entry>droite</entry>
       <entry>plus unaire, moins unaire</entry>
      </row>

      <row>
       <entry><token>^</token></entry>
       <entry>gauche</entry>
       <entry>exponentiel</entry>
      </row>

      <row>
       <entry><token>*</token> <token>/</token> <token>%</token></entry>
       <entry>gauche</entry>
       <entry>multiplication, division, modulo</entry>
      </row>

      <row>
       <entry><token>+</token> <token>-</token></entry>
       <entry>gauche</entry>
       <entry>addition, soustraction</entry>
      </row>

      <row>
       <entry><token>IS</token></entry>
       <entry></entry>
       <entry><literal>IS TRUE</literal>, <literal>IS FALSE</literal>,
        <literal>IS NULL</literal>, etc</entry>
      </row>

      <row>
       <entry><token>ISNULL</token></entry>
       <entry></entry>
       <entry>test pour NULL</entry>
      </row>

      <row>
       <entry><token>NOTNULL</token></entry>
       <entry></entry>
       <entry>test pour non NULL</entry>
      </row>

      <row>
       <entry>(autres)</entry>
       <entry>gauche</entry>
       <entry>tout autre opérateur natif et défini par l'utilisateur</entry>
      </row>

      <row>
       <entry><token>IN</token></entry>
       <entry></entry>
       <entry>appartenance à un ensemble</entry>
      </row>

      <row>
       <entry><token>BETWEEN</token></entry>
       <entry></entry>
       <entry>compris entre</entry>
      </row>

      <row>
       <entry><token>OVERLAPS</token></entry>
       <entry></entry>
       <entry>surcharge un intervalle de temps</entry>
      </row>

      <row>
       <entry><token>LIKE</token> <token>ILIKE</token>
<token>SIMILAR</token></entry>
       <entry></entry>
       <entry>correspondance de modèles de chaînes</entry>
      </row>

      <row>
       <entry><token>&lt;</token> <token>&gt;</token></entry>
       <entry></entry>
       <entry>inférieur, supérieur à</entry>
      </row>

      <row>
       <entry><token>=</token></entry>
       <entry>droite</entry>
       <entry>égalité, affectation</entry>
      </row>

      <row>
       <entry><token>NOT</token></entry>
       <entry>droite</entry>
       <entry>négation logique</entry>
      </row>

      <row>
       <entry><token>AND</token></entry>
       <entry>gauche</entry>
       <entry>conjonction logique</entry>
      </row>

      <row>
       <entry><token>OR</token></entry>
       <entry>gauche</entry>
       <entry>disjonction logique</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Notez que les règles de précédence des opérateurs s'appliquent aussi aux
    opérateurs définis par l'utilisateur qui ont le même nom que les
    opérateurs internes mentionnés ici. Par exemple, si vous définissez un
    opérateur <quote>+</quote> pour un type de données personnalisé, il aura la
    même précédence que l'opérateur interne <quote>+</quote>, peu importe ce
    que fait le votre.
   </para>

   <para>
    Lorsqu'un nom d'opérateur qualifié par un schéma est utilisé
    dans la syntaxe <literal>OPERATOR</literal>, comme par exemple dans&nbsp;:
<programlisting>SELECT 3 OPERATOR(pg_catalog.+) 4;</programlisting>
    la construction <literal>OPERATOR</literal> est prise pour avoir la
    précédence par défaut affichée dans le <xref linkend="sql-precedence-table"/>
    pour les opérateurs <quote>autres</quote>. Ceci est vrai quelque soit le nom
    spécifique de l'opérateur apparaissant à l'intérieur de
    <literal>OPERATOR()</literal>.
   </para>
  </sect2>
 </sect1>

 <sect1 id="sql-expressions">
  <title>Expressions de valeurs</title>

  <indexterm zone="sql-expressions">
   <primary>expression</primary>
   <secondary>syntaxe</secondary>
  </indexterm>

  <indexterm zone="sql-expressions">
   <primary>expression de valeur</primary>
  </indexterm>

  <indexterm>
   <primary>scalaire</primary>
   <see>expression</see>
  </indexterm>

  <para>
   Les expressions de valeurs sont utilisées dans une grande variété de
   contextes, tels que dans la liste cible d'une commande
   <command>SELECT</command>, dans les nouvelles valeurs de colonnes d'une
   commande <command>INSERT</command> ou <command>UPDATE</command>, ou dans les
   conditions de recherche d'un certain nombre de commandes. Le résultat d'une
   expression de valeurs est quelquefois appelé
   <firstterm>scalaire</firstterm>, pour le distinguer du résultat d'une
   expression de table (qui est une table). Les expressions de valeurs sont
   aussi appelées des <firstterm>expressions scalaires</firstterm> (voire même
   simplement des <firstterm>expressions</firstterm>). La syntaxe d'expression
   permet le calcul des valeurs à partir de morceaux primitifs en utilisant les
   opérations arithmétiques, logiques, d'ensemble et autres.
  </para>

  <para>
   Une expression de valeur peut être&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Une constante ou une valeur littérale.
     </para>
    </listitem>

    <listitem>
     <para>
      Une référence de colonne.
     </para>
    </listitem>

    <listitem>
     <para>
      Une référence de paramètre de position, dans le corps d'une définition de
      fonction ou d'instruction préparée.
     </para>
    </listitem>

    <listitem>
     <para>
      Une expression indicée.
     </para>
    </listitem>

    <listitem>
     <para>
      Une expression de sélection de champs.
     </para>
    </listitem>

    <listitem>
     <para>
      Un appel d'opérateur.
     </para>
    </listitem>

    <listitem>
     <para>
      Un appel de fonction.
     </para>
    </listitem>

    <listitem>
     <para>
      Une expression d'agrégat.
     </para>
    </listitem>

    <listitem>
     <para>
      Un appel de fonction window.
     </para>
    </listitem>

    <listitem>
     <para>
      Une conversion de type.
     </para>
    </listitem>

    <listitem>
     <para>
      Une expression de collationnement
     </para>
    </listitem>

    <listitem>
     <para>
      Une sous-requête scalaire.
     </para>
    </listitem>

    <listitem>
     <para>
      Un constructeur de tableau.
     </para>
    </listitem>

    <listitem>
     <para>
      Un constructeur de ligne.
     </para>
    </listitem>

    <listitem>
     <para>
      Toute expression de tableau entre parenthèses, utile pour grouper
      des sous-expressions et surcharger la
      précédence.<indexterm><primary>parenthèses</primary></indexterm>
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   En plus de cette liste, il existe un certain nombre de constructions pouvant
   être classées comme une expression mais ne suivant aucune règle de syntaxe
   générale. Elles ont généralement la sémantique d'une fonction ou d'un
   opérateur et sont expliquées à l'emplacement approprié dans le <xref
   linkend="functions"/>. Un exemple est la clause <literal>IS NULL</literal>.
  </para>

  <para>
   Nous avons déjà discuté des constantes dans la <xref
   linkend="sql-syntax-constants"/>. Les sections suivantes discutent des
   options restantes.
  </para>

  <sect2 id="sql-expressions-column-refs">
   <title>Références de colonnes</title>

   <indexterm>
    <primary>référence de colonne</primary>
   </indexterm>

   <para>
    Une colonne peut être référencée avec la forme
<synopsis><replaceable>correlation</replaceable>.<replaceable>nom_colonne</replaceable></synopsis>
   </para>

   <para>
    <replaceable>correlation</replaceable> est le nom d'une table (parfois
    qualifié par son nom de schéma) ou un alias d'une table définie au moyen de
    la clause <literal>FROM</literal>. Le nom de corrélation et le point de
    séparation peuvent être omis si
    le nom de colonne est unique dans les tables utilisées par la requête
    courante (voir aussi le <xref linkend="queries"/>).
   </para>
  </sect2>

  <sect2 id="sql-expressions-parameters-positional">
   <title>Paramètres de position</title>

   <indexterm>
    <primary>paramètre</primary>
    <secondary>syntaxe</secondary>
   </indexterm>

   <indexterm>
    <primary>$</primary>
   </indexterm>

   <para>
    Un paramètre de position est utilisé pour indiquer une valeur fournie en
    externe par une instruction SQL. Les paramètres sont utilisés dans des
    définitions de fonction SQL et dans les requêtes préparées. Quelques
    bibliothèques clients supportent aussi la spécification de valeurs de
    données séparément de la chaîne de commande SQL, auquel cas les paramètres
    sont utilisés pour référencer les valeurs de données en dehors. Le format
    d'une référence de paramètre est&nbsp;:
<synopsis>$<replaceable>numéro</replaceable></synopsis>
   </para>

   <para>
    Par exemple, considérez la définition d'une fonction&nbsp;:
    <function>dept</function> comme

<programlisting>CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE nom = $1 $$
    LANGUAGE SQL;</programlisting>

    Ici, <literal>$1</literal> référence la valeur du premier argument de la
    fonction à chaque appel de cette commande.
   </para>
  </sect2>

  <sect2 id="sql-expressions-subscripts">
   <title>Indices</title>

   <indexterm>
    <primary>indice</primary>
   </indexterm>

   <para>
    Si une expression récupère une valeur de type tableau, alors un élément
    spécifique du tableau peut être extrait en écrivant
<synopsis><replaceable>expression</replaceable>[<replaceable>indice</replaceable>]</synopsis>
    ou des éléments adjacents (un <quote>morceau de tableau</quote>) peuvent
    être extrait en écrivant
<synopsis><replaceable>expression</replaceable>[<replaceable>indice_bas</replaceable>:<replaceable>indice_haut</replaceable>]</synopsis>
    Ici, les crochets <literal>[ ]</literal> doivent apparaître littéralement.
    Chaque <replaceable>indice</replaceable> est lui-même une expression, qui
    doit contenir une valeur entière.
   </para>

   <para>
    En général, l'<replaceable>expression</replaceable> de type tableau doit
    être entre parenthèses mais ces dernières peuvent être omises lorsque l'expression à
    indicer est seulement une référence de colonne ou une position de paramètre.
    De plus, les indices multiples peuvent être concaténés lorsque le tableau
    original est multi-dimensionnel. Par exemple&nbsp;:

<programlisting>ma_table.colonnetableau[4]
ma_table.colonnes_deux_d[17][34]
$1[10:42]
(fonctiontableau(a,b))[42]
</programlisting>

    Dans ce dernier exemple, les parenthèses sont requises. Voir la <xref
    linkend="arrays"/> pour plus d'informations sur les tableaux.
   </para>
  </sect2>

  <sect2 id="field-selection">
   <title>Sélection de champs</title>

   <indexterm>
    <primary>sélection de champs</primary>
   </indexterm>

   <para>
    Si une expression récupère une valeur de type composite (type row), alors un
    champ spécifique de la ligne est extrait en écrivant
<synopsis><replaceable>expression</replaceable>.<replaceable>nom_champ</replaceable></synopsis>
   </para>

   <para>
    En général, l'<replaceable>expression</replaceable> de ligne doit être
    entre parenthèses mais les parenthèses peuvent être omises lorsque
    l'expression à partir de laquelle se fait la sélection est seulement une
    référence de table ou un paramètre de position. Par exemple&nbsp;:

<programlisting>ma_table.macolonne
$1.unecolonne
(fonctionligne(a,b)).col3</programlisting>

    Donc, une référence de colonne qualifiée est réellement un cas spécial de 
    syntaxe de sélection de champ. Un cas spécial important revient à extraire
    un champ de la colonne de type composite d'une table&nbsp;:

<programlisting>
(colcomposite).unchamp
(matable.colcomposite).unchamp
</programlisting>

    Les parenthèses sont requises ici pour montrer que
    <structfield>colcomposite</structfield> est un nom de colonne, et non pas
    un nom de table, ou que <structname>matable</structname> est un nom de
    table, pas un nom de schéma dans le deuxième cas.
   </para>

   <para>
    Dans une liste d'extraction (voir <xref linkend="queries-select-lists"/>),
    vous pouvez demander tous les champs d'une valeur composite en écrivant
    <literal>.*</literal>&nbsp;:
<programlisting>
(compositecol).*
</programlisting>
   </para>
  </sect2>

  <sect2 id="sql-expressions-operator-calls">
   <title>Appels d'opérateurs</title>

   <indexterm>
    <primary>opérateur</primary>
    <secondary>appel</secondary>
   </indexterm>

   <para>
    Il existe trois syntaxes possibles pour l'appel d'un opérateur&nbsp;:
    <simplelist>
     <member><replaceable>expression</replaceable>
     <replaceable>opérateur</replaceable> <replaceable>expression</replaceable>
     (opérateur binaire préfixe)</member>
     <member><replaceable>opérateur</replaceable>
     <replaceable>expression</replaceable> (opérateur unaire préfixe)</member>
     <member><replaceable>expression</replaceable>
     <replaceable>opérateur</replaceable> (opérateur unaire suffixe)</member>
    </simplelist>
    où le jeton <replaceable>opérateur</replaceable> suit les règles de syntaxe
    de la <xref linkend="sql-syntax-operators"/>, ou est un des mots clés
    <token>AND</token>, <token>OR</token> et <token>NOT</token>, ou est un nom
    d'opérateur qualifié de la forme
<synopsis><literal>OPERATOR(</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>nom_operateur</replaceable><literal>)</literal></synopsis>
    Quel opérateur particulier existe et est-il unaire ou binaire dépend des
    opérateurs définis par le système ou l'utilisateur. Le <xref
    linkend="functions"/> décrit les opérateurs internes.
   </para>
  </sect2>

  <sect2 id="sql-expressions-function-calls">
   <title>Appels de fonctions</title>

   <indexterm>
    <primary>fonction</primary>
    <secondary>appel</secondary>
   </indexterm>

   <para>
    La syntaxe pour un appel de fonction est le nom d'une fonction (qualifié ou
    non du nom du schéma) suivi par sa liste d'arguments entre
    parenthèses&nbsp;:

<synopsis><replaceable>nom_fonction</replaceable>(<optional><replaceable>expression</replaceable> <optional>,<replaceable>expression</replaceable> ...</optional></optional> )</synopsis>
   </para>

   <para>
    Par exemple, ce qui suit calcule la racine carré de 2&nbsp;:
<programlisting>sqrt(2)</programlisting>
   </para>

   <para>
    La liste des fonctions intégrées se trouve dans le <xref
    linkend="functions"/>. D'autres fonctions pourraient être ajoutées par
    l'utilisateur.
   </para>

   <para>
    En option, les arguments peuvent avoir leur nom attaché. Voir <xref
    linkend="sql-syntax-calling-funcs"/> pour les détails.
   </para>

   <note>
    <para>
     Une fonction qui prend un seul argument de type composite peut être
     appelée en plus en utilisant la syntaxe de sélection de champ. Du coup,
     un champ peut être écrit dans le style fonctionnel. Cela signifie que les
     notations <literal>col(table)</literal> et <literal>table.col</literal>
     ont interchangeables. Ce comportement ne respecte pas le standard SQL mais
     il est fourni dans <productname>PostgreSQL</productname> car il permet
     l'utilisation de fonctions émulant les <quote>champs calculés</quote>.
     Pour plus d'informations, voir <xref linkend="xfunc-sql-composite-functions"/>.
    </para>
   </note>
  </sect2>

  <sect2 id="syntax-aggregates">
   <title>Expressions d'agrégat</title>

   <indexterm zone="syntax-aggregates">
    <primary>fonction d'agrégat</primary>
    <secondary>appel</secondary>
   </indexterm>

   <para>
    Une <firstterm>expression d'agrégat</firstterm> représente l'application
    d'une fonction d'agrégat à travers les lignes sélectionnées par une requête.
    Une fonction d'agrégat réduit les nombres entrés en une seule valeur de
    sortie, comme la somme ou la moyenne des valeurs en entrée. La syntaxe d'une
    expression d'agrégat est une des suivantes&nbsp;:

<synopsis><replaceable>nom_agregat</replaceable> (<replaceable>expression</replaceable> [ , ... ] [ <replaceable>clause_order_by</replaceable> ] )
<replaceable>nom_agregat</replaceable> (ALL <replaceable>expression</replaceable> [ , ... ] [ <replaceable>clause_order_by</replaceable> ] )
<replaceable>nom_agregat</replaceable> (DISTINCT <replaceable>expression</replaceable> [ , ... ] [ <replaceable>clause_order_by</replaceable> ] )
<replaceable>nom_agregat</replaceable> ( * )</synopsis>

    où <replaceable>nom_agregat</replaceable> est un agrégat précédemment
    défini (parfois qualifié d'un nom de schéma),
    <replaceable>expression</replaceable> est toute expression de valeur qui ne
    contient pas lui-même une expression d'agrégat ou un appel à une fonction
    de fenêtrage. <replaceable>order_by_clause</replaceable> est une clause
    <literal>ORDER BY</literal> optionnelle comme décrite ci-dessous.
   </para>

   <para>
    La première forme d'expression d'agrégat appelle l'agrégat une fois pour
    chaque ligne en entrée. La seconde forme est identique à la première car
    <literal>ALL</literal> est ajouté par défaut. La troisième forme fait
    appel à l'agrégat une fois pour chaque valeur distincte de l'expression
    (ou ensemble distinct de valeurs, pour des expressions multiples) trouvée
    dans les lignes en entrée. La dernière forme appelle l'agrégat une
    fois pour chaque ligne en entrée&nbsp;; comme
    aucune valeur particulière en entrée n'est spécifiée, c'est généralement
    utile pour la fonction d'agrégat <function>count(*)</function>.
   </para>

   <para>
    La plupart des fonctions d'agrégats ignorent les entrées NULL, pour que
    les lignes pour lesquelles une ou plusieurs expressions renvoient NULL
    soient disqualifiées. Ceci peut être considéré vrai, sauf indication
    contraire pour tous les agrégats internes.
   </para>

   <para>
    Par exemple, <literal>count(*)</literal> trouve le nombre total de lignes
    en entrée&nbsp;; <literal>count(f1)</literal> récupère le nombre de lignes
    en entrée pour lesquelles <literal>f1</literal> n'est pas NULL, car la
    fonction <function>count</function> ignore les valeurs NULL&nbsp;; et
    <literal>count(distinct f1)</literal> retrouve le nombre de valeurs
    distinctes non NULL de <literal>f1</literal>.
   </para>

   <para>
    D'habitude, les lignes en entrée sont passées à la fonction d'agrégat dans
    un ordre non spécifié. Dans la plupart des cas, cela n'a pas d'importance.
    Par exemple, <function>min</function> donne le même résultat quelque soit
    l'ordre dans lequel il reçoit les données. Néanmoins, certaines fonctions
    d'agrégat (telle que <function>array_agg</function> et
    <function>string_agg</function>) donnent un résultat dépendant de l'ordre des
    lignes en entrée. Lors de l'utilisation de ce type d'agrégat, la clause
    <replaceable>clause_order_by</replaceable> peut être utilisée pour
    préciser l'ordre de tri désiré. La clause
    <replaceable>clause_order_by</replaceable> a la même syntaxe que la clause
    <literal>ORDER BY</literal> d'une requête, qui est décrite dans <xref
    linkend="queries-order"/>, sauf que ses expressions sont toujours des
    expressions simples et ne peuvent pas être des noms de colonne en sortie
    ou des numéros. Par exemple&nbsp;:

<programlisting>
SELECT array_agg(a ORDER BY b DESC) FROM table;
</programlisting>
   </para>

   <para>
    Lors de l'utilisation de fonctions d'agrégat à plusieurs arguments, la
    clause <literal>ORDER BY</literal> arrive après tous les arguments de
    l'agrégat. Par exemple, il faut écrire ceci&nbsp;:
<programlisting>
SELECT string_agg(a, ',' ORDER BY a) FROM table;
</programlisting>
    et non pas ceci&nbsp;:
<programlisting>
SELECT string_agg(a ORDER BY a, ',') FROM table;  -- incorrect
</programlisting>
    Ce dernier est syntaxiquement correct mais il concerne un appel à une
    fonction d'agrégat à un seul argument avec deux clés pour le
    <literal>ORDER BY</literal> (le deuxième étant inutile car il est
    constant).
   </para>

   <para>
    Si <literal>DISTINCT</literal> est indiqué en plus d'une
    <replaceable>clause_order_by</replaceable>, alors toutes les expressions
    de l'<literal>ORDER BY</literal> doivent correspondre aux arguments de
    l'agrégat&nbsp;; autrement dit, vous ne pouvez pas trier sur une expression
    qui n'est pas incluse dans la liste <literal>DISTINCT</literal>.
   </para>

   <note>
    <para>
     La possibilité de spécifier à la fois <literal>DISTINCT</literal> et
     <literal>ORDER BY</literal> dans une fonction d'agrégat est une extension
     de <productname>PostgreSQL</productname>.
    </para>
   </note>

   <para>
    Les fonctions d'agrégat prédéfinies sont décrites dans la <xref
    linkend="functions-aggregate"/>. D'autres fonctions d'agrégat
    pourraient être ajoutées par l'utilisateur. 
   </para>

   <para>
    Une expression d'agrégat pourrait apparaître dans la liste de résultat ou
    dans la clause <literal>HAVING</literal> d'une commande <command>SELECT</command>. Elle est
    interdite dans d'autres clauses, telles que <literal>WHERE</literal>, parce que ces
    clauses sont logiquement évaluées avant que les résultats des agrégats ne
    soient formés.
   </para>

   <para>
    Lorsqu'une expression d'agrégat apparaît dans une sous-requête (voir la
    <xref linkend="sql-syntax-scalar-subqueries"/> et la
    <xref linkend="functions-subquery"/>), l'agrégat est normalement évalué sur
    les lignes de la sous-requête. Mais, une exception arrive si les arguments de
    l'agrégat contiennent seulement des niveaux externes de variables&nbsp;:
    ensuite, l'agrégat appartient au niveau externe le plus proche et est évalué
    sur les lignes de cette requête. L'expression de l'agrégat en un tout est
    une référence externe pour la sous-requête dans laquelle il apparaît et agit
    comme une constante sur toute évaluation de cette requête. La restriction
    apparaissant seulement dans la liste de résultat ou dans la clause
    <literal>HAVING</literal> s'applique avec respect du niveau de requête auquel
    appartient l'agrégat.
   </para>
  </sect2>

  <sect2 id="syntax-window-functions">
   <title>Appels de fonction window</title>

   <indexterm zone="syntax-window-functions">
    <primary>fonction window</primary>
    <secondary>appel</secondary>
   </indexterm>

   <indexterm zone="syntax-window-functions">
    <primary>clause OVER</primary>
   </indexterm>

   <para>
    Un <firstterm>appel de fonction window</firstterm> représente l'application
    d'une fonction de type agrégat sur une portion des lignes sélectionnées
    par une requête. Contrairement aux appels de fonction d'agrégat standard,
    ce n'est pas lié au groupement des lignes sélectionnées en une seule ligne
    résultat &mdash; chaque ligne reste séparée dans les résultats. Néanmoins,
    la fonction window est capable de parcourir toutes les lignes qui font
    partie du groupe de la ligne courante d'après la spécification du groupe
    (liste <literal>PARTITION BY</literal>) de l'appel de la fonction window.
    La syntaxe d'un appel de fonction window est une des suivantes&nbsp;:

<synopsis>
<replaceable>nom_fonction</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) OVER ( <replaceable class="parameter">définition_window</replaceable> )
<replaceable>nom_fonction</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) OVER <replaceable>nom_window</replaceable>
<replaceable>nom_fonction</replaceable> ( * ) OVER ( <replaceable class="parameter">définition_window</replaceable> )
<replaceable>nom_fonction</replaceable> ( * ) OVER <replaceable>nom_window</replaceable>
</synopsis>
    où <replaceable class="parameter">définition_window</replaceable> a comme
    syntaxe&nbsp;:
<synopsis>
[ <replaceable class="parameter">nom_window_existante</replaceable> ]
[ PARTITION BY <replaceable class="parameter">expression</replaceable> [, ...] ]
[ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">opérateur</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <replaceable class="parameter">clause_frame</replaceable> ]
</synopsis>
    et la clause <replaceable class="parameter">clause_frame</replaceable>
    optionnelle fait partie de&nbsp;:
<synopsis>
[ RANGE | ROWS ] <replaceable>début_frame</replaceable>
[ RANGE | ROWS ] BETWEEN <replaceable>début_frame</replaceable> AND <replaceable>fin_frame</replaceable>
</synopsis>
    avec <replaceable>début_frame</replaceable> et
    <replaceable>fin_frame</replaceable> pouvant faire partie de
<synopsis>
UNBOUNDED PRECEDING
<replaceable>valeur</replaceable> PRECEDING
CURRENT ROW
<replaceable>valeur</replaceable> FOLLOWING
UNBOUNDED FOLLOWING
</synopsis>
   </para>

   <para>
    Ici, <replaceable>expression</replaceable> représente toute expression de
    valeur qui ne contient pas elle-mêle d'appel à des fonctions window. Les
    listes <literal>PARTITION BY</literal> et <literal>ORDER BY</literal> ont
    essentiellement la même syntaxe et la même sémantique que les clauses
    <literal>GROUP BY</literal> et <literal>ORDER BY</literal> de la requête
    complète, sauf que leur expressions sont toujours seulement des expressions
    et ne peuvent pas être des noms ou des numéros de colonnes en sortie.
    <replaceable>nom_window</replaceable> est une référence à la
    spécification d'une window nommée, définie dans la clause
    <literal>WINDOW</literal> de la requête. Les spécifications window nommées
    sont habituellement référencées avec <literal>OVER</literal>
    <replaceable>nom_window</replaceable>, mais il est aussi possible d'écrire
    un nom de window entre parenthèses, puis de fournir en option une clause
    de tri et/ou une clause frame (le window reférencé ne doit pas avoir ces
    clauses si elles sont fournies ici). Cette dernière syntaxe suit les même
    règles que la modification d'un nom de window existant dans une clause
    <literal>WINDOW</literal>&nbsp;; voir la page de référence de
    <xref linkend="sql-select"/> pour les détails.
   </para>

   <para>
    La clause <replaceable class="parameter">clause_frame</replaceable> indique
    l'ensemble de lignes constituant le <firstterm>frame window</firstterm>,
    pour les fonctions window qui agissent sur le frame et non pas sur la
    partition entière.
    Si <replaceable>fin_frame</replaceable> est omis, sa valeur par défaut est
    <literal>CURRENT ROW</literal>. Les restrictions sont les suivantes&nbsp;:
    <replaceable>début_frame</replaceable> ne peut pas valoir
    <literal>UNBOUNDED FOLLOWING</literal>,
    <replaceable>fin_frame</replaceable> ne peut pas valoir <literal>UNBOUNDED
    PRECEDING</literal> et <replaceable>fin_frame</replaceable> ne peut pas
    apparaître avant <replaceable>début_frame</replaceable> &mdash; par
    exemple, <literal>RANGE BETWEEN CURRENT ROW AND
    <replaceable>valeur</replaceable> PRECEDING</literal> n'est pas autorisé.
    L'option de frame par défaut est <literal>RANGE UNBOUNDED
    PRECEDING</literal>, qui est identique à <literal>RANGE BETWEEN UNBOUNDED
    PRECEDING AND CURRENT ROW</literal>&nbsp;; cela configure la frame à toutes
    les lignes à partir du début de la partition jusqu'à la ligne actuelle du
    prochain dans l'ordre du <literal>ORDER BY</literal> (ce qui signifie
    toutes les lignes si la clause <literal>ORDER BY</literal> est absente).
    En général, <literal>UNBOUNDED PRECEDING</literal> signifie que la frame
    commence avec la première ligne de la partition et, de façon similaire,
    <literal>UNBOUNDED FOLLOWING</literal> signifie que la frame se termine
    avec la dernière ligne de la partition (quel que soit le mode,
    <literal>RANGE</literal> ou <literal>ROWS</literal>. Dans le mode
    <literal>ROWS</literal>, <literal>CURRENT ROW</literal> signifie que la
    frame commence ou finit avec la ligne actuelle&nbsp;; mais dans le mode
    <literal>RANGE</literal>, cela signifie que la frame commence ou finit avec
    le premier ou le prochain élément à partir de la ligne actuel dans l'ordre
    indiqué par la clause <literal>ORDER BY</literal>. Les cas
    <replaceable>valeur</replaceable> <literal>PRECEDING</literal> et
    <replaceable>valeur</replaceable> <literal>FOLLOWING</literal> sont
    actuellement seulement autorisés dans le mode <literal>ROWS</literal>. Ils
    indiquent que la frame commence ou finit avec la ligne qui se trouve à ce
    nombre de lignes avant ou après la ligne actuelle.
    <replaceable>valeur</replaceable> doit être une expression entière ne
    contenant aucune variable, fonction d'agrégat ou fonction de fenêtrage. La
    valeur ne doit pas être NULL ou négative. Par contre, elle peut valoir
    zéro, ce qui a pour effet de sélectionner la ligne actuelle.
   </para>

   <para>
    Les fonctions window internes sont décrites dans <xref
    linkend="functions-window-table"/>. D'autres fonctions window peuvent être
    ajoutées par l'utilisateur. De plus, toute fonction d'agrégat interne ou
    définie par l'utilisateur peut être utilisée comme fonction window.
   </para>

   <para>
    Les syntaxes utilisant <literal>*</literal> sont utilisées pour appeler des
    fonctions d'agrégats sans paramètres en tant que fonctions window.
    Par exemple&nbsp;: <literal>count(*) OVER (PARTITION BY x ORDER BY y)</literal>.
    <literal>*</literal> n'est habituellement pas utilisé pour les fonctions window
    qui ne sont pas des agrégats. Les fonctions window agrégats, contrairement aux
    fonctions d'agrégats normales, n'autorisent pas l'utilisation de
    <literal>DISTINCT</literal> ou <literal>ORDER BY</literal> dans la liste
    des arguments de la fonction.
   </para>

   <para>
    Les appels de fonctions window sont autorisés seulement dans la liste
    <literal>SELECT</literal> et dans la clause <literal>ORDER BY</literal> de
    la requête.
   </para>

   <para>
    Il existe plus d'informations sur les fonctions de fenêtrages dans le
    <xref linkend="tutorial-window"/>, <xref linkend="functions-window"/> et
    dans le <xref linkend="queries-window"/>.
   </para>
  </sect2>

  <sect2 id="sql-syntax-type-casts">
   <title>Conversions de type</title>

   <indexterm>
    <primary>type de données</primary>
    <secondary>conversion de type</secondary>
   </indexterm>

   <indexterm>
    <primary>conversion de type</primary>
   </indexterm>

   <indexterm>
    <primary>::</primary>
   </indexterm>

   <para>
    Une conversion de type spécifie une conversion à partir d'un type de
    données en un autre. <productname>PostgreSQL</productname> accepte deux
    syntaxes équivalentes pour les conversions de type&nbsp;:
<synopsis>CAST ( <replaceable>expression</replaceable> AS <replaceable>type</replaceable> )
<replaceable>expression</replaceable>::<replaceable>type</replaceable></synopsis>
    La syntaxe <literal>CAST</literal> est conforme à SQL&nbsp;; la syntaxe avec
    <literal>::</literal> est historique dans
    <productname>PostgreSQL</productname>.
   </para>

   <para>
    Lorsqu'une conversion est appliquée à une expression de valeur pour un
    type connu, il représente une conversion de type à l'exécution. Cette
    conversion réussira seulement si une opération convenable de conversion de
    type a été définie. Notez que ceci est subtilement différent de
    l'utilisation de conversion avec des constantes, comme indiqué dans la <xref
    linkend="sql-syntax-constants-generic"/>. Une conversion appliquée à une
    chaîne littérale représente l'affectation initiale d'un type pour une
    valeur constante littérale, et donc cela réussira pour tout type (si le
    contenu de la chaîne littérale est une syntaxe acceptée en entrée pour le
    type de donnée).
   </para>

   <para>
    Une conversion de type explicite pourrait être habituellement omise s'il
    n'y a pas d'ambiguïté sur le type qu'une expression de valeur pourrait
    produire (par exemple, lorsqu'elle est affectée à une colonne de
    table)&nbsp;; le système appliquera automatiquement une conversion de type
    dans de tels cas. Néanmoins, la conversion automatique est réalisée
    seulement pour les conversions marquées <quote>OK pour application
    implicite</quote> dans les catalogues système. D'autres conversions peuvent être
    appelées avec la syntaxe de conversion explicite. Cette restriction a pour
    but d'empêcher l'application silencieuse de conversions surprenantes.
   </para>

   <para>
    Il est aussi possible de spécifier une conversion de type en utilisant une
    syntaxe de type fonction&nbsp;:
<synopsis><replaceable>nom_type</replaceable> ( <replaceable>expression</replaceable> )</synopsis>
    Néanmoins, ceci fonctionne seulement pour les types dont les noms sont 
    aussi valides en tant que noms de fonctions. Par exemple, <literal>double
    precision</literal> ne peut pas être utilisé de cette façon mais son
    équivalent <literal>float8</literal> le peut. De même, les noms
    <literal>interval</literal>, <literal>time</literal> et <literal>timestamp</literal> peuvent
    seulement être utilisés de cette façon s'ils sont entre des guillemets
    doubles à cause des conflits de syntaxe. Du coup, l'utilisation de la
    syntaxe de conversion du style fonction amène à des inconsistances et
    devrait probablement être évitée.
   </para>
   <note>
    <para>
     La syntaxe style fonction est en fait seulement un appel de fonction.
     Quand un des deux standards de syntaxe de conversion est utilisé pour faire
     une conversion à l'exécution, elle appellera en interne une fonction
     enregistrée pour réaliser la conversion. Par convention, ces fonctions de
     conversion ont le même nom que leur type de sortie et, du coup, la
     <quote>syntaxe style fonction</quote> n'est rien de plus qu'un appel direct à la
     fonction de conversion sous-jacente. Évidemment, une application portable ne
     devrait pas s'y fier. Pour plus d'informations, voir
     <xref linkend="sql-createcast"/>.
    </para>
   </note>
  </sect2>

  <sect2 id="sql-syntax-collate-exprs">
   <title>Expressions de collationnement</title>

   <indexterm>
    <primary>COLLATE</primary>
   </indexterm>

   <para>
    La clause <literal>COLLATE</literal> surcharge le collationnement d'une
    expression. Elle est ajoutée à l'expression à laquelle elle s'applique&nbsp;:
<synopsis>
<replaceable>expr</replaceable> COLLATE <replaceable>collation</replaceable>
</synopsis>
    où <replaceable>collation</replaceable> est un identifiant pouvant être
    qualifié par son schéma. La clause <literal>COLLATE</literal> a priorité
    par rapport aux opérateurs&nbsp;; des parenthèses peuvent être
    utilisées si nécessaire.
   </para>

   <para>
    Si aucun collationnement n'est spécifiquement indiqué, le système de bases
    de données déduit cette information du collationnement des colonnes
    impliquées dans l'expression. Si aucune colonne ne se trouve dans
    l'expression, il utilise le collationnement par défaut de la base de
    données.
   </para>

   <para>
    Les deux utilisations principales de la clause <literal>COLLATE</literal>
    sont la surcharge de l'ordre de tri dans une clause <literal>ORDER
    BY</literal> clause, par exemple&nbsp;:
<programlisting>
SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE "C";
</programlisting>
    et la surcharge du collationnement d'une fonction ou d'un opérateur qui
    produit un résultat sensible à la locale, par exemple&nbsp;:
<programlisting>
SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE "C";
</programlisting>
    Notez que dans le dernier cas, la clause <literal>COLLATE</literal> est
    attachée à l'argument en entrée de l'opérateur. Peu importe l'argument de
    l'opérateur ou de la fonction qui a la clause <literal>COLLATE</literal>
    parce que le collationnement appliqué à l'opérateur ou à la fonction est
    dérivé en considérant tous les arguments, et une clause
    <literal>COLLATE</literal> explicite surchargera les collationnements des
    autres arguments. (Attacher des clauses <literal>COLLATE</literal>
    différentes sur les arguments aboutit à une erreur. Pour plus de détails,
    voir <xref linkend="collation"/>.) Du coup, ceci donne le même résultat
    que l'exemple précédent&nbsp;:
<programlisting>
SELECT * FROM tbl WHERE a COLLATE "C" &gt; 'foo';
</programlisting>
    Mais ceci est une erreur&nbsp;:
<programlisting>
SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE "C";
</programlisting>
    cat cette requête cherche à appliquer un collationnement au résultat de
    l'opérateur <literal>&gt;</literal>, qui est du type <type>boolean</type>,
    type non collationnable.
   </para>
  </sect2>

  <sect2 id="sql-syntax-scalar-subqueries">
   <title>Sous-requêtes scalaires</title>

   <indexterm>
    <primary>sous-requête</primary>
   </indexterm>

   <para>
    Une sous-requête scalaire est une requête <command>SELECT</command>
    ordinaire entre parenthèses renvoyant exactement une ligne avec une colonne
    (voir le <xref linkend="queries"/> pour plus d'informations sur l'écriture
    des requêtes). La requête <command>SELECT</command> est exécutée et la
    seule valeur renvoyée est utilisée dans l'expression de valeur englobante.
    C'est une erreur d'utiliser une requête qui renvoie plus d'une ligne ou plus
    d'une colonne comme requête scalaire. Mais si, lors d'une exécution
    particulière, la sous-requête ne renvoie pas de lignes, alors il n'y a pas
    d'erreur&nbsp;; le résultat scalaire est supposé NULL. La sous-requête peut
    référencer des variables de la requête englobante, qui agiront comme des
    constantes durant toute évaluation de la sous-requête. Voir aussi la <xref
    linkend="functions-subquery"/> pour d'autres expressions impliquant des
    sous-requêtes.
   </para>

   <para>
    Par exemple, ce qui suit trouve la ville disposant de la population la plus
    importante dans chaque état&nbsp;:
<programlisting>SELECT nom, (SELECT max(pop) FROM villes WHERE villes.etat = etat.nom)
    FROM etats;</programlisting>
   </para>
  </sect2>

  <sect2 id="sql-syntax-array-constructors">
   <title>Constructeurs de tableaux</title>

   <indexterm>
    <primary>tableau</primary>
    <secondary>constructeur</secondary>
   </indexterm>

   <indexterm>
    <primary>ARRAY</primary>
   </indexterm>

   <para>
    Un constructeur de tableau est une expression qui construit une valeur de
    tableau à partir de valeurs de ses membres. Un constructeur de tableau
    simple utilise le mot clé <literal>ARRAY</literal>, un crochet ouvrant
    <literal>[</literal>, une liste d'expressions (séparées par des virgules)
    pour les valeurs des éléments du tableau et finalement un crochet fermant
    <literal>]</literal>. Par exemple&nbsp;:
<programlisting>SELECT ARRAY[1,2,3+4];
  array
---------
 {1,2,7}
(1 row)</programlisting>
    Par défaut, le type d'élément du tableau est le type commun des expressions des membres,
    déterminé en utilisant les mêmes règles que pour les constructions
    <literal>UNION</literal> ou <literal>CASE</literal> (voir la <xref
    linkend="typeconv-union-case"/>).
    Vous pouvez surcharger ceci en convertissant explicitement le constructeur
    de tableau vers le type désiré. Par exemple&nbsp;:
<programlisting>
SELECT ARRAY[1,2,22.7]::integer[];
  array
----------
 {1,2,23}
(1 row)
</programlisting>
    Ceci a le même effet que la conversion de chaque expression vers le type
    d'élément du tableau individuellement. Pour plus d'informations sur les
    conversions, voir <xref linkend="sql-syntax-type-casts"/>.
   </para>

   <para>
    Les valeurs de tableaux multidimensionnels peuvent être construits par des
    constructeurs de tableaux imbriqués. Pour les constructeurs internes, le mot
    clé <literal>ARRAY</literal> peut être omis. Par exemple, ces
    expressions produisent le même résultat&nbsp;:

<programlisting>SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)</programlisting>

    Comme les tableaux multidimensionnels doivent être rectangulaires, les
    constructeurs internes du même niveau doivent produire des
    sous-tableaux de dimensions identiques.
    Toute conversion appliquée au constructeur <literal>ARRAY</literal> externe se
    propage automatiquement à tous les constructeurs internes.
  </para>

  <para>
    Les éléments d'un constructeur de tableau multidimensionnel peuvent être
    tout ce qui récupère un tableau du bon type, pas seulement une construction
    d'un tableau imbriqué. Par exemple&nbsp;:
<programlisting>CREATE TABLE tab(f1 int[], f2 int[]);

INSERT INTO tab VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);

SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM tab;
                     array
------------------------------------------------
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)
</programlisting>
  </para>

  <para>
   Vous pouvez construire un tableau vide mais, comme il est impossible d'avoir
   un tableau sans type, vous devez convertir explicitement votre tableau vide
   dans le type désiré. Par exemple&nbsp;:
<programlisting>
SELECT ARRAY[]::integer[];
 array
-------
 {}
(1 row)</programlisting>
  </para>

  <para>
   Il est aussi possible de construire un tableau à partir des résultats d'une
   sous-requête. Avec cette forme, le constructeur de tableau est écrit avec le
   mot clé <literal>ARRAY</literal> suivi par une sous-requête entre
   parenthèses (et non pas des crochets). Par exemple&nbsp;:
<programlisting>SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                                 array
-----------------------------------------------------------------------
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412,2413}
(1 row)</programlisting>
   La sous-requête doit renvoyer une seule colonne. Le tableau à une dimension
   résultant aura un élément pour chaque ligne dans le résultat de la
   sous-requête, avec un type élément correspondant à celui de la colonne en
   sortie de la sous-requête.
  </para>

  <para>
   Les indices d'une valeur de tableau construit avec <literal>ARRAY</literal>
   commencent toujours à un. Pour plus d'informations sur les tableaux, voir la
   <xref linkend="arrays"/>.
  </para>

  </sect2>

  <sect2 id="sql-syntax-row-constructors">
    <title>Constructeurs de lignes</title>

    <indexterm>
      <primary>type composite</primary>
      <secondary>constructeur</secondary>
    </indexterm>

    <indexterm>
      <primary>type de ligne</primary>
      <secondary>constructeur</secondary>
    </indexterm>

    <indexterm>
      <primary>ROW</primary>
    </indexterm>

    <para>
      Un constructeur de ligne est une expression qui construit une valeur de
      ligne (aussi appelée une valeur composite) à partir des valeurs de ses
      membres. Un constructeur de ligne consiste en un mot clé
      <literal>ROW</literal>, une parenthèse gauche, zéro ou plus d'une
      expression (séparées par des virgules) pour les valeurs des champs de la
      ligne, et finalement une parenthèse droite. Par exemple&nbsp;:
      <programlisting>SELECT ROW(1,2.5,'ceci est un test');</programlisting>
      Le mot clé <literal>ROW</literal> est optionnel lorsqu'il y a plus d'une expression
      dans la liste.
  </para>

   <para>
    Un constructeur de ligne peut inclure la syntaxe
    <replaceable>rowvalue</replaceable><literal>.*</literal>, qui sera étendue
    en une liste d'éléments de la valeur ligne, ce qui arrive lorsque la syntaxe
    <literal>.*</literal> est utilisée au niveau haut d'une liste
    <command>SELECT</command>. Par exemple, si la table <literal>t</literal> a
    les colonnes <literal>f1</literal> et <literal>f2</literal>, elles sont
    identiques&nbsp;:
<programlisting>
SELECT ROW(t.*, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;
</programlisting>
   </para>

   <note>
    <para>
     Avant <productname>PostgreSQL</productname> 8.2, la syntaxe
     <literal>.*</literal> n'était pas étendue, pour que écrire
     <literal>ROW(t.*, 42)</literal> crée une ligne à deux champs dont le premier
     est une autre valeur de ligne. Le nouveau comportement est habituellement
     plus utile. Si vous avez besoin de l'ancien comportement de valeurs de ligne
     imbriquées, écrivez la valeur de ligne interne sans <literal>.*</literal>,
     par exemple <literal>ROW(t, 42)</literal>.
    </para>
   </note>

  <para>
    Par défaut, la valeur créée par une expression <literal>ROW</literal> est d'un
    type d'enregistrement anonyme. Si nécessaire, il peut être converti en un
    type composite nommé &mdash; soit le type de ligne d'une table soit un type
    composite créé avec <command>CREATE TYPE AS</command>. Une conversion explicite
    pourrait être nécessaire pour éviter une ambiguïté. Par exemple&nbsp;:
<programlisting>CREATE TABLE ma_table(f1 int, f2 float, f3 text);

CREATE FUNCTION recup_f1(ma_table) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- Aucune conversion nécessaire parce que seul un recup_f1() existe
SELECT recup_f1(ROW(1,2.5,'ceci est un test'));
 recup_f1
----------
1
(1 row)

CREATE TYPE mon_typeligne AS (f1 int, f2 text, f3 numeric);

CREATE FUNCTION recup_f1(mon_typeligne) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- Maintenant, nous avons besoin d'une conversion
-- pour indiquer la fonction à appeler:
SELECT recup_f1(ROW(1,2.5,'ceci est un test'));
ERROR:  function recup_f1(record) is not unique

SELECT recup_f1(ROW(1,2.5,'ceci est un test')::ma_table);
 getf1
-------
 1
(1 row)

SELECT recup_f1(CAST(ROW(11,'ceci est un test',2.5) AS mon_typeligne));
 getf1
-------
 11
(1 row)</programlisting>
</para>

  <para>
   Les constructeurs de lignes peuvent être utilisés pour construire des valeurs
   composites à stocker dans une colonne de table de type composite ou pour être
   passé à une fonction qui accepte un paramètre composite. De plus, il est
   possible de comparer deux valeurs de lignes ou pour tester une ligne avec
   <literal>IS NULL</literal> ou <literal>IS NOT NULL</literal>, par exemple
<programlisting>SELECT ROW(1,2.5,'ceci est un test') = ROW(1, 3, 'pas le même');

SELECT ROW(table.*) IS NULL FROM table; -- détecte toutes les lignes non NULL</programlisting>
   Pour plus de détails, voir la <xref linkend="functions-comparisons"/>. Les
   constructeurs de lignes peuvent aussi être utilisés en connexion avec
   des sous-requêtes, comme discuté dans la <xref linkend="functions-subquery"/>.
  </para>

  </sect2>

  <sect2 id="syntax-express-eval">
   <title>Règles d'évaluation des expressions</title>

   <indexterm>
    <primary>expression</primary>
    <secondary>ordre d'évaluation</secondary>
   </indexterm>

   <para>
    L'ordre d'évaluation des sous-expressions n'est pas défini. En   
    particulier, les entrées d'un opérateur ou d'une fonction ne sont pas
    nécessairement évaluées de la gauche vers la droite ou dans un autre ordre
    fixé.
   </para>

   <para>
    De plus, si le résultat d'une expression peut être déterminé par
    l'évaluation de certaines parties de celle-ci, alors d'autres
    sous-expressions devraient ne pas être évaluées du tout. Par exemple, si
    vous écrivez&nbsp;:
<programlisting>SELECT true OR une_fonction();</programlisting>
    alors <literal>une_fonction()</literal> pourrait (probablement) ne pas être
    appelée du tout. Pareil dans le cas suivant&nbsp;:
<programlisting>SELECT une_fonction() OR true;</programlisting>
    Notez que ceci n'est pas identique au <quote>court-circuitage</quote> de
    gauche à droite des opérateurs booléens utilisé par certains langages de
    programmation.
   </para>

   <para>
    En conséquence, il est déconseillé d'utiliser des fonctions ayant des
    effets de bord dans une partie des expressions complexes. Il est
    particulièrement dangereux de se fier aux effets de bord ou à l'ordre
    d'évaluation dans les clauses <literal>WHERE</literal> et <literal>HAVING</literal> car
    ces clauses sont reproduites de nombreuses fois lors du développement du
    plan d'exécution. Les expressions booléennes (combinaisons
    <literal>AND</literal>/<literal>OR</literal>/<literal>NOT</literal>) dans ces clauses pourraient
    être réorganisées d'une autre façon autorisée dans l'algèbre
    booléenne.
   </para>

   <para>
    Quand il est essentiel de forcer l'ordre d'évaluation, une construction
    <literal>CASE</literal> (voir la <xref linkend="functions-conditional"/>) peut
être utilisée. Par exemple, c'est une façon, non sûre, d'essayer d'éviter
une division par zéro dans une clause <literal>WHERE</literal>&nbsp;:
<programlisting>SELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;</programlisting>
    Mais ceci est sûr&nbsp;:
<programlisting>SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;</programlisting>
    Une construction <literal>CASE</literal> utilisée de cette façon déjouera les
    tentatives d'optimisation, donc cela ne sera fait que si nécessaire (dans
    cet exemple particulier, il serait sans doute mieux de contourner le
    problème en écrivant <literal>y &gt; 1.5*x</literal>).
   </para>
  </sect2>
 </sect1>

 <sect1 id="sql-syntax-calling-funcs">
  <title>Fonctions appelantes</title>

   <indexterm zone="sql-syntax-calling-funcs">
    <primary>notation</primary>
    <secondary>fonctions</secondary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> permet aux fonctions qui ont des
    paramètres nommés d'être appelées en utilisant soit la notation par
    <firstterm>position</firstterm> soit la notation par
    <firstterm>nom</firstterm>. La notation par nom est particulièrement utile
    pour les fonctions qui ont un grand nombre de paramètres car elle rend
    l'association entre paramètre et argument plus explicite et fiable. Dans
    la notation par position, un appel de fonction précise les valeurs
    en argument dans le même ordre que ce qui a été défini à la création de la
    fonction. Dans la notation nommée, les arguments sont précisés par leur
    nom et peuvent du coup être intégrés dans n'importe quel ordre.
   </para>

   <para>
    Quel que soit la notation, les paramètres qui ont des valeurs par défaut
    dans leur déclaration n'ont pas besoin d'être précisés dans l'appel. Ceci
    est particulièrement utile dans la notation nommée car toute combinaison
    de paramètre peut être omise alors que dans la notation par position, les
    paramètres peuvent seulement être omis de la droite vers la gauche.
   </para>

   <para>
    <productname>PostgreSQL</productname> supporte aussi la notation
    <firstterm>mixée</firstterm>. Elle combine la notation par position avec
    la notation par nom. Dans ce cas, les paramètres de position sont écrits
    en premier, les paramètres nommés apparaissent après.
   </para>

   <para>
    Les exemples suivants illustrent l'utilisation des trois notations, en
    utilisant la définition de fonction suivante&nbsp;:
<programlisting>
CREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false)
RETURNS text
AS
$$
 SELECT CASE
        WHEN $3 THEN UPPER($1 || ' ' || $2)
        ELSE LOWER($1 || ' ' || $2)
        END;
$$
LANGUAGE SQL IMMUTABLE STRICT;
</programlisting>
    La fonction <function>concat_lower_or_upper</function> a deux paramètres
    obligatoires, <literal>a</literal> et <literal>b</literal>. Il existe en
    plus un paramètre optionnel, <literal>uppercase</literal>, qui vaut par
    défaut <literal>false</literal>. Les arguments <literal>a</literal> et
    <literal>b</literal> seront concaténés et forcés soit en majuscule soit en
    minuscule suivant la valeur du paramètre <literal>uppercase</literal>. Les
    détails restant ne sont pas importants ici (voir <xref linkend="extend"/>
    pour plus d'informations).
   </para>

   <sect2 id="sql-syntax-calling-funcs-positional">
    <title>En utilisant la notation par position</title>

    <indexterm>
     <primary>fonction</primary>
     <secondary>notation par position</secondary>
    </indexterm>

    <para>
     La notation par position est le mécanisme traditionnel pour passer des
     arguments aux fonctions avec <productname>PostgreSQL</productname>. En
     voici un exemple&nbsp;:
<screen>
SELECT concat_lower_or_upper('Hello', 'World', true);
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen>
     Tous les arguments sont indiqués dans l'ordre. Le résultat est en
     majuscule car l'argument <literal>uppercase</literal> est indiqué à
     <literal>true</literal>. Voici un autre exemple&nbsp;:
<screen>
SELECT concat_lower_or_upper('Hello', 'World');
 concat_lower_or_upper 
-----------------------
 hello world
(1 row)
</screen>
     Ici, le paramètre <literal>uppercase</literal> est omis, donc il récupère
     la valeur par défaut, soit <literal>false</literal>, ce qui a pour
     résultat une sortie en minuscule. Dans la notation par position, les
     arguments peuvent être omis de la droite à la gauche à partir du moment
     où ils ont des valeurs par défaut.
    </para>
   </sect2>

   <sect2 id="sql-syntax-calling-funcs-named">
    <title>En utilisant la notation par nom</title>

    <indexterm>
     <primary>fonction</primary>
     <secondary>notation par nom</secondary>
    </indexterm>

    <para>
     Dans la notation par nom, chaque nom d'argument est précisé en utilisant
     <literal>:=</literal> pour le séparer de l'expression de la valeur de
     l'argument.
     Par exemple&nbsp;:
<screen>
SELECT concat_lower_or_upper(a := 'Hello', b := 'World');
 concat_lower_or_upper 
-----------------------
 hello world
(1 row)
</screen>
     Encore une fois, l'argument <literal>uppercase</literal> a été omis, donc
     il dispose de sa valeur par défaut, <literal>false</literal>,
     implicitement. Un avantage à utiliser la notation par nom est que les
     arguments peuvent être saisis dans n'importe quel ordre. Par
     exemple&nbsp;:
<screen>
SELECT concat_lower_or_upper(a := 'Hello', b := 'World', uppercase := true);
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)

SELECT concat_lower_or_upper(a := 'Hello', uppercase := true, b := 'World');
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen>
    </para>
   </sect2>

  <sect2 id="sql-syntax-calling-funcs-mixed">
   <title>En utilisant la notation mixée</title>

   <indexterm>
    <primary>fonction</primary>
    <secondary>notation mixée</secondary>
   </indexterm>

   <para>
    La notation mixée combine les notations par position et par nom. Néanmoins,
    comme cela a déjà été expliqué, les arguments par nom ne peuvent pas
    précéder les arguments par position. Par exemple&nbsp;:
<screen>
SELECT concat_lower_or_upper('Hello', 'World', uppercase := true);
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen>
    Dans la requête ci-dessus, les arguments <literal>a</literal> et
    <literal>b</literal> sont précisés par leur position alors que
    <literal>uppercase</literal> est indiqué par son nom. Dans cet exemple,
    cela n'apporte pas grand-chose, sauf pour une documentation de la
    fonction. Avec une fonction plus complexe, comprenant de nombreux
    paramètres avec des valeurs par défaut, les notations par nom et mixées
    améliorent l'écriture des appels de fonction et permettent de réduire les
    risques d'erreurs.
   </para>
  </sect2>
 </sect1>

</chapter>
