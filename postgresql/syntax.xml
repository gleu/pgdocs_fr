<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="sql-syntax">
 <title>Syntaxe SQL</title>

 <indexterm zone="sql-syntax">
  <primary>syntaxe</primary>
  <secondary>SQL</secondary>
 </indexterm>

 <para>
  Ce chapitre décrit la syntaxe de SQL. Il donne les fondements pour comprendre
  les chapitres suivants qui iront plus en détail sur la façon dont les
  commandes SQL sont appliquées pour définir et modifier des données.
 </para>

 <para>
  Nous avertissons aussi nos utilisateurs, déjà familiers avec le SQL, qu'ils
  doivent lire ce chapitre très attentivement car il existe plusieurs règles et
  concepts implémentés différemment suivant les bases de données SQL ou
  spécifiques à <productname>PostgreSQL</productname>.
 </para>

 <sect1 id="sql-syntax-lexical">
  <title>Structure lexicale</title>

  <indexterm>
   <primary>token</primary>
  </indexterm>

  <para>
   Une entrée SQL consiste en une séquence de <firstterm>commandes</firstterm>.
   Une commande est composée d'une séquence de <firstterm>jetons</firstterm>,
   terminés par un point-virgule (<quote>;</quote>). La fin du flux en entrée
   termine aussi une commande. Les jetons valides dépendent de la syntaxe
   particulière de la commande.
  </para>

  <para>
   Un jeton peut être un <firstterm>mot clé</firstterm>, un
   <firstterm>identificateur</firstterm>, un <firstterm>identificateur entre
    guillemets</firstterm>, une <firstterm>constante</firstterm> ou un symbole
   de caractère spécial. Les jetons sont normalement séparés par des espaces
   blancs (espace, tabulation, nouvelle ligne) mais n'ont pas besoin de l'être
   s'il n'y a pas d'ambiguïté (ce qui est seulement le cas si un caractère
   spécial est adjacent à des jetons d'autres types).
  </para>

  <para>
   Par exemple, ce qui suit est (syntaxiquement) valide pour une entrée
   SQL&nbsp;:
   <programlisting>SELECT * FROM MA_TABLE;
UPDATE MA_TABLE SET A = 5;
INSERT INTO MA_TABLE VALUES (3, 'salut ici');</programlisting>
    C'est une séquence de trois commandes, une par ligne (bien que cela ne soit
    pas requis&nbsp;; plusieurs commandes peuvent se trouver sur une même ligne
    et une commande peut se répartir sur plusieurs lignes).
   </para>

  <para>
   De plus, des <firstterm>commentaires</firstterm> peuvent se trouver dans
   l'entrée SQL. Ce ne sont pas des jetons, ils sont réellement équivalents à
   un espace blanc.
  </para>

  <para>
   La syntaxe SQL n'est pas très cohérente en ce qui concerne les jetons
   identificateurs des commandes et lesquels sont des opérandes ou des
   paramètres. Les premiers jetons sont généralement le nom de la commande.
   Dans l'exemple ci-dessus, nous parlons d'une commande <quote>SELECT</quote>,
   d'une commande <quote>UPDATE</quote> et d'une commande <quote>INSERT</quote>.
   Mais en fait, la commande <command>UPDATE</command> requiert toujours un
   jeton <token>SET</token> apparaissant à une certaine position, et cette
   variante particulière de <command>INSERT</command> requiert aussi un
   <token>VALUES</token> pour être complète. Les règles précises de syntaxe
   pour chaque commande sont décrites dans la <xref linkend="reference"/>.
  </para>

  <sect2 id="sql-syntax-identifiers">
   <title>identificateurs et mots clés</title>

   <indexterm zone="sql-syntax-identifiers">
    <primary>identificateur</primary>
    <secondary>syntaxe de</secondary>
   </indexterm>

   <indexterm zone="sql-syntax-identifiers">
    <primary>nom</primary>
    <secondary>syntaxe de</secondary>
   </indexterm>

   <indexterm zone="sql-syntax-identifiers">
    <primary>mot clé</primary>
    <secondary>syntaxe de</secondary>
   </indexterm>

   <para>
    Les jetons tels que <token>SELECT</token>, <token>UPDATE</token> ou
    <token>VALUES</token> dans l'exemple ci-dessus sont des exemples de
    <firstterm>mots clés</firstterm>, c'est-à-dire des mots qui ont une
    signification dans le langage SQL. Les jetons <token>MA_TABLE</token> et
    <token>A</token> sont des exemples d'<firstterm>identificateurs</firstterm>.
    Ils identifient des noms de tables, colonnes ou d'autres objets de la base
    de données suivant la commande qui a été utilisée. Du coup, ils sont
    quelques fois simplement nommés des <quote>noms</quote>. Les mots clés et
    les identificateurs ont la même structure lexicale, signifiant que quelqu'un
    ne peut pas savoir si un jeton est un identificateur ou un mot clé sans
    connaître le langage. Une liste complète des mots clé est disponible dans
    l'<xref linkend="sql-keywords-appendix"/>.
   </para>

   <para>
    Les identificateurs et les mots clés SQL doivent commencer avec une lettre
    (<literal>a</literal>-<literal>z</literal>, mais aussi des lettres de
    marques diacritiques différentes et des lettres non latines) ou un tiret bas
    (<literal>_</literal>). Les caractères suivants dans un identificateur ou
    dans un mot clé peuvent être des lettres, des tirets-bas, des chiffres
    (<literal>0</literal>-<literal>9</literal>) ou des signes dollar
    (<literal>$</literal>). Notez que les signes dollar ne sont pas autorisés
    en tant qu'identificateur d'après le standard SQL, donc leur utilisation
    pourrait rendre les applications moins portables. Le standard SQL ne
    définira pas un mot clé contenant des chiffres ou commençant ou finissant
    par un tiret bas, donc les identificateurs de cette forme sont sûr de ne
    pas entrer en conflit avec les futures extensions du standard.
   </para>

   <para>
   <indexterm><primary>identificateur</primary><secondary>longueur</secondary>
</indexterm>
    Le système utilise au plus <symbol>NAMEDATALEN</symbol>-1 octets d'un
    identificateur&nbsp;; les noms longs peuvent être écrits dans des commandes
    mais ils seront tronqués. Par défaut, <symbol>NAMEDATALEN</symbol> vaut 64.
    Du coup, la taille maximum de l'identificateur est de 63 octets. Si cette
    limite est problématique, elle peut être élevée en modifiant
    <symbol>NAMEDATALEN</symbol> dans
    <filename>src/include/pg_config_manual.h</filename>.
   </para>

   <para>
    <indexterm>
     <primary>sensibilité à la casse</primary>
     <secondary>des commandes SQL</secondary>
    </indexterm>
    Les mots clés et les identificateurs sans guillemets doubles sont
    insensibles à la casse. Du coup&nbsp;:
<programlisting>UPDATE MA_TABLE SET A = 5;</programlisting>
    peut aussi s'écrire de cette façon&nbsp;:
<programlisting>uPDaTE ma_TabLE SeT a = 5;</programlisting>
    Une convention couramment utilisée revient à écrire les mots clés en
    majuscule et les noms en minuscule, c'est-à-dire&nbsp;:
<programlisting>UPDATE ma_table SET a = 5;</programlisting>
   </para>

   <para>
    <indexterm>
     <primary>marques de citation</primary>
     <secondary>et identificateurs</secondary>
    </indexterm>
    Voici un deuxième type d'identificateur&nbsp;: l'<firstterm>identificateur
    délimité</firstterm> ou l'<firstterm>identificateur entre
    guillemets</firstterm>. Il est formé en englobant une séquence arbitraire de
    caractères entre des guillemets doubles (<literal>"</literal>). Un
    identificateur délimité est toujours un identificateur, jamais un mot clé.
    Donc, <literal>"select"</literal> pourrait être utilisé pour faire référence
    à une colonne ou à une table nommée <quote>select</quote>, alors qu'un
    <literal>select</literal> sans guillemets sera pris pour un mot clé et du
    coup, pourrait provoquer une erreur d'analyse lorsqu'il est utilisé alors
    qu'un nom de table ou de colonne est attendu. L'exemple peut être écrit avec
    des identificateurs entre guillemets comme ceci&nbsp;:
<programlisting>UPDATE "ma_table" SET "a" = 5;</programlisting>
   </para>

   <para>
    Les identificateurs entre guillemets peuvent contenir tout caractère autre
    que celui de code 0. (Pour inclure un guillemet double, écrivez deux
    guillemets doubles.) Ceci permet la construction de noms de tables et de
    colonnes qui ne seraient pas possible autrement, comme des noms contenant
    des espaces ou des arobases. La limitation de la longueur s'applique
    toujours.
   </para>

   <indexterm>
     <primary>échappement Unicode</primary>
     <secondary>dans les identificateurs</secondary>
   </indexterm>

   <para>
    Une variante des identificateurs entre guillemets permet d'inclure des
    caractères Unicode échappés en les identificateur par leur point de code.
    Cette variante commence par <literal>U&amp;</literal> (U en majuscule ou
    minuscule suivi par un « et commercial ») immédiatement suivi par un
    guillemet double d'ouverture, sans espace entre eux. Par exemple
    <literal>U&amp;"foo"</literal>. (Notez que c'est source d'ambiguïté avec
    l'opérateur <literal>&amp;</literal>. Utilisez les espaces autour de
    l'opérateur pour éviter ce problème.) À l'intérieur des guillemets, les
    caractères Unicode peuvent être indiqués dans une forme échappée en écrivant
    un antislash suivi par le code hexadécimal sur quatre chiffres ou, autre
    possibilité, un antislash suivi du signe plus suivi d'un code hexadécimal
    sur six chiffres. Par exemple, l'identificateur <literal>"data"</literal>
    peut être écrit ainsi&nbsp;:
<programlisting>
U&amp;"d\0061t\+000061"
   </programlisting>
   L'exemple suivant, moins trivial, écrit le mot russe <quote>slon</quote>
   (éléphant) en lettres cyrilliques&nbsp;:
   <programlisting>
U&amp;"\0441\043B\043E\043D"
   </programlisting>
  </para>

  <para>
   Si un caractère d'échappement autre que l'antislash est désiré, il peut
   être indiqué en utilisant la clause <literal>UESCAPE</literal>
   <indexterm><primary>UESCAPE</primary></indexterm> après la chaîne. Par
   exemple&nbsp;:
   <programlisting>
U&amp;"d!0061t!+000061" UESCAPE '!'
   </programlisting>
   La chaîne d'échappement peut être tout caractère simple autre qu'un chiffre
   hexadécimal, le signe plus, un guillemet simple ou double, ou un espace
   blanc. Notez que le caractère d'échappement est écrit entre guillemets
   simples, pas entre guillemets doubles.
  </para>

  <para>
   Pour inclure le caractère d'échappement dans l'identificateur sans
   interprétation, écrivez-le deux fois.
  </para>

  <para>
   La syntaxe d'échappement Unicode fonctionne seulement quand l'encodage
   serveur est <literal>UTF8</literal>. Quand d'autres encodages clients sont
   utilisés, seuls les codes dans l'échelle ASCII (jusqu'à
   <literal>\007F</literal>) peuvent être utilisés. La forme sur quatre
   chiffres et la forme sur six chiffres peuvent être utilisées pour indiquer
   des paires UTF-16 composant ainsi des caractères comprenant des points de
   code plus grands que U+FFFF (et ce, bien que la disponibilité de la forme
   sur six chiffres ne le nécessite pas techniquement). (Les paires de
   substitution ne sont pas stockées directement mais combinées dans un point
   de code seul qui est ensuite encodé en UTF-8.)
  </para>

  <para>
   Mettre un identificateur entre guillemets le rend sensible à la casse alors
   que les noms sans guillemets sont toujours convertis en minuscules. Par
   exemple, les identificateurs <literal>FOO</literal>, <literal>foo</literal>
   et <literal>"foo"</literal> sont considérés identiques par
   <productname>PostgreSQL</productname> mais <literal>"Foo"</literal> et
   <literal>"FOO"</literal> sont différents des trois autres et entre eux. La
   mise en minuscule des noms sans guillemets avec
   <productname>PostgreSQL</productname> n'est pas compatible avec le standard
   SQL qui indique que les noms sans guillemets devraient être mis en
   majuscule. Du coup, <literal>foo</literal> devrait être équivalent à
   <literal>"FOO"</literal> et non pas à <literal>"foo"</literal> en respect
   avec le standard. Si vous voulez écrire des applications portables, nous
   vous conseillons de toujours mettre entre guillemets un nom particulier ou
   de ne jamais le mettre.
  </para>
 </sect2>


 <sect2 id="sql-syntax-constants">
  <title>Constantes</title>

  <indexterm zone="sql-syntax-constants">
   <primary>constante</primary>
  </indexterm>

  <para>
   Il existe trois <firstterm>types implicites de constantes</firstterm> dans
   <productname>PostgreSQL</productname>&nbsp;: les chaînes, les chaînes de
   bits et les nombres. Les constantes peuvent aussi être spécifiées avec des
   types explicites, ce qui peut activer des représentations plus précises
   et gérées plus efficacement par le système. Les constantes implicites sont
   décrites ci-dessous&nbsp;; ces constantes sont discutées dans les
   sous-sections suivantes.
  </para>

  <sect3 id="sql-syntax-strings">
   <title>Constantes de chaînes</title>

   <indexterm zone="sql-syntax-strings">
    <primary>chaîne de caractère</primary>
    <secondary>constante</secondary>
   </indexterm>

   <para>
    <indexterm>
     <primary>marques de citation</primary>
     <secondary>échappement</secondary>
    </indexterm>
    Une constante de type chaîne en SQL est une séquence arbitraire de
    caractères entourée par des guillemets simples (<literal>'</literal>), par
    exemple <literal>'Ceci est une chaîne'</literal>. Pour inclure un guillemet
    simple dans une chaîne constante, saisissez deux guillemets simples
    adjacents, par exemple <literal>'Le cheval d''Anne'</literal>. Notez que ce
    n'est <emphasis>pas</emphasis> identique à un guillemet double
    (<literal>"</literal>).
   </para>

   <para>
    Deux constantes de type chaîne séparées par un espace blanc <emphasis>avec
     au moins une nouvelle ligne</emphasis> sont concaténées et traitées
    réellement comme si la chaîne avait été écrite dans une constante. Par
    exemple&nbsp;:
    <programlisting>SELECT 'foo'
'bar';</programlisting>
     est équivalent à&nbsp;:
<programlisting>SELECT 'foobar';</programlisting>
     mais&nbsp;:
<programlisting>SELECT 'foo'      'bar';</programlisting>
     n'a pas une syntaxe valide (ce comportement légèrement bizarre est spécifié
     par le standard <acronym>SQL</acronym>&nbsp;;
     <productname>PostgreSQL</productname> suit le standard).
    </para>
   </sect3>

   <sect3 id="sql-syntax-strings-escape">
    <title>Constantes chaîne avec des échappements de style C</title>

     <indexterm zone="sql-syntax-strings-escape">
      <primary>syntaxe d'échappement de chaîne</primary>
     </indexterm>
     <indexterm zone="sql-syntax-strings-escape">
      <primary>échappements d'antislash</primary>
     </indexterm>

    <para>
     <productname>PostgreSQL</productname> accepte aussi les constantes de
     chaîne utilisant des échappements qui sont une extension au standard SQL.
     Une constante de type chaîne d'échappement est indiquée en écrivant la
     lettre <literal>E</literal> (en majuscule ou minuscule) juste avant le
     guillemet d'ouverture, par exemple <literal>E'foo'</literal>. (Pour
     continuer une constante de ce type sur plusieurs lignes, écrire
     <literal>E</literal> seulement avant le premier guillemet d'ouverture.)
     À l'intérieur d'une chaîne d'échappement, un caractère antislash
     (<literal>\</literal>) est géré comme une séquence d'<firstterm>échappement
     avec antislash</firstterm> du langage C. La combinaison d'antislash et du
     (ou des) caractère(s) suivant représente une valeur spéciale, comme indiqué
     dans le <xref linkend="sql-backslash-table"/>.
    </para>

     <table id="sql-backslash-table">
      <title>Séquences d'échappements avec antislash</title>
      <tgroup cols="2">
      <thead>
       <row>
        <entry>Séquence d'échappement avec antislash</entry>
        <entry>Interprétation</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>\b</literal></entry>
        <entry>suppression</entry>
       </row>
       <row>
        <entry><literal>\f</literal></entry>
        <entry>retour en début de ligne</entry>
       </row>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>saut de ligne</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>saut de ligne</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>tabulation</entry>
       </row>
       <row>
        <entry>
         <literal>\<replaceable>o</replaceable></literal>,
         <literal>\<replaceable>oo</replaceable></literal>,
         <literal>\<replaceable>ooo</replaceable></literal>
         (<replaceable>o</replaceable> = 0 - 7)
        </entry>
        <entry>valeur octale</entry>
       </row>
       <row>
        <entry>
         <literal>\x<replaceable>h</replaceable></literal>,
         <literal>\x<replaceable>hh</replaceable></literal>
         (<replaceable>h</replaceable> = 0 - 9, A - F)
        </entry>
        <entry>valeur hexadécimale</entry>
       </row>
       <row>
        <entry>
         <literal>\u<replaceable>xxxx</replaceable></literal>,
         <literal>\U<replaceable>xxxxxxxx</replaceable></literal>
         (<replaceable>x</replaceable> = 0 - 9, A - F)
        </entry>
        <entry>caractère Unicode hexadécimal sur 16 ou 32 bits</entry>
       </row>
      </tbody>
      </tgroup>
     </table>

    <para>
     Tout autre caractère suivi d'un antislash est pris littéralement. Du coup,
     pour inclure un caractère antislash, écrivez deux antislashs
     (<literal>\\</literal>). De plus, un guillemet simple peut être inclus dans
     une chaîne d'échappement en écrivant <literal>\'</literal>, en plus de la
     façon normale <literal>''</literal>.
    </para>

    <para>
     Il est de votre responsabilité que les séquences d'octets que vous créez,
     tout spécialement lorsque vous utilisez les échappements octaux et
     hexadécimaux, soient des caractères valides dans l'encodage du jeu de
     caractères du serveur. Quand l'encodage est UTF-8, alors les échappements
     Unicode ou l'autre syntaxe d'échappement Unicode, expliqués dans la <xref
     linkend="sql-syntax-strings-uescape"/>, devraient être utilisés.
     (L'alternative serait de réaliser l'encodage UTF-8 manuellement et d'écrire
     les octets, ce qui serait très lourd.)
    </para>

    <para>
     La syntaxe d'échappement Unicode fonctionne complètement mais seulement
     quand l'encodage du serveur est justement <literal>UTF8</literal>. Lorsque
     d'autres encodages serveur sont utilisés, seuls les points de code dans
     l'échelle ASCII (jusqu'à <literal>\u007F</literal>) peuvent être utilisés.
     La forme sur quatre chiffres et la forme sur six chiffres peuvent être
     utilisées pour indiquer des paires UTF-16 composant ainsi des caractères
     comprenant des points de code plus grands que U+FFFF et ce, bien que la
     disponibilité de la forme sur six chiffres ne le nécessite pas
     techniquement. (Quand des paires de substitution sont utilisées et que
     l'encodage du serveur est <literal>UTF8</literal>, elles sont tout d'abord
     combinées en un point code seul qui est ensuite encodé en UTF-8.)
    </para>

    <caution>
    <para>
     Si le paramètre de configuration <xref
     linkend="guc-standard-conforming-strings"/> est désactivé
     (<literal>off</literal>), alors <productname>PostgreSQL</productname>
     reconnaît les échappements antislashs dans les constantes traditionnelles
     de type chaînes et celles échappées. Néanmoins, à partir de
     <productname>PostgreSQL</productname> 9.1, la valeur par défaut est
     <literal>on</literal>, ce qui signifie que les échappements par antislash
     ne sont reconnus que dans les constantes de chaînes d'échappement. Ce
     comportement est plus proche du standard SQL mais pourrait causer des
     problèmes aux applications qui se basent sur le comportement historique où
     les échappements par antislash étaient toujours reconnus. Pour contourner
     ce problème, vous pouvez configurer ce paramètre à <literal>off</literal>
     bien qu'il soit préférable de ne plus utiliser les échappements par
     antislash. Si vous avez besoin d'un échappement par antislash pour
     représenter un caractère spécial, écrivez la chaîne fixe avec un
     <literal>E</literal>.
    </para>

    <para>
     En plus de <varname>standard_conforming_strings</varname>, les paramètres
     de configuration <xref linkend="guc-escape-string-warning"/> et <xref
     linkend="guc-backslash-quote"/> imposent le traitement des antislashs dans
     les constantes de type chaîne.
    </para>
    </caution>

    <para>
     Le caractère de code zéro ne peut pas être placé dans une constante de type
     chaîne.
    </para>
   </sect3>

   <sect3 id="sql-syntax-strings-uescape">
    <title>Constantes de chaînes avec des échappements Unicode</title>

    <indexterm  zone="sql-syntax-strings-uescape">
     <primary>Échappement Unicode</primary>
     <secondary>dans des constantes de chaîne</secondary>
    </indexterm>

    <para>
     <productname>PostgreSQL</productname> supporte aussi un autre type de
     syntaxe d'échappement pour les chaînes qui permettent d'indiquer des
     caractères Unicode arbitraires par code. Une constante de chaîne
     d'échappement Unicode commence avec <literal>U&amp;</literal> (U en
     majuscule ou minuscule suivi par un « et commercial ») immédiatement suivi
     par un guillemet double d'ouverture, sans espace entre eux. Par exemple
     <literal>U&amp;"foo"</literal>. (Notez que c'est source d'ambiguïté avec
     l'opérateur <literal>&amp;</literal>. Utilisez les espaces autour de
     l'opérateur pour éviter ce problème.) À l'intérieur des guillemets, les
     caractères Unicode peuvent être indiqués dans une forme échappée en
     écrivant un antislash suivi par le code hexadécimal sur quatre chiffres
     ou, autre possibilité, un antislash suivi du signe plus suivi d'un code
     hexadécimal sur six chiffres. Par exemple, l'identificateur
     <literal>'data'</literal> peut être écrit ainsi&nbsp;:
<programlisting>
U&amp;'d\0061t\+000061'
    </programlisting>
    L'exemple suivant, moins trivial, écrit le mot russe <quote>slon</quote>
    (éléphant) en lettres cyrilliques&nbsp;:
    <programlisting>
U&amp;'\0441\043B\043E\043D'
    </programlisting>
   </para>

   <para>
    Si un caractère d'échappement autre que l'antislash est souhaité, il peut
    être indiqué en utilisant la clause <literal>UESCAPE</literal>
    <indexterm><primary>UESCAPE</primary></indexterm> après la chaîne. Par
    exemple&nbsp;:
    <programlisting>
U&amp;'d!0061t!+000061' UESCAPE '!'
    </programlisting>
    Le caractère d'échappement peut être tout caractère simple autre qu'un
    chiffre hexadécimal, le signe plus, un guillement simple ou double, ou un
    espace blanc.
   </para>

   <para>
    La syntaxe d'échappement Unicode fonctionne seulement quand l'encodage du
    serveur est <literal>UTF8</literal>. Quand d'autres encodages de serveur
    sont utilisés, seuls les codes dans l'échelle ASCII (jusqu'à
    <literal>\007F</literal>) peuvent être utilisés.
    La forme sur quatre chiffres et la forme sur six chiffres peuvent être
    utilisées pour indiquer des paires de substitution UTF-16 composant ainsi
    des caractères comprenant des points de code plus grands que U+FFFF (et
    ce, bien que la disponibilité de la forme sur six chiffres ne le nécessite
    pas techniquement). (Quand des paires de substitution sont utilisées avec
    un encodage serveur <literal>UTF8</literal>, elles sont tout d'abord
    combinées en un seul point de code, qui est ensuite encodé en UTF-8.)
   </para>

   <para>
    De plus, la syntaxe d'échappement de l'Unicode pour les constantes de
    chaînes fonctionne seulement quand le paramètre de configuration <xref
    linkend="guc-standard-conforming-strings"/> est activé. Dans le cas
    contraire, cette syntaxe est confuse pour les clients qui analysent les
    instructions SQL au point que cela pourrait amener des injections SQL et
    des problèmes de sécurité similaires. Si le paramètre est désactivé, cette
    syntaxe sera rejetée avec un message d'erreur.
   </para>

   <para>
    Pour inclure le caractère d'échappement littéralement dans la chaîne,
    écrivez-le deux fois.
   </para>
  </sect3>

  <sect3 id="sql-syntax-dollar-quoting">
   <title>Constantes de chaînes avec guillemet dollar</title>

   <indexterm>
    <primary>guillemet dollar</primary>
   </indexterm>

   <para>
    Alors que la syntaxe standard pour la spécification des constantes de
    chaînes est généralement agréable, elle peut être difficile à comprendre
    quand la chaîne désirée contient un grand nombre de guillemets ou
    d'antislashs car chacun d'entre eux doit être doublé. Pour permettre la
    saisie de requêtes plus lisibles dans de telles situations,
    <productname>PostgreSQL</productname> fournit une autre façon, appelée
    <quote>guillemet dollar</quote>, pour écrire des constantes de chaînes.
    Une constante de chaîne avec guillemet dollar consiste en un signe
    dollar (<literal>$</literal>), une <quote>balise</quote> optionnelle
    de zéro ou plus de caractères, un autre signe dollar, une séquence
    arbitraire de caractères qui constitue le contenu de la chaîne, un signe
    dollar, la même balise et un signe dollar. Par exemple, voici deux façons
    de spécifier la chaîne <quote>Le cheval d'Anne</quote> en utilisant les
    guillemets dollar&nbsp;:
    <programlisting>$$Le cheval d'Anne$$
$UneBalise$Le cheval d'Anne$UneBalise$</programlisting>
       Notez qu'à l'intérieur de la chaîne avec guillemet dollar, les guillemets
       simples peuvent être utilisés sans devoir être échappés. En fait, aucun
       caractère à l'intérieur d'une chaîne avec guillemet dollar n'a besoin
       d'être échappé&nbsp;: le contenu est toujours écrit littéralement. Les
       antislashs ne sont pas spéciaux, pas plus que les signes dollar, sauf
       s'ils font partie d'une séquence correspondant à la balise ouvrante.
     </para>

     <para>
       Il est possible d'imbriquer les constantes de chaînes avec guillemets
       dollar en utilisant différentes balises pour chaque niveau d'imbrication.
       Ceci est habituellement utilisé lors de l'écriture de définition de
       fonctions. Par exemple&nbsp;:
     <programlisting>$fonction$
BEGIN
  RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$fonction$</programlisting>
       Dans cet exemple, la séquence <literal>$q$[\t\r\n\v\\]$q$</literal>
       représente une chaîne constante avec guillemet dollar
       <literal>[\t\r\n\v\\]</literal>, qui sera reconnue quand le corps de la
       fonction est exécuté par <productname>PostgreSQL</productname>. Mais
       comme la séquence ne correspond pas au délimiteur
       <literal>$fonction$</literal>, il s'agit juste de quelques caractères à
       l'intérieur de la constante pour ce qu'en sait la chaîne externe.
     </para>

     <para>
      La balise d'une chaîne avec guillemets dollar, si elle existe, suit les
      mêmes règles qu'un identificateur sans guillemets, sauf qu'il ne peut
      pas contenir de signes dollar. Les balises sont sensibles à la casse,
      du coup <literal>$balise$Contenu de la chaîne$balise$</literal> est
      correct mais <literal>$BALISE$Contenu de la chaîne$balise$</literal> ne
      l'est pas.
     </para>

     <para>
      Une chaîne avec guillemets dollar suivant un mot clé ou un identificateur
      doit en être séparé par un espace blanc&nbsp;; sinon, le délimiteur du
      guillemet dollar serait pris comme faisant parti de l'identificateur
      précédent.
     </para>

     <para>
      Le guillemet dollar ne fait pas partie du standard SQL mais c'est un
      moyen bien plus agréable pour écrire des chaînes constantes que
      d'utiliser la syntaxe des guillemets simples, bien que compatible avec
      le standard. Elle est particulièrement utile  pour représenter des
      constantes de type chaîne à l'intérieur d'autres constantes, comme cela
      est souvent le cas avec les définitions de fonctions. Avec la syntaxe des
      guillemets simples, chaque antislash dans l'exemple précédent devrait
      avoir été écrit avec quatre antislashs, ce qui sera réduit à deux
      antislashs dans l'analyse de la constante originale, puis à un lorsque
      la constante interne est analysée de nouveau lors de l'exécution de la
      fonction.
     </para>
   </sect3>

   <sect3 id="sql-syntax-bit-strings">
    <title>Constantes de chaînes de bits</title>

    <indexterm zone="sql-syntax-bit-strings">
     <primary>chaîne de bit</primary>
     <secondary>constante</secondary>
    </indexterm>

    <para>
     Les constantes de chaînes de bits ressemblent aux constantes de chaînes
     standards avec un <literal>B</literal> (majuscule ou minuscule) juste
     avant le guillemet du début (sans espace blanc), c'est-à-dire
     <literal>B'1001'</literal>. Les seuls caractères autorisés dans les
     constantes de type chaîne de bits sont <literal>0</literal> et
     <literal>1</literal>.
    </para>

    <para>
     Les constantes de chaînes de bits peuvent aussi être spécifiées en
     notation hexadécimale en utilisant un <literal>X</literal> avant (minuscule
     ou majuscule), c'est-à-dire <literal>X'1FF'</literal>. Cette notation est
     équivalente à une constante de chaîne de bits avec quatre chiffres binaires
     pour chaque chiffre hexadécimal.
    </para>

    <para>
     Les deux formes de constantes de chaînes de bits peuvent être continuées
     sur plusieurs lignes de la même façon que les constantes de chaînes
     habituelles. Le guillemet dollar ne peut pas être utilisé dans une
     constante de chaîne de bits.
    </para>
   </sect3>

   <sect3 id="sql-syntax-constants-numeric">
    <title>Constantes numériques</title>

    <indexterm>
     <primary>nombre</primary>
     <secondary>constante</secondary>
    </indexterm>

    <para>
     Les constantes numériques sont acceptées dans ces formes générales&nbsp;:
<synopsis><replaceable>chiffres</replaceable>
<replaceable>chiffres</replaceable>.<optional><replaceable>chiffres</replaceable></optional><optional>e<optional>+-</optional><replaceable>chiffres</replaceable></optional>
<optional><replaceable>chiffres</replaceable></optional>.<replaceable>chiffres</replaceable><optional>e<optional>+-</optional><replaceable>chiffres</replaceable></optional>
<replaceable>chiffres</replaceable>e<optional>+-</optional><replaceable>chiffres</replaceable>
    </synopsis>
    où <replaceable>chiffres</replaceable> est un ou plusieurs chiffres
    décimaux (de 0 à 9). Au moins un chiffre doit être avant ou après le point
    décimal, s'il est utilisé. Au moins un chiffre doit suivre l'indicateur
    d'exponentiel (<literal>e</literal>), s'il est présent. Il ne peut pas
    y avoir d'espaces ou d'autres caractères imbriqués dans la constante. Notez
    que tout signe plus ou moins en avant n'est pas considéré comme faisant
    part de la constante&nbsp;; il est un opérateur appliqué à la constante.
   </para>

   <para>
    Voici quelques exemples de constantes numériques valides&nbsp;:
    <literallayout>42
     3.5
     4.
     .001
     5e2
     1.925e-3
    </literallayout>
   </para>

   <para>
    <indexterm><primary>integer</primary></indexterm>
    <indexterm><primary>bigint</primary></indexterm>
    <indexterm><primary>numeric</primary></indexterm>
    Une constante numérique ne contenant ni un point décimal ni un exposant est
    tout d'abord présumée du type <type>integer</type> si sa valeur est
    contenue dans le type <type>integer</type> (32 bits)&nbsp;; sinon, il est
    présumé de type <type>bigint</type> si sa valeur entre dans un type
    <type>bigint</type> (64 bits)&nbsp;; sinon, il est pris pour un type
    <type>numeric</type>. Les constantes contenant des poins décimaux et/ou des
    exposants sont toujours présumées de type <type>numeric</type>.
   </para>

   <para>
    Le type de données affecté initialement à une constante numérique est
    seulement un point de départ pour les algorithmes de résolution de types.
    Dans la plupart des cas, la constante sera automatiquement convertie dans
    le type le plus approprié suivant le contexte. Si nécessaire, vous pouvez
    forcer l'interprétation d'une valeur numérique sur un type de données
    spécifique en la convertissant. <indexterm><primary>conversion de
      type</primary></indexterm> Par exemple, vous pouvez forcer une valeur
    numérique à être traitée comme un type <type>real</type>
    (<type>float4</type>) en écrivant&nbsp;:

    <programlisting>REAL '1.23'  -- style chaîne
1.23::REAL   -- style PostgreSQL (historique)</programlisting>

      Ce sont en fait des cas spéciaux des notations de conversion générales
      discutées après.
     </para>
    </sect3>

   <sect3 id="sql-syntax-constants-generic">
    <title>Constantes d'autres types</title>

    <indexterm>
     <primary>type de données</primary>
     <secondary>constante</secondary>
    </indexterm>

    <para>
     Une constante de type arbitraire peut être saisie en utilisant une des
     notations suivantes&nbsp;:
<synopsis><replaceable>type</replaceable> '<replaceable>chaîne</replaceable>'
'<replaceable>chaîne</replaceable>'::<replaceable>type</replaceable>
CAST ( '<replaceable>chaîne</replaceable>' AS <replaceable>type</replaceable> )</synopsis>
     Le texte de la chaîne constante est passé dans la routine de conversion
     pour le type appelé <replaceable>type</replaceable>. Le résultat est une
     constante du type indiqué. La conversion explicite de type peut être omise
     s'il n'y a pas d'ambiguïté sur le type de la constante (par exemple,
     lorsqu'elle est affectée directement à une colonne de la table), auquel
     cas elle est convertie automatiquement.
    </para>


    <para>
     La constante chaîne peut être écrite en utilisant soit la notation SQL
     standard soit les guillemets dollar.
    </para>
    <para>
     Il est aussi possible de spécifier une conversion de type en utilisant une
     syntaxe style fonction&nbsp;:
<synopsis><replaceable>nom_type</replaceable> ( '<replaceable>chaîne</replaceable>' )</synopsis>
     mais tous les noms de type ne peuvent pas être utilisés ainsi&nbsp;; voir
     la <xref linkend="sql-syntax-type-casts"/> pour plus de détails.
    </para>

    <para>
     Les syntaxes <literal>::</literal>, <literal>CAST()</literal> et d'appels
     de fonctions sont aussi utilisables pour spécifier les conversions de
     type à l'exécution d'expressions arbitraires, comme discuté dans la <xref
     linkend="sql-syntax-type-casts"/>. Pour éviter une ambiguïté syntaxique,
     la syntaxe <literal><replaceable>type</replaceable>
     '<replaceable>chaîne</replaceable>'</literal> peut seulement être utilisée
     pour spécifier le type d'une constante. Une autre restriction sur
     la syntaxe <literal><replaceable>type</replaceable>
     '<replaceable>chaîne</replaceable>'</literal> est qu'il ne fonctionne pas
     pour les types de tableau&nbsp;; utilisez <literal>::</literal> ou
     <literal>CAST()</literal> pour spécifier le type d'une constante de type
     tableau.
    </para>

    <para>
     La syntaxe de <literal>CAST()</literal> est conforme au standard SQL. La
     syntaxe <literal><replaceable>type</replaceable>
     '<replaceable>chaine</replaceable>'</literal> est une généralisation du
     standard&nbsp;: SQL spécifie cette syntaxe uniquement pour quelques types
     de données mais <productname>PostgreSQL</productname> l'autorise pour tous
     les types. La syntaxe <literal>::</literal> est un usage historique dans
     <productname>PostgreSQL</productname>, comme l'est la syntaxe d'appel de
     fonction.
    </para>
   </sect3>
  </sect2>

  <sect2 id="sql-syntax-operators">
   <title>Opérateurs</title>

   <indexterm zone="sql-syntax-operators">
    <primary>opérateur</primary>
    <secondary>syntaxe</secondary>
   </indexterm>

   <para>
    Un nom d'opérateur est une séquence d'au plus <symbol>NAMEDATALEN</symbol>-1
    (63 par défaut) caractères provenant de la liste suivante&nbsp;:
<literallayout>+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?</literallayout>

    Néanmoins, il existe quelques restrictions sur les noms d'opérateurs&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       <literal>--</literal> et <literal>/*</literal> ne peuvent pas apparaître
       quelque part dans un nom d'opérateur car ils seront pris pour le début
       d'un commentaire.
      </para>
     </listitem>

     <listitem>
      <para>
       Un nom d'opérateur à plusieurs caractères ne peut pas finir avec
       <literal>+</literal> ou <literal>-</literal>, sauf si le nom contient
       aussi un de ces caractères&nbsp;:
<literallayout>~ ! @ # % ^ &amp; | ` ?</literallayout>
       Par exemple, <literal>@-</literal> est un nom d'opérateur autorisé mais
       <literal>*-</literal> ne l'est pas. Cette restriction permet à
       <productname>PostgreSQL</productname> d'analyser des requêtes compatibles
       avec SQL sans requérir des espaces entre les jetons.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Lors d'un travail avec des noms d'opérateurs ne faisant pas partie du
    standard SQL, vous aurez habituellement besoin de séparer les opérateurs
    adjacents avec des espaces pour éviter toute ambiguïté. Par exemple, si
    vous avez défini un opérateur unaire gauche nommé <literal>@</literal>,
    vous ne pouvez pas écrire <literal>X*@Y</literal>&nbsp;; vous devez écrire
    <literal>X* @Y</literal> pour vous assurer que
    <productname>PostgreSQL</productname> le lit comme deux noms d'opérateurs,
    et non pas comme un seul.
   </para>
  </sect2>

  <sect2 id="sql-syntax-special-chars">
   <title>Caractères spéciaux</title>

  <para>
   Quelques caractères non alphanumériques ont une signification spéciale,
   différente de celui d'un opérateur. Les détails sur leur utilisation sont
   disponibles à l'endroit où l'élément de syntaxe respectif est décrit. Cette
   section existe seulement pour avertir de leur existence et pour résumer le
   but de ces caractères.

   <itemizedlist>
    <listitem>
     <para>
      Un signe dollar (<literal>$</literal>) suivi de chiffres est utilisé pour
      représenter un paramètre de position dans le corps de la définition d'une
      fonction ou d'une instruction préparée. Dans d'autres contextes, le signe
      dollar pourrait faire partie d'un identificateur ou d'une constante de
      type chaîne utilisant le dollar comme guillemet.
     </para>
    </listitem>

    <listitem>
     <para>
      Les parenthèses (<literal>()</literal>) ont leur signification habituelle
      pour grouper leurs expressions et renforcer la précédence. Dans certains
      cas, les parenthèses sont requises car faisant partie de la syntaxe d'une
      commande SQL particulière.
     </para>
    </listitem>

    <listitem>
     <para>
      Les crochets (<literal>[]</literal>) sont utilisés pour sélectionner les
      éléments d'un tableau. Voir la <xref linkend="arrays"/> pour plus
      d'informations sur les tableaux.
     </para>
    </listitem>

    <listitem>
     <para>
      Les virgules (<literal>,</literal>) sont utilisées dans quelques
      constructions syntaxiques pour séparer les éléments d'une liste.
     </para>
    </listitem>

    <listitem>
     <para>
      Le point-virgule (<literal>;</literal>) termine une commande SQL. Il ne
      peut pas apparaître quelque part dans une commande, sauf à l'intérieur
      d'une constante de type chaîne ou d'un identificateur entre guillemets.
     </para>
    </listitem>

    <listitem>
     <para>
      Le caractère deux points (<literal>:</literal>) est utilisé pour
      sélectionner des <quote>morceaux</quote> de tableaux (voir la <xref
      linkend="arrays"/>). Dans certains dialectes SQL (tel que le SQL embarqué),
      il est utilisé pour préfixer les noms de variables.
     </para>
    </listitem>

    <listitem>
     <para>
      L'astérisque (<literal>*</literal>) est utilisé dans certains contextes
      pour indiquer tous les champs de la ligne d'une table ou d'une valeur
      composite. Elle a aussi une signification spéciale lorsqu'elle est
      utilisée comme argument d'une fonction d'agrégat. Cela signifie que
      l'agrégat ne requiert par de paramètre explicite.
     </para>
    </listitem>

    <listitem>
     <para>
      Le point (<literal>.</literal>) est utilisé dans les constantes numériques
      et pour séparer les noms de schéma, table et colonne.
     </para>
    </listitem>
   </itemizedlist>

   </para>
  </sect2>

  <sect2 id="sql-syntax-comments">
   <title>Commentaires</title>

   <indexterm zone="sql-syntax-comments">
    <primary>commentaire</primary>
    <secondary sortas="SQL">en SQL</secondary>
   </indexterm>

   <para>
    Un commentaire est une séquence de caractères commençant avec deux tirets
    et s'étendant jusqu'à la fin de la ligne, par exemple&nbsp;:
<programlisting>-- Ceci est un commentaire standard en SQL</programlisting>
   </para>

   <para>
    Autrement, les blocs de commentaires style C peuvent être utilisés&nbsp;:
<programlisting>/* commentaires multilignes
 * et imbriqués: /* bloc de commentaire imbriqué */
 */</programlisting>
    où le commentaire commence avec <literal>/*</literal> et s'étend jusqu'à
    l'occurrence de <literal>*/</literal>. Ces blocs de commentaires
    s'imbriquent, comme spécifié dans le standard SQL mais pas comme dans le
    langage C. De ce fait, vous pouvez commenter des blocs importants de code
    pouvant contenir des blocs de commentaires déjà existants.
   </para>

   <para>
    Un commentaire est supprimé du flux en entrée avant une analyse plus poussée
    de la syntaxe et est remplacé par un espace blanc.
   </para>
  </sect2>

  <sect2 id="sql-precedence">
   <title>Précédence d'opérateurs</title>

   <indexterm zone="sql-precedence">
    <primary>opérateur</primary>
    <secondary>précédence</secondary>
   </indexterm>

   <para>
    Le <xref linkend="sql-precedence-table"/> affiche la précédence et
    l'associativité des opérateurs dans <productname>PostgreSQL</productname>.
    La plupart des opérateurs ont la même précédence et sont associatifs par la
    gauche. La précédence et l'associativité des opérateurs sont codées en dur
    dans l'analyseur.
   </para>

   <para>
    De même, vous
    aurez quelque fois besoin d'ajouter des parenthèses lors de l'utilisation de
    combinaisons d'opérateurs binaires et unaires. Par exemple&nbsp;:
<programlisting>SELECT 5 ! - 6;</programlisting>
   sera analysé comme&nbsp;:
<programlisting>SELECT 5 ! (- 6);</programlisting>
    parce que l'analyseur n'a aucune idée, jusqu'à ce qu'il ne soit trop tard,
    que <token>!</token> est défini comme un opérateur suffixe, et non pas
    préfixe. Pour obtenir le comportement désiré dans ce cas, vous devez
    écrire&nbsp;:
<programlisting>SELECT (5 !) - 6;</programlisting>
    C'est le prix à payer pour l'extensibilité.
   </para>

   <table id="sql-precedence-table">
    <title>Précédence des opérateurs (du plus haut vers le plus bas)</title>

    <tgroup cols="3">
     <colspec colnum="1" colwidth="2*"/>
     <colspec colnum="2" colwidth="1*"/>
     <colspec colnum="3" colwidth="4*"/>
     <thead>
      <row>
       <entry>Opérateur/Élément</entry>
       <entry>Associativité</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><token>.</token></entry>
       <entry>gauche</entry>
       <entry>séparateur de noms de table et de colonne</entry>
      </row>

      <row>
       <entry><token>::</token></entry>
       <entry>gauche</entry>
       <entry>conversion de type,
        style <productname>PostgreSQL</productname></entry>
      </row>

      <row>
       <entry><token>[</token> <token>]</token></entry>
       <entry>gauche</entry>
       <entry>sélection d'un élément d'un tableau</entry>
      </row>

      <row>
       <entry><token>+</token> <token>-</token></entry>
       <entry>droite</entry>
       <entry>plus unaire, moins unaire</entry>
      </row>

      <row>
       <entry><token>^</token></entry>
       <entry>gauche</entry>
       <entry>exposant</entry>
      </row>

      <row>
       <entry><token>*</token> <token>/</token> <token>%</token></entry>
       <entry>gauche</entry>
       <entry>multiplication, division, modulo</entry>
      </row>

      <row>
       <entry><token>+</token> <token>-</token></entry>
       <entry>gauche</entry>
       <entry>addition, soustraction</entry>
      </row>

      <row>
       <entry>(autres opérateurs)</entry>
       <entry>gauche</entry>
       <entry>tout autre opérateur natif ou défini par l'utilisateur</entry>
      </row>

      <row>
       <entry><token>BETWEEN</token> <token>IN</token> <token>LIKE</token> <token>ILIKE</token> <token>SIMILAR</token></entry>
       <entry></entry>
       <entry>intervalle contenu, recherche d'appartenance, correspondance de chaîne</entry>
      </row>

      <row>
       <entry><token>&lt;</token> <token>&gt;</token> <token>=</token> <token>&lt;=</token> <token>&gt;=</token> <token>&lt;&gt;</token>
</entry>
       <entry></entry>
       <entry>opérateurs de comparaison</entry>
      </row>

      <row>
       <entry><token>IS</token> <token>ISNULL</token> <token>NOTNULL</token></entry>
       <entry></entry>
       <entry><literal>IS TRUE</literal>, <literal>IS FALSE</literal>, <literal>IS
       NULL</literal>, <literal>IS DISTINCT FROM</literal>, etc</entry>
      </row>

      <row>
       <entry><token>NOT</token></entry>
       <entry>droite</entry>
       <entry>négation logique</entry>
      </row>

      <row>
       <entry><token>AND</token></entry>
       <entry>gauche</entry>
       <entry>conjonction logique</entry>
      </row>

      <row>
       <entry><token>OR</token></entry>
       <entry>gauche</entry>
       <entry>disjonction logique</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Notez que les règles de précédence des opérateurs s'appliquent aussi aux
    opérateurs définis par l'utilisateur qui ont le même nom que les opérateurs
    internes mentionnés ici. Par exemple, si vous définissez un opérateur
    <quote>+</quote> pour un type de données personnalisé, il aura la même
    précédence que l'opérateur interne <quote>+</quote>, peu importe ce que fait
    le votre.
   </para>

   <para>
    Lorsqu'un nom d'opérateur qualifié par un schéma est utilisé dans la syntaxe
    <literal>OPERATOR</literal>, comme par exemple dans&nbsp;:
<programlisting>SELECT 3 OPERATOR(pg_catalog.+) 4;</programlisting>
    la construction <literal>OPERATOR</literal> est prise pour avoir la
    précédence par défaut affichée dans le <xref linkend="sql-precedence-table"/>
    pour les opérateurs <quote>autres</quote>. Ceci est vrai quelque soit le nom
    spécifique de l'opérateur apparaissant à l'intérieur de
    <literal>OPERATOR()</literal>.
   </para>

   <note>
    <para>
     Les versions de <productname>PostgreSQL</productname> antérieures à la
     9.5 utilisaient des règles de précédence différentes pour les opérateurs.
     En particulier, <token>&lt;=</token> <token>&gt;=</token> et
     <token>&lt;&gt;</token> étaient traités comme des opérateurs
     génériques&nbsp;; les tests <literal>IS</literal> avaient une priorité
     supérieure&nbsp;; <literal>NOT BETWEEN</literal> et les constructions qui
     en découlent agissaient de façon incohérente, ayant dans certains cas la
     précédence de <literal>NOT</literal> plutôt que de
     <literal>BETWEEN</literal>. Ces règles étaient modifiées pour un meilleur
     accord avec le standard SQL et pour réduire la configuration d'un
     traitement incohérent de constructions équivalentes logiquement. Dans la
     plupart des cas, ces changements ne résulteront pas en un changement de
     comportement. Il peut arriver que des échecs du type <quote>opérateur
     inconnu</quote> surviennent, auquel cas un ajout de parenthèses devrait
     corriger le problème. Néanmoins, il existe des cas particuliers où une
     requête pourrait voir son comportement changé sans qu'une erreur
     d'analyse ne soit renvoyé. Si vous êtes inquiet qu'un de ces changements
     pourrait avoir cassé quelque chose silencieusement, vous pouvez tester
     votre application en activant le paramètre <xref
     linkend="guc-operator-precedence-warning"/> pour voir si des messages
     d'avertissement sont tracés.
    </para>
   </note>
  </sect2>
 </sect1>

 <sect1 id="sql-expressions">
  <title>Expressions de valeurs</title>

  <indexterm zone="sql-expressions">
   <primary>expression</primary>
   <secondary>syntaxe</secondary>
  </indexterm>

  <indexterm zone="sql-expressions">
   <primary>expression de valeur</primary>
  </indexterm>

  <indexterm>
   <primary>scalaire</primary>
   <see>expression</see>
  </indexterm>

  <para>
   Les expressions de valeurs sont utilisées dans une grande variété de
   contextes, tels que dans la liste cible d'une commande
   <command>SELECT</command>, dans les nouvelles valeurs de colonnes d'une
   commande <command>INSERT</command> ou <command>UPDATE</command>, ou dans les
   conditions de recherche d'un certain nombre de commandes. Le résultat d'une
   expression de valeurs est quelquefois appelé <firstterm>scalaire</firstterm>,
   pour le distinguer du résultat d'une expression de table (qui est une table).
   Les expressions de valeurs sont aussi appelées des <firstterm>expressions
   scalaires</firstterm> (voire même simplement des
   <firstterm>expressions</firstterm>). La syntaxe d'expression permet le
   calcul des valeurs à partir de morceaux primitifs en utilisant les
   opérations arithmétiques, logiques, d'ensemble et autres.
  </para>

  <para>
   Une expression de valeur peut être&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      une constante ou une valeur constante&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      une référence de colonne&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      une référence de la position d'un paramètre, dans le corps d'une
      définition de fonction ou d'instruction préparée&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      une expression indicée&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      une expression de sélection de champs&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      un appel d'opérateur&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      un appel de fonction&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      une expression d'agrégat&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      un appel de fonction de fenêtrage&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      une conversion de type&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      une expression de collationnement&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      une sous-requête scalaire&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      un constructeur de tableau&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      un constructeur de ligne&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      toute expression de valeur entre parenthèses, utile pour grouper des
      sous-expressions et surcharger la précédence.
      <indexterm><primary>parenthèses</primary></indexterm>
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   En plus de cette liste, il existe un certain nombre de constructions pouvant
   être classées comme une expression mais ne suivant aucune règle de syntaxe
   générale. Elles ont généralement la sémantique d'une fonction ou d'un
   opérateur et sont expliquées au <xref linkend="functions"/>. Un exemple est
   la clause <literal>IS NULL</literal>.
  </para>

  <para>
   Nous avons déjà discuté des constantes dans la <xref
   linkend="sql-syntax-constants"/>. Les sections suivantes discutent des
   options restantes.
  </para>

  <sect2 id="sql-expressions-column-refs">
   <title>Références de colonnes</title>

   <indexterm>
    <primary>référence de colonne</primary>
   </indexterm>

   <para>
    Une colonne peut être référencée avec la forme&nbsp;:
<synopsis><replaceable>correlation</replaceable>.<replaceable>nom_colonne</replaceable></synopsis>
   </para>

   <para>
    <replaceable>correlation</replaceable> est le nom d'une table (parfois
    qualifié par son nom de schéma) ou un alias d'une table définie au moyen de
    la clause <literal>FROM</literal>. Le nom de corrélation et le point de
    séparation peuvent être omis si le nom de colonne est unique dans les
    tables utilisées par la requête courante (voir aussi le <xref
    linkend="queries"/>).
   </para>
  </sect2>

  <sect2 id="sql-expressions-parameters-positional">
   <title>Paramètres de position</title>

   <indexterm>
    <primary>paramètre</primary>
    <secondary>syntaxe</secondary>
   </indexterm>

   <indexterm>
    <primary>$</primary>
   </indexterm>

   <para>
    Un paramètre de position est utilisé pour indiquer une valeur fournie en
    externe par une instruction SQL. Les paramètres sont utilisés dans des
    définitions de fonction SQL et dans les requêtes préparées. Quelques
    bibliothèques clients supportent aussi la spécification de valeurs de
    données séparément de la chaîne de commande SQL, auquel cas les paramètres
    sont utilisés pour référencer les valeurs de données en dehors. Le format
    d'une référence de paramètre est&nbsp;:
<synopsis>$<replaceable>numéro</replaceable></synopsis>
   </para>

   <para>
    Par exemple, considérez la définition d'une fonction&nbsp;:
    <function>dept</function>&nbsp;:

<programlisting>CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE nom = $1 $$
    LANGUAGE SQL;</programlisting>

    Dans cet exemple, <literal>$1</literal> référence la valeur du premier
    argument de la fonction à chaque appel de cette commande.
   </para>
  </sect2>

  <sect2 id="sql-expressions-subscripts">
   <title>Indices</title>

   <indexterm>
    <primary>indice</primary>
   </indexterm>

   <para>
    Si une expression récupère une valeur de type tableau, alors un élément
    spécifique du tableau peut être extrait en écrivant&nbsp;:
<synopsis><replaceable>expression</replaceable>[<replaceable>indice</replaceable>]</synopsis>
    Des éléments adjacents (un <quote>morceau de tableau</quote>) peuvent être
    extraits en écrivant&nbsp;:
<synopsis><replaceable>expression</replaceable>[<replaceable>indice_bas</replaceable>:<replaceable>indice_haut</replaceable>]</synopsis>
    Les crochets <literal>[ ]</literal> doivent apparaître réellement. Chaque
    <replaceable>indice</replaceable> est lui-même une expression, devant
    contenir une valeur entière.
   </para>

   <para>
    En général, l'<replaceable>expression</replaceable> de type tableau doit
    être entre parenthèses mais ces dernières peuvent être omises lorsque
    l'expression utilisée comme indice est seulement une référence de colonne
    ou un paramètre de position. De plus, les indices multiples peuvent être
    concaténés lorsque le tableau original est multi-dimensionnel. Par
    exemple&nbsp;:

<programlisting>ma_table.colonnetableau[4]
ma_table.colonnes_deux_d[17][34]
$1[10:42]
(fonctiontableau(a,b))[42]
    </programlisting>

    Dans ce dernier exemple, les parenthèses sont requises. Voir la <xref
    linkend="arrays"/> pour plus d'informations sur les tableaux.
   </para>
  </sect2>

  <sect2 id="field-selection">
   <title>Sélection de champs</title>

   <indexterm>
    <primary>sélection de champs</primary>
   </indexterm>

   <para>
    Si une expression récupère une valeur de type composite (type row), alors
    un champ spécifique de la ligne est extrait en écrivant&nbsp;:
    <synopsis><replaceable>expression</replaceable>.<replaceable>nom_champ</replaceable></synopsis>
   </para>

   <para>
    En général, l'<replaceable>expression</replaceable> de ligne doit être
    entre parenthèses mais les parenthèses peuvent être omises lorsque
    l'expression à partir de laquelle se fait la sélection est seulement une
    référence de table ou un paramètre de position. Par exemple&nbsp;:

<programlisting>ma_table.macolonne
$1.unecolonne
(fonctionligne(a,b)).col3</programlisting>

    En fait, une référence de colonne qualifiée est un cas spécial de syntaxe
    de sélection de champ. Un cas spécial important revient à extraire un champ
    de la colonne de type composite d'une table&nbsp;:

<programlisting>
(colcomposite).unchamp
(matable.colcomposite).unchamp
    </programlisting>

    Les parenthèses sont requises ici pour montrer que
    <structfield>colcomposite</structfield> est un nom de colonne, et non pas
    un nom de table, ou que <structname>matable</structname> est un nom de
    table, pas un nom de schéma dans le deuxième cas.
   </para>

   <para>
    Vous pouvez demander tous les champs d'une valeur composite en écrivant
    <literal>.*</literal>&nbsp;:
    <programlisting>
(compositecol).*
    </programlisting>
    Cette syntaxe se comporte différemment suivant le contexte. Voir <xref
    linkend="rowtypes-usage"/> pour plus de détails.
   </para>
  </sect2>

  <sect2 id="sql-expressions-operator-calls">
   <title>Appels d'opérateurs</title>

   <indexterm>
    <primary>opérateur</primary>
    <secondary>appel</secondary>
   </indexterm>

   <para>
    Il existe trois syntaxes possibles pour l'appel d'un opérateur&nbsp;:
    <simplelist>
     <member><replaceable>expression</replaceable>
      <replaceable>opérateur</replaceable> <replaceable>expression</replaceable>
      (opérateur binaire préfixe)</member>
     <member><replaceable>opérateur</replaceable>
      <replaceable>expression</replaceable> (opérateur unaire préfixe)</member>
     <member><replaceable>expression</replaceable>
      <replaceable>opérateur</replaceable> (opérateur unaire suffixe)</member>
    </simplelist>
    où le jeton <replaceable>opérateur</replaceable> suit les règles de syntaxe
    de la <xref linkend="sql-syntax-operators"/>, ou est un des mots clés
    <token>AND</token>, <token>OR</token> et <token>NOT</token>, ou est un nom
    d'opérateur qualifié de la forme
    <synopsis><literal>OPERATOR(</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>nom_operateur</replaceable><literal>)</literal></synopsis>
    Quel opérateur particulier existe et est-il unaire ou binaire dépend des
    opérateurs définis par le système ou l'utilisateur. Le <xref
    linkend="functions"/> décrit les opérateurs internes.
   </para>
  </sect2>

  <sect2 id="sql-expressions-function-calls">
   <title>Appels de fonctions</title>

   <indexterm>
    <primary>fonction</primary>
    <secondary>appel</secondary>
   </indexterm>

   <para>
    La syntaxe pour un appel de fonction est le nom d'une fonction (qualifié ou
    non du nom du schéma) suivi par sa liste d'arguments entre
    parenthèses&nbsp;:

<synopsis><replaceable>nom_fonction</replaceable>(<optional><replaceable>expression</replaceable> <optional>,<replaceable>expression</replaceable> ...</optional></optional> )</synopsis>
   </para>

   <para>
    Par exemple, ce qui suit calcule la racine carré de 2&nbsp;:
<programlisting>sqrt(2)</programlisting>
   </para>

   <para>
    La liste des fonctions intégrées se trouve dans le <xref
    linkend="functions"/>. D'autres fonctions pourraient être ajoutées par
    l'utilisateur.
   </para>

   <para>
    En option, les arguments peuvent avoir leur nom attaché. Voir la <xref
    linkend="sql-syntax-calling-funcs"/> pour les détails.
   </para>

   <note>
    <para>
     Une fonction qui prend un seul argument de type composite peut aussi être
     appelée en utilisant la syntaxe de sélection de champ. Du coup, un champ
     peut être écrit dans le style fonctionnel. Cela signifie que les notations
     <literal>col(table)</literal> et <literal>table.col</literal> sont
     interchangeables. Ce comportement ne respecte pas le standard SQL mais il
     est fourni dans <productname>PostgreSQL</productname> car il permet
     l'utilisation de fonctions émulant les <quote>champs calculés</quote>.
     Pour plus d'informations, voir la <xref
     linkend="rowtypes-usage"/>.
    </para>
   </note>
  </sect2>

  <sect2 id="syntax-aggregates">
   <title>Expressions d'agrégat</title>

   <indexterm zone="syntax-aggregates">
    <primary>fonction d'agrégat</primary>
    <secondary>appel</secondary>
   </indexterm>

   <indexterm zone="syntax-aggregates">
    <primary>agrégat avec ensemble trié</primary>
   </indexterm>

   <indexterm zone="syntax-aggregates">
    <primary>WITHIN GROUP</primary>
   </indexterm>

   <indexterm zone="syntax-aggregates">
    <primary>FILTER</primary>
   </indexterm>

   <para>
    Une <firstterm>expression d'agrégat</firstterm> représente l'application
    d'une fonction d'agrégat à travers les lignes sélectionnées par une requête.
    Une fonction d'agrégat réduit les nombres entrés en une seule valeur de
    sortie, comme la somme ou la moyenne des valeurs en entrée. La syntaxe d'une
    expression d'agrégat est une des suivantes&nbsp;:

<synopsis><replaceable>nom_agregat</replaceable> (<replaceable>expression</replaceable> [ , ... ] [ <replaceable>clause_order_by</replaceable> ] ) [ FILTER ( WHERE <replaceable>clause_filtre</replaceable> ) ]
<replaceable>nom_agregat</replaceable> (ALL <replaceable>expression</replaceable> [ , ... ] [ <replaceable>clause_order_by</replaceable> ] ) [ FILTER ( WHERE <replaceable>clause_filtre</replaceable> ) ]
<replaceable>nom_agregat</replaceable> (DISTINCT <replaceable>expression</replaceable> [ , ... ] [ <replaceable>clause_order_by</replaceable> ] ) [ FILTER ( WHERE <replaceable>clause_filtre</replaceable> ) ]
<replaceable>nom_agregat</replaceable> ( * ) [ FILTER ( WHERE <replaceable>clause_filtre</replaceable> ) ]
<replaceable>nom_agregat</replaceable> ( [ <replaceable>expression</replaceable> [ , ... ] ] ) WITHIN GROUP ( <replaceable>clause_order_by</replaceable> ) [ FILTER ( WHERE <replaceable>clause_filtre</replaceable> ) ]</synopsis>

    où <replaceable>nom_agregat</replaceable> est un agrégat précédemment
    défini (parfois qualifié d'un nom de schéma),
    <replaceable>expression</replaceable> est toute expression de valeur qui ne
    contient pas lui-même une expression d'agrégat ou un appel à une fonction
    de fenêtrage. Les clauses optionnelles <replaceable>clause_order_by</replaceable> et
    <replaceable>clause_filtre</replaceable> sont décrites ci-dessous.
   </para>

   <para>
    La première forme d'expression d'agrégat appelle l'agrégat une fois pour
    chaque ligne en entrée. La seconde forme est identique à la première car
    <literal>ALL</literal> est une clause active par défaut. La troisième forme
    fait appel à l'agrégat une fois pour chaque valeur distincte de l'expression
    (ou ensemble distinct de valeurs, pour des expressions multiples) trouvée
    dans les lignes en entrée. La quatrième forme appelle l'agrégat une fois pour
    chaque ligne en entrée&nbsp;; comme aucune valeur particulière en entrée
    n'est spécifiée, c'est généralement utile pour la fonction d'agrégat
    <function>count(*)</function>.
    La dernière forme est utilisée avec les agrégats à <firstterm>ensemble
    trié</firstterm> qui sont décrits ci-dessous.
   </para>

   <para>
    La plupart des fonctions d'agrégats ignorent les entrées NULL, pour que les
    lignes qui renvoient une ou plusieurs expressions NULL soient disqualifiées.
    Ceci peut être considéré vrai pour tous les agrégats internes sauf
    indication contraire.
   </para>

   <para>
    Par exemple, <literal>count(*)</literal> trouve le nombre total de lignes
    en entrée alors que <literal>count(f1)</literal> récupère le nombre de
    lignes en entrée pour lesquelles <literal>f1</literal> n'est pas NULL. En
    effet, la fonction <function>count</function> ignore les valeurs NULL mais
    <literal>count(distinct f1)</literal> retrouve le nombre de valeurs
    distinctes non NULL de <literal>f1</literal>.
   </para>

   <para>
    D'habitude, les lignes en entrée sont passées à la fonction d'agrégat dans
    un ordre non spécifié. Dans la plupart des cas, cela n'a pas d'importance.
    Par exemple, <function>min</function> donne le même résultat quelque soit
    l'ordre dans lequel il reçoit les données. Néanmoins, certaines fonctions
    d'agrégat (tels que <function>array_agg</function> et
    <function>string_agg</function>) donnent un résultat dépendant de l'ordre
    des lignes en entrée. Lors de l'utilisation de ce type d'agrégat, la clause
    <replaceable>clause_order_by</replaceable> peut être utilisée pour préciser
    l'ordre de tri désiré. La clause <replaceable>clause_order_by</replaceable>
    a la même syntaxe que la clause <literal>ORDER BY</literal> d'une requête,
    qui est décrite dans la <xref linkend="queries-order"/>, sauf que ses
    expressions sont toujours des expressions simples et ne peuvent pas être
    des noms de colonne en sortie ou des numéros. Par exemple&nbsp;:

<programlisting>SELECT array_agg(a ORDER BY b DESC) FROM table;</programlisting>
   </para>

   <para>
    Lors de l'utilisation de fonctions d'agrégat à plusieurs arguments, la
    clause <literal>ORDER BY</literal> arrive après tous les arguments de
    l'agrégat. Par exemple, il faut écrire ceci&nbsp;:
<programlisting>SELECT string_agg(a, ',' ORDER BY a) FROM table;</programlisting>
    et non pas ceci&nbsp;:
<programlisting>SELECT string_agg(a ORDER BY a, ',') FROM table;  -- incorrect</programlisting>
    Ce dernier exemple est syntaxiquement correct mais il concerne un appel à
    une fonction d'agrégat à un seul argument avec deux clés pour le
    <literal>ORDER BY</literal> (le deuxième étant inutile car il est constant).
   </para>

   <para>
    Si <literal>DISTINCT</literal> est indiqué en plus de la clause
    <replaceable>clause_order_by</replaceable>, alors toutes les expressions
    de l'<literal>ORDER BY</literal> doivent correspondre aux arguments de
    l'agrégat&nbsp;; autrement dit, vous ne pouvez pas trier sur une expression
    qui n'est pas inclus dans la liste <literal>DISTINCT</literal>.
   </para>

   <note>
    <para>
     La possibilité de spécifier à la fois <literal>DISTINCT</literal> et
     <literal>ORDER BY</literal> dans une fonction d'agrégat est une extension
     de <productname>PostgreSQL</productname>.
    </para>
   </note>

   <para>
    Placer la clause <literal>ORDER BY</literal> dans la liste des arguments
    standards de l'agrégat, comme décrit jusqu'ici, est utilisé pour un agrégat 
    de type général et statistique pour lequel le tri est optionnel.
    Il existe une sous-classe de fonctions d'agrégat appelée <firstterm>agrégat
    d'ensemble trié</firstterm> pour laquelle la clause
    <replaceable>clause_order_by</replaceable> est <emphasis>requise</emphasis>,
    habituellement parce que le calcul de l'agrégat est seulement sensible à
    l'ordre des lignes en entrée. Des exemples typiques d'agrégat avec ensemble
    trié incluent les calculs de rang et de pourcentage. Pour un agrégat
    d'ensemble trié, la clause <replaceable>clause_order_by</replaceable> est
    écrite à l'intérieur de <literal>WITHIN GROUP (...)</literal>, comme indiqué
    dans la syntaxe alternative finale. Les expressions dans
    <replaceable>clause_order_by</replaceable> sont évaluées une fois par ligne
    en entrée, comme n'importe quel argument d'un agrégat, une fois triée suivant
    la clause <replaceable>clause_order_by</replaceable>, et envoyée à la fonction
    en tant qu'arguments en entrée. (Ceci est contraire au cas de la clause
    <replaceable>clause_order_by</replaceable> en dehors d'un <literal>WITHIN
    GROUP</literal> , qui n'est pas traité comme argument de la fonction d'agrégat.
    Les expressions d'argument précédant <literal>WITHIN GROUP</literal>, s'il y
    en a, sont appelées des <firstterm>arguments directs</firstterm> pour les
    distinguer des <firstterm>arguments agrégés</firstterm> listés dans
    <replaceable>clause_order_by</replaceable>.  Contrairement aux arguments
    normaux d'agrégats, les arguments directs sont évalués seulement une fois par
    appel d'agrégat et non pas une fois par ligne en entrée. Cela signifie qu'ils
    peuvent contenir des variables seulement si ces variables sont regroupés par
    <literal>GROUP BY</literal>&nbsp;; cette restriction est identique à si les
    arguments directs n'étaient pas dans une expression d'agrégat. Les arguments
    directs sont typiquement utilisés pour des fractions de pourcentage, qui
    n'ont de sens qu'en tant que valeur singulière par calcul d'agrégat. La liste
    d'arguments directs peut être vide&nbsp;; dans ce cas, écrivez simplement
    <literal>()</literal>, et non pas <literal>(*)</literal>.
    (<productname>PostgreSQL</productname> accepte actuellement les deux écritures
    mais seule la première est conforme avec le standard SQL.)
   </para>

   <para>
    <indexterm>
     <primary>médian</primary>
     <seealso>pourcentage</seealso>
    </indexterm>
    Voici un exemple d'appel d'agrégat à ensemble trié&nbsp;:

<programlisting>
SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY revenu) FROM proprietes;
 percentile_cont
-----------------
           50489
    </programlisting>

    qui obtient le 50è pourcentage ou le médian des valeurs de la colonne
    <structfield>revenu</structfield> de la table <structname>proprietes</structname>.
    Ici, <literal>0.5</literal> est un argument direct&nbsp;; cela n'aurait pas
    de sens si la fraction de pourcentage était une valeur variant suivant les
    lignes.
   </para>

   <para>
    Si la clause <literal>FILTER</literal> est spécifié, alors seules les lignes
    en entrée pour lesquelles <replaceable>filter_clause</replaceable> est
    vraie sont envoyées à la fonction d'agrégat&nbsp;; les autres lignes sont
    ignorées. Par exemple&nbsp;:
    <programlisting><![CDATA[
SELECT
    count(*) AS nonfiltres,
    count(*) FILTER (WHERE i < 5) AS filtres
FROM generate_series(1,10) AS s(i);
 nonfiltres | filtres
------------+---------
         10 |       4
(1 row)]]></programlisting>
   </para>

   <para>
    Les fonctions d'agrégat prédéfinies sont décrites dans la <xref
    linkend="functions-aggregate"/>. D'autres fonctions d'agrégat pourraient
    être ajoutées par l'utilisateur.
   </para>

   <para>
    Une expression d'agrégat peut seulement apparaître dans la liste de
    résultats ou dans la clause <literal>HAVING</literal> d'une commande
    <command>SELECT</command>. Elle est interdite dans d'autres clauses, tels
    que <literal>WHERE</literal>, parce que ces clauses sont logiquement
    évaluées avant que les résultats des agrégats ne soient calculés.
   </para>

   <para>
    Lorsqu'une expression d'agrégat apparaît dans une sous-requête (voir la
    <xref linkend="sql-syntax-scalar-subqueries"/> et la <xref
    linkend="functions-subquery"/>), l'agrégat est normalement évalué sur les
    lignes de la sous-requête. Cependant, une exception survient si les
    arguments de l'agrégat (et <replaceable>clause_filtre</replaceable>
    si fourni) contiennent seulement des niveaux externes de
    variables&nbsp;: ensuite, l'agrégat appartient au niveau externe le plus
    proche et est évalué sur les lignes de cette requête. L'expression de
    l'agrégat est une référence externe pour la sous-requête dans laquelle il
    apparaît et agit comme une constante sur toute évaluation de cette requête.
    La restriction apparaissant seulement dans la liste de résultat ou dans la
    clause <literal>HAVING</literal> s'applique avec respect du niveau de
    requête auquel appartient l'agrégat.
   </para>
  </sect2>

  <sect2 id="syntax-window-functions">
   <title>Appels de fonction de fenêtrage</title>

   <indexterm zone="syntax-window-functions">
    <primary>fonction de fenêtrage</primary>
    <secondary>appel</secondary>
   </indexterm>

   <indexterm zone="syntax-window-functions">
    <primary>clause OVER</primary>
   </indexterm>

   <para>
    Un <firstterm>appel de fonction de fenêtrage</firstterm> représente
    l'application d'une fonction de type agrégat sur une portion des lignes
    sélectionnées par une requête. Contrairement aux appels de fonction
    d'agrégat standard, ce n'est pas lié au groupement des lignes sélectionnées
    en une seule ligne résultat &mdash; chaque ligne reste séparée dans les
    résultats. Néanmoins, la fonction de fenêtrage a accès à
    toutes les lignes qui font partie du groupe de la ligne courante d'après
    la spécification du groupe (liste <literal>PARTITION BY</literal>) de
    l'appel de la fonction de fenêtrage. La syntaxe d'un appel de fonction de
    fenêtrage est une des suivantes&nbsp;:

<synopsis>
<replaceable>nom_fonction</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) [ FILTER ( WHERE <replaceable>clause_filtre</replaceable> ) ] OVER <replaceable>nom_window</replaceable>
<replaceable>nom_fonction</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) [ FILTER ( WHERE <replaceable>clause_filtre</replaceable> ) ] OVER ( <replaceable class="parameter">définition_window</replaceable> )
<replaceable>nom_fonction</replaceable> ( * ) [ FILTER ( WHERE <replaceable>clause_filtre</replaceable> ) ] OVER <replaceable>nom_window</replaceable>
<replaceable>nom_fonction</replaceable> ( * ) [ FILTER ( WHERE <replaceable>clause_filtre</replaceable> ) ] OVER ( <replaceable class="parameter">définition_window</replaceable> )
    </synopsis>
    où <replaceable class="parameter">définition_fenêtrage</replaceable> a comme
    syntaxe&nbsp;:
    <synopsis>
[ <replaceable class="parameter">nom_fenêtrage_existante</replaceable> ]
[ PARTITION BY <replaceable class="parameter">expression</replaceable> [, ...] ]
[ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">opérateur</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <replaceable class="parameter">clause_portée</replaceable> ]
    </synopsis>
    et la clause <replaceable class="parameter">clause_portée</replaceable>
    optionnelle fait partie de&nbsp;:
    <synopsis>
{ RANGE | ROWS } <replaceable>début_portée</replaceable>
{ RANGE | ROWS } BETWEEN <replaceable>début_portée</replaceable> AND <replaceable>fin_portée</replaceable>
    </synopsis>
    avec <replaceable>début_portée</replaceable> et
    <replaceable>fin_portée</replaceable> pouvant faire partie de
    <synopsis>
UNBOUNDED PRECEDING
<replaceable>valeur</replaceable> PRECEDING
CURRENT ROW
<replaceable>valeur</replaceable> FOLLOWING
UNBOUNDED FOLLOWING
    </synopsis>
   </para>

   <para>
    Ici, <replaceable>expression</replaceable> représente toute expression de
    valeur qui ne contient pas elle-même d'appel à des fonctions de fenêtrage.
   </para>

   <para>
    <replaceable>nom_fenêtrage</replaceable> est une référence à la
    spécification d'une fenêtre nommée, définie dans la clause
    <literal>WINDOW</literal> de la requête. Les spécifications de fenêtres
    nommées sont habituellement référencées avec <literal>OVER</literal>
    <replaceable>nom_fenêtrage</replaceable>, mais il est aussi possible
    d'écrire un nom de fenêtre entre parenthèses, puis de fournir en option une
    clause de tri et/ou une clause de portée (la fenêtre reférencée ne doit pas
    avoir ces clauses si elles sont fournies ici). Cette dernière syntaxe suit
    les mêmes règles que la modification d'un nom de fenêtre existant dans une
    clause <literal>WINDOW</literal>&nbsp;; voir la page de référence de <xref
    linkend="sql-select"/> pour les détails.
   </para>

   <para>
    La clause <literal>PARTITION BY</literal> groupe les lignes de la requête en
    <firstterm>partitions</firstterm>, qui sont traitées séparément par la
    fonction de fenêtrage. <literal>PARTITION BY</literal> fonctionne de la même
    façon qu'une clause <literal>GROUP BY</literal> au niveau de la requête,
    sauf que ses expressions sont toujours des expressions et ne peuvent pas
    être des noms ou des numéros de colonnes en sortie. Sans <literal>PARTITION
     BY</literal>, toutes les lignes produites par la requête sont traitées comme
    une seule partition. La clause <literal>ORDER BY</literal> détermine l'ordre
    dans lequel les lignes d'une partition sont traitées par la fonction de
    fenêtrage. Cela fonctionne de la même façon que la clause <literal>ORDER
     BY</literal> d'une requête mais ne peut pas non plus utilisé les noms ou
    les numéros des colonnes en sortie. Sans <literal>ORDER BY</literal>, les
    lignes sont traitées dans n'importe quel ordre.
   </para>

   <para>
    La clause <replaceable class="parameter">clause_portée</replaceable> indique
    l'ensemble de lignes constituant la <firstterm>portée de la
     fenêtre</firstterm>, qui est un sous-ensemble de la partition en cours, pour
    les fonctions de fenêtrage qui agissent sur ce sous-ensemble plutôt que sur
    la partition entière. Le sous-ensemble peut être spécifié avec le mode
    <literal>RANGE</literal> ou avec le mode <literal>ROWS</literal>. Dans les
    deux cas, il s'exécute de <replaceable>début_portée</replaceable> à
    <replaceable>fin_portée</replaceable>.  Si <replaceable>fin_portée</replaceable>
    est omis, il vaut par défaut <literal>CURRENT ROW</literal>.
   </para>

   <para>
    Un <replaceable>début_portée</replaceable> à <literal>UNBOUNDED
     PRECEDING</literal> signifie que le sous-ensemble commence avec la première
    ligne de la partition. De la même façon, un
    <replaceable>fin_portée</replaceable> à <literal>UNBOUNDED
     FOLLOWING</literal> signifie que le sous-ensemble se termine avec la
    dernière ligne de la partition.
   </para>

   <para>
    Dans le mode <literal>RANGE</literal>, un
    <replaceable>début_portée</replaceable> à <literal>CURRENT ROW</literal>
    signifie que le sous-ensemble commence avec la ligne suivant la ligne
    courante (une ligne que <literal>ORDER BY</literal> considère comme
    équivalente à la ligne courante), alors qu'un
    <replaceable>fin_portée</replaceable> à <literal>CURRENT ROW</literal>
    signifie que le sous-ensemble se termine avec le <literal>ORDER BY</literal> équivalent. Dans
    le mode <literal>ROWS</literal>, <literal>CURRENT ROW</literal> signifie
    simplement la ligne courante.
   </para>

   <para>
    La <replaceable>valeur</replaceable> <literal>PRECEDING</literal> et la
    <replaceable>valeur</replaceable> <literal>FOLLOWING</literal> sont
    actuellement seulement autorisées dans le mode <literal>ROWS</literal>.
    Elles indiquent que le sous-ensemble commence ou finit au nombre spécifié
    de lignes avant ou après la ligne courante.
    <replaceable>valeur</replaceable> doit être une expression entière ne
    contenant pas de variables, de fonctions d'agrégat ou de fonctions de
    fenêtrage. La valeur doit être non NULL et positive. Elle peut être égale
    à zéro, auquel cas elle sélectionne simplement la ligne courante.
   </para>

   <para>
    L'option par défaut est <literal>RANGE UNBOUNDED PRECEDING</literal>, ce
    qui est identique à <literal>RANGE BETWEEN UNBOUNDED PRECEDING AND
     CURRENT ROW</literal>. Avec <literal>ORDER BY</literal>, ceci configure le
    sous-ensemble à contenir toutes les lignes de la partition à partir de la
    ligne courante. Sans <literal>ORDER BY</literal>, toutes les lignes de la
    partition sont inclus dans le sous-ensemble de la fenêtre car toutes les
    lignes deviennent voisines de la ligne en cours.
   </para>

   <para>
    Les restrictions sont que <replaceable>début_portée</replaceable> ne peut
    pas valoir <literal>UNBOUNDED FOLLOWING</literal>,
    <replaceable>fin_portée</replaceable> ne peut pas valoir <literal>UNBOUNDED
     PRECEDING</literal>, et le choix de <replaceable>fin_portée</replaceable>
    ne peut pas apparaître avant le choix de
    <replaceable>début_portée</replaceable> &mdash; par exemple, <literal>RANGE
     BETWEEN CURRENT ROW AND <replaceable>valeur</replaceable> PRECEDING</literal>
    n'est pas autorisé.
   </para>

   <para>
    Si <literal>FILTER</literal> est indiqué, seules les lignes en entrée pour
    lesquelles <replaceable>clause_filtre</replaceable> est vrai sont
    envoyées à la fonction de fenêtrage. Les autres lignes sont simplement
    ignorées. Seules les fonctions de fenêtrage qui sont des agrégats acceptent
    une clause <literal>FILTER</literal>.
   </para>

   <para>
    Les fonctions de fenêtrage internes sont décrites dans la <xref
    linkend="functions-window-table"/>. D'autres fonctions de fenêtrage peuvent
    être ajoutées par l'utilisateur. De plus, toute fonction d'agrégat de type général
    ou statistique peut être utilisée comme fonction de fenêtrage.
    Néanmoins, les agrégats d'ensemble trié et d'ensemble hypothétique ne peuvent pas être utilisés
    actuellement comme des fonctions de fenêtrage.
   </para>

   <para>
    Les syntaxes utilisant <literal>*</literal> sont utilisées pour appeler des
    fonctions d'agrégats sans paramètres en tant que fonctions de fenêtrage.
    Par exemple&nbsp;: <literal>count(*) OVER (PARTITION BY x ORDER BY
     y)</literal>. Le symbole <literal>*</literal> n'est habituellement pas utilisé pour les
    fonctions de fenêtrage. Les fonctions de
    fenêtrage n'autorisent pas l'utilisation de <literal>DISTINCT</literal> ou
    <literal>ORDER BY</literal> dans la liste des arguments de la fonction.
   </para>

   <para>
    Les appels de fonctions de fenêtrage sont autorisés seulement dans la liste
    <literal>SELECT</literal> et dans la clause <literal>ORDER BY</literal> de
    la requête.
   </para>

   <para>
    Il existe plus d'informations sur les fonctions de fenêtrages dans la
    <xref linkend="tutorial-window"/>, dans la <xref
    linkend="functions-window"/> et dans la <xref linkend="queries-window"/>.
   </para>
  </sect2>

  <sect2 id="sql-syntax-type-casts">
   <title>Conversions de type</title>

   <indexterm>
    <primary>type de données</primary>
    <secondary>conversion de type</secondary>
   </indexterm>

   <indexterm>
    <primary>conversion de type</primary>
   </indexterm>

   <indexterm>
    <primary>::</primary>
   </indexterm>

   <para>
    Une conversion de type spécifie une conversion à partir d'un type de données
    vers un autre. <productname>PostgreSQL</productname> accepte deux syntaxes
    équivalentes pour les conversions de type&nbsp;:
    <synopsis>CAST ( <replaceable>expression</replaceable> AS <replaceable>type</replaceable> )
<replaceable>expression</replaceable>::<replaceable>type</replaceable></synopsis>
    La syntaxe <literal>CAST</literal> est conforme à SQL&nbsp;; la syntaxe avec
    <literal>::</literal> est historique dans
    <productname>PostgreSQL</productname>.
   </para>

   <para>
    Lorsqu'une conversion est appliquée à une expression de valeur pour un type
    connu, il représente une conversion de type à l'exécution. Cette conversion
    réussira seulement si une opération convenable de conversion de type a été
    définie. Notez que ceci est subtilement différent de l'utilisation de
    conversion avec des constantes, comme indiqué dans la <xref
    linkend="sql-syntax-constants-generic"/>. Une conversion appliquée à une
    chaîne constante représente l'affectation initiale d'un type pour une valeur
    constante, et donc cela réussira pour tout type (si le contenu de la chaîne
    constante est une syntaxe acceptée en entrée pour le type de donnée).
   </para>

   <para>
    Une conversion de type explicite pourrait être habituellement omise s'il
    n'y a pas d'ambiguïté sur le type qu'une expression de valeur pourrait
    produire (par exemple, lorsqu'elle est affectée à une colonne de
    table)&nbsp;; le système appliquera automatiquement une conversion de type
    dans de tels cas. Néanmoins, la conversion automatique est réalisée
    seulement pour les conversions marquées <quote>OK pour application
    implicite</quote> dans les catalogues système. D'autres conversions peuvent
    être appelées avec la syntaxe de conversion explicite. Cette restriction a
    pour but d'empêcher l'exécution silencieuse de conversions surprenantes.
   </para>

   <para>
    Il est aussi possible de spécifier une conversion de type en utilisant une
    syntaxe de type fonction&nbsp;:
<synopsis><replaceable>nom_type</replaceable> ( <replaceable>expression</replaceable> )</synopsis>
    Néanmoins, ceci fonctionne seulement pour les types dont les noms sont
    aussi valides en tant que noms de fonctions. Par exemple, <literal>double
    precision</literal> ne peut pas être utilisé de cette façon mais son
    équivalent <literal>float8</literal> le peut. De même, les noms
    <literal>interval</literal>, <literal>time</literal> et
    <literal>timestamp</literal> peuvent seulement être utilisés de cette façon
    s'ils sont entre des guillemets doubles à cause des conflits de syntaxe. Du
    coup, l'utilisation de la syntaxe de conversion du style fonction amène à
    des incohérences et devrait probablement être évitée.
   </para>
   <note>
    <para>
     La syntaxe par fonction est en fait seulement un appel de fonction. Quand
     un des deux standards de syntaxe de conversion est utilisé pour faire une
     conversion à l'exécution, elle appellera en interne une fonction
     enregistrée pour réaliser la conversion. Par convention, ces fonctions de
     conversion ont le même nom que leur type de sortie et, du coup, la syntaxe
     par fonction n'est rien de plus qu'un appel direct à la fonction de
     conversion sous-jacente. Évidemment, une application portable ne devrait
     pas s'y fier. Pour plus d'informations, voir la page de manuel de <xref
     linkend="sql-createcast"/>.
    </para>
   </note>
  </sect2>

  <sect2 id="sql-syntax-collate-exprs">
   <title>Expressions de collationnement</title>

   <indexterm>
    <primary>COLLATE</primary>
   </indexterm>

   <para>
    La clause <literal>COLLATE</literal> surcharge le collationnement d'une
    expression. Elle est ajoutée à l'expression à laquelle elle
    s'applique&nbsp;:
<synopsis><replaceable>expr</replaceable> COLLATE <replaceable>collationnement</replaceable></synopsis>
    où <replaceable>collationnement</replaceable> est un identificateur pouvant
    être qualifié par son schéma. La clause <literal>COLLATE</literal> a
    priorité par rapport aux opérateurs&nbsp;; des parenthèses peuvent être
    utilisées si nécessaire.
   </para>

   <para>
    Si aucun collationnement n'est spécifiquement indiqué, le système de bases
    de données déduit cette information du collationnement des colonnes
    impliquées dans l'expression. Si aucune colonne ne se trouve dans
    l'expression, il utilise le collationnement par défaut de la base de
    données.
   </para>

   <para>
    Les deux utilisations principales de la clause <literal>COLLATE</literal>
    sont la surcharge de l'ordre de tri dans une clause <literal>ORDER
    BY</literal>, par exemple&nbsp;:
<programlisting>SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE "C";</programlisting>
    et la surcharge du collationnement d'une fonction ou d'un opérateur qui
    produit un résultat sensible à la locale, par exemple&nbsp;:
<programlisting>
SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE "C";
    </programlisting>
    Notez que, dans le dernier cas, la clause <literal>COLLATE</literal> est
    attachée à l'argument en entrée de l'opérateur. Peu importe l'argument de
    l'opérateur ou de la fonction qui a la clause <literal>COLLATE</literal>
    parce que le collationnement appliqué à l'opérateur ou à la fonction est
    dérivé en considérant tous les arguments, et une clause
    <literal>COLLATE</literal> explicite surchargera les collationnements des
    autres arguments. (Attacher des clauses <literal>COLLATE</literal>
    différentes sur les arguments aboutit à une erreur. Pour plus de détails,
    voir la <xref linkend="collation"/>.) Du coup, ceci donne le même résultat
    que l'exemple précédent&nbsp;:
    <programlisting>SELECT * FROM tbl WHERE a COLLATE "C" &gt; 'foo';</programlisting>
    Mais ceci n'est pas valide&nbsp;:
<programlisting>SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE "C";</programlisting>
    car cette requête cherche à appliquer un collationnement au résultat de
    l'opérateur <literal>&gt;</literal>, qui est du type <type>boolean</type>,
    type non sujet au collationnement.
   </para>
  </sect2>

  <sect2 id="sql-syntax-scalar-subqueries">
   <title>Sous-requêtes scalaires</title>

   <indexterm>
    <primary>sous-requête</primary>
   </indexterm>

   <para>
    Une sous-requête scalaire est une requête <command>SELECT</command>
    ordinaire entre parenthèses renvoyant exactement une ligne avec une colonne
    (voir le <xref linkend="queries"/> pour plus d'informations sur l'écriture
    des requêtes). La requête <command>SELECT</command> est exécutée et la
    seule valeur renvoyée est utilisée dans l'expression de valeur englobante.
    C'est une erreur d'utiliser une requête qui renvoie plus d'une ligne ou plus
    d'une colonne comme requête scalaire. Mais si, lors d'une exécution
    particulière, la sous-requête ne renvoie pas de lignes, alors il n'y a pas
    d'erreur&nbsp;; le résultat scalaire est supposé NULL. La sous-requête peut
    référencer des variables de la requête englobante, qui agiront comme des
    constantes durant toute évaluation de la sous-requête. Voir aussi la <xref
    linkend="functions-subquery"/> pour d'autres expressions impliquant des
    sous-requêtes.
   </para>

   <para>
    Par exemple, ce qui suit trouve la ville disposant de la population la plus
    importante dans chaque état&nbsp;:
<programlisting>SELECT nom, (SELECT max(pop) FROM villes WHERE villes.etat = etat.nom)
    FROM etats;</programlisting>
   </para>
  </sect2>

  <sect2 id="sql-syntax-array-constructors">
   <title>Constructeurs de tableaux</title>

   <indexterm>
    <primary>tableau</primary>
    <secondary>constructeur</secondary>
   </indexterm>

   <indexterm>
    <primary>ARRAY</primary>
   </indexterm>

   <para>
    Un constructeur de tableau est une expression qui construit une valeur de
    tableau à partir de la valeur de ses membres. Un constructeur de tableau
    simple utilise le mot clé <literal>ARRAY</literal>, un crochet ouvrant
    <literal>[</literal>, une liste d'expressions (séparées par des virgules)
    pour les valeurs des éléments du tableau et finalement un crochet fermant
    <literal>]</literal>. Par exemple&nbsp;:
<programlisting>SELECT ARRAY[1,2,3+4];
  array
---------
 {1,2,7}
(1 row)</programlisting>
    Par défaut, le type d'élément du tableau est le type commun des expressions
    des membres, déterminé en utilisant les mêmes règles que pour les
    constructions <literal>UNION</literal> ou <literal>CASE</literal> (voir la
    <xref linkend="typeconv-union-case"/>). Vous pouvez surcharger ceci en
    convertissant explicitement le constructeur de tableau vers le type désiré.
    Par exemple&nbsp;:
<programlisting>SELECT ARRAY[1,2,22.7]::integer[];
  array
----------
 {1,2,23}
(1 row)</programlisting>
    Ceci a le même effet que la conversion de chaque expression vers le type
    d'élément du tableau individuellement. Pour plus d'informations sur les
    conversions, voir la <xref linkend="sql-syntax-type-casts"/>.
   </para>

   <para>
    Les valeurs de tableaux multidimensionnels peuvent être construits par des
    constructeurs de tableaux imbriqués. Pour les constructeurs internes, le
    mot-clé <literal>ARRAY</literal> peut être omis. Par exemple, ces
    expressions produisent le même résultat&nbsp;:

<programlisting>SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)</programlisting>

    Comme les tableaux multidimensionnels doivent être rectangulaires, les
    constructeurs internes du même niveau doivent produire des sous-tableaux
    de dimensions identiques. Toute conversion appliquée au constructeur
    <literal>ARRAY</literal> externe se propage automatiquement à tous les
    constructeurs internes.
  </para>

  <para>
    Les éléments d'un constructeur de tableau multidimensionnel peuvent être
    tout ce qui récupère un tableau du bon type, pas seulement une construction
    d'un tableau imbriqué. Par exemple&nbsp;:
<programlisting>CREATE TABLE tab(f1 int[], f2 int[]);

INSERT INTO tab VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);

SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM tab;
                     array
------------------------------------------------
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)
    </programlisting>
   </para>

   <para>
    Vous pouvez construire un tableau vide mais, comme il est impossible d'avoir
    un tableau sans type, vous devez convertir explicitement votre tableau vide
    dans le type désiré. Par exemple&nbsp;:
    <programlisting>
SELECT ARRAY[]::integer[];
 array
-------
 {}
(1 row)</programlisting>
  </para>

  <para>
   Il est aussi possible de construire un tableau à partir des résultats d'une
   sous-requête. Avec cette forme, le constructeur de tableau est écrit avec le
   mot clé <literal>ARRAY</literal> suivi par une sous-requête entre
   parenthèses (et non pas des crochets). Par exemple&nbsp;:
<programlisting>SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                                 array
-----------------------------------------------------------------------
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412,2413}
(1 row)

SELECT ARRAY(SELECT ARRAY[i, i*2] FROM generate_series(1,5) AS a(i));
              array
----------------------------------
 {{1,2},{2,4},{3,6},{4,8},{5,10}}
(1 row)</programlisting>
   La sous-requête doit renvoyer une seule colonne. Si la sortie de la sous-
   requête n'est pas de type tableau, le tableau à une dimension résultant
   aura un élément pour chaque ligne dans le résultat de la sous-requête, avec
   un type élément correspondant à celui de la colonne en sortie de la sous-
   requête. Si la colonne en sortie de la sous-requête est de type tableau, le
   résultat sera un tableau du même type mais avec une dimension
   supplémentaire&nbsp;; dans ce cas, toutes les lignes de la sous-requête
   doivent renvoyer des tableaux de dimension identique (dans le cas
   contraire, le résultat ne serait pas rectangulaire).
  </para>

  <para>
   Les indices d'un tableau construit avec <literal>ARRAY</literal> commencent
   toujours à un. Pour plus d'informations sur les tableaux, voir la <xref
   linkend="arrays"/>.
  </para>

  </sect2>

  <sect2 id="sql-syntax-row-constructors">
    <title>Constructeurs de lignes</title>

    <indexterm>
      <primary>type composite</primary>
      <secondary>constructeur</secondary>
    </indexterm>

    <indexterm>
      <primary>type de ligne</primary>
      <secondary>constructeur</secondary>
    </indexterm>

    <indexterm>
      <primary>ROW</primary>
    </indexterm>

    <para>
      Un constructeur de ligne est une expression qui construit une valeur de
      ligne (aussi appelée une valeur composite) à partir des valeurs de ses
      membres. Un constructeur de ligne consiste en un mot clé
      <literal>ROW</literal>, une parenthèse gauche, zéro ou une ou plus d'une
      expression (séparées par des virgules) pour les valeurs des champs de la
      ligne, et enfin une parenthèse droite. Par exemple&nbsp;:
      <programlisting>SELECT ROW(1,2.5,'ceci est un test');</programlisting>
      Le mot clé <literal>ROW</literal> est optionnel lorsqu'il y a plus d'une
      expression dans la liste.
  </para>

   <para>
    Un constructeur de ligne peut inclure la syntaxe
    <replaceable>valeurligne</replaceable><literal>.*</literal>, qui sera
    étendue en une liste d'éléments de la valeur ligne, ce qui est le
    comportement habituel de la syntaxe <literal>.*</literal> utilisée au niveau
    haut d'une liste <command>SELECT</command> (voir <xref
    linkend="rowtypes-usage"/>). Par exemple, si la table
    <literal>t</literal> a les colonnes <literal>f1</literal> et
    <literal>f2</literal>, ces deux requêtes sont identiques&nbsp;:
<programlisting>
SELECT ROW(t.*, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;
    </programlisting>
   </para>

   <note>
    <para>
     Avant <productname>PostgreSQL</productname> 8.2, la syntaxe
     <literal>.*</literal> n'était pas étendue dans les constructeurs de
     lignes. De ce fait,
     <literal>ROW(t.*, 42)</literal> créait une ligne à deux champs dont le
     premier était une autre valeur de ligne. Le nouveau comportement est
     généralement plus utile. Si vous avez besoin de l'ancien comportement de
     valeurs de ligne imbriquées, écrivez la valeur de ligne interne sans
     <literal>.*</literal>, par exemple <literal>ROW(t, 42)</literal>.
    </para>
   </note>

   <para>
    Par défaut, la valeur créée par une expression <literal>ROW</literal> est
    d'un type d'enregistrement anonyme. Si nécessaire, il peut être converti en
    un type composite nommé &mdash; soit le type de ligne d'une table soit un
    type composite créé avec <command>CREATE TYPE AS</command>. Une conversion
    explicite pourrait être nécessaire pour éviter toute ambiguïté. Par
    exemple&nbsp;:
    <programlisting>CREATE TABLE ma_table(f1 int, f2 float, f3 text);

CREATE FUNCTION recup_f1(ma_table) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- Aucune conversion nécessaire parce que seul un recup_f1() existe
SELECT recup_f1(ROW(1,2.5,'ceci est un test'));
 recup_f1
----------
1
(1 row)

CREATE TYPE mon_typeligne AS (f1 int, f2 text, f3 numeric);

CREATE FUNCTION recup_f1(mon_typeligne) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- Maintenant, nous avons besoin d'une conversion
-- pour indiquer la fonction à appeler
SELECT recup_f1(ROW(1,2.5,'ceci est un test'));
ERROR:  function recup_f1(record) is not unique

SELECT recup_f1(ROW(1,2.5,'ceci est un test')::ma_table);
 getf1
-------
 1
(1 row)

SELECT recup_f1(CAST(ROW(11,'ceci est un test',2.5) AS mon_typeligne));
 getf1
-------
 11
(1 row)</programlisting>
</para>

  <para>
   Les constructeurs de lignes peuvent être utilisés pour construire des valeurs
   composites à stocker dans une colonne de table de type composite ou pour être
   passé à une fonction qui accepte un paramètre composite. De plus, il est
   possible de comparer deux valeurs de lignes ou pour tester une ligne avec
   <literal>IS NULL</literal> ou <literal>IS NOT NULL</literal>, par exemple
<programlisting>SELECT ROW(1,2.5,'ceci est un test') = ROW(1, 3, 'pas le même');

SELECT ROW(table.*) IS NULL FROM table; -- détecte toutes les lignes non NULL</programlisting>
   Pour plus de détails, voir la <xref linkend="functions-comparisons"/>. Les
   constructeurs de lignes peuvent aussi être utilisés en relation avec
   des sous-requêtes, comme discuté dans la <xref linkend="functions-subquery"/>.
  </para>

  </sect2>

  <sect2 id="syntax-express-eval">
   <title>Règles d'évaluation des expressions</title>

   <indexterm>
    <primary>expression</primary>
    <secondary>ordre d'évaluation</secondary>
   </indexterm>

   <para>
    L'ordre d'évaluation des sous-expressions n'est pas défini. En particulier,
    les entrées d'un opérateur ou d'une fonction ne sont pas obligatoirement
    évaluées de la gauche vers la droite ou dans un autre ordre fixé.
   </para>

   <para>
    De plus, si le résultat d'une expression peut être déterminé par
    l'évaluation de certaines parties de celle-ci, alors d'autres
    sous-expressions devraient ne pas être évaluées du tout. Par exemple, si
    vous écrivez&nbsp;:
<programlisting>SELECT true OR une_fonction();</programlisting>
    alors <literal>une_fonction()</literal> pourrait (probablement) ne pas être
    appelée du tout. Pareil dans le cas suivant&nbsp;:
<programlisting>SELECT une_fonction() OR true;</programlisting>
    Notez que ceci n'est pas identique au <quote>court-circuitage</quote> de
    gauche à droite des opérateurs booléens utilisé par certains langages de
    programmation.
   </para>

   <para>
    En conséquence, il est déconseillé d'utiliser des fonctions ayant des effets
    de bord dans une partie des expressions complexes. Il est particulièrement
    dangereux de se fier aux effets de bord ou à l'ordre d'évaluation dans les
    clauses <literal>WHERE</literal> et <literal>HAVING</literal> car ces
    clauses sont reproduites de nombreuses fois lors du développement du plan
    d'exécution. Les expressions booléennes (combinaisons
    <literal>AND</literal>/<literal>OR</literal>/<literal>NOT</literal>) dans
    ces clauses pourraient être réorganisées d'une autre façon autorisée dans
    l'algèbre booléenne.
   </para>

   <para>
    Quand il est essentiel de forcer l'ordre d'évaluation, une construction
    <literal>CASE</literal> (voir la <xref linkend="functions-conditional"/>)
    peut être utilisée. Voici un exemple qui ne garantie pas qu'une division
    par zéro ne soit faite dans une clause <literal>WHERE</literal>&nbsp;:
<programlisting>SELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;</programlisting>
    Mais ceci est sûr&nbsp;:
<programlisting>SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;</programlisting>
    Une construction <literal>CASE</literal> utilisée de cette façon déjouera
    les tentatives d'optimisation, donc cela ne sera à faire que si c'est
    nécessaire (dans cet exemple particulier, il serait sans doute mieux de
    contourner le problème en écrivant <literal>y &gt; 1.5*x</literal>).
   </para>

   <para>
    Néanmoins, <literal>CASE</literal> n'est pas un remède à tout. Une limitation
    à la technique illustrée ci-dessus est qu'elle n'empêche pas l'évaluation
    en avance des sous-expressions constantes. Comme décrit dans <xref
    linkend="xfunc-volatility"/>, les fonctions et les opérateurs marqués
    <literal>IMMUTABLE</literal> peuvent être évalués quand la requête est
    planifiée plutôt que quand elle est exécutée. Donc, par exemple&nbsp;:
 <programlisting>
 SELECT CASE WHEN x &gt; 0 THEN x ELSE 1/0 END FROM tab;
    </programlisting>
    va produire comme résultat un échec pour division par zéro car le
    planificateur a essayé de simplifier la sous-expression constante, même
    si chaque ligne de la table a <literal>x &gt; 0</literal> de façon à ce
    que la condition <literal>ELSE</literal> ne soit jamais exécutée.
   </para>

   <para>
    Bien que cet exemple particulier puisse sembler stupide, il existe de
    nombreux cas moins évident, n'impliquant pas de constantes, mais plutôt
    des requêtes exécutées par des fonctions, quand les valeurs des arguments
    des fonctions et de variables locales peuvent être insérées dans les requêtes
    en tant que constantes toujours dans le but de la planification. À l'intéreur
    de fonctions <application>PL/pgSQL</application>, par exemple, en utilisant
    une instruction <literal>IF</literal>-<literal>THEN</literal>-
    <literal>ELSE</literal> pour proteger un calcul risqué est beaucoup plus sûr
    que dans une expression <literal>CASE</literal>.
   </para>

   <para>
    Une autre limitation de cette technique est qu'une expression
    <literal>CASE</literal> ne peut pas empêcher l'évaluation d'une expression
    d'agrégat contenue dans cette expression car les expressions d'agrégat
    sont calculées avant les expressions <quote>scalaires</quote> dans une liste
    <literal>SELECT</literal> ou dans une clause <literal>HAVING</literal>. Par
    exemple, la requête suivante peut provoquer une erreur de division par zéro
    bien qu'elle semble protégée contre ce type d'erreurs&nbsp;:
    <programlisting>
SELECT CASE WHEN min(employees) > 0
            THEN avg(expenses / employees)
       END
    FROM departments;
    </programlisting>
    Les agrégats <function>min()</function> et <function>avg()</function> sont
    calculés en même temps avec toutes les lignes en entrée, donc si une ligne
    a une valeur 0 pour la colonne <structfield>employees</structfield>, l'erreur
    de division par zéro surviendra avant d'avoir pu tester le résultat de
    <function>min()</function>. Il est préférable d'utiliser une clause
    <literal>WHERE</literal> ou une clause <literal>FILTER</literal> pour
    empêcher les lignes problématiques en entrée d'atteindre la fonction
    d'agrégat.
   </para>
  </sect2>
 </sect1>

 <sect1 id="sql-syntax-calling-funcs">
  <title>Fonctions appelantes</title>

  <indexterm zone="sql-syntax-calling-funcs">
   <primary>notation</primary>
   <secondary>fonctions</secondary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> permet aux fonctions qui ont des
   paramètres nommés d'être appelées en utilisant soit la notation par
   <firstterm>position</firstterm> soit la notation par
   <firstterm>nom</firstterm>. La notation par nom est particulièrement utile
   pour les fonctions qui ont un grand nombre de paramètres car elle rend
   l'association entre paramètre et argument plus explicite et fiable. Dans
   la notation par position, un appel de fonction précise les valeurs en
   argument dans le même ordre que ce qui a été défini à la création de la
   fonction. Dans la notation nommée, les arguments sont précisés par leur
   nom et peuvent du coup être intégrés dans n'importe quel ordre.
  </para>

  <para>
   Quel que soit la notation, les paramètres qui ont des valeurs par défaut
   dans leur déclaration n'ont pas besoin d'être précisés dans l'appel. Ceci
   est particulièrement utile dans la notation nommée car toute combinaison
   de paramètre peut être omise alors que dans la notation par position, les
   paramètres peuvent seulement être omis de la droite vers la gauche.
  </para>

  <para>
   <productname>PostgreSQL</productname> supporte aussi la notation
   <firstterm>mixée</firstterm>. Elle combine la notation par position avec
   la notation par nom. Dans ce cas, les paramètres de position sont écrits
   en premier, les paramètres nommés apparaissent après.
  </para>

  <para>
   Les exemples suivants illustrent l'utilisation des trois notations, en
   utilisant la définition de fonction suivante&nbsp;:
   <programlisting>
CREATE FUNCTION assemble_min_ou_maj(a text, b text, majuscule boolean DEFAULT false)
RETURNS text
AS
$$
 SELECT CASE
        WHEN $3 THEN UPPER($1 || ' ' || $2)
        ELSE LOWER($1 || ' ' || $2)
        END;
$$
LANGUAGE SQL IMMUTABLE STRICT;
   </programlisting>
   La fonction <function>assemble_min_ou_maj</function> a deux paramètres
   obligatoires, <literal>a</literal> et <literal>b</literal>. Il existe en
   plus un paramètre optionnel, <literal>majuscule</literal>, qui vaut par
   défaut <literal>false</literal>. Les arguments <literal>a</literal> et
   <literal>b</literal> seront concaténés et forcés soit en majuscule soit en
   minuscule suivant la valeur du paramètre <literal>majuscule</literal>. Les
   détails restant ne sont pas importants ici (voir le <xref linkend="extend"/>
   pour plus d'informations).
  </para>

  <sect2 id="sql-syntax-calling-funcs-positional">
   <title>En utilisant la notation par position</title>

   <indexterm>
    <primary>fonction</primary>
    <secondary>notation par position</secondary>
   </indexterm>

   <para>
    La notation par position est le mécanisme traditionnel pour passer des
    arguments aux fonctions avec <productname>PostgreSQL</productname>. En
    voici un exemple&nbsp;:
    <screen>
SELECT assemble_min_ou_maj('Hello', 'World', true);
 assemble_min_ou_maj
---------------------
 HELLO WORLD
(1 row)
    </screen>
    Tous les arguments sont indiqués dans l'ordre. Le résultat est en
    majuscule car l'argument <literal>majuscule</literal> est indiqué à
    <literal>true</literal>. Voici un autre exemple&nbsp;:
    <screen>
SELECT assemble_min_ou_maj('Hello', 'World');
 assemble_min_ou_maj
-----------------------
 hello world
(1 row)
    </screen>
    Ici, le paramètre <literal>majuscule</literal> est omis, donc il récupère
    la valeur par défaut, soit <literal>false</literal>, ce qui a pour
    résultat une sortie en minuscule. Dans la notation par position, les
    arguments peuvent être omis de la droite à la gauche à partir du moment
    où ils ont des valeurs par défaut.
   </para>
  </sect2>

  <sect2 id="sql-syntax-calling-funcs-named">
   <title>En utilisant la notation par nom</title>

   <indexterm>
    <primary>fonction</primary>
    <secondary>notation par nom</secondary>
   </indexterm>

   <para>
    Dans la notation par nom, chaque nom d'argument est précisé en utilisant
    <literal>=&gt;</literal> pour le séparer de l'expression de la valeur de
    l'argument. Par exemple&nbsp;:
    <screen>
SELECT assemble_min_ou_maj(a =&gt; 'Hello', b =&gt; 'World');
 assemble_min_ou_maj
---------------------
 hello world
(1 row)
    </screen>
    Encore une fois, l'argument <literal>majuscule</literal> a été omis, donc
    il dispose de sa valeur par défaut, <literal>false</literal>,
    implicitement. Un avantage à utiliser la notation par nom est que les
    arguments peuvent être saisis dans n'importe quel ordre. Par
    exemple&nbsp;:
    <screen>
SELECT assemble_min_ou_maj(a =&gt; 'Hello', b =&gt; 'World', uppercase =&gt; true);
 assemble_min_ou_maj 
---------------------
 HELLO WORLD
(1 row)

SELECT assemble_min_ou_maj(a =&gt; 'Hello', uppercase =&gt; true, b =&gt; 'World');
 assemble_min_ou_maj 
---------------------
 HELLO WORLD
(1 row)
</screen>
    </para>

    <para>
      Une syntaxe plus ancienne basée sur « := » est supportée pour des
      raisons de compatibilité ascendante&nbsp;:
<screen>
SELECT assemble_min_ou_maj(a := 'Hello', uppercase := true, b := 'World');
 assemble_min_ou_maj 
---------------------
 HELLO WORLD
(1 row)
</screen>
   </para>
  </sect2>

  <sect2 id="sql-syntax-calling-funcs-mixed">
   <title>En utilisant la notation mixée</title>

   <indexterm>
    <primary>fonction</primary>
    <secondary>notation mixée</secondary>
   </indexterm>

   <para>
    La notation mixée combine les notations par position et par nom. Néanmoins,
    comme cela a déjà été expliqué, les arguments par nom ne peuvent pas
    précéder les arguments par position. Par exemple&nbsp;:
    <screen>
SELECT assemble_min_ou_maj('Hello', 'World', majuscule =&gt; true);
 assemble_min_ou_maj
-----------------------
 HELLO WORLD
(1 row)
    </screen>
    Dans la requête ci-dessus, les arguments <literal>a</literal> et
    <literal>b</literal> sont précisés par leur position alors que
    <literal>majuscule</literal> est indiqué par son nom. Dans cet exemple,
    cela n'apporte pas grand-chose, sauf pour une documentation de la fonction.
    Avec une fonction plus complexe, comprenant de nombreux paramètres avec des
    valeurs par défaut, les notations par nom et mixées améliorent l'écriture
    des appels de fonction et permettent de réduire les risques d'erreurs.
   </para>

   <note>
    <para>
     Les notations par appel nommé ou mixe ne peuvent pas être utilisé lors de
     l'appel d'une fonction d'agrégat (mais elles fonctionnent quand une
     fonction d'agrégat est utilisée en tant que fonction de fenêtrage).
    </para>
   </note>
  </sect2>
 </sect1>

</chapter>
