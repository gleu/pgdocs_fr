<?xml version="1.0" encoding="UTF-8"?>
<chapter id="plperl">
 <title>PL/Perl &mdash; Langage de procédures Perl</title>

 <indexterm zone="plperl">
  <primary>PL/Perl</primary>
 </indexterm>

 <indexterm zone="plperl">
  <primary>Perl</primary>
 </indexterm>

 <para>
  PL/Perl est un langage de procédures chargeable qui vous permet d'écrire des
  fonctions <productname>PostgreSQL</productname> dans le <ulink
  url="https://www.perl.org">langage de programmation Perl</ulink>.
 </para>

 <para>
  Le principal avantage habituellement cité quant à l'utilisation de Perl est que cela
  permet l'utilisation des nombreux opérateurs et fonctions de <quote>gestion
   de chaînes</quote> disponibles grâce à Perl dans des procédures stockées.
  L'analyse de chaînes complexes se trouve facilité par l'utilisation de Perl
  et des fonctions et structures de contrôles fournies dans PL/pgSQL.
 </para>

 <para>
  Pour installer PL/Perl dans une base de données spécifique, utilisez
  <literal>CREATE EXTENSION plperl</literal>.
 </para>

 <tip>
  <para>
   Si un langage est installé dans <literal>template1</literal>, toutes les
   bases de données créées ultérieurement disposeront automatiquement de ce
   langage.
  </para>
 </tip>

 <note>
  <para>
   Les utilisateurs des paquetages sources doivent explicitement autoriser la
   construction de PL/Perl pendant le processus d'installation (se référer à
   la <xref linkend="installation"/> pour plus d'informations). Les utilisateurs
   des paquetages binaires peuvent trouver PL/Perl dans un sous-paquetage
   séparé.
  </para>
 </note>

 <sect1 id="plperl-funcs">
  <title>Fonctions et arguments PL/Perl</title>

  <para>
   Pour créer une fonction dans le langage PL/Perl, utilisez la syntaxe
   standard <xref linkend="sql-createfunction"/>&nbsp;:
   <programlisting>CREATE FUNCTION <replaceable>nom_fonction</replaceable> (<replaceable>types-arguments</replaceable>) RETURNS
<replaceable>type-retour</replaceable>
-- attributs de fonction
AS $$
    # Corps de la fonction PL/Perl
$$ LANGUAGE plperl;
   </programlisting>
   Le corps de la fonction est du code Perl normal. En fait, le code
   supplémentaire PL/Perl l'emballe dans une sous-routine Perl. Une fonction
   PL/Perl est appelée dans un contexte scalaire, il ne peut donc pas retourner
   une liste. Vous pouvez retourner des valeurs non scalaire par référence comme
   indiqué ci-dessous.
  </para>

  <para>
   Dans une procédure PL/Perl, toute valeur de retour du code Perl est
   ignorée.
  </para>

  <para>
   PL/Perl peut aussi être utilisé au sein de blocs de procédures anonymes avec
   l'ordre <xref linkend="sql-do"/> :

   <programlisting>
DO $$
    # PL/Perl code
$$ LANGUAGE plperl;
   </programlisting>

   Un bloc de procédure anonyme ne prend pas d'arguments et toute valeur
   retournée est ignorée. Ceci mis à part, il se comporte comme une fonction
   classique.
  </para>

  <note>
   <para>
    L'utilisation de sous-routines nommées est dangereux en Perl, spécialement
    si elles font références à des variables lexicales dans la partie
    englobante. Comme une fonction PL/Perl est englobée dans une sous-routine,
    toute sous-routine nommée que vous y créez
    sera englobée. En général, il est bien plus sûr de créer des sous-routines anonymes
    que vous appellerez via un coderef. Pour de plus amples détails, voir
    les entrées <literal>Variable "%s" will not stay shared</literal> et
    <literal>Variable "%s" is not available</literal> dans le manuel
    <citerefentry><refentrytitle>perldiag</refentrytitle></citerefentry>, ou
    recherchez <quote>perl nested named subroutine</quote> sur internet.
   </para>
  </note>

  <para>
   La syntaxe de la commande <command>CREATE FUNCTION</command> requiert que le
   corps de la fonction soit écrit comme une constante de type chaîne. Il est
   habituellement plus agréable d'utiliser les guillemets dollar (voir la <xref
   linkend="sql-syntax-dollar-quoting"/>) pour cette constante. Si vous
   choisissez d'utiliser la syntaxe d'échappement des chaînes <literal>E''</literal>,
   vous devez doubler les marques de guillemets simples (<literal>'</literal>)
   et les antislashs (<literal>\</literal>) utilisés dans le corps de la
   fonction (voir la <xref linkend="sql-syntax-strings"/>).
  </para>

  <para>
   Les arguments et les résultats sont manipulés comme dans n'importe quel
   routine Perl&nbsp;: les arguments sont passés au tableau
   <varname>@_</varname> et une valeur de retour
   est indiquée par <literal>return</literal> ou par la dernière expression
   évaluée dans la fonction.
  </para>

  <para>
   Par exemple, une fonction retournant le plus grand de deux entiers
   peut être définie comme suit&nbsp;:

   <programlisting>CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    if ($_[0] &gt; $_[1]) { return $_[0]; }
    return $_[1];
$$ LANGUAGE plperl;
   </programlisting>
  </para>

  <note>
   <para>
    Les arguments seront convertis de l'encodage de la base de données en
    UTF-8 pour être utilisé par PL/perl, puis converti de l'UTF-8 vers
    l'encodage de la base.
   </para>
  </note>

  <para>
   Si une valeur NULL en SQL<indexterm><primary>valeur NULL</primary><secondary
    sortas="PL/Perl">en PL/Perl</secondary></indexterm> est passée à une fonction,
   cet argument apparaîtra comme <quote>undefined</quote> en Perl. La
   fonction définie ci-dessus ne se comportera pas correctement avec des
   arguments NULL (en fait, tout se passera comme s'ils avaient été des zéros).
   Nous aurions pu ajouter <literal>STRICT</literal> à la définition de la fonction
   pour forcer <productname>PostgreSQL</productname> à faire quelque chose de
   plus raisonnable&nbsp;: si une valeur NULL est passée en argument, la
   fonction ne sera pas du tout appelée mais retournera automatiquement un
   résultat NULL. D'une autre façon, nous aurions pu vérifier dans le corps de
   la fonction la présence d'arguments NULL. Par exemple, supposons que nous
   voulions que <function>perl_max</function> avec un argument NULL et un autre
   non NULL retourne une valeur non NULL plutôt qu'une valeur NULL, on aurait
   écrit&nbsp;:

   <programlisting>CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    my ($x, $y) = @_;
    if (not defined $x) {
        return undef if not defined $y;
        return $y;
    }
    return $x if not defined $y;
    return $x if $x &gt; $y;
    return $y;
$$ LANGUAGE plperl;
   </programlisting>
   Comme le montre l'exemple ci-dessus, passer une valeur NULL en SQL
   à une fonction en PL/Perl retourne une valeur non définie. Et ceci,
   que la fonction soit déclarée stricte ou non.
  </para>

  <para>
   Dans un argument de fonction, tout ce qui n'est pas une référence est une
   chaîne qui est dans la représentation texte externe standard de
   <productname>PostgreSQL</productname> pour ce type de données. Dans le cas
   de types numériques ou texte, Perl fera ce qu'il faut et le programmeur
   n'aura pas à s'en soucier. Néanmoins, dans d'autres cas, l'argument aura
   besoin d'être converti dans une forme qui est plus utilisable que Perl.
   Par exemple, la fonction <function>decode_bytea</function> peut-être utilisée
   pour convertir un argument de type
   <type>bytea</type> en données binaires non échappées.
  </para>

  <para>
   De façon similaire, les valeurs renvoyées à
   <productname>PostgreSQL</productname> doivent être dans le format textuel.
   Par exemple,
   la fonction <function>encode_bytea</function> peut être utilisée
   pour échapper des données binaires en retournant une valeur de type <type>bytea</type>.
  </para>

  <para>
   Un cas particulièrement important concerne les valeurs booléennes. Comme
   indiqué à l'instant, le comportement par défaut des valeurs de type
   <type>bool</type> est qu'elles sont passées en tant que text à
   l'interpréteur Perl, donc soit <literal>'t'</literal> soit
   <literal>'f'</literal>. Ceci est problématique parce que Perl ne traite pas
   <literal>'f'</literal> comme un false&nbsp;! Il est possible d'améliorer
   les choses en utilisant une <quote>transformation</quote> (voir <xref
   linkend="sql-createtransform"/>). Des transformations intéressantes sont
   fournies par l'extension <filename>bool_plperl</filename>. Pour l'utiliser,
   installez l'extension&nbsp;:
   <programlisting>
CREATE EXTENSION bool_plperl;  -- or bool_plperlu for PL/PerlU
   </programlisting>
   Puis utilisez l'attribut de fonction <literal>TRANSFORM</literal> pour une
   fonction PL/Perl qui prend ou renvoie une donnée de type <type>bool</type>,
   par exemple&nbsp;:
   <programlisting>
CREATE FUNCTION perl_and(bool, bool) RETURNS bool
TRANSFORM FOR TYPE bool
AS $$
  my ($a, $b) = @_;
  return $a &amp;&amp; $b;
$$ LANGUAGE plperl;
   </programlisting>
   Quand cette transformation est appliquée, les arguments <type>bool</type>
   seront vues par Perl comme valant <literal>1</literal> ou vide, soit des
   valeurs true ou false propres. Si le résultat de la fonction renvoie le
   type <type>bool</type>, il sera true ou false suivant comment Perl évaluera
   la valeur retournée. Des transformations similaires sont aussi réalisées
   pour les arguments de requêtes de type booléen et les résultats des
   requêtes SPI réalisées à l'intérieur de la fonction (<xref
   linkend="plperl-database"/>).
  </para>

  <para>
   Perl peut renvoyer des tableaux <productname>PostgreSQL</productname>
   comme référence à des tableaux Perl. Voici un exemple&nbsp;:

   <programlisting>CREATE OR REPLACE function renvoit_tableau()
RETURNS text[][] AS $$
    return [['a&quot;b','c,d'],['e\\f','g']];
$$ LANGUAGE plperl;

select renvoit_tableau();
   </programlisting>
  </para>

  <para>
   Perl utilise les tableaux <productname>PostgreSQL</productname> comme des
   objets <type>PostgreSQL::InServer::ARRAY</type>. Cet objet sera traité comme une référence
   de tableau ou comme une chaîne, permettant une compatibilité ascendante avec
   le code Perl écrit pour les versions de <productname>PostgreSQL</productname>
   antérieures à la 9.1. Par exemple&nbsp;:

   <programlisting>
CREATE OR REPLACE FUNCTION concat_array_elements(text[]) RETURNS TEXT AS $$
    my $arg = shift;
    my $result = "";
    return undef if (!defined $arg);

    # en tant que référence de tableau
    for (@$arg) {
        $result .= $_;
    }

    # en tant que chaîne
    $result .= $arg;

    return $result;
$$ LANGUAGE plperl;

SELECT concat_array_elements(ARRAY['PL','/','Perl']);
   </programlisting>

   <note>
    <para>
     Les tableaux multi-dimensionnels sont représentés comme des références à
     des tableaux de reférence et de moindre dimension, d'une façon connue de
     chaque développeur Perl.
    </para>
   </note>
  </para>

  <para>
   Les arguments de type composite sont passés à la fonction en tant que
   références d'un tableau de découpage, les clés du tableau de découpage étant
   les noms des attributs du type composé. Voici un exemple&nbsp;:

   <programlisting>CREATE TABLE employe (
    nom text,
    basesalaire integer,
    bonus integer
);

CREATE FUNCTION empcomp(employe) RETURNS integer AS $$
    my ($emp) = @_;
    return $emp-&gt;{basesalaire} + $emp-&gt;{bonus};
$$ LANGUAGE plperl;

SELECT nom, empcomp(employe.*) FROM employe;
   </programlisting>
  </para>

  <para>
   Une fonction PL/Perl peut renvoyer un résultat de type composite en utilisant
   la même approche&nbsp;: renvoyer une référence à un hachage qui a les
   attributs requis. Par exemple&nbsp;

   <programlisting>      CREATE TYPE testligneperl AS (f1 integer, f2 text, f3 text);

      CREATE OR REPLACE FUNCTION perl_ligne() RETURNS test_ligne_perl AS $$
      return {f2 =&gt; 'hello', f1 =&gt; 1, f3 =&gt; 'world'};
      $$ LANGUAGE plperl;

      SELECT * FROM perl_row();
   </programlisting>

   Toute colonne dans le type de données déclaré du résultat qui n'est pas
   présente dans le hachage sera renvoyée NULL.
  </para>

  <para>
   De façon similaire, les arguments en sortie des procédures peuvent être
   renvoyés sous la format d'une référence hash&nbsp;:

   <programlisting>
CREATE PROCEDURE perl_triple(INOUT a integer, INOUT b integer) AS $$
    my ($a, $b) = @_;
    return {a =&gt; $a * 3, b =&gt; $b * 3};
$$ LANGUAGE plperl;

CALL perl_triple(5, 10);
   </programlisting>
  </para>

  <para>
   Les fonctions PL/Perl peuvent aussi renvoyer des ensembles de types
   scalaires ou composites. Habituellement, vous voulez renvoyer une ligne à
   la fois, à la fois pour améliorer le temps de démarrage et pour éviter
   d'allonger la queue de l'ensemble des résultats en mémoire. Vous pouvez
   faire ceci avec <function>return_next</function> comme indiqué ci-dessous.
   Notez qu'après le dernier <function>return_next</function>, vous devez
   placer soit <literal>return</literal> soit (encore mieux) <literal>return
    undef</literal>.

   <programlisting>CREATE OR REPLACE FUNCTION perl_set_int(int)
RETURNS SETOF INTEGER AS $$
    foreach (0..$_[0]) {
        return_next($_);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set()
RETURNS SETOF test_ligne_perl AS $$
    return_next({ f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' });
    return_next({ f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' });
    return_next({ f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' });
    return undef;
$$ LANGUAGE plperl;
   </programlisting>

   Pour les petits ensembles de résultats, vous pouvez renvoyer une référence
   à un tableau contenant soit des scalaires, soit des références à des
   tableaux soit des références à des hachages de types simples, de types
   tableaux ou de types composites. Voici quelques exemples simples pour
   renvoyer l'ensemble complet du résultant en tant que référence de
   tableau&nbsp;:

   <programlisting>CREATE OR REPLACE FUNCTION perl_set_int(int) RETURNS SETOF INTEGER AS $$
      return [0..$_[0]];
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set() RETURNS SETOF testligneperl AS $$
return [
      { f1 =&gt; 1, f2 =&gt; 'Bonjour', f3 =&gt; 'Monde' },
      { f1 =&gt; 2, f2 =&gt; 'Bonjour', f3 =&gt; 'PostgreSQL' },
      { f1 =&gt; 3, f2 =&gt; 'Bonjour', f3 =&gt; 'PL/Perl' }
      ];
$$  LANGUAGE plperl;

SELECT * FROM perl_set();</programlisting>

  </para>

  <para>
   Si vous souhaitez utiliser le pragma <literal>strict</literal> dans votre code,
   vous avez plusieurs options. Pour une utilisation temporaire globale vous pouvez positionner (<command>SET</command>)
   <literal>plperl.use_strict</literal> à « true ». Ce paramètre affectera les
   compilations suivantes de fonctions <application>PL/Perl</application>, mais
   pas les fonctions déjà compilées dans la session en cours.
   Pour une utilisation globale permanente, vous pouvez positionner <literal>plperl.use_strict</literal>
   à « true » dans le fichier <filename>postgresql.conf</filename>.
  </para>

  <para>
   Pour une utilisation permanente dans des fonctions spécifiques, vous pouvez simplement placer:
<programlisting>use strict;
   </programlisting>
   en haut du corps de la fonction.
  </para>

  <para>
   Le pragma <literal>feature</literal> est aussi disponible avec <function>use</function> si votre version de Perl est 5.10.0 ou supérieur.
  </para>
 </sect1>

 <sect1 id="plperl-data">
  <title>Valeurs en PL/Perl</title>

  <para>
   Les valeurs des arguments fournis au code d'une fonction PL/Perl sont
   simplement les arguments d'entrée convertis en tant que texte (comme s'ils
   avaient été affichés par une commande <command>SELECT</command>).
   Inversement, les commandes <function>return</function> et <function>return_next</function>
   accepterons toute chaîne qui a un format d'entrée acceptable
   pour le type de retour déclaré de la fonction.
  </para>

  <para>
   Si ce comportement n'est pas convenable pour une utilisation particulière,
   il peut être amélioré en ajoutant une transformation comme cela a déjà été
   illustré pour les valeurs de type <type>bool</type>. Plusieurs exemples de
   modules de transformation sont inclus dans la distribution
   <productname>PostgreSQL</productname>.
  </para>
 </sect1>

 <sect1 id="plperl-builtins">
  <title>Fonction incluses</title>

  <sect2 id="plperl-database">
   <title>Accès à la base de données depuis PL/Perl</title>

   <para>
    L'accès à la base de données à l'intérieur de vos fonctions écrites en Perl
    peut se faire à partir des fonctions suivantes&nbsp;:
   </para>

   <variablelist>
    <varlistentry>
     <term>
      <literal><function>spi_exec_query</function>(<replaceable>query</replaceable> [, <replaceable>max-rows</replaceable>])</literal>
      <indexterm>
       <primary>spi_exec_query</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
       <literal>spi_exec_query</literal> exécute une commande SQL et renvoie
       l'ensemble complet de la ligne comme une référence à un table de
       références hachées. <emphasis>Vous ne devez utiliser cette commande
        que lorsque vous savez que l'ensemble de résultat sera relativement
        petit.</emphasis>  Voici un exemple d'une requête (commande
       <command>SELECT</command>) avec le nombre optionnel maximum de
       lignes&nbsp;:
       <programlisting>$rv = spi_exec_query('SELECT * FROM ma_table', 5);</programlisting>
       Ceci entrevoit cinq lignes au maximum de la table
       <literal>ma_table</literal>. Si <literal>ma_table</literal> a une
       colonne <literal>ma_colonne</literal>, vous obtenez la valeur de la
       ligne <literal>$i</literal> du résultat de cette façon&nbsp;:
       <programlisting>$foo = $rv-&gt;{rows}[$i]-&gt;{ma_colonne};</programlisting>
       Le nombre total des lignes renvoyées d'une requête
       <command>SELECT</command> peut être accédé de cette façon&nbsp;:
       <programlisting>$nrows = $rv-&gt;{processed}</programlisting>
     </para>

     <para>
       Voici un exemple en utilisant un type de commande différent&nbsp;:
       <programlisting>$query = "INSERT INTO ma_table VALUES (1, 'test')";
$rv = spi_exec_query($query);</programlisting>
       Ensuite, vous pouvez accéder au statut de la commande (c'est-à-dire,
       <literal>SPI_OK_INSERT</literal>) de cette façon&nbsp;:
       <programlisting>$res = $rv-&gt;{status};</programlisting>
       Pour obtenir le nombre de lignes affectées, exécutez&nbsp;:
       <programlisting>$nrows = $rv-&gt;{processed};</programlisting>
     </para>

     <para>
       Voici un exemple complet&nbsp;:
       <programlisting>CREATE TABLE test (
    i int,
    v varchar
    );

INSERT INTO test (i, v) VALUES (1, 'première ligne');
INSERT INTO test (i, v) VALUES (2, 'deuxième ligne');
INSERT INTO test (i, v) VALUES (3, 'troisième ligne');
INSERT INTO test (i, v) VALUES (4, 'immortel');

CREATE OR REPLACE FUNCTION test_munge() RETURNS SETOF test AS $$
    my $rv = spi_exec_query('select i, v from test;');
    my $status = $rv-&gt;{status};
    my $nrows = $rv-&gt;{processed};
    foreach my $rn (0 .. $nrows - 1) {
        my $row = $rv-&gt;{rows}[$rn];
        $row-&gt;{i} += 200 if defined($row-&gt;{i});
        $row-&gt;{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row-&gt;{v}));
        return_next($row);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM test_munge();
       </programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>spi_query(<replaceable>command</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_query</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>
     <term>
      <literal><function>spi_fetchrow(<replaceable>cursor</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_fetchrow</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>
     <term>
      <literal><function>spi_cursor_close(<replaceable>cursor</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_cursor_close</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>

     <listitem>
      <para>
       <literal>spi_query</literal> et <literal>spi_fetchrow</literal>
       fonctionnent ensemble comme une paire d'ensembles de lignes pouvant être
       assez importants ou pour les cas où vous souhaitez renvoyer les lignes dès
       qu'elles arrivent. <literal>spi_fetchrow</literal> fonctionne
       <emphasis>seulement</emphasis> avec <literal>spi_query</literal>. L'exemple
       suivant illustre comment vous les utilisez ensemble&nbsp;:

       <programlisting>CREATE TYPE foo_type AS (the_num INTEGER, the_text TEXT);

CREATE OR REPLACE FUNCTION lotsa_md5 (INTEGER) RETURNS SETOF foo_type AS $$
    use Digest::MD5 qw(md5_hex);
    my $file = '/usr/share/dict/words';
    my $t = localtime;
    elog(NOTICE, "opening file $file at $t" );
    open my $fh, '&lt;', $file # ooh, it's a file access!
        or elog(ERROR, "cannot open $file for reading: $!");
    my @words = &lt;$fh&gt;;
    close $fh;
    $t = localtime;
    elog(NOTICE, "closed file $file at $t");
    chomp(@words);
    my $row;
    my $sth = spi_query("SELECT * FROM generate_series(1,$_[0]) AS b(a)");
    while (defined ($row = spi_fetchrow($sth))) {
        return_next({
            the_num =&gt; $row-&gt;{a},
            the_text =&gt; md5_hex($words[rand @words])
        });
    }
    return;
$$ LANGUAGE plperlu;

SELECT * from lotsa_md5(500);
       </programlisting>
      </para>

      <para>
       Habituellement, <function>spi_fetchrow</function> devra être répété jusqu'à
       ce qu'il renvoie <literal>undef</literal>, indiquant qu'il n'y a plus de
       lignes à lire. Le curseur renvoyé par <literal>spi_query</literal> est
       automatiquement libéré quand
       <function>spi_fetchrow</function> renvoie <literal>undef</literal>. Si vous
       ne souhaitez pas lire toutes les lignes, appelez à la place
       <function>spi_cursor_close</function> pour libérer le curseur. Un échec ici
       résultera en des pertes mémoire.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>spi_prepare(<replaceable>command</replaceable>, <replaceable>argument types</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_prepare</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>
     <term>
      <literal><function>spi_query_prepared(<replaceable>plan</replaceable>, <replaceable>arguments</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_query_prepared</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>
     <term>
      <literal><function>spi_exec_prepared(<replaceable>plan</replaceable> [, <replaceable>attributes</replaceable>], <replaceable>arguments</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_exec_prepared</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>
     <term>
      <literal><function>spi_freeplan(<replaceable>plan</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_freeplan</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>

     <listitem>
      <para>
       <literal>spi_prepare</literal>, <literal>spi_query_prepared</literal>,
       <literal>spi_exec_prepared</literal> et <literal>spi_freeplan</literal>
       implémentent la même fonctionnalité, mais pour des requêtes préparées.
       <literal>spi_prepare</literal> accepte une chaîne pour la requête avec des
       arguments numérotés ($1, $2, etc) et une liste de chaînes indiquant le type
       des arguments&nbsp;:
       <programlisting>
$plan = spi_prepare('SELECT * FROM test WHERE id &gt; $1 AND name = $2', 'INTEGER', 'TEXT');
       </programlisting>
       Une fois qu'un plan est préparé suite à un appel à
       <literal>spi_prepare</literal>, le plan peut être utilisé à la place de la
       requête, soit dans <literal>spi_exec_prepared</literal>, où le résultat est
       identique à celui renvoyé par <literal>spi_exec_query</literal>, soit dans
       <literal>spi_query_prepared</literal> qui renvoi un curseur exactement comme
       le fait <literal>spi_query</literal>, qui peut ensuite être passé à
       <literal>spi_fetchrow</literal>. Le deuxième paramètre, optionnel, de
       <literal>spi_exec_prepared</literal> est une référence hachée des
       attributs&nbsp;; le seul attribut actuellement supporté est
       <literal>limit</literal>, qui configure le nombre maximum de lignes renvoyées
       par une requête.
      </para>

      <para>
       L'avantage des requêtes préparées est que cela rend possible l'utilisation
       d'un plan préparé par plusieurs exécutions de la requête. Une fois que le
       plan n'est plus utile, il peut être libéré avec
       <literal>spi_freeplan</literal>&nbsp;:
      </para>

      <para>
       <programlisting>
CREATE OR REPLACE FUNCTION init() RETURNS VOID AS $$
        $_SHARED{my_plan} = spi_prepare( 'SELECT (now() + $1)::date AS now', 'INTERVAL');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION add_time( INTERVAL ) RETURNS TEXT AS $$
        return spi_exec_prepared(
                $_SHARED{my_plan},
                $_[0]
        )->{rows}->[0]->{now};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION done() RETURNS VOID AS $$
        spi_freeplan( $_SHARED{my_plan});
        undef $_SHARED{my_plan};
$$ LANGUAGE plperl;

SELECT init();
SELECT add_time('1 day'), add_time('2 days'), add_time('3 days');
SELECT done();

  add_time  |  add_time  |  add_time
------------+------------+------------
 2005-12-10 | 2005-12-11 | 2005-12-12
       </programlisting>
      </para>

      <para>
       Notez que l'indice du paramètre dans <literal>spi_prepare</literal> est
       défini via $1, $2, $3, etc, donc évitez de déclarer des chaînes de requêtes
       qui pourraient aisément amener des bogues difficiles à trouver et corriger.
      </para>

      <para>
       Cet autre exemple illustre l'utilisation d'un paramètre optionnel avec
       <literal>spi_exec_prepared</literal>&nbsp;:
      </para>

      <para>
       <programlisting>
CREATE TABLE hosts AS SELECT id, ('192.168.1.'||id)::inet AS address FROM generate_series(1,3) AS id;

CREATE OR REPLACE FUNCTION init_hosts_query() RETURNS VOID AS $$
        $_SHARED{plan} = spi_prepare('SELECT * FROM hosts WHERE address &lt;&lt; $1', 'inet');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION query_hosts(inet) RETURNS SETOF hosts AS $$
        return spi_exec_prepared(
                $_SHARED{plan},
                {limit =&gt; 2},
                $_[0]
        )->{rows};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION release_hosts_query() RETURNS VOID AS $$
        spi_freeplan($_SHARED{plan});
        undef $_SHARED{plan};
$$ LANGUAGE plperl;

SELECT init_hosts_query();
SELECT query_hosts('192.168.1.0/30');
SELECT release_hosts_query();

    query_hosts
-----------------
 (1,192.168.1.1)
 (2,192.168.1.2)
(2 rows)
       </programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>spi_commit()</function></literal>
      <indexterm>
       <primary>spi_commit</primary>
       <secondary>dans PL/Perl</secondary>
      </indexterm>
     </term>
     <term>
      <literal><function>spi_rollback()</function></literal>
      <indexterm>
       <primary>spi_rollback</primary>
       <secondary>dans PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
       Valide ou annule la transaction en cours. Ceci peut seulement être
       appelé dans une procédure ou un code de bloc anonyme (commande
       <command>DO</command>) appelé au plus haut niveau. (Notez qu'il n'est
       pas possible d'exécuter les commandes SQL <command>COMMIT</command> ou
       <command>ROLLBACK</command> via <function>spi_exec_query</function> ou
       similaire. Cela doit se faire en utilisant ces fonctions.) À la fin
       d'une transaction, une nouvelle transaction est automatiquement
       démarrée, donc il n'y a pas de fonction séparée pour cela.
      </para>

      <para>
       En voici un exemple&nbsp;:
       <programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE plperl
AS $$
foreach my $i (0..9) {
    spi_exec_query("INSERT INTO test1 (a) VALUES ($i)");
    if ($i % 2 == 0) {
        spi_commit();
    } else {
        spi_rollback();
    }
}
$$;

CALL transaction_test1();
       </programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="plperl-utility-functions">
   <title>Fonctions utiles en PL/Perl</title>

   <variablelist>
    <varlistentry>
     <term>
      <literal><function>elog(<replaceable>level</replaceable>, <replaceable>msg</replaceable>)</function></literal>
      <indexterm>
       <primary>elog</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>

      <para>
       Produit un message de trace ou d'erreur. Les niveaux possibles sont
       <literal>DEBUG</literal>, <literal>LOG</literal>, <literal>INFO</literal>,
       <literal>NOTICE</literal>, <literal>WARNING</literal> et <literal>ERROR</literal>.
       <literal>ERROR</literal> lève une condition d'erreur&nbsp;; si elle n'est pas
       récupérée par le code Perl l'entourant, l'erreur se propage à
       l'extérieur de la requête appelante, causant l'annulation de la
       transaction ou sous-transaction en cours. Ceci est en fait identique à
       la commande <literal>die</literal> de Perl. Les autres niveaux génèrent
       seulement des messages de niveaux de priorité différents. Le fait que
       les messages d'un niveau de priorité particulier soient rapportés au
       client, écrit dans les journaux du serveur, voire les deux, est contrôlé
       par les variables de configuration <xref
       linkend="guc-log-min-messages"/> et <xref
       linkend="guc-client-min-messages"/>. Voir le <xref
       linkend="runtime-config"/> pour plus d'informations.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>quote_literal(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>quote_literal</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Retourne la chaîne donnée convenablement placé entre simple guillemets pour être utilisée comme une chaîne littérale au sein
       d'une chaîne représentant un ordre SQL. Les simples guillemets et antislashes de la chaîne sont correctement doublés
       Notez que <function>quote_literal</function> retourne undef avec une entrée undef ; si l'argument
       peut être undef, <function>quote_nullable</function> est souvent plus approprié.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>quote_nullable(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>quote_nullable</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
       Retourne la chaîne donnée convenablement placé entre simple guillemets pour être utilisée comme une chaîne littérale au sein
       d'une chaîne représentant un ordre SQL. Si l'argument d'entrée est undef, retourne la chaîne "NULL" sans simple guillemet.
       Les simples guillemets et antislashes de la chaîne sont correctement doublés
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>quote_ident(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>quote_ident</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
       Retourne la chaîne donnée convenablement placé entre guillemets pour être utilisée
       comme un identifiant au sein d'une chaîne représentant un ordre SQL.
       Les guillemets sont ajoutées seulement si cela est nécessaire (i.e. si
       la chaîne contient des caractères non-identifiant ou est en majuscule).
       Les guillemets  de la chaîne seront convenablement doublés.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>decode_bytea(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>decode_bytea</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
       Retourne les données binaires non échappé représentées par le contenu de
       la chaîne donnée, qui doit être encodé au format <type>bytea</type>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>encode_bytea(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_bytea</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
       Retourne sous la forme d'un <type>bytea</type> le contenu binaire dans la chaîne passé en argument.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>encode_array_literal(<replaceable>array</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_array_literal</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>
     <term>
      <literal><function>encode_array_literal(<replaceable>array</replaceable>, <replaceable>delimiter</replaceable>)</function></literal>
     </term>

     <listitem>
      <para>
       Retourne le contenu de tableau passé par référence sous forme d'une chaîne littérale.
       (voir <xref linkend="arrays-input"/>).
       Retourne la valeur de l'argument non altérée si ce n'est pas une référence à un tableau.
       Le délimiteur utilisé entre les éléments du tableau sous forme littérale sera par défaut "<literal>, </literal>"
       si aucun délimiteur n'est spécifié ou s'il est undef.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>encode_typed_literal(<replaceable>value</replaceable>, <replaceable>typename</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_typed_literal</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
       Convertit une variable Perl en une valeur du type de données passé
       en second argument et renvoie une représentation de type chaîne pour
       cette valeur. Gère correctement les tableaux imbriqués et les valeurs
       de types composites.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>encode_array_constructor(<replaceable>array</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_array_constructor</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
       Retourne le contenu de tableau passé par référence sous forme d'une chaîne
       permettant de construire un tableau en SQL.
       (voir <xref linkend="sql-syntax-array-constructors"/>).
       Chaque élément est entouré de simple guillemets par <function>quote_nullable</function>.
       Retourne la valeur de l'argument, entouré de simple guillemets par <function>quote_nullable</function>,
       si ce n'est pas une référence à un tableau.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>looks_like_number(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>looks_like_number</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
       Retourne une valeur vraie si le contenu de la chaîne passée ressemble à
       un nombre, selon l'interprétation de Perl, et faux dans le cas contraire.
       Retourne undef si undef est passé en argument. Tout espace en début et fin de chaîne sont
       ignorés. <literal>Inf</literal> et <literal>Infinity</literal> sont vu comme des nombres.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>is_array_ref(<replaceable>argument</replaceable>)</function></literal>
      <indexterm>
       <primary>is_array_ref</primary>
       <secondary>en PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
       Renvoie une valeur true si l'argument donné peut être traité comme une
       référence de tableau, c'est-à-dire si la référence de l'argument est
       <literal>ARRAY</literal> ou <literal>PostgreSQL::InServer::ARRAY</literal>.
       Renvoie false sinon.
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </sect2>
 </sect1>

 <sect1 id="plperl-global">
  <title>Valeurs globales dans PL/Perl</title>

  <para>
   Vous pouvez utiliser le hachage global <varname>%_SHARED</varname> pour
   stocker les données, incluant les références de code, entre les appels de
   fonction pour la durée de vie de la session en cours.
  </para>

  <para>
   Voici un exemple simple pour des données partagées&nbsp;:
   <programlisting>CREATE OR REPLACE FUNCTION set_var(name text, val text) RETURNS text AS $$
if ($_SHARED{$_[0]} = $_[1]) {
      return 'ok';
} else {
      return "Ne peux pas initialiser la variable partagée $_[0] à $_[1]";
}
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION get_var(name text) RETURNS text AS $$
      return $_SHARED{$_[0]};
$$ LANGUAGE plperl;

SELECT set_var('sample', 'Bonjour, PL/Perl ! Comment va ?');
SELECT get_var('sample');</programlisting>
  </para>

  <para>
    Voici un exemple légèrement plus compliqué utilisant une référence de
    code&nbsp;:

    <programlisting>CREATE OR REPLACE FUNCTION ma_fonction() RETURNS void AS $$
$_SHARED{myquote} = sub {
      my $arg = shift;
      $arg =~ s/(['\\])/\\$1/g;
      return "'$arg'";
      };
$$ LANGUAGE plperl;

SELECT ma_fonction(); /* initialise la fonction */

/* Initialise une fonction qui utilise la fonction quote */

CREATE OR REPLACE FUNCTION utilise_quote(TEXT) RETURNS text AS $$
      my $text_to_quote = shift;
      my $qfunc = $_SHARED{myquote};
      return &amp;$qfunc($text_to_quote);
$$ LANGUAGE plperl;</programlisting>

    (Vous pouviez avoir remplacé le code ci-dessus avec la seule ligne
    <literal>return $_SHARED{myquote}-&gt;($_[0]);</literal>
    au prix d'une mauvaise lisibilité.)
  </para>

  <para>
   Pour des raisons de sécurité, PL/Perl exécute des fonctions appelées par
   un rôle SQL dans un interpréteur Perl séparé pour ce rôle. Ceci empêche
   l'interférence accidentelle ou malicieuse d'un utilisateur avec le
   comportement des fonctions PL/Perl d'un autre utilisateur. Chaque
   interpréteur a sa propre valeur de la variable
   <varname>%_SHARED</varname> et des autres états globaux. Du coup, deux
   fonctions PL/Perl partageront la même valeur de <varname>%_SHARED</varname>
   si et seulement si elles sont exécutées par le même rôle SQL. Dans une
   application où une session seule exécute du code sous plusieurs rôles SQL
   (via des fonctions <literal>SECURITY DEFINER</literal>, l'utilisation de
   <command>SET ROLE</command>, etc), vous pouvez avoir besoin de mettre en place des
   étapes explicites pour vous assurer que les fonctions PL/Perl peuvent
   partager des données <varname>%_SHARED</varname>. Pour cela, assurez-vous
   que les fonctions qui doivent communiquer ont pour propriétaire le même
   utilisateur et marquez les comme <literal>SECURITY DEFINER</literal>. Bien sûr,
   vous devez faire attention à ce que ces fonctions ne puissent pas être
   utilisées pour faire des choses qu'elles ne sont pas sensées faire.
  </para>
</sect1>

 <sect1 id="plperl-trusted">
  <title>Niveaux de confiance de PL/Perl</title>

  <indexterm zone="plperl-trusted">
   <primary>trusted</primary>
   <secondary>PL/Perl</secondary>
  </indexterm>

  <para>
   Normalement, PL/Perl est installé en tant que langage de programmation de
   <quote>confiance</quote>, de nom <literal>plperl</literal>. Durant cette installation,
   certaines commandes Perl sont désactivées pour préserver la sécurité. En
   général, les commandes qui interagissent avec l'environnement sont
   restreintes. Cela inclut les commandes sur les descripteurs de fichiers,
   <literal>require</literal> et <literal>use</literal> (pour les modules
   externes). Il n'est pas possible d'accéder aux fonctions et variables
   internes du processus du serveur de base de données ou d'obtenir un accès au
   niveau du système d'exploitation avec les droits du processus serveur, tel
   qu'une fonction C peut le faire. Ainsi, n'importe quel utilisateur sans
   droits sur la base de données est autorisé à utiliser ce langage.
  </para>

  <para>
   Voici l'exemple d'une fonction qui ne fonctionnera pas car les commandes système
   ne sont pas autorisées pour des raisons de sécurité&nbsp;:
<programlisting>CREATE FUNCTION badfunc() RETURNS integer AS $$
    my $tmpfile = "/tmp/badfile";
    open my $fh, '&gt;', $tmpfile
        or elog(ERROR, qq{could not open the file "$tmpfile": $!});
    print $fh "Testing writing to a file\n";
    close $fh or elog(ERROR, qq{could not close the file "$tmpfile": $!});
    return 1;
$$ LANGUAGE plperl;
   </programlisting>
   La création de cette fonction échouera car le validateur détectera
   l'utilisation par cette fonction d'une opération interdite.
  </para>

  <para>
   Il est parfois souhaitable d'écrire des fonctions Perl qui ne sont pas
   restreintes. Par exemple, on peut souhaiter vouloir envoyer des courriers
   électroniques. Pour supporter ce cas de figure, PL/Perl peut aussi être
   installé comme un langage <quote>douteux</quote> (habituellement nommé
   <application>PL/PerlU</application>
   <indexterm><primary>PL/PerlU</primary></indexterm>).
   Dans ce cas, la totalité du langage Perl est accessible. Lors de
   l'installation du langage, le nom
   du langage <literal>plperlu</literal> sélectionnera la version douteuse de
   PL/Perl.
  </para>

  <para>
   Les auteurs des fonctions <application>PL/PerlU</application> doivent faire attention au
   fait que celles-ci ne puissent être utilisées pour faire quelque chose de non
   désiré car cela donnera la possibilité d'agir comme si l'on possédait les
   privilèges d'administrateur de la base de données. Il est à noter que le
   système de base de données ne permet qu'aux super-utilisateurs de créer des
   fonctions dans un langage douteux.
  </para>

  <para>
   Si la fonction ci-dessus a été créée par un super-utilisateur en utilisant
   le langage <literal>plperlu</literal>, l'exécution de celle-ci réussira.
  </para>

  <para>
   De la même façon, les blocs de procédure anonymes écris en perl peuvent utiliser
   les opérations restreintes si le langage est spécifié comme
   <literal>plperlu</literal> plutôt que <literal>plperl</literal>, mais l'appelant
   doit être un super-utilisateur.
  </para>

  <note>
   <para>
    Bien que les fonctions <application>PL/Perl</application> s'exécutent dans un
    interpréteur Perl séparé pour chaque rôle SQL, toutes les fonctions
    <application>PL/PerlU</application> exécutées dans la même session utilisent
    un seul interpréteur Perl (qui n'est pas un de ceux utilisés par les fonctions
    <application>PL/Perl</application>). Ceci permet aux fonctions
    <application>PL/PerlU</application> de partager librement des données, mais
    aucune communication ne peut survenir entre des fonctions
    <application>PL/Perl</application> et <application>PL/PerlU</application>.
   </para>
  </note>

  <note>
   <para>
    Perl ne peut pas supporter plusieurs interpréteurs à l'intérieur d'un seul
    processus sauf s'il a été construit avec les bonnes options, soit
    <literal>usemultiplicity</literal> soit <literal>useithreads</literal>.
    (<literal>usemultiplicity</literal> est préféré sauf si vous avez besoin
    d'utiliser des threads. Pour plus de détails, voir la page de manuel de
    <citerefentry><refentrytitle>perlembed</refentrytitle></citerefentry>.) Si
    <application>PL/Perl</application> est utilisé avec une copie de Perl qui
    n'a pas été construite de cette façon, alors seul un interpréteur Perl par
    session sera disponible, et donc une session ne pourra exécuter soit que
    des fonctions <application>PL/PerlU</application>, soit que des fonctions
    <application>PL/Perl</application> qui sont appelées par le même rôle SQL.
   </para>
  </note>

 </sect1>

 <sect1 id="plperl-triggers">
  <title>Déclencheurs PL/Perl</title>

  <para>
   PL/Perl peut être utilisé pour écrire des fonctions pour déclencheurs.
   Dans une fonction déclencheur, la référence hachée
   <varname>$_TD</varname> contient des informations sur l'événement du
   déclencheur en cours. <varname>$_TD</varname> est une variable globale
   qui obtient une valeur locale séparée à chaque appel du déclencheur.
   Les champs de la référence de hachage
   <varname>$_TD</varname> sont&nbsp;:

   <variablelist>
    <varlistentry>
     <term><literal>$_TD-&gt;{new}{foo}</literal></term>
     <listitem>
      <para>
       Valeur <literal>NEW</literal> de la colonne <literal>foo</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{old}{foo}</literal></term>
     <listitem>
      <para>
       Valeur <literal>OLD</literal> de la colonne <literal>foo</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{name}</literal></term>
     <listitem>
      <para>
       Nom du déclencheur appelé
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{event}</literal></term>
     <listitem>
      <para>
       Événement du déclencheur&nbsp;: <literal>INSERT</literal>,
       <literal>UPDATE</literal>, <literal>DELETE</literal>,
       <literal>TRUNCATE</literal>, <literal>INSTEAD OF</literal> ou
       <literal>UNKNOWN</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{when}</literal></term>
     <listitem>
      <para>
       Quand le déclencheur a été appelé&nbsp;:
       <literal>BEFORE</literal> (avant), <literal>AFTER</literal>
       (après) ou <literal>UNKNOWN</literal> (inconnu)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{level}</literal></term>
     <listitem>
      <para>
       Le niveau du déclencheur&nbsp;: <literal>ROW</literal> (ligne),
       <literal>STATEMENT</literal> (instruction) ou
       <literal>UNKNOWN</literal> (inconnu)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{relid}</literal></term>
     <listitem>
      <para>
       L'OID de la table sur lequel le déclencheur a été exécuté
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{table_name}</literal></term>
     <listitem>
      <para>
       Nom de la table sur lequel le déclencheur a été exécuté
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{relname}</literal></term>
     <listitem>
      <para>
       Nom de la table sur lequel le déclencheur a été exécuté. Elle est obsolète
       et pourrait être supprimée dans une prochaine version. Utilisez
       $_TD-&gt;{table_name} à la place.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{table_schema}</literal></term>
     <listitem>
      <para>
       Nom du schéma sur lequel le déclencheur a été exécuté.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{argc}</literal></term>
     <listitem>
      <para>
       Nombre d'arguments de la fonction déclencheur
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>@{$_TD-&gt;{args}}</literal></term>
     <listitem>
      <para>
       Arguments de la fonction déclencheur. N'existe pas si
       <literal>$_TD-&gt;{argc}</literal> vaut 0.
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>

  <para>
   Les déclencheurs niveau ligne peuvent renvoyer un des éléments suivants&nbsp;:

   <variablelist>
    <varlistentry>
     <term><literal>return;</literal></term>
     <listitem>
      <para>
       Exécute l'opération
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>"SKIP"</literal></term>
     <listitem>
      <para>
       N'exécute pas l'opération
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>"MODIFY"</literal></term>
     <listitem>
      <para>
       Indique que la ligne <literal>NEW</literal> a été modifiée par la
       fonction déclencheur
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Voici un exemple d'une fonction déclencheur illustrant certains points
   ci-dessus&nbsp;:
   <programlisting>CREATE TABLE test (
    i int,
    v varchar
);

CREATE OR REPLACE FUNCTION valid_id() RETURNS trigger AS $$
    if (($_TD-&gt;{new}{i} &gt;= 100) || ($_TD-&gt;{new}{i} &lt;= 0)) {
        return "SKIP";    # passe la commande INSERT/UPDATE
    } elsif ($_TD-&gt;{new}{v} ne "immortal") {
        $_TD-&gt;{new}{v} .= "(modified by trigger)";
        return "MODIFY";  # modifie la ligne et exécute la commande INSERT/UPDATE
    } else {
        return;           # exécute la commande INSERT/UPDATE
    }
$$ LANGUAGE plperl;

CREATE TRIGGER test_valid_id_trig
    BEFORE INSERT OR UPDATE ON test
    FOR EACH ROW EXECUTE FUNCTION valid_id();</programlisting>
   </para>
 </sect1>

 <sect1 id="plperl-event-triggers">
  <title>Triggers sur événements avec PL/Perl</title>

  <para>
   PL/Perl peut être utilisé pour écrire des fonctions trigger sur événement.
   Dans ce type de fonctions, la référence hachée <varname>$_TD</varname>
   contient des informations sur l'événement du trigger.
   <varname>$_TD</varname> est une variable globale, qui obtient une valeur
   locale séparée à chaque invocation du trigger. Les champs disponibles
   via <varname>$_TD</varname> sont&nbsp;:

   <variablelist>
    <varlistentry>
     <term><literal>$_TD-&gt;{event}</literal></term>
     <listitem>
      <para>
       Le nom de l'événement pour lequel le trigger a été déclenché.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{tag}</literal></term>
     <listitem>
      <para>
       La balise de la commande pour laquelle le trigger a été déclenché.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Le code de retour de la fonction trigger est ignoré.
  </para>

  <para>
   Voici un exemple de fonction trigger sur événement, illustrant certaines
   des informations ci-dessus&nbsp;:
<programlisting>
CREATE OR REPLACE FUNCTION perlsnitch() RETURNS event_trigger AS $$
  elog(NOTICE, "perlsnitch: " . $_TD->{event} . " " . $_TD->{tag} . " ");
$$ LANGUAGE plperl;

CREATE EVENT TRIGGER perl_a_snitch
    ON ddl_command_start
    EXECUTE FUNCTION perlsnitch();
   </programlisting>
  </para>
 </sect1>

 <sect1 id="plperl-under-the-hood">
  <title>PL/Perl sous le capot</title>

  <sect2 id="plperl-config">
   <title>Configuration</title>

   <para>
    Cette section liste les paramètres de configuration de <application>PL/Perl</application>.
   </para>

   <variablelist>

    <varlistentry id="guc-plperl-on-init" xreflabel="plperl.on_init">
     <term>
      <varname>plperl.on_init</varname> (<type>string</type>)
      <indexterm>
       <primary>paramètre de configuration <varname>plperl.on_init</varname></primary>
      </indexterm>
     </term>
     <listitem>
      <para><!--TODO-->
       Spécifie un code perl à exécuter lorsque l'interpréteur Perl est initialisé
       pour la première fois et avant qu'il soit spécialisé pour être utilisé par
       <literal>plperl</literal> ou <literal>plperlu</literal>.
       Les fonction SPI ne sont pas disponible lorsque ce code est exécuté.
       Si le code lève une erreur, il interrompra l'initialisation de
       l'interpréteur et la propagera à la requête originale, provoquant ainsi
       l'annulation de la transaction ou sous-transaction courante.
      </para>
      <para>
       Le code Perl est limité à une seule ligne. Un code plus long peut
       être placé dans un module et chargé par <literal>on_init</literal>.
       Exemples:
       <programlisting>
plperl.on_init = 'require "plperlinit.pl"'
plperl.on_init = 'use lib "/my/app"; use MyApp::PgInit;'
       </programlisting>
      </para>
      <para>
       Tous les modules chargés par <literal>plperl.on_init</literal>, directement
       ou indirectement, seront disponibles depuis <literal>plperl</literal>.
       Cela entraîne un problème de sécurité potentiel. Pour consulter
       la liste des modules chargés, vous pouvez utiliser :
       <programlisting>
DO 'elog(WARNING, join ", ", sort keys %INC)' LANGUAGE plperl;
       </programlisting>
      </para>
      <para>
       L'initialisation aura lieu au sein du postmaster si la librairie <literal>plperl</literal>
       est incluse dans le paramètre <xref linkend="guc-shared-preload-libraries"/>),
       auquel cas une plus grande attention doit être portée au risque de
       déstabiliser ce dernier. La raison principale d'utilisation de cette
       fonctionnalité est que les modules Perl chargés par
       <literal>plperl.on_init</literal> doivent être chargés seulement au
       démarrage de postmaster, et seront instantanément disponible sans
       surcoût dans chaque session individuelle. Néanmoins, gardez en tête
       que la surcharge est seulement évitée pour le premier interpréteur Perl
       utilisé par une session de base de données &mdash; soit PL/PerlU, soit
       PL/Perl pour le premier rôle SQL qui appelle une fonction PL/Perl. Tout
       interpréteur Perl supplémentaire créé dans une session de base aura à
       exécuter <literal>plperl.on_init</literal>. De plus, sur Windows, il n'y
       aura aucun gain avec le préchargement car l'interpréteur Perl créé par le
       processus postmaster ne se propage pas aux processus fils.
      </para>
      <para>
       Ce paramètre ne peut être positionné que dans le fichier <filename>postgresql.conf</filename> ou
       depuis la ligne de commande de démarrage du serveur.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="guc-plperl-on-plperl-init" xreflabel="plperl.on_plperl_init">
     <term>
      <varname>plperl.on_plperl_init</varname> (<type>string</type>)
      <indexterm>
       <primary>paramètre de configuration <varname>plperl.on_plperl_init</varname></primary>
      </indexterm>
     </term>
     <term>
      <varname>plperl.on_plperlu_init</varname> (<type>string</type>)
      <indexterm>
       <primary>paramètre de configuration <varname>plperl.on_plperlu_init</varname></primary>
      </indexterm>
     </term>
     <listitem>
      <para>
       Ces paramètres spécifient le code Perl à exécuter quand un interpréteur
       Perl est spécialisé respectivement pour <literal>plperl</literal> ou
       <literal>plperlu</literal>. Ceci n'arrivera que quand une fonction
       PL/Perl ou PL/PerlU est exécutée la première fois dans une session de
       base de données, ou quand un interpréteur supplémentaire doit être créé
       parce que l'autre langage a été appelé ou parce qu'une fonction PL/Perl
       a été appelée par un nouveau rôle SQL. Ceci suit toute initialisation
       réalisée par <literal>plperl.on_init</literal>. Les fonctions SPI ne
       sont pas disponibles quand ce code est exécuté. Le code Perl dans
       <literal>plperl.on_plperl_init</literal> est exécuté après le
       <quote>verrouillage</quote> de l'interpréteur, et donc il peut seulement
       réaliser des opérations de confiance.
      </para>
      <para>
       Si le code lève une erreur, il interrompra l'initialisation et la
       propagera à la requête originale, provoquant ainsi l'annulation de la
       transaction ou sous-transaction courante. Toute action déjà réalisée
       dans Perl ne sera pas défaite&nbsp;; néanmoins, cet interpréteur ne sera
       plus utilisé de nouveau. Si le langage est utilisé de nouveau,
       l'initialisation sera tentée de nouveau avec un nouvel interpréteur Perl.
      </para>
      <para>
       Seuls les superutilisateurs peuvent modifier ces paramètres. Bien que
       ces paramètres peuvent être modifiés dans une session, de tels
       changements n'affecteront pas les interpréteurs Perl qui ont déjà été
       utilisés pour exécuter des fonctions.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="guc-plperl-use-strict" xreflabel="plperl.use_strict">
     <term>
      <varname>plperl.use_strict</varname> (<type>boolean</type>)
      <indexterm>
       <primary>paramètre de configuration <varname>plperl.use_strict</varname></primary>
      </indexterm>
     </term>
     <listitem>
      <para>
       Lorsqu'il est positionné à « true », les compilations des fonction
       PL/Perl suivantes auront le pragma <literal>strict</literal> activé.
       Ce paramètre n'affecte pas les fonctions déjà compilées au sein de
       la session courante.
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </sect2>

  <sect2 id="plperl-missing">
   <title>Limitations et fonctionnalités absentes</title>

   <para>
    Les fonctionnalités suivantes ne sont actuellement pas implémentées dans
    PL/Perl, mais peuvent faire l'objet de contributions généreuses de votre part.

    <itemizedlist>
     <listitem>
      <para>
       Les fonctions PL/Perl ne peuvent pas s'appeler entre elles.
      </para>
     </listitem>

     <listitem>
      <para>
       SPI n'est pas complètement implémenté.
      </para>
     </listitem>

     <listitem>
      <para>
       Si vous récupérez des ensembles de données très importants en utilisant
       <literal>spi_exec_query</literal>, vous devez être conscient qu'ils
       iront tous en mémoire. Vous pouvez l'éviter en utilisant
       <literal>spi_query</literal>/<literal>spi_fetchrow</literal> comme
       montré précédemment.
      </para>
      <para>
       Un problème similaire survient si une fonction renvoyant un ensemble
       passe un gros ensemble de lignes à PostgreSQL via
       <literal>return</literal>. Vous pouvez l'éviter aussi en utilisant à la
       place <literal>return_next</literal> pour chaque ligne renvoyée, comme
       indiqué précédemment.
      </para>
     </listitem>

     <listitem>
      <para>
       Lorsqu'une session se termine normalement, et pas à cause d'une erreur fatale,
       tous les blocs <literal>END</literal> qui ont été définis sont exécutés.
       Actuellement, aucune autre action ne sont réalisées.
       Spécifiquement, les descripteurs de fichiers ne sont pas vidés automatiquement
       et les objets ne sont pas détruits automatiquement.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>
 </sect1>

</chapter>

