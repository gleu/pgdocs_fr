<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

 <chapter id="plperl">
  <title>PL/Perl - Langage de procédures Perl</title>

  <indexterm zone="plperl">
   <primary>PL/Perl</primary>
  </indexterm>

  <indexterm zone="plperl">
   <primary>Perl</primary>
  </indexterm>

  <para>
   PL/Perl est un langage de procédures chargeable qui vous permet d'écrire des
   fonctions <productname>PostgreSQL</productname> dans le <ulink
   url="http://www.perl.org">langage de programmation Perl</ulink>.
  </para>

  <para>
   Le principal avantage habituellement cité quant à l'utilisation de Perl est que cela
   permet l'utilisation des nombreux opérateurs et fonctions de <quote>gestion
   de chaînes</quote> disponibles grâce à Perl dans des procédures stockées.
   L'analyse de chaînes complexes se trouve facilité par l'utilisation de Perl
   et des fonctions et structures de contrôles fournies dans PL/pgSQL.
  </para>
  
  <para>
   Pour installer PL/Perl dans une base de données spécifique, utilisez la
   commande <literal>createlang plperl <replaceable>nom_base</replaceable></literal>.
  </para>

  <tip>
   <para>
    Si un langage est installé dans <literal>template1</literal>, toutes les
    bases de données créées ultérieurement disposeront automatiquement de ce
    langage.
   </para>
  </tip>

  <note>
   <para>
    Les utilisateurs des paquetages sources doivent explicitement autoriser la
    construction de PL/Perl pendant le processus d'installation (se référer à
    la <xref linkend="install-short"/> pour plus d'informations). Les utilisateurs
    des paquetages binaires peuvent trouver PL/Perl dans un sous-paquetage
    séparé.
   </para>
  </note>

 <sect1 id="plperl-funcs">
  <title>Fonctions et arguments PL/Perl</title>

  <para>
   Pour créer une fonction dans le langage PL/Perl, utilisez la syntaxe
   standard <xref linkend="sql-createfunction"/>&nbsp;:
<programlisting>CREATE FUNCTION <replaceable>nom_fonction</replaceable> (<replaceable>types-arguments</replaceable>) RETURNS
<replaceable>type-retour</replaceable> AS $$
    # Corps de la fonction PL/Perl
$$ LANGUAGE plperl;
</programlisting>
   Le corps de la fonction est du code Perl normal. En fait, le code
   supplémentaire PL/Perl l'emballe dans une sous-routine Perl. Une fonction
   PL/Perl is
   called in a scalar context, so it can't return a list.  You can return
   non-scalar values (arrays, records, and sets) by returning a reference,
   as discussed below.
  </para>

  <para>
   PL/Perl also supports anonymous code blocks called with the
   <xref linkend="sql-do"/> statement:

<programlisting>
DO $$
    # PL/Perl code
$$ LANGUAGE plperl;
</programlisting>

   An anonymous code block receives no arguments, and whatever value it
   might return is discarded.  Otherwise it behaves just like a function.
  </para>

  <note>
   <para>
    L'utilisation de sous-routines nommées est dangereux en Perl, spécialement
    si elles font références à des variables lexicales dans la partie
    englobante. Comme une fonction PL/Perl est englobée dans une sous-routine,
    any named subroutine you place inside
    one will be nested. In general, it is far safer to create anonymous
    subroutines which you call via a coderef. For more information, see the
    entries for <literal>Variable "%s" will not stay shared</literal> and
    <literal>Variable "%s" is not available</literal> in the
    <citerefentry><refentrytitle>perldiag</refentrytitle></citerefentry> man page, or
    search the Internet for <quote>perl nested named subroutine</quote>.
   </para>
  </note>

  <para>
    La syntaxe de la commande <command>CREATE FUNCTION</command> requiert que le
    corps de la fonction soit écrit comme une constante de type chaîne. Il est
    habituellement plus agréable d'utiliser les guillemets dollar (voir la <xref
    linkend="sql-syntax-dollar-quoting"/>) pour cette constante. Si vous
    choisissez d'utiliser la syntaxe d'échappement des chaînes <literal>E''</literal>,
    vous devez doubler les marques de guillemets simples (<literal>'</literal>)
    et les antislashs (<literal>\</literal>) utilisés dans le corps de la
    fonction (voir la <xref linkend="sql-syntax-strings"/>).
  </para>

  <para>
   Les arguments et les résultats sont manipulés comme dans n'importe quel
   routine Perl&nbsp;: les arguments sont passés au tableau
   <varname>@_</varname> et une valeur de retour
   est indiquée par <literal>return</literal> ou par la dernière expression
   évaluée dans la fonction.
  </para>

  <para>
   Par exemple, une fonction retournant le plus grand de deux entiers
   peut être définie comme suit&nbsp;:

<programlisting>CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    if ($_[0] &gt; $_[1]) { return $_[0]; }
    return $_[1];
$$ LANGUAGE plperl;
</programlisting>
  </para>

  <para>
   Si une valeur NULL en SQL<indexterm><primary>valeur NULL</primary><secondary
   sortas="PL/Perl">en PL/Perl</secondary></indexterm> est passée à une fonction,
   cet argument apparaîtra comme <quote>undefined</quote> en Perl. La
   fonction définie ci-dessus ne se comportera pas correctement avec des
   arguments NULL (en fait, tout se passera comme s'ils avaient été des zéros).
   Nous aurions pu ajouter <literal>STRICT</literal> à la définition de la fonction
   pour forcer <productname>PostgreSQL</productname> à faire quelque chose de
   plus raisonnable&nbsp;: si une valeur NULL est passée en argument, la
   fonction ne sera pas du tout appelée mais retournera automatiquement un
   résultat NULL. D'une autre façon, nous aurions pu vérifier dans le corps de
   la fonction la présence d'arguments NULL. Par exemple, supposons que nous
   voulions que <function>perl_max</function> avec un argument NULL et un autre
   non NULL retourne une valeur non NULL plutôt qu'une valeur NULL, on aurait
   écrit&nbsp;:

<programlisting>CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    my ($x, $y) = @_;
    if (not defined $x) {
        return undef if not defined $y;
        return $y;
    }
    return $x if not defined $y;
    return $x if $x &gt; $y;
    return $y;
$$ LANGUAGE plperl;
</programlisting>
   Comme le montre l'exemple ci-dessus, passer une valeur NULL en SQL
   à une fonction en PL/Perl retourne une valeur non définie. Et ceci,
   que la fonction soit déclarée stricte ou non.
  </para>

  <para>
   Dans un argument de fonction, tout ce qui n'est pas une référence est une
   chaîne qui est dans la représentation texte externe standard de
   <productname>PostgreSQL</productname> pour ce type de données. Dans le cas
   de types numériques ou texte, Perl fera ce qu'il faut et le programmeur
   n'aura pas à s'en soucier. Néanmoins, dans d'autres cas, l'argument aura
   besoin d'être converti dans une forme qui est plus utilisable que Perl.
   For example, the <function>decode_bytea</function>
   function can be used to convert an argument of
   type <type>bytea</type> into unescaped binary.
  </para>

  <para>
   De façon similaire, les valeurs renvoyées à
   <productname>PostgreSQL</productname> doivent être dans le format textuel.
   For example, the
   <function>encode_bytea</function> function can be used to
   to escape binary data for a return value of type <type>bytea</type>.
  </para>

  <para>
   Perl peut renvoyer des tableaux <productname>PostgreSQL</productname>
   comme référence à des tableaux Perl. Voici un exemple&nbsp;:

<programlisting>CREATE OR REPLACE function renvoit_tableau()
RETURNS text[][] AS $$
    return [['a&quot;b','c,d'],['e\\f','g']];
$$ LANGUAGE plperl;

select renvoit_tableau();
</programlisting>
  </para>

  <para>
   Les arguments de type composite sont passés à la fonction en tant que
   références d'un tableau de découpage, les clés du tableau de découpage étant
   les noms des attributs du type composé. Voici un exemple&nbsp;:

<programlisting>CREATE TABLE employe (
    nom text,
    basesalaire integer,
    bonus integer
);

CREATE FUNCTION empcomp(employe) RETURNS integer AS $$
    my ($emp) = @_;
    return $emp-&gt;{basesalaire} + $emp-&gt;{bonus};
$$ LANGUAGE plperl;

SELECT nom, empcomp(employe.*) FROM employe;
</programlisting>
  </para>

  <para>
   Une fonction PL/Perl peut renvoyer un résultat de type composite en utilisant
   la même approche&nbsp;: renvoyer une référence à un hachage qui a les 
   attributs requis. Par exemple&nbsp;

    <programlisting>      CREATE TYPE testligneperl AS (f1 integer, f2 text, f3 text);

      CREATE OR REPLACE FUNCTION perl_ligne() RETURNS test_ligne_perl AS $$
      return {f2 =&gt; 'hello', f1 =&gt; 1, f3 =&gt; 'world'};
      $$ LANGUAGE plperl;

      SELECT * FROM perl_row();
    </programlisting>

    Toute colonne dans le type de données déclaré du résultat qui n'est pas
    présente dans le hachage sera renvoyée NULL.
  </para>

  <para>
    Les fonctions PL/Perl peuvent aussi renvoyer des ensembles de types
    scalaires ou composites. Habituellement, vous voulez renvoyer une ligne à
    la fois, à la fois pour améliorer le temps de démarrage et pour éviter
    d'allonger la queue de l'ensemble des résultats en mémoire. Vous pouvez
    faire ceci avec <function>return_next</function> comme indiqué ci-dessous.
    Notez qu'après le dernier <function>return_next</function>, vous devez
    placer soit <literal>return</literal> soit (encore mieux) <literal>return
    undef</literal>.

<programlisting>CREATE OR REPLACE FUNCTION perl_set_int(int)
RETURNS SETOF INTEGER AS $$
    foreach (0..$_[0]) {
        return_next($_);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set()
RETURNS SETOF test_ligne_perl AS $$
    return_next({ f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' });
    return_next({ f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' });
    return_next({ f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' });
    return undef;
$$ LANGUAGE plperl;
</programlisting>

    Pour les petits ensembles de résultats, vous pouvez renvoyer une référence
    à un tableau contenant soit des scalaires, soit des références à des
    tableaux soit des références à des hachages de types simples, de types
    tableaux ou de types composites. Voici quelques exemples simples pour
    renvoyer l'ensemble complet du résultant en tant que référence de
    tableau&nbsp;:

    <programlisting>CREATE OR REPLACE FUNCTION perl_set_int(int) RETURNS SETOF INTEGER AS $$
      return [0..$_[0]];
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set() RETURNS SETOF testligneperl AS $$
return [
      { f1 =&gt; 1, f2 =&gt; 'Bonjour', f3 =&gt; 'Monde' },
      { f1 =&gt; 2, f2 =&gt; 'Bonjour', f3 =&gt; 'PostgreSQL' },
      { f1 =&gt; 3, f2 =&gt; 'Bonjour', f3 =&gt; 'PL/Perl' }
      ];
$$  LANGUAGE plperl;

SELECT * FROM perl_set();</programlisting>

  </para>

  <para>
   Si vous souhaitez utiliser le pragma <literal>strict</literal> dans votre code,
    you 
   have a few options. For temporary global use you can (<command>SET</command>)
   <literal>plperl.use_strict</literal> à true. Ce paramètre affectera les
   compilations suivantes de fonctions <application>PL/Perl</application>, mais
   pas les fonctions déjà compilées dans la session en cours.
   For permanent global use you can set <literal>plperl.use_strict</literal>
   to true in the <filename>postgresql.conf</filename> file.
  </para>

  <para>
   For permanent use in specific functions you can simply put:
<programlisting>use strict;
</programlisting>
   en haut du corps de la fonction.
  </para>
  
  <para>
  The <literal>feature</literal> pragma is also available to <function>use</function> if your Perl is version 5.10.0 or higher.
  </para>
 </sect1>

 <sect1 id="plperl-data">
  <title>Data Values in PL/Perl</title>

  <para>
   The argument values supplied to a PL/Perl function's code are
   simply the input arguments converted to text form (just as if they
   had been displayed by a <command>SELECT</command> statement).
   Conversely, the <function>return</function> and <function>return_next</function>
   commands will accept any string that is acceptable input format
   for the function's declared return type.
  </para>
 </sect1>

 <sect1 id="plperl-builtins">
  <title>Built-in Functions</title>

 <sect2 id="plperl-database">
  <title>Accès à la base de données depuis PL/Perl</title>

  <para>
   L'accès à la base de données à l'intérieur de vos fonctions écrites en Perl
   peut se faire à partir des fonctions suivantes&nbsp;:
  </para>

   <variablelist>
    <varlistentry>
     <indexterm>
      <primary>spi_exec_query</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_query</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_fetchrow</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_prepare</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_exec_prepared</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_query_prepared</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_cursor_close</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_freeplan</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>spi_exec_query</function>(<replaceable>query</replaceable> [, <replaceable>max-rows</replaceable>])</literal></term>
     <listitem>
      <para>
       <literal>spi_exec_query</literal> exécute une commande SQL et renvoie
       l'ensemble complet de la ligne comme une référence à un table de
       références hachées. <emphasis>Vous ne devez utiliser cette commande
       que lorsque vous savez que l'ensemble de résultat sera relativement
       petit.</emphasis>  Voici un exemple d'une requête (commande
       <command>SELECT</command>) avec le nombre optionnel maximum de
       lignes&nbsp;:
       <programlisting>$rv = spi_exec_query('SELECT * FROM ma_table', 5);</programlisting>
       Ceci entrevoit cinq lignes au maximum de la table
       <literal>ma_table</literal>. Si <literal>ma_table</literal> a une 
       colonne <literal>ma_colonne</literal>, vous obtenez la valeur de la
       ligne <literal>$i</literal> du résultat de cette façon&nbsp;:
       <programlisting>$foo = $rv-&gt;{rows}[$i]-&gt;{ma_colonne};</programlisting>
       Le nombre total des lignes renvoyées d'une requête 
       <command>SELECT</command> peut être accédé de cette façon&nbsp;:
       <programlisting>$nrows = $rv-&gt;{processed}</programlisting>
     </para>
     
     <para>
       Voici un exemple en utilisant un type de commande différent&nbsp;:
       <programlisting>$query = "INSERT INTO ma_table VALUES (1, 'test')";
$rv = spi_exec_query($query);</programlisting>
       Ensuite, vous pouvez accéder au statut de la commande (c'est-à-dire,
       <literal>SPI_OK_INSERT</literal>) de cette façon&nbsp;:
       <programlisting>$res = $rv-&gt;{status};</programlisting>
       Pour obtenir le nombre de lignes affectées, exécutez&nbsp;:
       <programlisting>$nrows = $rv-&gt;{processed};</programlisting>
     </para>

     <para>
       Voici un exemple complet&nbsp;:
       <programlisting>CREATE TABLE test (
    i int,
    v varchar
    );

INSERT INTO test (i, v) VALUES (1, 'première ligne');
INSERT INTO test (i, v) VALUES (2, 'deuxième ligne');
INSERT INTO test (i, v) VALUES (3, 'troisième ligne');
INSERT INTO test (i, v) VALUES (4, 'immortel');

CREATE OR REPLACE FUNCTION test_munge() RETURNS SETOF test AS $$
    my $rv = spi_exec_query('select i, v from test;');
    my $status = $rv-&gt;{status};
    my $nrows = $rv-&gt;{processed};
    foreach my $rn (0 .. $nrows - 1) {
        my $row = $rv-&gt;{rows}[$rn];
        $row-&gt;{i} += 200 if defined($row-&gt;{i});
        $row-&gt;{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row-&gt;{v}));
        return_next($row);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM test_munge();
       </programlisting>
     </para>
    </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal><function>spi_query</function>(<replaceable>command</replaceable>)</literal></term>
     <term><literal><function>spi_fetchrow</function>(<replaceable>cursor</replaceable>)</literal></term>
     <term><literal><function>spi_cursor_close</function>(<replaceable>cursor</replaceable>)</literal></term>

    <listitem>
    <para>
    <literal>spi_query</literal> et <literal>spi_fetchrow</literal>
    fonctionnent ensemble comme une paire d'ensembles de lignes pouvant être
    assez importants ou pour les cas où vous souhaitez renvoyer les lignes dès
    qu'elles arrivent. <literal>spi_fetchrow</literal> fonctionne
    <emphasis>seulement</emphasis> avec <literal>spi_query</literal>. L'exemple
    suivant illustre comment vous les utilisez ensemble&nbsp;:

<programlisting>CREATE TYPE foo_type AS (the_num INTEGER, the_text TEXT);

CREATE OR REPLACE FUNCTION lotsa_md5 (INTEGER) RETURNS SETOF foo_type AS $$
    use Digest::MD5 qw(md5_hex);
    my $file = '/usr/share/dict/words';
    my $t = localtime;
    elog(NOTICE, "opening file $file at $t" );
    open my $fh, '&lt;', $file # ooh, it's a file access!
        or elog(ERROR, "cannot open $file for reading: $!");
    my @words = &lt;$fh&gt;;
    close $fh;
    $t = localtime;
    elog(NOTICE, "closed file $file at $t");
    chomp(@words);
    my $row;
    my $sth = spi_query("SELECT * FROM generate_series(1,$_[0]) AS b(a)");
    while (defined ($row = spi_fetchrow($sth))) {
        return_next({
            the_num =&gt; $row-&gt;{a},
            the_text =&gt; md5_hex($words[rand @words])
        });
    }
    return;
$$ LANGUAGE plperlu;

SELECT * from lotsa_md5(500);
</programlisting>
    </para>

    <para>
     Habituellement, <function>spi_fetchrow</function> devra être répété jusqu'à
     ce qu'il renvoie <literal>undef</literal>, indiquant qu'il n'y a plus de
     lignes à lire. Le curseur renvoyé par <literal>spi_query</literal> est
     automatiquement libéré quand
     <function>spi_fetchrow</function> renvoie <literal>undef</literal>. Si vous
     ne souhaitez pas lire toutes les lignes, appelez à la place
     <function>spi_cursor_close</function> pour libérer le curseur. Un échec ici
     résultera en des pertes mémoire.
    </para>
   </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal><function>spi_prepare</function>(<replaceable>command</replaceable>, <replaceable>argument types</replaceable>)</literal></term>
     <term><literal><function>spi_query_prepared</function>(<replaceable>plan</replaceable>, <replaceable>arguments</replaceable>)</literal></term>
     <term><literal><function>spi_exec_prepared</function>(<replaceable>plan</replaceable> [, <replaceable>attributes</replaceable>], <replaceable>arguments</replaceable>)</literal></term>
     <term><literal><function>spi_freeplan</function>(<replaceable>plan</replaceable>)</literal></term>

    <listitem>
    <para>
    <literal>spi_prepare</literal>, <literal>spi_query_prepared</literal>,
    <literal>spi_exec_prepared</literal> et <literal>spi_freeplan</literal>
    implémentent la même fonctionnalité, mais pour des requêtes préparées.
    <literal>spi_prepare</literal> accepte une chaîne pour la requête avec des
    arguments numérotés ($1, $2, etc) et une liste de chaînes indiquant le type
    des arguments&nbsp;:
<programlisting>
$plan = spi_prepare('SELECT * FROM test WHERE id &gt; $1 AND name = $2', 'INTEGER', 'TEXT');
</programlisting>
    Une fois qu'un plan est préparé suite à un appel à
    <literal>spi_prepare</literal>, le plan peut être utilisé à la place de la
    requête, soit dans <literal>spi_exec_prepared</literal>, où le résultat est
    identique à celui renvoyé par <literal>spi_exec_query</literal>, soit dans
    <literal>spi_query_prepared</literal> qui renvoit un curseur exactement comme
    le fait <literal>spi_query</literal>, qui peut ensuite être passé à
    <literal>spi_fetchrow</literal>. Le deuxième paramètre, optionnel, de
    <literal>spi_exec_prepared</literal> est une référence hachée des
    attributs&nbsp;; le seul attribut actuellement supporté est
    <literal>limit</literal>, qui configure le nombre maximum de lignes renvoyées
    par une requête. 
    </para>

    <para>
    L'avantage des requêtes préparées est que cela rend possible l'utilisation
    d'un plan préparé par plusieurs exécutions de la requête. Une fois que le
    plan n'est plus utile, il peut être libéré avec
    <literal>spi_freeplan</literal>&nbsp;:
    </para>

    <para>
    <programlisting>
CREATE OR REPLACE FUNCTION init() RETURNS VOID AS $$
        $_SHARED{my_plan} = spi_prepare( 'SELECT (now() + $1)::date AS now', 'INTERVAL');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION add_time( INTERVAL ) RETURNS TEXT AS $$
        return spi_exec_prepared(
                $_SHARED{my_plan},
                $_[0]
        )->{rows}->[0]->{now};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION done() RETURNS VOID AS $$
        spi_freeplan( $_SHARED{my_plan});
        undef $_SHARED{my_plan};
$$ LANGUAGE plperl;

SELECT init();
SELECT add_time('1 day'), add_time('2 days'), add_time('3 days');
SELECT done();

  add_time  |  add_time  |  add_time
------------+------------+------------
 2005-12-10 | 2005-12-11 | 2005-12-12
    </programlisting>
    </para>

    <para>
    Notez que l'indice du paramètre dans <literal>spi_prepare</literal> est
    défini via $1, $2, $3, etc, donc évitez de déclarer des chaînes de requêtes
    qui pourraient aisément amener des bogues difficiles à trouver et corriger.
    </para>

    <para>
    Cet autre exemple illustre l'utilisation d'un paramètre optionnel avec
    <literal>spi_exec_prepared</literal>&nbsp;:
    </para>

    <para>
    <programlisting>
CREATE TABLE hosts AS SELECT id, ('192.168.1.'||id)::inet AS address FROM generate_series(1,3) AS id;

CREATE OR REPLACE FUNCTION init_hosts_query() RETURNS VOID AS $$
        $_SHARED{plan} = spi_prepare('SELECT * FROM hosts WHERE address &lt;&lt; $1', 'inet');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION query_hosts(inet) RETURNS SETOF hosts AS $$
        return spi_exec_prepared(
                $_SHARED{plan},
                {limit =&gt; 2},
                $_[0]
        )->{rows};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION release_hosts_query() RETURNS VOID AS $$
        spi_freeplan($_SHARED{plan});
        undef $_SHARED{plan};
$$ LANGUAGE plperl;

SELECT init_hosts_query();
SELECT query_hosts('192.168.1.0/30');
SELECT release_hosts_query();

    query_hosts    
-----------------
 (1,192.168.1.1)
 (2,192.168.1.2)
(2 rows)
    </programlisting>
    </para>
    </listitem>
    </varlistentry>
   </variablelist>
 </sect2>

 <sect2 id="plperl-utility-functions">
  <title>Utility functions in PL/Perl</title>

   <variablelist>
    <varlistentry>
     <term><literal><function>elog</function>(<replaceable>level</replaceable>,
     <replaceable>msg</replaceable>)</literal></term>
     <listitem>
     <indexterm>
      <primary>elog</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

      <para>
       Produit un message de trace ou d'erreur. Les niveaux possibles sont
       <literal>DEBUG</literal>, <literal>LOG</literal>, <literal>INFO</literal>,
       <literal>NOTICE</literal>, <literal>WARNING</literal> et <literal>ERROR</literal>.
       <literal>ERROR</literal> lève une condition d'erreur&nbsp;; si elle n'est pas
       récupérée par le code Perl l'entourant, l'erreur se propage à
       l'extérieur de la requête appelante, causant l'annulation de la 
       transaction ou sous-transaction en cours. Ceci est en fait identique à
       la commande <literal>die</literal> de Perl. Les autres niveaux génèrent 
       seulement des messages de niveaux de priorité différents. Le fait que
       les messages d'un niveau de priorité particulier soient rapportés au
       client, écrit dans les journaux du serveur, voire les deux, est contrôlé
       par les variables de configuration <xref
       linkend="guc-log-min-messages"/> et <xref
       linkend="guc-client-min-messages"/>. Voir le <xref
       linkend="runtime-config"/> pour plus d'informations.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>quote_literal</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>quote_literal</function>(<replaceable>string</replaceable>)</literal></term>
     <listitem>
      <para>
        Return the given string suitably quoted to be used as a string literal in an SQL
        statement string. Embedded single-quotes and backslashes are properly doubled.
        Note that <function>quote_literal</function> returns undef on undef input; if the argument
        might be undef, <function>quote_nullable</function> is often more suitable.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>quote_nullable</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>quote_nullable</function>(<replaceable>string</replaceable>)</literal></term>
     <listitem>
      <para>
        Return the given string suitably quoted to be used as a string literal in an SQL
        statement string; or, if the argument is undef, return the unquoted string "NULL".
        Embedded single-quotes and backslashes are properly doubled.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>quote_ident</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>quote_ident</function>(<replaceable>string</replaceable>)</literal></term>
     <listitem>
      <para>
        Return the given string suitably quoted to be used as an identifier in
        an SQL statement string. Quotes are added only if necessary (i.e., if
        the string contains non-identifier characters or would be case-folded).
        Embedded quotes are properly doubled.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>decode_bytea</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>decode_bytea</function>(<replaceable>string</replaceable>)</literal></term>
     <listitem>
      <para>
        Return the unescaped binary data represented by the contents of the given string,
        which should be bytea encoded.
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>encode_bytea</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>encode_bytea</function>(<replaceable>string</replaceable>)</literal></term>
     <listitem>
      <para>
        Return the bytea encoded form of the binary data contents of the given string.
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>encode_array_literal</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>encode_array_literal</function>(<replaceable>array</replaceable>)</literal></term>
     <term><literal><function>encode_array_literal</function>(<replaceable>array</replaceable>, <replaceable>delimiter</replaceable>)</literal></term>
     <listitem>
      <para>
        Returns the contents of the referenced array as a string in array literal format
        (see <xref linkend="arrays-input"/>).
        Returns the argument value unaltered if it's not a reference to an array.
        The delimiter used between elements of the array literal defaults to "<literal>, </literal>"
        if a delimiter is not specified or is undef.
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>encode_array_constructor</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>encode_array_constructor</function>(<replaceable>array</replaceable>)</literal></term>
     <listitem>
      <para>
        Returns the contents of the referenced array as a string in array constructor format
        (see <xref linkend="sql-syntax-array-constructors"/>).
        Individual values are quoted using <function>quote_nullable</function>.
        Returns the argument value, quoted using <function>quote_nullable</function>,
        if it's not a reference to an array.
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>looks_like_number</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>looks_like_number</function>(<replaceable>string</replaceable>)</literal></term>
     <listitem>
      <para>
        Returns a true value if the content of the given string looks like a
        number, according to Perl, returns false otherwise.
        Returns undef if the argument is undef.  Leading and trailing space is
        ignored. <literal>Inf</literal> and <literal>Infinity</literal> are regarded as numbers.
        </para>
     </listitem>
    </varlistentry>

   </variablelist>
 </sect2>
 </sect1>

<sect1 id="plperl-global">
  <title>Valeurs globales dans PL/Perl</title>
  
  <para>
    Vous pouvez utiliser le hachage global <varname>%_SHARED</varname> pour
    stocker les données, incluant les références de code, entre les appels de
    fonction pour la durée de vie de la session en cours.
  </para>
  
  <para>
    Voici un exemple simple pour des données partagées&nbsp;:
    <programlisting>CREATE OR REPLACE FUNCTION set_var(name text, val text) RETURNS text AS $$
if ($_SHARED{$_[0]} = $_[1]) {
      return 'ok';
} else {
      return "Ne peux pas initialiser la variable partagée $_[0] à $_[1]";
}
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION get_var(name text) RETURNS text AS $$
      return $_SHARED{$_[0]};
$$ LANGUAGE plperl;

SELECT set_var('sample', 'Bonjour, PL/Perl ! Comment va ?');
SELECT get_var('sample');</programlisting>
  </para>
  
  <para>
    Voici un exemple légèrement plus compliqué utilisant une référence de
    code&nbsp;:
    
    <programlisting>CREATE OR REPLACE FUNCTION ma_fonction() RETURNS void AS $$
$_SHARED{myquote} = sub {
      my $arg = shift;
      $arg =~ s/(['\\])/\\$1/g;
      return "'$arg'";
      };
$$ LANGUAGE plperl;

SELECT ma_fonction(); /* initialise la fonction */

/* Initialise une fonction qui utilise la fonction quote */

CREATE OR REPLACE FUNCTION utilise_quote(TEXT) RETURNS text AS $$
      my $text_to_quote = shift;
      my $qfunc = $_SHARED{myquote};
      return &amp;$qfunc($text_to_quote);
$$ LANGUAGE plperl;</programlisting>

    (Vous pouviez avoir remplacé le code ci-dessus avec la seule ligne
    <literal>return $_SHARED{myquote}-&gt;($_[0]);</literal>
    au prix d'une mauvaise lisibilité.)
  </para>

  <para>
    The <varname>%_SHARED</varname> variable and other global state within
    the language is public data, available to all PL/Perl functions within a
    session. Use with care, especially in situations that involve use of 
    multiple roles or <literal>SECURITY DEFINER</literal> functions.
  </para>
</sect1>

 <sect1 id="plperl-trusted">
  <title>Niveaux de confiance de PL/Perl</title>

  <indexterm zone="plperl-trusted">
   <primary>trusted</primary>
   <secondary>PL/Perl</secondary>
  </indexterm>

  <para>
   Normalement, PL/Perl est installé en tant que langage de programmation de
   <quote>confiance</quote>, de nom <literal>plperl</literal>. Durant cette installation,
   certaines commandes Perl sont désactivées pour préserver la sécurité. En
   général, les commandes qui interagissent avec l'environnement sont
   restreintes. Cela inclut les commandes sur les descripteurs de fichiers,
   <literal>require</literal> et <literal>use</literal> (pour les modules
   externes). Il n'est pas possible d'accéder aux fonctions et variables
   internes du processus du serveur de base de données ou d'obtenir un accès au
   niveau du système d'exploitation avec les droits du processus serveur, tel
   qu'une fonction C peut le faire. Ainsi, n'importe quel utilisateur sans
   droits sur la base de données est autorisé à utiliser ce langage.
  </para>

  <para>
   Voici l'exemple d'une fonction qui ne fonctionnera pas car les commandes système
   ne sont pas autorisées pour des raisons de sécurité&nbsp;:
<programlisting>CREATE FUNCTION badfunc() RETURNS integer AS $$
    my $tmpfile = "/tmp/badfile";
    open my $fh, '&gt;', $tmpfile
        or elog(ERROR, qq{could not open the file "$tmpfile": $!});
    print $fh "Testing writing to a file\n";
    close $fh or elog(ERROR, qq{could not close the file "$tmpfile": $!});
    return 1;
$$ LANGUAGE plperl;
</programlisting>
   La création de cette fonction échouera car le validateur détectera
   l'utilisation par cette fonction d'une opération interdite.
  </para>

  <para>
   Il est parfois souhaitable d'écrire des fonctions Perl qui ne sont pas
   restreintes. Par exemple, on peut souhaiter vouloir envoyer des courriers
   électroniques. Pour supporter ce cas de figure, PL/Perl peut aussi être
   installé comme un langage <quote>douteux</quote> (habituellement nommé
   <application>PL/PerlU</application>
   <indexterm><primary>PL/PerlU</primary></indexterm>).
   Dans ce cas, la totalité du langage Perl est accessible. Si la commande
   <command>createlang</command> est utilisée pour installer le langage, le nom
   du langage <literal>plperlu</literal> sélectionnera la version douteuse de
   PL/Perl.
  </para>

  <para>
   Les auteurs des fonctions <application>PL/PerlU</application> doivent faire attention au
   fait que celles-ci ne puissent être utilisées pour faire quelque chose de non
   désiré car cela donnera la possibilité d'agir comme si l'on possédait les
   privilèges d'administrateur de la base de données. Il est à noter que le
   système de base de données ne permet qu'aux super-utilisateurs de créer des
   fonctions dans un langage douteux.
  </para>

  <para>
   Si la fonction ci-dessus a été créée par un super-utilisateur en utilisant
   le langage <literal>plperlu</literal>, l'exécution de celle-ci réussira.
  </para>

  <para>
   In the same way, anonymous code blocks written in Perl can use
   restricted operations if the language is specified as
   <literal>plperlu</literal> rather than <literal>plperl</literal>, but the caller
   must be a superuser.
  </para>

  <note>
    <para>
      Pour des raisons de sécurité, pour stopper une faille des opérations
      privilégiées à partir de <application>PL/PerlU</application> vers
      <application>PL/Perl</application>, ces deux langages doivent être exécutés
      dans des instances séparées de l'interpréteur Perl. Si votre installation
      Perl a été compilé de façon approprié, ce n'est pas un problème. Néanmoins,
      toutes les installations ne sont pas compilées avec les options requises.
      Si <productname>PostgreSQL</productname> détecte que c'est le cas, alors
      il n'exécutera pas le deuxième interpréteur mais lèvera une erreur à la
      place. En conséquence, dans une telle installation, vous ne pouvez pas
      utiliser à la fois <application>PL/PerlU</application> et
      <application>PL/Perl</application> dans le même processus serveur. Le
      remède à ceci est d'obtenir une installation Perl configurée avec les options
      appropriées, nommément <literal>usemultiplicity</literal> ou
      <literal>useithreads</literal>. <literal>usemultiplicity</literal> is preferred
      unless you actually need to use threads. For more details, see the
      <citerefentry><refentrytitle>perlembed</refentrytitle></citerefentry> man page.
    </para>
  </note>

 </sect1>

 <sect1 id="plperl-triggers">
   <title>Déclencheurs PL/Perl</title>
   
   <para>
     PL/Perl peut être utilisé pour écrire des fonctions pour déclencheurs.
     Dans une fonction déclencheur, la référence hachée 
     <varname>$_TD</varname> contient des informations sur l'événement du
     déclencheur en cours. <varname>$_TD</varname> est une variable globale
     qui obtient une valeur locale séparée à chaque appel du déclencheur.
     Les champs de la référence de hachage
     <varname>$_TD</varname> sont&nbsp;:
     
     <variablelist>
       <varlistentry>
         <term><literal>$_TD-&gt;{new}{foo}</literal></term>
         <listitem>
           <para>
             Valeur <literal>NEW</literal> de la colonne <literal>foo</literal>
           </para>
         </listitem>
       </varlistentry>
       
       <varlistentry>
         <term><literal>$_TD-&gt;{old}{foo}</literal></term>
         <listitem>
           <para>
             Valeur <literal>OLD</literal> de la colonne <literal>foo</literal>
           </para>
         </listitem>
       </varlistentry>
       
       <varlistentry>
         <term><literal>$_TD-&gt;{name}</literal></term>
         <listitem>
           <para>
             Nom du déclencheur appelé
           </para>
         </listitem>
       </varlistentry>
       
       <varlistentry>
         <term><literal>$_TD-&gt;{event}</literal></term>
         <listitem>
           <para>
             Événement du déclencheur&nbsp;: <literal>INSERT</literal>,
             <literal>UPDATE</literal>, <literal>DELETE</literal>,
             <literal>TRUNCATE</literal> ou <literal>UNKNOWN</literal>
           </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>$_TD-&gt;{when}</literal></term>
         <listitem>
           <para>
             Quand le déclencheur a été appelé&nbsp;:
             <literal>BEFORE</literal> (avant), <literal>AFTER</literal>
             (après) ou <literal>UNKNOWN</literal> (inconnu)
           </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>$_TD-&gt;{level}</literal></term>
         <listitem>
           <para>
             Le niveau du déclencheur&nbsp;: <literal>ROW</literal> (ligne),
             <literal>STATEMENT</literal> (instruction) ou
             <literal>UNKNOWN</literal> (inconnu)
           </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>$_TD-&gt;{relid}</literal></term>
         <listitem>
           <para>
             L'OID de la table sur lequel le déclencheur a été exécuté
           </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>$_TD-&gt;{table_name}</literal></term>
         <listitem>
           <para>
             Nom de la table sur lequel le déclencheur a été exécuté
           </para>
         </listitem>
       </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{relname}</literal></term>
     <listitem>
      <para>
       Nom de la table sur lequel le déclencheur a été exécuté. Elle est obsolète
       et pourrait être supprimée dans une prochaine version. Utilisez
       $_TD-&gt;{table_name} à la place.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{table_schema}</literal></term>
     <listitem>
      <para>
       Nom du schéma sur lequel le déclencheur a été exécuté.
      </para>
     </listitem>
    </varlistentry>

       <varlistentry>
         <term><literal>$_TD-&gt;{argc}</literal></term>
         <listitem>
           <para>
             Nombre d'arguments de la fonction déclencheur
           </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>@{$_TD-&gt;{args}}</literal></term>
         <listitem>
           <para>
             Arguments de la fonction déclencheur. N'existe pas si
             <literal>$_TD-&gt;{argc}</literal> vaut 0.
           </para>
         </listitem>
       </varlistentry>

     </variablelist>
   </para>

   <para>
     Les déclencheurs niveau ligne peuvent renvoyer un des éléments suivants&nbsp;:
  
     <variablelist>
       <varlistentry>
         <term><literal>return;</literal></term>
         <listitem>
           <para>
             Exécute l'opération
           </para>
         </listitem>
       </varlistentry>
    
       <varlistentry>
         <term><literal>"SKIP"</literal></term>
         <listitem>
           <para>
             N'exécute pas l'opération
           </para>
         </listitem>
       </varlistentry>
    
       <varlistentry>
         <term><literal>"MODIFY"</literal></term>
         <listitem>
           <para>
             Indique que la ligne <literal>NEW</literal> a été modifiée par la
             fonction déclencheur
           </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </para>

   <para>
     Voici un exemple d'une fonction déclencheur illustrant certains points
     ci-dessus&nbsp;:
     <programlisting>CREATE TABLE test (
    i int,
    v varchar
);

CREATE OR REPLACE FUNCTION valid_id() RETURNS trigger AS $$
    if (($_TD-&gt;{new}{i} &gt;= 100) || ($_TD-&gt;{new}{i} &lt;= 0)) {
        return "SKIP";    # passe la commande INSERT/UPDATE
    } elsif ($_TD-&gt;{new}{v} ne "immortal") {
        $_TD-&gt;{new}{v} .= "(modified by trigger)";
        return "MODIFY";  # modifie la ligne et exécute la commande INSERT/UPDATE
    } else {
        return;           # exécute la commande INSERT/UPDATE
    }
$$ LANGUAGE plperl;

CREATE TRIGGER test_valid_id_trig
    BEFORE INSERT OR UPDATE ON test
    FOR EACH ROW EXECUTE PROCEDURE valid_id();</programlisting>
   </para>
 </sect1>

 <sect1 id="plperl-under-the-hood">
  <title>PL/Perl Under the Hood</title>

 <sect2 id="plperl-config">
  <title>Configuration</title>

  <para>
  This section lists configuration parameters that affect <application>PL/Perl</application>.
  To set any of these parameters before <application>PL/Perl</application> has been loaded,
  it is necessary to have added <quote><literal>plperl</literal></quote> to the
  <xref linkend="guc-custom-variable-classes"/> list in
  <filename>postgresql.conf</filename>.
  </para>

  <variablelist>

     <varlistentry id="guc-plperl-on-init" xreflabel="plperl.on_init">
      <term><varname>plperl.on_init</varname> (<type>string</type>)</term>
      <indexterm>
       <primary><varname>plperl.on_init</varname> configuration parameter</primary>
      </indexterm>
      <listitem>
       <para>
       Specifies Perl code to be executed when a Perl interpreter is first initialized
       and before it is specialized for use by <literal>plperl</literal> or <literal>plperlu</literal>.
       The SPI functions are not available when this code is executed.
       If the code fails with an error it will abort the initialization of the interpreter
       and propagate out to the calling query, causing the current transaction
       or subtransaction to be aborted.
       </para>
       <para>
       The Perl code is limited to a single string. Longer code can be placed
       into a module and loaded by the <literal>on_init</literal> string.
       Examples:
<programlisting>
plperl.on_init = 'require "plperlinit.pl"'
plperl.on_init = 'use lib "/my/app"; use MyApp::PgInit;'
</programlisting>
       </para>
       <para>
       Any modules loaded by <literal>plperl.on_init</literal>, either directly or
       indirectly, will be available for use by <literal>plperl</literal>.  This may
       create a security risk. To see what modules have been loaded you can use:
<programlisting>
DO 'elog(WARNING, join ", ", sort keys %INC)' language plperl;
</programlisting>
       </para>
       <para>
       Initialization will happen in the postmaster if the plperl library is included
       in <literal>shared_preload_libraries</literal> (see <xref linkend="guc-shared-preload-libraries"/>),
       in which case extra consideration should be given to the risk of destabilizing the postmaster.
       </para>
       <para>
       This parameter can only be set in the postgresql.conf file or on the server command line.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-plperl-on-plperl-init" xreflabel="plperl.on_plperl_init">
      <term><varname>plperl.on_plperl_init</varname> (<type>string</type>)</term>
      <term><varname>plperl.on_plperlu_init</varname> (<type>string</type>)</term>
      <indexterm>
       <primary><varname>plperl.on_plperl_init</varname> configuration parameter</primary>
      </indexterm>
      <indexterm>
       <primary><varname>plperl.on_plperlu_init</varname> configuration parameter</primary>
      </indexterm>
      <listitem>
       <para>
       These parameters specify Perl code to be executed when the
       <literal>plperl</literal>, or <literal>plperlu</literal> language is first used in a
       session.  Changes to these parameters after the corresponding language
       has been used will have no effect.
       The SPI functions are not available when this code is executed.
       Only superusers can change these settings.
       The Perl code in <literal>plperl.on_plperl_init</literal> can only perform trusted operations.
       </para>
       <para>
       The effect of setting these parameters is very similar to executing a
       <literal>DO</literal> command with the Perl code before any other use of the
       language.  The parameters are useful when you want to execute the Perl
       code automatically on every connection, or when a connection is not
       interactive. The parameters can be used by non-superusers by having a
       superuser execute an <literal>ALTER USER ... SET ...</literal> command.
       For example:
<programlisting>
ALTER USER joe SET plperl.on_plperl_init = '$_SHARED{debug} = 1';
</programlisting>
       </para>
       <para>
       If the code fails with an error it will abort the initialization and
       propagate out to the calling query, causing the current transaction or
       subtransaction to be aborted. Any changes within Perl won't be undone.
       If the language is used again the initialization will be repeated.
       </para>
       <para>
       The difference between these two settings and the 
       <literal>plperl.on_init</literal> setting is that these can be used for
       settings specific to the trusted or untrusted language variant, such
       as setting values in the <varname>%_SHARED</varname> variable. By contrast,
       <literal>plperl.on_init</literal> is more useful for doing things like
       setting the library search path for <productname>Perl</productname> or 
       loading Perl modules that don't interact directly with 
       <productname>PostgreSQL</productname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-plperl-use-strict" xreflabel="plperl.use_strict">
      <term><varname>plperl.use_strict</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary><varname>plperl.use_strict</varname> configuration parameter</primary>
      </indexterm>
      <listitem>
       <para>
       When set true subsequent compilations of PL/Perl functions have the <literal>strict</literal> pragma enabled.
       This parameter does not affect functions already compiled in the current session.
       </para>
      </listitem>
     </varlistentry>

  </variablelist>
</sect2>

 <sect2 id="plperl-missing">
  <title>Limitations et fonctionnalités absentes</title>

  <para>
   Les fonctionnalités suivantes ne sont actuellement pas implémentées dans
   PL/Perl, mais peuvent faire l'objet de contributions généreuses de votre part.

   <itemizedlist>
    <listitem>
     <para>
      Les fonctions PL/Perl ne peuvent pas s'appeler entre elles.
     </para>
    </listitem>

    <listitem>
     <para>
      SPI n'est pas complètement implémenté.
     </para>
    </listitem>

    <listitem>
     <para>
      Si vous récupérez des ensembles de données très importants en utilisant
      <literal>spi_exec_query</literal>, vous devez être conscient qu'ils
      iront tous en mémoire. Vous pouvez l'éviter en utilisant
      <literal>spi_query</literal>/<literal>spi_fetchrow</literal> comme
      montré précédemment.
     </para>
     <para>
        Un problème similaire survient si une fonction renvoyant un ensemble
        passe un gros ensemble de lignes à PostgreSQL via
        <literal>return</literal>. Vous pouvez l'éviter aussi en utilisant à la
        place <literal>return_next</literal> pour chaque ligne renvoyée, comme
        indiqué précédemment.
     </para>
    </listitem>

     <listitem>
      <para>
        When a session ends normally, not due to a fatal error, any
        <literal>END</literal> blocks that have been defined are executed.
        Currently no other actions are performed. Specifically, 
        file handles are not automatically flushed and objects are 
        not automatically destroyed.
      </para>
     </listitem>
   </itemizedlist>
  </para>
 </sect2>
 </sect1>

</chapter>
