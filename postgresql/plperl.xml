<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

 <chapter id="plperl">
  <title>PL/Perl - Langage de procédures Perl</title>

  <indexterm zone="plperl">
   <primary>PL/Perl</primary>
  </indexterm>

  <indexterm zone="plperl">
   <primary>Perl</primary>
  </indexterm>

  <para>
   PL/Perl est un langage de procédures chargeable qui vous permet d'écrire des
   fonctions <productname>PostgreSQL</productname> dans le <ulink
   url="http://www.perl.org">langage de programmation Perl</ulink>.
  </para>

  <para>
   Le principal avantage habituellement cité quant à l'utilisation de Perl est que cela
   permet l'utilisation des nombreux opérateurs et fonctions de <quote>gestion
   de chaînes</quote> disponibles grâce à Perl dans des procédures stockées.
   L'analyse de chaînes complexes se trouve facilité par l'utilisation de Perl
   et des fonctions et structures de contrôles fournies dans PL/pgSQL.
  </para>
  
  <para>
   Pour installer PL/Perl dans une base de données spécifique, utilisez
   <literal>CREATE EXTENSION plperl</literal> ou utilisez la commande
   <literal>createlang plperl <replaceable>nom_base</replaceable></literal> à
   partir de la ligne de commande du shell.
  </para>

  <tip>
   <para>
    Si un langage est installé dans <literal>template1</literal>, toutes les
    bases de données créées ultérieurement disposeront automatiquement de ce
    langage.
   </para>
  </tip>

  <note>
   <para>
    Les utilisateurs des paquetages sources doivent explicitement autoriser la
    construction de PL/Perl pendant le processus d'installation (se référer à
    la <xref linkend="installation"/> pour plus d'informations). Les utilisateurs
    des paquetages binaires peuvent trouver PL/Perl dans un sous-paquetage
    séparé.
   </para>
  </note>

 <sect1 id="plperl-funcs">
  <title>Fonctions et arguments PL/Perl</title>

  <para>
   Pour créer une fonction dans le langage PL/Perl, utilisez la syntaxe
   standard <xref linkend="sql-createfunction"/>&nbsp;:
<programlisting>CREATE FUNCTION <replaceable>nom_fonction</replaceable> (<replaceable>types-arguments</replaceable>) RETURNS
<replaceable>type-retour</replaceable> AS $$
    # Corps de la fonction PL/Perl
$$ LANGUAGE plperl;
</programlisting>
   Le corps de la fonction est du code Perl normal. En fait, le code
   supplémentaire PL/Perl l'emballe dans une sous-routine Perl. Une fonction
   PL/Perl est appelée dans un contexte scalaire, il ne peut donc pas retourner 
   une liste. Vous pouvez retourner des valeurs non scalaire par référence comme
   indiqué ci-dessous.
  </para>

  <para>
   PL/Perl peut aussi être utilisé au sein de blocs de procédures anonymes avec 
   l'ordre <xref linkend="sql-do"/> :

<programlisting>
DO $$
    # PL/Perl code
$$ LANGUAGE plperl;
</programlisting>

   Un bloc de procédure anonyme ne prend pas d'arguments et toute valeur 
   retourné est ignorée. Ceci mis à part, il se comporte comme une fonction 
   classique.
  </para>

  <note>
   <para>
    L'utilisation de sous-routines nommées est dangereux en Perl, spécialement
    si elles font références à des variables lexicales dans la partie
    englobante. Comme une fonction PL/Perl est englobée dans une sous-routine,
    toute sous-routine nommée que vous y créez 
    sera englobée. En général, il est bien plus sûr de créer des sous-routines anonymes
    que vous appellerez via un coderef. Pour de plus amples détails, voir 
    les entrées <literal>Variable "%s" will not stay shared</literal> et
    <literal>Variable "%s" is not available</literal> dans le manuel
    <citerefentry><refentrytitle>perldiag</refentrytitle></citerefentry>, ou
    recherchez <quote>perl nested named subroutine</quote> sur internet.
   </para>
  </note>

  <para>
    La syntaxe de la commande <command>CREATE FUNCTION</command> requiert que le
    corps de la fonction soit écrit comme une constante de type chaîne. Il est
    habituellement plus agréable d'utiliser les guillemets dollar (voir la <xref
    linkend="sql-syntax-dollar-quoting"/>) pour cette constante. Si vous
    choisissez d'utiliser la syntaxe d'échappement des chaînes <literal>E''</literal>,
    vous devez doubler les marques de guillemets simples (<literal>'</literal>)
    et les antislashs (<literal>\</literal>) utilisés dans le corps de la
    fonction (voir la <xref linkend="sql-syntax-strings"/>).
  </para>

  <para>
   Les arguments et les résultats sont manipulés comme dans n'importe quel
   routine Perl&nbsp;: les arguments sont passés au tableau
   <varname>@_</varname> et une valeur de retour
   est indiquée par <literal>return</literal> ou par la dernière expression
   évaluée dans la fonction.
  </para>

  <para>
   Par exemple, une fonction retournant le plus grand de deux entiers
   peut être définie comme suit&nbsp;:

<programlisting>CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    if ($_[0] &gt; $_[1]) { return $_[0]; }
    return $_[1];
$$ LANGUAGE plperl;
</programlisting>
  </para>

  <note>
    <para>
      Les arguments seront convertis de l'encodage de la base de données en
      UTF-8 pour être utilisé par PL/perl, puis converti de l'UTF-8 vers
      l'encodage de la base.
    </para>
  </note>

  <para>
   Si une valeur NULL en SQL<indexterm><primary>valeur NULL</primary><secondary
   sortas="PL/Perl">en PL/Perl</secondary></indexterm> est passée à une fonction,
   cet argument apparaîtra comme <quote>undefined</quote> en Perl. La
   fonction définie ci-dessus ne se comportera pas correctement avec des
   arguments NULL (en fait, tout se passera comme s'ils avaient été des zéros).
   Nous aurions pu ajouter <literal>STRICT</literal> à la définition de la fonction
   pour forcer <productname>PostgreSQL</productname> à faire quelque chose de
   plus raisonnable&nbsp;: si une valeur NULL est passée en argument, la
   fonction ne sera pas du tout appelée mais retournera automatiquement un
   résultat NULL. D'une autre façon, nous aurions pu vérifier dans le corps de
   la fonction la présence d'arguments NULL. Par exemple, supposons que nous
   voulions que <function>perl_max</function> avec un argument NULL et un autre
   non NULL retourne une valeur non NULL plutôt qu'une valeur NULL, on aurait
   écrit&nbsp;:

<programlisting>CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    my ($x, $y) = @_;
    if (not defined $x) {
        return undef if not defined $y;
        return $y;
    }
    return $x if not defined $y;
    return $x if $x &gt; $y;
    return $y;
$$ LANGUAGE plperl;
</programlisting>
   Comme le montre l'exemple ci-dessus, passer une valeur NULL en SQL
   à une fonction en PL/Perl retourne une valeur non définie. Et ceci,
   que la fonction soit déclarée stricte ou non.
  </para>

  <para>
   Dans un argument de fonction, tout ce qui n'est pas une référence est une
   chaîne qui est dans la représentation texte externe standard de
   <productname>PostgreSQL</productname> pour ce type de données. Dans le cas
   de types numériques ou texte, Perl fera ce qu'il faut et le programmeur
   n'aura pas à s'en soucier. Néanmoins, dans d'autres cas, l'argument aura
   besoin d'être converti dans une forme qui est plus utilisable que Perl.
   Par exemple, la fonction <function>decode_bytea</function> peut-être utilisée
   pour convertir un argument de type 
   <type>bytea</type> en données binaires non échappées.
  </para>

  <para>
   De façon similaire, les valeurs renvoyées à
   <productname>PostgreSQL</productname> doivent être dans le format textuel.
   Par exemple, 
   la fonction <function>encode_bytea</function> peut être utilisée
   pour échapper des données binaires en retournant une valeur de type <type>bytea</type>.
  </para>

  <para>
   Perl peut renvoyer des tableaux <productname>PostgreSQL</productname>
   comme référence à des tableaux Perl. Voici un exemple&nbsp;:

<programlisting>CREATE OR REPLACE function renvoit_tableau()
RETURNS text[][] AS $$
    return [['a&quot;b','c,d'],['e\\f','g']];
$$ LANGUAGE plperl;

select renvoit_tableau();
</programlisting>
  </para>

  <para>
   Perl utilise les tableaux <productname>PostgreSQL</productname> comme des
   objets PostgreSQL::InServer::ARRAY. Cet objet sera traité comme une référence
   de tableau ou comme une chaîne, permettant une compatibilité ascendante avec
   le code Perl écrit pour les versions de <productname>PostgreSQL</productname>
   antérieures à la 9.1. Par exemple&nbsp;:

<programlisting>
CREATE OR REPLACE FUNCTION concat_array_elements(text[]) RETURNS TEXT AS $$
    my $arg = shift;
    my $result = "";
    return undef if (!defined $arg);

    # en tant que référence de tableau
    for (@$arg) {
        $result .= $_;
    }

    # en tant que chaîne
    $result .= $arg;

    return $result;
$$ LANGUAGE plperl;

SELECT concat_array_elements(ARRAY['PL','/','Perl']);
</programlisting>

  <note>
   <para>
    Les tableaux multi-dimensionnels sont représentés comme des références à
    des tableaux de reférence et de moindre dimension, d'une façon connue de
    chaque développeur Perl.
   </para>
  </note>
  </para>

  <para>
   Les arguments de type composite sont passés à la fonction en tant que
   références d'un tableau de découpage, les clés du tableau de découpage étant
   les noms des attributs du type composé. Voici un exemple&nbsp;:

<programlisting>CREATE TABLE employe (
    nom text,
    basesalaire integer,
    bonus integer
);

CREATE FUNCTION empcomp(employe) RETURNS integer AS $$
    my ($emp) = @_;
    return $emp-&gt;{basesalaire} + $emp-&gt;{bonus};
$$ LANGUAGE plperl;

SELECT nom, empcomp(employe.*) FROM employe;
</programlisting>
  </para>

  <para>
   Une fonction PL/Perl peut renvoyer un résultat de type composite en utilisant
   la même approche&nbsp;: renvoyer une référence à un hachage qui a les 
   attributs requis. Par exemple&nbsp;

    <programlisting>      CREATE TYPE testligneperl AS (f1 integer, f2 text, f3 text);

      CREATE OR REPLACE FUNCTION perl_ligne() RETURNS test_ligne_perl AS $$
      return {f2 =&gt; 'hello', f1 =&gt; 1, f3 =&gt; 'world'};
      $$ LANGUAGE plperl;

      SELECT * FROM perl_row();
    </programlisting>

    Toute colonne dans le type de données déclaré du résultat qui n'est pas
    présente dans le hachage sera renvoyée NULL.
  </para>

  <para>
    Les fonctions PL/Perl peuvent aussi renvoyer des ensembles de types
    scalaires ou composites. Habituellement, vous voulez renvoyer une ligne à
    la fois, à la fois pour améliorer le temps de démarrage et pour éviter
    d'allonger la queue de l'ensemble des résultats en mémoire. Vous pouvez
    faire ceci avec <function>return_next</function> comme indiqué ci-dessous.
    Notez qu'après le dernier <function>return_next</function>, vous devez
    placer soit <literal>return</literal> soit (encore mieux) <literal>return
    undef</literal>.

<programlisting>CREATE OR REPLACE FUNCTION perl_set_int(int)
RETURNS SETOF INTEGER AS $$
    foreach (0..$_[0]) {
        return_next($_);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set()
RETURNS SETOF test_ligne_perl AS $$
    return_next({ f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' });
    return_next({ f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' });
    return_next({ f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' });
    return undef;
$$ LANGUAGE plperl;
</programlisting>

    Pour les petits ensembles de résultats, vous pouvez renvoyer une référence
    à un tableau contenant soit des scalaires, soit des références à des
    tableaux soit des références à des hachages de types simples, de types
    tableaux ou de types composites. Voici quelques exemples simples pour
    renvoyer l'ensemble complet du résultant en tant que référence de
    tableau&nbsp;:

    <programlisting>CREATE OR REPLACE FUNCTION perl_set_int(int) RETURNS SETOF INTEGER AS $$
      return [0..$_[0]];
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set() RETURNS SETOF testligneperl AS $$
return [
      { f1 =&gt; 1, f2 =&gt; 'Bonjour', f3 =&gt; 'Monde' },
      { f1 =&gt; 2, f2 =&gt; 'Bonjour', f3 =&gt; 'PostgreSQL' },
      { f1 =&gt; 3, f2 =&gt; 'Bonjour', f3 =&gt; 'PL/Perl' }
      ];
$$  LANGUAGE plperl;

SELECT * FROM perl_set();</programlisting>

  </para>

  <para>
   Si vous souhaitez utiliser le pragma <literal>strict</literal> dans votre code,
   vous avez plusieurs options. Pour une utilisation temporaire globale vous pouvez positionner (<command>SET</command>)
   <literal>plperl.use_strict</literal> à « true ». Ce paramètre affectera les
   compilations suivantes de fonctions <application>PL/Perl</application>, mais
   pas les fonctions déjà compilées dans la session en cours.
   Pour une utilisation globale permanente, vous pouvez positionner <literal>plperl.use_strict</literal>
   à « true » dans le fichier <filename>postgresql.conf</filename>.
  </para>

  <para>
   Pour une utilisation permanente dans des fonctions spécifiques, vous pouvez simplement placer:
<programlisting>use strict;
</programlisting>
   en haut du corps de la fonction.
  </para>
  
  <para>
  Le pragma <literal>feature</literal> est aussi disponible avec <function>use</function> si votre version de Perl est 5.10.0 ou supérieur.
  </para>
 </sect1>

 <sect1 id="plperl-data">
  <title>Valeurs en PL/Perl</title>

  <para>
   Les valeurs des arguments fournis au code d'une fonction PL/Perl sont
   simplement les arguments d'entrée convertis en tant que texte (comme s'ils 
   avaient été affichés par une commande <command>SELECT</command>).
   Inversement, les commandes <function>return</function> and <function>return_next</function>
   accepterons toute chaîne qui a un format d'entrée acceptable
   pour le type de retour déclaré de la fonction.
  </para>
 </sect1>

 <sect1 id="plperl-builtins">
  <title>Fonction incluses</title>

 <sect2 id="plperl-database">
  <title>Accès à la base de données depuis PL/Perl</title>

  <para>
   L'accès à la base de données à l'intérieur de vos fonctions écrites en Perl
   peut se faire à partir des fonctions suivantes&nbsp;:
  </para>

   <variablelist>
    <varlistentry>
     <indexterm>
      <primary>spi_exec_query</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_query</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_fetchrow</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_prepare</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_exec_prepared</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_query_prepared</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_cursor_close</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_freeplan</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>spi_exec_query</function>(<replaceable>query</replaceable> [, <replaceable>max-rows</replaceable>])</literal></term>
     <listitem>
      <para>
       <literal>spi_exec_query</literal> exécute une commande SQL et renvoie
       l'ensemble complet de la ligne comme une référence à un table de
       références hachées. <emphasis>Vous ne devez utiliser cette commande
       que lorsque vous savez que l'ensemble de résultat sera relativement
       petit.</emphasis>  Voici un exemple d'une requête (commande
       <command>SELECT</command>) avec le nombre optionnel maximum de
       lignes&nbsp;:
       <programlisting>$rv = spi_exec_query('SELECT * FROM ma_table', 5);</programlisting>
       Ceci entrevoit cinq lignes au maximum de la table
       <literal>ma_table</literal>. Si <literal>ma_table</literal> a une 
       colonne <literal>ma_colonne</literal>, vous obtenez la valeur de la
       ligne <literal>$i</literal> du résultat de cette façon&nbsp;:
       <programlisting>$foo = $rv-&gt;{rows}[$i]-&gt;{ma_colonne};</programlisting>
       Le nombre total des lignes renvoyées d'une requête 
       <command>SELECT</command> peut être accédé de cette façon&nbsp;:
       <programlisting>$nrows = $rv-&gt;{processed}</programlisting>
     </para>
     
     <para>
       Voici un exemple en utilisant un type de commande différent&nbsp;:
       <programlisting>$query = "INSERT INTO ma_table VALUES (1, 'test')";
$rv = spi_exec_query($query);</programlisting>
       Ensuite, vous pouvez accéder au statut de la commande (c'est-à-dire,
       <literal>SPI_OK_INSERT</literal>) de cette façon&nbsp;:
       <programlisting>$res = $rv-&gt;{status};</programlisting>
       Pour obtenir le nombre de lignes affectées, exécutez&nbsp;:
       <programlisting>$nrows = $rv-&gt;{processed};</programlisting>
     </para>

     <para>
       Voici un exemple complet&nbsp;:
       <programlisting>CREATE TABLE test (
    i int,
    v varchar
    );

INSERT INTO test (i, v) VALUES (1, 'première ligne');
INSERT INTO test (i, v) VALUES (2, 'deuxième ligne');
INSERT INTO test (i, v) VALUES (3, 'troisième ligne');
INSERT INTO test (i, v) VALUES (4, 'immortel');

CREATE OR REPLACE FUNCTION test_munge() RETURNS SETOF test AS $$
    my $rv = spi_exec_query('select i, v from test;');
    my $status = $rv-&gt;{status};
    my $nrows = $rv-&gt;{processed};
    foreach my $rn (0 .. $nrows - 1) {
        my $row = $rv-&gt;{rows}[$rn];
        $row-&gt;{i} += 200 if defined($row-&gt;{i});
        $row-&gt;{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row-&gt;{v}));
        return_next($row);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM test_munge();
       </programlisting>
     </para>
    </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal><function>spi_query(<replaceable>command</replaceable>)</function></literal></term>
     <term><literal><function>spi_fetchrow(<replaceable>cursor</replaceable>)</function></literal></term>
     <term><literal><function>spi_cursor_close(<replaceable>cursor</replaceable>)</function></literal></term>

    <listitem>
    <para>
    <literal>spi_query</literal> et <literal>spi_fetchrow</literal>
    fonctionnent ensemble comme une paire d'ensembles de lignes pouvant être
    assez importants ou pour les cas où vous souhaitez renvoyer les lignes dès
    qu'elles arrivent. <literal>spi_fetchrow</literal> fonctionne
    <emphasis>seulement</emphasis> avec <literal>spi_query</literal>. L'exemple
    suivant illustre comment vous les utilisez ensemble&nbsp;:

<programlisting>CREATE TYPE foo_type AS (the_num INTEGER, the_text TEXT);

CREATE OR REPLACE FUNCTION lotsa_md5 (INTEGER) RETURNS SETOF foo_type AS $$
    use Digest::MD5 qw(md5_hex);
    my $file = '/usr/share/dict/words';
    my $t = localtime;
    elog(NOTICE, "opening file $file at $t" );
    open my $fh, '&lt;', $file # ooh, it's a file access!
        or elog(ERROR, "cannot open $file for reading: $!");
    my @words = &lt;$fh&gt;;
    close $fh;
    $t = localtime;
    elog(NOTICE, "closed file $file at $t");
    chomp(@words);
    my $row;
    my $sth = spi_query("SELECT * FROM generate_series(1,$_[0]) AS b(a)");
    while (defined ($row = spi_fetchrow($sth))) {
        return_next({
            the_num =&gt; $row-&gt;{a},
            the_text =&gt; md5_hex($words[rand @words])
        });
    }
    return;
$$ LANGUAGE plperlu;

SELECT * from lotsa_md5(500);
</programlisting>
    </para>

    <para>
     Habituellement, <function>spi_fetchrow</function> devra être répété jusqu'à
     ce qu'il renvoie <literal>undef</literal>, indiquant qu'il n'y a plus de
     lignes à lire. Le curseur renvoyé par <literal>spi_query</literal> est
     automatiquement libéré quand
     <function>spi_fetchrow</function> renvoie <literal>undef</literal>. Si vous
     ne souhaitez pas lire toutes les lignes, appelez à la place
     <function>spi_cursor_close</function> pour libérer le curseur. Un échec ici
     résultera en des pertes mémoire.
    </para>
   </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal><function>spi_prepare(<replaceable>command</replaceable>, <replaceable>argument types</replaceable>)</function></literal></term>
     <term><literal><function>spi_query_prepared(<replaceable>plan</replaceable>, <replaceable>arguments</replaceable>)</function></literal></term>
     <term><literal><function>spi_exec_prepared(<replaceable>plan</replaceable> [, <replaceable>attributes</replaceable>], <replaceable>arguments</replaceable>)</function></literal></term>
     <term><literal><function>spi_freeplan(<replaceable>plan</replaceable>)</function></literal></term>

    <listitem>
    <para>
    <literal>spi_prepare</literal>, <literal>spi_query_prepared</literal>,
    <literal>spi_exec_prepared</literal> et <literal>spi_freeplan</literal>
    implémentent la même fonctionnalité, mais pour des requêtes préparées.
    <literal>spi_prepare</literal> accepte une chaîne pour la requête avec des
    arguments numérotés ($1, $2, etc) et une liste de chaînes indiquant le type
    des arguments&nbsp;:
<programlisting>
$plan = spi_prepare('SELECT * FROM test WHERE id &gt; $1 AND name = $2', 'INTEGER', 'TEXT');
</programlisting>
    Une fois qu'un plan est préparé suite à un appel à
    <literal>spi_prepare</literal>, le plan peut être utilisé à la place de la
    requête, soit dans <literal>spi_exec_prepared</literal>, où le résultat est
    identique à celui renvoyé par <literal>spi_exec_query</literal>, soit dans
    <literal>spi_query_prepared</literal> qui renvoi un curseur exactement comme
    le fait <literal>spi_query</literal>, qui peut ensuite être passé à
    <literal>spi_fetchrow</literal>. Le deuxième paramètre, optionnel, de
    <literal>spi_exec_prepared</literal> est une référence hachée des
    attributs&nbsp;; le seul attribut actuellement supporté est
    <literal>limit</literal>, qui configure le nombre maximum de lignes renvoyées
    par une requête. 
    </para>

    <para>
    L'avantage des requêtes préparées est que cela rend possible l'utilisation
    d'un plan préparé par plusieurs exécutions de la requête. Une fois que le
    plan n'est plus utile, il peut être libéré avec
    <literal>spi_freeplan</literal>&nbsp;:
    </para>

    <para>
    <programlisting>
CREATE OR REPLACE FUNCTION init() RETURNS VOID AS $$
        $_SHARED{my_plan} = spi_prepare( 'SELECT (now() + $1)::date AS now', 'INTERVAL');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION add_time( INTERVAL ) RETURNS TEXT AS $$
        return spi_exec_prepared(
                $_SHARED{my_plan},
                $_[0]
        )->{rows}->[0]->{now};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION done() RETURNS VOID AS $$
        spi_freeplan( $_SHARED{my_plan});
        undef $_SHARED{my_plan};
$$ LANGUAGE plperl;

SELECT init();
SELECT add_time('1 day'), add_time('2 days'), add_time('3 days');
SELECT done();

  add_time  |  add_time  |  add_time
------------+------------+------------
 2005-12-10 | 2005-12-11 | 2005-12-12
    </programlisting>
    </para>

    <para>
    Notez que l'indice du paramètre dans <literal>spi_prepare</literal> est
    défini via $1, $2, $3, etc, donc évitez de déclarer des chaînes de requêtes
    qui pourraient aisément amener des bogues difficiles à trouver et corriger.
    </para>

    <para>
    Cet autre exemple illustre l'utilisation d'un paramètre optionnel avec
    <literal>spi_exec_prepared</literal>&nbsp;:
    </para>

    <para>
    <programlisting>
CREATE TABLE hosts AS SELECT id, ('192.168.1.'||id)::inet AS address FROM generate_series(1,3) AS id;

CREATE OR REPLACE FUNCTION init_hosts_query() RETURNS VOID AS $$
        $_SHARED{plan} = spi_prepare('SELECT * FROM hosts WHERE address &lt;&lt; $1', 'inet');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION query_hosts(inet) RETURNS SETOF hosts AS $$
        return spi_exec_prepared(
                $_SHARED{plan},
                {limit =&gt; 2},
                $_[0]
        )->{rows};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION release_hosts_query() RETURNS VOID AS $$
        spi_freeplan($_SHARED{plan});
        undef $_SHARED{plan};
$$ LANGUAGE plperl;

SELECT init_hosts_query();
SELECT query_hosts('192.168.1.0/30');
SELECT release_hosts_query();

    query_hosts    
-----------------
 (1,192.168.1.1)
 (2,192.168.1.2)
(2 rows)
    </programlisting>
    </para>
    </listitem>
    </varlistentry>
   </variablelist>
 </sect2>

 <sect2 id="plperl-utility-functions">
  <title>Fonctions utiles en PL/Perl</title>

   <variablelist>
    <varlistentry>
     <term><literal><function>elog(<replaceable>level</replaceable>,
     <replaceable>msg</replaceable>)</function></literal></term>
     <listitem>
     <indexterm>
      <primary>elog</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

      <para>
       Produit un message de trace ou d'erreur. Les niveaux possibles sont
       <literal>DEBUG</literal>, <literal>LOG</literal>, <literal>INFO</literal>,
       <literal>NOTICE</literal>, <literal>WARNING</literal> et <literal>ERROR</literal>.
       <literal>ERROR</literal> lève une condition d'erreur&nbsp;; si elle n'est pas
       récupérée par le code Perl l'entourant, l'erreur se propage à
       l'extérieur de la requête appelante, causant l'annulation de la 
       transaction ou sous-transaction en cours. Ceci est en fait identique à
       la commande <literal>die</literal> de Perl. Les autres niveaux génèrent 
       seulement des messages de niveaux de priorité différents. Le fait que
       les messages d'un niveau de priorité particulier soient rapportés au
       client, écrit dans les journaux du serveur, voire les deux, est contrôlé
       par les variables de configuration <xref
       linkend="guc-log-min-messages"/> et <xref
       linkend="guc-client-min-messages"/>. Voir le <xref
       linkend="runtime-config"/> pour plus d'informations.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>quote_literal</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

     <term><literal><function>quote_literal(<replaceable>string</replaceable>)</function></literal></term>
     <listitem>
      <para>
        Retourne la chaîne donnée convenablement placé entre simple guillemets pour être utilisée comme une chaîne littérale au sein
        d'une chaîne représentant un ordre SQL. Les simples guillemets et antislashes de la chaîne sont correctement doublés
        Notez que <function>quote_literal</function> retourne undef avec une entrée undef ; si l'argument
        peut être undef, <function>quote_nullable</function> est souvent plus approprié.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>quote_nullable</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

     <term><literal><function>quote_nullable(<replaceable>string</replaceable>)</function></literal></term>
     <listitem>
      <para>
	    Retourne la chaîne donnée convenablement placé entre simple guillemets pour être utilisée comme une chaîne littérale au sein
        d'une chaîne représentant un ordre SQL. Si l'argument d'entrée est undef, retourne la chaîne "NULL" sans simple guillemet.
        Les simples guillemets et antislashes de la chaîne sont correctement doublés
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>quote_ident</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

     <term><literal><function>quote_ident(<replaceable>string</replaceable>)</function></literal></term>
     <listitem>
      <para>
        Retourne la chaîne donnée convenablement placé entre guillemets pour être utilisée 
        comme un identifiant au sein d'une chaîne représentant un ordre SQL. 
        Les guillemets sont ajoutées seulement si cela est nécessaire (i.e. si 
        la chaîne contient des caractères non-identifiant ou est en majuscule). 
        Les guillemets  de la chaîne seront convenablement doublés.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>decode_bytea</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

     <term><literal><function>decode_bytea(<replaceable>string</replaceable>)</function></literal></term>
     <listitem>
      <para>
	    Retourne les données binaires non échappé représentées par le contenu de 
	    la chaîne donnée, qui doit être encodé au format <type>bytea</type>.
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>encode_bytea</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

     <term><literal><function>encode_bytea(<replaceable>string</replaceable>)</function></literal></term>
     <listitem>
      <para>
        Retourne sous la forme d'un <type>bytea</type> le contenu binaire dans la chaîne passé en argument.
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>encode_array_literal</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

     <term><literal><function>encode_array_literal(<replaceable>array</replaceable>)</function></literal></term>
     <term><literal><function>encode_array_literal(<replaceable>array</replaceable>, <replaceable>delimiter</replaceable>)</function></literal></term>
     <listitem>
      <para>
	    Retourne le contenu de tableau passé par référence sous forme d'une chaîne littérale.
        (voir <xref linkend="arrays-input"/>).
        Retourne la valeur de l'argument non altérée si ce n'est pas une référence à un tableau.
        Le délimiteur utilisé entre les éléments du tableau sous forme littérale sera par défaut "<literal>, </literal>"
        si aucun délimiteur n'est spécifié ou s'il est undef.
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>encode_typed_literal</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>encode_typed_literal(<replaceable>value</replaceable>, <replaceable>typename</replaceable>)</function></literal></term>
      <listitem>
       <para>
         Convertit une variable Perl en une valeur du type de données passé
         en second argument et renvoie une représentation de type chaîne pour
         cette valeur. Gère correctement les tableaux imbriqués et les valeurs
         de types composites.
       </para>
      </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>encode_array_constructor</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

     <term><literal><function>encode_array_constructor(<replaceable>array</replaceable>)</function></literal></term>
     <listitem>
      <para>
        Retourne le contenu de tableau passé par référence sous forme d'une chaîne 
        permettant de construire un tableau en SQL.
        (voir <xref linkend="sql-syntax-array-constructors"/>).
        Chaque élément est entouré de simple guillemets par <function>quote_nullable</function>.
        Retourne la valeur de l'argument, entouré de simple guillemets par <function>quote_nullable</function>,
        si ce n'est pas une référence à un tableau.
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>looks_like_number</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

     <term><literal><function>looks_like_number(<replaceable>string</replaceable>)</function></literal></term>
     <listitem>
      <para>
        Retourne une valeur vraie si le contenu de la chaîne passée ressemble à 
        un nombre, selon l'interprétation de Perl, et faux dans le cas contraire.
        Retourne undef si undef est passé en argument. Tout espace en début et fin de chaîne sont
        ignorés. <literal>Inf</literal> et <literal>Infinity</literal> sont vu comme des nombres.
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>is_array_ref</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>is_array_ref(<replaceable>argument</replaceable>)</function></literal></term>
     <listitem>
      <para>
        Renvoie une valeur true si l'argument donné peut être traité comme une
        référence de tableau, c'est-à-dire si la référence de l'argument est
        <literal>ARRAY</literal> ou <literal>PostgreSQL::InServer::ARRAY</literal>.
        Renvoie false sinon.
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
 </sect2>
 </sect1>

<sect1 id="plperl-global">
  <title>Valeurs globales dans PL/Perl</title>
  
  <para>
    Vous pouvez utiliser le hachage global <varname>%_SHARED</varname> pour
    stocker les données, incluant les références de code, entre les appels de
    fonction pour la durée de vie de la session en cours.
  </para>
  
  <para>
    Voici un exemple simple pour des données partagées&nbsp;:
    <programlisting>CREATE OR REPLACE FUNCTION set_var(name text, val text) RETURNS text AS $$
if ($_SHARED{$_[0]} = $_[1]) {
      return 'ok';
} else {
      return "Ne peux pas initialiser la variable partagée $_[0] à $_[1]";
}
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION get_var(name text) RETURNS text AS $$
      return $_SHARED{$_[0]};
$$ LANGUAGE plperl;

SELECT set_var('sample', 'Bonjour, PL/Perl ! Comment va ?');
SELECT get_var('sample');</programlisting>
  </para>
  
  <para>
    Voici un exemple légèrement plus compliqué utilisant une référence de
    code&nbsp;:
    
    <programlisting>CREATE OR REPLACE FUNCTION ma_fonction() RETURNS void AS $$
$_SHARED{myquote} = sub {
      my $arg = shift;
      $arg =~ s/(['\\])/\\$1/g;
      return "'$arg'";
      };
$$ LANGUAGE plperl;

SELECT ma_fonction(); /* initialise la fonction */

/* Initialise une fonction qui utilise la fonction quote */

CREATE OR REPLACE FUNCTION utilise_quote(TEXT) RETURNS text AS $$
      my $text_to_quote = shift;
      my $qfunc = $_SHARED{myquote};
      return &amp;$qfunc($text_to_quote);
$$ LANGUAGE plperl;</programlisting>

    (Vous pouviez avoir remplacé le code ci-dessus avec la seule ligne
    <literal>return $_SHARED{myquote}-&gt;($_[0]);</literal>
    au prix d'une mauvaise lisibilité.)
  </para>

  <para>
   Pour des raisons de sécurité, PL/Perl exécute des fonctions appelées par
   un rôle SQL dans un interpréteur Perl séparé pour ce rôle. Ceci empêche
   l'interférence accidentelle ou malicieuse d'un utilisateur avec le
   comportement des fonctions PL/Perl d'un autre utilisateur. Chaque
   interprétateur a sa propre valeur de la variable
   <varname>%_SHARED</varname> et des autres états globaux. Du coup, deux
   fonctions PL/Perl partageront la même valeur de <varname>%_SHARED</varname>
   si et seulement si elles sont exécutées par le même rôle SQL. Dans une
   application où une session seule exécute du code sous plusieurs rôles SQL
   (via des fonctions <literal>SECURITY DEFINER</literal>, l'utilisation de
   <command>SET ROLE</command>, etc), vous pouvez avoir besoin de mettre en place des
   étapes explicites pour vous assurer que les fonctions PL/Perl peuvent
   partager des données <varname>%_SHARED</varname>. Pour cela, assurez-vous
   que les fonctions qui doivent communiquer ont pour propriétaire le même
   utilisateur et marquez les comme <literal>SECURITY DEFINER</literal>. Bien sûr,
   vous devez faire attention à ce que ces fonctions ne puissent pas être
   utilisées pour faire des choses qu'elles ne sont pas sensées faire.
  </para>
</sect1>

 <sect1 id="plperl-trusted">
  <title>Niveaux de confiance de PL/Perl</title>

  <indexterm zone="plperl-trusted">
   <primary>trusted</primary>
   <secondary>PL/Perl</secondary>
  </indexterm>

  <para>
   Normalement, PL/Perl est installé en tant que langage de programmation de
   <quote>confiance</quote>, de nom <literal>plperl</literal>. Durant cette installation,
   certaines commandes Perl sont désactivées pour préserver la sécurité. En
   général, les commandes qui interagissent avec l'environnement sont
   restreintes. Cela inclut les commandes sur les descripteurs de fichiers,
   <literal>require</literal> et <literal>use</literal> (pour les modules
   externes). Il n'est pas possible d'accéder aux fonctions et variables
   internes du processus du serveur de base de données ou d'obtenir un accès au
   niveau du système d'exploitation avec les droits du processus serveur, tel
   qu'une fonction C peut le faire. Ainsi, n'importe quel utilisateur sans
   droits sur la base de données est autorisé à utiliser ce langage.
  </para>

  <para>
   Voici l'exemple d'une fonction qui ne fonctionnera pas car les commandes système
   ne sont pas autorisées pour des raisons de sécurité&nbsp;:
<programlisting>CREATE FUNCTION badfunc() RETURNS integer AS $$
    my $tmpfile = "/tmp/badfile";
    open my $fh, '&gt;', $tmpfile
        or elog(ERROR, qq{could not open the file "$tmpfile": $!});
    print $fh "Testing writing to a file\n";
    close $fh or elog(ERROR, qq{could not close the file "$tmpfile": $!});
    return 1;
$$ LANGUAGE plperl;
</programlisting>
   La création de cette fonction échouera car le validateur détectera
   l'utilisation par cette fonction d'une opération interdite.
  </para>

  <para>
   Il est parfois souhaitable d'écrire des fonctions Perl qui ne sont pas
   restreintes. Par exemple, on peut souhaiter vouloir envoyer des courriers
   électroniques. Pour supporter ce cas de figure, PL/Perl peut aussi être
   installé comme un langage <quote>douteux</quote> (habituellement nommé
   <application>PL/PerlU</application>
   <indexterm><primary>PL/PerlU</primary></indexterm>).
   Dans ce cas, la totalité du langage Perl est accessible. Lors de
   l'installation du langage, le nom
   du langage <literal>plperlu</literal> sélectionnera la version douteuse de
   PL/Perl.
  </para>

  <para>
   Les auteurs des fonctions <application>PL/PerlU</application> doivent faire attention au
   fait que celles-ci ne puissent être utilisées pour faire quelque chose de non
   désiré car cela donnera la possibilité d'agir comme si l'on possédait les
   privilèges d'administrateur de la base de données. Il est à noter que le
   système de base de données ne permet qu'aux super-utilisateurs de créer des
   fonctions dans un langage douteux.
  </para>

  <para>
   Si la fonction ci-dessus a été créée par un super-utilisateur en utilisant
   le langage <literal>plperlu</literal>, l'exécution de celle-ci réussira.
  </para>

  <para>
   De la même façon, les blocs de procédure anonymes écris en perl peuvent utiliser
   les opérations restreintes si le langage est spécifié comme 
   <literal>plperlu</literal> plutôt que <literal>plperl</literal>, mais l'appelant
   doit être un super-utilisateur.
  </para>

  <note>
   <para>
    While <application>PL/Perl</application> functions run in a separate Perl
    interpreter for each SQL role, all <application>PL/PerlU</application> functions
    executed in a given session run in a single Perl interpreter (which is
    not any of the ones used for <application>PL/Perl</application> functions).
    This allows <application>PL/PerlU</application> functions to share data freely,
    but no communication can occur between <application>PL/Perl</application> and
    <application>PL/PerlU</application> functions.
   </para>
  </note>

  <note>
   <para>
    Perl cannot support multiple interpreters within one process unless
    it was built with the appropriate flags, namely either
    <literal>usemultiplicity</literal> or <literal>useithreads</literal>.
    (<literal>usemultiplicity</literal> is preferred unless you actually need
    to use threads.  For more details, see the
    <citerefentry><refentrytitle>perlembed</refentrytitle></citerefentry> man page.)
    If <application>PL/Perl</application> is used with a copy of Perl that was not built
    this way, then it is only possible to have one Perl interpreter per
    session, and so any one session can only execute either
    <application>PL/PerlU</application> functions, or <application>PL/Perl</application> functions
    that are all called by the same SQL role.
   </para>
  </note>

 </sect1>

 <sect1 id="plperl-triggers">
   <title>Déclencheurs PL/Perl</title>
   
   <para>
     PL/Perl peut être utilisé pour écrire des fonctions pour déclencheurs.
     Dans une fonction déclencheur, la référence hachée 
     <varname>$_TD</varname> contient des informations sur l'événement du
     déclencheur en cours. <varname>$_TD</varname> est une variable globale
     qui obtient une valeur locale séparée à chaque appel du déclencheur.
     Les champs de la référence de hachage
     <varname>$_TD</varname> sont&nbsp;:
     
     <variablelist>
       <varlistentry>
         <term><literal>$_TD-&gt;{new}{foo}</literal></term>
         <listitem>
           <para>
             Valeur <literal>NEW</literal> de la colonne <literal>foo</literal>
           </para>
         </listitem>
       </varlistentry>
       
       <varlistentry>
         <term><literal>$_TD-&gt;{old}{foo}</literal></term>
         <listitem>
           <para>
             Valeur <literal>OLD</literal> de la colonne <literal>foo</literal>
           </para>
         </listitem>
       </varlistentry>
       
       <varlistentry>
         <term><literal>$_TD-&gt;{name}</literal></term>
         <listitem>
           <para>
             Nom du déclencheur appelé
           </para>
         </listitem>
       </varlistentry>
       
       <varlistentry>
         <term><literal>$_TD-&gt;{event}</literal></term>
         <listitem>
           <para>
             Événement du déclencheur&nbsp;: <literal>INSERT</literal>,
             <literal>UPDATE</literal>, <literal>DELETE</literal>,
             <literal>TRUNCATE</literal>, <literal>INSTEAD OF</literal> ou
             <literal>UNKNOWN</literal>
           </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>$_TD-&gt;{when}</literal></term>
         <listitem>
           <para>
             Quand le déclencheur a été appelé&nbsp;:
             <literal>BEFORE</literal> (avant), <literal>AFTER</literal>
             (après) ou <literal>UNKNOWN</literal> (inconnu)
           </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>$_TD-&gt;{level}</literal></term>
         <listitem>
           <para>
             Le niveau du déclencheur&nbsp;: <literal>ROW</literal> (ligne),
             <literal>STATEMENT</literal> (instruction) ou
             <literal>UNKNOWN</literal> (inconnu)
           </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>$_TD-&gt;{relid}</literal></term>
         <listitem>
           <para>
             L'OID de la table sur lequel le déclencheur a été exécuté
           </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>$_TD-&gt;{table_name}</literal></term>
         <listitem>
           <para>
             Nom de la table sur lequel le déclencheur a été exécuté
           </para>
         </listitem>
       </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{relname}</literal></term>
     <listitem>
      <para>
       Nom de la table sur lequel le déclencheur a été exécuté. Elle est obsolète
       et pourrait être supprimée dans une prochaine version. Utilisez
       $_TD-&gt;{table_name} à la place.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{table_schema}</literal></term>
     <listitem>
      <para>
       Nom du schéma sur lequel le déclencheur a été exécuté.
      </para>
     </listitem>
    </varlistentry>

       <varlistentry>
         <term><literal>$_TD-&gt;{argc}</literal></term>
         <listitem>
           <para>
             Nombre d'arguments de la fonction déclencheur
           </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>@{$_TD-&gt;{args}}</literal></term>
         <listitem>
           <para>
             Arguments de la fonction déclencheur. N'existe pas si
             <literal>$_TD-&gt;{argc}</literal> vaut 0.
           </para>
         </listitem>
       </varlistentry>

     </variablelist>
   </para>

   <para>
     Les déclencheurs niveau ligne peuvent renvoyer un des éléments suivants&nbsp;:
  
     <variablelist>
       <varlistentry>
         <term><literal>return;</literal></term>
         <listitem>
           <para>
             Exécute l'opération
           </para>
         </listitem>
       </varlistentry>
    
       <varlistentry>
         <term><literal>"SKIP"</literal></term>
         <listitem>
           <para>
             N'exécute pas l'opération
           </para>
         </listitem>
       </varlistentry>
    
       <varlistentry>
         <term><literal>"MODIFY"</literal></term>
         <listitem>
           <para>
             Indique que la ligne <literal>NEW</literal> a été modifiée par la
             fonction déclencheur
           </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </para>

   <para>
     Voici un exemple d'une fonction déclencheur illustrant certains points
     ci-dessus&nbsp;:
     <programlisting>CREATE TABLE test (
    i int,
    v varchar
);

CREATE OR REPLACE FUNCTION valid_id() RETURNS trigger AS $$
    if (($_TD-&gt;{new}{i} &gt;= 100) || ($_TD-&gt;{new}{i} &lt;= 0)) {
        return "SKIP";    # passe la commande INSERT/UPDATE
    } elsif ($_TD-&gt;{new}{v} ne "immortal") {
        $_TD-&gt;{new}{v} .= "(modified by trigger)";
        return "MODIFY";  # modifie la ligne et exécute la commande INSERT/UPDATE
    } else {
        return;           # exécute la commande INSERT/UPDATE
    }
$$ LANGUAGE plperl;

CREATE TRIGGER test_valid_id_trig
    BEFORE INSERT OR UPDATE ON test
    FOR EACH ROW EXECUTE PROCEDURE valid_id();</programlisting>
   </para>
 </sect1>

 <sect1 id="plperl-under-the-hood">
  <title>PL/Perl sous le capot</title>

 <sect2 id="plperl-config">
  <title>Configuration</title>

  <para>
  Cette section liste les paramètres de configuration de <application>PL/Perl</application>.
  </para>

  <variablelist>

     <varlistentry id="guc-plperl-on-init" xreflabel="plperl.on_init">
      <term><varname>plperl.on_init</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>paramètre de configuration <varname>plperl.on_init</varname></primary>
      </indexterm>
      <listitem>
       <para><!--TODO-->
       Spécifie un code perl à exécuter lorsque l'interpréteur Perl est initialisé 
       pour la première fois et avant qu'il soit spécialisé pour être utilisé par 
       <literal>plperl</literal> ou <literal>plperlu</literal>.
       Les fonction SPI ne sont pas disponible lorsque ce code est exécuté.
       Si le code lève une erreur, il interrompra l'initialisation de 
       l'interpréteur et la propagera à la requête originale, provoquant ainsi 
       l'annulation de la transaction ou sous-transaction courante.
       </para>
       <para>
       Le code Perl est limité à une seule ligne. Un code plus long peut
       être placé dans un module et chargé par <literal>on_init</literal>.
       Exemples:
<programlisting>
plperl.on_init = 'require "plperlinit.pl"'
plperl.on_init = 'use lib "/my/app"; use MyApp::PgInit;'
</programlisting>
       </para>
       <para>
       Tous les modules chargés par <literal>plperl.on_init</literal>, directement
       ou indirectement, seront disponibles depuis <literal>plperl</literal>.
       Cela entraîne un problème de sécurité potentiel. Pour consulter 
       la liste des modules chargés, vous pouvez utiliser :
<programlisting>
DO 'elog(WARNING, join ", ", sort keys %INC)' LANGUAGE plperl;
</programlisting>
       </para>
       <para>
       L'initialisation aura lieu au sein du postmaster si la librairie plperl 
       est incluse dans le paramètre <xref linkend="guc-shared-preload-libraries"/>), 
       auquel cas une plus grande attention doit être portée au risque de 
       déstabiliser ce dernier. The principal reason for making use of this feature
       is that Perl modules loaded by <literal>plperl.on_init</literal> need be
       loaded only at postmaster start, and will be instantly available
       without loading overhead in individual database sessions.  However,
       keep in mind that the overhead is avoided only for the first Perl
       interpreter used by a database session &mdash; either PL/PerlU, or
       PL/Perl for the first SQL role that calls a PL/Perl function.  Any
       additional Perl interpreters created in a database session will have
       to execute <literal>plperl.on_init</literal> afresh.  Also, on Windows there
       will be no savings whatsoever from preloading, since the Perl
       interpreter created in the postmaster process does not propagate to
       child processes.
       </para>
       <para>
       Ce paramètre ne peut être positionné que dans le fichier <filename>postgresql.conf</filename> ou 
       depuis la ligne de commande de démarrage du serveur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-plperl-on-plperl-init" xreflabel="plperl.on_plperl_init">
      <term><varname>plperl.on_plperl_init</varname> (<type>string</type>)</term>
      <term><varname>plperl.on_plperlu_init</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>paramètre de configuration <varname>plperl.on_plperl_init</varname></primary>
      </indexterm>
      <indexterm>
       <primary>paramètre de configuration <varname>plperl.on_plperlu_init</varname></primary>
      </indexterm>
      <listitem>
       <para>
        These parameters specify Perl code to be executed when a Perl
        interpreter is specialized for <literal>plperl</literal> or
        <literal>plperlu</literal> respectively.  This will happen when a PL/Perl or
        PL/PerlU function is first executed in a database session, or when
        an additional interpreter has to be created because the other language
        is called or a PL/Perl function is called by a new SQL role.  This
        follows any initialization done by <literal>plperl.on_init</literal>.
        The SPI functions are not available when this code is executed.
        The Perl code in <literal>plperl.on_plperl_init</literal> is executed after
        <quote>locking down</quote> the interpreter, and thus it can only perform
        trusted operations.
       </para>
       <para>
        Si le code lève une erreur, il interrompra l'initialisation et la 
        propagera à la requête originale, provoquant ainsi l'annulation de la 
        transaction ou sous-transaction courante. Any actions already done within Perl
        won't be undone; however, that interpreter won't be used again.
        If the language is used again the initialization will be attempted
        again within a fresh Perl interpreter.
       </para>
       <para>
        Only superusers can change these settings.  Although these settings
        can be changed within a session, such changes will not affect Perl
        interpreters that have already been used to execute functions.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-plperl-use-strict" xreflabel="plperl.use_strict">
      <term><varname>plperl.use_strict</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>paramètre de configuration <varname>plperl.use_strict</varname></primary>
      </indexterm>
      <listitem>
       <para>
       Lorsqu'il est positionné à « true », les compilations des fonction 
       PL/Perl suivantes auront le pragma <literal>strict</literal> activé.
       Ce paramètre n'affecte pas les fonctions déjà compilées au sein de 
       la session courante.
       </para>
      </listitem>
     </varlistentry>

  </variablelist>
</sect2>

 <sect2 id="plperl-missing">
  <title>Limitations et fonctionnalités absentes</title>

  <para>
   Les fonctionnalités suivantes ne sont actuellement pas implémentées dans
   PL/Perl, mais peuvent faire l'objet de contributions généreuses de votre part.

   <itemizedlist>
    <listitem>
     <para>
      Les fonctions PL/Perl ne peuvent pas s'appeler entre elles.
     </para>
    </listitem>

    <listitem>
     <para>
      SPI n'est pas complètement implémenté.
     </para>
    </listitem>

    <listitem>
     <para>
      Si vous récupérez des ensembles de données très importants en utilisant
      <literal>spi_exec_query</literal>, vous devez être conscient qu'ils
      iront tous en mémoire. Vous pouvez l'éviter en utilisant
      <literal>spi_query</literal>/<literal>spi_fetchrow</literal> comme
      montré précédemment.
     </para>
     <para>
        Un problème similaire survient si une fonction renvoyant un ensemble
        passe un gros ensemble de lignes à PostgreSQL via
        <literal>return</literal>. Vous pouvez l'éviter aussi en utilisant à la
        place <literal>return_next</literal> pour chaque ligne renvoyée, comme
        indiqué précédemment.
     </para>
    </listitem>

     <listitem>
      <para>
        Lorsque'une session se termine normalement, et pas à cause d'une erreur fatale,
        tous les blocs <literal>END</literal> qui ont été définis sont exécutés.
        Actuellement, aucune autre action ne sont réalisées.
        Spécifiquement, les descripteurs de fichiers ne sont pas vidés automatiquement
        et les objets ne sont pas détruits automatiquement.
      </para>
     </listitem>
   </itemizedlist>
  </para>
 </sect2>
 </sect1>

</chapter>

