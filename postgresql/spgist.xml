<?xml version="1.0" encoding="UTF-8"?>
<chapter id="spgist">
 <title>Index SP-GiST</title>

 <indexterm>
  <primary>index</primary>
  <secondary>SP-GiST</secondary>
 </indexterm>

 <sect1 id="spgist-intro">
  <title>Introduction</title>

  <para>
   <acronym>SP-GiST</acronym> est une abréviation pour les espaces géographiques
   partitionnées avec <acronym>GiST</acronym>. <acronym>SP-GiST</acronym>
   supporte les arbres de recherche partitionnés, qui facilitent le développement
   d'un grand nombre de structures de données non balancées différentes, comme
   les <foreignphrase>quadtree</foreignphrase>, les arbres k-d et les arbres de
   <foreignphrase>radix</foreignphrase>.
   Le principal intérêt de ces structures et la division régulière de l'espace de recherche
   en partitions de taille égales. Les recherches qui correspondent bien avec la règle
   de partitionnement peuvent être très rapides.
  </para>

  <para>
   Ces fameuses structures de données ont été initialement conçues pour une
   exécution en mémoire. Dans la mémoire principale, elles sont généralement
   conçues comme un ensemble de nœuds alloués dynamiquement et reliés entre eux
   par des pointeurs. Cette organisation ne peut pas être transposée directement
   sur disque car ces suites de pointeurs peuvent nécessiter un nombre d'accès
   disque trop important. Au contraire, les structures de données adaptées
   au disque devraient permettre de charger simultanément un grand nombre de données
   (<foreignphrase>high fanout</foreignphrase>) pour minimiser les accès disque.
   Le challenge proposé par <acronym>SP-GiST</acronym> est de faire correspondre
   les nœuds des arbres de recherche avec les pages du disque de manière à ce
   qu'une recherche ne nécessite qu'un faible nombre d'accès disque, même si
   il nécessite de traverser plusieurs nœuds.
  </para>

  <para>
   Tout comme <acronym>GiST</acronym>, <acronym>SP-GiST</acronym> est destiné
   à permettre le développement de types de données personnalisées, disposant
   des méthodes d'accès appropriées, par un expert du domaine plutôt que par
   un expert en base de données.
  </para>

  <para>
   Une partie des informations fournies ici sont extraites du
   <ulink url="https://www.cs.purdue.edu/spgist/">site web</ulink> du projet
   d'indexation SP-GiST de l'université Purdue.
   L'implémentation de <acronym>SP-GiST</acronym> dans <productname>PostgreSQL</productname>
   est principalement maintenue par Teodor Sigaev et Oleg Bartunov, plus
   d'informations sont disponibles sur leur
   <!-- URL will be changed -->
   <ulink url="http://www.sai.msu.su/~megera/wiki/spgist_dev">site web</ulink>.
  </para>

 </sect1>

 <sect1 id="spgist-builtin-opclasses">
  <title>Classes d'opérateur internes</title>

  <para>
   La distribution de <productname>PostgreSQL</productname> inclut les classes
   d'opérateur <acronym>SP-GiST</acronym> indiquées dans <xref
   linkend="spgist-builtin-opclasses-table"/>.
  </para>

  <table id="spgist-builtin-opclasses-table">
   <title>Classes d'opérateur <acronym>SP-GiST</acronym> internes</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Opérateurs indexables</entry>
      <entry>Opérateurs d'ordre</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry valign="middle" morerows="11"><literal>box_ops</literal></entry>
      <entry><literal>&lt;&lt; (box,box)</literal></entry>
      <entry valign="middle" morerows="11"><literal>&lt;-&gt; (box,point)</literal></entry>
     </row>
     <row><entry><literal>&amp;&lt; (box,box)</literal></entry></row>
     <row><entry><literal>&amp;&gt; (box,box)</literal></entry></row>
     <row><entry><literal>&gt;&gt; (box,box)</literal></entry></row>
     <row><entry><literal>&lt;@ (box,box)</literal></entry></row>
     <row><entry><literal>@&gt; (box,box)</literal></entry></row>
     <row><entry><literal>~= (box,box)</literal></entry></row>
     <row><entry><literal>&amp;&amp; (box,box)</literal></entry></row>
     <row><entry><literal>&lt;&lt;| (box,box)</literal></entry></row>
     <row><entry><literal>&amp;&lt;| (box,box)</literal></entry></row>
     <row><entry><literal>|&amp;&gt; (box,box)</literal></entry></row>
     <row><entry><literal>|&gt;&gt; (box,box)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="10"><literal>inet_ops</literal></entry>
      <entry><literal>&lt;&lt; (inet,inet)</literal></entry>
      <entry valign="middle" morerows="10"></entry>
     </row>
     <row><entry><literal>&lt;&lt;= (inet,inet)</literal></entry></row>
     <row><entry><literal>&gt;&gt; (inet,inet)</literal></entry></row>
     <row><entry><literal>&gt;&gt;= (inet,inet)</literal></entry></row>
     <row><entry><literal>= (inet,inet)</literal></entry></row>
     <row><entry><literal>&lt;&gt; (inet,inet)</literal></entry></row>
     <row><entry><literal>&lt; (inet,inet)</literal></entry></row>
     <row><entry><literal>&lt;= (inet,inet)</literal></entry></row>
     <row><entry><literal>&gt; (inet,inet)</literal></entry></row>
     <row><entry><literal>&gt;= (inet,inet)</literal></entry></row>
     <row><entry><literal>&amp;&amp; (inet,inet)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="5"><literal>kd_point_ops</literal></entry>
      <entry><literal>|&gt;&gt; (point,point)</literal></entry>
      <entry valign="middle" morerows="5"><literal>&lt;-&gt; (point,point)</literal></entry>
     </row>
     <row><entry><literal>&lt;&lt; (point,point)</literal></entry></row>
     <row><entry><literal>&gt;&gt; (point,point)</literal></entry></row>
     <row><entry><literal>&lt;&lt;| (point,point)</literal></entry></row>
     <row><entry><literal>~= (point,point)</literal></entry></row>
     <row><entry><literal>&lt;@ (point,box)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="11"><literal>poly_ops</literal></entry>
      <entry><literal>&lt;&lt; (polygon,polygon)</literal></entry>
      <entry valign="middle" morerows="11"><literal>&lt;-&gt; (polygon,point)</literal></entry>
     </row>
     <row><entry><literal>&amp;&lt; (polygon,polygon)</literal></entry></row>
     <row><entry><literal>&amp;&gt; (polygon,polygon)</literal></entry></row>
     <row><entry><literal>&gt;&gt; (polygon,polygon)</literal></entry></row>
     <row><entry><literal>&lt;@ (polygon,polygon)</literal></entry></row>
     <row><entry><literal>@&gt; (polygon,polygon)</literal></entry></row>
     <row><entry><literal>~= (polygon,polygon)</literal></entry></row>
     <row><entry><literal>&amp;&amp; (polygon,polygon)</literal></entry></row>
     <row><entry><literal>&lt;&lt;| (polygon,polygon)</literal></entry></row>
     <row><entry><literal>&amp;&lt;| (polygon,polygon)</literal></entry></row>
     <row><entry><literal>|&gt;&gt; (polygon,polygon)</literal></entry></row>
     <row><entry><literal>|&amp;&gt; (polygon,polygon)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="5"><literal>quad_point_ops</literal></entry>
      <entry><literal>|&gt;&gt; (point,point)</literal></entry>
      <entry valign="middle" morerows="5"><literal>&lt;-&gt; (point,point)</literal></entry>
     </row>
     <row><entry><literal>&lt;&lt; (point,point)</literal></entry></row>
     <row><entry><literal>&gt;&gt; (point,point)</literal></entry></row>
     <row><entry><literal>&lt;&lt;| (point,point)</literal></entry></row>
     <row><entry><literal>~= (point,point)</literal></entry></row>
     <row><entry><literal>&lt;@ (point,box)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="9"><literal>range_ops</literal></entry>
      <entry><literal>= (anyrange,anyrange)</literal></entry>
      <entry valign="middle" morerows="9"></entry>
     </row>
     <row><entry><literal>&amp;&amp; (anyrange,anyrange)</literal></entry></row>
     <row><entry><literal>@&gt; (anyrange,anyelement)</literal></entry></row>
     <row><entry><literal>@&gt; (anyrange,anyrange)</literal></entry></row>
     <row><entry><literal>&lt;@ (anyrange,anyrange)</literal></entry></row>
     <row><entry><literal>&lt;&lt; (anyrange,anyrange)</literal></entry></row>
     <row><entry><literal>&gt;&gt; (anyrange,anyrange)</literal></entry></row>
     <row><entry><literal>&amp;&lt; (anyrange,anyrange)</literal></entry></row>
     <row><entry><literal>&amp;&gt; (anyrange,anyrange)</literal></entry></row>
     <row><entry><literal>-|- (anyrange,anyrange)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="9"><literal>text_ops</literal></entry>
      <entry><literal>= (text,text)</literal></entry>
      <entry valign="middle" morerows="9"></entry>
     </row>
     <row><entry><literal>&lt; (text,text)</literal></entry></row>
     <row><entry><literal>&lt;= (text,text)</literal></entry></row>
     <row><entry><literal>&gt; (text,text)</literal></entry></row>
     <row><entry><literal>&gt;= (text,text)</literal></entry></row>
     <row><entry><literal>~&lt;~ (text,text)</literal></entry></row>
     <row><entry><literal>~&lt;=~ (text,text)</literal></entry></row>
     <row><entry><literal>~&gt;=~ (text,text)</literal></entry></row>
     <row><entry><literal>~&gt;~ (text,text)</literal></entry></row>
     <row><entry><literal>^@ (text,text)</literal></entry></row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Sur les deux classes d'opérateurs pour le type <type>point</type>,
   <literal>quad_point_ops</literal> est celui par défaut.
   <literal>kd_point_ops</literal> gère les mêmes opérateurs mais utilise une
   structure de données différente pour l'index, structure pouvant offrir de
   meilleures performances pour certaines utilisations.
  </para>

  <para>
   Les classes d'opérateurs <literal>quad_point_ops</literal>,
   <literal>kd_point_ops</literal> et <literal>poly_ops</literal> supportent
   l'ordre d'opérateur <literal>&lt;-&gt;</literal>, qui active la recherche de
   type voisin-le-plus-proche (<literal>k-NN</literal>) sur des ensembles de
   données composés de point ou polygon.
  </para>

 </sect1>

 <sect1 id="spgist-extensibility">
  <title>Extensibilité</title>

  <para>
   <acronym>SP-GiST</acronym> offre une interface avec un haut niveau d'abstraction,
   imposant au développeur des méthodes d'accès de n'implémenter que des méthodes
   spécifiques à un type de donnée spécifié. Le cœur de <acronym>SP-GiST</acronym>
   est responsable de l'efficacité du stockage sur le disque et de la recherche
   dans la structure arborescente. Il s'occupe aussi de la concurrence d'accès
   et des journaux.
  </para>

  <para>
   Les lignes des feuilles d'un arbre <acronym>SP-GiST</acronym> contiennent
   habituellement des valeurs du même type de données que la colonne indexée,
   bien qu'il soit possible qu'ils contiennent des représentations à perte de
   la colonne indexée. Les enregistrements des feuilles stockés à la racine
   représenteront directement la valeur originale de la donnée indexée, mais
   les enregistrements des feuilles à des niveaux plus bas pourraient ne contenir
   qu'une valeur partielle, telle qu'un suffixe. Dans ce cas, les
   classes d'opérateurs des fonctions supportées devront être capables de
   reconstruire la valeur originale en utilisant les informations accumulées
   dans les lignes intermédiaires au travers du parcours de l'arbre et vers
   le niveau le plus bas.
  </para>

  <para>
   Quand un index <acronym>SP-GiST</acronym> est créé avec des colonnes
   <literal>INCLUDE</literal>, les valeurs de ces colonnes sont aussi
   stockées dans des enregistrements feuilles. Les colonnes
   <literal>INCLUDE</literal> ne concernent pas la classe d'opérateurs
   <acronym>SP-GiST</acronym>, donc elles ne seront pas discutées avec plus
   de détails ici.
  </para>

  <para>
   Les lignes internes sont plus complexes car elles relient des points
   dans l'arbre de recherche. Chaque ligne intermédiaire contient un ensemble
   d'au moins un <firstterm>nœud</firstterm>, qui représente des groupes
   de valeurs similaires de feuilles. Un nœud contient un lien qui mène
   vers un autre nœud de niveau inférieur, ou une petite liste de lignes de
   feuilles qui appartiennent toutes à la même page d'index.
   Chaque nœud a un <firstterm>label</firstterm> qui le décrit. Par exemple,
   dans un arbre <foreignphrase>radix</foreignphrase>, le label du nœud
   peut être le caractère suivant de la chaîne de caractère. (Sinon, une
   classe d'opérateurs peut omettre les labels des nœuds si elle
   fonctionne avec un ensemble fixe de nœuds pour les enregistrements
   internes&nbsp;; voir <xref linkend ="spgist-null-labels"/>.) En option, une
   ligne intermédiaire peut avoir une valeur
   de <firstterm>préfixe</firstterm> qui décrit tous ses membres. Dans un arbre
   <foreignphrase>radix</foreignphrase>, cela peut être le préfixe commun des chaînes représentant les données.
   La valeur du préfixe n'est pas nécessairement réellement un préfixe, mais peut
   être toute donnée utilisée par la classe d'opérateurs. Par exemple, pour un
   <foreignphrase>quadtree</foreignphrase>, il peut stocker le barycentre des
   quatre points représenté par chaque feuille. Une ligne intermédiaire d'un
   <foreignphrase>quadtree</foreignphrase> contiendra aussi quatre nœuds correspondants
   à des points autour de ce point central.
  </para>

  <para>
   Quelques algorithmes de recherche arborescente nécessite la connaissance
   du niveau (ou profondeur) de la ligne en cours, et ainsi le cœur de
   <acronym>SP-GiST</acronym> fournit aux classes d'opérateurs la possibilité
   de gérer le décompte des niveaux lors du parcours de l'arbre.
   Il fournit aussi le moyen de reconstruire de façon incrémentale la valeur
   représentée lorsque cela est nécessaire, et pour passer des données
   supplémentaires (appelées <firstterm>valeurs traverses</firstterm>) lors de
   la descente de l'arbre.
  </para>

  <note>
   <para>
    Le code du cœur de <acronym>SP-GiST</acronym> tient aussi compte
    des valeurs NULL. Bien que les index <acronym>SP-GiST</acronym>
    stockent des entrées pour les valeurs NULL dans les colonnes indexées,
    cette implémentation reste non apparente au code de l'index de classe
    d'opérateur : aucune valeur NULL d'index ou de condition de recherche ne sera
    jamais transmis aux méthodes de la classe d'opérateurs (il est convenu
    que les opérateurs <acronym>SP-GiST</acronym> sont stricts et ainsi
    ne peuvent trouver des valeurs NULL). Le cas des valeurs NULL n'est
    ainsi plus abordé dans les paragraphes qui suivent.
   </para>
  </note>

  <para>
   Un index de classe d'opérateurs pour <acronym>SP-GiST</acronym> peut
   proposer cinq méthodes personnalisées, et deux optionnelles. Chacune de ces
   cinq méthodes obligatoires doit suivre la convention qui consiste à
   accepter deux arguments de type <type>internal</type>, le premier étant un
   pointeur vers une structure C contenant les valeurs en entrée de cette
   méthode, et le second étant un pointeur vers une structure C où les valeurs
   en sortie seront placées. Quatre de ces méthodes retournent
   <type>void</type> car leurs résultats sont présents dans la structure en
   sortie. Mais la méthode <function>leaf_consistent</function> retourne
   une valeur de type <type>boolean</type>. Les méthodes ne doivent
   modifier aucun des champs de la structure en entrée. Dans tous les cas, la
   structure en sortie est initialisée avec des zéros avant l'appel à la
   méthode personnalisée. La sixième méthode, optionnelle,
   <function>compress</function> accepte un <type>datum</type> à indexer
   comme seul argument et renvoie une valeur convenable pour un enregistrement
   physique dans une ligne feuille. La septième méthode, optionnelle, est
   appelée <function>options</function> et accepte un pointeur
   <type>internal</type> vers une structure C, remplie avec les paramètres
   spécifiques à la classe d'opérateurs, et renvoie <type>void</type>.
  </para>

  <para>
   Les cinq méthodes personnalisées sont&nbsp;:
  </para>

  <variablelist>
   <varlistentry>
    <term><function>config</function></term>
    <listitem>
     <para>
      Retourne des informations statiques concernant l'implémentation des index,
      incluant les OID du type de données du préfixe et le type de données
      du label du nœud.
     </para>
     <para>
      La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à&nbsp;:
      <programlisting>
CREATE FUNCTION ma_configuration(internal, internal) RETURNS void ...
      </programlisting>
      Le premier argument est un pointeur vers une structure C <structname>spgConfigIn</structname>,
      qui contient les données en entrée de la fonction.
      Le second argument est un pointeur vers une structure C <structname>spgConfigOut</structname>,
      qui permet à la fonction d'y spécifier les données en sortie.
      <programlisting>
typedef struct spgConfigIn
{
    Oid         attType;        /* Le type de donnée à indexer */
} spgConfigIn;

typedef struct spgConfigOut
{
    Oid         prefixType;     /* Le type de donnée des préfixe des tuples intermédiaires */
    Oid         labelType;      /* Le type de donnée des labels de nœud des tuples intermédiaires */
    Oid         leafType;       /* Type de données pour les valeurs de tuple feuille */
    bool        canReturnData;  /* Opclass peut reconstruire les données originales */
    bool        longValuesOK;   /* Opclass sait gérer les valeurs plus grandes qu'une page */
} spgConfigOut;
      </programlisting>

      <structfield>attType</structfield> est fourni pour gérer les index polymorphiques
      de classe d'opérateurs. Pour les types de données ordinaires de classe d'opérateurs (fixés),
      il aura toujours la même valeur et peut ainsi être ignoré.
     </para>

     <para>
      Pour les classes d'opérateurs qui n'utilisent pas de préfixe,
      <structfield>prefixType</structfield> peut être défini à <literal>VOIDOID</literal>.
      De la même façon, pour les classes d'opérateurs qui n'utilisent pas de label de nœud,
      <structfield>labelType</structfield> peut être défini à <literal>VOIDOID</literal>.
      <structfield>canReturnData</structfield> peut être défini à true si la classe d'opérateurs
      est capable de reconstruire la valeur d'index fournie initialement.
      <structfield>longValuesOK</structfield> doit être défini à true uniquement lorsque
      <structfield>attType</structfield> est de longueur variable et que la classe
      d'opérateur est capable de segmenter les grandes valeurs en répétant les suffixes
      (voir <xref linkend="spgist-limits"/>).
     </para>

     <para>
      <structfield>leafType</structfield> doit correspondre au type de
      stockage de l'index défini par l'entrée de catalogue
      <structfield>opckeytype</structfield> de la classe d'opérateurs.
      (Notez que <structfield>opckeytype</structfield> peut valoir zéro,
      impliquant que le type de stockage est le même que le type en entrée de
      la classe d'opérateurs, ce qui est la situation la plus commune.) Pour
      des raisons de compatibilité ascendante, la méthode
      <function>config</function> peut configurer
      <structfield>leafType</structfield> à toute autre valeur, et cette
      valeur sera utilisée&nbsp;; mais ceci est abandonné car le contenu de
      l'index est alors incorrectement identifié dans les catalogues. De
      plus, il est autorisé de laisser leave
      <structfield>leafType</structfield> non initialisé (zéro)&nbsp;; ceci
      est interprété comme signifiant que le type de stockage de l'index est
      dérivé de <structfield>opckeytype</structfield>.
     </para>

     <para>
      Quand <structfield>attType</structfield> et
      <structfield>leafType</structfield> sont différents, alors la méthode
      optionnelle <function>compress</function> doit être fournie. La méthode
      <function>compress</function> est responsable de la transformation des
      datums pour les indexer de <structfield>attType</structfield> vers
      <structfield>leafType</structfield>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>choose</function></term>
    <listitem>
     <para>
      Choisit une méthode pour insérer une nouvelle valeur dans une ligne intermédiaire.
     </para>

     <para>
      La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à&nbsp;:
      <programlisting>
CREATE FUNCTION mon_choix(internal, internal) RETURNS void ...
      </programlisting>
      Le premier argument est un pointeur vers une structure C <structname>spgChooseIn</structname>,
      qui contient les données en entrée de la fonction.
      Le second argument est un pointeur vers une structure C <structname>spgChooseOut</structname>,
      qui permet à la fonction d'y spécifier les données en sortie.
      <programlisting>
typedef struct spgChooseIn
{
    Datum       datum;          /* donnée initiale à indexer */
    Datum       leafDatum;      /* donnée en cours à stocker dans la feuille */
    int         level;          /* niveau en cours (à partir de 0) */

    /* Données issues de la ligne intermédiaire */
    bool        allTheSame;     /* la ligne contient des valeurs équivalentes ? */
    bool        hasPrefix;      /* la ligne a-t-elle un préfixe? */
    Datum       prefixDatum;    /* si c'est le cas, la valeur de ce préfixe */
    int         nNodes;         /* nombre de nœuds dans la ligne intermédiaire */
    Datum      *nodeLabels;     /* valeurs du label du nœud (NULL sinon) */
} spgChooseIn;

typedef enum spgChooseResultType
{
    spgMatchNode = 1,           /* descend dans le nœud existant */
    spgAddNode,                 /* ajoute un nœud dans la ligne intermédiaire */
    spgSplitTuple               /* scinde une ligne intermédiaire (modifie son préfixe) */
} spgChooseResultType;

typedef struct spgChooseOut
{
    spgChooseResultType resultType;     /* code d'action, voir plus bas */
    union
    {
        struct                  /* resultats de spgMatchNode */
        {
            int         nodeN;      /* descend dans ce nœud (à partir de 0) */
            int         levelAdd;   /* incrémente le niveau de cette valeur */
            Datum       restDatum;  /* nouvelle valeur de la feuille */
        }           matchNode;
        struct                  /* résultats de spgAddNode */
        {
            Datum       nodeLabel;  /* nouveau label du nœud */
            int         nodeN;      /* là où l'insérer (à partir de 0) */
        }           addNode;
        struct                  /* résultats pour spgSplitTuple */
        {
	    /* Information pour former une ligne de niveau supérieur avec un nœud fils */
            bool        prefixHasPrefix;    /* la ligne doit-elle avoir un préfixe ? */
            Datum       prefixPrefixDatum;  /* si oui, sa valeur */
            int         prefixNNodes;       /* nombre de nœuds */
            Datum      *prefixNodeLabels;   /* leurs labels (ou NULL si
                                             * aucun label) */
            int         childNodeN;         /* quel nœud a un nœud fils */

            /* Informations pour former une nouvelle ligne intermédaire de niveau inférieur
			à partir de tous les anciens nœuds */
            bool        postfixHasPrefix;   /* la ligne doit-elle avoir un préfixe ? */
            Datum       postfixPrefixDatum; /* si oui, sa valeur */
        }           splitTuple;
    }           result;
} spgChooseOut;
      </programlisting>

      <structfield>datum</structfield> est la valeur initiale de type
      <structname>spgConfigIn</structname>.<structfield>attType</structfield>
      de la donnée qui a été insérée dans l'index.
      <structfield>leafDatum</structfield> est une valeur de type
      <structname>spgConfigOut</structname>.<structfield>leafType</structfield>
      qui est initialement un résultat de la méthode
      <function>compress</function> appliquée à <structfield>datum</structfield>
      quand la méthode <function>compress</function> est fournie, ou la même valeur que
      <structfield>datum</structfield> dans le cas contraire.
      <structfield>leafDatum</structfield> peut changer à des niveaux inférieurs de l'arbre
      si la fonction <function>choose</function> ou <function>picksplit</function>
      change cette valeur. Lorsque la recherche liée à l'insertion atteint une feuille,
      la valeur actuelle de <structfield>leafDatum</structfield> sera stockée
      dans la nouvelle ligne de feuille créée.
      <structfield>level</structfield> est le niveau actuel de la ligne
      intermédiaire, en considérant que 0 est le niveau racine.
      <structfield>allTheSame</structfield> est true si la ligne intermédiaire
      actuelle est marquée comme contenant plusieurs nœuds équivalents.
      (voir <xref linkend="spgist-all-the-same"/>).
      <structfield>hasPrefix</structfield> est vrai si la ligne intermédiaire
      actuelle contient un préfixe&nbsp;; si c'est le cas,
      <structfield>prefixDatum</structfield> est sa valeur.
      <structfield>nNodes</structfield> est le nombre de nœuds enfants contenus
      dans la ligne intermédiaire, et <structfield>nodeLabels</structfield> est
      un tableau des valeurs de leurs labels, ou NULL s'il n'y a pas de labels.
     </para>

     <para>
      La fonction <function>choose</function> peut déterminer si la nouvelle
      valeur correspond à un des nœuds enfants existants, ou si un nouvel
      enfant doit être ajouté, ou si la nouvelle valeur n'est pas consistante
      avec les préfixes de ligne et qu'ainsi la ligne intermédiaire doit être
      découpée pour créer un préfixe moins restrictif.
     </para>

     <para>
      Si la nouvelle valeur correspond à un des nœuds enfants existants,
      définir <structfield>resultType</structfield> à <literal>spgMatchNode</literal>.
      et définir <structfield>nodeN</structfield> à l'index (à partir de 0) du nœud dans
      le tableau de nœud.
      Définir <structfield>levelAdd</structfield> à l'incrément de
      <structfield>level</structfield> nécessaire pour descendre au travers de ce nœud,
      ou le laisser à 0 si la classe d'opérateurs n'utilise pas de niveaux.
      Définir <structfield>restDatum</structfield> à la valeur de <structfield>leafDatum</structfield>
      si la classe d'opérateurs ne modifie pas les valeurs d'un niveau au suivant,
      ou dans le cas contraire, définir la valeur modifiée pour être utilisée comme
      valeur de <structfield>leafDatum</structfield> au niveau suivant.
     </para>

     <para>
      Si un nouveau nœud enfant doit être ajouté,
      définir <structfield>resultType</structfield> à <literal>spgAddNode</literal>.
      Définir <structfield>nodeLabel</structfield> au label à utiliser pour le nouveau nœud,
      et définir <structfield>nodeN</structfield> à l'index (de 0) auquel insérer
      le nœud dans le tableau de nœud.
      Après que ce nœud a été ajouté, la fonction <function>choose</function>
      sera appelée à nouveau avec la ligne intermédiaire modifiée.
      Cet appel devrait produire un résultat <literal>spgMatchNode</literal>.
     </para>

     <para>
      Si la nouvelle valeur est cohérente avec le préfixe de ligne,
      définir <structfield>resultType</structfield> à <literal>spgSplitTuple</literal>.
      Cette action déplace tous les nœuds existants dans le nouveau niveau inférieur
      de la ligne intermédiaire, et remplace la ligne intermédiaire existant avec une ligne
      qui dispose d'un unique nœud qui est lié à la nouvelle ligne intermédiaire de niveau inférieur.
      Définir <structfield>prefixHasPrefix</structfield> pour indiquer si les nouvelles lignes
      supérieures doivent avoir un préfixe, et si c'est le cas, définir
      <structfield>prefixPrefixDatum</structfield> à la valeur du préfixe. Cette nouvelle
      valeur de préfixe doit être suffisamment moins restrictive que l'original pour accepter
      que la nouvelle valeur soit indexée.

      Définir <structfield>prefixNNodes</structfield> au nombre de nœuds
      nécessaires pour la nouvelle ligne et définir <structfield>prefixNodeLabels</structfield>
      à un tableau alloué avec palloc de leurs labels, ou à NULL si les labels
      des nœuds ne sont pas nécessaires. Noter que la taille totale de la nouvelle
      ligne supérieure ne doit pas dépasser la taille totale de la ligne qu'elle remplace&nbsp;;
      cela contraint les longueurs des nouveaux préfixes et labels. 
      Définir <structfield>postfixHasPrefix</structfield> pour indiquer si la nouvelle
      ligne intermédiaire de niveau inférieur aura un préfixe, et dans ce cas définir
      <structfield>postfixPrefixDatum</structfield> à la valeur du préfixe. La 
      combinaison de ces deux préfixes et le label additionnel doit
      avoir la même signification que le préfixe original car il n'y a pas de moyen
      de modifier le label du nœud qui est déplacé vers la nouvelle ligne de niveau inférieur,
      ni de modifier une quelconque entrée d'index enfant.
      Après que ce nœud ait été découpé, la fonction <function>choose</function>
      sera appelée à nouveau avec la ligne intermédiaire de remplacement.
      Cet appel devrait retourner un <literal>spgAddNode</literal> car,
      à priori, le label du nœud ajouté lors de l'étape de découpage ne correspondra
      pas à la nouvelle valeur. Ainsi, après cette étape, il y aura une troisième étape
      qui retournera finalement <literal>spgMatchNode</literal> et permettra l'insertion
      pour descendre au niveau feuille.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>picksplit</function></term>
    <listitem>
     <para>
      Décide de la manière à suivre pour créer une ligne intermédiaire à partir d'un ensemble de lignes de feuilles.
     </para>

     <para>
      La déclaration de fonction <acronym>SQL</acronym> doit ressembler à&nbsp;:
      <programlisting>
CREATE FUNCTION mon_decoupage(internal, internal) RETURNS void ...
      </programlisting>
      Le premier argument est un pointeur vers une structure C <structname>spgPickSplitIn</structname>,
      qui contient les données en entrée de la fonction.
      Le second argument est un pointeur vers une structure C <structname>spgPickSplitOut</structname>,
      qui permet à la fonction d'y spécifier les données en sortie.
      <programlisting>
typedef struct spgPickSplitIn
{
    int         nTuples;        /* nombre de lignes feuilles */
    Datum      *datums;         /* leur données (tableau de taille nTuples) */
    int         level;          /* niveau actuel (à partir de 0) */
} spgPickSplitIn;

typedef struct spgPickSplitOut
{
    bool        hasPrefix;      /* les nouvelles lignes intermédiaires doivent-elles avoir un préfixe ? */
    Datum       prefixDatum;    /* si oui, la valeur du préfixe */

    int         nNodes;         /* nombre de nœud pour une nouvelle ligne intermédiaire */
    Datum      *nodeLabels;     /* leurs labels (ou NULL s'il n'y a aucun label) */

    int        *mapTuplesToNodes;   /* index du nœud de chaque ligne feuille */
    Datum      *leafTupleDatums;    /* données à stocker dans chaque nouvelle ligne feuille */
} spgPickSplitOut;
      </programlisting>

      <structfield>nTuples</structfield> est le nombre de lignes feuilles fournies.
      <structfield>datums</structfield> est un tableau de leurs données de type
      <structname>spgConfigOut</structname>.<structfield>leafType</structfield>.
      <structfield>level</structfield> est le niveau actuel que les lignes feuille concernées
      partagent, qui deviendra le niveau de la nouvelle ligne intermédiaire.
     </para>

     <para>
      Définir <structfield>hasPrefix</structfield> pour indiquer que la nouvelle ligne intermédiaire
      doit avoir un préfixe, et dans ce cas, définir <structfield>prefixDatum</structfield>
      à la valeur de ce préfixe.
      Définir <structfield>nNodes</structfield> pour indiquer le nombre de nœuds que contiendra
      la nouvelle ligne intermédiaire, et
      spécifier dans <structfield>nodeLabels</structfield> un tableau de leurs labels,
      ou NULL si les labels ne sont pas nécessaires.
      Attribuer à <structfield>mapTuplesToNodes</structfield> un tableau des index (à partir de zéro)
      des nœuds auxquels seront assignés chaque ligne feuille.
      Attribuer à <structfield>leafTupleDatums</structfield> un tableau des valeurs à
      stocker dans la nouvelle ligne de feuilles (ces valeurs seront les mêmes que celles des données
      <structfield>datums</structfield> fournies en paramètre si la classe d'opérateurs ne modifie
      pas les données d'un niveau à un autre).
      À noter que la fonction <function>picksplit</function> est responsable de l'allocation de mémoire
      des tableaux <structfield>nodeLabels</structfield>, <structfield>mapTuplesToNodes</structfield> et
      <structfield>leafTupleDatums</structfield>.
     </para>

     <para>
      Si plus d'une ligne de feuille est fournie, il est nécessaire que la fonction
      <function>picksplit</function> les classent en plus d'un nœud.
      Dans le cas contraire, il ne sera pas possible de répartir les lignes des feuilles
      sur des pages différentes, ce qui est pourtant l'objectif de cette opération.
      À cet effet, si la fonction <function>picksplit</function> se termine après avoir
      réparti toutes les lignes des feuilles dans le même nœud, le code du moteur de
      SP-GiST ne tiendra pas compte de cette décision, et générera une ligne intermédiaire
      dans lequel chaque ligne de feuille sera assigné aléatoirement à plusieurs nœuds
      de labels identiques. De telles lignes sont marquées <literal>allTheSame</literal> pour
      garder une trace de cette décision. Les fonctions <function>choose</function> et
      <function>inner_consistent</function> doivent tenir compte de ces lignes
      intermédiaires.
      Voir <xref linkend="spgist-all-the-same"/> pour plus d'informations.
     </para>

     <para>
      <function>picksplit</function> peut être appliqué à une unique ligne de feuille
      lorsque la fonction <function>config</function> définit <structfield>longValuesOK</structfield>
      à true et qu'une valeur plus large qu'une page est donnée en paramètre.
      Dans ce cas, l'objectif de la fonction est d'extraire un préfixe et de produire
      une donnée de feuille moins longue. Cet appel sera répété jusqu'à ce que la donnée
      de la feuille soit suffisamment petite pour tenir dans une page. Voir
      <xref linkend="spgist-limits"/> pour plus d'information.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>inner_consistent</function></term>
    <listitem>
     <para>
      Retourne un ensemble de nœuds (branches) à suivre durant une recherche arborescente.
     </para>

     <para>
      La déclaration <acronym>SQL</acronym> de cette fonction doit ressembler à&nbsp;:
      <programlisting>
CREATE FUNCTION ma_suite_de_nœuds(internal, internal) RETURNS void ...
      </programlisting>
      Le premier argument est un pointeur vers une structure C <structname>spgInnerConsistentIn</structname>,
      qui contient les données en entrée de la fonction.
      Le second argument est un pointeur vers une structure C <structname>spgInnerConsistentOut</structname>,
      qui permet à la fonction d'y spécifier les données en sortie.

      <programlisting>
typedef struct spgInnerConsistentIn
{
    ScanKey     scankeys;       /* tableau d'opérateurs et de valeurs de comparaison */
    ScanKey     orderbys;       /* tableau d'opérateurs de tri et comparaison */
                                 * de valeur */
    int         nkeys;          /* taille du tableau scankeys */
    int         norderbys;      /* taille du tableau orderbys */

    Datum       reconstructedValue;     /* valeur reconstruite au niveau parent */
    MemoryContext traversalMemoryContext;   /* placer les nouvelles valeurs ici */
    int         level;          /* niveau actuel (à partir de zéro) */
    bool        returnData;     /* retourner la valeur originale ? */

    /* Données du tuple intermédiaire en cours */
    bool        allTheSame;     /* la ligne est-elle identifiée comme all-the-same ? */
    bool        hasPrefix;      /* la ligne a-t-elle un préfixe ? */
    Datum       prefixDatum;    /* dans ce cas, la valeur du préfixe */
    int         nNodes;         /* nombre de nœuds dans la ligne intermédiaire */
    Datum      *nodeLabels;     /* labels du nœud (NULL si pas de labels) */
    void      **traversalValues;        /* valeurs traverses spécifiques de la classe d'opérateurs */
    double    **distances;              /* distances associées */
} spgInnerConsistentIn;

typedef struct spgInnerConsistentOut
{
    int         nNodes;         /* nombre de nœuds enfants à visiter */
    int        *nodeNumbers;    /* leurs index dans le tableau de nœuds */
    int        *levelAdds;      /* l'incrément à apporter au niveau pour chaque enfant */
    Datum      *reconstructedValues;    /* valeurs reconstruites associées */
} spgInnerConsistentOut;
      </programlisting>

      Le tableau <structfield>scankeys</structfield>, de longueur <structfield>nkeys</structfield>,
      décrit les conditions de recherche d'index. Ces conditions sont combinées avec un opérateur
      et seules les entrées d'index qui correspondent à toutes ces conditions sont conservées
      (à noter que <structfield>nkeys</structfield> = 0 implique que toutes les entrées d'index sont
      conservées). Généralement, la fonction <function>inner_consistent</function> ne tient compte que
      des champs <structfield>sk_strategy</structfield> et <structfield>sk_argument</structfield>
      de chaque entrée de tableau, qui fournissent respectivement l'opérateur indexé et la valeur de comparaison.
      En particulier, il n'est pas nécessaire de vérifier si <structfield>sk_flags</structfield> est NULL
      car le moteur de SP-GiST aura complété cette valeur.
      Le tableau <structfield>orderbys</structfield>, de longueur <structfield>norderbys</structfield>,
      décrit les opérateurs de tri (s'il y en a) de la même manière.
      <structfield>reconstructedValue</structfield> est la valeur reconstruite pour la ligne parent.
      La valeur est <literal>(Datum) 0</literal> au niveau le plus haut ou si la fonction
      <function>inner_consistent</function> ne fournit pas de valeur pour le
      niveau supérieur.
      <structfield>traversalValue</structfield> est un
      pointer vers toute donnée traverse passée à l'appel précédent de
      <function>inner_consistent</function> sur l'enregistrement parent de
      l'index, ou NULL à la racine.
      <structfield>traversalMemoryContext</structfield> est le contexte
      mémoire de stockage des valeurs traverses en sortie (voir ci-dessous).
      <structfield>level</structfield> est le niveau actuel de la ligne intermédiaire, en commençant à 0 pour le niveau racine.
      <structfield>returnData</structfield> est <literal>true</literal> pour la valeur reconstruite pour cette requête.
      Ce n'est le cas que si la fonction <function>config</function> définit <structfield>canReturnData</structfield>.
      <structfield>allTheSame</structfield> est true si la ligne intermédiaire en cours est
      marquée <quote>all-the-same</quote>. Dans ce cas, tous les nœuds ont le même label (si un label est défini) et
      ainsi soit ils correspondent tous à la requête, soit aucun ne correspond (voir <xref linkend="spgist-all-the-same"/>).
      <structfield>hasPrefix</structfield> est true si la ligne intermédiaire en cours contient un préfixe.
      Dans ce cas, <structfield>prefixDatum</structfield> est sa valeur.
      <structfield>nNodes</structfield> est le nombre de nœuds enfants de la ligne intermédiaire, et
      <structfield>nodeLabels</structfield> est un tableau de leurs labels, ou NULL
      si les nœuds n'ont pas de labels.
     </para>

     <para>
      <structfield>nNodes</structfield> doit être défini comme le nombre de
      nœuds enfants qui doivent être visités durant la recherche, et
      <structfield>nodeNumbers</structfield> doit être défini comme le
      tableau de leurs index. Si la classe d'opérateurs effectue le suivi des
      niveaux, définir <structfield>levelAdds</structfield> comme un tableau
      des incréments à ajouter aux niveaux pour descendre vers chaque nœud à
      visiter (dans la plupart des cas, les incréments seront les mêmes pour
      chaque nœud, mais ce n'est pas systématique, et ainsi un tableau est
      employé). Si la reconstruction de la valeur est nécessaire, définir
      <structfield>reconstructedValues</structfield> en un tableau des
      valeurs reconstruites pour chaque nœud enfant à visiter. Sinon, laisser
      <structfield>reconstructedValues</structfield> à la valeur NULL. Si une
      recherche triée est exécutée, initialise
      <structfield>distances</structfield> à un tableau de valeurs de
      distance suivant le tableau <structfield>orderbys</structfield>
      (les nœuds avec les plus petites distances seront traitées en premier).
      Laisse NULL sinon. Les valeurs reconstruites sont supposées être de
      type
      <structname>spgConfigOut</structname>.<structfield>leafType</structfield>.
      (Néanmoins, comme le coeur du système ne fera rien avec elles sauf
      potentiellementles copier, il est suffisant qu'elles aient les mêmes
      propriétés <literal>typlen</literal> et <literal>typbyval</literal> que
      <structfield>leafType</structfield>.) S'il est souhaitable de passer
      les informations supplémentaires hors bande
      (<quote>valeurs traverses</quote>) pour diminuer les niveaux de l'arbre
      de recherche, initialiser <structfield>traversalValues</structfield> en
      un tableau des valeurs traverses appropriées, un pour chaque nœud
      enfants à visiter&nbsp;; sinon laisser
      <structfield>traversalValues</structfield> à NULL. Notez que la
      fonction <function>inner_consistent</function> est responsable de
      l'allocation mémoire des tableaux
      <structfield>nodeNumbers</structfield>,
      <structfield>levelAdds</structfield>,
      <structfield>distances</structfield>,
      <structfield>reconstructedValues</structfield> et
      <structfield>traversalValues</structfield> dans le contexte mémoire
      actuel. Néanmoins, toute valeur traverse en sortie pointée par le
      tableau <structfield>traversalValues</structfield> devrait être allouée
      dans <structfield>traversalMemoryContext</structfield>. Chaque valeur
      traverse doit être un morceau simple alloué avec la fonction palloc.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>leaf_consistent</function></term>
    <listitem>
     <para>
      Retourne true si une ligne de feuille satisfait une requête.
     </para>

     <para>
      La déclaration <acronym>SQL</acronym> de cette fonction doit ressembler à&nbsp;:
      <programlisting>
CREATE FUNCTION ma_fonction_leaf_consistent(internal, internal) RETURNS bool ...
      </programlisting>
      Le premier argument est un pointeur vers une structure C <structname>spgLeafConsistentIn</structname>,
      qui contient les données en entrée de la fonction.
      Le second argument est un pointeur vers une structure C <structname>spgLeafConsistentOut</structname>,
      qui permet à la fonction d'y spécifier les données en sortie.

      <programlisting>
typedef struct spgLeafConsistentIn
{
    ScanKey     scankeys;       /* tableau d'opérateurs et de valeurs de comparaison */
    ScanKey     orderbys;       /* tableau d'opérateurs de tri et comparaison */
                                 * de valeurs */
    int         nkeys;          /* taille du tableau scankeys */
    int         norderbys;      /* taille du tableau orderbys */

    Datum       reconstructedValue;     /* valeur reconstruite au parent */
    void       *traversalValue; /* valeur traverse spécifique à la classe d'opérateurs */
    int         level;          /* niveau actuel (à partir de zéro) */
    bool        returnData;     /* les données originales doivent-elles être reconstruites ? */

    Datum       leafDatum;      /* données de la ligne de feuille */
} spgLeafConsistentIn;

typedef struct spgLeafConsistentOut
{
    Datum       leafValue;      /* données originales reconstruites, le cas échéant */
    bool        recheck;        /* définir à true si l'opérateur doit être revérifié */
    Datum       leafValue;        /* valeur d'origine reconstruite, le cas échéant */
    bool        recheck;          /* positionné à true si l'opérateur doit être revérifié */
    bool        recheckDistances; /* positionné à true si les distances doivent être revérifiées */
    double     *distances;        /* associated distances */
} spgLeafConsistentOut;
      </programlisting>

      Le tableau <structfield>scankeys</structfield>, de longueur <structfield>nkeys</structfield>,
      décrit les conditions de recherche dans l'index. Ces conditions sont uniquement combinées avec AND &mdash;
      Seules les entrées d'index qui satisfont toutes les conditions satisfont la requête
      (Notez que <structfield>nkeys</structfield> = 0 implique que toutes les entrées de l'index satisfont la requête).
      Généralement, la fonction de recherche ne tient compte que des champs <structfield>sk_strategy</structfield> et
      <structfield>sk_argument</structfield> de chaque entrée du tableau, qui correspondent
      respectivement à l'opérateur indexable et à la valeur de comparaison.
      En particulier, il n'est pas nécessaire de vérifier <structfield>sk_flags</structfield> pour
      savoir que la valeur de comparaison est NULL car le code du cœur de SP-GiST filtre
      ces conditions.
      Le tableau <structfield>orderbys</structfield>, de taille <structfield>norderbys</structfield>,
      décrit les opérateurs de tri de la même manière.
      <structfield>reconstructedValue</structfield> est la valeur reconstruite pour la ligne parent&nbsp;;
      Il s'agit de <literal>(Datum) 0</literal> au niveau racine ou si la fonction
      <function>inner_consistent</function> ne fournit pas de valeur au niveau parent.
      <structfield>traversalValue</structfield> est un pointeur vers toute
      donnée traverse passée lors de l'appel précédent à
      <function>inner_consistent</function> de l'enregistrement parent de
      l'index ou NULL à la racine.
      <structfield>level</structfield> est le niveau actuel de la ligne de feuille, qui commence à zéro
      pour le niveau racine.
      <structfield>returnData</structfield> est <literal>true</literal> s'il est nécessaire de reconstruire
      les données pour cette requête. Cela ne sera le cas que lorsque la fonction
      <function>config</function> vérifie <structfield>canReturnData</structfield>.
      <structfield>leafDatum</structfield> est la valeur de la clé stockée de
      <structname>spgConfigOut</structname>.<structfield>leafType</structfield> dans la ligne de feuille en cours.
     </para>

     <para>
      La fonction doit retourner <literal>true</literal> si la ligne de feuille correspond à la requête
      ou <literal>false</literal> sinon. Dans le cas où la valeur serait <literal>true</literal>,
      et que <structfield>returnData</structfield> est <literal>true</literal> alors
      <structfield>leafValue</structfield> doit être défini à la valeur originale, de type
      <structname>spgConfigIn</structname>.<structfield>attType</structfield> fournie
      pour être indexée pour cette ligne de feuille.
      <structfield>recheck</structfield> peut être défini à <literal>true</literal> si la correspondance
      est incertaine et ainsi l'opérateur doit être réappliqué à la pile de ligne courante
      pour vérifier la correspondance.
      Si une recherche triée est effectuée, positionne <structfield>distances</structfield>
      à un tableau de distance suivant le tableau <structfield>orderbys</structfield>
      Laisse NULL sinon. Si au moins une des distances retournées n'est pas
      exacte, positionne <structfield>recheckDistances</structfield> à true.
      Dans ce cas, l'exécuteur recalculera la distance exacte après avoir
      récupéré toutes les lignes de la table, et réordonnera les lignes si
      besoin.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Les méthodes optionnelles définies par l'utilisateur sont&nbsp;:
  </para>

  <variablelist>
   <varlistentry>
    <term><function>Datum compress(Datum in)</function></term>
    <listitem>
     <para>
      Convertit un élément de données dans un format convenable pour un
      stockage physique dans un enregistrement feuille d'un index.
      Elle accepte une valeur de type
      <structname>spgConfigIn</structname>.<structfield>attType</structfield>
      et renvoie une valeur de type
      <structname>spgConfigOut</structname>.<structfield>leafType</structfield>.
      La valeur en sortie ne doit pas contenir un pointeur TOAST hors ligne.
     </para>

     <para>
      Note&nbsp;: la méthode <function>compress</function> est seulement
      appliquée aux valeurs à enregistrer. Les méthodes cohérentes reçoivent
      les clés de parcours non modifiées, sans transformation utilisant
      <function>compress</function>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><function>options</function></term>
    <listitem>
     <para>
      Définit un ensemble de paramètres visibles aux utilisateurs qui
      contrôlent le comportement d'une classe d'opérateurs.
     </para>

     <para>
      La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
      ceci&nbsp;:

      <programlisting>
CREATE OR REPLACE FUNCTION my_options(internal)
RETURNS void
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
      </programlisting>
     </para>

     <para>
      La fonction <function>options</function> se voit donné un pointeur
      vers une structure <structname>local_relopts</structname> qui doit
      être remplie avec un ensemble d'options spécifiques à la classe
      d'opérateur. Les options peuvent être accédées à partir des autres
      fonctions de support en utilisant les macros
      <literal>PG_HAS_OPCLASS_OPTIONS()</literal> et
      <literal>PG_GET_OPCLASS_OPTIONS()</literal>.
     </para>

     <para>
      Étant donné que la représentation de la clé dans
      <acronym>SP-GiST</acronym> est flexible, elle peut dépendre de
      paramètres spécifiés par l'utilisateur.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Toutes les méthodes permettant d'utiliser SP-GiST sont normalement exécutées dans un
   contexte mémoire de courte durée, c'est-à-dire que <varname>CurrentMemoryContext</varname> sera remis à zéro
   après le traitement de chaque ligne. Il n'est cependant pas réellement important de se soucier
   de désallouer la mémoire allouée avec palloc (la méthode <function>config</function> est
   une exception&nbsp;: elle essaiera d'éviter les fuites mémoire. Mais généralement, la méthode
   <function>config</function> ne nécessite rien si ce n'est assigner des constantes
   aux structures passées en paramètre).
  </para>

  <para>
   Si la colonne indexée a un type de donnée collationnable, l'index de collationnement
   sera passé à toutes les méthodes, en utilisant le mécanisme standard
   <function>PG_GET_COLLATION()</function>.
  </para>

 </sect1>

 <sect1 id="spgist-implementation">
  <title>Implémentation</title>

  <para>
   Cette section traite des détails d'implémentation et d'autres astuces qui sont
   utiles à connaître pour implémenter des opérateurs de classe <acronym>SP-GiST</acronym>.
  </para>

  <sect2 id="spgist-limits">
   <title>Limites de SP-GiST</title>

   <para>
    Les lignes de feuille individuelles et les lignes intermédiaires doivent tenir dans une
    unique page d'index (8&nbsp;ko par défaut). Cependant, lorsque des données de taille variable
    sont indexées, les longues valeurs ne sont uniquement supportées que par les arbres suffixés,
    dans lesquels chaque niveau de l'arbre contient un préfixe qui est suffisamment petit
    pour tenir dans une page. La classe d'opérateurs doit uniquement définir <structfield>longValuesOK</structfield>
    à TRUE si elle supporte ce cas de figure. Dans le cas contraire, le cœur de <acronym>SP-GiST</acronym>
    rejettera l'indexation d'une valeur plus large qu'une page.
   </para>

   <para>
    De la même manière, il est de la responsabilité de l'opérateur de classe
    de s'assurer que la taille des lignes intermédiaires soit plus petite
    qu'une page&nbsp;; cela limite le nombre de nœuds enfants qui peuvent être utilisés
    dans une ligne intermédiaire, ainsi que la taille maximum d'un préfixe.
   </para>

   <para>
    Une autre limite est que lorsqu'un nœud de ligne intermédiaire pointe vers
    un ensemble de lignes de feuille, ces lignes doivent toutes être dans la même
    page d'index (il s'agit d'une décision d'architecture pour réduire le temps de recherche
    et utiliser moins de mémoire dans les liens qui lient de telles lignes ensemble).
    Si l'ensemble de lignes de feuille grandit plus qu'une page, un découpage est réalisé
    et un nœud intermédiaire est inséré. Pour que ce mécanisme résolve le problème,
    le nouveau nœud intermédiaire <emphasis>doit</emphasis> diviser l'ensemble de valeurs
    de feuilles en plus d'un groupe de nœuds. Si la fonction <function>picksplit</function>
    de la classe d'opérateurs n'y parvient pas, le cœur de <acronym>SP-GiST</acronym> met en œuvre
    des mesures extraordinaires telles que décrites dans <xref linkend="spgist-all-the-same"/>.
   </para>

   <para>
    Quand <structfield>longValuesOK</structfield> vaut true, il est attendu
    que les niveaux successifs de l'arbre <acronym>SP-GiST</acronym>
    absorbera de plus en plus d'informations dans les prefixes et labels de
    noeuds des enregistrements internes, rendant la donnée feuille de plus en
    plus petite, pour qu'à la fin, elle tienne sur un bloc. Pour empêcher les
    bugs dans les classes d'opérateurs, du style boucle d'insertions infinies,
    le code principal de  <acronym>SP-GiST</acronym> lèvera une erreur si la
    donnée feuille ne devient pas plus petite au bout de dix cycles d'appel à
    la méthode <function>choose</function>.
   </para>

   <para>
    Quand <structfield>longValuesOK</structfield> vaut true, il est attendu
    que les niveaux successifs de l'arbre <acronym>SP-GiST</acronym>
    absorberont de plus en plus d'informations dans les préfixes et labels de
    nœuds des lignes internes, rendant la donnée requise pour la feuille de
    plus en plus petite, jusqu'à ce qu'elle tienne sur un bloc. Pour empêcher
    que des bugs dans les classes d'opérateurs causent des boucles d'insertion
    infinies, le noyau de <acronym>SP-GiST</acronym> lèvera une erreur si la
    donnée de la feuille ne devient pas plus petite dans les dix cycles
    d'appel à la méthode <function>choose</function>.
   </para>
  </sect2>

  <sect2 id="spgist-null-labels">
   <title>SP-GiST sans label de nœud</title>

   <para>
    Certains algorithmes d'arbres utilisent un ensemble de nœuds figé pour chaque ligne intermédiaire&nbsp;;
    par exemple, l'arbre quad-tree impose exactement quatre nœuds correspondant aux quatre coins autour du
    centroïde de la ligne intermédiaire. Dans ce cas, le code travaille généralement avec les nœuds
    au moyen de leur identifiant, et le besoin de label de nœud ne se fait pas ressentir.
    Pour supprimer les labels de nœud (et ainsi gagner de l'espace), la fonction <function>picksplit</function>
    peut retourner NULL pour le tableau <structfield>nodeLabels</structfield>, et de même, la fonction
    <function>choose</function> peut retourner NULL pour le tableau <structfield>prefixNodeLabels</structfield>
    lors de l'action <literal>spgSplitTuple</literal>
    Cela aura pour effet d'obtenir une valeur NULL pour <structfield>nodeLabels</structfield> lors des appels
    aux fonctions <function>choose</function> et <function>inner_consistent</function>.
    En principe, les labels de nœuds peuvent être utilisés par certaines lignes intermédiaires, et ignorés
    pour les autres de même index.
   </para>

   <para>
    Lorsqu'une ligne intermédaire sans label est concerné, la fonction <function>choose</function>
    ne peut pas retourner <literal>spgAddNode</literal> car l'ensemble
    des nœuds est supposé être fixé dans de tels cas.
   </para>
  </sect2>

  <sect2 id="spgist-all-the-same">
   <title>Lignes intermédiaires <quote>All-the-same</quote></title>

   <para>
    Le cœur de <acronym>SP-GiST</acronym> peut surcharger les résultats de
    la fonction <function>picksplit</function> de l'opérateur de classe lorsque
    <function>picksplit</function> ne réussit pas à diviser la valeur de la feuille fournie en
    au moins un nœud. Dans ce cas, la nouvelle ligne intermédiaire
    est créée avec de multiples nœuds qui ont tous le même label (si un label est défini)
    qui est celui attribué au nœud utilisé par <function>picksplit</function> et les valeurs
    des feuilles sont divisées aléatoirement entre les nœuds équivalents.
    Le drapeau <literal>allTheSame</literal> est activé sur la ligne intermédiaire pour signifier aux fonctions
    <function>choose</function> et <function>inner_consistent</function> que la
    ligne n'a pas l'ensemble de nœud attendu.
   </para>

   <para>
    Lorsque le cas d'une ligne <literal>allTheSame</literal> est rencontré, le résultat de la fonction <function>choose</function>
    sous la forme <literal>spgMatchNode</literal> est interprété de manière à ce que la nouvelle valeur
    puisse être assignée à chacun des nœuds équivalents&nbsp;; le code du cœur de <acronym>SP-GiST</acronym> ignorera
    la valeur <structfield>nodeN</structfield> fournie et descendra dans l'un des nœuds enfants
    au hasard (pour conserver l'équilibre de l'arbre). Il s'agirait d'une erreur si
    la fonction <function>choose</function> retournait <literal>spgAddNode</literal> car tous
    les nœuds ne seraient pas équivalent&nbsp;; l'action <literal>spgSplitTuple</literal> doit être utilisée
    si la valeur à insérer ne correspond pas aux nœuds existants.
   </para>

   <para>
    Lorsque le cas d'une ligne <literal>allTheSame</literal> est rencontré, la fonction
    <function>inner_consistent</function> peut tout autant retourner tous les nœuds ou aucun des nœuds ciblés
    pour continuer la recherche indexée car ils sont tous équivalents.
    Cela peut éventuellement nécessiter du code spécifique, suivant le support
    réalisé par la fonction <function>inner_consistent</function> concernant
    la signification des nœuds.
   </para>
  </sect2>

 </sect1>

 <sect1 id="spgist-examples">
  <title>Exemples</title>

  <para>
   Les sources de <productname>PostgreSQL</productname> incluent plusieurs
   exemples de classes d'opérateurs d'index pour <acronym>SP-GiST</acronym>
   comme décrit dans <xref linkend="spgist-builtin-opclasses-table"/>. Lire le
   code dans <filename>src/backend/access/spgist/</filename> et
   <filename>src/backend/utils/adt/</filename>.
  </para>

 </sect1>

</chapter>
