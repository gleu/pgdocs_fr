<?xml version="1.0" encoding="UTF-8"?>
<chapter id="logical-replication">
 <title>Réplication logique</title>

 <para>
  La réplication logique est une méthode permettant de répliquer des données au
  niveau objet ainsi que les modifications apportées à ces objets, ceci basé sur
  leur identité de réplication (habituellement la clé primaire). L'utilisation
  du terme de <quote>réplication logique</quote> est faite en opposition à la
  réplication physique, cette dernière utilisant l'adresse exacte des blocs couplée
  avec une réplication octet par octet. PostgreSQL supporte ces deux méthodes,
  référez-vous à l'article <xref linkend="high-availability"/>. La réplication
  logique permet un contrôle fin des données au niveau de la réplication et de
  la sécurité.
 </para>

 <para>
  La réplication logique utilise un système de
  <firstterm>publication</firstterm> / <firstterm>abonnement</firstterm> avec un
  ou plusieurs <firstterm>abonnés</firstterm> qui s'abonnent à une ou plusieurs
  <firstterm>publications</firstterm> d'un nœud particulier. Les abonnés
  récupèrent les données des publications auxquelles ils sont abonnés et peuvent
  éventuellement renvoyer ces informations, ce qui permet un système de
  réplication en cascade dans le cas de configurations plus complexes.
 </para>

 <para>
  When logical replication of a table typically starts, PostgreSQL takes
  a snapshot of the table's data on the publisher database and copies it
  to the subscriber.  Once complete, changes on the publisher since the
  initial copy are sent continually to the subscriber.
  La base abonnée applique les
  modifications dans le même ordre qu'elles auront été réalisées de façon à ce
  que la cohérence transactionnelle soit garantie pour les publications d'un
  seul abonnement. Cette méthode de réplication porte parfois le nom de
  réplication transactionnelle.
 </para>

 <para>
  Les cas typiques d'utilisation de la réplication logique peuvent être les
  suivants&nbsp;:

  <itemizedlist>
   <listitem>
    <para>
     Envoyer immédiatement les changements réalisés sur une base de données, ou
     sur un sous-ensemble de ces données, de façon incrémentale à une base de
     données abonnée;
    </para>
   </listitem>

   <listitem>
    <para>
     Déclencher des triggers pour des changements spécifiques lorsqu'ils
     apparaissent sur la base de données abonnée&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Réaliser la consolidation de plusieurs bases de données au sein d'une seule
     (par exemple pour répondre à des problématiques analytiques)&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Répliquer entre des versions majeures différentes de PostgreSQL&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Répliquer des instances PostgreSQL sur des plateformes différentes (par
     exemple de Linux à Windows)&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Donner accès à des données répliquées à différents groupes d'utilisateurs&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Partager un sous-ensemble de données entre plusieurs bases de données.
    </para>
   </listitem>
  </itemizedlist>
 </para>

 <para>
  Une base de données abonnée se comporte comme n'importe quelle autre base de
  données d'une instance PostgreSQL et peut être utilisée comme base de données
  de publication pour d'autres base de données en lui définissant ses propres
  publications. Lorsque la base abonnée est considérée comme une base en
  lecture seule par l'application, il ne va pas y avoir de problèmes de conflits.
  D'un autre côté, s'il y a des écritures provenant soit de l'application soit
  d'un autre abonnement sur le même ensemble de tables, des conflits peuvent
  survenir.
 </para>

 <sect1 id="logical-replication-publication">
  <title>Publication</title>

  <para>
   Une <firstterm>publication</firstterm> peut être définie sur n'importe quel
   serveur primaire de réplication physique. Le nœud sur laquelle la
   publication est définie est nommé <firstterm>publieur</firstterm>. Une
   publication est un ensemble de modifications générées par une table ou un
   groupe de tables et peut aussi être défini comme un ensemble de modifications
   ou un ensemble de réplication. Chaque publication existe au sein d'une seule
   base de données.
  </para>

  <para>
   Les publications sont différenciées du schéma et n'ont pas d'impact sur la
   manière dont la base est accédée. Chaque table peut être ajoutée à
   différentes publications au besoin. Actuellement, les publications ne
   contiennent que les tables et toutes les tables d'un schéma. Les objets
   doivent être ajoutés explicitement, sauf si la publication a été créée pour
   toutes les tables (<literal>ALL TABLES</literal>).
  </para>

  <para>
   Les publications peuvent choisir de limiter les changements qu'elles
   produisent avec n'importe quelle combinaison de <command>INSERT</command>,
   <command>UPDATE</command>, <command>DELETE</command> et
   <command>TRUNCATE</command>, ceci d'une façon similaire à l'activation de
   triggers en fonction d'un certain type d'événement. Par défaut, tous les
   types d'opération sont répliqués. Ces spécifications de publication
   s'appliquent seulement pour les opérations DML&nbsp;; elles n'affectent pas
   la copie initiale de synchronisation des données. (Les filtres de ligne
   n'ont pas d'effet pour la commande <command>TRUNCATE</command>. Voir <xref
   linkend="logical-replication-row-filter"/>.)
  </para>

  <para>
   Chaque publication peut avoir plusieurs abonnés.
  </para>

  <para>
   Une publication est créée en utilisant la commande <link
   linkend="sql-createpublication"><command>CREATE PUBLICATION</command></link>
   et peut ensuite être modifiée ou supprimée en utilisant la commande
   correspondante.
  </para>

  <para>
   Les tables individuelles peuvent être ajoutées ou supprimées dynamiquement en
   utilisant <link linkend="sql-alterpublication"><command>ALTER
   PUBLICATION</command></link>. Les opérations <literal>ADD TABLE</literal> et
   <literal>DROP TABLE</literal> sont toutes les deux transactionnelles&nbsp;;
   de ce fait, une table va commencer ou arrêter de répliquer dans le bon
   instantané seulement une fois que la transaction a été validée.
  </para>

  <sect2 id="logical-replication-publication-replica-identity">
   <title>Replica Identity</title>

   <para>
    A published table must have a <firstterm>replica identity</firstterm>
    configured in order to be able to replicate <command>UPDATE</command>
    and <command>DELETE</command> operations, so that appropriate rows to
    update or delete can be identified on the subscriber side.
   </para>

   <para>
    By default, this is the primary key, if there is one. Another unique index
    (with certain additional requirements) can also be set to be the replica
    identity.  If the table does not have any suitable key, then it can be set
    to replica identity <literal>FULL</literal>, which means the entire row
    becomes the key.  When replica identity <literal>FULL</literal> is
    specified, indexes can be used on the subscriber side for searching the
    rows.  Candidate indexes must be btree or hash, non-partial, and the
    leftmost index field must be a column (not an expression) that references
    the published table column.  These restrictions on the non-unique index
    properties adhere to some of the restrictions that are enforced for
    primary keys.  If there are no such suitable indexes, the search on the
    subscriber side can be very inefficient, therefore replica identity
    <literal>FULL</literal> should only be used as a fallback if no other
    solution is possible.
   </para>

   <para>
    If a replica identity other than <literal>FULL</literal> is set on the
    publisher side, a replica identity comprising the same or fewer columns
    must also be set on the subscriber side.
   </para>

   <para>
    Tables with a replica identity defined as <literal>NOTHING</literal>,
    <literal>DEFAULT</literal> without a primary key, or <literal>USING
    INDEX</literal> with a dropped index, cannot support
    <command>UPDATE</command> or <command>DELETE</command> operations when
    included in a publication replicating these actions. Attempting such
    operations will result in an error on the publisher.
   </para>

   <para>
    <command>INSERT</command> operations can proceed regardless of any replica identity.
   </para>

   <para>
    See <link linkend="sql-altertable-replica-identity"><literal>ALTER TABLE...REPLICA IDENTITY</literal></link>
    for details on how to set the replica identity.
   </para>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-subscription">
  <title>Abonnement</title>

  <para>
   Un <firstterm>abonnement</firstterm> est le côté aval de la réplication
   logique. Le nœud où un abonnement a été défini est nommé
   <firstterm>abonné</firstterm>. Un abonnement définit la connexion à une
   autre base de données et un ensemble de publications (une ou plus) auxquelles
   l'abonné veut souscrire.
  </para>

  <para>
   La base de données abonnée se comporte comme n'importe quelle base de données
   d'une instance PostgreSQL et peut être utilisée comme éditeur pour d'autres
   bases de données en définissant ses propres publications.
  </para>

  <para>
   Un nœud abonné peut avoir plusieurs abonnements si besoin. Il est possible de
   définir plusieurs abonnements entre une même paire publieur - abonné. Dans ce
   cas, il faut faire attention à ce que les objets des publications auxquelles
   l'abonné a souscrit ne se chevauchent pas.
  </para>

  <para>
   Chaque abonnement recevra les changements par un slot de réplication (voir
   <xref linkend="streaming-replication-slots"/>). Des slots de réplications
   supplémentaires peuvent être nécessaires pour la synchronisation initiale des
   données d'une table contenant des données pré-existantes mais ils seront
   supprimés à la fin de la synchronisation des données.
  </para>

  <para>
   Un abonnement de réplication logique peut être réalisé sur un serveur
   secondaire pour de la réplication synchrone (voir <xref
   linkend="synchronous-replication"/>). Le nom du serveur secondaire
   correspond par défaut au nom de l'abonnement. Un nom alternatif peut être
   indiqué avec le paramètre <literal>application_name</literal> dans les
   informations de connexion à l'abonnement.
  </para>

  <para>
   Les abonnements sont sauvegardés par <command>pg_dump</command> si
   l'utilisateur courant a des droits de superutilisateur. Si ce n'est pas le
   cas, un message d'avertissement est renvoyé et les abonnements ne sont pas
   sauvegardés. En effet, les informations d'abonnements contenues dans
   <structname>pg_subscription</structname> ne sont pas consultables par des
   utilisateurs dotés de droits moins importants.
  </para>

  <para>
   Un abonnement est ajouté en utilisant <link
   linkend="sql-createsubscription"><command>CREATE
   SUBSCRIPTION</command></link>. Il peut être arrêté/repris à n'importe quel
   moment en utilisant la commande <link
   linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION</command></link>,
   et il peut être supprimé par la commande <link
   linkend="sql-dropsubscription"><command>DROP SUBSCRIPTION</command></link>.
  </para>

  <para>
   Quand un abonnement est supprimé puis recréé, les informations de
   synchronisation sont perdues. Cela signifie que les données doivent être
   resynchronisées ensuite.
  </para>

  <para>
   La définition d'un schéma n'est pas répliquée, et les tables publiées doivent
   exister sur la base abonnée. Seules des tables standards peuvent accueillir
   des données répliquées. Par exemple, il n'est pas pas possible de répliquer
   dans une vue.
  </para>

  <para>
   La correspondance entre les tables du publieur et de l'abonné est réalisée en
   utilisant le nom entièrement qualifié de la table. La réplication entre des
   tables portant un nom différent sur la base abonnée n'est pas supportée.
  </para>

  <para>
   La correspondance sur les colonnes d'une table se fait aussi par nom.
   L'ordre des colonnes dans la table sur le serveur abonné ne correspond pas
   forcément à l'ordre sur le serveur publieur. Les types de données n'ont pas
   non plus besoin de correspondre, à partir du moment où la représentation
   textuelle de la donnée peut être convertie vers le type de données cible.
   Par exemple, vous pouvez répliquer depuis une colonne de type <type>integer</type>
   vers une colonne de type <type>bigint</type>. La table cible peut aussi avoir
   des colonnes supplémentaires non fournies par la table publiée. Ce type de
   colonne sera rempli avec la valeur par défaut fournie dans la définition de
   la table cible. Cependant, la réplication logique en format binaire est plus
   restrictive. Voir l'option
   <link linkend="sql-createsubscription-params-with-binary"><literal>binary</literal></link>
   de <command>CREATE SUBSCRIPTION</command> pour les détails.
  </para>

  <sect2 id="logical-replication-subscription-slot">
   <title>Gestion des slots de réplication</title>

   <para>
    Comme présenté plus tôt, chaque abonnement (actif) reçoit les changements
    depuis un slot de réplication du serveur distant (publication).
   </para>

   <para>
    Des slots de synchronisation de tables supplémentaires sont normalement
    temporaires, créés en interne pour réaliser la synchronisation initiale des
    tables et supprimés automatiquement quand elles ne sont plus nécessaires.
    Ces slots de synchronisation de table ont des noms générés
    automatiquement&nbsp;: <quote><literal>pg_%u_sync_%u_%llu</literal></quote>
    (paramètres <parameter>oid</parameter> de la souscription,
    <parameter>relid</parameter> de la table, <parameter>sysid</parameter> pour
    l'identifiant du système).
   </para>

   <para>
    Normalement, le slot de réplication distant est créé automatiquement en
    utilisant la commande <link linkend="sql-createsubscription">
    <command>CREATE SUBSCRIPTION</command></link> et il est
    supprimé automatiquement en utilisant la commande <link
    linkend="sql-dropsubscription"><command>DROP SUBSCRIPTION</command></link>.
    Dans certaines situations, il peut être utile ou
    nécessaire de manipuler les abonnements ainsi que les slots de réplication
    sous-jacents de façon séparées. Voici quelques exemples&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       Lorsqu'en créant un abonnement, le slot de réplication correspondant
       existe déjà. Dans ce cas, l'abonnement peut être créé en utilisant
       l'option <literal>create_slot = false</literal> pour réaliser
       l'association avec le slot existant&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       Lorsqu'en créant un abonnement, le serveur distant n'est pas disponible
       ou dans un état indéfini. Dans ce cas, l'abonnement peut être créé en
       utilisant l'option <literal>connect = false</literal>. Le serveur
       distant ne sera alors jamais contacté. C'est la méthode utilisée par
       <application>pg_dump</application>. Le slot de réplication distant devra
       alors être créé manuellement avant que l'abonnement ne puisse être
       activé&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       Lorsqu'on supprime un abonnement et que le slot de réplication doit être
       conservé, par exemple lorsqu'une base abonnée est déplacée vers un
       serveur différent et sera activée depuis cette nouvelle localisation.
       Dans ce cas, il faut dissocier le slot de réplication de l'abonnement
       correspondant en utilisant la commande <link
       linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION</command></link>
       avant de supprimer l'abonnement&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       Lorsque l'on supprime un abonnement et que le serveur distant n'est pas
       joignable. Dans ce cas, il faut aussi dissocier le slot de réplication de
       l'abonnement correspondant en utilisant <command>ALTER
       SUBSCRIPTION</command> avant de supprimer l'abonnement. Si l'instance
       distante n'existe plus, aucune action supplémentaire n'est nécessaire.
       Si, par contre, l'instance distante est simplement temporairement
       injoignable, le slot de réplication (et tout slot de synchronisation de
       table restant) devrait être supprimé manuellement, sinon l'instance va
       persévérer à conserver ses fichiers WAL jusqu'à saturation de l'espace
       disque disponible. Ces cas doivent être traités avec beaucoup de
       précautions.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>

  <sect2 id="logical-replication-subscription-examples">
    <title>Exemples&nbsp;: Mettre en place la réplication logique</title>

    <para>
     Créer des tables tests sur le publieur.
<programlisting>
/* pub # */ CREATE TABLE t1(a int, b text, PRIMARY KEY(a));
/* pub # */ CREATE TABLE t2(c int, d text, PRIMARY KEY(c));
/* pub # */ CREATE TABLE t3(e int, f text, PRIMARY KEY(e));
</programlisting></para>

    <para>
     Créer les mêmes tables sur l'abonné.
<programlisting>
/* sub # */ CREATE TABLE t1(a int, b text, PRIMARY KEY(a));
/* sub # */ CREATE TABLE t2(c int, d text, PRIMARY KEY(c));
/* sub # */ CREATE TABLE t3(e int, f text, PRIMARY KEY(e));
</programlisting></para>

    <para>
     Insérer des données sur les tables du côté publieur.
<programlisting>
/* pub # */ INSERT INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'three');
/* pub # */ INSERT INTO t2 VALUES (1, 'A'), (2, 'B'), (3, 'C');
/* pub # */ INSERT INTO t3 VALUES (1, 'i'), (2, 'ii'), (3, 'iii');
</programlisting></para>

    <para>
     Créer les publications pour les tables. Les publications
     <literal>pub2</literal> et <literal>pub3a</literal> interdisent certaines
     opérations <link
     linkend="sql-createpublication-params-with-publish"><literal>publish</literal></link>.
     La publication <literal>pub3b</literal> a un filtre de lignes (voir <xref
     linkend="logical-replication-row-filter"/>).
<programlisting><![CDATA[
/* pub # */ CREATE PUBLICATION pub1 FOR TABLE t1;
/* pub # */ CREATE PUBLICATION pub2 FOR TABLE t2 WITH (publish = 'truncate');
/* pub # */ CREATE PUBLICATION pub3a FOR TABLE t3 WITH (publish = 'truncate');
/* pub # */ CREATE PUBLICATION pub3b FOR TABLE t3 WHERE (e > 5);
]]></programlisting></para>

    <para>
     Créer les abonnements (souscriptions) pour les publications. La
     souscription <literal>sub3</literal> s'abonne à <literal>pub3a</literal> et
     <literal>pub3b</literal>. Toutes les souscriptions copieront les données
     initiales par défaut.
<programlisting>
/* sub # */ CREATE SUBSCRIPTION sub1
/* sub - */ CONNECTION 'host=localhost dbname=test_pub application_name=sub1'
/* sub - */ PUBLICATION pub1;
/* sub # */ CREATE SUBSCRIPTION sub2
/* sub - */ CONNECTION 'host=localhost dbname=test_pub application_name=sub2'
/* sub - */ PUBLICATION pub2;
/* sub # */ CREATE SUBSCRIPTION sub3
/* sub - */ CONNECTION 'host=localhost dbname=test_pub application_name=sub3'
/* sub - */ PUBLICATION pub3a, pub3b;
</programlisting></para>

    <para>
     Observez que les données initiales des tables sont copiées, quelque soit
     l'opération <literal>publish</literal> de la publication.
<programlisting>
/* sub # */ SELECT * FROM t1;
 a |   b
---+-------
 1 | one
 2 | two
 3 | three
(3 rows)

/* sub # */ SELECT * FROM t2;
 c | d
---+---
 1 | A
 2 | B
 3 | C
(3 rows)
</programlisting></para>

    <para>
     De plus, comme la copie initiale de données ignore l'opération
     <literal>publish</literal> et comme la publication <literal>pub3a</literal>
     n'a pas de filtre de lignes, cela signifie que la table
     <literal>t3</literal> copiée contient toutes les lignes même quand elles ne
     correspondent pas au filtre de lignes de la publication
     <literal>pub3b</literal>.
<programlisting>
/* sub # */ SELECT * FROM t3;
 e |  f
---+-----
 1 | i
 2 | ii
 3 | iii
(3 rows)
</programlisting></para>

   <para>
    Insérer plus de données dans les tables du côté publieur.
<programlisting>
/* pub # */ INSERT INTO t1 VALUES (4, 'four'), (5, 'five'), (6, 'six');
/* pub # */ INSERT INTO t2 VALUES (4, 'D'), (5, 'E'), (6, 'F');
/* pub # */ INSERT INTO t3 VALUES (4, 'iv'), (5, 'v'), (6, 'vi');
</programlisting></para>

   <para>
    Maintenant, les données du côté publieur ressemblent à ceci&nbsp;:
<programlisting>
/* pub # */ SELECT * FROM t1;
 a |   b
---+-------
 1 | one
 2 | two
 3 | three
 4 | four
 5 | five
 6 | six
(6 rows)

/* pub # */ SELECT * FROM t2;
 c | d
---+---
 1 | A
 2 | B
 3 | C
 4 | D
 5 | E
 6 | F
(6 rows)

/* pub # */ SELECT * FROM t3;
 e |  f
---+-----
 1 | i
 2 | ii
 3 | iii
 4 | iv
 5 | v
 6 | vi
(6 rows)
</programlisting></para>

   <para>
    Observez que, durant la réplication normale, les opérations
    <literal>publish</literal> appropriées sont utilisées. Cela signifie que les
    publications <literal>pub2</literal> et <literal>pub3a</literal> ne
    répliquent pas les opérations <literal>INSERT</literal>. De plus, la
    publication <literal>pub3b</literal> répliquera seulement les données
    correspondant au filtre de lignes de <literal>pub3b</literal>. Maintenant,
    les données du côté abonné ressemblent à ceci&nbsp;:
<programlisting>
/* sub # */ SELECT * FROM t1;
 a |   b
---+-------
 1 | one
 2 | two
 3 | three
 4 | four
 5 | five
 6 | six
(6 rows)

/* sub # */ SELECT * FROM t2;
 c | d
---+---
 1 | A
 2 | B
 3 | C
(3 rows)

/* sub # */ SELECT * FROM t3;
 e |  f
---+-----
 1 | i
 2 | ii
 3 | iii
 6 | vi
(4 rows)
</programlisting></para>
  </sect2>

  <sect2 id="logical-replication-subscription-examples-deferred-slot">
   <title>Exemples&nbsp;: Création de slot de réplication différée</title>

   <para>
    Dans certains cas (i.e
    <xref linkend="logical-replication-subscription-slot"/>), si le slot de réplication
    n'a pas été créé automatiquement, l'utilisateur doit le créer manuellement
    avant que la souscription ne soit activée. Les étapes pour créer le slot et activer
    la souscription sont indiquées dans les exemples suivants.
    Ces exemples spécifient le plugin de décodage logique standard
    (<literal>pgoutput</literal>), qui est utilisé par la réplication logique interne.
   </para>
   <para>
    D'abord, créer une publication pour les exemples.
<programlisting>
/* pub # */ CREATE PUBLICATION pub1 FOR ALL TABLES;
</programlisting>
   </para>
   <para>
    Exemple 1&nbsp;: Quand l'abonnement indique <literal>connect = false</literal>
   </para>
   <para>
    <itemizedlist>
     <listitem>
      <para>
       Créez l'abonnement.
<programlisting>
/* sub # */ CREATE SUBSCRIPTION sub1
/* sub - */ CONNECTION 'host=localhost dbname=test_pub'
/* sub - */ PUBLICATION pub1
/* sub - */ WITH (connect=false);
WARNING:  subscription was created, but is not connected
HINT:  To initiate replication, you must manually create the replication slot, enable the subscription, and refresh the subscription.
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Sur le publieur, créer manuellement le slot. Comme son nom n'a pas été
       spécifié lors de <literal>CREATE SUBSCRIPTION</literal>, le nom du slot à créer
       est le même que le nom d'abonnement, i.e. "sub1".
<programlisting>
/* pub # */ SELECT * FROM pg_create_logical_replication_slot('sub1', 'pgoutput');
 slot_name |    lsn
-----------+-----------
 sub1      | 0/19404D0
(1 row)
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Sur l'abonné, complétez l'activation de l'abonnement. Après cela,
       les tables de <literal>pub1</literal> commenceront à répliquer.
<programlisting>
/* sub # */ ALTER SUBSCRIPTION sub1 ENABLE;
/* sub # */ ALTER SUBSCRIPTION sub1 REFRESH PUBLICATION;
</programlisting></para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Exemple 2&nbsp;: Quand l'abonnement indique <literal>connect = false</literal>,
    mais spécifie aussi l'option
    <link linkend="sql-createsubscription-params-with-slot-name"><literal>slot_name</literal></link>.
    <itemizedlist>
     <listitem>
      <para>
       Créez l'abonnement.
<programlisting>
/* sub # */ CREATE SUBSCRIPTION sub1
/* sub - */ CONNECTION 'host=localhost dbname=test_pub'
/* sub - */ PUBLICATION pub1
/* sub - */ WITH (connect=false, slot_name='myslot');
WARNING:  subscription was created, but is not connected
HINT:  To initiate replication, you must manually create the replication slot, enable the subscription, and refresh the subscription.
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Sur le publieur, créez manuellement un slot en utilisant le même nom que
       celui spécifié lors de <literal>CREATE SUBSCRIPTION</literal>, i.e. "myslot".
<programlisting>
/* pub # */ SELECT * FROM pg_create_logical_replication_slot('myslot', 'pgoutput');
 slot_name |    lsn
-----------+-----------
 myslot    | 0/19059A0
(1 row)
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Sur l'abonné, les étapes restantes d'activation d'abonnement sont les mêmes
       que précédemment.
<programlisting>
/* sub # */ ALTER SUBSCRIPTION sub1 ENABLE;
/* sub # */ ALTER SUBSCRIPTION sub1 REFRESH PUBLICATION;
</programlisting></para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Exemple 3&nbsp;: Quand l'abonnement indique <literal>slot_name = NONE</literal>
    <itemizedlist>
     <listitem>
      <para>
       Créez l'abonnement. Quand <literal>slot_name = NONE</literal> alors
       <literal>enabled = false</literal> et <literal>create_slot = false</literal>
       sont aussi nécessaires.
<programlisting>
/* sub # */ CREATE SUBSCRIPTION sub1
/* sub - */ CONNECTION 'host=localhost dbname=test_pub'
/* sub - */ PUBLICATION pub1
/* sub - */ WITH (slot_name=NONE, enabled=false, create_slot=false);
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Sur le publieur, créez manuellement un slot en utilisant n'importe quel nom, i.e. "myslot".
<programlisting>
/* pub # */ SELECT * FROM pg_create_logical_replication_slot('myslot', 'pgoutput');
 slot_name |    lsn
-----------+-----------
 myslot    | 0/1905930
(1 row)
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Sur l'abonné, associez l'abonnement avec le nom de slot juste créé.
<programlisting>
/* sub # */ ALTER SUBSCRIPTION sub1 SET (slot_name='myslot');
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Les étapes restantes d'activation d'abonnement sont les mêmes que précédemment.
<programlisting>
/* sub # */ ALTER SUBSCRIPTION sub1 ENABLE;
/* sub # */ ALTER SUBSCRIPTION sub1 REFRESH PUBLICATION;
</programlisting></para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>

 </sect1>

 <sect1 id="logical-replication-failover">
  <title>Failover en réplication logique</title>

  <para>
   Pour permettre à des nœuds abonnés de continuer de répliquer les
   données du nœud publieur même quand ce dernier tombe, il doit y
   avoir un secondaire physique correspondant au nœud publieur. Les
   slots logique du serveur primaire correspondant aux souscriptions
   peuvent être synchronisés sur le serveur secondaire en précisant
   <literal>failover = true</literal> lors de la création de la souscription.
   Voir <xref linkend="logicaldecoding-replication-slots-synchronization"/>
   pour les détails. Activer le paramètre
   <link linkend="sql-createsubscription-params-with-failover"><literal>failover</literal></link>
   assure une transition directe de ces souscriptions après la promotion
   du secondaire. Ils peuvent continuer à souscrire aux publications du
   nouveau serveur primaire.
  </para>

  <para>
   Comme la logique de synchronisation du slot copies de façon asynchrone,
   il est nécessaire de confirmer que les slots de réplication doivent être
   synchronisés vers le serveur secondaire avant l'exécution du failover.
   Pour s'assurer d'un failover réussi, le serveur secondaire doit être en avance sur l'abonné. Ceci peut se faire en configurant
   <link linkend="guc-synchronized-standby-slots"><varname>synchronized_standby_slots</varname></link>.
  </para>

  <para>
   Pour confirmer que le serveur secondaire est prêt pour un failover, suivez
   ces étapes pour vérifier que tous les slots de réplication logique
   nécessaires ont bien été synchronisés sur le serveur secondaire&nbsp;:
  </para>

  <procedure>
   <step performance="required">
    <para>
     Sur le nœud abonné, utilisez la requête SQL suivante pour identifier
     les slots de réplication devant être synchronisés sur le secondaire que
     nous souhaitons promouvoir. Cette requête renverra les slots de
     réplication adéquats avec les souscriptions dont l'option failover est
     activée.
     <programlisting>
/* sub # */ SELECT
               array_agg(quote_literal(s.subslotname)) AS slots
           FROM  pg_subscription s
           WHERE s.subfailover AND
                 s.subslotname IS NOT NULL;
 slots
-------
 {'sub1','sub2','sub3'}
(1 row)
</programlisting></para>
   </step>
   <step performance="required">
    <para>
     Sur le nœud abonné, utilisez la requête SQL suivante pour identifier
     les slots de synchronisation qui doivent être synchronisés sur le secondaire
     que nous planifions de promouvoir. Cette requête a besoin d'être exécutée
     sur chaque base qui inclut les souscriptions dont l'option failover a été
     activée. Notez que le slot de synchronisation de table doit être synchronisé
     vers le serveur secondaire seulement si la copie de table est terminée
     (Voir <xref linkend="catalog-pg-subscription-rel"/>).
     Nous n'avons pas besoin de nous assurer que les slots de synchronisation
     de table sont synchronisés dans les autres scénarios car ceux-là seront
     soit supprimés soit re-créés sur le nouveau serveur primaire.
<programlisting>
/* sub # */ SELECT
               array_agg(quote_literal(slot_name) AS slots
           FROM
           (
               SELECT CONCAT('pg_', srsubid, '_sync_', srrelid, '_', ctl.system_identifier) AS slot_name
               FROM pg_control_system() ctl, pg_subscription_rel r, pg_subscription s
               WHERE r.srsubstate = 'f' AND s.oid = r.srsubid AND s.subfailover
           );
 slots
-------
 {'pg_16394_sync_16385_7394666715149055164'}
(1 row)
</programlisting></para>
   </step>
   <step performance="required">
    <para>
     Vérifiez que les slots de réplication logique identifiés ci-dessus
     existent sur le serveur secondaire et sont prêt pour un failover.
<programlisting>
/* standby # */ SELECT slot_name, (synced AND NOT temporary AND NOT conflicting) AS failover_ready
               FROM pg_replication_slots
               WHERE slot_name IN
                   ('sub1','sub2','sub3', 'pg_16394_sync_16385_7394666715149055164');
  slot_name                                 | failover_ready
--------------------------------------------+----------------
  sub1                                      | t
  sub2                                      | t
  sub3                                      | t
  pg_16394_sync_16385_7394666715149055164   | t
(4 rows)
</programlisting></para>
    </step>
  </procedure>

  <para>
   Si tous les slots sont présents sur le serveur secondaire et que le
   résultat (<literal>failover_ready</literal>) de la requête SQL ci-dessus
   vaut <literal>true</literal>, alors les souscriptions existantes
   pourront continuer leur travail avec les publications sur le nouveau
   serveur primaire.
  </para>

  <para>
   The first two steps in the above procedure are meant for a
   <productname>PostgreSQL</productname> subscriber. It is recommended to run
   these steps on each subscriber node, that will be served by the designated
   standby after failover, to obtain the complete list of replication
   slots. This list can then be verified in Step 3 to ensure failover readiness.
   Non-<productname>PostgreSQL</productname> subscribers, on the other hand, may
   use their own methods to identify the replication slots used by their
   respective subscriptions.
  </para>

  <para>
   In some cases, such as during a planned failover, it is necessary to confirm
   that all subscribers, whether <productname>PostgreSQL</productname> or
   non-<productname>PostgreSQL</productname>, will be able to continue
   replication after failover to a given standby server. In such cases, use the
   following SQL, instead of performing the first two steps above, to identify
   which replication slots on the primary need to be synced to the standby that
   is intended for promotion. This query returns the relevant replication slots
   associated with all the failover-enabled subscriptions.
  </para>

   <para>
<programlisting>
/* primary # */ SELECT array_agg(quote_literal(r.slot_name)) AS slots
               FROM pg_replication_slots r
               WHERE r.failover AND NOT r.temporary;
 slots
-------
 {'sub1','sub2','sub3', 'pg_16394_sync_16385_7394666715149055164'}
(1 row)
</programlisting></para>

 </sect1>

 <sect1 id="logical-replication-row-filter">
  <title>Filtres de lignes</title>

  <para>
   Par défaut, toutes les données de toutes les tables publiées seront
   répliquées aux abonnés appropriés. Les données répliquées peuvent être
   réduites en utilisant un <firstterm>filtre de lignes</firstterm>. Un
   utilisateur pourrait choisir d'utiliser des filtres de lignes pour des
   raisons de comportement, de sécurité ou de performance. Si une table publiée
   configure un filtre de lignes, une ligne est répliquée seulement si ses
   données satisfont l'expression du filtre de lignes. Cela permet à un ensemble
   de tables d'être répliquées partiellement. Le filtre de lignes est défini par
   table. Utilisez une clause <literal>WHERE</literal> après le nom de la table
   pour chaque table publiée dont les données doivent être filtrées. La clause
   <literal>WHERE</literal> doit être entourée de parenthèses. Voir <xref
   linkend="sql-createpublication"/> pour les détails.
  </para>

  <sect2 id="logical-replication-row-filter-rules">
   <title>Règles des filtres de lignes</title>

   <para>
    Les filtres de lignes sont appliqués <emphasis>avant</emphasis> de publier
    les changements. Si le filtre de ligne est évalué à <literal>false</literal>
    ou <literal>NULL</literal>, alors la ligne n'est pas répliquée. L'expression
    de la clause <literal>WHERE</literal> est évaluée avec le même rôle utilisé
    pour la connexion de réplication (soit le rôle indiqué dans la clause
    <link linkend="sql-createsubscription-params-connection"><literal>CONNECTION</literal></link>
    de l'instruction <xref
    linkend="sql-createsubscription"/>). Les filtres de ligne n'ont pas deffet
    sur la commande <command>TRUNCATE</command>.
   </para>
  </sect2>

  <sect2 id="logical-replication-row-filter-restrictions">
   <title>Restrictions de l'expression</title>

   <para>
    La clause <literal>WHERE</literal> autorise uniquement des expressions simples.
    Elle ne peut pas contenir de fonctions, opérateurs, types et collations
    définis par les utilisateurs, des références aux colonnes système ou à des
    fonctions internes non immutables.
   </para>

   <para>
    Si une publication publie des opérations <command>UPDATE</command> ou
    <command>DELETE</command>, la clause <literal>WHERE</literal> du filtre de
    lignes doit contenir uniquement les colonnes couvertes par l'identité de
    réplica (voir <xref linkend="sql-altertable-replica-identity"/>). Si une
    publication publie uniquement des opérations <command>INSERT</command>, la
    clause <literal>WHERE</literal> du filtre de ligne peut utiliser toute
    colonne.
   </para>
  </sect2>

  <sect2 id="logical-replication-row-filter-transformations">
   <title>Transformations d'un UPDATE</title>

   <para>
    À chaque fois qu'un <command>UPDATE</command> est traité, l'expression du
    filtre de lignes est évaluée pour l'ancienne et la nouvelle ligne (autrement
    dit, en utilisant les données avant et après la mise à jour). Si les deux
    évaluations valent <literal>true</literal>, les modifications de
    l'<command>UPDATE</command> sont répliquées. Si les deux évaluations valent
    <literal>false</literal>, les modifications ne sont pas répliquées. Si
    seulement une des deux évaluations vaut true, la commande
    <command>UPDATE</command> est transformée en <command>INSERT</command> ou
    <command>DELETE</command>, pour éviter toute incohérence de données. La
    ligne sur l'abonné doit refléter ce qui est défini par l'expression de
    filtre de lignes sur le publieur.
   </para>

   <para>
    Si l'ancienne ligne satisfait l'expression du filtre de lignes (elle a été
    envoyée sur l'abonné) contrairement à la nouvelle ligne, alors, d'un point
    de vue de la cohérence des données, l'ancienne ligne devrait être supprimée
    de l'abonné. Donc la commande <command>UPDATE</command> est transformée en
    commande <command>DELETE</command>.
   </para>

   <para>
    Si l'ancienne ligne ne satisfait pas l'expression du filtre de lignes (elle
    n'a pas été envoyée sur l'abonné) contrairement à la nouvelle ligne, alors,
    d'un point de vue de la cohérence des données, la nouvelle ligne doit être
    ajoutée à l'abonné. Donc la commande <command>UPDATE</command> est
    transformée en commande <command>INSERT</command>.
   </para>

   <para>
    <xref linkend="logical-replication-row-filter-transformations-summary"/>
    résume les transformations appliquées.
   </para>

   <table id="logical-replication-row-filter-transformations-summary">
    <title>Résumé des transformations d'un <command>UPDATE</command></title>
    <tgroup cols="3">
    <thead>
     <row>
      <entry>Ancienne ligne</entry>
      <entry>Nouvelle ligne</entry>
      <entry>Transformation</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>pas de correspondance</entry>
      <entry>pas de correspondance</entry>
      <entry>ne réplique pas</entry>
     </row>
     <row>
      <entry>pas de correspondance</entry>
      <entry>correspondance</entry>
      <entry><literal>INSERT</literal></entry>
     </row>
     <row>
      <entry>correspondance</entry>
      <entry>pas de correspondance</entry>
      <entry><literal>DELETE</literal></entry>
     </row>
     <row>
      <entry>correspondance</entry>
      <entry>correspondance</entry>
      <entry><literal>UPDATE</literal></entry>
     </row>
    </tbody>
   </tgroup>
   </table>

  </sect2>

  <sect2 id="logical-replication-row-filter-partitioned-table">
   <title>Tables partitionnées</title>

   <para>
    Si la publication contient une table partitionnée, le paramètre de
    publication <link
    linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>
    détermine le filtre de lignes à utiliser. Si
    <literal>publish_via_partition_root</literal> vaut <literal>true</literal>,
    le filtre de ligne de la <emphasis>table partitionnée racine</emphasis> est
    utilisé. Si <literal>publish_via_partition_root</literal> vaut
    <literal>false</literal> (ce qui est le cas par défaut), le filtre de lignes
    de chaque <emphasis>partition</emphasis> est utilisé.
   </para>

  </sect2>

  <sect2 id="logical-replication-row-filter-initial-data-sync">
   <title>Synchronisation initiale des données</title>

   <para>
    Si la souscription requiert une copie des données pré-existantes de la table
    et qu'une publication contient des clauses <literal>WHERE</literal>, seules
    les données qui satisfont les expressions des filtres de ligne sont copiées
    sur l'abonné.
   </para>

   <para>
    Si la souscription a plusieurs publications dans lesquelles une table a été
    publiée avec différentes clauses <literal>WHERE</literal>, les lignes qui
    satisfont <emphasis>une</emphasis> des expressions seront copiées. Voir
    <xref linkend="logical-replication-row-filter-combining"/> pour les détails.
   </para>

   <warning>
    <para>
     Comme la synchronisation initiale des données ne prend pas en compte le
     paramètre <link
     linkend="sql-createpublication-params-with-publish"><literal>publish</literal></link>
     lors de la copie des données
     pré-existantes de la table, certaines lignes pourraient être copiées alors
     qu'elles n'auraient pas été répliquées avec des instructions DML.
     Référez-vous à <xref linkend="logical-replication-snapshot"/>, et à
     <xref linkend="logical-replication-subscription-examples"/> pour des
     exemples.
    </para>
   </warning>

   <note>
    <para>
     Si l'abonné est d'une version antérieure à la 15, la copie des données
     pré-existantes n'utilise pas les filtres de ligne même s'ils sont définis
     dans la publication. Ceci est dû au fait que les anciennes versions peuvent
     seulement copier les données de la table entière.
    </para>
   </note>

  </sect2>

  <sect2 id="logical-replication-row-filter-combining">
   <title>Combiner plusieurs filtres de lignes</title>

   <para>
    Si la souscription a plusieurs publications pour lesquelles la même table a
    été publiée avec des filtres de lignes différents (pour la même opération
    <link linkend="sql-createpublication-params-with-publish"><literal>publish</literal></link>,
    ces expressions sont assemblées avec un OU
    logique, pour que les lignes satisfaisant au moins <emphasis>une</emphasis>
    expression seront répliquées. Cela signifie que les autres filtres de lignes
    pour la même table deviennent redondants si&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       Une des publications n'a pas de filtres de lignes&nbsp;;
      </para>
     </listitem>
     <listitem>
      <para>
       Une des publications a été créée en utilisant <link
       linkend="sql-createpublication-params-for-all-tables"><literal>FOR ALL
       TABLES</literal></link>. Cette clause n'autorise pas les filtres de
       lignes&nbsp;;
      </para>
     </listitem>
     <listitem>
      <para>
       Une des publications a été créée en utilisant <link
       linkend="sql-createpublication-params-for-tables-in-schema"><literal>FOR TABLES
       IN SCHEMA</literal></link> et la table appartient au schéma référencé.
       Cette clause n'autorise pas les filtres de lignes.
      </para>
     </listitem>
    </itemizedlist></para>
  </sect2>

  <sect2 id="logical-replication-row-filter-examples">
   <title>Exemples</title>

   <para>
    Créer quelques tables à utiliser dans les exemples suivants.
<programlisting>
/* pub # */ CREATE TABLE t1(a int, b int, c text, PRIMARY KEY(a,c));
/* pub # */ CREATE TABLE t2(d int, e int, f int, PRIMARY KEY(d));
/* pub # */ CREATE TABLE t3(g int, h int, i int, PRIMARY KEY(g));
</programlisting></para>

   <para>
    Créer quelques publications. La publication <literal>p1</literal> a une
    table (<literal>t1</literal>) et cette table a un filtre de lignes. La
    publication <literal>p2</literal> a deux tables. La table
    <literal>t1</literal> n'a pas de filtre de lignes, et la table
    <literal>t2</literal> a un filtre de lignes. La publication
    <literal>p3</literal> a deux tables, qui ont toutes les deux un filtre de
    lignes.
<programlisting>
/* pub # */ CREATE PUBLICATION p1 FOR TABLE t1 WHERE (a > 5 AND c = 'NSW');
/* pub # */ CREATE PUBLICATION p2 FOR TABLE t1, t2 WHERE (e = 99);
/* pub # */ CREATE PUBLICATION p3 FOR TABLE t2 WHERE (d = 10), t3 WHERE (g = 10);
</programlisting></para>

   <para>
    <command>psql</command> peut être utilisé pour afficher les expressions
    de filtres de lignes (si défini) pour chaque publication.
<programlisting><![CDATA[
/* pub # */ \dRp+
                               Publication p1
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t1" WHERE ((a > 5) AND (c = 'NSW'::text))

                               Publication p2
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t1"
    "public.t2" WHERE (e = 99)

                               Publication p3
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t2" WHERE (d = 10)
    "public.t3" WHERE (g = 10)
]]></programlisting></para>

   <para>
    <command>psql</command> peut être utilisé pour afficher les expressions des
    filtres de lignes (si défini) pour chaque table. La table
    <literal>t1</literal> est membre de deux publications, mais a un filtre de
    lignes uniquement dans <literal>p1</literal>. La table
    <literal>t2</literal> est membre de deux publications, et a un filtre de
    lignes différent sur chacune.
<programlisting><![CDATA[
/* pub # */ \d t1
                 Table "public.t1"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 a      | integer |           | not null |
 b      | integer |           |          |
 c      | text    |           | not null |
Indexes:
    "t1_pkey" PRIMARY KEY, btree (a, c)
Publications:
    "p1" WHERE ((a > 5) AND (c = 'NSW'::text))
    "p2"

/* pub # */ \d t2
                 Table "public.t2"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 d      | integer |           | not null |
 e      | integer |           |          |
 f      | integer |           |          |
Indexes:
    "t2_pkey" PRIMARY KEY, btree (d)
Publications:
    "p2" WHERE (e = 99)
    "p3" WHERE (d = 10)

/* pub # */ \d t3
                 Table "public.t3"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 g      | integer |           | not null |
 h      | integer |           |          |
 i      | integer |           |          |
Indexes:
    "t3_pkey" PRIMARY KEY, btree (g)
Publications:
    "p3" WHERE (g = 10)
]]></programlisting></para>

   <para>
    Sur le nœud abonné, créer une table <literal>t1</literal> avec la même
    définition que celle du publieur, et créer aussi la souscription
    <literal>s1</literal> vers la publication <literal>p1</literal>.
<programlisting>
/* sub # */ CREATE TABLE t1(a int, b int, c text, PRIMARY KEY(a,c));
/* sub # */ CREATE SUBSCRIPTION s1
/* sub - */ CONNECTION 'host=localhost dbname=test_pub application_name=s1'
/* sub - */ PUBLICATION p1;
</programlisting></para>

   <para>
    Insérer quelques lignes. Seules les lignes satisfaisant la clause
    <literal>t1 WHERE</literal> de la publication <literal>p1</literal> sont
    répliquées.
<programlisting>
/* pub # */ INSERT INTO t1 VALUES (2, 102, 'NSW');
/* pub # */ INSERT INTO t1 VALUES (3, 103, 'QLD');
/* pub # */ INSERT INTO t1 VALUES (4, 104, 'VIC');
/* pub # */ INSERT INTO t1 VALUES (5, 105, 'ACT');
/* pub # */ INSERT INTO t1 VALUES (6, 106, 'NSW');
/* pub # */ INSERT INTO t1 VALUES (7, 107, 'NT');
/* pub # */ INSERT INTO t1 VALUES (8, 108, 'QLD');
/* pub # */ INSERT INTO t1 VALUES (9, 109, 'NSW');

/* pub # */ SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 2 | 102 | NSW
 3 | 103 | QLD
 4 | 104 | VIC
 5 | 105 | ACT
 6 | 106 | NSW
 7 | 107 | NT
 8 | 108 | QLD
 9 | 109 | NSW
(8 rows)
</programlisting>
<programlisting>
/* sub # */ SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 6 | 106 | NSW
 9 | 109 | NSW
(2 rows)
</programlisting></para>

   <para>
    Mettre à jour quelques données, où les valeurs de l'ancienne et de la
    nouvelle ligne satisfont la clause <literal>t1 WHERE</literal> de la
    publication <literal>p1</literal>. La commande <command>UPDATE</command>
    réplique les changements de façon normale.
<programlisting>
/* pub # */ UPDATE t1 SET b = 999 WHERE a = 6;

/* pub # */ SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 2 | 102 | NSW
 3 | 103 | QLD
 4 | 104 | VIC
 5 | 105 | ACT
 7 | 107 | NT
 8 | 108 | QLD
 9 | 109 | NSW
 6 | 999 | NSW
(8 rows)
</programlisting>
<programlisting>
/* sub # */ SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 9 | 109 | NSW
 6 | 999 | NSW
(2 rows)
</programlisting></para>

   <para>
    Mettre à jour des données de façon à ce que les valeurs de l'ancienne ligne
    ne satisfont pas la clause <literal>t1 WHERE</literal> de la publication
    <literal>p1</literal>, mais que les valeurs de la nouvelle ligne la
    satisfont. La commande <command>UPDATE</command> est transformée en une
    commande <command>INSERT</command> et les changements sont répliqués. Voir
    la nouvelle ligne sur l'abonné.
<programlisting>
/* pub # */ UPDATE t1 SET a = 555 WHERE a = 2;

/* pub # */ SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   3 | 103 | QLD
   4 | 104 | VIC
   5 | 105 | ACT
   7 | 107 | NT
   8 | 108 | QLD
   9 | 109 | NSW
   6 | 999 | NSW
 555 | 102 | NSW
(8 rows)
</programlisting>
<programlisting>
/* sub # */ SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   9 | 109 | NSW
   6 | 999 | NSW
 555 | 102 | NSW
(3 rows)
</programlisting></para>

   <para>
    Mettre à jour des données de façon à ce que les valeurs de l'ancienne ligne
    satisfont la clause <literal>t1 WHERE</literal> de la publication
    <literal>p1</literal>, mais que les valeurs de la nouvelle ligne ne la
    satisfont pas. La commande <command>UPDATE</command> est transformée en une
    commande <command>DELETE</command> et les changements sont répliqués. Voir
    la nouvelle ligne supprimée sur l'abonné.
<programlisting>
/* pub # */ UPDATE t1 SET c = 'VIC' WHERE a = 9;

/* pub # */ SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   3 | 103 | QLD
   4 | 104 | VIC
   5 | 105 | ACT
   7 | 107 | NT
   8 | 108 | QLD
   6 | 999 | NSW
 555 | 102 | NSW
   9 | 109 | VIC
(8 rows)
</programlisting>
<programlisting>
/* sub # */ SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   6 | 999 | NSW
 555 | 102 | NSW
(2 rows)
</programlisting></para>

   <para>
    Les exemples suivants montrent comment le paramètre de publication <link
    linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>
    détermine si le filtre de
    ligne de la table parent ou enfant sera utilisé dans le cas de tables
    partitionnées.
   </para>

   <para>
    Créer une table partitionnée sur le publieur.
<programlisting>
/* pub # */ CREATE TABLE parent(a int PRIMARY KEY) PARTITION BY RANGE(a);
/* pub # */ CREATE TABLE child PARTITION OF parent DEFAULT;
</programlisting>
   Créer les mêmes tables sur l'abonné.
<programlisting>
/* sub # */ CREATE TABLE parent(a int PRIMARY KEY) PARTITION BY RANGE(a);
/* sub # */ CREATE TABLE child PARTITION OF parent DEFAULT;
</programlisting></para>

   <para>
    Créer une publication <literal>p4</literal>, puis abonnez-vous à cette
    publication. Le paramètre de publication
    <literal>publish_via_partition_root</literal> est configuré à true. Il
    existe des filtres de lignes définis sur la table partitionnée
    (<literal>parent</literal>), et sur sa partition (<literal>child</literal>).
<programlisting><![CDATA[
/* pub # */ CREATE PUBLICATION p4 FOR TABLE parent WHERE (a &lt; 5), child WHERE (a >= 5)
test_pub-# WITH (publish_via_partition_root=true);
+]]></programlisting>
<programlisting>
/* sub # */ CREATE SUBSCRIPTION s4
/* sub - */ CONNECTION 'host=localhost dbname=test_pub application_name=s4'
/* sub - */ PUBLICATION p4;
</programlisting></para>

   <para>
    Insérer quelques valeurs directement dans les tables
    <literal>parent</literal> et <literal>child</literal>. Elles se répliquent
    en utilisant le filtre de lignes de <literal>parent</literal> (parce que
    <literal>publish_via_partition_root</literal> vaut true).
<programlisting>
/* pub # */ INSERT INTO parent VALUES (2), (4), (6);
/* pub # */ INSERT INTO child VALUES (3), (5), (7);

/* pub # */ SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
 5
 6
 7
(6 rows)
</programlisting>
<programlisting>
/* sub # */ SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
(3 rows)
</programlisting></para>

   <para>
    Répéter le même test, mais avec une valeur différente pour
    <literal>publish_via_partition_root</literal>. Le paramètre de publication
    <literal>publish_via_partition_root</literal> est configuré à false. Un
    filtre de lignes est défini sur la partition (<literal>child</literal>).
<programlisting><![CDATA[
/* pub # */ DROP PUBLICATION p4;
/* pub # */ CREATE PUBLICATION p4 FOR TABLE parent, child WHERE (a >= 5)
/* pub - */ WITH (publish_via_partition_root=false);
]]></programlisting>
<programlisting>
/* sub # */ ALTER SUBSCRIPTION s4 REFRESH PUBLICATION;
</programlisting></para>

   <para>
    Faire les insertions sur le publieur de la même façon qu'avant. Elles se
    répliquent en utilisant le filtre de lignes de <literal>child</literal>
    (parce que <literal>publish_via_partition_root</literal> vaut false).
<programlisting>
/* pub # */ TRUNCATE parent;
/* pub # */ INSERT INTO parent VALUES (2), (4), (6);
/* pub # */ INSERT INTO child VALUES (3), (5), (7);

/* pub # */ SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
 5
 6
 7
(6 rows)
</programlisting>
<programlisting>
/* sub # */ SELECT * FROM child ORDER BY a;
 a
---
 5
 6
 7
(3 rows)
</programlisting></para>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-col-lists">
  <title>Listes de colonnes</title>

  <para>
   Chaque publication peut indiquer en option aux abonnés les colonnes à
   répliquer pour chaque table. La table du côté abonné doit avoir au moins
   toutes les colonnes publiées. Si aucune liste de colonnes n'est indiquée,
   alors toutes les colonnes du côté du publieur sont répliquées. Voir <xref
   linkend="sql-createpublication"/> pour les détails sur la syntaxe.
  </para>

  <para>
   Le choix des colonnes peut être basé sur des raisons de comportement ou de
   performance. Néanmoins, ne vous basez pas sur cette fonctionnalité pour de la
   sécurité&nbsp;: un abonné mal intentionné est capable d'obtenir des données
   des colonnes qui ne sont pas spécifiquement publiées. D'un point de vue
   sécurité, des protections peuvent être mises en place du côté du publieur.
  </para>

  <para>
   Si aucune liste de colonne n'est indiquée, toutes les colonnes ajoutées
   ultérieurement à la table sont automatiquement répliquées. Cela signifie
   qu'avoir une
   liste de colonnes qui nomme toutes les colonnes n'aboutit pas au même
   comportement que ne pas avoir de liste de colonnes.
  </para>

  <para>
   Une liste de colonnes peut contenir seulement des références de colonnes.
   L'ordre des colonnes dans la liste n'est pas préservé.
  </para>

  <para>
   Generated columns can also be specified in a column list. This allows
   generated columns to be published, regardless of the publication parameter
   <link linkend="sql-createpublication-params-with-publish-generated-columns">
   <literal>publish_generated_columns</literal></link>. See
   <xref linkend="logical-replication-gencols"/> for details.
  </para>

  <para>
   Préciser une liste de colonnes n'est pas possible quand la publication publie
   aussi toutes les tables d'un schéma (clause <link
   linkend="sql-createpublication-params-for-tables-in-schema"><literal>FOR TABLES IN
   SCHEMA</literal></link>).
  </para>

  <para>
   Pour les tables partitionnées, le paramètre de publication <link
   linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>
   détermine quel liste de
   colonnes utiliser. Si <literal>publish_via_partition_root</literal> vaut
   <literal>true</literal>, la liste de colonnes utilisée est celle de la table
   partitionnée. Sinon, si <literal>publish_via_partition_root</literal> vaut
   <literal>false</literal> (valeur par défaut), la liste de colonnes utilisée
   est celle de la partition concernée.
  </para>

  <para>
   Si une publication publie des opérations <command>UPDATE</command> ou
   <command>DELETE</command>, toute liste de colonnes doit inclure les colonnes
   d'identité de réplica de la table (voir <xref
   linkend="sql-altertable-replica-identity"/>). Si une publication publie
   seulement des opérations <command>INSERT</command>, alors la liste de
   colonnes peut omettre les colonnes d'identité de réplica.
  </para>

  <para>
   Les listes de colonnes n'ont pas d'effet sur la commande
   <literal>TRUNCATE</literal>.
  </para>

  <para>
   Lors de la synchronisation initiale des données, seules les colonnes publiées
   sont copiées. Néanmoins, si l'abonné est d'une version antérieure à la 15,
   alors toutes les colonnes dans la table sont copiées lors de la
   synchronisation initiale des données, ignorant en cela les liste de colonnes.
   If the subscriber is from a release prior to 18,
   then initial table synchronization won't copy generated columns even if they
   are defined in the publisher.
  </para>

  <warning id="logical-replication-col-list-combining">
   <title>Attention&nbsp;: Combiner des listes de plusieurs publications</title>
   <para>
    Actuellement, il n'est pas possible qu'une souscription soit entreprise
    auprès de plusieurs publications quand la même table a été publiée avec des
    listes de colonnes différentes. <xref linkend="sql-createsubscription"/>
    interdit la création de telles souscriptions mais il est toujours possible
    d'arriver dans cette situation par l'ajout ou la modification de listes de
    colonnes du côté publication une fois que la souscription a été créée.
   </para>
   <para>
    Ceci signifie que la modification de liste de colonnes sur les publications
    déjà souscrites peut amener à des erreurs du côté souscripteur.
   </para>
   <para>
    Si ce problème affecte une souscription, la seule façon de reprendre la
    réplication est d'ajuster une des listes de colonnes côté publication pour
    que les listes correspondent&nbsp;; puis soit de créer de nouveau la
    souscription, soit utiliser <link
    linkend="sql-altersubscription-params-setadddrop-publication">
    <literal>ALTER SUBSCRIPTION ... DROP PUBLICATION</literal></link> pour supprimer
    une des publications problématiques et l'ajouter de nouveau après.
   </para>
  </warning>

  <sect2 id="logical-replication-col-list-examples">
   <title>Exemples</title>

   <para>
    Créer une table <literal>t1</literal> à utiliser dans l'exemple suivant.
<programlisting>
/* pub # */ CREATE TABLE t1(id int, a text, b text, c text, d text, e text, PRIMARY KEY(id));
</programlisting></para>

   <para>
    Créer une publication <literal>p1</literal>. Une liste de colonnes est
    définie pour la table <literal>t1</literal> pour réduire le nombre de
    colonnes qui seront répliquées. Notez que l'ordre des noms de colonnes dans
    la liste de colonnes n'a pas d'importance.
<programlisting>
/* pub # */ CREATE PUBLICATION p1 FOR TABLE t1 (id, b, a, d);
</programlisting></para>

    <para>
     <literal>psql</literal> peut être utilisé pour afficher les listes de
     colonnes (si définies) pour chaque publication.
<programlisting>
/* pub # */ \dRp+
                               Publication p1
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t1" (id, a, b, d)
</programlisting></para>

    <para>
     <literal>psql</literal> peut être utilisé pour afficher les listes de
     colonnes (si définies) pour chaque table.
<programlisting>
/* pub # */ \d t1
                 Table "public.t1"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 id     | integer |           | not null |
 a      | text    |           |          |
 b      | text    |           |          |
 c      | text    |           |          |
 d      | text    |           |          |
 e      | text    |           |          |
Indexes:
    "t1_pkey" PRIMARY KEY, btree (id)
Publications:
    "p1" (id, a, b, d)
</programlisting></para>

    <para>
     Sur le nœud abonné, créer une table <literal>t1</literal> qui maintenant a
     seulement besoin d'un sous-ensemble des colonnes qui sont sur la table côté
     publieur <literal>t1</literal>, et crée aussi l'abonnement
     <literal>s1</literal> qui cible la publication <literal>p1</literal>.
<programlisting>
/* sub # */ CREATE TABLE t1(id int, b text, a text, d text, PRIMARY KEY(id));
/* sub # */ CREATE SUBSCRIPTION s1
/* sub - */ CONNECTION 'host=localhost dbname=test_pub application_name=s1'
/* sub - */ PUBLICATION p1;
</programlisting></para>

    <para>
     Sur le nœud publieur, insérer quelques lignes dans la table
     <literal>t1</literal>.
<programlisting>
/* pub # */ INSERT INTO t1 VALUES(1, 'a-1', 'b-1', 'c-1', 'd-1', 'e-1');
/* pub # */ INSERT INTO t1 VALUES(2, 'a-2', 'b-2', 'c-2', 'd-2', 'e-2');
/* pub # */ INSERT INTO t1 VALUES(3, 'a-3', 'b-3', 'c-3', 'd-3', 'e-3');
/* pub # */ SELECT * FROM t1 ORDER BY id;
 id |  a  |  b  |  c  |  d  |  e
----+-----+-----+-----+-----+-----
  1 | a-1 | b-1 | c-1 | d-1 | e-1
  2 | a-2 | b-2 | c-2 | d-2 | e-2
  3 | a-3 | b-3 | c-3 | d-3 | e-3
(3 rows)
</programlisting></para>

    <para>
     Seules les données de la liste de colonnes de la publication
     <literal>p1</literal> sont répliquées.
<programlisting>
/* sub # */ SELECT * FROM t1 ORDER BY id;
 id |  b  |  a  |  d
----+-----+-----+-----
  1 | b-1 | a-1 | d-1
  2 | b-2 | a-2 | d-2
  3 | b-3 | a-3 | d-3
(3 rows)
</programlisting></para>

  </sect2>

 </sect1>

 <sect1 id="logical-replication-gencols">
  <title>Generated Column Replication</title>

  <para>
   Typically, a table at the subscriber will be defined the same as the
   publisher table, so if the publisher table has a <link linkend="ddl-generated-columns">
   <literal>GENERATED column</literal></link> then the subscriber table will
   have a matching generated column. In this case, it is always the subscriber
   table generated column value that is used.
  </para>

  <para>
   For example, note below that subscriber table generated column value comes from the
   subscriber column's calculation.
<programlisting>
/* pub # */ CREATE TABLE tab_gen_to_gen (a int, b int GENERATED ALWAYS AS (a + 1) STORED);
/* pub # */ INSERT INTO tab_gen_to_gen VALUES (1),(2),(3);
/* pub # */ CREATE PUBLICATION pub1 FOR TABLE tab_gen_to_gen;
/* pub # */ SELECT * FROM tab_gen_to_gen;
 a | b
---+---
 1 | 2
 2 | 3
 3 | 4
(3 rows)

/* sub # */ CREATE TABLE tab_gen_to_gen (a int, b int GENERATED ALWAYS AS (a * 100) STORED);
/* sub # */ CREATE SUBSCRIPTION sub1 CONNECTION 'dbname=test_pub' PUBLICATION pub1;
/* sub # */ SELECT * from tab_gen_to_gen;
 a | b
---+----
 1 | 100
 2 | 200
 3 | 300
(3 rows)
</programlisting>
  </para>

  <para>
   In fact, prior to version 18.0, logical replication does not publish
   <literal>GENERATED</literal> columns at all.
  </para>

  <para>
   But, replicating a generated column to a regular column can sometimes be
   desirable.
   <tip>
    <para>
     This feature may be useful when replicating data to a
     non-PostgreSQL database via output plugin, especially if the target database
     does not support generated columns.
    </para>
  </tip>
  </para>

  <para>
   Generated columns are not published by default, but users can opt to
   publish stored generated columns just like regular ones.
  </para>

  <para>
   There are two ways to do this:
   <itemizedlist>
     <listitem>
      <para>
       Set the <command>PUBLICATION</command> parameter
       <link linkend="sql-createpublication-params-with-publish-generated-columns">
       <literal>publish_generated_columns</literal></link> to <literal>stored</literal>.
       This instructs PostgreSQL logical replication to publish current and
       future stored generated columns of the publication's tables.
      </para>
     </listitem>

     <listitem>
      <para>
       Specify a table <link linkend="logical-replication-col-lists">column list</link>
       to explicitly nominate which stored generated columns will be published.
      </para>

      <note>
       <para>
        When determining which table columns will be published, a column list
        takes precedence, overriding the effect of the
        <literal>publish_generated_columns</literal> parameter.
       </para>
      </note>
     </listitem>
   </itemizedlist>
  </para>

  <para>
   The following table summarizes behavior when there are generated columns
   involved in the logical replication. Results are shown for when
   publishing generated columns is not enabled, and for when it is
   enabled.
  </para>

  <table id="logical-replication-gencols-table-summary">
   <title>Replication Result Summary</title>
   <tgroup cols="4">

    <thead>
     <row>
      <entry>Publish generated columns?</entry>
      <entry>Publisher table column</entry>
      <entry>Subscriber table column</entry>
      <entry>Result</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>No</entry>
      <entry>GENERATED</entry>
      <entry>GENERATED</entry>
      <entry>Publisher table column is not replicated. Use the subscriber table generated column value.</entry>
     </row>

     <row>
      <entry>No</entry>
      <entry>GENERATED</entry>
      <entry>regular</entry>
      <entry>Publisher table column is not replicated. Use the subscriber table regular column default value.</entry>
     </row>

     <row>
      <entry>No</entry>
      <entry>GENERATED</entry>
      <entry>--missing--</entry>
      <entry>Publisher table column is not replicated. Nothing happens.</entry>
     </row>

     <row>
      <entry>Yes</entry>
      <entry>GENERATED</entry>
      <entry>GENERATED</entry>
      <entry>ERROR. Not supported.</entry>
     </row>

     <row>
      <entry>Yes</entry>
      <entry>GENERATED</entry>
      <entry>regular</entry>
      <entry>Publisher table column value is replicated to the subscriber table column.</entry>
     </row>

     <row>
      <entry>Yes</entry>
      <entry>GENERATED</entry>
      <entry>--missing--</entry>
      <entry>ERROR. The column is reported as missing from the subscriber table.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <warning>
   <para>
    There's currently no support for subscriptions comprising several
    publications where the same table has been published with different column
    lists. See <xref linkend="logical-replication-col-lists"/>.
   </para>

   <para>
    This same situation can occur if one publication is publishing generated
    columns, while another publication in the same subscription is not
    publishing generated columns for the same table.
   </para>
  </warning>

  <note>
   <para>
    If the subscriber is from a release prior to 18, then initial table
    synchronization won't copy generated columns even if they are defined in
    the publisher.
   </para>
  </note>
 </sect1>

 <sect1 id="logical-replication-conflicts">
  <title>Conflits</title>

  <para>
   La réplication logique se comporte de la même manière pour les opérations DML
   dans le sens où les données seront mises à jour même si la modification a été
   faite en local sur la base abonnée. Si les données entrantes entrainent des
   violations de contrainte d'intégrité, la réplication s'arrête. Cela sera
   référencé comme un <firstterm>conflit</firstterm>. Lorsque l'on réplique des
   opérations <command>UPDATE</command> ou <command>DELETE</command>, les
   données manquantes
   operations, missing data is also considered as a
   <firstterm>conflict</firstterm>, but does not result in an error and such
   operations will simply be skipped.
  </para>

  <para>
   Additional logging is triggered, and the conflict statistics are collected (displayed in the
   <link linkend="monitoring-pg-stat-subscription-stats"><structname>pg_stat_subscription_stats</structname></link> view)
   in the following <firstterm>conflict</firstterm> cases:
   <variablelist>
    <varlistentry id="conflict-insert-exists" xreflabel="insert_exists">
     <term><literal>insert_exists</literal></term>
     <listitem>
      <para>
       Inserting a row that violates a <literal>NOT DEFERRABLE</literal>
       unique constraint. Note that to log the origin and commit
       timestamp details of the conflicting key,
       <link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>
       should be enabled on the subscriber. In this case, an error will be
       raised until the conflict is resolved manually.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="conflict-update-origin-differs" xreflabel="update_origin_differs">
     <term><literal>update_origin_differs</literal></term>
     <listitem>
      <para>
       Updating a row that was previously modified by another origin.
       Note that this conflict can only be detected when
       <link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>
       is enabled on the subscriber. Currently, the update is always applied
       regardless of the origin of the local row.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="conflict-update-exists" xreflabel="update_exists">
     <term><literal>update_exists</literal></term>
     <listitem>
      <para>
       The updated value of a row violates a <literal>NOT DEFERRABLE</literal>
       unique constraint. Note that to log the origin and commit
       timestamp details of the conflicting key,
       <link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>
       should be enabled on the subscriber. In this case, an error will be
       raised until the conflict is resolved manually. Note that when updating a
       partitioned table, if the updated row value satisfies another partition
       constraint resulting in the row being inserted into a new partition, the
       <literal>insert_exists</literal> conflict may arise if the new row
       violates a <literal>NOT DEFERRABLE</literal> unique constraint.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="conflict-update-missing" xreflabel="update_missing">
     <term><literal>update_missing</literal></term>
     <listitem>
      <para>
       The tuple to be updated was not found. The update will simply be
       skipped in this scenario.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="conflict-delete-origin-differs" xreflabel="delete_origin_differs">
     <term><literal>delete_origin_differs</literal></term>
     <listitem>
      <para>
       Deleting a row that was previously modified by another origin. Note that
       this conflict can only be detected when
       <link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>
       is enabled on the subscriber. Currently, the delete is always applied
       regardless of the origin of the local row.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="conflict-delete-missing" xreflabel="delete_missing">
     <term><literal>delete_missing</literal></term>
     <listitem>
      <para>
       The tuple to be deleted was not found. The delete will simply be
       skipped in this scenario.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="conflict-multiple-unique-conflicts" xreflabel="multiple_unique_conflicts">
     <term><literal>multiple_unique_conflicts</literal></term>
     <listitem>
      <para>
       Inserting or updating a row violates multiple
       <literal>NOT DEFERRABLE</literal> unique constraints. Note that to log
       the origin and commit timestamp details of conflicting keys, ensure
       that <link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>
       is enabled on the subscriber. In this case, an error will be raised until
       the conflict is resolved manually.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
    Note that there are other conflict scenarios, such as exclusion constraint
    violations. Currently, we do not provide additional details for them in the
    log.
  </para>

  <para>
   The log format for logical replication conflicts is as follows:
<synopsis>
LOG:  conflict detected on relation "<replaceable>schemaname</replaceable>.<replaceable>tablename</replaceable>": conflict=<replaceable>conflict_type</replaceable>
DETAIL:  <replaceable class="parameter">detailed_explanation</replaceable>.
{<replaceable class="parameter">detail_values</replaceable> [; ... ]}.

<phrase>where <replaceable class="parameter">detail_values</replaceable> is one of:</phrase>

    <literal>Key</literal> (<replaceable>column_name</replaceable> <optional>, ...</optional>)=(<replaceable>column_value</replaceable> <optional>, ...</optional>)
    <literal>existing local tuple</literal> <optional>(<replaceable>column_name</replaceable> <optional>, ...</optional>)=</optional>(<replaceable>column_value</replaceable> <optional>, ...</optional>)
    <literal>remote tuple</literal> <optional>(<replaceable>column_name</replaceable> <optional>, ...</optional>)=</optional>(<replaceable>column_value</replaceable> <optional>, ...</optional>)
    <literal>replica identity</literal> {(<replaceable>column_name</replaceable> <optional>, ...</optional>)=(<replaceable>column_value</replaceable> <optional>, ...</optional>) | full <optional>(<replaceable>column_name</replaceable> <optional>, ...</optional>)=</optional>(<replaceable>column_value</replaceable> <optional>, ...</optional>)}
</synopsis>

   The log provides the following information:
   <variablelist>
    <varlistentry>
     <term><literal>LOG</literal></term>
      <listitem>
       <itemizedlist>
        <listitem>
         <para>
         <replaceable>schemaname</replaceable>.<replaceable>tablename</replaceable>
         identifies the local relation involved in the conflict.
         </para>
        </listitem>
        <listitem>
         <para>
         <replaceable>conflict_type</replaceable> is the type of conflict that occurred
         (e.g., <literal>insert_exists</literal>, <literal>update_exists</literal>).
         </para>
        </listitem>
       </itemizedlist>
      </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>DETAIL</literal></term>
      <listitem>
      <itemizedlist>
       <listitem>
        <para>
         <replaceable class="parameter">detailed_explanation</replaceable> includes
         the origin, transaction ID, and commit timestamp of the transaction that
         modified the existing local tuple, if available.
        </para>
       </listitem>
       <listitem>
        <para>
         The <literal>Key</literal> section includes the key values of the local
         tuple that violated a unique constraint for
         <literal>insert_exists</literal>, <literal>update_exists</literal> or
         <literal>multiple_unique_conflicts</literal> conflicts.
        </para>
       </listitem>
       <listitem>
        <para>
         The <literal>existing local tuple</literal> section includes the local
         tuple if its origin differs from the remote tuple for
         <literal>update_origin_differs</literal> or <literal>delete_origin_differs</literal>
         conflicts, or if the key value conflicts with the remote tuple for
         <literal>insert_exists</literal>, <literal>update_exists</literal> or
         <literal>multiple_unique_conflicts</literal> conflicts.
        </para>
       </listitem>
       <listitem>
        <para>
         The <literal>remote tuple</literal> section includes the new tuple from
         the remote insert or update operation that caused the conflict. Note that
         for an update operation, the column value of the new tuple will be null
         if the value is unchanged and toasted.
        </para>
       </listitem>
       <listitem>
        <para>
         The <literal>replica identity</literal> section includes the replica
         identity key values that were used to search for the existing local
         tuple to be updated or deleted. This may include the full tuple value
         if the local relation is marked with
         <link linkend="sql-altertable-replica-identity-full"><literal>REPLICA IDENTITY FULL</literal></link>.
        </para>
       </listitem>
       <listitem>
        <para>
         <replaceable class="parameter">column_name</replaceable> is the column name.
         For <literal>existing local tuple</literal>, <literal>remote tuple</literal>,
         and <literal>replica identity full</literal> cases, column names are
         logged only if the user lacks the privilege to access all columns of
         the table. If column names are present, they appear in the same order
         as the corresponding column values.
        </para>
       </listitem>
       <listitem>
        <para>
         <replaceable class="parameter">column_value</replaceable> is the column value.
         The large column values are truncated to 64 bytes.
        </para>
       </listitem>
       <listitem>
        <para>
         Note that in case of <literal>multiple_unique_conflicts</literal> conflict,
         multiple <replaceable class="parameter">detailed_explanation</replaceable>
         and <replaceable class="parameter">detail_values</replaceable> lines
         will be generated, each detailing the conflict information associated
         with distinct unique
         constraints.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Les opérations de réplication logique sont réalisées avec les droits du
   propriétaire de la souscription. Les échecs de droit sur les tables cibles
   causeront des conflits de réplication, tout autant que l'activation de <link
   linkend="ddl-rowsecurity">politiques de sécurité au niveau ligne</link> sur
   des tables cibles et pour lesquels le propriétaire de la souscription est
   sujet des politiques de sécurité, sans chercher si une politique rejetterait
   habituellement les opérations <command>INSERT</command>,
   <command>UPDATE</command>, <command>DELETE</command> ou
   <command>TRUNCATE</command> en cours de réplication. Cette restriction sur
   les politiques de sécurité niveau ligne pourrait être supprimée dans une
   prochaine version de <productname>PostgreSQL</productname>.
  </para>

  <para>
   Lorsqu'un conflit entraine une erreur, cela stoppe la réplication&nbsp;; Le
   conflit devra être résolu manuellement par un utilisateur. Des informations
   détaillées concernant le conflit seront disponibles dans les journaux
   applicatifs de l'instance abonnée.
  </para>

  <para>
   La résolution peut être réalisée, soit en changeant les données ou les droits
   sur la base abonnée pour qu'elles ne soient plus en conflit avec les données
   entrantes ou en évitant les transactions qui sont en conflit avec les données
   existantes. Quand un conflit produit une erreur, la réplication ne peut pas
   continuer et le processus worker de la réplication logique émet un message du
   type suivant dans les journaux applicatifs de l'abonné&nbsp;:
<screen>
ERROR:  conflict detected on relation "public.test": conflict=insert_exists
DETAIL:  Key already exists in unique index "t_pkey", which was modified locally in transaction 740 at 2024-06-26 10:47:04.727375+08.
+Key (c)=(1); existing local tuple (1, 'local'); remote tuple (1, 'remote').
CONTEXT:  processing remote data for replication origin "pg_16395" during "INSERT" for replication target relation "public.test" in transaction 725 finished at 0/14C0378
</screen>
   Le LSN de la transaction qui contient le changement violant la contrainte et
   le nom d'origine de réplication peuvent être trouvés à partir du journal
   applicatif du serveur (LSN 0/14C0378 et origine de réplication
   <literal>pg_16395</literal> dans le cas ci-dessus). La transaction qui a
   produit le conflit peut être ignorée en utilisant l'instruction
   <link linkend="sql-altersubscription-params-skip"><command>ALTER SUBSCRIPTION
    ... SKIP</command></link> avec le LSN final (LSN
   0/14C0378). Le LSN final pourrait être un LSN sur lequel la transaction est
   validée ou préparée sur le publieur. La transaction peut aussi être ignorée
   en appelant la fonction <link
   linkend="pg-replication-origin-advance"><function>pg_replication_origin_advance()</function></link>.
   Avant d'utiliser cette fonction, la souscription doit être désactivée
   temporairement soit par <link linkend="sql-altersubscription-params-disable">
   <command>ALTER SUBSCRIPTION ... DISABLE</command></link>
   soit en utilisant l'option <link
   linkend="sql-createsubscription-params-with-disable-on-error"><literal>disable_on_error</literal></link>
   de la souscription. Ensuite, vous pouvez utiliser la fonction
   <function>pg_replication_origin_advance()</function> avec
   <parameter>node_name</parameter> (<literal>pg_16395</literal>) et le LSN
   suivant du LSN final (0/14C0379). La position actuelle des origines peut être
   trouvée dans la vue système <link
   linkend="view-pg-replication-origin-status"><structname>pg_replication_origin_status</structname></link>.
   Merci de noter qu'ignorer la transaction complète inclut d'ignorer des
   changements qui pourraient ne pas violer des contraintes. Ceci peut rendre
   l'abonné incohérent très facilement.
   The additional details regarding conflicting rows, such as their origin and
   commit timestamp can be seen in the <literal>DETAIL</literal> line of the
   log. But note that this information is only available when
   <link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>
   is enabled on the subscriber. Users can use this information to decide
   whether to retain the local change or adopt the remote alteration. For
   instance, the <literal>DETAIL</literal> line in the above log indicates that
   the existing row was modified locally. Users can manually perform a
   remote-change-win.
  </para>

  <para>
   Quand le mode <link linkend="sql-createsubscription-params-with-streaming"><literal>streaming</literal></link>
   vaut <literal>parallel</literal>, le LSN final des transactions en échec peut ne pas être
   journalisé. Dans ce cas, il peut être nécessaire de changer le mode
   de flux (streaming) à <literal>on</literal> ou <literal>off</literal> et provoquer
   les même conflits encore pour que le LSN final des transactions échouées soit écrit dans
   le journal du serveur. Pour l'utilisation du LSN final, veuillez vous reférer à
   <link
   linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION ... SKIP</command></link>.
  </para>
 </sect1>

 <sect1 id="logical-replication-restrictions">
  <title>Restrictions</title>

  <para>
   La réplication logique souffre actuellement des restrictions ou des
   fonctionnalités manquantes suivantes. Elles pourraient être adressées dans
   les prochaines versions.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     La structure de la base de données et les commandes DDL ne sont pas
     répliquées. Le schéma initial peut être copié à la main en utilisant la
     commande <literal>pg_dump --schema-only</literal>. Les modifications de
     schéma suivantes auront besoin d'être synchronisées manuellement. (Notez,
     néanmoins, qu'il n'est pas nécessaire que les schémas soient strictement
     identiques des deux côtés.) La réplication logique est robuste quand il y a
     des modifications de schéma dans une base de données. Quand le schéma est
     changé sur le publieur et les données répliquées commencent à arriver sur
     l'abonné mais ne correspondent pas à la structure de la table, la
     réplication renverra une erreur jusqu'à ce que le schéma soit mis à jour.
     Dans de nombreux cas, les erreurs intermittentes peuvent être évitées en
     appliquant des modifications de schéma à l'abonné en premier&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Les données des séquences ne sont pas répliquées. Les données des colonnes
     de type serial et des colonnes identité, gérées par des séquences, seront
     bien sûr répliquées comme faisant partie de la table, mais la séquence
     elle-même affichera toujours la valeur de démarrage sur l'abonné. Si
     l'abonné est utilisé comme une base de données en lecture seule, alors cela
     ne devrait pas être un problème. Néanmoins, s'il est nécessaire de faire un
     bascule (<foreignphrase>switchover</foreignphrase> ou
     <foreignphrase>failover</foreignphrase> sur la base de données abonnée,
     alors les séquences auront besoin d'être mises à jour à leur dernières
     valeurs, soit en copiant les données courantes du publieur (peut-être en
     utilisant <command>pg_dump</command>), soit en déterminant une valeur
     suffisamment haute à partir des données de la table&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     La réplication des commandes <command>TRUNCATE</command> est supportée mais
     il est nécessaire de prêter attention lors de l'utilisation de cette
     commande sur des groupes de tables connectés par des clés étrangères. Lors
     de la réplication d'une action truncate, l'abonné tronquera le même groupe
     de tables tronquées sur le publieur, qu'elles soient spécifiées
     explicitement ou implicitement (grâce à la clause
     <literal>CASCADE</literal>), moins les tables qui ne font pas partie de la
     souscription. Ceci fonctionnera correctement si toutes les tables affectées
     font partie de la même souscription. Cependant, si certaines tables à
     tronquer ont des clés étrangères vers des tables qui ne font pas partie de
     la même souscription, alors l'application de l'action truncate échouera sur
     le serveur abonné&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Les Large Objects (voir <xref linkend="largeobjects"/>) ne sont pas
     répliqués. Il n'y a pas de contournement pour ça, en dehors d'enregistrer
     les données dans des tables normales&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     La réplication est seulement supportée par les tables, y compris les tables
     partitionnées. Toute tentative de répliquer d'autres types de relation,
     comme les vues, les vues matérialisées ou les tables externes, résultera en
     une erreur&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Lors de la réplication entre tables partitionnées, la réplication actuelle
     a pour origine, par défaut, les partitions filles sur le publieur, donc les
     partitions sur le publieur doivent exister aussi sur l'abonné en tant que
     tables cibles valides. Elles peuvent être soit des partitions filles
     elles-mêmes, soit de nouveau sous-partitionnées, soit des tables
     indépendantes. Les publications peuvent aussi spécifier les changements à
     répliquer en utilisant l'identité et le schéma de la table racine
     partitionnée au lieu de chaque partition individuelle à l'origine des
     changements (voir le paramètre
     <link linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>
     de <command>CREATE PUBLICATION</command>).
    </para>
   </listitem>

   <listitem>
    <para>
     Lors de l'utilisation de <link
     linkend="sql-altertable-replica-identity-full"><literal>REPLICA IDENTITY
     FULL</literal></link> sur les tables publiées, il est important de noter
     que les opérations <literal>UPDATE</literal> et <literal>DELETE</literal>
     ne peuvent être appliquées aux abonnés si les tables incluent des
     attributs avec les types de données (tels que point ou box) qui n'ont pas
     une classe d'opérateurs par défaut pour les méthodes B-tree ou Hash.
     Néanmoins, cette limitation peut être contournée en s'assurant que la
     table a une clé primaire ou une identité de réplica.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="logical-replication-architecture">
  <title>Architecture</title>

  <para>
   La réplication se construit de façon similaire à la réplication physique en
   flux (<foreignphrase>Streaming Replication</foreignphrase>, voir <xref
   linkend="streaming-replication"/>). Ceci est implémenté par les processus
   <literal>walsender</literal> et <literal>apply</literal>. Le processus walsender
   démarre le décodage logique (décrit dans la section <xref
   linkend="protocol-logical-replication"/>) des fichiers WAL et charge le
   plugin de décodage logique standard (<literal>pgoutput</literal>). Ce plugin
   transforme les
   changements lus depuis les fichiers WAL vers le protocole de réplication
   logique (voir <xref linkend="protocol-logical-replication"/>) et filtre les
   données en fonction des spécificités des publications. Les données sont
   envoyées au fil de l'eau au processus apply, qui met en relation les données
   vers les tables locales et applique les changements individuels au moment où
   ils sont reçus, dans le bon ordre transactionnel.
  </para>

  <para>
   Le processus apply sur l'instance de la base abonnée fonctionne toujours avec
   le paramètre <varname>session_replication_role</varname> défini à la valeur
   <literal>replica</literal>, qui produit les effets habituels sur les triggers
   et les contraintes.
  </para>

  <para>
   Le processus apply de la réplication logique déclenche actuellement des
   triggers de ligne, et non pas des triggers de requêtes. Néanmoins, la
   synchronisation initiale des tables est implémentée comme une commande
   <command>COPY</command>, ce qui peut déclencher les triggers
   <command>INSERT</command> en mode ligne et requête.
  </para>

  <sect2 id="logical-replication-snapshot">
   <title>Instantané initial</title>

   <para>
    The initial data in existing subscribed tables are snapshotted and
    copied in parallel instances of a special kind of apply process.
    These special apply processes are dedicated table synchronization
    workers, spawned for each table to be synchronized.  Each table
    synchronization process will create its own replication slot and
    copy the existing data.  As soon as the copy is finished the table
    contents will become visible to other backends.  Once existing data
    is copied, the worker enters synchronization mode, which ensures
    that the table is brought up to a synchronized state with the main
    apply process by streaming any changes that happened during the
    initial data copy using standard logical replication.  During this
    synchronization phase, the changes are applied and committed in the same
    order as they happened on the publisher.  Once synchronization is done,
    control of the replication of the table is given back to the main apply
    process where replication continues as normal.
    Les données initiales présentes dans des tables abonnées sont photographiées
    et copiées dans une instance parallèle qui utilise un type particulier de
    processus apply. Ce processus va créer son propre slot de réplication et
    copier les données existantes. Dès que la copie est terminée, le contenu de
    la table deviendra visible aux autres processus. Une fois les données
    existantes copiées, le processus passe en mode de synchronisation, qui
    assure que la table est amenée vers un état synchronisé avec le processus
    apply principal, ceci en transférant toutes les modifications survenues
    pendant la copie initiale des données, réalisée avec le système de
    réplication logique standard. Lors de cette phase de synchronisation, les
    changements sont appliqués et validés dans le même ordre que sur le
    publieur. Une fois la synchronisation terminée, le contrôle de la
    réplication de la table est rendu au processus apply principal et la
    réplication continue telle quelle.
   </para>

   <note>
    <para>
     Le paramètre de publication  <link
     linkend="sql-createpublication-params-with-publish"><literal>publish</literal></link>
     affecte uniquement
     les opérations DML qui seront répliquées. La synchronisation initiale des
     données ne prend pas ce paramètre en compte lors de la copie des données
     existantes de la table.
    </para>
   </note>

   <note>
    <para>
     If a table synchronization worker fails during copy, the apply worker
     detects the failure and respawns the table synchronization worker to
     continue the synchronization process. This behaviour ensures that
     transient errors do not permanently disrupt the replication setup. See
     also <link linkend="guc-wal-retrieve-retry-interval"><varname>wal_retrieve_retry_interval</varname></link>.
    </para>
   </note>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-monitoring">
  <title>Supervision</title>

  <para>
   Puisque la réplication logique est basée sur une architecture similaire à la
   <link linkend="streaming-replication">réplication physique en flux</link>, la
   supervision d'une instance publication est similaire à la supervision d'une
   instance primaire dans la réplication physique (voir <xref
   linkend="streaming-replication-monitoring"/>).
  </para>

  <para>
   Les informations des abonnements sont consultables dans la vue <link
   linkend="monitoring-pg-stat-subscription"><structname>pg_stat_subscription</structname></link>.
   Cette vue contient une ligne pour chaque processus d'abonnement. Un
   abonnement peut avoir zéro ou plusieurs processus abonnés, selon son état.
  </para>

  <para>
   Normalement il y a un seul processus apply démarré pour un abonnement actif.
   Un abonnement désactivé ou une publication effondrée n'aura pas de ligne dans
   cette vue. Si la synchronisation initiale d'une table est en cours, il y
   aura des processus supplémentaires pour les tables en cours de
   synchronisation. En outre, si la transaction
   <link linkend="sql-createsubscription-params-with-streaming"><literal>streaming</literal></link>
   est appliquée en parallèle, il y aura des processus apply parallèles supplémentaires.
  </para>
 </sect1>

 <sect1 id="logical-replication-security">
  <title>Sécurité</title>

  <para>
   Le rôle utilisée pour la réplication doit avoir l'attribut
   <literal>REPLICATION</literal> (ou être un superutilisateur). Si le rôle ne
   dispose pas des attributs <literal>SUPERUSER</literal> et
   <literal>BYPASSRLS</literal>, les politiques de sécurité niveau ligne du
   publieur peuvent s'exécuter. Si le rôle n'a pas confiance en tous les
   propriétaires de tables, incluez
   <literal>options=-crow_security=off</literal> dans la chaîne de
   connexion&nbsp;;: si un propriétaire de table ajoute ensuite une politique de
   sécurité de ligne, cette configuration imposera un arrêt de la réplication
   plutôt qu'une exécution de la politique. L'accès de ce rôle à l'instance doit
   avoir été déclaré dans <filename>pg_hba.conf</filename> et ce rôle doit avoir
   l'attribut <literal>LOGIN</literal>.
  </para>

  <para>
   Pour être capable de copier les données originales de la table, le rôle
   utilisé pour la connexion de réplication doit avoir le droit
   <literal>SELECT</literal> sur une table publiée (ou être un
   superutilisateur).
  </para>

  <para>
   Pour créer une publication, l'utilisateur doit avoir le droit
   <literal>CREATE</literal> pour la base de données.
  </para>

  <para>
   Pour ajouter des tables à une publication, l'utilisateur doit être
   propriétaire de ces tables. Pour ajouter toutes les tables d'un schéma dans
   une publication, l'utilisateur doit avoir l'attribut
   <literal>SUPERUSER</literal>. Pour créer une publication qui publie toutes
   les tables ou toutes les tables d'un schéma automatiquement, l'utilisateur
   doit avoir l'attribut <literal>SUPERUSER</literal>.
  </para>

  <para>
   Actuellement, il n'y a aucun droit sur les abonnements. Tout abonnement (qui
   est capable de se connecter) peut accéder à n'importe quelle publication. Ainsi,
   si vous avez l'intention de cacher certaines informations à certains abonnés, en utilisant
   le filtrage de ligne ou les listes de colonnes, ou en n'ajoutant pas la totalité de la table
   à la publication, soyez averti que les autres publications dans la même base de données
   pourront exposer les mêmes informations. Les droits de publication pourront être
   ajoutés à <productname>PostgreSQL</productname> dans le futur pour permettre un
   contrôle d'accès plus fin.
  </para>

  <para>
   Pour créer un abonnement, l'utilisateur doit avoir les droits du
   rôle <literal>pg_create_subscription</literal> ainsi que le droit
   <literal>CREATE</literal> sur la base de données.
  </para>

  <para>
   Le processus d'application de l'abonnement va, au niveau de la session, s'exécuter
   avec les droits du propriétaire de l'abonnement. Cependant, quand une opération
   d'insertion, de mise à jour, de suppression ou de troncation est effectuée sur
   un table donnée, le rôle sera interverti avec celui du propriétaire de la table
   et l'opération effectuée avec les droits du propriétaire de la table.
   Cela signifie que le propriétaire de l'abonnement doit pouvoir faire un
   <literal>SET ROLE</literal> sur chacun des rôles propriétaires des tables répliquées.
  </para>

  <para>
   Si l'abonnement a été configuré avec <literal>run_as_owner = true</literal>,
   alors aucun changement d'utilisateur ne sera possible. À la place,
   les opérations seront effectuées avec les droits du propriétaire de l'abonnement.
   Dans ce cas, le propriétaire de l'abonnement nécessite seulement des droits
   pour <literal>SELECT</literal>, <literal>INSERT</literal>,
   <literal>UPDATE</literal> et <literal>DELETE</literal> sur les tables cibles,
   et n'a pas besoin de droits pour faire un <literal>SET ROLE</literal> sur
   les propriétaires des tables. Cependant, cela implique aussi que n'importe
   quel utilisateur propriétaire de table sur laquelle la réplication s'applique,
   pourra exécuter du code arbitrairement avec les droits du propriétaire de
   l'abonnement. Par exemple, ils pourront effectuer cela simplement en
   attachant un trigger à une des tables dont ils sont propriétaires.
   Parce qu'il est fortement indésirable de permettre à un rôle d'assumer librement
   les droits d'un autre, cette option devrait être évitée sauf si la sécurité
   de la base de données n'est pas un problème.
  </para>

  <para>
   Sur le publieur, les droits sont vérifiés uniquement au démarrage de la
   connexion de réplication et ne sont pas vérifiés de nouveau à chaque fois
   qu'un enregistrement de changement est lu.
  </para>

  <para>
   Sur l'abonné, les droits du propriétaire de la souscription sont vérifiés à
   chaque application d'une transaction. Si un processus worker est en cours de
   traitement pour appliquer une transaction au moment où le propriétaire de la
   souscription est changé dans une transaction concurrente, l'application de la
   transaction en cours continuera sous les droits de l'ancien propriétaire.
  </para>
 </sect1>

 <sect1 id="logical-replication-config">
  <title>Paramètres de configuration</title>

  <para>
   La réplication logique requiert de nombreuses configurations pour
   fonctionner. Ces options ne sont pertinentes que d'un côté de la réplication.
  </para>

  <sect2 id="logical-replication-config-publisher">
   <title>Publieurs</title>

   <para>
    <link linkend="guc-wal-level"><varname>wal_level</varname></link> doit être
    mis à <literal>logical</literal>.
   </para>

   <para>
    <link linkend="guc-max-replication-slots"><varname>max_replication_slots</varname></link>
    doit être mis au moins au nombre d'abonnements attendus de se connecter, plus
    une réserve pour la synchronisation des tables.
   </para>

   <para>
    Logical replication slots are also affected by
    <link linkend="guc-idle-replication-slot-timeout"><varname>idle_replication_slot_timeout</varname></link>.
   </para>

   <para>
    <link linkend="guc-max-wal-senders"><varname>max_wal_senders</varname></link>
    doit être mis à au moins la même valeur que <varname>max_replication_slots</varname>, plus le nombre de
    réplicas physiques qui sont connectés en même temps.
   </para>

   <para>
    Le walsender de réplication logique est aussi impacté par
    <link linkend="guc-wal-sender-timeout"><varname>wal_sender_timeout</varname></link>.
   </para>

  </sect2>

  <sect2 id="logical-replication-config-subscriber">
   <title>Abonnés</title>

   <para>
    <link linkend="guc-max-active-replication-origins"><varname>max_active_replication_origins</varname></link>
    doit être mis à au moins le nombre d'abonnements qui seront ajoutés à l'abonné, plus une réserve
    pour la synchronisation des tables.
   </para>

   <para>
    <link linkend="guc-max-logical-replication-workers"><varname>max_logical_replication_workers</varname></link>
    doit être mis à au moins le nombre d'abonnements (pour les processus apply leader),
    plus une réserve pour les processus de synchronisation des tables et les processus apply parallèles.
   </para>

   <para>
    <link linkend="guc-max-worker-processes"><varname>max_worker_processes</varname></link>
    peut être ajusté pour accommoder les processus de réplication, au moins
    (<link linkend="guc-max-logical-replication-workers"><varname>max_logical_replication_workers</varname></link>
    <literal>1</literal>). Notez que certaines extensions et requêtes parallèles puisent aussi
    des slots de processus dans <varname>max_worker_processes</varname>.
   </para>

   <para>
    <link linkend="guc-max-sync-workers-per-subscription"><varname>max_sync_workers_per_subscription</varname></link>
    contrôle la quantité de parallélisme lors de la copie initiale des données lors de
    l'initialisation de l'abonnement ou quand des nouvelles tables sont ajoutées.
   </para>

   <para>
    <link linkend="guc-max-parallel-apply-workers-per-subscription"><varname>max_parallel_apply_workers_per_subscription</varname></link>
    contrôle la quantité de parallélisme pour le flux des transaction en cours avec
    le paramètre d'abonnement <literal>streaming = parallel</literal>.
   </para>

   <para>
    Les processus de réplication logique sont aussi affectés par
    <link linkend="guc-wal-receiver-timeout"><varname>wal_receiver_timeout</varname></link>,
    <link linkend="guc-wal-receiver-status-interval"><varname>wal_receiver_status_interval</varname></link> et
    <link linkend="guc-wal-retrieve-retry-interval"><varname>wal_retrieve_retry_interval</varname></link>.
   </para>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-upgrade">
  <title>Upgrade</title>

  <para>
   Migration of <glossterm linkend="glossary-logical-replication-cluster">logical replication clusters</glossterm>
   is possible only when all the members of the old logical replication
   clusters are version 17.0 or later.
  </para>

  <sect2 id="prepare-publisher-upgrades">
   <title>Prepare for publisher upgrades</title>

   <para>
    <application>pg_upgrade</application> attempts to migrate logical
    slots. This helps avoid the need for manually defining the same
    logical slots on the new publisher. Migration of logical slots is
    only supported when the old cluster is version 17.0 or later.
    Logical slots on clusters before version 17.0 will silently be
    ignored.
   </para>

   <para>
    Before you start upgrading the publisher cluster, ensure that the
    subscription is temporarily disabled, by executing
    <link linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>.
    Re-enable the subscription after the upgrade.
   </para>

   <para>
    There are some prerequisites for <application>pg_upgrade</application> to
    be able to upgrade the logical slots. If these are not met an error
    will be reported.
   </para>

   <itemizedlist>
    <listitem>
     <para>
      The new cluster must have
      <link linkend="guc-wal-level"><varname>wal_level</varname></link> as
      <literal>logical</literal>.
     </para>
    </listitem>
    <listitem>
     <para>
      The new cluster must have
      <link linkend="guc-max-replication-slots"><varname>max_replication_slots</varname></link>
      configured to a value greater than or equal to the number of slots
      present in the old cluster.
     </para>
    </listitem>
    <listitem>
     <para>
      The output plugins referenced by the slots on the old cluster must be
      installed in the new PostgreSQL executable directory.
     </para>
    </listitem>
    <listitem>
     <para>
      The old cluster has replicated all the transactions and logical decoding
      messages to subscribers.
     </para>
    </listitem>
    <listitem>
     <para>
      All slots on the old cluster must be usable, i.e., there are no slots
      whose
      <link linkend="view-pg-replication-slots">pg_replication_slots</link>.<structfield>conflicting</structfield>
      is not <literal>true</literal>.
     </para>
    </listitem>
    <listitem>
     <para>
      The new cluster must not have permanent logical slots, i.e.,
      there must be no slots where
      <link linkend="view-pg-replication-slots">pg_replication_slots</link>.<structfield>temporary</structfield>
      is <literal>false</literal>.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 id="prepare-subscriber-upgrades">
   <title>Prepare for subscriber upgrades</title>

   <para>
    Setup the <link linkend="logical-replication-config-subscriber">
    subscriber configurations</link> in the new subscriber.
    <application>pg_upgrade</application> attempts to migrate subscription
    dependencies which includes the subscription's table information present in
    <link linkend="catalog-pg-subscription-rel">pg_subscription_rel</link>
    system catalog and also the subscription's replication origin. This allows
    logical replication on the new subscriber to continue from where the
    old subscriber was up to. Migration of subscription dependencies is only
    supported when the old cluster is version 17.0 or later. Subscription
    dependencies on clusters before version 17.0 will silently be ignored.
   </para>

   <para>
    There are some prerequisites for <application>pg_upgrade</application> to
    be able to upgrade the subscriptions. If these are not met an error
    will be reported.
   </para>

   <itemizedlist>
    <listitem>
     <para>
      All the subscription tables in the old subscriber should be in state
      <literal>i</literal> (initialize) or <literal>r</literal> (ready). This
      can be verified by checking <link linkend="catalog-pg-subscription-rel">pg_subscription_rel</link>.<structfield>srsubstate</structfield>.
     </para>
    </listitem>
    <listitem>
     <para>
      The replication origin entry corresponding to each of the subscriptions
      should exist in the old cluster. This can be found by checking
      <link linkend="catalog-pg-subscription">pg_subscription</link> and
      <link linkend="catalog-pg-replication-origin">pg_replication_origin</link>
      system tables.
     </para>
    </listitem>
    <listitem>
     <para>
      The new cluster must have
      <link linkend="guc-max-active-replication-origins"><varname>max_active_replication_origins</varname></link>
      configured to a value greater than or equal to the number of
      subscriptions present in the old cluster.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 id="upgrading-logical-replication-clusters">
   <title>Upgrading logical replication clusters</title>

   <para>
    While upgrading a subscriber, write operations can be performed in the
    publisher. These changes will be replicated to the subscriber once the
    subscriber upgrade is completed.
   </para>

   <note>
    <para>
     The logical replication restrictions apply to logical replication cluster
     upgrades also. See <xref linkend="logical-replication-restrictions"/> for
     details.
    </para>
    <para>
     The prerequisites of publisher upgrade apply to logical replication
     cluster upgrades also. See <xref linkend="prepare-publisher-upgrades"/>
     for details.
    </para>
    <para>
     The prerequisites of subscriber upgrade apply to logical replication
     cluster upgrades also. See <xref linkend="prepare-subscriber-upgrades"/>
     for details.
    </para>
   </note>

   <warning>
    <para>
     Upgrading logical replication cluster requires multiple steps to be
     performed on various nodes. Because not all operations are
     transactional, the user is advised to take backups as described in
     <xref linkend="backup-base-backup"/>.
    </para>
   </warning>

   <para>
    The steps to upgrade the following logical replication clusters are
    detailed below:
    <itemizedlist>
     <listitem>
      <para>
       Follow the steps specified in
       <xref linkend="steps-two-node-logical-replication-cluster"/> to upgrade
       a two-node logical replication cluster.
      </para>
     </listitem>
     <listitem>
      <para>
       Follow the steps specified in
       <xref linkend="steps-cascaded-logical-replication-cluster"/> to upgrade
       a cascaded logical replication cluster.
      </para>
     </listitem>
     <listitem>
      <para>
       Follow the steps specified in
       <xref linkend="steps-two-node-circular-logical-replication-cluster"/>
       to upgrade a two-node circular logical replication cluster.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <sect3 id="steps-two-node-logical-replication-cluster">
    <title>Steps to upgrade a two-node logical replication cluster</title>
     <para>
      Let's say publisher is in <literal>node1</literal> and subscriber is
      in <literal>node2</literal>. The subscriber <literal>node2</literal> has
      a subscription <literal>sub1_node1_node2</literal> which is subscribing
      the changes from <literal>node1</literal>.
     </para>

     <procedure>
      <step id="two-node-cluster-disable-subscriptions-node2">
       <para>
        Disable all the subscriptions on <literal>node2</literal> that are
        subscribing the changes from <literal>node1</literal> by using
        <link linkend="sql-altersubscription-params-disable"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>,
        e.g.:
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 DISABLE;
</programlisting>
       </para>
      </step>
      <step>
       <para>
        Stop the publisher server in <literal>node1</literal>, e.g.:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data1 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Initialize <literal>data1_upgraded</literal> instance by using the
        required newer version.
       </para>
      </step>

      <step>
       <para>
        Upgrade the publisher <literal>node1</literal>'s server to the
        required newer version, e.g.:
<programlisting>
pg_upgrade
        --old-datadir "/opt/PostgreSQL/postgres/17/data1"
        --new-datadir "/opt/PostgreSQL/postgres/18/data1_upgraded"
        --old-bindir "/opt/PostgreSQL/postgres/17/bin"
        --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Start the upgraded publisher server in <literal>node1</literal>, e.g.:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data1_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Stop the subscriber server in <literal>node2</literal>, e.g.:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data2 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Initialize <literal>data2_upgraded</literal> instance by using the
        required newer version.
       </para>
      </step>

      <step>
       <para>
        Upgrade the subscriber <literal>node2</literal>'s server to
        the required new version, e.g.:
<programlisting>
pg_upgrade
       --old-datadir "/opt/PostgreSQL/postgres/17/data2"
       --new-datadir "/opt/PostgreSQL/postgres/18/data2_upgraded"
       --old-bindir "/opt/PostgreSQL/postgres/17/bin"
       --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Start the upgraded subscriber server in <literal>node2</literal>, e.g.:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data2_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step>
       <para>
        On <literal>node2</literal>, create any tables that were created in
        the upgraded publisher <literal>node1</literal> server between
        <xref linkend="two-node-cluster-disable-subscriptions-node2"/>
        and now, e.g.:
<programlisting>
/* node2 # */ CREATE TABLE distributors (did integer PRIMARY KEY, name varchar(40));
CREATE TABLE
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Enable all the subscriptions on <literal>node2</literal> that are
        subscribing the changes from <literal>node1</literal> by using
        <link linkend="sql-altersubscription-params-enable"><command>ALTER SUBSCRIPTION ... ENABLE</command></link>,
        e.g.:
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 ENABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Refresh the <literal>node2</literal> subscription's publications using
        <link linkend="sql-altersubscription-params-refresh-publication"><command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command></link>,
        e.g.:
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 REFRESH PUBLICATION;
</programlisting>
       </para>
      </step>
     </procedure>

     <note>
      <para>
       In the steps described above, the publisher is upgraded first, followed
       by the subscriber. Alternatively, the user can use similar steps to
       upgrade the subscriber first, followed by the publisher.
      </para>
     </note>
    </sect3>

    <sect3 id="steps-cascaded-logical-replication-cluster">
     <title>Steps to upgrade a cascaded logical replication cluster</title>
     <para>
      Let's say we have a cascaded logical replication setup
      <literal>node1</literal>-><literal>node2</literal>-><literal>node3</literal>.
      Here <literal>node2</literal> is subscribing the changes from
      <literal>node1</literal> and <literal>node3</literal> is subscribing
      the changes from <literal>node2</literal>. The <literal>node2</literal>
      has a subscription <literal>sub1_node1_node2</literal> which is
      subscribing the changes from <literal>node1</literal>. The
      <literal>node3</literal> has a subscription
      <literal>sub1_node2_node3</literal> which is subscribing the changes from
      <literal>node2</literal>.
     </para>

     <procedure>
      <step id="cascaded-cluster-disable-sub-node1-node2">
       <para>
        Disable all the subscriptions on <literal>node2</literal> that are
        subscribing the changes from <literal>node1</literal> by using
        <link linkend="sql-altersubscription-params-disable"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>,
        e.g.:
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 DISABLE;
ALTER SUBSCRIPTION
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Stop the server in <literal>node1</literal>, e.g.:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data1 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Initialize <literal>data1_upgraded</literal> instance by using the
        required newer version.
       </para>
      </step>

      <step>
       <para>
        Upgrade the <literal>node1</literal>'s server to the required newer
        version, e.g.:
<programlisting>
pg_upgrade
        --old-datadir "/opt/PostgreSQL/postgres/17/data1"
        --new-datadir "/opt/PostgreSQL/postgres/18/data1_upgraded"
        --old-bindir "/opt/PostgreSQL/postgres/17/bin"
        --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Start the upgraded server in <literal>node1</literal>, e.g.:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data1_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step id="cascaded-cluster-disable-sub-node2-node3">
       <para>
        Disable all the subscriptions on <literal>node3</literal> that are
        subscribing the changes from <literal>node2</literal> by using
        <link linkend="sql-altersubscription-params-disable"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>,
        e.g.:
<programlisting>
/* node3 # */ ALTER SUBSCRIPTION sub1_node2_node3 DISABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Stop the server in <literal>node2</literal>, e.g.:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data2 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Initialize <literal>data2_upgraded</literal> instance by using the
        required newer version.
       </para>
      </step>

      <step>
       <para>
        Upgrade the <literal>node2</literal>'s server to the required
        new version, e.g.:
<programlisting>
pg_upgrade
        --old-datadir "/opt/PostgreSQL/postgres/17/data2"
        --new-datadir "/opt/PostgreSQL/postgres/18/data2_upgraded"
        --old-bindir "/opt/PostgreSQL/postgres/17/bin"
        --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Start the upgraded server in <literal>node2</literal>, e.g.:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data2_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step>
       <para>
        On <literal>node2</literal>, create any tables that were created in
        the upgraded publisher <literal>node1</literal> server between
        <xref linkend="cascaded-cluster-disable-sub-node1-node2"/>
        and now, e.g.:
<programlisting>
/* node2 # */ CREATE TABLE distributors (did integer PRIMARY KEY, name varchar(40));
CREATE TABLE
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Enable all the subscriptions on <literal>node2</literal> that are
        subscribing the changes from <literal>node1</literal> by using
        <link linkend="sql-altersubscription-params-enable"><command>ALTER SUBSCRIPTION ... ENABLE</command></link>,
        e.g.:
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 ENABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Refresh the <literal>node2</literal> subscription's publications using
        <link linkend="sql-altersubscription-params-refresh-publication"><command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command></link>,
        e.g.:
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 REFRESH PUBLICATION;
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Stop the server in <literal>node3</literal>, e.g.:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data3 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Initialize <literal>data3_upgraded</literal> instance by using the
        required newer version.
       </para>
      </step>

      <step>
       <para>
        Upgrade the <literal>node3</literal>'s server to the required
        new version, e.g.:
<programlisting>
pg_upgrade
        --old-datadir "/opt/PostgreSQL/postgres/17/data3"
        --new-datadir "/opt/PostgreSQL/postgres/18/data3_upgraded"
        --old-bindir "/opt/PostgreSQL/postgres/17/bin"
        --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Start the upgraded server in <literal>node3</literal>, e.g.:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data3_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step>
       <para>
        On <literal>node3</literal>, create any tables that were created in
        the upgraded <literal>node2</literal> between
        <xref linkend="cascaded-cluster-disable-sub-node2-node3"/> and now,
        e.g.:
<programlisting>
/* node3 # */ CREATE TABLE distributors (did integer PRIMARY KEY, name varchar(40));
CREATE TABLE
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Enable all the subscriptions on <literal>node3</literal> that are
        subscribing the changes from <literal>node2</literal> by using
        <link linkend="sql-altersubscription-params-enable"><command>ALTER SUBSCRIPTION ... ENABLE</command></link>,
        e.g.:
<programlisting>
/* node3 # */ ALTER SUBSCRIPTION sub1_node2_node3 ENABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Refresh the <literal>node3</literal> subscription's publications using
        <link linkend="sql-altersubscription-params-refresh-publication"><command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command></link>,
        e.g.:
<programlisting>
/* node3 # */ ALTER SUBSCRIPTION sub1_node2_node3 REFRESH PUBLICATION;
</programlisting>
       </para>
      </step>
     </procedure>
    </sect3>

    <sect3 id="steps-two-node-circular-logical-replication-cluster">
     <title>Steps to upgrade a two-node circular logical replication cluster</title>
     <para>
      Let's say we have a circular logical replication setup
      <literal>node1</literal>-><literal>node2</literal> and
      <literal>node2</literal>-><literal>node1</literal>. Here
      <literal>node2</literal> is subscribing the changes from
      <literal>node1</literal> and <literal>node1</literal> is subscribing
      the changes from <literal>node2</literal>. The <literal>node1</literal>
      has a subscription <literal>sub1_node2_node1</literal> which is
      subscribing the changes from <literal>node2</literal>. The
      <literal>node2</literal> has a subscription
      <literal>sub1_node1_node2</literal> which is subscribing the changes from
      <literal>node1</literal>.
     </para>

     <procedure>
      <step id="circular-cluster-disable-sub-node2">
       <para>
        Disable all the subscriptions on <literal>node2</literal> that are
        subscribing the changes from <literal>node1</literal> by using
        <link linkend="sql-altersubscription-params-disable"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>,
        e.g.:
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 DISABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Stop the server in <literal>node1</literal>, e.g.:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data1 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Initialize <literal>data1_upgraded</literal> instance by using the
        required newer version.
       </para>
      </step>

      <step>
       <para>
        Upgrade the <literal>node1</literal>'s server to the required
        newer version, e.g.:
<programlisting>
pg_upgrade
        --old-datadir "/opt/PostgreSQL/postgres/17/data1"
        --new-datadir "/opt/PostgreSQL/postgres/18/data1_upgraded"
        --old-bindir "/opt/PostgreSQL/postgres/17/bin"
        --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Start the upgraded server in <literal>node1</literal>, e.g.:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data1_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Enable all the subscriptions on <literal>node2</literal> that are
        subscribing the changes from <literal>node1</literal> by using
        <link linkend="sql-altersubscription-params-enable"><command>ALTER SUBSCRIPTION ... ENABLE</command></link>,
        e.g.:
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 ENABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
        On <literal>node1</literal>, create any tables that were created in
        <literal>node2</literal> between <xref linkend="circular-cluster-disable-sub-node2"/>
        and now, e.g.:
<programlisting>
node1=# CREATE TABLE distributors (did integer PRIMARY KEY, name varchar(40));
</programlisting>
       </para>
      </step>


      <step>
       <para>
        Refresh the <literal>node1</literal> subscription's publications to
        copy initial table data from <literal>node2</literal> using
        <link linkend="sql-altersubscription-params-refresh-publication"><command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command></link>,
        e.g.:
<programlisting>
node1=# ALTER SUBSCRIPTION sub1_node2_node1 REFRESH PUBLICATION;
</programlisting>
       </para>
      </step>

      <step id="circular-cluster-disable-sub-node1">
       <para>
        Disable all the subscriptions on <literal>node1</literal> that are
        subscribing the changes from <literal>node2</literal> by using
        <link linkend="sql-altersubscription-params-disable"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>,
        e.g.:
<programlisting>
node1=# ALTER SUBSCRIPTION sub1_node2_node1 DISABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Stop the server in <literal>node2</literal>, e.g.:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data2 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Initialize <literal>data2_upgraded</literal> instance by using the
        required newer version.
       </para>
      </step>

      <step>
       <para>
        Upgrade the <literal>node2</literal>'s server to the required
        new version, e.g.:
<programlisting>
pg_upgrade
        --old-datadir "/opt/PostgreSQL/postgres/17/data2"
        --new-datadir "/opt/PostgreSQL/postgres/18/data2_upgraded"
        --old-bindir "/opt/PostgreSQL/postgres/17/bin"
        --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Start the upgraded server in <literal>node2</literal>, e.g.:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data2_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Enable all the subscriptions on <literal>node1</literal> that are
        subscribing the changes from <literal>node2</literal> by using
        <link linkend="sql-altersubscription-params-enable"><command>ALTER SUBSCRIPTION ... ENABLE</command></link>,
        e.g.:
<programlisting>
node1=# ALTER SUBSCRIPTION sub1_node2_node1 ENABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
        On <literal>node2</literal>, create any tables that were created in
        the upgraded <literal>node1</literal> between <xref linkend="circular-cluster-disable-sub-node1"/>
        and now, e.g.:
<programlisting>
/* node2 # */ CREATE TABLE distributors (did integer PRIMARY KEY, name varchar(40));
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Refresh the <literal>node2</literal> subscription's publications to
        copy initial table data from <literal>node1</literal> using
        <link linkend="sql-altersubscription-params-refresh-publication"><command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command></link>,
        e.g.:
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 REFRESH PUBLICATION;
</programlisting>
       </para>
      </step>
     </procedure>
    </sect3>

   </sect2>
 </sect1>

 <sect1 id="logical-replication-quick-setup">
  <title>Démarrage rapide</title>

  <para>
   En premier, définissez les options de configurations dans le fichier
   <filename>postgresql.conf</filename>&nbsp;:
   <programlisting>wal_level = logical</programlisting>
   La valeur par défaut des autres paramètres est suffisante pour une mise en
   place de base.
  </para>

  <para>
   Le fichier <filename>pg_hba.conf</filename> doit être mis à jour pour
   autoriser la réplication (les valeurs dépendent de la configuration réelle de
   votre réseau et de l'utilisateur dont vous disposerez pour vous
   connecter)&nbsp;:
   <programlisting>host     all     repuser     0.0.0.0/0     md5</programlisting>
  </para>

  <para>
   Ensuite sur la base du publieur&nbsp;:
   <programlisting>
CREATE PUBLICATION mypub FOR TABLE users, departments;
   </programlisting>
  </para>

  <para>
   Et sur la base abonnée&nbsp;:
   <programlisting>
CREATE SUBSCRIPTION mysub CONNECTION 'dbname=foo host=bar user=repuser' PUBLICATION mypub;
   </programlisting>
  </para>

  <para>
   Les instructions précédentes vont démarrer le processus de réplication, qui
   va réaliser la synchronisation initiale du contenu des tables
   <literal>users</literal> et <literal>departments</literal> et qui commencera
   ensuite à répliquer les changements de manière incrémentale sur ces tables.
  </para>
 </sect1>
</chapter>
