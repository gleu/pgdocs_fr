<?xml version="1.0" encoding="UTF-8"?>
<chapter id="logical-replication">
 <title>Réplication logique</title>

 <para>
  La réplication logique est une méthode permettant de répliquer des données au
  niveau objet ainsi que les modifications apportées à ces objets, ceci basé sur
  leur identité de réplication (habituellement la clé primaire). L'utilisation
  du terme de <quote>réplication logique</quote> est faite en opposition à la
  réplication physique, cette dernière utilisant l'adresse exacte des blocs couplée
  avec une réplication octet par octet. PostgreSQL supporte ces deux méthodes,
  référez-vous à l'article <xref linkend="high-availability"/>. La réplication
  logique permet un contrôle fin des données au niveau de la réplication et de
  la sécurité.
 </para>

 <para>
  La réplication logique utilise un système de
  <firstterm>publication</firstterm> / <firstterm>abonnement</firstterm> avec un
  ou plusieurs <firstterm>abonnés</firstterm> qui s'abonnent à une ou plusieurs
  <firstterm>publications</firstterm> d'un nœud particulier. Les abonnés
  récupèrent les données des publications auxquelles ils sont abonnés et peuvent
  éventuellement renvoyer ces informations, ce qui permet un système de
  réplication en cascade dans le cas de configurations plus complexes.
 </para>

 <para>
  Quand la réplication logique d'une table commence, PostgreSQL prend une
  image des données de la table sur le publieur et la copie sur l'abonné.
  Une fois cette copie initiale terminée, les modifications qui ont eu lieu
  sur le publieur depuis le début de copie initiale sont envoyées en continue
  à l'abonné. La base abonnée applique les
  modifications dans le même ordre qu'elles auront été réalisées de façon à ce
  que la cohérence transactionnelle soit garantie pour les publications d'un
  seul abonnement. Cette méthode de réplication porte parfois le nom de
  réplication transactionnelle.
 </para>

 <para>
  Les cas typiques d'utilisation de la réplication logique peuvent être les
  suivants&nbsp;:

  <itemizedlist>
   <listitem>
    <para>
     Envoyer immédiatement les changements réalisés sur une base de données, ou
     sur un sous-ensemble de ces données, de façon incrémentale à une base de
     données abonnée;
    </para>
   </listitem>

   <listitem>
    <para>
     Déclencher des triggers pour des changements spécifiques lorsqu'ils
     apparaissent sur la base de données abonnée&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Réaliser la consolidation de plusieurs bases de données au sein d'une seule
     (par exemple pour répondre à des problématiques analytiques)&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Répliquer entre des versions majeures différentes de PostgreSQL&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Répliquer des instances PostgreSQL sur des plateformes différentes (par
     exemple de Linux à Windows)&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Donner accès à des données répliquées à différents groupes d'utilisateurs&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Partager un sous-ensemble de données entre plusieurs bases de données.
    </para>
   </listitem>
  </itemizedlist>
 </para>

 <para>
  Une base de données abonnée se comporte comme n'importe quelle autre base de
  données d'une instance PostgreSQL et peut être utilisée comme base de données
  de publication pour d'autres bases de données en lui définissant ses propres
  publications. Lorsque la base abonnée est considérée comme une base en
  lecture seule par l'application, il ne va pas y avoir de problèmes de conflits.
  D'un autre côté, s'il y a des écritures provenant soit de l'application soit
  d'un autre abonnement sur le même ensemble de tables, des conflits peuvent
  survenir.
 </para>

 <sect1 id="logical-replication-publication">
  <title>Publication</title>

  <para>
   Une <firstterm>publication</firstterm> peut être définie sur n'importe quel
   serveur primaire de réplication physique. Le nœud sur laquelle la
   publication est définie est nommé <firstterm>publieur</firstterm>. Une
   publication est un ensemble de modifications générées par une table ou un
   groupe de tables et peut aussi être défini comme un ensemble de modifications
   ou un ensemble de réplication. Chaque publication existe au sein d'une seule
   base de données.
  </para>

  <para>
   Les publications sont différenciées du schéma et n'ont pas d'impact sur la
   manière dont la base est accédée. Chaque table peut être ajoutée à
   différentes publications au besoin. Actuellement, les publications ne
   contiennent que les tables et toutes les tables d'un schéma. Les objets
   doivent être ajoutés explicitement, sauf si la publication a été créée pour
   toutes les tables (<literal>ALL TABLES</literal>).
  </para>

  <para>
   Les publications peuvent choisir de limiter les changements qu'elles
   produisent avec n'importe quelle combinaison de <command>INSERT</command>,
   <command>UPDATE</command>, <command>DELETE</command> et
   <command>TRUNCATE</command>, ceci d'une façon similaire à l'activation de
   triggers en fonction d'un certain type d'événement. Par défaut, tous les
   types d'opération sont répliqués. Ces spécifications de publication
   s'appliquent seulement pour les opérations DML&nbsp;; elles n'affectent pas
   la copie initiale de synchronisation des données. (Les filtres de ligne
   n'ont pas d'effet pour la commande <command>TRUNCATE</command>. Voir <xref
   linkend="logical-replication-row-filter"/>.)
  </para>

  <para>
   Chaque publication peut avoir plusieurs abonnés.
  </para>

  <para>
   Une publication est créée en utilisant la commande <link
   linkend="sql-createpublication"><command>CREATE PUBLICATION</command></link>
   et peut ensuite être modifiée ou supprimée en utilisant la commande
   correspondante.
  </para>

  <para>
   Les tables individuelles peuvent être ajoutées ou supprimées dynamiquement en
   utilisant <link linkend="sql-alterpublication"><command>ALTER
   PUBLICATION</command></link>. Les opérations <literal>ADD TABLE</literal> et
   <literal>DROP TABLE</literal> sont toutes les deux transactionnelles&nbsp;;
   de ce fait, une table va commencer ou arrêter de répliquer dans le bon
   instantané seulement une fois que la transaction a été validée.
  </para>

  <sect2 id="logical-replication-publication-replica-identity">
   <title>Identité de réplicat</title>

   <para>
    Une table publiée doit avoir une <firstterm>identité de réplicat</firstterm>
    configurée pour être capable de répliquer les opérations
    <command>UPDATE</command> et <command>DELETE</command>, pour que les lignes
    ciblées par les mises à jour ou suppressions puissent être identifiées sur
    l'abonné.
   </para>

   <para>
    Par défaut, il s'agit de la clé primaire, s'il en existe une. Une contrainte
    d'unicité (avec quelques prérequis supplémentaires) peut aussi être
    configurée comme une identité de réplicat. Si la table n'a pas de contrainte
    convenable, alors son identité de réplicat peut être configurée à
    <literal>FULL</literal>, ce qui signifie que la ligne entière devient la
    clé. Quand l'identité de réplicat <literal>FULL</literal> est indiquée,
    les index peuvent être utilisés sur le côté abonné pour rechercher les
    lignes. Les index candidats doivent être des btree ou des hash, non
    partiels, et le champ le plus à gauche doit être une colonne (pas une
    expression) qui référence la colonne de la table publiée. Ces restrictions
    sur les propriétés de l'index (sans unicité) adhèrent à certaines des
    restrictions posées sur les clés primaires. Si aucun index ne convient,
    la recherche sur l'abonné peut être très inefficace, donc l'identité de
    réplicat <literal>FULL</literal> doit seulement être utilisée si aucune
    autre solution n'est possible.
   </para>

   <para>
    Si une identité de réplicat autre que <literal>FULL</literal> est configuré
    sur le côté publieur, une identité de réplicat comprenant les mêmes colonnes
    ou moins de colonnes doit être configuré sur le côté abonné.
   </para>

   <para>
    Les tables avec une identité de réplicat définie comme
    <literal>NOTHING</literal>, <literal>DEFAULT</literal> sans une clé
    primaire, ou <literal>USING INDEX</literal> avec une clé supprimée, ne
    peuvent pas prendre en compte des opérations <command>UPDATE</command> ou
    <command>DELETE</command> lorsqu'elles sont inclus dans une publication
    répliquant ces actions. Tenter de telles opérations résultera en une erreur
    sur le publieur.
   </para>

   <para>
    Les opérations <command>INSERT</command> peuvent s'exécuter quelque soit
    l'identité de réplicat.
   </para>

   <para>
    Voir <link linkend="sql-altertable-replica-identity"><literal>ALTER
    TABLE...REPLICA IDENTITY</literal></link> pour des détails sur la
    configuration de l'identité de réplicat.
   </para>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-subscription">
  <title>Abonnement</title>

  <para>
   Un <firstterm>abonnement</firstterm> est le côté aval de la réplication
   logique. Le nœud où un abonnement a été défini est nommé
   <firstterm>abonné</firstterm>. Un abonnement définit la connexion à une
   autre base de données et un ensemble de publications (une ou plus) auxquelles
   l'abonné veut souscrire.
  </para>

  <para>
   La base de données abonnée se comporte comme n'importe quelle base de données
   d'une instance PostgreSQL et peut être utilisée comme éditeur pour d'autres
   bases de données en définissant ses propres publications.
  </para>

  <para>
   Un nœud abonné peut avoir plusieurs abonnements si besoin. Il est possible de
   définir plusieurs abonnements entre une même paire publieur - abonné. Dans ce
   cas, il faut faire attention à ce que les objets des publications auxquelles
   l'abonné a souscrit ne se chevauchent pas.
  </para>

  <para>
   Chaque abonnement recevra les changements par un slot de réplication (voir
   <xref linkend="streaming-replication-slots"/>). Des slots de réplications
   supplémentaires peuvent être nécessaires pour la synchronisation initiale des
   données d'une table contenant des données pré-existantes mais ils seront
   supprimés à la fin de la synchronisation des données.
  </para>

  <para>
   Un abonnement de réplication logique peut être réalisé sur un serveur
   secondaire pour de la réplication synchrone (voir <xref
   linkend="synchronous-replication"/>). Le nom du serveur secondaire
   correspond par défaut au nom de l'abonnement. Un nom alternatif peut être
   indiqué avec le paramètre <literal>application_name</literal> dans les
   informations de connexion à l'abonnement.
  </para>

  <para>
   Les abonnements sont sauvegardés par <command>pg_dump</command> si
   l'utilisateur courant a des droits de superutilisateur. Si ce n'est pas le
   cas, un message d'avertissement est renvoyé et les abonnements ne sont pas
   sauvegardés. En effet, les informations d'abonnements contenues dans
   <structname>pg_subscription</structname> ne sont pas consultables par des
   utilisateurs dotés de droits moins importants.
  </para>

  <para>
   Un abonnement est ajouté en utilisant <link
   linkend="sql-createsubscription"><command>CREATE
   SUBSCRIPTION</command></link>. Il peut être arrêté/repris à n'importe quel
   moment en utilisant la commande <link
   linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION</command></link>,
   et il peut être supprimé par la commande <link
   linkend="sql-dropsubscription"><command>DROP SUBSCRIPTION</command></link>.
  </para>

  <para>
   Quand un abonnement est supprimé puis recréé, les informations de
   synchronisation sont perdues. Cela signifie que les données doivent être
   resynchronisées ensuite.
  </para>

  <para>
   La définition d'un schéma n'est pas répliquée, et les tables publiées doivent
   exister sur la base abonnée. Seules des tables standards peuvent accueillir
   des données répliquées. Par exemple, il n'est pas pas possible de répliquer
   dans une vue.
  </para>

  <para>
   La correspondance entre les tables du publieur et de l'abonné est réalisée en
   utilisant le nom entièrement qualifié de la table. La réplication entre des
   tables portant un nom différent sur la base abonnée n'est pas supportée.
  </para>

  <para>
   La correspondance sur les colonnes d'une table se fait aussi par nom.
   L'ordre des colonnes dans la table sur le serveur abonné ne correspond pas
   forcément à l'ordre sur le serveur publieur. Les types de données n'ont pas
   non plus besoin de correspondre, à partir du moment où la représentation
   textuelle de la donnée peut être convertie vers le type de données cible.
   Par exemple, vous pouvez répliquer depuis une colonne de type <type>integer</type>
   vers une colonne de type <type>bigint</type>. La table cible peut aussi avoir
   des colonnes supplémentaires non fournies par la table publiée. Ce type de
   colonne sera rempli avec la valeur par défaut fournie dans la définition de
   la table cible. Cependant, la réplication logique en format binaire est plus
   restrictive. Voir l'option
   <link linkend="sql-createsubscription-params-with-binary"><literal>binary</literal></link>
   de <command>CREATE SUBSCRIPTION</command> pour les détails.
  </para>

  <sect2 id="logical-replication-subscription-slot">
   <title>Gestion des slots de réplication</title>

   <para>
    Comme présenté plus tôt, chaque abonnement (actif) reçoit les changements
    depuis un slot de réplication du serveur distant (publication).
   </para>

   <para>
    Des slots de synchronisation de tables supplémentaires sont normalement
    temporaires, créés en interne pour réaliser la synchronisation initiale des
    tables et supprimés automatiquement quand elles ne sont plus nécessaires.
    Ces slots de synchronisation de table ont des noms générés
    automatiquement&nbsp;: <quote><literal>pg_%u_sync_%u_%llu</literal></quote>
    (paramètres <parameter>oid</parameter> de la souscription,
    <parameter>relid</parameter> de la table, <parameter>sysid</parameter> pour
    l'identifiant du système).
   </para>

   <para>
    Normalement, le slot de réplication distant est créé automatiquement en
    utilisant la commande <link linkend="sql-createsubscription">
    <command>CREATE SUBSCRIPTION</command></link> et il est
    supprimé automatiquement en utilisant la commande <link
    linkend="sql-dropsubscription"><command>DROP SUBSCRIPTION</command></link>.
    Dans certaines situations, il peut être utile ou
    nécessaire de manipuler les abonnements ainsi que les slots de réplication
    sous-jacents de façon séparées. Voici quelques exemples&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       Lorsqu'en créant un abonnement, le slot de réplication correspondant
       existe déjà. Dans ce cas, l'abonnement peut être créé en utilisant
       l'option <literal>create_slot = false</literal> pour réaliser
       l'association avec le slot existant&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       Lorsqu'en créant un abonnement, le serveur distant n'est pas disponible
       ou dans un état indéfini. Dans ce cas, l'abonnement peut être créé en
       utilisant l'option <literal>connect = false</literal>. Le serveur
       distant ne sera alors jamais contacté. C'est la méthode utilisée par
       <application>pg_dump</application>. Le slot de réplication distant devra
       alors être créé manuellement avant que l'abonnement ne puisse être
       activé&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       Lorsqu'on supprime un abonnement et que le slot de réplication doit être
       conservé, par exemple lorsqu'une base abonnée est déplacée vers un
       serveur différent et sera activée depuis cette nouvelle localisation.
       Dans ce cas, il faut dissocier le slot de réplication de l'abonnement
       correspondant en utilisant la commande <link
       linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION</command></link>
       avant de supprimer l'abonnement&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       Lorsque l'on supprime un abonnement et que le serveur distant n'est pas
       joignable. Dans ce cas, il faut aussi dissocier le slot de réplication de
       l'abonnement correspondant en utilisant <command>ALTER
       SUBSCRIPTION</command> avant de supprimer l'abonnement. Si l'instance
       distante n'existe plus, aucune action supplémentaire n'est nécessaire.
       Si, par contre, l'instance distante est simplement temporairement
       injoignable, le slot de réplication (et tout slot de synchronisation de
       table restant) devrait être supprimé manuellement, sinon l'instance va
       persévérer à conserver ses fichiers WAL jusqu'à saturation de l'espace
       disque disponible. Ces cas doivent être traités avec beaucoup de
       précautions.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>

  <sect2 id="logical-replication-subscription-examples">
    <title>Exemples&nbsp;: Mettre en place la réplication logique</title>

    <para>
     Créer des tables tests sur le publieur.
<programlisting>
/* pub # */ CREATE TABLE t1(a int, b text, PRIMARY KEY(a));
/* pub # */ CREATE TABLE t2(c int, d text, PRIMARY KEY(c));
/* pub # */ CREATE TABLE t3(e int, f text, PRIMARY KEY(e));
</programlisting></para>

    <para>
     Créer les mêmes tables sur l'abonné.
<programlisting>
/* sub # */ CREATE TABLE t1(a int, b text, PRIMARY KEY(a));
/* sub # */ CREATE TABLE t2(c int, d text, PRIMARY KEY(c));
/* sub # */ CREATE TABLE t3(e int, f text, PRIMARY KEY(e));
</programlisting></para>

    <para>
     Insérer des données sur les tables du côté publieur.
<programlisting>
/* pub # */ INSERT INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'three');
/* pub # */ INSERT INTO t2 VALUES (1, 'A'), (2, 'B'), (3, 'C');
/* pub # */ INSERT INTO t3 VALUES (1, 'i'), (2, 'ii'), (3, 'iii');
</programlisting></para>

    <para>
     Créer les publications pour les tables. Les publications
     <literal>pub2</literal> et <literal>pub3a</literal> interdisent certaines
     opérations <link
     linkend="sql-createpublication-params-with-publish"><literal>publish</literal></link>.
     La publication <literal>pub3b</literal> a un filtre de lignes (voir <xref
     linkend="logical-replication-row-filter"/>).
<programlisting><![CDATA[
/* pub # */ CREATE PUBLICATION pub1 FOR TABLE t1;
/* pub # */ CREATE PUBLICATION pub2 FOR TABLE t2 WITH (publish = 'truncate');
/* pub # */ CREATE PUBLICATION pub3a FOR TABLE t3 WITH (publish = 'truncate');
/* pub # */ CREATE PUBLICATION pub3b FOR TABLE t3 WHERE (e > 5);
]]></programlisting></para>

    <para>
     Créer les abonnements (souscriptions) pour les publications. La
     souscription <literal>sub3</literal> s'abonne à <literal>pub3a</literal> et
     <literal>pub3b</literal>. Toutes les souscriptions copieront les données
     initiales par défaut.
<programlisting>
/* sub # */ CREATE SUBSCRIPTION sub1
/* sub - */ CONNECTION 'host=localhost dbname=test_pub application_name=sub1'
/* sub - */ PUBLICATION pub1;
/* sub # */ CREATE SUBSCRIPTION sub2
/* sub - */ CONNECTION 'host=localhost dbname=test_pub application_name=sub2'
/* sub - */ PUBLICATION pub2;
/* sub # */ CREATE SUBSCRIPTION sub3
/* sub - */ CONNECTION 'host=localhost dbname=test_pub application_name=sub3'
/* sub - */ PUBLICATION pub3a, pub3b;
</programlisting></para>

    <para>
     Observez que les données initiales des tables sont copiées, quelque soit
     l'opération <literal>publish</literal> de la publication.
<programlisting>
/* sub # */ SELECT * FROM t1;
 a |   b
---+-------
 1 | one
 2 | two
 3 | three
(3 rows)

/* sub # */ SELECT * FROM t2;
 c | d
---+---
 1 | A
 2 | B
 3 | C
(3 rows)
</programlisting></para>

    <para>
     De plus, comme la copie initiale de données ignore l'opération
     <literal>publish</literal> et comme la publication <literal>pub3a</literal>
     n'a pas de filtre de lignes, cela signifie que la table
     <literal>t3</literal> copiée contient toutes les lignes même quand elles ne
     correspondent pas au filtre de lignes de la publication
     <literal>pub3b</literal>.
<programlisting>
/* sub # */ SELECT * FROM t3;
 e |  f
---+-----
 1 | i
 2 | ii
 3 | iii
(3 rows)
</programlisting></para>

   <para>
    Insérer plus de données dans les tables du côté publieur.
<programlisting>
/* pub # */ INSERT INTO t1 VALUES (4, 'four'), (5, 'five'), (6, 'six');
/* pub # */ INSERT INTO t2 VALUES (4, 'D'), (5, 'E'), (6, 'F');
/* pub # */ INSERT INTO t3 VALUES (4, 'iv'), (5, 'v'), (6, 'vi');
</programlisting></para>

   <para>
    Maintenant, les données du côté publieur ressemblent à ceci&nbsp;:
<programlisting>
/* pub # */ SELECT * FROM t1;
 a |   b
---+-------
 1 | one
 2 | two
 3 | three
 4 | four
 5 | five
 6 | six
(6 rows)

/* pub # */ SELECT * FROM t2;
 c | d
---+---
 1 | A
 2 | B
 3 | C
 4 | D
 5 | E
 6 | F
(6 rows)

/* pub # */ SELECT * FROM t3;
 e |  f
---+-----
 1 | i
 2 | ii
 3 | iii
 4 | iv
 5 | v
 6 | vi
(6 rows)
</programlisting></para>

   <para>
    Observez que, durant la réplication normale, les opérations
    <literal>publish</literal> appropriées sont utilisées. Cela signifie que les
    publications <literal>pub2</literal> et <literal>pub3a</literal> ne
    répliquent pas les opérations <literal>INSERT</literal>. De plus, la
    publication <literal>pub3b</literal> répliquera seulement les données
    correspondant au filtre de lignes de <literal>pub3b</literal>. Maintenant,
    les données du côté abonné ressemblent à ceci&nbsp;:
<programlisting>
/* sub # */ SELECT * FROM t1;
 a |   b
---+-------
 1 | one
 2 | two
 3 | three
 4 | four
 5 | five
 6 | six
(6 rows)

/* sub # */ SELECT * FROM t2;
 c | d
---+---
 1 | A
 2 | B
 3 | C
(3 rows)

/* sub # */ SELECT * FROM t3;
 e |  f
---+-----
 1 | i
 2 | ii
 3 | iii
 6 | vi
(4 rows)
</programlisting></para>
  </sect2>

  <sect2 id="logical-replication-subscription-examples-deferred-slot">
   <title>Exemples&nbsp;: Création de slot de réplication différée</title>

   <para>
    Dans certains cas (i.e
    <xref linkend="logical-replication-subscription-slot"/>), si le slot de réplication
    n'a pas été créé automatiquement, l'utilisateur doit le créer manuellement
    avant que la souscription ne soit activée. Les étapes pour créer le slot et activer
    la souscription sont indiquées dans les exemples suivants.
    Ces exemples spécifient le plugin de décodage logique standard
    (<literal>pgoutput</literal>), qui est utilisé par la réplication logique interne.
   </para>
   <para>
    D'abord, créer une publication pour les exemples.
<programlisting>
/* pub # */ CREATE PUBLICATION pub1 FOR ALL TABLES;
</programlisting>
   </para>
   <para>
    Exemple 1&nbsp;: Quand l'abonnement indique <literal>connect = false</literal>
   </para>
   <para>
    <itemizedlist>
     <listitem>
      <para>
       Créez l'abonnement.
<programlisting>
/* sub # */ CREATE SUBSCRIPTION sub1
/* sub - */ CONNECTION 'host=localhost dbname=test_pub'
/* sub - */ PUBLICATION pub1
/* sub - */ WITH (connect=false);
WARNING:  subscription was created, but is not connected
HINT:  To initiate replication, you must manually create the replication slot, enable the subscription, and refresh the subscription.
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Sur le publieur, créer manuellement le slot. Comme son nom n'a pas été
       spécifié lors de <literal>CREATE SUBSCRIPTION</literal>, le nom du slot à créer
       est le même que le nom d'abonnement, i.e. "sub1".
<programlisting>
/* pub # */ SELECT * FROM pg_create_logical_replication_slot('sub1', 'pgoutput');
 slot_name |    lsn
-----------+-----------
 sub1      | 0/19404D0
(1 row)
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Sur l'abonné, complétez l'activation de l'abonnement. Après cela,
       les tables de <literal>pub1</literal> commenceront à répliquer.
<programlisting>
/* sub # */ ALTER SUBSCRIPTION sub1 ENABLE;
/* sub # */ ALTER SUBSCRIPTION sub1 REFRESH PUBLICATION;
</programlisting></para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Exemple 2&nbsp;: Quand l'abonnement indique <literal>connect = false</literal>,
    mais spécifie aussi l'option
    <link linkend="sql-createsubscription-params-with-slot-name"><literal>slot_name</literal></link>.
    <itemizedlist>
     <listitem>
      <para>
       Créez l'abonnement.
<programlisting>
/* sub # */ CREATE SUBSCRIPTION sub1
/* sub - */ CONNECTION 'host=localhost dbname=test_pub'
/* sub - */ PUBLICATION pub1
/* sub - */ WITH (connect=false, slot_name='myslot');
WARNING:  subscription was created, but is not connected
HINT:  To initiate replication, you must manually create the replication slot, enable the subscription, and refresh the subscription.
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Sur le publieur, créez manuellement un slot en utilisant le même nom que
       celui spécifié lors de <literal>CREATE SUBSCRIPTION</literal>, i.e. "myslot".
<programlisting>
/* pub # */ SELECT * FROM pg_create_logical_replication_slot('myslot', 'pgoutput');
 slot_name |    lsn
-----------+-----------
 myslot    | 0/19059A0
(1 row)
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Sur l'abonné, les étapes restantes d'activation d'abonnement sont les mêmes
       que précédemment.
<programlisting>
/* sub # */ ALTER SUBSCRIPTION sub1 ENABLE;
/* sub # */ ALTER SUBSCRIPTION sub1 REFRESH PUBLICATION;
</programlisting></para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Exemple 3&nbsp;: Quand l'abonnement indique <literal>slot_name = NONE</literal>
    <itemizedlist>
     <listitem>
      <para>
       Créez l'abonnement. Quand <literal>slot_name = NONE</literal> alors
       <literal>enabled = false</literal> et <literal>create_slot = false</literal>
       sont aussi nécessaires.
<programlisting>
/* sub # */ CREATE SUBSCRIPTION sub1
/* sub - */ CONNECTION 'host=localhost dbname=test_pub'
/* sub - */ PUBLICATION pub1
/* sub - */ WITH (slot_name=NONE, enabled=false, create_slot=false);
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Sur le publieur, créez manuellement un slot en utilisant n'importe quel nom, i.e. "myslot".
<programlisting>
/* pub # */ SELECT * FROM pg_create_logical_replication_slot('myslot', 'pgoutput');
 slot_name |    lsn
-----------+-----------
 myslot    | 0/1905930
(1 row)
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Sur l'abonné, associez l'abonnement avec le nom de slot juste créé.
<programlisting>
/* sub # */ ALTER SUBSCRIPTION sub1 SET (slot_name='myslot');
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Les étapes restantes d'activation d'abonnement sont les mêmes que précédemment.
<programlisting>
/* sub # */ ALTER SUBSCRIPTION sub1 ENABLE;
/* sub # */ ALTER SUBSCRIPTION sub1 REFRESH PUBLICATION;
</programlisting></para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>

 </sect1>

 <sect1 id="logical-replication-failover">
  <title>Failover en réplication logique</title>

  <para>
   Pour permettre à des nœuds abonnés de continuer de répliquer les
   données du nœud publieur même quand ce dernier tombe, il doit y
   avoir un secondaire physique correspondant au nœud publieur. Les
   slots logique du serveur primaire correspondant aux souscriptions
   peuvent être synchronisés sur le serveur secondaire en précisant
   <literal>failover = true</literal> lors de la création de la souscription.
   Voir <xref linkend="logicaldecoding-replication-slots-synchronization"/>
   pour les détails. Activer le paramètre
   <link linkend="sql-createsubscription-params-with-failover"><literal>failover</literal></link>
   assure une transition directe de ces souscriptions après la promotion
   du secondaire. Ils peuvent continuer à souscrire aux publications du
   nouveau serveur primaire.
  </para>

  <para>
   Comme la logique de synchronisation du slot copie de façon asynchrone,
   il est nécessaire de confirmer que les slots de réplication doivent être
   synchronisés vers le serveur secondaire avant l'exécution du failover.
   Pour s'assurer d'un failover réussi, le serveur secondaire doit être en avance sur l'abonné. Ceci peut se faire en configurant
   <link linkend="guc-synchronized-standby-slots"><varname>synchronized_standby_slots</varname></link>.
  </para>

  <para>
   Pour confirmer que le serveur secondaire est prêt pour un failover pour
   un abonné précis, suivez ces étapes pour vérifier que tous les slots de
   réplication logique requis pour cet abonné ont bien été synchronisés sur
   le serveur secondaire&nbsp;:
  </para>

  <procedure>
   <step performance="required">
    <para>
     Sur le nœud abonné, utilisez la requête SQL suivante pour identifier
     les slots de réplication devant être synchronisés sur le secondaire que
     nous souhaitons promouvoir. Cette requête renverra les slots de
     réplication adéquats avec les souscriptions dont l'option failover est
     activée.
     <programlisting>
/* sub # */ SELECT
               array_agg(quote_literal(s.subslotname)) AS slots
           FROM  pg_subscription s
           WHERE s.subfailover AND
                 s.subslotname IS NOT NULL;
 slots
-------
 {'sub1','sub2','sub3'}
(1 row)
</programlisting></para>
   </step>
   <step performance="required">
    <para>
     Sur le nœud abonné, utilisez la requête SQL suivante pour identifier
     les slots de synchronisation qui doivent être synchronisés sur le secondaire
     que nous planifions de promouvoir. Cette requête a besoin d'être exécutée
     sur chaque base qui inclut les souscriptions dont l'option failover a été
     activée. Notez que le slot de synchronisation de table doit être synchronisé
     vers le serveur secondaire seulement si la copie de table est terminée
     (Voir <xref linkend="catalog-pg-subscription-rel"/>).
     Nous n'avons pas besoin de nous assurer que les slots de synchronisation
     de table sont synchronisés dans les autres scénarios car ceux-là seront
     soit supprimés soit re-créés sur le nouveau serveur primaire.
<programlisting>
/* sub # */ SELECT
               array_agg(quote_literal(slot_name) AS slots
           FROM
           (
               SELECT CONCAT('pg_', srsubid, '_sync_', srrelid, '_', ctl.system_identifier) AS slot_name
               FROM pg_control_system() ctl, pg_subscription_rel r, pg_subscription s
               WHERE r.srsubstate = 'f' AND s.oid = r.srsubid AND s.subfailover
           );
 slots
-------
 {'pg_16394_sync_16385_7394666715149055164'}
(1 row)
</programlisting></para>
   </step>
   <step performance="required">
    <para>
     Vérifiez que les slots de réplication logique identifiés ci-dessus
     existent sur le serveur secondaire et sont prêt pour un failover.
<programlisting>
/* standby # */ SELECT slot_name, (synced AND NOT temporary AND NOT conflicting) AS failover_ready
               FROM pg_replication_slots
               WHERE slot_name IN
                   ('sub1','sub2','sub3', 'pg_16394_sync_16385_7394666715149055164');
  slot_name                                 | failover_ready
--------------------------------------------+----------------
  sub1                                      | t
  sub2                                      | t
  sub3                                      | t
  pg_16394_sync_16385_7394666715149055164   | t
(4 rows)
</programlisting></para>
    </step>
  </procedure>

  <para>
   Si tous les slots sont présents sur le serveur secondaire et que le
   résultat (<literal>failover_ready</literal>) de la requête SQL ci-dessus
   vaut <literal>true</literal>, alors les souscriptions existantes
   pourront continuer leur travail avec les publications sur le nouveau
   serveur primaire.
  </para>

  <para>
   Les deux premières étapes dans la procédure ci-dessus ont pour cible un
   abonné <productname>PostgreSQL</productname>. Il est recommandé d'exécuter
   ces étapes sur chaque nœud abonné, qui sera servi par le secondaire désigné
   après la bascule, pour obtenir la liste complète des slots de réplication.
   Cette liste peut ensuite être vérifiée à l'étape 3 pour s'assurer que la
   bascule est prête. Concernant les abonnées non
   <productname>PostgreSQL</productname>, ils peuvent utiliser leur propre
   méthode pour identifier les slots de réplication utilisés par leurs
   abonnements respectifs.
  </para>

  <para>
   Dans certains cas, comme une bascule planifiée, il est nécessaire de
   confirmer que tous les abonnées, <productname>PostgreSQL</productname> ou
   autres, seront capables de continuer la réplication après la bascule d'un
   serveur secondaire donné. Dans de tels cas, utilisez la requête suivante
   au lieu de réaliser les deux premières étapes ci-dessus, pour identifier les
   slots de réplication du primaire qui ont besoin d'être synchronisés sur le
   secondaire qui sera promu. Cette requête renvoie les slots de réplication
   adéquats associés avec tous les abonnements dont l'option failover est
   activée.
  </para>

   <para>
<programlisting>
/* primary # */ SELECT array_agg(quote_literal(r.slot_name)) AS slots
               FROM pg_replication_slots r
               WHERE r.failover AND NOT r.temporary;
 slots
-------
 {'sub1','sub2','sub3', 'pg_16394_sync_16385_7394666715149055164'}
(1 row)
</programlisting></para>

  <para>
   Les deux premières étapes de la procédure ci-dessus sont destinées à un
   abonné <productname>PostgreSQL</productname>. Il est recommandé
   d'exécuter ces étapes sur chaque nœud abonné, qui seront utilisés par
   le secondaire désigné après le failover, pour obtenir la liste des slots
   de réplication. Cette liste peut ensuite être vérifiée à l'étape 3 pour
   s'assurer de la disponibilité du failover. D'un autre côté, les abonnés
   autres que <productname>PostgreSQL</productname> peuvent utiliser leur
   propre méthode pour identifier les slots de réplication utilisés par
   leurs abonnements respectifs.
  </para>

  <para>
   Dans certains cas, comme un failover planifié, il est nécessaire de
   confirmer que tous les abonnés, <productname>PostgreSQL</productname> ou
   autres, seront capables de continuer après le failover vers un serveur
   secondaire donné. Dans de tels cas, utilisez le SQL suivant au lieu de
   réaliser les deux premières étapes ci-dessus, pour identifier les slots
   de réplication que le primaire doit synchronisé sur le secondaire qui
   sera promu. Cette requête renvoie les slots de réplication en question
   associés avec tous les abonnements avec l'option failover activée.
  </para>

  <para><programlisting>
/* primary # */ SELECT array_agg(quote_literal(r.slot_name)) AS slots
               FROM pg_replication_slots r
               WHERE r.failover AND NOT r.temporary;
 slots
-------
 {'sub1','sub2','sub3', 'pg_16394_sync_16385_7394666715149055164'}
(1 row)
  </programlisting></para>
 </sect1>

 <sect1 id="logical-replication-row-filter">
  <title>Filtres de lignes</title>

  <para>
   Par défaut, toutes les données de toutes les tables publiées seront
   répliquées aux abonnés appropriés. Les données répliquées peuvent être
   réduites en utilisant un <firstterm>filtre de lignes</firstterm>. Un
   utilisateur pourrait choisir d'utiliser des filtres de lignes pour des
   raisons de comportement, de sécurité ou de performance. Si une table publiée
   configure un filtre de lignes, une ligne est répliquée seulement si ses
   données satisfont l'expression du filtre de lignes. Cela permet à un ensemble
   de tables d'être répliquées partiellement. Le filtre de lignes est défini par
   table. Utilisez une clause <literal>WHERE</literal> après le nom de la table
   pour chaque table publiée dont les données doivent être filtrées. La clause
   <literal>WHERE</literal> doit être entourée de parenthèses. Voir <xref
   linkend="sql-createpublication"/> pour les détails.
  </para>

  <sect2 id="logical-replication-row-filter-rules">
   <title>Règles des filtres de lignes</title>

   <para>
    Les filtres de lignes sont appliqués <emphasis>avant</emphasis> de publier
    les changements. Si le filtre de ligne est évalué à <literal>false</literal>
    ou <literal>NULL</literal>, alors la ligne n'est pas répliquée. L'expression
    de la clause <literal>WHERE</literal> est évaluée avec le même rôle utilisé
    pour la connexion de réplication (soit le rôle indiqué dans la clause
    <link linkend="sql-createsubscription-params-connection"><literal>CONNECTION</literal></link>
    de l'instruction <xref
    linkend="sql-createsubscription"/>). Les filtres de ligne n'ont pas deffet
    sur la commande <command>TRUNCATE</command>.
   </para>
  </sect2>

  <sect2 id="logical-replication-row-filter-restrictions">
   <title>Restrictions de l'expression</title>

   <para>
    La clause <literal>WHERE</literal> autorise uniquement des expressions simples.
    Elle ne peut pas contenir de fonctions, opérateurs, types et collations
    définis par les utilisateurs, des références aux colonnes système ou à des
    fonctions internes non immutables.
   </para>

   <para>
    Si une publication publie des opérations <command>UPDATE</command> ou
    <command>DELETE</command>, la clause <literal>WHERE</literal> du filtre de
    lignes doit contenir uniquement les colonnes couvertes par l'identité de
    réplica (voir <xref linkend="sql-altertable-replica-identity"/>). Si une
    publication publie uniquement des opérations <command>INSERT</command>, la
    clause <literal>WHERE</literal> du filtre de ligne peut utiliser toute
    colonne.
   </para>
  </sect2>

  <sect2 id="logical-replication-row-filter-transformations">
   <title>Transformations d'un UPDATE</title>

   <para>
    À chaque fois qu'un <command>UPDATE</command> est traité, l'expression du
    filtre de lignes est évaluée pour l'ancienne et la nouvelle ligne (autrement
    dit, en utilisant les données avant et après la mise à jour). Si les deux
    évaluations valent <literal>true</literal>, les modifications de
    l'<command>UPDATE</command> sont répliquées. Si les deux évaluations valent
    <literal>false</literal>, les modifications ne sont pas répliquées. Si
    seulement une des deux évaluations vaut true, la commande
    <command>UPDATE</command> est transformée en <command>INSERT</command> ou
    <command>DELETE</command>, pour éviter toute incohérence de données. La
    ligne sur l'abonné doit refléter ce qui est défini par l'expression de
    filtre de lignes sur le publieur.
   </para>

   <para>
    Si l'ancienne ligne satisfait l'expression du filtre de lignes (elle a été
    envoyée sur l'abonné) contrairement à la nouvelle ligne, alors, d'un point
    de vue de la cohérence des données, l'ancienne ligne devrait être supprimée
    de l'abonné. Donc la commande <command>UPDATE</command> est transformée en
    commande <command>DELETE</command>.
   </para>

   <para>
    Si l'ancienne ligne ne satisfait pas l'expression du filtre de lignes (elle
    n'a pas été envoyée sur l'abonné) contrairement à la nouvelle ligne, alors,
    d'un point de vue de la cohérence des données, la nouvelle ligne doit être
    ajoutée à l'abonné. Donc la commande <command>UPDATE</command> est
    transformée en commande <command>INSERT</command>.
   </para>

   <para>
    <xref linkend="logical-replication-row-filter-transformations-summary"/>
    résume les transformations appliquées.
   </para>

   <table id="logical-replication-row-filter-transformations-summary">
    <title>Résumé des transformations d'un <command>UPDATE</command></title>
    <tgroup cols="3">
    <thead>
     <row>
      <entry>Ancienne ligne</entry>
      <entry>Nouvelle ligne</entry>
      <entry>Transformation</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>pas de correspondance</entry>
      <entry>pas de correspondance</entry>
      <entry>ne réplique pas</entry>
     </row>
     <row>
      <entry>pas de correspondance</entry>
      <entry>correspondance</entry>
      <entry><literal>INSERT</literal></entry>
     </row>
     <row>
      <entry>correspondance</entry>
      <entry>pas de correspondance</entry>
      <entry><literal>DELETE</literal></entry>
     </row>
     <row>
      <entry>correspondance</entry>
      <entry>correspondance</entry>
      <entry><literal>UPDATE</literal></entry>
     </row>
    </tbody>
   </tgroup>
   </table>

  </sect2>

  <sect2 id="logical-replication-row-filter-partitioned-table">
   <title>Tables partitionnées</title>

   <para>
    Si la publication contient une table partitionnée, le paramètre de
    publication <link
    linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>
    détermine le filtre de lignes à utiliser. Si
    <literal>publish_via_partition_root</literal> vaut <literal>true</literal>,
    le filtre de ligne de la <emphasis>table partitionnée racine</emphasis> est
    utilisé. Si <literal>publish_via_partition_root</literal> vaut
    <literal>false</literal> (ce qui est le cas par défaut), le filtre de lignes
    de chaque <emphasis>partition</emphasis> est utilisé.
   </para>

  </sect2>

  <sect2 id="logical-replication-row-filter-initial-data-sync">
   <title>Synchronisation initiale des données</title>

   <para>
    Si la souscription requiert une copie des données pré-existantes de la table
    et qu'une publication contient des clauses <literal>WHERE</literal>, seules
    les données qui satisfont les expressions des filtres de ligne sont copiées
    sur l'abonné.
   </para>

   <para>
    Si la souscription a plusieurs publications dans lesquelles une table a été
    publiée avec différentes clauses <literal>WHERE</literal>, les lignes qui
    satisfont <emphasis>une</emphasis> des expressions seront copiées. Voir
    <xref linkend="logical-replication-row-filter-combining"/> pour les détails.
   </para>

   <warning>
    <para>
     Comme la synchronisation initiale des données ne prend pas en compte le
     paramètre <link
     linkend="sql-createpublication-params-with-publish"><literal>publish</literal></link>
     lors de la copie des données
     pré-existantes de la table, certaines lignes pourraient être copiées alors
     qu'elles n'auraient pas été répliquées avec des instructions DML.
     Référez-vous à <xref linkend="logical-replication-snapshot"/>, et à
     <xref linkend="logical-replication-subscription-examples"/> pour des
     exemples.
    </para>
   </warning>

   <note>
    <para>
     Si l'abonné est d'une version antérieure à la 15, la copie des données
     pré-existantes n'utilise pas les filtres de ligne même s'ils sont définis
     dans la publication. Ceci est dû au fait que les anciennes versions peuvent
     seulement copier les données de la table entière.
    </para>
   </note>

  </sect2>

  <sect2 id="logical-replication-row-filter-combining">
   <title>Combiner plusieurs filtres de lignes</title>

   <para>
    Si la souscription a plusieurs publications pour lesquelles la même table a
    été publiée avec des filtres de lignes différents (pour la même opération
    <link linkend="sql-createpublication-params-with-publish"><literal>publish</literal></link>,
    ces expressions sont assemblées avec un OU
    logique, pour que les lignes satisfaisant au moins <emphasis>une</emphasis>
    expression seront répliquées. Cela signifie que les autres filtres de lignes
    pour la même table deviennent redondants si&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       Une des publications n'a pas de filtres de lignes&nbsp;;
      </para>
     </listitem>
     <listitem>
      <para>
       Une des publications a été créée en utilisant <link
       linkend="sql-createpublication-params-for-all-tables"><literal>FOR ALL
       TABLES</literal></link>. Cette clause n'autorise pas les filtres de
       lignes&nbsp;;
      </para>
     </listitem>
     <listitem>
      <para>
       Une des publications a été créée en utilisant <link
       linkend="sql-createpublication-params-for-tables-in-schema"><literal>FOR TABLES
       IN SCHEMA</literal></link> et la table appartient au schéma référencé.
       Cette clause n'autorise pas les filtres de lignes.
      </para>
     </listitem>
    </itemizedlist></para>
  </sect2>

  <sect2 id="logical-replication-row-filter-examples">
   <title>Exemples</title>

   <para>
    Créer quelques tables à utiliser dans les exemples suivants.
<programlisting>
/* pub # */ CREATE TABLE t1(a int, b int, c text, PRIMARY KEY(a,c));
/* pub # */ CREATE TABLE t2(d int, e int, f int, PRIMARY KEY(d));
/* pub # */ CREATE TABLE t3(g int, h int, i int, PRIMARY KEY(g));
</programlisting></para>

   <para>
    Créer quelques publications. La publication <literal>p1</literal> a une
    table (<literal>t1</literal>) et cette table a un filtre de lignes. La
    publication <literal>p2</literal> a deux tables. La table
    <literal>t1</literal> n'a pas de filtre de lignes, et la table
    <literal>t2</literal> a un filtre de lignes. La publication
    <literal>p3</literal> a deux tables, qui ont toutes les deux un filtre de
    lignes.
<programlisting>
/* pub # */ CREATE PUBLICATION p1 FOR TABLE t1 WHERE (a > 5 AND c = 'NSW');
/* pub # */ CREATE PUBLICATION p2 FOR TABLE t1, t2 WHERE (e = 99);
/* pub # */ CREATE PUBLICATION p3 FOR TABLE t2 WHERE (d = 10), t3 WHERE (g = 10);
</programlisting></para>

   <para>
    <command>psql</command> peut être utilisé pour afficher les expressions
    de filtres de lignes (si défini) pour chaque publication.
<programlisting><![CDATA[
/* pub # */ \dRp+
                                         Publication p1
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Generated columns | Via root
----------+------------+---------+---------+---------+-----------+-------------------+----------
 postgres | f          | t       | t       | t       | t         | none              | f
Tables:
    "public.t1" WHERE ((a > 5) AND (c = 'NSW'::text))

                                         Publication p2
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Generated columns | Via root
----------+------------+---------+---------+---------+-----------+-------------------+----------
 postgres | f          | t       | t       | t       | t         | none              | f
Tables:
    "public.t1"
    "public.t2" WHERE (e = 99)

                                         Publication p3
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Generated columns | Via root
----------+------------+---------+---------+---------+-----------+-------------------+----------
 postgres | f          | t       | t       | t       | t         | none              | f
Tables:
    "public.t2" WHERE (d = 10)
    "public.t3" WHERE (g = 10)
]]></programlisting></para>

   <para>
    <command>psql</command> peut être utilisé pour afficher les expressions des
    filtres de lignes (si défini) pour chaque table. La table
    <literal>t1</literal> est membre de deux publications, mais a un filtre de
    lignes uniquement dans <literal>p1</literal>. La table
    <literal>t2</literal> est membre de deux publications, et a un filtre de
    lignes différent sur chacune.
<programlisting><![CDATA[
/* pub # */ \d t1
                 Table "public.t1"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 a      | integer |           | not null |
 b      | integer |           |          |
 c      | text    |           | not null |
Indexes:
    "t1_pkey" PRIMARY KEY, btree (a, c)
Publications:
    "p1" WHERE ((a > 5) AND (c = 'NSW'::text))
    "p2"

/* pub # */ \d t2
                 Table "public.t2"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 d      | integer |           | not null |
 e      | integer |           |          |
 f      | integer |           |          |
Indexes:
    "t2_pkey" PRIMARY KEY, btree (d)
Publications:
    "p2" WHERE (e = 99)
    "p3" WHERE (d = 10)

/* pub # */ \d t3
                 Table "public.t3"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 g      | integer |           | not null |
 h      | integer |           |          |
 i      | integer |           |          |
Indexes:
    "t3_pkey" PRIMARY KEY, btree (g)
Publications:
    "p3" WHERE (g = 10)
]]></programlisting></para>

   <para>
    Sur le nœud abonné, créer une table <literal>t1</literal> avec la même
    définition que celle du publieur, et créer aussi la souscription
    <literal>s1</literal> vers la publication <literal>p1</literal>.
<programlisting>
/* sub # */ CREATE TABLE t1(a int, b int, c text, PRIMARY KEY(a,c));
/* sub # */ CREATE SUBSCRIPTION s1
/* sub - */ CONNECTION 'host=localhost dbname=test_pub application_name=s1'
/* sub - */ PUBLICATION p1;
</programlisting></para>

   <para>
    Insérer quelques lignes. Seules les lignes satisfaisant la clause
    <literal>t1 WHERE</literal> de la publication <literal>p1</literal> sont
    répliquées.
<programlisting>
/* pub # */ INSERT INTO t1 VALUES (2, 102, 'NSW');
/* pub # */ INSERT INTO t1 VALUES (3, 103, 'QLD');
/* pub # */ INSERT INTO t1 VALUES (4, 104, 'VIC');
/* pub # */ INSERT INTO t1 VALUES (5, 105, 'ACT');
/* pub # */ INSERT INTO t1 VALUES (6, 106, 'NSW');
/* pub # */ INSERT INTO t1 VALUES (7, 107, 'NT');
/* pub # */ INSERT INTO t1 VALUES (8, 108, 'QLD');
/* pub # */ INSERT INTO t1 VALUES (9, 109, 'NSW');

/* pub # */ SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 2 | 102 | NSW
 3 | 103 | QLD
 4 | 104 | VIC
 5 | 105 | ACT
 6 | 106 | NSW
 7 | 107 | NT
 8 | 108 | QLD
 9 | 109 | NSW
(8 rows)
</programlisting>
<programlisting>
/* sub # */ SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 6 | 106 | NSW
 9 | 109 | NSW
(2 rows)
</programlisting></para>

   <para>
    Mettre à jour quelques données, où les valeurs de l'ancienne et de la
    nouvelle ligne satisfont la clause <literal>t1 WHERE</literal> de la
    publication <literal>p1</literal>. La commande <command>UPDATE</command>
    réplique les changements de façon normale.
<programlisting>
/* pub # */ UPDATE t1 SET b = 999 WHERE a = 6;

/* pub # */ SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 2 | 102 | NSW
 3 | 103 | QLD
 4 | 104 | VIC
 5 | 105 | ACT
 7 | 107 | NT
 8 | 108 | QLD
 9 | 109 | NSW
 6 | 999 | NSW
(8 rows)
</programlisting>
<programlisting>
/* sub # */ SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 9 | 109 | NSW
 6 | 999 | NSW
(2 rows)
</programlisting></para>

   <para>
    Mettre à jour des données de façon à ce que les valeurs de l'ancienne ligne
    ne satisfont pas la clause <literal>t1 WHERE</literal> de la publication
    <literal>p1</literal>, mais que les valeurs de la nouvelle ligne la
    satisfont. La commande <command>UPDATE</command> est transformée en une
    commande <command>INSERT</command> et les changements sont répliqués. Voir
    la nouvelle ligne sur l'abonné.
<programlisting>
/* pub # */ UPDATE t1 SET a = 555 WHERE a = 2;

/* pub # */ SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   3 | 103 | QLD
   4 | 104 | VIC
   5 | 105 | ACT
   7 | 107 | NT
   8 | 108 | QLD
   9 | 109 | NSW
   6 | 999 | NSW
 555 | 102 | NSW
(8 rows)
</programlisting>
<programlisting>
/* sub # */ SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   9 | 109 | NSW
   6 | 999 | NSW
 555 | 102 | NSW
(3 rows)
</programlisting></para>

   <para>
    Mettre à jour des données de façon à ce que les valeurs de l'ancienne ligne
    satisfont la clause <literal>t1 WHERE</literal> de la publication
    <literal>p1</literal>, mais que les valeurs de la nouvelle ligne ne la
    satisfont pas. La commande <command>UPDATE</command> est transformée en une
    commande <command>DELETE</command> et les changements sont répliqués. Voir
    la nouvelle ligne supprimée sur l'abonné.
<programlisting>
/* pub # */ UPDATE t1 SET c = 'VIC' WHERE a = 9;

/* pub # */ SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   3 | 103 | QLD
   4 | 104 | VIC
   5 | 105 | ACT
   7 | 107 | NT
   8 | 108 | QLD
   6 | 999 | NSW
 555 | 102 | NSW
   9 | 109 | VIC
(8 rows)
</programlisting>
<programlisting>
/* sub # */ SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   6 | 999 | NSW
 555 | 102 | NSW
(2 rows)
</programlisting></para>

   <para>
    Les exemples suivants montrent comment le paramètre de publication <link
    linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>
    détermine si le filtre de
    ligne de la table parent ou enfant sera utilisé dans le cas de tables
    partitionnées.
   </para>

   <para>
    Créer une table partitionnée sur le publieur.
<programlisting>
/* pub # */ CREATE TABLE parent(a int PRIMARY KEY) PARTITION BY RANGE(a);
/* pub # */ CREATE TABLE child PARTITION OF parent DEFAULT;
</programlisting>
   Créer les mêmes tables sur l'abonné.
<programlisting>
/* sub # */ CREATE TABLE parent(a int PRIMARY KEY) PARTITION BY RANGE(a);
/* sub # */ CREATE TABLE child PARTITION OF parent DEFAULT;
</programlisting></para>

   <para>
    Créer une publication <literal>p4</literal>, puis abonnez-vous à cette
    publication. Le paramètre de publication
    <literal>publish_via_partition_root</literal> est configuré à true. Il
    existe des filtres de lignes définis sur la table partitionnée
    (<literal>parent</literal>), et sur sa partition (<literal>child</literal>).
<programlisting><![CDATA[
/* pub # */ CREATE PUBLICATION p4 FOR TABLE parent WHERE (a &lt; 5), child WHERE (a >= 5)
test_pub-# WITH (publish_via_partition_root=true);
+]]></programlisting>
<programlisting>
/* sub # */ CREATE SUBSCRIPTION s4
/* sub - */ CONNECTION 'host=localhost dbname=test_pub application_name=s4'
/* sub - */ PUBLICATION p4;
</programlisting></para>

   <para>
    Insérer quelques valeurs directement dans les tables
    <literal>parent</literal> et <literal>child</literal>. Elles se répliquent
    en utilisant le filtre de lignes de <literal>parent</literal> (parce que
    <literal>publish_via_partition_root</literal> vaut true).
<programlisting>
/* pub # */ INSERT INTO parent VALUES (2), (4), (6);
/* pub # */ INSERT INTO child VALUES (3), (5), (7);

/* pub # */ SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
 5
 6
 7
(6 rows)
</programlisting>
<programlisting>
/* sub # */ SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
(3 rows)
</programlisting></para>

   <para>
    Répéter le même test, mais avec une valeur différente pour
    <literal>publish_via_partition_root</literal>. Le paramètre de publication
    <literal>publish_via_partition_root</literal> est configuré à false. Un
    filtre de lignes est défini sur la partition (<literal>child</literal>).
<programlisting><![CDATA[
/* pub # */ DROP PUBLICATION p4;
/* pub # */ CREATE PUBLICATION p4 FOR TABLE parent, child WHERE (a >= 5)
/* pub - */ WITH (publish_via_partition_root=false);
]]></programlisting>
<programlisting>
/* sub # */ ALTER SUBSCRIPTION s4 REFRESH PUBLICATION;
</programlisting></para>

   <para>
    Faire les insertions sur le publieur de la même façon qu'avant. Elles se
    répliquent en utilisant le filtre de lignes de <literal>child</literal>
    (parce que <literal>publish_via_partition_root</literal> vaut false).
<programlisting>
/* pub # */ TRUNCATE parent;
/* pub # */ INSERT INTO parent VALUES (2), (4), (6);
/* pub # */ INSERT INTO child VALUES (3), (5), (7);

/* pub # */ SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
 5
 6
 7
(6 rows)
</programlisting>
<programlisting>
/* sub # */ SELECT * FROM child ORDER BY a;
 a
---
 5
 6
 7
(3 rows)
</programlisting></para>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-col-lists">
  <title>Listes de colonnes</title>

  <para>
   Chaque publication peut indiquer en option aux abonnés les colonnes à
   répliquer pour chaque table. La table du côté abonné doit avoir au moins
   toutes les colonnes publiées. Si aucune liste de colonnes n'est indiquée,
   alors toutes les colonnes du côté du publieur sont répliquées. Voir <xref
   linkend="sql-createpublication"/> pour les détails sur la syntaxe.
  </para>

  <para>
   Le choix des colonnes peut être basé sur des raisons de comportement ou de
   performance. Néanmoins, ne vous basez pas sur cette fonctionnalité pour de la
   sécurité&nbsp;: un abonné mal intentionné est capable d'obtenir des données
   des colonnes qui ne sont pas spécifiquement publiées. D'un point de vue
   sécurité, des protections peuvent être mises en place du côté du publieur.
  </para>

  <para>
   Si aucune liste de colonne n'est indiquée, toutes les colonnes ajoutées
   ultérieurement à la table sont automatiquement répliquées. Cela signifie
   qu'avoir une
   liste de colonnes qui nomme toutes les colonnes n'aboutit pas au même
   comportement que ne pas avoir de liste de colonnes.
  </para>

  <para>
   Une liste de colonnes peut contenir seulement des références de colonnes.
   L'ordre des colonnes dans la liste n'est pas préservé.
  </para>

  <para>
   Les colonnes générées peuvent aussi être indiquées dans une liste de
   colonnes. Ceci permet aux colonnes générées d'être publiées, quelque soit
   le paramètre de publication
   <link linkend="sql-createpublication-params-with-publish-generated-columns">
   <literal>publish_generated_columns</literal></link>. Voir
   <xref linkend="logical-replication-gencols"/> pour les détails.
  </para>

  <para>
   Préciser une liste de colonnes n'est pas possible quand la publication publie
   aussi toutes les tables d'un schéma (clause <link
   linkend="sql-createpublication-params-for-tables-in-schema"><literal>FOR TABLES IN
   SCHEMA</literal></link>).
  </para>

  <para>
   Pour les tables partitionnées, le paramètre de publication <link
   linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>
   détermine quel liste de
   colonnes utiliser. Si <literal>publish_via_partition_root</literal> vaut
   <literal>true</literal>, la liste de colonnes utilisée est celle de la table
   partitionnée. Sinon, si <literal>publish_via_partition_root</literal> vaut
   <literal>false</literal> (valeur par défaut), la liste de colonnes utilisée
   est celle de la partition concernée.
  </para>

  <para>
   Si une publication publie des opérations <command>UPDATE</command> ou
   <command>DELETE</command>, toute liste de colonnes doit inclure les colonnes
   d'identité de réplica de la table (voir <xref
   linkend="sql-altertable-replica-identity"/>). Si une publication publie
   seulement des opérations <command>INSERT</command>, alors la liste de
   colonnes peut omettre les colonnes d'identité de réplica.
  </para>

  <para>
   Les listes de colonnes n'ont pas d'effet sur la commande
   <literal>TRUNCATE</literal>.
  </para>

  <para>
   Lors de la synchronisation initiale des données, seules les colonnes publiées
   sont copiées. Néanmoins, si l'abonné est d'une version antérieure à la 15,
   alors toutes les colonnes dans la table sont copiées lors de la
   synchronisation initiale des données, ignorant en cela les liste de colonnes.
   Si l'abonné a une version antérieure à la 18, alors la synchronisation
   initiale de table ne copiera pas les colonnes générées même si elles sont
   définies sur le publieur.
  </para>

  <warning id="logical-replication-col-list-combining">
   <title>Attention&nbsp;: Combiner des listes de plusieurs publications</title>
   <para>
    Actuellement, il n'est pas possible qu'une souscription soit entreprise
    auprès de plusieurs publications quand la même table a été publiée avec des
    listes de colonnes différentes. <xref linkend="sql-createsubscription"/>
    interdit la création de telles souscriptions mais il est toujours possible
    d'arriver dans cette situation par l'ajout ou la modification de listes de
    colonnes du côté publication une fois que la souscription a été créée.
   </para>
   <para>
    Ceci signifie que la modification de liste de colonnes sur les publications
    déjà souscrites peut amener à des erreurs du côté souscripteur.
   </para>
   <para>
    Si ce problème affecte une souscription, la seule façon de reprendre la
    réplication est d'ajuster une des listes de colonnes côté publication pour
    que les listes correspondent&nbsp;; puis soit de créer de nouveau la
    souscription, soit utiliser <link
    linkend="sql-altersubscription-params-setadddrop-publication">
    <literal>ALTER SUBSCRIPTION ... DROP PUBLICATION</literal></link> pour supprimer
    une des publications problématiques et l'ajouter de nouveau après.
   </para>
  </warning>

  <sect2 id="logical-replication-col-list-examples">
   <title>Exemples</title>

   <para>
    Créer une table <literal>t1</literal> à utiliser dans l'exemple suivant.
<programlisting>
/* pub # */ CREATE TABLE t1(id int, a text, b text, c text, d text, e text, PRIMARY KEY(id));
</programlisting></para>

   <para>
    Créer une publication <literal>p1</literal>. Une liste de colonnes est
    définie pour la table <literal>t1</literal> pour réduire le nombre de
    colonnes qui seront répliquées. Notez que l'ordre des noms de colonnes dans
    la liste de colonnes n'a pas d'importance.
<programlisting>
/* pub # */ CREATE PUBLICATION p1 FOR TABLE t1 (id, b, a, d);
</programlisting></para>

    <para>
     <literal>psql</literal> peut être utilisé pour afficher les listes de
     colonnes (si définies) pour chaque publication.
<programlisting>
/* pub # */ \dRp+
                                         Publication p1
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Generated columns | Via root
----------+------------+---------+---------+---------+-----------+-------------------+----------
 postgres | f          | t       | t       | t       | t         | none              | f
Tables:
    "public.t1" (id, a, b, d)
</programlisting></para>

    <para>
     <literal>psql</literal> peut être utilisé pour afficher les listes de
     colonnes (si définies) pour chaque table.
<programlisting>
/* pub # */ \d t1
                 Table "public.t1"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 id     | integer |           | not null |
 a      | text    |           |          |
 b      | text    |           |          |
 c      | text    |           |          |
 d      | text    |           |          |
 e      | text    |           |          |
Indexes:
    "t1_pkey" PRIMARY KEY, btree (id)
Publications:
    "p1" (id, a, b, d)
</programlisting></para>

    <para>
     Sur le nœud abonné, créer une table <literal>t1</literal> qui maintenant a
     seulement besoin d'un sous-ensemble des colonnes qui sont sur la table côté
     publieur <literal>t1</literal>, et crée aussi l'abonnement
     <literal>s1</literal> qui cible la publication <literal>p1</literal>.
<programlisting>
/* sub # */ CREATE TABLE t1(id int, b text, a text, d text, PRIMARY KEY(id));
/* sub # */ CREATE SUBSCRIPTION s1
/* sub - */ CONNECTION 'host=localhost dbname=test_pub application_name=s1'
/* sub - */ PUBLICATION p1;
</programlisting></para>

    <para>
     Sur le nœud publieur, insérer quelques lignes dans la table
     <literal>t1</literal>.
<programlisting>
/* pub # */ INSERT INTO t1 VALUES(1, 'a-1', 'b-1', 'c-1', 'd-1', 'e-1');
/* pub # */ INSERT INTO t1 VALUES(2, 'a-2', 'b-2', 'c-2', 'd-2', 'e-2');
/* pub # */ INSERT INTO t1 VALUES(3, 'a-3', 'b-3', 'c-3', 'd-3', 'e-3');
/* pub # */ SELECT * FROM t1 ORDER BY id;
 id |  a  |  b  |  c  |  d  |  e
----+-----+-----+-----+-----+-----
  1 | a-1 | b-1 | c-1 | d-1 | e-1
  2 | a-2 | b-2 | c-2 | d-2 | e-2
  3 | a-3 | b-3 | c-3 | d-3 | e-3
(3 rows)
</programlisting></para>

    <para>
     Seules les données de la liste de colonnes de la publication
     <literal>p1</literal> sont répliquées.
<programlisting>
/* sub # */ SELECT * FROM t1 ORDER BY id;
 id |  b  |  a  |  d
----+-----+-----+-----
  1 | b-1 | a-1 | d-1
  2 | b-2 | a-2 | d-2
  3 | b-3 | a-3 | d-3
(3 rows)
</programlisting></para>

  </sect2>

 </sect1>

 <sect1 id="logical-replication-gencols">
  <title>Réplication d'une colonne générée</title>

  <para>
   Typiquement, une table sur un abonné doit être définie de la même façon que
   sur le publieur, donc si une table sur le publieur a une <link
   linkend="ddl-generated-columns"><literal>colonne GENERATED</literal></link>,
   alors la table sur l'abonné aura une colonne générée correspondante. Dans ce
   cas, c'est la valeur de la colonne générée sur l'abonné qui est utilisée.
  </para>

  <para>
   Par exemple, notez ci-dessous que la valeur de la colonne générée sur la
   table côté abonné vient du calcul de la colonne sur l'abonné.
<programlisting>
/* pub # */ CREATE TABLE tab_gen_to_gen (a int, b int GENERATED ALWAYS AS (a + 1) STORED);
/* pub # */ INSERT INTO tab_gen_to_gen VALUES (1),(2),(3);
/* pub # */ CREATE PUBLICATION pub1 FOR TABLE tab_gen_to_gen;
/* pub # */ SELECT * FROM tab_gen_to_gen;
 a | b
---+---
 1 | 2
 2 | 3
 3 | 4
(3 rows)

/* sub # */ CREATE TABLE tab_gen_to_gen (a int, b int GENERATED ALWAYS AS (a * 100) STORED);
/* sub # */ CREATE SUBSCRIPTION sub1 CONNECTION 'dbname=test_pub' PUBLICATION pub1;
/* sub # */ SELECT * from tab_gen_to_gen;
 a | b
---+----
 1 | 100
 2 | 200
 3 | 300
(3 rows)
</programlisting>
  </para>

  <para>
   En fait, avant la version 18, la réplication logique ne publie jamais les
   colonnes de type <literal>GENERATED</literal>.
  </para>

  <para>
   Mais répliquer une colonne générée vers une colonne standard peut parfois
   être souhaitable.
   <tip>
    <para>
     Cette fonctionnalité pourrait être utile lors de la réplication de données
     vers une base autre que PostgreSQL via un plugin de sortie, tout
     spécialement si la base cible ne prend pas en compte les colonnes générées.
    </para>
  </tip>
  </para>

  <para>
   Les colonnes générées ne sont pas publiées par défaut mais les utilisateurs
   peuvent opter pour la publication des colonnes générées stockées comme
   pour les colonnes standards.
  </para>

  <para>
   Il existe deux façons de le faire&nbsp;:
   <itemizedlist>
     <listitem>
      <para>
       Configurer le paramètre <command>PUBLICATION</command>
       <link linkend="sql-createpublication-params-with-publish-generated-columns">
       <literal>publish_generated_columns</literal></link> à <literal>stored</literal>.
       Ceci force la réplication logique de PostgreSQL à publier les colonnes
       générées stockées actuelles et futures des tables de la publication.
      </para>
     </listitem>

     <listitem>
      <para>
       Spécifier une <link linkend="logical-replication-col-lists">liste de
       colonnes</link> d'une table pour nommer explicitement les colonnes
       générées stockées à publier.
      </para>

      <note>
       <para>
        Lors de la détermination des colonnes à publier, une liste de colonnes
        a la priorité, surchargeant les effets du paramètre
        <literal>publish_generated_columns</literal>.
       </para>
      </note>
     </listitem>
   </itemizedlist>
  </para>

  <para>
   La table suivante résume le comportement quand des colonnes générées sont
   impliquées dans la réplication logique. Les résultats sont affichés quand
   la publication des colonnes générées est activée et quand elle est
   désactivée.
  </para>

  <table id="logical-replication-gencols-table-summary">
   <title>Résumé du résultat de réplication</title>
   <tgroup cols="4">

    <thead>
     <row>
      <entry>Colonnes générées publiées&nbsp;?</entry>
      <entry>Colonne côté publieur</entry>
      <entry>Colonne côté abonné</entry>
      <entry>Résultat</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>Non</entry>
      <entry>GENERATED</entry>
      <entry>GENERATED</entry>
      <entry>La colonne côté publieur n'est pas répliquée. Utilise la valeur de la colonne côté abonné.</entry>
     </row>

     <row>
      <entry>Non</entry>
      <entry>GENERATED</entry>
      <entry>standard</entry>
      <entry>La colonne côté publieur n'est pas répliquée. Utilise la valeur par défaut de la colonne côté abonné.</entry>
     </row>

     <row>
      <entry>Non</entry>
      <entry>GENERATED</entry>
      <entry>--manquante--</entry>
      <entry>La colonne côté publieur n'est pas répliquée. Rien ne se passe.</entry>
     </row>

     <row>
      <entry>Oui</entry>
      <entry>GENERATED</entry>
      <entry>GENERATED</entry>
      <entry>ERREUR. Non pris en compte.</entry>
     </row>

     <row>
      <entry>Oui</entry>
      <entry>GENERATED</entry>
      <entry>standard</entry>
      <entry>La colonne côté publieur est répliquée sur la colonne côté abonné.</entry>
     </row>

     <row>
      <entry>Oui</entry>
      <entry>GENERATED</entry>
      <entry>--manquante--</entry>
      <entry>ERREUR. La colonne est rapportée comme manquant côté abonné.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <warning>
   <para>
    Il n'y a actuellement pas de prise en compte des souscriptions comprenant
    plusieurs publications où la même table est publiée avec des listes de
    colonnes différentes. Voir <xref linkend="logical-replication-col-lists"/>.
   </para>

   <para>
    Cette même situation peut survenir si une publication a publié des colonnes
    générées alors qu'une autre publication dans le même abonnement n'a pas
    publiée les colonnes générées pour la même table.
   </para>
  </warning>

  <note>
   <para>
    Si l'abonné est d'une version antérieure à la 18, la synchronisation initiale
    de la table ne copiera pas les colonnes générées même si elles ont été
    définies dans le publieur.
   </para>
  </note>
 </sect1>

 <sect1 id="logical-replication-conflicts">
  <title>Conflits</title>

  <para>
   La réplication logique se comporte de la même manière pour les opérations DML
   dans le sens où les données seront mises à jour même si la modification a été
   faite en local sur la base abonnée. Si les données entrantes entrainent des
   violations de contrainte d'intégrité, la réplication s'arrête. Cela sera
   référencé comme un <firstterm>conflit</firstterm>. Lorsque l'on réplique des
   opérations <command>UPDATE</command> ou <command>DELETE</command>, les
   données manquantes sont aussi considérées comme un
   <firstterm>conflit</firstterm>, mais cela ne se termine pas avec une erreur
   et de telles opérations seront simplement ignorées.
  </para>

  <para>
  Une trace supplémentaire est déclenchée et les statistiques sur les conflits
  sont enregistrées (disponibles dans la vue
   <link linkend="monitoring-pg-stat-subscription-stats"><structname>pg_stat_subscription_stats</structname></link>)
   dans les cas suivants <firstterm>conflict</firstterm>&nbsp;:
   <variablelist>
    <varlistentry id="conflict-insert-exists" xreflabel="insert_exists">
     <term><literal>insert_exists</literal></term>
     <listitem>
      <para>
       Insérer une ligne qui viole une contrainte d'unicité <literal>NOT
       DEFERRABLE</literal>. Notez que pour tracer des détails comme l'origine
       et la date et heure de validation de la clé en conflit,
       <link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>
       doit être activé sur l'abonné. Dans ce cas, une erreur sera levée
       jusqu'à ce que le conflit soit résolu manuellement.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="conflict-update-origin-differs" xreflabel="update_origin_differs">
     <term><literal>update_origin_differs</literal></term>
     <listitem>
      <para>
       Mettre à jour une ligne qui a été précédemment modifiée par une autre
       origine. Notez que ce conflit peut seulement être détecté quand
       <link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>
       est activé sur l'abonné. Actuellement, une mise à jour est toujours
       appliquée quelque soit l'origine de la ligne locale.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="conflict-update-exists" xreflabel="update_exists">
     <term><literal>update_exists</literal></term>
     <listitem>
      <para>
       La valeur mise à jour d'une ligne viole la contrainte d'unicité
       <literal>NOT DEFERRABLE</literal>. Notez que pour tracer des détails
       comme l'origine et la date et heure de validation de la clé en conflit,
       <link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>
       doit être activé sur l'abonné. Dans ce cas, une erreur sera levée
       jusqu'à ce que le conflit soit résolu manuellement. Notez que lors de la
       mise à jour d'une table partitionnée, si la valeur de la ligne mise à
       jour satisfait une autre contrainte de partitionnement résultant en
       l'insertion de la ligne dans une nouvelle partition, le conflit
       <literal>insert_exists</literal> peut survenir si la nouvelle ligne viole
       la contrainte d'unicité <literal>NOT DEFERRABLE</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="conflict-update-missing" xreflabel="update_missing">
     <term><literal>update_missing</literal></term>
     <listitem>
      <para>
       La ligne à mettre à jour n'a pas été trouvée. La mise à jour sera
       simplement ignorée dans ce scénario.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="conflict-delete-origin-differs" xreflabel="delete_origin_differs">
     <term><literal>delete_origin_differs</literal></term>
     <listitem>
      <para>
       Supprimer une ligne qui a été modifiée précédemment par une autre
       origine. Notez que ce conflit peut seulement être détecté quand
       <link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>
       est activé sur l'abonné. Actuellement, la suppression est toujours
       appliquée quelque soit l'origine de la ligne locale.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="conflict-delete-missing" xreflabel="delete_missing">
     <term><literal>delete_missing</literal></term>
     <listitem>
      <para>
       La ligne à supprimer n'a pas été trouvée. La suppression sera simplement
       ignorée dans ce scénario.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="conflict-multiple-unique-conflicts" xreflabel="multiple_unique_conflicts">
     <term><literal>multiple_unique_conflicts</literal></term>
     <listitem>
      <para>
       Insérer ou mettre à jour une ligne viole plusieurs contraintes d'unicité
       <literal>NOT DEFERRABLE</literal>. Notez que pour tracer des détails
       comme l'origine et la date et heure des clés en conflit, il faut
       s'assurer que
       <link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>
       est activé sur l'abonné. Dans ce cas, une erreur sera levée jusqu'à ce
       que le conflit soit résolu manuellement.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
    Notez qu'il y a d'autres scénarios de conflit comme par exemple les
    violations de contraintes d'exclusion. Actuellement, nous ne fournissons
    pas de détails supplémentaires dans les traces pour ces scénarios.
  </para>

  <para>
   Le format de la trace pour les conflits de réplication logique ressemble à
   ceci&nbsp;:
<synopsis>
LOG:  conflict detected on relation "<replaceable>nom_schéma</replaceable>.<replaceable>nom_table</replaceable>": conflict=<replaceable>type_conflit</replaceable>
DETAIL:  <replaceable class="parameter">explication_détaillée</replaceable>.
{<replaceable class="parameter">informations_supplémentaires</replaceable> [; ... ]}.

<phrase>où <replaceable class="parameter">informations_supplémentaires</replaceable> fait partie de&nbsp;:</phrase>

    <literal>Key</literal> (<replaceable>nom_colonne</replaceable> <optional>, ...</optional>)=(<replaceable>valeur_colonne</replaceable> <optional>, ...</optional>)
    <literal>existing local row</literal> <optional>(<replaceable>column_name</replaceable> <optional>, ...</optional>)=</optional>(<replaceable>column_value</replaceable> <optional>, ...</optional>)
    <literal>remote row</literal> <optional>(<replaceable>column_name</replaceable> <optional>, ...</optional>)=</optional>(<replaceable>column_value</replaceable> <optional>, ...</optional>)
    <literal>replica identity</literal> {(<replaceable>nom_colonne</replaceable> <optional>, ...</optional>)=(<replaceable>valeur_colonne</replaceable> <optional>, ...</optional>) | full <optional>(<replaceable>nom_colonne</replaceable> <optional>, ...</optional>)=</optional>(<replaceable>valeur_colonne</replaceable> <optional>, ...</optional>)}
</synopsis>

   La trace fournit les informations suivantes&nbsp;:
   <variablelist>
    <varlistentry>
     <term><literal>LOG</literal></term>
      <listitem>
       <itemizedlist>
        <listitem>
         <para>
          <replaceable>nom_schéma</replaceable>.<replaceable>nom_table</replaceable>
          identifie la relation locale impliquée dans le conflit.
         </para>
        </listitem>
        <listitem>
         <para>
          <replaceable>type_conflit</replaceable> est le type de conflit
          survenu (par exemple <literal>insert_exists</literal>,
          <literal>update_exists</literal>).
         </para>
        </listitem>
       </itemizedlist>
      </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>DETAIL</literal></term>
      <listitem>
      <itemizedlist>
       <listitem>
        <para>
         <replaceable class="parameter">explication_détaillée</replaceable>
         inclut l'origine, l'identifiant de transaction et les date et heure
         de la transaction qui a modifié la ligne locale existante, si
         disponible.
        </para>
       </listitem>
       <listitem>
        <para>
         La section <literal>Key</literal> inclut les valeurs de la clé de la
         ligne locale qui a violé une contrainte d'unicité pour les conflits
         <literal>insert_exists</literal>, <literal>update_exists</literal> ou
         <literal>multiple_unique_conflicts</literal>.
        </para>
       </listitem>
       <listitem>
        <para>
         La section <literal>existing local tuple</literal> inclut la ligne
         locale si son origine diffère de la ligne distante pour les conflits
         <literal>update_origin_differs</literal> ou
         <literal>delete_origin_differs</literal>, ou si la valeur de la clé
         entre en conflit avec la ligne distante pour les conflits
         <literal>insert_exists</literal>, <literal>update_exists</literal> ou
         <literal>multiple_unique_conflicts</literal>.
        </para>
       </listitem>
       <listitem>
        <para>
         La section <literal>remote tuple</literal> inclut la nouvelle ligne
         de l'opération distante d'insertion ou de mise à jour qui a causé le
         conflit. Notez que pour une opération de mise à jour, la valeur de la
         colonne de la nouvelle ligne sera NULL si la valeur n'est pas modifiée
         ou placée dans un TOAST.
        </para>
       </listitem>
       <listitem>
        <para>
         La section <literal>replica identity</literal> inclut les valeurs de
         la clé d'identité de réplicat qui ont été utilisé pour la ligne locale
         existante qui doit être mise à jour ou supprimée. Cela peut inclure
         la valeur complète de la ligne si la relation locale est marquée avec
         <link linkend="sql-altertable-replica-identity-full"><literal>REPLICA
         IDENTITY FULL</literal></link>.
        </para>
       </listitem>
       <listitem>
        <para>
         <replaceable class="parameter">nom_colonne</replaceable> est le nom
         de la colonne. Pour les cas <literal>existing local tuple</literal>,
         <literal>remote tuple</literal> et <literal>replica identity
         full</literal>, les noms de colonne sont tracés uniquement si
         l'utilisateur n'a pas le droit d'accéder à toutes les colonnes de la
         table. Si les noms de colonne sont présents, ils apparaissent dans le
         même ordre que les valeurs correspondantes.
        </para>
       </listitem>
       <listitem>
        <para>
         <replaceable class="parameter">valeur_colonne</replaceable> est la
         valeur de la colonne. Les valeurs volumineuses sont tronquées à
         64 octets.
        </para>
       </listitem>
       <listitem>
        <para>
         Notez que dans le cas d'un conflit
         <literal>multiple_unique_conflicts</literal>, plusieurs lignes
         <replaceable class="parameter">explication_détaillée</replaceable>
         et <replaceable class="parameter">informations_supplémentaires</replaceable>
         seront générées, chacune détaillant l'information de conflit associée
         à des contraintes d'unicité distinctes.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Les opérations de réplication logique sont réalisées avec les droits du
   propriétaire de la souscription. Les échecs de droit sur les tables cibles
   causeront des conflits de réplication, tout autant que l'activation de <link
   linkend="ddl-rowsecurity">politiques de sécurité au niveau ligne</link> sur
   des tables cibles et pour lesquels le propriétaire de la souscription est
   sujet des politiques de sécurité, sans chercher si une politique rejetterait
   habituellement les opérations <command>INSERT</command>,
   <command>UPDATE</command>, <command>DELETE</command> ou
   <command>TRUNCATE</command> en cours de réplication. Cette restriction sur
   les politiques de sécurité niveau ligne pourrait être supprimée dans une
   prochaine version de <productname>PostgreSQL</productname>.
  </para>

  <para>
   Lorsqu'un conflit entraine une erreur, cela stoppe la réplication&nbsp;; Le
   conflit devra être résolu manuellement par un utilisateur. Des informations
   détaillées concernant le conflit seront disponibles dans les journaux
   applicatifs de l'instance abonnée.
  </para>

  <para>
   La résolution peut être réalisée, soit en changeant les données ou les droits
   sur la base abonnée pour qu'elles ne soient plus en conflit avec les données
   entrantes ou en évitant les transactions qui sont en conflit avec les données
   existantes. Quand un conflit produit une erreur, la réplication ne peut pas
   continuer et le processus worker de la réplication logique émet un message du
   type suivant dans les journaux applicatifs de l'abonné&nbsp;:
<screen>
ERROR:  conflict detected on relation "public.test": conflict=insert_exists
DETAIL:  Key already exists in unique index "t_pkey", which was modified locally in transaction 740 at 2024-06-26 10:47:04.727375+08.
Key (c)=(1); existing local row (1, 'local'); remote tuple (1, 'remote').
CONTEXT:  processing remote data for replication origin "pg_16395" during "INSERT" for replication target relation "public.test" in transaction 725 finished at 0/14C0378
</screen>
   Le LSN de la transaction qui contient le changement violant la contrainte et
   le nom d'origine de réplication peuvent être trouvés à partir du journal
   applicatif du serveur (LSN 0/14C0378 et origine de réplication
   <literal>pg_16395</literal> dans le cas ci-dessus). La transaction qui a
   produit le conflit peut être ignorée en utilisant l'instruction
   <link linkend="sql-altersubscription-params-skip"><command>ALTER SUBSCRIPTION
    ... SKIP</command></link> avec le LSN final (LSN
   0/14C0378). Le LSN final pourrait être un LSN sur lequel la transaction est
   validée ou préparée sur le publieur. La transaction peut aussi être ignorée
   en appelant la fonction <link
   linkend="pg-replication-origin-advance"><function>pg_replication_origin_advance()</function></link>.
   Avant d'utiliser cette fonction, la souscription doit être désactivée
   temporairement soit par <link linkend="sql-altersubscription-params-disable">
   <command>ALTER SUBSCRIPTION ... DISABLE</command></link>
   soit en utilisant l'option <link
   linkend="sql-createsubscription-params-with-disable-on-error"><literal>disable_on_error</literal></link>
   de la souscription. Ensuite, vous pouvez utiliser la fonction
   <function>pg_replication_origin_advance()</function> avec
   <parameter>node_name</parameter> (<literal>pg_16395</literal>) et le LSN
   suivant du LSN final (0/14C0379). La position actuelle des origines peut être
   trouvée dans la vue système <link
   linkend="view-pg-replication-origin-status"><structname>pg_replication_origin_status</structname></link>.
   Merci de noter qu'ignorer la transaction complète inclut d'ignorer des
   changements qui pourraient ne pas violer des contraintes. Ceci peut rendre
   l'abonné incohérent très facilement.
   Les détails supplémentaires concernant les lignes en conflit, comme leur
   origine et l'horodatage de la validation sont disponibles dans la ligne
   <literal>DETAIL</literal> de la trace. Mais notez que cette information est
   uniquement disponible quand
   <link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>
   est activé sur l'abonné. Les utilisateurs peuvent utiliser cette information
   pour décider s'il faut conserver la modification locale ou adopter la
   modification distante. Par exemple, la ligne <literal>DETAIL</literal> dans
   la trace ci-dessus indique que la ligne existante a été modifiée localement.
   Les utilisateurs peuvent réaliser manuellement un
   <foreignphrase></foreignphrase>.
  </para>

  <para>
   Quand le mode <link linkend="sql-createsubscription-params-with-streaming"><literal>streaming</literal></link>
   vaut <literal>parallel</literal>, le LSN final des transactions en échec peut ne pas être
   journalisé. Dans ce cas, il peut être nécessaire de changer le mode
   de flux (streaming) à <literal>on</literal> ou <literal>off</literal> et provoquer
   les même conflits encore pour que le LSN final des transactions échouées soit écrit dans
   le journal du serveur. Pour l'utilisation du LSN final, veuillez vous reférer à
   <link
   linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION ... SKIP</command></link>.
  </para>
 </sect1>

 <sect1 id="logical-replication-restrictions">
  <title>Restrictions</title>

  <para>
   La réplication logique souffre actuellement des restrictions ou des
   fonctionnalités manquantes suivantes. Elles pourraient être adressées dans
   les prochaines versions.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     La structure de la base de données et les commandes DDL ne sont pas
     répliquées. Le schéma initial peut être copié à la main en utilisant la
     commande <literal>pg_dump --schema-only</literal>. Les modifications de
     schéma suivantes auront besoin d'être synchronisées manuellement. (Notez,
     néanmoins, qu'il n'est pas nécessaire que les schémas soient strictement
     identiques des deux côtés.) La réplication logique est robuste quand il y a
     des modifications de schéma dans une base de données. Quand le schéma est
     changé sur le publieur et les données répliquées commencent à arriver sur
     l'abonné mais ne correspondent pas à la structure de la table, la
     réplication renverra une erreur jusqu'à ce que le schéma soit mis à jour.
     Dans de nombreux cas, les erreurs intermittentes peuvent être évitées en
     appliquant des modifications de schéma à l'abonné en premier&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Les données des séquences ne sont pas répliquées. Les données des colonnes
     de type serial et des colonnes identité, gérées par des séquences, seront
     bien sûr répliquées comme faisant partie de la table, mais la séquence
     elle-même affichera toujours la valeur de démarrage sur l'abonné. Si
     l'abonné est utilisé comme une base de données en lecture seule, alors cela
     ne devrait pas être un problème. Néanmoins, s'il est nécessaire de faire un
     bascule (<foreignphrase>switchover</foreignphrase> ou
     <foreignphrase>failover</foreignphrase> sur la base de données abonnée,
     alors les séquences auront besoin d'être mises à jour à leur dernières
     valeurs, soit en copiant les données courantes du publieur (peut-être en
     utilisant <command>pg_dump</command>), soit en déterminant une valeur
     suffisamment haute à partir des données de la table&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     La réplication des commandes <command>TRUNCATE</command> est supportée mais
     il est nécessaire de prêter attention lors de l'utilisation de cette
     commande sur des groupes de tables connectés par des clés étrangères. Lors
     de la réplication d'une action truncate, l'abonné tronquera le même groupe
     de tables tronquées sur le publieur, qu'elles soient spécifiées
     explicitement ou implicitement (grâce à la clause
     <literal>CASCADE</literal>), moins les tables qui ne font pas partie de la
     souscription. Ceci fonctionnera correctement si toutes les tables affectées
     font partie de la même souscription. Cependant, si certaines tables à
     tronquer ont des clés étrangères vers des tables qui ne font pas partie de
     la même souscription, alors l'application de l'action truncate échouera sur
     le serveur abonné&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Les Large Objects (voir <xref linkend="largeobjects"/>) ne sont pas
     répliqués. Il n'y a pas de contournement pour ça, en dehors d'enregistrer
     les données dans des tables normales&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     La réplication est seulement supportée par les tables, y compris les tables
     partitionnées. Toute tentative de répliquer d'autres types de relation,
     comme les vues, les vues matérialisées ou les tables externes, résultera en
     une erreur&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Lors de la réplication entre tables partitionnées, la réplication actuelle
     a pour origine, par défaut, les partitions filles sur le publieur, donc les
     partitions sur le publieur doivent exister aussi sur l'abonné en tant que
     tables cibles valides. Elles peuvent être soit des partitions filles
     elles-mêmes, soit de nouveau sous-partitionnées, soit des tables
     indépendantes. Les publications peuvent aussi spécifier les changements à
     répliquer en utilisant l'identité et le schéma de la table racine
     partitionnée au lieu de chaque partition individuelle à l'origine des
     changements (voir le paramètre
     <link linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>
     de <command>CREATE PUBLICATION</command>).
    </para>
   </listitem>

   <listitem>
    <para>
     Lors de l'utilisation de <link
     linkend="sql-altertable-replica-identity-full"><literal>REPLICA IDENTITY
     FULL</literal></link> sur les tables publiées, il est important de noter
     que les opérations <literal>UPDATE</literal> et <literal>DELETE</literal>
     ne peuvent être appliquées aux abonnés si les tables incluent des
     attributs avec les types de données (tels que point ou box) qui n'ont pas
     une classe d'opérateurs par défaut pour les méthodes B-tree ou Hash.
     Néanmoins, cette limitation peut être contournée en s'assurant que la
     table a une clé primaire ou une identité de réplica.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="logical-replication-architecture">
  <title>Architecture</title>

  <para>
   La réplication se construit de façon similaire à la réplication physique en
   flux (<foreignphrase>Streaming Replication</foreignphrase>, voir <xref
   linkend="streaming-replication"/>). Ceci est implémenté par les processus
   <literal>walsender</literal> et <literal>apply</literal>. Le processus walsender
   démarre le décodage logique (décrit dans la section <xref
   linkend="protocol-logical-replication"/>) des fichiers WAL et charge le
   plugin de décodage logique standard (<literal>pgoutput</literal>). Ce plugin
   transforme les
   changements lus depuis les fichiers WAL vers le protocole de réplication
   logique (voir <xref linkend="protocol-logical-replication"/>) et filtre les
   données en fonction des spécificités des publications. Les données sont
   envoyées au fil de l'eau au processus apply, qui met en relation les données
   vers les tables locales et applique les changements individuels au moment où
   ils sont reçus, dans le bon ordre transactionnel.
  </para>

  <para>
   Le processus apply sur l'instance de la base abonnée fonctionne toujours avec
   le paramètre <varname>session_replication_role</varname> défini à la valeur
   <literal>replica</literal>, qui produit les effets habituels sur les triggers
   et les contraintes.
  </para>

  <para>
   Le processus apply de la réplication logique déclenche actuellement des
   triggers de ligne, et non pas des triggers de requêtes. Néanmoins, la
   synchronisation initiale des tables est implémentée comme une commande
   <command>COPY</command>, ce qui peut déclencher les triggers
   <command>INSERT</command> en mode ligne et requête.
  </para>

  <sect2 id="logical-replication-snapshot">
   <title>Instantané initial</title>

   <para>
    Les données initiales dans les tables abonnées sont copiées dans des
    instances parallélisées d'un type spéciale de processus d'application.
    Ces processus sont des <foreignphrase>workers</foreignphrase> dédiés à la
    synchronisation de tables, avec une instance par table à synchroniser.
    Chaque processus de synchronisation de table crée son propre slot de
    réplication et copie les données existantes. Dès que la copie est terminée,
    le contenu de la table devient visible aux autres processus. Une fois les
    données existantes copiées, le processus entre en mode de synchronisation,
    qui s'assure d'amener la table à un état synchronisé avec le processus
    d'application principal en envoyant tout changement survenu pendant la copie
    initiale des données en utilisant la réplication logique standard. Durant
    cette phase de synchronisation, les modifications sont appliquées et
    validées dans le même ordre que sur le publieur. Une fois la synchronisation
    terminée, le contrôle de la réplication de la table est redonné au processus
    principal d'application où la réplication continue normalement.
   </para>

   <note>
    <para>
     Le paramètre de publication  <link
     linkend="sql-createpublication-params-with-publish"><literal>publish</literal></link>
     affecte uniquement
     les opérations DML qui seront répliquées. La synchronisation initiale des
     données ne prend pas ce paramètre en compte lors de la copie des données
     existantes de la table.
    </para>
   </note>

   <note>
    <para>
     Si un <foreignphrase>worker</foreignphrase> de synchronisation de table
     échoue lors de la copie, le processus d'application détecte l'échec et
     relance un <foreignphrase>worker</foreignphrase> de synchronisation de
     table pour continuer le processus de synchronisation. Ce comportement
     s'assure que les erreurs transitoires ne perturbent pas de façon
     permanente la configuration de la réplication. Voir aussi
     <link linkend="guc-wal-retrieve-retry-interval"><varname>wal_retrieve_retry_interval</varname></link>.
    </para>
   </note>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-monitoring">
  <title>Supervision</title>

  <para>
   Puisque la réplication logique est basée sur une architecture similaire à la
   <link linkend="streaming-replication">réplication physique en flux</link>, la
   supervision d'une instance publication est similaire à la supervision d'une
   instance primaire dans la réplication physique (voir <xref
   linkend="streaming-replication-monitoring"/>).
  </para>

  <para>
   Les informations des abonnements sont consultables dans la vue <link
   linkend="monitoring-pg-stat-subscription"><structname>pg_stat_subscription</structname></link>.
   Cette vue contient une ligne pour chaque processus d'abonnement. Un
   abonnement peut avoir zéro ou plusieurs processus abonnés, selon son état.
  </para>

  <para>
   Normalement il y a un seul processus apply démarré pour un abonnement actif.
   Un abonnement désactivé ou une publication effondrée n'aura pas de ligne dans
   cette vue. Si la synchronisation initiale d'une table est en cours, il y
   aura des processus supplémentaires pour les tables en cours de
   synchronisation. En outre, si la transaction
   <link linkend="sql-createsubscription-params-with-streaming"><literal>streaming</literal></link>
   est appliquée en parallèle, il y aura des processus apply parallèles supplémentaires.
  </para>
 </sect1>

 <sect1 id="logical-replication-security">
  <title>Sécurité</title>

  <para>
   Le rôle utilisée pour la réplication doit avoir l'attribut
   <literal>REPLICATION</literal> (ou être un superutilisateur). Si le rôle ne
   dispose pas des attributs <literal>SUPERUSER</literal> et
   <literal>BYPASSRLS</literal>, les politiques de sécurité niveau ligne du
   publieur peuvent s'exécuter. Si le rôle n'a pas confiance en tous les
   propriétaires de tables, incluez
   <literal>options=-crow_security=off</literal> dans la chaîne de
   connexion&nbsp;;: si un propriétaire de table ajoute ensuite une politique de
   sécurité de ligne, cette configuration imposera un arrêt de la réplication
   plutôt qu'une exécution de la politique. L'accès de ce rôle à l'instance doit
   avoir été déclaré dans <filename>pg_hba.conf</filename> et ce rôle doit avoir
   l'attribut <literal>LOGIN</literal>.
  </para>

  <para>
   Pour être capable de copier les données originales de la table, le rôle
   utilisé pour la connexion de réplication doit avoir le droit
   <literal>SELECT</literal> sur une table publiée (ou être un
   superutilisateur).
  </para>

  <para>
   Pour créer une publication, l'utilisateur doit avoir le droit
   <literal>CREATE</literal> pour la base de données.
  </para>

  <para>
   Pour ajouter des tables à une publication, l'utilisateur doit être
   propriétaire de ces tables. Pour ajouter toutes les tables d'un schéma dans
   une publication, l'utilisateur doit avoir l'attribut
   <literal>SUPERUSER</literal>. Pour créer une publication qui publie toutes
   les tables ou toutes les tables d'un schéma automatiquement, l'utilisateur
   doit avoir l'attribut <literal>SUPERUSER</literal>.
  </para>

  <para>
   Actuellement, il n'y a aucun droit sur les abonnements. Tout abonnement (qui
   est capable de se connecter) peut accéder à n'importe quelle publication. Ainsi,
   si vous avez l'intention de cacher certaines informations à certains abonnés, en utilisant
   le filtrage de ligne ou les listes de colonnes, ou en n'ajoutant pas la totalité de la table
   à la publication, soyez averti que les autres publications dans la même base de données
   pourront exposer les mêmes informations. Les droits de publication pourront être
   ajoutés à <productname>PostgreSQL</productname> dans le futur pour permettre un
   contrôle d'accès plus fin.
  </para>

  <para>
   Pour créer un abonnement, l'utilisateur doit avoir les droits du
   rôle <literal>pg_create_subscription</literal> ainsi que le droit
   <literal>CREATE</literal> sur la base de données.
  </para>

  <para>
   Le processus d'application de l'abonnement va, au niveau de la session, s'exécuter
   avec les droits du propriétaire de l'abonnement. Cependant, quand une opération
   d'insertion, de mise à jour, de suppression ou de troncation est effectuée sur
   un table donnée, le rôle sera interverti avec celui du propriétaire de la table
   et l'opération effectuée avec les droits du propriétaire de la table.
   Cela signifie que le propriétaire de l'abonnement doit pouvoir faire un
   <literal>SET ROLE</literal> sur chacun des rôles propriétaires des tables répliquées.
  </para>

  <para>
   Si l'abonnement a été configuré avec <literal>run_as_owner = true</literal>,
   alors aucun changement d'utilisateur ne sera possible. À la place,
   les opérations seront effectuées avec les droits du propriétaire de l'abonnement.
   Dans ce cas, le propriétaire de l'abonnement nécessite seulement des droits
   pour <literal>SELECT</literal>, <literal>INSERT</literal>,
   <literal>UPDATE</literal> et <literal>DELETE</literal> sur les tables cibles,
   et n'a pas besoin de droits pour faire un <literal>SET ROLE</literal> sur
   les propriétaires des tables. Cependant, cela implique aussi que n'importe
   quel utilisateur propriétaire de table sur laquelle la réplication s'applique,
   pourra exécuter du code arbitrairement avec les droits du propriétaire de
   l'abonnement. Par exemple, ils pourront effectuer cela simplement en
   attachant un trigger à une des tables dont ils sont propriétaires.
   Parce qu'il est fortement indésirable de permettre à un rôle d'assumer librement
   les droits d'un autre, cette option devrait être évitée sauf si la sécurité
   de la base de données n'est pas un problème.
  </para>

  <para>
   Sur le publieur, les droits sont vérifiés uniquement au démarrage de la
   connexion de réplication et ne sont pas vérifiés de nouveau à chaque fois
   qu'un enregistrement de changement est lu.
  </para>

  <para>
   Sur l'abonné, les droits du propriétaire de la souscription sont vérifiés à
   chaque application d'une transaction. Si un processus worker est en cours de
   traitement pour appliquer une transaction au moment où le propriétaire de la
   souscription est changé dans une transaction concurrente, l'application de la
   transaction en cours continuera sous les droits de l'ancien propriétaire.
  </para>
 </sect1>

 <sect1 id="logical-replication-config">
  <title>Paramètres de configuration</title>

  <para>
   La réplication logique requiert de nombreuses configurations pour
   fonctionner. Ces options ne sont pertinentes que d'un côté de la réplication.
  </para>

  <sect2 id="logical-replication-config-publisher">
   <title>Publieurs</title>

   <para>
    <link linkend="guc-wal-level"><varname>wal_level</varname></link> doit être
    mis à <literal>logical</literal>.
   </para>

   <para>
    <link linkend="guc-max-replication-slots"><varname>max_replication_slots</varname></link>
    doit être mis au moins au nombre d'abonnements attendus de se connecter, plus
    une réserve pour la synchronisation des tables.
   </para>

   <para>
    Les slots de réplication logique sont aussi affectés par
    <link linkend="guc-idle-replication-slot-timeout"><varname>idle_replication_slot_timeout</varname></link>.
   </para>

   <para>
    <link linkend="guc-max-wal-senders"><varname>max_wal_senders</varname></link>
    doit être mis à au moins la même valeur que <varname>max_replication_slots</varname>, plus le nombre de
    réplicas physiques qui sont connectés en même temps.
   </para>

   <para>
    Le walsender de réplication logique est aussi impacté par
    <link linkend="guc-wal-sender-timeout"><varname>wal_sender_timeout</varname></link>.
   </para>

  </sect2>

  <sect2 id="logical-replication-config-subscriber">
   <title>Abonnés</title>

   <para>
    <link linkend="guc-max-active-replication-origins"><varname>max_active_replication_origins</varname></link>
    doit être mis à au moins le nombre d'abonnements qui seront ajoutés à l'abonné, plus une réserve
    pour la synchronisation des tables.
   </para>

   <para>
    <link linkend="guc-max-logical-replication-workers"><varname>max_logical_replication_workers</varname></link>
    doit être mis à au moins le nombre d'abonnements (pour les processus apply leader),
    plus une réserve pour les processus de synchronisation des tables et les processus apply parallèles.
   </para>

   <para>
    <link linkend="guc-max-worker-processes"><varname>max_worker_processes</varname></link>
    peut être ajusté pour accommoder les processus de réplication, au moins
    (<link linkend="guc-max-logical-replication-workers"><varname>max_logical_replication_workers</varname></link>
    <literal>1</literal>). Notez que certaines extensions et requêtes parallèles puisent aussi
    des slots de processus dans <varname>max_worker_processes</varname>.
   </para>

   <para>
    <link linkend="guc-max-sync-workers-per-subscription"><varname>max_sync_workers_per_subscription</varname></link>
    contrôle la quantité de parallélisme lors de la copie initiale des données lors de
    l'initialisation de l'abonnement ou quand des nouvelles tables sont ajoutées.
   </para>

   <para>
    <link linkend="guc-max-parallel-apply-workers-per-subscription"><varname>max_parallel_apply_workers_per_subscription</varname></link>
    contrôle la quantité de parallélisme pour le flux des transaction en cours avec
    le paramètre d'abonnement <literal>streaming = parallel</literal>.
   </para>

   <para>
    Les processus de réplication logique sont aussi affectés par
    <link linkend="guc-wal-receiver-timeout"><varname>wal_receiver_timeout</varname></link>,
    <link linkend="guc-wal-receiver-status-interval"><varname>wal_receiver_status_interval</varname></link> et
    <link linkend="guc-wal-retrieve-retry-interval"><varname>wal_retrieve_retry_interval</varname></link>.
   </para>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-upgrade">
  <title>Mise à jour</title>

  <para>
   Les migrations d'<glossterm
   linkend="glossary-logical-replication-cluster">instances en réplication
   logique</glossterm> sont possibles seulement quand tous les membres des
   anciennes instances en réplication logique sont en version 17 ou ultérieur.
  </para>

  <sect2 id="prepare-publisher-upgrades">
   <title>Préparations pour les mises à jour d'un publieur</title>

   <para>
    <application>pg_upgrade</application> tente de migrer les slots de
    réplication logique. Ceci aide à éviter le besoin de définir manuellement
    les mêmes slots de réplication sur le nouveau publieur. La migration des
    slots de réplication logique est uniquement prise en compte quand l'ancienne
    instance est de version 17 ou ultérieur. Les slots logiques sur des
    instances de version antérieure à la 17 seront ignorés silencieusement.
   </para>

   <para>
    Avant de commencer à mettre à jour l'instance publieur, assurez-vous que
    l'abonnement est désactivé temporairement en exécutant
    <link linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>.
    Ré-activez l'abonnement après la mise à jour.
   </para>

   <para>
    Il existe quelques prérequis pour que <application>pg_upgrade</application>
    soit capable de mettre à jour les slots logiques. S'ils ne sont pas
    rencontrés, une erreur sera levée.
   </para>

   <itemizedlist>
    <listitem>
     <para>
      La nouvelle instance doit avoir
      <link linkend="guc-wal-level"><varname>wal_level</varname></link> à
      <literal>logical</literal>.
     </para>
    </listitem>
    <listitem>
     <para>
      La nouvelle instance doit avoir
      <link linkend="guc-max-replication-slots"><varname>max_replication_slots</varname></link>
      configuré à une valeur supérieure ou égale au nombre de slots présents
      sur l'ancienne instance.
     </para>
    </listitem>
    <listitem>
     <para>
      Les plugins en sortie référencés par les slots de l'ancienne instance
      doivent être installés dans le nouveau répertoire des exécutables de
      PostgreSQL.
     </para>
    </listitem>
    <listitem>
     <para>
      L'ancienne instance a répliqué toutes les transactions et tous les
      messages de décodage logique aux abonnés.
     </para>
    </listitem>
    <listitem>
     <para>
      Tous les slots de l'ancienne instance doivent être utilisables, donc
      il ne doit y avoir aucun socle pour lequel
      <link linkend="view-pg-replication-slots">pg_replication_slots</link>.<structfield>conflicting</structfield>
      ne vaut pas <literal>true</literal>.
     </para>
    </listitem>
    <listitem>
     <para>
      La nouvelle instance ne doit pas avoir de slots logiques permanents, donc
      il ne doit y avoir aucun slot pour lequel
      <link linkend="view-pg-replication-slots">pg_replication_slots</link>.<structfield>temporary</structfield>
      vaut <literal>false</literal>.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 id="prepare-subscriber-upgrades">
   <title>Préparations pour les mises à jour d'un abonné</title>

   <para>
    Modifier les <link linkend="logical-replication-config-subscriber">
    configurations de l'abonné</link> vers le nouvel abonné.
    <application>pg_upgrade</application> tente de migrer les dépendances de
    l'abonnement qui incluent les informations des tables abonnées présentes
    dans le catalogue système <link
    linkend="catalog-pg-subscription-rel">pg_subscription_rel</link> ainsi que
    l'origine de la réplication de l'abonnement. Ceci permet à la réplication
    logique sur le nouvel abonné de continuer à partir de l'endroit où
    l'ancien abonné s'était arrêté. La migration des dépendances de l'abonnement
    est seulement prise en compte quand l'ancienne instance est de version 17 ou
    ultérieure. Les dépendances d'abonnement pour des instances antérieures à
    la version 17 sont ignorées silencieusement.
   </para>

   <para>
    Il existe quelques prérequis pour que <application>pg_upgrade</application>
    soit capable de mettre à jour les abonnements. S'ils ne sont pas rencontrés,
    une erreur sera remontée.
   </para>

   <itemizedlist>
    <listitem>
     <para>
      Toutes les tables de l'abonnement sur l'ancien abonné doivent être dans
      l'état <literal>i</literal> (initialisation) ou <literal>r</literal>
      (prête). Ceci peut se vérifier en regardant
      le champ <structfield>srsubstate</structfield> de la vue
      <link linkend="catalog-pg-subscription-rel">pg_subscription_rel</link>.
     </para>
    </listitem>
    <listitem>
     <para>
      L'entrée de l'origine de réplication correspondant à chacun des
      abonnements doit exister dans l'ancienne instance. Ceci peut se vérifier
      en regardant les catalogues systèmes
      <link linkend="catalog-pg-subscription">pg_subscription</link> et
      <link linkend="catalog-pg-replication-origin">pg_replication_origin</link>.
     </para>
    </listitem>
    <listitem>
     <para>
      La nouvelle instance doit avoir le paramètre
      <link linkend="guc-max-active-replication-origins"><varname>max_active_replication_origins</varname></link>
      configuré à une valeur supérieure ou égale au nombre d'abonnements
      présents dans l'ancienne instance.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 id="upgrading-logical-replication-clusters">
   <title>Mettre à jour des clusters de réplication logique</title>

   <para>
    Lors de la mise à jour d'un abonné, les opérations en écriture peuvent se
    faire sur le publieur. Ces changements seront répliqués sur l'abonné une
    fois la mise à jour de l'abonné terminé.
   </para>

   <note>
    <para>
     Les restrictions de la réplication logique s'appliquent aussi aux mises à
     jour d'un cluster de réplication logique. Voir
     <xref linkend="logical-replication-restrictions"/> pour plus de détails.
    </para>
    <para>
     Les prérequis d'une mise à jour d'un publieur s'appliquent aussi aux mises
     à jour d'un cluster de réplication logique. Voir
     <xref linkend="prepare-publisher-upgrades"/> pour plus de détails.
    </para>
    <para>
     Les prérequis d'une mise à jour d'un abonné s'appliquent aussi aux mises
     à jour d'un cluster de réplication logique. Voir
     <xref linkend="prepare-subscriber-upgrades"/> pour plus de détails.
    </para>
   </note>

   <warning>
    <para>
     Mettre à jour un cluster de réplication logique requiert la réalisation
     de plusieurs étapes sur plusieurs nœuds. Comme toutes les opérations ne
     sont pas transactionnelles, l'utilisateur est avisé à réaliser des
     sauvegardes comme décrit dans <xref linkend="backup-base-backup"/>.
    </para>
   </warning>

   <para>
    Les étapes pour mettre à jour des clusters de réplication logique sont
    détaillées ci-dessous&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       Suivre les étapes indiquées dans
       <xref linkend="steps-two-node-logical-replication-cluster"/> pour mettre
       à jour un cluster de réplication logique à deux nœuds.
      </para>
     </listitem>
     <listitem>
      <para>
       Suivre les étapes indiquées dans
       <xref linkend="steps-cascaded-logical-replication-cluster"/> pour mettre
       à jour un cluster de réplication logique en cascade.
      </para>
     </listitem>
     <listitem>
      <para>
       Suivre les étapes indiquées dans
       <xref linkend="steps-two-node-circular-logical-replication-cluster"/>
       pour mettre à jour un cluster de réplication logique circulaire à deux
       nœuds.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <sect3 id="steps-two-node-logical-replication-cluster">
   <title>Étapes pour mettre à jour un cluster de réplication logique à deux nœuds</title>
     <para>
      Disons que le publieur est sur <literal>node1</literal> et l'abonné est
      sur <literal>node2</literal>. L'abonné <literal>node2</literal> a un
      abonnement <literal>sub1_node1_node2</literal> qui récupère les
      changements de <literal>node1</literal>.
     </para>

     <procedure>
      <step id="two-node-cluster-disable-subscriptions-node2">
       <para>
        Désactivez tous les abonnements sur <literal>node2</literal> qui sont
        récupèrent les changements de <literal>node1</literal> en utilisant
        <link linkend="sql-altersubscription-params-disable"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>,
        par exemple&nbsp;:
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 DISABLE;
</programlisting>
       </para>
      </step>
      <step>
       <para>
        Arrêtez le serveur publieur sur <literal>node1</literal>, par exemple&nbsp;:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data1 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Initialisez l'instance <literal>data1_upgraded</literal> en utilisant
        dans la nouvelle version requise.
       </para>
      </step>

      <step>
       <para>
        Mettez à jour le serveur publieur <literal>node1</literal> à la nouvelle
        version requise, par exemple&nbsp;:
<programlisting>
pg_upgrade
        --old-datadir "/opt/PostgreSQL/postgres/17/data1"
        --new-datadir "/opt/PostgreSQL/postgres/18/data1_upgraded"
        --old-bindir "/opt/PostgreSQL/postgres/17/bin"
        --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Démarrez le serveur publieur mis à jour sur <literal>node1</literal>,
        par exemple&nbsp;:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data1_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Arrêtez le serveur abonné sur <literal>node2</literal>, par
        exemple&nbsp;:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data2 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Initialisez l'instance <literal>data2_upgraded</literal> en utilisant
        la nouvelle version requise.
       </para>
      </step>

      <step>
       <para>
        Mettez à jour le serveur abonné sur <literal>node2</literal> à la
        nouvelle version requise, par exemple&nbsp;:
<programlisting>
pg_upgrade
       --old-datadir "/opt/PostgreSQL/postgres/17/data2"
       --new-datadir "/opt/PostgreSQL/postgres/18/data2_upgraded"
       --old-bindir "/opt/PostgreSQL/postgres/17/bin"
       --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Démarrez le serveur abonné mis à jour sur <literal>node2</literal>, par
        exemple&nbsp;:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data2_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Sur <literal>node2</literal>, créez toute table qui a été créé sur le
        serveur publieur mis à jour <literal>node1</literal> entre
        <xref linkend="two-node-cluster-disable-subscriptions-node2"/>
        et maintenant&nbsp;:
<programlisting>
/* node2 # */ CREATE TABLE distributors (did integer PRIMARY KEY, name varchar(40));
CREATE TABLE
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Activez tous les abonnements sur <literal>node2</literal> qui récupèrent
        des modifications de <literal>node1</literal> en utilisant
        <link linkend="sql-altersubscription-params-enable"><command>ALTER SUBSCRIPTION ... ENABLE</command></link>,
        donc&nbsp;:
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 ENABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Rafraichissez les publications pour les abonnements de
        <literal>node2</literal> en utilisant&nbsp;:
        <link linkend="sql-altersubscription-params-refresh-publication"><command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command></link>,
        donc&nbsp;:
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 REFRESH PUBLICATION;
</programlisting>
       </para>
      </step>
     </procedure>

     <note>
      <para>
       Dans les étapes décrites ci-dessus, le publieur est tout d'abord mis à
       jour, suivi par l'abonné. Autrement, l'utilisateur peut utiliser des
       étapes similaires pour mettre à jour l'abonné dans un premier temps,
       puis mettre à jour le publieur.
      </para>
     </note>
    </sect3>

    <sect3 id="steps-cascaded-logical-replication-cluster">
     <title>Étapes pour mettre à jour un cluster de réplication logique en cascade</title>
     <para>
      Disons que nous avons une configuration de réplication logique en cascade
      du type <literal>node1</literal>-><literal>node2</literal>-><literal>node3</literal>.
      Ici <literal>node2</literal> est abonné aux modifications de
      <literal>node1</literal> et <literal>node3</literal> est abonné aux
      modifications de <literal>node2</literal>. <literal>node2</literal> a
      l'abonnement <literal>sub1_node1_node2</literal> pour les modifications de
      <literal>node1</literal>. <literal>node3</literal> a l'abonnement
      <literal>sub1_node2_node3</literal> pour les modifications de
      <literal>node2</literal>.
     </para>

     <procedure>
      <step id="cascaded-cluster-disable-sub-node1-node2">
       <para>
        Désactivez tous les abonnements sur <literal>node2</literal> qui
        récupèrent les modifications provenant de <literal>node1</literal> en
        utilisant <link
        linkend="sql-altersubscription-params-disable"><command>ALTER
        SUBSCRIPTION ... DISABLE</command></link>, donc&nbsp;:
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 DISABLE;
ALTER SUBSCRIPTION
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Arrêtez le serveur sur <literal>node1</literal>, donc&nbsp;:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data1 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Initialisez l'instance <literal>data1_upgraded</literal> en utilisant
        la nouvelle version requise.
       </para>
      </step>

      <step>
       <para>
        Mettez à jour le serveur de <literal>node1</literal> vers la nouvelle
        version requise, donc&nbsp;:
<programlisting>
pg_upgrade
        --old-datadir "/opt/PostgreSQL/postgres/17/data1"
        --new-datadir "/opt/PostgreSQL/postgres/18/data1_upgraded"
        --old-bindir "/opt/PostgreSQL/postgres/17/bin"
        --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Démarrez le serveur mis à jour sur <literal>node1</literal>, donc&nbsp;:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data1_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step id="cascaded-cluster-disable-sub-node2-node3">
       <para>
        Désactivez tous les abonnements sur <literal>node3</literal> qui
        récupèrent les modifications provenant de <literal>node2</literal> en
        utilisant <link
        linkend="sql-altersubscription-params-disable"><command>ALTER
        SUBSCRIPTION ... DISABLE</command></link>, donc&nbsp;:
<programlisting>
/* node3 # */ ALTER SUBSCRIPTION sub1_node2_node3 DISABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Arrêtez le serveur sur <literal>node2</literal>, donc&nbsp;:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data2 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Initialisez l'instance <literal>data2_upgraded</literal> en utilisant
        la nouvelle version requise.
       </para>
      </step>

      <step>
       <para>
        Mettez à jour le serveur de <literal>node2</literal> vers la nouvelle
        version requise, donc&nbsp;:
<programlisting>
pg_upgrade
        --old-datadir "/opt/PostgreSQL/postgres/17/data2"
        --new-datadir "/opt/PostgreSQL/postgres/18/data2_upgraded"
        --old-bindir "/opt/PostgreSQL/postgres/17/bin"
        --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Démarrez le serveur mis à jour sur <literal>node2</literal>, donc&nbsp;:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data2_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Sur <literal>node2</literal>, créez toute table qui a été créée sur le
        publieur mis à jour, donc <literal>node1</literal>, entre
        <xref linkend="cascaded-cluster-disable-sub-node1-node2"/>
        et maintenant, par exemple&nbsp;:
<programlisting>
/* node2 # */ CREATE TABLE distributors (did integer PRIMARY KEY, name varchar(40));
CREATE TABLE
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Activez tous les abonnements de <literal>node2</literal> qui récupèrent
        les modifications sur <literal>node1</literal> en utilisant <link
        linkend="sql-altersubscription-params-enable"><command>ALTER
        SUBSCRIPTION ... ENABLE</command></link>, donc&nbsp;:
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 ENABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Rafraichissez les publications des abonnements de
        <literal>node2</literal> en utilisant <link
        linkend="sql-altersubscription-params-refresh-publication"><command>ALTER
        SUBSCRIPTION ... REFRESH PUBLICATION</command></link>, donc&nbsp;:
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 REFRESH PUBLICATION;
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Arrêtez le serveur sur <literal>node3</literal>, donc&nbsp;:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data3 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Initialisez l'instance <literal>data3_upgraded</literal> en utilisant la
        nouvelle version requise.
       </para>
      </step>

      <step>
       <para>
        Mettez à jour le serveur de <literal>node3</literal> vers la nouvelle
        version requise, donc&nbsp;:
<programlisting>
pg_upgrade
        --old-datadir "/opt/PostgreSQL/postgres/17/data3"
        --new-datadir "/opt/PostgreSQL/postgres/18/data3_upgraded"
        --old-bindir "/opt/PostgreSQL/postgres/17/bin"
        --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Démarrez le serveur mis à jour sur <literal>node3</literal>, donc&nbsp;:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data3_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Sur <literal>node3</literal>, créez toute table qui a été créée sur le
        serveur <literal>node2</literal> entre
        <xref linkend="cascaded-cluster-disable-sub-node2-node3"/> et maintenant,
        donc&nbsp;:
<programlisting>
/* node3 # */ CREATE TABLE distributors (did integer PRIMARY KEY, name varchar(40));
CREATE TABLE
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Activez tous les abonnements sur <literal>node3</literal> qui récupèrent
        les modifications provenant de <literal>node2</literal> en utilisant
        <link linkend="sql-altersubscription-params-enable"><command>ALTER
        SUBSCRIPTION ... ENABLE</command></link>, donc&nbsp;:
<programlisting>
/* node3 # */ ALTER SUBSCRIPTION sub1_node2_node3 ENABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Rafraichissez les publications des abonnements de
        <literal>node3</literal> en utilisant <link
        linkend="sql-altersubscription-params-refresh-publication"><command>ALTER
        SUBSCRIPTION ... REFRESH PUBLICATION</command></link>, donc&nbsp;:
<programlisting>
/* node3 # */ ALTER SUBSCRIPTION sub1_node2_node3 REFRESH PUBLICATION;
</programlisting>
       </para>
      </step>
     </procedure>
    </sect3>

    <sect3 id="steps-two-node-circular-logical-replication-cluster">
     <title>Étapes pour mettre à jour une instance de réplication logique
     circulaire à 2 nœuds</title>
     <para>
      Disons que nous avons une configuration de réplication logique circulaire
      avec <literal>node1</literal>-><literal>node2</literal> et
      <literal>node2</literal>-><literal>node1</literal>. Ici,
      <literal>node2</literal> est abonné aux modifications de
      <literal>node1</literal> et <literal>node1</literal> est abonné aux
      modifications de <literal>node2</literal>. <literal>node1</literal> a
      l'abonnement <literal>sub1_node2_node1</literal> qui récupère les
      modifications de <literal>node2</literal>. <literal>node2</literal> a
      l'abonnement <literal>sub1_node1_node2</literal> qui récupère les
      modifications de <literal>node1</literal>.
     </para>

     <procedure>
      <step id="circular-cluster-disable-sub-node2">
       <para>
        Désactivez tous les abonnements sur <literal>node2</literal> qui
        récupèrent les modifications provenant de <literal>node1</literal> en
        utilisant <link
        linkend="sql-altersubscription-params-disable"><command>ALTER
        SUBSCRIPTION ... DISABLE</command></link>, donc&nbsp;:
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 DISABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Arrêtez le serveur sur <literal>node1</literal>, donc&nbsp;:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data1 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Initialisez l'instance <literal>data1_upgraded</literal> en utilisant
        la nouvelle version requise.
       </para>
      </step>

      <step>
       <para>
        Mettez à jour le serveur de <literal>node1</literal> vers la nouvelle
        version requise, donc&nbsp;:
<programlisting>
pg_upgrade
        --old-datadir "/opt/PostgreSQL/postgres/17/data1"
        --new-datadir "/opt/PostgreSQL/postgres/18/data1_upgraded"
        --old-bindir "/opt/PostgreSQL/postgres/17/bin"
        --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Démarrez le serveur mis à jour <literal>node1</literal>, donc&nbsp;:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data1_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Activez tous les abonnements sur <literal>node2</literal> qui récupèrent
        les modifications provenant de <literal>node1</literal> en utilisant
        <link linkend="sql-altersubscription-params-enable"><command>ALTER
        SUBSCRIPTION ... ENABLE</command></link>, donc&nbsp;:
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 ENABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Sur <literal>node1</literal>, créez toute table qui a été créée sur
        <literal>node2</literal> entre <xref linkend="circular-cluster-disable-sub-node2"/>
        et maintenant, par exemple&nbsp;:
<programlisting>
node1=# CREATE TABLE distributors (did integer PRIMARY KEY, name varchar(40));
</programlisting>
       </para>
      </step>


      <step>
       <para>
        Rafraichissez les publications des abonnements de
        <literal>node1</literal> pour copier les données des tables de
        <literal>node2</literal> en utilisant
        <link linkend="sql-altersubscription-params-refresh-publication"><command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command></link>,
        e.g.:
<programlisting>
node1=# ALTER SUBSCRIPTION sub1_node2_node1 REFRESH PUBLICATION;
</programlisting>
       </para>
      </step>

      <step id="circular-cluster-disable-sub-node1">
       <para>
        Désactivez tous les abonnements sur <literal>node1</literal> qui
        récupèrent les modifications dprovenant de <literal>node2</literal> en
        utilisant <link
        linkend="sql-altersubscription-params-disable"><command>ALTER
        SUBSCRIPTION ... DISABLE</command></link>, donc&nbsp;:
<programlisting>
node1=# ALTER SUBSCRIPTION sub1_node2_node1 DISABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Arrêtez le serveur sur <literal>node2</literal>, donc&nbsp;:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data2 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Initialisez l'instance <literal>data2_upgraded</literal> en utilisant
        la nouvelle version requise.
       </para>
      </step>

      <step>
       <para>
        Mettez à jour le serveur sur <literal>node2</literal> vers la nouvelle
        version requise, donc&nbsp;:
<programlisting>
pg_upgrade
        --old-datadir "/opt/PostgreSQL/postgres/17/data2"
        --new-datadir "/opt/PostgreSQL/postgres/18/data2_upgraded"
        --old-bindir "/opt/PostgreSQL/postgres/17/bin"
        --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Démarrez le serveur mis à jour sur <literal>node2</literal>, donc&nbsp;:
<programlisting>
pg_ctl -D /opt/PostgreSQL/data2_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Activez tous les abonnements sur <literal>node1</literal> qui récupèrent
        les modifications provenant de <literal>node2</literal> en utilisant
        <link linkend="sql-altersubscription-params-enable"><command>ALTER
        SUBSCRIPTION ... ENABLE</command></link>, donc&nbsp;:
<programlisting>
node1=# ALTER SUBSCRIPTION sub1_node2_node1 ENABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Sur <literal>node2</literal>, créez toute table que a été créée sur le
        serveur mise à jour <literal>node1</literal> entre <xref
        linkend="circular-cluster-disable-sub-node1"/> et maintenant, donc&nbsp;:
<programlisting>
/* node2 # */ CREATE TABLE distributors (did integer PRIMARY KEY, name varchar(40));
</programlisting>
       </para>
      </step>

      <step>
       <para>
        Rafraichissez les publications des abonnements de <literal>node2</literal>
        pour copier les données des tables du serveur <literal>node1</literal>
        en utilisant <link
        linkend="sql-altersubscription-params-refresh-publication"><command>ALTER
        SUBSCRIPTION ... REFRESH PUBLICATION</command></link>, donc&nbsp;:
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 REFRESH PUBLICATION;
</programlisting>
       </para>
      </step>
     </procedure>
    </sect3>

   </sect2>
 </sect1>

 <sect1 id="logical-replication-quick-setup">
  <title>Démarrage rapide</title>

  <para>
   En premier, définissez les options de configurations dans le fichier
   <filename>postgresql.conf</filename>&nbsp;:
   <programlisting>wal_level = logical</programlisting>
   La valeur par défaut des autres paramètres est suffisante pour une mise en
   place de base.
  </para>

  <para>
   Le fichier <filename>pg_hba.conf</filename> doit être mis à jour pour
   autoriser la réplication (les valeurs dépendent de la configuration réelle de
   votre réseau et de l'utilisateur dont vous disposerez pour vous
   connecter)&nbsp;:
   <programlisting>host     all     repuser     0.0.0.0/0     md5</programlisting>
  </para>

  <para>
   Ensuite sur la base du publieur&nbsp;:
   <programlisting>
CREATE PUBLICATION mypub FOR TABLE users, departments;
   </programlisting>
  </para>

  <para>
   Et sur la base abonnée&nbsp;:
   <programlisting>
CREATE SUBSCRIPTION mysub CONNECTION 'dbname=foo host=bar user=repuser' PUBLICATION mypub;
   </programlisting>
  </para>

  <para>
   Les instructions précédentes vont démarrer le processus de réplication, qui
   va réaliser la synchronisation initiale du contenu des tables
   <literal>users</literal> et <literal>departments</literal> et qui commencera
   ensuite à répliquer les changements de manière incrémentale sur ces tables.
  </para>
 </sect1>
</chapter>
