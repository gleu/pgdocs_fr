<?xml version="1.0" encoding="UTF-8"?>
<chapter id="logical-replication">
 <title>Réplication logique</title>

 <para>
  La réplication logique est une méthode permettant de répliquer des données au
  niveau objet ainsi que les modifications apportées à ces objets, ceci basé sur
  leur identité de réplication (habituellement la clé primaire). L'utilisation
  du terme de <quote>réplication logique</quote> est faite en opposition à la
  réplication physique, cette dernière utilisant l'adresse exacte des blocs couplée
  avec une réplication octet par octet. PostgreSQL supporte ces deux méthodes,
  référez-vous à l'article <xref linkend="high-availability"/>. La réplication
  logique permet un contrôle fin des données au niveau de la réplication et de
  la sécurité.
 </para>

 <para>
  La réplication logique utilise un système de
  <firstterm>publication</firstterm> / <firstterm>abonnement</firstterm> avec un
  ou plusieurs <firstterm>abonnés</firstterm> qui s'abonnent à une ou plusieurs
  <firstterm>publications</firstterm> d'un nœud particulier. Les abonnés
  récupèrent les données des publications auxquelles ils sont abonnés et peuvent
  éventuellement renvoyer ces informations, ce qui permet un système de
  réplication en cascade dans le cas de configurations plus complexes.
 </para>

 <para>
  La réplication logique d'une table commence en général en prenant un
  instantané des données sur la base publiée et en le copiant vers la base
  abonnée. Une fois cette étape réalisée, les changements sur la base publiée
  sont envoyés à la base abonnée en temps réel. La base abonnée applique les
  modifications dans le même ordre qu'elles auront été réalisées de façon à ce
  que la cohérence transactionnelle soit garantie pour les publications d'un
  seul abonnement. Cette méthode de réplication porte parfois le nom de
  réplication transactionnelle.
 </para>

 <para>
  Les cas typiques d'utilisation de la réplication logique peuvent être les
  suivants&nbsp;:

  <itemizedlist>
   <listitem>
    <para>
     Envoyer immédiatement les changements réalisés sur une base de données, ou
     sur un sous-ensemble de ces données, de façon incrémentale à une base de
     données abonnée;
    </para>
   </listitem>

   <listitem>
    <para>
     Déclencher des triggers pour des changements spécifiques lorsqu'ils
     apparaissent sur la base de données abonnée&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Réaliser la consolidation de plusieurs bases de données au sein d'une seule
     (par exemple pour répondre à des problématiques analytiques)&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Répliquer entre des versions majeures différentes de PostgreSQL&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Répliquer des instances PostgreSQL sur des plateformes différentes (par
     exemple de Linux à Windows)&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Donner accès à des données répliquées à différents groupes d'utilisateurs&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Partager un sous-ensemble de données entre plusieurs bases de données.
    </para>
   </listitem>
  </itemizedlist>
 </para>

 <para>
  Une base de données abonnée se comporte comme n'importe quelle autre base de
  données d'une instance PostgreSQL et peut être utilisée comme base de données
  de publication pour d'autres base de données en lui définissant ses propres
  publications. Lorsque la base abonnée est considérée comme une base en
  lecture seule par l'application, il ne va pas y avoir de problèmes de conflits.
  D'un autre côté, s'il y a des écritures provenant soit de l'application soit
  d'un autre abonnement sur le même ensemble de tables, des conflits peuvent
  survenir.
 </para>

 <sect1 id="logical-replication-publication">
  <title>Publication</title>

  <para>
   Une <firstterm>publication</firstterm> peut être définie sur n'importe quel
   serveur primaire de réplication physique. Le nœud sur laquelle la
   publication est définie est nommé <firstterm>publieur</firstterm>. Une
   publication est un ensemble de modifications générées par une table ou un
   groupe de tables et peut aussi être défini comme un ensemble de modifications
   ou un ensemble de réplication. Chaque publication existe au sein d'une seule
   base de données.
  </para>

  <para>
   Les publications sont différenciées du schéma et n'ont pas d'impact sur la
   manière dont la base est accédée. Chaque table peut être ajoutée à
   différentes publications au besoin. Actuellement, les publications ne
   contiennent que les tables et toutes les tables d'un schéma. Les objets
   doivent être ajoutés explicitement, sauf si la publication a été créée pour
   toutes les tables (<literal>ALL TABLES</literal>).
  </para>

  <para>
   Les publications peuvent choisir de limiter les changements qu'elles
   produisent avec n'importe quelle combinaison de <command>INSERT</command>,
   <command>UPDATE</command>, <command>DELETE</command> et
   <command>TRUNCATE</command>, ceci d'une façon similaire à l'activation de
   triggers en fonction d'un certain type d'événement. Par défaut, tous les
   types d'opération sont répliqués. Ces spécifications de publication
   s'appliquent seulement pour les opérations DML&nbsp;; elles n'affectent pas
   la copie initiale de synchronisation des données. (Les filtres de ligne
   n'ont pas d'effet pour la commande <command>TRUNCATE</command>. Voir <xref
   linkend="logical-replication-row-filter"/>.)
  </para>

  <para>
   Une table publiée doit avoir une <quote>identité de réplication</quote>
   configurée pour être capable de répliquer des opérations
   <command>UPDATE</command> et <command>DELETE</command>, pour que les lignes
   appropriées à modifier ou supprimer puissent être identifiées du côté de
   l'abonné. Par défaut, il s'agit de la clé primaire, si elle existe. Un autre
   index d'unicité (avec quelques prérequis supplémentaires) peut aussi être
   configuré du côté de l'abonné. Si la table n'a pas de clé convenable, alors
   elle peut être configurée pour l'identité de réplicat <quote>full</quote>, ce
   qui signifie que la ligne entière devient la clé. Néanmoins, ceci est très
   inefficace et devrait seulement être utilisé si aucune autre solution n'est
   disponible. Si une identité de réplication est différente de
   <quote>full</quote> du côté du publieur, une identité de réplication
   comprenant les mêmes colonnes, ou moins de colonnes, peut aussi être
   configuré du côté de l'abonné. Voir <xref
   linkend="sql-altertable-replica-identity"/> pour les détails sur la
   configuration de l'identité de réplication. Si une table sans identité de
   réplication est ajoutée à une publication qui réplique les opérations
   <command>UPDATE</command> ou <command>DELETE</command>, alors les opérations
   <command>UPDATE</command> ou <command>DELETE</command> suivantes causeront une
   erreur sur le publieur. Les opérations <command>INSERT</command> peuvent se
   réaliser quelle que soit l'identité de réplication.
  </para>

  <para>
   Chaque publication peut avoir plusieurs abonnés.
  </para>

  <para>
   Une publication est créée en utilisant la commande <link
   linkend="sql-createpublication"><command>CREATE PUBLICATION</command></link>
   et peut ensuite être modifiée ou supprimée en utilisant la commande
   correspondante.
  </para>

  <para>
   Les tables individuelles peuvent être ajoutées ou supprimées dynamiquement en
   utilisant <link linkend="sql-alterpublication"><command>ALTER
   PUBLICATION</command></link>. Les opérations <literal>ADD TABLE</literal> et
   <literal>DROP TABLE</literal> sont toutes les deux transactionnelles&nbsp;;
   de ce fait, une table va commencer ou arrêter de répliquer dans le bon
   instantané seulement une fois que la transaction a été validée.
  </para>
 </sect1>

 <sect1 id="logical-replication-subscription">
  <title>Abonnement</title>

  <para>
   Un <firstterm>abonnement</firstterm> est le côté aval de la réplication
   logique. Le nœud où un abonnement a été défini est nommé
   <firstterm>abonné</firstterm>. Un abonnement définit la connexion à une
   autre base de données et un ensemble de publications (une ou plus) auxquelles
   l'abonné veut souscrire.
  </para>

  <para>
   La base de données abonnée se comporte comme n'importe quelle base de données
   d'une instance PostgreSQL et peut être utilisée comme éditeur pour d'autres
   bases de données en définissant ses propres publications.
  </para>

  <para>
   Un nœud abonné peut avoir plusieurs abonnements si besoin. Il est possible de
   définir plusieurs abonnements entre une même paire publieur - abonné. Dans ce
   cas, il faut faire attention à ce que les objets des publications auxquelles
   l'abonné a souscrit ne se chevauchent pas.
  </para>

  <para>
   Chaque abonnement recevra les changements par un slot de réplication (voir
   <xref linkend="streaming-replication-slots"/>). Des slots de réplications
   supplémentaires peuvent être nécessaires pour la synchronisation initiale des
   données d'une table contenant des données pré-existantes mais ils seront
   supprimés à la fin de la synchronisation des données.
  </para>

  <para>
   Un abonnement de réplication logique peut être réalisé sur un serveur
   secondaire pour de la réplication synchrone (voir <xref
   linkend="synchronous-replication"/>). Le nom du serveur secondaire
   correspond par défaut au nom de l'abonnement. Un nom alternatif peut être
   indiqué avec le paramètre <literal>application_name</literal> dans les
   informations de connexion à l'abonnement.
  </para>

  <para>
   Les abonnements sont sauvegardés par <command>pg_dump</command> si
   l'utilisateur courant a des droits de superutilisateur. Si ce n'est pas le
   cas, un message d'avertissement est renvoyé et les abonnements ne sont pas
   sauvegardés. En effet, les informations d'abonnements contenues dans
   <structname>pg_subscription</structname> ne sont pas consultables par des
   utilisateurs dotés de droits moins importants.
  </para>

  <para>
   Un abonnement est ajouté en utilisant <link
   linkend="sql-createsubscription"><command>CREATE
   SUBSCRIPTION</command></link>. Il peut être arrêté/repris à n'importe quel
   moment en utilisant la commande <link
   linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION</command></link>,
   et il peut être supprimé par la commande <link
   linkend="sql-dropsubscription"><command>DROP SUBSCRIPTION</command></link>.
  </para>

  <para>
   Quand un abonnement est supprimé puis recréé, les informations de
   synchronisation sont perdues. Cela signifie que les données doivent être
   resynchronisées ensuite.
  </para>

  <para>
   La définition d'un schéma n'est pas répliquée, et les tables publiées doivent
   exister sur la base abonnée. Seules des tables standards peuvent accueillir
   des données répliquées. Par exemple, il n'est pas pas possible de répliquer
   dans une vue.
  </para>

  <para>
   La correspondance entre les tables du publieur et de l'abonné est réalisée en
   utilisant le nom entièrement qualifié de la table. La réplication entre des
   tables portant un nom différent sur la base abonnée n'est pas supportée.
  </para>

  <para>
   La correspondance sur les colonnes d'une table se fait aussi par nom.
   L'ordre des colonnes dans la table sur le serveur abonné ne correspond pas
   forcément à l'ordre sur le serveur publieur. Les types de données n'ont pas
   non plus besoin de correspondre, à partir du moment où la représentation
   textuelle de la donnée peut être convertie vers le type de données cible.
   Par exemple, vous pouvez répliquer depuis une colonne de type <type>integer</type>
   vers une colonne de type <type>bigint</type>. La table cible peut aussi avoir
   des colonnes supplémentaires non fournies par la table publiée. Ce type de
   colonne sera rempli avec la valeur par défaut fournie dans la définition de
   la table cible.
  </para>

  <sect2 id="logical-replication-subscription-slot">
   <title>Gestion des slots de réplication</title>

   <para>
    Comme présenté plus tôt, chaque abonnement (actif) reçoit les changements
    depuis un slot de réplication du serveur distant (publication).
   </para>

   <para>
    Des slots de synchronisation de tables supplémentaires sont normalement
    temporaires, créés en interne pour réaliser la synchronisation initiale des
    tables et supprimés automatiquement quand elles ne sont plus nécessaires.
    Ces slots de synchronisation de table ont des noms générés
    automatiquement&nbsp;: <quote><literal>pg_%u_sync_%u_%llu</literal></quote>
    (paramètres <parameter>oid</parameter> de la souscription,
    <parameter>relid</parameter> de la table, <parameter>sysid</parameter> pour
    l'identifiant du système).
   </para>

   <para>
    Normalement, le slot de réplication distant est créé automatiquement en
    utilisant la commande <command>CREATE SUBSCRIPTION</command> et il est
    supprimé automatiquement en utilisant la commande <command>DROP
    SUBSCRIPTION</command>. Dans certaines situations, il peut être utile ou
    nécessaire de manipuler les abonnements ainsi que les slots de réplication
    sous-jacents de façon séparées. Voici quelques exemples&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       Lorsqu'en créant un abonnement, le slot de réplication correspondant
       existe déjà. Dans ce cas, l'abonnement peut être créé en utilisant
       l'option <literal>create_slot = false</literal> pour réaliser
       l'association avec le slot existant&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       Lorsqu'en créant un abonnement, le serveur distant n'est pas disponible
       ou dans un état indéfini. Dans ce cas, l'abonnement peut être créé en
       utilisant l'option <literal>connect = false</literal>. Le serveur
       distant ne sera alors jamais contacté. C'est la méthode utilisée par
       <application>pg_dump</application>. Le slot de réplication distant devra
       alors être créé manuellement avant que l'abonnement ne puisse être
       activé&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       Lorsqu'on supprime un abonnement et que le slot de réplication doit être
       conservé, par exemple lorsqu'une base abonnée est déplacée vers un
       serveur différent et sera activée depuis cette nouvelle localisation.
       Dans ce cas, il faut dissocier le slot de réplication de l'abonnement
       correspondant en utilisant la commande <command>ALTER
       SUBSCRIPTION</command> avant de supprimer l'abonnement&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       Lorsque l'on supprime un abonnement et que le serveur distant n'est pas
       joignable. Dans ce cas, il faut aussi dissocier le slot de réplication de
       l'abonnement correspondant en utilisant <command>ALTER
       SUBSCRIPTION</command> avant de supprimer l'abonnement. Si l'instance
       distante n'existe plus, aucune action supplémentaire n'est nécessaire.
       Si, par contre, l'instance distante est simplement temporairement
       injoignable, le slot de réplication (et tout slot de synchronisation de
       table restant) devrait être supprimé manuellement, sinon l'instance va
       persévérer à conserver ses fichiers WAL jusqu'à saturation de l'espace
       disque disponible. Ces cas doivent être traités avec beaucoup de
       précautions.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>

  <sect2 id="logical-replication-subscription-examples">
    <title>Exemples</title>

    <para>
     Créer des tables tests sur le publieur.
<programlisting>
test_pub=# CREATE TABLE t1(a int, b text, PRIMARY KEY(a));
CREATE TABLE
test_pub=# CREATE TABLE t2(c int, d text, PRIMARY KEY(c));
CREATE TABLE
test_pub=# CREATE TABLE t3(e int, f text, PRIMARY KEY(e));
CREATE TABLE
</programlisting></para>

    <para>
     Créer les mêmes tables sur l'abonné.
<programlisting>
test_sub=# CREATE TABLE t1(a int, b text, PRIMARY KEY(a));
CREATE TABLE
test_sub=# CREATE TABLE t2(c int, d text, PRIMARY KEY(c));
CREATE TABLE
test_sub=# CREATE TABLE t3(e int, f text, PRIMARY KEY(e));
CREATE TABLE
</programlisting></para>

    <para>
     Insérer des données sur les tables du côté publieur.
<programlisting>
test_pub=# INSERT INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'three');
INSERT 0 3
test_pub=# INSERT INTO t2 VALUES (1, 'A'), (2, 'B'), (3, 'C');
INSERT 0 3
test_pub=# INSERT INTO t3 VALUES (1, 'i'), (2, 'ii'), (3, 'iii');
INSERT 0 3
</programlisting></para>

    <para>
     Créer les publications pour les tables. Les publications
     <literal>pub2</literal> et <literal>pub3a</literal> interdisent certaines
     opérations <literal>publish</literal>. La publication
     <literal>pub3b</literal> a un filtre de lignes (voir <xref
     linkend="logical-replication-row-filter"/>).
<programlisting>
test_pub=# CREATE PUBLICATION pub1 FOR TABLE t1;
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION pub2 FOR TABLE t2 WITH (publish = 'truncate');
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION pub3a FOR TABLE t3 WITH (publish = 'truncate');
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION pub3b FOR TABLE t3 WHERE (e > 5);
CREATE PUBLICATION
</programlisting></para>

    <para>
     Créer les abonnements (souscriptions) pour les publications. La
     souscription <literal>sub3</literal> s'abonne à <literal>pub3a</literal> et
     <literal>pub3b</literal>. Toutes les souscriptions copieront les données
     initiales par défaut.
<programlisting>
test_sub=# CREATE SUBSCRIPTION sub1
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=sub1'
test_sub-# PUBLICATION pub1;
CREATE SUBSCRIPTION
test_sub=# CREATE SUBSCRIPTION sub2
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=sub2'
test_sub-# PUBLICATION pub2;
CREATE SUBSCRIPTION
test_sub=# CREATE SUBSCRIPTION sub3
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=sub3'
test_sub-# PUBLICATION pub3a, pub3b;
CREATE SUBSCRIPTION
</programlisting></para>

    <para>
     Observez que les données initiales des tables sont copiées, quelque soit
     l'opération <literal>publish</literal> de la publication.
<programlisting>
test_sub=# SELECT * FROM t1;
 a |   b
---+-------
 1 | one
 2 | two
 3 | three
(3 rows)

test_sub=# SELECT * FROM t2;
 c | d
---+---
 1 | A
 2 | B
 3 | C
(3 rows)
</programlisting></para>

    <para>
     De plus, comme la copie initiale de données ignore l'opération
     <literal>publish</literal> et comme la publication <literal>pub3a</literal>
     n'a pas de filtre de lignes, cela signifie que la table
     <literal>t3</literal> copiée contient toutes les lignes même quand elles ne
     correspondent pas au filtre de lignes de la publication
     <literal>pub3b</literal>.
<programlisting>
test_sub=# SELECT * FROM t3;
 e |  f
---+-----
 1 | i
 2 | ii
 3 | iii
(3 rows)
</programlisting></para>

   <para>
    Insérer plus de données dans les tables du côté publieur.
<programlisting>
test_pub=# INSERT INTO t1 VALUES (4, 'four'), (5, 'five'), (6, 'six');
INSERT 0 3
test_pub=# INSERT INTO t2 VALUES (4, 'D'), (5, 'E'), (6, 'F');
INSERT 0 3
test_pub=# INSERT INTO t3 VALUES (4, 'iv'), (5, 'v'), (6, 'vi');
INSERT 0 3
</programlisting></para>

   <para>
    Maintenant, les données du côté publieur ressemblent à ceci&nbsp;:
<programlisting>
test_pub=# SELECT * FROM t1;
 a |   b
---+-------
 1 | one
 2 | two
 3 | three
 4 | four
 5 | five
 6 | six
(6 rows)

test_pub=# SELECT * FROM t2;
 c | d
---+---
 1 | A
 2 | B
 3 | C
 4 | D
 5 | E
 6 | F
(6 rows)

test_pub=# SELECT * FROM t3;
 e |  f
---+-----
 1 | i
 2 | ii
 3 | iii
 4 | iv
 5 | v
 6 | vi
(6 rows)
</programlisting></para>

   <para>
    Observez que, durant la réplication normale, les opérations
    <literal>publish</literal> appropriées sont utilisées. Cela signifie que les
    publications <literal>pub2</literal> et <literal>pub3a</literal> ne
    répliquent pas les opérations <literal>INSERT</literal>. De plus, la
    publication <literal>pub3b</literal> répliquera seulement les données
    correspondant au filtre de lignes de <literal>pub3b</literal>. Maintenant,
    les données du côté abonné ressemblent à ceci&nbsp;:
<programlisting>
test_sub=# SELECT * FROM t1;
 a |   b
---+-------
 1 | one
 2 | two
 3 | three
 4 | four
 5 | five
 6 | six
(6 rows)

test_sub=# SELECT * FROM t2;
 c | d
---+---
 1 | A
 2 | B
 3 | C
(3 rows)

test_sub=# SELECT * FROM t3;
 e |  f
---+-----
 1 | i
 2 | ii
 3 | iii
 6 | vi
(4 rows)
</programlisting></para>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-row-filter">
  <title>Filtres de lignes</title>

  <para>
   Par défaut, toutes les données de toutes les tables publiées seront
   répliquées aux abonnés appropriés. Les données répliquées peuvent être
   réduites en utilisant un <firstterm>filtre de lignes</firstterm>. Un
   utilisateur pourrait choisir d'utiliser des filtres de lignes pour des
   raisons de comportement, de sécurité ou de performance. Si une table publiée
   configure un filtre de lignes, une ligne est répliquée seulement si ses
   données satisfont l'expression du filtre de lignes. Cela permet à un ensemble
   de tables d'être répliquées partiellement. Le filtre de lignes est défini par
   table. Utilisez une clause <literal>WHERE</literal> après le nom de la table
   pour chaque table publiée dont les données doivent être filtrées. La clause
   <literal>WHERE</literal> doit être entourée de parenthèses. Voir <xref
   linkend="sql-createpublication"/> pour les détails.
  </para>

  <sect2 id="logical-replication-row-filter-rules">
   <title>Règles des filtres de lignes</title>

   <para>
    Les filtres de lignes sont appliqués <emphasis>avant</emphasis> de publier
    les changements. Si le filtre de ligne est évalué à <literal>false</literal>
    ou <literal>NULL</literal>, alors la ligne n'est pas répliquée. L'expression
    de la clause <literal>WHERE</literal> est évaluée avec le même rôle utilisé
    pour la connexion de réplication (soit le rôle indiqué dans la clause
    <literal>CONNECTION</literal> de l'instruction <xref
    linkend="sql-createsubscription"/>). Les filtres de ligne n'ont pas deffet
    sur la commande <command>TRUNCATE</command>.
   </para>
  </sect2>

  <sect2 id="logical-replication-row-filter-restrictions">
   <title>Restrictions de l'expression</title>

   <para>
    La clause <literal>WHERE</literal> autorise uniquement des expressions simples.
    Elle ne peut pas contenir de fonctions, opérateurs, types et collations
    définis par les utilisateurs, des références aux colonnes système ou à des
    fonctions internes non immutables.
   </para>

   <para>
    Si une publication publie des opérations <command>UPDATE</command> ou
    <command>DELETE</command>, la clause <literal>WHERE</literal> du filtre de
    lignes doit contenir uniquement les colonnes couvertes par l'identité de
    réplicat (voir <xref linkend="sql-altertable-replica-identity"/>). Si une
    publication publie uniquement des opérations <command>INSERT</command>, la
    clause <literal>WHERE</literal> du filtre de ligne peut utiliser toute
    colonne.
   </para>
  </sect2>

  <sect2 id="logical-replication-row-filter-transformations">
   <title>Transformations d'un UPDATE</title>

   <para>
    À chaque fois qu'un <command>UPDATE</command> est traité, l'expression du
    filtre de lignes est évaluée pour l'ancienne et la nouvelle ligne (autrement
    dit, en utilisant les données avant et après la mise à jour). Si les deux
    évaluations valent <literal>true</literal>, les modifications de
    l'<command>UPDATE</command> sont répliquées. Si les deux évaluations valent
    <literal>false</literal>, les modifications ne sont pas répliquées. Si
    seulement une des deux évaluations vaut true, la commande
    <command>UPDATE</command> est transformée en <command>INSERT</command> ou
    <command>DELETE</command>, pour éviter toute incohérence de données. La
    ligne sur l'abonné doit refléter ce qui est défini par l'expression de
    filtre de lignes sur le publieur.
   </para>

   <para>
    Si l'ancienne ligne satisfait l'expression du filtre de lignes (elle a été
    envoyée sur l'abonné) contrairement à la nouvelle ligne, alors, d'un point
    de vue de la cohérence des données, l'ancienne ligne devrait être supprimée
    de l'abonné. Donc la commande <command>UPDATE</command> est transformée en
    commande <command>DELETE</command>.
   </para>

   <para>
    Si l'ancienne ligne ne satisfait pas l'expression du filtre de lignes (elle
    n'a pas été envoyée sur l'abonné) contrairement à la nouvelle ligne, alors,
    d'un point de vue de la cohérence des données, la nouvelle ligne doit être
    ajoutée à l'abonné. Donc la commande <command>UPDATE</command> est
    transformée en commande <command>INSERT</command>.
   </para>

   <para>
    <xref linkend="logical-replication-row-filter-transformations-summary"/>
    résume les transformations appliquées.
   </para>

   <table id="logical-replication-row-filter-transformations-summary">
    <title>Résumé des transformations d'un <command>UPDATE</command></title>
    <tgroup cols="3">
    <thead>
     <row>
      <entry>Ancienne ligne</entry>
      <entry>Nouvelle ligne</entry>
      <entry>Transformation</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>pas de correspondance</entry>
      <entry>pas de correspondance</entry>
      <entry>ne réplique pas</entry>
     </row>
     <row>
      <entry>pas de correspondance</entry>
      <entry>correspondance</entry>
      <entry><literal>INSERT</literal></entry>
     </row>
     <row>
      <entry>correspondance</entry>
      <entry>pas de correspondance</entry>
      <entry><literal>DELETE</literal></entry>
     </row>
     <row>
      <entry>correspondance</entry>
      <entry>correspondance</entry>
      <entry><literal>UPDATE</literal></entry>
     </row>
    </tbody>
   </tgroup>
   </table>

  </sect2>

  <sect2 id="logical-replication-row-filter-partitioned-table">
   <title>Tables partitionnées</title>

   <para>
    Si la publication contient une table partitionnée, le paramètre de
    publication <literal>publish_via_partition_root</literal> détermine le
    filtre de lignes à utiliser. Si
    <literal>publish_via_partition_root</literal> vaut <literal>true</literal>,
    le filtre de ligne de la <emphasis>table partitionnée racine</emphasis> est
    utilisé. Si <literal>publish_via_partition_root</literal> vaut
    <literal>false</literal> (ce qui est le cas par défaut), le filtre de lignes
    de chaque <emphasis>partition</emphasis> est utilisé.
   </para>

  </sect2>

  <sect2 id="logical-replication-row-filter-initial-data-sync">
   <title>Synchronisation initiale des données</title>

   <para>
    Si la souscription requiert une copie des données pré-existantes de la table
    et qu'une publication contient des clauses <literal>WHERE</literal>, seules
    les données qui satisfont les expressions des filtres de ligne sont copiées
    sur l'abonné.
   </para>

   <para>
    Si la souscription a plusieurs publications dans lesquelles une table a été
    publiée avec différentes clauses <literal>WHERE</literal>, les lignes qui
    satisfont <emphasis>une</emphasis> des expressions seront copiées. Voir
    <xref linkend="logical-replication-row-filter-combining"/> pour les détails.
   </para>

   <warning>
    <para>
     Comme la synchronisation initiale des données ne prend pas en compte le
     paramètre <literal>publish</literal> lors de la copie des données
     pré-existantes de la table, certaines lignes pourraient être copiées alors
     qu'elles n'auraient pas été répliquées avec des instructions DML.
     Référez-vous à <xref linkend="logical-replication-snapshot"/>, et à
     <xref linkend="logical-replication-subscription-examples"/> pour des
     exemples.
    </para>
   </warning>

   <note>
    <para>
     Si l'abonné est d'une version antérieure à la 15, la copie des données
     pré-existantes n'utilise pas les filtres de ligne même s'ils sont définis
     dans la publication. Ceci est dû au fait que les anciennes versions peuvent
     seulement copier les données de la table entière.
    </para>
   </note>

  </sect2>

  <sect2 id="logical-replication-row-filter-combining">
   <title>Combiner plusieurs filtres de lignes</title>

   <para>
    Si la souscription a plusieurs publications pour lesquelles la même table a
    été publiée avec des filtres de lignes différents (pour la même opération
    <literal>publish</literal>, ces expressions sont assemblées avec un OU
    logique, pour que les lignes satisfaisant au moins <emphasis>une</emphasis>
    expression seront répliquées. Cela signifie que les autres filtres de lignes
    pour la même table deviennent redondants si&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       Une des publications n'a pas de filtres de lignes&nbsp;;
      </para>
     </listitem>
     <listitem>
      <para>
       Une des publications a été créée en utilisant <literal>FOR ALL
       TABLES</literal>. Cette clause n'autorise pas les filtres de lignes&nbsp;;
      </para>
     </listitem>
     <listitem>
      <para>
       Une des publications a été créée en utilisant <literal>FOR ALL TABLES IN
       SCHEMA</literal> et la table appartient au schéma référencé. Cette clause
       n'autorise pas les filtres de lignes.
      </para>
     </listitem>
    </itemizedlist></para>
  </sect2>

  <sect2 id="logical-replication-row-filter-examples">
   <title>Exemples</title>

   <para>
    Créer quelques tables à utiliser dans les exemples suivants.
<programlisting>
test_pub=# CREATE TABLE t1(a int, b int, c text, PRIMARY KEY(a,c));
CREATE TABLE
test_pub=# CREATE TABLE t2(d int, e int, f int, PRIMARY KEY(d));
CREATE TABLE
test_pub=# CREATE TABLE t3(g int, h int, i int, PRIMARY KEY(g));
CREATE TABLE
</programlisting></para>

   <para>
    Créer quelques publications. La publication <literal>p1</literal> a une
    table (<literal>t1</literal>) et cette table a un filtre de lignes. La
    publication <literal>p2</literal> a deux tables. La table
    <literal>t1</literal> n'a pas de filtre de lignes, et la table
    <literal>t2</literal> a un filtre de lignes. La publication
    <literal>p3</literal> a deux tables, qui ont toutes les deux un filtre de
    lignes.
<programlisting>
test_pub=# CREATE PUBLICATION p1 FOR TABLE t1 WHERE (a > 5 AND c = 'NSW');
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION p2 FOR TABLE t1, t2 WHERE (e = 99);
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION p3 FOR TABLE t2 WHERE (d = 10), t3 WHERE (g = 10);
CREATE PUBLICATION
</programlisting></para>

   <para>
    <command>psql</command> peut être utilisé pour afficher les expressions
    de filtres de lignes (si défini) pour chaque publication.
<programlisting>
test_pub=# \dRp+
                               Publication p1
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t1" WHERE ((a > 5) AND (c = 'NSW'::text))

                               Publication p2
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t1"
    "public.t2" WHERE (e = 99)

                               Publication p3
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t2" WHERE (d = 10)
    "public.t3" WHERE (g = 10)
</programlisting></para>

   <para>
    <command>psql</command> peut être utilisé pour afficher les expressions des
    filtres de lignes (si défini) pour chaque table. La table
    <literal>t1</literal> est membre de deux publications, mais a un filtre de
    lignes uniquement dans <literal>p1</literal>. La table
    <literal>t2</literal> est membre de deux publications, et a un filtre de
    lignes différent sur chacune.
<programlisting>
test_pub=# \d t1
                 Table "public.t1"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 a      | integer |           | not null |
 b      | integer |           |          |
 c      | text    |           | not null |
Indexes:
    "t1_pkey" PRIMARY KEY, btree (a, c)
Publications:
    "p1" WHERE ((a > 5) AND (c = 'NSW'::text))
    "p2"

test_pub=# \d t2
                 Table "public.t2"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 d      | integer |           | not null |
 e      | integer |           |          |
 f      | integer |           |          |
Indexes:
    "t2_pkey" PRIMARY KEY, btree (d)
Publications:
    "p2" WHERE (e = 99)
    "p3" WHERE (d = 10)

test_pub=# \d t3
                 Table "public.t3"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 g      | integer |           | not null |
 h      | integer |           |          |
 i      | integer |           |          |
Indexes:
    "t3_pkey" PRIMARY KEY, btree (g)
Publications:
    "p3" WHERE (g = 10)
</programlisting></para>

   <para>
    Sur le nœud abonné, créer une table <literal>t1</literal> avec la même
    définition que celle du publieur, et créer aussi la souscription
    <literal>s1</literal> vers la publication <literal>p1</literal>.
<programlisting>
test_sub=# CREATE TABLE t1(a int, b int, c text, PRIMARY KEY(a,c));
CREATE TABLE
test_sub=# CREATE SUBSCRIPTION s1
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=s1'
test_sub-# PUBLICATION p1;
CREATE SUBSCRIPTION
</programlisting></para>

   <para>
    Insérer quelques lignes. Seules les lignes satisfaisant la clause
    <literal>t1 WHERE</literal> de la publication <literal>p1</literal> sont
    répliquées.
<programlisting>
test_pub=# INSERT INTO t1 VALUES (2, 102, 'NSW');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (3, 103, 'QLD');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (4, 104, 'VIC');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (5, 105, 'ACT');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (6, 106, 'NSW');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (7, 107, 'NT');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (8, 108, 'QLD');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (9, 109, 'NSW');
INSERT 0 1

test_pub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 2 | 102 | NSW
 3 | 103 | QLD
 4 | 104 | VIC
 5 | 105 | ACT
 6 | 106 | NSW
 7 | 107 | NT
 8 | 108 | QLD
 9 | 109 | NSW
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 6 | 106 | NSW
 9 | 109 | NSW
(2 rows)
</programlisting></para>

   <para>
    Mettre à jour quelques données, où les valeurs de l'ancienne et de la
    nouvelle ligne satisfont la clause <literal>t1 WHERE</literal> de la
    publication <literal>p1</literal>. La commande <command>UPDATE</command>
    réplique les changements de façon normale.
<programlisting>
test_pub=# UPDATE t1 SET b = 999 WHERE a = 6;
UPDATE 1

test_pub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 2 | 102 | NSW
 3 | 103 | QLD
 4 | 104 | VIC
 5 | 105 | ACT
 7 | 107 | NT
 8 | 108 | QLD
 9 | 109 | NSW
 6 | 999 | NSW
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 9 | 109 | NSW
 6 | 999 | NSW
(2 rows)
</programlisting></para>

   <para>
    Mettre à jour des données de façon à ce que les valeurs de l'ancienne ligne
    ne satisfont pas la clause <literal>t1 WHERE</literal> de la publication
    <literal>p1</literal>, mais que les valeurs de la nouvelle ligne la
    satisfont. La commande <command>UPDATE</command> est transformée en une
    commande <command>INSERT</command> et les changements sont répliqués. Voir
    la nouvelle ligne sur l'abonné.
<programlisting>
test_pub=# UPDATE t1 SET a = 555 WHERE a = 2;
UPDATE 1

test_pub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   3 | 103 | QLD
   4 | 104 | VIC
   5 | 105 | ACT
   7 | 107 | NT
   8 | 108 | QLD
   9 | 109 | NSW
   6 | 999 | NSW
 555 | 102 | NSW
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   9 | 109 | NSW
   6 | 999 | NSW
 555 | 102 | NSW
(3 rows)
</programlisting></para>

   <para>
    Mettre à jour des données de façon à ce que les valeurs de l'ancienne ligne
    satisfont la clause <literal>t1 WHERE</literal> de la publication
    <literal>p1</literal>, mais que les valeurs de la nouvelle ligne ne la
    satisfont pas. La commande <command>UPDATE</command> est transformée en une
    commande <command>DELETE</command> et les changements sont répliqués. Voir
    la nouvelle ligne supprimée sur l'abonné.
<programlisting>
test_pub=# UPDATE t1 SET c = 'VIC' WHERE a = 9;
UPDATE 1

test_pub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   3 | 103 | QLD
   4 | 104 | VIC
   5 | 105 | ACT
   7 | 107 | NT
   8 | 108 | QLD
   6 | 999 | NSW
 555 | 102 | NSW
   9 | 109 | VIC
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   6 | 999 | NSW
 555 | 102 | NSW
(2 rows)
</programlisting></para>

   <para>
    Les exemples suivants montrent comment le paramètre de publication
    <literal>publish_via_partition_root</literal> détermine si le filtre de
    ligne de la table parent ou enfant sera utilisé dans le cas de tables
    partitionnées.
   </para>

   <para>
    Créer une table partitionnée sur le publieur.
<programlisting>
test_pub=# CREATE TABLE parent(a int PRIMARY KEY) PARTITION BY RANGE(a);
CREATE TABLE
test_pub=# CREATE TABLE child PARTITION OF parent DEFAULT;
CREATE TABLE
</programlisting>
   Créer les mêmes tables sur l'abonné.
<programlisting>
test_sub=# CREATE TABLE parent(a int PRIMARY KEY) PARTITION BY RANGE(a);
CREATE TABLE
test_sub=# CREATE TABLE child PARTITION OF parent DEFAULT;
CREATE TABLE
</programlisting></para>

   <para>
    Créer une publication <literal>p4</literal>, puis abonnez-vous à cette
    publication. Le paramètre de publication
    <literal>publish_via_partition_root</literal> est configuré à true. Il
    existe des filtres de lignes définis sur la table partitionnée
    (<literal>parent</literal>), et sur sa partition (<literal>child</literal>).
<programlisting>
test_pub=# CREATE PUBLICATION p4 FOR TABLE parent WHERE (a &lt; 5), child WHERE (a >= 5)
test_pub-# WITH (publish_via_partition_root=true);
CREATE PUBLICATION
</programlisting>
<programlisting>
test_sub=# CREATE SUBSCRIPTION s4
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=s4'
test_sub-# PUBLICATION p4;
CREATE SUBSCRIPTION
</programlisting></para>

   <para>
    Insérer quelques valeurs directement dans les tables
    <literal>parent</literal> et <literal>child</literal>. Elles se répliquent
    en utilisant le filtre de lignes de <literal>parent</literal> (parce que
    <literal>publish_via_partition_root</literal> vaut true).
<programlisting>
test_pub=# INSERT INTO parent VALUES (2), (4), (6);
INSERT 0 3
test_pub=# INSERT INTO child VALUES (3), (5), (7);
INSERT 0 3

test_pub=# SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
 5
 6
 7
(6 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
(3 rows)
</programlisting></para>

   <para>
    Répéter le même test, mais avec une valeur différent pour
    <literal>publish_via_partition_root</literal>. Le paramètre de publication
    <literal>publish_via_partition_root</literal> est configuré à false. Un
    filtre de lignes est défini sur la partition (<literal>child</literal>).
<programlisting>
test_pub=# DROP PUBLICATION p4;
DROP PUBLICATION
test_pub=# CREATE PUBLICATION p4 FOR TABLE parent, child WHERE (a >= 5)
test_pub-# WITH (publish_via_partition_root=false);
CREATE PUBLICATION
</programlisting>
<programlisting>
test_sub=# ALTER SUBSCRIPTION s4 REFRESH PUBLICATION;
ALTER SUBSCRIPTION
</programlisting></para>

   <para>
    Faire les insertions sur le publieur de la même façon qu'avant. Elles se
    répliquent en utilisant le filtre de lignes de <literal>child</literal>
    (parce que <literal>publish_via_partition_root</literal> vaut false).
<programlisting>
test_pub=# TRUNCATE parent;
TRUNCATE TABLE
test_pub=# INSERT INTO parent VALUES (2), (4), (6);
INSERT 0 3
test_pub=# INSERT INTO child VALUES (3), (5), (7);
INSERT 0 3

test_pub=# SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
 5
 6
 7
(6 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM child ORDER BY a;
 a
---
 5
 6
 7
(3 rows)
</programlisting></para>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-conflicts">
  <title>Conflits</title>

  <para>
   La réplication logique se comporte de la même manière pour les opérations DML
   dans le sens où les données seront mises à jour même si la modification a été
   faite en local sur la base abonnée. Si les données entrantes entrainent des
   violations de contrainte d'intégrité, la réplication s'arrête. Cela sera
   référencé comme un <firstterm>conflit</firstterm>. Lorsque l'on réplique des
   opérations <command>UPDATE</command> ou <command>DELETE</command>, les
   données manquantes ne produiront pas de conflit et des opérations de la sorte
   seront simplement évitées.
  </para>

  <para>
   Les opérations de réplication logique sont réalisées avec les droits du
   propriétaire de la souscription. Les échecs de droit sur les tables cibles
   causeront des conflits de réplication, tout autant que l'activation de <link
   linkend="ddl-rowsecurity">politiques de sécurité au niveau ligne</link> sur
   des tables cibles et pour lesquels le propriétaire de la souscription est
   sujet des politiques de sécurité, sans chercher si une politique rejetterait
   habituellement les opérations <command>INSERT</command>,
   <command>UPDATE</command>, <command>DELETE</command> ou
   <command>TRUNCATE</command> en cours de réplication. Cette restriction sur
   les politiques de sécurité niveau ligne pourrait être supprimée dans une
   prochaine version de <productname>PostgreSQL</productname>.
  </para>

  <para>
   Lorsqu'un conflit entraine une erreur, cela stoppe la réplication&nbsp;; Le
   conflit devra être résolu manuellement par un utilisateur. Des informations
   détaillées concernant le conflit seront disponibles dans les journaux
   applicatifs de l'instance abonnée.
  </para>

  <para>
   La résolution peut être réalisée, soit en changeant les données ou les droits
   sur la base abonnée pour qu'elles ne soient plus en conflit avec les données
   entrantes ou en évitant les transactions qui sont en conflit avec les données
   existantes. Quand un conflit produit une erreur, la réplication ne peut pas
   continuer et le processus worker de la réplication logique émet un message du
   type suivant dans les journaux applicatifs de l'abonné&nbsp;:
<screen>
ERROR:  duplicate key value violates unique constraint "test_pkey"
DETAIL:  Key (c)=(1) already exists.
CONTEXT:  processing remote data for replication origin "pg_16395" during "INSERT" for replication target relation "public.test" in transaction 725 finished at 0/14C0378
</screen>
   Le LSN de la transaction qui contient le changement violant la contrainte et
   le nom d'origine de réplication peuvent être trouvés à partir du journal
   applicatif du serveur (LSN 0/14C0378 et origine de réplication
   <literal>pg_16395</literal> dans le cas ci-dessus). La transaction qui a
   produit le conflit peut être ignorée en utilisant l'instruction
   <command>ALTER SUBSCRIPTION ... SKIP</command> avec le LSN final (LSN
   0/14C0378). Le LSN final pourrait être un LSN sur lequel la transaction est
   validée ou préparée sur le publieur. La transaction peut aussi être ignorée
   en appelant la fonction <link
   linkend="pg-replication-origin-advance"><function>pg_replication_origin_advance()</function></link>.
   Avant d'utiliser cette fonction, la souscription doit être désactivée
   temporairement soit par <command>ALTER SUBSCRIPTION ... DISABLE</command>
   soit en utilisant l'option <literal>disable_on_error</literal> de la
   souscription. Ensuite, vous pouvez utiliser la fonction
   <function>pg_replication_origin_advance()</function> avec
   <parameter>node_name</parameter> (<literal>pg_16395</literal>) et le LSN
   suivant du LSN final (0/14C0379). La position actuelle des origines peut être
   trouvée dans la vue système <link
   linkend="view-pg-replication-origin-status"><structname>pg_replication_origin_status</structname></link>.
   Merci de noter qu'ignorer la transaction complète inclut d'ignorer des
   changements qui pourraient ne pas violer des contraintes. Ceci peut rendre
   l'abonné incohérent très facilement.
  </para>
 </sect1>

 <sect1 id="logical-replication-restrictions">
  <title>Restrictions</title>

  <para>
   La réplication logique souffre actuellement des restrictions ou des
   fonctionnalités manquantes suivantes. Elles pourraient être adressées dans
   les prochaines versions.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     La structure de la base de données et les commandes DDL ne sont pas
     répliquées. Le schéma initial peut être copié à la main en utilisant la
     commande <literal>pg_dump --schema-only</literal>. Les modifications de
     schéma suivantes auront besoin d'être synchronisées manuellement. (Notez,
     néanmoins, qu'il n'est pas nécessaire que les schémas soient strictement
     identiques des deux côtés.) La réplication logique est robuste quand il y a
     des modifications de schéma dans une base de données. Quand le schéma est
     changé sur le publieur et les données répliquées commencent à arriver sur
     l'abonné mais ne correspondent pas à la structure de la table, la
     réplication renverra une erreur jusqu'à ce que le schéma soit mis à jour.
     Dans de nombreux cas, les erreurs intermittentes peuvent être évitées en
     appliquant des modifications de schéma à l'abonné en premier&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Les données des séquences ne sont pas répliquées. Les données des colonnes
     de type serial et des colonnes identité, gérées par des séquences, seront
     bien sûr répliquées comme faisant partie de la table, mais la séquence
     elle-même affichera toujours la valeur de démarrage sur l'abonné. Si
     l'abonné est utilisé comme une base de données en lecture seule, alors cela
     ne devrait pas être un problème. Néanmoins, s'il est nécessaire de faire un
     bascule (<foreignphrase>switchover</foreignphrase> ou
     <foreignphrase>failover</foreignphrase> sur la base de données abonnée,
     alors les séquences auront besoin d'être mises à jour à leur dernières
     valeurs, soit en copiant les données courantes du publieur (peut-être en
     utilisant <command>pg_dump</command>), soit en déterminant une valeur
     suffisamment haute à partir des données de la table&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     La réplication des commandes <command>TRUNCATE</command> est supportée mais
     il est nécessaire de prêter attention lors de l'utilisation de cette
     commande sur des groupes de tables connectés par des clés étrangères. Lors
     de la réplication d'une action truncate, l'abonné tronquera le même groupe
     de tables tronquées sur le publieur, qu'elles soient spécifiées
     explicitement ou implicitement (grâce à la clause
     <literal>CASCADE</literal>), moins les tables qui ne font pas partie de la
     souscription. Ceci fonctionnera correctement si toutes les tables affectées
     font partie de la même souscription. Cependant, si certaines tables à
     tronquer ont des clés étrangères vers des tables qui ne font pas partie de
     la même souscription, alors l'application de l'action truncate échouera sur
     le serveur abonné&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Les Large Objects (voir <xref linkend="largeobjects"/>) ne sont pas
     répliqués. Il n'y a pas de contournement pour ça, en dehors d'enregistrer
     les données dans des tables normales&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     La réplication est seulement supportée par les tables, y compris les tables
     partitionnées. Toute tentative de répliquer d'autres types de relation,
     comme les vues, les vues matérialisées ou les tables externes, résultera en
     une erreur&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Lors de la réplication entre tables partitionnées, la réplication actuelle
     a pour origine, par défaut, les partitions filles sur le publieur, donc les
     partitions sur le publieur doivent exister aussi sur l'abonné en tant que
     tables cibles valides. Elles peuvent être soit des partitions filles
     elles-mêmes, soit de nouveau sous-partitionnées, soit des tables
     indépendantes. Les publications peuvent aussi spécifier les changements à
     répliquer en utilisant l'identité et le schéma de la table racine
     partitionnée au lieu de chaque partition individuelle à l'origine des
     changements (voir <link linkend="sql-createpublication"><command>CREATE
     PUBLICATION</command></link>).
    </para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="logical-replication-architecture">
  <title>Architecture</title>

  <para>
   La réplication logique démarre en copiant un instantané des données sur la
   base de publication. Une fois cette étape réalisée, les modifications sur la
   base de publication sont envoyées à la base de données abonnée au fil de
   l'eau. La base abonnée applique les modifications sur les données dans
   l'ordre dans lequel les validations ont été effectuées sur la base éditeur de
   manière à ce que la cohérence transactionnelle soit respectée pour les
   publications vis à vis de tous les abonnements.
  </para>

  <para>
   La réplication se construit de façon similaire à la réplication physique en
   flux (<foreignphrase>Streaming Replication</foreignphrase>, voir <xref
   linkend="streaming-replication"/>). Ceci est implémenté par les processus
   <quote>walsender</quote> et <quote>apply</quote>. Le processus walsender
   démarre le décodage logique (décrit dans la section <xref
   linkend="protocol-logical-replication"/>) des fichiers WAL et charge le
   plugin de décodage logique standard (pgoutput). Ce plugin transforme les
   changements lus depuis les fichiers WAL vers le protocole de réplication
   logique (voir <xref linkend="protocol-logical-replication"/>) et filtre les
   données en fonction des spécificités des publications. Les données sont
   envoyées au fil de l'eau au processus apply, qui met en relation les données
   vers les tables locales et applique les changements individuels au moment où
   ils sont reçus, dans le bon ordre transactionnel.
  </para>

  <para>
   Le processus apply sur l'instance de la base abonnée fonctionne toujours avec
   le paramètre <varname>session_replication_role</varname> défini à la valeur
   <literal>replica</literal>, qui produit les effets habituels sur les triggers
   et les contraintes.
  </para>

  <para>
   Le processus apply de la réplication logique déclenche actuellement des
   triggers de ligne, et non pas des triggers de requêtes. Néanmoins, la
   synchronisation initiale des tables est implémentée comme une commande
   <command>COPY</command>, ce qui peut déclencher les triggers
   <command>INSERT</command> en mode ligne et requête.
  </para>

  <sect2 id="logical-replication-snapshot">
   <title>Instantané initial</title>

   <para>
    Les données initiales présentes dans des tables abonnées sont photographiées
    et copiées dans une instance parallèle qui utilise un type particulier de
    processus apply. Ce processus va créer son propre slot de réplication et
    copier les données existantes. Dès que la copie est terminée, le contenu de
    la table deviendra visible aux autres processus. Une fois les données
    existantes copiées, le processus passe en mode de synchronisation, qui
    assure que la table est amenée vers un état synchronisé avec le processus
    apply principal, ceci en transférant toutes les modifications survenues
    pendant la copie initiale des données, réalisée avec le système de
    réplication logique standard. Lors de cette phase de synchronisation, les
    changements sont appliqués et validés dans le même ordre que sur le
    publieur. Une fois la synchronisation terminée, le contrôle de la
    réplication de la table est rendu au processus apply principal et la
    réplication continue telle quelle.
   </para>

   <note>
    <para>
     Le paramètre de publication <literal>publish</literal> affecte uniquement
     les opérations DML qui seront répliquées. La synchronisation initiale des
     données ne prend pas ce paramètre en compte lors de la copie des données
     existantes de la table.
    </para>
   </note>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-monitoring">
  <title>Supervision</title>

  <para>
   Puisque la réplication logique est basée sur une architecture similaire à la
   <link linkend="streaming-replication">réplication physique en flux</link>, la
   supervision d'une instance publication est similaire à la supervision d'une
   instance primaire dans la réplication physique (voir <xref
   linkend="streaming-replication-monitoring"/>).
  </para>

  <para>
   Les informations des abonnements sont consultables dans la vue <link
   linkend="monitoring-pg-stat-subscription"><structname>pg_stat_subscription</structname></link>.
   Cette vue contient une ligne pour chaque processus d'abonnement. Un
   abonnement peut avoir zéro ou plusieurs processus abonnés, selon son état.
  </para>

  <para>
   Normalement il y a un seul processus apply démarré pour un abonnement actif.
   Un abonnement désactivé ou une publication effondrée n'aura pas de ligne dans
   cette vue. Si la synchronisation initiale d'une table est en cours, il y
   aura des processus supplémentaires pour les tables en cours de
   synchronisation.
  </para>
 </sect1>

 <sect1 id="logical-replication-security">
  <title>Sécurité</title>

  <para>
   Un utilisateur capable de modifier le schéma des tables côté souscription
   peut exécuter un code arbitraire en tant que le rôle propriétaire de la
   souscription qui modifie ces tables. Limitez le propriétaire et le droit
   <literal>TRIGGER</literal> sur ces tables aux rôles de confiance. Néanmoins,
   si des utilisateurs sans confiance peuvent créer des tables, utilisez
   seulement des publications qui listent explicitement les tables. Autrement
   dit, créez une souscription <literal>FOR ALL TABLES</literal> ou <literal>FOR
   ALL TABLES IN SCHEMA</literal> uniquement quand les superutilisateurs ont
   confiance en tous les utilisateurs autorisés à créer une table non temporaire
   sur le publieur ou sur l'abonné.
  </para>

  <para>
   Le rôle utilisée pour la réplication doit avoir l'attribut
   <literal>REPLICATION</literal> (ou être un superutilisateur). Si le rôle ne
   dispose pas des attributs <literal>SUPERUSER</literal> et
   <literal>BYPASSRLS</literal>, les politiques de sécurité niveau ligne du
   publieur peuvent s'exécuter. Si le rôle n'a pas confiance en tous les
   propriétaires de tables, incluez
   <literal>options=-crow_security=off</literal> dans la chaîne de
   connexion&nbsp;;: si un propriétaire de table ajoute ensuite une politique de
   sécurité de ligne, cette configuration imposera un arrêt de la réplication
   plutôt qu'une exécution de la politique. L'accès de ce rôle à l'instance doit
   avoir été déclaré dans <filename>pg_hba.conf</filename> et ce rôle doit avoir
   l'attribut <literal>LOGIN</literal>.
  </para>

  <para>
   Pour être capable de copier les données originales de la table, le rôle
   utilisé pour la connexion de réplication doit avoir le droit
   <literal>SELECT</literal> sur une table publiée (ou être un
   superutilisateur).
  </para>

  <para>
   Pour créer une publication, l'utilisateur doit avoir le droit
   <literal>CREATE</literal> pour la base de données.
  </para>

  <para>
   Pour ajouter des tables à une publication, l'utilisateur doit être
   propriétaire de ces tables. Pour ajouter toutes les tables d'un schéma dans
   une publication, l'utilisateur doit avoir l'attribut
   <literal>SUPERUSER</literal>. Pour créer une publication qui publie toutes
   les tables ou toutes les tables d'un schéma automatiquement, l'utilisateur
   doit avoir l'attribut <literal>SUPERUSER</literal>.
  </para>

  <para>
   Pour créer un abonnement, l'utilisateur doit avoir les droits de
   superutilisateur.
  </para>

  <para>
   Le processus apply lié à un abonnement tournera sur la base de données locale
   avec les droits d'un propriétaire de l'abonnement.
  </para>

  <para>
   Sur le publieur, les droits sont vérifiés uniquement au démarrage de la
   connexion de réplication et ne sont pas vérifiés de nouveau à chaque fois
   qu'un enregistrement de changement est lu.
  </para>

  <para>
   Sur l'abonné, les droits du propriétaire de la souscription sont vérifiés à
   chaque application d'une transaction. Si un processus worker est en cours de
   traitement pour appliquer une transaction au moment où le propriétaire de la
   souscription est changé dans une transaction concurrente, l'application de la
   transaction en cours continuera sous les droits de l'ancien propriétaire.
  </para>
 </sect1>

 <sect1 id="logical-replication-config">
  <title>Paramètres de configuration</title>

  <para>
   La réplication logique requiert de nombreuses configurations pour
   fonctionner.
  </para>

  <para>
   Du côté de l'éditeur, <varname>wal_level</varname> doit être positionné à
   <literal>logical</literal>, et <varname>max_replication_slots</varname> doit
   être positionné au minimum au nombre d'abonnements que l'on va connecter,
   plus quelques-uns que l'on réservera pour les synchronisations des tables.
   Le paramètre <varname>max_wal_senders</varname> devrait être positionné au
   minimum à la même valeur que <varname>max_replication_slots</varname> en plus
   du nombre de réplicats physiques qui pourraient être connectés au même
   moment.
  </para>

  <para>
   <varname>max_replication_slots</varname> doit aussi être configuré sur
   l'abonné. Il doit être configuré à au moins la valeur du nombre de
   souscriptions qui seront ajoutés par le souscripteur, plus une réserve pour
   la synchronisation des tables.
   <varname>max_logical_replication_workers</varname> doit être configuré à au
   moins la valeur du nombre de souscriptions, plus, là-aussi, une réserve pour
   la synchronisation des tables. En supplément, le paramètre
   <varname>max_worker_processes</varname> peut devoir être ajusté pour
   s'accorder au nombre de processus de réplication,
   (<varname>max_logical_replication_workers</varname> + <literal>1</literal>).
   Notez que certaines extensions et les requêtes parallélisées prennent elles
   aussi des unités de la réserve de <varname>max_worker_processes</varname>.
  </para>
 </sect1>

 <sect1 id="logical-replication-quick-setup">
  <title>Démarrage rapide</title>

  <para>
   En premier, définissez les options de configurations dans le fichier
   <filename>postgresql.conf</filename>&nbsp;:
   <programlisting>wal_level = logical</programlisting>
   La valeur par défaut des autres paramètres est suffisante pour une mise en
   place de base.
  </para>

  <para>
   Le fichier <filename>pg_hba.conf</filename> doit être mis à jour pour
   autoriser la réplication (les valeurs dépendent de la configuration réelle de
   votre réseau et de l'utilisateur dont vous disposerez pour vous
   connecter)&nbsp;:
   <programlisting>host     all     repuser     0.0.0.0/0     md5</programlisting>
  </para>

  <para>
   Ensuite sur la base du publieur&nbsp;:
   <programlisting>
CREATE PUBLICATION mypub FOR TABLE users, departments;
   </programlisting>
  </para>

  <para>
   Et sur la base abonnée&nbsp;:
   <programlisting>
CREATE SUBSCRIPTION mysub CONNECTION 'dbname=foo host=bar user=repuser' PUBLICATION mypub;
   </programlisting>
  </para>

  <para>
   Les instructions précédentes vont démarrer le processus de réplication, qui
   va réaliser la synchronisation initiale du contenu des tables
   <literal>users</literal> et <literal>departments</literal> et qui commencera
   ensuite à répliquer les changements de manière incrémentale sur ces tables.
  </para>
 </sect1>
</chapter>
