<?xml version="1.0" encoding="UTF-8"?>
<!-- doc/src/sgml/logical-replication.sgml -->

<chapter id="logical-replication">
 <title>Réplication logique</title>

 <para>
  La réplication logique est une méthode permettant de répliquer des
  données au niveau objet ainsi que les modifications apportées à ces
  objets, ceci basé sur leur identité de réplication (habituellement
  la clé primaire).
  L'utilisation du terme "réplication logique" est faite en opposition
  à la réplication physique qui elle, utilise l'adresse exacte des blocs
  couplée avec une réplication octet par octet.
  PostgreSQL supporte ces deux méthodes, référez vous à l'article
  <xref linkend="high-availability"/>.
  La réplication logique permet un contrôle fin des données au niveau
  de la réplication et de la sécurité.
 </para>

 <para>
  La réplication logique utilise un système de
  <firstterm>publication</firstterm>/<firstterm>abonnement</firstterm>
  avec un ou plusieurs <firstterm>abonnés</firstterm> qui s'abonnent
  une ou plusieurs <firstterm>publications</firstterm> d'un noeud
  particulier.
  Les abonnés récupèrent les données des publications auxquelles ils sont
  abonnés et peuvent éventuellement renvoyer ces informations pour
  permettre un système de réplication en cascade dans le cas de
  configurations plus complexes.
 </para>

 <para>
  La réplication logique d'une table commence en générale en prennant un
  instantanné des données sur la base publication et le copiant vers la base
  abonnée.
  Une fois cette étape réalisée, les changements sur la base publication
  sont envoyés à la base abonnée en temps réel.
  La base abonnée applique les modifications dans le même ordre qu'elles
  auront été réalisées de façon à ce que la cohérence transactionnelle
  soit garantie pour les publications d'un seul abonnement.
  Cette méthode de réplication porte parfois le nom de réplication
  transactionnelle.
 </para>

 <para>
  Les cas typiques d'utilisation de la réplication logiques peuvent être
  les suivants:

  <itemizedlist>
   <listitem>
    <para>
     Envoyer immédiatement les changements réalisés sur une base de données,
     ou sur un sous ensemble de ces données, de facon incrémentale à une
     base de données abonnée.
    </para>
   </listitem>

   <listitem>
    <para>
     Déclencher des triggers pour des changements spécifiques lorsqu'ils
     apparaissent sur la base de données abonnée.
    </para>
   </listitem>

   <listitem>
    <para>
     Réaliser la consolidation de plusieurs bases de données au sein d'une
     seule. (par exemple pour répondre à des problématiques analytiques)
    </para>
   </listitem>

   <listitem>
    <para>
     Réplication entre des versions majeures différentes de PostgreSQL.
    </para>
   </listitem>

   <listitem>
    <para>
     Donner accès a des données répliquées à différents groupes
     d'utilisateurs.
    </para>
   </listitem>

   <listitem>
    <para>
     Partager un sous ensemble de données entre plusieurs base de données.
    </para>
   </listitem>
  </itemizedlist>
 </para>

 <para>
  Une base de données abonnée se comporte comme n'importe quelle autre
  base de données d'une instance PostgreSQL et peut être utilisée comme
  base de données de publication pour d'autres base de données en lui
  définissant ses propres publications.
  Lorsque la base abonnée est considérée comme une base en lecture seule
  par l'application, il ne va pas y avoir de problèmes de conflit.
  D'un autre côté, s'il y a des écritures provenant soit de l'application
  soit d'un autre abonnement sur le même ensemble de table, des conflits
  peuvent survenir.
 </para>

 <sect1 id="logical-replication-publication">
  <title>Publication</title>

  <para>
   Une <firstterm>publication</firstterm> peut être définie sur n'importe
   quel serveur primaire de réplication physique.
   Le noeud sur laquelle la publication est définie est nommé
   <firstterm>éditeur</firstterm> .
   Une publication est un ensemble de modifications générées par une table
   ou un groupe de table et peut aussi être défini comme un set de
   modifications ou un set de réplication. Chaque publication existe au
   sein d'une seule base de données.
  </para>

  <para>
   Les publications sont différenciées du shéma et n'ont pas d'impacts
   sur la manière dont la base est accédée.
   Chaque table peut être ajoutée à différentes publications si besoin.
   Actuellement, les publications ne contiennent que les tables.
   Les objets doivent être ajoutés explicitement, sauf si la publication
   a été créée pour <literal>ALL TABLES</literal>.
  </para>

  <para>
   Les publications peuvent choisir de limiter les changements qu'elles
   produisent avec n'importe quelle combinaison de
   <command>INSERT</command>, <command>UPDATE</command>, et
   <command>DELETE</command>, ceci d'une façon similaire de l'activation *
   de triggers en fonction d'un certain type d'évenemment.
   Si une table sans <literal>REPLICA IDENTITY</literal> est ajoutée à
   une publication qui réplique les opérations de <command>UPDATE</command>
   ou <command>DELETE</command> alors, les opérations de
   <command>UPDATE</command> ou <command>DELETE</command> échoueront sur
   l'éditeur.
  </para>

  <para>
   Chaque publications peut avoir plusieurs abonnés.
  </para>

  <para>
   Une publication est créée en utilisant la commande
   <xref linkend="sql-createpublication"/> et peut être ensuite modifiée
   ou supprimée en utilisant la commande correspondante.
  </para>

  <para>
   Les tables individuelles peuvent être ajoutées ou supprimées
   dynamiquement en utilisant <xref linkend="sql-alterpublication"/>.
   Les opérations <literal>ADD TABLE</literal> et
   <literal>DROP TABLE</literal> sont toutes les deux transactionnelles;
   de ce fait, une table va commencer ou arrêter de répliquer dans le bon
   instantanné seulement une fois que la transaction a été validée.
  </para>
 </sect1>

 <sect1 id="logical-replication-subscription">
  <title>Abonnement</title>

  <para>
   Un <firstterm>abonnement</firstterm> est le côté aval de la
   réplication logique.
   Le noeud où un abonnement a été défini est nommé
   <firstterm>abonné</firstterm>
   Un abonnement définit la connexion à une autre base de données et
   un ensemble de publications (une ou plus) auxquelles l'abonné veut
   souscrire.
  </para>

  <para>
   La base de données abonnée se comporte comme n'importe quelle base
   de données d'une instance PostgreSQL et peut être utilisée comme
   éditeur pour d'autres bases de données en définissant ses propres
   publications.
  </para>

  <para>
   un noeud abonné peut avoir plusieurs abonnements si besoin. Il est
   possible de définir plusieurs abonnements entre une même paire
   éditeur-abonné, dans ce cas, il faut faire attention à ce que les objets
   des publications auquelles l'abonné à souscrit ne se chevauchent pas.
  </para>

  <para>
   Chaque abonnement recevra les changements par un slot de réplication
   (cf <xref linkend="streaming-replication-slots"/>).
   Des slots de réplications temporaires supplémentaires peuvent être
   nécessaires pour la synchronisation initiale des données d'une table
   contenant des données pré-existantes.
  </para>

  <para>
   Les abonnements sont sauvegardés par <command>pg_dump</command> si
   l'utilisateur courant a des droits de superutilisateur. Si ce n'est
   pas le cas un warning est renvoyé et les abonnements ne sont pas
   sauvegardés. En effet, les informations d'abonnements contenues dans
   <structname>pg_subscription</structname> ne sont pas consultables par
   des utilisateurs avec des droits moins importants.
  </para>

  <para>
   Un abonnement est ajouté en utilisant <xref linkend="sql-createsubscription"/> ,
   il peut être arrêté/repris à n'importe quel moment en utilisant la
   commande <xref linkend="sql-altersubscription"/> et il peut être
   supprimé par la commande <xref linkend="sql-dropsubscription"/>.
  </para>

  <para>
   Quand un abonnement est supprimé puis recréé, les informations de
   synchronisation sont perdues. Cela signifie que les données doivent
   être resynchronisées ensuite.
  </para>

  <para>
   La définition d'un schéma n'est pas répliquée, et les tables publiées
   doivent exister sur la base abonnée. Seules des tables standards
   peuvent accueuillir des données répliquées. Par exemple, il n'est pas
   pas possible de répliquer dans une vue.
  </para>

  <para>
   La correspondance entre les tables de l'éditeur et de l'abonné est
   réalisée en utilisant le fully qualified name de la table.
   La réplication entre des tables portant un nom différent sur la base
   abonnée n'est pas supporté.
  </para>

  <para>
   La correspondance entre les colonnes d'une table est aussi faite sur
   le nom de la colonne. Il est possible que les colonnes ne soient pas
   définies dans le même ordre, par contre, les types des colonnes
   doivent concorder.
   La table cible peut avoir des colonnes supplémentaires, non valorisées
   par la table qui publie. Celles ci seront remplies par leurs valeurs
   par défaut.
  </para>

  <sect2 id="logical-replication-subscription-slot">
   <title>Gestion des slots de réplication</title>

   <para>
    Comme présenté plus tôt, chaque abonnement (actif) reçoit les
    changements depuis un slot de réplication du serveur distant
    (publication). Normalement, le slot de réplication distant est créé
    automatiquement en utlisant la commande
    <command>CREATE SUBSCRIPTION</command> et il est supprimé
    automatiquement en utilisant la commande
    <command>DROP SUBSCRIPTION</command>.
    Dans certaines situations, il peut être utile ou nécessaire de
    manipuler les abonnements ainsi que les slots de réplication
    sous-jacents de façon séparées. Voici quelques exemples :

    <itemizedlist>
     <listitem>
      <para>
	   Lorsqu'en créant un abonnement, le slot de réplication
	   correspondant existe déjà. Dans ce cas, l'abonnement peut être
	   créé en utilisant l'option <literal>create_slot = false</literal>
	   pour réaliser l'association avec le slot existant.
      </para>
     </listitem>

     <listitem>
      <para>
       Lorsqu'en créant un abonnement, le serveur distant n'est pas
       disponible ou dans un état indéfini. Dans ce cas, l'abonnement
       peut être créé en utilisant l'option  <literal>connect = false</literal>.
       Le serveur distant ne sera jamais contacté. C'est la méthode
       utilisée par  <application>pg_dump</application>.
       Le slot de réplication distant devra alors être créé manuellement
       avant que l'abonnement puisse être activé.
      </para>
     </listitem>

     <listitem>
      <para>
       Lorsqu'on supprime un abonnement et que le slot de réplication doit
       être conservé, par exemple lorsqu'une base abonnée est
       déplacée vers un serveur différent et sera activé depuis cette
       nouvelle localisation.
       Dans ce cas, il faut dissocier le slot de réplication de
       l'abonnement correspondant en utilisant la commande
       <command>ALTER SUBSCRIPTION</command> avant de supprimer
       l'abonnement.
      </para>
     </listitem>

     <listitem>
      <para>
	   Lorsque l'on supprime un abonnement et que le serveur distant n'est
	   pas joignable. Dans ce cas, il faut aussi dissocier le slot de
	   réplication de l'abonnement correspondant en utilisant
	   <command>ALTER SUBSCRIPTION</command> avant de supprimer
	   l'abonnement.
       Si l'instance distante n'existe plus, aucune action supplémentaire
       n'est nécessaire. Si, par contre, l'instance distante est
       simplement temporairement injoignable, le slot de réplication
       devrait être supprimé manuellement, sinon l'instance va
       persevérer à conserver ses fichiers WAL jusqu'à saturation de
       l'espace disque disponible. Ces cas doivent être traités avec
       beaucoup de précautions.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-conflicts">
  <title>Conflits</title>

  <para>
   La réplication logique se comporte de la même manière pour les
   opérations DML dans le sens où les données seront mise à jour même si
   la modification a été faite en local sur la base abonnée. Si les
   données entrantes entrainent des violations de contrainte d'intégrité,
   la réplication s'arrête. Cela sera référencé comme un
   <firstterm>conflit</firstterm>.
   Lorsque l'on réplique des opérations <command>UPDATE</command> ou
   <command>DELETE</command>, les données manquantes ne produiront pas
   de conflit et des opérations de la sorte seront simplement évitées.
  </para>

  <para>
   Lorsqu'un conflit entraine une erreur, cela stoppe la réplication ;
   Le conflit devra être résolu manuellement par un utilisateur. Des
   informations détaillées concernant le conflit seront diponible dans
   les journaux d'erreurs de l'instance abonnée.
  </para>

  <para>
   La résolution peut être réalisée, soit en changeant les données sur
   la base abonnée pour qu'elles ne soient plus en conflit avec les
   données entrantes ou en évitant les transactions qui sont en conflit
   avec les données existantes. La transaction peut être évitée en
   utilisant la fonction <link linkend="pg-replication-origin-advance">
   <function>pg_replication_origin_advance()</function></link> avec
   <parameter>node_name</parameter> pointant sur le nom de l'abonnement,
   ainsi que la position. La position courante d'origine peut être
   consultée dans la vue système
   <link linkend="view-pg-replication-origin-status">
   <structname>pg_replication_origin_status</structname></link>.
  </para>
 </sect1>

 <sect1 id="logical-replication-architecture">
  <title>Architecture</title>

  <para>
   La réplication logique démarre en copiant un instantanné des données
   sur la base de publication. Une fois cette étape réalisée, les
   modifications sur la base de publication sont envoyées à la base de
   données abonnée au fil de l'eau. La base abonnée applique les
   modifications sur les données dans l'ordre dans lequel les validations
   ont été effectuées sur la base éditeur de manière à ce que la
   cohérence transactionnelle soit respectée pour les publications vis à
   vis de tous les abonnements.
  </para>

  <para>
   La réplication se contruit de façon similaire à la réplication
   physique continue (Streaming Replication)
   (cf <xref linkend="streaming-replication"/>).
   Ceci est implémenté par les processus <quote>walsender</quote> et
   <quote>apply</quote>.
   Le processus walsender démarre le décodage logique (décrit dans la
   section <xref linkend="protocol-logical-replication"/>) des fichiers
   WAL et charge le plugin de décodage logique standard (pgoutput).
   Ce plugin transforme les changements lu depuis les fichiers WAL vers
   le protocole de réplication logique
   (cf <xref linkend="protocol-logical-replication"/>)
   et filtre les données en fonction des spécificités des publications.
   Les données sont envoyées au fil de l'eau au processus apply, qui
   met en relation les données vers les tables locales et applique les
   changements individuels au moment où ils sont reçus, dans le bon ordre
   transactionnel.
  </para>

  <para>
   Le processus apply sur l'instance de la base abonnée fonctionne toujours
   avec le paramètre <varname>session_replication_role</varname> défini
   à la valeur <literal>replica</literal>, qui produit les effets habituels
   sur les triggers et les contraintes.
  </para>

  <sect2 id="logical-replication-snapshot">
    <title>Instantanné initial</title>
    <para>
	  Les données initiales présentes dans des tables abonnées sont
	  photographiées et copiées dans une instance parallèle qui utilise
	  un type particulier de processus apply.
      Ce processus va créer son propre slot de réplication temporaire
      et copier les données existantes. Une fois les données existantes
      copiées, le processus passe en mode de synchronisation, qui
      assure que la table est amenée vers un état synchronisé avec le
      processus apply principal, ceci en transferant toutes les
      modifications survenues pendant la copie initiale des données,
      réalisée avec le système de réplication logique standard
      Une fois la synchronisation terminée, le contrôle de la
      réplication de la table est rendu au processus apply principal et
      la réplication continue telle quelle.
    </para>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-monitoring">
  <title>Supervision</title>

  <para>
   Puisque la réplication logique est basée sur une architecture
   similaire à la
   <link linkend="streaming-replication">réplication physique continue</link>,
   la supervision d'une instance publication et similaire à la
   supervision d'une instance primaire dans la réplication physique
   (cf <xref linkend="streaming-replication-monitoring"/>).
  </para>

  <para>
   Les informations des abonnements sont consultables dans la vue
   <link linkend="pg-stat-subscription">
   <literal>pg_stat_subscription</literal></link>.
   Cette vue contient une ligne pour chaque processus d'abonnement. Un
   abonnement peut avoir zéro ou plusieurs processus abonnés selon son
   état.
  </para>

  <para>
   Normalement il y a un seul processus apply démarré pour
   un abonnement actif.
   Un abonnement désactivé ou une publication effondrée n'aura pas de
   ligne dans cette vue.
   Si la synchronisation initiale d'une table est en cours, il y aura des
   processus supplémentaire pour les tables en cours de synchronisation.
  </para>
 </sect1>

 <sect1 id="logical-replication-security">
  <title>Sécurité</title>

  <para>
   Le role utilisée pour la réplication doit avoir l'attribut
   <literal>REPLICATION</literal> . L'accès à l'instance de ce rôle doit
   avoir été déclaré dans <filename>pg_hba.conf</filename>.
  </para>

  <para>
   Pour créer une publication, l'utilisateur doit avoir le privilège
   <literal>CREATE</literal> pour la base de données.
  </para>

  <para>
   Pour ajouter des tables à une publication, l'utilisateur doit avoir
   les droits de propriétaire de ces tables.
   Pour créer une publication qui publie toutes les tables
   automatiquement, l'utilisateur doit avoir les droits de super
   utilisateur.
  </para>

  <para>
   Pour créer un abonnement, l'utilisateur doit avoir les droits de super
   utilisateur.
  </para>

  <para>
   Le processus apply lié à un abonnement tournera sur la base de données
   locale avec les privilèges d'un superutilisateur.
  </para>

  <para>
   Les privilèges ne sont vérifiés qu'une seule fois, au démarrage de la
   connexion de réplication.
   Il ne sont pas revérifiés lorsqu'un changement est lu depuis l'éditeur,
   et ils ne sont pas revérifiés non plus à chaque application d'un
   changement.
  </para>
 </sect1>

 <sect1 id="logical-replication-config">
  <title>Paramètres de configuration</title>

  <para>
   La réplication logique requiert de nombreuses configurations pour
   fonctionner.
  </para>

  <para>
   Du côté de l'éditeur, <varname>wal_level</varname> doit être
   positionné à <literal>logical</literal>, et
   <varname>max_replication_slots</varname> doit être positionné au
   minimum au nombre d'abonnements que l'on va connecter, plus
   quelque uns que l'on réservera pour les synchronisations des tables.
   Le paramètre <varname>max_wal_senders</varname> devrait être
   positionné au minimum à la même valeur que
   <varname>max_replication_slots</varname> en plus du nombre de réplicats
   physiques qui pourraient être connectés au même moment.
  </para>

  <para>
   Du côté de l'abonné, le paramètre
   <varname>max_replication_slots</varname> doit lui aussi être défini.
   Il devrait être défini au minimum, au nombre d'abonnements
   qui vont être souscrits par les bases abonnées.
   Le paramètre <varname>max_logical_replication_workers</varname> doit
   être positionné au minimum à la valeur du nombre d'abonnements plus une
   réserve pour la synchronisation des tables.
   En supplément, le paramètre <varname>max_worker_processes</varname>
   peut devoir être ajusté pour s'accorder au nombre de processus de
   réplication, (<varname>max_logical_replication_workers</varname>
   + <literal>1</literal>).
   Notez que certaines extensions et les requêtes parallélisées
   prennent elles aussi des unités de la réserve de
   <varname>max_worker_processes</varname>.
  </para>
 </sect1>

 <sect1 id="logical-replication-quick-setup">
  <title>Démarrage rapide</title>

  <para>
   En premier, définissez les options de configurations dans le fichier
   <filename>postgresql.conf</filename>:
<programlisting>
wal_level = logical
</programlisting>
   La valeur par défaut des autres paramètres est suffisante pour une
   mise en place de base.
  </para>

  <para>
   Le fichier <filename>pg_hba.conf</filename> doit être mis à jour pour
   autoriser la réplication (les valeurs dépendent de la configuration
   réelle de votre réseau et de l'utilisateur que vous disposerez pour
   vous connecter):
<programlisting>
host     all     repuser     0.0.0.0/0     md5
</programlisting>
  </para>

  <para>
   Ensuite sur la base de l'éditeur:
<programlisting>
CREATE PUBLICATION mypub FOR TABLE users, departments;
</programlisting>
  </para>

  <para>
   Et sur la base abonnée:
<programlisting>
CREATE SUBSCRIPTION mysub CONNECTION 'dbname=foo host=bar user=repuser' PUBLICATION mypub;
</programlisting>
  </para>

  <para>
   Les instructions précédentes vont démarrer le processus de réplication,
   qui va réaliser la synchronisation initiale du contenu des tables
   <literal>users</literal> et <literal>departments</literal> et ensuite
   qui commencera à répliquer les changements de manière incrémentale
   sur ces tables.
  </para>
 </sect1>
</chapter>
