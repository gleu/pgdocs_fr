<?xml version="1.0" encoding="UTF-8"?>
<chapter id="logical-replication">
 <title>Réplication logique</title>

 <para>
  La réplication logique est une méthode permettant de répliquer des données au
  niveau objet ainsi que les modifications apportées à ces objets, ceci basé sur
  leur identité de réplication (habituellement la clé primaire). L'utilisation
  du terme de <quote>réplication logique</quote> est faite en opposition à la
  réplication physique, cette dernière utilisant l'adresse exacte des blocs couplée
  avec une réplication octet par octet. PostgreSQL supporte ces deux méthodes,
  référez-vous à l'article <xref linkend="high-availability"/>. La réplication
  logique permet un contrôle fin des données au niveau de la réplication et de
  la sécurité.
 </para>

 <para>
  La réplication logique utilise un système de
  <firstterm>publication</firstterm> / <firstterm>abonnement</firstterm> avec un
  ou plusieurs <firstterm>abonnés</firstterm> qui s'abonnent à une ou plusieurs
  <firstterm>publications</firstterm> d'un nœud particulier. Les abonnés
  récupèrent les données des publications auxquelles ils sont abonnés et peuvent
  éventuellement renvoyer ces informations, ce qui permet un système de
  réplication en cascade dans le cas de configurations plus complexes.
 </para>

 <para>
  La réplication logique d'une table commence en général en prenant un
  instantané des données sur la base publiée et en le copiant vers la base
  abonnée. Une fois cette étape réalisée, les changements sur la base publiée
  sont envoyés à la base abonnée en temps réel. La base abonnée applique les
  modifications dans le même ordre qu'elles auront été réalisées de façon à ce
  que la cohérence transactionnelle soit garantie pour les publications d'un
  seul abonnement. Cette méthode de réplication porte parfois le nom de
  réplication transactionnelle.
 </para>

 <para>
  Les cas typiques d'utilisation de la réplication logique peuvent être les
  suivants&nbsp;:

  <itemizedlist>
   <listitem>
    <para>
     Envoyer immédiatement les changements réalisés sur une base de données, ou
     sur un sous-ensemble de ces données, de façon incrémentale à une base de
     données abonnée;
    </para>
   </listitem>

   <listitem>
    <para>
     Déclencher des triggers pour des changements spécifiques lorsqu'ils
     apparaissent sur la base de données abonnée&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Réaliser la consolidation de plusieurs bases de données au sein d'une seule
     (par exemple pour répondre à des problématiques analytiques)&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Répliquer entre des versions majeures différentes de PostgreSQL&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Répliquer des instances PostgreSQL sur des plateformes différentes (par
     exemple de Linux à Windows)&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Donner accès à des données répliquées à différents groupes d'utilisateurs&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Partager un sous-ensemble de données entre plusieurs bases de données.
    </para>
   </listitem>
  </itemizedlist>
 </para>

 <para>
  Une base de données abonnée se comporte comme n'importe quelle autre base de
  données d'une instance PostgreSQL et peut être utilisée comme base de données
  de publication pour d'autres base de données en lui définissant ses propres
  publications. Lorsque la base abonnée est considérée comme une base en
  lecture seule par l'application, il ne va pas y avoir de problèmes de conflits.
  D'un autre côté, s'il y a des écritures provenant soit de l'application soit
  d'un autre abonnement sur le même ensemble de tables, des conflits peuvent
  survenir.
 </para>

 <sect1 id="logical-replication-publication">
  <title>Publication</title>

  <para>
   Une <firstterm>publication</firstterm> peut être définie sur n'importe quel
   serveur primaire de réplication physique. Le nœud sur laquelle la
   publication est définie est nommé <firstterm>publieur</firstterm>. Une
   publication est un ensemble de modifications générées par une table ou un
   groupe de tables et peut aussi être défini comme un ensemble de modifications
   ou un ensemble de réplication. Chaque publication existe au sein d'une seule
   base de données.
  </para>

  <para>
   Les publications sont différenciées du schéma et n'ont pas d'impact sur la
   manière dont la base est accédée. Chaque table peut être ajoutée à
   différentes publications au besoin. Actuellement, les publications ne
   contiennent que les tables et toutes les tables d'un schéma. Les objets
   doivent être ajoutés explicitement, sauf si la publication a été créée pour
   toutes les tables (<literal>ALL TABLES</literal>).
  </para>

  <para>
   Les publications peuvent choisir de limiter les changements qu'elles
   produisent avec n'importe quelle combinaison de <command>INSERT</command>,
   <command>UPDATE</command>, <command>DELETE</command> et
   <command>TRUNCATE</command>, ceci d'une façon similaire à l'activation de
   triggers en fonction d'un certain type d'événement. Par défaut, tous les
   types d'opération sont répliqués. Ces spécifications de publication
   s'appliquent seulement pour les opérations DML&nbsp;; elles n'affectent pas
   la copie initiale de synchronisation des données. (Les filtres de ligne
   n'ont pas d'effet pour la commande <command>TRUNCATE</command>. Voir <xref
   linkend="logical-replication-row-filter"/>.)
  </para>

  <para>
   Une table publiée doit avoir une <firstterm>identité de réplication</firstterm>
   configurée pour être capable de répliquer des opérations
   <command>UPDATE</command> et <command>DELETE</command>, pour que les lignes
   appropriées à modifier ou supprimer puissent être identifiées du côté de
   l'abonné. Par défaut, il s'agit de la clé primaire, si elle existe. Un autre
   index d'unicité (avec quelques prérequis supplémentaires) peut aussi être
   configuré du côté de l'abonné. Si la table n'a pas de clé convenable, alors
   elle peut être configurée pour l'identité de réplica <literal>FULL</literal>,
   ce qui signifie que la ligne entière devient la clé.
   Lorsque l'identité de réplica est spécifiée à <literal>FULL</literal>,
   des index peuvent être utilisés du côté de l'abonné pour rechercher des lignes.
   Ces index candidats doivent être de type B-tree ou hash, non-partiels, et le champ d'index le plus à gauche
   doit être une colonne (pas une expression) qui référencie la colonne de la table publiée. Ces
   restrictions sur les propriétés non-unique de l'index correspondent à certaines des restrictions
   renforcées par des clés primaires. S'il n'y a pas d'index approprié, la recherche côté abonné
   peut être très peu efficace, par conséquent l'identité de réplica <literal>FULL</literal>
   devrait seulement être utilisée comme solution de repli si aucune autre solution n'est
   disponible. Si une identité de réplication est différente de
   <literal>FULL</literal> du côté du publieur, une identité de réplication
   comprenant les mêmes colonnes, ou moins de colonnes, peut aussi être
   configuré du côté de l'abonné. Voir <xref
   linkend="sql-altertable-replica-identity"/> pour les détails sur la
   configuration de l'identité de réplication. Si une table sans identité de
   réplication est ajoutée à une publication qui réplique les opérations
   <command>UPDATE</command> ou <command>DELETE</command>, alors les opérations
   <command>UPDATE</command> ou <command>DELETE</command> suivantes causeront une
   erreur sur le publieur. Les opérations <command>INSERT</command> peuvent se
   réaliser quelle que soit l'identité de réplication.
  </para>

  <para>
   Chaque publication peut avoir plusieurs abonnés.
  </para>

  <para>
   Une publication est créée en utilisant la commande <link
   linkend="sql-createpublication"><command>CREATE PUBLICATION</command></link>
   et peut ensuite être modifiée ou supprimée en utilisant la commande
   correspondante.
  </para>

  <para>
   Les tables individuelles peuvent être ajoutées ou supprimées dynamiquement en
   utilisant <link linkend="sql-alterpublication"><command>ALTER
   PUBLICATION</command></link>. Les opérations <literal>ADD TABLE</literal> et
   <literal>DROP TABLE</literal> sont toutes les deux transactionnelles&nbsp;;
   de ce fait, une table va commencer ou arrêter de répliquer dans le bon
   instantané seulement une fois que la transaction a été validée.
  </para>
 </sect1>

 <sect1 id="logical-replication-subscription">
  <title>Abonnement</title>

  <para>
   Un <firstterm>abonnement</firstterm> est le côté aval de la réplication
   logique. Le nœud où un abonnement a été défini est nommé
   <firstterm>abonné</firstterm>. Un abonnement définit la connexion à une
   autre base de données et un ensemble de publications (une ou plus) auxquelles
   l'abonné veut souscrire.
  </para>

  <para>
   La base de données abonnée se comporte comme n'importe quelle base de données
   d'une instance PostgreSQL et peut être utilisée comme éditeur pour d'autres
   bases de données en définissant ses propres publications.
  </para>

  <para>
   Un nœud abonné peut avoir plusieurs abonnements si besoin. Il est possible de
   définir plusieurs abonnements entre une même paire publieur - abonné. Dans ce
   cas, il faut faire attention à ce que les objets des publications auxquelles
   l'abonné a souscrit ne se chevauchent pas.
  </para>

  <para>
   Chaque abonnement recevra les changements par un slot de réplication (voir
   <xref linkend="streaming-replication-slots"/>). Des slots de réplications
   supplémentaires peuvent être nécessaires pour la synchronisation initiale des
   données d'une table contenant des données pré-existantes mais ils seront
   supprimés à la fin de la synchronisation des données.
  </para>

  <para>
   Un abonnement de réplication logique peut être réalisé sur un serveur
   secondaire pour de la réplication synchrone (voir <xref
   linkend="synchronous-replication"/>). Le nom du serveur secondaire
   correspond par défaut au nom de l'abonnement. Un nom alternatif peut être
   indiqué avec le paramètre <literal>application_name</literal> dans les
   informations de connexion à l'abonnement.
  </para>

  <para>
   Les abonnements sont sauvegardés par <command>pg_dump</command> si
   l'utilisateur courant a des droits de superutilisateur. Si ce n'est pas le
   cas, un message d'avertissement est renvoyé et les abonnements ne sont pas
   sauvegardés. En effet, les informations d'abonnements contenues dans
   <structname>pg_subscription</structname> ne sont pas consultables par des
   utilisateurs dotés de droits moins importants.
  </para>

  <para>
   Un abonnement est ajouté en utilisant <link
   linkend="sql-createsubscription"><command>CREATE
   SUBSCRIPTION</command></link>. Il peut être arrêté/repris à n'importe quel
   moment en utilisant la commande <link
   linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION</command></link>,
   et il peut être supprimé par la commande <link
   linkend="sql-dropsubscription"><command>DROP SUBSCRIPTION</command></link>.
  </para>

  <para>
   Quand un abonnement est supprimé puis recréé, les informations de
   synchronisation sont perdues. Cela signifie que les données doivent être
   resynchronisées ensuite.
  </para>

  <para>
   La définition d'un schéma n'est pas répliquée, et les tables publiées doivent
   exister sur la base abonnée. Seules des tables standards peuvent accueillir
   des données répliquées. Par exemple, il n'est pas pas possible de répliquer
   dans une vue.
  </para>

  <para>
   La correspondance entre les tables du publieur et de l'abonné est réalisée en
   utilisant le nom entièrement qualifié de la table. La réplication entre des
   tables portant un nom différent sur la base abonnée n'est pas supportée.
  </para>

  <para>
   La correspondance sur les colonnes d'une table se fait aussi par nom.
   L'ordre des colonnes dans la table sur le serveur abonné ne correspond pas
   forcément à l'ordre sur le serveur publieur. Les types de données n'ont pas
   non plus besoin de correspondre, à partir du moment où la représentation
   textuelle de la donnée peut être convertie vers le type de données cible.
   Par exemple, vous pouvez répliquer depuis une colonne de type <type>integer</type>
   vers une colonne de type <type>bigint</type>. La table cible peut aussi avoir
   des colonnes supplémentaires non fournies par la table publiée. Ce type de
   colonne sera rempli avec la valeur par défaut fournie dans la définition de
   la table cible. Cependant, la réplication logique en format binaire est plus
   restrictive. Voir l'option
   <link linkend="sql-createsubscription-params-with-binary"><literal>binary</literal></link>
   de <command>CREATE SUBSCRIPTION</command> pour les détails.
  </para>

  <sect2 id="logical-replication-subscription-slot">
   <title>Gestion des slots de réplication</title>

   <para>
    Comme présenté plus tôt, chaque abonnement (actif) reçoit les changements
    depuis un slot de réplication du serveur distant (publication).
   </para>

   <para>
    Des slots de synchronisation de tables supplémentaires sont normalement
    temporaires, créés en interne pour réaliser la synchronisation initiale des
    tables et supprimés automatiquement quand elles ne sont plus nécessaires.
    Ces slots de synchronisation de table ont des noms générés
    automatiquement&nbsp;: <quote><literal>pg_%u_sync_%u_%llu</literal></quote>
    (paramètres <parameter>oid</parameter> de la souscription,
    <parameter>relid</parameter> de la table, <parameter>sysid</parameter> pour
    l'identifiant du système).
   </para>

   <para>
    Normalement, le slot de réplication distant est créé automatiquement en
    utilisant la commande <link linkend="sql-createsubscription">
    <command>CREATE SUBSCRIPTION</command></link> et il est
    supprimé automatiquement en utilisant la commande <link
    linkend="sql-dropsubscription"><command>DROP SUBSCRIPTION</command></link>.
    Dans certaines situations, il peut être utile ou
    nécessaire de manipuler les abonnements ainsi que les slots de réplication
    sous-jacents de façon séparées. Voici quelques exemples&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       Lorsqu'en créant un abonnement, le slot de réplication correspondant
       existe déjà. Dans ce cas, l'abonnement peut être créé en utilisant
       l'option <literal>create_slot = false</literal> pour réaliser
       l'association avec le slot existant&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       Lorsqu'en créant un abonnement, le serveur distant n'est pas disponible
       ou dans un état indéfini. Dans ce cas, l'abonnement peut être créé en
       utilisant l'option <literal>connect = false</literal>. Le serveur
       distant ne sera alors jamais contacté. C'est la méthode utilisée par
       <application>pg_dump</application>. Le slot de réplication distant devra
       alors être créé manuellement avant que l'abonnement ne puisse être
       activé&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       Lorsqu'on supprime un abonnement et que le slot de réplication doit être
       conservé, par exemple lorsqu'une base abonnée est déplacée vers un
       serveur différent et sera activée depuis cette nouvelle localisation.
       Dans ce cas, il faut dissocier le slot de réplication de l'abonnement
       correspondant en utilisant la commande <link
       linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION</command></link>
       avant de supprimer l'abonnement&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       Lorsque l'on supprime un abonnement et que le serveur distant n'est pas
       joignable. Dans ce cas, il faut aussi dissocier le slot de réplication de
       l'abonnement correspondant en utilisant <command>ALTER
       SUBSCRIPTION</command> avant de supprimer l'abonnement. Si l'instance
       distante n'existe plus, aucune action supplémentaire n'est nécessaire.
       Si, par contre, l'instance distante est simplement temporairement
       injoignable, le slot de réplication (et tout slot de synchronisation de
       table restant) devrait être supprimé manuellement, sinon l'instance va
       persévérer à conserver ses fichiers WAL jusqu'à saturation de l'espace
       disque disponible. Ces cas doivent être traités avec beaucoup de
       précautions.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>

  <sect2 id="logical-replication-subscription-examples">
    <title>Exemples&nbsp;: Mettre en place la réplication logique</title>

    <para>
     Créer des tables tests sur le publieur.
<programlisting>
test_pub=# CREATE TABLE t1(a int, b text, PRIMARY KEY(a));
CREATE TABLE
test_pub=# CREATE TABLE t2(c int, d text, PRIMARY KEY(c));
CREATE TABLE
test_pub=# CREATE TABLE t3(e int, f text, PRIMARY KEY(e));
CREATE TABLE
</programlisting></para>

    <para>
     Créer les mêmes tables sur l'abonné.
<programlisting>
test_sub=# CREATE TABLE t1(a int, b text, PRIMARY KEY(a));
CREATE TABLE
test_sub=# CREATE TABLE t2(c int, d text, PRIMARY KEY(c));
CREATE TABLE
test_sub=# CREATE TABLE t3(e int, f text, PRIMARY KEY(e));
CREATE TABLE
</programlisting></para>

    <para>
     Insérer des données sur les tables du côté publieur.
<programlisting>
test_pub=# INSERT INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'three');
INSERT 0 3
test_pub=# INSERT INTO t2 VALUES (1, 'A'), (2, 'B'), (3, 'C');
INSERT 0 3
test_pub=# INSERT INTO t3 VALUES (1, 'i'), (2, 'ii'), (3, 'iii');
INSERT 0 3
</programlisting></para>

    <para>
     Créer les publications pour les tables. Les publications
     <literal>pub2</literal> et <literal>pub3a</literal> interdisent certaines
     opérations <link
     linkend="sql-createpublication-params-with-publish"><literal>publish</literal></link>.
     La publication <literal>pub3b</literal> a un filtre de lignes (voir <xref
     linkend="logical-replication-row-filter"/>).
<programlisting>
test_pub=# CREATE PUBLICATION pub1 FOR TABLE t1;
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION pub2 FOR TABLE t2 WITH (publish = 'truncate');
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION pub3a FOR TABLE t3 WITH (publish = 'truncate');
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION pub3b FOR TABLE t3 WHERE (e > 5);
CREATE PUBLICATION
</programlisting></para>

    <para>
     Créer les abonnements (souscriptions) pour les publications. La
     souscription <literal>sub3</literal> s'abonne à <literal>pub3a</literal> et
     <literal>pub3b</literal>. Toutes les souscriptions copieront les données
     initiales par défaut.
<programlisting>
test_sub=# CREATE SUBSCRIPTION sub1
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=sub1'
test_sub-# PUBLICATION pub1;
CREATE SUBSCRIPTION
test_sub=# CREATE SUBSCRIPTION sub2
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=sub2'
test_sub-# PUBLICATION pub2;
CREATE SUBSCRIPTION
test_sub=# CREATE SUBSCRIPTION sub3
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=sub3'
test_sub-# PUBLICATION pub3a, pub3b;
CREATE SUBSCRIPTION
</programlisting></para>

    <para>
     Observez que les données initiales des tables sont copiées, quelque soit
     l'opération <literal>publish</literal> de la publication.
<programlisting>
test_sub=# SELECT * FROM t1;
 a |   b
---+-------
 1 | one
 2 | two
 3 | three
(3 rows)

test_sub=# SELECT * FROM t2;
 c | d
---+---
 1 | A
 2 | B
 3 | C
(3 rows)
</programlisting></para>

    <para>
     De plus, comme la copie initiale de données ignore l'opération
     <literal>publish</literal> et comme la publication <literal>pub3a</literal>
     n'a pas de filtre de lignes, cela signifie que la table
     <literal>t3</literal> copiée contient toutes les lignes même quand elles ne
     correspondent pas au filtre de lignes de la publication
     <literal>pub3b</literal>.
<programlisting>
test_sub=# SELECT * FROM t3;
 e |  f
---+-----
 1 | i
 2 | ii
 3 | iii
(3 rows)
</programlisting></para>

   <para>
    Insérer plus de données dans les tables du côté publieur.
<programlisting>
test_pub=# INSERT INTO t1 VALUES (4, 'four'), (5, 'five'), (6, 'six');
INSERT 0 3
test_pub=# INSERT INTO t2 VALUES (4, 'D'), (5, 'E'), (6, 'F');
INSERT 0 3
test_pub=# INSERT INTO t3 VALUES (4, 'iv'), (5, 'v'), (6, 'vi');
INSERT 0 3
</programlisting></para>

   <para>
    Maintenant, les données du côté publieur ressemblent à ceci&nbsp;:
<programlisting>
test_pub=# SELECT * FROM t1;
 a |   b
---+-------
 1 | one
 2 | two
 3 | three
 4 | four
 5 | five
 6 | six
(6 rows)

test_pub=# SELECT * FROM t2;
 c | d
---+---
 1 | A
 2 | B
 3 | C
 4 | D
 5 | E
 6 | F
(6 rows)

test_pub=# SELECT * FROM t3;
 e |  f
---+-----
 1 | i
 2 | ii
 3 | iii
 4 | iv
 5 | v
 6 | vi
(6 rows)
</programlisting></para>

   <para>
    Observez que, durant la réplication normale, les opérations
    <literal>publish</literal> appropriées sont utilisées. Cela signifie que les
    publications <literal>pub2</literal> et <literal>pub3a</literal> ne
    répliquent pas les opérations <literal>INSERT</literal>. De plus, la
    publication <literal>pub3b</literal> répliquera seulement les données
    correspondant au filtre de lignes de <literal>pub3b</literal>. Maintenant,
    les données du côté abonné ressemblent à ceci&nbsp;:
<programlisting>
test_sub=# SELECT * FROM t1;
 a |   b
---+-------
 1 | one
 2 | two
 3 | three
 4 | four
 5 | five
 6 | six
(6 rows)

test_sub=# SELECT * FROM t2;
 c | d
---+---
 1 | A
 2 | B
 3 | C
(3 rows)

test_sub=# SELECT * FROM t3;
 e |  f
---+-----
 1 | i
 2 | ii
 3 | iii
 6 | vi
(4 rows)
</programlisting></para>
  </sect2>

  <sect2 id="logical-replication-subscription-examples-deferred-slot">
   <title>Exemples&nbsp;: Création de slot de réplication différée</title>

   <para>
    Dans certains cas (i.e
    <xref linkend="logical-replication-subscription-slot"/>), si le slot de réplication
    n'a pas été créé automatiquement, l'utilisateur doit le créer manuellement
    avant que la souscription ne soit activée. Les étapes pour créer le slot et activer
    la souscription sont indiquées dans les exemples suivants.
    Ces exemples spécifient le plugin de décodage logique standard
    (<literal>pgoutput</literal>), qui est utilisé par la réplication logique interne.
   </para>
   <para>
    D'abord, créer une publication pour les exemples.
<programlisting>
test_pub=# CREATE PUBLICATION pub1 FOR ALL TABLES;
CREATE PUBLICATION
</programlisting>
   </para>
   <para>
    Exemple 1&nbsp;: Quand l'abonnement indique <literal>connect = false</literal>
   </para>
   <para>
    <itemizedlist>
     <listitem>
      <para>
       Créez l'abonnement.
<programlisting>
test_sub=# CREATE SUBSCRIPTION sub1
test_sub-# CONNECTION 'host=localhost dbname=test_pub'
test_sub-# PUBLICATION pub1
test_sub-# WITH (connect=false);
WARNING:  subscription was created, but is not connected
HINT:  To initiate replication, you must manually create the replication slot, enable the subscription, and refresh the subscription.
CREATE SUBSCRIPTION
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Sur le publieur, créer manuellement le slot. Comme son nom n'a pas été
       spécifié lors de <literal>CREATE SUBSCRIPTION</literal>, le nom du slot à créer
       est le même que le nom d'abonnement, i.e. "sub1".
<programlisting>
test_pub=# SELECT * FROM pg_create_logical_replication_slot('sub1', 'pgoutput');
 slot_name |    lsn
-----------+-----------
 sub1      | 0/19404D0
(1 row)
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Sur l'abonné, complétez l'activation de l'abonnement. Après cela,
       les tables de <literal>pub1</literal> commenceront à répliquer.
<programlisting>
test_sub=# ALTER SUBSCRIPTION sub1 ENABLE;
ALTER SUBSCRIPTION
test_sub=# ALTER SUBSCRIPTION sub1 REFRESH PUBLICATION;
ALTER SUBSCRIPTION
</programlisting></para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Exemple 2&nbsp;: Quand l'abonnement indique <literal>connect = false</literal>,
    mais spécifie aussi l'option
    <link linkend="sql-createsubscription-params-with-slot-name"><literal>slot_name</literal></link>.
    <itemizedlist>
     <listitem>
      <para>
       Créez l'abonnement.
<programlisting>
test_sub=# CREATE SUBSCRIPTION sub1
test_sub-# CONNECTION 'host=localhost dbname=test_pub'
test_sub-# PUBLICATION pub1
test_sub-# WITH (connect=false, slot_name='myslot');
WARNING:  subscription was created, but is not connected
HINT:  To initiate replication, you must manually create the replication slot, enable the subscription, and refresh the subscription.
CREATE SUBSCRIPTION
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Sur le publieur, créez manuellement un slot en utilisant le même nom que
       celui spécifié lors de <literal>CREATE SUBSCRIPTION</literal>, i.e. "myslot".
<programlisting>
test_pub=# SELECT * FROM pg_create_logical_replication_slot('myslot', 'pgoutput');
 slot_name |    lsn
-----------+-----------
 myslot    | 0/19059A0
(1 row)
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Sur l'abonné, les étapes restantes d'activation d'abonnement sont les mêmes
       que précédemment.
<programlisting>
test_sub=# ALTER SUBSCRIPTION sub1 ENABLE;
ALTER SUBSCRIPTION
test_sub=# ALTER SUBSCRIPTION sub1 REFRESH PUBLICATION;
ALTER SUBSCRIPTION
</programlisting></para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Exemple 3&nbsp;: Quand l'abonnement indique <literal>slot_name = NONE</literal>
    <itemizedlist>
     <listitem>
      <para>
       Créez l'abonnement. Quand <literal>slot_name = NONE</literal> alors
       <literal>enabled = false</literal> et <literal>create_slot = false</literal>
       sont aussi nécessaires.
<programlisting>
test_sub=# CREATE SUBSCRIPTION sub1
test_sub-# CONNECTION 'host=localhost dbname=test_pub'
test_sub-# PUBLICATION pub1
test_sub-# WITH (slot_name=NONE, enabled=false, create_slot=false);
CREATE SUBSCRIPTION
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Sur le publieur, créez manuellement un slot en utilisant n'importe quel nom, i.e. "myslot".
<programlisting>
test_pub=# SELECT * FROM pg_create_logical_replication_slot('myslot', 'pgoutput');
 slot_name |    lsn
-----------+-----------
 myslot    | 0/1905930
(1 row)
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Sur l'abonné, associez l'abonnement avec le nom de slot juste créé.
<programlisting>
test_sub=# ALTER SUBSCRIPTION sub1 SET (slot_name='myslot');
ALTER SUBSCRIPTION
</programlisting></para>
     </listitem>
     <listitem>
      <para>
       Les étapes restantes d'activation d'abonnement sont les mêmes que précédemment.
<programlisting>
test_sub=# ALTER SUBSCRIPTION sub1 ENABLE;
ALTER SUBSCRIPTION
test_sub=# ALTER SUBSCRIPTION sub1 REFRESH PUBLICATION;
ALTER SUBSCRIPTION
</programlisting></para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>

 </sect1>

 <sect1 id="logical-replication-failover">
  <title>Failover en réplication logique</title>

  <para>
   Pour permettre à des nœuds abonnés de continuer de répliquer les
   données du nœud publieur même quand ce dernier tombe, il doit y
   avoir un secondaire physique correspondant au nœud publieur. Les
   slots logique du serveur primaire correspondant aux souscriptions
   peuvent être synchronisés sur le serveur secondaire en précisant
   <literal>failover = true</literal> lors de la création de la souscription.
   Voir <xref linkend="logicaldecoding-replication-slots-synchronization"/>
   pour les détails. Activer le paramètre
   <link linkend="sql-createsubscription-params-with-failover"><literal>failover</literal></link>
   assure une transition directe de ces souscriptions après la promotion
   du secondaire. Ils peuvent continuer à souscrire aux publications du
   nouveau serveur primaire.
  </para>

  <para>
   Comme la logique de synchronisation du slot copies de façon asynchrone,
   il est nécessaire de confirmer que les slots de réplication doivent être
   synchronisés vers le serveur secondaire avant l'exécution du failover.
   Pour s'assurer d'un failover réussi, le serveur secondaire doit être en avance sur l'abonné. Ceci peut se faire en configurant
   <link linkend="guc-synchronized-standby-slots"><varname>synchronized_standby_slots</varname></link>.
  </para>

  <para>
   Pour confirmer que le serveur secondaire est prêt pour un failover, suivez
   ces étapes pour vérifier que tous les slots de réplication logique
   nécessaires ont bien été synchronisés sur le serveur secondaire&nbsp;:
  </para>

  <procedure>
   <step performance="required">
    <para>
     Sur le nœud abonné, utilisez la requête SQL suivante pour identifier
     les slots de réplication devant être synchronisés sur le secondaire que
     nous souhaitons promouvoir. Cette requête renverra les slots de
     réplication adéquats avec les souscriptions dont l'option failover est
     activée.
     <programlisting>
test_sub=# SELECT
               array_agg(quote_literal(s.subslotname)) AS slots
           FROM  pg_subscription s
           WHERE s.subfailover AND
                 s.subslotname IS NOT NULL;
 slots
-------
 {'sub1','sub2','sub3'}
(1 row)
</programlisting></para>
   </step>
   <step performance="required">
    <para>
     Sur le nœud abonné, utilisez la requête SQL suivante pour identifier
     les slots de synchronisation qui doivent être synchronisés sur le secondaire
     que nous planifions de promouvoir. Cette requête a besoin d'être exécutée
     sur chaque base qui inclut les souscriptions dont l'option failover a été
     activée. Notez que le slot de synchronisation de table doit être synchronisé
     vers le serveur secondaire seulement si la copie de table est terminée
     (Voir <xref linkend="catalog-pg-subscription-rel"/>).
     Nous n'avons pas besoin de nous assurer que les slots de synchronisation
     de table sont synchronisés dans les autres scénarios car ceux-là seront
     soit supprimés soit re-créés sur le nouveau serveur primaire.
<programlisting>
test_sub=# SELECT
               array_agg(quote_literal(slot_name) AS slots
           FROM
           (
               SELECT CONCAT('pg_', srsubid, '_sync_', srrelid, '_', ctl.system_identifier) AS slot_name
               FROM pg_control_system() ctl, pg_subscription_rel r, pg_subscription s
               WHERE r.srsubstate = 'f' AND s.oid = r.srsubid AND s.subfailover
           );
 slots
-------
 {'pg_16394_sync_16385_7394666715149055164'}
(1 row)
</programlisting></para>
   </step>
   <step performance="required">
    <para>
     Vérifiez que les slots de réplication logique identifiés ci-dessus
     existent sur le serveur secondaire et sont prêt pour un failover.
<programlisting>
test_standby=# SELECT slot_name, (synced AND NOT temporary AND NOT conflicting) AS failover_ready
               FROM pg_replication_slots
               WHERE slot_name IN
                   ('sub1','sub2','sub3', 'pg_16394_sync_16385_7394666715149055164');
  slot_name                                 | failover_ready
--------------------------------------------+----------------
  sub1                                      | t
  sub2                                      | t
  sub3                                      | t
  pg_16394_sync_16385_7394666715149055164   | t
(4 rows)
</programlisting></para>
    </step>
  </procedure>

  <para>
   Si tous les slots sont présents sur le serveur secondaire et que le
   résultat (<literal>failover_ready</literal>) de la requête SQL ci-dessus
   vaut <literal>true</literal>, alors les souscriptions existantes
   pourront continuer leur travail avec les publications sur le nouveau
   serveur primaire.
  </para>

 </sect1>

 <sect1 id="logical-replication-row-filter">
  <title>Filtres de lignes</title>

  <para>
   Par défaut, toutes les données de toutes les tables publiées seront
   répliquées aux abonnés appropriés. Les données répliquées peuvent être
   réduites en utilisant un <firstterm>filtre de lignes</firstterm>. Un
   utilisateur pourrait choisir d'utiliser des filtres de lignes pour des
   raisons de comportement, de sécurité ou de performance. Si une table publiée
   configure un filtre de lignes, une ligne est répliquée seulement si ses
   données satisfont l'expression du filtre de lignes. Cela permet à un ensemble
   de tables d'être répliquées partiellement. Le filtre de lignes est défini par
   table. Utilisez une clause <literal>WHERE</literal> après le nom de la table
   pour chaque table publiée dont les données doivent être filtrées. La clause
   <literal>WHERE</literal> doit être entourée de parenthèses. Voir <xref
   linkend="sql-createpublication"/> pour les détails.
  </para>

  <sect2 id="logical-replication-row-filter-rules">
   <title>Règles des filtres de lignes</title>

   <para>
    Les filtres de lignes sont appliqués <emphasis>avant</emphasis> de publier
    les changements. Si le filtre de ligne est évalué à <literal>false</literal>
    ou <literal>NULL</literal>, alors la ligne n'est pas répliquée. L'expression
    de la clause <literal>WHERE</literal> est évaluée avec le même rôle utilisé
    pour la connexion de réplication (soit le rôle indiqué dans la clause
    <link linkend="sql-createsubscription-params-connection"><literal>CONNECTION</literal></link>
    de l'instruction <xref
    linkend="sql-createsubscription"/>). Les filtres de ligne n'ont pas deffet
    sur la commande <command>TRUNCATE</command>.
   </para>
  </sect2>

  <sect2 id="logical-replication-row-filter-restrictions">
   <title>Restrictions de l'expression</title>

   <para>
    La clause <literal>WHERE</literal> autorise uniquement des expressions simples.
    Elle ne peut pas contenir de fonctions, opérateurs, types et collations
    définis par les utilisateurs, des références aux colonnes système ou à des
    fonctions internes non immutables.
   </para>

   <para>
    Si une publication publie des opérations <command>UPDATE</command> ou
    <command>DELETE</command>, la clause <literal>WHERE</literal> du filtre de
    lignes doit contenir uniquement les colonnes couvertes par l'identité de
    réplica (voir <xref linkend="sql-altertable-replica-identity"/>). Si une
    publication publie uniquement des opérations <command>INSERT</command>, la
    clause <literal>WHERE</literal> du filtre de ligne peut utiliser toute
    colonne.
   </para>
  </sect2>

  <sect2 id="logical-replication-row-filter-transformations">
   <title>Transformations d'un UPDATE</title>

   <para>
    À chaque fois qu'un <command>UPDATE</command> est traité, l'expression du
    filtre de lignes est évaluée pour l'ancienne et la nouvelle ligne (autrement
    dit, en utilisant les données avant et après la mise à jour). Si les deux
    évaluations valent <literal>true</literal>, les modifications de
    l'<command>UPDATE</command> sont répliquées. Si les deux évaluations valent
    <literal>false</literal>, les modifications ne sont pas répliquées. Si
    seulement une des deux évaluations vaut true, la commande
    <command>UPDATE</command> est transformée en <command>INSERT</command> ou
    <command>DELETE</command>, pour éviter toute incohérence de données. La
    ligne sur l'abonné doit refléter ce qui est défini par l'expression de
    filtre de lignes sur le publieur.
   </para>

   <para>
    Si l'ancienne ligne satisfait l'expression du filtre de lignes (elle a été
    envoyée sur l'abonné) contrairement à la nouvelle ligne, alors, d'un point
    de vue de la cohérence des données, l'ancienne ligne devrait être supprimée
    de l'abonné. Donc la commande <command>UPDATE</command> est transformée en
    commande <command>DELETE</command>.
   </para>

   <para>
    Si l'ancienne ligne ne satisfait pas l'expression du filtre de lignes (elle
    n'a pas été envoyée sur l'abonné) contrairement à la nouvelle ligne, alors,
    d'un point de vue de la cohérence des données, la nouvelle ligne doit être
    ajoutée à l'abonné. Donc la commande <command>UPDATE</command> est
    transformée en commande <command>INSERT</command>.
   </para>

   <para>
    <xref linkend="logical-replication-row-filter-transformations-summary"/>
    résume les transformations appliquées.
   </para>

   <table id="logical-replication-row-filter-transformations-summary">
    <title>Résumé des transformations d'un <command>UPDATE</command></title>
    <tgroup cols="3">
    <thead>
     <row>
      <entry>Ancienne ligne</entry>
      <entry>Nouvelle ligne</entry>
      <entry>Transformation</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>pas de correspondance</entry>
      <entry>pas de correspondance</entry>
      <entry>ne réplique pas</entry>
     </row>
     <row>
      <entry>pas de correspondance</entry>
      <entry>correspondance</entry>
      <entry><literal>INSERT</literal></entry>
     </row>
     <row>
      <entry>correspondance</entry>
      <entry>pas de correspondance</entry>
      <entry><literal>DELETE</literal></entry>
     </row>
     <row>
      <entry>correspondance</entry>
      <entry>correspondance</entry>
      <entry><literal>UPDATE</literal></entry>
     </row>
    </tbody>
   </tgroup>
   </table>

  </sect2>

  <sect2 id="logical-replication-row-filter-partitioned-table">
   <title>Tables partitionnées</title>

   <para>
    Si la publication contient une table partitionnée, le paramètre de
    publication <link
    linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>
    détermine le filtre de lignes à utiliser. Si
    <literal>publish_via_partition_root</literal> vaut <literal>true</literal>,
    le filtre de ligne de la <emphasis>table partitionnée racine</emphasis> est
    utilisé. Si <literal>publish_via_partition_root</literal> vaut
    <literal>false</literal> (ce qui est le cas par défaut), le filtre de lignes
    de chaque <emphasis>partition</emphasis> est utilisé.
   </para>

  </sect2>

  <sect2 id="logical-replication-row-filter-initial-data-sync">
   <title>Synchronisation initiale des données</title>

   <para>
    Si la souscription requiert une copie des données pré-existantes de la table
    et qu'une publication contient des clauses <literal>WHERE</literal>, seules
    les données qui satisfont les expressions des filtres de ligne sont copiées
    sur l'abonné.
   </para>

   <para>
    Si la souscription a plusieurs publications dans lesquelles une table a été
    publiée avec différentes clauses <literal>WHERE</literal>, les lignes qui
    satisfont <emphasis>une</emphasis> des expressions seront copiées. Voir
    <xref linkend="logical-replication-row-filter-combining"/> pour les détails.
   </para>

   <warning>
    <para>
     Comme la synchronisation initiale des données ne prend pas en compte le
     paramètre <link
     linkend="sql-createpublication-params-with-publish"><literal>publish</literal></link>
     lors de la copie des données
     pré-existantes de la table, certaines lignes pourraient être copiées alors
     qu'elles n'auraient pas été répliquées avec des instructions DML.
     Référez-vous à <xref linkend="logical-replication-snapshot"/>, et à
     <xref linkend="logical-replication-subscription-examples"/> pour des
     exemples.
    </para>
   </warning>

   <note>
    <para>
     Si l'abonné est d'une version antérieure à la 15, la copie des données
     pré-existantes n'utilise pas les filtres de ligne même s'ils sont définis
     dans la publication. Ceci est dû au fait que les anciennes versions peuvent
     seulement copier les données de la table entière.
    </para>
   </note>

  </sect2>

  <sect2 id="logical-replication-row-filter-combining">
   <title>Combiner plusieurs filtres de lignes</title>

   <para>
    Si la souscription a plusieurs publications pour lesquelles la même table a
    été publiée avec des filtres de lignes différents (pour la même opération
    <link linkend="sql-createpublication-params-with-publish"><literal>publish</literal></link>,
    ces expressions sont assemblées avec un OU
    logique, pour que les lignes satisfaisant au moins <emphasis>une</emphasis>
    expression seront répliquées. Cela signifie que les autres filtres de lignes
    pour la même table deviennent redondants si&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       Une des publications n'a pas de filtres de lignes&nbsp;;
      </para>
     </listitem>
     <listitem>
      <para>
       Une des publications a été créée en utilisant <link
       linkend="sql-createpublication-params-for-all-tables"><literal>FOR ALL
       TABLES</literal></link>. Cette clause n'autorise pas les filtres de
       lignes&nbsp;;
      </para>
     </listitem>
     <listitem>
      <para>
       Une des publications a été créée en utilisant <link
       linkend="sql-createpublication-params-for-tables-in-schema"><literal>FOR TABLES
       IN SCHEMA</literal></link> et la table appartient au schéma référencé.
       Cette clause n'autorise pas les filtres de lignes.
      </para>
     </listitem>
    </itemizedlist></para>
  </sect2>

  <sect2 id="logical-replication-row-filter-examples">
   <title>Exemples</title>

   <para>
    Créer quelques tables à utiliser dans les exemples suivants.
<programlisting>
test_pub=# CREATE TABLE t1(a int, b int, c text, PRIMARY KEY(a,c));
CREATE TABLE
test_pub=# CREATE TABLE t2(d int, e int, f int, PRIMARY KEY(d));
CREATE TABLE
test_pub=# CREATE TABLE t3(g int, h int, i int, PRIMARY KEY(g));
CREATE TABLE
</programlisting></para>

   <para>
    Créer quelques publications. La publication <literal>p1</literal> a une
    table (<literal>t1</literal>) et cette table a un filtre de lignes. La
    publication <literal>p2</literal> a deux tables. La table
    <literal>t1</literal> n'a pas de filtre de lignes, et la table
    <literal>t2</literal> a un filtre de lignes. La publication
    <literal>p3</literal> a deux tables, qui ont toutes les deux un filtre de
    lignes.
<programlisting>
test_pub=# CREATE PUBLICATION p1 FOR TABLE t1 WHERE (a > 5 AND c = 'NSW');
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION p2 FOR TABLE t1, t2 WHERE (e = 99);
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION p3 FOR TABLE t2 WHERE (d = 10), t3 WHERE (g = 10);
CREATE PUBLICATION
</programlisting></para>

   <para>
    <command>psql</command> peut être utilisé pour afficher les expressions
    de filtres de lignes (si défini) pour chaque publication.
<programlisting>
test_pub=# \dRp+
                               Publication p1
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t1" WHERE ((a > 5) AND (c = 'NSW'::text))

                               Publication p2
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t1"
    "public.t2" WHERE (e = 99)

                               Publication p3
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t2" WHERE (d = 10)
    "public.t3" WHERE (g = 10)
</programlisting></para>

   <para>
    <command>psql</command> peut être utilisé pour afficher les expressions des
    filtres de lignes (si défini) pour chaque table. La table
    <literal>t1</literal> est membre de deux publications, mais a un filtre de
    lignes uniquement dans <literal>p1</literal>. La table
    <literal>t2</literal> est membre de deux publications, et a un filtre de
    lignes différent sur chacune.
<programlisting>
test_pub=# \d t1
                 Table "public.t1"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 a      | integer |           | not null |
 b      | integer |           |          |
 c      | text    |           | not null |
Indexes:
    "t1_pkey" PRIMARY KEY, btree (a, c)
Publications:
    "p1" WHERE ((a > 5) AND (c = 'NSW'::text))
    "p2"

test_pub=# \d t2
                 Table "public.t2"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 d      | integer |           | not null |
 e      | integer |           |          |
 f      | integer |           |          |
Indexes:
    "t2_pkey" PRIMARY KEY, btree (d)
Publications:
    "p2" WHERE (e = 99)
    "p3" WHERE (d = 10)

test_pub=# \d t3
                 Table "public.t3"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 g      | integer |           | not null |
 h      | integer |           |          |
 i      | integer |           |          |
Indexes:
    "t3_pkey" PRIMARY KEY, btree (g)
Publications:
    "p3" WHERE (g = 10)
</programlisting></para>

   <para>
    Sur le nœud abonné, créer une table <literal>t1</literal> avec la même
    définition que celle du publieur, et créer aussi la souscription
    <literal>s1</literal> vers la publication <literal>p1</literal>.
<programlisting>
test_sub=# CREATE TABLE t1(a int, b int, c text, PRIMARY KEY(a,c));
CREATE TABLE
test_sub=# CREATE SUBSCRIPTION s1
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=s1'
test_sub-# PUBLICATION p1;
CREATE SUBSCRIPTION
</programlisting></para>

   <para>
    Insérer quelques lignes. Seules les lignes satisfaisant la clause
    <literal>t1 WHERE</literal> de la publication <literal>p1</literal> sont
    répliquées.
<programlisting>
test_pub=# INSERT INTO t1 VALUES (2, 102, 'NSW');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (3, 103, 'QLD');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (4, 104, 'VIC');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (5, 105, 'ACT');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (6, 106, 'NSW');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (7, 107, 'NT');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (8, 108, 'QLD');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (9, 109, 'NSW');
INSERT 0 1

test_pub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 2 | 102 | NSW
 3 | 103 | QLD
 4 | 104 | VIC
 5 | 105 | ACT
 6 | 106 | NSW
 7 | 107 | NT
 8 | 108 | QLD
 9 | 109 | NSW
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 6 | 106 | NSW
 9 | 109 | NSW
(2 rows)
</programlisting></para>

   <para>
    Mettre à jour quelques données, où les valeurs de l'ancienne et de la
    nouvelle ligne satisfont la clause <literal>t1 WHERE</literal> de la
    publication <literal>p1</literal>. La commande <command>UPDATE</command>
    réplique les changements de façon normale.
<programlisting>
test_pub=# UPDATE t1 SET b = 999 WHERE a = 6;
UPDATE 1

test_pub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 2 | 102 | NSW
 3 | 103 | QLD
 4 | 104 | VIC
 5 | 105 | ACT
 7 | 107 | NT
 8 | 108 | QLD
 9 | 109 | NSW
 6 | 999 | NSW
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 9 | 109 | NSW
 6 | 999 | NSW
(2 rows)
</programlisting></para>

   <para>
    Mettre à jour des données de façon à ce que les valeurs de l'ancienne ligne
    ne satisfont pas la clause <literal>t1 WHERE</literal> de la publication
    <literal>p1</literal>, mais que les valeurs de la nouvelle ligne la
    satisfont. La commande <command>UPDATE</command> est transformée en une
    commande <command>INSERT</command> et les changements sont répliqués. Voir
    la nouvelle ligne sur l'abonné.
<programlisting>
test_pub=# UPDATE t1 SET a = 555 WHERE a = 2;
UPDATE 1

test_pub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   3 | 103 | QLD
   4 | 104 | VIC
   5 | 105 | ACT
   7 | 107 | NT
   8 | 108 | QLD
   9 | 109 | NSW
   6 | 999 | NSW
 555 | 102 | NSW
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   9 | 109 | NSW
   6 | 999 | NSW
 555 | 102 | NSW
(3 rows)
</programlisting></para>

   <para>
    Mettre à jour des données de façon à ce que les valeurs de l'ancienne ligne
    satisfont la clause <literal>t1 WHERE</literal> de la publication
    <literal>p1</literal>, mais que les valeurs de la nouvelle ligne ne la
    satisfont pas. La commande <command>UPDATE</command> est transformée en une
    commande <command>DELETE</command> et les changements sont répliqués. Voir
    la nouvelle ligne supprimée sur l'abonné.
<programlisting>
test_pub=# UPDATE t1 SET c = 'VIC' WHERE a = 9;
UPDATE 1

test_pub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   3 | 103 | QLD
   4 | 104 | VIC
   5 | 105 | ACT
   7 | 107 | NT
   8 | 108 | QLD
   6 | 999 | NSW
 555 | 102 | NSW
   9 | 109 | VIC
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   6 | 999 | NSW
 555 | 102 | NSW
(2 rows)
</programlisting></para>

   <para>
    Les exemples suivants montrent comment le paramètre de publication <link
    linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>
    détermine si le filtre de
    ligne de la table parent ou enfant sera utilisé dans le cas de tables
    partitionnées.
   </para>

   <para>
    Créer une table partitionnée sur le publieur.
<programlisting>
test_pub=# CREATE TABLE parent(a int PRIMARY KEY) PARTITION BY RANGE(a);
CREATE TABLE
test_pub=# CREATE TABLE child PARTITION OF parent DEFAULT;
CREATE TABLE
</programlisting>
   Créer les mêmes tables sur l'abonné.
<programlisting>
test_sub=# CREATE TABLE parent(a int PRIMARY KEY) PARTITION BY RANGE(a);
CREATE TABLE
test_sub=# CREATE TABLE child PARTITION OF parent DEFAULT;
CREATE TABLE
</programlisting></para>

   <para>
    Créer une publication <literal>p4</literal>, puis abonnez-vous à cette
    publication. Le paramètre de publication
    <literal>publish_via_partition_root</literal> est configuré à true. Il
    existe des filtres de lignes définis sur la table partitionnée
    (<literal>parent</literal>), et sur sa partition (<literal>child</literal>).
<programlisting>
test_pub=# CREATE PUBLICATION p4 FOR TABLE parent WHERE (a &lt; 5), child WHERE (a >= 5)
test_pub-# WITH (publish_via_partition_root=true);
CREATE PUBLICATION
</programlisting>
<programlisting>
test_sub=# CREATE SUBSCRIPTION s4
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=s4'
test_sub-# PUBLICATION p4;
CREATE SUBSCRIPTION
</programlisting></para>

   <para>
    Insérer quelques valeurs directement dans les tables
    <literal>parent</literal> et <literal>child</literal>. Elles se répliquent
    en utilisant le filtre de lignes de <literal>parent</literal> (parce que
    <literal>publish_via_partition_root</literal> vaut true).
<programlisting>
test_pub=# INSERT INTO parent VALUES (2), (4), (6);
INSERT 0 3
test_pub=# INSERT INTO child VALUES (3), (5), (7);
INSERT 0 3

test_pub=# SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
 5
 6
 7
(6 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
(3 rows)
</programlisting></para>

   <para>
    Répéter le même test, mais avec une valeur différent pour
    <literal>publish_via_partition_root</literal>. Le paramètre de publication
    <literal>publish_via_partition_root</literal> est configuré à false. Un
    filtre de lignes est défini sur la partition (<literal>child</literal>).
<programlisting>
test_pub=# DROP PUBLICATION p4;
DROP PUBLICATION
test_pub=# CREATE PUBLICATION p4 FOR TABLE parent, child WHERE (a >= 5)
test_pub-# WITH (publish_via_partition_root=false);
CREATE PUBLICATION
</programlisting>
<programlisting>
test_sub=# ALTER SUBSCRIPTION s4 REFRESH PUBLICATION;
ALTER SUBSCRIPTION
</programlisting></para>

   <para>
    Faire les insertions sur le publieur de la même façon qu'avant. Elles se
    répliquent en utilisant le filtre de lignes de <literal>child</literal>
    (parce que <literal>publish_via_partition_root</literal> vaut false).
<programlisting>
test_pub=# TRUNCATE parent;
TRUNCATE TABLE
test_pub=# INSERT INTO parent VALUES (2), (4), (6);
INSERT 0 3
test_pub=# INSERT INTO child VALUES (3), (5), (7);
INSERT 0 3

test_pub=# SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
 5
 6
 7
(6 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM child ORDER BY a;
 a
---
 5
 6
 7
(3 rows)
</programlisting></para>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-col-lists">
  <title>Listes de colonnes</title>

  <para>
   Chaque publication peut indiquer en option aux abonnés les colonnes à
   répliquer pour chaque table. La table du côté abonné doit avoir au moins
   toutes les colonnes publiées. Si aucune liste de colonnes n'est indiquée,
   alors toutes les colonnes du côté du publieur sont répliquées. Voir <xref
   linkend="sql-createpublication"/> pour les détails sur la syntaxe.
  </para>

  <para>
   Le choix des colonnes peut être basé sur des raisons de comportement ou de
   performance. Néanmoins, ne vous basez pas sur cette fonctionnalité pour de la
   sécurité&nbsp;: un abonné mal intentionné est capable d'obtenir des données
   des colonnes qui ne sont pas spécifiquement publiées. D'un point de vue
   sécurité, des protections peuvent être mises en place du côté du publieur.
  </para>

  <para>
   Si aucune liste de colonne n'est indiquée, toutes les colonnes ajoutées
   ultérieurement à la table sont automatiquement répliquées. Cela signifie
   qu'avoir une
   liste de colonnes qui nomme toutes les colonnes n'aboutit pas au même
   comportement que ne pas avoir de liste de colonnes.
  </para>

  <para>
   Une liste de colonnes peut contenir seulement des références de colonnes.
   L'ordre des colonnes dans la liste n'est pas préservé.
  </para>

  <para>
   Préciser une liste de colonnes n'est pas possible quand la publication publie
   aussi toutes les tables d'un schéma (clause <link
   linkend="sql-createpublication-params-for-tables-in-schema"><literal>FOR TABLES IN
   SCHEMA</literal></link>).
  </para>

  <para>
   Pour les tables partitionnées, le paramètre de publication <link
   linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>
   détermine quel liste de
   colonnes utiliser. Si <literal>publish_via_partition_root</literal> vaut
   <literal>true</literal>, la liste de colonnes utilisée est celle de la table
   partitionnée. Sinon, si <literal>publish_via_partition_root</literal> vaut
   <literal>false</literal> (valeur par défaut), la liste de colonnes utilisée
   est celle de la partition concernée.
  </para>

  <para>
   Si une publication publie des opérations <command>UPDATE</command> ou
   <command>DELETE</command>, toute liste de colonnes doit inclure les colonnes
   d'identité de réplica de la table (voir <xref
   linkend="sql-altertable-replica-identity"/>). Si une publication publie
   seulement des opérations <command>INSERT</command>, alors la liste de
   colonnes peut omettre les colonnes d'identité de réplica.
  </para>

  <para>
   Les listes de colonnes n'ont pas d'effet sur la commande
   <literal>TRUNCATE</literal>.
  </para>

  <para>
   Lors de la synchronisation initiale des données, seules les colonnes publiées
   sont copiées. Néanmoins, si l'abonné est d'une version antérieure à la 15,
   alors toutes les colonnes dans la table sont copiées lors de la
   synchronisation initiale des données, ignorant en cela les liste de colonnes.
  </para>

  <warning id="logical-replication-col-list-combining">
   <title>Attention&nbsp;: Combiner des listes de plusieurs publications</title>
   <para>
    Actuellement, il n'est pas possible qu'une souscription soit entreprise
    auprès de plusieurs publications quand la même table a été publiée avec des
    listes de colonnes différentes. <xref linkend="sql-createsubscription"/>
    interdit la création de telles souscriptions mais il est toujours possible
    d'arriver dans cette situation par l'ajout ou la modification de listes de
    colonnes du côté publication une fois que la souscription a été créée.
   </para>
   <para>
    Ceci signifie que la modification de liste de colonnes sur les publications
    déjà souscrites peut amener à des erreurs du côté souscripteur.
   </para>
   <para>
    Si ce problème affecte une souscription, la seule façon de reprendre la
    réplication est d'ajuster une des listes de colonnes côté publication pour
    que les listes correspondent&nbsp;; puis soit de créer de nouveau la
    souscription, soit utiliser <link
    linkend="sql-altersubscription-params-setadddrop-publication">
    <literal>ALTER SUBSCRIPTION ... DROP PUBLICATION</literal></link> pour supprimer
    une des publications problématiques et l'ajouter de nouveau après.
   </para>
  </warning>

  <sect2 id="logical-replication-col-list-examples">
   <title>Exemples</title>

   <para>
    Créer une table <literal>t1</literal> à utiliser dans l'exemple suivant.
<programlisting>
test_pub=# CREATE TABLE t1(id int, a text, b text, c text, d text, e text, PRIMARY KEY(id));
CREATE TABLE
</programlisting></para>

   <para>
    Créer une publication <literal>p1</literal>. Une liste de colonnes est
    définie pour la table <literal>t1</literal> pour réduire le nombre de
    colonnes qui seront répliquées. Notez que l'ordre des noms de colonnes dans
    la liste de colonnes n'a pas d'importance.
<programlisting>
test_pub=# CREATE PUBLICATION p1 FOR TABLE t1 (id, b, a, d);
CREATE PUBLICATION
</programlisting></para>

    <para>
     <literal>psql</literal> peut être utilisé pour afficher les listes de
     colonnes (si définies) pour chaque publication.
<programlisting>
test_pub=# \dRp+
                               Publication p1
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t1" (id, a, b, d)
</programlisting></para>

    <para>
     <literal>psql</literal> peut être utilisé pour afficher les listes de
     colonnes (si définies) pour chaque table.
<programlisting>
test_pub=# \d t1
                 Table "public.t1"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 id     | integer |           | not null |
 a      | text    |           |          |
 b      | text    |           |          |
 c      | text    |           |          |
 d      | text    |           |          |
 e      | text    |           |          |
Indexes:
    "t1_pkey" PRIMARY KEY, btree (id)
Publications:
    "p1" (id, a, b, d)
</programlisting></para>

    <para>
     Sur le nœud abonné, créer une table <literal>t1</literal> qui maintenant a
     seulement besoin d'un sous-ensemble des colonnes qui sont sur la table côté
     publieur <literal>t1</literal>, et crée aussi l'abonnement
     <literal>s1</literal> qui cible la publication <literal>p1</literal>.
<programlisting>
test_sub=# CREATE TABLE t1(id int, b text, a text, d text, PRIMARY KEY(id));
CREATE TABLE
test_sub=# CREATE SUBSCRIPTION s1
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=s1'
test_sub-# PUBLICATION p1;
CREATE SUBSCRIPTION
</programlisting></para>

    <para>
     Sur le nœud publieur, insérer quelques lignes dans la table
     <literal>t1</literal>.
<programlisting>
test_pub=# INSERT INTO t1 VALUES(1, 'a-1', 'b-1', 'c-1', 'd-1', 'e-1');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES(2, 'a-2', 'b-2', 'c-2', 'd-2', 'e-2');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES(3, 'a-3', 'b-3', 'c-3', 'd-3', 'e-3');
INSERT 0 1
test_pub=# SELECT * FROM t1 ORDER BY id;
 id |  a  |  b  |  c  |  d  |  e
----+-----+-----+-----+-----+-----
  1 | a-1 | b-1 | c-1 | d-1 | e-1
  2 | a-2 | b-2 | c-2 | d-2 | e-2
  3 | a-3 | b-3 | c-3 | d-3 | e-3
(3 rows)
</programlisting></para>

    <para>
     Seules les données de la liste de colonnes de la publication
     <literal>p1</literal> sont répliquées.
<programlisting>
test_sub=# SELECT * FROM t1 ORDER BY id;
 id |  b  |  a  |  d
----+-----+-----+-----
  1 | b-1 | a-1 | d-1
  2 | b-2 | a-2 | d-2
  3 | b-3 | a-3 | d-3
(3 rows)
</programlisting></para>

  </sect2>

 </sect1>

 <sect1 id="logical-replication-conflicts">
  <title>Conflits</title>

  <para>
   La réplication logique se comporte de la même manière pour les opérations DML
   dans le sens où les données seront mises à jour même si la modification a été
   faite en local sur la base abonnée. Si les données entrantes entrainent des
   violations de contrainte d'intégrité, la réplication s'arrête. Cela sera
   référencé comme un <firstterm>conflit</firstterm>. Lorsque l'on réplique des
   opérations <command>UPDATE</command> ou <command>DELETE</command>, les
   données manquantes ne produiront pas de conflit et des opérations de la sorte
   seront simplement évitées.
  </para>

  <para>
   Les opérations de réplication logique sont réalisées avec les droits du
   propriétaire de la souscription. Les échecs de droit sur les tables cibles
   causeront des conflits de réplication, tout autant que l'activation de <link
   linkend="ddl-rowsecurity">politiques de sécurité au niveau ligne</link> sur
   des tables cibles et pour lesquels le propriétaire de la souscription est
   sujet des politiques de sécurité, sans chercher si une politique rejetterait
   habituellement les opérations <command>INSERT</command>,
   <command>UPDATE</command>, <command>DELETE</command> ou
   <command>TRUNCATE</command> en cours de réplication. Cette restriction sur
   les politiques de sécurité niveau ligne pourrait être supprimée dans une
   prochaine version de <productname>PostgreSQL</productname>.
  </para>

  <para>
   Lorsqu'un conflit entraine une erreur, cela stoppe la réplication&nbsp;; Le
   conflit devra être résolu manuellement par un utilisateur. Des informations
   détaillées concernant le conflit seront disponibles dans les journaux
   applicatifs de l'instance abonnée.
  </para>

  <para>
   La résolution peut être réalisée, soit en changeant les données ou les droits
   sur la base abonnée pour qu'elles ne soient plus en conflit avec les données
   entrantes ou en évitant les transactions qui sont en conflit avec les données
   existantes. Quand un conflit produit une erreur, la réplication ne peut pas
   continuer et le processus worker de la réplication logique émet un message du
   type suivant dans les journaux applicatifs de l'abonné&nbsp;:
<screen>
ERROR:  duplicate key value violates unique constraint "test_pkey"
DETAIL:  Key (c)=(1) already exists.
CONTEXT:  processing remote data for replication origin "pg_16395" during "INSERT" for replication target relation "public.test" in transaction 725 finished at 0/14C0378
</screen>
   Le LSN de la transaction qui contient le changement violant la contrainte et
   le nom d'origine de réplication peuvent être trouvés à partir du journal
   applicatif du serveur (LSN 0/14C0378 et origine de réplication
   <literal>pg_16395</literal> dans le cas ci-dessus). La transaction qui a
   produit le conflit peut être ignorée en utilisant l'instruction
   <link linkend="sql-altersubscription-params-skip"><command>ALTER SUBSCRIPTION
    ... SKIP</command></link> avec le LSN final (LSN
   0/14C0378). Le LSN final pourrait être un LSN sur lequel la transaction est
   validée ou préparée sur le publieur. La transaction peut aussi être ignorée
   en appelant la fonction <link
   linkend="pg-replication-origin-advance"><function>pg_replication_origin_advance()</function></link>.
   Avant d'utiliser cette fonction, la souscription doit être désactivée
   temporairement soit par <link linkend="sql-altersubscription-params-disable">
   <command>ALTER SUBSCRIPTION ... DISABLE</command></link>
   soit en utilisant l'option <link
   linkend="sql-createsubscription-params-with-disable-on-error"><literal>disable_on_error</literal></link>
   de la souscription. Ensuite, vous pouvez utiliser la fonction
   <function>pg_replication_origin_advance()</function> avec
   <parameter>node_name</parameter> (<literal>pg_16395</literal>) et le LSN
   suivant du LSN final (0/14C0379). La position actuelle des origines peut être
   trouvée dans la vue système <link
   linkend="view-pg-replication-origin-status"><structname>pg_replication_origin_status</structname></link>.
   Merci de noter qu'ignorer la transaction complète inclut d'ignorer des
   changements qui pourraient ne pas violer des contraintes. Ceci peut rendre
   l'abonné incohérent très facilement.
  </para>

  <para>
   Quand le mode <link linkend="sql-createsubscription-params-with-streaming"><literal>streaming</literal></link>
   vaut <literal>parallel</literal>, le LSN final des transactions en échec peut ne pas être
   journalisé. Dans ce cas, il peut être nécessaire de changer le mode
   de flux (streaming) à <literal>on</literal> ou <literal>off</literal> et provoquer
   les même conflits encore pour que le LSN final des transactions échouées soit écrit dans
   le journal du serveur. Pour l'utilisation du LSN final, veuillez vous reférer à
   <link
   linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION ... SKIP</command></link>.
  </para>
 </sect1>

 <sect1 id="logical-replication-restrictions">
  <title>Restrictions</title>

  <para>
   La réplication logique souffre actuellement des restrictions ou des
   fonctionnalités manquantes suivantes. Elles pourraient être adressées dans
   les prochaines versions.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     La structure de la base de données et les commandes DDL ne sont pas
     répliquées. Le schéma initial peut être copié à la main en utilisant la
     commande <literal>pg_dump --schema-only</literal>. Les modifications de
     schéma suivantes auront besoin d'être synchronisées manuellement. (Notez,
     néanmoins, qu'il n'est pas nécessaire que les schémas soient strictement
     identiques des deux côtés.) La réplication logique est robuste quand il y a
     des modifications de schéma dans une base de données. Quand le schéma est
     changé sur le publieur et les données répliquées commencent à arriver sur
     l'abonné mais ne correspondent pas à la structure de la table, la
     réplication renverra une erreur jusqu'à ce que le schéma soit mis à jour.
     Dans de nombreux cas, les erreurs intermittentes peuvent être évitées en
     appliquant des modifications de schéma à l'abonné en premier&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Les données des séquences ne sont pas répliquées. Les données des colonnes
     de type serial et des colonnes identité, gérées par des séquences, seront
     bien sûr répliquées comme faisant partie de la table, mais la séquence
     elle-même affichera toujours la valeur de démarrage sur l'abonné. Si
     l'abonné est utilisé comme une base de données en lecture seule, alors cela
     ne devrait pas être un problème. Néanmoins, s'il est nécessaire de faire un
     bascule (<foreignphrase>switchover</foreignphrase> ou
     <foreignphrase>failover</foreignphrase> sur la base de données abonnée,
     alors les séquences auront besoin d'être mises à jour à leur dernières
     valeurs, soit en copiant les données courantes du publieur (peut-être en
     utilisant <command>pg_dump</command>), soit en déterminant une valeur
     suffisamment haute à partir des données de la table&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     La réplication des commandes <command>TRUNCATE</command> est supportée mais
     il est nécessaire de prêter attention lors de l'utilisation de cette
     commande sur des groupes de tables connectés par des clés étrangères. Lors
     de la réplication d'une action truncate, l'abonné tronquera le même groupe
     de tables tronquées sur le publieur, qu'elles soient spécifiées
     explicitement ou implicitement (grâce à la clause
     <literal>CASCADE</literal>), moins les tables qui ne font pas partie de la
     souscription. Ceci fonctionnera correctement si toutes les tables affectées
     font partie de la même souscription. Cependant, si certaines tables à
     tronquer ont des clés étrangères vers des tables qui ne font pas partie de
     la même souscription, alors l'application de l'action truncate échouera sur
     le serveur abonné&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Les Large Objects (voir <xref linkend="largeobjects"/>) ne sont pas
     répliqués. Il n'y a pas de contournement pour ça, en dehors d'enregistrer
     les données dans des tables normales&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     La réplication est seulement supportée par les tables, y compris les tables
     partitionnées. Toute tentative de répliquer d'autres types de relation,
     comme les vues, les vues matérialisées ou les tables externes, résultera en
     une erreur&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     Lors de la réplication entre tables partitionnées, la réplication actuelle
     a pour origine, par défaut, les partitions filles sur le publieur, donc les
     partitions sur le publieur doivent exister aussi sur l'abonné en tant que
     tables cibles valides. Elles peuvent être soit des partitions filles
     elles-mêmes, soit de nouveau sous-partitionnées, soit des tables
     indépendantes. Les publications peuvent aussi spécifier les changements à
     répliquer en utilisant l'identité et le schéma de la table racine
     partitionnée au lieu de chaque partition individuelle à l'origine des
     changements (voir le paramètre
     <link linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>
     de <command>CREATE PUBLICATION</command>).
    </para>
   </listitem>

   <listitem>
    <para>
     Lors de l'utilisation de <link
     linkend="sql-altertable-replica-identity-full"><literal>REPLICA IDENTITY
     FULL</literal></link> sur les tables publiées, il est important de noter
     que les opérations <literal>UPDATE</literal> et <literal>DELETE</literal>
     ne peuvent être appliquées aux abonnés si les tables incluent des
     attributs avec les types de données (tels que point ou box) qui n'ont pas
     une classe d'opérateurs par défaut pour les méthodes B-tree ou Hash.
     Néanmoins, cette limitation peut être contournée en s'assurant que la
     table a une clé primaire ou une identité de réplica.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="logical-replication-architecture">
  <title>Architecture</title>

  <para>
   La réplication logique démarre en copiant un instantané des données sur la
   base de publication. Une fois cette étape réalisée, les modifications sur la
   base de publication sont envoyées à la base de données abonnée au fil de
   l'eau. La base abonnée applique les modifications sur les données dans
   l'ordre dans lequel les validations ont été effectuées sur la base éditeur de
   manière à ce que la cohérence transactionnelle soit respectée pour les
   publications vis à vis de tous les abonnements.
  </para>

  <para>
   La réplication se construit de façon similaire à la réplication physique en
   flux (<foreignphrase>Streaming Replication</foreignphrase>, voir <xref
   linkend="streaming-replication"/>). Ceci est implémenté par les processus
   <literal>walsender</literal> et <literal>apply</literal>. Le processus walsender
   démarre le décodage logique (décrit dans la section <xref
   linkend="protocol-logical-replication"/>) des fichiers WAL et charge le
   plugin de décodage logique standard (<literal>pgoutput</literal>). Ce plugin
   transforme les
   changements lus depuis les fichiers WAL vers le protocole de réplication
   logique (voir <xref linkend="protocol-logical-replication"/>) et filtre les
   données en fonction des spécificités des publications. Les données sont
   envoyées au fil de l'eau au processus apply, qui met en relation les données
   vers les tables locales et applique les changements individuels au moment où
   ils sont reçus, dans le bon ordre transactionnel.
  </para>

  <para>
   Le processus apply sur l'instance de la base abonnée fonctionne toujours avec
   le paramètre <varname>session_replication_role</varname> défini à la valeur
   <literal>replica</literal>, qui produit les effets habituels sur les triggers
   et les contraintes.
  </para>

  <para>
   Le processus apply de la réplication logique déclenche actuellement des
   triggers de ligne, et non pas des triggers de requêtes. Néanmoins, la
   synchronisation initiale des tables est implémentée comme une commande
   <command>COPY</command>, ce qui peut déclencher les triggers
   <command>INSERT</command> en mode ligne et requête.
  </para>

  <sect2 id="logical-replication-snapshot">
   <title>Instantané initial</title>

   <para>
    Les données initiales présentes dans des tables abonnées sont photographiées
    et copiées dans une instance parallèle qui utilise un type particulier de
    processus apply. Ce processus va créer son propre slot de réplication et
    copier les données existantes. Dès que la copie est terminée, le contenu de
    la table deviendra visible aux autres processus. Une fois les données
    existantes copiées, le processus passe en mode de synchronisation, qui
    assure que la table est amenée vers un état synchronisé avec le processus
    apply principal, ceci en transférant toutes les modifications survenues
    pendant la copie initiale des données, réalisée avec le système de
    réplication logique standard. Lors de cette phase de synchronisation, les
    changements sont appliqués et validés dans le même ordre que sur le
    publieur. Une fois la synchronisation terminée, le contrôle de la
    réplication de la table est rendu au processus apply principal et la
    réplication continue telle quelle.
   </para>

   <note>
    <para>
     Le paramètre de publication  <link
     linkend="sql-createpublication-params-with-publish"><literal>publish</literal></link>
     affecte uniquement
     les opérations DML qui seront répliquées. La synchronisation initiale des
     données ne prend pas ce paramètre en compte lors de la copie des données
     existantes de la table.
    </para>
   </note>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-monitoring">
  <title>Supervision</title>

  <para>
   Puisque la réplication logique est basée sur une architecture similaire à la
   <link linkend="streaming-replication">réplication physique en flux</link>, la
   supervision d'une instance publication est similaire à la supervision d'une
   instance primaire dans la réplication physique (voir <xref
   linkend="streaming-replication-monitoring"/>).
  </para>

  <para>
   Les informations des abonnements sont consultables dans la vue <link
   linkend="monitoring-pg-stat-subscription"><structname>pg_stat_subscription</structname></link>.
   Cette vue contient une ligne pour chaque processus d'abonnement. Un
   abonnement peut avoir zéro ou plusieurs processus abonnés, selon son état.
  </para>

  <para>
   Normalement il y a un seul processus apply démarré pour un abonnement actif.
   Un abonnement désactivé ou une publication effondrée n'aura pas de ligne dans
   cette vue. Si la synchronisation initiale d'une table est en cours, il y
   aura des processus supplémentaires pour les tables en cours de
   synchronisation. En outre, si la transaction
   <link linkend="sql-createsubscription-params-with-streaming"><literal>streaming</literal></link>
   est appliquée en parallèle, il y aura des processus apply parallèles supplémentaires.
  </para>
 </sect1>

 <sect1 id="logical-replication-security">
  <title>Sécurité</title>

  <para>
   Le rôle utilisée pour la réplication doit avoir l'attribut
   <literal>REPLICATION</literal> (ou être un superutilisateur). Si le rôle ne
   dispose pas des attributs <literal>SUPERUSER</literal> et
   <literal>BYPASSRLS</literal>, les politiques de sécurité niveau ligne du
   publieur peuvent s'exécuter. Si le rôle n'a pas confiance en tous les
   propriétaires de tables, incluez
   <literal>options=-crow_security=off</literal> dans la chaîne de
   connexion&nbsp;;: si un propriétaire de table ajoute ensuite une politique de
   sécurité de ligne, cette configuration imposera un arrêt de la réplication
   plutôt qu'une exécution de la politique. L'accès de ce rôle à l'instance doit
   avoir été déclaré dans <filename>pg_hba.conf</filename> et ce rôle doit avoir
   l'attribut <literal>LOGIN</literal>.
  </para>

  <para>
   Pour être capable de copier les données originales de la table, le rôle
   utilisé pour la connexion de réplication doit avoir le droit
   <literal>SELECT</literal> sur une table publiée (ou être un
   superutilisateur).
  </para>

  <para>
   Pour créer une publication, l'utilisateur doit avoir le droit
   <literal>CREATE</literal> pour la base de données.
  </para>

  <para>
   Pour ajouter des tables à une publication, l'utilisateur doit être
   propriétaire de ces tables. Pour ajouter toutes les tables d'un schéma dans
   une publication, l'utilisateur doit avoir l'attribut
   <literal>SUPERUSER</literal>. Pour créer une publication qui publie toutes
   les tables ou toutes les tables d'un schéma automatiquement, l'utilisateur
   doit avoir l'attribut <literal>SUPERUSER</literal>.
  </para>

  <para>
   Actuellement, il n'y a aucun droit sur les abonnements. Tout abonnement (qui
   est capable de se connecter) peut accéder à n'importe quelle publication. Ainsi,
   si vous avez l'intention de cacher certaines informations à certains abonnés, en utilisant
   le filtrage de ligne ou les listes de colonnes, ou en n'ajoutant pas la totalité de la table
   à la publication, soyez averti que les autres publications dans la même base de données
   pourront exposer les mêmes informations. Les droits de publication pourront être
   ajoutés à <productname>PostgreSQL</productname> dans le futur pour permettre un
   contrôle d'accès plus fin.
  </para>

  <para>
   Pour créer un abonnement, l'utilisateur doit avoir les droits du
   rôle <literal>pg_create_subscription</literal> ainsi que le droit
   <literal>CREATE</literal> sur la base de données.
  </para>

  <para>
   Le processus d'application de l'abonnement va, au niveau de la session, s'exécuter
   avec les droits du propriétaire de l'abonnement. Cependant, quand une opération
   d'insertion, de mise à jour, de suppression ou de troncation est effectuée sur
   un table donnée, le rôle sera interverti avec celui du propriétaire de la table
   et l'opération effectuée avec les droits du propriétaire de la table.
   Cela signifie que le propriétaire de l'abonnement doit pouvoir faire un
   <literal>SET ROLE</literal> sur chacun des rôles propriétaires des tables répliquées.
  </para>

  <para>
   Si l'abonnement a été configuré avec <literal>run_as_owner = true</literal>,
   alors aucun changement d'utilisateur ne sera possible. À la place,
   les opérations seront effectuées avec les droits du propriétaire de l'abonnement.
   Dans ce cas, le propriétaire de l'abonnement nécessite seulement des droits
   pour <literal>SELECT</literal>, <literal>INSERT</literal>,
   <literal>UPDATE</literal> et <literal>DELETE</literal> sur les tables cibles,
   et n'a pas besoin de droits pour faire un <literal>SET ROLE</literal> sur
   les propriétaires des tables. Cependant, cela implique aussi que n'importe
   quel utilisateur propriétaire de table sur laquelle la réplication s'applique,
   pourra exécuter du code arbitrairement avec les droits du propriétaire de
   l'abonnement. Par exemple, ils pourront effectuer cela simplement en
   attachant un trigger à une des tables dont ils sont propriétaires.
   Parce qu'il est fortement indésirable de permettre à un rôle d'assumer librement
   les droits d'un autre, cette option devrait être évitée sauf si la sécurité
   de la base de données n'est pas un problème.
  </para>

  <para>
   Sur le publieur, les droits sont vérifiés uniquement au démarrage de la
   connexion de réplication et ne sont pas vérifiés de nouveau à chaque fois
   qu'un enregistrement de changement est lu.
  </para>

  <para>
   Sur l'abonné, les droits du propriétaire de la souscription sont vérifiés à
   chaque application d'une transaction. Si un processus worker est en cours de
   traitement pour appliquer une transaction au moment où le propriétaire de la
   souscription est changé dans une transaction concurrente, l'application de la
   transaction en cours continuera sous les droits de l'ancien propriétaire.
  </para>
 </sect1>

 <sect1 id="logical-replication-config">
  <title>Paramètres de configuration</title>

  <para>
   La réplication logique requiert de nombreuses configurations pour
   fonctionner. La plupart des options ne sont pertinentes que d'un côté de la réplication.
   Cependant, <varname>max_replication_slots</varname> est utilisée aussi bien sur le publieur
   que sur l'abonné, mais a une différente signification pour chacun.
  </para>

  <sect2 id="logical-replication-config-publisher">
   <title>Publieurs</title>

   <para>
    <link linkend="guc-wal-level"><varname>wal_level</varname></link> doit être
    mis à <literal>logical</literal>.
   </para>

   <para>
    <link linkend="guc-max-replication-slots"><varname>max_replication_slots</varname></link>
    doit être mis au moins au nombre d'abonnements attendus de se connecter, plus
    une réserve pour la synchronisation des tables.
   </para>

   <para>
    <link linkend="guc-max-wal-senders"><varname>max_wal_senders</varname></link>
    doit être mis à au moins la même valeur que <varname>max_replication_slots</varname>, plus le nombre de
    réplicas physiques qui sont connectés en même temps.
   </para>

   <para>
    Le walsender de réplication logique est aussi impacté par
    <link linkend="guc-wal-sender-timeout"><varname>wal_sender_timeout</varname></link>.
   </para>

  </sect2>

  <sect2 id="logical-replication-config-subscriber">
   <title>Abonnés</title>

   <para>
    <link linkend="guc-max-replication-slots-subscriber"><varname>max_replication_slots</varname></link>
    doit être mis à au moins le nombre d'abonnements qui seront ajoutés à l'abonné, plus une réserve
    pour la synchronisation des tables.
   </para>

   <para>
    <link linkend="guc-max-logical-replication-workers"><varname>max_logical_replication_workers</varname></link>
    doit être mis à au moins le nombre d'abonnements (pour les processus apply leader),
    plus une réserve pour les processus de synchronisation des tables et les processus apply parallèles.
   </para>

   <para>
    <link linkend="guc-max-worker-processes"><varname>max_worker_processes</varname></link>
    peut être ajusté pour accommoder les processus de réplication, au moins
    (<link linkend="guc-max-logical-replication-workers"><varname>max_logical_replication_workers</varname></link>
    <literal>1</literal>). Notez que certaines extensions et requêtes parallèles puisent aussi
    des slots de processus dans <varname>max_worker_processes</varname>.
   </para>

   <para>
    <link linkend="guc-max-sync-workers-per-subscription"><varname>max_sync_workers_per_subscription</varname></link>
    contrôle la quantité de parallélisme lors de la copie initiale des données lors de
    l'initialisation de l'abonnement ou quand des nouvelles tables sont ajoutées.
   </para>

   <para>
    <link linkend="guc-max-parallel-apply-workers-per-subscription"><varname>max_parallel_apply_workers_per_subscription</varname></link>
    contrôle la quantité de parallélisme pour le flux des transaction en cours avec
    le paramètre d'abonnement <literal>streaming = parallel</literal>.
   </para>

   <para>
    Les processus de réplication logique sont aussi affectés par
    <link linkend="guc-wal-receiver-timeout"><varname>wal_receiver_timeout</varname></link>,
    <link linkend="guc-wal-receiver-status-interval"><varname>wal_receiver_status_interval</varname></link> et
    <link linkend="guc-wal-retrieve-retry-interval"><varname>wal_retrieve_retry_interval</varname></link>.
   </para>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-quick-setup">
  <title>Démarrage rapide</title>

  <para>
   En premier, définissez les options de configurations dans le fichier
   <filename>postgresql.conf</filename>&nbsp;:
   <programlisting>wal_level = logical</programlisting>
   La valeur par défaut des autres paramètres est suffisante pour une mise en
   place de base.
  </para>

  <para>
   Le fichier <filename>pg_hba.conf</filename> doit être mis à jour pour
   autoriser la réplication (les valeurs dépendent de la configuration réelle de
   votre réseau et de l'utilisateur dont vous disposerez pour vous
   connecter)&nbsp;:
   <programlisting>host     all     repuser     0.0.0.0/0     md5</programlisting>
  </para>

  <para>
   Ensuite sur la base du publieur&nbsp;:
   <programlisting>
CREATE PUBLICATION mypub FOR TABLE users, departments;
   </programlisting>
  </para>

  <para>
   Et sur la base abonnée&nbsp;:
   <programlisting>
CREATE SUBSCRIPTION mysub CONNECTION 'dbname=foo host=bar user=repuser' PUBLICATION mypub;
   </programlisting>
  </para>

  <para>
   Les instructions précédentes vont démarrer le processus de réplication, qui
   va réaliser la synchronisation initiale du contenu des tables
   <literal>users</literal> et <literal>departments</literal> et qui commencera
   ensuite à répliquer les changements de manière incrémentale sur ces tables.
  </para>
 </sect1>
</chapter>
