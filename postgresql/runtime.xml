<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="runtime">
 <title>Configuration du serveur et mise en place</title>

 <para>
  Ce chapitre discute de la configuration, du lancement du serveur de bases de
  données et de ses interactions avec le système d'exploitation.
 </para>

 <sect1 id="postgres-user">
  <title>Compte utilisateur <productname>PostgreSQL</productname></title>

  <indexterm>
   <primary>utilisateur postgres</primary>
  </indexterm>

  <para>
   Comme avec tout démon serveur accessible au monde externe, il est
   conseillé de lancer <productname>PostgreSQL</productname> sous un compte
   utilisateur séparé. Ce compte devrait seulement être le propriétaire des
   données gérées par le serveur et ne devrait pas être partagé avec d'autres
   démons (par exemple, utiliser l'utilisateur <literal>nobody</literal> est
   une mauvaise idée). Il n'est pas conseillé de changer le propriétaire des
   exécutables par cet utilisateur car les systèmes compromis pourraient alors
   se voir modifier leur propres binaires.
  </para>

  <para>
   Pour ajouter un compte utilisateur Unix, jetez un &oelig;il à la commande
   <command>useradd</command> ou <command>adduser</command> de votre système.
   Le nom de l'utilisateur <systemitem>postgres</systemitem> est souvent utilisé
   et l'est sur tout le livre, mais vous pouvez utiliser un autre nom si vous le
   souhaitez.
  </para>
 </sect1>

 <sect1 id="creating-cluster">
  <title>Créer un groupe de base de données</title>

  <indexterm>
   <primary>groupe de bases de données</primary>
  </indexterm>

  <indexterm>
   <primary>emplacement des données</primary>
   <see>groupe de bases de données</see>
  </indexterm>

  <para>
   Avant de faire quoi que ce soit, vous devez initialiser un emplacement de
   stockage pour la base de données. Nous appelons ceci un <firstterm>groupe de
   bases de données</firstterm> (<acronym>sql</acronym> utilise
   le terme de groupe de catalogues). Un groupe de bases de données est une
   collection de bases données et est géré par une seule instance d'un
   serveur de bases de données en cours d'exécution. Après initialisation, un
   groupe de bases de données contiendra une base de données nommée
   <literal>postgres</literal>, qui a pour but d'être la base de données par
   défaut utilisée par les outils, les utilisateurs et les applications
   tiers. Le serveur de la base de données lui-même ne requiert pas la présence
   de la base de données <literal>postgres</literal> mais beaucoup d'outils
   supposent son existence. Une autre base de données est créée à l'intérieur
   de chaque groupe lors de l'initialisation. Elle est appelée
   <literal>template1</literal>. Comme le nom le suggère, elle sera utilisée
   comme modèle pour les bases de données créées après&nbsp;; elle ne devrait
   pas être utilisée pour un vrai travail (voir le <xref
   linkend="managing-databases"/> pour des informations sur la création de
   nouvelles bases de données dans le groupe).
  </para>

  <para>
   En terme de système de fichiers, un groupe de bases de données sera un
   simple répertoire sous lequel les données seront stockées. Nous l'appelons le
   <firstterm>répertoire de données</firstterm> ou l'<firstterm>emplacement des
   données</firstterm>. Le choix de cet emplacement vous appartient complètement.
   Il n'existe pas de valeur par défaut bien que les emplacements tels que
   <filename>/usr/local/pgsql/data</filename> ou
   <filename>/var/lib/pgsql/data</filename> sont populaires. Pour initialiser un
   groupe de bases de données, utilisez la commande <xref
   linkend="app-initdb"/>,<indexterm><primary>initdb</primary></indexterm> installée avec
   <productname>PostgreSQL</productname>. L'emplacement désiré sur le groupe de
   fichier est indiqué par l'option <option>-d</option>, par exemple
<screen><prompt>$</prompt> <userinput>initdb -D /usr/local/pgsql/data</userinput></screen>
   Notez que vous devez exécuter cette commande en étant connecté sous le compte
   de l'utilisateur <productname>PostgreSQL</productname> décrit dans la section
   précédente.
  </para>

  <tip>
   <para>
    Comme alternative à l'option <option>-d</option>, vous pouvez initialiser
    la variable d'environnement <envar>pgdata</envar>.
    <indexterm><primary><envar>pgdata</envar></primary></indexterm>
   </para>
  </tip>

  <para>
   Autrement, vous pouvez exécuter <command>initdb</command> via le programme
   <xref linkend="app-pg-ctl"/><indexterm><primary>pg_ctl</primary></indexterm>
   ainsi&nbsp;:
<screen>
<prompt>$</prompt> <userinput>pg_ctl -D /usr/local/pgsql/data initdb</userinput>
</screen>
   C'est peut-être plus intuitif si vous utilisez déjà
   <command>pg_ctl</command> pour démarrer et arrêter le serveur (voir <xref
   linkend="server-start"/> pour les détails). Un gros intérêt est de ne
   connaître que cette seule commande pour gérer l'instance du serveur de
   bases de données.
  </para>

  <para>
   <command>initdb</command> tentera de créer le répertoire que vous avez
   spécifié si celui-ci n'existe pas déjà. Il est possible qu'il n'ait pas le
   droit de le faire (si vous avez suivi notre conseil et créé un compte sans
   droits). Dans ce cas, vous devez créer le répertoire vous-même (en tant que
   root) et modifier le propriétaire pour qu'il corresponde à l'utilisateur
   <productname>PostgreSQL</productname>. Voici comment réaliser ceci&nbsp;:
<screen>root# <userinput>mkdir /usr/local/pgsql/data</userinput>
root# <userinput>chown postgres /usr/local/pgsql/data</userinput>
root# <userinput>su postgres</userinput>
postgres$ <userinput>initdb -D /usr/local/pgsql/data</userinput></screen>
  </para>

  <para>
   <command>initdb</command> refusera de s'exécuter si le répertoire des données
   semble être déjà initialisé.</para>

  <para>
   Comme le répertoire des données contient toutes les données stockées par 
   le système de bases de données, il est essentiel qu'il soit sécurisé par
   rapport à des accès non autorisés. Du coup, <command>initdb</command>
   supprimera les droits d'accès à tout le monde sauf l'utilisateur
   <productname>PostgreSQL</productname>.
  </para>

  <para>
   Néanmoins, bien que le contenu du répertoire soit sécurisé, la configuration
   d'authentification du client par défaut permet à tout utilisateur local de se
   connecter à la base de données et même à devenir le super-utilisateur de
   la base de données. Si vous ne faites pas confiance aux utilisateurs
   locaux, nous vous recommandons d'utiliser une des options <option>-w</option> ou
   <option>--pwprompt</option> de la commande <command>initdb</command> pour
   affecter un mot de passe au super-utilisateur de la base de
   données <indexterm><primary>mot de passe</primary><secondary>du
   super-utilisateur</secondary></indexterm>. De plus, spécifiez <option>-a md5</option> ou
   <option>-a mot_de_passe</option> de façon à ce que la méthode d'authentification
   <literal>trust</literal> par défaut ne soit pas utilisée&nbsp;; ou modifiez le fichier
   <filename>pg_hba.conf</filename> généré après l'exécution
   d'<command>initdb</command> (d'autres
   approches raisonnables incluent l'utilisation de l'authentification
   <literal>peer</literal> ou les droits du système de fichiers pour
   restreindre les connexions. Voir le <xref
   linkend="client-authentication"/> pour plus d'informations).
  </para>

  <para>
   <command>initdb</command> initialise aussi la
   locale<indexterm><primary>locale</primary></indexterm> par défaut du groupe de bases de
   données. Normalement, elle prends seulement le paramétrage local dans
   l'environnement et l'applique à la base de données initialisée. Il est
   possible de spécifier une locale différente pour la base de données&nbsp;;
   la <xref linkend="locale"/> propose plus d'informations là-dessus.
   L'ordre de tri utilisé par défaut pour ce cluster de bases de données est
   initialisé par <command>initdb</command> et, bien que vous pouvez créer de
   nouvelles bases de données en utilisant des ordres de tris différents, l'ordre
   utilisé dans les bases de données modèle que initdb a créé ne peut pas être
   modifié sans les supprimer et les re-créer. Cela a aussi un impact sur les
   performances pour l'utilisation de locales autres que <literal>c</literal>
   ou <literal>posix</literal>. Du coup, il est important de faire ce choix
   correctement la première fois.
  </para>

  <para>
   <command>initdb</command> configure aussi le codage par défaut de l'ensemble
   de caractères pour le groupe de bases de données. Normalement, cela doit
   être choisi pour correspondre au paramétrage de la locale. Pour les détails,
   voir la <xref linkend="multibyte"/>.
  </para>

  <sect2 id="creating-cluster-nfs">
   <title>Systèmes de fichiers réseaux</title>

   <indexterm zone="creating-cluster-nfs">
    <primary>Systèmes de fichiers réseaux</primary>
   </indexterm>
   <indexterm><primary><acronym>NFS</acronym></primary><see>Systèmes de fichiers réseaux</see></indexterm>
   <indexterm><primary>Network Attached Storage (<acronym>NAS</acronym>)</primary><see>Systèmes de fichiers réseaux</see></indexterm>

   <para>
    Beaucoup d'installations créent les clusters de bases de données sur des
    systèmes de fichiers réseau. Parfois, cela utilise directement par
    <acronym>NFS</acronym>. Cela peut aussi passer par un <acronym>NAS</acronym>
    (acronyme de <foreignphrase>Network Attached Storage</foreignphrase>),
    périphérique qui utilise <acronym>NFS</acronym> en interne.
    <productname>PostgreSQL</productname> ne fait rien de particulier avec les
    systèmes de fichiers <acronym>NFS</acronym>, ceci signifiant que
    <productname>PostgreSQL</productname> suppose que
    <acronym>NFS</acronym> se comporte exactement comme les lecteurs connectés
    en local (<acronym>DAS</acronym>, acronyme de <foreignphrase>Direct
    Attached Storage</foreignphrase>). Si les implémentations du client et du
    serveur <acronym>NFS</acronym> ont une sémantique non standard,
    cela peut poser des problèmes de fiabilité (voir <ulink
    url="http://www.time-travellers.org/shane/papers/NFS_considered_harmful.html"></ulink>).
    En particulier, des écritures asynchrones (décalées dans le temps) sur le
    serveur <acronym>NFS</acronym> peuvent poser des soucis de fiabilité. Si
    possible, montez les systèmes de fichiers <acronym>NFS</acronym> en
    synchrone (autrement dit sans cache) pour éviter cela. De même, le montage
    <acronym>NFS</acronym> n'est pas recommandé. Les <acronym>SAN</acronym>
    utilisent un protocole de communication bas-niveau plutôt que
    <acronym>NFS</acronym>.
   </para>

  </sect2>
 </sect1>

 <sect1 id="server-start">
  <title>Lancer le serveur de bases de données</title>

  <para>
   Avant qu'une personne ait accès à la base de données, vous devez démarrer le
serveur de bases de données. Le programme serveur est appelé
<command>postgres</command><indexterm><primary>postgres</primary></indexterm>. Le
programme <command>postgres</command> doit savoir où trouver les données qu'il est
supposé utiliser. Ceci se fait avec l'option <option>-d</option>. Du coup, la
façon la plus simple de lancer le serveur est&nbsp;:
<screen>$ <userinput>postgres -D /usr/local/pgsql/data</userinput></screen>
   qui laissera le serveur s'exécuter en avant plan. Pour cela, vous devez être
   connecté en utilisant le compte de l'utilisateur
   <productname>PostgreSQL</productname>. Sans l'option <option>-d</option>, le serveur
   essaiera d'utiliser le répertoire de données nommé par la variable
   d'environnement <envar>pgdata</envar>. Si cette variable ne le fournit pas
   non plus, le lancement échouera.
  </para>

  <para>
   Habituellement, il est préférable de lancer <command>postgres</command> en tâche
   de fond. Pour cela, utilisez la syntaxe shell Unix habituelle&nbsp;:
<screen>$ <userinput>postgres -D /usr/local/pgsql/data &gt;journaux_trace 2&gt;&amp;1 &amp;</userinput></screen>
   Il est important de sauvegarder les sorties <systemitem>stdout</systemitem> et
   <systemitem>stderr</systemitem> du serveur quelque part, comme montré ci-dessus. Cela
   vous aidera dans des buts d'audits ou pour diagnostiquer des problèmes (voir
   la <xref linkend="logfile-maintenance"/> pour une discussion plus détaillée
   de la gestion de journaux de trace).
  </para>

  <para>
   Le programme <command>postgres</command> prend aussi un certain nombre d'autres
   options en ligne de commande. Pour plus d'informations, voir la page de
   référence <xref linkend="app-postmaster"/> ainsi que le <xref
   linkend="runtime-config"/> ci-dessous.
  </para>

  <para>
   Cette syntaxe shell peut rapidement devenir ennuyante. Donc, le programme
   d'emballage <xref linkend="app-pg-ctl"/><indexterm><primary>pg_ctl</primary></indexterm>
   est fourni pour simplifier certaines tâches. Par exemple&nbsp;:
<programlisting>pg_ctl start -l journaux_trace</programlisting>
   lancera le serveur en tâche de fond et placera les sorties dans le journal 
   de trace indiqué. L'option <option>-d</option> a la même signification ici
   que pour <command>postgres</command>. <command>pg_ctl</command> est aussi
   capable d'arrêter le serveur.
  </para>

  <para>
   Normalement, vous lancerez le serveur de bases de données lors du
   démarrage de l'ordinateur <indexterm><primary>démarrage</primary><secondary>au
   lancement du serveur</secondary></indexterm>. Les scripts de lancement automatique sont
   spécifiques au système d'exploitation. Certains sont distribués avec
   <productname>PostgreSQL</productname> dans le répertoire
   <filename>contrib/start-scripts</filename>. En installer un demandera les
   droits de root.
  </para>

  <para>
   Différents systèmes ont différentes conventions pour lancer les démons au
   démarrage. La plupart des systèmes ont un fichier
   <filename>/etc/rc.local</filename> ou
   <filename>/etc/rc.d/rc.local</filename>. D'autres utilisent les répertoires
   <filename>init.d</filename> ou <filename>rc.d</filename>. Quoi que
   vous fassiez, le serveur doit être exécuté par le
   compte utilisateur <productname>PostgreSQL</productname> <emphasis>et non pas
   par root</emphasis> ou tout autre utilisateur. Donc, vous devriez
   probablement former vos commandes en utilisant <literal>su -c '...' 
   postgres</literal>. Par exemple&nbsp;:
<programlisting>su -c 'pg_ctl start -D /usr/local/pgsql/data -l serverlog' postgres</programlisting>
  </para>

  <para>
   Voici quelques suggestions supplémentaires par système d'exploitation
   (dans chaque cas, assurez-vous d'utiliser le bon répertoire d'installation et
   le bon nom de l'utilisateur où nous montrons des valeurs génériques).

   <itemizedlist>
    <listitem>
     <para>
      Pour <productname>freebsd</productname>, regardez le fichier
      <filename>contrib/start-scripts/freebsd</filename> du répertoire des
      sources de <productname>PostgreSQL</productname>.
      <indexterm><primary>freebsd</primary><secondary>script de
      lancement</secondary></indexterm>
     </para>
    </listitem>

    <listitem>
     <para>
      Sur <productname>openbsd</productname>, ajoutez les lignes suivantes à
      votre fichier <filename>/etc/rc.local</filename>&nbsp;:
      <indexterm><primary>openbsd</primary><secondary>script de
      lancement</secondary></indexterm>
<programlisting>if [ -x /usr/local/pgsql/bin/pg_ctl -a -x /usr/local/pgsql/bin/postgres ]; then
    su - -c '/usr/local/pgsql/bin/pg_ctl start -l /var/PostgreSQL/log -s' postgres
    echo -n ' PostgreSQL'
fi</programlisting>
     </para>
    </listitem>

    <listitem>
     <para>
      Sur les systèmes <productname>linux</productname>, soit vous ajoutez
      <indexterm><primary>linux</primary><secondary>script de lancement</secondary></indexterm>
<programlisting>/usr/local/pgsql/bin/pg_ctl start -l journaux_trace -D /usr/local/pgsql/data</programlisting>
      à <filename>/etc/rc.d/rc.local</filename> ou
      <filename>/etc/rc.local</filename> soit vous jetez un &oelig;il à
      <filename>contrib/start-scripts/linux</filename> dans le répertoire des
      sources de <productname>PostgreSQL</productname>.
     </para>
    </listitem>

    <listitem>
     <para>
      Sur <productname>netbsd</productname>, vous pouvez utiliser les scripts
      de lancement de <productname>freebsd</productname> ou de
      <productname>linux</productname> suivant vos préférences.
      <indexterm><primary>netbsd</primary><secondary>script de lancement</secondary></indexterm>
     </para>
    </listitem>

    <listitem>
     <para>
      Sur <productname>solaris</productname>, créez un fichier appelé
      <filename>/etc/init.d/PostgreSQL</filename> et contenant la ligne
      suivante&nbsp;:
      <indexterm><primary>solaris</primary><secondary>script de
      lancement</secondary></indexterm>
<programlisting>su - postgres -c "/usr/local/pgsql/bin/pg_ctl start -l journaux_trace -D /usr/local/pgsql/data"</programlisting>
      Puis, créez un lien symbolique vers lui dans <filename>/etc/rc3.d</filename> de
      nom <filename>s99PostgreSQL</filename>.
     </para>
    </listitem>
   </itemizedlist>

  </para>

   <para>
    Tant que le serveur est lancé, son
    <acronym>pid</acronym> est stocké dans le fichier
    <filename>postmaster.pid</filename> du répertoire de données. C'est utilisé
    pour empêcher plusieurs instances du serveur d'être exécutées dans le même
    répertoire de données et peut aussi être utilisé pour arrêter le processus
    le serveur.
   </para>

   <sect2 id="server-start-failures">
    <title>Échecs de lancement</title>

    <para>
     Il existe de nombreuses raisons habituelles pour lesquelles le serveur
     échouerait au lancement. Vérifiez le journal des traces du serveur ou
     lancez-le manuellement (sans redirection des sorties standard et d'erreur)
     et regardez les messages d'erreurs qui apparaissent. Nous en expliquons
     certains ci-dessous parmi les messages d'erreurs les plus communs.
    </para>

    <para>
<screen>LOG:  could not bind IPv4 socket: Address already in use
HINT:  Is another postmaster already running on port 5432? If not, wait a few seconds and retry.
FATAL:  could not create TCP/IP listen socket</screen>
     Ceci signifie seulement ce que cela suggère&nbsp;: vous avez essayé de lancer
     un autre serveur sur le même port où un autre est en 
     cours d'exécution. Néanmoins, si le message d'erreur du noyau 
     n'est pas <computeroutput>address already in use</computeroutput> ou une
     quelconque variante, il pourrait y avoir un autre problème. Par
     exemple, essayer de lancer un serveur sur un numéro
     de port réservé pourrait avoir ce résultat&nbsp;:
<screen>$ <userinput>postgres -p 666</userinput>
LOG:  could not bind IPv4 socket: Permission denied
HINT:  Is another postmaster already running on port 666? If not, wait a few seconds and retry.
FATAL:  could not create TCP/IP listen socket</screen>
    </para>

    <para>
     Un message du type
<screen>FATAL:  could not create shared memory segment: Invalid argument
DETAIL:  Failed system call was shmget(key=5440001, size=4011376640, 03600).</screen>
     signifie probablement que les limites de votre noyau sur la taille de 
     la mémoire partagée est plus petite que l'aire de fonctionnement que
     <productname>PostgreSQL</productname> essaie de créer (4011376640 octets
     dans cet exemple). Ou il pourrait signifier que vous n'avez pas du tout
     configuré le support de la mémoire partagée de type System-V dans votre
     noyau. Comme contournement temporaire, vous pouvez essayer de lancer le
     serveur avec un nombre de tampons plus petit que la normale
     (<xref linkend="guc-shared-buffers"/>). Éventuellement, vous pouvez
     reconfigurer votre noyau pour accroître la taille de mémoire partagée
     autorisée. Vous pourriez voir aussi ce message en essayant d'exécuter
     plusieurs serveurs sur la même machine si le total de l'espace qu'ils
     requièrent dépasse la limite du noyau.
    </para>

    <para>
     Une erreur du type
<screen>FATAL:  could not create semaphores: No space left on device
DETAIL:  Failed system call was semget(5440126, 17, 03600).</screen>
     ne signifie <emphasis>pas</emphasis> qu'il vous manque de l'espace disque.
     Elle signifie que la limite de votre noyau sur le nombre de sémaphores
     <systemitem class="osname">system v</systemitem> est inférieure au nombre que
     <productname>PostgreSQL</productname> veut créer. Comme ci-dessus, vous
     pouvez contourner le problème en lançant le serveur avec un nombre
     réduit de connexions autorisées (<xref linkend="guc-max-connections"/>)
     mais vous voudrez éventuellement augmenter la limite du noyau.
    </para>

    <para>
     Si vous obtenez une erreur <quote>illegal system call</quote>, il est probable
     que la mémoire partagée ou les sémaphores ne sont pas du tout supportés par
     votre noyau. Dans ce cas, votre seule option est de reconfigurer le noyau
     pour activer ces fonctionnalités.
    </para>

    <para>
     Des détails sur la configuration des capacités <acronym>ipc</acronym> <systemitem
     class="osname">System V</systemitem> sont donnés dans la <xref linkend="sysvipc"/>.
    </para>
   </sect2>

   <sect2 id="client-connection-problems">
    <title>Problèmes de connexion du client</title>

    <para>
     Bien que les conditions d'erreurs possibles du côté client sont assez
     variées et dépendantes de l'application, certaines pourraient être en
     relation direct avec la façon dont le serveur a été lancé. Les conditions
     autres que celles montrées ici devraient être documentées avec
     l'application client respective.
    </para>

    <para>
<screen>psql: could not connect to server: Connection refused
        Is the server running on host "server.joe.com" and accepting
        TCP/IP connections on port 5432?</screen>
     Ceci est l'échec générique <quote>je n'ai pas trouvé de serveur à qui
     parler</quote>. Cela ressemble au message ci-dessus lorsqu'une connexion
     TCP/IP est tentée. Une erreur commune est d'oublier de configurer le
     serveur pour qu'il autorise les connexions TCP/IP.
    </para>

    <para>
     Autrement, vous obtiendrez ceci en essayant une communication de type
     socket de domaine Unix vers un serveur local&nbsp;:
<screen>psql: could not connect to server: No such file or directory
        Is the server running locally and accepting
        connections on Unix domain socket "/tmp/.s.PGSQL.5432"?</screen>
    </para>

    <para>
     La dernière ligne est utile pour vérifier si le client essaie de se
     connecter au bon endroit. Si aucun serveur n'est exécuté ici, le
     message d'erreur du noyau sera typiquement soit <computeroutput>connection
     refused</computeroutput> soit <computeroutput>no such file or
     directory</computeroutput>, comme ce qui est illustré (il est important de
     réaliser que <computeroutput>connection refused</computeroutput>, dans ce
     contexte, ne signifie <emphasis>pas</emphasis> que le serveur a obtenu une
     demande de connexion et l'a refusé. Ce cas produira un message différent
     comme indiqué dans la <xref linkend="client-authentication-problems"/>).
     D'autres messages d'erreurs tel que <computeroutput>connection timed
     out</computeroutput> pourraient indiquer des problèmes plus fondamentaux
     comme un manque de connexion réseau.
    </para>
   </sect2>
  </sect1>

 <sect1 id="kernel-resources">
  <title>Gérer les ressources du noyau</title>

  <para>
   Une installation importante de <productname>PostgreSQL</productname> peut rapidement
   épuiser les limites des ressources du système d'exploitation (Sur certains
   systèmes, les valeurs par défaut sont trop basses que vous n'avez même pas
   besoin d'une installation <quote>importante</quote>.). Si vous avez rencontré ce
   type de problème, continuez votre lecture.
  </para>

  <sect2 id="sysvipc">
   <title>Mémoire partagée et sémaphore</title>

   <indexterm zone="sysvipc">
    <primary>mémoire partagée</primary>
   </indexterm>

   <indexterm zone="sysvipc">
    <primary>sémaphores</primary>
   </indexterm>

   <para>
    La mémoire partagée et les sémaphores sont nommés collectivement
    <quote><acronym>ipc</acronym> <systemitem class="osname">system v</systemitem></quote>
    (ensemble avec les queues de messages, qui n'ont pas d'importance pour
    <productname>PostgreSQL</productname>). Pratiquement, tous les systèmes d'exploitation
    modernes fournissent ces fonctionnalités mais, parmi elles, toutes ne sont pas
    activées ou dimensionnées suffisamment par défaut, car la mémoire
    disponible et la demande des applications augmente. (Sur
    <systemitem class="osname">Windows</systemitem>,
    <productname>PostgreSQL</productname> fournit sa
    propre implémentation de remplacement de ces fonctionnalités, du coup, ce qui suit peut être ignoré).
   </para>

   <para>
    Le manque complet de fonctionnalités est généralement manifesté par 
    une erreur <errorname>illegal system call</errorname> au lancement du serveur. Dans
    ce cas, il n'y a rien à faire à part reconfigurer votre noyau.
    <productname>PostgreSQL</productname> ne fonctionnera pas sans. Néanmoins,
    cette situation est rare parmi les systèmes d'exploitation modernes.
   </para>

   <para>
    Quand <productname>PostgreSQL</productname> dépasse une des nombreuses limites
    <acronym>ipc</acronym>, le serveur refusera de s'exécuter et lèvera un
    message d'erreur instructif décrivant le problème rencontré et que faire
    avec (voir aussi la <xref linkend="server-start-failures"/>). Les
    paramètres adéquats du noyau sont nommés de façon cohérente parmi les
    différents systèmes&nbsp;; le <xref linkend="sysvipc-parameters"/> donne un
    aperçu. Néanmoins, les méthodes pour les obtenir varient. Les suggestions
    pour quelques plateformes sont données ci-dessous.
   </para>


   <table id="sysvipc-parameters">
    <title>Paramètres <systemitem class="osname">system v</systemitem> <acronym>ipc</acronym></title>

    <tgroup cols="3">
     <colspec colnum="1" colwidth="0.3*"/>
     <colspec colnum="2" colwidth="1.5*"/>
     <colspec colnum="3" colwidth="1.2*"/>
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Description</entry>
       <entry>Valeurs raisonnables</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><varname>shmmax</varname></entry>
       <entry>taille maximum du segment de mémoire partagée (octets)</entry>
       <entry>au moins plusieurs mo (voir texte)</entry>
      </row>

      <row>
       <entry><varname>shmmin</varname></entry>
       <entry>taille minimum du segment de mémoire partagée (octets)</entry>
       <entry>1</entry>
      </row>

      <row>
       <entry><varname>shmall</varname></entry>
       <entry>total de la mémoire partagée disponible (octets ou pages)</entry>
       <entry>si octets, identique à <varname>shmmax</varname>&nbsp;; si pages,
        <literal>ceil(shmmax/page_size)</literal></entry>
      </row>

      <row>
       <entry><varname>shmseg</varname></entry>
       <entry>nombre maximum de segments de mémoire partagée par
        processus</entry>
       <entry>seul un segment est nécessaire mais la valeur par défaut est
        bien plus importante</entry>
      </row>

       <row>
        <entry><varname>shmmni</varname></entry>
        <entry>nombre maximum de segments de mémoire partagée pour
         tout le système</entry>
        <entry>comme <varname>shmseg</varname> plus la place pour les autres
         applications</entry>
       </row>

       <row>
        <entry><varname>semmni</varname></entry>
        <entry>nombre maximum d'identifiants de sémaphores (c'est-à-dire
         d'ensembles)</entry>
        <entry>au moins <literal>ceil((max_connections + autovacuum_max_workers + 4) / 16)</literal></entry>
       </row>

       <row>
        <entry><varname>semmns</varname></entry>
        <entry>nombre maximum de sémaphores répartis dans le système</entry>
        <entry><literal>ceil((max_connections + autovacuum_max_workers = 4) / 16) * 17</literal> plus la place
         pour les autres applications</entry>
       </row>

       <row>
        <entry><varname>semmsl</varname></entry>
        <entry>nombre maximum de sémaphores par ensemble</entry>
        <entry>au moins 17</entry>
       </row>

       <row>
        <entry><varname>semmap</varname></entry>
        <entry>nombre d'entrées dans la carte des sémaphores</entry>
        <entry>voir le texte</entry>
       </row>

       <row>
        <entry><varname>semvmx</varname></entry>
        <entry>valeur maximum d'un sémaphore</entry>
        <entry>au moins 1000 (vaut souvent par défaut 32767, ne pas changer
         sauf si vous êtes forcé.)</entry>
       </row>

     </tbody>
    </tgroup>
   </table>


   <para>
    <indexterm><primary>shmmax</primary></indexterm> le paramètre de mémoire
    partagé le plus important est <varname>shmmax</varname>, la taille maximum, en
    octets, d'un segment de mémoire partagée. Si vous obtenez un message
    d'erreur à partir de <function>shmget</function> comme <quote>invalid
    argument</quote>, il est possible que cette limite soit dépassée.
    La taille du segment de mémoire partagée requis dépend de plusieurs
    paramètres de configuration de <productname>PostgreSQL</productname>, comme indiqué
    dans le <xref linkend="shared-memory-parameters"/> (tout message
    d'erreur obtenu incluera la taille exacte utilisée dans la requête
    d'allocation qui a échoué). Temporairement, vous pouvez
    baisser certains de ces paramètres pour éviter un échec. Alors qu'il est possible d'obtenir de
    <productname>PostgreSQL</productname> qu'il fonctionne avec un <varname>shmmax</varname>
    de 2&nbsp;Mo, vous avez besoin de bien plus pour obtenir
    des performances acceptables. Les paramètrages désirables sont plutôt de
    l'ordre de centaines de Mo à quelques Go.
   </para>

   <para>
    Certains systèmes ont aussi une limite sur le nombre total de mémoire partagée
    dans le système (<varname>shmall</varname>). Assurez-vous que cela soit suffisamment
    important pour <productname>PostgreSQL</productname> et quelque autres applications
    utilisant des segments de mémoire partagée (notez que
    <varname>shmall</varname> est mesuré en pages plutôt qu'en octets sur beaucoup de
    systèmes).
   </para>



   <para>
    La taille minimum des segments de mémoire partagée (<varname>shmmin</varname>) est
    moins sensible aux problèmes. Elle devrait être au plus à environ
    500&nbsp;Ko pour <productname>PostgreSQL</productname> (il est habituellement à 1). Le
    nombre maximum de segments au travers du système (<varname>shmmni</varname>) ou par
    processus (<varname>shmseg</varname>) a peu de chances de causer un problème sauf
    s'ils sont configurés à zéro sur votre système.
   </para>

   <para>
    <productname>PostgreSQL</productname> utilise un sémaphore par connexion
    autorisée (<xref linkend="guc-max-connections"/>) et par processus
    autovacuum autorisé (<xref linkend="guc-autovacuum-max-workers"/>), le
    tout par ensemble de 16. Chacun de ces
    ensembles contiendra aussi un 17è sémaphore qui contient un <quote>nombre
    magique</quote> pour détecter la collision avec des ensembles de sémaphore
    utilisés par les autres applications. Le nombre maximum de sémaphores dans le
    système est initialisé par <varname>semmns</varname>, qui en conséquence doit être
    au moins aussi haut que <varname>max_connections</varname> plus
    <varname>autovacuum_max_workers</varname> plus un extra de chacune
    des 16 connexions autorisées et des processus autovacuum (voir la formule dans le <xref
    linkend="sysvipc-parameters"/>). Le paramètre <varname>semmni</varname> détermine la
    limite sur le nombre d'ensembles de sémaphores qui peuvent exister sur le
    système à un instant précis. Donc, ce paramètre doit être au moins égal à
    <literal>ceil((max_connections + autovacuum_max_workers + 4) / 16)</literal>. Baisser le nombre de connexions
    autorisées est un contournement temporaire pour les échecs qui sont
    habituellement indiqués par le message <quote>no space left on
    device</quote>, à partir de la fonction <function>semget</function>.
   </para>

   <para>
    Dans certains cas, il pourrait être nécessaire d'augmenter
    <varname>semmap</varname> pour être au moins dans l'ordre de <varname>semmns</varname>. Ce
    paramètre définit la taille de la carte de ressources de sémaphores, dans
    laquelle chaque bloc contigü de sémaphores disponibles ont besoin d'une
    entrée. Lorsqu'un ensemble de sémaphores est libéré ou qu'il est enregistré
    sous une nouvelle entrée de carte. Si la carte est pleine, les sémaphores
    libérés sont perdus (jusqu'au redémarrage). La fragmentation de l'espace
    des sémaphores pourrait amener dans le temps à moins de sémaphores
    disponibles.
   </para>

   <para>
    La paramètre <varname>semmsl</varname>, qui détermine le nombre de sémaphores dans
    un ensemble, pourrait valoir au moins 17 pour <productname>PostgreSQL</productname>.
   </para>

   <para>
    D'autres paramètres en relation avec l'<quote>annulation de sémaphores</quote>,
    tels que <varname>semmnu</varname> et <varname>semume</varname>, n'affectent pas
    <productname>PostgreSQL</productname>.
   </para>

    <variablelist>

     <varlistentry>
      <term><systemitem class="osname">AIX</systemitem></term>
      <listitem>
      <indexterm><primary>AIX</primary><secondary>configuration IPC</secondary></indexterm>
       <para>
        À partir de la version 5.1, il ne doit plus être nécessaire de faire
	une configuration spéciale pour les paramètres tels que
        <varname>SHMMAX</varname>, car c'est configuré de façon à ce que toute
	la mémoire puisse être utilisée en tant que mémoire partagée.
	C'est le type de configuration habituellement utilisée pour d'autres
	bases de données comme <application>DB/2</application>.</para>

       <para>
        Néanmoins, il pourrait être nécessaire de modifier l'information
       globale <command>ulimit</command> dans
       <filename>/etc/security/limits</filename> car les limites en dur par
       défaut pour les tailles de fichiers (<varname>fsize</varname>) et
       les nombres de fichiers (<varname>nofiles</varname>) pourraient être
       trop bas.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">freebsd</systemitem></term>
      <listitem>
      <indexterm><primary>freebsd</primary><secondary>configuration ipc</secondary></indexterm>
       <para>
        Les paramètres par défaut sont seulement acceptables pour de petites
	installations (par exemple, la valeur par défaut de
	<varname>shmmax</varname> est de 32&nbsp;mo). Les modifications se font
	via les interfaces <command>sysctl</command> ou
        <command>loader</command>. Les paramètres suivants peuvent être configurés
	en utilisant <command>sysctl</command>&nbsp;:
<screen><prompt>$</prompt> <userinput>sysctl -w kern.ipc.shmall=32768</userinput>
<prompt>$</prompt> <userinput>sysctl -w kern.ipc.shmmax=134217728</userinput>
<prompt>$</prompt> <userinput>sysctl -w kern.ipc.semmap=256</userinput></screen>
        Pour que ces paramètres persistent après les redémarrages, modifiez
        <filename>/etc/sysctl.conf</filename>.
       </para>

       <para>
        Les paramètres restant, concernant les sémaphores, sont en lecture seule
	en ce qui concerne <command>sysctl</command> mais peuvent être modifiés
	avant le redémarrage en utilisant l'invite <command>loader</command>&nbsp;:
<screen><prompt>(loader)</prompt> <userinput>set kern.ipc.semmni=256</userinput>
<prompt>(loader)</prompt> <userinput>set kern.ipc.semmns=512</userinput>
<prompt>(loader)</prompt> <userinput>set kern.ipc.semmnu=256</userinput></screen>
        De façon similaire, ils peuvent être sauvegardés entre les redémarrages
	dans <filename>/boot/loader.conf</filename>.
       </para>

       <para>
        Vous pourriez aussi vouloir configurer votre noyau pour verrouiller la
	mémoire partagée en RAM et l'empêcher d'être envoyé dans la swap. Ceci
        s'accomplit en utilisant le paramètre
	<literal>kern.ipc.shm_use_phys</literal> de <command>sysctl</command>.
       </para>

       <para>
        En cas d'exécution dans une cage FreeBSD en activant
	<literal>security.jail.sysvipc_allowed</literal> de <application>sysctl</application>,
	les <application>postmaster</application> exécutés dans différentes cages
	devront être exécutés par différents utilisateurs du système d'exploitation.
	Ceci améliore la sécurité car cela empêche les utilisateurs non root
	d'interférer avec la mémoire partagée ou les sémaphores d'une cage
	différente et cela permet au code de nettoyage des IPC PostgreSQL de
	fonctionner correctement (dans FreeBSD 6.0 et ultérieurs, le code de
	nettoyage IPC ne détecte pas proprement les processus des autres
	cages, empêchant les postmaster en cours d'exécution d'utiliser le
	même port dans différentes cages).
       </para>

       <para>
        Les <systemitem class="osname">FreeBSD</systemitem>, avant la 4.0, fonctionnent
	    comme <systemitem class="osname">OpenBSD</systemitem> (voir ci-dessous).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">NetBSD</systemitem></term>
      <indexterm><primary>netbsd</primary><secondary>configuration ipc</secondary></indexterm>
      <listitem>
       <para>
        Avec <systemitem class="osname">NetBSD</systemitem> 5.0 et
        ultérieur, les paramètres IPC peuvent être ajustés en utilisant
        <command>sysctl</command>. Par exemple&nbsp;:
<screen>
<prompt>$</prompt> <userinput>sysctl -w kern.ipc.shmmax=16777216</userinput>
</screen>
        Pour que ce paramètrage persiste après un redémarrage, modifiez
        le fichier <filename>/etc/sysctl.conf</filename>.
       </para>

       <para>
        Vous pourriez aussi vouloir configurer votre noyau pour verrouiller
        la mémoire partagée en RAM et l'empêcher d'être mise dans le swap.
        Cela peut se faire en utilisant le paramètre
        <literal>kern.ipc.shm_use_phys</literal> de <command>sysctl</command>.
       </para>

       <para>
        Les versions de <systemitem class="osname">NetBSD</systemitem>
        antérieures à la 5.0 fonctionnent comme <systemitem
        class="osname">OpenBSD</systemitem> (voir ci-dessous), sauf que
        les paramètres doivent être configurés avec le mot clé
        <literal>options</literal>, et non pas <literal>option</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">OpenBSD</systemitem></term>
      <listitem>
      <indexterm><primary>netbsd</primary><secondary>ipc configuration</secondary></indexterm>
      <indexterm><primary>openbsd</primary><secondary>configuration ipc</secondary></indexterm>
       <para>
        Les options <varname>sysvshm</varname> et <varname>sysvsem</varname> doivent être
        activées à la compilation du noyau (ils le sont par défaut). La taille
        maximum de mémoire partagée est déterminée par l'option
        <varname>shmmaxpgs</varname> (en pages). Ce qui suit montre un exemple de
        l'initialisation des différents paramètres&nbsp;:
<programlisting>option        SYSVSHM
option        SHMMAXPGS=4096
option        SHMSEG=256

option        SYSVSEM
option        SEMMNI=256
option        SEMMNS=512
option        SEMMNU=256
option        SEMMAP=256</programlisting>
       </para>
       <para>
        Vous pourriez aussi vouloir configurer votre noyau pour verrouiller la
        mémoire partagée en RAM et l'empêcher d'être paginée en swap. Ceci se
        fait en utilisant le paramètre <literal>kern.ipc.shm_use_phys</literal> de
        <command>sysctl</command>.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">hp-ux</systemitem></term>
      <listitem>
      <indexterm><primary>hp-ux</primary><secondary>configuration ipc</secondary></indexterm>
       <para>
        Les paramètres par défaut tendent à suffire pour des installations
        normales. Sur <productname>hp-ux</productname> 10, la valeur par défaut de
        <varname>semmns</varname> est 128, qui pourrait être trop basse pour de gros
        sites de bases de données.
       </para>
       <para>
        Les paramètres <acronym>ipc</acronym> peuvent être initialisés dans 
        <application>system administration manager</application> (<acronym>sam</acronym>) sous
        <menuchoice><guimenu>kernel configuration</guimenu><guimenuitem>configurable
        Parameters</guimenuitem></menuchoice>. Allez sur <guibutton>create a new kernel</guibutton> une fois
        terminée.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">linux</systemitem></term>
      <listitem>
      <indexterm><primary>linux</primary><secondary>configuration ipc</secondary></indexterm>
       <para>
        La taille maximale du segment par défaut est de 32&nbsp;Mo, ce qui
        n'est adéquat que pour les très petites installations de
        <productname>PostgreSQL</productname>. La taille totale maximale par
        défaut est de 2097152 pages. Une page équivaut pratiquement toujours
        à 4096 octets sauf pour certaines configurations inhabituelles du
        noyau comme <quote>huge pages</quote> (utilisez
        <literal>getconf PAGE_SIZE</literal> pour vérifier). Cela donne une
        limite par défaut de 8&nbsp;Go, ce qui est souvent suffisant.
       </para>

       <para>
        La configuration de la taille de mémoire partagée peut être modifiée
        avec l'interface proposée par la commande <command>sysctl</command>.
        Par exemple, pour permettre l'utilisation de 16&nbsp;Go&nbsp;:
<screen>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmmax=17179869184</userinput>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmall=4194304</userinput>
</screen>
        De plus, ces paramètres peuvent être préservés entre des redémarrages
        dans le fichier <filename>/etc/sysctl.conf</filename>. Il est
        recommandé de le faire.
       </para>

       <para>
        Les anciennes distributions pourraient ne pas avoir le programme
        <command>sysctl</command> mais des modifications équivalentes peuvent
        se faire en manipulant le système de fichiers
        <filename>/proc</filename>&nbsp;:
<screen>
<prompt>$</prompt> <userinput>echo 17179869184 &gt;/proc/sys/kernel/shmmax</userinput>
<prompt>$</prompt> <userinput>echo 4194304 &gt;/proc/sys/kernel/shmall</userinput>
</screen>
       </para>

       <para>
        Les valeurs par défaut restantes sont taillées de façon assez
        généreuses pour ne pas nécessiter de modifications.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">Mac OS X</systemitem></term>
      <listitem>
      <indexterm><primary>Mac OS X</primary><secondary>configuration ipc</secondary></indexterm>
       <para>
        La méthode recommandée pour configurer la mémoire partagée sous OS X
        est de créer un fichier nommé <filename>/etc/sysctl.conf</filename>
        contenant des affectations de variables comme&nbsp;:
<programlisting>kern.sysv.shmmax=4194304
kern.sysv.shmmin=1
kern.sysv.shmmni=32
kern.sysv.shmseg=8
kern.sysv.shmall=1024
</programlisting>
        Notez que, dans certaines versions d'OS X, <emphasis>les
        cinq</emphasis> paramètres de mémoire partagée doivent être configurés
        dans <filename>/etc/sysctl.conf</filename>, sinon les valeurs seront
        ignorées.
       </para>

       <para>
        Attention au fait que les versions récentes d'OS X ignorent les tentatives
	de configuration de <varname>SHMMAX</varname> à une valeur qui n'est pas
	un multiple exact de 4096.
       </para>

       <para>
        <varname>SHMALL</varname> est mesuré en page de 4&nbsp;Ko sur cette
	plateforme.
       </para>

       <para>
        Dans les anciennes versions d'OS X, vous aurez besoin de redémarrer
        pour que les modifications de la mémoire partagée soient prises en
        considération. À partir de la version 10.5, il est possible de tous
        les modifier en ligne sauf <varname>SHMMNI</varname>, grâce à
        <application>sysctl</application>. Mais il est toujours préférable de
        configurer vos valeurs préférées dans
        <filename>/etc/sysctl.conf</filename>, pour que les nouvelles valeurs
        soient conservées après un redémarrage.
       </para>

       <para>
        Le fichier <filename>/etc/sysctl.conf</filename> est seulement honoré
        à partir de la version 1.0.3.9 de OS X. Si vous utilisez une version
        antérieure, vous devez modifier le fichier <filename>/etc/rc</filename>
        et changer les valeurs dans les commandes suivantes&nbsp;:
<programlisting>
sysctl -w kern.sysv.shmmax
sysctl -w kern.sysv.shmmin
sysctl -w kern.sysv.shmmni
sysctl -w kern.sysv.shmseg
sysctl -w kern.sysv.shmall
</programlisting>
        Notez que <filename>/etc/rc</filename> est habituellement écrasé lors
        de mises à jour systèmes d'OS X, donc vous devez vous attendre à les
        modifier manuellement après chaque mise à jour.
       </para>

       <para>
        En 10.2 et avant cette version, modifiez ces commandes dans le fichier
        <filename>/System/Library/StartupItems/SystemTuning/SystemTuning</filename>.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">sco openserver</systemitem></term>
      <listitem>
      <indexterm><primary>sco openserver</primary><secondary>configuration ipc</secondary></indexterm>
       <para>
        Dans la configuration par défaut, seuls 512&nbsp;Ko de mémoire partagée
        par segment est autorisé. Pour augmenter ce paramétrage, allez tout
	d'abord dans le répertoire <filename>/etc/conf/cf.d</filename>. Pour afficher
	la valeur courante de <varname>shmmax</varname>, lancez&nbsp;:
<programlisting>./configure -y SHMMAX</programlisting>
        Pour configurer une nouvelle valeur de <varname>shmmax</varname>, lancez&nbsp;:
<programlisting>./configure SHMMAX=<replaceable>valeur</replaceable></programlisting>
        où <replaceable>value</replaceable> est la nouvelle valeur que vous voulez utiliser
        (en octets). Après avoir configuré <varname>shmmax</varname>, reconstruisez le
        noyau&nbsp;:
<programlisting>./link_unix</programlisting>
        et redémarrez.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">solaris</systemitem> 2.6 à 2.9 (Solaris
      6 à Solaris 9)</term>
      <listitem>
      <indexterm><primary>solaris</primary><secondary>configuration ipc</secondary></indexterm>
       <para>
        La taille maximale par défaut d'un segment de mémoire partagée
        est trop bas pour <productname>PostgreSQL</productname>. La
        configuration est modifiable dans
        <filename>/etc/system</filename>, par exemple&nbsp;:
<programlisting>set shmsys:shminfo_shmmax=0x2000000
set shmsys:shminfo_shmmin=1
set shmsys:shminfo_shmmni=256
set shmsys:shminfo_shmseg=256

set semsys:seminfo_semmap=256
set semsys:seminfo_semmni=512
set semsys:seminfo_semmns=512
set semsys:seminfo_semmsl=32</programlisting>
        Vous avez besoin de redémarrer pour que les modifications prennent
        effet. Voir aussi
        <ulink url="http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html"></ulink>
        pour des informations sur la configuration de la mémoire partagée
        sur des versions plus anciennes de Solaris.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">Solaris</systemitem> 2.10 (Solaris
      10)</term>
      <term><systemitem class="osname">OpenSolaris</systemitem></term>
      <listitem>
       <para>
        Dans Solaris 10 et OpenSolaris, la configuration de la mémoire
        partagée et des sémaphores par défaut sont suffisamment bonnes
        pour la majorité des configurations de
        <productname>PostgreSQL</productname>. La valeur par défaut de
        Solaris pour <varname>SHMMAX</varname> correspond maintenant à
        un quart de la mémoire disponible sur le système. Si vous avez
        besoin d'augmenter cette configuration pour obtenir un
        paramétrage légèrement supérieur, vous devez utiliser une
        configuration de projet associé à l'utilisateur
        <literal>postgres</literal>. Par exemple, exécutez ce qui suit
        en tant qu'utilisateur <literal>root</literal>&nbsp;:
<programlisting>
projadd -c "PostgreSQL DB User" -K "project.max-shm-memory=(privileged,8GB,deny)" -U postgres -G postgres user.postgres
</programlisting>
       </para>

       <para>
        Cette commande ajoute le projet  <literal>user.postgres</literal>
        et augmente le maximum de mémoire partagée pour l'utilisateur
        <literal>postgres</literal> à 8 Go. Cela prend effet à chaque
        fois que l'utilisateur se connecte et quand vous redémarrez
        <productname>PostgreSQL</productname>. La ligne ci-dessus
        suppose que <productname>PostgreSQL</productname> est exécuté
        par l'utilisateur <literal>postgres</literal> dans le groupe
        <literal>postgres</literal>. Aucun redémarrage du serveur n'est
        requis.
       </para>

       <para>
        Sur un serveur de bases de données ayant beaucoup de connexions,
        les autres modifications recommandés pour le noyau sont&nbsp;:
<programlisting>
project.max-shm-ids=(priv,32768,deny)
project.max-sem-ids=(priv,4096,deny)
project.max-msg-ids=(priv,4096,deny)
</programlisting>

       </para>

       <para>
        De plus, si vous exécutez <productname>PostgreSQL</productname>
        dans une zone, vous pourriez avoir besoin d'augmenter les limites
        d'utilisation des ressources pour la zone. Voir
        <foreignphrase>Chapter2:  Projects and Tasks</foreignphrase> dans
        <citetitle>Solaris 10 System Administrator's Guide</citetitle>
        pour plus d'informations sur les <literal>projets</literal> et
        <command>prctl</command>.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">unixware</systemitem></term>
      <listitem>
      <indexterm><primary>unixware</primary><secondary>configuration ipc</secondary></indexterm>
       <para>
        Avec <productname>unixware</productname> 7, la taille maximum des segments de
        mémoire partagée est de 512&nbsp;Ko dans la configuration par défaut.
        Pour afficher la valeur courante de <varname>shmmax</varname>, lancez&nbsp;:
<programlisting>/etc/conf/bin/idtune -g SHMMAX</programlisting>
        qui affiche la valeur courante, par défaut, minimum et
        maximum. Pour configurer une nouvelle valeur de <varname>shmmax</varname>,
        lancez&nbsp;:
<programlisting>/etc/conf/bin/idtune SHMMAX <replaceable>valeur</replaceable></programlisting>
        où <replaceable>valeur</replaceable> est la nouvelle valeur que vous voulez
        utiliser (en octets). Après avoir initialisé <varname>shmmax</varname>,
        reconstruisez le noyau&nbsp;:
<programlisting>/etc/conf/bin/idbuild -B</programlisting>
        et relancez.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

   <table id="shared-memory-parameters">
    <title>Usage de la mémoire partagée <productname>PostgreSQL</productname></title>

    <tgroup cols="2">
     <colspec colnum="1" colwidth="0.5*"/>
     <colspec colnum="2" colwidth="1.5*"/>
     <thead>
      <row>
       <entry>Usage</entry>
       <entry>Nombre d'octets approximatifs pour la mémoire partagée (en 8.3)</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>Connexions</entry>
       <entry>(1800 + 270 * <xref
       linkend="guc-max-locks-per-transaction"/>) * <xref
       linkend="guc-max-connections"/></entry>
      </row>

      <row>
       <entry>Processus travailleurs de l'autovacuum</entry>
       <entry>(1800 + 270 * <xref
       linkend="guc-max-locks-per-transaction"/>) * <xref
       linkend="guc-autovacuum-max-workers"/></entry>
      </row>

      <row>
       <entry>Transactions préparées</entry>
       <entry>(770 + 270 * <xref
       linkend="guc-max-locks-per-transaction"/>) * <xref linkend="guc-max-prepared-transactions"/></entry>
      </row>

      <row>
       <entry>Tampons disque partagés</entry>
       <entry>(<xref linkend="guc-block-size"/> + 208) * <xref linkend="guc-shared-buffers"/></entry>
      </row>

      <row>
       <entry>Tampons WAL</entry>
       <entry>(<xref linkend="guc-wal-block-size"/> + 8) * <xref linkend="guc-wal-buffers"/></entry>
      </row>

      <row>
       <entry>Espace fixe requis</entry>
       <entry>770 kB</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>


  <sect2>
   <title>Limites de ressources</title>

   <para>
    Les systèmes d'exploitation style Unix renforcent différents types de
    limites de ressources qui pourraient interférer avec les opérations de votre
    serveur <productname>PostgreSQL</productname>. Les limites sur le nombre de
    processus par utilisateur, le nombre de fichiers ouverts par un processus et la
    taille mémoire disponible pour chaque processus sont d'une grande
    importance. Chacun d'entre elles ont une limite <quote>dure</quote> et une
    limite <quote>souple</quote>. La limite souple est réellement ce qui compte
    mais cela pourrait être changé par l'utilisateur jusqu'à la limite dure. La
    limite dure pourrait seulement être modifiée par l'utilisateur root. L'appel
    système <function>setrlimit</function> est responsable de l'initialisation
    de ces paramètres. La commande interne du shell <command>ulimit</command>
    (shells Bourne) ou <command>limit</command> (<application>csh</application>) est
    utilisé pour contrôler les limites de ressource à partir de la ligne de
    commande. Sur les systèmes dérivés BSD, le fichier
    <filename>/etc/login.conf</filename> contrôle les différentes limites de
    ressource initialisées à la connexion. Voir la documentation du système
    d'exploitation pour les détails. Les paramètres en question sont
    <varname>maxproc</varname>, <varname>openfiles</varname> et
    <varname>datasize</varname>. par exemple&nbsp;:
<programlisting>default:\
...
        :datasize-cur=256M:\
        :maxproc-cur=256:\
        :openfiles-cur=256:\
...</programlisting>
    (<literal>-cur</literal> est la limite douce. Ajoutez
    <literal>-max</literal> pour configurer la limite dure.)
   </para>

   <para>
    Les noyaux peuvent aussi avoir des limites sur le système complet pour
    certaines ressources.
    <itemizedlist>
     <listitem>
      <para>
      Sur <productname>linux</productname>,
      <filename>/proc/sys/fs/file-max</filename> détermine le nombre maximum de
      fichiers ouverts que le noyau supportera. Ce nombre est modifiable en
      écrivant un autre nombre dans le fichier ou en ajoutant une affectation
      dans <filename>/etc/sysctl.conf</filename>. La limite des fichiers par
      processus est fixée lors de la compilation du noyau&nbsp;; voir
      <filename>/usr/src/linux/documentation/proc.txt</filename> pour plus
      d'informations.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Le serveur <productname>PostgreSQL</productname> utilise un processus par
    connexion de façon à ce que vous puissiez fournir au moins autant de
    processus que de connexions autorisées, en plus de ce dont vous avez besoin
    pour le reste de votre système. Ceci n'est habituellement pas un problème
    mais si vous exécutez plusieurs serveurs sur une seule machine, cela
    pourrait devenir étroit.
   </para>

   <para>
    La limite par défaut des fichiers ouverts est souvent initialisée pour être
    <quote>amicalement sociale</quote>, pour permettre à de nombreux
    utilisateurs de coexister sur une machine sans utiliser une fraction
    inappropriée des ressources du système. Si vous lancez un grand nombre de
    serveurs sur une machine, cela pourrait être quelque chose que vous
    souhaitez mais sur les serveurs dédiés, vous pourriez vouloir augmenter
    cette limite.
   </para>

   <para>
    D'un autre côté, certains systèmes autorisent l'ouverture d'un grand
    nombre de fichiers à des processus individuels&nbsp;; si un plus grand
    nombre le font, alors les limites du système peuvent facilement être
    dépassées. Si vous rencontrez ce cas et que vous ne voulez pas modifier la
    limite du système, vous pouvez initialiser le paramètre de configuration
    <xref linkend="guc-max-files-per-process"/> de
    <productname>PostgreSQL</productname> pour limiter la consommation de
    fichiers ouverts.
   </para>
  </sect2>

  <sect2 id="linux-memory-overcommit">
   <title>Linux memory overcommit</title>

   <para>
    Dans Linux 2.4 et suivants, le comportement par défaut de la mémoire
    virtuelle n'est pas optimal pour <productname>PostgreSQL</productname>.
    Du fait de l'implémentation du <quote>memory overcommit</quote> par le
    noyau, celui-ci peut arrêter le serveur
    <productname>PostgreSQL</productname> (le processus serveur
    maître, <quote>postmaster</quote>) si les demandes de mémoire d'un autre
    processus provoque un manque de mémoire virtuelle au niveau du système.
   </para>

   <para>
    Si cela se produit, un message du noyau qui ressemble à ceci
    (consulter la documentation et la configuration du système pour savoir
    où chercher un tel message)&nbsp;:
<programlisting>Out of Memory: Killed process 12345 (postgres)</programlisting>
    peut survenir.
    Ceci indique que le processus <filename>postgres</filename> a été terminé
    à cause d'un problème de mémoire. Bien que les connexions en cours
    continuent de fonctionner normalement, aucune nouvelle
    connexion n'est acceptée. Pour revenir à un état normal,
    <productname>PostgreSQL</productname> doit être relancé.
   </para>

   <para>
    Une façon d'éviter ce problème revient à lancer
    <productname>PostgreSQL</productname> sur une machine où vous pouvez vous
    assurer que les autres processus ne mettront pas la machine en manque de
    mémoire. S'il y a peu de mémoire, augmenter la swap peut aider à éviter
    le problème car un système peut tuer des processus lorsque la mémoire
    physique et la mémoire swap sont utilisées entièrement.
   </para>

   <para>
    Sur Linux 2.6 et ultérieur, il est possible de modifier
    le comportement du noyau avec le <quote>overcommit memory</quote>.
    Bien que ce paramétrage n'empêchera pas ce <ulink
    url="http://lwn.net/Articles/104179/">comportement</ulink>, il réduira sa
    fréquence de façon significative et contribuera du coup à un système
    plus robuste. Ceci se fait en sélectionnant le mode strict de
    l'overcommit via <command>sysctl</command>&nbsp;:
<programlisting>sysctl -w vm.overcommit_memory=2</programlisting>
    ou en plaçant une entrée équivalente dans <filename>/etc/sysctl.conf</filename>.
    Vous pourriez souhaiter modifier le paramétrage relatif
    <varname>vm.overcommit_ratio</varname>. Pour les détails, voir la documentation du
    noyau (<filename>documentation/vm/overcommit-accounting</filename>).
   </para>

   <para>
    Une autre approche, qui peut aussi utiliser la modification de
    <varname>vm.overcommit_memory</varname>, est de configurer la valeur de la
    variable <varname>oom_adj</varname>, valeur par processus, pour le
    processus postmaster à <literal>-17</literal>, garantissant ainsi qu'il ne
    sera pas la cible de OOM. La façon la plus simple de le faire est
    d'exécuter
<programlisting>
echo -17 > /proc/self/oom_adj
</programlisting>
    dans le script de démarrage de postmaster juste avant d'appeler
    postmaster. Notez que cette action doit être faite en tant qu'utilisateur
    root. Dans le cas contraire, elle n'aura aucun effet. Du coup, un script
    de démarrage, exécuté par root, est le meilleur endroit où placer ce code.
    Si vous le faites, vous pourriez aussi souhaiter construire
    <productname>PostgreSQL</productname> avec l'option
    <literal>-DLINUX_OOM_ADJ=0</literal> ajoutée à <varname>CPPFLAGS</varname>.
    Cela fera en sorte que les processus enfants de postmaster seront exécutés
    avec la valeur <varname>oom_adj</varname> normale de zéro, pour que OOM
    puisse les cibler si nécessaire.
   </para>

   <note>
   <para>
    Quelques noyaux 2.4 de vendeurs ont des pré-versions de l'overcommit du
    2.6. Néanmoins, configurer <literal>vm.overcommit_memory</literal> à 2 sur un noyau
    2.4 qui n'a pas le code correspondant rendra les choses pires qu'elles
    n'étaient. Il est recommandé d'inspecter le code source du noyau (voir la
    fonction <function>vm_enough_memory</function> dans le fichier
    <filename>mm/mmap.c</filename>) pour vérifier ce qui est supporté dans votre noyau
    avant d'essayer ceci avec une installation 2.4. La présence du fichier de
    documentation <filename>overcommit-accounting</filename> ne devrait <emphasis>pas</emphasis>
    être pris comme une preuve de la présence de cette fonctionnalité. En cas de
    doute, consultez un expert du noyau ou le vendeur de votre noyau.
   </para>
   </note>
  </sect2>
 </sect1>


 <sect1 id="server-shutdown">
  <title>Arrêter le serveur</title>

  <indexterm zone="server-shutdown">
   <primary>arrêt</primary>
  </indexterm>

  <para>
   Il existe plusieurs façons d'arrêter le serveur de bases de données. Vous
   contrôlez le type d'arrêt en envoyant différents signaux au processus
   serveur maître.

   <variablelist>
    <varlistentry>
     <term><systemitem>sigterm</systemitem><indexterm><primary>sigterm</primary></indexterm></term>
     <listitem>
      <para>
       C'est le mode d'<firstterm>arrêt intelligent</firstterm>.
       Après réception de <systemitem>sigterm</systemitem>, le serveur
       désactive les nouvelles connexions mais permet aux sessions en cours de
       terminer leur travail normalement. Il s'arrête seulement après que toutes
       les sessions se sont terminées normalement. C'est l'arrêt intelligent
       (<firstterm>smart shutdown</firstterm>).
       Si le serveur est en mode de sauvegarde en ligne, il attends en plus la
       désactivation du mot de sauvegarde en ligne. Lorsque le mode de sauvegarde
       est actif, les nouvelles connexions sont toujours autorisées, mais
       seulement pour les superutilisateurs (cette exception permet à un
       superutilisateur de se connecter pour terminer le mode de sauvegarde en
       ligne). Si le serveur est en restauration quand une demande d'arrêt
       intelligent est envoyée, la restauration et la réplication en flux
       seront stoppées seulement une fois que toutes les autres sessions ont
       terminé.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>sigint</systemitem><indexterm><primary>sigint</primary></indexterm></term>
     <listitem>
      <para>
       C'est le mode d'<firstterm>arrêt rapide</firstterm>.
       Le serveur désactive les nouvelles connexions et envoie à tous
       les processus serveur le signal <systemitem>sigterm</systemitem>, qui les
       fera annuler leurs transactions courantes pour quitter rapidement. Il
       attend ensuite la fin de tous les processus serveur et s'arrête finalement.
       Si le serveur est en mode de sauvegarde en ligne, le mode est annulé,
       rendant la sauvegarde inutilisable.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>sigquit</systemitem><indexterm><primary>sigquit</primary></indexterm></term>
     <listitem>
      <para>
       C'est le mode d'<firstterm>arrêt immédiat</firstterm>.
       Le processus <command>postgres</command> maître envoie un signal
       <systemitem>sigquit</systemitem> à tous les processus fils et à quitter
       immédiatement non proprement. Les processus fils quittent immédiatement
       à réception du signal <systemitem>sigquit</systemitem>. ceci amènera une
       tentative de récupération (en rejouant les traces WAL) au prochain
       lancement. Ceci n'est recommandé que dans les cas d'urgence.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Le programme <xref linkend="app-pg-ctl"/> fournit une interface agréable
   pour envoyer ces signaux dans le but d'arrêter le serveur. Autrement, vous
   pouvez envoyer le signal directement en utilisant <command>kill</command>
   sur les systèmes autres que Windows. Le <acronym>PID</acronym> du processus
   <command>postgres</command> peut être trouvé en utilisant le programme
   <command>ps</command> ou à partir du fichier
   <filename>postmaster.pid</filename> dans le répertoire des données.
   Par exemple, pour exécuter un arrêt rapide&nbsp;:
<screen>$ <userinput>kill -int `head -1 /usr/local/pgsql/data/postmaster.pid`</userinput></screen>
  </para>

  <important>
   <para>
    Il vaux mieux de ne pas utiliser <systemitem>sigkill</systemitem> pour arrêter
    le serveur. Le faire empêchera le serveur de libérer la mémoire partagée et
    les sémaphores, ce qui pourrait devoir être fait manuellement avant qu'un
    nouveau serveur ne soit lancé. De plus, <systemitem>SIGKILL</systemitem> tue
    le processus <command>postgres</command> sans que celui-ci ait le temps de
    relayer ce signal à ses sous-processus, donc il sera aussi nécessaire de tuer
    les sous-processus individuels à la main.
   </para>
  </important>

  <para>
   Pour terminer une session individuelle tout en permettant aux autres de
   continuer, utilisez <function>pg_terminate_backend()</function> (voir <xref
   linkend="functions-admin-signal-table"/>) ou envoyez un signal
   <systemitem>SIGTERM</systemitem> au processus fils associé à cette session.
  </para>
 </sect1>

 <sect1 id="upgrading">
  <title>Mise à jour d'une instance <productname>PostgreSQL</productname></title>

  <indexterm zone="upgrading">
   <primary>mise à jour</primary>
  </indexterm>

  <indexterm zone="upgrading">
   <primary>version</primary>
   <secondary>compatibilité</secondary>
  </indexterm>

  <para>
   Cette section concerne la mise à jour des données de votre serveur
   d'une version de <productname>PostgreSQL</productname> vers une
   version ultérieure.
  </para>

  <para>
   Les versions majeures de <productname>PostgreSQL</productname> sont
   représentées par les deux premiers groupes de chiffres du numéro de
   version, par exemple 8.4. Les versions mineures de
   <productname>PostgreSQL</productname> sont représentées par le
   troisième groupe de chiffres, par exemple 8.4.2 est la deuxième
   version mineure de la 8.4. Les versions mineures ne modifient jamais
   le format de stockage interne et sont donc compatibles avec les
   versions antérieures et ultérieures de la même version majeure.
   Par exemple, le format 8.4.2 est compatible avec le format des
   versions 8.4, 8.4.1 et 8.4.6. Pour mettre à jour entre des versions
   compatibles, vous devez simplement remplacer les binaires une fois le
   serveur arrêté, puis redémarrer le serveur. Le répertoire des données
   ne doit pas être modifié. Les mises à jour de versions mineures sont
   aussi simples que ça.
  </para>

  <para>
   Pour les versions <emphasis>majeures</emphasis> de
   <productname>PostgreSQL</productname>, le format de stockage interne
   des données est sujet à modification, ce qui complique les mises à
   jour. La méthode traditionnelle de migration des données vers une
   nouvelle version majeure est de sauvegarder puis recharger la base
   de données. D'autres méthodes sont disponibles, ce qui est expliqué
   ci-dessous.
  </para>

  <para>
   De plus, les nouvelles versions majeures introduisent généralement
   des incompatibilités qui impactent les utilisateurs. Du coup, des
   modifications peuvent être nécessaires sur les applications clientes.
   Tous les changements visibles par les utilisateurs sont listés dans
   les notes de version (<xref linkend="release"/>). Soyez
   particulièrement attentif à la section Migration. Si vous mettez à
   jour en passant plusieurs versions majeures, assurez-vous de lire les
   notes de version de chaque version majeure que vous passez.
  </para>

  <para>
   Les utilisateurs précautionneux testeront leur applications clientes
   sur la nouvelle version avant de basculer complètement. Du coup, il
   est souvent intéressant de mettre en place des installations parallèles
   des ancienne et nouvelle versions. Lors d'un test d'une mise à jour
   majeure de <productname>PostgreSQL</productname>, pensez aux
   différentes catégories suivantes&nbsp;:
  </para>

  <variablelist>

   <varlistentry>
    <term>Administration</term>
    <listitem>
     <para>
      Les fonctionnalités disponibles pour les administrateurs pour
      surveiller et contrôler le serveur s'améliorent fréquemment à
      chaque nouvelle version.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>SQL</term>
    <listitem>
     <para>
      Cela inclut généralement les nouvelles commandes ou clauses SQL,
      et non pas des changements de comportement sauf si c'est
      spécifiquement précisé dans les notes de version.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>API</term>
    <listitem>
     <para>
      Les bibliothèques comme <application>libpq</application> se voient
      seulement ajouter de nouvelles fonctionnalités, sauf encore une
      fois si le contraire est mentionné dans les notes de version.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Catalogues systèmes</term>
    <listitem>
     <para>
      Les modifications dans les catalogues systèmes affectent seulement
      les outils de gestion des bases de données.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>API serveur pour le langage C</term>
    <listitem>
     <para>
      Ceci implique des modifications dans l'API des fonctions du moteur
      qui est écrit en C. De telles modifications affectent le code qui
      fait référence à des fonctions du moteur.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>

  <sect2 id="upgrade-methods-pgdump">
   <title>Mise à jour des données via <application>pg_dump</application></title>

   <para>
    Pour sauvegarder les données d'une version majeure de
    <productname>PostgreSQL</productname> et les recharger dans une
    autre, vous devez utiliser <application>pg_dump</application>&nbsp;;
    une sauvegarde au niveau système de fichiers ne fonctionnera pas.
    Des vérifications sont faites pour vous empêcher d'utiliser un
    répertoire de données avec une version incompatible de
    <productname>PostgreSQL</productname>, donc aucun mal ne sera fait
    si vous essayez de lancer un serveur d'une version majeure sur un
    répertoire de données créé par une autre version majeure.)
   </para>

   <para>
    Il est recommandé d'utiliser les programmes
    <application>pg_dump</application> et
    <application>pg_dumpall</application> provenant de la nouvelle
    version de <productname>PostgreSQL</productname>, pour bénéficier
    des améliorations apportées à ces programmes. Les versions actuelles
    de ces programmes peuvent lire des données provenant de tout serveur
    dont la version est supérieure ou égale à la 7.0.
   </para>

   <para>
    Ces instructions supposent que votre installation existante se
    trouve dans le répertoire <filename>/usr/local/pgsql</filename> et
    que le répertoire des données est
    <filename>/usr/local/pgsql/data</filename>. Remplacez ces chemins
    pour correspondre à votre installation.
   </para>

   <procedure>
    <step>
     <para>
      Si vous faites une sauvegarde, assurez-vous que votre base de
      données n'est pas en cours de modification. Cela n'affectera pas
      l'intégrité de la sauvegarde mais les données modifiées ne seront
      évidemment pas incluses. Si nécessaire, modifiez les droits dans
      le fichier <filename>/usr/local/pgsql/data/pg_hba.conf</filename>
      (ou équivalent) pour interdire l'accès à tout le monde sauf vous.
      Voir <xref linkend="client-authentication"/> pour plus
      d'informations sur le contrôle des accès.
     </para>

     <para>
      <indexterm>
       <primary>pg_dumpall</primary>
       <secondary>utilisation lors d'une mise à jour</secondary>
      </indexterm>

      Pour sauvegarder votre installation, exécutez la commande
      suivante&nbsp;:
<screen>
<userinput>pg_dumpall &gt; <replaceable>fichier_en_sortie</replaceable></userinput>
</screen>
      Si vous devez conserver les OID (parce que vous les utilisez en
      tant que clés étrangères, par exemple), utilisez l'option
      <option>-o</option> lors de l'exécution de
      <application>pg_dumpall</application>.
     </para>

     <para>
      Pour faire la sauvegarde, vous pouvez utiliser la commande
      <application>pg_dumpall</application> de la version en cours
      d'exécution. Néanmoins, pour de meilleurs résultats, essayez
      d'utiliser la commande <application>pg_dumpall</application>
      provenant de la version &version; de
      <productname>PostgreSQL</productname>, car cette version contient
      des corrections de bugs et des améliorations par rapport aux
      anciennes version. Bien que ce conseil peut sembler étonnant, étant
      donné que vous n'avez pas encore été la nouvelle version, il est
      conseillé de le suivre si vous souhaitez installer la nouvelle
      version en parallèle de l'ancienne. Dans ce cas, vous pouvez
      terminer l'installation normalement et transférer les données plus
      tard. Cela diminuera aussi le temps d'immobilisation.
     </para>
    </step>

    <step>
     <para>
      Arrêtez l'ancien serveur&nbsp;:
<screen>
<userinput>pg_ctl stop</userinput>
</screen>
      Sur les systèmes qui lancent <productname>PostgreSQL</productname>
      au démarrage, il existe probablement un script de démarrage qui
      fera la même chose. Par exemple, sur un système <systemitem
      class="osname">Red Hat Linux</systemitem>, cette commande
      pourrait fonctionner&nbsp;:
<screen>
<userinput>/etc/rc.d/init.d/postgresql stop</userinput>
</screen>
      Voir <xref linkend="runtime"/> pour des détails sur le lancement
      et l'arrêt d'un serveur.
     </para>
    </step>

    <step>
     <para>
      Lors de la restauration de la sauvegarde, renommez ou supprimez
      l'ancien répertoire d'installation. Il est préférable de le
      renommer car, en cas de problème, vous pourrez le récupérer. Garder
      en tête que le répertoire peut prendre beaucoup d'espace disque.
      Pour renommer le répertoire, utilisez une commande comme
      celle-ci&nbsp;:
<screen>
<userinput>mv /usr/local/pgsql /usr/local/pgsql.old</userinput>
</screen>
     (Assurez-vous de déplacer le répertoire en un seul coup, pour que
     les chemins relatifs restent inchangés.)
     </para>
    </step>

    <step>
     <para>
      Installez la nouvelle version de <productname>PostgreSQL</productname>
      comme indiqué dans <phrase>la section suivante</phrase>
      <phrase><xref linkend="install-procedure"/></phrase>.
     </para>
    </step>

    <step>
     <para>
      Créez une nouvelle instance de bases de données si nécessaire.
      Rappelez-vous que vous devez exécuter ces commandes une fois
      connecté en tant que l'utilisateur de bases de données (que vous
      devez déjà avoir si vous faites une mise à jour).
<programlisting>
<userinput>/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data</userinput>
</programlisting>
     </para>
    </step>

    <step>
     <para>
      Restaurez vos modifications dans les fichiers
      <filename>pg_hba.conf</filename> et
      <filename>postgresql.conf</filename>.
     </para>
    </step>

    <step>
     <para>
      Démarrez le serveur de bases de données, en utilisant encore une
      fois l'utilisateur de bases de données&nbsp;:
<programlisting>
<userinput>/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data</userinput>
</programlisting>
     </para>
    </step>

    <step>
     <para>
      Enfin, restaurez vos données à partir de votre sauvegarde&nbsp;:
<screen>
<userinput>/usr/local/pgsql/bin/psql -d postgres -f <replaceable>outputfile</replaceable></userinput>
</screen>
      en utilisant le <emphasis>nouveau</emphasis> <application>psql</application>.
     </para>
    </step>
   </procedure>

   <para>
    Il est possible de parvenir à une immobilisation moins longue en
    installant le nouveau serveur dans un autre répertoire et en
    exécutant l'ancien et le nouveau serveur, en parallèle, sur des
    ports différents. Vous pouvez ensuite utiliser quelque chose
    comme&nbsp;:

<programlisting>
pg_dumpall -p 5432 | psql -d postgres -p 5433
</programlisting>
    pour transférer vos données.
   </para>

  </sect2>

  <sect2 id="upgrading-methods-other">
   <title>Méthodes de mise à jour sans sauvegarde</title>

   <para>
    Le module <link linkend="pgupgrade">pg_upgrade</link> permet la
    migration d'une installation d'une version majeure de
    <productname>PostgreSQL</productname> à une autre, par modification
    des fichiers présents. Les mises à jour se réalisent en quelques
    minutes.
   </para>

   <para>
    Il est aussi possible d'utiliser certaines méthodes de réplication,
    comme <productname>Slony</productname>, pour créer un serveur esclave
    avec la version à jour de <productname>PostgreSQL</productname>.
    Ceci est possible car Slony permet une réplication entre des
    versions majeures différentes de
    <productname>PostgreSQL</productname>. L'esclave peut se trouver sur
    le même serveur ou sur un autre. Une fois qu'il est synchronisé
    avec le serveur maître (qui utilise toujours l'ancienne version de
    <productname>PostgreSQL</productname>), vous pouvez basculer le
    serveur maître sur le nouveau serveur et arrêter l'ancien maître.
    Ce type de bascule fait que l'arrêt requis pour la mise à jour se
    mesure seulement en secondes.
   </para>

  </sect2>
 </sect1>

 <sect1 id="preventing-server-spoofing">
  <title>Empêcher l'usurpation de serveur</title>

  <indexterm zone="preventing-server-spoofing">
   <primary>usurpation de serveur (server spoofing)</primary>
  </indexterm>

  <para>
   Quand le serveur est en cours d'exécution, un utilisateur pernicieux ne
   peut pas interférer dans les communications client/serveur. Néanmoins,
   quand le serveur est arrêté, un utilisateur local peut usurper le serveur
   normal en lançant son propre serveur. Le serveur usurpateur pourrait lire
   les mots de passe et requêtes envoyées par les clients, mais ne pourrait
   pas renvoyer de données car le répertoire <varname>PGDATA</varname> serait
   toujours sécurisé grâce aux droits d'accès du répertoire. L'usurpation
   est possible parce que tout utilisateur peut lancer un serveur de bases
   de données&nbsp;; un client ne peut pas identifier un serveur invalide
   sauf s'il est configuré spécialement.
  </para>

  <para>
   Le moyen le plus simple d'empêcher les serveurs invalides pour des
   connexions <literal>local</literal>es est d'utiliser un répertoire de
   socket de domaine Unix (<xref linkend="guc-unix-socket-directory"/>) qui
   a un droit en écriture accessible seulement par un utilisateur local de
   confiance. Ceci empêche un utilisateur mal intentionné de créer son
   propre fichier socket dans ce répertoire. Si vous êtes concerné que
   certaines applications pourraient toujours référencer
   <filename>/tmp</filename> pour le fichier socket et, du coup, être
   vulnérable au <quote>spoofing</quote>, lors de la création du lien
   symbolique <filename>/tmp/.s.PGSQL.5432</filename> pointant vers le fichier
   socket déplacé. Vous pouvez aussi avoir besoin de modifier votre script
   de nettoyage de <filename>/tmp</filename> pour empêcher la suppression du
   lien symbolique.
  </para>

  <para>
   Pour empêcher l'usurpation des connexions TCP, le mieux est d'utiliser des
   certificats SSL et de s'assurer que les clients vérifient le certificat du
   serveur. Pour cela, le serveur doit être configuré pour accepter les
   connexions <literal>hostssl</literal>
   (<xref linkend="auth-pg-hba-conf"/>) et avoir les fichiers SSL clé et certificat
   (<xref linkend="ssl-tcp"/>). Le client TCP
   doit se connecter en utilisant <literal>sslmode='verify-ca'</literal> ou
   <literal>'verify-full'</literal> et avoir le certificat racine installé
   (<xref linkend="libpq-connect"/>).
  </para>
 </sect1>
  
 <sect1 id="encryption-options">
  <title>Options de chiffrement</title>

  <indexterm zone="encryption-options">
   <primary>chiffrement</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> offre du chiffrement sur plusieurs niveaux
   et fournit une flexibilité pour protéger les données d'être révélées suite à
   un vol du serveur de la base de données, des administrateurs non scrupuleux
   et des réseaux non sécurisés. Le chiffrement pourrait aussi être requis pour
   sécuriser des données sensibles, par exemple des informations médicales ou des
   transactions financières.
  </para>

  <variablelist>

  <varlistentry>
   <term>chiffrement du mot de passe stocké</term>
   <listitem>

    <para>
     Par défaut, les mots de passe des utilisateurs de la base de données sont
     stockées suivant des hachages MD5, donc l'administrateur ne peut pas
     déterminer le mot de passe affecté à l'utilisateur. Si le cryptage MD5
     est utilisé pour l'authentification du client, le mot de passe non crypté
     n'est jamais présent temporairement sur le serveur parce que le client
     le crypte en MD5 avant de l'envoyer sur le réseau.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>chiffrement de colonnes spécifiques</term>

   <listitem>
    <para>
     Le module <xref linkend="pgcrypto"/> autorise le stockage crypté de certains
     champs. Ceci est utile si seulement certaines données sont sensibles.
     Le client fournit la clé de décryptage et la donnée est décryptée sur
     le serveur puis elle est envoyée au client.
    </para>

    <para>
     La donnée décryptée et la clé de déchiffrement sont présente sur le serveur
     pendant un bref moment où la donnée est décryptée, puis envoyée entre le
     client et le serveur. Ceci présente un bref moment où la données et les
     clés peuvent être interceptées par quelqu'un ayant un accès complet au
     serveur de bases de données, tel que l'administrateur du système.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>chiffrement de la partition de données</term>

   <listitem>
    <para>
     Sur Linux, le chiffrement peut se faire au niveau du montage d'un système
     de fichiers en utilisant un <quote>périphérique loopback</quote>. Ceci
     permet à une partition entière du système de fichiers d'être cryptée et
     décryptée par le système d'exploitation. Sur FreeBSD, la fonctionnalité
     équivalent est appelé <quote>geom based disk encryption</quote>
     (<acronym>gbde</acronym>), et beaucoup d'autres systèmes d'exploitations,
     comme Windows, supportent cette fonctionnalité.
    </para>

    <para>
     Ce mécanisme empêche les données non cryptées d'être lues à partir des
     lecteurs s'ils sont volés. Ceci ne protège pas contre les attaques quand
     le système de fichiers est monté parce que, une fois monté, le système
     d'exploitation fournit une vue non cryptée des données. Néanmoins, pour
     monter le système de fichiers, vous avez besoin d'un moyen pour fournir
     la clé de chiffrement au système d'exploitation et, quelque fois, la clé
     est stocké quelque part près de l'hôte qui monte le disque.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>chiffrement des mots de passe sur le réseau</term>

   <listitem>
     <para>
      La méthode d'authentification <literal>md5</literal> crypte deux fois le mot de
      passe sur le client avant de l'envoyer au serveur. Il le crypte tout
      d'abord à partir du nom de l'utilisateur puis il le crypte à partir d'un
      élément du hasard envoyé par le serveur au moment de la connexion. Cette
      valeur, deux fois cryptée, est envoyée sur le réseau au serveur. Le double
      chiffrement empêche non seulement la découverte du mot de passe, il empêche
      aussi une autre connexion en utilisant le même mot de passe crypté pour
      se connecter au serveur de bases de données lors d'une connexion future.
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
   <term>chiffrement des données sur le réseau</term>

    <listitem>
     <para>
      Les connexions SSL cryptent toutes les données envoyées sur le
      réseau&nbsp;: le mot de passe, les requêtes et les données renvoyées. Le
      fichier <filename>pg_hba.conf</filename> permet aux administrateurs de spécifier
      quels hôtes peuvent utiliser des connexions non cryptées (<literal>host</literal>)
      et lesquels requièrent des connexions SSL (<literal>hostssl</literal>). De plus,
      les clients peuvent spécifier qu'ils se connectent aux serveurs seulement
      via SSL. <application>stunnel</application> ou <application>ssh</application> peuvent aussi
      être utilisés pour crypter les transmissions.
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
   <term>authentification de l'hôte ssl</term>

   <listitem>
    <para> 
     Il est possible que le client et le serveur fournissent des certificats
     SSL à l'autre. Cela demande une configuration supplémentaire
     de chaque côté mais cela fournit une vérification plus forte de l'identité
     que la simple utilisation de mots de passe. Cela empêche un ordinateur de
     se faire passer pour le serveur assez longtemps pour lire le mot de passe
     envoyé par le client. Cela empêche aussi les attaques du type <quote>man
     in the middle</quote> où un ordinateur, entre le client et le serveur,
     prétend être le serveur, lit et envoie les données entre le client et le
     serveur.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>chiffrement côté client</term>

   <listitem>
    <para>
     Si vous n'avez pas confiance en l'administrateur système du serveur, il
     est nécessaire
     que le client crypte les données&nbsp;; de cette façon, les données non
     cryptées n'apparaissent jamais sur le serveur de la base de données. Les
     données sont cryptées sur le client avant d'être envoyé au serveur, et les
     résultats de la base de données doivent être décryptés sur le client avant
     d'être utilisés.
    </para>
   </listitem>
  </varlistentry>

  </variablelist>

 </sect1>

 <sect1 id="ssl-tcp">
  <title>Connexions tcp/ip sécurisées avec ssl</title>

  <indexterm zone="ssl-tcp">
   <primary>ssl</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> dispose d'un support natif pour l'utilisation de
    connexions <acronym>ssl</acronym>, cryptant ainsi les communications
    clients/serveurs pour une sécurité améliorée. Ceci requiert l'installation
    d'<productname>openssl</productname> à la fois sur le système client et sur
    le système serveur et que ce support soit activé au moment de la
    construction de <productname>PostgreSQL</productname> (voir le <xref
    linkend="installation"/>).
  </para>

  <para>
   Avec le support <acronym>ssl</acronym> compilé, le serveur
   <productname>PostgreSQL</productname> peut être lancé avec
   <acronym>ssl</acronym> activé en activant <xref linkend="guc-ssl"/> dans
   <filename>PostgreSQL.conf</filename>. Le serveur écoutera les deux
   connexions, standard et <acronym>SSL</acronym> sur le même port TCP, et
   négociera avec tout client l'utilisation de <acronym>SSL</acronym>. Par
   défaut, le client peut choisir cette option&nbsp;; voir <xref
   linkend="auth-pg-hba-conf"/> sur la façon de configurer le serveur pour
   réclamer l'utilisation de <acronym>SSL</acronym> pour certaines, voire
   toutes les connexions.
  </para>

  <para>
   <productname>PostgreSQL</productname> lit le fichier de configuration
   d'<productname>OpenSSL</productname> pour le serveur. Par défaut, ce
   fichier est nommé <filename>openssl.cnf</filename> et est situé dans le
   répertoire indiqué par <literal>openssl version -d</literal>.
   Cette valeur par défaut peut être surchargée en configurant la variable
   d'environnement <envar>OPENSSL_CONF</envar> avec le nom du fichier de
   configuration désiré.
  </para>

  <para>
   <productname>OpenSSL</productname> accepte une gamme étendue d'algorithmes
   de chiffrement et d'authentification, de différentes forces. Bien qu'une
   liste d'algorithmes de chiffrement peut être indiquée dans le fichier de
   configuration d'<productname>OpenSSL</productname>, vous pouvez spécifier
   des algorithmes spécifiques à utiliser par le serveur de la base de
   données en modifiant le paramètre <xref linkend="guc-ssl-ciphers"/> dans
   <filename>postgresql.conf</filename>.
  </para>

  <note>
   <para>
    Il est possible d'avoir une authentification sans le chiffrement en
    utilisant les algorithmes <literal>NULL-SHA</literal> ou
    <literal>NULL-MD5</literal>. Néanmoins, une attaque du type
    <foreignphrase>man-in-the-middle</foreignphrase> pourrait lire et passer
    les communications entre client et serveur. De plus, le temps pris par
    le chiffrement est minimal comparé à celui pris par l'authentification.
    Pour ces raisons, les algorithmes NULL ne sont pas recommandés.
   </para>
  </note>

  <para>
   To start in <acronym>SSL</acronym> mode, files containing the server certificate
   and private key must exist.  By default, these files are expected to be
   named <filename>server.crt</filename> and <filename>server.key</filename>, respectively, in
   the server's data directory, but other names and locations can be specified
   using the configuration parameters <xref linkend="guc-ssl-cert-file"/>
   and <xref linkend="guc-ssl-key-file"/>.
   Sur les systèmes Unix, les droits de <filename>server.key</filename> doivent
   interdire l'accès au groupe et au reste du monde&nbsp;; cela se fait avec
   la commande <command>chmod 0600 server.key</command>. Si
   la clé privée est protégée par une phrase de passe, le serveur la
   demandera et ne se lancera pas tant qu'elle n'aura pas été saisie.
  </para>

  <para>
   Dans certains cas, le certificat du serveur peut être signé par une
   autorité <quote>intermédiaire</quote> de certificats, plutôt que par un
   qui soit directement de confiance par les clients. Pour utiliser un tel
   certificat, ajoutez le certificat de l'autorité signataire au fichier
   <filename>server.crt</filename>, puis le certificat de l'autorité parente,
   et ainsi de suite jusqu'à l'autorité racine qui est acceptée par les
   clients. Le certificat racine doit être inclus dans chaque cas où
   <filename>server.crt</filename> contient plus d'un certificat.
  </para>

  <sect2 id="ssl-client-certificates">
   <title>Utiliser des certificats clients</title>
   
  <para>
   Pour réclamer l'envoi d'un certificat de confiance par le client, placez
   les certificats des autorités (<acronym>CA</acronym>) de confiance dans
   le fichier <filename>root.crt</filename> du répertoire des données,
   set the parameter <xref linkend="guc-ssl-ca-file"/> in
   <filename>postgresql.conf</filename> to <literal>root.crt</literal>,
   and configurez le paramètre <literal>clientcert</literal> à 1
   sur la ligne <literal>hostssl</literal> appropriée dans le fichier
   <filename>pg_hba.conf</filename>. Un
   certificat pourra ensuite être réclamé lors du lancement de la connexion
   SSL. (Voir <xref linkend="libpq-ssl"/> pour une description de la
   configuration de certificats sur le client.) Le serveur vérifiera que le
   certificat du client est signé par une des autorités de confiance. Les
   entrées de la liste de révocation des certificats sont aussi vérifiées
   si le paramètre <xref linkend="guc-ssl-crl-file"/> est configuré.
   <!-- If this URL changes replace it with a URL to www.archive.org. -->
   (Voir les <ulink
   url="http://h71000.www7.hp.com/DOC/83final/BA554_90007/ch04s02.html">diagrammes montrant l'utilisation des certificats SSL</ulink>.)
  </para>

  <para>
   L'option <literal>clientcert</literal> de <filename>pg_hba.conf</filename>
   est disponible pour toutes les méthodes d'authentification, mais seulement
   pour les lignes spécifiées <literal>hostssl</literal>. Quand
   <literal>clientcert</literal> n'est pas précisé ou qu'il est configuré à
   0, le serveur vérifiera toujours les certificats clients
   présentés avec sa liste CA si elle est configurée &mdash;
   mais il ne forcera pas la présentation d'un certificat client.
  </para>

  <para>
   Notez que <filename>root.crt</filename> liste les autorités de certificats
   de haut-niveau, ceux suffisamment de confiance pour signer les certificats
   des clients. En principe, il n'a pas besoin de lister l'autorité de
   certificats qui a signé le certificat du serveur bien que dans la plupart
   des cas, cette autorité sera aussi de confiance pour les certificats de
   clients.
  </para>

  <para>
   Si vous configurez les certificats de clients, vous pouvez utiliser la
   méthode d'authentification <literal>cert</literal>, de façon à ce que
   les certificats soient aussi utilisés pour contrôler l'authentification de
   l'utilisateur, tout en fournissant une sécurité de connexion. Voir <xref
   linkend="auth-cert"/> pour les détails.
  </para>
  </sect2>

  <sect2 id="ssl-server-files">
   <title>Utilisation des fichiers serveur SSL</title>

   <para>
    <xref linkend="ssl-file-usage"/> résume les fichiers qui ont un lien
    avec la configuration de SSL sur le serveur. (The shown file names are default
    or typical names.  The locally configured names could be different.)
   </para>

  <table id="ssl-file-usage">
   <title>Utilisation des fichiers serveur SSL</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Fichier</entry>
      <entry>Contenu</entry>
      <entry>Effet</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><xref linkend="guc-ssl-cert-file"/> (<filename>$PGDATA/server.crt</filename>)</entry>
      <entry>certificat du serveur</entry>
      <entry>envoyé au client pour indiquer l'identité du serveur</entry>
     </row>

     <row>
      <entry><xref linkend="guc-ssl-key-file"/> (<filename>$PGDATA/server.key</filename>)</entry>
      <entry>clé privée du serveur</entry>
      <entry>prouve que le certificat serveur est envoyé par son
      propriétaire&nbsp; n'indique pas que le propriétaire du certificat est
      de confiance</entry>
     </row>

     <row>
      <entry><xref linkend="guc-ssl-ca-file"/> (<filename>$PGDATA/root.crt</filename>)</entry>
      <entry>autorités de confiance pour les certificats</entry>
      <entry>vérifie le certificat du client&nbsp;; vérifie que le certificat
      du client est signé par une autorité de confiance</entry>
     </row>

     <row>
      <entry><xref linkend="guc-ssl-crl-file"/> (<filename>$PGDATA/root.crl</filename>)</entry>
      <entry>certificats révoqués par les autorités de confiance</entry>
      <entry>le certificat du client ne doit pas être sur cette liste</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Les fichiers <filename>server.key</filename>,
   <filename>server.crt</filename>, <filename>root.crt</filename> et
   <filename>root.crl</filename> (or their configured alternative names)
   sont seulement examinés au démarrage du
   serveur&nbsp;; donc vous devez démarrer le serveur pour que les changements
   prennent effet.
  </para>

  </sect2>

  <sect2 id="ssl-certificate-creation">
   <title>Créer un certificat auto-signé</title>

   <para>
    Pour créer rapidement un certificat signé soi-même pour le serveur,
    utilisez la commande <productname>OpenSSL</productname> suivante&nbsp;:
<programlisting>
openssl req -new -text -out server.req
</programlisting>
    Remplissez l'information que <application>openssl</application> demande.
    Assurez-vous de saisir le nom de l'hôte local dans <quote>Common
    Name</quote>&nbsp;; le mot de passe peut ne pas être saisi. Le programme
    générera une clé qui est protégée par une phrase de passe&nbsp;; il
    n'acceptera pas une phrase de passe qui fait moins de quatre caractères
    de long. Pour la supprimer (vous le devez si vous voulez un démarrage
    automatique du serveur), exécutez les commandes suivantes&nbsp;:
<programlisting>
openssl rsa -in privkey.pem -out server.key
rm privkey.pem
</programlisting>
    Saisissez l'ancienne phrase de passe pour déverrouiller la clé existante.
    Maintenant, lancez&nbsp;:
<programlisting>
openssl req -x509 -in server.req -text -key server.key -out server.crt
</programlisting>
    pour transformer le certificat en un certificat auto-signé et pour copier
    la clé et le certificat là où le serveur les cherchera. 
    Enfin, faites&nbsp;:
<programlisting>
chmod og-rwx server.key
</programlisting>
    car le serveur rejetera le fichier si ses droits sont plus importants.
    Pour plus de détails sur la façon de créer la clé privée et le certificat
    de votre serveur, référez-vous à la documentation
    d'<productname>OpenSSL</productname>.
   </para>

   <para>
    Un certificat auto-signé peut être utilisé pour tester, mais un
    certificat signé par une autorité (<acronym>CA</acronym>) (un des
    <acronym>CAs</acronym> global ou un local) devra être utilisé lorsque
    le serveur sera en production pour que le client puisse vérifier
    l'identité du serveur. Si tous les clients sont locaux à l'organisation,
    utiliser un <acronym>CA</acronym> local est recommandé.
   </para>

  </sect2>
 </sect1>

 <sect1 id="ssh-tunnels">
  <title>Connexions tcp/ip sécurisées avec des tunnels
   <application>ssh</application> tunnels</title>

  <indexterm zone="ssh-tunnels">
   <primary>ssh</primary>
  </indexterm>

  <para>
   Il est possible d'utiliser <application>ssh</application> pour chiffrer la
   connexion réseau entre les clients et un serveur
   <productname>PostgreSQL</productname>. Réalisé correctement, ceci fournit une
   connexion réseau sécurisée, y compris pour les clients non SSL.
  </para>

  <para>
   Tout d'abord, assurez-vous qu'un serveur <application>ssh</application> est
   en cours d'exécution sur la même machine que le serveur
   <productname>PostgreSQL</productname> et que vous pouvez vous connecter via
   <command>ssh</command> en tant qu'un utilisateur quelconque. Ensuite, vous
   pouvez établir un tunnel sécurisé avec une commande comme ceci sur la machine
   cliente&nbsp;:
<programlisting>ssh -L 63333:localhost:5432 joe@foo.com</programlisting>
   Le premier numéro de l'argument <option>-l</option>, 63333, est le numéro de
   port de votre bout du tunnel&nbsp;; il peut être choisi parmi tous les ports
   non utilisés.
   (IANA réserve les ports 49152 à 65535 pour une utilisation privée.)  Le second
   numéro, 5432, est le bout distant du tunnel&nbsp;: le numéro de port que votre
   serveur utilise. Le nom ou l'adresse entre les numéros de port est l'hôte
   disposant du serveur de bases de données auquel vous souhaitez vous connecter,
   comme vu à partir de l'hôte où vous vous connectez, qui est
   <literal>foo.com</literal> dans cet exemple. Pour vous connecter au serveur
   en utilisant ce tunnel, vous vous connectez au port 63333 de la machine
   locale&nbsp;:
<programlisting>psql -h localhost -p 63333 postgres</programlisting>
   Sur le serveur de bases de données, il semblera que vous êtes réellement
   l'utilisateur <literal>joe</literal> sur l'hôte <literal>foo.com</literal>
   en vous connectant à <literal>localhost</literal> dans ce contexte, et il
   utilisera la procédure d'authentification configurée pour les connexions
   de cet utilisateur et de cet hôte. Notez que le serveur ne pensera pas que
   la connexion est chiffrée avec SSL car, en effet, elle n'est pas chiffrée
   entre le serveur <application>SSH</application> et le serveur
   <productname>PostgreSQL</productname>. Cela ne devrait pas poser un risque
   de sécurité supplémentaire si les deux serveurs sont sur la même machine.
  </para>

  <para>
   Pour réussir la configuration du tunnel, vous devez être autorisé pour vous
   connecter via <command>ssh</command> sur <literal>joe@foo.com</literal>,
   comme si vous aviez tenté d'utiliser <command>ssh</command> pour créer
   une session de terminal.
  </para>

  <para>
   Vous pouvez aussi configurer la translation de port de cette façon&nbsp;:
<programlisting>
ssh -L 63333:foo.com:5432 joe@foo.com
</programlisting>
   mais alors le serveur de la base de données verra la connexion venir de
   son interface <literal>foo.com</literal> qui n'est pas ouverte par son
   paramétrage par défaut <literal>listen_addresses =
   'localhost'</literal>. Ceci n'est pas habituellement ce que vous êtes.
  </para>

  <para>
   Si vous devez vous connecter au serveur de bases de données via un hôte de
   connexion, une configuration possible serait&nbsp;:
<programlisting>
ssh -L 63333:db.foo.com:5432 joe@shell.foo.com
</programlisting>
   Notez que de cette façon la connexion de <literal>shell.foo.com</literal>
   à <literal>db.foo.com</literal> ne sera pas chiffrée par le tunnel SSH.
   SSH offre un certain nombre de possibilités de configuration quand le
   réseau est restreint. Merci de vous référer à la documentation de SSH pour
   les détails.
  </para>

  <tip>
   <para>
    Plusieurs autres applications existantes peuvent fournir des tunnels
   sécurisés en utilisant une procédure similaire dans le concept à celle que
   nous venons de décrire.
   </para>
  </tip>

 </sect1>

 <sect1 id="event-log-registration">
  <title>Registering <application>Event Log</application> on <systemitem
  class="osname">Windows</systemitem></title>

  <indexterm zone="event-log-registration">
   <primary>event log</primary>
   <secondary>event log</secondary>
  </indexterm>

  <para>
   To register a <systemitem class="osname">Windows</systemitem>
   <application>event log</application> library with the operating system,
   issue this command:
<screen>
<userinput>regsvr32 <replaceable>pgsql_library_directory</replaceable>/pgevent.dll</userinput>
</screen>
   This creates registry entries used by the event viewer, under the default
   event source named <literal>PostgreSQL</literal>.
  </para>

  <para>
   To specify a different event source name (see
   <xref linkend="guc-event-source"/>), use the <literal>/n</literal>
   and <literal>/i</literal> options:
<screen>
<userinput>regsvr32 /n /i:<replaceable>event_source_name</replaceable> <replaceable>pgsql_library_directory</replaceable>/pgevent.dll</userinput>
</screen>
  </para>

  <para>
   To unregister the <application>event log</application> library from
   the operating system, issue this command:
<screen>
<userinput>regsvr32 /u [/i:<replaceable>event_source_name</replaceable>] <replaceable>pgsql_library_directory</replaceable>/pgevent.dll</userinput>
</screen>
  </para>

  <note>
   <para>
    To enable event logging in the database server, modify
    <xref linkend="guc-log-destination"/> to include
    <literal>eventlog</literal> in <filename>postgresql.conf</filename>.
   </para>
  </note>
 </sect1>

</chapter>
