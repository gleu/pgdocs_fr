<?xml version="1.0" encoding="UTF-8"?>
<chapter id="runtime">
 <title>Configuration du serveur et mise en place</title>

 <para>
  Ce chapitre discute de la configuration, du lancement du serveur de bases de
  données et de ses interactions avec le système d'exploitation.
 </para>

 <para>
  Les directions dans ce chapitre supposent que vous travaillez avec un
  serveur <productname>PostgreSQL</productname> standard, sans infrastructure
  supplémentaire, par exemple une copie que vous aurez construit à partir des
  sources, d'après la méthode indiquée dans les chapitres précédents. Si vous
  travaillez avec une version de <productname>PostgreSQL</productname>
  pré-packagée ou fournie par un vendeur, il est probable que le développeur
  du package a fait quelques modifications pour l'installation et le démarrage
  du serveur suivant les conventions de votre système. Consultez la
  documentation du package pour les détails.
 </para>

 <sect1 id="postgres-user">
  <title>Compte utilisateur <productname>PostgreSQL</productname></title>

  <indexterm>
   <primary>utilisateur postgres</primary>
  </indexterm>

  <para>
   Comme avec tout démon serveur accessible au monde externe, il est conseillé
   de lancer <productname>PostgreSQL</productname> sous un compte utilisateur
   séparé. Ce compte devrait seulement être le propriétaire des données gérées
   par le serveur et ne devrait pas être partagé avec d'autres démons (par
   exemple, utiliser l'utilisateur <literal>nobody</literal> est une mauvaise
   idée). En particulier, il est conseillé que ce compte utilisateur ne soit
   pas le propriétaire des exécutables du serveur
   <productname>PostgreSQL</productname> pour s'assurer qu'un processus
   serveur compromis ne pourra pas modifier ces exécutables.
  </para>

  <para>
   Les versions pré-packagées de <productname>PostgreSQL</productname> créera
   habituellement un compte utilisateur convenable, automatiquement, lors de
   l'installation du paquet.
  </para>

  <para>
   Pour ajouter un compte utilisateur Unix, jetez un œil à la commande
   <command>useradd</command> ou <command>adduser</command> de votre système.
   Le nom de l'utilisateur <systemitem>postgres</systemitem> est souvent utilisé
   et l'est sur tout le livre, mais vous pouvez utiliser un autre nom si vous le
   souhaitez.
  </para>
 </sect1>

 <sect1 id="creating-cluster">
  <title>Créer un groupe de base de données</title>

  <indexterm>
   <primary>groupe de bases de données</primary>
  </indexterm>

  <indexterm>
   <primary>emplacement des données</primary>
   <see>groupe de bases de données</see>
  </indexterm>

  <para>
   Avant de faire quoi que ce soit, vous devez initialiser un emplacement de
   stockage pour la base de données. Nous appelons ceci un <firstterm>groupe de
    bases de données</firstterm> (le standard <acronym>SQL</acronym> utilise
   le terme de groupe de catalogues). Un groupe de bases de données est une
   collection de bases données et est géré par une seule instance d'un
   serveur de bases de données en cours d'exécution. Après initialisation, un
   groupe de bases de données contiendra une base de données nommée
   <literal>postgres</literal>, qui a pour but d'être la base de données par
   défaut utilisée par les outils, les utilisateurs et les applications
   tiers. Le serveur de la base de données lui-même ne requiert pas la présence
   de la base de données <literal>postgres</literal> mais beaucoup d'outils
   supposent son existence. Une autre base de données est créée à l'intérieur
   de chaque groupe lors de l'initialisation. Elle est appelée
   <literal>template1</literal>. Comme le nom le suggère, elle sera utilisée
   comme modèle pour les bases de données créées après&nbsp;; elle ne devrait
   pas être utilisée pour un vrai travail (voir le <xref
   linkend="managing-databases"/> pour des informations sur la création de
   nouvelles bases de données dans le groupe).
  </para>

  <para>
   En terme de système de fichiers, un groupe de bases de données est un
   simple répertoire sous lequel les données seront stockées. Nous l'appelons
   le <firstterm>répertoire de données</firstterm> ou l'<firstterm>emplacement
    des données</firstterm>. Le choix de cet emplacement vous appartient
   complètement. Il n'existe pas de valeur par défaut bien que les
   emplacements tels que <filename>/usr/local/pgsql/data</filename> ou
   <filename>/var/lib/pgsql/data</filename> sont populaires. Le répertoire de
   données doit être initialisé avant d'être utilisé, en utilisant le
   programme <xref
   linkend="app-initdb"/><indexterm><primary>initdb</primary></indexterm> qui
   est installé avec <productname>PostgreSQL</productname>.
  </para>

  <para>
   Si vous utilisez une version pré-packagée de
   <productname>PostgreSQL</productname>, il pourrait bien avoir une
   convention spécifique pour l'emplacement du répertoire de données, et il
   pourrait aussi fournir un script pour créer le répertoire de données. Dans
   ce cas, il est conseillé d'utiliser ce script plutôt que d'exécuter
   directement <command>initdb</command>. Consultez la documentation du paquet
   pour les détails.
  </para>

  <para>
   Pour initialiser un groupe de bases de données, exécutez la commande
   <command>initdb</command> et indiquez l'emplacement désiré sur le système
   de fichiers de l'instance avec l'option <option>-D</option>, par exemple
   <screen><prompt>$</prompt> <userinput>initdb -D /usr/local/pgsql/data</userinput></screen>
   Notez que vous devez exécuter cette commande en étant connecté sous le
   compte de l'utilisateur <productname>PostgreSQL</productname> décrit dans
   la section précédente.
  </para>

  <tip>
   <para>
    Comme alternative à l'option <option>-d</option>, vous pouvez initialiser
    la variable d'environnement <envar>pgdata</envar>.
    <indexterm><primary><envar>pgdata</envar></primary></indexterm>
   </para>
  </tip>

  <para>
   Autrement, vous pouvez exécuter <command>initdb</command> via le programme
   <xref linkend="app-pg-ctl"/><indexterm><primary>pg_ctl</primary></indexterm>
   ainsi&nbsp;:
<screen>
<prompt>$</prompt> <userinput>pg_ctl -D /usr/local/pgsql/data initdb</userinput>
   </screen>
   C'est peut-être plus intuitif si vous utilisez déjà
   <command>pg_ctl</command> pour démarrer et arrêter le serveur (voir <xref
   linkend="server-start"/> pour les détails). Un gros intérêt est de ne
   connaître que cette seule commande pour gérer l'instance du serveur de
   bases de données.
  </para>

  <para>
   <command>initdb</command> tentera de créer le répertoire que vous avez
   spécifié si celui-ci n'existe pas déjà. Bien sûr, cela peut échouer si
   <command>initdb</command> n'a pas les droits pour écrire dans le répertoire
   parent. Il est généralement recommandé que l'utilisateur
   <productname>PostgreSQL</productname> soit propriétaire du répertoire des
   données, mais aussi du répertoire parent pour que ce problème ne se
   présente pas. Si le répertoire parent souhaité n'existe pas plus, vous
   aurez besoin de le créer, en utilisant les droits de l'utilisateur root si
   nécessaire. Le processus pourrait ressembler à ceci&nbsp;:
   <screen>root# <userinput>mkdir /usr/local/pgsql</userinput>
root# <userinput>chown postgres /usr/local/pgsql</userinput></screen>
  </para>

  <para>
   <command>initdb</command> refusera de s'exécuter si le répertoire des données
   existe et contient déjà des fichiers. Cela permet de prévenir tout écrasement
   accidentel d'une installation existante.
  </para>

  <para>
   Comme le répertoire des données contient toutes les données stockées
   dans la base, il est essentiel qu'il soit protégé contre les
   accès non autorisés. En conséquence, <command>initdb</command>
   supprime les droits d'accès à tout le monde sauf à l'utilisateur
   <productname>PostgreSQL</productname>, et optionnellement au groupe.
   L'accès au groupe, s'il est autorisé, est en lecture seule.
   Cela permet à un utilisateur non privilégié, du même groupe que le
   propriétaire de l'instance, de faire une sauvegarde des fichiers ou d'effectuer
   des opérations qui ne requièrent qu'un accès en lecture.
  </para>

  <para>
   Notez qu'activer ou désactiver l'accès au groupe sur une instance
   préexistante exige qu'elle soit arrêtée et que les droits soient mis en place
   sur tous les répertoires et fichiers avant de redémarrer <productname>PostgreSQL</productname>.

   Sinon, un mélange des droits pourrait exister dans le répertoire de données.
   Pour les instances qui ne donnent accès qu'au propriétaire, les droits
   appropriés sont <literal>0700</literal> sur les répertoires et
   <literal>0600</literal> sur les fichiers. Pour les instances qui permettent
   aussi la lecture par le groupe, les droits appropriés sont
   <literal>0750</literal> sur les répertoires et <literal>0640</literal>
   sur les fichiers.
  </para>

  <para>
   Néanmoins, bien que le contenu du répertoire soit sécurisé, la configuration
   d'authentification du client par défaut permet à tout utilisateur local de se
   connecter à la base de données et même à devenir le super-utilisateur de
   la base de données. Si vous ne faites pas confiance aux utilisateurs
   locaux, nous vous recommandons d'utiliser une des options <option>-w</option> ou
   <option>--pwprompt</option> de la commande <command>initdb</command> pour
   affecter un mot de passe au super-utilisateur de la base de
   données <indexterm><primary>mot de passe</primary><secondary>du
   super-utilisateur</secondary></indexterm>. De plus, spécifiez <option>-a md5</option> ou
   <option>-a mot_de_passe</option> de façon à ce que la méthode d'authentification
   <literal>trust</literal> par défaut ne soit pas utilisée&nbsp;; ou modifiez le fichier
   <filename>pg_hba.conf</filename> généré après l'exécution
   d'<command>initdb</command> (d'autres
   approches raisonnables incluent l'utilisation de l'authentification
   <literal>peer</literal> ou les droits du système de fichiers pour
   restreindre les connexions. Voir le <xref
   linkend="client-authentication"/> pour plus d'informations).
  </para>

  <para>
   <command>initdb</command> initialise aussi la
   locale<indexterm><primary>locale</primary></indexterm> par défaut du groupe de bases de
   données. Normalement, elle prends seulement le paramétrage local dans
   l'environnement et l'applique à la base de données initialisée. Il est
   possible de spécifier une locale différente pour la base de données&nbsp;;
   la <xref linkend="locale"/> propose plus d'informations là-dessus.
   L'ordre de tri utilisé par défaut pour ce cluster de bases de données est
   initialisé par <command>initdb</command> et, bien que vous pouvez créer de
   nouvelles bases de données en utilisant des ordres de tris différents, l'ordre
   utilisé dans les bases de données modèle que initdb a créé ne peut pas être
   modifié sans les supprimer et les re-créer. Cela a aussi un impact sur les
   performances pour l'utilisation de locales autres que <literal>c</literal>
   ou <literal>posix</literal>. Du coup, il est important de faire ce choix
   correctement la première fois.
  </para>

  <para>
   <command>initdb</command> configure aussi le codage par défaut de l'ensemble
   de caractères pour le groupe de bases de données. Normalement, cela doit
   être choisi pour correspondre au paramétrage de la locale. Pour les détails,
   voir la <xref linkend="multibyte"/>.
  </para>

  <para>
   Les locales différentes de <literal>C</literal> et <literal>POSIX</literal>
   se basent sur la bibliothèque de collationnement du système pour le tri
   dépendant du jeu de caractères. Cela contrôle l'ordre des clés stockées
   dans les index. Pour cette raison, une instance ne peut pas basculer vers
   une version incompatible de la bibliothèque de collationnement, que ce soit
   pour une restauration d'une sauvegarde PITR mais aussi pour de la
   réplication binaire en flux ou pour un système d'exploitation différent, ou
   une mise à jour du système d'exploitation.
  </para>

  <sect2 id="creating-cluster-mount-points">
   <title>Utilisation de systèmes de fichiers secondaires</title>

   <indexterm zone="creating-cluster-mount-points">
    <primary>points de montage d'un système de fichiers</primary>
   </indexterm>

   <para>
    Beaucoup d'installations créent leur instance dans des systèmes de fichiers
    (volumes) autres que le volume racine de la machine. Si c'est votre choix,
    il est déconseillé d'utiliser le répertoire
    principal de ce volume secondaire (son point de montage) comme répertoire de
    données. Une meilleure pratique est de créer un répertoire au sein
    du point de montage, répertoire possédé par l'utilisateur
    <productname>PostgreSQL</productname>, puis de créer le
    répertoire de données à l'intérieur. Ceci évite des problèmes de droits,
    tout particulièrement lors d'opérations comme
    <application>pg_upgrade</application>, et garantit aussi des échecs
    propres si le volume secondaire n'est pas disponible.
   </para>

  </sect2>

  <sect2 id="creating-cluster-filesystem">
   <title>Systèmes de fichiers</title>

   <para>
    De manière générale, tout système de fichiers avec une sémantique POSIX
    est utilisable avec PostgreSQL. Les utilisateurs peuvent en choisir
    de différents pour diverses raisons, comme le support du fournisseur,
    la performance ou la familiarité. L'expérience montre que,
    toutes choses égales par ailleurs, on ne doit pas espérer de grosses
    différences de performances ou de comportement en changeant juste de système
    de fichiers ni en faisant de petites modifications de sa configuration.
   </para>

   <sect3 id="creating-cluster-nfs">
    <title>NFS</title>

    <indexterm zone="creating-cluster-nfs">
     <primary>NFS</primary>
    </indexterm>

    <para>
     Il est possible d'utiliser un système de fichier <acronym>NFS</acronym>
     pour le répertoire des données de <productname>PostgreSQL</productname>.
     <productname>PostgreSQL</productname> ne fait rien de spécial sur un
     un système de fichier <acronym>NFS</acronym>, c'est-à-dire qu'il
     suppose un comportement identique à celui de disques connectés locaux.
     <productname>PostgreSQL</productname> n'utilise aucune fonctionnalité
     connue pour un comportement non standard sur <acronym>NFS</acronym>,
     comme le verrouillage de fichier.
    </para>

    <para>
     Le seul pré-requis ferme pour l'utilisation de <acronym>NFS</acronym>
     avec <productname>PostgreSQL</productname> est que celui-ci soit
     monté avec l'option <literal>hard</literal>. Avec cette option,
     des processus peuvent rester <quote>pendants</quote> indéfiniment
     s'il y a des problèmes réseau&nbsp;;cette configuration nécessite donc
     une mise en place soigneuse.
     L'option <literal>soft</literal> interrompra les appels système
     en cas de problème réseau, mais <productname>PostgreSQL</productname>
     ne répétera pas ces appels interrompus&nbsp;; une telle interruption
     mènera donc à la levée d'une erreur d'entrée-sortie.
    </para>

    <para>
     Il n'est pas nécessaire d'utiliser l'option de montage <literal>sync</literal>.
     Le comportement de <literal>async</literal> est suffisant car
     <productname>PostgreSQL</productname> génère des appels <literal>fsync</literal>
     quand c'est approprié pour purger les caches en écriture.
     (C'est analogue au fonctionnement sur un système de fichiers local).
     Cependant, il est fortement conseillé d'utiliser l'option
     <literal>sync</literal> pour l'export depuis le
     <emphasis>serveur</emphasis> NFS sur les systèmes où elle existe
     (principalement Linux).
     Sinon, il n'y a pas de garantie qu'un <literal>fsync</literal>,
     ou son équivalent, sur le client NFS, atteigne le stockage permanent du
     serveur, ce qui causerait une corruption, comme si on tournait avec
      <xref linkend="guc-fsync"/> à off.
     Les valeurs par défaut des options de montage et d'export diffèrent selon
     les fournisseurs et les versions&nbsp;; il est donc recommandé de les
     vérifier, voire de les préciser explicitement pour lever toute
     ambiguïté.
    </para>

    <para>
     Dans certains cas, un stockage externe peut être utilisé soit par NFS,
     soit par un protocole de plus bas niveau comme iSCSI.
     Dans ce dernier cas, le stockage apparaît comme un périphérique par bloc
     et n'importe quel système de fichiers peut y être créé.
     Cette approche peut éviter au DBA de gérer les particularités du NFS,
     mais la complexité de la gestion du stockage distant est bien sûr
     repoussée à un autre niveau.
    </para>
   </sect3>
  </sect2>
 </sect1>

 <sect1 id="server-start">
  <title>Lancer le serveur de bases de données</title>

  <para>
   Avant qu'une personne ait accès à la base de données, vous devez démarrer
   le serveur de bases de données. Le programme serveur est appelé
<command>postgres</command><indexterm><primary>postgres</primary></indexterm>.
  </para>

  <para>
   Si vous utilisez une version pré-packagé de
   <productname>PostgreSQL</productname>, il inclut pratiquement à coup sûr de
   quoi exécuter le serveur en tâche de fond suivant les conventions de votre
   système d'exploitation. Utiliser l'infrastructure du paquet pour démarrer
   le serveur demande beaucoup moins d'efforts qu'essayer de le faire
   soi-même. Consultez la documentation du paquet pour les détails.
  </para>

  <para>
   La façon brute pour démarrer le serveur manuellement est d'invoquer
   <command>postgres</command> directement, en précisant l'emplacement du
   répertoire des données avec l'option <option>-D</option>, par
   exemple&nbsp;:
<screen>$ <userinput>postgres -D /usr/local/pgsql/data</userinput></screen>
   qui laissera le serveur s'exécuter en avant plan. Pour cela, vous devez
   être connecté en utilisant le compte de l'utilisateur
   <productname>PostgreSQL</productname>. Sans l'option <option>-d</option>,
   le serveur essaiera d'utiliser le répertoire de données nommé par la
   variable d'environnement <envar>pgdata</envar>. Si cette variable ne le
   fournit pas non plus, le lancement échouera.
  </para>

  <para>
   Habituellement, il est préférable de lancer <command>postgres</command> en tâche
   de fond. Pour cela, utilisez la syntaxe shell Unix habituelle&nbsp;:
<screen>$ <userinput>postgres -D /usr/local/pgsql/data &gt;journaux_trace 2&gt;&amp;1 &amp;</userinput></screen>
   Il est important de sauvegarder les sorties <systemitem>stdout</systemitem> et
   <systemitem>stderr</systemitem> du serveur quelque part, comme montré ci-dessus. Cela
   vous aidera dans des buts d'audits ou pour diagnostiquer des problèmes (voir
   la <xref linkend="logfile-maintenance"/> pour une discussion plus détaillée
   de la gestion de journaux de trace).
  </para>

  <para>
   Le programme <command>postgres</command> prend aussi un certain nombre d'autres
   options en ligne de commande. Pour plus d'informations, voir la page de
   référence <xref linkend="app-postmaster"/> ainsi que le <xref
   linkend="runtime-config"/> ci-dessous.
  </para>

  <para>
   Cette syntaxe shell peut rapidement devenir ennuyante. Donc, le programme
   d'emballage <xref linkend="app-pg-ctl"/><indexterm><primary>pg_ctl</primary></indexterm>
   est fourni pour simplifier certaines tâches. Par exemple&nbsp;:
<programlisting>pg_ctl start -l journaux_trace</programlisting>
   lancera le serveur en tâche de fond et placera les sorties dans le journal
   de trace indiqué. L'option <option>-d</option> a la même signification ici
   que pour <command>postgres</command>. <command>pg_ctl</command> est aussi
   capable d'arrêter le serveur.
  </para>

  <para>
   Normalement, vous lancerez le serveur de bases de données lors du démarrage
   de l'ordinateur <indexterm><primary>démarrage</primary><secondary>au
   lancement du serveur</secondary></indexterm>. Les scripts de lancement
   automatique sont spécifiques au système d'exploitation. Quelques scripts
   d'exemple sont distribués avec <productname>PostgreSQL</productname> dans
   le répertoire <filename>contrib/start-scripts</filename>. En installer un
   nécessitera les droits de root.
  </para>

  <para>
   Différents systèmes ont différentes conventions pour lancer les démons au
   démarrage. La plupart des systèmes ont un fichier
   <filename>/etc/rc.local</filename> ou
   <filename>/etc/rc.d/rc.local</filename>. D'autres utilisent les répertoires
   <filename>init.d</filename> ou <filename>rc.d</filename>. Quoi que
   vous fassiez, le serveur doit être exécuté par le
   compte utilisateur <productname>PostgreSQL</productname> <emphasis>et non pas
   par root</emphasis> ou tout autre utilisateur. Donc, vous devriez
   probablement former vos commandes en utilisant <literal>su postgres -c '...' </literal>.
   Par exemple&nbsp;:
<programlisting>su postgres -c 'pg_ctl start -D /usr/local/pgsql/data -l serverlog'</programlisting>
  </para>

  <para>
   Voici quelques suggestions supplémentaires par système d'exploitation
   (dans chaque cas, assurez-vous d'utiliser le bon répertoire d'installation et
   le bon nom de l'utilisateur où nous montrons des valeurs génériques).

   <itemizedlist>
    <listitem>
     <para>
      Pour <productname>freebsd</productname>, regardez le fichier
      <filename>contrib/start-scripts/freebsd</filename> du répertoire des
      sources de <productname>PostgreSQL</productname>.
      <indexterm><primary>freebsd</primary><secondary>script de
      lancement</secondary></indexterm>
     </para>
    </listitem>

    <listitem>
     <para>
      Sur <productname>openbsd</productname>, ajoutez les lignes suivantes à
      votre fichier <filename>/etc/rc.local</filename>&nbsp;:
      <indexterm><primary>openbsd</primary><secondary>script de
      lancement</secondary></indexterm>
<programlisting>if [ -x /usr/local/pgsql/bin/pg_ctl -a -x /usr/local/pgsql/bin/postgres ]; then
    su -l postgres -c '/usr/local/pgsql/bin/pg_ctl start -s -l /var/postgresql/log -D /usr/local/pgsql/data'
    echo -n ' PostgreSQL'
fi</programlisting>
     </para>
    </listitem>

    <listitem>
     <para>
      Sur les systèmes <productname>linux</productname>, soit vous ajoutez
      <indexterm><primary>linux</primary><secondary>script de lancement</secondary></indexterm>
<programlisting>/usr/local/pgsql/bin/pg_ctl start -l journaux_trace -D /usr/local/pgsql/data</programlisting>
      à <filename>/etc/rc.d/rc.local</filename> ou
      <filename>/etc/rc.local</filename> soit vous jetez un œil à
      <filename>contrib/start-scripts/linux</filename> dans le répertoire des
      sources de <productname>PostgreSQL</productname>.
     </para>

     <para>
      Si vous utilisez <application>systemd</application>, vous pouvez utiliser
      le fichier de service (par exemple dans
      <filename>/etc/systemd/system/postgresql.service</filename>)&nbsp;:
      <indexterm><primary>systemd</primary></indexterm>
<programlisting>
[Unit]
Description=PostgreSQL database server
Documentation=man:postgres(1)

[Service]
Type=notify
User=postgres
ExecStart=/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data
ExecReload=/bin/kill -HUP $MAINPID
KillMode=mixed
KillSignal=SIGINT
TimeoutSec=0

[Install]
WantedBy=multi-user.target
   </programlisting>
   Utiliser <literal>Type=notify</literal> nécessite que le binaire du
   serveur soit construit avec <literal>configure --with-systemd</literal>.
  </para>

  <para>
   Faites bien attention au paramètre de délai.
   <application>systemd</application> a un délai par défaut de 90 secondes
   (au moment de l'écriture de cette documentation) et tuera un processus
   qui n'indique pas sa disponibilité après ce délai. Cependant, un serveur
   <productname>PostgreSQL</productname> qui aurait à réaliser une
   restauration suite à un crash pourrait prendre beaucoup plus de temps à
   démarrer. La valeur suggérée, 0, désactive ce comportement.
  </para>
 </listitem>

 <listitem>
  <para>
   Sur <productname>netbsd</productname>, vous pouvez utiliser les scripts
   de lancement de <productname>freebsd</productname> ou de
   <productname>linux</productname> suivant vos préférences.
   <indexterm><primary>netbsd</primary><secondary>script de lancement</secondary></indexterm>
  </para>
 </listitem>

 <listitem>
  <para>
   Sur <productname>solaris</productname>, créez un fichier appelé
   <filename>/etc/init.d/PostgreSQL</filename> et contenant la ligne
   suivante&nbsp;:
   <indexterm><primary>solaris</primary><secondary>script de
     lancement</secondary></indexterm>
   <programlisting>su - postgres -c "/usr/local/pgsql/bin/pg_ctl start -l journaux_trace -D /usr/local/pgsql/data"</programlisting>
      Puis, créez un lien symbolique vers lui dans <filename>/etc/rc3.d</filename> de
      nom <filename>s99PostgreSQL</filename>.
     </para>
    </listitem>
   </itemizedlist>

  </para>

   <para>
    Tant que le serveur est lancé, son
    <acronym>pid</acronym> est stocké dans le fichier
    <filename>postmaster.pid</filename> du répertoire de données. C'est utilisé
    pour empêcher plusieurs instances du serveur d'être exécutées dans le même
    répertoire de données et peut aussi être utilisé pour arrêter le processus
    le serveur.
   </para>

   <sect2 id="server-start-failures">
    <title>Échecs de lancement</title>

    <para>
     Il existe de nombreuses raisons habituelles pour lesquelles le serveur
     échouerait au lancement. Vérifiez le journal des traces du serveur ou
     lancez-le manuellement (sans redirection des sorties standard et d'erreur)
     et regardez les messages d'erreurs qui apparaissent. Nous en expliquons
     certains ci-dessous parmi les messages d'erreurs les plus communs.
    </para>

    <para>
<screen>LOG:  could not bind IPv4 address "127.0.0.1": Address already in use
HINT:  Is another postmaster already running on port 5432? If not, wait a few seconds and retry.
FATAL:  could not create any TCP/IP sockets</screen>
     Ceci signifie seulement ce que cela suggère&nbsp;: vous avez essayé de lancer
     un autre serveur sur le même port où un autre est en
     cours d'exécution. Néanmoins, si le message d'erreur du noyau
     n'est pas <computeroutput>address already in use</computeroutput> ou une
     quelconque variante, il pourrait y avoir un autre problème. Par
     exemple, essayer de lancer un serveur sur un numéro
     de port réservé pourrait avoir ce résultat&nbsp;:
<screen>$ <userinput>postgres -p 666</userinput>
LOG:  could not bind IPv4 address "127.0.0.1": Permission denied
HINT:  Is another postmaster already running on port 666? If not, wait a few seconds and retry.
FATAL:  could not create any TCP/IP sockets</screen>
    </para>

    <para>
     Un message du type
<screen>FATAL:  could not create shared memory segment: Invalid argument
DETAIL:  Failed system call was shmget(key=5440001, size=4011376640, 03600).</screen>
     signifie probablement que les limites de votre noyau sur la taille de
     la mémoire partagée est plus petite que l'aire de fonctionnement que
     <productname>PostgreSQL</productname> essaie de créer (4011376640 octets
     dans cet exemple). Ceci n'est susceptible de se produire uniquement si
     <literal>shared_memory_type</literal> a été affecté à <literal>sysv</literal>. Dans ce
     cas, vous pouvez essayer de lancer le serveur avec un nombre de tampons
     plus petit que la normale
     (<xref linkend="guc-shared-buffers"/>) ou vous pouvez
     reconfigurer votre noyau pour accroître la taille de mémoire partagée
     autorisée. Vous pourriez voir aussi ce message en essayant d'exécuter
     plusieurs serveurs sur la même machine si le total de l'espace qu'ils
     requièrent dépasse la limite du noyau.
    </para>

    <para>
     Une erreur du type
<screen>FATAL:  could not create semaphores: No space left on device
DETAIL:  Failed system call was semget(5440126, 17, 03600).</screen>
     ne signifie <emphasis>pas</emphasis> qu'il vous manque de l'espace disque.
     Elle signifie que la limite de votre noyau sur le nombre de sémaphores
     <systemitem class="osname">system v</systemitem> est inférieure au nombre que
     <productname>PostgreSQL</productname> veut créer. Comme ci-dessus, vous
     pouvez contourner le problème en lançant le serveur avec un nombre
     réduit de connexions autorisées (<xref linkend="guc-max-connections"/>)
     mais vous voudrez éventuellement augmenter la limite du noyau.
    </para>

    <para>
     Des détails sur la configuration des capacités <acronym>IPC</acronym> <systemitem
     class="osname">System V</systemitem> sont donnés dans la <xref linkend="sysvipc"/>.
    </para>
   </sect2>

   <sect2 id="client-connection-problems">
    <title>Problèmes de connexion du client</title>

    <para>
     Bien que les conditions d'erreurs possibles du côté client sont assez
     variées et dépendantes de l'application, certaines pourraient être en
     relation direct avec la façon dont le serveur a été lancé. Les conditions
     autres que celles montrées ici devraient être documentées avec
     l'application client respective.
    </para>

    <para>
<screen>psql: error: connection to server at "server.joe.com" (123.123.123.123), port 5432 failed: Connection refused
        Is the server running on that host and accepting TCP/IP connections?
</screen>
     Ceci est l'échec générique <quote>je n'ai pas trouvé de serveur à qui
     parler</quote>. Cela ressemble au message ci-dessus lorsqu'une connexion
     TCP/IP est tentée. Une erreur commune est d'oublier de configurer le
     serveur pour qu'il autorise les connexions TCP/IP.
    </para>

    <para>
     Autrement, vous obtiendrez ceci en essayant une communication de type
     socket de domaine Unix vers un serveur local&nbsp;:
<screen>psql: error: connection to server on socket "/tmp/.s.PGSQL.5432" failed: No such file or directory
        Is the server running locally and accepting connections on that socket?</screen>
     Si le serveur est vraiment en cours d'exécution, vérifiez que le chemin
     du socket pour le client (ici <literal>/tmp</literal>) est en accord
     avec le paramètre <xref linkend="guc-unix-socket-directories"/> du
     serveur.
    </para>

    <para>
     Un message d'échec de connexion affiche toujours l'adresse du serveur ou
     le chemin de la socket, ce qui est utile pour vérifier que le client est
     en train de se connecter au bon endroit. Si aucun serveur n'est en
     écoute ici, le message d'erreur du noyau sera typiquement soit
     <computeroutput>connection refused</computeroutput> soit
     <computeroutput>no such file or directory</computeroutput>, comme ce qui
     est illustré (il est important de réaliser que
     <computeroutput>connection refused</computeroutput>, dans ce contexte,
     ne signifie <emphasis>pas</emphasis> que le serveur a obtenu une demande
     de connexion et l'a refusé. Ce cas produira un message différent comme
     indiqué dans la <xref linkend="client-authentication-problems"/>).
     D'autres messages d'erreurs tel que <computeroutput>connection timed
     out</computeroutput> pourraient indiquer des problèmes plus fondamentaux
     comme un manque de connexion réseau, ou un pare-feu bloquant la
     connexion.
    </para>
   </sect2>
  </sect1>

 <sect1 id="kernel-resources">
  <title>Gérer les ressources du noyau</title>

  <para>
   <productname>PostgreSQL</productname> peut quelque fois dépasser les limites
   des ressources du système d'exploitation, tout spécialement quand plusieurs
   copies du serveur s'exécutent sur le même système, ou sur des très grosses
   installations. Cette section explique les ressources du noyau utilisées par
   <productname>PostgreSQL</productname> et les étapes à suivre pour résoudre
   les problèmes liés à la consommation des ressources du noyau.
  </para>

  <sect2 id="sysvipc">
   <title>Mémoire partagée et sémaphore</title>

   <indexterm zone="sysvipc">
    <primary>mémoire partagée</primary>
   </indexterm>

   <indexterm zone="sysvipc">
    <primary>sémaphores</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> a besoin que le système d'exploitation
    fournisse des fonctionnalités de communication inter-processus
    (<acronym>IPC</acronym>), en particulier de la mémoire partagée et des
    sémaphores. Les systèmes dérivés d'Unix fournissent
    <quote><systemitem class="osname">System V</systemitem></quote> <acronym>IPC</acronym>,
    <quote><systemitem class="osname">POSIX</systemitem></quote> <acronym>IPC</acronym>
    ou les deux. <systemitem class="osname">Windows</systemitem> qui fournit sa propre
    implémentation de ces fonctionnalités ne sera pas approfondi ici.
   </para>

   <para>
    Par défaut, <productname>PostgreSQL</productname> alloue
    une très petite quantité de mémoire partagée System&nbsp;V, ainsi
    qu'une quantité bien plus importante de mémoire partagée anonyme
    <function>mmap</function>.
    Autre possibilité&nbsp;: utiliser un seul gros bloc de mémoire partagée
    System&nbsp;V (voir <xref linkend="guc-shared-memory-type"/>).

    De plus, un nombre important de sémaphores de style System&nbsp;V ou POSIX sont
    créés au démarrage du serveur. Actuellement, les sémaphores POSIX sont
    utilisés sur les systèmes Linux et FreeBSD, alors que les autres plateformes
    utilisent les sémaphores System&nbsp;V.
   </para>

   <para>
    Les fonctionnalités System&nbsp;V <acronym>IPC</acronym> sont habituellement
    restreintes par les limites d'allocation au niveau système.
    Quand <productname>PostgreSQL</productname> dépasse une des nombreuses limites
    <acronym>IPC</acronym>, le serveur refusera de s'exécuter et lèvera un
    message d'erreur instructif décrivant le problème rencontré et que faire
    avec (voir aussi la <xref linkend="server-start-failures"/>). Les
    paramètres adéquats du noyau sont nommés de façon cohérente parmi les
    différents systèmes&nbsp;; le <xref linkend="sysvipc-parameters"/> donne un
    aperçu. Néanmoins, les méthodes pour les obtenir varient. Les suggestions
    pour quelques plateformes sont données ci-dessous.
   </para>

   <table id="sysvipc-parameters">
    <title>Paramètres <systemitem class="osname">System V</systemitem> <acronym>IPC</acronym></title>

    <tgroup cols="3">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="3*"/>
     <colspec colname="col3" colwidth="3*"/>
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Description</entry>
       <entry>Valeurs nécessaires pour faire fonctionner une instance <productname>PostgreSQL</productname> </entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><varname>SHMMAX</varname></entry>
       <entry>Taille maximum du segment de mémoire partagée (en octets)</entry>
       <entry>au moins 1&nbsp;ko, mais la valeur par défaut est normalement bien plus grande</entry>
      </row>

      <row>
       <entry><varname>SHMMIN</varname></entry>
       <entry>Taille minimum du segment de mémoire partagée (en octets)</entry>
       <entry>1</entry>
      </row>

      <row>
       <entry><varname>SHMALL</varname></entry>
       <entry>Total de la mémoire partagée disponible (en octets ou pages)</entry>
       <entry>si octets, identique à <varname>SHMMAX</varname>&nbsp;;
        si pages, <literal>ceil(SHMMAX/PAGE_SIZE)</literal>,
        plus de la marge pour les autres applications</entry>
      </row>

      <row>
       <entry><varname>SHMSEG</varname></entry>
       <entry>Nombre maximum de segments de mémoire partagée par processus</entry>
       <entry>seul un segment est nécessaire, mais la valeur par défaut est
        bien plus importante</entry>
      </row>

       <row>
        <entry><varname>SHMMNI</varname></entry>
        <entry>Nombre maximum de segments de mémoire partagée pour
         tout le système</entry>
        <entry>comme <varname>SHMSEG</varname> plus de la place pour les autres
         applications</entry>
       </row>

       <row>
        <entry><varname>SEMMNI</varname></entry>
        <entry>Nombre maximum d'identifiants de sémaphores (c'est-à-dire
         d'ensembles)</entry>
        <entry>au moins <literal>ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)</literal> plus de la marge pour les autres applications</entry>
       </row>

       <row>
        <entry><varname>SEMMNS</varname></entry>
        <entry>nombre maximum de sémaphores répartis dans le système</entry>
        <entry><literal>ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16) * 17</literal> plus la place
         pour les autres applications</entry>
       </row>

       <row>
        <entry><varname>SEMMSL</varname></entry>
        <entry>Nombre maximum de sémaphores par ensemble</entry>
        <entry>au moins 17</entry>
       </row>

       <row>
        <entry><varname>SEMMAP</varname></entry>
        <entry>Nombre d'entrées dans la carte des sémaphores</entry>
        <entry>voir le texte</entry>
       </row>

       <row>
        <entry><varname>SEMVMX</varname></entry>
        <entry>Valeur maximum d'un sémaphore</entry>
        <entry>au moins 1000 (vaut souvent par défaut 32767&nbsp;; ne pas changer
         sauf si vous êtes forcé.)</entry>
       </row>

     </tbody>
    </tgroup>
   </table>


   <para>
    <productname>PostgreSQL</productname> requiert quelques octets de mémoire
    partagée System&nbsp;V (typiquement 48 octets sur des plateformes 64 bits) pour
    chaque copie du serveur. Sur la plupart des systèmes d'exploitation modernes,
    cette quantité est facilement allouable. Néanmoins, si vous exécutez
    plusieurs copies du serveur
    ou si vous le configurez explicitement pour utiliser de grandes quantités
    de mémoire partagée System&nbsp;V (voir <xref linkend="guc-shared-memory-type"/>
    et <xref linkend="guc-dynamic-shared-memory-type"/>),
    il pourrait être nécessaire d'augmenter
    <varname>SHMALL</varname>, correspondant à la quantité
    totale de mémoire partagée System&nbsp;V pour tout le système. Notez que
    <varname>SHMALL</varname> est en nombre de blocs disques, et non pas en
    nombre d'octets sur de nombreux systèmes.
   </para>

   <para>
    La taille minimum des segments de mémoire partagée (<varname>SHMMIN</varname>) est
    moins sensible aux problèmes. Elle devrait être au plus à environ
    32 octets pour <productname>PostgreSQL</productname> (il est habituellement à 1). Le
    nombre maximum de segments au travers du système (<varname>SHMMNI</varname>) ou par
    processus (<varname>SHMSEG</varname>) a peu de chances de causer un problème sauf
    s'ils sont configurés à zéro sur votre système.
   </para>

   <para>
    Lors de l'utilisation de sémaphores System&nbsp;V,
    <productname>PostgreSQL</productname> utilise un sémaphore par connexion
    autorisée (<xref linkend="guc-max-connections"/>), par processus
    autovacuum autorisé (<xref linkend="guc-autovacuum-max-workers"/>) et par
    processus en tâche de fond autorisé réclamant un accès à la mémoire
    partagée, le tout par ensemble de 16. Chacun de ces ensembles contiendra
    aussi un 17è sémaphore qui contient un <quote>nombre magique</quote> pour
    détecter la collision avec des ensembles de sémaphore utilisés par les
    autres applications. Le nombre maximum de sémaphores dans le système est
    initialisé par <varname>SEMMNS</varname>, qui en conséquence doit être au
    moins aussi haut que <varname>max_connections</varname> plus
    <varname>autovacuum_max_workers</varname> plus
    <varname>max_wal_senders</varname> plus
    <varname>max_worker_processes</varname>,
    plus 1 encore pour chacune des 16 connexions autorisées,
    plus les workers (voir la formule dans le <xref
    linkend="sysvipc-parameters"/>). Le paramètre <varname>SEMMNI</varname>
    détermine la limite du nombre d'ensembles de sémaphores qui peuvent
    exister sur le système à un instant précis. Ce paramètre doit donc être
    au moins égal à
    <literal>ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)</literal>.
    Baisser le
    nombre de connexions autorisées est un contournement temporaire pour les
    échecs qui sont habituellement indiqués par le message <quote>no space
    left on device</quote>, à partir de la fonction
    <function>semget</function>.
   </para>

   <para>
    Dans certains cas, il pourrait être nécessaire d'augmenter
    <varname>SEMMAP</varname> pour être au moins dans l'ordre de
    <varname>SEMMNS</varname>. Si le système dispose de ce paramètre (ce n'est
    pas le cas pour beaucoup d'entre eux), il définit la taille de
    la carte de ressources de sémaphores, dans laquelle chaque bloc contigu de
    sémaphores disponibles a besoin d'une entrée. Lorsqu'un ensemble de
    sémaphores est libéré, soit il est ajouté à une entrée existante,
    soit il est enregistré sous une nouvelle entrée dans la carte.
    Si la carte est pleine, les sémaphores libérés sont perdus
    (jusqu'au redémarrage). La fragmentation de l'espace des sémaphores
    peut mener au fil du temps à rendre moins de sémaphores disponibles qu'il
    ne devrait y avoir.
   </para>

   <para>
    D'autres paramètres en relation avec l'<quote>annulation de sémaphores</quote>,
    tels que <varname>SEMMNU</varname> et <varname>SEMUME</varname>, n'affectent pas
    <productname>PostgreSQL</productname>.
   </para>

   <para>
    Lors de l'utilisation de sémaphores POSIX, le nombre de sémaphores
    nécessaires est le même que pour System&nbsp;V, c'est-à-dire un sémaphore par
    connexion autorisée (<xref linkend="guc-max-connections"/>), par
    processus autovacuum autorisé (<xref linkend="guc-autovacuum-max-workers"/>)
    et par processus en t&acirc;che de fond (<xref linkend="guc-max-worker-processes"/>).
    Sur les plateformes o&ugrave; cette option est préférée, le noyau ne
    spécifie pas de limite au nombre de sémaphores POSIX.
   </para>

    <variablelist>

     <varlistentry>
      <term><systemitem class="osname">AIX</systemitem></term>
      <listitem>
      <indexterm><primary>AIX</primary><secondary>configuration IPC</secondary></indexterm>
       <para>
        Il ne doit plus être nécessaire de faire
        une configuration spéciale pour les paramètres tels que
        <varname>SHMMAX</varname>, car c'est configuré de façon à ce que toute
        la mémoire puisse être utilisée en tant que mémoire partagée.
        C'est le type de configuration habituellement utilisée pour d'autres
        bases de données comme <application>DB/2</application>.
       </para>

       <para>
        Néanmoins, il pourrait être nécessaire de modifier l'information
       globale <command>ulimit</command> dans
       <filename>/etc/security/limits</filename> car les limites en dur par
       défaut pour les tailles de fichiers (<varname>fsize</varname>) et
       les nombres de fichiers (<varname>nofiles</varname>) pourraient être
       trop bas.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">FreeBSD</systemitem></term>
      <listitem>
      <indexterm><primary>FreeBSD</primary><secondary>configuration IPC</secondary></indexterm>
       <para>
        Les paramètres par défaut de mémoire partagée sont en général
        suffisant, sauf si vous affectez <literal>shared_memory_type</literal>
        à <literal>sysv</literal>. Les sémaphores System V ne sont pas
        utilisés sur cette plateforme.
       </para>

       <para>
        Les paramètres IPC par défaut peuvent être modifiés en utilisant la
        commande <command>sysctl</command> ou <command>loader</command>. Les
        paramètres suivants peuvent être configurés en utilisant
        <command>sysctl</command>&nbsp;:
<screen><prompt>#</prompt> <userinput>sysctl kern.ipc.shmall=32768</userinput>
<prompt>#</prompt> <userinput>sysctl kern.ipc.shmmax=134217728</userinput>
   </screen>
   Pour que ces paramètres persistent après les redémarrages, modifiez
   <filename>/etc/sysctl.conf</filename>.
  </para>

  <para>
   Si vous avez affecté <literal>shared_memory_type</literal> à
   <literal>sysv</literal>, vous pourriez aussi vouloir configurer votre noyau
   pour verrouiller la mémoire partagée System V en RAM et l'empêcher d'être
   envoyé dans le swap. Ceci peut être accompli en utilisant le paramètre
   <literal>kern.ipc.shm_use_phys</literal> de <command>sysctl</command>.
  </para>

  <para>
   Dans une prison FreeBSD, il vous est recommandé de configurer le paramètre
   <literal>sysvshm</literal> à <literal>new</literal>, ainsi il a son propre
   espace de nommage de mémoire partagée System V. (Avant FreeBSD 11.0, il
   était nécessaire d'activer l'accès partagé à l'espace de nommage IPC de
   l'hôte depuis les prisons, et prendre les mesures pour éviter les
   collisions.)
  </para>
 </listitem>
</varlistentry>

<varlistentry>
 <term><systemitem class="osname">NetBSD</systemitem></term>
 <listitem>
  <indexterm><primary>NetBSD</primary><secondary>configuration IPC</secondary></indexterm>
  <para>
   La configuration par défaut de la mémoire partagé est en général
   suffisante, sauf si vous avez affecté <literal>shared_memory_type</literal>
   à <literal>sysv</literal>. Dans ce cas, vous voudrez habituellement
   augmenter <literal>kern.ipc.semmni</literal> et
   <literal>kern.ipc.semmns</literal> car les valeurs par défaut de ces
   paramètres sur <systemitem class="osname">NetBSD</systemitem> sont bien
   trop bas.
  </para>

  <para>
   Les paramètres IPC peuvent être ajustés en utilisant
   <command>sysctl</command>. Par exemple&nbsp;:
   <screen>
<prompt>#</prompt> <userinput>sysctl -w kern.ipc.semmni=100</userinput>
   </screen>
   Pour que ce paramètrage persiste après un redémarrage, modifiez
   le fichier <filename>/etc/sysctl.conf</filename>.
  </para>

  <para>
   Si vous avez configuré <literal>shared_memory_type</literal> à
   <literal>sysv</literal>, vous pourriez aussi vouloir configurer votre noyau
   pour verrouiller la mémoire partagée System V en RAM et prévenir la mémoire
   d'être envoyée sur swap. Ceci peut être accompli en utilisant le paramètre
   <literal>kern.ipc.shm_use_phys</literal>de la commande
   <command>sysctl</command>.
  </para>
 </listitem>
</varlistentry>

<varlistentry>
 <term><systemitem class="osname">OpenBSD</systemitem></term>
 <listitem>
  <indexterm><primary>OpenBSD</primary><secondary>configuration IPC</secondary></indexterm>
  <para>
   La configuration par défaut de la mémoire partagée est en général
   suffisante, sauf si vous avez configuré
   <literal>shared_memory_type</literal> à <literal>sysv</literal>. Vous
   voudrez habituellement augmenter <literal>kern.seminfo.semmni</literal> et
   <literal>kern.seminfo.semmns</literal> car les valeurs par défaut de ces
   paramètres sur <systemitem class="osname">OpenBSD</systemitem> sont bien
   trop bas.
  </para>

  <para>
   Les paramètres IPC peuvent être ajustés en utilisant
   <command>sysctl</command>, par exemple&nbsp;:
   <screen>
<prompt>#</prompt> <userinput>sysctl kern.seminfo.semmni=100</userinput>
   </screen>
   Pour rendre ce paramétrage persistant entre les redémarrages, modifiez
   <filename>/etc/sysctl.conf</filename>.
  </para>
 </listitem>
</varlistentry>


<varlistentry>
 <term><systemitem class="osname">HP-UX</systemitem></term>
 <listitem>
  <indexterm><primary>HP-UX</primary><secondary>configuration IPC</secondary></indexterm>
  <para>
   Les paramètres par défaut tendent à suffire pour des installations
   normales.
  </para>
  <para>
   Les paramètres <acronym>IPC</acronym> peuvent être initialisés dans
   <application>System Administration Manager</application> (<acronym>SAM</acronym>) sous
   <menuchoice><guimenu>Kernel Configuration</guimenu><guimenuitem>Configurable
     Parameters</guimenuitem></menuchoice>.
   Choisissez <guibutton>Create A New Kernel</guibutton> une fois terminé.
  </para>
 </listitem>
</varlistentry>


<varlistentry>
 <term><systemitem class="osname">Linux</systemitem></term>
 <listitem>
  <indexterm><primary>Linux</primary><secondary>configuration IPC</secondary></indexterm>
  <para>
   La configuration par défaut de la mémoire partagée est en général
   suffisante, sauf si vous avez configuré
   <literal>shared_memory_type</literal> à <literal>sysv</literal>, et
   uniquement sur les anciennes versions de noyau fournies avec des
   valeurs par défaut trop basses. Les sémaphores de System V ne sont pas
   utilisés sur cette plateforme.
  </para>

  <para>
   La configuration de la taille de mémoire partagée peut être modifiée
   avec l'interface proposée par la commande <command>sysctl</command>.
   Par exemple, pour permettre l'utilisation de 16&nbsp;Go&nbsp;:
   <screen>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmmax=17179869184</userinput>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmall=4194304</userinput>
   </screen>
   Pour rendre ce paramètrage persistant entre les redémarrages, voir
   <filename>/etc/sysctl.conf</filename>.
  </para>
 </listitem>
</varlistentry>


<varlistentry>
 <term><systemitem class="osname">macOS</systemitem></term>
 <listitem>
  <indexterm><primary>macOS</primary><secondary>configuration IPC</secondary></indexterm>
  <para>
   La configuration par défaut de la mémoire partagée et des sémaphores est en
   général suffisante, sauf si vous avez configuré
   <literal>shared_memory_type</literal> à <literal>sysv</literal>.
  </para>
  <para>
   La méthode recommandée pour configurer la mémoire partagée sous macOS
   est de créer un fichier nommé <filename>/etc/sysctl.conf</filename>
   contenant des affectations de variables comme&nbsp;:
   <programlisting>kern.sysv.shmmax=4194304
kern.sysv.shmmin=1
kern.sysv.shmmni=32
kern.sysv.shmseg=8
kern.sysv.shmall=1024
   </programlisting>
   Notez que, dans certaines versions de macOS, <emphasis>les
    cinq</emphasis> paramètres de mémoire partagée doivent être configurés
   dans <filename>/etc/sysctl.conf</filename>, sinon les valeurs seront
   ignorées.
  </para>

  <para>
   <varname>SHMMAX</varname> peut seulement être configuré avec un multiple
   exact de 4096.
  </para>

  <para>
   <varname>SHMALL</varname> est mesuré en page de 4&nbsp;ko sur cette
   plateforme.
  </para>

  <para>
   Il est possible de tous les modifier en ligne sauf
   <varname>SHMMNI</varname>, grâce à <application>sysctl</application>. Mais
   il est toujours préférable de configurer vos valeurs préférées dans
   <filename>/etc/sysctl.conf</filename>, pour que les nouvelles valeurs
   soient conservées après un redémarrage.
  </para>
 </listitem>
</varlistentry>

<varlistentry>
 <term><systemitem class="osname">Solaris</systemitem></term>
 <term><systemitem class="osname">illumos</systemitem></term>
 <listitem>
  <para>
   La configuration de la mémoire partagée et des sémaphores par défaut
   sont habituellement suffisamment bonnes pour la majorité des
   configurations de <productname>PostgreSQL</productname>. La valeur par
   défaut de Solaris pour <varname>SHMMAX</varname> correspond maintenant
   à un quart de la mémoire disponible sur le système. Pour configurer
   plus finement ce paramètre, vous devez utiliser une configuration de
   projet associé à l'utilisateur <literal>postgres</literal>. Par
   exemple, exécutez ce qui suit en tant qu'utilisateur
   <literal>root</literal>&nbsp;:
   <programlisting>
projadd -c "PostgreSQL DB User" -K "project.max-shm-memory=(privileged,8GB,deny)" -U postgres -G postgres user.postgres
   </programlisting>
  </para>

  <para>
   Cette commande ajoute le projet  <literal>user.postgres</literal>
   et configure le maximum de mémoire partagée pour l'utilisateur
   <literal>postgres</literal> à 8&nbsp;Go. Cela prend effet à chaque
   fois que l'utilisateur se connecte et quand vous redémarrez
   <productname>PostgreSQL</productname>. La ligne ci-dessus
   suppose que <productname>PostgreSQL</productname> est exécuté
   par l'utilisateur <literal>postgres</literal> dans le groupe
   <literal>postgres</literal>. Aucun redémarrage du serveur n'est
   requis.
  </para>

  <para>
   Sur un serveur de bases de données ayant beaucoup de connexions,
   les autres modifications recommandés pour le noyau sont&nbsp;:
   <programlisting>
project.max-shm-ids=(priv,32768,deny)
project.max-sem-ids=(priv,4096,deny)
project.max-msg-ids=(priv,4096,deny)
   </programlisting>

  </para>

  <para>
   De plus, si vous exécutez <productname>PostgreSQL</productname>
   dans une zone, vous pourriez avoir besoin d'augmenter les limites
   d'utilisation des ressources pour la zone. Voir
   <foreignphrase>Chapter2:  Projects and Tasks</foreignphrase> dans
   <citetitle>System Administrator's Guide</citetitle>
   pour plus d'informations sur les <literal>projets</literal> et
   <command>prctl</command>.
  </para>
 </listitem>
</varlistentry>


</variablelist>

</sect2>

<sect2 id="systemd-removeipc">
<title>systemd RemoveIPC</title>

<indexterm>
<primary>systemd</primary>
<secondary>RemoveIPC</secondary>
</indexterm>

<para>
Si <productname>systemd</productname> est utilisé, certaines précautions
sont de mise pour que les ressources IPC (incluant la mémoire partagée)
ne soient pas supprimées par le système d'exploitation. Cela est
particulièrement important lors de l'installation de PostgreSQL via les
sources. Les utilisateurs de versions packagées par la distribution ont moins
de chance d'être affectés, l'utilisateur <literal>postgres</literal> étant
habituellement créé en tant qu'utilisateur système.
</para>

<para>
Le paramètre <literal>RemoveIPC</literal> dans <filename>logind.conf</filename>
contr&ocirc;le si les objets IPC sont supprimés lors de déconnexion
complète d'un utilisateur. Les utilisateurs système sont exclus.
Ce paramètre est par défaut actif sur la version originale de
<productname>systemd</productname>, mais certaines distributions
positionnent ce paramètre à off.
</para>

<para>
Un effet typique observé quand ce paramètre est activé est que les objets
en mémoire partagée utilisés pour l'exécution des requêtes en parallèle
sont supprimés à des moments en apparence aléatoires, amenant ainsi des
erreurs et messages d'avertissement lors des tentatives de les ouvrir ou
supprimer, comme&nbsp;:
<screen>
WARNING:  could not remove shared memory segment "/PostgreSQL.1450751626": No such file or directory
</screen>
Différents types d'objets IPC (mémoire partagée et sémaphores, System&nbsp;V et
POSIX) sont traités de manière légèrement différente par
<productname>systemd</productname>, et l'on peut observer que certaines
ressources IPC ne sont pas supprimées de la m&ecirc;me manière que les
autres. Il n'est toutefois pas conseillé de compter sur ces subtiles
différences.
</para>

<para>
Une <quote>déconnexion utilisateur</quote> peut survenir lors d'une
opération de maintenance ou manuellement lorsqu'un administrateur se
connecte avec le compte <literal>postgres</literal> ou un compte similaire,
ce qui est difficile à éviter en général.
</para>

<para>
Ce qu'est un <quote>utilisateur système</quote> est déterminé à la
compilation de <productname>systemd</productname> par le paramètre
<symbol>SYS_UID_MAX</symbol> dans <filename>/etc/login.defs</filename>.
</para>

<para>
Les scripts de packaging et déploiement devront faire attention à créer
l'utilisateur <literal>postgres</literal> en tant qu'utilisateur système
avec <literal>useradd -r</literal>, <literal>adduser --system</literal>,
ou une commande équivalente.
</para>

<para>
Sinon, si le compte utilisateur a été créé de manière incorrecte ou ne peut
être modifié, il est recommandé de configurer
<programlisting>
RemoveIPC=no
</programlisting>
dans <filename>/etc/systemd/logind.conf</filename> ou un autre fichier de
configuration approprié.
</para>

<caution>
<para>
 Au moins une de ces deux choses doit être garantie, sinon le serveur
 PostgreSQL ne pourra être considéré comme fiable.
</para>
</caution>
</sect2>

<sect2>
<title>Limites de ressources</title>

<para>
Les systèmes d'exploitation style Unix renforcent différents types de
limites de ressources qui pourraient interférer avec les opérations de votre
serveur <productname>PostgreSQL</productname>. Les limites sur le nombre de
processus par utilisateur, le nombre de fichiers ouverts par un processus et la
taille mémoire disponible pour chaque processus sont d'une grande
importance. Chacun d'entre elles ont une limite <quote>dure</quote> et une
limite <quote>souple</quote>. La limite souple est réellement ce qui compte
mais cela pourrait être changé par l'utilisateur jusqu'à la limite dure. La
limite dure pourrait seulement être modifiée par l'utilisateur root. L'appel
système <function>setrlimit</function> est responsable de l'initialisation
de ces paramètres. La commande interne du shell <command>ulimit</command>
(shells Bourne) ou <command>limit</command> (<application>csh</application>) est
utilisé pour contrôler les limites de ressource à partir de la ligne de
commande. Sur les systèmes dérivés BSD, le fichier
<filename>/etc/login.conf</filename> contrôle les différentes limites de
ressource initialisées à la connexion. Voir la documentation du système
d'exploitation pour les détails. Les paramètres en question sont
<varname>maxproc</varname>, <varname>openfiles</varname> et
<varname>datasize</varname>. par exemple&nbsp;:
<programlisting>default:\
...
        :datasize-cur=256M:\
        :maxproc-cur=256:\
        :openfiles-cur=256:\
...</programlisting>
    (<literal>-cur</literal> est la limite douce. Ajoutez
    <literal>-max</literal> pour configurer la limite dure.)
   </para>

   <para>
    Les noyaux peuvent aussi avoir des limites sur le système complet pour
    certaines ressources.
    <itemizedlist>
     <listitem>
      <para>
      Sur <productname>linux</productname>,
      <filename>/proc/sys/fs/file-max</filename> détermine le nombre maximum de
      fichiers ouverts que le noyau supportera. Ce nombre est modifiable en
      écrivant un autre nombre dans le fichier ou en ajoutant une affectation
      dans <filename>/etc/sysctl.conf</filename>. La limite des fichiers par
      processus est fixée lors de la compilation du noyau&nbsp;; voir
      <filename>/usr/src/linux/documentation/proc.txt</filename> pour plus
      d'informations.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Le serveur <productname>PostgreSQL</productname> utilise un processus par
    connexion de façon à ce que vous puissiez fournir au moins autant de
    processus que de connexions autorisées, en plus de ce dont vous avez besoin
    pour le reste de votre système. Ceci n'est habituellement pas un problème
    mais si vous exécutez plusieurs serveurs sur une seule machine, cela
    pourrait devenir étroit.
   </para>

   <para>
    La limite par défaut des fichiers ouverts est souvent initialisée pour être
    <quote>amicalement sociale</quote>, pour permettre à de nombreux
    utilisateurs de coexister sur une machine sans utiliser une fraction
    inappropriée des ressources du système. Si vous lancez un grand nombre de
    serveurs sur une machine, cela pourrait être quelque chose que vous
    souhaitez mais sur les serveurs dédiés, vous pourriez vouloir augmenter
    cette limite.
   </para>

   <para>
    D'un autre côté, certains systèmes autorisent l'ouverture d'un grand
    nombre de fichiers à des processus individuels&nbsp;; si un plus grand
    nombre le font, alors les limites du système peuvent facilement être
    dépassées. Si vous rencontrez ce cas et que vous ne voulez pas modifier la
    limite du système, vous pouvez initialiser le paramètre de configuration
    <xref linkend="guc-max-files-per-process"/> de
    <productname>PostgreSQL</productname> pour limiter la consommation de
    fichiers ouverts.
   </para>
  </sect2>

  <sect2 id="linux-memory-overcommit">
   <title>Linux memory overcommit</title>

   <indexterm>
    <primary>memory overcommit</primary>
   </indexterm>

   <indexterm>
    <primary>OOM</primary>
   </indexterm>

   <indexterm>
    <primary>overcommit</primary>
   </indexterm>

   <para>
    Le comportement par défaut de la mémoire
    virtuelle sur Linux n'est pas optimal pour <productname>PostgreSQL</productname>.
    Du fait de l'implémentation du <quote>memory overcommit</quote> par le
    noyau, celui-ci peut arrêter le serveur
    <productname>PostgreSQL</productname> (le processus serveur
    principal, <quote>postmaster</quote>) si les demandes de mémoire de
    <productname>PostgreSQL</productname> ou d'un autre processus provoque un
    manque de mémoire virtuelle au niveau du système.
   </para>

   <para>
    Si cela se produit, un message du noyau qui ressemble à ceci
    (consulter la documentation et la configuration du système pour savoir
    où chercher un tel message)&nbsp;:
<programlisting>Out of Memory: Killed process 12345 (postgres)</programlisting>
    peut survenir.
    Ceci indique que le processus <filename>postgres</filename> a été terminé
    à cause d'un problème de mémoire. Bien que les connexions en cours
    continuent de fonctionner normalement, aucune nouvelle
    connexion n'est acceptée. Pour revenir à un état normal,
    <productname>PostgreSQL</productname> doit être relancé.
   </para>

   <para>
    Une façon d'éviter ce problème revient à lancer
    <productname>PostgreSQL</productname> sur une machine où vous pouvez vous
    assurer que les autres processus ne mettront pas la machine en manque de
    mémoire. S'il y a peu de mémoire, augmenter la swap peut aider à éviter
    le problème car un système peut tuer des processus lorsque la mémoire
    physique et la mémoire swap sont utilisées entièrement.
   </para>

   <para>
    Si <productname>PostgreSQL</productname> lui-même est la cause d'un manque
    de mémoire du système, vous pouvez éviter le problème en modifiant votre
    configuration. Dans certains cas, baisser les paramètres de configuration
    de la mémoire peut aider, tout particulièrement
    <link linkend="guc-shared-buffers"><varname>shared_buffers</varname></link>,
    <link linkend="guc-work-mem"><varname>work_mem</varname></link> et
    <link linkend="guc-hash-mem-multiplier"><varname>hash_mem_multiplier</varname></link>. Dans
    d'autres cas, le problème peut être causé par l'autorisation d'un trop grand
    nombre de connexions au serveur de bases de données. Dans beaucoup de cas,
    il est préférable de réduire <link
    linkend="guc-max-connections"><varname>max_connections</varname></link> et
    d'utiliser à la place un logiciel de multiplexage de connexions
    (<foreignphrase>connection pooling</foreignphrase>).
   </para>

   <para>
    Il est possible de modifier
    le comportement du noyau avec le <quote>overcommit memory</quote>.
    Bien que ce paramétrage n'empêchera pas ce <ulink
    url="https://lwn.net/Articles/104179/">comportement</ulink>, il réduira sa
    fréquence de façon significative et contribuera du coup à un système
    plus robuste. Ceci se fait en sélectionnant le mode strict de
    l'overcommit via <command>sysctl</command>&nbsp;:
<programlisting>sysctl -w vm.overcommit_memory=2</programlisting>
    ou en plaçant une entrée équivalente dans <filename>/etc/sysctl.conf</filename>.
    Vous pourriez souhaiter modifier le paramétrage relatif
    <varname>vm.overcommit_ratio</varname>. Pour les détails, voir la documentation du
    noyau (<ulink url="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting">https://www.kernel.org/doc/Documentation/vm/overcommit-accounting</ulink>).
   </para>

   <para>
    Une autre approche, qui peut aussi utiliser la modification de
    <varname>vm.overcommit_memory</varname>, est de configurer la valeur de
    la variable d'<firstterm>ajustement du score OOM</firstterm>, valeur par
    processus, pour le processus postmaster à <literal>-1000</literal>,
    garantissant ainsi qu'il ne sera pas la cible de OOM. La façon la plus
    simple de le faire est d'exécuter
<programlisting>
echo -1000 > /proc/self/oom_score_adj
</programlisting>
    dans le script de démarrage de postmaster juste avant d'appeler
    postmaster. Notez que cette action doit être faite en tant qu'utilisateur
    root. Dans le cas contraire, elle n'aura aucun effet. Du coup, un script
    de démarrage, exécuté par root, est le meilleur endroit où placer ce
    code. Si vous le faites, vous devriez aussi configurer ces variables
    d'environnement dans le script de démarrage avant d'invoquer le processus
    postmaster&nbsp;:
<programlisting>
export PG_OOM_ADJUST_FILE=/proc/self/oom_score_adj
export PG_OOM_ADJUST_VALUE=0
</programlisting>
    Ces paramètres vont faire en sorte que les processus fils du postmaster
    s'exécuteront avec l'ajustement de score OOm normal (0), pour que l'OOM
    puisse encore les cibler si cela s'avère nécessaire. Vous pouvez utiliser
    d'autres valeurs pour <envar>PG_OOM_ADJUST_VALUE</envar> si vous voulez
    que les processus fils s'exécutent avec un autre ajustement de score.
    (<envar>PG_OOM_ADJUST_VALUE</envar> peut aussi être omis, auquel cas sa
    valeur par défaut est zéro.) Si vous ne voulez pas configurer
    <envar>PG_OOM_ADJUST_FILE</envar>, les processus fils s'exécuteront avec
    le même ajustement de score OOM que le processus père postmaster, ce qui
    n'est pas conseillé car le but est de s'assurer que le processus
    postmaster soit protégé par la configuration.
   </para>
  </sect2>

  <sect2 id="linux-huge-pages">
   <title>Pages mémoire de grande taille
    (<foreignphrase>huge pages</foreignphrase>) sous Linux</title>

   <para>
    L'utilisation des <foreignphrase>huge pages</foreignphrase> réduit la
    surcharge lors de l'utilisation de gros morceaux contigus de mémoire, ce
    que fait <productname>PostgreSQL</productname>, tout particulièrement
    lors de l'utilisation de grosses valeurs pour <xref
    linkend="guc-shared-buffers"/>. Pour activer cette fonctionnalité avec
    <productname>PostgreSQL</productname>, vous avez besoin d'un noyau
    compilé avec <varname>CONFIG_HUGETLBFS=y</varname> et
    <varname>CONFIG_HUGETLB_PAGE=y</varname>. Vous aurez aussi besoin de
    configurer le système d'exploitation pour qu'il fournisse suffisament de
    Huge Pages de la taille désirée. Pour estimer le nombre de Huges Pages
    nécessaires, démarrez <productname>PostgreSQL</productname> sans activer
    les Huge Pages et vérifiez la taille du segment de mémoire partagée
    anonyme du processus postmaster, ainsi que les tailles par défaut et
    supportée par le systèmes des Huge Pages, en utilisant les systèmes de
    fichiers <filename>/proc</filename> et <filename>/sys</filename>. Cela
    pourrait ressemble à cela&nbsp;:

<programlisting>
$ <userinput>head -1 $PGDATA/postmaster.pid</userinput>
4170
$ <userinput>pmap 4170 | awk '/rw-s/ &amp;&amp; /zero/ {print $2}'</userinput>
6490428K
$ <userinput>ls /sys/kernel/mm/hugepages</userinput>
hugepages-1048576kB  hugepages-2048kB
</programlisting>

    Dans cet exemple, la valeur par défaut est de 2 Mo, vous pouvez aussi
    demander explicitement soit 2 Mo soit 1 Go avec <xref
    linkend="guc-huge-page-size"/>. En supposant <literal>2MB</literal> pour
    les Huge Pages, <literal>6490428</literal> / <literal>2048</literal>
    donne approximativement <literal>3169.154</literal>. Donc, dans cet
    exemple, nous avons besoin d'au moins <literal>3170</literal>
    <foreignphrase>huge pages</foreignphrase>. Une configuration plus
    importante serait appropriée si d'autres programmes du serveur ont aussi
    besoin des Huge Pages. Nous pouvons les configurer avec&nbsp;:

<programlisting>
# <userinput>sysctl -w vm.nr_hugepages=3170</userinput>
</programlisting>

    N'oubliez pas d'ajouter cette configuration à
    <filename>/etc/sysctl.conf</filename> pour qu'elle soit appliquée à
    chaque redémarrage. Pour les tailles personnalisées de Huge Page, nous
    pouvons utilisez à la place&nbsp;:

<programlisting>
# <userinput>echo 3170 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</userinput>
</programlisting>

    Il est aussi possible de fournir ces paramètres au démarrage en utilisant
    les paramètres noyau tels que <literal>hugepagesz=2M
    hugepages=3170</literal>.
   </para>

   <para>
    Parfois, le noyau n'est pas capable d'allouer immédiatement le nombre
    souhaité de  <foreignphrase>huge pages</foreignphrase> à cause de la
    fragmentation, donc il peut être nécessaire de répéter cette commande ou
    de redémarrer. (Tout de suite après un redémarrage, la plupart de la
    mémoire de la machine doit être disponible à une conversion en
    <foreignphrase>huge pages</foreignphrase>.) Pour vérifier la situation au
    niveau de l'allocation des  <foreignphrase>huge pages</foreignphrase>
    pour une taille donnée, utilisez&nbsp;:
<programlisting>
$ <userinput>cat /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</userinput>
</programlisting>
   </para>

   <para>
    Il pourrait être nécessaire de donner le droit à l'utilisateur du système
    d'exploitation du serveur de bases de données en configurant
    <varname>vm.hugetlb_shm_group</varname> via
    <application>sysctl</application>, et/ou en donnant le droit de
    verrouiller la mémoire avec <command>ulimit -l</command>.
   </para>
   
   <para>
    Il est aussi nécessaire de donner le droit d'utiliser les
    <foreignphrase>huge pages</foreignphrase> à l'utilisateur système qui
    exécute PostgreSQL. Cela se fait en configurant
    <varname>vm.hugetlb_shm_group</varname> via
    <application>sysctl</application>, et le droit de verrouiller la mémoire
    avec <command>ulimit -l</command>.
   </para>

   <para>
    Le comportement par défaut pour les <foreignphrase>huge
    pages</foreignphrase> dans <productname>PostgreSQL</productname> est de
    les utiliser quand cela est possible, avec la taille par défaut des Huge
    Pages du système, et de revenir aux pages normales dans le cas contraire.
    Pour forcer l'utilisation des  <foreignphrase>huge pages</foreignphrase>,
    vous pouvez configurer <xref linkend="guc-huge-pages"/> à
    <literal>on</literal> dans le fichier
    <filename>postgresql.conf</filename>. Notez que, avec ce paramètre
    configuré ainsi, <productname>PostgreSQL</productname> refusera de
    démarrer s'il ne peut pas récupérer suffisamment de <foreignphrase>huge
    pages</foreignphrase>.
   </para>

   <para>

    Pour une description détaillée des <foreignphrase>huge
    pages</foreignphrase> sous <productname>Linux</productname>, lisez <ulink
    url="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</ulink>.
   </para>
  </sect2>
 </sect1>


<sect1 id="server-shutdown">
<title>Arrêter le serveur</title>

<indexterm zone="server-shutdown">
<primary>arrêt</primary>
</indexterm>

<para>
Il existe plusieurs façons d'arrêter le serveur de bases de données. Au
final, elles se basent toutes sur l'envoi d'un signal au processus serveur
principal.
</para>

<para>
Si vous utilisez une version pré-packagée de
<productname>PostgreSQL</productname> et que vous avez utilisé les outils du
paquet pour démarrer le serveur, alors vous devriez aussi utiliser les
outils du paquet pour arrêter le serveur. Consultez la documentation du
paquet pour les détails.
</para>

<para>
Lors d'une gestion directe du serveur, vous pouvez contrôler le type d'arrêt
en envoyant différents signaux au processus
<command>postgres</command>&nbsp;:

<variablelist>
<varlistentry>
 <term><systemitem>sigterm</systemitem><indexterm><primary>sigterm</primary></indexterm></term>
 <listitem>
  <para>
   C'est le mode d'<firstterm>arrêt intelligent</firstterm>.
   Après réception de <systemitem>sigterm</systemitem>, le serveur
   désactive les nouvelles connexions mais permet aux sessions en cours de
   terminer leur travail normalement. Il s'arrête seulement après que toutes
   les sessions se sont terminées normalement. C'est l'arrêt intelligent
   (<firstterm>smart shutdown</firstterm>).
   Si le serveur est en mode de sauvegarde en ligne, il attends en plus la
   désactivation du mot de sauvegarde en ligne. Lorsque le mode de sauvegarde
   est actif, les nouvelles connexions sont toujours autorisées, mais
   seulement pour les super-utilisateurs (cette exception permet à un
   super-utilisateur de se connecter pour terminer le mode de sauvegarde en
   ligne). Si le serveur est en restauration quand une demande d'arrêt
   intelligent est envoyée, la restauration et la réplication en flux
   seront stoppées seulement une fois que toutes les autres sessions ont
   terminé.
  </para>
 </listitem>
</varlistentry>

<varlistentry>
 <term><systemitem>sigint</systemitem><indexterm><primary>sigint</primary></indexterm></term>
 <listitem>
  <para>
   C'est le mode d'<firstterm>arrêt rapide</firstterm>.
   Le serveur désactive les nouvelles connexions et envoie à tous
   les processus serveur le signal <systemitem>sigterm</systemitem>, qui les
   fera annuler leurs transactions courantes pour quitter rapidement. Il
   attend ensuite la fin de tous les processus serveur et s'arrête finalement.
   Si le serveur est en mode de sauvegarde en ligne, le mode est annulé,
   rendant la sauvegarde inutilisable.
  </para>
 </listitem>
</varlistentry>

<varlistentry>
 <term><systemitem>sigquit</systemitem><indexterm><primary>sigquit</primary></indexterm></term>
 <listitem>
  <para>
   C'est le mode d'<firstterm>arrêt immédiat</firstterm>. Le serveur enverra
   <systemitem>SIGQUIT</systemitem> à tous les processus fils et attendra
   qu'ils se terminent. Ceux qui ne se terminent pas au bout de cinq secondes
   se verront envoyés un signal <systemitem>SIGKILL</systemitem> par le
   processus père <command>postgres</command>, qui les arrêtera sans attendre
   plus. Ceci peut amener à un redémarrage en mode restauration (de ce fait,
   ceci n'est recommandé que dans les cas d'urgence).
  </para>
 </listitem>
</varlistentry>
</variablelist>
</para>

<para>
Le programme <xref linkend="app-pg-ctl"/> fournit une interface agréable
pour envoyer ces signaux dans le but d'arrêter le serveur. Autrement, vous
pouvez envoyer le signal directement en utilisant <command>kill</command>
sur les systèmes autres que Windows. Le <acronym>PID</acronym> du processus
<command>postgres</command> peut être trouvé en utilisant le programme
<command>ps</command> ou à partir du fichier
<filename>postmaster.pid</filename> dans le répertoire des données.
Par exemple, pour exécuter un arrêt rapide&nbsp;:
<screen>$ <userinput>kill -int `head -1 /usr/local/pgsql/data/postmaster.pid`</userinput></screen>
  </para>

  <important>
   <para>
    Il vaux mieux de ne pas utiliser <systemitem>SIGKILL</systemitem> pour arrêter
    le serveur. Le faire empêchera le serveur de libérer la mémoire partagée et
    les sémaphores. De plus, <systemitem>SIGKILL</systemitem> tue
    le processus <command>postgres</command> sans lui laisser le temps de
    relayer ce signal à ses sous-processus, donc il peut aussi être nécessaire
    de tuer chaque sous-processus à la main.
   </para>
  </important>

  <para>
   Pour terminer une session donnée tout en permettant aux autres de
   continuer, utilisez <function>pg_terminate_backend()</function>
   (voir <xref linkend="functions-admin-signal-table"/>) ou envoyez un signal
   <systemitem>SIGTERM</systemitem> au processus fils associé à cette session.
  </para>
 </sect1>

 <sect1 id="upgrading">
  <title>Mise à jour d'une instance <productname>PostgreSQL</productname></title>

  <indexterm zone="upgrading">
   <primary>mise à jour</primary>
  </indexterm>

  <indexterm zone="upgrading">
   <primary>version</primary>
   <secondary>compatibilité</secondary>
  </indexterm>

  <para>
   Cette section concerne la mise à jour des données de votre serveur
   d'une version de <productname>PostgreSQL</productname> vers une
   version ultérieure.
  </para>

  <para>
   Les numéros de versions actuelles de <productname>PostgreSQL</productname>
   se composent d'un numéro de version majeure et mineure. Par exemple, pour le
   numéro de version 10.1, 10 est le numéro de la version majeure et 1 est le
   numéro de la version mineure, ce qui signifie que c'est la première mise à
   jour mineure de la version majeure 10. Pour les versions précédant
   <productname>PostgreSQL</productname> 10.0, la numérotation des versions
   est composée de 3 numéros, par exemple 9.5.3. Dans ces cas, la version
   majeure est composée des deux premiers groupes de chiffres du numéro de
   version, par exemple 9.5, et la version mineure est le troisième chiffre,
   par exemple 3, signifiant que c'est la troisième version mineure de la
   version majeure 9.5.
  </para>

  <para>
   Les versions mineures ne changent jamais le format de stockage interne et
   sont toujours compatibles avec les versions mineures précédentes et
   suivantes de la m&ecirc;me version majeure. Par exemple, la version 10.1 est
   compatible avec la version 10.0 et la version 10.6. De m&ecirc;me, par
   exemple, la version 9.5.3 est compatible avec 9.5.0, 9.5.1 et 9.5.6. Pour
   mettre à jour entre versions compatibles, il suffit de remplacer les
   exécutables lorsque le serveur est arr&ecirc;té et de redémarrer le serveur.
   Le répertoire de données reste inchangé&nbsp;: les mises à jour mineures sont
   aussi simples que cela.
  </para>

  <para>
   Pour les versions <emphasis>majeures</emphasis> de
   <productname>PostgreSQL</productname>, le format de stockage interne
   des données est sujet à modification, ce qui complique les mises à
   jour. La méthode traditionnelle de migration des données vers une
   nouvelle version majeure est de sauvegarder puis recharger la base
   de données, même si cela peut être lent. <xref linkend="pgupgrade"/> est une
   méthode plus rapide. Des méthodes de réplication sont aussi disponibles,
   comme discuté ci-dessus. (Si vous utilisez une version pré-packagée de
   <productname>PostgreSQL</productname>, ce dernier pourrait fournir des
   scripts pour vous aider dans les mises à jour de versions majeures.
   Consultez la documentation du paquet pour les détails.)
  </para>

  <para>
   De plus, les nouvelles versions majeures introduisent généralement
   des incompatibilités qui impactent les utilisateurs. Du coup, des
   modifications peuvent être nécessaires sur les applications clientes.
   Tous les changements visibles par les utilisateurs sont listés dans
   les notes de version (<xref linkend="release"/>). Soyez particulièrement
   attentif à la section Migration. Bien que vous pouvez mettre à jour d'une
   version majeure vers une autre sans passer par les versions intermédiaires,
   vous devez lire les notes de version de toutes les versions majeures
   intermédiaires.
  </para>

  <para>
   Les utilisateurs précautionneux testeront leur applications clientes
   sur la nouvelle version avant de basculer complètement. Du coup, il
   est souvent intéressant de mettre en place des installations parallèles
   des ancienne et nouvelle versions. Lors d'un test d'une mise à jour
   majeure de <productname>PostgreSQL</productname>, pensez aux
   différentes catégories suivantes&nbsp;:
  </para>

  <variablelist>

   <varlistentry>
    <term>Administration</term>
    <listitem>
     <para>
      Les fonctionnalités disponibles pour les administrateurs pour
      surveiller et contrôler le serveur s'améliorent fréquemment à
      chaque nouvelle version.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>SQL</term>
    <listitem>
     <para>
      Cela inclut généralement les nouvelles commandes ou clauses SQL,
      et non pas des changements de comportement sauf si c'est
      spécifiquement précisé dans les notes de version.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>API</term>
    <listitem>
     <para>
      Les bibliothèques comme <application>libpq</application> se voient
      seulement ajouter de nouvelles fonctionnalités, sauf encore une
      fois si le contraire est mentionné dans les notes de version.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Catalogues systèmes</term>
    <listitem>
     <para>
      Les modifications dans les catalogues systèmes affectent seulement
      les outils de gestion des bases de données.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>API serveur pour le langage C</term>
    <listitem>
     <para>
      Ceci implique des modifications dans l'API des fonctions du moteur
      qui est écrit en C. De telles modifications affectent le code qui
      fait référence à des fonctions du moteur.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>

  <sect2 id="upgrading-via-pgdumpall">
   <title>Mettre à jour les données via <application>pg_dumpall</application></title>

   <para>
    Une méthode de mise à jour revient à sauvegarder les données d'une version
    majeure de <productname>PostgreSQL</productname> et de la recharger dans une
    autre &mdash; pour cela, vous devez utiliser un outil de sauvegarde
    <emphasis>logique</emphasis> comme <application>pg_dumpall</application>&nbsp;;
    une sauvegarde au niveau système de fichiers ne fonctionnera pas.
    Des vérifications sont faites pour vous empêcher d'utiliser un
    répertoire de données avec une version incompatible de
    <productname>PostgreSQL</productname>, donc aucun mal ne sera fait
    si vous essayez de lancer un serveur d'une version majeure sur un
    répertoire de données créé par une autre version majeure.)
   </para>

   <para>
    Il est recommandé d'utiliser les programmes
    <application>pg_dump</application> et
    <application>pg_dumpall</application> provenant de la <emphasis>nouvelle</emphasis>
    version de <productname>PostgreSQL</productname>, pour bénéficier
    des améliorations apportées à ces programmes. Les versions actuelles
    de ces programmes peuvent lire des données provenant de tout serveur
    dont la version est supérieure ou égale à la 7.0.
   </para>

   <para>
    Ces instructions supposent que votre installation existante se
    trouve dans le répertoire <filename>/usr/local/pgsql</filename> et
    que le répertoire des données est
    <filename>/usr/local/pgsql/data</filename>. Remplacez ces chemins
    pour correspondre à votre installation.
   </para>

   <procedure>
    <step>
     <para>
      Si vous faites une sauvegarde, assurez-vous que votre base de
      données n'est pas en cours de modification. Cela n'affectera pas
      l'intégrité de la sauvegarde mais les données modifiées ne seront
      évidemment pas incluses. Si nécessaire, modifiez les droits dans
      le fichier <filename>/usr/local/pgsql/data/pg_hba.conf</filename>
      (ou équivalent) pour interdire l'accès à tout le monde sauf vous.
      Voir <xref linkend="client-authentication"/> pour plus
      d'informations sur le contrôle des accès.
     </para>

     <para>
      <indexterm>
       <primary>pg_dumpall</primary>
       <secondary>utilisation lors d'une mise à jour</secondary>
      </indexterm>

      Pour sauvegarder votre installation, exécutez la commande
      suivante&nbsp;:
<screen>
<userinput>pg_dumpall &gt; <replaceable>fichier_en_sortie</replaceable></userinput>
</screen>
</para>

<para>
Pour faire la sauvegarde, vous pouvez utiliser la commande
<application>pg_dumpall</application> de la version en cours
d'exécution&nbsp;; voir <xref
linkend="backup-dump-all"/> pour plus de détails. Néanmoins,
pour de meilleurs résultats, essayez
d'utiliser la commande <application>pg_dumpall</application>
provenant de la version &version; de
<productname>PostgreSQL</productname>, car cette version contient
des corrections de bugs et des améliorations par rapport aux
anciennes version. Bien que ce conseil peut sembler étonnant, étant
donné que vous n'avez pas encore été la nouvelle version, il est
conseillé de le suivre si vous souhaitez installer la nouvelle
version en parallèle de l'ancienne. Dans ce cas, vous pouvez
terminer l'installation normalement et transférer les données plus
tard. Cela diminuera aussi le temps d'immobilisation.
</para>
</step>

<step>
<para>
Arrêtez l'ancien serveur&nbsp;:
<screen>
<userinput>pg_ctl stop</userinput>
</screen>
Sur les systèmes qui lancent <productname>PostgreSQL</productname>
au démarrage, il existe probablement un script de démarrage qui
fera la même chose. Par exemple, sur un système <systemitem
class="osname">Red Hat Linux</systemitem>, cette commande
pourrait fonctionner&nbsp;:
<screen>
<userinput>/etc/rc.d/init.d/postgresql stop</userinput>
</screen>
Voir <xref linkend="runtime"/> pour des détails sur le lancement
et l'arrêt d'un serveur.
</para>
</step>

<step>
<para>
Lors de la restauration de la sauvegarde, renommez ou supprimez l'ancien
répertoire d'installation si ce n'est pas spécifique à la version. Il
est préférable de le renommer car, en cas de problème, vous pourrez le
récupérer. Garder en tête que le répertoire peut prendre beaucoup d'espace
disque. Pour renommer le répertoire, utilisez une commande comme
celle-ci&nbsp;:
<screen>
<userinput>mv /usr/local/pgsql /usr/local/pgsql.old</userinput>
</screen>
(Assurez-vous de déplacer le répertoire en un seul coup, pour que
les chemins relatifs restent inchangés.)
</para>
</step>

<step>
<para>
Installez la nouvelle version de <productname>PostgreSQL</productname>
comme indiqué dans <phrase>la section suivante</phrase>
<phrase><xref linkend="install-procedure"/></phrase>.
</para>
</step>

<step>
<para>
Créez une nouvelle instance de bases de données si nécessaire.
Rappelez-vous que vous devez exécuter ces commandes une fois
connecté en tant que l'utilisateur de bases de données (que vous
devez déjà avoir si vous faites une mise à jour).
<programlisting>
<userinput>/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data</userinput>
</programlisting>
</para>
</step>

<step>
<para>
Restaurez vos modifications dans les fichiers
<filename>pg_hba.conf</filename> et
<filename>postgresql.conf</filename>.
</para>
</step>

<step>
<para>
Démarrez le serveur de bases de données, en utilisant encore une
fois l'utilisateur de bases de données&nbsp;:
<programlisting>
<userinput>/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data</userinput>
</programlisting>
</para>
</step>

<step>
<para>
Enfin, restaurez vos données à partir de votre sauvegarde&nbsp;:
<screen>
<userinput>/usr/local/pgsql/bin/psql -d postgres -f <replaceable>outputfile</replaceable></userinput>
</screen>
en utilisant le <emphasis>nouveau</emphasis> <application>psql</application>.
</para>
</step>
</procedure>

<para>
Il est possible de parvenir à une immobilisation moins longue en
installant le nouveau serveur dans un autre répertoire et en
exécutant l'ancien et le nouveau serveur, en parallèle, sur des
ports différents. Vous pouvez ensuite utiliser quelque chose
comme&nbsp;:

<programlisting>
pg_dumpall -p 5432 | psql -d postgres -p 5433
</programlisting>
pour transférer vos données.
</para>

</sect2>

<sect2 id="upgrading-via-pg-upgrade">
<title>Mettre à jour les données via <application>pg_upgrade</application></title>

<para>
Le module <xref linkend="pgupgrade"/> permet la mise à jour en ligne
d'une installation d'une version majeure de
<productname>PostgreSQL</productname> vers une autre. Les mises à jour se
sont en quelques minutes, notamment avec le mode <option>--link</option>.
Il requiert les mêmes étapes que pour <application>pg_dumpall</application>
ci-dessus, autrement dit lancer/arrêter le serveur, lancer
<application>initdb</application>.  La <link
linkend="pgupgrade">documentation</link> de <application>pg_upgrade</application>
surligne les étapes nécessaires.
</para>
</sect2>

<sect2 id="upgrading-via-replication">
<title>Mettre à jour les données via la réplication</title>

<para>
Il est aussi possible d'utiliser des méthodes de réplication logique
pour créer un serveur secondaire
avec une version plus récente de <productname>PostgreSQL</productname>.
C'est possible car la réplication logique permet une réplication entre des
versions majeures différentes de
<productname>PostgreSQL</productname>. Le secondaire peut se trouver sur
le même serveur ou sur un autre. Une fois qu'il est synchronisé
avec le serveur primaire (qui utilise toujours l'ancienne version de
<productname>PostgreSQL</productname>), vous pouvez basculer le
serveur primaire sur le nouveau serveur et arrêter l'ancien primaire.
Ce type de bascule fait que l'arrêt requis pour la mise à jour se
mesure seulement en secondes.
</para>

<para>
Cette méthode de mise à jour peut être mise en œuvre avec la réplication
logique intégrée comme avec des outils de réplication logique tels que
<productname>pglogical</productname>, <productname>Slony</productname>,
<productname>Londiste</productname>, et <productname>Bucardo</productname>.
</para>

</sect2>
</sect1>

<sect1 id="preventing-server-spoofing">
<title>Empêcher l'usurpation de serveur (spoofing)</title>

<indexterm zone="preventing-server-spoofing">
<primary>usurpation de serveur (server spoofing)</primary>
</indexterm>

<para>
Quand le serveur est en cours d'exécution, un utilisateur mal intentionné ne
peut pas interférer dans les communications client/serveur. Néanmoins,
quand le serveur est arrêté, un utilisateur local peut usurper le rôle du serveur
normal en lançant son propre serveur. Le serveur usurpateur pourrait lire
les mots de passe et les requêtes envoyés par les clients, mais ne pourrait
pas renvoyer de données car le répertoire <varname>PGDATA</varname> est
toujours sécurisé grâce aux droits d'accès du répertoire. L'usurpation
est possible parce que tout utilisateur peut lancer un serveur de bases
de données&nbsp;; un client ne peut pas identifier un serveur invalide
sauf s'il est configuré spécialement.
</para>

<para>
Un moyen d'empêcher les serveurs d'usurper des
connexions <literal>local</literal>es est d'utiliser un répertoire de
socket de domaine Unix (<xref linkend="guc-unix-socket-directories"/>) qui
n'a un droit en écriture que pour un utilisateur local de
confiance. Ceci empêche un utilisateur mal intentionné de créer son
propre fichier socket dans ce répertoire. Si vous craignez que
certaines applications puissent encore référencer
<filename>/tmp</filename> pour le fichier socket et, du coup, être
vulnérable au <quote>spoofing</quote>, créez un lien
symbolique <filename>/tmp/.s.PGSQL.5432</filename> pointant vers le fichier
socket déplacé. Vous pourriez alors avoir besoin de modifier votre script
de nettoyage de <filename>/tmp</filename> pour empêcher la suppression du
lien symbolique.
</para>

<para>
Une autre option pour les connexions de type <literal>local</literal> est que
les clients utilisent <link
linkend="libpq-connect-requirepeer"><literal>requirepeer</literal></link>
pour indiquer un propriétaire précis du processus serveur connecté au socket.
</para>

<para>
Pour éviter l'usurpation sur les connexions TCP, utilisez des certificats SSL,
et assurez-vous que les clients vérifient le certificat du serveur,
ou bien utilisez le chiffrage GSSAPI (ou les deux, s'il s'agit de connexions
séparées).
</para>

<para>
Pour éviter l'usurpation avec SSL, le serveur doit être configuré
pour accepter les connexions <literal>hostssl</literal>
(<xref linkend="auth-pg-hba-conf"/>)
et avoir des fichiers SSL clé et certificat
(<xref linkend="ssl-tcp"/>). Le client TCP
doit se connecter en utilisant <literal>sslmode='verify-ca'</literal> ou
<literal>verify-full</literal> et le fichier certificat root approprié
doit y être installé (<xref linkend="libq-ssl-certificates"/>).
</para>

<para>
Pour éviter l'usurpation avec GSSAPI, le serveur doit être configuré
pour n'accepter que les connexions <literal>hostgssenc</literal>
(<xref linkend="auth-pg-hba-conf"/>) et l'authentification
<literal>gss</literal> avec elles.
Le client TCP doit se connecter en utilisant <literal>gssencmode=require</literal>.
</para>
</sect1>

<sect1 id="encryption-options">
<title>Options de chiffrement</title>

<indexterm zone="encryption-options">
<primary>chiffrement</primary>
</indexterm>

<para>
<productname>PostgreSQL</productname> offre du chiffrement à différents niveaux
et offre une certaine flexibilité pour éviter que les données soit révélées
à cause d'un vol du serveur de la base de données, d'administrateurs peu scrupuleux
et de réseaux non sécurisés. Le chiffrement pourrait aussi être requis pour
sécuriser des données sensibles, par exemple des informations médicales ou des
transactions financières.
</para>

<variablelist>

<varlistentry>
<term>Chiffrement du mot de passe</term>
<listitem>

<para>
Les mots de passe des utilisateurs de la base de données sont stockées
suivant des hachages (déterminés par la configuration du paramètre <xref
linkend="guc-password-encryption"/>), donc l'administrateur ne peut pas
déterminer le mot de passe actuellement affecté à l'utilisateur. Si le
chiffrage MD5 ou SCRAM est utilisé pour l'authentification du client, le mot
de passe non chiffré n'est jamais, y compris temporairement, présent sur le
serveur parce que le client le chiffre avant de l'envoyer sur le réseau.
SCRAM est à préférer parce qu'il s'agit d'un standard Internet et qu'il
est bien plus sécurisé que le protocole d'authentification MD5 spécifique à
PostgreSQL.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>chiffrement de colonnes spécifiques</term>

<listitem>
<para>
Le module <xref linkend="pgcrypto"/> autorise le stockage chiffré de certains
champs. Ceci est utile si seulement certaines données sont sensibles.
Le client fournit la clé, la donnée est déchiffrée sur
le serveur puis envoyée au client.
</para>

<para>
La donnée déchiffrée et la clé de déchiffrement sont présentes sur le serveur
pendant un bref moment où la donnée est déchiffrée, puis envoyée entre le
client et le serveur. Il y a donc un bref moment où la donnée et les
clés peuvent être interceptées par quelqu'un ayant un accès complet au
serveur de bases de données, tel que l'administrateur du système.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>chiffrement de la partition de données</term>

<listitem>
<para>
Le chiffrement du stockage peut se réaliser au niveau du système de
fichiers ou au niveu du bloc. Les options de chiffrement des systèmes
de fichiers sous Linux incluent eCryptfs et EncFS, alors que FreeBSD
utilise PEFS. Les options de chiffrement au niveau bloc ou au niveau
disque incluent dm-crypt + LUKS sur Linux et les modules GEOM geli et
gbde sur FreeBSD. Beaucoup d'autres systèmes d'exploitation supportent
cette fonctionnalité, y compris Windows.
</para>

<para>
Ce mécanisme empêche les données non chiffrées d'être lues à partir des
lecteurs s'ils sont volés. Ceci ne protège pas contre les attaques quand
le système de fichiers est monté parce que, une fois monté, le système
d'exploitation fournit une vue non chiffrée des données. Néanmoins, pour
monter le système de fichiers, vous avez besoin d'un moyen pour fournir
la clé de chiffrement au système d'exploitation et, quelque fois, la clé
est stocké quelque part près de l'hôte qui monte le disque.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>chiffrement des données sur le réseau</term>

<listitem>
<para>
Les connexions SSL chiffrent toutes les données envoyées sur le
réseau&nbsp;: le mot de passe, les requêtes et les données renvoyées. Le
fichier <filename>pg_hba.conf</filename> permet aux administrateurs de spécifier
quels hôtes peuvent utiliser des connexions non chiffrées (<literal>host</literal>)
et lesquels requièrent des connexions SSL (<literal>hostssl</literal>). De plus,
les clients peuvent spécifier qu'ils se connectent aux serveurs seulement
via SSL.
</para>

<para>
Les connexions chiffrées par GSSAPI chiffrent toutes les données
envoyées sur le réseau, dont les requêtes et les données renvoyées.
(Aucun mot de passe n'est envoyé sur le réseau).
Le fichier <filename>pg_hba.conf</filename> permet aux administrateurs
d'indiquer quels clients peuvent utiliser des connexions non chiffrées
(<literal>host</literal>) et lesquels nécessitent des connexions
chiffrées par GSSAPI (<literal>hostgssenc</literal>).
Les clients peuvent aussi préciser qu'ils ne se connecteront
qu'avec des connections chiffrées par GSSAPI
(<literal>gssencmode=require</literal>).

</para>

<para>
<application>Stunnel</application> ou
<application>SSH</application> peuvent aussi
être utilisés pour chiffrer les transmissions.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Authentification de l'hôte SSL</term>

<listitem>
<para>
Il est possible que le client et le serveur fournissent des certificats
SSL à l'autre. Cela demande une configuration supplémentaire
de chaque côté mais cela fournit une vérification plus forte de l'identité
que la simple utilisation de mots de passe. Cela empêche un ordinateur de
se faire passer pour le serveur assez longtemps pour lire le mot de passe
envoyé par le client. Cela empêche aussi les attaques du type <quote>man
in the middle</quote> où un ordinateur, entre le client et le serveur,
prétend être le serveur, lit et envoie les données entre le client et le
serveur.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Chiffrement côté client</term>

<listitem>
<para>
Si vous n'avez pas confiance en l'administrateur système du serveur, il
est nécessaire
que le client crypte les données&nbsp;; de cette façon, les données non
cryptées n'apparaissent jamais sur le serveur de la base de données. Les
données sont cryptées sur le client avant d'être envoyé au serveur, et les
résultats de la base de données doivent être décryptés sur le client avant
d'être utilisés.
</para>
</listitem>
</varlistentry>

</variablelist>

</sect1>

<sect1 id="ssl-tcp">
<title>Connexions TCP/IP sécurisées avec SSL</title>

<indexterm zone="ssl-tcp">
<primary>ssl</primary>
</indexterm>

<para>
<productname>PostgreSQL</productname> dispose d'un support natif pour l'utilisation de
connexions <acronym>SSL</acronym> et le chiffrage des communications
client/serveur pour améliorer la sécurité améliorée.
Ceci requiert l'installation
d'<productname>OpenSSL</productname> à la fois sur le système client et sur
le système serveur et que ce support soit activé au moment de la
construction de <productname>PostgreSQL</productname> (voir le <xref
linkend="installation"/>).
</para>

<sect2 id="ssl-setup">
<title>Configuration basique</title>

<para>
Avec <acronym>SSL</acronym> intégré à la compilation, le serveur
<productname>PostgreSQL</productname> peut être démarré avec
<acronym>SSL</acronym> activé en positionnant le paramètre
<xref linkend="guc-ssl"/> à <literal>on</literal> dans
<filename>postgresql.conf</filename>. Le serveur écoutera les deux types
de connexion, normal et  <acronym>SSL</acronym>, sur le même port TCP,
et négociera l'utilisation de <acronym>SSL</acronym> avec chaque client.
Par défaut, c'est au choix du client&nbsp;; voir <xref
linkend="auth-pg-hba-conf"/> pour la configuration du serveur
pour exiger <acronym>SSL</acronym> pour tout ou partie des connexions.
</para>

<para>
Pour démarrer dans le mode <acronym>SSL</acronym>, les fichiers contenant le
certificat du serveur et la clé privée doivent exister. Par défaut, ces
fichiers sont nommés respectivement <filename>server.crt</filename> et
<filename>server.key</filename>, et sont placés dans le répertoire des
données du serveur. D'autres noms et emplacements peuvent être spécifiés
en utilisant les paramètres <xref linkend="guc-ssl-cert-file"/>
et <xref linkend="guc-ssl-key-file"/>.
</para>

<para>
Sur les systèmes Unix, les droits de <filename>server.key</filename> doivent
interdire l'accès au groupe et au reste du monde&nbsp;; cela se fait avec
la commande <command>chmod 0600 server.key</command>. Il est aussi possible
de faire en sorte que le fichier ait root comme propriétaire et des droits
de lecture pour le groupe (autrement dit, des droits <literal>0640</literal>).
Cette configuration cible les installations où les fichiers certificat et
clé sont gérés par le système d'exploitation. L'utilisateur qui exécute le
serveur <productname>PostgreSQL</productname> doit être un membre du groupe
qui a accès aux fichiers certificat et clé.
</para>

<para>
Si le répertoire des données permet l'accès en lecture au groupe,
alors les fichiers de certificat doivent être placés hors de ce répertoire
pour se conformer aux exigences de sécurité décrites ci-dessus.
Généralement, l'accès au groupe est autorisé pour permettre à un utilisateur
non privilégié de sauvegarder la base, et dans ce cas le logiciel
de sauvegarde sera incapable de lire les certificats et retournera
probablement une erreur.
</para>

<para>
Si la clé privée est protégée par une phrase de passe, le serveur la
demandera et ne se lancera pas tant qu'elle n'aura pas été saisie.
Utiliser une phrase de passe par défaut emp&ecirc;che également la
possibilité de modifier la configuration SSL du serveur sans redémarrage.
Voir <xref linkend="guc-ssl-passphrase-command-supports-reload"/>. De
plus, les clés privées protégées par phrases de passe ne peuvent
&ecirc;tre utilisées sur Windows.
</para>

<para>
Le premier certificat dans <filename>server.crt</filename> doit être le
certificat du serveur car il doit correspondre à la clé privée du serveur.
Les certificats des autorités <quote>intermédiaires</quote> d'autorité
peuvent aussi être ajoutés au fichier. Le faire permet d'éviter la
nécessité d'enregistrer les certificats intermédiaires des clients, en
supposant que le certificat racine et les certificats intermédiaires ont
été créés avec les extensions <literal>v3_ca</literal>. (Ceci configure
la contrainte basique du certificat de <literal>CA</literal> à
<literal>true</literal>.) Ceci permet une expiration plus simple des
certificats intermédiaires.
</para>

<para>
Il n'est pas nécessaire d'ajouter le certificat racine dans le fichier
<filename>server.crt</filename>. À la place, les clients doivent avoir le
certificat racine de la chaîne de certificats du serveur.
</para>
</sect2>

<sect2 id="ssl-openssl-config">
<title>Configuration d'OpenSSL</title>

<para>
<productname>PostgreSQL</productname> lit le fichier de configuration
<productname>OpenSSL</productname> du système. Par défaut, ce fichier
est nommé <filename>openssl.cnf</filename> et est situé dans le
répertoire désigné par <literal>openssl version -d</literal>.
Ce défaut peut être surchargé en remplissant la variable d'environnement
<envar>OPENSSL_CONF</envar> avec le nom du fichier de configuration
désiré.
</para>

<para>
<productname>OpenSSL</productname> supporte une large gamme d'algorithmes
de chiffrement et d'authentification de forces variables.
Bien qu'une liste des techniques de chiffrement soit spécifiée dans le
fichier de configuration d'<productname>OpenSSL</productname>,
vous pouvez préciser les chiffrements à utiliser par le serveur
en modifiant <xref linkend="guc-ssl-ciphers"/> dans
<filename>postgresql.conf</filename>.
</para>

<note>
<para>
Il est possible d'avoir une authentification sans le coût du chiffrement
en utilisant les chiffrements <literal>NULL-SHA</literal> ou
<literal>NULL-MD5</literal> ciphers. Cependant, un «&nbsp;homme
du milieu&nbsp;» (<foreignphrase>man-in-the-middle</foreignphrase>)
pourrait lire et transmettre des communications entre client et serveur.
Pour ces raisons, les chiffrements NULL ne sont pas recommandés.
</para>
</note>
</sect2>

<sect2 id="ssl-client-certificates">
<title>Utiliser des certificats clients</title>

<para>
Pour réclamer au client de fournir un certificat de confiance, placez les
certificats des autorités certificats racines (<acronym>CA</acronym>) dont
vous avez confiance dans un fichier du répertoire des données, configurez le
paramètre <xref linkend="guc-ssl-ca-file"/> dans
<filename>postgresql.conf</filename> au nouveau nom du fichier, et ajoutez
l'option d'authentification <literal>clientcert=verify-ca</literal> ou
<literal>clientcert=verify-full</literal> sur la ligne
<literal>hostssl</literal> approprié dans <filename>pg_hba.conf</filename>. Un
certificat sera alors réclamé du client lors du démarrage de la connexion SSL.
(Voir <xref linkend="libpq-ssl"/> pour une description sur la configuration
des certificats sur le client.)
</para>

<para>
For a <literal>hostssl</literal> entry with
<literal>clientcert=verify-ca</literal>, the server will verify
that the client's certificate is signed by one of the trusted
certificate authorities. If <literal>clientcert=verify-full</literal>
is specified, the server will not only verify the certificate
chain, but it will also check whether the username or its mapping
matches the <literal>cn</literal> (Common Name) of the provided certificate.
Note that certificate chain validation is always ensured when the
<literal>cert</literal> authentication method is used
(see <xref linkend="auth-cert"/>).
</para>

<para>
Les certificats intermédiaires chaînés jusqu'aux certificats racines existants
peuvent aussi apparaître dans le fichier <filename>root.crt</filename> si vous
souhaitez éviter d'avoir à les stocker sur les clients (en supposant que les
certificats racine et intermédiaires ont été créés avec les extensions
<literal>v3_ca</literal>). Les entrées dans la liste de révocation de
certificats (CRL) sont aussi vérifiées si le paramètre <xref
linkend="guc-ssl-crl-file"/> ou <xref linkend="guc-ssl-crl-dir"/> est configuré.
</para>

<para>
L'option d'authentification <literal>clientcert</literal> est disponible
pour toutes les méthodes d'authentification, mais seulement pour les lignes
du fichier <filename>pg_hba.conf</filename> indiquées avec
<literal>hostssl</literal>.
Quand <literal>clientcert</literal> n'est pas
configuré,
le serveur vérifie toujours avec son fichier CA le
certificat client présenté, s'il est configuré.
</para>

<para>
Il y a deux approches pour forcer les utilisateurs à fournir un certificat
à la connexion.
</para>

<para>
La première approche fait usage de la méthode d'authentification
<literal>cert</literal> pour les entrées <literal>hostssl</literal> de
<filename>pg_hba.conf</filename>, afin que le certificat lui-même soit
utilisé pour l'authentification tout en fournissant la sécurité de la
connexion SSL. Voir les détails dans <xref linkend="auth-cert"/>.
(Il n'est pas nécessaire de spécifier explicitement d'options
<literal>clientcert</literal> avec la méthode d'authentification
<literal>cert</literal>.)
Dans ce cas, le <literal>cn</literal> (<foreignphrase>Common Name</foreignphrase>)
dans le certificat est comparé au nom d'utilisateur ou au mappage
applicable.
</para>

<para>
La seconde approche combine n'importe quelle méthode d'authentification
pour les entrées <literal>hostssl</literal> avec la vérification des
certificats des clients, en positionnant l'option d'authentification
<literal>clientcert</literal> à <literal>verify-ca</literal>
ou <literal>verify-full</literal>.
La première option ne garantit que la validité du certificat,
alors que la seconde vérifie aussi que le
<literal>cn</literal> (<foreignphrase>Common Name</foreignphrase>)
correspond au nom d'utilisateur ou au mappage applicable.
</para>
</sect2>

<sect2 id="ssl-server-files">
<title>Utilisation des fichiers serveur SSL</title>

<para>
<xref linkend="ssl-file-usage"/> résume les fichiers qui ont un lien
avec la configuration de SSL sur le serveur. (Les noms de fichiers
indiqués sont les noms par défaut. Les noms configurés
localement peuvent être différents.)
</para>

<table id="ssl-file-usage">
<title>Utilisation des fichiers serveur SSL</title>
<tgroup cols="3">
<thead>
<row>
<entry>Fichier</entry>
<entry>Contenu</entry>
<entry>Effet</entry>
</row>
</thead>

<tbody>

<row>
<entry><xref linkend="guc-ssl-cert-file"/> (<filename>$PGDATA/server.crt</filename>)</entry>
<entry>certificat du serveur</entry>
<entry>envoyé au client pour indiquer l'identité du serveur</entry>
</row>

<row>
<entry><xref linkend="guc-ssl-key-file"/> (<filename>$PGDATA/server.key</filename>)</entry>
<entry>clé privée du serveur</entry>
<entry>prouve que le certificat serveur est envoyé par son
 propriétaire&nbsp; n'indique pas que le propriétaire du certificat est
 de confiance</entry>
</row>

<row>
<entry><xref linkend="guc-ssl-ca-file"/> (<filename>$PGDATA/root.crt</filename>)</entry>
<entry>autorités de confiance pour les certificats</entry>
<entry>vérifie le certificat du client&nbsp;; vérifie que le certificat
 du client est signé par une autorité de confiance</entry>
</row>

<row>
<entry><xref linkend="guc-ssl-crl-file"/> (<filename>$PGDATA/root.crl</filename>)</entry>
<entry>certificats révoqués par les autorités de confiance</entry>
<entry>le certificat du client ne doit pas être sur cette liste</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
Le serveur lit ces fichiers lors de son démarrage et à chaque rechargement
de la configuration serveur. Sur les systèmes
<systemitem class="osname">Windows</systemitem>, ils sont également relus
chaque fois qu'un nouveau processus est démarré pour une nouvelle connexion
client.
</para>

<para>
Si une erreur est détectée dans ces fichiers lors du démarrage du serveur,
celui-ci refusera de démarrer. Par contre, si une erreur est détectée lors
d'un rechargement de configuration, ces fichiers seront ignorés et
l'ancienne configuration SSL continuera d'&ecirc;tre utilisée. Sur les
systèmes <systemitem class="osname">Windows</systemitem>, si une erreur est
détectée dans ces fichiers au démarrage d'un processus backend, celui-ci ne
pourra établir une connexion SSL. Dans tous les cas, l'erreur sera rapportée
dans les journaux du serveur.
</para>

</sect2>

<sect2 id="ssl-certificate-creation">
<title>Créer des certificats</title>

<para>
Pour créer un certificat simple auto-signé pour le serveur, valide pour 365
jours, utilisez la commande <productname>OpenSSL</productname> suivante, en
remplaçant <replaceable>dbhost.yourdomain.com</replaceable> avec le nom d'hôte
du serveur&nbsp;
<programlisting>
openssl req -new -x509 -days 365 -nodes -text -out server.crt \
  -keyout server.key -subj "/CN=<replaceable>dbhost.yourdomain.com</replaceable>"
</programlisting>
Puis, exécutez&nbsp;:
<programlisting>
chmod og-rwx server.key
</programlisting>
car le serveur rejetera le fichier si ses droits sont plus importants. Pour
plus de détails sur la façon de créer la clé privée et le certificat de votre
serveur, référez-vous à la documentation d'<productname>OpenSSL</productname>.
</para>

<para>
Bien qu'un certificat auto-signé puisse être utilisé pour des tests, un
certificat signé par une autorité de certificats (<acronym>CA</acronym>)
(habituellement un <acronym>CA</acronym> racine entreprise) devrait être
utilisé en production.
</para>

<para>
Pour créer un certificat serveur dont l'identité peut être validé par des
clients, créez tout d'abord une demande de signature de certificat
(<acronym>CSR</acronym>) et un fichier clés public/privé&nbsp;:
<programlisting>
openssl req -new -nodes -text -out root.csr \
  -keyout root.key -subj "/CN=<replaceable>root.yourdomain.com</replaceable>"
chmod og-rwx root.key
</programlisting>
Puis, signez la demande avec la clé pour créer une autorité de certificat
racine (en utilisant l'emplacement du fichier de configuration
<productname>OpenSSL</productname> par défaut sur
<productname>Linux</productname>)&nbsp;:
<programlisting>
openssl x509 -req -in root.csr -text -days 3650 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -signkey root.key -out root.crt
</programlisting>
Enfin, créez un certificat serveur signé par la nouvelle autorité de
certificat racine&nbsp;:
<programlisting>
openssl req -new -nodes -text -out server.csr \
  -keyout server.key -subj "/CN=<replaceable>dbhost.yourdomain.com</replaceable>"
chmod og-rwx server.key

openssl x509 -req -in server.csr -text -days 365 \
  -CA root.crt -CAkey root.key -CAcreateserial \
  -out server.crt
</programlisting>
<filename>server.crt</filename> et <filename>server.key</filename> doivent
être stockés sur le serveur, et <filename>root.crt</filename> doit être stocké
sur le client pour que le client puisse vérifier que le certificat feuille du
serveur a été signé par son propre certificat racine de confiance.
<filename>root.key</filename> doit être enregistré hors ligne pour l'utiliser
pour créer les prochains certificats.
</para>

<para>
Il est aussi possible de créer une chaîne de confiance qui inclut les
certificats intermédiaires&nbsp;:
<programlisting>
# root
openssl req -new -nodes -text -out root.csr \
  -keyout root.key -subj "/CN=<replaceable>root.yourdomain.com</replaceable>"
chmod og-rwx root.key
openssl x509 -req -in root.csr -text -days 3650 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -signkey root.key -out root.crt

# intermediate
openssl req -new -nodes -text -out intermediate.csr \
  -keyout intermediate.key -subj "/CN=<replaceable>intermediate.yourdomain.com</replaceable>"
chmod og-rwx intermediate.key
openssl x509 -req -in intermediate.csr -text -days 1825 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -CA root.crt -CAkey root.key -CAcreateserial \
  -out intermediate.crt

# leaf
openssl req -new -nodes -text -out server.csr \
  -keyout server.key -subj "/CN=<replaceable>dbhost.yourdomain.com</replaceable>"
chmod og-rwx server.key
openssl x509 -req -in server.csr -text -days 365 \
  -CA intermediate.crt -CAkey intermediate.key -CAcreateserial \
  -out server.crt
</programlisting>
<filename>server.crt</filename> et <filename>intermediate.crt</filename>
doivent être concaténés dans un fichier certificat et stocké sur le serveur.
<filename>server.key</filename> doit aussi être stocké sur le serveur.
<filename>root.crt</filename> doit être stocké sur le client pour que le
client puisse vérifier que le certificat feuille du serveur a été signé par
une chaîne de certificats liés au certificat racine de confiance.
<filename>root.key</filename> et <filename>intermediate.key</filename> doivent
être stockées hors ligne pour être utilisé dans la création des certificats
futurs.
</para>
</sect2>
</sect1>

<sect1 id="gssapi-enc">
<title>Connexions TCP/IP sécurisées avec le chiffrage GSSAPI</title>

<indexterm zone="gssapi-enc">
<primary>gssapi</primary>
</indexterm>

<para>
<productname>PostgreSQL</productname> a aussi un support natif de
<acronym>GSSAPI</acronym> pour améliorer la sécurité en chiffrant
les communications client/serveur.
Cela requiert que soit installée une implémentation de
<acronym>GSSAPI</acronym> (comme MIT Kerberos) à la fois sur le client et
le serveur, et que le support dans <productname>PostgreSQL</productname>
soit activé à la compilation (voir <xref linkend="installation"/>).
</para>

<sect2 id="gssapi-setup">
<title>Mise en place de base</title>

<para>
Le serveur <productname>PostgreSQL</productname> écoutera
sur le même port TCP à la fois les connexions normales
et celles chiffrées par <acronym>GSSAPI</acronym>, et négociera
avec chaque client désirant se connecter s'il faut utiliser
<acronym>GSSAPI</acronym> pour le chiffrage (et l'authentification).
Par défaut, cette décision est celle du client (ce qui signifie
qu'un attaquant peut en dégrader le niveau)&nbsp;; voir
<xref linkend="auth-pg-hba-conf"/> sur comment configurer le serveur
pour exiger l'utilisation de <acronym>GSSAPI</acronym> pour tout ou
partie des connexions.
</para>

   <para>
    Lors de l'utilisation de <acronym>GSSAPI</acronym> pour le chiffrement, il
    est commun d'utiliser <acronym>GSSAPI</acronym> aussi pour
    l'authentification car les mécanismes sous-jacents détermineront les
    identités du client et du serveur (d'après l'implémentation
    <acronym>GSSAPI</acronym>) dans tous les cas. Ceci n'est pas requis. Une
    autre méthode d'authentification <productname>PostgreSQL</productname>
    peut être utilisée pour réaliser les vérifications supplémentaires.
   </para>

<para>
À part la configuration de cette négociation, <acronym>GSSAPI</acronym>
ne requiert aucune configuration au-delà de ce qui est nécessaire pour
l'authentification GSSAPI. (Pour plus d'informations sur sa mise
en place, voir <xref linkend="gssapi-auth"/>.)
</para>
</sect2>
</sect1>

<sect1 id="ssh-tunnels">
<title>Connexions TCP/IP sécurisées avec des tunnels
<application>ssh</application> tunnels</title>

<indexterm zone="ssh-tunnels">
<primary>ssh</primary>
</indexterm>

<para>
Il est possible d'utiliser <application>ssh</application> pour chiffrer la
connexion réseau entre les clients et un serveur
<productname>PostgreSQL</productname>. Réalisé correctement, ceci fournit une
connexion réseau sécurisée, y compris pour les clients non SSL.
</para>

<para>
Tout d'abord, assurez-vous qu'un serveur <application>ssh</application> est
en cours d'exécution sur la même machine que le serveur
<productname>PostgreSQL</productname> et que vous pouvez vous connecter via
<command>ssh</command> en tant qu'un utilisateur quelconque. Ensuite, vous
pouvez établir un tunnel sécurisé vers le serveur distant. Un tunnel
sécurisé écoute sur un port local et envoie tout le trafic vers un port de
la machine distante. Le trafic envoyé vers le port distant peut arriver sur
son adresse <literal>localhost</literal> ou vers une autre adresse liée si
désirée&nbsp;, il n'apparaît pas comme venant de votre machine locale.
Cette commande crée un tunnel sécurisé de la machine cliente vers la
machine distante
<literal>foo.com</literal>&nbsp;:
<programlisting>ssh -L 63333:localhost:5432 joe@foo.com</programlisting>
   Le premier numéro de l'argument <option>-l</option>, 63333, est le numéro
   de port local du tunnel&nbsp;; cela peut être tout port inutilisé. (IANA
   réserve les ports 49152 à 65535 pour une utilisation privée.) Le nom ou
   l'adresse IP après ça est l'adresse distante liée à laquelle vous vous
   connectez, par exemple <literal>localhost</literal>, ce qui est la valeur
   par défaut. Le deuxième nombre, 5432, est la fin distante du tunnel,
   autrement dit le numéro de port du serveur de bases de données. Pour vous
   connecter au serveur en utilisant ce tunnel, vous vous connectez au port
   63333 de la machine locale&nbsp;:
<programlisting>psql -h localhost -p 63333 postgres</programlisting>
   Sur le serveur de bases de données, il semblera que vous êtes l'utilisateur
   <literal>joe</literal> sur l'hôte <literal>foo.com</literal> en vous
   connectant à l'adresse liée <literal>localhost</literal> dans ce contexte,
   et il utilisera la procédure d'authentification configurée pour les
   connexions de cet utilisateur et de cet hôte. Notez que le serveur ne
   pensera pas que la connexion est chiffrée avec SSL car, en effet, elle
   n'est pas chiffrée entre le serveur <application>SSH</application> et le
   serveur <productname>PostgreSQL</productname>. Cela ne devrait pas poser un
   risque de sécurité supplémentaire parce que les deux serveurs sont sur la
   même machine.
  </para>

  <para>
   Pour réussir la configuration du tunnel, vous devez être autorisé pour vous
   connecter via <command>ssh</command> sur <literal>joe@foo.com</literal>,
   comme si vous aviez tenté d'utiliser <command>ssh</command> pour créer
   une session de terminal.
  </para>

  <para>
   Vous pouvez aussi configurer la translation de port de cette façon&nbsp;:
<programlisting>
ssh -L 63333:foo.com:5432 joe@foo.com
</programlisting>
mais alors le serveur de la base de données verra la connexion venir de
son adresse liée <literal>foo.com</literal> qui n'est pas ouverte par son
paramétrage par défaut <literal>listen_addresses =
'localhost'</literal>. Ceci n'est pas habituellement ce que vous êtes.
</para>

<para>
Si vous devez vous connecter au serveur de bases de données via un hôte de
connexion, une configuration possible serait&nbsp;:
<programlisting>
ssh -L 63333:db.foo.com:5432 joe@shell.foo.com
</programlisting>
Notez que de cette façon la connexion de <literal>shell.foo.com</literal>
à <literal>db.foo.com</literal> ne sera pas chiffrée par le tunnel SSH.
SSH offre un certain nombre de possibilités de configuration quand le
réseau est restreint. Merci de vous référer à la documentation de SSH pour
les détails.
</para>

<tip>
<para>
Plusieurs autres applications existantes peuvent fournir des tunnels
sécurisés en utilisant une procédure similaire dans le concept à celle que
nous venons de décrire.
</para>
</tip>

</sect1>

<sect1 id="event-log-registration">
<title>Enregistrer le <application>journal des événements</application> sous <systemitem
class="osname">Windows</systemitem></title>

<indexterm zone="event-log-registration">
<primary>journal des événements</primary>
<secondary>journal des événements</secondary>
</indexterm>

<para>
Pour enregistrer une bibliothèque pour le <application>journal des
événements</application> de <systemitem class="osname">Windows</systemitem>,
lancez la commande&nbsp;:
<screen>
<userinput>regsvr32 <replaceable>répertoire_bibliothèques_postgres</replaceable>/pgevent.dll</userinput>
</screen>
Ceci crée les clés de registre utilisé par le visualisateur des événements,
sous la source d'événement par défaut, nommée <literal>PostgreSQL</literal>.
</para>

<para>
Pour indiquer un nom de source différent (voir
<xref linkend="guc-event-source"/>), utilisez les options <literal>/n</literal>
et <literal>/i</literal>&nbsp;:
<screen>
<userinput>regsvr32 /n /i:<replaceable>nom_source_evenement</replaceable> <replaceable>répertoire_bibliothèques_postgres</replaceable>/pgevent.dll</userinput>
</screen>
</para>

<para>
Pour désenregistrer la bibliothèque du <application>journal des
événements</application> de <systemitem class="osname">Windows</systemitem>,
lancez la commande&nbsp;:
<screen>
<userinput>regsvr32 /u [/i:<replaceable>nom_source_evenement</replaceable>] <replaceable>répertoire_bibliothèques_postgres</replaceable>/pgevent.dll</userinput>
</screen>
</para>

<note>
<para>
Pour activer la journalisation des événements dans le serveur de base de
données, modifiez <xref linkend="guc-log-destination"/> pour include
<literal>eventlog</literal> dans <filename>postgresql.conf</filename>.
</para>
</note>
</sect1>

</chapter>
