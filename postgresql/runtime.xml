<?xml version="1.0" encoding="UTF-8"?>
<chapter id="runtime">
 <title>Configuration du serveur et mise en place</title>

 <para>
  Ce chapitre discute de la configuration, du lancement du serveur de bases de
  données et de ses interactions avec le système d'exploitation.
 </para>

 <sect1 id="postgres-user">
  <title>Compte utilisateur <productname>PostgreSQL</productname></title>

  <indexterm>
   <primary>utilisateur postgres</primary>
  </indexterm>

  <para>
   Comme avec tout démon serveur accessible au monde externe, il est
   conseillé de lancer <productname>PostgreSQL</productname> sous un compte
   utilisateur séparé. Ce compte devrait seulement être le propriétaire des
   données gérées par le serveur et ne devrait pas être partagé avec d'autres
   démons (par exemple, utiliser l'utilisateur <literal>nobody</literal> est
   une mauvaise idée). Il n'est pas conseillé de changer le propriétaire des
   exécutables par cet utilisateur car les systèmes compromis pourraient alors
   se voir modifier leur propres binaires.
  </para>

  <para>
   Pour ajouter un compte utilisateur Unix, jetez un &oelig;il à la commande
   <command>useradd</command> ou <command>adduser</command> de votre système.
   Le nom de l'utilisateur <systemitem>postgres</systemitem> est souvent utilisé
   et l'est sur tout le livre, mais vous pouvez utiliser un autre nom si vous le
   souhaitez.
  </para>
 </sect1>

 <sect1 id="creating-cluster">
  <title>Créer un groupe de base de données</title>

  <indexterm>
   <primary>groupe de bases de données</primary>
  </indexterm>

  <indexterm>
   <primary>emplacement des données</primary>
   <see>groupe de bases de données</see>
  </indexterm>

  <para>
   Avant de faire quoi que ce soit, vous devez initialiser un emplacement de
   stockage pour la base de données. Nous appelons ceci un <firstterm>groupe de
    bases de données</firstterm> (le standard <acronym>SQL</acronym> utilise
   le terme de groupe de catalogues). Un groupe de bases de données est une
   collection de bases données et est géré par une seule instance d'un
   serveur de bases de données en cours d'exécution. Après initialisation, un
   groupe de bases de données contiendra une base de données nommée
   <literal>postgres</literal>, qui a pour but d'être la base de données par
   défaut utilisée par les outils, les utilisateurs et les applications
   tiers. Le serveur de la base de données lui-même ne requiert pas la présence
   de la base de données <literal>postgres</literal> mais beaucoup d'outils
   supposent son existence. Une autre base de données est créée à l'intérieur
   de chaque groupe lors de l'initialisation. Elle est appelée
   <literal>template1</literal>. Comme le nom le suggère, elle sera utilisée
   comme modèle pour les bases de données créées après&nbsp;; elle ne devrait
   pas être utilisée pour un vrai travail (voir le <xref
   linkend="managing-databases"/> pour des informations sur la création de
   nouvelles bases de données dans le groupe).
  </para>

  <para>
   En terme de système de fichiers, un groupe de bases de données est un
   simple répertoire sous lequel les données seront stockées. Nous l'appelons le
   <firstterm>répertoire de données</firstterm> ou l'<firstterm>emplacement des
    données</firstterm>. Le choix de cet emplacement vous appartient complètement.
   Il n'existe pas de valeur par défaut bien que les emplacements tels que
   <filename>/usr/local/pgsql/data</filename> ou
   <filename>/var/lib/pgsql/data</filename> sont populaires. Pour initialiser un
   groupe de bases de données, utilisez la commande <xref
   linkend="app-initdb"/>,<indexterm><primary>initdb</primary></indexterm> installée avec
   <productname>PostgreSQL</productname>. L'emplacement désiré sur le groupe de
   fichier est indiqué par l'option <option>-D</option>, par exemple
   <screen><prompt>$</prompt> <userinput>initdb -D /usr/local/pgsql/data</userinput></screen>
   Notez que vous devez exécuter cette commande en étant connecté sous le compte
   de l'utilisateur <productname>PostgreSQL</productname> décrit dans la section
   précédente.
  </para>

  <tip>
   <para>
    Comme alternative à l'option <option>-d</option>, vous pouvez initialiser
    la variable d'environnement <envar>pgdata</envar>.
    <indexterm><primary><envar>pgdata</envar></primary></indexterm>
   </para>
  </tip>

  <para>
   Autrement, vous pouvez exécuter <command>initdb</command> via le programme
   <xref linkend="app-pg-ctl"/><indexterm><primary>pg_ctl</primary></indexterm>
   ainsi&nbsp;:
<screen>
<prompt>$</prompt> <userinput>pg_ctl -D /usr/local/pgsql/data initdb</userinput>
   </screen>
   C'est peut-être plus intuitif si vous utilisez déjà
   <command>pg_ctl</command> pour démarrer et arrêter le serveur (voir <xref
   linkend="server-start"/> pour les détails). Un gros intérêt est de ne
   connaître que cette seule commande pour gérer l'instance du serveur de
   bases de données.
  </para>

  <para>
   <command>initdb</command> tentera de créer le répertoire que vous avez
   spécifié si celui-ci n'existe pas déjà. Bien sûr, cela peut échouer si
   <command>initdb</command> n'a pas les droits pour écrire dans le répertoire
   parent. Il est généralement recommandé que l'utilisateur
   <productname>PostgreSQL</productname> soit propriétaire du répertoire des
   données, mais aussi du répertoire parent pour que ce problème ne se
   présente pas. Si le répertoire parent souhaité n'existe pas plus, vous
   aurez besoin de le créer, en utilisant les droits de l'utilisateur root si
   nécessaire. Le processus pourrait ressembler à ceci&nbsp;:
   <screen>root# <userinput>mkdir /usr/local/pgsql</userinput>
root# <userinput>chown postgres /usr/local/pgsql</userinput></screen>
  </para>

  <para>
   <command>initdb</command> refusera de s'exécuter si le répertoire des données
   existe et contient déjà des fichiers. Cela permet de prévenir tout écrasement
   accidentel d'une installation existante.
  </para>

  <para>
   Comme le répertoire des données contient toutes les données stockées
   dans la base, il est essentiel qu'il soit protégé contre les
   accès non autorisés. En conséquence, <command>initdb</command>
   supprime les droits d'accès à tout le monde sauf à l'utilisateur
   <productname>PostgreSQL</productname>, et optionnellement au groupe.
   L'accès au groupe, s'il est autorisé, est en lecture seule.
   Cela permet à un utilisateur non privilégié, du même groupe que le
   propriétaire de l'instance, de faire une sauvegarde des fichiers ou d'effectuer
   des opérations qui ne requièrent qu'un accès en lecture.
  </para>

  <para>
   Notez qu'activer ou désactiver l'accès au groupe sur une instance
   préexistante exige qu'elle soit arrêtée et que les droits soient mis en place
   sur tous les répertoires et fichiers avant de redémarrer <productname>PostgreSQL</productname>.

   Sinon, un mélange des droits pourrait exister dans le répertoire de données.
   Pour les instances qui ne donnent accès qu'au propriétaire, les droits
   appropriés sont <literal>0700</literal> sur les répertoires et
   <literal>0600</literal> sur les fichiers. Pour les instances qui permettent
   aussi la lecture par le groupe, les droits appropriés sont
   <literal>0750</literal> sur les répertoires et <literal>0640</literal>
   sur les fichiers.
  </para>

  <para>
   Néanmoins, bien que le contenu du répertoire soit sécurisé, la configuration
   d'authentification du client par défaut permet à tout utilisateur local de se
   connecter à la base de données et même à devenir le super-utilisateur de
   la base de données. Si vous ne faites pas confiance aux utilisateurs
   locaux, nous vous recommandons d'utiliser une des options <option>-w</option> ou
   <option>--pwprompt</option> de la commande <command>initdb</command> pour
   affecter un mot de passe au super-utilisateur de la base de
   données <indexterm><primary>mot de passe</primary><secondary>du
   super-utilisateur</secondary></indexterm>. De plus, spécifiez <option>-a md5</option> ou
   <option>-a mot_de_passe</option> de façon à ce que la méthode d'authentification
   <literal>trust</literal> par défaut ne soit pas utilisée&nbsp;; ou modifiez le fichier
   <filename>pg_hba.conf</filename> généré après l'exécution
   d'<command>initdb</command> (d'autres
   approches raisonnables incluent l'utilisation de l'authentification
   <literal>peer</literal> ou les droits du système de fichiers pour
   restreindre les connexions. Voir le <xref
   linkend="client-authentication"/> pour plus d'informations).
  </para>

  <para>
   <command>initdb</command> initialise aussi la
   locale<indexterm><primary>locale</primary></indexterm> par défaut du groupe de bases de
   données. Normalement, elle prends seulement le paramétrage local dans
   l'environnement et l'applique à la base de données initialisée. Il est
   possible de spécifier une locale différente pour la base de données&nbsp;;
   la <xref linkend="locale"/> propose plus d'informations là-dessus.
   L'ordre de tri utilisé par défaut pour ce cluster de bases de données est
   initialisé par <command>initdb</command> et, bien que vous pouvez créer de
   nouvelles bases de données en utilisant des ordres de tris différents, l'ordre
   utilisé dans les bases de données modèle que initdb a créé ne peut pas être
   modifié sans les supprimer et les re-créer. Cela a aussi un impact sur les
   performances pour l'utilisation de locales autres que <literal>c</literal>
   ou <literal>posix</literal>. Du coup, il est important de faire ce choix
   correctement la première fois.
  </para>

  <para>
   <command>initdb</command> configure aussi le codage par défaut de l'ensemble
   de caractères pour le groupe de bases de données. Normalement, cela doit
   être choisi pour correspondre au paramétrage de la locale. Pour les détails,
   voir la <xref linkend="multibyte"/>.
  </para>

  <para>
   Les locales différentes de <literal>C</literal> et <literal>POSIX</literal>
   se basent sur la bibliothèque de collationnement du système pour le tri
   dépendant du jeu de caractères. Cela contrôle l'ordre des clés stockées
   dans les index. Pour cette raison, une instance ne peut pas basculer vers
   une version incompatible de la bibliothèque de collationnement, que ce soit
   pour une restauration d'une sauvegarde PITR mais aussi pour de la
   réplication binaire en flux ou pour un système d'exploitation différent, ou
   une mise à jour du système d'exploitation.
  </para>

  <sect2 id="creating-cluster-mount-points">
   <title>Utilisation de systèmes de fichiers secondaires</title>

   <indexterm zone="creating-cluster-mount-points">
    <primary>points de montage d'un système de fichiers</primary>
   </indexterm>

   <para>
    Beaucoup d'installations créent leur instance dans des systèmes de fichiers
    (volumes) autres que le volume racine de la machine. Si c'est votre choix,
    il est déconseillé d'utiliser le répertoire
    principal de ce volume secondaire (son point de montage) comme répertoire de
    données. Une meilleure pratique est de créer un répertoire au sein
    du point de montage, répertoire possédé par l'utilisateur
    <productname>PostgreSQL</productname>, puis de créer le
    répertoire de données à l'intérieur. Ceci évite des problèmes de droits,
    tout particulièrement lors d'opérations comme
    <application>pg_upgrade</application>, et garantit aussi des échecs
    propres si le volume secondaire n'est pas disponible.
   </para>

  </sect2>

  <sect2 id="creating-cluster-filesystem">
   <title>Systèmes de fichiers</title>

   <para>
    De manière générale, tout système de fichiers avec une sémantique POSIX
    est utilisable avec PostgreSQL. Les utilisateurs peuvent en choisir
    de différents pour diverses raisons, comme le support du fournisseur,
    la performance ou la familiarité. L'expérience montre que,
    toutes choses égales par ailleurs, on ne doit pas espérer de grosses
    différences de performances ou de comportement en changeant juste de système
    de fichiers ni en faisant de petites modifications de sa configuration.
   </para>

   <sect3 id="creating-cluster-nfs">
    <title>NFS</title>

    <indexterm zone="creating-cluster-nfs">
     <primary>NFS</primary>
    </indexterm>

    <para>
     Il est possible d'utiliser un système de fichier <acronym>NFS</acronym>
     pour le répertoire des données de <productname>PostgreSQL</productname>.
     <productname>PostgreSQL</productname> ne fait rien de spécial sur un
     un système de fichier <acronym>NFS</acronym>, c'est-à-dire qu'il
     suppose un comportement identique à celui de disques connectés locaux.
     <productname>PostgreSQL</productname> n'utilise aucune fonctionnalité
     connue pour un comportement non standard sur <acronym>NFS</acronym>,
     comme le verrouillage de fichier.
    </para>

    <para>
     Le seul pré-requis ferme pour l'utilisation de <acronym>NFS</acronym>
     avec <productname>PostgreSQL</productname> est que celui-ci soit
     monté avec l'option <literal>hard</literal>. Avec cette option,
     des processus peuvent rester <quote>pendants</quote> indéfiniment
     s'il y a des problèmes réseau&nbsp;;cette configuration nécessite donc
     une mise en place soigneuse.
     L'option <literal>soft</literal> interrompra les appels système
     en cas de problème réseau, mais <productname>PostgreSQL</productname>
     ne répétera pas ces appels interrompus&nbsp;; une telle interruption
     mènera donc à la levée d'une erreur d'entrée-sortie.
    </para>

    <para>
     Il n'est pas nécessaire d'utiliser l'option de montage <literal>sync</literal>.
     Le comportement de <literal>async</literal> est suffisant car
     <productname>PostgreSQL</productname> génère des appels <literal>fsync</literal>
     quand c'est approprié pour purger les caches en écriture.
     (C'est analogue au fonctionnement sur un système de fichiers local).
     Cepdendant, il est fortement conseillé d'utiliser l'option
     <literal>sync</literal> pour l'export depuis le
     <emphasis>serveur</emphasis> NFS sur les systèmes où elle existe
     (principalement Linux).
     Sinon, il n'y a pas de garantie qu'un <literal>fsync</literal>,
     ou son équivalent, sur le client NFS, atteigne le stockage permanent du
     serveur, ce qui causerait une corruption, comme si on tournait avec
      <xref linkend="guc-fsync"/> à off.
     Les valeurs par défaut des options de montage et d'export diffèrent selon
     les fournisseurs et les versions&nbsp;; il est donc recommandé de les
     vérifier, voire de les préciser explicitement pour lever toute
     ambiguïté.
    </para>

    <para>
     Dans certains cas, un stockage externe peut être utilisé soit par NFS,
     soit par un protocole de plus bas niveau comme iSCSI.
     Dans ce dernier cas, le stockage apparaît comme un périphérique par bloc
     et n'importe quel système de fichiers peut y être créé.
     Cette approche peut éviter au DBA de gérer les particularités du NFS,
     mais la complexité de la gestion du stockage distant est bien sûr
     repoussée à un autre niveau.
    </para>
   </sect3>
  </sect2>
 </sect1>

 <sect1 id="server-start">
  <title>Lancer le serveur de bases de données</title>

  <para>
   Avant qu'une personne ait accès à la base de données, vous devez démarrer le
serveur de bases de données. Le programme serveur est appelé
<command>postgres</command><indexterm><primary>postgres</primary></indexterm>. Le
programme <command>postgres</command> doit savoir où trouver les données qu'il est
supposé utiliser. Ceci se fait avec l'option <option>-d</option>. Du coup, la
façon la plus simple de lancer le serveur est&nbsp;:
<screen>$ <userinput>postgres -D /usr/local/pgsql/data</userinput></screen>
   qui laissera le serveur s'exécuter en avant plan. Pour cela, vous devez être
   connecté en utilisant le compte de l'utilisateur
   <productname>PostgreSQL</productname>. Sans l'option <option>-d</option>, le serveur
   essaiera d'utiliser le répertoire de données nommé par la variable
   d'environnement <envar>pgdata</envar>. Si cette variable ne le fournit pas
   non plus, le lancement échouera.
  </para>

  <para>
   Habituellement, il est préférable de lancer <command>postgres</command> en tâche
   de fond. Pour cela, utilisez la syntaxe shell Unix habituelle&nbsp;:
<screen>$ <userinput>postgres -D /usr/local/pgsql/data &gt;journaux_trace 2&gt;&amp;1 &amp;</userinput></screen>
   Il est important de sauvegarder les sorties <systemitem>stdout</systemitem> et
   <systemitem>stderr</systemitem> du serveur quelque part, comme montré ci-dessus. Cela
   vous aidera dans des buts d'audits ou pour diagnostiquer des problèmes (voir
   la <xref linkend="logfile-maintenance"/> pour une discussion plus détaillée
   de la gestion de journaux de trace).
  </para>

  <para>
   Le programme <command>postgres</command> prend aussi un certain nombre d'autres
   options en ligne de commande. Pour plus d'informations, voir la page de
   référence <xref linkend="app-postmaster"/> ainsi que le <xref
   linkend="runtime-config"/> ci-dessous.
  </para>

  <para>
   Cette syntaxe shell peut rapidement devenir ennuyante. Donc, le programme
   d'emballage <xref linkend="app-pg-ctl"/><indexterm><primary>pg_ctl</primary></indexterm>
   est fourni pour simplifier certaines tâches. Par exemple&nbsp;:
<programlisting>pg_ctl start -l journaux_trace</programlisting>
   lancera le serveur en tâche de fond et placera les sorties dans le journal
   de trace indiqué. L'option <option>-d</option> a la même signification ici
   que pour <command>postgres</command>. <command>pg_ctl</command> est aussi
   capable d'arrêter le serveur.
  </para>

  <para>
   Normalement, vous lancerez le serveur de bases de données lors du
   démarrage de l'ordinateur <indexterm><primary>démarrage</primary><secondary>au
   lancement du serveur</secondary></indexterm>. Les scripts de lancement automatique sont
   spécifiques au système d'exploitation. Certains sont distribués avec
   <productname>PostgreSQL</productname> dans le répertoire
   <filename>contrib/start-scripts</filename>. En installer un demandera les
   droits de root.
  </para>

  <para>
   Différents systèmes ont différentes conventions pour lancer les démons au
   démarrage. La plupart des systèmes ont un fichier
   <filename>/etc/rc.local</filename> ou
   <filename>/etc/rc.d/rc.local</filename>. D'autres utilisent les répertoires
   <filename>init.d</filename> ou <filename>rc.d</filename>. Quoi que
   vous fassiez, le serveur doit être exécuté par le
   compte utilisateur <productname>PostgreSQL</productname> <emphasis>et non pas
   par root</emphasis> ou tout autre utilisateur. Donc, vous devriez
   probablement former vos commandes en utilisant <literal>su postgres -c '...' </literal>.
   Par exemple&nbsp;:
<programlisting>su postgres -c 'pg_ctl start -D /usr/local/pgsql/data -l serverlog'</programlisting>
  </para>

  <para>
   Voici quelques suggestions supplémentaires par système d'exploitation
   (dans chaque cas, assurez-vous d'utiliser le bon répertoire d'installation et
   le bon nom de l'utilisateur où nous montrons des valeurs génériques).

   <itemizedlist>
    <listitem>
     <para>
      Pour <productname>freebsd</productname>, regardez le fichier
      <filename>contrib/start-scripts/freebsd</filename> du répertoire des
      sources de <productname>PostgreSQL</productname>.
      <indexterm><primary>freebsd</primary><secondary>script de
      lancement</secondary></indexterm>
     </para>
    </listitem>

    <listitem>
     <para>
      Sur <productname>openbsd</productname>, ajoutez les lignes suivantes à
      votre fichier <filename>/etc/rc.local</filename>&nbsp;:
      <indexterm><primary>openbsd</primary><secondary>script de
      lancement</secondary></indexterm>
<programlisting>if [ -x /usr/local/pgsql/bin/pg_ctl -a -x /usr/local/pgsql/bin/postgres ]; then
    su -l postgres -c '/usr/local/pgsql/bin/pg_ctl start -s -l /var/postgresql/log -D /usr/local/pgsql/data'
    echo -n ' PostgreSQL'
fi</programlisting>
     </para>
    </listitem>

    <listitem>
     <para>
      Sur les systèmes <productname>linux</productname>, soit vous ajoutez
      <indexterm><primary>linux</primary><secondary>script de lancement</secondary></indexterm>
<programlisting>/usr/local/pgsql/bin/pg_ctl start -l journaux_trace -D /usr/local/pgsql/data</programlisting>
      à <filename>/etc/rc.d/rc.local</filename> ou
      <filename>/etc/rc.local</filename> soit vous jetez un &oelig;il à
      <filename>contrib/start-scripts/linux</filename> dans le répertoire des
      sources de <productname>PostgreSQL</productname>.
     </para>

     <para>
      Si vous utilisez <application>systemd</application>, vous pouvez utiliser
      le fichier de service (par exemple dans
      <filename>/etc/systemd/system/postgresql.service</filename>)&nbsp;:
      <indexterm><primary>systemd</primary></indexterm>
<programlisting>
[Unit]
Description=PostgreSQL database server
Documentation=man:postgres(1)

[Service]
Type=notify
User=postgres
ExecStart=/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data
ExecReload=/bin/kill -HUP $MAINPID
KillMode=mixed
KillSignal=SIGINT
TimeoutSec=0

[Install]
WantedBy=multi-user.target
</programlisting>
      Utiliser <literal>Type=notify</literal> nécessite que le binaire du
      serveur soit construit avec <literal>configure --with-systemd</literal>.
     </para>

     <para>
      Faites bien attention au paramètre de délai.
      <application>systemd</application> a un délai par défaut de 90 secondes
      (au moment de l'écriture de cette documentation) et tuera un processus
      qui n'indique pas sa disponibilité après ce délai. Cependant, un serveur
      <productname>PostgreSQL</productname> qui aurait à réaliser une
      restauration suite à un crash pourrait prendre beaucoup plus de temps à
      démarrer. La valeur suggérée, 0, désactive ce comportement.
     </para>
    </listitem>

    <listitem>
     <para>
      Sur <productname>netbsd</productname>, vous pouvez utiliser les scripts
      de lancement de <productname>freebsd</productname> ou de
      <productname>linux</productname> suivant vos préférences.
      <indexterm><primary>netbsd</primary><secondary>script de lancement</secondary></indexterm>
     </para>
    </listitem>

    <listitem>
     <para>
      Sur <productname>solaris</productname>, créez un fichier appelé
      <filename>/etc/init.d/PostgreSQL</filename> et contenant la ligne
      suivante&nbsp;:
      <indexterm><primary>solaris</primary><secondary>script de
      lancement</secondary></indexterm>
<programlisting>su - postgres -c "/usr/local/pgsql/bin/pg_ctl start -l journaux_trace -D /usr/local/pgsql/data"</programlisting>
      Puis, créez un lien symbolique vers lui dans <filename>/etc/rc3.d</filename> de
      nom <filename>s99PostgreSQL</filename>.
     </para>
    </listitem>
   </itemizedlist>

  </para>

   <para>
    Tant que le serveur est lancé, son
    <acronym>pid</acronym> est stocké dans le fichier
    <filename>postmaster.pid</filename> du répertoire de données. C'est utilisé
    pour empêcher plusieurs instances du serveur d'être exécutées dans le même
    répertoire de données et peut aussi être utilisé pour arrêter le processus
    le serveur.
   </para>

   <sect2 id="server-start-failures">
    <title>Échecs de lancement</title>

    <para>
     Il existe de nombreuses raisons habituelles pour lesquelles le serveur
     échouerait au lancement. Vérifiez le journal des traces du serveur ou
     lancez-le manuellement (sans redirection des sorties standard et d'erreur)
     et regardez les messages d'erreurs qui apparaissent. Nous en expliquons
     certains ci-dessous parmi les messages d'erreurs les plus communs.
    </para>

    <para>
<screen>LOG:  could not bind IPv4 address "127.0.0.1": Address already in use
HINT:  Is another postmaster already running on port 5432? If not, wait a few seconds and retry.
FATAL:  could not create any TCP/IP sockets</screen>
     Ceci signifie seulement ce que cela suggère&nbsp;: vous avez essayé de lancer
     un autre serveur sur le même port où un autre est en
     cours d'exécution. Néanmoins, si le message d'erreur du noyau
     n'est pas <computeroutput>address already in use</computeroutput> ou une
     quelconque variante, il pourrait y avoir un autre problème. Par
     exemple, essayer de lancer un serveur sur un numéro
     de port réservé pourrait avoir ce résultat&nbsp;:
<screen>$ <userinput>postgres -p 666</userinput>
LOG:  could not bind IPv4 address "127.0.0.1": Permission denied
HINT:  Is another postmaster already running on port 666? If not, wait a few seconds and retry.
FATAL:  could not create any TCP/IP sockets</screen>
    </para>

    <para>
     Un message du type
<screen>FATAL:  could not create shared memory segment: Invalid argument
DETAIL:  Failed system call was shmget(key=5440001, size=4011376640, 03600).</screen>
     signifie probablement que les limites de votre noyau sur la taille de
     la mémoire partagée est plus petite que l'aire de fonctionnement que
     <productname>PostgreSQL</productname> essaie de créer (4011376640 octets
     dans cet exemple). Ceci n'est susceptible de se produire uniquement si
     <literal>shared_memory_type</literal> a été affecté à <literal>sysv</literal>. Dans ce
     cas, vous pouvez essayer de lancer le serveur avec un nombre de tampons
     plus petit que la normale
     (<xref linkend="guc-shared-buffers"/>) ou vous pouvez
     reconfigurer votre noyau pour accroître la taille de mémoire partagée
     autorisée. Vous pourriez voir aussi ce message en essayant d'exécuter
     plusieurs serveurs sur la même machine si le total de l'espace qu'ils
     requièrent dépasse la limite du noyau.
    </para>

    <para>
     Une erreur du type
<screen>FATAL:  could not create semaphores: No space left on device
DETAIL:  Failed system call was semget(5440126, 17, 03600).</screen>
     ne signifie <emphasis>pas</emphasis> qu'il vous manque de l'espace disque.
     Elle signifie que la limite de votre noyau sur le nombre de sémaphores
     <systemitem class="osname">system v</systemitem> est inférieure au nombre que
     <productname>PostgreSQL</productname> veut créer. Comme ci-dessus, vous
     pouvez contourner le problème en lançant le serveur avec un nombre
     réduit de connexions autorisées (<xref linkend="guc-max-connections"/>)
     mais vous voudrez éventuellement augmenter la limite du noyau.
    </para>

    <para>
     Des détails sur la configuration des capacités <acronym>IPC</acronym> <systemitem
     class="osname">System V</systemitem> sont donnés dans la <xref linkend="sysvipc"/>.
    </para>
   </sect2>

   <sect2 id="client-connection-problems">
    <title>Problèmes de connexion du client</title>

    <para>
     Bien que les conditions d'erreurs possibles du côté client sont assez
     variées et dépendantes de l'application, certaines pourraient être en
     relation direct avec la façon dont le serveur a été lancé. Les conditions
     autres que celles montrées ici devraient être documentées avec
     l'application client respective.
    </para>

    <para>
<screen>psql: could not connect to server: Connection refused
        Is the server running on host "server.joe.com" and accepting
        TCP/IP connections on port 5432?</screen>
     Ceci est l'échec générique <quote>je n'ai pas trouvé de serveur à qui
     parler</quote>. Cela ressemble au message ci-dessus lorsqu'une connexion
     TCP/IP est tentée. Une erreur commune est d'oublier de configurer le
     serveur pour qu'il autorise les connexions TCP/IP.
    </para>

    <para>
     Autrement, vous obtiendrez ceci en essayant une communication de type
     socket de domaine Unix vers un serveur local&nbsp;:
<screen>psql: could not connect to server: No such file or directory
        Is the server running locally and accepting
        connections on Unix domain socket "/tmp/.s.PGSQL.5432"?</screen>
    </para>

    <para>
     La dernière ligne est utile pour vérifier si le client essaie de se
     connecter au bon endroit. Si aucun serveur n'est exécuté ici, le
     message d'erreur du noyau sera typiquement soit <computeroutput>connection
     refused</computeroutput> soit <computeroutput>no such file or
     directory</computeroutput>, comme ce qui est illustré (il est important de
     réaliser que <computeroutput>connection refused</computeroutput>, dans ce
     contexte, ne signifie <emphasis>pas</emphasis> que le serveur a obtenu une
     demande de connexion et l'a refusé. Ce cas produira un message différent
     comme indiqué dans la <xref linkend="client-authentication-problems"/>).
     D'autres messages d'erreurs tel que <computeroutput>connection timed
     out</computeroutput> pourraient indiquer des problèmes plus fondamentaux
     comme un manque de connexion réseau.
    </para>
   </sect2>
  </sect1>

 <sect1 id="kernel-resources">
  <title>Gérer les ressources du noyau</title>

  <para>
   <productname>PostgreSQL</productname> peut quelque fois dépasser les limites
   des ressources du système d'exploiration, tout spécialement quand plusieurs
   copies du serveur s'exécutent sur le même système, ou sur des très grosses
   installations. Cette section explique les ressources du noyau utilisées par
   <productname>PostgreSQL</productname> et les étapes à suivre pour résoudre
   les problèmes liés à la consommation des ressources du noyau.
  </para>

  <sect2 id="sysvipc">
   <title>Mémoire partagée et sémaphore</title>

   <indexterm zone="sysvipc">
    <primary>mémoire partagée</primary>
   </indexterm>

   <indexterm zone="sysvipc">
    <primary>sémaphores</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> a besoin que le système d'exploitation
    fournisse des fonctionnalités de communication inter-processus
    (<acronym>IPC</acronym>), en particulier de la mémoire partagée et des
    sémaphores. Les systèmes dérivés d'Unix fournissent
    <quote><systemitem class="osname">System V</systemitem></quote> <acronym>IPC</acronym>,
    <quote><systemitem class="osname">POSIX</systemitem></quote> <acronym>IPC</acronym>
    ou les deux. <systemitem class="osname">Windows</systemitem> qui fournit sa propre
    implémentation de ces fonctionnalités ne sera pas approfondi ici.
   </para>

   <para>
    Par défaut, <productname>PostgreSQL</productname> alloue
    une très petite quantité de mémoire partagée System&nbsp;V, ainsi
    qu'une quantité bien plus importante de mémoire partagée anonyme
    <function>mmap</function>.
    Autre possibilité&nbsp;: utiliser un seul gros bloc de mémoire partagée
    System&nbsp;V (voir <xref linkend="guc-shared-memory-type"/>).

    De plus, un nombre important de sémaphores de style System&nbsp;V ou POSIX sont
    créés au démarrage du serveur. Actuellement, les sémaphores POSIX sont
    utilisés sur les systèmes Linux et FreeBSD, alors que les autres plateformes
    utilisent les sémaphores System&nbsp;V.
   </para>

   <para>
    Les fonctionnalités System&nbsp;V <acronym>IPC</acronym> sont habituellement
    restreintes par les limites d'allocation au niveau système.
    Quand <productname>PostgreSQL</productname> dépasse une des nombreuses limites
    <acronym>IPC</acronym>, le serveur refusera de s'exécuter et lèvera un
    message d'erreur instructif décrivant le problème rencontré et que faire
    avec (voir aussi la <xref linkend="server-start-failures"/>). Les
    paramètres adéquats du noyau sont nommés de façon cohérente parmi les
    différents systèmes&nbsp;; le <xref linkend="sysvipc-parameters"/> donne un
    aperçu. Néanmoins, les méthodes pour les obtenir varient. Les suggestions
    pour quelques plateformes sont données ci-dessous.
   </para>

   <table id="sysvipc-parameters">
    <title>Paramètres <systemitem class="osname">System V</systemitem> <acronym>IPC</acronym></title>

    <tgroup cols="3">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="3*"/>
     <colspec colname="col3" colwidth="3*"/>
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Description</entry>
       <entry>Valeurs nécessaires pour faire fonctionner une instance <productname>PostgreSQL</productname> </entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><varname>SHMMAX</varname></entry>
       <entry>Taille maximum du segment de mémoire partagée (en octets)</entry>
       <entry>au moins 1&nbsp;ko, mais la valeur par défaut est normalement bien plus grande</entry>
      </row>

      <row>
       <entry><varname>SHMMIN</varname></entry>
       <entry>Taille minimum du segment de mémoire partagée (en octets)</entry>
       <entry>1</entry>
      </row>

      <row>
       <entry><varname>SHMALL</varname></entry>
       <entry>Total de la mémoire partagée disponible (en octets ou pages)</entry>
       <entry>si octets, identique à <varname>SHMMAX</varname>&nbsp;;
        si pages, <literal>ceil(SHMMAX/PAGE_SIZE)</literal>,
        plus de la marge pour les autres applications</entry>
      </row>

      <row>
       <entry><varname>SHMSEG</varname></entry>
       <entry>Nombre maximum de segments de mémoire partagée par processus</entry>
       <entry>seul un segment est nécessaire, mais la valeur par défaut est
        bien plus importante</entry>
      </row>

       <row>
        <entry><varname>SHMMNI</varname></entry>
        <entry>Nombre maximum de segments de mémoire partagée pour
         tout le système</entry>
        <entry>comme <varname>SHMSEG</varname> plus de la place pour les autres
         applications</entry>
       </row>

       <row>
        <entry><varname>SEMMNI</varname></entry>
        <entry>Nombre maximum d'identifiants de sémaphores (c'est-à-dire
         d'ensembles)</entry>
        <entry>au moins <literal>ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)</literal> plus de la marge pour les autres applications</entry>
       </row>

       <row>
        <entry><varname>SEMMNS</varname></entry>
        <entry>nombre maximum de sémaphores répartis dans le système</entry>
        <entry><literal>ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16) * 17</literal> plus la place
         pour les autres applications</entry>
       </row>

       <row>
        <entry><varname>SEMMSL</varname></entry>
        <entry>Nombre maximum de sémaphores par ensemble</entry>
        <entry>au moins 17</entry>
       </row>

       <row>
        <entry><varname>SEMMAP</varname></entry>
        <entry>Nombre d'entrées dans la carte des sémaphores</entry>
        <entry>voir le texte</entry>
       </row>

       <row>
        <entry><varname>SEMVMX</varname></entry>
        <entry>Valeur maximum d'un sémaphore</entry>
        <entry>au moins 1000 (vaut souvent par défaut 32767&nbsp;; ne pas changer
         sauf si vous êtes forcé.)</entry>
       </row>

     </tbody>
    </tgroup>
   </table>


   <para>
    <productname>PostgreSQL</productname> requiert quelques octets de mémoire
    partagée System&nbsp;V (typiquement 48 octets sur des plateformes 64 bits) pour
    chaque copie du serveur. Sur la plupart des systèmes d'exploitation modernes,
    cette quantité est facilement allouable. Néanmoins, si vous exécutez
    plusieurs copies du serveur
    ou si vous le configurez explicitement pour utiliser de grandes quantités
    de mémoire partagée System&nbsp;V (voir <xref linkend="guc-shared-memory-type"/>
    et <xref linkend="guc-dynamic-shared-memory-type"/>),
    il pourrait être nécessaire d'augmenter
    <varname>SHMALL</varname>, correspondant à la quantité
    totale de mémoire partagée System&nbsp;V pour tout le système. Notez que
    <varname>SHMALL</varname> est en nombre de blocs disques, et non pas en
    nombre d'octets sur de nombreux systèmes.
   </para>

   <para>
    La taille minimum des segments de mémoire partagée (<varname>SHMMIN</varname>) est
    moins sensible aux problèmes. Elle devrait être au plus à environ
    32 octets pour <productname>PostgreSQL</productname> (il est habituellement à 1). Le
    nombre maximum de segments au travers du système (<varname>SHMMNI</varname>) ou par
    processus (<varname>SHMSEG</varname>) a peu de chances de causer un problème sauf
    s'ils sont configurés à zéro sur votre système.
   </para>

   <para>
    Lors de l'utilisation de sémaphores System&nbsp;V,
    <productname>PostgreSQL</productname> utilise un sémaphore par connexion
    autorisée (<xref linkend="guc-max-connections"/>), par processus
    autovacuum autorisé (<xref linkend="guc-autovacuum-max-workers"/>) et par
    processus en tâche de fond autorisé réclamant un accès à la mémoire
    partagée, le tout par ensemble de 16. Chacun de ces ensembles contiendra
    aussi un 17è sémaphore qui contient un <quote>nombre magique</quote> pour
    détecter la collision avec des ensembles de sémaphore utilisés par les
    autres applications. Le nombre maximum de sémaphores dans le système est
    initialisé par <varname>SEMMNS</varname>, qui en conséquence doit être au
    moins aussi haut que <varname>max_connections</varname> plus
    <varname>autovacuum_max_workers</varname> plus
    <varname>max_wal_senders</varname> plus
    <varname>max_worker_processes</varname>,
    plus 1 encore pour chacune des 16 connexions autorisées,
    plus les workers (voir la formule dans le <xref
    linkend="sysvipc-parameters"/>). Le paramètre <varname>SEMMNI</varname>
    détermine la limite du nombre d'ensembles de sémaphores qui peuvent
    exister sur le système à un instant précis. Ce paramètre doit donc être
    au moins égal à
    <literal>ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)</literal>.
    Baisser le
    nombre de connexions autorisées est un contournement temporaire pour les
    échecs qui sont habituellement indiqués par le message <quote>no space
    left on device</quote>, à partir de la fonction
    <function>semget</function>.
   </para>

   <para>
    Dans certains cas, il pourrait être nécessaire d'augmenter
    <varname>SEMMAP</varname> pour être au moins dans l'ordre de
    <varname>SEMMNS</varname>. Si le système dispose de ce paramètre (ce n'est
    pas le cas pour beaucoup d'entre eux), il définit la taille de
    la carte de ressources de sémaphores, dans laquelle chaque bloc contigu de
    sémaphores disponibles a besoin d'une entrée. Lorsqu'un ensemble de
    sémaphores est libéré, soit il est ajouté à une entrée existante,
    soit il est enregistré sous une nouvelle entrée dans la carte.
    Si la carte est pleine, les sémaphores libérés sont perdus
    (jusqu'au redémarrage). La fragmentation de l'espace des sémaphores
    peut mener au fil du temps à rendre moins de sémaphores disponibles qu'il
    ne devrait y avoir.
   </para>

   <para>
    D'autres paramètres en relation avec l'<quote>annulation de sémaphores</quote>,
    tels que <varname>SEMMNU</varname> et <varname>SEMUME</varname>, n'affectent pas
    <productname>PostgreSQL</productname>.
   </para>

   <para>
    Lors de l'utilisation de sémaphores POSIX, le nombre de sémaphores
    nécessaires est le même que pour System&nbsp;V, c'est-à-dire un sémaphore par
    connexion autorisée (<xref linkend="guc-max-connections"/>), par
    processus autovacuum autorisé (<xref linkend="guc-autovacuum-max-workers"/>)
    et par processus en t&acirc;che de fond (<xref linkend="guc-max-worker-processes"/>).
    Sur les plateformes o&ugrave; cette option est préférée, le noyau ne
    spécifie pas de limite au nombre de sémaphores POSIX.
   </para>

    <variablelist>

     <varlistentry>
      <term><systemitem class="osname">AIX</systemitem></term>
      <listitem>
      <indexterm><primary>AIX</primary><secondary>configuration IPC</secondary></indexterm>
       <para>
        Il ne doit plus être nécessaire de faire
        une configuration spéciale pour les paramètres tels que
        <varname>SHMMAX</varname>, car c'est configuré de façon à ce que toute
        la mémoire puisse être utilisée en tant que mémoire partagée.
        C'est le type de configuration habituellement utilisée pour d'autres
        bases de données comme <application>DB/2</application>.
       </para>

       <para>
        Néanmoins, il pourrait être nécessaire de modifier l'information
       globale <command>ulimit</command> dans
       <filename>/etc/security/limits</filename> car les limites en dur par
       défaut pour les tailles de fichiers (<varname>fsize</varname>) et
       les nombres de fichiers (<varname>nofiles</varname>) pourraient être
       trop bas.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">FreeBSD</systemitem></term>
      <listitem>
      <indexterm><primary>FreeBSD</primary><secondary>configuration IPC</secondary></indexterm>
       <para>
        Les paramètres par défaut de mémoire partagée sont en général
        suffisant, sauf si vous affectez <literal>shared_memory_type</literal>
        à <literal>sysv</literal>. Les sémaphores System V ne sont pas
        utilisés sur cette plateforme.
       </para>

       <para>
        Les paramètres IPC par défaut peuvent être modifiés en utilisant la
        commande <command>sysctl</command> ou <command>loader</command>. Les
        paramètres suivants peuvent être configurés en utilisant
        <command>sysctl</command>&nbsp;:
<screen><prompt>#</prompt> <userinput>sysctl kern.ipc.shmall=32768</userinput>
<prompt>#</prompt> <userinput>sysctl kern.ipc.shmmax=134217728</userinput>
   </screen>
        Pour que ces paramètres persistent après les redémarrages, modifiez
        <filename>/etc/sysctl.conf</filename>.
  </para>

  <para>
   Si vous avez affecté <literal>shared_memory_type</literal> à
   <literal>sysv</literal>, vous pourriez aussi vouloir configurer votre noyau
   pour verrouiller la mémoire partagée System V en RAM et l'empêcher d'être
   envoyé dans le swap. Ceci peut être accompli en utilisant le paramètre
   <literal>kern.ipc.shm_use_phys</literal> de <command>sysctl</command>.
  </para>

  <para>
   Dans une prison FreeBSD, il vous est recommandé de configurer le paramètre
   <literal>sysvshm</literal> à <literal>new</literal>, ainsi il a son propre
   espace de nommage de mémoire partagée System V. (Avant FreeBSD 11.0, il
   était nécessaire d'activer l'accès partagé à l'espace de nommage IPC de
   l'hôte depuis les prisons, et prendre les mesures pour éviter les
   collisions.)
  </para>
 </listitem>
</varlistentry>

<varlistentry>
 <term><systemitem class="osname">NetBSD</systemitem></term>
 <indexterm><primary>NetBSD</primary><secondary>configuration IPC</secondary></indexterm>
 <listitem>
  <para>
   La configuration par défaut de la mémoire partagé est en général
   suffisante, sauf si vous avez affecté <literal>shared_memory_type</literal>
   à <literal>sysv</literal>. Dans ce cas, vous voudrez habituellement
   augmenter <literal>kern.ipc.semmni</literal> et
   <literal>kern.ipc.semmns</literal> car les valeurs par défaut de ces
   paramètres sur <systemitem class="osname">NetBSD</systemitem> sont bien
   trop bas.
  </para>

  <para>
   Les paramètres IPC peuvent être ajustés en utilisant
   <command>sysctl</command>. Par exemple&nbsp;:
   <screen>
<prompt>#</prompt> <userinput>sysctl -w kern.ipc.semmni=100</userinput>
   </screen>
   Pour que ce paramètrage persiste après un redémarrage, modifiez
   le fichier <filename>/etc/sysctl.conf</filename>.
  </para>

  <para>
   Si vous avez configuré <literal>shared_memory_type</literal> à
   <literal>sysv</literal>, vous pourriez aussi vouloir configurer votre noyau
   pour verrouiller la mémoire partagée System V en RAM et prévenir la mémoire
   d'être envoyée sur swap. Ceci peut être accompli en utilisant le paramètre
   <literal>kern.ipc.shm_use_phys</literal>de la commande
   <command>sysctl</command>.
  </para>
 </listitem>
</varlistentry>

<varlistentry>
 <term><systemitem class="osname">OpenBSD</systemitem></term>
 <listitem>
  <indexterm><primary>OpenBSD</primary><secondary>configuration IPC</secondary></indexterm>
  <para>
   La configuration par défaut de la mémoire partagée est en général
   suffisante, sauf si vous avez configuré
   <literal>shared_memory_type</literal> à <literal>sysv</literal>. Vous
   voudrez habituellement augmenter <literal>kern.seminfo.semmni</literal> et
   <literal>kern.seminfo.semmns</literal> car les valeurs par défaut de ces
   paramètres sur <systemitem class="osname">OpenBSD</systemitem> sont bien
   trop bas.
  </para>

  <para>
   Les paramètres IPC peuvent être ajustés en utilisant
   <command>sysctl</command>, par exemple&nbsp;:
<screen>
<prompt>#</prompt> <userinput>sysctl kern.seminfo.semmni=100</userinput>
</screen>
   Pour rendre ce paramétrage persistant entre les redémarrages, modifiez
   <filename>/etc/sysctl.conf</filename>.
  </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">HP-UX</systemitem></term>
      <listitem>
      <indexterm><primary>HP-UX</primary><secondary>configuration IPC</secondary></indexterm>
       <para>
        Les paramètres par défaut tendent à suffire pour des installations
        normales.
       </para>
       <para>
        Les paramètres <acronym>IPC</acronym> peuvent être initialisés dans
        <application>System Administration Manager</application> (<acronym>SAM</acronym>) sous
        <menuchoice><guimenu>Kernel Configuration</guimenu><guimenuitem>Configurable
        Parameters</guimenuitem></menuchoice>.
        Choisissez <guibutton>Create A New Kernel</guibutton> une fois terminé.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">Linux</systemitem></term>
      <listitem>
      <indexterm><primary>Linux</primary><secondary>configuration IPC</secondary></indexterm>
       <para>
        La configuration par défaut de la mémoire partagée est en général
        suffisante, sauf si vous avez configuré
        <literal>shared_memory_type</literal> à <literal>sysv</literal>, et
        uniquement sur les anciennes versions de noyau fournies avec des
        valeurs par défaut trop basses. Les sémaphores de System V ne sont pas
        utilisés sur cette plateforme.
       </para>

       <para>
        La configuration de la taille de mémoire partagée peut être modifiée
        avec l'interface proposée par la commande <command>sysctl</command>.
        Par exemple, pour permettre l'utilisation de 16&nbsp;Go&nbsp;:
<screen>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmmax=17179869184</userinput>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmall=4194304</userinput>
   </screen>
        Pour rendre ce paramètrage persistant entre les redémarrages, voir
        <filename>/etc/sysctl.conf</filename>.
  </para>
 </listitem>
</varlistentry>


<varlistentry>
 <term><systemitem class="osname">macOS</systemitem></term>
 <listitem>
  <indexterm><primary>macOS</primary><secondary>configuration IPC</secondary></indexterm>
  <para>
   La configuration par défaut de la mémoire partagée et des sémaphores est en
   général suffisante, sauf si vous avez configuré
   <literal>shared_memory_type</literal> à <literal>sysv</literal>.
  </para>
  <para>
   La méthode recommandée pour configurer la mémoire partagée sous macOS
   est de créer un fichier nommé <filename>/etc/sysctl.conf</filename>
   contenant des affectations de variables comme&nbsp;:
   <programlisting>kern.sysv.shmmax=4194304
kern.sysv.shmmin=1
kern.sysv.shmmni=32
kern.sysv.shmseg=8
kern.sysv.shmall=1024
   </programlisting>
   Notez que, dans certaines versions de macOS, <emphasis>les
    cinq</emphasis> paramètres de mémoire partagée doivent être configurés
   dans <filename>/etc/sysctl.conf</filename>, sinon les valeurs seront
   ignorées.
  </para>

  <para>
   <varname>SHMMAX</varname> peut seulement être configuré avec un multiple
   exact de 4096.
  </para>

  <para>
   <varname>SHMALL</varname> est mesuré en page de 4&nbsp;ko sur cette
   plateforme.
  </para>

  <para>
   Il est possible de tous les modifier en ligne sauf
   <varname>SHMMNI</varname>, grâce à <application>sysctl</application>. Mais
   il est toujours préférable de configurer vos valeurs préférées dans
   <filename>/etc/sysctl.conf</filename>, pour que les nouvelles valeurs
   soient conservées après un redémarrage.
  </para>
</listitem>
</varlistentry>

     <varlistentry>
      <term><systemitem class="osname">Solaris</systemitem></term>
      <term><systemitem class="osname">illumos</systemitem></term>
      <listitem>
       <para>
        La configuration de la mémoire partagée et des sémaphores par défaut
        sont habituellement suffisamment bonnes pour la majorité des
        configurations de <productname>PostgreSQL</productname>. La valeur par
        défaut de Solaris pour <varname>SHMMAX</varname> correspond maintenant
        à un quart de la mémoire disponible sur le système. Pour configurer
        plus finement ce paramètre, vous devez utiliser une configuration de
        projet associé à l'utilisateur <literal>postgres</literal>. Par
        exemple, exécutez ce qui suit en tant qu'utilisateur
        <literal>root</literal>&nbsp;:
<programlisting>
projadd -c "PostgreSQL DB User" -K "project.max-shm-memory=(privileged,8GB,deny)" -U postgres -G postgres user.postgres
   </programlisting>
  </para>

  <para>
   Cette commande ajoute le projet  <literal>user.postgres</literal>
   et configure le maximum de mémoire partagée pour l'utilisateur
   <literal>postgres</literal> à 8&nbsp;Go. Cela prend effet à chaque
   fois que l'utilisateur se connecte et quand vous redémarrez
   <productname>PostgreSQL</productname>. La ligne ci-dessus
   suppose que <productname>PostgreSQL</productname> est exécuté
   par l'utilisateur <literal>postgres</literal> dans le groupe
   <literal>postgres</literal>. Aucun redémarrage du serveur n'est
   requis.
  </para>

  <para>
   Sur un serveur de bases de données ayant beaucoup de connexions,
   les autres modifications recommandés pour le noyau sont&nbsp;:
   <programlisting>
project.max-shm-ids=(priv,32768,deny)
project.max-sem-ids=(priv,4096,deny)
project.max-msg-ids=(priv,4096,deny)
   </programlisting>

  </para>

  <para>
   De plus, si vous exécutez <productname>PostgreSQL</productname>
   dans une zone, vous pourriez avoir besoin d'augmenter les limites
   d'utilisation des ressources pour la zone. Voir
   <foreignphrase>Chapter2:  Projects and Tasks</foreignphrase> dans
   <citetitle>System Administrator's Guide</citetitle>
   pour plus d'informations sur les <literal>projets</literal> et
   <command>prctl</command>.
  </para>
 </listitem>
</varlistentry>


    </variablelist>

  </sect2>

  <sect2 id="systemd-removeipc">
   <title>systemd RemoveIPC</title>

   <indexterm>
    <primary>systemd</primary>
    <secondary>RemoveIPC</secondary>
   </indexterm>

   <para>
    Si <productname>systemd</productname> est utilisé, certaines précautions
    sont de mise pour que les ressources IPC (incluant la mémoire partagée)
    ne soient pas supprimées par le système d'exploitation. Cela est
    particulièrement important lors de l'installation de PostgreSQL via les
    sources. Les utiisateurs de versions packagées par la distribution ont moins
    de chance d'être affectés, l'utilisateur <literal>postgres</literal> étant
    habituellement créé en tant qu'utilisateur système.
   </para>

   <para>
    Le paramètre <literal>RemoveIPC</literal> dans <filename>logind.conf</filename>
    contr&ocirc;le si les objets IPC sont supprimés lors de déconnexion
    complète d'un utilisateur. Les utilisateurs système sont exclus.
    Ce paramètre est par défaut actif sur la version originale de
    <productname>systemd</productname>, mais certaines distributions
    positionnent ce paramètre à off.
   </para>

   <para>
    Un effet typique observé quand ce paramètre est activé est que les objets
    en mémoire partagée utilisés pour l'exécution des requêtes en parallèle
    sont supprimés à des moments en apparence aléatoires, amenant ainsi des
    erreurs et messages d'avertissement lors des tentatives de les ouvrir ou
    supprimer, comme&nbsp;:
<screen>
WARNING:  could not remove shared memory segment "/PostgreSQL.1450751626": No such file or directory
</screen>
    Différents types d'objets IPC (mémoire partagée et sémaphores, System&nbsp;V et
    POSIX) sont traités de manière légèrement différente par
    <productname>systemd</productname>, et l'on peut observer que certaines
    ressources IPC ne sont pas supprimées de la m&ecirc;me manière que les
    autres. Il n'est toutefois pas conseillé de compter sur ces subtiles
    différences.
   </para>

   <para>
    Une <quote>déconnexion utilisateur</quote> peut survenir lors d'une
    opération de maintenance ou manuellement lorsqu'un administrateur se
    connecte avec le compte <literal>postgres</literal> ou un compte similaire,
    ce qui est difficile à éviter en général.
   </para>

   <para>
    Ce qu'est un <quote>utilisateur système</quote> est déterminé à la
    compilation de <productname>systemd</productname> par le paramètre
    <symbol>SYS_UID_MAX</symbol> dans <filename>/etc/login.defs</filename>.
   </para>

   <para>
    Les scripts de packaging et déploiement devront faire attention à créer
    l'utilisateur <literal>postgres</literal> en tant qu'utilisateur système
    avec <literal>useradd -r</literal>, <literal>adduser --system</literal>,
    ou une commande équivalente.
   </para>

   <para>
    Sinon, si le compte utilisateur a été créé de manière incorrecte ou ne peut
    être modifié, il est recommandé de configurer
 <programlisting>
RemoveIPC=no
 </programlisting>
 dans <filename>/etc/systemd/logind.conf</filename> ou un autre fichier de
 configuration approprié.
   </para>

   <caution>
    <para>
     Au moins une de ces deux choses doit être garantie, sinon le serveur
     PostgreSQL ne pourra être considéré comme fiable.
    </para>
   </caution>
  </sect2>

  <sect2>
   <title>Limites de ressources</title>

   <para>
    Les systèmes d'exploitation style Unix renforcent différents types de
    limites de ressources qui pourraient interférer avec les opérations de votre
    serveur <productname>PostgreSQL</productname>. Les limites sur le nombre de
    processus par utilisateur, le nombre de fichiers ouverts par un processus et la
    taille mémoire disponible pour chaque processus sont d'une grande
    importance. Chacun d'entre elles ont une limite <quote>dure</quote> et une
    limite <quote>souple</quote>. La limite souple est réellement ce qui compte
    mais cela pourrait être changé par l'utilisateur jusqu'à la limite dure. La
    limite dure pourrait seulement être modifiée par l'utilisateur root. L'appel
    système <function>setrlimit</function> est responsable de l'initialisation
    de ces paramètres. La commande interne du shell <command>ulimit</command>
    (shells Bourne) ou <command>limit</command> (<application>csh</application>) est
    utilisé pour contrôler les limites de ressource à partir de la ligne de
    commande. Sur les systèmes dérivés BSD, le fichier
    <filename>/etc/login.conf</filename> contrôle les différentes limites de
    ressource initialisées à la connexion. Voir la documentation du système
    d'exploitation pour les détails. Les paramètres en question sont
    <varname>maxproc</varname>, <varname>openfiles</varname> et
    <varname>datasize</varname>. par exemple&nbsp;:
<programlisting>default:\
...
        :datasize-cur=256M:\
        :maxproc-cur=256:\
        :openfiles-cur=256:\
...</programlisting>
    (<literal>-cur</literal> est la limite douce. Ajoutez
    <literal>-max</literal> pour configurer la limite dure.)
   </para>

   <para>
    Les noyaux peuvent aussi avoir des limites sur le système complet pour
    certaines ressources.
    <itemizedlist>
     <listitem>
      <para>
      Sur <productname>linux</productname>,
      <filename>/proc/sys/fs/file-max</filename> détermine le nombre maximum de
      fichiers ouverts que le noyau supportera. Ce nombre est modifiable en
      écrivant un autre nombre dans le fichier ou en ajoutant une affectation
      dans <filename>/etc/sysctl.conf</filename>. La limite des fichiers par
      processus est fixée lors de la compilation du noyau&nbsp;; voir
      <filename>/usr/src/linux/documentation/proc.txt</filename> pour plus
      d'informations.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Le serveur <productname>PostgreSQL</productname> utilise un processus par
    connexion de façon à ce que vous puissiez fournir au moins autant de
    processus que de connexions autorisées, en plus de ce dont vous avez besoin
    pour le reste de votre système. Ceci n'est habituellement pas un problème
    mais si vous exécutez plusieurs serveurs sur une seule machine, cela
    pourrait devenir étroit.
   </para>

   <para>
    La limite par défaut des fichiers ouverts est souvent initialisée pour être
    <quote>amicalement sociale</quote>, pour permettre à de nombreux
    utilisateurs de coexister sur une machine sans utiliser une fraction
    inappropriée des ressources du système. Si vous lancez un grand nombre de
    serveurs sur une machine, cela pourrait être quelque chose que vous
    souhaitez mais sur les serveurs dédiés, vous pourriez vouloir augmenter
    cette limite.
   </para>

   <para>
    D'un autre côté, certains systèmes autorisent l'ouverture d'un grand
    nombre de fichiers à des processus individuels&nbsp;; si un plus grand
    nombre le font, alors les limites du système peuvent facilement être
    dépassées. Si vous rencontrez ce cas et que vous ne voulez pas modifier la
    limite du système, vous pouvez initialiser le paramètre de configuration
    <xref linkend="guc-max-files-per-process"/> de
    <productname>PostgreSQL</productname> pour limiter la consommation de
    fichiers ouverts.
   </para>
  </sect2>

  <sect2 id="linux-memory-overcommit">
   <title>Linux memory overcommit</title>

   <indexterm>
    <primary>memory overcommit</primary>
   </indexterm>

   <indexterm>
    <primary>OOM</primary>
   </indexterm>

   <indexterm>
    <primary>overcommit</primary>
   </indexterm>

   <para>
    Le comportement par défaut de la mémoire
    virtuelle sur Linux n'est pas optimal pour <productname>PostgreSQL</productname>.
    Du fait de l'implémentation du <quote>memory overcommit</quote> par le
    noyau, celui-ci peut arrêter le serveur
    <productname>PostgreSQL</productname> (le processus serveur
    maître, <quote>postmaster</quote>) si les demandes de mémoire de
    <productname>PostgreSQL</productname> ou d'un autre processus provoque un
    manque de mémoire virtuelle au niveau du système.
   </para>

   <para>
    Si cela se produit, un message du noyau qui ressemble à ceci
    (consulter la documentation et la configuration du système pour savoir
    où chercher un tel message)&nbsp;:
<programlisting>Out of Memory: Killed process 12345 (postgres)</programlisting>
    peut survenir.
    Ceci indique que le processus <filename>postgres</filename> a été terminé
    à cause d'un problème de mémoire. Bien que les connexions en cours
    continuent de fonctionner normalement, aucune nouvelle
    connexion n'est acceptée. Pour revenir à un état normal,
    <productname>PostgreSQL</productname> doit être relancé.
   </para>

   <para>
    Une façon d'éviter ce problème revient à lancer
    <productname>PostgreSQL</productname> sur une machine où vous pouvez vous
    assurer que les autres processus ne mettront pas la machine en manque de
    mémoire. S'il y a peu de mémoire, augmenter la swap peut aider à éviter
    le problème car un système peut tuer des processus lorsque la mémoire
    physique et la mémoire swap sont utilisées entièrement.
   </para>

   <para>
    Si <productname>PostgreSQL</productname> lui-même est la cause d'un manque
    de mémoire du système, vous pouvez éviter le problème en modifiant votre
    configuration. Dans certains cas, baisser les paramètres de configuration
    de la mémoire peut aider, tout particulièrement
    <link linkend="guc-shared-buffers"><varname>shared_buffers</varname></link>,
    <link linkend="guc-work-mem"><varname>work_mem</varname></link> et
    <link linkend="guc-hash-mem-multiplier"><varname>hash_mem_multiplier</varname></link>. Dans
    d'autres cas, le problème peut être causé par l'autorisation d'un trop grand
    nombre de connexions au serveur de bases de données. Dans beaucoup de cas,
    il est préférable de réduire <link
    linkend="guc-max-connections"><varname>max_connections</varname></link> et
    d'utiliser à la place un logiciel de multiplexage de connexions
    (<foreignphrase>connection pooling</foreignphrase>).
   </para>

   <para>
    Il est possible de modifier
    le comportement du noyau avec le <quote>overcommit memory</quote>.
    Bien que ce paramétrage n'empêchera pas ce <ulink
    url="https://lwn.net/Articles/104179/">comportement</ulink>, il réduira sa
    fréquence de façon significative et contribuera du coup à un système
    plus robuste. Ceci se fait en sélectionnant le mode strict de
    l'overcommit via <command>sysctl</command>&nbsp;:
<programlisting>sysctl -w vm.overcommit_memory=2</programlisting>
    ou en plaçant une entrée équivalente dans <filename>/etc/sysctl.conf</filename>.
    Vous pourriez souhaiter modifier le paramétrage relatif
    <varname>vm.overcommit_ratio</varname>. Pour les détails, voir la documentation du
    noyau (<ulink url="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting">https://www.kernel.org/doc/Documentation/vm/overcommit-accounting</ulink>).
   </para>

   <para>
    Une autre approche, qui peut aussi utiliser la modification de
    <varname>vm.overcommit_memory</varname>, est de configurer la valeur de la
    variable d'<firstterm>ajustement du score OOM</firstterm>, valeur par processus, pour le
    processus postmaster à <literal>-1000</literal>, garantissant ainsi qu'il ne
    sera pas la cible de OOM. La façon la plus simple de le faire est
    d'exécuter
<programlisting>
echo -1000 > /proc/self/oom_score_adj
   </programlisting>
   dans le script de démarrage de postmaster juste avant d'appeler postmaster.
   Notez que cette action doit être faite en tant qu'utilisateur root. Dans le
   cas contraire, elle n'aura aucun effet. Du coup, un script de démarrage,
   exécuté par root, est le meilleur endroit où placer ce code. Si vous le
   faites, vous devriez aussi configurer ces variables d'environnement dans le
   script de démarrage avant d'invoquer le processus postmaster :
<programlisting>
export PG_OOM_ADJUST_FILE=/proc/self/oom_score_adj
export PG_OOM_ADJUST_VALUE=0
</programlisting>
    Ces paramètres vont faire en sorte que les processus fils du postmaster
    s'exécuteront avec l'ajustement de score OOm normal (0), pour que l'OOM
    puisse encore les cibler si cela s'avère nécessaire. Vous pouvez utiliser
    d'autres valeurs pour <envar>PG_OOM_ADJUST_VALUE</envar> si vous voulez
    que les processus fils s'exécutent avec un autre ajustement de score.
    (<envar>PG_OOM_ADJUST_VALUE</envar> peut aussi être omis, auquel cas sa
    valeur par défaut est zéro.) Si vous ne voulez pas configurer
    <envar>PG_OOM_ADJUST_FILE</envar>, les processus fils s'exécuteront avec
    le même ajustement de score OOM que le processus père postmaster, ce qui
    n'est pas conseillé car le but est de s'assurer que le processus
    postmaster soit protégé par la configuration.
  </para>
 </sect2>

 <sect2 id="linux-huge-pages">
  <title>Pages mémoire de grande taille
   (<foreignphrase>huge pages</foreignphrase>) sous Linux</title>

  <para>
   L'utilisation des <foreignphrase>huge pages</foreignphrase> réduit la
   surcharge lors de l'utilisation de gros morceaux contigus de mémoire,
   ce que fait
   <productname>PostgreSQL</productname>, tout particulièrement lors de
   l'utilisation de grosses valeurs pour <xref linkend="guc-shared-buffers"/>.
   Pour activer cette fonctionnalité avec
   <productname>PostgreSQL</productname>, vous avez besoin d'un noyau compilé
   avec <varname>CONFIG_HUGETLBFS=y</varname> et
   <varname>CONFIG_HUGETLB_PAGE=y</varname>. Vous devez aussi configurer le
   paramètre noyau <varname>vm.nr_hugepages</varname>. Pour estimer le nombre
   nécessaire de <foreignphrase>huge pages</foreignphrase>,
   lancer <productname>PostgreSQL</productname>
   sans activer les  <foreignphrase>huge pages</foreignphrase>
   et vérifiez la taille du segment de mémoire
   partagée anonyme pour le processus postmaster, ainsi que la taille
   des  <foreignphrase>huge pages</foreignphrase> pour le système en utilisant
   le système de fichiers
   <filename>/proc</filename>. Cela pourrait ressembler à ceci&nbsp;:
   <programlisting>
$ <userinput>head -1 $PGDATA/postmaster.pid</userinput>
4170
$ <userinput>pmap 4170 | awk '/rw-s/ &amp;&amp; /zero/ {print $2}'</userinput>
6490428K
$ <userinput>grep ^Hugepagesize /proc/meminfo</userinput>
Hugepagesize:       2048 kB
   </programlisting>
   <literal>6490428</literal> / <literal>2048</literal> donne approximativement
   <literal>3169.154</literal>. Donc, dans cet exemple, nous avons besoin d'au
   moins <literal>3170</literal>  <foreignphrase>huge pages</foreignphrase>,
   ce que nous pouvons configurer avec&nbsp;:
   <programlisting>
$ <userinput>sysctl -w vm.nr_hugepages=3170</userinput>
   </programlisting>
   Une configuration plus importante serait appropriée si les autres
   programmes du serveur avaient aussi besoin de
   <foreignphrase>huge pages</foreignphrase>. N'oubliez pas
   d'ajouter cette configuration à <filename>/etc/sysctl.conf</filename> pour
   qu'elle soit appliquée à chaque redémarrage.
   </para>

   <para>
   Parfois, le noyau n'est pas capable d'allouer immédiatement le nombre
   souhaité de  <foreignphrase>huge pages</foreignphrase>,
   donc il peut être nécessaire de répéter cette
   commande ou de redémarrer. (Tout de suite après un redémarrage, la plupart
   de la mémoire de la machine doit être disponible à une conversion en
    <foreignphrase>huge pages</foreignphrase>.) Pour vérifier la situation
    au niveau de l'allocation des  <foreignphrase>huge pages</foreignphrase>,
    utilisez&nbsp;:
<programlisting>
$ <userinput>grep Huge /proc/meminfo</userinput>
</programlisting>
   </para>

  <para>
    Il pourrait être nécessaire de donner le droit à l'utilisateur du système
    d'exploitation du serveur de bases de données en configurant
    <varname>vm.hugetlb_shm_group</varname> via
    <application>sysctl</application>, et/ou en donnant le droit de
    verrouiller la mémoire avec <command>ulimit -l</command>.
  </para>

  <para>
   Il est aussi nécessaire de donner le droit d'utiliser les
   <foreignphrase>huge pages</foreignphrase> à
   l'utilisateur système qui exécute PostgreSQL. Cela se fait en configurant
   <varname>vm.hugetlb_shm_group</varname> via
   <application>sysctl</application>, et le droit de verrouiller la mémoire
   avec <command>ulimit -l</command>.
   </para>

   <para>
   Le comportement par défaut pour les
   <foreignphrase>huge pages</foreignphrase> dans
   <productname>PostgreSQL</productname> est de les utiliser quand cela est
   possible et de revenir aux pages normales dans le cas contraire. Pour
   forcer l'utilisation des  <foreignphrase>huge pages</foreignphrase>,
   vous pouvez configurer <xref
   linkend="guc-huge-pages"/> à <literal>on</literal> dans le fichier
   <filename>postgresql.conf</filename>. Notez que, avec ce paramètre
   configuré ainsi, <productname>PostgreSQL</productname> refusera de démarrer
   s'il ne peut pas récupérer suffisamment de
   <foreignphrase>huge pages</foreignphrase>.
  </para>

  <para>
   Pour une description détaillée des  <foreignphrase>huge pages</foreignphrase>
   sous <productname>Linux</productname>, lisez <ulink
   url="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</ulink>.
  </para>

 </sect2>
</sect1>


<sect1 id="server-shutdown">
 <title>Arrêter le serveur</title>

 <indexterm zone="server-shutdown">
  <primary>arrêt</primary>
 </indexterm>

 <para>
  Il existe plusieurs façons d'arrêter le serveur de bases de données. Vous
  contrôlez le type d'arrêt en envoyant différents signaux au processus
  serveur maître.

  <variablelist>
   <varlistentry>
    <term><systemitem>sigterm</systemitem><indexterm><primary>sigterm</primary></indexterm></term>
    <listitem>
     <para>
      C'est le mode d'<firstterm>arrêt intelligent</firstterm>.
      Après réception de <systemitem>sigterm</systemitem>, le serveur
      désactive les nouvelles connexions mais permet aux sessions en cours de
      terminer leur travail normalement. Il s'arrête seulement après que toutes
      les sessions se sont terminées normalement. C'est l'arrêt intelligent
      (<firstterm>smart shutdown</firstterm>).
      Si le serveur est en mode de sauvegarde en ligne, il attends en plus la
      désactivation du mot de sauvegarde en ligne. Lorsque le mode de sauvegarde
      est actif, les nouvelles connexions sont toujours autorisées, mais
      seulement pour les superutilisateurs (cette exception permet à un
      superutilisateur de se connecter pour terminer le mode de sauvegarde en
      ligne). Si le serveur est en restauration quand une demande d'arrêt
      intelligent est envoyée, la restauration et la réplication en flux
      seront stoppées seulement une fois que toutes les autres sessions ont
      terminé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><systemitem>sigint</systemitem><indexterm><primary>sigint</primary></indexterm></term>
    <listitem>
     <para>
      C'est le mode d'<firstterm>arrêt rapide</firstterm>.
      Le serveur désactive les nouvelles connexions et envoie à tous
      les processus serveur le signal <systemitem>sigterm</systemitem>, qui les
      fera annuler leurs transactions courantes pour quitter rapidement. Il
      attend ensuite la fin de tous les processus serveur et s'arrête finalement.
      Si le serveur est en mode de sauvegarde en ligne, le mode est annulé,
      rendant la sauvegarde inutilisable.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><systemitem>sigquit</systemitem><indexterm><primary>sigquit</primary></indexterm></term>
    <listitem>
     <para>
      C'est le mode d'<firstterm>arrêt immédiat</firstterm>. Le serveur enverra
      <systemitem>SIGQUIT</systemitem> à tous les processus fils et attendra
      qu'ils se terminent. Ceux qui ne se terminent pas au bout de cinq secondes
      se verront envoyés un signal <systemitem>SIGKILL</systemitem> par le
      processus père <command>postgres</command>, qui les arrêtera sans attendre
      plus. Ceci peut amener à un redémarrage en mode restauration (de ce fait,
      ceci n'est recommandé que dans les cas d'urgence).
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </para>

 <para>
  Le programme <xref linkend="app-pg-ctl"/> fournit une interface agréable
  pour envoyer ces signaux dans le but d'arrêter le serveur. Autrement, vous
  pouvez envoyer le signal directement en utilisant <command>kill</command>
  sur les systèmes autres que Windows. Le <acronym>PID</acronym> du processus
  <command>postgres</command> peut être trouvé en utilisant le programme
  <command>ps</command> ou à partir du fichier
  <filename>postmaster.pid</filename> dans le répertoire des données.
  Par exemple, pour exécuter un arrêt rapide&nbsp;:
  <screen>$ <userinput>kill -int `head -1 /usr/local/pgsql/data/postmaster.pid`</userinput></screen>
  </para>

  <important>
   <para>
    Il vaux mieux de ne pas utiliser <systemitem>SIGKILL</systemitem> pour arrêter
    le serveur. Le faire empêchera le serveur de libérer la mémoire partagée et
    les sémaphores. De plus, <systemitem>SIGKILL</systemitem> tue
    le processus <command>postgres</command> sans lui laisser le temps de
    relayer ce signal à ses sous-processus, donc il peut aussi être nécessaire
    de tuer chaque sous-processus à la main.
   </para>
  </important>

  <para>
   Pour terminer une session donnée tout en permettant aux autres de
   continuer, utilisez <function>pg_terminate_backend()</function>
   (voir <xref linkend="functions-admin-signal-table"/>) ou envoyez un signal
   <systemitem>SIGTERM</systemitem> au processus fils associé à cette session.
  </para>
 </sect1>

 <sect1 id="upgrading">
  <title>Mise à jour d'une instance <productname>PostgreSQL</productname></title>

  <indexterm zone="upgrading">
   <primary>mise à jour</primary>
  </indexterm>

  <indexterm zone="upgrading">
   <primary>version</primary>
   <secondary>compatibilité</secondary>
  </indexterm>

  <para>
   Cette section concerne la mise à jour des données de votre serveur
   d'une version de <productname>PostgreSQL</productname> vers une
   version ultérieure.
  </para>

  <para>
   Les numéros de versions actuelles de <productname>PostgreSQL</productname>
   se composent d'un numéro de version majeure et mineure. Par exemple, pour le
   numéro de version 10.1, 10 est le numéro de la version majeure et 1 est le
   numéro de la version mineure, ce qui signifie que c'est la première mise à
   jour mineure de la version majeure 10. Pour les versions précédant
   <productname>PostgreSQL</productname> 10.0, la numérotation des versions
   est composée de 3 numéros, par exemple 9.5.3. Dans ces cas, la version
   majeure est composée des deux premiers groupes de chiffres du numéro de
   version, par exemple 9.5, et la version mineure est le troisième chiffre,
   par exemple 3, signifiant que c'est la troisième version mineure de la
   version majeure 9.5.
  </para>

  <para>
   Les versions mineures ne changent jamais le format de stockage interne et
   sont toujours compatibles avec les versions mineures précédentes et
   suivantes de la m&ecirc;me version majeure. Par exemple, la version 10.1 est
   compatible avec la version 10.0 et la version 10.6. De m&ecirc;me, par
   exemple, la version 9.5.3 est compatible avec 9.5.0, 9.5.1 et 9.5.6. Pour
   mettre à jour entre versions compatibles, il suffit de remplacer les
   exécutables lorsque le serveur est arr&ecirc;té et de redémarrer le serveur.
   Le répertoire de données reste inchangé&nbsp;: les mises à jour mineures sont
   aussi simples que cela.
  </para>

  <para>
   Pour les versions <emphasis>majeures</emphasis> de
   <productname>PostgreSQL</productname>, le format de stockage interne
   des données est sujet à modification, ce qui complique les mises à
   jour. La méthode traditionnelle de migration des données vers une
   nouvelle version majeure est de sauvegarder puis recharger la base
   de données, même si cela peut être lent. <xref linkend="pgupgrade"/> est une
   méthode plus rapide. Des méthodes de réplication sont aussi disponibles,
   comme discuté ci-dessus.
  </para>

  <para>
   De plus, les nouvelles versions majeures introduisent généralement
   des incompatibilités qui impactent les utilisateurs. Du coup, des
   modifications peuvent être nécessaires sur les applications clientes.
   Tous les changements visibles par les utilisateurs sont listés dans
   les notes de version (<xref linkend="release"/>). Soyez
   particulièrement attentif à la section Migration. Si vous mettez à
   jour en passant plusieurs versions majeures, assurez-vous de lire les
   notes de version de chaque version majeure que vous passez.
  </para>

  <para>
   Les utilisateurs précautionneux testeront leur applications clientes
   sur la nouvelle version avant de basculer complètement. Du coup, il
   est souvent intéressant de mettre en place des installations parallèles
   des ancienne et nouvelle versions. Lors d'un test d'une mise à jour
   majeure de <productname>PostgreSQL</productname>, pensez aux
   différentes catégories suivantes&nbsp;:
  </para>

  <variablelist>

   <varlistentry>
    <term>Administration</term>
    <listitem>
     <para>
      Les fonctionnalités disponibles pour les administrateurs pour
      surveiller et contrôler le serveur s'améliorent fréquemment à
      chaque nouvelle version.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>SQL</term>
    <listitem>
     <para>
      Cela inclut généralement les nouvelles commandes ou clauses SQL,
      et non pas des changements de comportement sauf si c'est
      spécifiquement précisé dans les notes de version.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>API</term>
    <listitem>
     <para>
      Les bibliothèques comme <application>libpq</application> se voient
      seulement ajouter de nouvelles fonctionnalités, sauf encore une
      fois si le contraire est mentionné dans les notes de version.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Catalogues systèmes</term>
    <listitem>
     <para>
      Les modifications dans les catalogues systèmes affectent seulement
      les outils de gestion des bases de données.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>API serveur pour le langage C</term>
    <listitem>
     <para>
      Ceci implique des modifications dans l'API des fonctions du moteur
      qui est écrit en C. De telles modifications affectent le code qui
      fait référence à des fonctions du moteur.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>

  <sect2 id="upgrading-via-pgdumpall">
   <title>Mettre à jour les données via <application>pg_dumpall</application></title>

   <para>
    Une méthode de mise à jour revient à sauvegarder les données d'une version
    majeure de <productname>PostgreSQL</productname> et de la recharger dans une
    autre &mdash; pour cela, vous devez utiliser un outil de sauvegarde
    <emphasis>logique</emphasis> comme <application>pg_dumpall</application>&nbsp;;
    une sauvegarde au niveau système de fichiers ne fonctionnera pas.
    Des vérifications sont faites pour vous empêcher d'utiliser un
    répertoire de données avec une version incompatible de
    <productname>PostgreSQL</productname>, donc aucun mal ne sera fait
    si vous essayez de lancer un serveur d'une version majeure sur un
    répertoire de données créé par une autre version majeure.)
   </para>

   <para>
    Il est recommandé d'utiliser les programmes
    <application>pg_dump</application> et
    <application>pg_dumpall</application> provenant de la <emphasis>nouvelle</emphasis>
    version de <productname>PostgreSQL</productname>, pour bénéficier
    des améliorations apportées à ces programmes. Les versions actuelles
    de ces programmes peuvent lire des données provenant de tout serveur
    dont la version est supérieure ou égale à la 7.0.
   </para>

   <para>
    Ces instructions supposent que votre installation existante se
    trouve dans le répertoire <filename>/usr/local/pgsql</filename> et
    que le répertoire des données est
    <filename>/usr/local/pgsql/data</filename>. Remplacez ces chemins
    pour correspondre à votre installation.
   </para>

   <procedure>
    <step>
     <para>
      Si vous faites une sauvegarde, assurez-vous que votre base de
      données n'est pas en cours de modification. Cela n'affectera pas
      l'intégrité de la sauvegarde mais les données modifiées ne seront
      évidemment pas incluses. Si nécessaire, modifiez les droits dans
      le fichier <filename>/usr/local/pgsql/data/pg_hba.conf</filename>
      (ou équivalent) pour interdire l'accès à tout le monde sauf vous.
      Voir <xref linkend="client-authentication"/> pour plus
      d'informations sur le contrôle des accès.
     </para>

     <para>
      <indexterm>
       <primary>pg_dumpall</primary>
       <secondary>utilisation lors d'une mise à jour</secondary>
      </indexterm>

      Pour sauvegarder votre installation, exécutez la commande
      suivante&nbsp;:
<screen>
<userinput>pg_dumpall &gt; <replaceable>fichier_en_sortie</replaceable></userinput>
  </screen>
 </para>

 <para>
  Pour faire la sauvegarde, vous pouvez utiliser la commande
  <application>pg_dumpall</application> de la version en cours
  d'exécution&nbsp;; voir <xref
  linkend="backup-dump-all"/> pour plus de détails. Néanmoins,
  pour de meilleurs résultats, essayez
  d'utiliser la commande <application>pg_dumpall</application>
  provenant de la version &version; de
  <productname>PostgreSQL</productname>, car cette version contient
  des corrections de bugs et des améliorations par rapport aux
  anciennes version. Bien que ce conseil peut sembler étonnant, étant
  donné que vous n'avez pas encore été la nouvelle version, il est
  conseillé de le suivre si vous souhaitez installer la nouvelle
  version en parallèle de l'ancienne. Dans ce cas, vous pouvez
  terminer l'installation normalement et transférer les données plus
  tard. Cela diminuera aussi le temps d'immobilisation.
 </para>
</step>

<step>
 <para>
  Arrêtez l'ancien serveur&nbsp;:
  <screen>
<userinput>pg_ctl stop</userinput>
  </screen>
  Sur les systèmes qui lancent <productname>PostgreSQL</productname>
  au démarrage, il existe probablement un script de démarrage qui
  fera la même chose. Par exemple, sur un système <systemitem
  class="osname">Red Hat Linux</systemitem>, cette commande
  pourrait fonctionner&nbsp;:
  <screen>
<userinput>/etc/rc.d/init.d/postgresql stop</userinput>
  </screen>
  Voir <xref linkend="runtime"/> pour des détails sur le lancement
  et l'arrêt d'un serveur.
 </para>
</step>

<step>
 <para>
  Lors de la restauration de la sauvegarde, renommez ou supprimez l'ancien
  répertoire d'installation si ce n'est pas spécifique à la version. Il
  est préférable de le renommer car, en cas de problème, vous pourrez le
  récupérer. Garder en tête que le répertoire peut prendre beaucoup d'espace
  disque. Pour renommer le répertoire, utilisez une commande comme
  celle-ci&nbsp;:
  <screen>
<userinput>mv /usr/local/pgsql /usr/local/pgsql.old</userinput>
  </screen>
  (Assurez-vous de déplacer le répertoire en un seul coup, pour que
  les chemins relatifs restent inchangés.)
 </para>
</step>

<step>
 <para>
  Installez la nouvelle version de <productname>PostgreSQL</productname>
  comme indiqué dans <phrase>la section suivante</phrase>
  <phrase><xref linkend="install-procedure"/></phrase>.
 </para>
</step>

<step>
 <para>
  Créez une nouvelle instance de bases de données si nécessaire.
  Rappelez-vous que vous devez exécuter ces commandes une fois
  connecté en tant que l'utilisateur de bases de données (que vous
  devez déjà avoir si vous faites une mise à jour).
  <programlisting>
<userinput>/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data</userinput>
  </programlisting>
 </para>
</step>

<step>
 <para>
  Restaurez vos modifications dans les fichiers
  <filename>pg_hba.conf</filename> et
  <filename>postgresql.conf</filename>.
 </para>
</step>

<step>
 <para>
  Démarrez le serveur de bases de données, en utilisant encore une
  fois l'utilisateur de bases de données&nbsp;:
  <programlisting>
<userinput>/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data</userinput>
  </programlisting>
 </para>
</step>

<step>
 <para>
  Enfin, restaurez vos données à partir de votre sauvegarde&nbsp;:
  <screen>
<userinput>/usr/local/pgsql/bin/psql -d postgres -f <replaceable>outputfile</replaceable></userinput>
  </screen>
  en utilisant le <emphasis>nouveau</emphasis> <application>psql</application>.
 </para>
</step>
</procedure>

<para>
Il est possible de parvenir à une immobilisation moins longue en
installant le nouveau serveur dans un autre répertoire et en
exécutant l'ancien et le nouveau serveur, en parallèle, sur des
ports différents. Vous pouvez ensuite utiliser quelque chose
comme&nbsp;:

<programlisting>
pg_dumpall -p 5432 | psql -d postgres -p 5433
</programlisting>
pour transférer vos données.
</para>

</sect2>

<sect2 id="upgrading-via-pg-upgrade">
<title>Mettre à jour les données via <application>pg_upgrade</application></title>

<para>
Le module <xref linkend="pgupgrade"/> permet la mise à jour en ligne
d'une installation d'une version majeure de
<productname>PostgreSQL</productname> vers une autre. Les mises à jour se
sont en quelques minutes, notamment avec le mode <option>--link</option>.
Il requiert les mêmes étapes que pour <application>pg_dumpall</application>
ci-dessus, autrement dit lancer/arrêter le serveur, lancer
<application>initdb</application>.  La <link
linkend="pgupgrade">documentation</link> de <application>pg_upgrade</application>
surligne les étapes nécessaires.
</para>
</sect2>

<sect2 id="upgrading-via-replication">
<title>Mettre à jour les données via la réplication</title>

<para>
Il est aussi possible d'utiliser des méthodes de réplication logique
pour créer un serveur esclave
avec une version plus récente de <productname>PostgreSQL</productname>.
C'est possible car la réplication logique permet une réplication entre des
versions majeures différentes de
<productname>PostgreSQL</productname>. L'esclave peut se trouver sur
le même serveur ou sur un autre. Une fois qu'il est synchronisé
avec le serveur maître (qui utilise toujours l'ancienne version de
<productname>PostgreSQL</productname>), vous pouvez basculer le
serveur maître sur le nouveau serveur et arrêter l'ancien maître.
Ce type de bascule fait que l'arrêt requis pour la mise à jour se
mesure seulement en secondes.
</para>

<para>
 Cette méthode de mise à jour peut être mise en œuvre avec la réplication
 logique intégrée comme avec des outils de réplication logique tels que
 <productname>pglogical</productname>, <productname>Slony</productname>,
 <productname>Londiste</productname>, et <productname>Bucardo</productname>.
</para>

</sect2>
</sect1>

<sect1 id="preventing-server-spoofing">
<title>Empêcher l'usurpation de serveur (spoofing)</title>

<indexterm zone="preventing-server-spoofing">
<primary>usurpation de serveur (server spoofing)</primary>
</indexterm>

<para>
Quand le serveur est en cours d'exécution, un utilisateur mal intentionné ne
peut pas interférer dans les communications client/serveur. Néanmoins,
quand le serveur est arrêté, un utilisateur local peut usurper le rôle du serveur
normal en lançant son propre serveur. Le serveur usurpateur pourrait lire
les mots de passe et les requêtes envoyés par les clients, mais ne pourrait
pas renvoyer de données car le répertoire <varname>PGDATA</varname> est
toujours sécurisé grâce aux droits d'accès du répertoire. L'usurpation
est possible parce que tout utilisateur peut lancer un serveur de bases
de données&nbsp;; un client ne peut pas identifier un serveur invalide
sauf s'il est configuré spécialement.
</para>

<para>
Un moyen d'empêcher les serveurs d'usurper des
connexions <literal>local</literal>es est d'utiliser un répertoire de
socket de domaine Unix (<xref linkend="guc-unix-socket-directories"/>) qui
n'a un droit en écriture que pour un utilisateur local de
confiance. Ceci empêche un utilisateur mal intentionné de créer son
propre fichier socket dans ce répertoire. Si vous craignez que
certaines applications puissent encore référencer
<filename>/tmp</filename> pour le fichier socket et, du coup, être
vulnérable au <quote>spoofing</quote>, créez un lien
symbolique <filename>/tmp/.s.PGSQL.5432</filename> pointant vers le fichier
socket déplacé. Vous pourriez alors avoir besoin de modifier votre script
de nettoyage de <filename>/tmp</filename> pour empêcher la suppression du
lien symbolique.
</para>

<para>
 Une autre option pour les connexions de type <literal>local</literal> est que
 les clients utilisent <link
 linkend="libpq-connect-requirepeer"><literal>requirepeer</literal></link>
 pour indiquer un propriétaire précis du processus serveur connecté au socket.
</para>

  <para>
  Pour éviter l'usurpation sur les connexions TCP, utilisez des certificats SSL,
  et assurez-vous que les clients vérifient le certificat du serveur,
  ou bien utilisez le chiffrage GSSAPI (ou les deux, s'il s'agit de connexions
  séparées).
  </para>

  <para>
   Pour éviter l'usurpation avec SSL, le serveur doit être configuré
   pour accepter les connexions <literal>hostssl</literal>
   (<xref linkend="auth-pg-hba-conf"/>)
   et avoir des fichiers SSL clé et certificat
   (<xref linkend="ssl-tcp"/>). Le client TCP
   doit se connecter en utilisant <literal>sslmode='verify-ca'</literal> ou
   <literal>verify-full</literal> et le fichier certificat root approprié
   doit y être installé (<xref linkend="libq-ssl-certificates"/>).
  </para>

  <para>
    Pour éviter l'usurpation avec GSSAPI, le serveur doit être configuré
    pour n'accepter que les connexions <literal>hostgssenc</literal>
    (<xref linkend="auth-pg-hba-conf"/>) et l'authentification
    <literal>gss</literal> avec elles.
    Le client TCP doit se connecter en utilisant <literal>gssencmode=require</literal>.
  </para>
</sect1>

<sect1 id="encryption-options">
<title>Options de chiffrement</title>

<indexterm zone="encryption-options">
<primary>chiffrement</primary>
</indexterm>

<para>
<productname>PostgreSQL</productname> offre du chiffrement à différents niveaux
et offre une certaine flexibilité pour éviter que les données soit révélées
à cause d'un vol du serveur de la base de données, d'administrateurs peu scrupuleux
et de réseaux non sécurisés. Le chiffrement pourrait aussi être requis pour
sécuriser des données sensibles, par exemple des informations médicales ou des
transactions financières.
</para>

<variablelist>

<varlistentry>
<term>Chiffrement du mot de passe</term>
<listitem>

 <para>
  Les mots de passe des utilisateurs de la base de données sont stockées
  suivant des hachages (déterminés par la configuration du paramètre <xref
  linkend="guc-password-encryption"/>), donc l'administrateur ne peut pas
  déterminer le mot de passe actuellement affecté à l'utilisateur. Si le
  chiffrage MD5 ou SCRAM est utilisé pour l'authentification du client, le mot
  de passe non chiffré n'est jamais, y compris temporairement, présent sur le
  serveur parce que le client le chiffre avant de l'envoyer sur le réseau.
  SCRAM est à préférer parce qu'il s'agit d'un standard Internet et qu'il
  est bien plus sécurisé que le protocole d'authentification MD5 spécifique à
  PostgreSQL.
 </para>
</listitem>
</varlistentry>

<varlistentry>
<term>chiffrement de colonnes spécifiques</term>

<listitem>
 <para>
  Le module <xref linkend="pgcrypto"/> autorise le stockage chiffré de certains
  champs. Ceci est utile si seulement certaines données sont sensibles.
  Le client fournit la clé, la donnée est déchiffrée sur
  le serveur puis envoyée au client.
 </para>

 <para>
  La donnée déchiffrée et la clé de déchiffrement sont présentes sur le serveur
  pendant un bref moment où la donnée est déchiffrée, puis envoyée entre le
  client et le serveur. Il y a donc un bref moment où la donnée et les
  clés peuvent être interceptées par quelqu'un ayant un accès complet au
  serveur de bases de données, tel que l'administrateur du système.
 </para>
</listitem>
</varlistentry>

<varlistentry>
<term>chiffrement de la partition de données</term>

<listitem>
 <para>
  Le chiffrement du stockage peut se réaliser au niveau du système de
  fichiers ou au niveu du bloc. Les options de chiffrement des systèmes
  de fichiers sous Linux incluent eCryptfs et EncFS, alors que FreeBSD
  utilise PEFS. Les options de chiffrement au niveau bloc ou au niveau
  disque incluent dm-crypt + LUKS sur Linux et les modules GEOM geli et
  gbde sur FreeBSD. Beaucoup d'autres systèmes d'exploitation supportent
  cette fonctionnalité, y compris Windows.
 </para>

 <para>
  Ce mécanisme empêche les données non chiffrées d'être lues à partir des
  lecteurs s'ils sont volés. Ceci ne protège pas contre les attaques quand
  le système de fichiers est monté parce que, une fois monté, le système
  d'exploitation fournit une vue non chiffrée des données. Néanmoins, pour
  monter le système de fichiers, vous avez besoin d'un moyen pour fournir
  la clé de chiffrement au système d'exploitation et, quelque fois, la clé
  est stocké quelque part près de l'hôte qui monte le disque.
 </para>
</listitem>
</varlistentry>

<varlistentry>
<term>chiffrement des données sur le réseau</term>

<listitem>
 <para>
  Les connexions SSL chiffrent toutes les données envoyées sur le
  réseau&nbsp;: le mot de passe, les requêtes et les données renvoyées. Le
  fichier <filename>pg_hba.conf</filename> permet aux administrateurs de spécifier
  quels hôtes peuvent utiliser des connexions non chiffrées (<literal>host</literal>)
  et lesquels requièrent des connexions SSL (<literal>hostssl</literal>). De plus,
  les clients peuvent spécifier qu'ils se connectent aux serveurs seulement
  via SSL.
 </para>

 <para>
  Les connexions chiffrées par GSSAPI chiffrent toutes les données
  envoyées sur le réseau, dont les requêtes et les données renvoyées.
  (Aucun mot de passe n'est envoyé sur le réseau).
  Le fichier <filename>pg_hba.conf</filename> permet aux administrateurs
  d'indiquer quels clients peuvent utiliser des connexions non chiffrées
  (<literal>host</literal>) et lesquels nécessitent des connexions
  chiffrées par GSSAPI (<literal>hostgssenc</literal>).
  Les clients peuvent aussi préciser qu'ils ne se connecteront
  qu'avec des connections chiffrées par GSSAPI
  (<literal>gssencmode=require</literal>).

 </para>

 <para>
  <application>Stunnel</application> ou
  <application>SSH</application> peuvent aussi
  être utilisés pour chiffrer les transmissions.
 </para>
</listitem>
</varlistentry>

<varlistentry>
<term>Authentification de l'hôte SSL</term>

<listitem>
 <para>
  Il est possible que le client et le serveur fournissent des certificats
  SSL à l'autre. Cela demande une configuration supplémentaire
  de chaque côté mais cela fournit une vérification plus forte de l'identité
  que la simple utilisation de mots de passe. Cela empêche un ordinateur de
  se faire passer pour le serveur assez longtemps pour lire le mot de passe
  envoyé par le client. Cela empêche aussi les attaques du type <quote>man
   in the middle</quote> où un ordinateur, entre le client et le serveur,
  prétend être le serveur, lit et envoie les données entre le client et le
  serveur.
 </para>
</listitem>
</varlistentry>

<varlistentry>
<term>Chiffrement côté client</term>

<listitem>
 <para>
  Si vous n'avez pas confiance en l'administrateur système du serveur, il
  est nécessaire
  que le client crypte les données&nbsp;; de cette façon, les données non
  cryptées n'apparaissent jamais sur le serveur de la base de données. Les
  données sont cryptées sur le client avant d'être envoyé au serveur, et les
  résultats de la base de données doivent être décryptés sur le client avant
  d'être utilisés.
 </para>
</listitem>
</varlistentry>

</variablelist>

</sect1>

<sect1 id="ssl-tcp">
<title>Connexions TCP/IP sécurisées avec SSL</title>

<indexterm zone="ssl-tcp">
<primary>ssl</primary>
</indexterm>

<para>
<productname>PostgreSQL</productname> dispose d'un support natif pour l'utilisation de
connexions <acronym>SSL</acronym> et le chiffrage des communications
client/serveur pour améliorer la sécurité améliorée.
Ceci requiert l'installation
d'<productname>OpenSSL</productname> à la fois sur le système client et sur
le système serveur et que ce support soit activé au moment de la
construction de <productname>PostgreSQL</productname> (voir le <xref
linkend="installation"/>).
</para>

  <sect2 id="ssl-setup">
   <title>Configuration basique</title>

  <para>
   Avec <acronym>SSL</acronym> intégré à la compilation, le serveur
   <productname>PostgreSQL</productname> peut être démarré avec
   <acronym>SSL</acronym> activé en positionnant le paramètre
   <xref linkend="guc-ssl"/> à <literal>on</literal> dans
   <filename>postgresql.conf</filename>. Le serveur écoutera les deux types
   de connexion, normal et  <acronym>SSL</acronym>, sur le même port TCP,
   et négociera l'utilisation de <acronym>SSL</acronym> avec chaque client.
   Par défaut, c'est au choix du client&nbsp;; voir <xref
   linkend="auth-pg-hba-conf"/> pour la configuration du serveur
   pour exiger <acronym>SSL</acronym> pour tout ou partie des connexions.
  </para>

<para>
Pour démarrer dans le mode <acronym>SSL</acronym>, les fichiers contenant le
certificat du serveur et la clé privée doivent exister. Par défaut, ces
fichiers sont nommés respectivement <filename>server.crt</filename> et
<filename>server.key</filename>, et sont placés dans le répertoire des
données du serveur. D'autres noms et emplacements peuvent être spécifiés
en utilisant les paramètres <xref linkend="guc-ssl-cert-file"/>
et <xref linkend="guc-ssl-key-file"/>.
  </para>

  <para>
   Sur les systèmes Unix, les droits de <filename>server.key</filename> doivent
   interdire l'accès au groupe et au reste du monde&nbsp;; cela se fait avec
   la commande <command>chmod 0600 server.key</command>. Il est aussi possible
   de faire en sorte que le fichier ait root comme propriétaire et des droits
   de lecture pour le groupe (autrement dit, des droits <literal>0640</literal>).
   Cette configuration cible les installations où les fichiers certificat et
   clé sont gérés par le système d'exploitation. L'utilisateur qui exécute le
   serveur <productname>PostgreSQL</productname> doit être un membre du groupe
   qui a accès aux fichiers certificat et clé.
  </para>

  <para>
    Si le répertoire des données permet l'accès en lecture au groupe,
    alors les fichiers de certificat doivent être placés hors de ce répertoire
    pour se conformer aux exigences de sécurité décrites ci-dessus.
    Généralement, l'accès au groupe est autorisé pour permettre à un utilisateur
    non privilégié de sauvegarder la base, et dans ce cas le logiciel
    de sauvegarde sera incapable de lire les certificats et retournera
    probablement une erreur.
  </para>

  <para>
     Si la clé privée est protégée par une phrase de passe, le serveur la
demandera et ne se lancera pas tant qu'elle n'aura pas été saisie.
   Utiliser une phrase de passe par défaut emp&ecirc;che également la possibilité de
   modifier la configuration SSL du serveur sans redémarrage. Voir
   <xref linkend="guc-ssl-passphrase-command-supports-reload"/>.
   De plus, les clés privées protégées par phrases de passe ne peuvent
   &ecirc;tre utilisées sur Windows.
</para>

<para>
Le premier certificat dans <filename>server.crt</filename> doit être le
certificat du serveur car il doit correspondre à la clé privée du serveur. Les
certificats des autorités <quote>intermédiaires</quote> d'autorité peuvent
aussi être ajoutés au fichier. Le faire permet d'éviter la nécessité
d'enregistrer les certificats intermédiaires des clients, en supposant que le
certificat racine et les certificats intermédiaires ont été créés avec les
extensions <literal>v3_ca</literal>. Ceci permet une expiration plus simple
des certificats intermédiaires.
</para>

<para>
Il n'est pas nécessaire d'ajouter le certificat racine dans le fichier
<filename>server.crt</filename>. À la place, les clients doivent avoir le
certificat racine de la chaîne de certificats du serveur.
</para>
  </sect2>

  <sect2 id="ssl-openssl-config">
   <title>OpenSSL Configuration</title>

  <para>
   <productname>PostgreSQL</productname> lit le fichier de configuration
   <productname>OpenSSL</productname> du système. Par défaut, ce fichier
   est nommé <filename>openssl.cnf</filename> et est situé dans le
   répertoire désigné par <literal>openssl version -d</literal>.
   Ce défaut peut être surchargé en remplissant la variable d'environnement
   <envar>OPENSSL_CONF</envar> avec le nom du fichier de configuration
   désiré.
  </para>

  <para>
   <productname>OpenSSL</productname> supporte une large gamme d'algorithmes
   de chiffrement et d'authentification de forces variables.
   Bien qu'une liste des techniques de chiffrement soit spécifiée dans le
   fichier de configuration d'<productname>OpenSSL</productname>,
   vous pouvez préciser les chiffrements à utiliser par le serveur
   en modifiant <xref linkend="guc-ssl-ciphers"/> dans
   <filename>postgresql.conf</filename>.
  </para>

  <note>
   <para>
    Il est possible d'avoir une authentification sans le coût du chiffrement
    en utilisant les chiffrements <literal>NULL-SHA</literal> ou
    <literal>NULL-MD5</literal> ciphers. Cependant, un «&nbsp;homme
    du milieu&nbsp;» (<foreignphrase>man-in-the-middle</foreignphrase>)
    pourrait lire et transmettre des communications entre client et serveur.
    Pour ces raisons, les chiffrements NULL ne sont pas recommandés.
   </para>
  </note>
  </sect2>

<sect2 id="ssl-client-certificates">
<title>Utiliser des certificats clients</title>

<para>
Pour réclamer au client de fournir un certificat de confiance, placez les
certificats des autorités certificats racines (<acronym>CA</acronym>) dont
vous avez confiance dans un fichier du répertoire des données, configurez le
paramètre <xref linkend="guc-ssl-ca-file"/> dans
<filename>postgresql.conf</filename> au nouveau nom du fichier, et ajoutez
l'option d'authentification <literal>clientcert=verify-ca</literal> ou
<literal>clientcert=verify-full</literal> sur la ligne
<literal>hostssl</literal> approprié dans <filename>pg_hba.conf</filename>. Un
certificat sera alors réclamé du client lors du démarrage de la connexion SSL.
(Voir <xref linkend="libpq-ssl"/> pour une description sur la configuration
des certificats sur le client.)
  </para>

  <para>
   For a <literal>hostssl</literal> entry with
   <literal>clientcert=verify-ca</literal>, the server will verify
   that the client's certificate is signed by one of the trusted
   certificate authorities. If <literal>clientcert=verify-full</literal>
   is specified, the server will not only verify the certificate
   chain, but it will also check whether the username or its mapping
   matches the <literal>cn</literal> (Common Name) of the provided certificate.
   Note that certificate chain validation is always ensured when the
   <literal>cert</literal> authentication method is used
   (see <xref linkend="auth-cert"/>).
</para>

<para>
Les certificats intermédiaires chaînés jusqu'aux certificats racines existants
peuvent aussi apparaître dans le fichier <filename>root.crt</filename> si vous
souhaitez éviter d'avoir à les stocker sur les clients (en supposant que les
certificats racine et intermédiaires ont été créés avec les extensions
<literal>v3_ca</literal>). Les entrées dans la liste de révocation de
certificats (CRL) sont aussi vérifiées si le paramètre <xref
linkend="guc-ssl-crl-file"/> est configuré.
</para>

<para>
  L'option d'authentification <literal>clientcert</literal> est disponible
  pour toutes les méthodes d'authentification, mais seulement pour les lignes
  du fichier <filename>pg_hba.conf</filename> indiquées avec
  <literal>hostssl</literal>.
  Quand <literal>clientcert</literal> n'est pas
  configuré ou qu'il est configuré à <literal>no-verify</literal>,
  le serveur vérifiera toujours avec son fichier CA tout
  certificat client présenté, s'il est configuré &mdash;
  mais il n'exigera pas qu'un certificat client soit présenté.
  </para>

<para>
   Il y a deux approches pour forcer les utilisateurs à fournir un certificat
   à la connexion.
</para>

<para>
   La première approche fait usage de la méthode d'authentification
   <literal>cert</literal> pour les entrées <literal>hostssl</literal> de
   <filename>pg_hba.conf</filename>, afin que le certificat lui-même soit
   utilisé pour l'authentification tout en fournissant la sécurité de la
   connexion SSL. Voir les détails dans <xref linkend="auth-cert"/>.
   (Il n'est pas nécessaire de spécifier explicitement d'options
   <literal>clientcert</literal> avec la méthode d'authentification
   <literal>cert</literal>.)
   Dans ce cas, le <literal>cn</literal> (<foreignphrase>Common Name</foreignphrase>)
   dans le certificat est comparé au nom d'utilisateur ou au mappage
   applicable.
  </para>

  <para>
   La seconde approche combine n'importe quelle méthode d'authentification
   pour les entrées <literal>hostssl</literal> avec la vérification des
   certificats des clients, en positionnant l'option d'authentification
   <literal>clientcert</literal> à <literal>verify-ca</literal>
   ou <literal>verify-full</literal>.
   La première option ne garantit que la validité du certificat,
   alors que la seconde vérifie aussi que le
   <literal>cn</literal> (<foreignphrase>Common Name</foreignphrase>)
   correspond au nom d'utilisateur ou au mappage applicable.
</para>
</sect2>

<sect2 id="ssl-server-files">
<title>Utilisation des fichiers serveur SSL</title>

<para>
<xref linkend="ssl-file-usage"/> résume les fichiers qui ont un lien
avec la configuration de SSL sur le serveur. (Les noms de fichiers
indiqués sont les noms par défaut. Les noms configurés
localement peuvent être différents.)
</para>

<table id="ssl-file-usage">
<title>Utilisation des fichiers serveur SSL</title>
<tgroup cols="3">
 <thead>
  <row>
   <entry>Fichier</entry>
   <entry>Contenu</entry>
   <entry>Effet</entry>
  </row>
 </thead>

 <tbody>

  <row>
   <entry><xref linkend="guc-ssl-cert-file"/> (<filename>$PGDATA/server.crt</filename>)</entry>
   <entry>certificat du serveur</entry>
   <entry>envoyé au client pour indiquer l'identité du serveur</entry>
  </row>

  <row>
   <entry><xref linkend="guc-ssl-key-file"/> (<filename>$PGDATA/server.key</filename>)</entry>
   <entry>clé privée du serveur</entry>
   <entry>prouve que le certificat serveur est envoyé par son
    propriétaire&nbsp; n'indique pas que le propriétaire du certificat est
    de confiance</entry>
  </row>

  <row>
   <entry><xref linkend="guc-ssl-ca-file"/> (<filename>$PGDATA/root.crt</filename>)</entry>
   <entry>autorités de confiance pour les certificats</entry>
   <entry>vérifie le certificat du client&nbsp;; vérifie que le certificat
    du client est signé par une autorité de confiance</entry>
  </row>

  <row>
   <entry><xref linkend="guc-ssl-crl-file"/> (<filename>$PGDATA/root.crl</filename>)</entry>
   <entry>certificats révoqués par les autorités de confiance</entry>
   <entry>le certificat du client ne doit pas être sur cette liste</entry>
  </row>

 </tbody>
</tgroup>
</table>

<para>
    Le serveur lit ces fichiers lors de son démarrage et à chaque rechargement
    de la configuration serveur. Sur les systèmes
    <systemitem class="osname">Windows</systemitem>, ils sont également relus
    chaque fois qu'un nouveau processus est démarré pour une nouvelle connexion
    client.
   </para>

   <para>
    Si une erreur est détectée dans ces fichiers lors du démarrage du serveur,
    celui-ci refusera de démarrer. Par contre, si une erreur est détectée lors
    d'un rechargement de configuration, ces fichiers seront ignorés et
    l'ancienne configuration SSL continuera d'&ecirc;tre utilisée. Sur les
    systèmes <systemitem class="osname">Windows</systemitem>, si une erreur est
    détectée dans ces fichiers au démarrage d'un processus backend, celui-ci ne
    pourra établir une connexion SSL. Dans tous les cas, l'erreur sera rapportée
    dans les journaux du serveur.
</para>

</sect2>

<sect2 id="ssl-certificate-creation">
+<title>Créer des certificats</title>

 <para>
Pour créer un certificat simple auto-signé pour le serveur, valide pour 365
jours, utilisez la commande <productname>OpenSSL</productname> suivante, en
remplaçant <replaceable>dbhost.yourdomain.com</replaceable> avec le nom d'hôte
du serveur&nbsp;
<programlisting>
openssl req -new -x509 -days 365 -nodes -text -out server.crt \
  -keyout server.key -subj "/CN=<replaceable>dbhost.yourdomain.com</replaceable>"
</programlisting>
Puis, exécutez&nbsp;:
<programlisting>
chmod og-rwx server.key
</programlisting>
car le serveur rejetera le fichier si ses droits sont plus importants. Pour
plus de détails sur la façon de créer la clé privée et le certificat de votre
serveur, référez-vous à la documentation d'<productname>OpenSSL</productname>.
</para>

<para>
Bien qu'un certificat auto-signé puisse être utilisé pour des tests, un
certificat signé par une autorité de certificats (<acronym>CA</acronym>)
(habituellement un <acronym>CA</acronym> racine entreprise) devrait être
utilisé en production.
</para>

<para>
Pour créer un certificat serveur dont l'identité peut être validé par des
clients, créez tout d'abord une demande de signature de certificat
(<acronym>CSR</acronym>) et un fichier clés public/privé&nbsp;:
<programlisting>
openssl req -new -nodes -text -out root.csr \
  -keyout root.key -subj "/CN=<replaceable>root.yourdomain.com</replaceable>"
chmod og-rwx root.key
</programlisting>
Puis, signez la demande avec la clé pour créer une autorité de certificat
racine (en utilisant l'emplacement du fichier de configuration
<productname>OpenSSL</productname> par défaut sur
<productname>Linux</productname>)&nbsp;:
<programlisting>
openssl x509 -req -in root.csr -text -days 3650 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -signkey root.key -out root.crt
</programlisting>
Enfin, créez un certificat serveur signé par la nouvelle autorité de
certificat racine&nbsp;:
<programlisting>
openssl req -new -nodes -text -out server.csr \
  -keyout server.key -subj "/CN=<replaceable>dbhost.yourdomain.com</replaceable>"
chmod og-rwx server.key

openssl x509 -req -in server.csr -text -days 365 \
  -CA root.crt -CAkey root.key -CAcreateserial \
  -out server.crt
</programlisting>
<filename>server.crt</filename> et <filename>server.key</filename> doivent
être stockés sur le serveur, et <filename>root.crt</filename> doit être stocké
sur le client pour que le client puisse vérifier que le certificat feuille du
serveur a été signé par son propre certificat racine de confiance.
<filename>root.key</filename> doit être enregistré hors ligne pour l'utiliser
pour créer les prochains certificats.
</para>

<para>
Il est aussi possible de créer une chaîne de confiance qui inclut les
certificats intermédiaires&nbsp;:
<programlisting>
# root
openssl req -new -nodes -text -out root.csr \
  -keyout root.key -subj "/CN=<replaceable>root.yourdomain.com</replaceable>"
chmod og-rwx root.key
openssl x509 -req -in root.csr -text -days 3650 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -signkey root.key -out root.crt

# intermediate
openssl req -new -nodes -text -out intermediate.csr \
  -keyout intermediate.key -subj "/CN=<replaceable>intermediate.yourdomain.com</replaceable>"
chmod og-rwx intermediate.key
openssl x509 -req -in intermediate.csr -text -days 1825 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -CA root.crt -CAkey root.key -CAcreateserial \
  -out intermediate.crt

# leaf
openssl req -new -nodes -text -out server.csr \
  -keyout server.key -subj "/CN=<replaceable>dbhost.yourdomain.com</replaceable>"
chmod og-rwx server.key
openssl x509 -req -in server.csr -text -days 365 \
  -CA intermediate.crt -CAkey intermediate.key -CAcreateserial \
  -out server.crt
</programlisting>
<filename>server.crt</filename> et <filename>intermediate.crt</filename>
doivent être concaténés dans un fichier certificat et stocké sur le serveur.
<filename>server.key</filename> doit aussi être stocké sur le serveur.
<filename>root.crt</filename> doit être stocké sur le client pour que le
client puisse vérifier que le certificat feuille du serveur a été signé par
une chaîne de certificats liés au certificat racine de confiance.
<filename>root.key</filename> et <filename>intermediate.key</filename> doivent
être stockées hors ligne pour être utilisé dans la création des certificats
futurs.
</para>
</sect2>
</sect1>

 <sect1 id="gssapi-enc">
  <title>Connexions TCP/IP sécurisées avec le chiffrage GSSAPI</title>

  <indexterm zone="gssapi-enc">
   <primary>gssapi</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> a aussi un support natif de
   <acronym>GSSAPI</acronym> pour améliorer la sécurité en chiffrant
   les communications client/serveur.
   Cela requiert que soit installée une implémentation de
   <acronym>GSSAPI</acronym> (comme MIT krb5) à la fois sur le client et
   le serveur, et que le support dans <productname>PostgreSQL</productname>
   soit activé à la compilation (voir <xref linkend="installation"/>).
  </para>

  <sect2 id="gssapi-setup">
   <title>Mise en place de base</title>

   <para>
    Le serveur <productname>PostgreSQL</productname> écoutera
    sur le même port TCP à la fois les connexions normales
    et celles chiffrées par <acronym>GSSAPI</acronym>, et négociera
    avec chaque client désirant se connecter s'il faut utiliser
    <acronym>GSSAPI</acronym> pour le chiffrage (et l'authentification).
    Par défaut, cette décision est celle du client (ce qui signifie
    qu'un attaquant peut en dégrader le niveau)&nbsp;; voir
    <xref linkend="auth-pg-hba-conf"/> sur comment configurer le serveur
    pour exiger l'utilisation de <acronym>GSSAPI</acronym> pour tout ou
    partie des connexions.
   </para>

   <para>
    À part la configuration de cette négociation, <acronym>GSSAPI</acronym>
    ne requiert aucune configuration au-delà de ce qui est nécessaire pour
    l'authentification GSSAPI. (Pour plus d'informations sur sa mise
    en place, voir <xref linkend="gssapi-auth"/>.)
   </para>
  </sect2>
 </sect1>

<sect1 id="ssh-tunnels">
<title>Connexions TCP/IP sécurisées avec des tunnels
<application>ssh</application> tunnels</title>

<indexterm zone="ssh-tunnels">
<primary>ssh</primary>
</indexterm>

<para>
Il est possible d'utiliser <application>ssh</application> pour chiffrer la
connexion réseau entre les clients et un serveur
<productname>PostgreSQL</productname>. Réalisé correctement, ceci fournit une
connexion réseau sécurisée, y compris pour les clients non SSL.
</para>

<para>
Tout d'abord, assurez-vous qu'un serveur <application>ssh</application> est
en cours d'exécution sur la même machine que le serveur
<productname>PostgreSQL</productname> et que vous pouvez vous connecter via
<command>ssh</command> en tant qu'un utilisateur quelconque. Ensuite, vous
pouvez établir un tunnel sécurisé avec une commande comme ceci sur la machine
cliente&nbsp;:
<programlisting>ssh -L 63333:localhost:5432 joe@foo.com</programlisting>
   Le premier numéro de l'argument <option>-l</option>, 63333, est le numéro de
   port de votre bout du tunnel&nbsp;; il peut être choisi parmi tous les ports
   non utilisés.
   (IANA réserve les ports 49152 à 65535 pour une utilisation privée.)  Le second
   numéro, 5432, est le bout distant du tunnel&nbsp;: le numéro de port que votre
   serveur utilise. Le nom ou l'adresse entre les numéros de port est l'hôte
   disposant du serveur de bases de données auquel vous souhaitez vous connecter,
   comme vu à partir de l'hôte où vous vous connectez, qui est
   <literal>foo.com</literal> dans cet exemple. Pour vous connecter au serveur
   en utilisant ce tunnel, vous vous connectez au port 63333 de la machine
   locale&nbsp;:
<programlisting>psql -h localhost -p 63333 postgres</programlisting>
   Sur le serveur de bases de données, il semblera que vous êtes réellement
   l'utilisateur <literal>joe</literal> sur l'hôte <literal>foo.com</literal>
   en vous connectant à <literal>localhost</literal> dans ce contexte, et il
   utilisera la procédure d'authentification configurée pour les connexions
   de cet utilisateur et de cet hôte. Notez que le serveur ne pensera pas que
   la connexion est chiffrée avec SSL car, en effet, elle n'est pas chiffrée
   entre le serveur <application>SSH</application> et le serveur
   <productname>PostgreSQL</productname>. Cela ne devrait pas poser un risque
   de sécurité supplémentaire si les deux serveurs sont sur la même machine.
  </para>

  <para>
   Pour réussir la configuration du tunnel, vous devez être autorisé pour vous
   connecter via <command>ssh</command> sur <literal>joe@foo.com</literal>,
   comme si vous aviez tenté d'utiliser <command>ssh</command> pour créer
   une session de terminal.
  </para>

  <para>
   Vous pouvez aussi configurer la translation de port de cette façon&nbsp;:
<programlisting>
ssh -L 63333:foo.com:5432 joe@foo.com
</programlisting>
mais alors le serveur de la base de données verra la connexion venir de
son interface <literal>foo.com</literal> qui n'est pas ouverte par son
paramétrage par défaut <literal>listen_addresses =
'localhost'</literal>. Ceci n'est pas habituellement ce que vous êtes.
</para>

<para>
Si vous devez vous connecter au serveur de bases de données via un hôte de
connexion, une configuration possible serait&nbsp;:
<programlisting>
ssh -L 63333:db.foo.com:5432 joe@shell.foo.com
</programlisting>
Notez que de cette façon la connexion de <literal>shell.foo.com</literal>
à <literal>db.foo.com</literal> ne sera pas chiffrée par le tunnel SSH.
SSH offre un certain nombre de possibilités de configuration quand le
réseau est restreint. Merci de vous référer à la documentation de SSH pour
les détails.
</para>

<tip>
<para>
Plusieurs autres applications existantes peuvent fournir des tunnels
sécurisés en utilisant une procédure similaire dans le concept à celle que
nous venons de décrire.
</para>
</tip>

</sect1>

<sect1 id="event-log-registration">
<title>Enregistrer le <application>journal des événements</application> sous <systemitem
class="osname">Windows</systemitem></title>

<indexterm zone="event-log-registration">
<primary>journal des événements</primary>
<secondary>journal des événements</secondary>
</indexterm>

<para>
Pour enregistrer une bibliothèque pour le <application>journal des
événements</application> de <systemitem class="osname">Windows</systemitem>,
lancez la commande&nbsp;:
<screen>
<userinput>regsvr32 <replaceable>répertoire_bibliothèques_postgres</replaceable>/pgevent.dll</userinput>
</screen>
Ceci crée les clés de registre utilisé par le visualisateur des événements,
sous la source d'événement par défaut, nommée <literal>PostgreSQL</literal>.
</para>

<para>
Pour indiquer un nom de source différent (voir
<xref linkend="guc-event-source"/>), utilisez les options <literal>/n</literal>
et <literal>/i</literal>&nbsp;:
<screen>
<userinput>regsvr32 /n /i:<replaceable>nom_source_evenement</replaceable> <replaceable>répertoire_bibliothèques_postgres</replaceable>/pgevent.dll</userinput>
</screen>
</para>

<para>
Pour désenregistrer la bibliothèque du <application>journal des
événements</application> de <systemitem class="osname">Windows</systemitem>,
lancez la commande&nbsp;:
<screen>
<userinput>regsvr32 /u [/i:<replaceable>nom_source_evenement</replaceable>] <replaceable>répertoire_bibliothèques_postgres</replaceable>/pgevent.dll</userinput>
</screen>
</para>

<note>
<para>
Pour activer la journalisation des événements dans le serveur de base de
données, modifiez <xref linkend="guc-log-destination"/> pour include
<literal>eventlog</literal> dans <filename>postgresql.conf</filename>.
</para>
</note>
</sect1>

</chapter>
