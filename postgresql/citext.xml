<?xml version="1.0" encoding="UTF-8"?>
<sect1 id="citext" xreflabel="citext">
 <title>citext</title>

 <indexterm zone="citext">
  <primary>citext</primary>
 </indexterm>

 <para>
  Le module <filename>citext</filename> fournit un type chaîne de caratères
  insensible à la casse, <type>citext</type>. En réalité, il appelle en interne
  la fonction <function>lower</function> lorsqu'il compare des valeurs. Dans
  les autres cas, il se comporte presque exactement comme le type
  <type>text</type>.
 </para>

 <sect2>
  <title>Intérêt</title>

  <para>
      L'approche standard pour effectuer des rapprochements insensibles à 
      la casse avec <productname>PostgreSQL</productname> était d'utiliser la fonction
      <function>lower</function> pour comparer des valeurs. Par exemple&nbsp;:

  <programlisting>
   SELECT * FROM tab WHERE lower(col) = LOWER(?);
  </programlisting>
  </para>

  <para>
   Ceci fonctionne plutôt bien, mais présente quelques inconvénients&nbsp;:	  
  </para>

   <itemizedlist>
    <listitem>
     <para>
      Cela rend les ordres SQL bavards, et vous devez sans arrêt vous souvenir
      d'utiliser la fonction <function>lower</function> à la fois sur la
      colonne et la valeur de la requête.
     </para>
    </listitem>
    <listitem>
     <para>
      Cela n'utilise pas les index, à moins que vous ne créiez un index
      fonctionnel avec la fonction <function>lower</function>.
     </para>
    </listitem>
    <listitem>
     <para>
      Si vous déclarez une colonne  <literal>UNIQUE</literal> ou <literal>PRIMARY
      KEY</literal>, l'index généré implicitement est sensible à la casse. Il
      est donc inutile pour des recherches insensibles à la casse, et il ne va
      pas garantir l'unicité de manière insensible à la casse.
     </para>
    </listitem>
   </itemizedlist>

   <para>
    Le type de données <type>citext</type> vous permet d'éviter les appels à
    <function>lower</function> dans les requêtes SQL, et peut rendre une clé
    primaire insensible à la casse. <type>citext</type> tient compte de la
    locale, comme <type>text</type>, ce qui signifie que la comparaison entre
    caractères majuscules et minuscules dépend des règles de la locale
    paramétrée par <literal>LC_CTYPE</literal> de la base de données.
    Ici également, le comportement est identique à l'utilisation de la
    fonction <function>lower</function> dans les requêtes. Mais comme cela est fait de
    manière transparente par le type de données, vous n'avez pas à vous souvenir
    de faire quelque chose de particulier dans vos requêtes.
   </para>

 </sect2>

 <sect2>
  <title>Comment l'utiliser</title>

  <para>
   Voici un exemple simple d'utilisation&nbsp;:

  <programlisting>
   CREATE TABLE users (
       nick CITEXT PRIMARY KEY,
       pass TEXT   NOT NULL
   );

   INSERT INTO users VALUES ( 'larry',  md5(random()::text) );
   INSERT INTO users VALUES ( 'Tom',    md5(random()::text) );
   INSERT INTO users VALUES ( 'Damian', md5(random()::text) );
   INSERT INTO users VALUES ( 'NEAL',   md5(random()::text) );
   INSERT INTO users VALUES ( 'Bj&oslash;rn',  md5(random()::text) );

   SELECT * FROM users WHERE nick = 'Larry';
  </programlisting>

   L'ordre <command>SELECT</command> va renvoyer un enregistrement, bien que
   la colonne <structfield>nick</structfield> ait été positionnée à
   <literal>larry</literal> et que la requête soit pour
   <literal>Larry</literal>.
  </para>
 </sect2>

 <sect2>
  <title>Comportement des comparaisons de chaînes</title>

  <para>
   <type>citext</type> réalise des comparaisons en convertissant chaque chaîne
   en minuscule (comme si <function>lower</function> avait été appelé) puis en
   comparant normalement les résultats. Du coup, deux chaînes sont considérées
   égales si <function>lower</function> donne un résultat identique pour elles.
  </para>

  <para>
   Afin d'émuler un tri insensible à la casse de la manière la plus 
   fidèle possible, il existe des versions spécifiques à <type>citext</type> 
   de plusieurs opérateurs et fonctions de traitement de chaînes.
   Ainsi, par exemple, les opérateurs pour les expressions rationnelles
   <literal>~</literal> and <literal>~*</literal> ont le même comportement quand
   ils sont appliqués au type <type>citext</type>&nbsp;: ils comparent tous
   les deux de manière insensible à la casse.
   Cela est aussi vraie pour <literal>!~</literal> et <literal>!~*</literal>, 
   et également pour les opérateurs
   <literal>LIKE</literal>, <literal>~~</literal>,
   <literal>~~*</literal>, et
   <literal>!~~</literal> et <literal>!~~*</literal>. Si vous voulez faire une
   comparaison sensible à la casse, vous pouvez convertir dans un
   <type>text</type>.
  </para>

  <para>
   De la même façon, toutes les fonctions ci-dessous font une comparaison insensible à la casse
   si leurs arguments sont de type <type>citext</type>&nbsp;:
  </para>

  <itemizedlist>
   <listitem>
    <para>
      <function>regexp_matches()</function>
    </para>
   </listitem>
   <listitem>
    <para>
      <function>regexp_replace()</function>
    </para>
   </listitem>
   <listitem>
    <para>
      <function>regexp_split_to_array()</function>
    </para>
   </listitem>
   <listitem>
    <para>
      <function>regexp_split_to_table()</function>
    </para>
   </listitem>
   <listitem>
    <para>
      <function>replace()</function>
    </para>
   </listitem>
   <listitem>
    <para>
      <function>split_part()</function>
    </para>
   </listitem>
   <listitem>
    <para>
      <function>strpos()</function>
    </para>
   </listitem>
   <listitem>
    <para>
      <function>translate()</function>
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Pour les fonctions regexp, si vous voulez effectuer des comparaisons 
   sensibles à la casse, vous pouvez positionner l'indicateur <quote>c</quote>
   pour forcer une comparaison sensible à la casse.  Sinon, si vous souhaitez
   un comportement sensible à la casse, vous devez convertir dans un type 
   <type>text</type> avant d'utiliser une de ces fonctions.
  </para>

 </sect2>

 <sect2>
  <title>Limitations</title>

   <itemizedlist>
    <listitem>
     <para>
      Le comportement de <type>citext</type> sur la sensibilité à la
      casse dépend du paramètre
      <literal>LC_CTYPE</literal> de votre base de données. Par conséquent,
      la manière dont il compare les valeurs est fixée lorsque la base
      de données est créée.
      Il n'est pas réellement insensible à la casse dans les termes définis par
      le standard Unicode.
      En pratique, ce que cela signifie est que, tant que vous êtes satisfait 
      de votre tri, vous devriez être satisfait des comparaisons de
      <type>citext</type>. Mais si vous avez des données stockées dans
      différentes langues dans votre base, des utilisateurs de certains langages
      pourraient trouver que les résultats de leurs requêtes sont inattendus
      si le tri est déterminé pour un autre langage.
     </para>
    </listitem>

    <listitem>
     <para>
      À partir de <productname>PostgreSQL</productname>, vous pouvez attacher
      une clause <literal>COLLATE</literal> aux colonnes <type>citext</type>
      ou à une valeur. Actuellement, les opérateurs <type>citext</type> honoreront
      une valeur <literal>COLLATE</literal> différente de la valeur par défaut lors
      de la comparaison de chaînes. Par contre, la mise en minuscule se fait
      toujours à partir de la configuration <literal>LC_CTYPE</literal> de la
      base de données (c'est-à-dire comme si <literal>COLLATE "default"</literal>
      avait été donné). Cela pourrait changer dans une prochaine version pour que
      les deux étapes suivent la clause <literal>COLLATE</literal>
      specification.
     </para>
    </listitem>

    <listitem>
     <para>
       <type>citext</type> n'est pas aussi performant que <type>text</type> parce que
       les fonctions opérateurs et les fonctions de comparaison B-tree
       doivent faire des copies des données et les convertir en minuscules pour les 
       comparaisons. C'est cependant légèrement plus efficace qu'utiliser 
       <function>lower</function> pour obtenir des comparaisons insensibles à la casse.
     </para>
    </listitem>

    <listitem>
     <para>
      <type>citext</type> n'aide pas réellement dans un certain conctexte.
      Vos données doivent être comparées de manière sensible à la casse dans
      certains contextes, et de manière sensible à la casse dans d'autres
      contextes. La réponse habituelle à cette question est d'utiliser le type
      <type>text</type> et d'utiliser manuellement la fonction
      <function>lower</function> lorsque vous avez besoin d'une comparaison
      insensible à la casse&nbsp;; ceci fonctionne très bien si vous avez besoin
      peu fréquemment  de comparaisons insensibles à la casse. Si vous avez
      besoin de comparaisons insensibles à la casse la plupart du temps, pensez
      à stocker les données en <type>citext</type> et à convertir explicitement
      les colonnes en <type>text</type> quand vous voulez une comparaison
      sensible à la casse. Dans les deux situations, vous aurez besoin de deux
      index si vous voulez que les deux types de  recherche soient rapides.
    </para>
    </listitem>

    <listitem>
     <para>
      Le schéma contenant les opérateurs <type>citext</type> doit être dans
      le <varname>search_path</varname> (généralement
      <literal>public</literal>)&nbsp;; dans le cas contraire, les
      opérateurs <type>text</type> sensibles à la casse seront
      appelés.
    </para>
    </listitem>
   </itemizedlist>
 </sect2>

 <sect2>
  <title>Auteur</title>

  <para>
   David E. Wheeler <email>david@kineticode.com</email>
  </para>

  <para>
    Inspiré par le module original <type>citext</type> par Donald Fraser.
  </para>

 </sect2>

</sect1>
