<?xml version="1.0" encoding="UTF-8"?>
<chapter id="typeconv">
 <title>Conversion de types</title>

 <indexterm zone="typeconv">
  <primary>type de données</primary>
  <secondary>conversion</secondary>
 </indexterm>

 <para>
  Le mélange de différents types de données dans la même expression peut être
  requis, intentionnellement ou pas, par les instructions
  <acronym>SQL</acronym>. <productname>PostgreSQL</productname> possède des
  fonctionnalités étendues pour évaluer les expressions de type mixte.
 </para>

 <para>
  Dans la plupart des cas, un utilisateur n'aura pas besoin de comprendre les
  détails du mécanisme de conversion des types. Cependant, les conversions
  implicites faites par <productname>PostgreSQL</productname> peuvent affecter
  le résultat d'une requête. Quand cela est nécessaire, ces résultats peuvent
  être atteints directement en utilisant la conversion
  <emphasis>explicite</emphasis> de types.
 </para>

 <para>
  Ce chapitre introduit les mécanismes et les conventions sur les conversions
  de types dans <productname>PostgreSQL</productname>. Référez-vous aux
  sections appropriées du <xref linkend="datatype"/> et du <xref
  linkend="functions"/> pour plus d'informations sur les types de données
  spécifiques, les fonctions et les opérateurs autorisés.
 </para>

 <sect1 id="typeconv-overview">
  <title>Aperçu</title>

  <para>
   <acronym>SQL</acronym> est un langage fortement typé. C'est-à-dire que chaque
   élément de données est associé à un type de données qui détermine son
   comportement et son utilisation permise. <productname>PostgreSQL</productname>
   a un système de types extensible qui est beaucoup plus général et flexible que
   les autres implémentations de <acronym>SQL</acronym>.  Par conséquent, la
   plupart des comportements de conversion de types dans
   <productname>PostgreSQL</productname> est régie par des règles générales plutôt
   que par une heuristique <foreignphrase>ad hoc</foreignphrase>. Cela permet aux
   expressions de types mixtes d'être significatives, même avec des types définis
   par l'utilisateur.
  </para>

  <para>
   L'analyseur de <productname>PostgreSQL</productname> divise les éléments
   lexicaux en cinq catégories fondamentales&nbsp;:
   les entiers, les nombres non entiers, les chaînes de caractères, les
   identifieurs et
   les mots-clés.  Les constantes de la plupart des types non numériques
   sont d'abord classifiées comme chaînes de caractères. La définition du
   langage <acronym>SQL</acronym> permet de spécifier le nom des types
   avec une chaîne et ce mécanisme peut être utilisé dans
   <productname>PostgreSQL</productname> pour lancer l'analyseur sur le
   bon chemin. Par exemple, la requête&nbsp;:

   <screen>SELECT text 'Origin' AS "label", point '(0,0)' AS "value";

 label  | value
--------+-------
 Origin | (0,0)
(1 row)</screen>

a deux constantes littérales, de types <type>text</type> et
<type>point</type>. Si un type n'est pas spécifié pour une chaîne
littérale, alors le type <type>unknown</type> est assigné
initialement pour être résolu dans les étapes ultérieures comme décrit
plus bas.
</para>

<para>
Il y a quatre constructions <acronym>SQL</acronym> fondamentales
qui exigent des règles distinctes de conversion de types dans l'analyseur
de <productname>PostgreSQL</productname>&nbsp;:

<variablelist>
<varlistentry>
<term>
Les appels de fonctions
</term>
<listitem>
<para>
Une grande partie du système de types de
<productname>PostgreSQL</productname> est construite autour d'un riche
ensemble de fonctions.  Les fonctions peuvent avoir un ou
plusieurs arguments. Puisque 
<productname>PostgreSQL</productname> permet la surcharge des
fonctions, le nom seul de la fonction n'identifie pas de manière unique la
fonction à appeler&nbsp;; l'analyseur doit sélectionner la bonne fonction
par rapport aux types des arguments fournis.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
Les opérateurs
</term>
<listitem>
<para>
<productname>PostgreSQL</productname> autorise les expressions avec
des opérateurs de préfixe et de suffixe unaires (un argument) aussi bien
que binaires (deux arguments). Comme les fonctions, les opérateurs peuvent être
surchargés. Du coup, le même problème existe pour sélectionner le bon opérateur.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
Le stockage des valeurs
</term>
<listitem>
<para>
Les instructions <acronym>SQL</acronym> <command>INSERT</command> et
<command>UPDATE</command> placent le résultat des expressions dans
une table. Les expressions dans une instruction doivent être en accord avec
le type des colonnes cibles et peuvent être converties vers celles-ci.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
Les constructions <literal>UNION</literal>, <literal>CASE</literal> et des
constructions relatives
</term>
<listitem>
<para>
Comme toutes les requêtes issues d'une instruction
<command>SELECT</command> utilisant une union doivent apparaître dans
un ensemble unique de colonnes, les types de résultats de chaque
instruction <command>SELECT</command> doivent être assortis et convertis en un
ensemble uniforme.  De façon similaire, les expressions de résultats d'une
construction <literal>CASE</literal> doivent être converties vers un type commun
de façon à ce que l'ensemble de l'expression <literal>CASE</literal> ait un
type de sortie connu.  Cela est la même chose pour les constructions
avec <literal>ARRAY</literal> et pour les fonctions <function>GREATEST</function>
et <function>LEAST</function>.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<para>
Les catalogues systèmes stockent les informations concernant l'existence de
conversions entre certains types de données et la façon
d'exécuter ces conversions.  Les conversions sont appelées
<firstterm>casts</firstterm> en anglais. Des conversions de types
supplémentaires peuvent être ajoutées par l'utilisateur avec la commande
<xref linkend="sql-createcast"/> (c'est
habituellement réalisé en
conjonction avec la définition de nouveaux types de données.
L'ensemble des conversions entre les types prédéfinis a été
soigneusement choisi et le mieux est de ne pas le modifier).
</para>

<indexterm>
 <primary>type de données</primary>
 <secondary>catégorie</secondary>
</indexterm>

<para>
Une heuristique supplémentaire est fournie dans l'analyseur pour permettre de
meilleures estimations sur la bonne conversion de type parmi un groupe de types
qui ont des conversions implicites. Les types de données sont divisés en
plusieurs <firstterm>catégories de type</firstterm> basiques, incluant
<type>boolean</type>, <type>numeric</type>, <type>string</type>,
<type>bitstring</type>, <type>datetime</type>, <type>timespan</type>,
<type>geometric</type>, <type>network</type> et définis par l'utilisateur.
(Pour une liste, voir <xref linkend="catalog-typcategory-table"/>&nbsp;; mais
notez qu'il est aussi possible de créer des catégories de type personnalisées.)
À l'intérieur de chaque catégorie, il peut y avoir un ou plusieurs
<firstterm>types préférés</firstterm>, qui sont sélectionnés quand il y a un
choix possible de types. Avec une sélection attentive des types
préférés et des conversions implicites disponibles, il est possible de s'assurer
que les expressions ambiguës (celles avec plusieurs solutions candidates) peuvent
être résolues d'une façon utile.
</para>

<para>
Toutes les règles de conversions de types sont écrites en gardant à l'esprit
plusieurs principes&nbsp;:

<itemizedlist>
<listitem>
<para>
Les conversions implicites ne doivent jamais avoir de résultats
surprenants ou imprévisibles.
</para>
</listitem>

<listitem>
<para>
Il n'y aura pas de surcharge depuis l'analyseur ou l'exécuteur si une
requête n'a pas besoin d'une conversion implicite de types.  C'est-à-dire que
si une requête est bien formulée et si les types sont déjà bien distinguables,
alors la requête devra s'exécuter sans perte de temps supplémentaire et sans
introduire à l'intérieur de celle-ci des appels à des conversions
implicites non nécessaires.
</para>
</listitem>

<listitem>
<para>
De plus, si une requête nécessite habituellement une conversion
implicite pour une fonction et si l'utilisateur définit une nouvelle
fonction avec les types des arguments corrects, l'analyseur devrait
utiliser cette nouvelle fonction et ne fera plus des conversions
implicites en utilisant l'ancienne fonction.
</para>
</listitem>
</itemizedlist>
</para>

</sect1>

<sect1 id="typeconv-oper">
<title>Opérateurs</title>

<indexterm zone="typeconv-oper">
 <primary>opérateur</primary>
 <secondary>résolution de types dans un appel</secondary>
</indexterm>

  <para>
   L'opérateur spécifique qui est référencé par une expression d'opérateur
   est déterminé par la procédure ci-dessous. Notez que cette procédure est
   indirectement affectée par l'ordre d'insertion des opérateurs, car cela va
   déterminer les sous-expressions prises en entrée des opérateurs. Voir la
   <xref linkend="sql-precedence"/> pour plus d'informations.
  </para>

<procedure>
<title>Résolution de types pour les opérateurs</title>

<step id="op-resol-select" performance="required">
<para>
Sélectionner les opérateurs à examiner depuis le catalogue système
<classname>pg_operator</classname>.  Si un nom non qualifié
d'opérateur est utilisé (le cas habituel), les opérateurs examinés
sont ceux avec un nom et un nombre d'arguments corrects et qui sont
visibles dans le chemin de recherche courant (voir la
<xref linkend="ddl-schemas-path"/>).  Si un nom qualifié d'opérateur
a été donné, seuls les opérateurs dans le schéma spécifié sont
examinés.
</para>

<substeps>
<step performance="optional">
<para>
Si un chemin de recherche trouve de nombreux opérateurs avec des types
d'arguments identiques, seul sera examiné celui apparaissant le plus tôt dans
le chemin. Mais les opérateurs avec des types d'arguments différents sont
examinés sur une base d'égalité indépendamment de leur position dans le chemin
de recherche.
</para>
</step>
</substeps>
</step>

<step id="op-resol-exact-match" performance="required">
<para>
Vérifier que l'opérateur accepte le type exact des arguments en
entrée.  Si un opérateur existe (il peut y en avoir uniquement un qui
corresponde exactement dans l'ensemble des opérateurs considérés),
utiliser cet opérateur. Le manque de correspondance exacte crée
un risque de sécurité lors de l'appel, via un nom qualifié
  <footnote id="op-qualified-security">
   <!-- If you edit this, consider editing func-qualified-security. -->
   <para>
    Le risque ne vient pas d'un nom sans qualification de schéma, parce qu'un
    chemin de recherche contenant des schémas permettant à des utilisateurs
    sans confiance de créer des objets n'est pas un <link
    linkend="ddl-schemas-patterns">modèle d'utilisation sécurisée des
    schémas</link>.
   </para>
  </footnote>
(inhabituel), tout opérateur trouvé dans un schéma permettant à des
utilisateurs sans confiance de créer des objets. Dans de telles situations,
convertir les arguments pour forcer une correspondance exacte.
</para>

<substeps>
<step id="op-resol-exact-unknown" performance="optional">
<para>
Si un argument lors d'une invocation d'opérateur binaire est de type
<type>unknown</type> (NdT&nbsp;: inconnu), alors considérer pour ce contrôle
que c'est le même type que l'autre argument.  Les invocations impliquant deux
entrées de type <type>unknown</type>, ou un opérateur unaire avec en entrée
une donnée de type <type>unknown</type> ne trouveront jamais une correspondance
à ce niveau.
</para>
</step>
<step id="op-resol-exact-domain" performance="optional">
<para>
Si un argument d'un opérateur binaire est de type <type>unknown</type> et que
l'autre est un domaine, vérifier ensuite s'il existe un opérateur qui accepte
le type de base du domaine des deux côtés&nbsp;; si c'est le cas, l'utiliser.
</para>
</step>
</substeps>
</step>

<step id="op-resol-best-match" performance="required">
<para>
Rechercher la meilleure correspondance.
</para>
<substeps>
<step performance="required">
<para>
Se débarrasser des opérateurs candidats pour lesquels les types en
entrée ne correspondent pas et qui ne peuvent pas être convertis (en
utilisant une conversion implicite) dans le type correspondant.
Le type <type>unknown</type> est supposé être convertible vers tout.
Si un candidat reste, l'utiliser, sinon aller à la
prochaine étape.
</para>
</step>
<step performance="required">
<para>
Si l'argument en entrée est d'un type de domaine, le traiter comme étant
le type de base du domaine pour les étapes suivantes. Ceci nous assure
que les domaines se comportent comme leur type de base pour la résolution
d'opérateurs ambigus.
</para>
</step>
<step performance="required">
<para>
Parcourir tous les candidats et garder ceux avec la correspondance la
plus exacte par rapport aux types en entrée.
Garder tous les candidats si aucun n'a de correspondance exacte. Si
un seul candidat reste, l'utiliser&nbsp;; sinon, aller à la prochaine
étape.
</para>
</step>
<step performance="required">
<para>
Parcourir tous les candidats et garder ceux qui acceptent les types
préférés (de la catégorie des types de données en entrée) aux positions
où la conversion de types aurait été requise.
Garder tous les candidats si aucun n'accepte les types préférés. Si
seulement un candidat reste, l'utiliser&nbsp;; sinon aller à la prochaine
étape.
</para>
</step>
<step performance="required">
<para>
Si des arguments en entrée sont <type>unkown</type>, vérifier la
catégorie des types acceptés à la position de ces arguments par les
candidats restants. À chaque position, sélectionner la catégorie
<type>chaîne de caractères</type> si un des candidats accepte cette
catégorie (cette préférence vers les chaînes de caractères est
appropriée, car le terme type-inconnu ressemble à une chaîne de
caractères).  Dans le cas contraire, si tous les candidats restants
acceptent la même catégorie de types, sélectionner cette catégorie.
Dans le cas contraire, échouer, car le choix correct ne peut pas être
déduit sans plus d'indices.  Se débarrasser maintenant des candidats qui
n'acceptent pas la catégorie sélectionnée. De plus, si des candidats
acceptent un type préféré de cette catégorie, se débarrasser des
candidats qui acceptent, pour cet argument, les types qui ne sont pas
préférés.
Conserver tous les candidats si aucun ne survit à ces tests. Si un
candidat survit, utilisez-le&nbsp;; sinon continuer avec l'étape suivante.
</para>
</step>
<step id="op-resol-last-unknown" performance="required">
<para>
S'il y a des arguments à la fois <type>unkown</type> et connus, et que tous
les arguments de type connu ont le même type, supposer que les arguments
<type>unkown</type> sont de ce même type, et vérifier les candidats
qui acceptent ce type aux positions des arguments de type <type>unknown</type>.
Si un seul candidat réussit ce test, l'utiliser. Sinon, échec.
</para>
</step>
</substeps>
</step>
</procedure>

<para>
Quelques exemples suivent.
</para>

<example>
<title>Résolution du type d'opérateur racine carrée</title>

<para>
Il n'existe qu'un seul opérateur racine carrée (préfixe <literal>|/</literal>)
défini dans le catalogue standard. Il prend un argument de type <type>double
precision</type>. Le scanner affecte au début le type <type>integer</type> à
l'argument dans cette expression&nbsp;:
<screen>
SELECT |/ 40 AS "square root of 40";
 square root of 40
-------------------
 6.324555320336759
</screen>

   L'analyseur fait donc une conversion de types sur l'opérande et
   la requête est équivalente à

   <screen>SELECT |/ CAST(40 AS double precision) AS "square root of 40"</screen>
</para>
</example>

<example>
<title>Résolution de types pour les opérateurs de concaténation de chaînes</title>

<para>
La syntaxe d'une chaîne de caractères est utilisée pour travailler avec
les types chaînes, mais aussi avec les types d'extensions complexes.
Les chaînes de caractères avec un type non spécifié sont comparées avec
les opérateurs candidats probables.
</para>

<para>
Un exemple avec un argument non spécifié&nbsp;:
<screen>SELECT text 'abc' || 'def' AS "text and unknown";

 text and unknown
------------------
 abcdef
(1 row)</screen>
</para>

<para>
Dans ce cas, l'analyseur cherche à voir s'il existe un opérateur
prenant <type>text</type> pour ses deux arguments.  Comme il y en a,
il suppose que le second argument devra être interprété comme un type
<type>text</type>.
</para>

<para>
Voici une concaténation sur des valeurs de type non spécifié&nbsp;:
<screen>SELECT 'abc' || 'def' AS "unspecified";

 unspecified
-------------
 abcdef
(1 row)</screen>
</para>

<para>
Dans ce cas, il n'y a aucune allusion initiale sur le type à utiliser
puisqu'aucun type n'est spécifié dans la requête.  Donc, l'analyseur
regarde tous les opérateurs candidats et trouve qu'il existe des
candidats acceptant en entrée la catégorie chaîne de caractères
(string) et la catégorie morceaux de chaînes (bit-string).  Puisque la
catégorie chaînes de caractères est préférée quand elle est disponible,
cette catégorie est sélectionnée. Le type préféré pour la catégorie
chaînes étant <type>text</type>, ce type est utilisé comme le type
spécifique pour résoudre les types inconnus.
</para>
</example>

<example>
<title>Résolution de types pour les opérateurs de valeur absolue et de négation</title>

<para>
Le catalogue d'opérateurs de <productname>PostgreSQL</productname> a
plusieurs entrées pour l'opérateur de préfixe <literal>@</literal>. Ces entrées
implémentent toutes des opérations de valeur absolue pour des types variés de
données numériques.  Une de ces entrées est pour le type
<type>float8</type> (réel) qui est le type préféré dans la catégorie
des numériques.  Par conséquent, <productname>PostgreSQL</productname>
utilisera cette entrée quand il sera en face d'un argument de type
<type>unknown</type>&nbsp;:
<screen>SELECT @ '-4.5' AS "abs";
 abs
-----
 4.5
(1 row)</screen>
Le système a compris implicitement que le littéral de type
<type>unknown</type> est de type <type>float8</type> (réel) avant d'appliquer l'opérateur choisi. Nous
pouvons vérifier que <type>float8</type>, et pas un autre type, a été
utilisé&nbsp;:
<screen>SELECT @ '-4.5e500' AS "abs";

ERROR:  "-4.5e500" is out of range for type double precision</screen>
</para>

<para>
D'un autre côté, l'opérateur préfixe <literal>~</literal> (négation bit par bit) est
défini seulement pour les types entiers et non pas pour
<type>float8</type> (réel).  Ainsi, si nous essayons un cas similaire
avec <literal>~</literal>, nous obtenons&nbsp;:
<screen>SELECT ~ '20' AS "negation";

ERROR:  operator is not unique: ~ "unknown"
HINT:  Could not choose a best candidate operator. You might need to add explicit
type casts.</screen>
Ceci se produit parce que le système ne peut pas décider quel opérateur
doit être préféré parmi les différents opérateurs <literal>~</literal>
possibles.  Nous pouvons l'aider avec une conversion explicite&nbsp;:
<screen>SELECT ~ CAST('20' AS int8) AS "negation";

 negation
----------
      -21
(1 row)</screen>
</para>
</example>

<example>
<title>Résolution du type d'opérateur avec des inclusions de tableaux</title>

<para>
Voici un autre exemple de résolution d'un opérateur avec une entrée de type
connu et une entrée de type inconnu&nbsp;:
<screen>
SELECT array[1,2] &lt;@ '{1,2,3}' as "is subset";

 is subset
-----------
 t
(1 row)
   </screen>
   Le catalogue d'opérateurs pour <productname>PostgreSQL</productname> dispose de
   plusieurs entrées pour un opérateur <literal>&lt;@</literal>, mais les deux seuls
   qui peuvent accepter un tableau d'entiers en argument gauche sont ceux d'inclusion
   de tableaux (<type>anyarray</type> <literal>&lt;@</literal> <type>anyarray</type>)
   et d'inclusion d'intervalles
   (<type>anyelement</type> <literal>&lt;@</literal> <type>anyrange</type>).
   Comme aucun de ces pseudo-types polymorphiques (voir <xref
   linkend="datatype-pseudo"/>) n'est considéré comme préféré, l'analyseur ne peut
   pas résoudre l'ambiguïté sur cette base. Néanmoins, <xref linkend="op-resol-last-unknown"/>
   dit de supposer que le littéral de type inconnu est du même type que
   l'autre entrée, c'est-à-dire dans cet exemple le tableau d'entiers. Maintenant,
   seul un des deux opérateurs peut correspondre, donc l'inclusion de tableaux
   est sélectionnée. (Si l'inclusion d'intervalles avait été sélectionnée, nous
   aurions obtenu une erreur, car la chaîne n'a pas le bon format pour un intervalle.)
  </para>
 </example>

 <example>
  <title>Opérateur personnalisé sur un domaine</title>

  <para>
   Les utilisateurs essaient parfois de déclarer des opérateurs s'appliquant juste
   à un domaine. Ceci est possible, mais pas aussi intéressant que cela paraît, car
   les règles de résolution des opérateurs sont conçues pour sélectionner des
   opérateurs s'appliquant au type de base du domaine. Voici un exemple&nbsp;:
   <screen>
CREATE DOMAIN mon_texte AS text CHECK(...);
CREATE FUNCTION mon_texte_eq_text (mon_texte, text) RETURNS boolean AS ...;
CREATE OPERATOR = (procedure=mon_texte_eq_text, leftarg=mon_texte, rightarg=text);
CREATE TABLE ma_table (val mon_texte);

SELECT * FROM ma_table WHERE val = 'foo';
   </screen>
   Cette dernière requête n'utilisera pas l'opérateur personnalisé. L'analyseur
   verra tout d'abord s'il existe un opérateur <type>mon_texte</type>
   <literal>=</literal> <type>mon_texte</type>
   (<xref linkend="op-resol-exact-unknown"/>)&nbsp;; puis
   il considérera le type de base du domaine et verra s'il existe un opérateur
   <type>text</type> <literal>=</literal> <type>text</type>
   (<xref linkend="op-resol-exact-domain"/>), ce qui est vrai&nbsp;; donc il résout
   le littéral de type <type>unknown</type> comme un type <type>text</type> et
   utilise l'opérateur <type>text</type> <literal>=</literal> <type>text</type>.
   La seule façon d'obtenir l'utilisation de l'opérateur personnalisé est de convertir
   explicitement la valeur littérale&nbsp;:
   <screen>
SELECT * FROM ma_table WHERE val = text 'foo';
   </screen>
   de façon à ce que l'opérateur <type>mon_texte</type> <literal>=</literal>
   <type>text</type> soit immédiatement trouvé suivant la règle de correspondance
   exacte. Si les règles de meilleure correspondance sont atteintes, elles
   discriminent complètement les opérateurs sur les domaines. Dans le cas
   contraire, un tel opérateur créerait trop d'échecs sur des opérateurs ambigus,
   car les règles de conversion considèrent en permanence un domaine comme réductible
   à son type de base, et de ce fait, l'opérateur du domaine serait considéré comme
   utilisable dans les mêmes cas qu'un opérateur de même nom sur le type de base.
  </para>
 </example>

</sect1>

<sect1 id="typeconv-func">
 <title>Fonctions</title>

 <indexterm zone="typeconv-func">
  <primary>fonction</primary>
  <secondary>résolution de types dans un appel</secondary>
 </indexterm>

 <para>
  La fonction spécifique référencée par un appel de fonction
  est déterminée selon les étapes suivantes.
 </para>

 <procedure>
  <title>Résolution de types pour les fonctions</title>

  <step performance="required">
   <para>
    Sélectionner les fonctions à examiner depuis le catalogue système
    <classname>pg_proc</classname>.  Si un nom non qualifié de fonction
    est utilisé, les fonctions examinées sont celles avec un nom et un
    nombre d'arguments corrects et qui sont visibles dans le chemin de
    recherche courant (voir la <xref linkend="ddl-schemas-path"/>).  Si
    un nom qualifié de fonction a été donné, seules les fonctions dans le
    schéma spécifique sont examinées.
   </para>

   <substeps>
    <step performance="optional">
     <para>
      Si un chemin de recherche trouve de nombreuses fonctions avec des types
      d'arguments identiques, seule celle apparaissant le plus tôt dans le
      chemin sera examinée.  Mais les fonctions avec des types d'arguments
      différents sont examinées sur une base d'égalité indépendamment de leur
      position dans le chemin de recherche.
     </para>
    </step>
    <step performance="optional">
     <para>
      Si une fonction est déclarée avec un paramètre <literal>VARIADIC</literal> et
      que l'appel n'utilise pas le mot-clé <literal>VARIADIC</literal>, alors la
      fonction est traitée comme si le paramètre tableau était remplacé par une ou
      plusieurs occurrences de son type élémentaire, autant que nécessaire pour
      correspondre à l'appel. Après cette expansion, la fonction pourrait avoir
      des types d'arguments identiques à certaines fonctions non variadic. Dans ce
      cas, la fonction apparaissant plus tôt dans le chemin de recherche est utilisée
      ou, si les deux fonctions sont dans le même schéma, celle qui n'est pas VARIADIC
      est préférée.
     </para>
     <para>
     Le manque de correspondance exacte crée un risque de sécurité lors de l'appel,
     via un nom qualifié
       <footnote id="func-qualified-security">
        <!-- If you edit this, consider editing op-qualified-security. -->
        <para>
         Le risque ne vient pas d'un nom sans qualification de schéma parce qu'un
         chemin de recherche contenant des schémas permettant à des utilisateurs
         sans confiance de créer des objets n'est pas un <link
         linkend="ddl-schemas-patterns">modèle d'utilisation sécurisée des
         schémas</link>.
        </para>
       </footnote>,
     d'une fonction avec un nombre variable d'arguments trouvée dans un schéma qui
     permet à des utilisateurs sans confiance de créer des objets. Un utilisateur
     mal intentionné peut prendre contrôle et exécuter des fonctions SQL
     arbitraires comme si vous les aviez exécutées. Remplacez un appel utilisant le
     mot-clé <literal>VARIADIC</literal> qui contourne ce risque. Les appels
     utilisant des paramètres <literal>VARIADIC "any"</literal> n'ont généralement
     pas de formulation équivalente contenant le mot-clé
     <literal>VARIADIC</literal>. Pour réaliser ces appels en toute sécurité, le
     schéma de la fonction doit permettre de créer des objets uniquement à des
     utilisateurs de confiance.
     </para>
    </step>
    <step performance="optional">
     <para>
      Les fonctions qui ont des valeurs par défaut pour les paramètres sont considérées
      comme correspondant à un appel qui omet zéro ou plusieurs des paramètres ayant des
      valeurs par défaut. Si plus d'une fonction de ce type correspondent à un appel,
      celui apparaissant en premier dans le chemin des schémas est utilisé. S'il
      existe deux ou plus de ces fonctions dans le même schéma avec les mêmes types de
      paramètres pour les paramètres sans valeur par défaut (ce qui est possible s'ils
      ont des ensembles différents de paramètres par défaut), le système ne sera pas
      capable de déterminer laquelle sélectionner, ce dont il résultera une erreur
      <quote>ambiguous function call</quote>.
     </para>
     <para>
      Ceci crée un risque de disponibilité lors de l'appel, via un nom
      qualifié<footnoteref linkend="func-qualified-security"/>, de toute
      fonction trouvée dans un schéma permettant à des utilisateurs sans
      confiance de créer des objets. Un utilisateur mal intentionné peut créer
      une fonction avec le nom d'une fonction existante, répliquant les
      paramètres de la fonction et ajouter des nouveaux paramètres avec des
      valeurs par défaut. Ceci empêche les nouveaux appels à la fonction
      originale. Pour supprimer ce risque, placez les fonctions dans des
      schémas permettant uniquement aux utilisateurs de confiance de créer des
      objets.
     </para>
    </step>
   </substeps>
  </step>

  <step performance="required">
   <para>
    Vérifier que la fonction accepte le type exact des arguments en entrée.
    Si une fonction existe (il peut y en avoir uniquement une qui corresponde
    exactement dans tout l'ensemble des fonctions considérées), utiliser cette
    fonction. Le manque d'une correspondance exacte crée un risque de sécurité
    lors de l'appel, via un nom qualifié<footnoteref
    linkend="func-qualified-security"/>, d'une fonction trouvée dans un schéma
    permettant à des utilisateurs sans confiance de créer des objets. Dans de
    telles situations, convertir les arguments pour forcer une correspondance
    exacte. (Les cas impliquant le type <type>unknown</type> ne trouveront
    jamais de correspondance à cette étape).
   </para>
  </step>

  <step performance="required">
   <para>
    Si aucune correspondance n'est trouvée, vérifier si l'appel à la
    fonction apparaît être une requête spéciale de conversion de types.
    Cela arrive si l'appel à la fonction a juste un argument et si le nom
    de la fonction est le même que le nom (interne) de certains types de
    données.  De plus, l'argument de la fonction doit être soit un type
    inconnu soit, un type qui a une compatibilité binaire avec le type de
    données nommé, soit un type qui peut être converti dans le type de données
    indiqué en appliquant les fonctions d'entrées/sorties du type (c'est-à-dire
    que la conversion est vers ou à partir d'un type standard de chaîne). Quand
    ces conditions sont rencontrées, l'appel de la fonction est traité sous la
    forme d'une spécification <literal>CAST</literal>.
    <footnote>
     <para>
      La raison de cette étape est le support des spécifications de conversion
      au format fonction pour les cas où la vraie fonction de conversion
      n'existe pas. S'il existe une fonction de conversion, elle est
      habituellement nommée suivant le nom du type en sortie et donc il n'est
      pas nécessaire d'avoir un cas spécial. Pour plus d'informations, voir
      <xref linkend="sql-createcast"/>.
     </para>
    </footnote>

   </para>
  </step>
  <step performance="required">
   <para>
    Regarder pour la meilleure correspondance.
   </para>
   <substeps>
    <step performance="required">
     <para>
      Se débarrasser des fonctions candidates pour lesquelles les types en
      entrée ne correspondent pas et qui ne peuvent pas être convertis (en
      utilisant une conversion implicite) pour correspondre.  Le type
      <type>unknown</type> est supposé être convertible vers n'importe quoi.
      Si un seul candidat reste, l'utiliser&nbsp;; sinon, aller à la prochaine
      étape.
     </para>
    </step>
    <step performance="required">
     <para>
      Si tout argument en entrée est un type domaine, le traiter comme son type
      de base pour toutes les étapes suivantes. Ceci nous assure que les domaines
      agissent comme leurs types de base pour la résolution des fonctions ambiguës.
     </para>
    </step>
    <step performance="required">
     <para>
      Parcourir tous les candidats et garder ceux avec la correspondance la
      plus exacte par rapport aux types en entrée.
      Garder tous les candidats si aucun n'a de correspondance exacte. Si
      un seul candidat reste, l'utiliser&nbsp;; sinon, aller à la prochaine
      étape.
     </para>
    </step>
    <step performance="required">
     <para>
      Parcourir tous les candidats et garder ceux qui acceptent les types
      préférés (de la catégorie des types de données en entrée) aux positions
      où la conversion de types aurait été requise.  Garder tous les candidats
      si aucun n'accepte les types préférés. Si un seul candidat
      reste, l'utiliser&nbsp;; sinon, aller à la prochaine étape.
     </para>
    </step>
    <step performance="required">
     <para>
      Si des arguments en entrée sont <type>unknown</type>, vérifier les
      catégories de types acceptées à la position de ces arguments par les
      candidats restants. À chaque position, sélectionner la catégorie
      <type>chaîne de caractères</type> si un des candidats accepte cette
      catégorie (cette préférence envers les chaînes de caractères est
      appropriée depuis que le terme type-inconnu ressemble à une chaîne de
      caractères). Dans le cas contraire, si tous les candidats restants
      acceptent la même catégorie de types, sélectionner cette catégorie.
      Dans le cas contraire, échouer, car le choix correct ne peut pas être
      déduit sans plus d'indices.  Se débarrasser maintenant des candidats qui
      n'acceptent pas la catégorie sélectionnée.  De plus, si des candidats
      acceptent un type préféré dans cette catégorie, se débarrasser des
      candidats qui acceptent, pour cet argument, les types qui ne sont pas
      préférés.
      Garder tous les candidats si aucun ne survit à ces tests. Si un seul
      candidat reste, l'utiliser. Sinon, continuer avec l'étape suivante.
     </para>
    </step>
    <step performance="required">
     <para>
      S'il y a des arguments à fois <type>unkown</type> et connus, et que tous
      les arguments de type connu ont le même type, supposer que les arguments
      <type>unkown</type> sont de ce même type, et vérifier les candidats
      qui acceptent ce type aux positions des arguments de type <type>unknown</type>.
      Si un seul candidat réussit ce test, l'utiliser. Sinon, échec.
     </para>
    </step>
   </substeps>
  </step>
 </procedure>

 <para>
  Notez que les règles de <quote>correspondance optimale</quote> sont
  identiques pour la résolution de types concernant les opérateurs et les
  fonctions. Quelques exemples suivent.
 </para>

 <example>
  <title>Résolution de types pour les arguments de la fonction arrondi</title>

  <para>
   Il n'existe qu'une seule fonction <function>round</function>
   avec deux arguments (le premier est de type <type>numeric</type>, le
   second est de type <type>integer</type>). Ainsi, la requête suivante
   convertit automatiquement le type du premier argument de
   <type>integer</type> vers <type>numeric</type>.

   <screen>SELECT round(4, 4);

 round
--------
 4.0000
(1 row)</screen>

La requête est en fait transformée par l'analyseur en
<screen>SELECT round(CAST (4 AS numeric), 4);</screen>
</para>

<para>
Puisque le type <type>numeric</type> est initialement assigné aux
constantes numériques avec un point décimal, la requête suivante ne
requièrera pas une conversion de types et pourra par conséquent être
un peu plus efficace&nbsp;:
<screen>SELECT round(4.0, 4);</screen>
</para>
</example>

<example>
<title>Résolution de fonction à arguments variables</title>

<para>
<screen>
CREATE FUNCTION public.variadic_example(VARIADIC numeric[]) RETURNS int
  LANGUAGE sql AS 'SELECT 1';
CREATE FUNCTION
</screen>

Cette fonction accepte, mais ne requiert pas, le mot-clé VARIADIC. Elle tolère
des arguments à la fois entier et numérique&nbsp;:

<screen>
SELECT public.variadic_example(0),
       public.variadic_example(0.0),
       public.variadic_example(VARIADIC array[0.0]);
 variadic_example | variadic_example | variadic_example
------------------+------------------+------------------
                1 |                1 |                1
(1 row)
</screen>

Néanmoins, le premier et le deuxième appels préféreront des fonctions plus
spécifiques si elles sont disponibles&nbsp;:

<screen>
CREATE FUNCTION public.variadic_example(numeric) RETURNS int
  LANGUAGE sql AS 'SELECT 2';
CREATE FUNCTION

CREATE FUNCTION public.variadic_example(int) RETURNS int
  LANGUAGE sql AS 'SELECT 3';
CREATE FUNCTION

SELECT public.variadic_example(0),
       public.variadic_example(0.0),
       public.variadic_example(VARIADIC array[0.0]);
 variadic_example | variadic_example | variadic_example
------------------+------------------+------------------
                3 |                2 |                1
(1 row)
</screen>

Étant donné la configuration par défaut et si seule la première fonction existe,
le premier et le deuxième appels ne sont pas sécurisés. Tout utilisateur
peut les intercepter en créant la deuxième et la troisième fonction. En utilisant
une correspondance exacte du type d'argument et en utilisant le mot-clé
<literal>VARIADIC</literal>, le troisième appel est sécurisé.
</para>
</example>

<example>
<title>Résolution de types pour les fonctions retournant un segment de chaîne</title>

<para>
Il existe plusieurs fonctions <function>substr</function>, une d'entre
elles prend les types <type>text</type> et <type>integer</type>.  Si
cette fonction est appelée avec une constante de chaînes d'un type
inconnu, le système choisit la fonction candidate qui accepte un
argument issu de la catégorie préférée <type>string</type>
(c'est-à-dire de type <type>text</type>).

<screen>SELECT substr('1234', 3);

 substr
--------
     34
(1 row)</screen>
</para>

<para>
Si la chaîne de caractères est déclarée comme étant du type
<type>varchar</type> (chaîne de caractères de longueur variable), ce
qui peut être le cas si elle vient d'une table, alors l'analyseur
essaiera de la convertir en <type>text</type>&nbsp;:
<screen>SELECT substr(varchar '1234', 3);

 substr
--------
     34
(1 row)</screen>

Ceci est transformé par l'analyseur en
<screen>SELECT substr(CAST (varchar '1234' AS text), 3);</screen>
</para>
<para>
<note>
<para>
L'analyseur apprend depuis le catalogue <structname>pg_cast</structname> que les
types <type>text</type> et <type>varchar</type> ont une compatibilité
binaire, ce qui veut dire que l'un peut être passé à une fonction qui
accepte l'autre sans avoir à faire de conversion physique. Par
conséquent, aucun appel de conversion de types n'est
réellement inséré dans ce cas.
</para>
</note>
</para>

<para>
Et si la fonction est appelée avec un argument de type
<type>integer</type>, l'analyseur essaie de le convertir en
<type>text</type>&nbsp;:
<screen>
SELECT substr(1234, 3);
ERROR:  function substr(integer, integer) does not exist
HINT:  No function matches the given name and argument types. You might need
to add explicit type casts.
   </screen>

   Ceci ne fonctionne pas, car <type>integer</type> n'a pas de conversion
   implicite vers <type>text</type>. Néanmoins, une conversion explicite
   fonctionnera&nbsp;:
   <screen>
SELECT substr(CAST (1234 AS text), 3);

 substr
--------
     34
(1 row)
   </screen>
  </para>
 </example>

</sect1>

<sect1 id="typeconv-query">
 <title>Stockage de valeurs</title>

 <para>
  Les valeurs qui doivent être insérées dans une table sont converties
  vers le type de données de la colonne de destination selon les
  règles suivantes.
 </para>

 <procedure>
  <title>Conversion de types pour le stockage de valeurs</title>

  <step performance="required">
   <para>
    Vérifier qu'il y a une correspondance exacte avec la cible.
   </para>
  </step>

  <step performance="required">
   <para>
    Dans le cas contraire, essayer de convertir l'expression vers le type
    cible.  Cela réussira s'il y a une conversion d'affectation (cast)
    enregistrée entre ces deux types dans le catalogue
    <structname>pg_cast</structname> (voir <xref linkend="sql-createcast"/>).
    Si une expression est de type inconnu, le contenu de la chaîne littérale
    sera fourni à l'entrée de la routine de conversion pour le type cible.
   </para>
  </step>

  <step performance="required">
   <para>
    Vérifier s'il y a une conversion de taille pour le type cible. Une conversion
    de taille est une conversion d'un type vers lui-même. Si elle est trouvée dans
    le catalogue <structname>pg_cast</structname>, l'appliquer à l'expression avant de la
    stocker dans la colonne de destination. La fonction d'implémentation pour une
    telle conversion prend toujours un paramètre supplémentaire de type
    <type>integer</type>, qui reçoit la valeur <structfield>atttypmod</structfield>
    de la colonne de destination (en fait, sa valeur déclarée&nbsp;;
    l'interprétation de <structfield>atttypmod</structfield> varie pour les
    différents types de données).
    La fonction de conversion est responsable de l'application de toute
    sémantique dépendante de la longueur comme la vérification de la taille ou une
    troncature.
   </para>
  </step>

 </procedure>

 <example>
  <title>Conversion de types pour le stockage de <type>character</type></title>

  <para>
   Pour une colonne cible déclarée comme <type>character(20)</type>, la
   déclaration suivante montre que la valeur stockée a la taille correcte&nbsp;:

   <screen>CREATE TABLE vv (v character(20));
INSERT INTO vv SELECT 'abc' || 'def';
SELECT v, octet_length(v) FROM vv;

          v           | octet_length
----------------------+--------------
 abcdef               |           20
(1 row)</screen>
</para>

<para>
Voici ce qui s'est réellement passé ici&nbsp;: les deux types inconnus
sont résolus en <type>text</type> par défaut, permettant à l'opérateur
<literal>||</literal> de les résoudre comme une concaténation de
<type>text</type>.  Ensuite, le résultat <type>text</type> de
l'opérateur est converti en <type>bpchar</type> (
<quote>blank-padded char</quote>, le nom interne du type de données
<type>character</type> (caractère)) pour correspondre au type de la
colonne cible (comme la conversion de <type>text</type> à
<type>bpchar</type> est compatible binairement, cette conversion
n'insère aucun appel réel à une fonction). Enfin, la fonction de
taille <literal>bpchar(bpchar, integer, boolean)</literal> est trouvée dans le
catalogue système et appliquée au résultat de l'opérateur et à la
longueur de la colonne stockée. Cette fonction de type spécifique
effectue le contrôle de la longueur requise et ajoute des espaces pour
combler la chaîne.
</para>
</example>
</sect1>

<sect1 id="typeconv-union-case">
<title>Constructions <literal>UNION</literal>, <literal>CASE</literal> et
constructions relatives</title>

<indexterm zone="typeconv-union-case">
 <primary>UNION</primary>
 <secondary>détermination du type de résultat</secondary>
</indexterm>

<indexterm zone="typeconv-union-case">
 <primary>CASE</primary>
 <secondary>détermination du type de résultat</secondary>
</indexterm>

<indexterm zone="typeconv-union-case">
 <primary>ARRAY</primary>
 <secondary>détermination du type de résultat</secondary>
</indexterm>

<indexterm zone="typeconv-union-case">
 <primary>VALUES</primary>
 <secondary>détermination du type de résultat</secondary>
</indexterm>

<indexterm zone="typeconv-union-case">
 <primary>GREATEST</primary>
 <secondary>détermination du type de résultat</secondary>
</indexterm>

<indexterm zone="typeconv-union-case">
 <primary>LEAST</primary>
 <secondary>détermination du type de résultat</secondary>
</indexterm>

<para>
Les constructions SQL avec des <literal>UNION</literal> doivent
potentiellement faire correspondre des types différents pour avoir un
ensemble unique dans le résultat.  L'algorithme de résolution est
appliqué séparément à chaque colonne de sortie d'une requête d'union.
Les constructions <literal>INTERSECT</literal> et <literal>EXCEPT</literal> résolvent
des types différents de la même manière qu'<literal>UNION</literal>. Les
constructions <literal>CASE</literal>, <literal>ARRAY</literal>,
<function>VALUES</function>, <function>GREATEST</function> et
<function>LEAST</function> utilisent le même
algorithme pour faire correspondre les expressions qui les composent et
sélectionner un type de résultat.
</para>

<procedure>
<title>Résolution des types pour <literal>UNION</literal>,
<literal>CASE</literal> et les constructions relatives</title>

<step performance="required">
<para>
Si toutes les entrées sont du même type et qu'il ne s'agit pas du type
<type>unknown</type>, résoudre comme étant de ce type.
</para>
</step>

<step performance="required">
<para>
Si un type en entrée est un domaine, le traiter comme le type de base du domaine
pour toutes les étapes suivantes.
  <footnote>
   <para>
    Un peu comme le traitement des arguments de type domaine pour les opérateurs
    et les fonctions, ce comportement permet à un type domaine d'être préservé par
    un <literal> UNION </literal> ou toute construction similaire, tant que
    l'utilisateur veille à ce que toutes les entrées soient explicitement ou
    implicitement du type exact. Dans le cas contraire, le type de base du
    domaine sera utilisé.
   </para>
  </footnote>
</para>
</step>

<step performance="required">
<para>
Si toutes les entrées sont du type <type>unknown</type>, résoudre comme
étant du type <type>text</type> (le type préféré de la catégorie
chaîne).  Dans le cas contraire, les entrées
<type>unknown</type> seront ignorées pour les règles restantes.
</para>
</step>

<step performance="required">
<para>
Si toutes les entrées non inconnues ne sont pas toutes de la même
catégorie, échouer.
</para>
</step>

<step performance="required">
<para>
Sélectionne le premier type en entrée connu comme le type candidat, puis
considère chaque autre type en entrée connu, de gauche à droite.
  <footnote>
   <para>
    Pour des raisons historiques, <literal>CASE</literal> traite sa clause
    <literal>ELSE</literal> (s'il y en a) comme la <quote>première</quote>
    entrée, et les clauses <literal>THEN</literal> sont considérés après ça.
    Dans tous les autres cas, <quote>de gauche à droite</quote> signifie
    l'ordre dans lequel les expressions apparaissent dans le texte de la
    requête.
   </para>
  </footnote>
Si le type candidat peut être converti implicitement dans l'autre type, mais
pas vice versa, sélectionne l'autre type comme nouveau type candidat. Puis
continue en considérant les entrées restantes. Si, à tout moment de ce
traitement, un type préféré est sélectionné, s'arrête de considérer les
entrées supplémentaires.
</para>
</step>

<step performance="required">
<para>
Convertir toutes les entrées vers le type candidat final. Échoue s'il n'y a
pas de conversion implicite à partir de l'entrée donnée vers le type candidat.
</para>
</step>
</procedure>

<para>
Quelques exemples suivent.
</para>

<example>
<title>Résolution de types avec des types sous-spécifiés dans une union</title>

<para>
<screen>SELECT text 'a' AS "text" UNION SELECT 'b';

 text
------
 a
 b
(2 rows)</screen>
Ici, la chaîne de type inconnu <literal>'b'</literal> sera convertie
vers le type <type>text</type>.
</para>
</example>

<example>
<title>Résolution de types dans une union simple</title>

<para>
<screen>SELECT 1.2 AS "numeric" UNION SELECT 1;

 numeric
---------
       1
     1.2
(2 rows)</screen>
Le littéral <literal>1.2</literal> est du type <type>numeric</type> et la valeur
<literal>1</literal>, de type <type>integer</type>, peut
être convertie implicitement vers un type <type>numeric</type>, donc ce
type est utilisé.
</para>
</example>

<example>
<title>Résolution de types dans une union transposée</title>

<para>
<screen>SELECT 1 AS "real" UNION SELECT CAST('2.2' AS REAL);

 real
------
    1
  2.2
(2 rows)</screen>
Dans cet exemple, le type <type>real</type> (réel) ne peut pas être
implicitement converti en <type>integer</type> (entier), mais un
<type>integer</type> peut être implicitement converti en <type>real</type>&nbsp;; le
résultat de l'union est résolu comme étant un <type>real</type>.
</para>
</example>

<example>
<title>Résolution de type dans une union imbriquée</title>

<para>
<screen>
SELECT NULL UNION SELECT NULL UNION SELECT 1;

ERROR:  UNION types text and integer cannot be matched
</screen>
Cet échec survient parce que <productname>PostgreSQL</productname> traite
plusieurs <literal>UNION</literal> comme une imbrication d'opérations sous
forme de paires&nbsp;; c'est-à-dire que cette entrée est identique à
<screen>
(SELECT NULL UNION SELECT NULL) UNION SELECT 1;
</screen>
Le <literal>UNION</literal> interne est résolu en émettant le type
<type>text</type>, suivant les règles données ci-dessus. Puis le
<literal>UNION</literal> externe a en entrée les types <type>text</type> et
<type>integer</type>, amenant l'erreur observée. Le problème peut être corrigé
en s'assurant que le <literal>UNION</literal> le plus à gauche dispose au
moins d'une entrée du type résultant désiré.
</para>

<para>
Les opérations <literal>INTERSECT</literal> et <literal>EXCEPT</literal>
procèdent de la même façon. Néanmoins, les autres constructions décrites dans
cette section considèrent toutes leurs entrées en une seule étape de
résolution.
</para>
</example>
</sect1>

<sect1 id="typeconv-select">
<title>Colonnes de sortie du <literal>SELECT</literal></title>

<indexterm zone="typeconv-select">
 <primary>SELECT</primary>
 <secondary>détermination du type de résultat</secondary>
</indexterm>

<para>
Les règles des sections précédentes auront pour résultat 
d'assigner les types de données autres que <type>unknown</type> à toutes
les expressions dans la requête SQL, à l'exception des littéraux de type
non spécifié apparaissant en tant que colonne de sortie dans une commande
<command>SELECT</command>. Par exemple, dans :
     
<screen>
SELECT 'Hello World';
</screen>

rien ne permet d'identifier quel devrait être le type du litteral chaîne
de caractères. Dans ce cas, <productname>PostgreSQL</productname> résoudra
le type du littéral en type <type>text</type>.
</para>

<para>
Lorsque le <command>SELECT</command> fait partie d'une construction
<literal>UNION</literal> (ou <literal>INTERSECT</literal>  
<literal>EXCEPT</literal>) ou lorsqu'il apparaît dans un
<command>INSERT ... SELECT</command>, cette règle n'est pas appliquée, 
car les règles des sections précédentes ont priorité. Le type d'un littéral
au type non spécifié peut être choisi d'après l'autre partie 
d'un <literal>UNION</literal> dans le premier cas, ou d'après la colonne 
de destination dans le second cas.
</para>

<para>
Dans ce but, les listes <literal>RETURNING</literal> sont traitées de la 
même manière que les retours de <command>SELECT</command>.
</para>

<note>
 <para>
  Avant la version 10 de <productname>PostgreSQL</productname>, cette règle
  n'existait pas, et les littéraux aux types non spécifiés dans la sortie d'un 
  <command>SELECT</command> étaient de type <type>unknown</type>. Suite à plusieurs
 conséquences néfastes, ce comportement a été modifié.
 </para>
</note>
</sect1>
</chapter>
