<?xml version="1.0" encoding="UTF-8"?>
<chapter id="bki">
 <title>Déclaration du catalogue système et contenu initial</title>

 <para>
  <productname>PostgreSQL</productname> utilise de nombreux catalogues systèmes
  différents pour garder la trace de l'existence et les propriétés des objets
  des bases de données, tels que les tables et les fonctions.  Il n'y a aucune
  différence physique entre un catalogue système et une table utilisateur
  standard, mais le code C des processus clients connait la structure et les
  propriétés de chaque catalogue, et peut les manipuler directement à un bas
  niveau.  Ainsi, par exemple, il est déconseillé de tenter de modifier la
  structure d'un catalogue à la volée&nbsp;; cela casserait de nombreuses suppositions
  inscrites dans le code C sur comment les lignes du catalogues sont arrangées.
  Mais les structures des catalogues peuvent changer entre plusieurs versions
  majeures.
 </para>

 <para>
  Les structures des catalogues sont déclarées dans des en-têtes de fichiers C
  spécialement formatées dans le répertoire
  <filename>src/include/catalog/</filename> du code source.  En particulier,
  il y a pour chaque catalogue un fichier d'en-tête nommé d'après le catalogue
  (par exemple, <filename>pg_class.h</filename> pour
  <structname>pg_class</structname>), qui définit l'ensemble des colonnes que
  le catalogue a, ainsi que certaines autres propriétés basique telles que son
  OID.  D'autres fichiers cruciaux définissant la structure du catalogue
  incluent <filename>indexing.h</filename>, qui définit les index présents sur
  tous les catalogues systèmes, et <filename>toasting.h</filename>, qui définit
  les tables TOAST pour les catalogues qui en ont besoin.
 </para>

 <para>
  Beaucoup des catalogues ont des données initiales qui doivent être chargées
  à l'intérieur durant la phase de <quote>bootstrap</quote>
  d'<application>initdb</application>, pour amener le système à un point où il
  est capable d'exécuter des ordres SQL.  (Par exemple,
  <filename>pg_class.h</filename> doit contenir une entrée pour lui-même, ainsi
  qu'autant d'entrées pour chacun des autres catalogues système et index.)
  Ces données initiales sont conservées dans un format éditable dans des
  fichiers de données qui sont également stockés dans le répertoire
  <filename>src/include/catalog/</filename>.  Par exemple,
  <filename>pg_proc.dat</filename> décrit toutes les lignes initiales qui
  doivent être insérées dans le catalogue <structname>pg_proc</structname>.
 </para>

 <para>
  Pour créer les fichiers de catalogue et y charger ces données initiales,
  un processus client fonctionnant en mode bootstrap lit un fichier
  <acronym>BKI</acronym> (Backend Interface) contenant les commandes et les
  données initiales.  Le fichier <filename>postgres.bki</filename> utilisé
  dans ce mode est préparé à partir des en-têtes et fichiers de données
  susmentionnés, en même temps que la création d'une distribution
  <productname>PostgreSQL</productname>, par un script Perl nommé
  <filename>genbki.pl</filename>.
  Bien qu'il soit spécifique à une version précise de
  <productname>PostgreSQL</productname>, <filename>postgres.bki</filename> ne
  dépend pas de la plateforme et est installé dans le sous répertoire
  <filename>share</filename> de l'arborescence installée.
 </para>

 <para>
  <filename>genbki.pl</filename> produit également des fichiers d'en-tête
  dérivés pour chaque catalogue, par exemple <filename>pg_class_d.h</filename>
  pour le catalogue <structname>pg_class</structname>.  Ce fichier contient des
  définitions de macro automatiquement générées, et peut contenir d'autres
  macros, déclarations d'énumérations, etc qui peuvent être utiles pour du code
  C client qui lit un catalogue en particulier.
 </para>

 <para>
  La plupart des développeurs de PostgreSQL n'ont pas besoin de se préoccuper
  directement du fichier <acronym>BKI</acronym>, mais presque toutes les
  fonctionnalités non triviales ajoutées dans les processus clients
  nécessiteront de modifier les fichiers d'en-tête de catalogue et/ou les
  fichiers de données initiales.  Le reste de ce chapitre donne des informations
  sur ce sujet, et par soucis de complétude décrit le format de fichier
  <acronym>BKI</acronym>.
 </para>

 <sect1 id="system-catalog-declarations">
  <title>Règles de déclaration de catalogue système</title>

  <para>
   La partie cruciale d'un fichier d'en-tête de catalogue est une définition de
   structure C décrivant l'agencement de chaque ligne dans le catalogue.  Cela
   commence avec une macro <literal>CATALOG</literal>, qui, pour autant que le
   compilateur C est concerné, est juste un raccourci pour <literal>typedef
   struct FormData_<replaceable>catalogname</replaceable></literal>.
   Chaque champ dans cette structure donne naissance à une colonne de catalogue.
   Les champs peuvent être annotés en utilisant les macros de propriété BKI
   décrites dans <filename>genbki.h</filename>, par exemple pour définir une
   valeur par défaut pour un champ pour le marquer comme potentiellement NULL ou
   non. La ligne <literal>CATALOG</literal> peut également être annotée,
   avec d'autres macros de propriété décrites dans <filename>genbki.h</filename>,
   pour définir d'autres propriétés du catalogue dans son ensemble, par exemple
   s'il s'agit d'une relation partagée.
  </para>

  <para>
   Le code de cache du catalogue système (et la plupart du code concernant le
   catalogue en général) part du principe que la partie de taille fixe de toutes
   les lignes de tous les catalogues système sont vraiment présentes, car il
   associe cette déclaration de structure C sur elles.  Ainsi, tous les champs
   de longueur variable et tous les champs potentiellement NULL doivent être
   placés à la fin, et ils ne peuvent pas être accédés comme des champs de
   structure. Par exemple, si vous essayez de positioner
   <structname>pg_type</structname>.<structfield>typrelid</structfield> à
   NULL, cela échouerait quand certaines parties du code essaient de référencer
   <literal>typetup-&gt;typrelid</literal> (ou pire,
   <literal>typetup-&gt;typelem</literal>, car cela suit
   <structfield>typrelid</structfield>).  Cela aurait pour conséquence des
   erreurs aléatoires ou même des erreurs de segmentation.
  </para>

  <para>
   Comme protection contre ce type d'erreurs, les champs de longueur variable
   ou potentiellement NULL ne devraient pas être fait directement visibles
   pour le compilateur C. Cela se fait en les entourant de
   <literal>#ifdef CATALOG_VARLEN</literal> ... <literal>#endif</literal> (où
   <literal>CATALOG_VARLEN</literal> est un symbole qui n'est jamais défini).
   Cela empêche le code C d'imprudemment essayer d'accéder à des champs qui
   pourraient ne pas être là ou pourraient être à des décalage différents.
   Comme protection contre la création de lignes incorrectes, nous exigeons
   que toutes les colonnes qui devraient être non NULL soient marquées comme
   telles dans <structname>pg_attribute</structname>.  Le code de bootstrap
   marquera automatiquement les colonnes comme <literal>NOT NULL</literal> si
   elles sont de taille fixe et ne sont précédées d'aucune colonne potentiellement NULL.
   Quand cette règle ne convient pas, vous pouvez forcer un marquage correct en
   utilisant les annotations <literal>BKI_FORCE_NOT_NULL</literal> et
   <literal>BKI_FORCE_NULL</literal> selon les besoins.  Mais veuillez noter que
   les contraintes <literal>NOT NULL</literal> ne sont vérifiées que dans
   l'exécuteur, pas quand des lignes sont générées par n'importe quel code C.
   Il est donc nécessaire de prendre des précautions quand des lignes de
   catalogue sont créées ou mises à jour.
  </para>

  <para>
   Le code client ne devrait pas inclure de fichier d'en-tête de catalogue
   <filename>pg_xxx.h</filename>, car ces fichiers peuvent contenir du code C
   qui ne compilerait pas en dehors des processus clients.  (Typiquement, cela
   arrive car ces fichiers contiennent également des déclarations pour des
   fonctions dans des fichiers de <filename>src/backend/catalog/</filename>.)
   À la place, le client peut inclure les en-têtes correspondantes
   <filename>pg_xxx_d.h</filename> générées, qui contiendront les OID définis
   par des <literal>#define</literal> et toute autre donnée qui peut être utile
   pour le code client.  Si vous voulez que des macros ou d'autre code soient
   visibles par le code client, écrivez <literal>#ifdef
   EXPOSE_TO_CLIENT_CODE</literal> ... <literal>#endif</literal> autour de cette
   section pour demander à <filename>genbki.pl</filename> de copier cette
   section dans l'en-tête <filename>pg_xxx_d.h</filename>.
  </para>

  <para>
   Une petite partie des catalogues est tellement fondamentale qu'ils ne peuvent
   même pas être créés par la commande <acronym>BKI</acronym>
   <literal>create</literal> qui est utilisée pour la plupart des catalogues,
   car cette commande a besoin d'écrire des informations dans ces catalogues
   pour décrire les nouveaux catalogues.  Ceux-ci sont appelés les catalogues
   <firstterm>bootstrap</firstterm>, et en définir un nécessite beaucoup de
   travail supplémentaire&nbsp;: vous devez manuellement préparer les entrées
   appropriées pour eux dans le contenu pré-chargé de
   <structname>pg_class</structname> et <structname>pg_type</structname>, et ces
   entrées auront besoin d'être modifiées pour les futures changements de la
   structure du catalogue.  (Les catalogues bootstrap nécessitent également des
   entrées pré-chargées dans <structname>pg_attribute</structname>, mais
   heureusement, <filename>genbki.pl</filename> gère maintenant cette corvée.)
   Évitez de faire des nouveaux catalogues comme catalogue bootstrap si cela est
   possible.
  </para>
 </sect1>

 <sect1 id="system-catalog-initial-data">
  <title>Données initiales du catalogue système</title>

  <para>
   Chaque catalogue qui a des données initiales créées manuellement (certains
   n'en ont pas) a un fichier <literal>.dat</literal> correspondant qui contient
   ses données initiales dans un format éditable.
  </para>

  <sect2 id="system-catalog-initial-data-format">
   <title>Format de fichier de données</title>

   <para>
    Chaque fichier <literal>.dat</literal> contient des structures de données
    Perl littérales qui sont simplement évaluées pour produire une structure
    de données en mémoire qui consiste en un tableau de références de hash, un
    par ligne de catalogue.  Un extrait de <filename>pg_database.dat</filename>
    légèrement modifié va vous décrire les fonctionnalités principales&nbsp;:
   </para>

<programlisting>
[

# A comment could appear here.
{ oid =&gt; '1', oid_symbol =&gt; 'TemplateDbOid',
  descr =&gt; 'database\'s default template',
  datname =&gt; 'template1', encoding =&gt; 'ENCODING', datcollate =&gt; 'LC_COLLATE',
  datctype =&gt; 'LC_CTYPE', datistemplate =&gt; 't', datallowconn =&gt; 't',
  datconnlimit =&gt; '-1', datlastsysoid =&gt; '0', datfrozenxid =&gt; '0',
  datminmxid =&gt; '1', dattablespace =&gt; 'pg_default', datacl =&gt; '_null_' },

]
</programlisting>

   <para>
    Les points à noter&nbsp;:
   </para>

   <itemizedlist>

    <listitem>
     <para>
      La structure générale du fichier est&nbsp;: crochet ouvrant, un ensemble ou
      plus d'accolades qui chacune représentent une ligne de catalogue, crochet
      fermant.  Il faut mettre une virgule après chaque accolade fermante.
     </para>
    </listitem>

    <listitem>
     <para>
      Au sein de chaque ligne de catalogue, écrivez des paires de
      <replaceable>clé</replaceable> <literal>=&gt;</literal>
      <replaceable>valeur</replaceable> séparées par des virgules.  Les
      <replaceable>clé</replaceable>s autorisées sont les noms des colonnes du
      catalogue, ainsi que les clés de métadonnées <literal>oid</literal>,
      <literal>oid_symbol</literal>, <literal>array_type_oid</literal> et
      <literal>descr</literal>. (L'utilisation de <literal>oid</literal> et
      <literal>oid_symbol</literal> est décrite dans <xref
      linkend="system-catalog-oid-assignment"/> ci-dessous, alors que
      <literal>array_type_oid</literal> est décrite dans <xref
      linkend="system-catalog-auto-array-types"/>. <literal>descr</literal>
      fournit une chaîne de texte de description pour l'objet, qui sera
      insérée dans <structname>pg_description</structname> ou
      <structname>pg_shdescription</structname> selon le cas.)
      Bien que les clés de métadonnées soient facultatives, les colonnes
      définies pour le catalogue doivent toutes être fournies, sauf pour le cas
      où le fichier <literal>.h</literal> du catalogue définit une valeur par
      défaut pour la colonne.
      (In the example above, the <structfield>datdba</structfield> field has
      been omitted because <filename>pg_database.h</filename> supplies a
      suitable default value for it.)
     </para>
    </listitem>

    <listitem>
     <para>
      Toutes les valeurs doivent être entourées de guillemets simples.  Il faut
      échapper les guillemets simples utilisés au sein d'une valeur avec un
      antislash.  Les antislash qui doivent être utilisés comme une donnée
      peuvent être doublés, mais cela n'est pas nécessaire&nbsp;; cela correspond aux
      règles Perl pour les littéraux entourés d'un guillemet simple.  Veuillez
      noter que les antislash apparaissant comme données seront traités comme
      des échappements par le scanner du bootstrap, d'après les mêmes règles que
      pour les échappements de chaînes de texte constantes (voir
      <xref linkend="sql-syntax-strings-escape"/>)&nbsp;; par exemple
      <literal>\t</literal> est converti en un caractère tabulation.  Si vous
      voulez un antislash dans la valeur finale, il vous faudra en écrire
      quatre&nbsp;: Perl en retire deux, laissant <literal>\\</literal> pour le
      scanner boostrap.
     </para>
    </listitem>

    <listitem>
     <para>
      Les valeurs null sont représentées par <literal>_null_</literal>.
      (Veuillez noter qu'il n'y a aucun moyen moyen de créer une valeur qui est
      simplement cette chaîne de texte.)
     </para>
    </listitem>

    <listitem>
     <para>
      Les commentaires sont précédés d'un <literal>#</literal>, et doivent etre
      sur leur propre ligne.
     </para>
    </listitem>

    <listitem>
     <para>
      Field values that are OIDs of other catalog entries should be
      represented by symbolic names rather than actual numeric OIDs.
      (In the example above, <structfield>dattablespace</structfield>
      contains such a reference.)
      Cela est décrit dans <xref linkend="system-catalog-oid-references"/>
      ci-dessous.
     </para>
    </listitem>

    <listitem>
     <para>
      Puisque les hash sont des structures de données non triées, l'ordre des
      champs et des lignes ne sont pas sémantiquement significatifs.  Cependant,
      pour maintenir un aspect cohérent, nous définissions quelques règles qui
      sont appliquées par le script de formatage
      <filename>reformat_dat_file.pl</filename>&nbsp;:

      <itemizedlist>

       <listitem>
        <para>
         Au sein de chaque paire d'accolades, les champs de métadonnées
         <literal>oid</literal>, <literal>oid_symbol</literal>,
         <literal>array_type_oid</literal>
         et <literal>descr</literal> (si présent) apparaissent en premier, dans
         cet ordre, puis les champs propres au catalogue apparaissent dans leur
         ordre défini.
        </para>
       </listitem>

       <listitem>
        <para>
         Des retours à la ligne sont insérés entre les champs selon le besoin
         pour limiter la longueur de ligne à 80 caractères, si cela est
         possible.  Un retour à la ligne est également inséré entre les champs
         de métadonnées et les champs normaux.
        </para>
       </listitem>

       <listitem>
        <para>
         Si le fichier de catalogue <literal>.h</literal> spécifie une valeur
         par défaut pour la colonne, et qu'une entrée de donnée a la même
         valeur, <filename>reformat_dat_file.pl</filename> omettra cette valeur
         du fichier de données.  Cela conserve la représentation de données
         compacte.
        </para>
       </listitem>

       <listitem>
        <para>
         <filename>reformat_dat_file.pl</filename> conserve les lignes vides
         et les commentaires en l'état.
        </para>
       </listitem>

      </itemizedlist>

      Il est recommandé d'exécuter <filename>reformat_dat_file.pl</filename>
      avant de soumettre des patchs pour les données de catalogue.  Par
      commodité, vous pouvez simplement effectuer des changements dans
      <filename>src/include/catalog/</filename> et exécuter
      <literal>make reformat-dat-files</literal>.
     </para>
    </listitem>

    <listitem>
     <para>
      Si vous voulez ajouter une nouvelle méthode pour diminuer la taille de
      de la représentation des données, vous devez l'implémenter dans
      <filename>reformat_dat_file.pl</filename> et également apprendre à
      <function>Catalog::ParseData()</function> comment remettre les données
      dans leur représentation complète.
     </para>
    </listitem>

   </itemizedlist>
  </sect2>

  <sect2 id="system-catalog-oid-assignment">
   <title>Affectation d'OID</title>

   <para>
    Il est possible de donner un OID manuellement assigné à une ligne de
    catalogue apparaissant dans les données initiales en écrivant un champ de
    métadonnées <literal>oid =&gt; <replaceable>nnnn</replaceable></literal>.
    De plus, si un OID est assigné, une macro C pour cet OID peut être créée
    en écrivant un champ de métadonnée <literal>oid_symbol
    =&gt; <replaceable>nom</replaceable></literal>.
   </para>

   <para>
    Les lignes de catalogues préchargées doivent avoir des OID pré-assignés s'il
    y a des références d'OID pointant vers elles dans d'autres lignes
    pré-chargées.  Un OID pré-assigné est également nécessaire si l'OID de la
    ligne doit être référencé depuis le code C.  Si aucun de ces cas ne
    s'applique, le champ de métadonnée <literal>oid</literal> peut être omis,
    auquel cas le code de bootstrap assignera un OID automatiquement. En pratique, nous
    pré-assignons généralement des OID pour soit toutes soit aucune des lignes
    d'un catalogue donné, même si seulement une partie des lignes sont vraiment
    référencées dans d'autres catalogues.
   </para>

   <para>
    Écrire la vraie valeur numérique d'un OID dans le code C est considéré comme
    une très mauvaise pratique&nbsp;; il faut toujours utiliser une macro à la place.
    Des références directes à des OID de <structname>pg_proc</structname> sont
    suffisamment communes pour qu'il y ait un mécanisme spécial afin de créer
    les macros nécessaires automatiquement&nbsp;; voir
    <filename>src/backend/utils/Gen_fmgrtab.pl</filename>.  De même
    &mdash; mais, pour raisons historiques, fait d'une autre manière &mdash;
    il y a une méthode automatique pour créer les macros pour les OID de
    <structname>pg_type</structname>.  Les entrées de
    <literal>oid_symbol</literal> ne sont donc pas forcément dans ces deux
    catalogues.  De la même manière, les macros pour les OID de catalogue
    système et index <structname>pg_class</structname> sont positionnés
    automatiquement.  Pour tous les autres catalogues systèmes, vous devez
    spécifier manuellement toute macro dont vous avez besoin avec les entrées
    <literal>oid_symbol</literal>.
   </para>

   <para>
    Pour trouver un OID disponible pour une nouvelle ligne préchargée, exécutez
    le script <filename>src/include/catalog/unused_oids</filename>.  Il affiche
    l'intervalle inclusif d'OIDs inutilisés (par exemple, la ligne en sortie
    <quote>45-900</quote> signifie que les OIDs 45 jusqu'à 900 n'ont pas encore
    été alloués).  Pour le moment, les OIDs 1-9999 sont réservés pour des
    assignements manuels&nbsp;; le script <filename>unused_oids</filename> regarde
    simplement dans les en-têtes de catalogue et les fichiers
    <filename>.dat</filename> pour voir lesquels n'apparaissent pas.  Vous
    pouvez également utiliser le script <filename>duplicate_oids</filename> pour
    trouver des erreurs.  (<filename>genbki.pl</filename> will assign OIDs for any rows that
    didn't get one hand-assigned to them, and it will also detect duplicate
    OIDs at compile time.)
   </para>

   <para>
    When choosing OIDs for a patch that is not expected to be committed
    immediately, best practice is to use a group of more-or-less
    consecutive OIDs starting with some random choice in the range
    8000&mdash;9999.  This minimizes the risk of OID collisions with other
    patches being developed concurrently.  To keep the 8000&mdash;9999
    range free for development purposes, after a patch has been committed
    to the master git repository its OIDs should be renumbered into
    available space below that range.  Typically, this will be done
    near the end of each development cycle, moving all OIDs consumed by
    patches committed in that cycle at the same time.  The script
    <filename>renumber_oids.pl</filename> can be used for this purpose.
    If an uncommitted patch is found to have OID conflicts with some
    recently-committed patch, <filename>renumber_oids.pl</filename> may
    also be useful for recovering from that situation.
   </para>

   <para>
    Because of this convention of possibly renumbering OIDs assigned by
    patches, the OIDs assigned by a patch should not be considered stable
    until the patch has been included in an official release.  We do not
    change manually-assigned object OIDs once released, however, as that
    would create assorted compatibility problems.
   </para>

   <para>
    If <filename>genbki.pl</filename> needs to assign an OID to a catalog
    entry that does not have a manually-assigned OID, it will use a value in
    the range 10000&mdash;11999.  The server's OID counter is set to 12000
    at the start of a bootstrap run.  Thus objects created by regular SQL
    commands during the later phases of bootstrap, such as objects created
    while running the <filename>information_schema.sql</filename> script,
    receive OIDs of 12000 or above.
   </para>

   <para>
    OIDs assigned during normal database operation are constrained to be
    16384 or higher.  This ensures that the range 10000&mdash;16383 is free
    for OIDs assigned automatically by <filename>genbki.pl</filename> or
    during bootstrap.  These automatically-assigned OIDs are not considered
    stable, and may change from one installation to another.
   </para>
  </sect2>

  <sect2 id="system-catalog-oid-references">
   <title>Recherche de référénce d'OID</title>

   <para>
    In principle, cross-references from one initial catalog row to another
    could be written just by writing the preassigned OID of the referenced
    row in the referencing field.  However, that is against project
    policy, because it is error-prone, hard to read, and subject to
    breakage if a newly-assigned OID is renumbered.  Therefore
    <filename>genbki.pl</filename> provides mechanisms to write
    symbolic references instead.
    The rules are as follows:
   </para>

   <itemizedlist>

    <listitem>
     <para>
      L'utilisation de références symboliques est activée pour une colonne
      en particulier en attachant
      <literal>BKI_LOOKUP(<replaceable>lookuprule</replaceable>)</literal>
      à la définition de la colonne, où <replaceable>lookuprule</replaceable>
      est the name of the referenced catalog, e.g. <literal>pg_proc</literal>.
      <literal>BKI_LOOKUP</literal> peut être attaché aux colonnes de type
      <type>Oid</type>, <type>regproc</type>, <type>oidvector</type>,
      ou <type>Oid[]</type>&nbsp;; dans les deux derniers cas, cela implique
      d'effectuer une recherche pour chaque élément du tableau.
     </para>
    </listitem>

    <listitem>
     <para>
      Dans une telle colonne, toutes les entrées doivent utiliser le format
      symbolique sauf quand on écrit <literal>0</literal> pour InvalidOid.  (Si
      la colonne est déclarée <type>regproc</type>, vous pouvez facultativement
      écrire <literal>-</literal> à la place de <literal>0</literal>.)
      <filename>genbki.pl</filename> vous avertira sur des noms non reconnus.
     </para>
    </listitem>

    <listitem>
     <para>
      It's also permissible to attach <literal>BKI_LOOKUP(encoding)</literal>
      to integer columns to reference character set encodings, which are
      not currently represented as catalog OIDs, but have a set of values
      known to <filename>genbki.pl</filename>.
     </para>
    </listitem>

    <listitem>
     <para>
      Most kinds of catalog objects are simply referenced by their names.
      Note that type names must exactly match the
      referenced <structname>pg_type</structname>
      entry's <structfield>typname</structfield>; you do not get to use
      any aliases such as <literal>integer</literal>
      for <literal>int4</literal>.
     </para>
    </listitem>

    <listitem>
     <para>
      Une fonction peut être représentée par son
      <structfield>proname</structfield>, s'il est unique parmi les entrées
      de <filename>pg_proc.dat</filename> (cela fonctionne comme les entrées
      regproc).  Sinon, écrivez-les sous la forme
      <replaceable>proname(argtypename,argtypename,...)</replaceable>, comme
      pour regprocedure.  Les noms de type des arguments doivent être écrits
      exactement comme ils le sont dans les champs
      <structfield>proargtypes</structfield> des entrées de
      <filename>pg_proc.dat</filename>.  N'insérez aucun espace.
     </para>
    </listitem>

    <listitem>
     <para>
      Les oérateurs sont représentés par
      <replaceable>oprname(lefttype,righttype)</replaceable>,
      en écrivant les noms de type exactement comme ils apparaissent dans les
      <structfield>oprleft</structfield> et <structfield>oprright</structfield>
      des entrées de
      <filename>pg_operator.dat</filename>.
      (Écrivez <literal>0</literal> pour les opérandes omises d'un opérateur
      unaire.)
     </para>
    </listitem>

    <listitem>
     <para>
      Les noms des classes et familles d'opérateur ne sont uniques qu'au sein
      d'une méthode d'accès, elles sont donc représentées avec
      <replaceable>nom_methode_acces</replaceable><literal>/</literal><replaceable>nom_objet</replaceable>.
     </para>
    </listitem>

    <listitem>
     <para>
      Il n'est prévu de qualification par le schéma pour aucun de ces cas&nbsp;;
      tous les objects créés durant le bootstrap sont prévus pour être dans le
      schéma <literal>pg_catalog</literal>.
     </para>
    </listitem>

    <listitem>
     <para>
      In addition to the generic lookup mechanisms, there is a special
      convention that <literal>PGNSP</literal> is replaced by the OID of
      the <literal>pg_catalog</literal> schema,
      and <literal>PGUID</literal> is replaced by the OID of the bootstrap
      superuser role.  These usages are somewhat historical but so far
      there hasn't been a need to generalize them.
     </para>
    </listitem>
   </itemizedlist>

   <para>
    <filename>genbki.pl</filename> résout toutes les références symboliques
    pendant son exécution, et incrit de simples OID numériques dans les
    fichiers BKI émis.  Le processus client de bootstrap n'a donc pas besoin
    de gérer les références symboliques.
   </para>
  </sect2>

  <sect2 id="system-catalog-auto-array-types">
   <title>Automatic Creation of Array Types</title>

   <para>
    Most scalar data types should have a corresponding array type (that is,
    a standard varlena array type whose element type is the scalar type, and
    which is referenced by the <structfield>typarray</structfield> field of
    the scalar type's <structname>pg_type</structname>
    entry).  <filename>genbki.pl</filename> is able to generate
    the <structname>pg_type</structname> entry for the array type
    automatically in most cases.
   </para>

   <para>
    To use this facility, just write an <literal>array_type_oid
    =&gt; <replaceable>nnnn</replaceable></literal> metadata field in the
    scalar type's <structname>pg_type</structname> entry, specifying the OID
    to use for the array type.  You may then omit
    the <structfield>typarray</structfield> field, since it will be filled
    automatically with that OID.
   </para>

   <para>
    The generated array type's name is the scalar type's name with an
    underscore prepended.  The array entry's other fields are filled from
    <literal>BKI_ARRAY_DEFAULT(<replaceable>value</replaceable>)</literal>
    annotations in <filename>pg_type.h</filename>, or if there isn't one,
    copied from the scalar type.  (There's also a special case
    for <structfield>typalign</structfield>.)  Then
    the <structfield>typelem</structfield>
    and <structfield>typarray</structfield> fields of the two entries are
    set to cross-reference each other.
   </para>
  </sect2>

  <sect2 id="system-catalog-recipes">
   <title>Recettes pour éditer les fichiers de données</title>

   <para>
    Voici quelques suggestions pour les moyens les plus simples d'effectuer
    des tâches communes lors de la mise à jour de fichiers de données du
    catalogue.
   </para>

   <formalpara>
    <title>Ajouter une nouvelle colonne avec valeur par défaut à un
     catalogue&nbsp;:</title>
    <para>
     Ajoutez la colonne au fichier d'en-tête avec une annotation
     <literal>BKI_DEFAULT(<replaceable>valeur</replaceable>)</literal>
     Le fichier de données ne doit être ajusté en ajoutant le champ dans les
     lignes existantes que quand il est nécessaire d'avoir autre chose que la
     valeur par défaut.
    </para>
   </formalpara>

   <formalpara>
    <title>Ajouter une valeur par défaut à une colonne existant qui n'en a
     pas&nbsp;:</title>
    <para>
     Ajoutez une annotation <literal>BKI_DEFAULT</literal> au fichier d'en-tête,
     puis exécutez <literal>make reformat-dat-files</literal> pour supprimer les
     entrées de champ qui sont maintenant redondantes.
    </para>
   </formalpara>

   <formalpara>
    <title>Ajouter une colonne, qu'elle ait une valeur par défaut ou
     non&nbsp;:</title>
    <para>
     Supprimez la colonne de l'en-tête, puis exécutez <literal>make
     reformat-dat-files</literal> pour supprimer les entrées de champ maintenant
     inutiles.
    </para>
   </formalpara>

   <formalpara>
    <title>Changer ou supprimer une valeur par défaut existante&nbsp;:</title>
    <para>
     Vous ne pouvez pas simplement changer le fichier d'en-tête, puisque cela
     aurait pour conséquence une mauvaise interprétation des données actuelles.
     Tout d'abord, exécutez <literal>make expand-dat-files</literal> pour
     réécrire les fichiers de données avec toutes les valeurs par défaut
     insérées explicitement, puis modifiez ou supprimer l'annotation
     <literal>BKI_DEFAULT</literal>, puis exécutez <literal>make
     reformat-dat-files</literal> pour supprimer à nouveau les champs superflus.
    </para>
   </formalpara>

   <formalpara>
    <title>Édition en masse ad hoc&nbsp;:</title>
    <para>
     <filename>reformat_dat_file.pl</filename> peut être modifié pour effectuer
     différents types de changements en masse.  Cherchez les commentaires de
     blocs montrant où du code unique peut être inséré.  Dans l'exemple suivant,
     nous allons consolider deux champs booléans de
     <structname>pg_proc</structname> en un champ de type char&nbsp;:

     <orderedlist>
      <listitem>
       <para>
        Ajout de la nouvelle colonne, avec une valeur par défaut, à
        <filename>pg_proc.h</filename>:
<programlisting>
+    /* see PROKIND_ categories below */
+    char        prokind BKI_DEFAULT(f);
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        Création d'un nouveau script basé sur
        <filename>reformat_dat_file.pl</filename> pour insérer les valeurs
        appropriées à la volée&nbsp;:
<programlisting>
-           # At this point we have the full row in memory as a hash
-           # and can do any operations we want. As written, it only
-           # removes default values, but this script can be adapted to
-           # do one-off bulk-editing.
+           # One-off change to migrate to prokind
+           # Default has already been filled in by now, so change to other
+           # values as appropriate
+           if ($values{proisagg} eq 't')
+           {
+               $values{prokind} = 'a';
+           }
+           elsif ($values{proiswindow} eq 't')
+           {
+               $values{prokind} = 'w';
+           }
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        Lancement du nouveau script&nbsp;:
<programlisting>
$ cd src/include/catalog
$ perl  rewrite_dat_with_prokind.pl  pg_proc.dat
</programlisting>
        À cette étape, <filename>pg_proc.dat</filename> a la totalité des trois
        colonnes, <structfield>prokind</structfield>,
        <structfield>proisagg</structfield>
        et <structfield>proiswindow</structfield>, bien qu'elles n'apparaîtront
        que dans les lignes où elles ont des valeurs qui ne sont pas la valeur
        par défaut.
       </para>
      </listitem>

      <listitem>
       <para>
        Suppression de l'ancienne colonne de <filename>pg_proc.h</filename>&nbsp;:
<programlisting>
-    /* is it an aggregate? */
-    bool        proisagg BKI_DEFAULT(f);
-
-    /* is it a window function? */
-    bool        proiswindow BKI_DEFAULT(f);
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        Finalement, exécution de <literal>make reformat-dat-files</literal>
        pour supprimer les anciennes entrées inutiles de
        <filename>pg_proc.dat</filename>.
       </para>
      </listitem>
     </orderedlist>

     Pour plus d'exemples de scripts utilisés pour l'édition en masse, voir
     <filename>convert_oid2name.pl</filename>
     et <filename>remove_pg_type_oid_symbols.pl</filename> joints au message
     suivant&nbsp;:
     <ulink url="https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com"></ulink>
    </para>
   </formalpara>
  </sect2>
 </sect1>

 <sect1 id="bki-format">
  <title>Format des fichiers <acronym>BKI</acronym></title>

  <para>
   Cette section décrit l'interprétation des fichiers <acronym>BKI</acronym>
   par le moteur de <productname>PostgreSQL</productname>. Cette description
   est plus facile à comprendre si le fichier <filename>postgres.bki</filename>
   est utilisé comme exemple.
  </para>

  <para>
   L'entrée de <acronym>BKI</acronym> représente une séquence de commandes. Les
   commandes sont constituées de lexèmes
   (<foreignphrase>tokens</foreignphrase>) dont le nombre dépend de la syntaxe de
   la commande. Les lexèmes sont habituellement séparés par des espaces
   fines, mais en l'absence d'ambiguïté ce n'est pas nécessaire. Il n'y a pas
   de séparateur spécial pour les commandes&nbsp;; le prochain lexème qui ne
   peut syntaxiquement pas appartenir à la commande qui précède en lance une
   autre. (En général, il est préférable, pour des raisons de clarté, de
   placer toute nouvelle commande sur une nouvelle ligne.) Les lexèmes peuvent être
   des mots clés, des caractères spéciaux (parenthèses, virgules, etc.), nombres ou
   chaînes de caractères entre guillemets doubles. Tous sont sensibles à la
   casse.
  </para>

  <para>
   Les lignes qui débutent par <literal>#</literal> sont ignorées.
  </para>

 </sect1>

 <sect1 id="bki-commands">
  <title>Commandes <acronym>BKI</acronym></title>

  <variablelist>
   <varlistentry>
    <term>
     <literal>create</literal>
     <replaceable class="parameter">tablename</replaceable>
     <replaceable class="parameter">tableoid</replaceable>
     <optional><literal>bootstrap</literal></optional>
     <optional><literal>shared_relation</literal></optional>
     <optional><literal>rowtype_oid</literal> <replaceable>oid</replaceable></optional>
     (<replaceable class="parameter">name1</replaceable> =
     <replaceable class="parameter">type1</replaceable>
     <optional>FORCE NOT NULL | FORCE NULL </optional> <optional>,
     <replaceable class="parameter">name2</replaceable> =
     <replaceable class="parameter">type2</replaceable>
     <optional>FORCE NOT NULL | FORCE NULL </optional>,
     ...</optional>)
    </term>

    <listitem>
     <para>
      Crée une table nommée <replaceable class="parameter">nomtable</replaceable>,
      possédant l'OID
      <replaceable class="parameter">tableoid</replaceable> et composée des colonnes
      données entre parenthèses.
     </para>

     <para>
      Les types de colonnes suivants sont supportés directement par
      <filename>bootstrap.c</filename>: <type>bool</type>,
      <type>bytea</type>, <type>char</type> (1 byte),
      <type>name</type>, <type>int2</type>,
      <type>int4</type>, <type>regproc</type>, <type>regclass</type>,
      <type>regtype</type>, <type>text</type>,
      <type>oid</type>, <type>tid</type>, <type>xid</type>,
      <type>cid</type>, <type>int2vector</type>, <type>oidvector</type>,
      <type>_int4</type> (array), <type>_text</type> (array),
      <type>_oid</type> (array), <type>_char</type> (array),
      <type>_aclitem</type> (array). Bien qu'il soit possible de créer des
      tables contenant des colonnes d'autres types, cela ne peut pas être
      réalisé avant que <structname>pg_type</structname> ne soit créé et
      rempli avec les entrées
      appropriées. (Ce qui signifie en fait que seuls ces types de colonnes
      peuvent être utilisés dans les tables utilisant le
      <quote>bootstrap</quote> mais que les catalogues ne l'utilisant pas
      peuvent contenir tout type interne.)
     </para>

     <para>
      Quand <literal>bootstrap</literal> est précisé, la table est
      uniquement construite sur disque&nbsp;; rien n'est entré dans
      <structname>pg_class</structname>, <structname>pg_attribute</structname>,
      etc, pour cette table. Du coup, la table n'est pas accessible par les
      opérations SQL standard tant que ces entrées ne sont pas
      réalisées en dur (à l'aide de commandes <literal>insert</literal>).
      Cette option est utilisée pour créer <structname>pg_class</structname>, etc.
     </para>

     <para>
      La table est créée partagée si <literal>shared_relation</literal> est
      indiqué. L'OID du type de ligne
      de la table (OID de <structname>pg_type</structname>) peut en option
      être indiquée via la clause <literal>rowtype_oid</literal>&nbsp;; dans
      le cas contraire, un OID est automatiquement généré pour lui. (La clause
      <literal>rowtype_oid</literal> est inutile si
      <literal>bootstrap</literal> est spécifié, mais il peut néanmoins être
      fourni pour documentation.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>open</literal> <replaceable class="parameter">nomtable</replaceable>
    </term>

    <listitem>
     <para>
      Ouvre la table nommée
      <replaceable class="parameter">nomtable</replaceable>
      pour l'ajout de données. Toute table alors ouverte est fermée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>close</literal> <replaceable class="parameter">nomtable</replaceable>
    </term>

    <listitem>
     <para>
      Ferme la table ouverte. Le nom de la
      table peut-être indiqué pour vérification mais ce n'est pas nécessaire.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>insert</literal> <literal>(</literal> <optional><replaceable class="parameter">valeur_oid</replaceable></optional> <replaceable class="parameter">valeur1</replaceable> <replaceable class="parameter">valeur2</replaceable> ... <literal>)</literal>
    </term>

    <listitem>
     <para>
      Insère une nouvelle ligne dans la table ouverte en utilisant
      <replaceable class="parameter">valeur1</replaceable>,
      <replaceable class="parameter">valeur2</replaceable>, etc., comme valeurs de
      colonnes.
     </para>

     <para>
      La valeur NULL peut être indiquée en utilisant le mot clé spécial
      <literal>_null_</literal>. Les valeurs qui ne ressemblent pas à des
      identifiants ou des chaînes de nombre doivent être placées entre
      guillemets doubles.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>declare</literal> <optional><literal>unique</literal></optional>
     <literal>index</literal> <replaceable class="parameter">nomindex</replaceable>
     <replaceable class="parameter">oidindex</replaceable>
     <literal>on</literal> <replaceable class="parameter">nomtable</replaceable>
     <literal>using</literal> <replaceable class="parameter">nomam</replaceable>
     <literal>(</literal> <replaceable class="parameter">classeop1</replaceable>
     <replaceable class="parameter">nom1</replaceable>
     <optional>, ...</optional> <literal>)</literal>
    </term>

    <listitem>
     <para>
      Crée un index nommé
      <replaceable class="parameter">nomindex</replaceable>, d'OID
      <replaceable class="parameter">indexoid</replaceable>, sur la table nommée
      <replaceable class="parameter">nomtable</replaceable> en utilisant la
      méthode d'accès nommée <replaceable class="parameter">nomam</replaceable>.
      Les champs à indexer sont appelés
      <replaceable class="parameter">nom1</replaceable>,
      <replaceable class="parameter">nom2</replaceable> etc., et les classes d'opérateur à
      utiliser sont respectivement
      <replaceable class="parameter">classeop1</replaceable>,
      <replaceable class="parameter">classeop2</replaceable> etc.
      Le fichier index est créé et les entrées appropriées du catalogue sont
      ajoutées pour lui, mais le contenu de l'index n'est pas initialisé par
      cette commande.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>declare toast</literal>
     <replaceable class="parameter">toasttableoid</replaceable>
     <replaceable class="parameter">toastindexoid</replaceable>
     <literal>on</literal> <replaceable class="parameter">nomtable</replaceable>
    </term>

    <listitem>
     <para>
      Crée une table TOAST pour la table nommée
      <replaceable class="parameter">nomtable</replaceable>.
      La table TOAST se voit affecter l'OID
      <replaceable class="parameter">toasttableoid</replaceable>
      et son index l'OID
      <replaceable class="parameter">toastindexoid</replaceable>.
      Comme avec <literal>declare index</literal>, le remplissage de l'index
      est reporté.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>build indices</literal></term>

    <listitem>
     <para>
      Remplit les index précédemment déclarés.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect1>

 <sect1 id="bki-structure">
  <title>Structure du fichier <acronym>BKI</acronym> de <quote>bootstrap</quote></title>

  <para>
   La commande <literal>open</literal> ne peut pas être utilisée avant que les
   tables qu'elle utilise n'existent et n'aient des entrées pour la table à
   ouvrir. (Ces tables minimales sont <structname>pg_class</structname>,
   <structname>pg_attribute</structname>, <structname>pg_proc</structname> et
   <structname>pg_type</structname>.) Pour permettre le remplissage de ces
   tables elles-mêmes,
   <literal>create</literal> utilisé avec l'option <literal>bootstrap</literal>
   ouvre implicitement la table créée pour l'insertion de données.
  </para>

  <para>
   De la même façon, les commandes <literal>declare index</literal> et
   <literal>declare toast</literal> ne peuvent pas être utilisées tant que
   les catalogues systèmes dont elles ont besoin n'ont pas été créés et remplis.
  </para>

  <para>
   Du coup, la structure du fichier <filename>postgres.bki</filename> doit
   être&nbsp;:
   <orderedlist>
    <listitem>
     <para>
      <literal>create bootstrap</literal> une des tables critiques
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>insert</literal> les données décrivant au moins les tables critiques
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>close</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      À répéter pour les autres tables critiques.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>create</literal> (sans <literal>bootstrap</literal>) une table non critique
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>open</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>insert</literal> les données souhaitées
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>close</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      À répéter pour les autres tables non critiques.
     </para>
    </listitem>
    <listitem>
     <para>
      Définir les index et les tables TOAST.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>build indices</literal>
     </para>
    </listitem>
   </orderedlist>
  </para>

  <para>
   Il existe, sans doute, d'autres dépendances d'ordre non documentées.
  </para>
 </sect1>

 <sect1 id="bki-example">
  <title>Exemple BKI</title>

  <para>
   La séquence de commandes suivante crée la table
   <literal>test_table</literal> avec l'OID 420, trois colonnes
   <literal>oid</literal>, <literal>cola</literal> et <literal>colb</literal> de types respectifs
   <type>oid</type>, <type>int4</type> et <type>text</type> et insère deux lignes dans la
   table&nbsp;:
   <programlisting>create test_table 420 (oid = oid, cola = int4, colb = text)
open test_table
insert ( 421 1 "value1" )
insert ( 422 2 _null_ )
close test_table
   </programlisting>
  </para>
 </sect1>
</chapter>
