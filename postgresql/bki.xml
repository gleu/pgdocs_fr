<?xml version="1.0" encoding="UTF-8"?>
<chapter id="bki">
 <title>Déclaration du catalogue système et contenu initial</title>

 <para>
  <productname>PostgreSQL</productname> utilise de nombreux catalogues systèmes
  différents pour garder la trace de l'existence et les propriétés des objets
  des bases de données, tels que les tables et les fonctions.  Il n'y a aucune
  différence physique entre un catalogue système et une table utilisateur
  standard, mais le code C des processus clients connaît la structure et les
  propriétés de chaque catalogue, et peut les manipuler directement à un bas
  niveau.  Ainsi, par exemple, il est déconseillé de tenter de modifier la
  structure d'un catalogue à la volée&nbsp;; cela casserait de nombreuses suppositions
  inscrites dans le code C sur comment les lignes du catalogues sont arrangées.
  Mais les structures des catalogues peuvent changer entre plusieurs versions
  majeures.
 </para>

 <para>
  Les structures des catalogues sont déclarées dans des en-têtes de fichiers C
  spécialement formatées dans le répertoire
  <filename>src/include/catalog/</filename> du code source.  En particulier,
  il y a pour chaque catalogue un fichier d'en-tête nommé d'après le catalogue
  (par exemple, <filename>pg_class.h</filename> pour
  <structname>pg_class</structname>), qui définit l'ensemble des colonnes que
  le catalogue a, ainsi que certaines autres propriétés basique telles que son
  OID.  D'autres fichiers cruciaux définissant la structure du catalogue
  incluent <filename>indexing.h</filename>, qui définit les index présents sur
  tous les catalogues systèmes, et <filename>toasting.h</filename>, qui définit
  les tables TOAST pour les catalogues qui en ont besoin.
 </para>

 <para>
  Beaucoup des catalogues ont des données initiales qui doivent être chargées
  à l'intérieur durant la phase de <quote>bootstrap</quote>
  d'<application>initdb</application>, pour amener le système à un point où il
  est capable d'exécuter des ordres SQL.  (Par exemple,
  <filename>pg_class.h</filename> doit contenir une entrée pour lui-même, ainsi
  qu'autant d'entrées pour chacun des autres catalogues système et index.)
  Ces données initiales sont conservées dans un format éditable dans des
  fichiers de données qui sont également stockés dans le répertoire
  <filename>src/include/catalog/</filename>.  Par exemple,
  <filename>pg_proc.dat</filename> décrit toutes les lignes initiales qui
  doivent être insérées dans le catalogue <structname>pg_proc</structname>.
 </para>

 <para>
  Pour créer les fichiers de catalogue et y charger ces données initiales,
  un processus client fonctionnant en mode <quote>bootstrap</quote> lit un fichier
  <acronym>BKI</acronym> (Backend Interface) contenant les commandes et les
  données initiales.  Le fichier <filename>postgres.bki</filename> utilisé
  dans ce mode est préparé à partir des en-têtes et fichiers de données
  susmentionnés, en même temps que la création d'une distribution
  <productname>PostgreSQL</productname>, par un script Perl nommé
  <filename>genbki.pl</filename>.
  Bien qu'il soit spécifique à une version précise de
  <productname>PostgreSQL</productname>, <filename>postgres.bki</filename> ne
  dépend pas de la plateforme et est installé dans le sous-répertoire
  <filename>share</filename> de l'arborescence installée.
 </para>

 <para>
  <filename>genbki.pl</filename> produit également des fichiers d'en-tête
  dérivés pour chaque catalogue, par exemple <filename>pg_class_d.h</filename>
  pour le catalogue <structname>pg_class</structname>.  Ce fichier contient des
  définitions de macro automatiquement générées, et peut contenir d'autres
  macros, déclarations d'énumérations, etc qui peuvent être utiles pour du code
  C client qui lit un catalogue en particulier.
 </para>

 <para>
  La plupart des développeurs de PostgreSQL n'ont pas besoin de se préoccuper
  directement du fichier <acronym>BKI</acronym>, mais presque toutes les
  fonctionnalités non triviales ajoutées dans les processus clients
  nécessiteront de modifier les fichiers d'en-tête de catalogue et/ou les
  fichiers de données initiales.  Le reste de ce chapitre donne des informations
  sur ce sujet, et par soucis de complétude décrit le format de fichier
  <acronym>BKI</acronym>.
 </para>

 <sect1 id="system-catalog-declarations">
  <title>Règles de déclaration de catalogue système</title>

  <para>
   La partie cruciale d'un fichier d'en-tête de catalogue est une définition de
   structure C décrivant l'agencement de chaque ligne dans le catalogue.  Cela
   commence avec une macro <literal>CATALOG</literal>, qui, pour autant que le
   compilateur C est concerné, est juste un raccourci pour <literal>typedef
   struct FormData_<replaceable>catalogname</replaceable></literal>.
   Chaque champ dans cette structure donne naissance à une colonne de catalogue.
   Les champs peuvent être annotés en utilisant les macros de propriété BKI
   décrites dans <filename>genbki.h</filename>, par exemple pour définir une
   valeur par défaut pour un champ pour le marquer comme potentiellement NULL ou
   non. La ligne <literal>CATALOG</literal> peut également être annotée,
   avec d'autres macros de propriété décrites dans <filename>genbki.h</filename>,
   pour définir d'autres propriétés du catalogue dans son ensemble, par exemple
   s'il s'agit d'une relation partagée.
  </para>

  <para>
   Le code de cache du catalogue système (et la plupart du code concernant le
   catalogue en général) part du principe que la partie de taille fixe de toutes
   les lignes de tous les catalogues système sont vraiment présentes, car il
   associe cette déclaration de structure C sur elles.  Ainsi, tous les champs
   de longueur variable et tous les champs potentiellement NULL doivent être
   placés à la fin, et ils ne peuvent pas être accédés comme des champs de
   structure. Par exemple, si vous essayez de positionner
   <structname>pg_type</structname>.<structfield>typrelid</structfield> à
   NULL, cela échouerait quand certaines parties du code essaient de référencer
   <literal>typetup-&gt;typrelid</literal> (ou pire,
   <literal>typetup-&gt;typelem</literal>, car cela suit
   <structfield>typrelid</structfield>).  Cela aurait pour conséquence des
   erreurs aléatoires ou même des erreurs de segmentation.
  </para>

  <para>
   Comme protection contre ce type d'erreurs, les champs de longueur variable
   ou potentiellement NULL ne devraient pas être fait directement visibles
   pour le compilateur C. Cela se fait en les entourant de
   <literal>#ifdef CATALOG_VARLEN</literal> ... <literal>#endif</literal> (où
   <literal>CATALOG_VARLEN</literal> est un symbole qui n'est jamais défini).
   Cela empêche le code C d'imprudemment essayer d'accéder à des champs qui
   pourraient ne pas être là ou pourraient être à des décalage différents.
   Comme protection contre la création de lignes incorrectes, nous exigeons
   que toutes les colonnes qui devraient être non NULL soient marquées comme
   telles dans <structname>pg_attribute</structname>.  Le code de <quote>bootstrap</quote>
   marquera automatiquement les colonnes comme <literal>NOT NULL</literal> si
   elles sont de taille fixe et ne sont précédées d'aucune colonne potentiellement NULL.
   Quand cette règle ne convient pas, vous pouvez forcer un marquage correct en
   utilisant les annotations <literal>BKI_FORCE_NOT_NULL</literal> et
   <literal>BKI_FORCE_NULL</literal> selon les besoins.
  </para>

  <para>
   Le code client ne devrait pas inclure de fichier d'en-tête de catalogue
   <filename>pg_xxx.h</filename>, car ces fichiers peuvent contenir du code C
   qui ne compilerait pas en dehors des processus clients.  (Typiquement, cela
   arrive car ces fichiers contiennent également des déclarations pour des
   fonctions dans des fichiers de <filename>src/backend/catalog/</filename>.)
   À la place, le client peut inclure les en-têtes correspondantes
   <filename>pg_xxx_d.h</filename> générées, qui contiendront les OID définis
   par des <literal>#define</literal> et toute autre donnée qui peut être utile
   pour le code client.  Si vous voulez que des macros ou d'autre code soient
   visibles par le code client, écrivez <literal>#ifdef
   EXPOSE_TO_CLIENT_CODE</literal> ... <literal>#endif</literal> autour de cette
   section pour demander à <filename>genbki.pl</filename> de copier cette
   section dans l'en-tête <filename>pg_xxx_d.h</filename>.
  </para>

  <para>
   Une petite partie des catalogues est tellement fondamentale qu'ils ne peuvent
   même pas être créés par la commande <acronym>BKI</acronym>
   <literal>create</literal> qui est utilisée pour la plupart des catalogues,
   car cette commande a besoin d'écrire des informations dans ces catalogues
   pour décrire les nouveaux catalogues.  Ceux-ci sont appelés les catalogues
   <firstterm>bootstrap</firstterm>, et en définir un nécessite beaucoup de
   travail supplémentaire&nbsp;: vous devez manuellement préparer les entrées
   appropriées pour eux dans le contenu pré-chargé de
   <structname>pg_class</structname> et <structname>pg_type</structname>, et ces
   entrées auront besoin d'être modifiées pour les futures changements de la
   structure du catalogue.  (Les catalogues <quote>bootstrap</quote> nécessitent également des
   entrées pré-chargées dans <structname>pg_attribute</structname>, mais
   heureusement, <filename>genbki.pl</filename> gère maintenant cette corvée.)
   Évitez de faire des nouveaux catalogues comme catalogue <quote>bootstrap</quote> si cela est
   possible.
  </para>
 </sect1>

 <sect1 id="system-catalog-initial-data">
  <title>Données initiales du catalogue système</title>

  <para>
   Chaque catalogue qui a des données initiales créées manuellement (certains
   n'en ont pas) a un fichier <literal>.dat</literal> correspondant qui contient
   ses données initiales dans un format éditable.
  </para>

  <sect2 id="system-catalog-initial-data-format">
   <title>Format de fichier de données</title>

   <para>
    Chaque fichier <literal>.dat</literal> contient des structures de données
    Perl littérales qui sont simplement évaluées pour produire une structure
    de données en mémoire qui consiste en un tableau de références de hash, un
    par ligne de catalogue.  Un extrait de <filename>pg_database.dat</filename>
    légèrement modifié va vous décrire les fonctionnalités principales&nbsp;:
   </para>

<programlisting>
[

# A comment could appear here.
{ oid =&gt; '1', oid_symbol =&gt; 'TemplateDbOid',
  descr =&gt; 'database\'s default template',
  datname =&gt; 'template1', encoding =&gt; 'ENCODING', datcollate =&gt; 'LC_COLLATE',
  datctype =&gt; 'LC_CTYPE', datistemplate =&gt; 't', datallowconn =&gt; 't',
  datconnlimit =&gt; '-1', datlastsysoid =&gt; '0', datfrozenxid =&gt; '0',
  datminmxid =&gt; '1', dattablespace =&gt; 'pg_default', datacl =&gt; '_null_' },

]
</programlisting>

   <para>
    Les points à noter&nbsp;:
   </para>

   <itemizedlist>

    <listitem>
     <para>
      La structure générale du fichier est&nbsp;: crochet ouvrant, un ensemble ou
      plus d'accolades qui chacune représentent une ligne de catalogue, crochet
      fermant.  Il faut mettre une virgule après chaque accolade fermante.
     </para>
    </listitem>

    <listitem>
     <para>
      Au sein de chaque ligne de catalogue, écrivez des paires de
      <replaceable>clé</replaceable> <literal>=&gt;</literal>
      <replaceable>valeur</replaceable> séparées par des virgules.  Les
      <replaceable>clé</replaceable>s autorisées sont les noms des colonnes du
      catalogue, ainsi que les clés de métadonnées <literal>oid</literal>,
      <literal>oid_symbol</literal>, <literal>array_type_oid</literal> et
      <literal>descr</literal>. (L'utilisation de <literal>oid</literal> et
      <literal>oid_symbol</literal> est décrite dans <xref
      linkend="system-catalog-oid-assignment"/> ci-dessous, alors que
      <literal>array_type_oid</literal> est décrite dans <xref
      linkend="system-catalog-auto-array-types"/>. <literal>descr</literal>
      fournit une chaîne de texte de description pour l'objet, qui sera
      insérée dans <structname>pg_description</structname> ou
      <structname>pg_shdescription</structname> selon le cas.)
      Bien que les clés de métadonnées soient facultatives, les colonnes
      définies pour le catalogue doivent toutes être fournies, sauf pour le cas
      où le fichier <literal>.h</literal> du catalogue définit une valeur par
      défaut pour la colonne.
      (Dans l'exemple ci-dessus, le champ <structfield>datdba</structfield> a
      été volontairement omis car <filename>pg_database.h</filename> en fournit
      une valeur appropriée par défaut.)
     </para>
    </listitem>

    <listitem>
     <para>
      Toutes les valeurs doivent être entourées de guillemets simples.  Il faut
      échapper les guillemets simples utilisés au sein d'une valeur avec un
      antislash.  Les antislash qui doivent être utilisés comme une donnée
      peuvent être doublés, mais cela n'est pas nécessaire&nbsp;; cela correspond aux
      règles Perl pour les littéraux entourés d'un guillemet simple.  Veuillez
      noter que les antislash apparaissant comme données seront traités comme
      des échappements par le scanner du <quote>bootstrap</quote>, d'après les mêmes règles que
      pour les échappements de chaînes de texte constantes (voir
      <xref linkend="sql-syntax-strings-escape"/>)&nbsp;; par exemple
      <literal>\t</literal> est converti en un caractère tabulation.  Si vous
      voulez un antislash dans la valeur finale, il vous faudra en écrire
      quatre&nbsp;: Perl en retire deux, laissant <literal>\\</literal> pour le
      scanner <quote>bootstrap</quote>.
     </para>
    </listitem>

    <listitem>
     <para>
      Les valeurs NULL sont représentées par <literal>_null_</literal>.
      (Veuillez noter qu'il n'y a aucun moyen de créer une valeur qui est
      simplement cette chaîne de texte.)
     </para>
    </listitem>

    <listitem>
     <para>
      Les commentaires sont précédés d'un <literal>#</literal>, et doivent être
      sur leur propre ligne.
     </para>
    </listitem>

    <listitem>
     <para>
      Les valeurs de champs référençant des OID d'autres entrées de catalogue
      devraient être représentées par des macros plutôt que par de vrais
      nombres OID. (Dans l'exemple ci-dessus,
      <structfield>dattablespace</structfield> contient une telle référence.)
      Cela est décrit dans <xref linkend="system-catalog-oid-references"/>
      ci-dessous.
     </para>
    </listitem>

    <listitem>
     <para>
      Puisque les hash sont des structures de données non triées, l'ordre des
      champs et des lignes ne sont pas sémantiquement significatifs.  Cependant,
      pour maintenir un aspect cohérent, nous définissions quelques règles qui
      sont appliquées par le script de formatage
      <filename>reformat_dat_file.pl</filename>&nbsp;:

      <itemizedlist>

       <listitem>
        <para>
         Au sein de chaque paire d'accolades, les champs de métadonnées
         <literal>oid</literal>, <literal>oid_symbol</literal>,
         <literal>array_type_oid</literal>
         et <literal>descr</literal> (si présent) apparaissent en premier, dans
         cet ordre, puis les champs propres au catalogue apparaissent dans leur
         ordre défini.
        </para>
       </listitem>

       <listitem>
        <para>
         Des retours à la ligne sont insérés entre les champs selon le besoin
         pour limiter la longueur de ligne à 80 caractères, si cela est
         possible.  Un retour à la ligne est également inséré entre les champs
         de métadonnées et les champs normaux.
        </para>
       </listitem>

       <listitem>
        <para>
         Si le fichier de catalogue <literal>.h</literal> spécifie une valeur
         par défaut pour la colonne, et qu'une entrée de donnée a la même
         valeur, <filename>reformat_dat_file.pl</filename> omettra cette valeur
         du fichier de données.  Cela conserve la représentation de données
         compacte.
        </para>
       </listitem>

       <listitem>
        <para>
         <filename>reformat_dat_file.pl</filename> conserve les lignes vides
         et les commentaires en l'état.
        </para>
       </listitem>

      </itemizedlist>

      Il est recommandé d'exécuter <filename>reformat_dat_file.pl</filename>
      avant de soumettre des patchs pour les données de catalogue.  Par
      commodité, vous pouvez simplement effectuer des changements dans
      <filename>src/include/catalog/</filename> et exécuter
      <literal>make reformat-dat-files</literal>.
     </para>
    </listitem>

    <listitem>
     <para>
      Si vous voulez ajouter une nouvelle méthode pour diminuer la taille de
      de la représentation des données, vous devez l'implémenter dans
      <filename>reformat_dat_file.pl</filename> et également apprendre à
      <function>Catalog::ParseData()</function> comment remettre les données
      dans leur représentation complète.
     </para>
    </listitem>

   </itemizedlist>
  </sect2>

  <sect2 id="system-catalog-oid-assignment">
   <title>Affectation d'OID</title>

   <para>
    Il est possible de donner un OID manuellement assigné à une ligne de
    catalogue apparaissant dans les données initiales en écrivant un champ de
    métadonnées <literal>oid =&gt; <replaceable>nnnn</replaceable></literal>.
    De plus, si un OID est assigné, une macro C pour cet OID peut être créée
    en écrivant un champ de métadonnée <literal>oid_symbol
    =&gt; <replaceable>nom</replaceable></literal>.
   </para>

   <para>
    Les lignes de catalogues préchargées doivent avoir des OID pré-assignés s'il
    y a des références d'OID pointant vers elles dans d'autres lignes
    pré-chargées.  Un OID pré-assigné est également nécessaire si l'OID de la
    ligne doit être référencé depuis le code C.  Si aucun de ces cas ne
    s'applique, le champ de métadonnée <literal>oid</literal> peut être omis,
    auquel cas le code de <quote>bootstrap</quote> assignera un OID automatiquement. En pratique, nous
    pré-assignons généralement des OID pour soit toutes soit aucune des lignes
    d'un catalogue donné, même si seulement une partie des lignes sont vraiment
    référencées dans d'autres catalogues.
   </para>

   <para>
    Écrire la vraie valeur numérique d'un OID dans le code C est considéré comme
    une très mauvaise pratique&nbsp;; il faut toujours utiliser une macro à la place.
    Des références directes à des OID de <structname>pg_proc</structname> sont
    suffisamment communes pour qu'il y ait un mécanisme spécial afin de créer
    les macros nécessaires automatiquement&nbsp;; voir
    <filename>src/backend/utils/Gen_fmgrtab.pl</filename>.  De même
    &mdash; mais, pour raisons historiques, fait d'une autre manière &mdash;
    il y a une méthode automatique pour créer les macros pour les OID de
    <structname>pg_type</structname>.  Les entrées de
    <literal>oid_symbol</literal> ne sont donc pas forcément dans ces deux
    catalogues.  De la même manière, les macros pour les OID de catalogue
    système et index <structname>pg_class</structname> sont positionnés
    automatiquement.  Pour tous les autres catalogues systèmes, vous devez
    spécifier manuellement toute macro dont vous avez besoin avec les entrées
    <literal>oid_symbol</literal>.
   </para>

   <para>
    Pour trouver un OID disponible pour une nouvelle ligne préchargée, exécutez
    le script <filename>src/include/catalog/unused_oids</filename>.  Il affiche
    l'intervalle inclusif d'OID inutilisés (par exemple, la ligne en sortie
    <quote>45-900</quote> signifie que les OID 45 jusqu'à 900 n'ont pas encore
    été alloués).  Pour le moment, les OID 1-9999 sont réservés pour des
    allocations manuelles&nbsp;; le script <filename>unused_oids</filename> regarde
    simplement dans les en-têtes de catalogue et les fichiers
    <filename>.dat</filename> pour voir lesquels n'apparaissent pas.  Vous
    pouvez également utiliser le script <filename>duplicate_oids</filename> pour
    trouver des erreurs.  (<filename>genbki.pl</filename> va allouer des OID
    à toutes les lignes qui n'en auraient pas reçu manuellement, et va aussi
    détecter les OID dupliqués au moment de la compilation.)
   </para>

   <para>
   	Lors du choix d'OID pour l'écriture d'un patch qui n'est pas supposé être
   	validé immédiatement, la bonne pratique est d'utiliser un groupe d'OID
   	plus-ou-moins consécutifs en commençant par un choix aléatoire dans
   	l'intervalle 8000&mdash;9999. Cela minimise le risque de collisions d'OID
   	avec d'autres patchs développés en parallèle. Pour garder l'intervalle
   	8000&mdash;9999 libre pour le développement, après qu'un patch ait été
   	validé sur le dépôt git principal, ces OID doivent être renumérotés dans
   	un intervalle inférieur libre. Typiquement, cela sera fait à l'approche
   	de la fin de chaque cycle de développement, déplaçant tous les OID
   	consommés par des patchs validés lors de ce cycle en même temps. Le script
   	<filename>renumber_oids.pl</filename> peut être utilisé pour faire cela.
   	Si un patch non validé contient des OID en conflit avec un patch récemment
   	validé, <filename>renumber_oids.pl</filename> peut aussi être utile pour
   	rétablir une telle situation.
   </para>

   <para>
   	À cause de cette convention de renumérotation des OID consommés par les
   	patchs, les OID attribués à un patch ne doivent pas être considérés comme
   	stables jusqu'à ce que celui-ci ait été inclus dans une version officielle.
   	Nous ne changeons toutefois pas les OID assignés manuellement une fois la
   	version sortie, car cela pourrait engendrer des problèmes de compatibilité.
   </para>

   <para>
   	Si <filename>genbki.pl</filename> a besoin d'assigner un OID à un
   	enregistrement du catalogue ne pouvant donc être un OID assigné
   	manuellement, il utilisera une valeur de l'intervalle 10000&mdash;11999.
   	Le compteur des OID serveur est défini à 12000 au début d'une phase de
   	<quote>bootstrap</quote>. Dès lors, les objets créés par des commandes SQL
   	classiques durant ladite phase de <quote>bootstrap</quote>, tels que des
   	les objets créés par le script <filename>information_schema.sql</filename>,
   	reçoivent des OID de 12000 et supérieur.
   </para>

   <para>
   	Les OID assignés durant les opérations normales de la base de données
   	sont contraints entre 16384 et plus. Cela assure que l'intervalle
   	10000&mdash;16383 soit libre pour l'assignation automatique d'OID par
   	<filename>genbki.pl</filename> ou pour la phase de <quote>bootstrap</quote>.
   	Ces OID assignés automatiquement ne sont pas considérés comme stables, et
   	peuvent changer d'une installation à l'autre.
   </para>
  </sect2>

  <sect2 id="system-catalog-oid-references">
   <title>Recherche de référence d'OID</title>

   <para>
   	En principe, la référence d'une ligne de catalogue vers une autre pourrait
   	être écrite juste en se servant de l'OID pré-assigné de la ligne à
   	référencer dans le champ la référençant. Cependant, cela va à l'encontre
   	de la politique du projet, car sujet aux erreurs, difficile à lire et
   	source d'incohérence si un OID nouvellement assigné est renuméroté.
   	C'est pourquoi <filename>genbki.pl</filename> fournit un mécanisme de
   	génération de macros à utiliser à la place.
   	Les règles sont les suivantes&nbsp;:
   </para>

   <itemizedlist>

    <listitem>
     <para>
      L'utilisation de références symboliques est activée pour une colonne
      en particulier en attachant
      <literal>BKI_LOOKUP(<replaceable>lookuprule</replaceable>)</literal>
      à la définition de la colonne, où <replaceable>lookuprule</replaceable>
      est le nom du catalogue référencé, par exemple <literal>pg_proc</literal>.
      <literal>BKI_LOOKUP</literal> peut être attaché aux colonnes de type
      <type>Oid</type>, <type>regproc</type>, <type>oidvector</type>,
      ou <type>Oid[]</type>&nbsp;; dans les deux derniers cas, cela implique
      d'effectuer une recherche pour chaque élément du tableau.
     </para>
    </listitem>

    <listitem>
     <para>
      Dans une telle colonne, toutes les entrées doivent utiliser le format
      symbolique sauf quand on écrit <literal>0</literal> pour InvalidOid.  (Si
      la colonne est déclarée <type>regproc</type>, vous pouvez facultativement
      écrire <literal>-</literal> à la place de <literal>0</literal>.)
      <filename>genbki.pl</filename> vous avertira sur des noms non reconnus.
     </para>
    </listitem>

    <listitem>
     <para>
      Il est également permis d'attacher <literal>BKI_LOOKUP(encoding)</literal>
      aux colonnes de type entier pour référencer les encodages de caractères,
      ce qui n'est actuellement pas représenté par des OID de catalogue, mais
      par un ensemble de valeurs connues de <filename>genbki.pl</filename>.
     </para>
    </listitem>

    <listitem>
     <para>
      La plupart des types d'objets du catalogue sont référencées par leurs noms.
      Notez que ces noms doivent être strictement identiques aux entrées
      <structfield>typname</structfield> de <structname>pg_type</structname>;
      vous ne pouvez pas utiliser d'alias comme <literal>integer</literal> à
      la place de <literal>int4</literal>.
     </para>
    </listitem>

    <listitem>
     <para>
      Une fonction peut être représentée par son
      <structfield>proname</structfield>, s'il est unique parmi les entrées
      de <filename>pg_proc.dat</filename> (cela fonctionne comme les entrées
      regproc).  Sinon, écrivez-les sous la forme
      <replaceable>proname(argtypename,argtypename,...)</replaceable>, comme
      pour <type>regprocedure</type>.  Les noms de type des arguments doivent être écrits
      exactement comme ils le sont dans les champs
      <structfield>proargtypes</structfield> des entrées de
      <filename>pg_proc.dat</filename>.  N'insérez aucun espace.
     </para>
    </listitem>

    <listitem>
     <para>
      Les opérateurs sont représentés par
      <replaceable>oprname(lefttype,righttype)</replaceable>,
      en écrivant les noms de type exactement comme ils apparaissent dans les
      <structfield>oprleft</structfield> et <structfield>oprright</structfield>
      des entrées de
      <filename>pg_operator.dat</filename>.
      (Écrivez <literal>0</literal> pour les opérandes omises d'un opérateur
      unaire.)
     </para>
    </listitem>

    <listitem>
     <para>
      Les noms des classes et familles d'opérateur ne sont uniques qu'au sein
      d'une méthode d'accès, elles sont donc représentées avec
      <replaceable>nom_methode_acces</replaceable><literal>/</literal><replaceable>nom_objet</replaceable>.
     </para>
    </listitem>

    <listitem>
     <para>
      Il n'est prévu de qualification par le schéma pour aucun de ces cas&nbsp;;
      tous les objets créés durant le <quote>bootstrap</quote> sont prévus pour être dans le
      schéma <literal>pg_catalog</literal>.
     </para>
    </listitem>

    <listitem>
     <para>
      En plus des mécanismes de recherche génériques, il y a une convention
      spéciale pour remplacer <literal>PGNSP</literal> par l'OID du schéma
      <literal>pg_catalog</literal> et <literal>PGUID</literal> par l'OID du
      rôle super-utilisateur effectuant le <quote>bootstrap</quote>.
      Ces coutumes sont historiques mais il n'y a jusqu'ici pas eu de
      nécessité de les généraliser.
     </para>
    </listitem>
   </itemizedlist>

   <para>
    <filename>genbki.pl</filename> résout toutes les références symboliques
    pendant son exécution, et inscrit de simples OID numériques dans les
    fichiers BKI émis.  Le processus client de <quote>bootstrap</quote> n'a donc pas besoin
    de gérer les références symboliques.
   </para>
  </sect2>

  <sect2 id="system-catalog-auto-array-types">
   <title>Création automatique des types de tableau</title>

   <para>
   	La plupart des types de données scalaires devraient avoir un type tableau
   	correspondant (en fait, un type de tableau <quote>varlena</quote> standard,
   	dont le type d'élément est un scalaire référencé par le champ
   	<structfield>typarray</structfield> de l'entrée de type scalaire de
   	<structname>pg_type</structname>). <filename>genbki.pl</filename> est
   	capable de générer l'entrée de <structname>pg_type</structname> pour le
   	type de tableau automatiquement dans la plupart des cas.
   </para>

   <para>
   	Pour se servir de cette fonctionnalité, il suffit d'inscrire un champ de
   	méta-données <literal>array_type_oid=&gt; <replaceable>nnnn</replaceable></literal>
   	dans l'entrée de type scalaire de <structname>pg_type</structname>,
   	spécifiant l'OID à utiliser pour le type de tableau. Vous pouvez ensuite
   	omettre le champ <structfield>typarray</structfield>, puisque l'OID y sera
   	automatiquement renseigné.
   </para>

   <para>
   	Le nom du type de tableau généré est le nom du type scalaire préfixé du
	tiret bas. Les autres champs du type de tableau sont remplis par les
	annotations <literal>BKI_ARRAY_DEFAULT(<replaceable>value</replaceable>)</literal>
	de <filename>pg_type.h</filename>, ou s'il n'y en a pas, copiés du type
	scalaire. (Il y a aussi un cas particulier pour <structfield>typalign</structfield>.)
	Ensuite, les champs <structfield>typelem</structfield> et
	<structfield>typarray</structfield> des deux enregistrements sont
	positionnés afin de se référencer l'un et l'autre.
   </para>
  </sect2>

  <sect2 id="system-catalog-recipes">
   <title>Recettes pour éditer les fichiers de données</title>

   <para>
    Voici quelques suggestions pour les moyens les plus simples d'effectuer
    des tâches communes lors de la mise à jour de fichiers de données du
    catalogue.
   </para>

   <formalpara>
    <title>Ajouter une nouvelle colonne avec valeur par défaut à un
     catalogue&nbsp;:</title>
    <para>
     Ajoutez la colonne au fichier d'en-tête avec une annotation
     <literal>BKI_DEFAULT(<replaceable>valeur</replaceable>)</literal>
     Le fichier de données ne doit être ajusté en ajoutant le champ dans les
     lignes existantes que quand il est nécessaire d'avoir autre chose que la
     valeur par défaut.
    </para>
   </formalpara>

   <formalpara>
    <title>Ajouter une valeur par défaut à une colonne existante qui n'en a
     pas&nbsp;:</title>
    <para>
     Ajoutez une annotation <literal>BKI_DEFAULT</literal> au fichier d'en-tête,
     puis exécutez <literal>make reformat-dat-files</literal> pour supprimer les
     entrées de champ qui sont maintenant redondantes.
    </para>
   </formalpara>

   <formalpara>
    <title>Ajouter une colonne, qu'elle ait une valeur par défaut ou
     non&nbsp;:</title>
    <para>
     Supprimez la colonne de l'en-tête, puis exécutez <literal>make
     reformat-dat-files</literal> pour supprimer les entrées du champ maintenant
     inutiles.
    </para>
   </formalpara>

   <formalpara>
    <title>Changer ou supprimer une valeur par défaut existante&nbsp;:</title>
    <para>
     Vous ne pouvez pas simplement changer le fichier d'en-tête, puisque cela
     aurait pour conséquence une mauvaise interprétation des données actuelles.
     Tout d'abord, exécutez <literal>make expand-dat-files</literal> pour
     réécrire les fichiers de données avec toutes les valeurs par défaut
     insérées explicitement, puis modifiez ou supprimez l'annotation
     <literal>BKI_DEFAULT</literal>, puis exécutez <literal>make
     reformat-dat-files</literal> pour supprimer à nouveau les champs superflus.
    </para>
   </formalpara>

   <formalpara>
    <title>Édition en masse ad hoc&nbsp;:</title>
    <para>
     <filename>reformat_dat_file.pl</filename> peut être modifié pour effectuer
     différents types de changements en masse.  Cherchez les commentaires de
     blocs montrant où du code unique peut être inséré.  Dans l'exemple suivant,
     nous allons consolider deux champs booléens de
     <structname>pg_proc</structname> en un champ de type char&nbsp;:

     <orderedlist>
      <listitem>
       <para>
        Ajout de la nouvelle colonne, avec une valeur par défaut, à
        <filename>pg_proc.h</filename>:
<programlisting>
+    /* see PROKIND_ categories below */
+    char        prokind BKI_DEFAULT(f);
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        Création d'un nouveau script basé sur
        <filename>reformat_dat_file.pl</filename> pour insérer les valeurs
        appropriées à la volée&nbsp;:
<programlisting>
-           # At this point we have the full row in memory as a hash
-           # and can do any operations we want. As written, it only
-           # removes default values, but this script can be adapted to
-           # do one-off bulk-editing.
+           # One-off change to migrate to prokind
+           # Default has already been filled in by now, so change to other
+           # values as appropriate
+           if ($values{proisagg} eq 't')
+           {
+               $values{prokind} = 'a';
+           }
+           elsif ($values{proiswindow} eq 't')
+           {
+               $values{prokind} = 'w';
+           }
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        Lancement du nouveau script&nbsp;:
<programlisting>
$ cd src/include/catalog
$ perl  rewrite_dat_with_prokind.pl  pg_proc.dat
</programlisting>
        À cette étape, <filename>pg_proc.dat</filename> a la totalité des trois
        colonnes, <structfield>prokind</structfield>,
        <structfield>proisagg</structfield>
        et <structfield>proiswindow</structfield>, bien qu'elles n'apparaîtront
        que dans les lignes où elles ont des valeurs qui ne sont pas la valeur
        par défaut.
       </para>
      </listitem>

      <listitem>
       <para>
        Suppression de l'ancienne colonne de <filename>pg_proc.h</filename>&nbsp;:
<programlisting>
-    /* is it an aggregate? */
-    bool        proisagg BKI_DEFAULT(f);
-
-    /* is it a window function? */
-    bool        proiswindow BKI_DEFAULT(f);
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        Finalement, exécution de <literal>make reformat-dat-files</literal>
        pour supprimer les anciennes entrées inutiles de
        <filename>pg_proc.dat</filename>.
       </para>
      </listitem>
     </orderedlist>

     Pour plus d'exemples de scripts utilisés pour l'édition en masse, voir
     <filename>convert_oid2name.pl</filename>
     et <filename>remove_pg_type_oid_symbols.pl</filename> joints au message
     suivant&nbsp;:
     <ulink url="https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com"></ulink>
    </para>
   </formalpara>
  </sect2>
 </sect1>

 <sect1 id="bki-format">
  <title>Format des fichiers <acronym>BKI</acronym></title>

  <para>
   Cette section décrit l'interprétation des fichiers <acronym>BKI</acronym>
   par le moteur de <productname>PostgreSQL</productname>. Cette description
   est plus facile à comprendre si le fichier <filename>postgres.bki</filename>
   est utilisé comme exemple.
  </para>

  <para>
   L'entrée de <acronym>BKI</acronym> représente une séquence de commandes. Les
   commandes sont constituées de lexèmes
   (<foreignphrase>tokens</foreignphrase>) dont le nombre dépend de la syntaxe de
   la commande. Les lexèmes sont habituellement séparés par des espaces
   fines, mais en l'absence d'ambiguïté ce n'est pas nécessaire. Il n'y a pas
   de séparateur spécial pour les commandes&nbsp;; le prochain lexème qui ne
   peut syntaxiquement pas appartenir à la commande qui précède en lance une
   autre. (En général, il est préférable, pour des raisons de clarté, de
   placer toute nouvelle commande sur une nouvelle ligne.) Les lexèmes peuvent être
   des mots clés, des caractères spéciaux (parenthèses, virgules, etc.), nombres ou
   chaînes de caractères entre guillemets doubles. Tous sont sensibles à la
   casse.
  </para>

  <para>
   Les lignes qui débutent par <literal>#</literal> sont ignorées.
  </para>

 </sect1>

 <sect1 id="bki-commands">
  <title>Commandes <acronym>BKI</acronym></title>

  <variablelist>
   <varlistentry>
    <term>
     <literal>create</literal>
     <replaceable class="parameter">tablename</replaceable>
     <replaceable class="parameter">tableoid</replaceable>
     <optional><literal>bootstrap</literal></optional>
     <optional><literal>shared_relation</literal></optional>
     <optional><literal>rowtype_oid</literal> <replaceable>oid</replaceable></optional>
     (<replaceable class="parameter">name1</replaceable> =
     <replaceable class="parameter">type1</replaceable>
     <optional>FORCE NOT NULL | FORCE NULL </optional> <optional>,
     <replaceable class="parameter">name2</replaceable> =
     <replaceable class="parameter">type2</replaceable>
     <optional>FORCE NOT NULL | FORCE NULL </optional>,
     ...</optional>)
    </term>

    <listitem>
     <para>
      Crée une table nommée <replaceable class="parameter">nomtable</replaceable>,
      possédant l'OID
      <replaceable class="parameter">tableoid</replaceable> et composée des colonnes
      données entre parenthèses.
     </para>

     <para>
      Les types de colonnes suivants sont supportés directement par
      <filename>bootstrap.c</filename>: <type>bool</type>,
      <type>bytea</type>, <type>char</type> (1 byte),
      <type>name</type>, <type>int2</type>,
      <type>int4</type>, <type>regproc</type>, <type>regclass</type>,
      <type>regtype</type>, <type>text</type>,
      <type>oid</type>, <type>tid</type>, <type>xid</type>,
      <type>cid</type>, <type>int2vector</type>, <type>oidvector</type>,
      <type>_int4</type> (array), <type>_text</type> (array),
      <type>_oid</type> (array), <type>_char</type> (array),
      <type>_aclitem</type> (array). Bien qu'il soit possible de créer des
      tables contenant des colonnes d'autres types, cela ne peut pas être
      réalisé avant que <structname>pg_type</structname> ne soit créé et
      rempli avec les entrées
      appropriées. (Ce qui signifie en fait que seuls ces types de colonnes
      peuvent être utilisés dans les tables utilisant le
      <quote>bootstrap</quote> mais que les catalogues ne l'utilisant pas
      peuvent contenir tout type interne.)
     </para>

     <para>
      Quand <literal>bootstrap</literal> est précisé, la table est
      uniquement construite sur disque&nbsp;; rien n'est entré dans
      <structname>pg_class</structname>, <structname>pg_attribute</structname>,
      etc, pour cette table. Du coup, la table n'est pas accessible par les
      opérations SQL standard tant que ces entrées ne sont pas
      réalisées en dur (à l'aide de commandes <literal>insert</literal>).
      Cette option est utilisée pour créer <structname>pg_class</structname>, etc.
     </para>

     <para>
      La table est créée partagée si <literal>shared_relation</literal> est
      indiqué. L'OID du type de ligne
      de la table (OID de <structname>pg_type</structname>) peut en option
      être indiquée via la clause <literal>rowtype_oid</literal>&nbsp;; dans
      le cas contraire, un OID est automatiquement généré pour lui. (La clause
      <literal>rowtype_oid</literal> est inutile si
      <literal>bootstrap</literal> est spécifié, mais il peut néanmoins être
      fourni pour documentation.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>open</literal> <replaceable class="parameter">nomtable</replaceable>
    </term>

    <listitem>
     <para>
      Ouvre la table nommée
      <replaceable class="parameter">nomtable</replaceable>
      pour l'ajout de données. Toute table alors ouverte est fermée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>close</literal> <replaceable class="parameter">nomtable</replaceable>
    </term>

    <listitem>
     <para>
      Ferme la table ouverte. Le nom de la
      table peut être indiqué pour vérification mais ce n'est pas nécessaire.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>insert</literal> <literal>(</literal> <optional><replaceable class="parameter">valeur_oid</replaceable></optional> <replaceable class="parameter">valeur1</replaceable> <replaceable class="parameter">valeur2</replaceable> ... <literal>)</literal>
    </term>

    <listitem>
     <para>
      Insère une nouvelle ligne dans la table ouverte en utilisant
      <replaceable class="parameter">valeur1</replaceable>,
      <replaceable class="parameter">valeur2</replaceable>, etc., comme valeurs de
      colonnes.
     </para>

     <para>
      La valeur NULL peut être indiquée en utilisant le mot clé spécial
      <literal>_null_</literal>. Les valeurs qui ne ressemblent pas à des
      identifiants ou à des chaînes de nombres doivent être placées entre
      guillemets doubles.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>declare</literal> <optional><literal>unique</literal></optional>
     <literal>index</literal> <replaceable class="parameter">nomindex</replaceable>
     <replaceable class="parameter">oidindex</replaceable>
     <literal>on</literal> <replaceable class="parameter">nomtable</replaceable>
     <literal>using</literal> <replaceable class="parameter">nomam</replaceable>
     <literal>(</literal> <replaceable class="parameter">classeop1</replaceable>
     <replaceable class="parameter">nom1</replaceable>
     <optional>, ...</optional> <literal>)</literal>
    </term>

    <listitem>
     <para>
      Crée un index nommé
      <replaceable class="parameter">nomindex</replaceable>, d'OID
      <replaceable class="parameter">indexoid</replaceable>, sur la table nommée
      <replaceable class="parameter">nomtable</replaceable> en utilisant la
      méthode d'accès nommée <replaceable class="parameter">nomam</replaceable>.
      Les champs à indexer sont appelés
      <replaceable class="parameter">nom1</replaceable>,
      <replaceable class="parameter">nom2</replaceable> etc., et les classes d'opérateur à
      utiliser sont respectivement
      <replaceable class="parameter">classeop1</replaceable>,
      <replaceable class="parameter">classeop2</replaceable> etc.
      Le fichier index est créé et les entrées appropriées du catalogue sont
      ajoutées pour lui, mais le contenu de l'index n'est pas initialisé par
      cette commande.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>declare toast</literal>
     <replaceable class="parameter">toasttableoid</replaceable>
     <replaceable class="parameter">toastindexoid</replaceable>
     <literal>on</literal> <replaceable class="parameter">nomtable</replaceable>
    </term>

    <listitem>
     <para>
      Crée une table TOAST pour la table nommée
      <replaceable class="parameter">nomtable</replaceable>.
      La table TOAST se voit affecter l'OID
      <replaceable class="parameter">toasttableoid</replaceable>
      et son index l'OID
      <replaceable class="parameter">toastindexoid</replaceable>.
      Comme avec <literal>declare index</literal>, le remplissage de l'index
      est reporté.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>build indices</literal></term>

    <listitem>
     <para>
      Remplit les index précédemment déclarés.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect1>

 <sect1 id="bki-structure">
  <title>Structure du fichier <acronym>BKI</acronym> de <quote>bootstrap</quote></title>

  <para>
   La commande <literal>open</literal> ne peut pas être utilisée avant que les
   tables qu'elle utilise n'existent et n'aient des entrées pour la table à
   ouvrir. (Ces tables minimales sont <structname>pg_class</structname>,
   <structname>pg_attribute</structname>, <structname>pg_proc</structname> et
   <structname>pg_type</structname>.) Pour permettre le remplissage de ces
   tables elles-mêmes,
   <literal>create</literal> utilisé avec l'option <literal>bootstrap</literal>
   ouvre implicitement la table créée pour l'insertion de données.
  </para>

  <para>
   De la même façon, les commandes <literal>declare index</literal> et
   <literal>declare toast</literal> ne peuvent pas être utilisées tant que
   les catalogues systèmes dont elles ont besoin n'ont pas été créés et remplis.
  </para>

  <para>
   Du coup, la structure du fichier <filename>postgres.bki</filename> doit
   être&nbsp;:
   <orderedlist>
    <listitem>
     <para>
      <literal>create bootstrap</literal> une des tables critiques
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>insert</literal> les données décrivant au moins les tables critiques
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>close</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      À répéter pour les autres tables critiques.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>create</literal> (sans <literal>bootstrap</literal>) une table non critique
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>open</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>insert</literal> les données souhaitées
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>close</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      À répéter pour les autres tables non critiques.
     </para>
    </listitem>
    <listitem>
     <para>
      Définir les index et les tables TOAST.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>build indices</literal>
     </para>
    </listitem>
   </orderedlist>
  </para>

  <para>
   Il existe, sans doute, d'autres dépendances d'ordre non documentées.
  </para>
 </sect1>

 <sect1 id="bki-example">
  <title>Exemple BKI</title>

  <para>
   La séquence de commandes suivante crée la table
   <literal>test_table</literal> avec l'OID 420, trois colonnes
   <literal>oid</literal>, <literal>cola</literal> et <literal>colb</literal> de types respectifs
   <type>oid</type>, <type>int4</type> et <type>text</type> et insère deux lignes dans la
   table&nbsp;:
   <programlisting>create test_table 420 (oid = oid, cola = int4, colb = text)
open test_table
insert ( 421 1 "value1" )
insert ( 422 2 _null_ )
close test_table
   </programlisting>
  </para>
 </sect1>
</chapter>
