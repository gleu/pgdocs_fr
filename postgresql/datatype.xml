<?xml version="1.0" encoding="UTF-8"?>
<chapter id="datatype">
 <title>Types de données</title>

 <indexterm zone="datatype">
  <primary>Types de données</primary>
 </indexterm>

 <indexterm>
  <primary>type</primary>
  <see>type de données</see>
 </indexterm>

 <para>
  <productname>PostgreSQL</productname> offre un large choix de types de
  données disponibles nativement. Les utilisateurs peuvent ajouter de nouveaux
  types à <productname>PostgreSQL</productname> en utilisant la commande <xref
  linkend="sql-createtype"/>.
 </para>

 <para>
  Le <xref linkend="datatype-table"/> montre tous les types de données
  généraux disponibles nativement. La plupart des types de données alternatifs
  listés dans la colonne <quote>Alias</quote> sont les noms utilisés en
  interne par <productname>PostgreSQL</productname> pour des raisons
  historiques. Il existe également d'autres types de données internes ou
  obsolètes, mais ils ne sont pas listés ici.
 </para>

 <table id="datatype-table">
  <title>Types de données</title>
  <tgroup cols="3">
   <colspec colnum="1" colwidth="2*"/>
   <colspec colnum="2" colwidth="1*"/>
   <colspec colnum="3" colwidth="2*"/>
   <thead>
    <row>
     <entry>Nom</entry>
     <entry>Alias</entry>
     <entry>Description</entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry><type>bigint</type></entry>
     <entry><type>int8</type></entry>
     <entry>Entier signé sur huit octets</entry>
    </row>

    <row>
     <entry><type>bigserial</type></entry>
     <entry><type>serial8</type></entry>
     <entry>Entier sur huit octets à incrémentation automatique</entry>
    </row>

    <row>
     <entry><type>bit [ (<replaceable>n</replaceable>) ]</type></entry>
     <entry></entry>
     <entry>Suite de bits de longueur fixe</entry>
    </row>

    <row>
     <entry><type>bit varying [ (<replaceable>n</replaceable>) ]</type></entry>
     <entry><type>varbit [ (<replaceable>n</replaceable>) ]</type></entry>
     <entry>Suite de bits de longueur variable</entry>
    </row>

    <row>
     <entry><type>boolean</type></entry>
     <entry><type>bool</type></entry>
     <entry>Booléen (Vrai/Faux)</entry>
    </row>

    <row>
     <entry><type>box</type></entry>
     <entry></entry>
     <entry>Boîte rectangulaire dans le plan</entry>
    </row>

    <row>
     <entry><type>bytea</type></entry>
     <entry></entry>
     <entry>Donnée binaire (<quote>tableau d'octets</quote>)</entry>
    </row>

    <row>
     <entry><type>character [ (<replaceable>n</replaceable>) ]</type></entry>
     <entry><type>char [ (<replaceable>n</replaceable>) ]</type></entry>
     <entry>Chaîne de caractères de longueur fixe</entry>
    </row>

    <row>
     <entry><type>character varying [ (<replaceable>n</replaceable>) ]</type></entry>
     <entry><type>varchar [ (<replaceable>n</replaceable>) ]</type></entry>
     <entry>Chaîne de caractères de longueur variable</entry>
    </row>

    <row>
     <entry><type>cidr</type></entry>
     <entry></entry>
     <entry>Adresse réseau IPv4 ou IPv6 </entry>
    </row>

    <row>
     <entry><type>circle</type></entry>
     <entry></entry>
     <entry>Cercle dans le plan</entry>
    </row>

    <row>
     <entry><type>date</type></entry>
     <entry></entry>
     <entry>Date du calendrier (année, mois, jour)</entry>
    </row>

    <row>
     <entry><type>double precision</type></entry>
     <entry><type>float8</type></entry>
     <entry>Nombre à virgule flottante de double précision (sur huit octets)</entry>
    </row>

    <row>
     <entry><type>inet</type></entry>
     <entry></entry>
     <entry>Adresse d'ordinateur IPv4 ou IPv6</entry>
    </row>

    <row>
     <entry><type>integer</type></entry>
     <entry><type>int</type>, <type>int4</type></entry>
     <entry>Entier signé sur quatre octets</entry>
    </row>

    <row>
     <entry><type>interval [ <replaceable>champs</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
     <entry></entry>
     <entry>Intervalle de temps</entry>
    </row>

    <row>
     <entry><type>json</type></entry>
     <entry></entry>
     <entry>Données texte JSON</entry>
    </row>

    <row>
     <entry><type>jsonb</type></entry>
     <entry></entry>
     <entry>Données binaires JSON, décomposées</entry>
    </row>

    <row>
     <entry><type>line</type></entry>
     <entry></entry>
     <entry>Droite (infinie) dans le plan</entry>
    </row>

    <row>
     <entry><type>lseg</type></entry>
     <entry></entry>
     <entry>Segment de droite dans le plan</entry>
    </row>

    <row>
     <entry><type>macaddr</type></entry>
     <entry></entry>
     <entry>Adresse MAC (pour <foreignphrase>Media Access
       Control</foreignphrase>)</entry>
    </row>

    <row>
     <entry><type>macaddr8</type></entry>
     <entry></entry>
     <entry>Adresse MAC (pour <foreignphrase>Media Access
       Control</foreignphrase>) (format EUI-64)</entry>
    </row>

    <row>
     <entry><type>money</type></entry>
     <entry></entry>
     <entry>Montant monétaire</entry>
    </row>

    <row>
     <entry><type>numeric [ (<replaceable>p</replaceable>,
       <replaceable>s</replaceable>) ]</type></entry>
     <entry><type>decimal [ (<replaceable>p</replaceable>,
       <replaceable>s</replaceable>) ]</type></entry>
     <entry>Nombre exact dont la précision peut être spécifiée</entry>
    </row>

    <row>
     <entry><type>path</type></entry>
     <entry></entry>
     <entry>Chemin géométrique dans le plan</entry>
    </row>

    <row>
     <entry><type>pg_lsn</type></entry>
     <entry></entry>
     <entry>Séquence numérique de journal (Log Sequence Number) de
      <productname>PostgreSQL</productname></entry>
    </row>

    <row>
     <entry><type>pg_snapshot</type></entry>
     <entry></entry>
     <entry>image (<foreignphrase>snapshot</foreignphrase>) de l'identifiant
      de transaction niveau utilisateur</entry>
    </row>

    <row>
     <entry><type>point</type></entry>
     <entry></entry>
     <entry>Point géométrique dans le plan</entry>
    </row>

    <row>
     <entry><type>polygon</type></entry>
     <entry></entry>
     <entry>Chemin géométrique fermé dans le plan</entry>
    </row>

    <row>
     <entry><type>real</type></entry>
     <entry><type>float4</type></entry>
     <entry>Nombre à virgule flottante de simple précision (sur quatre octets)</entry>
    </row>

    <row>
     <entry><type>smallint</type></entry>
     <entry><type>int2</type></entry>
     <entry>Entier signé sur deux octets</entry>
    </row>

    <row>
     <entry><type>smallserial</type></entry>
     <entry><type>serial2</type></entry>
     <entry>Entier sur deux octets à incrémentation automatique</entry>
    </row>

    <row>
     <entry><type>serial</type></entry>
     <entry><type>serial4</type></entry>
     <entry>Entier sur quatre octets à incrémentation automatique</entry>
    </row>

    <row>
     <entry><type>text</type></entry>
     <entry></entry>
     <entry>Chaîne de caractères de longueur variable</entry>
    </row>

    <row>
     <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
     <entry></entry>
     <entry>Heure du jour (sans fuseau horaire)</entry>
    </row>

    <row>
     <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
     <entry><type>timetz</type></entry>
     <entry>Heure du jour, avec fuseau horaire</entry>
    </row>

    <row>
     <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
     <entry></entry>
     <entry>Date et heure (sans fuseau horaire)</entry>
    </row>

    <row>
     <entry><type>timestamp [ (<replaceable>p</replaceable>) with time zone</type></entry>
     <entry><type>timestamptz</type></entry>
     <entry>Date et heure, avec fuseau horaire</entry>
    </row>

    <row>
     <entry><type>tsquery</type></entry>
     <entry></entry>
     <entry>requête pour la recherche plein texte</entry>
    </row>

    <row>
     <entry><type>tsvector</type></entry>
     <entry></entry>
     <entry>document pour la recherche plein texte</entry>
    </row>

    <row>
     <entry><type>txid_snapshot</type></entry>
     <entry></entry>
     <entry>image de l'identifiant de transaction au niveau utilisateur
      (déprécié&nbsp;; voir <type>pg_snapshot</type>)</entry>
    </row>

    <row>
     <entry><type>uuid</type></entry>
     <entry></entry>
     <entry>identifiant unique universel</entry>
    </row>

    <row>
     <entry><type>xml</type></entry>
     <entry></entry>
     <entry>données XML</entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <note>
  <title>Compatibilité</title>
  <para>
   Les types suivants sont conformes à la norme <acronym>SQL</acronym>&nbsp;:
   <type>bigint</type>, <type>bit</type>, <type>bit varying</type>,
   <type>boolean</type>, <type>char</type>, <type>character varying</type>,
   <type>character</type>, <type>varchar</type>, <type>date</type>,
   <type>double precision</type>, <type>integer</type>, <type>interval</type>,
   <type>numeric</type>, <type>decimal</type>, <type>real</type>,
   <type>smallint</type>, <type>time</type> (avec et sans fuseau horaire),
   <type>timestamp</type> (avec et sans fuseau horaire), <type>xml</type>.
  </para>
 </note>

 <para>
  Chaque type de données a une représentation externe déterminée par ses
  fonctions d'entrée et de sortie. De nombreux types de données internes ont
  un format externe évident. Cependant, certains types sont spécifiques à
  <productname>PostgreSQL</productname>, comme les chemins géométriques, ou
  acceptent différents formats, comme les types de données de date et d'heure.
  Certaines fonctions d'entrée et de sortie ne sont pas inversables&nbsp;: le
  résultat de la fonction de sortie peut manquer de précision comparé à
  l'entrée initiale.
 </para>

 <sect1 id="datatype-numeric">
  <title>Types numériques</title>

  <indexterm zone="datatype-numeric">
   <primary>Type de données</primary>
   <secondary>numeric</secondary>
  </indexterm>

  <para>
   Les types numériques sont constitués d'entiers de deux, quatre ou huit
   octets, de nombres à virgule flottante de quatre ou huit octets et de
   décimaux dont la précision peut être indiquée. Le <xref
   linkend="datatype-numeric-table"/> précise les types disponibles.
  </para>

  <table id="datatype-numeric-table">
   <title>Types numériques</title>
   <tgroup cols="4">
    <colspec colnum="1" colwidth="2*"/>
    <colspec colnum="2" colwidth="1*"/>
    <colspec colnum="3" colwidth="2*"/>
    <colspec colnum="4" colwidth="2*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Taille de stockage</entry>
      <entry>Description</entry>
      <entry>Étendue</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><type>smallint</type></entry>
      <entry>2 octets</entry>
      <entry>entier de faible étendue</entry>
      <entry>de -32768 à +32767</entry>
     </row>

     <row>
      <entry><type>integer</type></entry>
      <entry>4 octets</entry>
      <entry>entier habituel</entry>
      <entry>de -2147483648 à +2147483647</entry>
     </row>

     <row>
      <entry><type>bigint</type></entry>
      <entry>8 octets</entry>
      <entry>grand entier</entry>
      <entry>de -9223372036854775808 à +9223372036854775807</entry>
     </row>

     <row>
      <entry><type>decimal</type></entry>
      <entry>variable</entry>
      <entry>précision indiquée par l'utilisateur, valeur exacte</entry>
      <entry>jusqu'à 131072 chiffres avant le point décimal&nbsp;; jusqu'à
       16383 après le point décimal</entry>
     </row>

     <row>
      <entry><type>numeric</type></entry>
      <entry>variable</entry>
      <entry>précision indiquée par l'utilisateur, valeur exacte</entry>
      <entry>jusqu'à 131072 chiffres avant le point décimal&nbsp;; jusqu'à
       16383 après le point décimal</entry>
     </row>

     <row>
      <entry><type>real</type></entry>
      <entry>4 octets</entry>
      <entry>précision variable, valeur inexacte</entry>
      <entry>précision de 6 décimales</entry>
     </row>

     <row>
      <entry><type>double precision</type></entry>
      <entry>8 octets</entry>
      <entry>précision variable, valeur inexacte</entry>
      <entry>précision de 15 décimales</entry>
     </row>

     <row>
      <entry><type>smallserial</type></entry>
      <entry>2 bytes</entry>
      <entry>Entier sur 2 octets à incrémentation automatique</entry>
      <entry>1 to 32767</entry>
     </row>

     <row>
      <entry><type>serial</type></entry>
      <entry>4 octets</entry>
      <entry>entier à incrémentation automatique</entry>
      <entry>de 1 à 2147483647</entry>
     </row>

     <row>
      <entry><type>bigserial</type></entry>
      <entry>8 octets</entry>
      <entry>entier de grande taille à incrémentation automatique</entry>
      <entry>de 1 à 9223372036854775807</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   La syntaxe des constantes pour les types numériques est décrite dans la
   <xref linkend="sql-syntax-constants"/>. Les types numériques ont un
   ensemble complet d'opérateurs arithmétiques et de fonctions. On peut se
   référer au <xref linkend="functions"/> pour plus d'informations. Les
   sections suivantes décrivent ces types en détail.
  </para>

  <sect2 id="datatype-int">
   <title>Types entiers</title>

   <indexterm zone="datatype-int">
    <primary>integer</primary>
   </indexterm>

   <indexterm zone="datatype-int">
    <primary>smallint</primary>
   </indexterm>

   <indexterm zone="datatype-int">
    <primary>bigint</primary>
   </indexterm>

   <indexterm>
    <primary>int4</primary>
    <see>integer</see>
   </indexterm>

   <indexterm>
    <primary>int2</primary>
    <see>smallint</see>
   </indexterm>

   <indexterm>
    <primary>int8</primary>
    <see>bigint</see>
   </indexterm>

   <para>
    Les types <type>smallint</type>, <type>integer</type> et
    <type>bigint</type> stockent des nombres entiers, c'est-à-dire sans
    décimale, de différentes étendues. Toute tentative d'y stocker une valeur
    en dehors de l'échelle produit une erreur.
   </para>

   <para>
    Le type <type>integer</type> est le plus courant. Il offre un bon
    compromis entre capacité, espace utilisé et performance. Le type
    <type>smallint</type> n'est utilisé que si l'économie d'espace disque est
    le premier critère de choix. Le type <type>bigint</type> est conçu pour
    n'être utilisé que si l'échelle de valeurs du type <type>integer</type>
    n'est pas suffisante.
   </para>

   <para>
    <acronym>SQL</acronym> ne définit que les types de données
    <type>integer</type> (ou <type>int</type>), <type>smallint</type> et
    <type>bigint</type>. Les noms de types <type>int2</type>,
    <type>int4</type>, et <type>int8</type> sont des extensions, partagées par
    d'autres systèmes de bases de données <acronym>SQL</acronym>.
   </para>
  </sect2>

  <sect2 id="datatype-numeric-decimal">
   <title>Nombres à précision arbitraire</title>

   <indexterm>
    <primary>numeric (data type)</primary>
   </indexterm>

   <indexterm>
    <primary>nombres à virgule flottante</primary>
   </indexterm>

   <indexterm>
    <primary>decimal</primary>
    <see>numeric</see>
   </indexterm>

   <para>
    Le type <type>numeric</type> peut stocker des nombres contenant un très
    grand nombre de chiffres. Il est spécialement recommandé pour stocker les
    montants financiers et autres quantités pour lesquels l'exactitude est
    indispensable. Les calculs avec des valeurs <type>numeric</type> renvoient
    des résultats exacts quand c'est possible (addition, soustraction,
    multiplication). Néanmoins, les calculs sur les valeurs
    <type>numeric</type> sont très lents comparés aux types entiers ou aux
    types à virgule flottante décrits dans la section suivante.
   </para>

   <para>
    Dans ce qui suit, on utilise les termes suivants. La
    <firstterm>précision</firstterm> d'un <type>numeric</type> est le nombre
    total de chiffres significatifs dans le nombre complet, c'est-à-dire le
    nombre de chiffres de part et d'autre du séparateur.
    L'<firstterm>échelle</firstterm> d'un <type>numeric</type> est le nombre
    de chiffres décimaux de la partie fractionnaire, à droite du séparateur de
    décimales. Donc, le nombre 23.5141 a une précision de 6 et une échelle de
    4. On peut considérer que les entiers ont une échelle de 0.
   </para>

   <para>
    La précision maximale et l'échelle maximale d'une colonne
    <type>numeric</type> peuvent être toutes deux réglées. Pour déclarer une
    colonne de type numérique, il faut utiliser la syntaxe&nbsp;:
    <programlisting>NUMERIC(<replaceable>précision</replaceable>, <replaceable>échelle</replaceable>)</programlisting>
     La précision doit être strictement positive, l'échelle positive ou NULL.
     Alternativement&nbsp;:
<programlisting>NUMERIC(<replaceable>précision</replaceable>)</programlisting>
     indique une échelle de 0.
<programlisting>NUMERIC</programlisting>
     sans précision ni échelle crée une colonne dans laquelle on peut stocker
     des valeurs de n'importe quelle précision ou échelle, dans la limite de
     la précision implantée. Une colonne de ce type n'impose aucune précision
     à la valeur entrée, alors que les colonnes <type>numeric</type> ayant une
     échelle forcent les valeurs entrées à cette échelle. (Le standard
     <acronym>SQL</acronym> demande une précision par défaut de 0,
     c'est-à-dire de forcer la transformation en entier. Les auteurs trouvent
     cela inutile. Dans un souci de portabilité, il est préférable de toujours
     indiquer explicitement la précision et l'échelle.)
    </para>

    <note>
     <para>
      La précision maximale autorisée, si elle est explicitement spécifiée
      dans la déclaration du type, est de 1000. <type>NUMERIC</type> sans
      précision est sujet aux limites décrites dans <xref
      linkend="datatype-numeric-table"/>.
     </para>
    </note>

    <para>
     Si l'échelle d'une valeur à stocker est supérieure à celle de la colonne,
     le système arrondit la valeur au nombre de décimales indiqué pour la
     colonne. Si le nombre de chiffres à gauche du point décimal est supérieur
     à la différence entre la précision déclarée et l'échelle déclarée, une
     erreur est levée.
    </para>

    <para>
     Les valeurs numériques sont stockées physiquement sans zéro avant ou
     après. Du coup, la précision déclarée et l'échelle de la colonne sont des
     valeurs maximales, pas des allocations fixes (en ce sens, le type
     numérique est plus proche de
     <type>varchar(<replaceable>n</replaceable>)</type> que de
     <type>char(<replaceable>n</replaceable>)</type>). Le besoin pour le
     stockage réel est de deux octets pour chaque groupe de quatre chiffres
     décimaux, plus trois à huit octets d'en-tête.
    </para>

    <indexterm>
     <primary>NaN</primary>
     <see>not a number</see>
    </indexterm>

    <indexterm>
     <primary>not a number</primary>
     <secondary>numeric (type de données)</secondary>
    </indexterm>

    <para>
      En plus des valeurs numériques ordinaires, le type <type>numeric</type>
      autorise la valeur spéciale <literal>NaN</literal> qui signifie
      <quote>not-a-number</quote> (NdT&nbsp;: pas un nombre). Toute opération
      sur <literal>NaN</literal> retourne <literal>NaN</literal>. Pour écrire
      cette valeur comme une constante dans une requête SQL, elle doit être
      placée entre guillemets. Par exemple, <literal>UPDATE table SET x =
      'NaN'</literal>. En saisie, la chaîne <literal>NaN</literal> est
      reconnue, quelle que soit la casse utilisée.
    </para>

    <note>
     <para>
      Dans la plupart des implémentations du concept
      <quote>not-a-number</quote>, <literal>NaN</literal> est considéré
      différent de toute valeur numérique (ceci incluant
      <literal>NaN</literal>). Pour autoriser le tri des valeurs de type
      <type>numeric</type> et les utiliser dans des index basés sur le tri,
      <productname>PostgreSQL</productname> traite les valeurs
      <literal>NaN</literal> comme identiques entre elles, mais toutes
      supérieures aux valeurs non <literal>NaN</literal>.
     </para>
    </note>

    <para>
     Les types <type>decimal</type> et <type>numeric</type> sont équivalents.
     Les deux types sont dans le standard <acronym>SQL</acronym>.
    </para>

    <para>
     Lors de l'arrondissement de valeurs, le type <type>numeric</type>
     arrondit en s'éloignant de zéro, alors que (sur la plupart des machines)
     les types <type>real</type> et <type>double precision</type> arrondissent
     vers le nombre le plus proche. Par exemple&nbsp;:

<programlisting>
SELECT x,
  round(x::numeric) AS num_round,
  round(x::double precision) AS dbl_round
FROM generate_series(-3.5, 3.5, 1) as x;
  x   | num_round | dbl_round
------+-----------+-----------
 -3.5 |        -4 |        -4
 -2.5 |        -3 |        -2
 -1.5 |        -2 |        -2
 -0.5 |        -1 |        -0
  0.5 |         1 |         0
  1.5 |         2 |         2
  2.5 |         3 |         2
  3.5 |         4 |         4
(8 rows)
    </programlisting>
   </para>
  </sect2>


  <sect2 id="datatype-float">
   <title>Types à virgule flottante</title>

   <indexterm zone="datatype-float">
    <primary>real</primary>
   </indexterm>

   <indexterm zone="datatype-float">
    <primary>double precision</primary>
   </indexterm>

   <indexterm>
    <primary>float4</primary>
    <see>real</see>
   </indexterm>

   <indexterm>
    <primary>float8</primary>
    <see>double precision</see>
   </indexterm>

   <indexterm zone="datatype-float">
    <primary>floating point</primary>
   </indexterm>

   <para>
    Les types de données <type>real</type> et <type>double precision</type>
    sont des types numériques inexacts de précision variable. Sur toutes les
    plateformes actuellement supportées, ces types sont une implémentation du
    <quote><acronym>IEEE</acronym> Standard 754 for Binary Floating-Point
     Arithmetic</quote> (respectivement, simple et double précision), suivant
    le support fourni par le processeur, le système d'exploitation et le
    compilateur.
   </para>

   <para>
    Inexact signifie que certaines valeurs ne peuvent être converties
    exactement dans le format interne. Elles sont, de ce fait, stockées sous
    une forme approchée. Ainsi, stocker puis réafficher ces valeurs peut
    faire apparaître de légers écarts. Prendre en compte ces erreurs et la
    façon dont elles se propagent au cours des calculs est le sujet d'une
    branche entière des mathématiques et de l'informatique, qui n'est pas le
    sujet de ce document, à l'exception des points suivants&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       pour un stockage et des calculs exacts, comme pour les valeurs
       monétaires, le type <type>numeric</type> doit être privilégié&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       pour des calculs compliqués avec ces types pour quoi que ce soit
       d'important, et particulièrement pour le comportement aux limites
       (infini, zéro), l'implantation spécifique à la plateforme doit être
       étudiée avec soin&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       tester l'égalité de deux valeurs à virgule flottante peut ne pas
       donner le résultat attendu.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Sur toutes les plates-formes supportées, le type <type>real</type> a une
    étendue d'au moins 1E-37 à 1E37 avec une précision d'au moins six
    chiffres décimaux. Le type <type>double precision</type> a une étendue de
    1E-307 à 1E+308 avec une précision d'au moins quinze chiffres. Les
    valeurs trop grandes ou trop petites produisent une erreur. Un arrondi
    peut avoir lieu si la précision d'un nombre en entrée est trop grande.
    Les nombres trop proches de zéro qui ne peuvent être représentés
    autrement que par zéro produisent une erreur (underflow).
   </para>

   <para>
    Par défaut, les valeurs à virgule flottante sont renvoyées sous forme de
    texte dans leur représentation décimale la plus courte&nbsp;; la valeur
    décimale produite est plus proche de la vraie valeur binaire enregistrée
    que toute autre valeur représentable dans la même précision binaire.
    (Néanmoins, la valeur en sortie n'est en fait jamais
    <emphasis>exactement</emphasis> entre deux valeurs représentables, pour
    éviter un bug fréquent où les routines en entrée ne respectent pas la
    règle d'arrondi.) Cette valeur utilisera au plus les 17 chiffres décimaux
    significatifs pour des valeurs <type>float8</type>, et au plus 9 chiffres
    pour des valeurs <type>float4</type>.
   </para>

   <note>
    <para>
     Ce format de sortie le plus précis tout en étant le plus court est bien
     plus rapide à générer que le format arrondi historique.
    </para>
   </note>

   <para>
    Pour la compatibilité avec la sortie générée par les anciennes versions
    de <productname>PostgreSQL</productname> et pour permettre de réduire la
    précision de la sortie, le paramètre <xref
    linkend="guc-extra-float-digits"/> peut être utilisé pour sélectionner
    une sortie décimale arrondie à la place. Configurer une valeur 0 restaure
    le précédent comportement par défaut avec un arrondi à de la valeur aux 6
    (pour <type>float4</type>) ou 15 (pour <type>float8</type>) chiffres
    décimaux significatifs. Configurer une valeur négative réduit encore plus
    le nombre de chiffres&nbsp;; par exemple, -2 arrondirait la sortie à,
    respectivement, 4 ou 13 chiffres.
   </para>

   <para>
    Toute valeur de <xref linkend="guc-extra-float-digits"/> supérieure à 0
    sélectionne le format précis le plus court.
   </para>

   <note>
    <para>
     Les applications qui voulaient des valeurs précises devaient
     historiquement configurer <xref linkend="guc-extra-float-digits"/> à 3
     pour les obtenir. Pour un maximum de compatibilité entre les versions,
     elles doivent continuer à le faire.
    </para>
   </note>

   <note>
    <para>
     Le paramètre <xref linkend="guc-extra-float-digits"/> contrôle le nombre
     de chiffres significatifs inclus lorsqu'une valeur à virgule flottante
     est convertie en texte. Avec la valeur par défaut de
     <literal>0</literal>, la sortie est la même sur chaque plateforme
     supportée par PostgreSQL. L'augmenter va produire une sortie
     représentant plus précisément la valeur stockée, mais il est possible
     que la sortie soit différente suivant les plates-formes.
    </para>
   </note>

   <indexterm>
    <primary>not a number</primary>
    <secondary>double precision</secondary>
   </indexterm>

   <para>
    En plus des valeurs numériques ordinaires, les types à virgule flottante
    ont plusieurs valeurs spéciales&nbsp;:
    <literallayout><literal>Infinity</literal>
     <literal>-Infinity</literal>
     <literal>NaN</literal></literallayout>
    Elles représentent les valeurs spéciales de l'IEEE 754, respectivement
    <quote>infinity</quote> (NdT&nbsp;: infini), <quote>negative
     infinity</quote> (NdT&nbsp;: infini négatif) et
    <quote>not-a-number</quote> (NdT&nbsp;: pas un nombre). Lorsqu'elles sont
    saisies en tant que constantes dans une commande SQL, ces valeurs doivent
    être placées entre guillemets. Par exemple, <literal>UPDATE table SET x =
     '-Infinity'</literal>. En entrée, ces valeurs sont reconnues, quelle que
    soit la casse utilisée.
   </para>

   <note>
    <para>
     IEEE754 spécifie que <literal>NaN</literal> ne devrait pas être
     considéré égale à toute autre valeur en virgule flottante (ceci incluant
     <literal>NaN</literal>). Pour permettre le tri des valeurs en virgule
     flottante et leur utilisation dans des index basés sur des arbres,
     <productname>PostgreSQL</productname> traite les valeurs
     <literal>NaN</literal> comme identiques entre elles, mais supérieures à
     toute valeur différente de <literal>NaN</literal>.
    </para>
   </note>

   <para>
    <productname>PostgreSQL</productname> autorise aussi la notation
    <type>float</type> du standard SQL, ainsi que
    <type>float(<replaceable>p</replaceable>)</type> pour indiquer des types
    numériques inexacts. <replaceable>p</replaceable> indique la précision
    minimale acceptable en <emphasis>chiffres binaires</emphasis>.
    <productname>PostgreSQL</productname> accepte de <type>float(1)</type> à
    <type>float(24)</type>, qu'il transforme en type <type>real</type>, et de
    <type>float(25)</type> à <type>float(53)</type>, qu'il transforme en type
    <type>double precision</type>. Toute valeur de
    <replaceable>p</replaceable> hors de la zone des valeurs possibles
    produit une erreur. <type>float</type> sans précision est compris comme
    <type>double precision</type>.
   </para>
  </sect2>

  <sect2 id="datatype-serial">
   <title>Types seriés</title>

   <indexterm zone="datatype-serial">
    <primary>smallserial</primary>
   </indexterm>

   <indexterm zone="datatype-serial">
    <primary>serial</primary>
   </indexterm>

   <indexterm zone="datatype-serial">
    <primary>bigserial</primary>
   </indexterm>

   <indexterm zone="datatype-serial">
    <primary>serial2</primary>
   </indexterm>

   <indexterm zone="datatype-serial">
    <primary>serial4</primary>
   </indexterm>

   <indexterm zone="datatype-serial">
    <primary>serial8</primary>
   </indexterm>

   <indexterm>
    <primary>auto-increment</primary>
    <see>serial</see>
   </indexterm>

   <indexterm>
    <primary>séquence</primary>
    <secondary>type serial</secondary>
   </indexterm>

   <note>
    <para>
     Cette section décrit une façon spécifique à PostgreSQL de créer une
     colonne autoincrémentée. Une autre façon revient à utiliser les colonnes
     d'identité, décrite sur <xref linkend="sql-createtable"/>.
    </para>
   </note>

   <para>
    Les types de données <type>smallserial</type>, <type>serial</type> et
    <type>bigserial</type> ne sont pas de vrais types, mais plutôt un
    raccourci de notation pour créer des colonnes d'identifiants uniques
    (similaires à la propriété <literal>AUTO_INCREMENT</literal> utilisée par
    d'autres SGBD). Dans la version actuelle, indiquer&nbsp;:

    <programlisting>CREATE TABLE <replaceable class="parameter">nom_de_table</replaceable> (
    <replaceable class="parameter">nom_de_colonne</replaceable> SERIAL
);</programlisting>

     est équivalent à écrire&nbsp;:

<programlisting>CREATE SEQUENCE <replaceable class="parameter">nom_de_table</replaceable>_<replaceable class="parameter">nom_de_colonne</replaceable>_seq AS integer;
CREATE TABLE <replaceable class="parameter">nom_de_table</replaceable> (
    <replaceable class="parameter">nom_de_colonne</replaceable> integer NOT NULL DEFAULT nextval('<replaceable class="parameter">nom_de_table</replaceable>_<replaceable class="parameter">nom_de_colonne</replaceable>_seq') NOT NULL
);
ALTER SEQUENCE <replaceable class="parameter">nom_de_table</replaceable>_<replaceable class="parameter">nom_de_colonne</replaceable>_seq OWNED BY <replaceable class="parameter">nom_de_table</replaceable>.<replaceable class="parameter">nom_de_colonne</replaceable>;</programlisting>

     Ainsi a été créée une colonne d'entiers dont la valeur par défaut est
     assignée par un générateur de séquence. Une contrainte <literal>NOT
     NULL</literal> est ajoutée pour s'assurer qu'une valeur NULL ne puisse
     pas être insérée. (Dans la plupart des cas, une contrainte
     <literal>UNIQUE</literal> ou <literal>PRIMARY KEY</literal> peut être
     ajoutée pour interdire que des doublons soient créés par accident, mais
     ce n'est pas automatique.) Enfin, la séquence est marquée <quote>owned
     by</quote> (possédée par) la colonne pour qu'elle soit supprimée si la
     colonne ou la table est supprimée.
    </para>

    <note>
     <para>
      Comme <type>smallserial</type>, <type>serial</type> et
      <type>bigserial</type> sont implémentés en utilisant des séquences, il
      peut y avoir des trous dans la séquence de valeurs qui apparait dans la
      colonne, même si aucune ligne n'est jamais supprimée. Une valeur allouée
      à partir de la séquence est toujours utilisée même si la ligne contenant
      cette valeur n'est pas insérée avec succès dans la colonne de la table.
      Cela peut survenir si la transaction d'insertion est annulée. Voir
      <literal>nextval()</literal> dans <xref linkend="functions-sequence"/>
      pour plus de détails.
     </para>
    </note>

    <para>
     Pour insérer la valeur suivante de la séquence dans la colonne
     <type>serial</type>, il faut préciser que la valeur par défaut de la
     colonne doit être utilisée. Cela peut se faire de deux façons&nbsp;: soit
     en excluant cette colonne de la liste des colonnes de la commande
     <command>INSERT</command>, soit en utilisant le mot-clé
     <literal>DEFAULT</literal>.
    </para>

    <para>
     Les types <type>serial</type> et <type>serial4</type> sont
     identiques&nbsp;: ils créent tous les deux des colonnes
     <type>integer</type>. Les types <type>bigserial</type> et
     <type>serial8</type> fonctionnent de la même façon, mais créent des
     colonnes <type>bigint</type>. <type>bigserial</type> doit être utilisé si
     plus de 2<superscript>31</superscript> identifiants sont prévus sur la
     durée de vie de la table. Les noms de type <type>smallserial</type> et
     <type>serial2</type> fonctionnent de la même façon, sauf qu'ils créent
     une colonne de type <type>smallint</type>.
    </para>

    <para>
     La séquence créée pour une colonne <type>serial</type> est
     automatiquement supprimée quand la colonne correspondante est supprimée.
     La séquence peut être détruite sans supprimer la colonne, mais la valeur
     par défaut de la colonne est alors également supprimée.
    </para>
   </sect2>
  </sect1>

  <sect1 id="datatype-money">
   <title>Types monétaires</title>

   <para>
    Le type <type>money</type> stocke un montant en devise avec un nombre fixe
    de décimales. Voir le <xref linkend="datatype-money-table"/>. La précision
    de la partie fractionnée est déterminée par le paramètre <xref
    linkend="guc-lc-monetary"/> de la base de données. L'échelle indiquée dans
    la table suppose qu'il y a deux chiffres dans la partie fractionnée. De
    nombreux formats sont acceptés en entrée, dont les entiers et les nombres
    à virgule flottante, ainsi que les formats classiques de devises, comme
    <literal>'$1,000.00'</literal>. Le format de sortie est généralement dans
    le dernier format, mais dépend de la locale.
   </para>

    <table id="datatype-money-table">
     <title>Types monétaires</title>
     <tgroup cols="4">
     <colspec colnum="1" colwidth="2*"/>
     <colspec colnum="2" colwidth="1*"/>
     <colspec colnum="3" colwidth="2*"/>
     <colspec colnum="4" colwidth="2*"/>
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Taille de stockage</entry>
        <entry>Description</entry>
        <entry>Étendue</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>money</type></entry>
        <entry>8 octets</entry>
        <entry>montant monétaire</entry>
        <entry>-92233720368547758.08 à +92233720368547758.07</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Comme la sortie de type de données est sensible à la locale, la recharge
    de données de type <type>money</type> dans une base de données pourrait ne
    pas fonctionner si la base a une configuration différente pour
    <varname>lc_monetary</varname>. Pour éviter les problèmes, avant de
    restaurer une sauvegarde dans une nouvelle base de données, assurez-vous
    que <varname>lc_monetary</varname> a la même valeur ou une valeur
    équivalente à celle de la base qui a été sauvegardée.
   </para>

   <para>
    Les valeurs de types <type>numeric</type>, <type>int</type> et
    <type>bigint</type> peuvent être converties en type <type>money</type>. La
    conversion à partir du type <type>real</type> et <type>double
    precision</type> peut être faite en convertissant tout d'abord vers le
    type <type>numeric</type>. Par exemple&nbsp;:
<programlisting>
SELECT '12.34'::float8::numeric::money;
    </programlisting>
    Néanmoins, ce n'est pas recommandé. Les nombres à virgules flottantes ne
    doivent pas être utilisés pour gérer de la monnaie à cause des erreurs
    potentielles d'arrondis.
   </para>

   <para>
    Une valeur <type>money</type> peut être convertie en <type>numeric</type>
    sans perdre de précision. Les conversions vers d'autres types peuvent
    potentiellement perdre en précision et doivent aussi se faire en deux
    étapes&nbsp;:
    <programlisting>
SELECT '52093.89'::money::numeric::float8;
    </programlisting>
   </para>

   <para>
    La division d'une valeur de type <type>money</type> par une valeur de type
    entier est réalisée en tronquant la partie décimale. Pour obtenir un
    résultat arrondi, il faut diviser par une valeur en virgule flottante ou
    convertir la valeur de type <type>money</type> en <type>numeric</type>
    avant de réaliser la division. Il faudra ensuite convertir vers le type
    <type>money</type>. (Cette dernière méthode est préférable pour éviter de
    perdre en précision.) Quand une valeur de type <type>money</type> est
    divisée par une autre valeur de type <type>money</type>, le résultat est
    du type <type>double precision</type> (c'est-à-dire un nombre pur, pas une
    monnaie). Les unités de monnaie s'annulent dans la division.
   </para>
  </sect1>


  <sect1 id="datatype-character">
   <title>Types caractère</title>

   <indexterm zone="datatype-character">
    <primary>Chaîne de caractères</primary>
    <secondary>types de données</secondary>
   </indexterm>

   <indexterm>
    <primary>Chaîne</primary>
    <see>Chaîne de caractères</see>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>character</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>character varying</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>text</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>char</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>varchar</primary>
   </indexterm>

   <table id="datatype-character-table">
    <title>Types caractère</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>character varying(<replaceable>n</replaceable>)</type>, <type>varchar(<replaceable>n</replaceable>)</type></entry>
       <entry>Longueur variable avec limite</entry>
      </row>
      <row>
       <entry><type>character(<replaceable>n</replaceable>)</type>, <type>char(<replaceable>n</replaceable>)</type></entry>
       <entry>longueur fixe, complété par des espaces</entry>
      </row>
      <row>
       <entry><type>text</type></entry>
       <entry>longueur variable illimitée</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Le <xref linkend="datatype-character-table"/> présente les types
    génériques disponibles dans <productname>PostgreSQL</productname>.
   </para>

   <para>
    <acronym>SQL</acronym> définit deux types de caractères principaux&nbsp;:
    <type>character varying(<replaceable>n</replaceable>)</type> et
    <type>character(<replaceable>n</replaceable>)</type> où <replaceable>n</replaceable>
    est un entier positif.
    Ces deux types permettent de stocker des chaînes de caractères de taille
    inférieure ou égale à <replaceable>n</replaceable> (ce ne sont pas des octets).
    Toute tentative
    d'insertion d'une chaîne plus longue conduit à une erreur, à moins que les
    caractères en excès ne soient tous des espaces, auquel cas la chaîne
    est tronquée à la taille maximale (cette exception étrange est imposée
    par la norme <acronym>SQL</acronym>).
    Si la chaîne à stocker est plus petite que la taille déclarée,
    les valeurs de type <type>character</type> sont complétées par des
    espaces, celles de type <type>character varying</type> sont stockées en
    l'état.
   </para>

   <para>
    Si une valeur est explicitement transtypée en
    <type>character varying(<replaceable>n</replaceable>)</type> ou en
    <type>character(<replaceable>n</replaceable>)</type>, une valeur trop
    longue est tronquée à <replaceable>n</replaceable> caractères sans
    qu'aucune erreur ne soit levée (ce comportement est aussi imposé par
    la norme <acronym>SQL</acronym>.)
   </para>

   <para>
    Les notations <type>varchar(<replaceable>n</replaceable>)</type> et
    <type>char(<replaceable>n</replaceable>)</type> sont des alias de
    <type>character varying(<replaceable>n</replaceable>)</type> et
    <type>character(<replaceable>n</replaceable>)</type>, respectivement.
    <type>character</type> sans indication de taille est équivalent à
    <type>character(1)</type>. Si <type>character varying</type> est
    utilisé sans indicateur de taille, le type accepte des chaînes de
    toute taille. Il s'agit là d'une spécificité de
    <productname>PostgreSQL</productname>.
   </para>

   <para>
    De plus, <productname>PostgreSQL</productname> propose aussi le type
    <type>text</type>, qui permet de stocker des chaînes de n'importe
    quelle taille. Bien que le type <type>text</type> ne soit pas
    dans le standard <acronym>SQL</acronym>, plusieurs autres systèmes de
    gestion de bases de données SQL le proposent également.
   </para>

   <!-- padded : complété, aligné, autre chose ? padding : remplissage -->
   <!-- trailing spaces : espaces finales -->
   <para>
    Les valeurs de type <type>character</type> sont complétées physiquement à
    l'aide d'espaces pour atteindre la longueur <replaceable>n</replaceable>
    indiquée. Ces valeurs sont également stockées et affichées de cette façon.
    Cependant, les espaces de remplissage sont traités comme sémantiquement non
    significatifs et sont donc ignorés lors de la comparaison de deux valeurs
    de type <type>character</type>.  Dans les collationnements où les espaces
    de remplissage sont significatifs, ce comportement peut produire des
    résultats inattendus, par exemple <command>SELECT 'a '::CHAR(2) collate "C" &lt;
     E'a\n'::CHAR(2)</command> retourne vrai, même si la locale
    <literal>C</literal> considérerait qu'un espace est plus grand qu'un
    retour chariot. Les espaces de remplissage  sont supprimés lors de la
    conversion d'une valeur <type>character</type> vers l'un des autres types
    chaîne.  Ces espaces <emphasis>ont</emphasis> une signification sémantique
    pour les valeurs de type <type>character varying</type> et
    <type>text</type>, et lors de l'utilisation de la correspondance de
    motifs, par exemple avec <literal>LIKE</literal> ou avec les expressions
    rationnelles.
   </para>

   <para>
    L'espace nécessaire pour une chaîne de caractères courte (jusqu'à 126 octets)
    est de un octet, plus la taille de la chaîne qui inclut le remplissage avec
    des espaces dans le cas du type <type>character</type>. Les chaînes plus
    longues ont quatre octets d'en-tête au lieu d'un seul. Les chaînes longues
    sont automatiquement compressées par le système, donc le besoin pourrait
    être moindre. Les chaînes vraiment très longues sont stockées dans des
    tables supplémentaires, pour qu'elles n'empêchent pas d'accéder rapidement
    à des valeurs plus courtes.
    Dans tous les cas, la taille maximale possible pour une chaîne de
    caractères est de l'ordre de 1 Go. (La taille maximale pour
    <replaceable>n</replaceable> dans la déclaration de type est inférieure.
    Il ne sert à rien de modifier ce comportement, car avec
    les encodages sur plusieurs octets, les nombres de caractères
    et d'octets peuvent être très différents. Pour stocker
    de longues chaînes sans limite supérieure précise, il est préférable
    d'utiliser les types
    <type>text</type> et <type>character varying</type> sans
    taille, plutôt que d'indiquer une limite de taille arbitraire.)
   </para>

   <tip>
    <para>
     Il n'y a aucune différence de performance parmi ces trois types, si ce
     n'est la place disque supplémentaire requise pour le type à remplissage
     et quelques cycles CPU supplémentaires pour vérifier la longueur lors du
     stockage dans une colonne contrainte par la taille. Bien que
     <type>character(<replaceable>n</replaceable>)</type> ait des avantages en
     termes de performance sur certains autres systèmes de bases de données, il
     ne dispose pas de ce type d'avantages dans
     <productname>PostgreSQL</productname>&nbsp;; en fait,
     <type>character(<replaceable>n</replaceable>)</type> est habituellement le
     plus lent des trois à cause des coûts de stockage supplémentaires. Dans la
     plupart des situations, les types <type>text</type> et <type>character
      varying</type> peuvent être utilisés à leur place.
    </para>
   </tip>

   <para>
    On peut se référer à la <xref linkend="sql-syntax-strings"/> pour obtenir plus d'informations
    sur la syntaxe des libellés de chaînes, et le <xref linkend="functions"/>
    pour des informations complémentaires sur les opérateurs et les fonctions.
    Le jeu de caractères de la base de données détermine celui
    utilisé pour stocker les valeurs texte&nbsp;; pour plus
    d'informations sur le support des jeux de caractères, se référer à
    la <xref linkend="multibyte"/>.
   </para>

   <example>
    <title>Utilisation des types caractère</title>

    <programlisting>CREATE TABLE test1 (a character(4));
INSERT INTO test1 VALUES ('ok');
SELECT a, char_length(a) FROM test1; -- <co id="co.datatype-char"/>
<computeroutput>
  a   | char_length
------+-------------
 ok   |           2
</computeroutput>

CREATE TABLE test2 (b varchar(5));
INSERT INTO test2 VALUES ('ok');
INSERT INTO test2 VALUES ('bien      ');
INSERT INTO test2 VALUES ('trop long');
<computeroutput>ERROR:  value too long for type character varying(5)</computeroutput>
INSERT INTO test2 VALUES ('trop long'::varchar(5)); -- troncature explicite
SELECT b, char_length(b) FROM test2;
<computeroutput>
   b   | char_length
-------+-------------
 ok    |           2
 bien  |           5
 trop  |           5
</computeroutput></programlisting>
    <calloutlist>
     <callout arearefs="co.datatype-char">
      <para>
       La fonction <function>char_length</function> est décrite dans
       la <xref linkend="functions-string"/>.
      </para>
     </callout>
    </calloutlist>
   </example>

   <para>
    Il y a deux autres types caractère de taille fixe dans
    <productname>PostgreSQL</productname>. Ils sont décrits dans le <xref
    linkend="datatype-character-special-table"/>. Le type <type>name</type>
    existe <emphasis>uniquement</emphasis> pour le stockage des identifiants
    dans les catalogues système et n'est pas destiné à être utilisé par
    les utilisateurs normaux. Sa taille est actuellement définie à 64 octets
    (63 utilisables plus le terminateur), mais doit être référencée en
    utilisant la constante <symbol>NAMEDATALEN</symbol> en code source
    <literal>C</literal>. La taille est
    définie à la compilation (et est donc ajustable pour des besoins
    particuliers). La taille maximale par défaut peut éventuellement être
    modifiée dans une
    prochaine version. Le type <type>"char"</type> (attention aux guillemets)
    est différent de <type>char(1)</type>, car il n'utilise qu'un seul octet
    de stockage. Il est utilisé dans les catalogues système comme un type
    d'énumération simpliste.
   </para>

    <table id="datatype-character-special-table">
     <title>Types caractères spéciaux</title>
     <tgroup cols="3">
     <colspec colnum="1" colwidth="1*"/>
     <colspec colnum="2" colwidth="1*"/>
     <colspec colnum="3" colwidth="2*"/>
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Taille de stockage</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>"char"</type></entry>
        <entry>1 octet</entry>
        <entry>type interne d'un octet</entry>
       </row>
       <row>
        <entry><type>name</type></entry>
        <entry>64 octets</entry>
        <entry>type interne pour les noms d'objets</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>

 <sect1 id="datatype-binary">
  <title>Types de données binaires</title>

  <indexterm zone="datatype-binary">
   <primary>binary data</primary>
  </indexterm>

  <indexterm zone="datatype-binary">
   <primary>bytea</primary>
  </indexterm>
   <para>
    Le type de données <type>bytea</type> permet de stocker des chaînes
    binaires&nbsp;; voir le <xref linkend="datatype-binary-table"/>.
   </para>

   <table id="datatype-binary-table">
    <title>Types de données binaires</title>
    <tgroup cols="3">
     <colspec colnum="1" colwidth="1*"/>
     <colspec colnum="2" colwidth="3*"/>
     <colspec colnum="3" colwidth="2*"/>
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Espace de stockage</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>bytea</type></entry>
       <entry>un à quatre octets plus la taille de la chaîne binaire à stocker</entry>
       <entry>Chaîne binaire de longueur variable</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Une chaîne binaire est une séquence d'octets. Les chaînes binaires
    se distinguent des chaînes de caractères de deux façons&nbsp;:
    tout d'abord, les chaînes binaires permettent de stocker des octets de
    valeurs zéro ainsi que les autres caractères <quote>non imprimables</quote>
    (habituellement, les octets en dehors de l'intervalle décimal de 32 à
    126). Les chaînes de caractères interdisent les octets de valeur zéro et
    interdisent aussi toute valeur d'octet ou séquence d'octets invalide
    selon l'encodage sélectionné pour la base
    de données. Ensuite, les opérations sur les chaînes binaires traitent
    réellement les octets alors que le traitement de chaînes de caractères
    dépend de la configuration de la locale. En résumé, les chaînes binaires
    sont appropriées pour le stockage de données que le développeur considère
    comme des <quote>octets bruts</quote>, alors que les chaînes de caractères sont
    appropriées pour le stockage de texte.
   </para>

   <para>
    Le type <type>bytea</type> accepte deux formats en entrée et en
    sortie&nbsp; le format <quote>hex</quote> et le format historique de
    <productname>PostgreSQL</productname>, <quote>escape</quote>. Les deux
    sont acceptés en entrée. Le format de sortie dépend du paramètre de
    configuration <xref linkend="guc-bytea-output"/>&nbsp;; ce dernier
    sélectionne par défaut le format hexadécimal. (Notez que le format
    hexadécimal est disponible depuis <productname>PostgreSQL</productname>
    9.0&nbsp;; les versions antérieures et certains outils ne le comprennent
    pas.)
   </para>

   <para>
    Le standard <acronym>SQL</acronym> définit un type de chaîne binaire
    différent, appelé <type>BLOB</type> ou <type>BINARY LARGE OBJECT</type>.
    Le format en entrée est différent du <type>bytea</type>, mais les fonctions
    et opérateurs fournis sont pratiquement les mêmes.
   </para>

  <sect2>
   <title>Le format hexadécimal <type>bytea</type></title>

   <para>
    Le format <quote>hex</quote> code les données binaires sous la forme de
    deux chiffres hexadécimaux par octet, le plus significatif en premier. La
    chaîne complète est précédée par la séquence <literal>\x</literal> (pour
    la distinguer du format d'échappement). Dans certains cas, l'antislash
    initial peut avoir besoin d'être échappé par un doublage du caractère
    (voir <xref linkend="sql-syntax-strings"/>). En saisie, les chiffres
    hexadécimaux peuvent être soit en majuscules, soit en minuscules, et les
    espaces blancs sont permis entre les paires de chiffres (mais pas à
    l'intérieur d'une paire ni dans la séquence <literal>\x</literal> de
    début). Le format hexadécimal est compatible avec une grande variété
    d'applications et de protocoles externes, et il a tendance à être plus
    rapide à convertir que le format d'échappement. Son utilisation est donc
    préférée.
   </para>

   <para>
    Exemple&nbsp;:
<programlisting>
SELECT '\xDEADBEEF';
    </programlisting>
   </para>
  </sect2>

  <sect2>
   <title>Le format d'échappement <type>bytea</type></title>

   <para>
    Le format d'échappement (<quote>escape</quote>) est le format traditionnel
    de <productname>PostgreSQL</productname> pour le type <type>bytea</type>.
    Son approche est de représenter une chaîne binaire comme un séquence de
    caractères ASCII et de convertir les données qui ne peuvent pas être
    représentées en ASCII en une séquence spéciale d'échappement. Si, du point
    de vue de l'application, représenter les octets sous la forme de
    caractères revêt un sens, alors cette représentation est intéressante. En
    pratique, c'est généralement source de confusion, car cela diminue la
    distinction entre chaînes binaires et chaînes textuelles. De plus, le
    mécanisme particulier de l'échappement qui a été choisi est quelque peu
    complexe.
    Donc ce format devrait probablement être évité pour la plupart des
    nouvelles applications.
   </para>

   <para>
    Lors de la saisie de valeurs <type>bytea</type> dans le format
    d'échappement, les octets de certaines valeurs <emphasis>doivent</emphasis>
    être échappés alors que les autres valeurs d'octets
    <emphasis>peuvent</emphasis> être échappés. En général, pour échapper un
    octet, il suffit de le convertir dans sa valeur octale composée de trois
    chiffres et de la faire précéder d'un antislash (ou de deux antislashs s'il
    faut utiliser la syntaxe d'échappement de chaînes). L'antislash lui-même
    (octet en valeur décimal, 92) peut alternativement être représenté par un double antislash.
    Le <xref linkend="datatype-binary-sqlesc"/>
    affiche les caractères qui doivent être échappés et donne les séquences
    d'échappement possibles.
   </para>

   <table id="datatype-binary-sqlesc">
    <title>Octets littéraux <type>bytea</type> à échapper</title>
    <tgroup cols="5">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="1*"/>
     <colspec colname="col3" colwidth="1*"/>
     <colspec colname="col4" colwidth="1.25*"/>
     <colspec colname="col5" colwidth="1*"/>
     <thead>
      <row>
       <entry>Valeur décimale de l'octet</entry>
       <entry>Description</entry>
       <entry>Représentation échappée en entrée</entry>
       <entry>Exemple</entry>
       <entry>Représentation hexadécimale</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>0</entry>
       <entry>octet zéro</entry>
       <entry><literal>'\000'</literal></entry>
       <entry><literal>'\000'::bytea;</literal></entry>
       <entry><literal>\x00</literal></entry>
      </row>

      <row>
       <entry>39</entry>
       <entry>apostrophe</entry>
       <entry><literal>''''</literal> ou <literal>'\047'</literal></entry>
       <entry><literal>''''::bytea;</literal></entry>
       <entry><literal>\x27</literal></entry>
      </row>

      <row>
       <entry>92</entry>
       <entry>antislash</entry>
       <entry><literal>'\\'</literal> or <literal>'\134'</literal></entry>
       <entry><literal>'\\'::bytea;</literal></entry>
       <entry><literal>\x5c</literal></entry>
      </row>

      <row>
       <entry>de 0 à 31 et de 127 à 255</entry>
       <entry>octets <quote>non affichables</quote></entry>
       <entry><literal>'\<replaceable>xxx'</replaceable></literal> (valeur octale)</entry>
       <entry><literal>'\001'::bytea;</literal></entry>
       <entry><literal>\x01</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    La nécessité d'échapper les octets <emphasis>non affichables</emphasis>
    dépend des paramétrages de la locale. Il est parfois possible de s'en
    sortir sans échappement.
   </para>

   <para>
    La raison pour laquelle les guillemets simples doivent être doublés, comme
    indiqué dans <xref linkend="datatype-binary-sqlesc"/>, est que cela est
    vrai pour toute chaîne litérale dans une commande SQL. L'analyseur
    générique des chaînes litérales utilise les guillemets simples externes et
    réduit toute paire de guillemets simples en un seul caractère. La fonction
    en entrée du type <type>bytea</type> ne voit qu'un guillemet simple, qu'il
    traire comme un caractère standard. Néanmoins, la fonction en entrée du
    type <type>bytea</type> traite les antislashs de façon spéciale et les
    autres comportements montrés dans <xref linkend="datatype-binary-sqlesc"/>
    sont implémentés par cette fonction.
   </para>

   <para>
    Dans certains contextes, les antislashs doivent être doublés par rapport à
    ce qui est montré ci-dessus car l'analyseur générique de chaîne litérale
    réduira aussi les paires d'antislashs en un seul caractère de
    données&nbsp;; voir <xref linkend="sql-syntax-strings"/>.
   </para>

   <para>
    Les octets <type>Bytea</type> sont affichés par défaut dans le format
    <literal>hex</literal>. Si vous modifiez <xref
    linkend="guc-bytea-output"/> à <literal>escape</literal>, les octets
    <quote>non affichables</quote> sont convertis dans leur équivalent sous la
    forme d'une valeur octale à trois chiffres et précédé d'un antislash. La
    plupart des octets <quote>affichables</quote> sont affichés dans leur
    représentation standard pour le jeu de caractères du client&nbsp;:

    <programlisting>
SET bytea_output = 'escape';

SELECT 'abc \153\154\155 \052\251\124'::bytea;
     bytea
----------------
 abc klm *\251T
    </programlisting>

    L'octet de valeur décimale 92 (antislash) est doublé en sortie. Les
    détails sont dans le <xref linkend="datatype-binary-resesc"/>.
   </para>

   <table id="datatype-binary-resesc">
    <title>Octets échappés en sortie pour <type>bytea</type></title>
    <tgroup cols="5">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="1*"/>
     <colspec colname="col3" colwidth="1*"/>
     <colspec colname="col4" colwidth="1.25*"/>
     <colspec colname="col5" colwidth="1*"/>
     <thead>
      <row>
       <entry>Valeur décimale de l'octet</entry>
       <entry>Description</entry>
       <entry>Représentation de sortie échappée</entry>
       <entry>Exemple</entry>
       <entry>Résultat en sortie</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry>92</entry>
       <entry>antislash</entry>
       <entry><literal>\\</literal></entry>
       <entry><literal>'\134'::bytea;</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>

      <row>
       <entry>0 à 31 et 127 à 255</entry>
       <entry>octets<quote>non affichables</quote></entry>
       <entry><literal>\<replaceable>xxx</replaceable></literal> (valeur octale)</entry>
       <entry><literal>'\001'::bytea;</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>

      <row>
       <entry>32 à 126</entry>
       <entry>octets <quote>affichables</quote></entry>
       <entry>Représentation dans le jeu de caractères du client</entry>
       <entry><literal>'\176'::bytea;</literal></entry>
       <entry><literal>~</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    En fonction de l'interface utilisée pour accéder à
    <productname>PostgreSQL</productname>, un travail supplémentaire
    d'échappement/de &laquo;&nbsp;déséchappement&nbsp;&raquo; des chaînes
    <type>bytea</type> peut être
    nécessaire. Il faut également
    échapper les sauts de lignes et retours à la ligne si l'interface les
    traduit automatiquement, par exemple.
   </para>

  </sect2>
 </sect1>


 <sect1 id="datatype-datetime">
  <title>Types date/heure</title>

  <indexterm zone="datatype-datetime">
   <primary>date</primary>
  </indexterm>
  <indexterm zone="datatype-datetime">
   <primary>time</primary>
  </indexterm>
  <indexterm zone="datatype-datetime">
   <primary>time without time zone</primary>
  </indexterm>
  <indexterm zone="datatype-datetime">
   <primary>time with time zone</primary>
  </indexterm>
  <indexterm zone="datatype-datetime">
   <primary>timestamptz</primary>
  </indexterm>
  <indexterm zone="datatype-datetime">
   <primary>timestamp</primary>
  </indexterm>
  <indexterm zone="datatype-datetime">
   <primary>timestamp with time zone</primary>
  </indexterm>
  <indexterm zone="datatype-datetime">
   <primary>timestamp without time zone</primary>
  </indexterm>
  <indexterm zone="datatype-datetime">
   <primary>interval</primary>
  </indexterm>
  <indexterm zone="datatype-datetime">
   <primary>time span</primary>
  </indexterm>
  <para>
   <productname>PostgreSQL</productname> supporte l'ensemble des types date
   et heure du <acronym>SQL</acronym>. Ces types sont présentés dans le <xref
   linkend="datatype-datetime-table"/>. Les opérations disponibles sur ces
   types de données sont décrites dans la <xref linkend="functions-datetime"/>.
   Les dates sont comptées suivant le calendrier grégorien, même dans le cas
   des dates antérieures à l'introduction du calendrier (voir) <xref
   linkend="datetime-units-history"/> pour plus d'informations).
  </para>

  <table id="datatype-datetime-table">
   <title>Types date et heure</title>
   <tgroup cols="6">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Taille de stockage</entry>
      <entry>Description</entry>
      <entry>Valeur minimale</entry>
      <entry>Valeur maximale</entry>
      <entry>Résolution</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
      <entry>8 octets</entry>
      <entry>date et heure (sans fuseau horaire)</entry>
      <entry>4713 avant JC</entry>
      <entry>294276 après JC</entry>
      <entry>1 microseconde</entry>
     </row>
     <row>
      <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
      <entry>8 octets</entry>
      <entry>date et heure, avec fuseau horaire</entry>
      <entry>4713 avant JC</entry>
      <entry>294276 après JC</entry>
      <entry>1 microseconde</entry>
     </row>
     <row>
      <entry><type>date</type></entry>
      <entry>4 octets</entry>
      <entry>date seule (pas d'heure)</entry>
      <entry>4713 avant JC</entry>
      <entry>5874897 après JC</entry>
      <entry>1 jour</entry>
     </row>
     <row>
      <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
      <entry>8 octets</entry>
      <entry>heure seule (pas de date)</entry>
      <entry>00:00:00.00</entry>
      <entry>24:00:00</entry>
      <entry>1 microseconde</entry>
     </row>
     <row>
      <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
      <entry>12 octets</entry>
      <entry>heure (sans date), avec fuseau horaire</entry>
      <!-- see MAX_TZDISP_HOUR in datatype/timestamp.h -->
      <entry>00:00:00+1559</entry>
      <entry>24:00:00-1559</entry>
      <entry>1 microseconde</entry>
     </row>
     <row>
      <entry><type>interval [ <replaceable>champs</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
      <entry>16 octets</entry>
      <entry>intervalles de temps</entry>
      <entry>-178000000 années</entry>
      <entry>178000000 années</entry>
      <entry>1 microseconde</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    Le standard SQL impose que <type>timestamp</type> soit un équivalent de
    <type>timestamp without time zone</type>.
    <type>timestamptz</type> est accepté comme abréviation pour
    <type>timestamp with time zone</type>&nbsp;; c'est une extension
    <productname>PostgreSQL</productname>.
   </para>
  </note>

  <para>
   <type>time</type>, <type>timestamp</type>, et
   <type>interval</type> acceptent une précision optionnelle
   <replaceable>p</replaceable>, qui indique le nombre de
   décimales pour les secondes. Il n'y a pas, par défaut, de
   limite explicite à cette précision. Les valeurs acceptées pour
   <replaceable>p</replaceable> s'étendent de 0 à 6.
  </para>

  <para>
   Le type <type>interval</type> a une option supplémentaire, qui permet
   de restreindre le jeu de champs stockés en écrivant une de ces
   expressions&nbsp;:
   <programlisting>
    YEAR
    MONTH
    DAY
    HOUR
    MINUTE
    SECOND
    YEAR TO MONTH
    DAY TO HOUR
    DAY TO MINUTE
    DAY TO SECOND
    HOUR TO MINUTE
    HOUR TO SECOND
    MINUTE TO SECOND
   </programlisting>
   Notez que si <replaceable>champs</replaceable> et
   <replaceable>p</replaceable> sont tous les deux indiqués,
   <replaceable>champs</replaceable> doit inclure <literal>SECOND</literal>,
   puisque la précision s'applique uniquement aux secondes.
  </para>

  <para>
   Le type <type>time with time zone</type> est défini dans le standard
   SQL, mais sa définition lui prête des propriétés qui font douter de son
   utilité. Dans la plupart des cas, une combinaison de <type>date</type>,
   <type>time</type>, <type>timestamp without time zone</type> et
   <type>timestamp with time zone</type> devrait permettre de résoudre
   toutes les fonctionnalités de date et heure nécessaires à une application.
  </para>

  <sect2 id="datatype-datetime-input">
   <title>Saisie des dates et heures</title>

   <para>
    La saisie de dates et heures peut se faire dans la plupart des formats
    raisonnables, dont ISO8601, tout format compatible avec
    <acronym>SQL</acronym>, le format <productname>POSTGRES</productname>
    traditionnel ou autres.
    Pour certains formats, l'ordre des jours, mois et années en entrée est ambigu.
    Il est alors possible de préciser l'ordre attendu pour ces champs.
    Le paramètre <xref linkend="guc-datestyle"/> peut être positionné à
    <literal>MDY</literal> pour choisir
    une interprétation mois-jour-année, à <literal>DMY</literal> pour jour-mois-année
    ou à <literal>YMD</literal> pour année-mois-jour.
   </para>

   <para>
    <productname>PostgreSQL</productname> est plus flexible que la norme
    <acronym>SQL</acronym> ne l'exige pour la manipulation des dates et
    des heures. Voir l'<xref linkend="datetime-appendix"/> pour connaître
    les règles exactes de reconnaissance des dates et heures et les formats
    reconnus pour les champs texte comme les mois, les jours de la
    semaine et les fuseaux horaires.
   </para>

   <para>
    Tout libellé de date ou heure saisi doit être placé
    entre apostrophes, comme les chaînes de caractères.
    La <xref linkend="sql-syntax-constants-generic"/> peut être consultée pour
    plus d'information. <acronym>SQL</acronym> requiert la syntaxe suivante&nbsp;:
    <synopsis><replaceable>type</replaceable> [ (<replaceable>p</replaceable>) ] '<replaceable>valeur</replaceable>'</synopsis>
     où <replaceable>p</replaceable>, précision optionnelle, est un entier
     correspondant au nombre de décimales du champ secondes.
     La précision peut être spécifiée pour les types <type>time</type>,
     <type>timestamp</type> et <type>interval</type>, et peut aller de 0 à 6.
     Si aucune précision
     n'est indiquée dans une déclaration de constante, celle de la valeur
     littérale est utilisée (mais pas plus de 6 chiffres).
    </para>

    <sect3>
    <title>Dates</title>

    <indexterm>
     <primary>date</primary>
    </indexterm>

    <para>
     Le <xref linkend="datatype-datetime-date-table"/> regroupe les formats
     de date possibles pour la saisie de valeurs de type <type>date</type>.
    </para>

     <table id="datatype-datetime-date-table">
      <title>Saisie de date</title>
      <tgroup cols="2">
       <colspec colnum="1" colwidth="1*"/>
       <colspec colnum="2" colwidth="2*"/>
       <thead>
        <row>
         <entry>Exemple</entry>
         <entry>Description</entry>
        </row>
           </thead>
           <tbody>
        <row>
         <entry>1999-01-08</entry>
         <entry>ISO-8601&nbsp;; 8 janvier, quel que soit le mode
         (format recommandé)</entry>
        </row>
        <row>
         <entry>January 8, 1999</entry>
         <entry>sans ambiguïté quel que soit le style de date
         (<varname>datestyle</varname>)</entry>
        </row>
        <row>
         <entry>1/8/1999</entry>
         <entry>8 janvier en mode <literal>MDY</literal>&nbsp;;
          1er août en mode <literal>DMY</literal></entry>
        </row>
        <row>
         <entry>1/18/1999</entry>
         <entry>18 janvier en mode <literal>MDY</literal>&nbsp;;
          rejeté dans les autres modes</entry>
        </row>
        <row>
         <entry>01/02/03</entry>
         <entry>2 janvier 2003 en mode <literal>MDY</literal>&nbsp;;
          1er février 2003 en mode <literal>DMY</literal>&nbsp;;
          3 février 2001 en mode <literal>YMD</literal>
         </entry>
        </row>
        <row>
         <entry>1999-Jan-08</entry>
         <entry>8 janvier dans tous les modes</entry>
        </row>
        <row>
         <entry>Jan-08-1999</entry>
         <entry>8 janvier dans tous les modes</entry>
        </row>
        <row>
         <entry>08-Jan-1999</entry>
         <entry>8 janvier dans tous les modes</entry>
        </row>
        <row>
         <entry>99-Jan-08</entry>
         <entry>8 janvier en mode <literal>YMD</literal>, erreur sinon</entry>
        </row>
        <row>
         <entry>08-Jan-99</entry>
         <entry>8 janvier, sauf en mode <literal>YMD</literal>&nbsp;: erreur</entry>
        </row>
        <row>
         <entry>Jan-08-99</entry>
         <entry>8 janvier, sauf en mode <literal>YMD</literal>&nbsp;: erreur</entry>
        </row>
        <row>
         <entry>19990108</entry>
         <entry>ISO-8601&nbsp;; 8 janvier 1999 dans tous les modes</entry>
        </row>
        <row>
         <entry>990108</entry>
         <entry>ISO-8601&nbsp;; 8 janvier 1999 dans tous les modes</entry>
        </row>
        <row>
         <entry>1999.008</entry>
         <entry>Année et jour de l'année</entry>
        </row>
        <row>
         <entry>J2451187</entry>
         <entry>Date du calendrier Julien</entry>
        </row>
        <row>
         <entry>January 8, 99 BC</entry>
         <entry>Année 99 avant Jésus Christ</entry>
        </row>
      </tbody>
     </tgroup>
    </table>
   </sect3>

    <sect3>
     <title>Heures</title>

     <indexterm>
      <primary>heure</primary>
     </indexterm>
     <indexterm>
      <primary>heure sans fuseau horaire</primary>
     </indexterm>
     <indexterm>
      <primary>heure avec fuseau horaire</primary>
     </indexterm>

     <para>
      Les types <quote>heure du jour</quote> sont
      <type>time [ (<replaceable>p</replaceable>) ] without time zone</type> et
      <type>time [ (<replaceable>p</replaceable>) ] with time zone</type>.
      <type>time</type> est équivalent à <type>time without time zone</type>.
     </para>

     <para>
      Les saisies valides pour ces types sont constituées d'une heure
      suivie éventuellement d'un fuseau horaire (voir le <xref
      linkend="datatype-datetime-time-table"/> et le <xref
      linkend="datatype-timezone-table"/>). Si un fuseau est précisé
      pour le type <type>time without time zone</type>, il est ignoré sans
      message d'erreur. Si une date est indiquée, elle
      est ignorée, sauf si un fuseau horaire impliquant une règle de changement
      d'heure (heure d'été/heure d'hiver) est précisé,
      <literal>America/New_York</literal> par exemple.
      Dans ce cas, la date est nécessaire pour pouvoir déterminer la règle de
      calcul de l'heure qui s'applique.
      Le décalage approprié du
      fuseau horaire est enregistré dans la valeur de
      <type>time with time zone</type>.
     </para>

      <table id="datatype-datetime-time-table">
       <title>Saisie d'heure</title>
       <tgroup cols="2">
        <colspec colnum="1" colwidth="3*"/>
        <colspec colnum="2" colwidth="2*"/>
        <thead>
         <row>
          <entry>Exemple</entry>
          <entry>Description</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>04:05:06.789</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>040506</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05 AM</literal></entry>
          <entry>Identique à 04:05&nbsp;; AM n'affecte pas la valeur</entry>
         </row>
         <row>
          <entry><literal>04:05 PM</literal></entry>
          <entry>Identique à 16:05&nbsp;; l'heure doit être &lt;= 12</entry>
         </row>
         <row>
          <entry><literal>04:05:06.789-8</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06-08:00</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05-08:00</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>040506-08</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06 PST</literal></entry>
          <entry>fuseau horaire abrégé</entry>
         </row>
         <row>
          <entry><literal>2003-04-12 04:05:06 America/New_York</literal></entry>
	  <entry>fuseau horaire en nom complet</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

      <table tocentry="1" id="datatype-timezone-table">
       <title>Saisie des fuseaux horaires</title>
       <tgroup cols="2">
        <colspec colnum="1" colwidth="1*"/>
        <colspec colnum="2" colwidth="4*"/>
        <thead>

         <row>
          <entry>Exemple</entry>
          <entry>Description</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry>PST</entry>
          <entry>Abréviation pour l'heure standard du Pacifique (Pacific Standard Time)</entry>
         </row>
         <row>
          <entry><literal>America/New_York</literal></entry>
	  <entry>Nom complet du fuseau horaire</entry>
         </row>
         <row>
          <entry><literal>PST8PDT</literal></entry>
          <entry>Nommage POSIX du fuseau horaire</entry>
         </row>
         <row>
          <entry>-8:00</entry>
          <entry>Décalage ISO-8601 pour la zone PST</entry>
         </row>
         <row>
          <entry>-800</entry>
          <entry>Décalage ISO-8601 pour la zone PST</entry>
         </row>
         <row>
          <entry>-8</entry>
          <entry>Décalage ISO-8601 pour la zone PST</entry>
         </row>
         <row>
          <entry><literal>zulu</literal></entry>
          <entry>Abréviation militaire de GMT</entry>
         </row>
         <row>
          <entry><literal>z</literal></entry>
          <entry>Version courte de <literal>zulu</literal></entry>
         </row>
        </tbody>
       </tgroup>
      </table>

      <para>
       La <xref linkend="datatype-timezones"/> apporte des précisions quant à
       la façon d'indiquer les fuseaux horaires.
      </para>
    </sect3>

    <sect3>
    <title>Horodatage</title>

    <indexterm>
     <primary>timestamp</primary>
    </indexterm>

    <indexterm>
     <primary>timestamp with time zone</primary>
    </indexterm>

    <indexterm>
     <primary>timestamp without time zone</primary>
    </indexterm>

    <indexterm>
     <primary>horodatage</primary>
    </indexterm>

    <indexterm>
     <primary>estampille temporelle</primary>
    </indexterm>

<!-- AD : After Death, après JC
     BD : Before Death, avant JC -->
    <para>
     Les saisies valides sont constituées de la concaténation
     d'une date et d'une heure, éventuellement suivie d'un fuseau horaire et d'un
     qualificatif <literal>AD</literal> (après Jésus Christ) ou
     <literal>BC</literal>  (avant Jésus Christ).
     (<literal>AD</literal>/<literal>BC</literal> peut aussi apparaître avant le
     fuseau horaire, mais ce n'est pas l'ordre préféré.)
     Ainsi&nbsp;:

     <programlisting>1999-01-08 04:05:06</programlisting>
      et&nbsp;:
<programlisting>1999-01-08 04:05:06 -8:00</programlisting>

      sont des valeurs valides, qui suivent le standard
      <acronym>ISO</acronym> 8601. Le format très courant&nbsp;:

<programlisting>January 8 04:05:06 1999 PST</programlisting>
      est également supporté.
     </para>

     <para>
      Le standard <acronym>SQL</acronym> différencie les libellés
      <type>timestamp without time zone</type> et
      <type>timestamp with time zone</type> par la présence d'un symbole
      <quote>+</quote> ou d'un <quote>-</quote> et le décalage du fuseau horaire
      après l'indication du temps. De ce fait, d'après le standard,
<programlisting>TIMESTAMP '2004-10-19 10:23:54'</programlisting>
      est du type <type>timestamp without time zone</type> alors que
      <programlisting>TIMESTAMP '2004-10-19 10:23:54+02'</programlisting>
      est du type <type>timestamp with time zone</type>.
      <productname>PostgreSQL</productname> n'examine jamais le contenu
      d'un libellé avant de déterminer son type. Du coup, il
      traite les deux ci-dessus comme des valeurs de type
      <type>timestamp without time zone</type>. Pour s'assurer qu'un
      littéral est traité comme une valeur de type
      <type>timestamp with time zone</type>, il faut préciser explicitement
      le bon type&nbsp;:
<programlisting>TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'</programlisting>
      Dans un libellé de type
      <type>timestamp without time zone</type>,
      <productname>PostgreSQL</productname> ignore
      silencieusement toute indication de fuseau horaire. C'est-à-dire que
      la valeur résultante est dérivée des champs date/heure de la valeur
      saisie et n'est pas corrigée par le fuseau horaire.
     </para>

     <para>
      Pour <type>timestamp with time zone</type>, la valeur stockée en interne
      est toujours en UTC (<foreignphrase>Universal Coordinated
      Time</foreignphrase> ou Temps Universel Coordonné), aussi
      connu sous le nom de <acronym>GMT</acronym> (<foreignphrase>Greenwich
      Mean Time</foreignphrase>).
      Les valeurs saisies avec un fuseau horaire explicite sont converties
      en UTC à l'aide du décalage approprié. Si aucun fuseau horaire
      n'est précisé, alors le système considère que la date est dans le fuseau
      horaire indiqué par le paramètre système <xref linkend="guc-timezone"/>,
      et la convertit en UTC en utilisant le décalage de la zone
      <varname>timezone</varname>.
     </para>

     <para>
      Quand une valeur <type>timestamp with time zone</type> est affichée,
      elle est toujours convertie de l'UTC vers le fuseau horaire courant
      (variable <varname>timezone</varname>), et affichée comme une heure locale.
      Pour voir l'heure dans un autre fuseau horaire, il faut, soit changer la
      valeur de <varname>timezone</varname>, soit utiliser la construction
      <literal>AT TIME ZONE</literal> (voir la
      <xref linkend="functions-datetime-zoneconvert"/>).
     </para>

     <para>
      Les conversions entre <type>timestamp without time zone</type> et
      <type>timestamp with time zone</type> considèrent normalement
      que la valeur <type>timestamp without time zone</type> utilise
      le fuseau horaire <varname>timezone</varname>. Un fuseau différent
      peut être choisi en utilisant <literal>AT TIME ZONE</literal>.
     </para>
    </sect3>

    <sect3 id="datatype-datetime-special-values">
     <title>Valeurs spéciales</title>

     <indexterm>
      <primary>heure</primary>
      <secondary>constantes</secondary>
     </indexterm>

     <indexterm>
      <primary>date</primary>
      <secondary>constantes</secondary>
     </indexterm>

     <para>
      <productname>PostgreSQL</productname> supporte plusieurs
      valeurs de dates spéciales, dans un souci de simplification. Ces valeurs
      sont présentées dans le
      <xref linkend="datatype-datetime-special-table"/>.
      Les valeurs <literal>infinity</literal> et <literal>-infinity</literal>
      ont une représentation spéciale dans le système et sont affichées
      ainsi&nbsp;; les autres ne sont que des raccourcies de notation
      convertis en dates/heures ordinaires lorsqu'ils sont
      lus. (En particulier, <literal>now</literal> et les chaînes relatives sont
      converties en une valeur de temps spécifique à leur lecture).
      Toutes ces valeurs doivent être écrites entre simples quotes
      lorsqu'elles sont utilisées comme des constantes dans les commandes SQL.
     </para>

      <table id="datatype-datetime-special-table">
       <title>Saisie de dates/heures spéciales</title>
       <tgroup cols="3">
        <thead>
         <row>
          <entry>Saisie</entry>
          <entry>Types valides</entry>
          <entry>Description</entry>
         </row>
        </thead>

        <tbody>
         <row>
          <entry><literal>epoch</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>1970-01-01 00:00:00+00 (date système zéro d'Unix)</entry>
         </row>
         <row>
          <entry><literal>infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>plus tard que toutes les autres dates</entry>
         </row>
         <row>
          <entry><literal>-infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>plus tôt que toutes les autres dates</entry>
         </row>
         <row>
          <entry><literal>now</literal></entry>
          <entry><type>date</type>, <type>time</type>, <type>timestamp</type></entry>
          <entry>heure de démarrage de la transaction courante</entry>
         </row>
         <row>
          <entry><literal>today</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>aujourd'hui minuit (<literal>00:00</literal>)</entry>
         </row>
         <row>
          <entry><literal>tomorrow</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>demain minuit (<literal>00:00</literal>)</entry>
         </row>
         <row>
          <entry><literal>yesterday</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>hier minuit (<literal>00:00</literal>)</entry>
         </row>
         <row>
          <entry><literal>allballs</literal></entry>
          <entry><type>time</type></entry>
          <entry>00:00:00.00 UTC</entry>
         </row>
        </tbody>

       </tgroup>
      </table>

      <para>
       Les fonctions suivantes, compatibles avec le standard
       <acronym>SQL</acronym>, peuvent aussi être utilisées pour obtenir
       l'heure courante pour le type de données correspondant&nbsp;:
       <literal>CURRENT_DATE</literal>, <literal>CURRENT_TIME</literal>,
       <literal>CURRENT_TIMESTAMP</literal>, <literal>LOCALTIME</literal>,
       <literal>LOCALTIMESTAMP</literal>. (Voir
       la <xref linkend="functions-datetime-current"/>). Ce
       sont là des fonctions SQL qui ne sont <emphasis>pas</emphasis> reconnues
       comme chaînes de saisie de données.
      </para>

      <caution>
       <para>
        Bien qu'il n'y ait pas de problèmes à utiliser les chaînes
        <literal>now</literal>, <literal>today</literal>,
        <literal>tomorrow</literal> et <literal>yesterday</literal> dans des
        commandes SQL interactives, elles peuvent avoir un comportement
        surprenant quand la commande est sauvegardée pour une exécution
        ultérieure, par exemple dans des requêtes préparées, des vues ou des
        fonctions. La châine peut être convertie en une valeur spécifique qui
        continue à être utilisée bien après qu'elle ne soit éculée. Dans de
        tels contextes, utilisez plutôt une des fonctions SQL. Par exemple,
        <literal>CURRENT_DATE + 1</literal> est plus sûr que
        <literal>'tomorrow'::date</literal>.
       </para>
      </caution>

    </sect3>
   </sect2>

   <sect2 id="datatype-datetime-output">
    <title>Affichage des dates et heures</title>

    <indexterm>
     <primary>date</primary>
     <secondary>format d'affichage</secondary>
     <seealso>formatage</seealso>
    </indexterm>

    <indexterm>
     <primary>heure</primary>
     <secondary>format de sortie</secondary>
     <seealso>formatage</seealso>
    </indexterm>

    <para>
     Le format de sortie des types date/heure peut être positionné à l'un des
     quatre formats de date suivants&nbsp;: ISO 8601, <acronym>SQL</acronym>
     (Ingres), traditionnel <productname>POSTGRES</productname> (date au format
     Unix <application>date</application>) ou German (germanique). Le format
     par défaut est le format <acronym>ISO</acronym>. (Le standard
     <literal>SQL</literal> impose l'utilisation du format ISO 8601. Le nom du
     format d'affichage <quote>SQL</quote> est mal choisi, un accident
     historique.) Le <xref linkend="datatype-datetime-output-table"/>  présente
     des exemples de chaque format d'affichage. La sortie d'un type
     <type>date</type> ou <type>time</type> n'est évidemment composée que de la
     partie date ou heure, comme montré dans les exemples. Néanmoins, le style
     <productname>POSTGRES</productname> affiche seulement les dates dans le
     format <acronym>ISO</acronym>.
    </para>

     <table id="datatype-datetime-output-table">
      <title>Styles d'affichage de date/heure</title>
      <tgroup cols="3">
       <colspec colname="col1" colwidth="1*"/>
       <colspec colname="col2" colwidth="1*"/>
       <colspec colname="col3" colwidth="2*"/>
       <thead>
        <row>

        <entry>Spécification de style</entry>
       <entry>Description</entry>
       <entry>Exemple</entry>
       </row>

       </thead>
       <tbody>
        <row>

         <entry><literal>ISO</literal></entry>
         <entry>standard SQL ISO 8601</entry>
         <entry><literal>1997-12-17 07:37:16-08</literal></entry>
        </row>
        <row>

         <entry><literal>SQL</literal></entry>
         <entry>style traditionnel</entry>
         <entry><literal>12/17/1997 07:37:16.00 PST</literal></entry>
        </row>
        <row>

     <entry><literal>Postgres</literal></entry>
     <entry>style original</entry>
     <entry><literal>Wed Dec 17 07:37:16 1997 PST</literal></entry>
    </row>
    <row>

     <entry><literal>German</literal></entry>
     <entry>style régional</entry>
     <entry><literal>17.12.1997 07:37:16.00 PST</literal></entry>
    </row>

       </tbody>
      </tgroup>
     </table>

    <note>
     <para>
      ISO 8601 spécifie l'utilisation d'une lettre <literal>T</literal> en
      majuscule pour séparer la date et l'heure.
      <productname>PostgreSQL</productname> accepte ce format en entrée. En
      sortie, il utilise un espace plutôt qu'un <literal>T</literal>, comme
      indiqué ci-dessus. C'est à la fois plus lisible et cohérent avec la
      RFC 3339 ainsi qu'avec d'autres systèmes de bases de données.
     </para>
    </note>

    <para>
     Dans les styles <acronym>SQL</acronym> et POSTGRES, les jours
     apparaissent avant le mois si l'ordre des champs DMY a été précisé,
     sinon les mois apparaissent avant les jours
     (voir la <xref linkend="datatype-datetime-input"/>  pour savoir comment
     ce paramètre affecte l'interprétation des valeurs en entrée). Le
     <xref linkend="datatype-datetime-output2-table"/> présente des exemples.
    </para>

     <table id="datatype-datetime-output2-table">
      <title>Convention de présentation des dates</title>
      <tgroup cols="3">
       <colspec colname="col1" colwidth="1*"/>
       <colspec colname="col2" colwidth="1*"/>
       <colspec colname="col3" colwidth="2*"/>
       <thead>
        <row>
         <entry>Valeur de <varname>datestyle</varname> (style de date)</entry>
         <entry>Ordre de saisie</entry>
         <entry>Exemple d'affichage</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>SQL, DMY</literal></entry>
         <entry><replaceable>jour</replaceable>/<replaceable>mois</replaceable>/<replaceable>année</replaceable></entry>
         <entry><literal>17/12/1997 15:37:16.00 CET</literal></entry>
        </row>
        <row>
         <entry><literal>SQL, MDY</literal></entry>
         <entry><replaceable>mois</replaceable>/<replaceable>jour</replaceable>/<replaceable>année</replaceable></entry>
         <entry><literal>12/17/1997 07:37:16.00 PST</literal></entry>
        </row>
        <row>
         <entry><literal>Postgres, DMY</literal></entry>
         <entry><replaceable>jour</replaceable>/<replaceable>mois</replaceable>/<replaceable>année</replaceable></entry>
         <entry><literal>Wed 17 Dec 07:37:16 1997 PST</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <para>
     Le style de date/heure peut être sélectionné à l'aide de la
     commande <command>SET datestyle</command>, du paramètre
     <xref linkend="guc-datestyle"/> du fichier de configuration
     <filename>postgresql.conf</filename> ou par la variable
     d'environnement <envar>PGDATESTYLE</envar> sur le serveur ou le client.
    </para>

    <para>
     La fonction de formatage <function>to_char</function> (voir <xref
     linkend="functions-formatting"/>) permet de formater les affichages
     de date/heure de manière plus flexible.
    </para>
   </sect2>

   <sect2 id="datatype-timezones">
    <title>Fuseaux horaires</title>

    <indexterm zone="datatype-timezones">
     <primary>fuseau horaire</primary>
    </indexterm>

    <para>
     Les fuseaux horaires et les conventions liées sont influencés
     par des décisions politiques, pas uniquement par la géométrie de la Terre.
     Les fuseaux horaires se sont quelque peu standardisés au cours du
     vingtième siècle, mais continuent à être soumis à des changements
     arbitraires, particulièrement en respect des règles de changement
     d'heure (heure d'été/heure d'hiver).
     <productname>PostgreSQL</productname> utilise la très répandue base de données
     de fuseaux horaires IANA (Olson) pour gérer les informations
     sur les règles historiques de fuseau horaire. Pour les dates se situant dans le futur,
     <productname>PostgreSQL</productname> part de l'assomption que les dernières
     règles connues pour un fuseau continueront à s'appliquer dans le futur.
    </para>

    <para>
     <productname>PostgreSQL</productname> se veut compatible avec les
     définitions standard <acronym>SQL</acronym> pour un usage typique.
     Néanmoins, le standard <acronym>SQL</acronym> possède un mélange
     étrange de types de date/heure et de possibilités. Deux problèmes
     évidents sont&nbsp;:

     <itemizedlist>
      <listitem>
       <para>
        bien que le type <type>date</type> ne puisse pas se voir associer un
	fuseau horaire, le type <type>heure</type> peut en avoir un.
        Les fuseaux horaires, dans le monde réel, ne peuvent avoir de sens
        qu'associés à une date et à une heure, vu que l'écart peut varier
        avec l'heure d'été&nbsp;;
       </para>
      </listitem>

      <listitem>
       <para>
        le fuseau horaire par défaut est précisé comme un écart numérique constant
        avec l'<acronym>UTC</acronym>. Il n'est, de ce fait, pas possible de s'adapter à l'heure
        d'été ou d'hiver lorsque l'on fait des calculs arithmétiques qui passent
        les limites de l'heure d'été et de l'heure d'hiver.
       </para>
      </listitem>

     </itemizedlist>
    </para>

    <para>
     Pour éviter ces difficultés, il est recommandé d'utiliser des
     types date/heure qui contiennent à la fois une date et une heure
     lorsque les fuseaux horaires sont utilisés. Il est également préférable
     de <emphasis>ne pas</emphasis> utiliser le type
     <type>time with time zone</type>. (Ce type est néanmoins proposé par
     <productname>PostgreSQL</productname> pour les applications
     existantes et pour assurer la compatibilité avec le standard
     <acronym>SQL</acronym>.)
     <productname>PostgreSQL</productname> utilise le fuseau horaire local
     pour tous les types qui ne contiennent qu'une date ou une heure.
    </para>

    <para>
     Toutes les dates et heures liées à un fuseau horaire sont stockées
     en interne en <acronym>UTC</acronym>. Elles sont converties en heure
     locale dans le fuseau indiqué par le paramètre de configuration <xref
     linkend="guc-timezone"/> avant d'être affichées sur le client.
    </para>

    <para>
     <productname>PostgreSQL</productname> permet d'indiquer les fuseaux
     horaires de trois façons différentes&nbsp;:
     <itemizedlist>
      <listitem>
       <para>
        un nom complet de fuseau horaire, par exemple <literal>America/New_York</literal>.
	Les noms reconnus de fuseau horaire sont listés dans la vue
        <literal>pg_timezone_names</literal> (voir <xref
        linkend="view-pg-timezone-names"/>).
        <productname>PostgreSQL</productname> utilise les données
        IANA pour cela, les mêmes noms sont donc
	reconnus par de nombreux autres logiciels&nbsp;;
       </para>
      </listitem>
      <listitem>
       <para>
        une abréviation de fuseau horaire, par exemple <literal>PST</literal>.
	Une telle indication ne définit qu'un décalage particulier
	à partir d'UTC, en contraste avec les noms complets de fuseau horaire
	qui peuvent aussi impliquer un ensemble de dates pour le changement
	d'heure. Les abréviations reconnues sont listées dans la vue
	<literal>pg_timezone_abbrevs</literal> (voir <xref
        linkend="view-pg-timezone-abbrevs"/>). Les paramètres de configuration
	<xref linkend="guc-timezone"/> et <xref linkend="guc-log-timezone"/> ne
	peuvent pas être configurés à l'aide
	d'une abréviation de fuseau horaire, mais ces abréviations peuvent
	être utilisées dans les saisies de date/heure et avec l'opérateur
        <literal>AT TIME ZONE</literal>&nbsp;;
       </para>
      </listitem>
      <listitem>
       <para>
        En plus de noms et abréviations de fuseaux horaires,
        <productname>PostgreSQL</productname> acceptera les spécifications de
        fuseaux horaire au format POSIX, comme décrites dans <xref
        linkend="datetime-posix-timezone-specs"/>. Cette option n'est
        normalement pas préférable à utiliser un nom de fuseau horaire, mais
        pourrait se révéler nécessaire si aucune entrée IANA de fuseau horaire
        n'est disponible.
       </para>
      </listitem>
     </itemizedlist>

     Les abréviations représentent un décalage spécifique depuis UTC, alors
     qu'un grand nombre des noms complets implique une règle de changement
     d'heure, et donc potentiellement deux décalages UTC. Par exemple,
     <literal>2014-06-04 12:00 America/New_York</literal> représente minuit à
     New York, ce qui, pour cette date particulière, sera le fuseau Eastern
     Daylight Time (UTC-4). Donc <literal>2014-06-04 12:00 EDT</literal> stipule
     ce moment précis. Mais <literal>2014-06-04 12:00 EST</literal> représente
     minuit pour le fuseau Eastern Standard Time (UTC-5), quel que soit le
     changement d'heure en effet à cette date.
    </para>

    <para>
     Pour compliquer encore plus, certaines juridictions ont utilisé les mêmes
     abréviations de fuseau horaire pour signifier des décalages UTC différents.
     Par exemple, Moscow <literal>MSK</literal> correspondait à UTC+3 certaines
     années et UTC+4 à d'autres.  <application>PostgreSQL</application> interprète
     ces abréviations suivant ce à quoi elles correspondent (ou ont correspondu
     récemment) pour la date indiquée. Mais, comme le montre l'exemple
     <literal>EST</literal> ci-dessus, ce n'est pas nécessairement la même chose
     que l'heure civile locale à ce moment.
    </para>

    <para>
     Dans tous les cas, les noms et les abréviations des fuseaux horaires sont
     insensibles à la casse. (C'est un changement par rapport aux versions
     de <productname>PostgreSQL</productname> antérieures à la 8.2 qui étaient
     sensibles à la casse dans certains cas et pas dans d'autres.)
    </para>

    <para>
     Ni les noms ni les abréviations des fuseaux horaires ne sont codés en dur
     dans le serveur&nbsp;; ils sont obtenus à partir des fichiers de configuration
     stockés sous <filename>.../share/timezone/</filename> et
     <filename>.../share/timezonesets/</filename> du répertoire d'installation
     (voir <xref linkend="datetime-config-files"/>).
    </para>

    <para>
     Le paramètre de configuration <xref linkend="guc-timezone"/> peut être
     fixé dans le fichier <filename>postgresql.conf</filename> ou par tout
     autre moyen standard décrit dans le <xref linkend="runtime-config"/>.
     Il existe aussi quelques manières spéciales de le configurer&nbsp;:

     <itemizedlist>
      <listitem>
       <para>
        la commande <acronym>SQL</acronym> <command>SET TIME ZONE</command>
        configure le fuseau horaire pour une session. C'est une autre façon
        d'indiquer <command>SET TIMEZONE TO</command> avec une syntaxe plus
        compatible avec les spécifications SQL&nbsp;;
       </para>
      </listitem>

      <listitem>
       <para>
        la variable d'environnement <envar>PGTZ</envar> est utilisée par les
	applications clientes fondées sur
        <application>libpq</application> pour envoyer une commande
        <command>SET TIME ZONE</command> au serveur lors de la connexion.
       </para>
      </listitem>
     </itemizedlist>
    </para>

   </sect2>

   <sect2 id="datatype-interval-input">
    <title>Saisie d'intervalle</title>

    <indexterm>
     <primary>intervalle</primary>
    </indexterm>

     <para>
      Les valeurs de type <type>interval</type> peuvent être saisies en utilisant
      la syntaxe verbeuse suivante&nbsp;:

<synopsis>
<optional>@</optional> <replaceable>quantité</replaceable>
<replaceable>unité</replaceable> <optional><replaceable>quantité</replaceable>
<replaceable>unité</replaceable>...</optional>
<optional><replaceable>direction</replaceable></optional>
     </synopsis>
     où <replaceable>quantité</replaceable> est un nombre (éventuellement signé)&nbsp;;
     <replaceable>unité</replaceable> est <literal>microsecond</literal>
     <literal>millisecond</literal>, <literal>second</literal>,
     <literal>minute</literal>, <literal>hour</literal>, <literal>day</literal>,
     <literal>week</literal>, <literal>month</literal>, <literal>year</literal>,
     <literal>decade</literal>, <literal>century</literal>, <literal>millennium</literal>,
     ou des abréviations ou pluriels de ces unités&nbsp;;
     <replaceable>direction</replaceable> peut être <literal>ago</literal> (pour indiquer
     un intervalle négatif) ou vide. Le signe <literal>@</literal> est du bruit optionnel.
     Les quantités de chaque unité différente sont implicitement ajoutées, avec prise en compte
     appropriée des signes (<literal>+</literal> et <literal>-</literal>). <literal>ago</literal>
     inverse tous les champs. Cette syntaxe est aussi utilisée pour les sorties d'intervalles, si
     <xref linkend="guc-intervalstyle"/> est positionné à <literal>postgres_verbose</literal>.
    </para>

    <para>
     Les quantités de jours, heures, minutes et secondes peuvent être spécifiées sans
     notations explicites d'unités. Par exemple <literal>'1 12:59:10'</literal> est
     comprise comme <literal>'1 day 12 hours 59 min 10 sec'</literal>. Par ailleurs,
     une combinaison d'années et de mois peut être spécifiée avec un tiret&nbsp;;
     par exemple, <literal>'200-10'</literal> est compris comme <literal>'200 years
      10 months'</literal>. (Ces formes raccourcies sont en fait les seules autorisées
     par le standard <acronym>SQL</acronym>, et sont utilisées pour la sortie quand
     la variable <varname>IntervalStyle</varname> est positionnée à
     <literal>sql_standard</literal>.)
    </para>

    <para>
     Les valeurs d'intervalles peuvent aussi être écrites en tant qu'intervalles
     de temps ISO&nbsp;8601, en utilisant soit le <quote>format avec désignateurs</quote>
     de la section 4.4.3.2 ou le <quote>format alternatif</quote> de la section 4.4.3.3.
     Le format avec désignateurs ressemble à ceci&nbsp;:

     <synopsis>
P <replaceable>quantité</replaceable> <replaceable>unité</replaceable> <optional> <replaceable>quantité</replaceable> <replaceable>unité</replaceable> ...</optional> <optional> T <optional> <replaceable>quantité</replaceable> <replaceable>unité</replaceable> ...</optional></optional>
     </synopsis>
     La chaîne doit commencer avec un <literal>P</literal>, et peut inclure un
     <literal>T</literal> qui introduit les unités de ce type. Les abréviations
     d'unité disponibles sont données dans <xref
     linkend="datatype-interval-iso8601-units"/>. Des unités peuvent être omises,
     et peuvent être spécifiées dans n'importe quel ordre, mais les unités inférieures
     à un jour doivent apparaître après <literal>T</literal>. En particulier, la signification
     de <literal>M</literal> dépend de son emplacement, c'est-à-dire avant ou après
     <literal>T</literal>.
    </para>

    <table id="datatype-interval-iso8601-units">
     <title>Abréviations d'unités d'intervalle ISO 8601</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Abréviation</entry>
        <entry>Signification</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>Y</entry>
        <entry>Années</entry>
       </row>
       <row>
        <entry>M</entry>
        <entry>Mois (dans la zone de date)</entry>
       </row>
       <row>
        <entry>W</entry>
        <entry>Semaines</entry>
       </row>
       <row>
        <entry>D</entry>
        <entry>Jours</entry>
       </row>
       <row>
        <entry>H</entry>
        <entry>Heures</entry>
       </row>
       <row>
        <entry>M</entry>
        <entry>Minutes (dans la zone de temps)</entry>
       </row>
       <row>
        <entry>S</entry>
        <entry>Secondes</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>
     Dans le format alternatif&nbsp;:
     <synopsis>
P <optional> <replaceable>années</replaceable>-<replaceable>mois</replaceable>-<replaceable>jours</replaceable> </optional> <optional> T <replaceable>heures</replaceable>:<replaceable>minutes</replaceable>:<replaceable>secondes</replaceable> </optional>
     </synopsis>
     la chaîne doit commencer par <literal>P</literal>, et un <literal>T</literal>
     sépare la zone de date et la zone de temps de l'intervalle.
     Les valeurs sont données comme des nombres, de façon similaire aux dates ISO 8601.
    </para>

    <para>
     Lors de l'écriture d'une constante d'intervalle avec une spécification de
     <replaceable>champs</replaceable>, ou lors de l'assignation d'une chaîne à
     une colonne d'intervalle qui a été définie avec une spécification de
     <replaceable>champs</replaceable>, l'interprétation de quantité sans unité
     dépend des <replaceable>champs</replaceable>. Par exemple,
     <literal>INTERVAL '1' YEAR</literal> est interprété comme 1 an, alors que
     <literal>INTERVAL '1'</literal> est interprété comme 1 seconde. De plus,
     les valeurs du champ <quote>à droite</quote> du champ le moins significatif
     autorisé par la spécification de <replaceable>champs</replaceable> sont
     annulées de façon silencieuse. Par exemple, écrire <literal>INTERVAL '1 day
      2:03:04' HOUR TO MINUTE</literal> implique la suppression du champ des
     secondes, mais pas celui des journées.
    </para>

    <para>
     D'après le standard <acronym>SQL</acronym>, toutes les valeurs de tous les champs
     d'un intervalle doivent avoir le même signe, ce qui entraîne qu'un signe négatif
     initial s'applique à tous les champs&nbsp;; par exemple, le signe négatif dans
     l'expression d'intervalle <literal>'-1 2:03:04'</literal> s'applique à la fois aux
     jours et aux heures/minutes/secondes. <productname>PostgreSQL</productname> permet
     que les champs aient des signes différents, et traditionnellement traite chaque champ
     de la représentation textuelle comme indépendamment signé, ce qui fait que la partie
     heure/minute/seconde est considérée comme positive dans l'exemple. Si
     <varname>IntervalStyle</varname> est positionné à <literal>sql_standard</literal>,
     alors un signe initial est considéré comme s'appliquant à tous les champs (mais
     seulement si aucun autre signe n'apparaît).
     Sinon, l'interprétation traditionnelle de <productname>PostgreSQL</productname>
     est utilisée. Pour éviter les ambiguïtés, il est recommandé d'attacher un signe
     explicite à chaque partie, si au moins un champ est négatif.
    </para>

    <para>
     Dans le format verbeux de saisie, et dans certains champs des formats
     plus compacts, les valeurs de champs peuvent avoir des parties décimales&nbsp;;
     par exemple, <literal>'1.5 week'</literal> ou <literal>'01:02:03.45'</literal>.
     Ces entrées sont converties en un nombre approprié de mois, jours et secondes
     pour être stockées. Quand ceci entraînerait le stockage d'une valeur décimale
     pour les mois ou les jours, la partie décimale est ajoutée aux champs d'ordre
     inférieur en utilisant les facteurs de conversion suivants&nbsp;:&nbsp;1&nbsp;mois
     &nbsp;=&nbsp;30&nbsp;jours, 1&nbsp;jour&nbsp;=&nbsp;24heures.
     Par exemple, <literal>'1.5 month'</literal> devient 1 mois et 15 jours.
     Seules les secondes pourront apparaître comme décimales en sortie.
    </para>

    <para>
     <xref linkend="datatype-interval-input-examples"/> présente des exemples de saisies
     d'<type>interval</type> valides.
    </para>

    <table id="datatype-interval-input-examples">
     <title>Saisie d'intervalle</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Exemple</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>1-2</literal></entry>
        <entry>Format SQL standard&nbsp;: 1 an 2 mois</entry>
       </row>
       <row>
        <entry><literal>3 4:05:06</literal></entry>
        <entry>Format SQL standard&nbsp;: 3 jours 4 heures 5 minutes 6 secondes</entry>
       </row>
       <row>
        <entry><literal>1 year 2 months 3 days 4 hours 5 minutes 6 seconds</literal></entry>
        <entry>Format PostgreSQL traditionnel&nbsp;: 1 an 2 mois 3 jours 4 heures 5 minutes 6 secondes</entry>
       </row>
       <row>
        <entry><literal>P1Y2M3DT4H5M6S</literal></entry>
        <entry><quote>format avec désignateurs</quote> ISO 8601&nbsp;: signification identique à ci-dessus</entry>
       </row>
       <row>
        <entry><literal>P0001-02-03T04:05:06</literal></entry>
        <entry><quote>format alternatif</quote> ISO 8601&nbsp;: signification identique à ci-dessus</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>
     En interne, les valeurs <type>interval</type> sont enregistrées comme des
     mois, jours et secondes. C'est fait ainsi parce que le nombre de jours
     dans un mois varie, et un jour peut avoir 23 ou 25 heures s'il y a eu un
     changement d'heure. Les champs mois et jours sont des entiers, alors que
     le champ des secondes peut contenir des fractions. Comme les intervalles
     sont habituellement créés à partir de chaînes constantes ou de
     soustractions de <type>timestamp</type>, cette méthode de stockage
     fonctionne bien dans la plupart des cas, mais peut être la cause de
     résultats inattendus&nbsp;:

     <programlisting>
SELECT EXTRACT(hours from '80 minutes'::interval);
 date_part
-----------
         1

SELECT EXTRACT(days from '80 hours'::interval);
 date_part
-----------
         0
     </programlisting>

     Les fonctions <function>justify_days</function> et
     <function>justify_hours</function> sont disponibles pour ajuster les
     jours et heures qui dépassent l'étendue normale.
    </para>

   </sect2>

   <sect2 id="datatype-interval-output">
    <title>Affichage d'intervalles</title>

    <indexterm>
     <primary>intervalle</primary>
     <secondary>format d'affichage</secondary>
     <seealso>formatage</seealso>
    </indexterm>

    <para>
     Le format de sortie du type interval peut être positionné à une de ces quatre
     valeurs : <literal>sql_standard</literal>, <literal>postgres</literal>,
     <literal>postgres_verbose</literal> ou <literal>iso_8601</literal>,
     en utilisant la commande <literal>SET intervalstyle</literal>.
     La valeur par défaut est le format <literal>postgres</literal>.
     <xref linkend="interval-style-output-table"/> donne des exemples de chaque style de
     format de sortie.
    </para>

    <para>
     Le style <literal>sql_standard</literal> produit une sortie qui se conforme
     à la spécification du standard SQL pour les chaînes littérales d'intervalle, si
     la valeur de l'intervalle reste dans les restrictions du standard (soit
     année-mois seul, ou jour-temps seul, et sans mélanger les composants positifs
     et négatifs). Sinon, la sortie ressemble au standard littéral année-mois
     suivi par une chaîne jour-temps littérale, avec des signes explicites ajoutés
     pour désambiguer les intervalles dont les signes seraient mélangés.
    </para>

    <para>
     La sortie du style <literal>postgres</literal> correspond à la sortie des
     versions de <productname>PostgreSQL</productname> précédant la 8.4, si le
     paramètre <xref linkend="guc-datestyle"/> était positionné à
     <literal>ISO</literal>.
    </para>

    <para>
     La sortie du style <literal>postgres_verbose</literal> correspond à la sortie
     des versions de <productname>PostgreSQL</productname> précédant la 8.4, si le
     paramètre <xref linkend="guc-datestyle"/> était positionné à autre chose que
     <literal>ISO</literal>.
    </para>

    <para>
     La sortie du style <literal>iso_8601</literal> correspond au <quote>format
      avec  designateurs</quote> décrit dans la section 4.4.3.2 du standard ISO 8601.
    </para>

    <table id="interval-style-output-table">
     <title>Exemples de styles d'affichage d'intervalles</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Spécification de style</entry>
        <entry>Intervalle année-mois</entry>
        <entry>Intervalle date-temps</entry>
        <entry>Interval Mixte</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>sql_standard</literal></entry>
        <entry>1-2</entry>
        <entry>3 4:05:06</entry>
        <entry>-1-2 +3 -4:05:06</entry>
       </row>
       <row>
        <entry><literal>postgres</literal></entry>
        <entry>1 year 2 mons</entry>
        <entry>3 days 04:05:06</entry>
        <entry>-1 year -2 mons +3 days -04:05:06</entry>
       </row>
       <row>
        <entry><literal>postgres_verbose</literal></entry>
        <entry>@ 1 year 2 mons</entry>
        <entry>@ 3 days 4 hours 5 mins 6 secs</entry>
        <entry>@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago</entry>
       </row>
       <row>
        <entry><literal>iso_8601</literal></entry>
        <entry>P1Y2M</entry>
        <entry>P3DT4H5M6S</entry>
        <entry><literal>P-1Y-2M3DT-4H-5M-6S</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   </sect2>

  </sect1>

  <sect1 id="datatype-boolean">
   <title>Type booléen</title>

   <indexterm zone="datatype-boolean">
    <primary>boolean</primary>
    <secondary>type de données</secondary>
   </indexterm>

   <indexterm zone="datatype-boolean">
    <primary>true</primary>
   </indexterm>

   <indexterm zone="datatype-boolean">
    <primary>false</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> fournit le type <type>boolean</type>
    du standard <acronym>SQL</acronym>&nbsp;; voir <xref
    linkend="datatype-boolean-table"/>.
    Ce type dispose de plusieurs états&nbsp;:<quote>true</quote> (vrai),
    <quote>false</quote> (faux) et un troisième état, <quote>unknown</quote>
    (inconnu), qui est représenté par la valeur <acronym>SQL</acronym> NULL.
   </para>

   <table id="datatype-boolean-table">
    <title>Type de données booléen</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Taille du stockage</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>boolean</type></entry>
       <entry>1 octet</entry>
       <entry>état vrai ou faux</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Les constantes booléennes peuvent être représentées dans les requêtes SQL
    avec les mots clés SQL <literal>TRUE</literal>, <literal>FALSE</literal>
    et <literal>NULL</literal>.
   </para>

   <para>
    La fonction en entrée pour le type <type>boolean</type> accepte ces
    représentations, sous forme de chaîne de caractères, pour l'état
    <quote>true</quote>&nbsp;:
    <simplelist>
     <member><literal>true</literal></member>
     <member><literal>yes</literal></member>
     <member><literal>on</literal></member>
     <member><literal>1</literal></member>
    </simplelist>
    et ces représentations pour l'état <quote>false</quote>&nbsp;:
    <simplelist>
     <member><literal>false</literal></member>
     <member><literal>no</literal></member>
     <member><literal>off</literal></member>
     <member><literal>0</literal></member>
    </simplelist>
    Les préfixes uniques de ces chaînes sont aussi acceptés, par exemple
    <literal>t</literal> ou <literal>n</literal>. Les espaces avant ou après,
    ainsi que la casse, sont ignorés.
   </para>

   <para>
    La fonction en sortie pour le <type>boolean</type> renvoie toujours soit
    <literal>t</literal> soit <literal>f</literal>, comme indiqué dans <xref
    linkend="datatype-boolean-example"/>.
   </para>

   <example id="datatype-boolean-example">
    <title>Utilisation du type <type>boolean</type>.</title>

    <programlisting>CREATE TABLE test1 (a boolean, b text);
INSERT INTO test1 VALUES (TRUE, 'sic est');
INSERT INTO test1 VALUES (FALSE, 'non est');
SELECT * FROM test1;
 a |    b
---+---------
 t | sic est
 f | non est

SELECT * FROM test1 WHERE a;
 a |    b
---+---------
 t | sic est</programlisting>
   </example>

   <para>
    Les mots clés <literal>TRUE</literal> et <literal>FALSE</literal> sont la
    méthode préférée (compatible <acronym>SQL</acronym>) pour l'écriture des
    constantes booléennes dans les requêtes SQL. Cependant, vous pouvez aussi
    utiliser les représentations sous forme de chaîne de caractères en suivant
    la syntaxe générique décrite dans <xref
    linkend="sql-syntax-constants-generic"/>, par exemple
    <literal>'yes'::boolean</literal>.
   </para>

   <para>
    Notez que l'analyseur comprend automatiquement que <literal>TRUE</literal>
    et <literal>FALSE</literal> sont du type <type>boolean</type>, mais ce
    n'est pas le cas pour <literal>NULL</literal> car il peut avoir tout type.
    Donc, dans certains contextes, vous devrez convertir explicitement
    <literal>NULL</literal> vers le type <type>boolean</type>, par exemple
    <literal>NULL::boolean</literal>. À l'inverse, la conversion peut être
    omise d'une valeur booléenne représentée sous la forme d'une chaîne de
    caractères dans les contextes où l'analyseur peut déduire que la constante
    doit être de type <type>boolean</type>.
   </para>
  </sect1>

  <sect1 id="datatype-enum">
   <title>Types énumération</title>

   <indexterm zone="datatype-enum">
    <primary>data type</primary>
    <secondary>énumération (enum)</secondary>
   </indexterm>

   <indexterm zone="datatype-enum">
    <primary>types énumérations</primary>
   </indexterm>

   <para>
    Les types énumérés (enum) sont des types de données qui comprennent un
    ensemble statique, prédéfini de valeurs dans un ordre spécifique. Ils sont
    équivalents aux types <type>enum</type> dans de nombreux langages de
    programmation. Les jours de la semaine ou un ensemble de valeurs de statut
    pour un type de données sont de bons exemples de type enum.
   </para>

   <sect2>
    <title>Déclaration de types énumérés</title>

    <para>
     Les types enum sont créés en utilisant la commande <xref
     linkend="sql-createtype"/>.
     Par exemple&nbsp;:

<programlisting>
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
    </programlisting>

    Une fois créé, le type enum peut être utilisé dans des définitions de
    table et de fonction, comme tous les autres types&nbsp;:

    <programlisting>
CREATE TYPE humeur AS ENUM ('triste', 'ok', 'heureux');
CREATE TABLE personne (
    nom text,
    humeur_actuelle humeur
);
INSERT INTO personne VALUES ('Moe', 'heureux');
SELECT * FROM personne WHERE humeur_actuelle = 'heureux';
 name | humeur_actuelle
------+-----------------
 Moe  | heureux
(1 row)
    </programlisting>
   </para>
  </sect2>

  <sect2>
   <title>Tri</title>

   <para>
    L'ordre des valeurs dans un type enum correspond à l'ordre dans lequel
    les valeurs sont créées lors de la déclaration du type. Tous les
    opérateurs de comparaison et les fonctions d'agrégats relatives peuvent
    être utilisés avec des types enum. Par exemple&nbsp;:

    <programlisting>
INSERT INTO personne VALUES ('Larry', 'triste');
INSERT INTO personne VALUES ('Curly', 'ok');
SELECT * FROM personne WHERE humeur_actuelle > 'triste';
 nom   | humeur_actuelle
-------+-----------------
 Moe   | heureux
 Curly | ok
(2 rows)

SELECT * FROM personne WHERE humeur_actuelle > 'triste' ORDER BY humeur_actuelle;
 nom   | humeur_actuelle
-------+--------------
 Curly | ok
 Moe   | heureux
(2 rows)

SELECT nom
FROM personne
WHERE humeur_actuelle = (SELECT MIN(humeur_actuelle) FROM personne);
 nom
-------
 Larry
(1 row)
    </programlisting>
   </para>
  </sect2>

  <sect2>
   <title>Sûreté du type</title>

   <para>
    Chaque type de données énuméré est séparé et ne peut pas être comparé
    aux autres types énumérés. Par exemple&nbsp;:

    <programlisting>
CREATE TYPE niveau_de_joie AS ENUM ('heureux', 'très heureux', 'ecstatique');
CREATE TABLE vacances (
    nombre_de_semaines integer,
    niveau_de_joie niveau_de_joie
);
INSERT INTO vacances(nombre_de_semaines,niveau_de_joie) VALUES (4, 'heureux');
INSERT INTO vacances(nombre_de_semaines,niveau_de_joie) VALUES (6, 'très heureux');
INSERT INTO vacances(nombre_de_semaines,niveau_de_joie) VALUES (8, 'ecstatique');
INSERT INTO vacances(nombre_de_semaines,niveau_de_joie) VALUES (2, 'triste');
ERROR:  invalid input value for enum niveau_de_joie: "triste"
SELECT personne.nom, vacances.nombre_de_semaines FROM personne, vacances
  WHERE personne.humeur_actuelle = vacances.niveau_de_joie;
ERROR:  operator does not exist: humeur = niveau_de_joie
    </programlisting>
   </para>

   <para>
    Si vous avez vraiment besoin de ce type de conversion, vous pouvez soit
    écrire un opérateur personnalisé soit ajouter des conversions explicites
    dans votre requête&nbsp;:

    <programlisting>
SELECT personne.nom, vacances.nombre_de_semaines FROM personne, vacances
  WHERE personne.humeur_actuelle::text = vacances.niveau_de_joie::text;
 nom  | nombre_de_semaines
------+--------------------
 Moe  |         4
(1 row)

    </programlisting>
   </para>
  </sect2>

  <sect2>
   <title>Détails d'implémentation</title>

   <para>
    Les labels enum sont sensibles à la casse, donc <type>'heureux'</type>
    n'est pas identique à <type>'HEUREUX'</type>. Les espaces blancs dans les
    labels sont aussi pris en compte.
   </para>

   <para>
    Bien que les types enum aient principalement pour but d'être des ensembles
    statiques de valeurs, il est possible d'ajouter de nouvelles valeurs à un
    type enum existant et de renommer les valeurs existantes (voir <xref
    linkend="sql-altertype"/>). Les valeurs existantes ne peuvent pas être
    supprimées d'un type enum, pas plus qu'il n'est possible de modifier
    l'ordre de tri de ces valeurs, si ce n'est en supprimant puis en re-
    créant le type enum.
   </para>

   <para>
    Une valeur enum occupe quatre octets sur disque. La longueur du label texte
    d'une valeur enum est limité au paramètre <symbol>NAMEDATALEN</symbol>
    codé en dur dans <productname>PostgreSQL</productname>&nbsp;; dans les
    constructions standard, cela signifie un maximum de 63 octets.
   </para>

   <para>
    Les traductions des valeurs enum internes vers des labels texte sont
    gardées dans le catalogue système <link linkend="catalog-pg-enum">
     <structname>pg_enum</structname></link>. Interroger ce catalogue directement
    peut s'avérer utile.
   </para>

  </sect2>
 </sect1>

 <sect1 id="datatype-geometric">
  <title>Types géométriques</title>

  <para>
   Les types de données géométriques représentent des objets à deux
   dimensions. Le <xref linkend="datatype-geo-table"/> liste les types
   disponibles dans <productname>PostgreSQL</productname>.
  </para>

  <table id="datatype-geo-table">
   <title>Types géométriques</title>
   <tgroup cols="4">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="1*"/>
    <colspec colname="col3" colwidth="2*"/>
    <colspec colname="col4" colwidth="1*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Taille de stockage</entry>
      <entry>Description</entry>
      <entry>Représentation</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><type>point</type></entry>
      <entry>16 octets</entry>
      <entry>Point du plan</entry>
      <entry>(x,y)</entry>
     </row>
     <row>
      <entry><type>line</type></entry>
      <entry>32 octets</entry>
      <entry>Ligne infinie</entry>
      <entry>((x1,y1),(x2,y2))</entry>
     </row>
     <row>
      <entry><type>lseg</type></entry>
      <entry>32 octets</entry>
      <entry>Segment de droite fini</entry>
      <entry>((x1,y1),(x2,y2))</entry>
     </row>
     <row>
      <entry><type>box</type></entry>
      <entry>32 octets</entry>
      <entry>Boîte rectangulaire</entry>
      <entry>((x1,y1),(x2,y2))</entry>
     </row>
     <row>
      <entry><type>path</type></entry>
      <entry>16+16n octets</entry>
      <entry>Chemin fermé (similaire à un polygone)</entry>
      <entry>((x1,y1),...)</entry>
     </row>
     <row>
      <entry><type>path</type></entry>
      <entry>16+16n octets</entry>
      <entry>Chemin ouvert</entry>
      <entry>[(x1,y1),...]</entry>
     </row>
     <row>
      <entry><type>polygon</type></entry>
      <entry>40+16n octets</entry>
      <entry>Polygone (similaire à un chemin fermé)</entry>
      <entry>((x1,y1),...)</entry>
     </row>
     <row>
      <entry><type>circle</type></entry>
      <entry>24 octets</entry>
      <entry>Cercle</entry>
      <entry>&lt;(x,y),r&gt; (point central et rayon)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Un large ensemble de fonctions et d'opérateurs permettent d'effectuer
   différentes opérations géométriques, comme l'échelonnage, la translation,
   la rotation, la détermination des intersections. Elles sont expliquées dans
   la <xref linkend="functions-geometry"/>.
  </para>

  <sect2>
   <title>Points</title>

   <indexterm>
    <primary>point</primary>
   </indexterm>

   <para>
    Les points sont les briques fondamentales des types géométriques.
    Les valeurs de type <type>point</type> sont indiquées à l'aide d'une des
    syntaxes suivantes&nbsp;:
    <synopsis>( <replaceable>x</replaceable> , <replaceable>y</replaceable> )
  <replaceable>x</replaceable> , <replaceable>y</replaceable></synopsis>

     où <replaceable>x</replaceable> et <replaceable>y</replaceable> sont les coordonnées respectives
     sous forme de nombre à virgule flottante.
    </para>

    <para>
     Les points sont affichés en utilisant la première syntaxe.
    </para>
   </sect2>

   <sect2 id="datatype-line">
    <title>Lines</title>

    <indexterm>
     <primary>line</primary>
    </indexterm>

    <para>
     Les lignes sont représentées par l'équation linéaire
     <replaceable>A</replaceable>x + <replaceable>B</replaceable>y + <replaceable>C</replaceable> = 0,
     où <replaceable>A</replaceable> et <replaceable>B</replaceable> ne valent
     pas zéro tous les deux. Les valeurs de type <type>line</type> sont fournies
     et récupérées sous la forme suivante&nbsp;:
<synopsis>
{ <replaceable>A</replaceable>, <replaceable>B</replaceable>, <replaceable>C</replaceable> }
    </synopsis>

    Il est également possible d'utiliser n'importe laquelle des formes
    suivantes pour la saisie&nbsp;:

    <synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
    </synopsis>

    où
    <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
    et
    <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
    sont deux points différents sur la ligne.
   </para>
  </sect2>

  <sect2 id="datatype-lseg">
   <title>Segments de droite</title>

   <indexterm>
    <primary>lseg</primary>
   </indexterm>

   <indexterm>
    <primary>ligne</primary>
   </indexterm>

   <para>
    Les segments de ligne sont représentés par des paires de points qui sont
    les points finaux du segment. Les valeurs de type <type>lseg</type> sont
    précisées en utilisant une des syntaxes suivantes&nbsp;:

    <synopsis>[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable></synopsis>

     où
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     et
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     sont les points aux extrémités du segment.
    </para>

    <para>
     Les segments de ligne sont affichés en utilisant la première syntaxe.
    </para>
   </sect2>

<!-- Boîte ou boite ? -->
    <sect2>
     <title>Boîtes</title>

     <indexterm>
      <primary>boîte (type de données)</primary>
     </indexterm>

     <indexterm>
      <primary>rectangle</primary>
     </indexterm>


     <para>
      Les boîtes (rectangles) sont représentées par les paires de points des coins
      opposés de la boîte selon une des syntaxes suivantes&nbsp;:

      <synopsis>( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable></synopsis>

     où
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     et
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     sont les coins opposés du rectangle.
    </para>

    <para>
     Les rectangles sont affichés selon la deuxième syntaxe.
    </para>

    <para>
     Les deux coins
     opposés peuvent être fournis en entrée, mais les valeurs seront réordonnées
     pour stocker les coins en haut à droite et en bas à gauche, dans cet ordre.
    </para>
   </sect2>

   <sect2>
    <title>Chemins</title>

    <indexterm>
     <primary>path (type de données)</primary>
    </indexterm>

    <para>
     Les chemins ( type <type>path</type> )
     sont représentés par des listes de points connectés.
     Ils peuvent être <firstterm>ouverts</firstterm>, si le premier et
     le dernier point ne sont pas considérés comme connectés, ou <firstterm>fermés</firstterm>,
     si le premier et le dernier point sont considérés comme connectés.
    </para>

    <para>
     Les valeurs de type <type>path</type> sont saisies selon une des syntaxes
     suivantes&nbsp;:

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable></synopsis>

    où les points sont les extrémités des segments de droite qui forment
    le chemin. Les crochets (<literal>[]</literal>) indiquent un chemin ouvert
    alors que les parenthèses (<literal>()</literal>) indiquent un chemin fermé.
    Quand les parenthèses externes sont omises, comme dans les syntaxes trois
    à cinq, un chemin fermé est utilisé.
    </para>

    <para>
     Les chemins sont affichés selon la première ou la seconde syntaxe appropriée.
    </para>
   </sect2>

   <sect2 id="datatype-polygon">
    <title>Polygones</title>

    <indexterm>
     <primary>polygon</primary>
    </indexterm>

    <para>
     Les polygones (type <type>polygon</type>) sont représentés par des
     listes de points (les vertex du polygone). Ils sont très similaires à
     des chemins fermés, mais ils sont stockés différemment et disposent de
     leurs propres routines de manipulation.
    </para>

    <para>
     Les valeurs de type <type>polygon</type> sont saisies selon une des
     syntaxes suivantes&nbsp;:

<synopsis>( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable></synopsis>

     où les points sont les extrémités des segments de droite
     qui forment les limites du polygone.
    </para>

    <para>
     Les polygones sont affichés selon la première syntaxe.
    </para>
   </sect2>

   <sect2 id="datatype-circle">
    <title>Cercles</title>

    <indexterm>
     <primary>circle</primary>
    </indexterm>

    <para>
     Les cercles (type <type>circle</type>) sont représentés par un point
     central et un rayon. Les valeurs de type <type>circle</type> sont saisies
     selon une des syntaxes suivantes&nbsp;:

<synopsis>&lt; ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> &gt;
( ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> )
  ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable>
    <replaceable>x</replaceable> , <replaceable>y</replaceable>   , <replaceable>r</replaceable>  </synopsis>

     où
     <literal>(<replaceable>x</replaceable>,<replaceable>y</replaceable>)</literal>
     est le point central et <replaceable>r</replaceable> le rayon du cercle.
    </para>

    <para>
     Les cercles sont affichés selon la première syntaxe.
    </para>
   </sect2>

  </sect1>

  <sect1 id="datatype-net-types">
   <title>Types adresses réseau</title>

   <indexterm zone="datatype-net-types">
    <primary>réseau</primary>
    <secondary>types de données</secondary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> propose des types de données pour stocker des
    adresses IPv4, IPv6 et MAC. Ceux-ci sont décrits dans le
    <xref linkend="datatype-net-types-table"/>.
    Il est préférable d'utiliser ces types plutôt que des types texte
    standard pour stocker les adresses réseau, car ils offrent un contrôle
    de syntaxe lors de la saisie et plusieurs opérateurs et fonctions
    spécialisés (voir la <xref linkend="functions-net"/>).
   </para>

    <table tocentry="1" id="datatype-net-types-table">
     <title>Types d'adresses réseau</title>
     <tgroup cols="3">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="1*"/>
     <colspec colname="col3" colwidth="2*"/>
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Taille de stockage</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>

       <row>
        <entry><type>cidr</type></entry>
        <entry>7 ou 19 octets</entry>
        <entry>réseaux IPv4 et IPv6</entry>
       </row>

       <row>
        <entry><type>inet</type></entry>
        <entry>7 ou 19 octets</entry>
        <entry>hôtes et réseaux IPv4 et IPv6</entry>
       </row>

       <row>
        <entry><type>macaddr</type></entry>
        <entry>6 octets</entry>
        <entry>adresses MAC</entry>
       </row>

       <row>
        <entry><type>macaddr8</type></entry>
        <entry>8 bytes</entry>
        <entry>adresses MAC (format EUI-64)</entry>
       </row>

      </tbody>
     </tgroup>
    </table>

   <para>
    Lors du tri de données de types <type>inet</type> ou <type>cidr</type>,
    les adresses IPv4 apparaissent toujours avant les adresses IPv6,
    y compris les adresses IPv4 encapsulées, comme
    ::10.2.3.4 ou ::ffff:10.4.3.2.
   </para>


   <sect2 id="datatype-inet">
    <title><type>inet</type></title>

    <indexterm>
     <primary>inet (type de données)</primary>
    </indexterm>

    <para>
     Le type <type>inet</type> stocke une adresse d'hôte IPv4 ou IPv6 et,
     optionnellement, son sous-réseau, le tout dans un seul champ. Le
     sous-réseau est représenté par le nombre de bits de l'adresse hôte
     constituant l'adresse réseau (le <quote>masque réseau</quote>).
     Si le masque réseau est 32 et l'adresse de type IPv4,
     alors la valeur n'indique pas un sous-réseau, juste un hôte.
     En IPv6, la longueur de l'adresse est de 128 bits, si bien que
     128 bits définissent une adresse réseau unique. Pour n'accepter que des
     adresses réseau, il est préférable
     d'utiliser le type <type>cidr</type> plutôt que le type <type>inet</type>.
    </para>

    <para>
      Le format de saisie pour ce type est
      <replaceable class="parameter">adresse/y</replaceable>
      où
      <replaceable class="parameter">adresse</replaceable>
      est l'adresse la plus basse du réseau en IPv4 ou en IPv6
      et <replaceable class="parameter">y</replaceable>
      est le nombre de bits du masque réseau.
      Si <replaceable class="parameter">y</replaceable>
      est omis, alors le masque vaut 32 pour IPv4 et
      128 pour IPv6, et la valeur représente un hôte unique.
      À l'affichage, la portion
      <replaceable class="parameter">/y</replaceable>
      est supprimée si le masque réseau indique un hôte unique.
    </para>
   </sect2>

   <sect2 id="datatype-cidr">
    <title><type>cidr</type></title>

    <indexterm>
     <primary>cidr</primary>
    </indexterm>

    <para>
     Le type <type>cidr</type> stocke une définition de réseau
     IPv4 ou IPv6. La saisie et l'affichage suivent les conventions
     Classless Internet Domain Routing.
     Le format de saisie d'un réseau est
     <replaceable class="parameter">address/y</replaceable> où
     <replaceable class="parameter">address</replaceable> est le réseau représenté sous forme
     d'une adresse IPv4 ou IPv6 et
     <replaceable class="parameter">y</replaceable> est le nombre de bits du masque réseau.
     Si <replaceable class="parameter">y</replaceable> est omis, il calculé en
     utilisant les règles de l'ancien système de classes d'adresses,
     à ceci près qu'il est au moins assez grand pour inclure tous
     les octets saisis. Saisir une adresse réseau
     avec des bits positionnés à droite du masque indiqué est une erreur.
    </para>

    <para>
     <xref linkend="datatype-net-cidr-table"/> présente quelques exemples.
    </para>

     <table id="datatype-net-cidr-table">
      <title>Exemples de saisie de types <type>cidr</type></title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Saisie <type>cidr</type></entry>
         <entry>Affichage <type>cidr</type></entry>
         <entry><literal><function>abbrev(<type>cidr</type>)</function></literal></entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
        </row>
        <row>
         <entry>192.168/24</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
        <row>
         <entry>192.168/25</entry>
         <entry>192.168.0.0/25</entry>
         <entry>192.168.0.0/25</entry>
        </row>
        <row>
         <entry>192.168.1</entry>
         <entry>192.168.1.0/24</entry>
         <entry>192.168.1/24</entry>
        </row>
        <row>
         <entry>192.168</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
        <row>
         <entry>128.1</entry>
         <entry>128.1.0.0/16</entry>
         <entry>128.1/16</entry>
        </row>
        <row>
         <entry>128</entry>
         <entry>128.0.0.0/16</entry>
         <entry>128.0/16</entry>
        </row>
        <row>
         <entry>128.1.2</entry>
         <entry>128.1.2.0/24</entry>
         <entry>128.1.2/24</entry>
        </row>
        <row>
         <entry>10.1.2</entry>
         <entry>10.1.2.0/24</entry>
         <entry>10.1.2/24</entry>
        </row>
        <row>
         <entry>10.1</entry>
         <entry>10.1.0.0/16</entry>
         <entry>10.1/16</entry>
        </row>
        <row>
         <entry>10</entry>
         <entry>10.0.0.0/8</entry>
         <entry>10/8</entry>
        </row>
        <row>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
        </row>
        <row>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba/64</entry>
        </row>
        <row>
         <entry>2001:4f8:3:ba:&zwsp;2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:&zwsp;2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:&zwsp;2e0:81ff:fe22:d1f1/128</entry>
        </row>
        <row>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3/120</entry>
        </row>
        <row>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
   </sect2>

<!-- vs est couramment employé en français pour signaler une mise en
opposition de deux choses -->
      <sect2 id="datatype-inet-vs-cidr">
       <title><type>inet</type> vs <type>cidr</type></title>

       <para>
        La différence principale entre les types de données <type>inet</type>
        et <type>cidr</type> réside dans le fait que <type>inet</type> accepte
        des valeurs avec des bits non nuls à droite du masque de réseau, alors
        que <type>cidr</type> ne l'accepte pas. Par exemple,
        <literal>192.168.0.1/24</literal> est valide pour <type>inet</type>,
        mais pas pour <type>cidr</type>.
       </para>

       <tip>
        <para>
         Les fonctions <function>host</function>, <function>text</function> et
         <function>abbrev</function> permettent de modifier le format
         d'affichage des valeurs <type>inet</type> et <type>cidr</type>.
        </para>
       </tip>
      </sect2>

      <sect2 id="datatype-macaddr">
       <title><type>macaddr</type></title>

       <indexterm>
        <primary>macaddr (type de données)</primary>
       </indexterm>

       <indexterm>
        <primary>adresse MAC</primary>
        <see>macaddr</see>
       </indexterm>

       <para>
        Le type <type>macaddr</type> stocke des adresses MAC, connues par exemple
        pour les adresses de cartes réseau Ethernet (mais les adresses MAC sont
        aussi utilisées dans d'autres cas). Les saisies sont acceptées dans les
        formats suivants&nbsp;:

        <simplelist>
         <member><literal>'08:00:2b:01:02:03'</literal></member>
         <member><literal>'08-00-2b-01-02-03'</literal></member>
         <member><literal>'08002b:010203'</literal></member>
         <member><literal>'08002b-010203'</literal></member>
         <member><literal>'0800-2b01-0203'</literal></member>
         <member><literal>'08002b010203'</literal></member>
        </simplelist>

        Ces exemples indiquent tous la même adresse. Les majuscules et les
        minuscules sont acceptées pour les chiffres <literal>a</literal> à
        <literal>f</literal>. L'affichage se fait toujours selon le premier
        des formats ci-dessus.
       </para>

       <para>
        Le standard IEEE 802-2001 spécifie la seconde forme affichée
        (avec les tirets) comme forme canonique pour les adresses MAC, et
        la première forme (avec les :) comme la notation à bits retournés,
        ce qui donne l'équivalence 08-00-2b-01-02-03 = 01:00:4D:08:04:0C.
        Cette convention est largement ignorée aujourd'hui et n'a de
        sens que pour des protocoles réseau obsolètes (comme Token Ring).
        PostgreSQL ne tient pas compte des bits retournés, et tous les formats
        acceptés utilisent l'ordre canonique LSB.
       </para>

       <para>
        Les cinq derniers formats ne font partie d'aucun standard.
       </para>

      </sect2>

      <sect2 id="datatype-macaddr8">
       <title><type>macaddr8</type></title>

       <indexterm>
        <primary>macaddr8 (data type)</primary>
       </indexterm>

       <indexterm>
        <primary>adresse MAC (format EUI-64)</primary>
        <see>macaddr</see>
       </indexterm>

       <para>
        Le type <type>macaddr8</type> stocke des adresses MAC au format EUI-64,
        connu par exemple pour les adresses de cartes réseau Ethernet (mais
        les adresses MAC sont aussi utilisées dans d'autres cas).
        Ce type accepte à la fois des adresses MAC d'une longueur de six et huit
        octets.  Les adresses MAC fournies dans un format de six octets seront
        stockées dans un format de huit octets avec les quatrième et cinquième octets
        respectivement positionnés à FF et FE.

        Veuillez noter qu'IPv6 utilise un format modifié de EUI-64 où le septième
        bit devrait être positionné à un après la conversion depuis EUI-48.  La
        fonction <function>macaddr8_set7bit</function> est fournie pour
        réaliser ce changement.

        De manière générale, n'importe quelle valeur en entrée constituée de
        paires de chiffres au format hexadécimal (dans les limites d'un octet),
        systématiquement séparées ou non d'un de ces caractères
        <literal>':'</literal>, <literal>'-'</literal> ou
        <literal>'.'</literal> est acceptée.  Le nombre de chiffres
        hexadécimaux doit être 16 (huit octets) ou 12 (six octets).  Les
        espaces non significatifs présents avant ou après sont ignorés.

        Voici un ensemble d'exemples de formats acceptés en entrée :

        <simplelist>
         <member><literal>'08:00:2b:01:02:03:04:05'</literal></member>
         <member><literal>'08-00-2b-01-02-03-04-05'</literal></member>
         <member><literal>'08002b:0102030405'</literal></member>
         <member><literal>'08002b-0102030405'</literal></member>
         <member><literal>'0800.2b01.0203.0405'</literal></member>
         <member><literal>'0800-2b01-0203-0405'</literal></member>
         <member><literal>'08002b01:02030405'</literal></member>
         <member><literal>'08002b0102030405'</literal></member>
        </simplelist>

        Ces exemples spécifient tous la même adresse.  Les majuscules et les
        minuscules sont acceptées pour les caractères de
        <literal>a</literal> jusqu'à <literal>f</literal>. La sortie sera
        toujours au même format que le premier exemple.
       </para>

       <para>
        Les six derniers formats en entrée qui sont mentionnés au-dessus ne
        font partie d'aucun standard.
       </para>

       <para>
        Pour convertir une adresse MAC traditionnelle de 48 bits au format
        EUI-48 vers le format modifié EUI-64 pour pouvoir être incluse dans la
        partie hôte d'une adresse IPv6, utilisez
        <function>macaddr8_set7bit</function> comme ceci :

        <programlisting>
SELECT macaddr8_set7bit('08:00:2b:01:02:03');
<computeroutput>
    macaddr8_set7bit
-------------------------
 0a:00:2b:ff:fe:01:02:03
(1 row)
</computeroutput>
        </programlisting>

       </para>

      </sect2>

     </sect1>

     <sect1 id="datatype-bit">
      <title>Type chaîne de bits</title>

      <indexterm zone="datatype-bit">
       <primary>chaîne de bits</primary>
       <secondary>type de données</secondary>
      </indexterm>

      <para>
       Les chaînes de bits sont des chaînes de 0 et de 1. Elles peuvent être
       utilisées pour stocker ou visualiser des masques de bits.
       Il y a deux types bits en SQL&nbsp;:
       <type>bit(<replaceable>n</replaceable>)</type> et
       <type>bit varying(<replaceable>n</replaceable>)</type>, avec
       <replaceable>n</replaceable> un entier positif.
      </para>

      <para>
       Les données de type <type>bit</type> doivent avoir une longueur de
       <replaceable>n</replaceable> bits exactement. Essayer de lui affecter une
       chaîne de bits plus longue ou plus courte déclenche une erreur.
       Les données de type <type>bit varying</type> ont une longueur variable,
       d'au maximum <replaceable>n</replaceable> bits&nbsp;;
       les chaînes plus longues sont rejetées.
       Écrire <type>bit</type> sans longueur est équivalent à
       <literal>bit(1)</literal>, alors que <type>bit varying</type> sans
       longueur indique une taille illimitée.
      </para>

      <note>
       <para>
        Lors du transtypage explicite (cast) d'une chaîne de bits en
        champ de type <type>bit(<replaceable>n</replaceable>)</type>, la chaîne
        obtenue est complétée avec des zéros ou bien tronquée pour obtenir une
        taille de <replaceable>n</replaceable> bits exactement, sans que cela
        ne produise une erreur. De la même façon, si une chaîne de bits est
        explicitement transtypée en un champ de type
        <type>bit varying(<replaceable>n</replaceable>)</type>, elle est tronquée
        si sa longueur dépasse <replaceable>n</replaceable> bits.
       </para>
      </note>

      <para>
       Voir la <xref linkend="sql-syntax-bit-strings"/> pour plus d'information sur
       la syntaxe des constantes en chaîne de bits.
       Les opérateurs logiques et les fonctions de manipulation de chaînes
       sont décrits dans la <xref linkend="functions-bitstring"/>.
      </para>

      <example>
       <title>Utiliser les types de chaînes de bits</title>

       <programlisting>CREATE TABLE test (a BIT(3), b BIT VARYING(5));
INSERT INTO test VALUES (B'101', B'00');
INSERT INTO test VALUES (B'10', B'101');
<computeroutput>
ERROR:  bit string length 2 does not match type bit(3)
</computeroutput>
INSERT INTO test VALUES (B'10'::bit(3), B'101');
SELECT * FROM test;
<computeroutput>
  a  |  b
-----+-----
 101 | 00
 100 | 101
</computeroutput></programlisting>
   </example>

   <para>
    Une valeur pour une chaîne de bits nécessite un octet pour chaque groupe de
    huit bits, plus cinq ou huit octets d'en-tête suivant la longueur de la
    chaîne (les valeurs longues peuvent être compressées ou déplacées, comme
    expliqué dans <xref linkend="datatype-character"/> pour les chaînes de
    caractères).
   </para>
  </sect1>

  <sect1 id="datatype-textsearch">
   <title>Types de recherche plein texte</title>

   <indexterm zone="datatype-textsearch">
    <primary>recherche plein texte</primary>
    <secondary>types de données</secondary>
   </indexterm>

   <indexterm zone="datatype-textsearch">
    <primary>recherche textuelle</primary>
    <secondary>types de données</secondary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> fournit deux types de données conçus
    pour supporter la recherche plein texte qui est l'activité de recherche
    via une collection de <firstterm>documents</firstterm> en langage naturel
    pour situer ceux qui correspondent le mieux à une
    <firstterm>requête</firstterm>. Le type <type>tsvector</type> représente un
    document dans une forme optimisée pour la recherche plein texte alors que le
    type <type>tsquery</type> représente de façon similaire une requête.
    <xref linkend="textsearch"/> fournit une explication détaillée de cette
    capacité et <xref linkend="functions-textsearch"/> résume les fonctions
    et opérateurs en relation.
   </para>

   <sect2 id="datatype-tsvector">
    <title><type>tsvector</type></title>

    <indexterm>
     <primary>tsvector (data type)</primary>
    </indexterm>

    <para>
     Une valeur <type>tsvector</type> est une liste triée de
     <firstterm>lexemes</firstterm> distincts, qui sont des mots qui ont été
     <firstterm>normalisés</firstterm> pour fusionner différentes variantes du
     même mot apparaissant (voir <xref linkend="textsearch"/> pour plus de détails).
     Trier et éliminer les duplicats se font automatiquement lors des entrées,
     comme indiqué dans cet exemple&nbsp;:

<programlisting>
SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;
                      tsvector
----------------------------------------------------
 'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'
       </programlisting>

       Pour représenter des lexèmes contenant des espaces blancs ou des signes
       de ponctuation, entourez-les avec des guillemets simples&nbsp;:

       <programlisting>
SELECT $$the lexeme '    ' contains spaces$$::tsvector;
                 tsvector
-------------------------------------------
 '    ' 'contains' 'lexeme' 'spaces' 'the'
       </programlisting>

       (Nous utilisons les valeurs littérales entre guillemets simples dans cet
       exemple et dans le prochain pour éviter une confusion en ayant à doubler
       les guillemets à l'intérieur des valeurs littérales.) Les guillemets
       imbriqués et les antislashs doivent être doublés&nbsp;:

       <programlisting>
SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;
                    tsvector
------------------------------------------------
 'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'
       </programlisting>

       En option, les <firstterm>positions</firstterm> peuvent être attachées
       aux lexèmes&nbsp;:

       <programlisting>
SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11 rat:12'::tsvector;
                                  tsvector
-------------------------------------------------------------------------------
 'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12 'sat':4
       </programlisting>

       Une position indique normalement l'emplacement du mot source dans le
       document. Les informations de position sont utilisables pour avoir un
       <firstterm>score de proximité</firstterm>. Les valeurs des positions peuvent
       aller de 1 à 16383&nbsp;; les grands nombres sont limités silencieusement
       à 16383.
       Les positions dupliquées du même lexème sont rejetées.
      </para>

      <para>
       Les lexèmes qui ont des positions peuvent aussi avoir un label d'un
       certain <firstterm>poids</firstterm>. Les labels possibles sont
       <literal>A</literal>, <literal>B</literal>, <literal>C</literal> ou
       <literal>D</literal>.
       <literal>D</literal> est la valeur par défaut et n'est du coup pas affiché
       en sortie&nbsp;:

       <programlisting>
SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;
          tsvector
----------------------------
 'a':1A 'cat':5 'fat':2B,4C
       </programlisting>

       Les poids sont typiquement utilisés pour refléter la structure du
       document en marquant les mots du titre de façon différente des mots du
       corps. Les fonctions de score de la recherche plein texte peuvent assigner
       des priorités différentes aux marqueurs de poids différents.
      </para>

      <para>
       Il est important de comprendre que le type <type>tsvector</type>
       lui-même ne réalise aucune normalisation de mots&nbsp;; il suppose que
       les mots qui lui sont fournis sont normalisés correctement pour
       l'application. Par exemple,

       <programlisting>
SELECT 'The Fat Rats'::tsvector;
      tsvector
--------------------
 'Fat' 'Rats' 'The'
       </programlisting>

       Pour la plupart des applications de recherche en anglais, les mots ci-dessus
       seraient considérés comme non normalisés, mais <type>tsvector</type> n'y prête
       pas attention. Le texte des documents bruts doit habituellement passer via
       <function>to_tsvector</function> pour normaliser les mots de façon appropriée
       pour la recherche&nbsp;:

       <programlisting>
SELECT to_tsvector('english', 'The Fat Rats');
   to_tsvector
-----------------
 'fat':2 'rat':3
       </programlisting>

       De nouveau, voir <xref linkend="textsearch"/> pour plus de détails.
      </para>

     </sect2>

     <sect2 id="datatype-tsquery">
      <title><type>tsquery</type></title>

      <indexterm>
       <primary>tsquery (type de données)</primary>
      </indexterm>

      <para>
       Une valeur <type>tsquery</type> enregistre les lexèmes qui doivent être
       recherchés, et peut les combiner en utilisant les opérateurs booléens
       <literal>&amp;</literal> (AND), <literal>|</literal> (OR) et
       <literal>!</literal> (NOT), ainsi que l'opérateur de recherche de phrase
       <literal>&lt;-&gt;</literal> (FOLLOWED BY). Il existe aussi une variante
       de l'opérateur FOLLOWED BY,
       <literal>&lt;<replaceable>N</replaceable>&gt;</literal>, où
       <replaceable>N</replaceable> est une constante entière indiquant la
       distance maximale entre les deux lexèmes recherchés.
       <literal>&lt;-&gt;</literal> est équivalent à <literal>&lt;1&gt;</literal>.
      </para>

      <para>
       Les parenthèses peuvent être utilisées pour forcer le regroupement des
       opérateurs. En l'absence de parenthèses, <literal>!</literal> (NOT)
       est prioritaire, <literal>&lt;-&gt;</literal> (FOLLOWED BY) suit, et
       enfin <literal>&amp;</literal> (AND) et <literal>|</literal> (OR) sont
       les moins prioritaires.
      </para>

      <para>
       Voici quelques exemples&nbsp;:

       <programlisting>
 SELECT 'fat &amp; rat'::tsquery;
    tsquery
---------------
 'fat' &amp; 'rat'

SELECT 'fat &amp; (rat | cat)'::tsquery;
          tsquery
---------------------------
 'fat' &amp; ( 'rat' | 'cat' )

SELECT 'fat &amp; rat &amp; ! cat'::tsquery;
        tsquery
------------------------
 'fat' &amp; 'rat' &amp; !'cat'
       </programlisting>
      </para>

      <para>
       En option, les lexèmes dans une <type>tsquery</type> peuvent être labelisés
       avec une lettre de poids ou plus, ce qui les restreint à une correspondance
       avec les seuls lexèmes <type>tsvector</type> pour un de ces poids&nbsp;:

       <programlisting>
SELECT 'fat:ab &amp; cat'::tsquery;
    tsquery
------------------
 'fat':AB &amp; 'cat'
       </programlisting>
      </para>

      <para>
       Par ailleurs, les lexèmes d'une <type>tsquery</type> peuvent
       être marqués avec <literal>*</literal> pour spécifier une correspondance
       de préfixe&nbsp;:
       <programlisting>
SELECT 'super:*'::tsquery;
  tsquery
-----------
 'super':*
       </programlisting>
       Cette requête fera ressortir tout mot dans un <type>tsvector</type> qui commence
       par <quote>super</quote>.
      </para>

      <para>
       Les règles de guillemets pour les lexèmes sont identiques à celles décrites
       ci-dessus pour les lexèmes de <type>tsvector</type>&nbsp;; et, comme avec
       <type>tsvector</type>, toute normalisation requise des mots doit se faire
       avant de les placer dans le type <type>tsquery</type>. La fonction
       <function>to_tsquery</function> est convenable pour réaliser une telle
       normalisation&nbsp;:

       <programlisting>
SELECT to_tsquery('Fat:ab &amp; Cats');
    to_tsquery
------------------
 'fat':AB &amp; 'cat'
       </programlisting>

       Notez que <function>to_tsquery</function> traitera les préfixes de la même façon que
       les autres mots, ce qui signifie que cette comparaison renvoie true&nbsp;:

       <programlisting>
SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );
 ?column?
----------
 t
       </programlisting>
       parce que <literal>postgres</literal> devient
       <literal>postgr</literal>&nbsp;:
       <programlisting>
SELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );
  to_tsvector  | to_tsquery
---------------+------------
 'postgradu':1 | 'postgr':*
       </programlisting>
       qui correspondra à la forme native de <literal>postgraduate</literal>.
      </para>

     </sect2>

    </sect1>

    <sect1 id="datatype-uuid">
     <title>Type <acronym>UUID</acronym></title>

     <indexterm zone="datatype-uuid">
      <primary>UUID</primary>
     </indexterm>

     <para>
      Le type de données <type>uuid</type> stocke des identifiants universels
      uniques (<acronym>UUID</acronym>, acronyme de <foreignphrase>Universally
       Unique Identifiers</foreignphrase>) décrits dans les standards RFC 4122,
      ISO/IEC 9834-8:2005,
      et d'autres encore. (Certains systèmes font référence à ce type de données
      en tant qu'identifiant unique global (ou <acronym>GUID</acronym>
      <indexterm><primary>GUID</primary></indexterm>).) Un identifiant de ce type
      est une quantité sur 128 bits générée par un algorithme adéquat qui a peu
      de chances d'être reproduit par quelqu'un d'autre utilisant le même
      algorithme. Du coup, pour les systèmes distribués, ces identifiants
      fournissent une meilleure garantie d'unicité que ce que pourrait fournir
      une séquence, dont la valeur est unique seulement au sein d'une base
      de données.
     </para>

     <para>
      Un <acronym>UUID</acronym> est écrit comme une séquence de chiffres
      hexadécimaux en minuscule, répartis en différents groupes, séparés par
      un tiret. Plus précisément, il s'agit d'un groupe de huit chiffres
      suivis de trois groupes de quatre chiffres terminés par un groupe de
      douze chiffres, ce qui fait un total de 32 chiffres représentant les
      128 bits. Voici un exemple d'<acronym>UUID</acronym> dans sa forme
      standard&nbsp;:
      <programlisting>
a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11
      </programlisting>
      PostgreSQL accepte aussi d'autres formes en entrée&nbsp;: utilisation
      des majuscules, de crochets englobant le nombre, suppression d'une partie
      ou de tous les tirets, ajout d'un tiret après n'importe quel groupe de quatre
      chiffres.
      Voici quelques exemples&nbsp;:
      <programlisting>
A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11
{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}
a0eebc999c0b4ef8bb6d6bb9bd380a11
a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11
{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}
      </programlisting>
      L'affichage est toujours dans la forme standard.
     </para>

     <para>
      Voir <xref linkend="functions-uuid"/> pour savoir comment générer un
      UUID dans <productname>PostgreSQL</productname>.
     </para>
    </sect1>

    <sect1 id="datatype-xml">
     <title>Type <acronym>XML</acronym></title>

     <indexterm zone="datatype-xml">
      <primary>XML</primary>
     </indexterm>

     <para>
      Le type de données <type>xml</type> est utilisé pour stocker des données
      au format XML. Son avantage sur un champ de type <type>text</type> est
      qu'il vérifie que les valeurs sont bien formées. De plus, il existe de
      nombreuses fonctions pour réaliser des opérations de vérification à partir
      de ce type&nbsp;; voir la <xref linkend="functions-xml"/>. L'utilisation
      de ce type de données requiert que l'étape de compilation ait utilisé
      l'option <option>--with-libxml</option>.
     </para>

     <para>
      Le type <type>xml</type> peut stocker des <quote>documents</quote> bien
      formés, suivant la définition du standard XML, ainsi que des fragments
      de contenu (<quote>content</quote>), en référence au <ulink
      url="https://www.w3.org/TR/2010/REC-xpath-datamodel-20101214/#DocumentNode"><quote>n&oelig;ud
        de document</quote></ulink> plus permissif des modèle de données XQuery
      et XPath. Cela signifie que les fragments de contenu peuvent avoir plus
      d'un élément racine ou n&oelig;ud caractère. L'expression
      <literal><replaceable>valeurxml</replaceable> IS DOCUMENT</literal>
      permet d'évaluer si une valeur <type>xml</type> particulière
      est un document complet ou seulement un fragment de contenu.
     </para>

     <para>
      Les limites et notes de compatibilité pour le type de données
      <type>xml</type> sont disponibles dans <xref
      linkend="xml-limits-conformance"/>.
     </para>

     <sect2>
      <title>Créer des valeurs XML</title>
      <para>
       Pour produire une valeur de type <type>xml</type> à partir d'une donnée de
       type caractère, utilisez la fonction <function>xmlparse</function>&nbsp;:
       <indexterm><primary>xmlparse</primary></indexterm>
       <synopsis>
XMLPARSE ( { DOCUMENT | CONTENT } <replaceable>valeur</replaceable>)
       </synopsis>
       Quelques exemples&nbsp;:
       <programlisting><![CDATA[
XMLPARSE (DOCUMENT '<?xml version="1.0"?><book><title>Manual</title><chapter>...</chapter></book>')
XMLPARSE (CONTENT 'abc<foo>bar</foo><bar>foo</bar>')
]]></programlisting>
    Bien que cela soit la seule façon de convertir des chaînes de
    caractères en valeurs XML d'après le standard XML, voici des syntaxes
    spécifiques à PostgreSQL&nbsp;:
<programlisting><![CDATA[
xml '<foo>bar</foo>'
'<foo>bar</foo>'::xml
]]></programlisting>
   </para>

   <para>
    Le type <type>xml</type> ne valide pas les valeurs en entrée par rapport
    à une déclaration de type de document (DTD),
    <indexterm><primary>DTD</primary></indexterm>
    même quand la valeur en entrée indique une DTD.
    Il n'existe pas encore de support pour la validation avec d'autres langages
    de schéma XML, comme XML Schema.
   </para>

   <para>
    L'opération inverse, produisant une chaîne de caractères à partir d'une
    valeur au type <type>xml</type>, utilise la fonction
    <function>xmlserialize</function>:<indexterm><primary>xmlserialize</primary></indexterm>
<synopsis>
XMLSERIALIZE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable> AS <replaceable>type</replaceable> )
       </synopsis>
       <replaceable>type</replaceable> peut être
       <type>character</type>, <type>character varying</type> ou
       <type>text</type> (ou un alias de ces derniers). Encore une fois, d'après
       le standard SQL, c'est le seul moyen de convertir le type
       <type>xml</type> vers les types caractère, mais PostgreSQL autorise aussi
       la conversion simple de la valeur.
      </para>

      <para>
       Lorsque les valeurs des chaînes de caractères sont converties vers ou à
       partir du type <type>xml</type> sans passer par <type>XMLPARSE</type> ou
       <type>XMLSERIALIZE</type>, respectivement, le choix de
       <literal>DOCUMENT</literal> ou de <literal>CONTENT</literal> est
       déterminé par un paramètre de configuration niveau session,
       <quote>XML OPTION</quote>
       <indexterm><primary>XML OPTION</primary></indexterm>, qui peut être
       configuré par la commande habituelle&nbsp;:
       <synopsis>
SET XML OPTION { DOCUMENT | CONTENT };
       </synopsis>
       ou la syntaxe PostgreSQL&nbsp;:
       <synopsis>
SET xmloption TO { DOCUMENT | CONTENT };
       </synopsis>
       La valeur par défaut est <literal>CONTENT</literal>, donc toutes les formes
       de données XML sont autorisées.
      </para>

     </sect2>

     <sect2>
      <title>Gestion de l'encodage</title>
      <para>
       Une grande attention doit prévaloir lors de la gestion de plusieurs
       encodages sur le client, le serveur ou dans les données XML qui
       passent entre eux. Lors de l'utilisation du mode texte pour passer
       les requêtes au serveur et pour renvoyer les résultats au client
       (qui se trouve dans le mode normal), PostgreSQL convertit toutes les
       données de type caractère passées entre le client et le serveur et
       vice-versa suivant l'encodage spécifique de la destination finale&nbsp;; voir la
       <xref linkend="multibyte"/>. Cela inclut les représentations textuelles
       des valeurs XML, comme dans les exemples ci-dessus, ce qui signifie
       que les déclarations d'encodage contenues dans les données XML pourraient
       devenir invalides lorsque les données sont converties vers un autre
       encodage lors du transfert entre le client et le serveur, alors que la
       déclaration de l'encodage n'est pas modifiée. Pour s'en sortir, une
       déclaration d'encodage contenue dans une chaîne de caractères
       présentée en entrée du type <type>xml</type> est
       <emphasis>ignorée</emphasis>, et le contenu est toujours supposé être de
       l'encodage du serveur. En conséquence, pour un traitement correct,
       ces chaînes de caractères de données XML doivent être envoyées du client
       dans le bon encodage. C'est de la responsabilité du client de soit
       convertir le document avec le bon encodage client avant de l'envoyer au
       serveur, soit d'ajuster l'encodage client de façon appropriée. En sortie,
       les valeurs du type <type>xml</type> n'auront pas une déclaration
       d'encodage et les clients devront supposer que les données sont dans
       l'encodage du client.
      </para>

      <para>
       Lors de l'utilisation du mode binaire pour le passage des paramètres
       de la requête au serveur et des résultats au client, aucune conversion
       de l'encodage n'est réalisée, donc la situation est différente.
       Dans ce cas, une déclaration d'encodage dans les données XML sera observée
       et, si elle est absente, les données seront supposées être en UTF-8 (comme
       requis par le standard XML&nbsp;; notez que PostgreSQL ne supporte pas
       du tout UTF-16). En sortie, les données auront une déclaration d'encodage
       spécifiant l'encodage client, sauf si l'encodage client est UTF-8, auquel
       cas elle sera omise.
      </para>

      <para>
       Le traitement des données XML avec PostgreSQL sera moins complexe et plus
       efficace si l'encodage des données, l'encodage client et l'encodage serveur sont
       identiques. Comme les données XML sont traitées en interne en UTF-8, les
       traitements seront plus efficaces si l'encodage serveur est aussi en
       UTF-8.
      </para>

      <caution>
       <para>
        Certaines fonctions relatives à XML pourraient ne pas fonctionner du tout
        sur des données non ASCII quand l'encodage du serveur n'est pas UTF-8. C'est
        un problème connu pour <function>xmltable()</function> et
        <function>xpath()</function> en particulier.
       </para>
      </caution>
     </sect2>

     <sect2>
      <title>Accéder aux valeurs XML</title>

      <para>
       Le type de données <type>xml</type> est inhabituel dans le sens où il ne
       dispose pas d'opérateurs de comparaison. Ceci est dû au fait qu'il n'existe
       pas d'algorithme de comparaison bien défini et utile pour des données XML.
       Une conséquence de ceci est que vous ne pouvez pas récupérer des lignes en
       comparant une colonne <type>xml</type> avec une valeur de recherche. Les
       valeurs XML doivent du coup être typiquement accompagnées par un champ
       clé séparé comme un identifiant. Une autre solution pour la comparaison
       de valeurs XML est de les convertir en des chaînes de caractères, mais
       notez que la comparaison de chaînes n'a que peu à voir avec une
       méthode de comparaison XML utile.
      </para>

      <para>
       Comme il n'y a pas d'opérateurs de comparaison pour le type de données
       <type>xml</type>, il n'est pas possible de créer un index directement
       sur une colonne de ce type. Si une recherche rapide est souhaitée dans
       des données XML, il est toujours possible de convertir l'expression en
       une chaîne de caractères et d'indexer cette conversion. Il est aussi
       possible d'indexer une expression XPath. La vraie requête devra bien sûr
       être ajustée à une recherche sur l'expression indexée.
      </para>

      <para>
       La fonctionnalité de recherche plein texte peut aussi être utilisée pour
       accélérer les recherches dans des données XML. Le support du prétraitement
       nécessaire n'est cependant pas disponible dans la distribution PostgreSQL.
      </para>
     </sect2>
    </sect1>

    &json;

    &array;

    &rowtypes;

    &rangetypes;

    <sect1 id="domains">
     <title>Types domaine</title>

     <indexterm zone="domains">
      <primary>domaine</primary>
     </indexterm>

     <indexterm zone="domains">
      <primary>type de données</primary>
      <secondary>domaine</secondary>
     </indexterm>

     <para>
      Un <firstterm>domaine</firstterm> est un type de données défini par
      l'utilisateur. Il est basé sur un autre <firstterm>type
       sous-jacent</firstterm>. En option, il peut avoir des contraintes qui
      restreignent les valeurs valides à un sous-ensemble de ce que permettrait
      le type sous-jacent. Pour le reste, il se comporte comme le type
      sous-jacent &mdash; par exemple, tout opérateur ou fonction qui peut être
      appliqué au type sous-jacent fonctionne avec le domaine. Le type
      sous-jacent peut être tout type, interne ou défini par l'utilisateur, type
      enum, type tableau, type composé, type intervalle ou autre domaine.
     </para>

     <para>
      Par exemple, nous pouvons créer un domaine sur des entiers qui n'accepte
      que des valeurs positives&nbsp;:
      <programlisting>
CREATE DOMAIN posint AS integer CHECK (VALUE &gt; 0);
CREATE TABLE mytable (id posint);
INSERT INTO mytable VALUES(1);   -- works
INSERT INTO mytable VALUES(-1);  -- fails
      </programlisting>
     </para>

     <para>
      Quand un opérateur ou une fonction du type sous-jacent est appliqué à la
      valeur d'un domaine, le domaine est automatiquement converti vers le type
      sous-jacent. Donc, par exemple, le résultat de <literal>mytable.id -
       1</literal> est considéré être de type <type>integer</type>, et non pas
      <type>posint</type>. Nous pouvons écrire <literal>(mytable.id -
       1)::posint</literal> pour convertir le résultat avec le type
      <type>posint</type>, causant une nouvelle vérification des contraintes du
      domaine. Dans ce cas, cela résultera en une erreur si l'expression a été
      appliquée à une valeur de 1 pour <structfield>id</structfield>. Affecter
      une valeur du type sous-jacent à un champ ou variable du type domaine est
      autorisé sans forcer une conversion explicite, mais les contraintes du
      domaine seront vérifiées.
     </para>

     <para>
      Pour plus d'informations, voir <xref linkend="sql-createdomain"/>.
     </para>
    </sect1>

    <sect1 id="datatype-oid">
     <title>Types identifiant d'objet</title>

     <indexterm zone="datatype-oid">
      <primary>identifiant d'objet</primary>
      <secondary>type de données</secondary>
     </indexterm>

     <indexterm zone="datatype-oid">
      <primary>oid</primary>
     </indexterm>

     <indexterm zone="datatype-oid">
      <primary>regclass</primary>
     </indexterm>

     <indexterm zone="datatype-oid">
      <primary>regcollation</primary>
     </indexterm>

     <indexterm zone="datatype-oid">
      <primary>regconfig</primary>
     </indexterm>

     <indexterm zone="datatype-oid">
      <primary>regdictionary</primary>
     </indexterm>

     <indexterm zone="datatype-oid">
      <primary>regnamespace</primary>
     </indexterm>

     <indexterm zone="datatype-oid">
      <primary>regoper</primary>
     </indexterm>

     <indexterm zone="datatype-oid">
      <primary>regoperator</primary>
     </indexterm>

     <indexterm zone="datatype-oid">
      <primary>regproc</primary>
     </indexterm>

     <indexterm zone="datatype-oid">
      <primary>regprocedure</primary>
     </indexterm>

     <indexterm zone="datatype-oid">
      <primary>regrole</primary>
     </indexterm>

     <indexterm zone="datatype-oid">
      <primary>regtype</primary>
     </indexterm>

     <indexterm zone="datatype-oid">
      <primary>xid8</primary>
     </indexterm>

     <indexterm zone="datatype-oid">
      <primary>cid</primary>
     </indexterm>

     <indexterm zone="datatype-oid">
      <primary>tid</primary>
     </indexterm>

     <indexterm zone="datatype-oid">
      <primary>xid</primary>
     </indexterm>

     <para>
      Les identifiants d'objets (OID) sont utilisés en interne par
      <productname>PostgreSQL</productname> comme clés primaires de
      différentes tables système. Le type <type>oid</type> représente un
      identifiant d'objet. Il existe aussi différents types alias pour un
      <type>oid</type> nommés
      <type>reg<replaceable>quelquechose</replaceable></type>. Le <xref
      linkend="datatype-oid-table"/> en donne un aperçu.
     </para>

     <para>
      Le type <type>oid</type> est à ce jour un entier non signé sur quatre octets.
      Il n'est, de ce fait, pas suffisamment large pour garantir l'unicité au
      sein d'une base de données volumineuse, voire au sein d'une très
      grosse table.
     </para>

     <para>
      Le type <type>oid</type> lui-même dispose de peu d'opérations en dehors de la
      comparaison. Il peut toutefois être converti en entier (integer)
      et manipulé par les opérateurs habituels des entiers
      (attention aux possibles confusions entre les entiers signés et non
      signés dans ce cas).
     </para>

     <para>
      Les types alias d'OID ne disposent pas d'opérations propres à
      l'exception des routines spécialisées de saisie et d'affichage.
      Ces routines acceptent et affichent les noms symboliques des objets système,
      plutôt que la valeur numérique brute que le type <type>oid</type>
      utilise. Les types alias permettent de simplifier la recherche des
      valeurs OID des objets. Par exemple, pour examiner les lignes
      <structname>pg_attribute</structname> en relation avec une table
      <literal>ma_table</literal>, on peut écrire&nbsp;:
      <programlisting>SELECT * FROM pg_attribute WHERE attrelid = 'ma_table'::regclass;</programlisting>
    plutôt que&nbsp;:
<programlisting>SELECT * FROM pg_attribute
WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'ma_table');</programlisting>
    Bien que cela semble une bonne solution, c'est un peu trop simplifié.
    Un sous-select bien plus compliqué peut être nécessaire pour sélectionner
    le bon OID s'il existe plusieurs tables nommées <literal>ma_table</literal> dans
    différents schémas. Le convertisseur de saisie <type>regclass</type> gère la
    recherche de la table en fonction du paramétrage du parcours des schémas et
    effectue donc la <quote>bonne recherche</quote> automatiquement. De façon
    similaire, la conversion d'un OID de table en <type>regclass</type>
    pour l'affichage d'un OID numérique est aisée.
   </para>

    <table id="datatype-oid-table">
     <title>Types identifiant d'objet</title>
     <tgroup cols="4">
      <colspec colnum="1" colwidth="0.7*"/>
      <colspec colnum="2" colwidth="0.7*"/>
      <colspec colnum="3" colwidth="1.3*"/>
      <colspec colnum="4" colwidth="1.3*"/>
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Référence</entry>
        <entry>Description</entry>
        <entry>Exemple</entry>
       </row>
      </thead>

      <tbody>

       <row>
        <entry><type>oid</type></entry>
        <entry>tous</entry>
        <entry>identifiant d'objet numérique</entry>
        <entry><literal>564182</literal></entry>
       </row>

       <row>
        <entry><type>regclass</type></entry>
        <entry><structname>pg_class</structname></entry>
        <entry>relation name</entry>
        <entry><literal>pg_type</literal></entry>
       </row>

       <row>
        <entry><type>regcollation</type></entry>
        <entry><structname>pg_collation</structname></entry>
        <entry>collation name</entry>
        <entry><literal>"POSIX"</literal></entry>
       </row>

       <row>
        <entry><type>regconfig</type></entry>
        <entry><structname>pg_ts_config</structname></entry>
        <entry>text search configuration</entry>
        <entry><literal>english</literal></entry>
       </row>

       <row>
        <entry><type>regdictionary</type></entry>
        <entry><structname>pg_ts_dict</structname></entry>
        <entry>text search dictionary</entry>
        <entry><literal>simple</literal></entry>
       </row>

       <row>
        <entry><type>regnamespace</type></entry>
        <entry><structname>pg_namespace</structname></entry>
        <entry>namespace name</entry>
        <entry><literal>pg_catalog</literal></entry>
       </row>

       <row>
        <entry><type>regoper</type></entry>
        <entry><structname>pg_operator</structname></entry>
        <entry>nom d'opérateur</entry>
        <entry><literal>+</literal></entry>
       </row>

       <row>
        <entry><type>regoperator</type></entry>
        <entry><structname>pg_operator</structname></entry>
        <entry>opérateur avec types d'arguments</entry>
        <entry><literal>*(integer,&zwsp;integer)</literal>
         ou <literal>-(NONE,&zwsp;integer)</literal></entry>
       </row>

       <row>
        <entry><type>regproc</type></entry>
        <entry><structname>pg_proc</structname></entry>
        <entry>nom de fonction</entry>
        <entry><literal>sum</literal></entry>
       </row>

       <row>
        <entry><type>regprocedure</type></entry>
        <entry><structname>pg_proc</structname></entry>
        <entry>fonction avec les types des arguments</entry>
        <entry><literal>sum(int4)</literal></entry>
       </row>

       <row>
        <entry><type>regrole</type></entry>
        <entry><structname>pg_authid</structname></entry>
        <entry>nom de rôle</entry>
        <entry><literal>smithee</literal></entry>
       </row>

       <row>
        <entry><type>regtype</type></entry>
        <entry><structname>pg_type</structname></entry>
        <entry>nom du type de données</entry>
        <entry><literal>integer</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Tous les types alias d'OID pour des objets groupés par schéma acceptent
    des noms qualifiés par le schéma,
    et affichent des noms préfixés par un schéma si l'objet ne peut être
    trouvé dans le chemin de recherche courant sans être qualifié.
    Les types alias <type>regproc</type> et <type>regoper</type> n'acceptent que des
    noms uniques en entrée (sans surcharge), si bien qu'ils sont d'un usage
    limité&nbsp;; dans la plupart des cas, <type>regprocedure</type> et
    <type>regoperator</type> sont plus appropriés. Pour <type>regoperator</type>,
    les opérateurs unaires sont identifiés en écrivant <literal>NONE</literal> pour
    les opérandes non utilisés.
   </para>

   <para>
    Une propriété supplémentaire de pratiquement tous les types alias d'OID est la création de
    dépendances. Si une
    constante d'un de ces types apparaît dans une expression stockée
    (telle que l'expression par défaut d'une colonne ou une vue), elle crée une
    dépendance sur l'objet référencé. Par exemple, si une colonne a une
    expression par défaut <literal>nextval('ma_seq'::regclass)</literal>,
    <productname>PostgreSQL</productname> comprend que l'expression par
    défaut dépend de la séquence <literal>ma_seq</literal>&nbsp;; le système ne
    permet alors pas la suppression de la séquence si l'expression par défaut
    n'est pas elle-même supprimée au préalable. <type>regrole</type> est la
    seule exception. Les constantes de ce type ne sont pas autorisées dans ce
    type d'expressions.
   </para>

   <note>
   <para>
    Les types d'alias d'OID ne suivent pas complètement les règles d'isolation
    des transactions. Le planificateur les traite aussi comme de simples constantes,
    ce qui pourrait résulter en une planification non optimale.
   </para>
   </note>

   <para>
    Un autre type d'identifiant utilisé par le système est <type>xid</type>, ou
    identifiant de transaction (abrégée <abbrev>xact</abbrev>).
    C'est le type de données des colonnes système <structfield>xmin</structfield> et
    <structfield>xmax</structfield>. Les identifiants de transactions sont
    stockés sur 32 bits.
    Dans certains contextes, une variante 64-bit <type>xid8</type> est utilisée.
    Contrairement aux valeurs <type>xid</type>, les valeurs <type>xid8</type>
    sont strictement à accroissement monotone et ne peuvent être réemployées sur
    la durée de vie d'une instance de base de données.
   </para>

   <para>
    Un troisième type d'identifiant utilisé par le système est <type>cid</type>,
    ou identifiant de commande. C'est le type de données des colonnes système
    <structfield>cmin</structfield> et <structfield>cmax</structfield>.
    Les identifiants de commandes sont aussi stockés sur 32 bits.
   </para>

   <para>
    Le dernier type d'identifiant utilisé par le système est <type>tid</type>,
    ou identifiant de ligne (tuple). C'est le type de données
    des colonnes système <structfield>ctid</structfield>. Un identifiant de tuple
    est une paire (numéro de bloc, index de tuple dans le bloc) qui identifie l'emplacement
    physique de la ligne dans sa table.
   </para>

   <para>
    Les colonnes système sont expliquées plus en détail dans la
    <xref linkend="ddl-system-columns"/>.
   </para>
  </sect1>

  <sect1 id="datatype-pg-lsn">
   <title>Type <acronym>pg_lsn</acronym></title>

   <indexterm zone="datatype-pg-lsn">
    <primary>pg_lsn</primary>
   </indexterm>

   <para>
    Le type de données <type>pg_lsn</type> peut être utilisé pour stocker des
    données LSN (Log Sequence Number ou Numéro de Séquence de Journal), qui
    sont un pointeur vers une position dans les journaux de transactions. Ce
    type est une représentation de <type>XLogRecPtr</type> et un type système
    interne de <productname>PostgreSQL</productname>.
   </para>

   <para>
    En interne, un LSN est un entier sur 64 bits, représentant une position
    d'octet dans le flux des journaux de transactions.  Il est affiché comme
    deux nombres hexadécimaux allant jusqu'à 8 caractères chacun, séparés par
    un slash. Par exemple, <literal>16/B374D848</literal>.  Le type
    <type>pg_lsn</type> gère les opérateurs de comparaison standard, comme
    <literal>=</literal> et <literal>&gt;</literal>.  Deux LSN peuvent être
    soustraits en utilisant l'opérateur <literal>-</literal>.  Le résultat est
    le nombre d'octets séparant ces deux emplacements dans les journaux de
    transactions.
   </para>
  </sect1>

  <sect1 id="datatype-pseudo">
   <title>Pseudo-Types</title>

   <indexterm zone="datatype-pseudo">
    <primary>record</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>any</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyelement</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyarray</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anynonarray</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyenum</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyrange</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anycompatible</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anycompatiblearray</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anycompatiblenonarray</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anycompatiblerange</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>void</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>trigger</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>event_trigger</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>pg_ddl_command</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>event_trigger</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>language_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>fdw_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>table_am_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>index_am_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>tsm_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>cstring</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>internal</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>unknown</primary>
   </indexterm>

   <para>
    Le système de types de <productname>PostgreSQL</productname>
    contient un certain nombre de types à usage spécial qui sont
    collectivement appelés des <firstterm>pseudo-types</firstterm>. Un
    pseudo-type ne peut être utilisé comme type d'une colonne de table, mais peut
    l'être pour déclarer un argument de fonction ou un type
    de résultat. Tous les pseudo-types disponibles sont utiles dans des
    situations où une fonction ne se contente pas d'accepter et retourner
    des valeurs d'un type de données <acronym>SQL</acronym> particulier. Le
    <xref linkend="datatype-pseudotypes-table"/> liste les différents pseudo-types.
   </para>

    <table id="datatype-pseudotypes-table">
     <title>Pseudo-Types</title>
     <tgroup cols="2">
      <colspec colnum="1" colwidth="1*"/>
      <colspec colnum="2" colwidth="2*"/>
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Description</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><type>any</type></entry>
        <entry>
         Indique qu'une fonction accepte tout type de données,
         quel qu'il soit.
        </entry>
       </row>

       <row>
        <entry><type>anyelement</type></entry>
        <entry>Indique qu'une fonction accepte tout type de données
        (voir la <xref linkend="extend-types-polymorphic"/>).</entry>
       </row>

       <row>
        <entry><type>anyarray</type></entry>
        <entry>
         Indique qu'une fonction accepte tout type de tableau (voir la
         <xref linkend="extend-types-polymorphic"/>).
        </entry>
       </row>

       <row>
        <entry><type>anynonarray</type></entry>
        <entry>Indique que la fonction accepte tout type de données non-array
         (voir <xref linkend="extend-types-polymorphic"/>).</entry>
       </row>

       <row>
        <entry><type>anyenum</type></entry>
        <entry>Indique que la fonction accepte tout type de données enum
        (voir <xref linkend="extend-types-polymorphic"/> et
        <xref linkend="datatype-enum"/>).</entry>
       </row>

       <row>
        <entry><type>anyrange</type></entry>
        <entry>Indique qu'une fonction accepte tout type de données intervalle
          (voir <xref linkend="extend-types-polymorphic"/> et
          <xref linkend="rangetypes"/>).</entry>
       </row>

       <row>
        <entry><type>anycompatible</type></entry>
        <entry>Indique qu'une fonction accepte tout type de données,
        avec une promotion automatique des arguments multiples vers un type de données commun
        (voir <xref linkend="extend-types-polymorphic"/>).</entry>
       </row>

       <row>
        <entry><type>anycompatiblearray</type></entry>
        <entry>Indique que la fonction accepte tout type de données tableau,
        avec une promotion automatique des arguments multiples vers un type de données commun
        (voir <xref linkend="extend-types-polymorphic"/>).</entry>
       </row>

       <row>
        <entry><type>anycompatiblenonarray</type></entry>
        <entry>Indique que la fonction accepte tout type de données autre que tableau,
        avec une promotion automatique des arguments multiples vers un type de données commun
        (voir <xref linkend="extend-types-polymorphic"/>).</entry>
       </row>

       <row>
        <entry><type>anycompatiblerange</type></entry>
        <entry>Indique qu'une fonction accepte tout type de données intervalle,
        avec une promotion automatique des arguments multiples vers un type de données commun
        (voir <xref linkend="extend-types-polymorphic"/> et
        <xref linkend="rangetypes"/>).</entry>
       </row>

       <row>
        <entry><type>cstring</type></entry>
        <entry>Indique qu'une fonction accepte ou retourne une chaîne de caractères
         C (terminée par un NULL).</entry>
       </row>

       <row>
        <entry><type>internal</type></entry>
        <entry>Indique qu'une fonction accepte ou retourne un type de données
         interne du serveur de bases de données.</entry>
       </row>

       <row>
        <entry><type>language_handler</type></entry>
        <entry>Une fonction d'appel de langage procédural est déclarée retourner
        un <type>language_handler</type>.</entry>
       </row>

       <row>
        <entry><type>fdw_handler</type></entry>
        <entry>Une fonction de gestion pour le wrapper de données distantes
        est déclarée retourner un <type>fdw_handler</type>.</entry>
       </row>

       <row>
        <entry><type>table_am_handler</type></entry>
        <entry>Un gestionnaire de méthode d'accès de table est déclaré comme retournant <type>table_am_handler</type>.</entry>
       </row>

       <row>
        <entry><type>index_am_handler</type></entry>
        <entry>Un gestionnaire pour une méthode d'accès d'index est déclaré
        renvoyer <type>index_am_handler</type>.</entry>
       </row>

       <row>
        <entry><type>tsm_handler</type></entry>
        <entry>Un gestionnaire de méthode d'échantillonnage est déclaré comme
         renvoyant le type <type>tsm_handler</type>.</entry>
       </row>

       <row>
        <entry><type>record</type></entry>
        <entry>Identifie une fonction qui prend ou retourne un type de ligne non spécifié.</entry>
       </row>

       <row>
        <entry><type>trigger</type></entry>
        <entry>Une fonction déclencheur est déclarée comme retournant un type
         <type>trigger</type>.</entry>
       </row>

       <row>
        <entry><type>event_trigger</type></entry>
        <entry>Une fonction pour un trigger d'événement est déclarée comme
         renvoyant une donnée de type <type>event_trigger</type>.</entry>
       </row>

       <row>
        <entry><type>pg_ddl_command</type></entry>
        <entry>Identifie une représention de commandes DDL qui est disponible
         pour les triggers d'événement.</entry>
       </row>

       <row>
        <entry><type>void</type></entry>
        <entry>Indique qu'une fonction ne retourne aucune valeur.</entry>
       </row>

       <row>
        <entry><type>unknown</type></entry>
        <entry>Identifie un type non encore résolu, par exemple une chaîne de
            texte non décorée.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Les fonctions codées en C (incluses ou chargées dynamiquement)
    peuvent être déclarées comme acceptant ou retournant tout pseudo-type. Il est de
    la responsabilité de l'auteur de la fonction de s'assurer du bon comportement
    de la fonction lorsqu'un pseudo-type est utilisé comme type d'argument.
   </para>

   <para>
    Les fonctions codées en langage procédural ne peuvent utiliser les
    pseudo-types que dans les limites imposées par l'implantation du langage.
    À ce jour, la plupart des langages procéduraux
    interdisent l'usage d'un pseudo-type comme argument et n'autorisent que
    <type>void</type> et <type>record</type> comme type de retour (plus
    <type>trigger</type> ou <type>event_trigger</type> lorsque la fonction est
    utilisée respectivement comme trigger ou triggers d'événement).
    Certains supportent également les fonctions polymorphes qui utilisent les
    pseudo-types polymorphes, qui sont décrits ci-dessus et discutés
    en détail dans <xref linkend="extend-types-polymorphic"/>.
   </para>

   <para>
    Le pseudo-type <type>internal</type> sert à déclarer des fonctions qui
    ne sont appelées que par le système en interne,
    et non pas directement par une requête <acronym>SQL</acronym>.
    Si une fonction accepte au minimum un argument de type <type>internal</type>,
    alors elle ne peut être appelée depuis <acronym>SQL</acronym>.
    Pour préserver la sécurité du type de cette restriction, il est important de
    suivre la règle de codage suivante&nbsp;: ne jamais créer de fonction qui retourne un
    <type>internal</type> si elle n'accepte pas au moins un argument de type
    <type>internal</type>.
   </para>

  </sect1>

 </chapter>
