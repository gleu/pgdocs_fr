<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="indexes">
 <title>Index</title>

 <indexterm zone="indexes">
  <primary>index</primary>
 </indexterm>

 <para>
  L'utilisation d'index est une façon habituelle d'améliorer les performances
  d'une base de données. Un index permet au serveur de bases de données de
  retrouver une ligne spécifique bien plus rapidement.
  Mais les index ajoutent aussi une surcharge au système de base de données
  dans son ensemble, si bien qu'ils doivent être utilisés avec discernement.
 </para>


 <sect1 id="index-intro">
  <title>Introduction</title>

  <para>
   Soit une table définie ainsi&nbsp;:
<programlisting>CREATE TABLE test1 (
    id integer,
    contenu varchar
);</programlisting>
   et une application qui utilise beaucoup de requêtes de la forme&nbsp;:
<programlisting>SELECT contenu FROM test1 WHERE id = <replaceable>constante</replaceable>;</programlisting>
   Sans préparation, le système doit lire la table
   <structname>test1</structname> dans son intégralité, ligne par ligne, pour trouver
   toutes les lignes qui correspondent. S'il y a beaucoup de lignes dans
   <structname>test1</structname>, et que seules quelques lignes 
   correspondent à la requête (peut-être même zéro ou une seule), alors,
   clairement, la méthode n'est pas efficace.
   Mais si le système doit maintenir un index sur la colonne
   <structfield>id</structfield>, alors il peut utiliser une manière
   beaucoup plus efficace pour trouver les lignes recherchées.
   Il se peut qu'il n'ait ainsi qu'à parcourir quelques niveaux d'un arbre de 
   recherche.
  </para>

  <para>
   Une approche similaire est utilisée dans la plupart des livres autres
   que ceux de fiction&nbsp;: les termes et concepts fréquemment
   recherchés par les lecteurs sont listés par ordre alphabétique à la
   fin du livre. Le lecteur qui recherche un mot particulier peut
   facilement parcourir l'index, puis aller directement à la page 
   (ou aux pages) indiquée(s). De la même façon que l'auteur doit anticiper
   les sujets que les lecteurs risquent de rechercher, il est de la
   responsabilité du programmeur de prévoir les index qui sont utiles.
  </para>

  <para>
   La commande suivante peut être utilisé pour créer un index sur la colonne
   <structfield>id</structfield>&nbsp;:
<programlisting>CREATE INDEX test1_id_index ON test1 (id);</programlisting>
   Le nom <structname>test1_id_index</structname> peut être choisi
   librement mais il est conseillé de choisir un nom qui rappelle le but
   de l'index.
  </para>

  <para>
   Pour supprimer l'index, on utilise la commande <command>DROP INDEX</command>.
   Les index peuvent être ajoutés et retirés des tables à tout moment.
  </para>

  <para>
   Une fois un index créé, aucune intervention supplémentaire n'est
   nécessaire&nbsp;:
   le système met à jour l'index lorsque la table est modifiée et utilise
   l'index dans les requêtes lorsqu'il pense que c'est plus efficace qu'une
   lecture complète de la table. Il faut néanmoins lancer la commande
   <command>ANALYZE</command> régulièrement pour permettre à l'optimiseur
   de requêtes de prendre les bonnes décisions.
   Voir le <xref linkend="performance-tips"/> pour comprendre quand et
   pourquoi l'optimiseur décide d'utiliser ou de ne
   <emphasis>pas</emphasis> utiliser un index.
  </para>

  <para>
   Les index peuvent aussi bénéficier aux commandes
   <command>UPDATE</command> et <command>DELETE</command> à
   conditions de recherche. De plus, les index peuvent être utilisés dans les
   jointures. Ainsi, un index défini sur une colonne qui fait partie d'une
   condition de jointure peut aussi accélérer significativement les requêtes avec
   jointures.
  </para>

  <para>
   Créer un index sur une grosse table peut prendre beaucoup de temps. Par
   défaut, <productname>PostgreSQL</productname> autorise la lecture
   (<command>SELECT</command>)
   sur la table pendant la création d'un index sur celle-ci, mais interdit les
   écritures (<command>INSERT</command>, <command>UPDATE</command>,
   <command>DELETE</command>). Elles sont bloquées jusqu'à la fin de la
   construction de l'index. Dans des environnements de production, c'est
   souvent inacceptable. Il est possible d'autoriser les écritures en
   parallèle de la création d'un index, mais quelques précautions sont à
   prendre. Pour plus d'informations, voir <xref
   linkend="sql-createindex-concurrently"
  />.
  </para>

  <para>
   Après la création d'un index, le système doit le maintenir synchronisé avec
   la table. Cela rend plus lourdes les opérations de manipulation de 
   données. C'est pourquoi les index qui sont peu, voire jamais, utilisés
   doivent être supprimés.
  </para>
 </sect1>


 <sect1 id="indexes-types">
  <title>Types d'index</title>

  <para>
   <productname>PostgreSQL</productname> propose plusieurs types d'index&nbsp;:
   B-tree, Hash, GiST, SP-GiST et GIN. Chaque type d'index utilise un algorithme
   différent qui convient à un type particulier de requêtes. Par défaut, la
   commande <command>CREATE INDEX</command> crée un index B-tree, ce qui
   convient dans la plupart des situations.
   <indexterm>
    <primary>index</primary>
    <secondary>B-tree</secondary>
   </indexterm>
   <indexterm>
    <primary>B-tree</primary>
    <see>index</see>
   </indexterm>
   Les index B-tree savent traiter les requêtes d'égalité et par
   tranches sur des données qu'il est possible de trier. En particulier,
   l'optimiseur de requêtes de <productname>PostgreSQL</productname>
   considère l'utilisation d'un index B-tree lorsqu'une colonne indexée est
   utilisée dans une comparaison qui utilise un de ces opérateurs&nbsp;:

   <simplelist>
    <member><literal>&lt;</literal></member>
    <member><literal>&lt;=</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&gt;=</literal></member>
    <member><literal>&gt;</literal></member>
   </simplelist>

   Les constructions équivalentes à des combinaisons de ces opérateurs, comme
   <literal>BETWEEN</literal> et <literal>IN</literal>, peuvent aussi être
   implantées avec une recherche par index B-tree. Une condition
   <literal>IS NULL</literal> ou <literal>IS NOT NULL</literal> sur une colonne
   indexée peut aussi être utilisé avec un index B-tree.
  </para>

  <para>
   L'optimiseur peut aussi utiliser un index B-tree pour des requêtes
   qui utilisent les opérateurs de recherche de motif <literal>LIKE</literal>
   et <literal>~</literal> <emphasis>si</emphasis> le motif est une constante et
   se trouve au début de la chaîne à rechercher &mdash; par exemple,
   <literal>col LIKE 'foo%'</literal> ou <literal>col ~ '^foo'</literal>, mais
   pas <literal>col LIKE '%bar'</literal>. Toutefois, si la base de données
   n'utilise pas la locale C, il est nécessaire de créer l'index avec
   une classe d'opérateur spéciale pour supporter l'indexation à correspondance
   de modèles. Voir la <xref linkend="indexes-opclass"/> ci-dessous. Il est
   aussi possible d'utiliser des index B-tree pour <literal>ILIKE</literal> et
   <literal>~*</literal>, mais seulement si le modèle débute par des caractères
   non alphabétiques, c'est-à-dire des caractères non affectés par les
   conversions majuscules/minuscules.
  </para>

  <para>
   Les index B-tree peuvent aussi être utilisés pour récupérer des données
   triées. Ce n'est pas toujours aussi rapide qu'un simple parcours séquentiel
   suivi d'un tri mais c'est souvent utile.
  </para>
 
  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>hash</secondary>
   </indexterm>
   <indexterm>
    <primary>hash</primary>
    <see>index</see>
   </indexterm>
   Les index hash ne peuvent gérer que des comparaisons d'égalité simple.
   Le planificateur de requêtes considère l'utilisation d'un index hash quand
   une colonne indexée est impliquée dans une comparaison avec l'opérateur
   <literal>=</literal>. La commande suivante est utilisée pour
   créer un index hash&nbsp;:
<synopsis>CREATE INDEX <replaceable>nom</replaceable> ON <replaceable>table</replaceable> USING hash (<replaceable>column</replaceable>);
</synopsis>
  </para>

  <caution>
   <para>
    Les opérations sur les index de hachage ne sont pas tracées par les journaux
    de transactions. Il est donc généralement nécessaire de les reconstruire
    avec <command>REINDEX</command> après un crash de la base. Ils ne sont pas
    non plus répliqués, que ce soit dans la réplication en flux ou par journaux
    de transactions. Pour ces raisons, l'utilisation des index de hachage est
    déconseillée.
   </para>
  </caution>  

  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>GiST</secondary>
   </indexterm>
   <indexterm>
    <primary>GiST</primary>
    <see>index</see>
   </indexterm>
   Les index GiST ne constituent pas un unique type d'index, mais plutôt une infrastructure
   à l'intérieur de laquelle plusieurs stratégies d'indexage peuvent être implantées.
   De cette façon, les opérateurs particuliers avec lesquels un index GiST peut
   être utilisé varient en fonction de la stratégie d'indexage (la <firstterm>classe
   d'opérateur</firstterm>). Par exemple, la distribution standard de
   <productname>PostgreSQL</productname> inclut des classes d'opérateur GiST
   pour plusieurs types de données géométriques à deux dimensions, qui supportent
   des requêtes indexées utilisant ces opérateurs&nbsp;:

   <simplelist>
    <member><literal>&lt;&lt;</literal></member>
    <member><literal>&amp;&lt;</literal></member>
    <member><literal>&amp;&gt;</literal></member>
    <member><literal>&gt;&gt;</literal></member>
    <member><literal>&lt;&lt;|</literal></member>
    <member><literal>&amp;&lt;|</literal></member>
    <member><literal>|&amp;&gt;</literal></member>
    <member><literal>|&gt;&gt;</literal></member>
    <member><literal>@&gt;</literal></member>
    <member><literal>&lt;@</literal></member>
    <member><literal>~=</literal></member>
    <member><literal>&amp;&amp;</literal></member>
   </simplelist>

   Voir la <xref linkend="functions-geometry"/> pour connaître la
   signification de ces opérateurs.
   De plus, une condition <literal>IS NULL</literal> sur une colonne d'index
   peut être utilisée avec un index GiST.
   Beaucoup de classes d'opérateur GiST sont disponibles dans l'ensemble
   des <literal>contrib</literal> ou comme projet séparé. Pour plus
   d'informations, voir <xref linkend="gist"/>.
  </para>

  <para>
   Les index GiST sont aussi capables d'optimiser des recherches du type
   <quote>voisin-le-plus-proche</quote>
   (<foreignphrase>nearest-neighbor</foreignphrase>), comme par exemple&nbsp;:
<programlisting><![CDATA[
SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;
]]>
</programlisting>
   qui trouve les dix places les plus proches d'une cible donnée. Cette
   fonctionnalité dépend de nouveau de la classe d'opérateur utilisée.
  </para>

  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>SP-GiST</secondary>
   </indexterm>
   <indexterm>
    <primary>SP-GiST</primary>
    <see>index</see>
   </indexterm>
   Les index SP-GiST, tout comme les index GiST, offrent une infrastructure
   qui supporte différents types de recherches. SP-GiST permet l'implémentation
   d'une grande étendue de structures de données non balancées, stockées sur
   disque comme les <foreignphrase>quadtrees</foreignphrase>, les arbres k-d, et
   les arbres suffixes. <productname>PostgreSQL</productname> inclut les classes
   d'opérateur SP-GiST pour les points à deux dimensions, qui supportent les
   requêtes indexées en utilisant les opérateurs suivants&nbsp;:

   <simplelist>
    <member><literal>&lt;&lt;</literal></member>
    <member><literal>&gt;&gt;</literal></member>
    <member><literal>~=</literal></member>
    <member><literal>&lt;@</literal></member>
    <member><literal>&lt;^</literal></member>
    <member><literal>&gt;^</literal></member>
   </simplelist>

   (Voir <xref linkend="functions-geometry"/> pour la signification de ces
   opérateurs.)
   Pour plus d'informations, voir <xref linkend="SPGiST"/>.
  </para>

  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>GIN</secondary>
   </indexterm>
   <indexterm>
    <primary>GIN</primary>
    <see>index</see>
   </indexterm>
   Les index GIN sont des index inversés qui peuvent gérer des valeurs contenant
   plusieurs clés, les tableaux par exemple. Comme GiST et SP-GiST, GIN supporte
   différentes stratégies d'indexation utilisateur. Les
   opérateurs particuliers avec lesquels un index GIN peut être utilisé varient
   selon la stratégie d'indexation. Par exemple, la distribution standard de
   <productname>PostgreSQL</productname> inclut des classes d'opérateurs GIN pour
   des tableaux à une dimension qui supportent les requêtes indexées utilisant
   ces opérateurs&nbsp;:

   <simplelist>
    <member><literal>&lt;@</literal></member>
    <member><literal>@&gt;</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&amp;&amp;</literal></member>
   </simplelist>

   Voir <xref linkend="functions-array"/> pour la signification de ces
   opérateurs.
   Beaucoup d'autres classes d'opérateurs GIN sont disponibles dans les modules
   <literal>contrib</literal> ou dans des projets séparés. Pour plus d'informations,
   voir <xref linkend="gin"/>.
  </para>

 </sect1>


 <sect1 id="indexes-multicolumn">
  <title>Index multicolonnes</title>

  <indexterm zone="indexes-multicolumn">
   <primary>index</primary>
   <secondary>multi colonne</secondary>
  </indexterm>

  <para>
   Un index peut porter sur plusieurs colonnes d'une table. Soit, par exemple, 
   une table de la forme&nbsp;:
<programlisting>CREATE TABLE test2 (
  majeur int,
  mineur int,
  nom varchar
);</programlisting>
   (cas d'un utilisateur gardant son répertoire
   <filename class="directory">/dev</filename> dans une base de données...)
   et que des requêtes comme&nbsp;:
<programlisting>SELECT nom FROM test2 WHERE majeur = <replaceable>constante</replaceable> AND mineur = <replaceable>constante</replaceable>;</programlisting>
   sont fréquemment exécutées. Il peut alors être souhaitable de définir un
   index qui porte sur les deux colonnes
   <structfield>majeur</structfield> et
   <structfield>mineur</structfield>. Ainsi, par exemple&nbsp;:
<programlisting>CREATE INDEX test2_mm_idx ON test2 (majeur, mineur);</programlisting>
  </para>

  <para>
   Actuellement, seuls les types d'index B-trees, GiST et GIN supportent les
   index multicolonnes. 32 colonnes peuvent être précisées, au maximum.
   Cette limite peut être modifiée à la compilation de
   <productname>PostgreSQL</productname>. Voir le fichier 
   <filename>pg_config_manual.h</filename>.
  </para>

  <para>
   Un index B-tree multicolonne peut être utilisé avec des conditions de
   requêtes impliquant un sous-ensemble quelconque de colonnes de l'index.
   L'index est toutefois plus efficace lorsqu'il y a des contraintes sur les
   premières colonnes (celles de gauche).
   La règle exacte est la suivante&nbsp;: les
   contraintes d'égalité sur les premières colonnes, et toute contrainte
   d'inégalité sur la première colonne qui ne possède pas de contrainte d'égalité
   sont utilisées pour limiter la partie parcourue de l'index. Les contraintes
   sur les colonnes à droite de ces colonnes sont vérifiées dans l'index, et
   limitent ainsi les visites de la table, mais elles ne réduisent pas la partie
   de l'index à parcourir.
  </para>
  
  <para>
   Par exemple, avec un index sur
   <literal>(a, b, c)</literal> et une condition de requête <literal>WHERE a =
   5 AND b &gt;= 42 AND c &lt; 77</literal>, l'index est parcouru à partir de
   la première entrée pour laquelle <literal>a</literal> = 5 et <literal>b</literal> = 42 jusqu'à la
   dernière entrée pour laquelle <literal>a</literal> = 5. Les entrées de l'index avec
   <literal>c</literal> &gt;= 77 sont sautées, mais elles sont toujours
   parcourues. En principe, cet index peutt être utilisé pour les requêtes
   qui ont des contraintes sur <literal>b</literal> et/ou <literal>c</literal> sans contrainte
   sur <literal>a</literal> &mdash; mais l'index entier doit être parcouru, donc, dans
   la plupart des cas, le planificateur préfère un parcours séquentiel de la
   table à l'utilisation de l'index.
  </para>

  <para>
   Un index GiST multicolonne peut être utilisé avec des conditions de
   requête qui impliquent un sous-ensemble quelconque de colonnes de l'index. Les
   conditions sur des colonnes supplémentaires restreignent les entrées renvoyées
   par l'index, mais la condition sur la première colonne est la plus importante
   pour déterminer la part de l'index parcourue. Un index GiST est
   relativement inefficace si sa première colonne n'a que quelques valeurs
   distinctes, même s'il y a beaucoup de valeurs distinctes dans les colonnes
   supplémentaires.
  </para>

  <para>
   Un index multi-colonnes GIN peut être utilisé avec des conditions de requête
   qui implique tout sous-ensemble des colonnes de l'index. Contrairement à
   B-tree ou GiST, la qualité de la recherche dans l'index est identique quelque
   soit les colonnes de l'index que la requête utilise
  </para>

  <para>
   Chaque colonne doit évidemment être utilisée avec des opérateurs appropriés
   au type de l'index&nbsp;; les clauses qui impliquent d'autres opérateurs ne
   sont pas pris en compte.
  </para>

  <para>
   Il est préférable d'utiliser les index multicolonnes avec parcimonie. Dans la
   plupart des cas, un index sur une seule colonne est suffisant et préserve
   espace et temps. Les index de plus de trois colonnes risquent fort
   d'être inefficaces, sauf si l'utilisation de cette table est extrêmement
   stylisée. Voir aussi la <xref linkend="indexes-bitmap-scans"/> pour les
   discussions sur les mérites des différentes configurations d'index.
  </para>
 </sect1>


 <sect1 id="indexes-ordering">
  <title>Index et <literal>ORDER BY</literal></title>

  <indexterm zone="indexes-ordering">
   <primary>index</primary>
   <secondary>et <literal>ORDER BY</literal></secondary>
  </indexterm>

  <para>
   Au delà du simple fait de trouver les lignes à renvoyer à une requête, un index
   peut les renvoyer dans un ordre spécifique. Cela permet de résoudre une
   clause <literal>ORDER BY</literal> sans
   étape de tri séparée. De tous les types d'index actuellement supportés par
   <productname>PostgreSQL</productname>, seuls les B-tree peuvent produire une
   sortie triée &mdash; les autres types d'index renvoient les lignes
   correspondantes dans un ordre imprécis, dépendant de l'implantation.
  </para>

  <para>
   Le planificateur répond à une clause <literal>ORDER BY</literal>
   soit en parcourant un index disponible qui correspond à la
   clause, soit en parcourant la table dans l'ordre physique et en réalisant
   un tri explicite. Pour une requête qui nécessite de parcourir une fraction
   importante de la table, le tri explicite est probablement plus rapide que
   le parcours d'un index car il nécessite moins d'entrées/sorties disque, du
   fait de son accès séquentiel. Les index sont plus utiles lorsqu'il s'agit
   de ne récupérer que
   quelques lignes être récupérées. <literal>ORDER BY</literal>
   combiné à <literal>LIMIT</literal> <replaceable>n</replaceable> est un cas
   spécial très important&nbsp;:
   un tri explicite doit traiter toutes les données pour identifier les
   <replaceable>n</replaceable> première lignes, mais s'il y a un index
   qui correspond à l'<literal>ORDER BY</literal>, alors les
   <replaceable>n</replaceable> premières lignes peuvent être récupérées directement
   sans qu'il soit nécessaires de parcourir les autres.
  </para>

  <para>
   Par défaut, les index B-tree stockent leurs entrées dans l'ordre ascendant,
   valeurs NULL en dernier. Cela signifie que le parcours avant
   d'un index sur une colonne <literal>x</literal> produit une sortie
   satisfaisant <literal>ORDER BY x</literal> (ou en plus verbeux
   <literal>ORDER BY x ASC NULLS LAST</literal>). L'index peut aussi être
   parcouru en arrière, produisant ainsi une sortie satisfaisant un
   <literal>ORDER BY x DESC</literal> (ou en plus verbeux
   <literal>ORDER BY x DESC NULLS FIRST</literal> car
   <literal>NULLS FIRST</literal> est la valeur par défaut pour un
   <literal>ORDER BY DESC</literal>).
  </para>

  <para>
   L'ordre d'un index B-tree peut être défini à la création par l'inclusion des options
   <literal>ASC</literal>, <literal>DESC</literal>, <literal>NULLS FIRST</literal>,
   et/ou <literal>NULLS LAST</literal> lors de la création de l'index&nbsp;; par
   exemple&nbsp;:
<programlisting>
CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);
CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);
</programlisting>
   Un index stocké en ordre ascendant avec les valeurs NULL en premier peut
   satisfaire soit <literal>ORDER BY x ASC NULLS FIRST</literal> soit
   <literal>ORDER BY x DESC NULLS LAST</literal> selon la direction du
   parcours.
  </para>

  <para>
   On peut s'interroger sur l'intérêt de proposer quatre options, alors que
   deux options associées à la possibilité d'un parcours inverse semblent
   suffire à couvrir toutes les
   variantes d'<literal>ORDER BY</literal>. Dans les index mono-colonne,
   les options sont en effet redondantes, mais pour un index à plusieurs colonnes,
   elles sont utiles. Si l'on considère un index à deux colonnes
   <literal>(x, y)</literal>, il peut satisfaire une clause <literal>ORDER
   BY x, y</literal> sur un parcours avant, ou
   <literal>ORDER BY x DESC, y DESC</literal> sur un parcours inverse.
   Mais il se peut que l'application utilise fréquemment
   <literal>ORDER BY x ASC, y DESC</literal>. Il n'y a pas moyen d'obtenir cet
   ordre à partir d'un index plus simple, mais c'est possible si l'index est défini
   comme <literal>(x ASC, y DESC)</literal> or <literal>(x DESC, y
   ASC)</literal>.
  </para>

  <para>
   Les index d'ordre différent de celui par défaut sont visiblement une
   fonctionnalité très spécialisée, mais ils peuvent parfois être à l'origine
   d'accélérations spectaculaires des performances sur certaines requêtes.
   L'intérêt de maintenir un tel index dépend
   de la fréquence des requêtes qui nécessitent un tri particulier.
  </para>
 </sect1>


 <sect1 id="indexes-bitmap-scans">
  <title>Combiner des index multiples</title>

  <indexterm zone="indexes-bitmap-scans">
   <primary>index</primary>
   <secondary>combiner des index multiples</secondary>
  </indexterm>

  <indexterm zone="indexes-bitmap-scans">
   <primary>parcours de bitmap</primary>
  </indexterm>

  <para>
   Un parcours unique d'index ne peut utiliser que les clauses de la requête qui utilisent
   les colonnes de l'index avec les opérateurs de sa classe d'opérateur et qui
   sont jointes avec <literal>AND</literal>. Par exemple, étant donné un index sur
   <literal>(a, b)</literal>, une condition de requête <literal>WHERE a = 5
   AND b = 6</literal> peut utiliser l'index, mais une requête
   <literal>WHERE a = 5 OR b = 6</literal> ne peutt pas l'utiliser directement.
  </para>

  <para>
   Heureusement, <productname>PostgreSQL</productname> peut combiner
   plusieurs index (y compris plusieurs utilisations du même index) pour gérer
   les cas qui ne peuvent pas être résolus par des parcours d'index
   simples. Le système peut former des conditions <literal>AND</literal>
   et <literal>OR</literal> sur plusieurs parcours d'index. Par exemple,
   une requête comme <literal>WHERE x = 42 OR x = 47 OR x = 53 OR x = 99</literal>
   peut être divisée en quatre parcours distincts d'un index sur
   <literal>x</literal>, chaque parcours utilisant une des clauses de la requête. Les
   résultats de ces parcours sont alors assemblés par OR pour produire le
   résultat. Autre exemple, s'il existe des index séparés sur
   <literal>x</literal> et <literal>y</literal>, une résolution possible d'une requête
   comme <literal>WHERE x = 5 AND y = 6</literal> consiste à utiliser chaque index avec la
   clause de la requête appropriée et d'assembler les différents résultats
   avec un AND pour identifier les lignes résultantes.
  </para>

  <para>
   Pour combiner plusieurs index, le système parcourt chaque index nécessaire
   et prépare un <firstterm>bitmap</firstterm> en mémoire qui donne l'emplacement des
   lignes de table qui correspondent aux conditions de
   l'index. Les bitmaps sont ensuite assemblés avec des opérateurs AND ou OR
   selon les besoins de la requête. Enfin, les lignes réelles de la table
   sont visitées et renvoyées. Elles sont visitées dans l'ordre physique parce
   c'est ainsi que le bitmap est créé&nbsp;; cela signifie que l'ordre
   des index originaux est perdu et que, du coup, une étape de tri séparée est
   nécessaire si la requête comprend une clause <literal>ORDER BY</literal>. Pour
   cette raison, et parce que chaque parcours d'index supplémentaire ajoute
   un temps additionnel, le planificateur choisit quelque fois d'utiliser un
   parcours d'index simple même si des index supplémentaires sont disponibles
   et peuvent être utilisés.
  </para>

  <para>
   Le nombre de combinaisons d'index possibles croît parallèlement à la
   complexité des applications. Il est alors de la responsabilité du
   développeur de la base de décider des index à fournir. Il est quelques fois
   préférable de créer des index multi-colonnes, mais il est parfois préférable
   de créer des index séparés et de s'appuyer sur la fonctionnalité de
   combinaison des index.
  </para>
  <para>
   Par exemple, si la charge inclut un mélange de requêtes qui impliquent
   parfois uniquement la colonne <literal>x</literal>, parfois uniquement
   la colonne <literal>y</literal> et quelques
   fois les deux colonnes, on peut choisir deux index séparés sur
   <literal>x</literal> et <literal>y</literal> et s'appuyer sur la combinaison d'index
   pour traiter les requêtes qui utilisent les deux colonnes. On peut aussi
   créer un index multi-colonnes sur <literal>(x, y)</literal>. Cet index est
   typiquement plus efficace que la combinaison d'index pour les requêtes
   impliquant les deux colonnes mais, comme discuté dans la <xref
   linkend="indexes-multicolumn"/>, il est pratiquement inutile pour les
   requêtes n'impliquant que <literal>y</literal>. Il ne peut donc pas être le
   seul index. Une combinaison de l'index multi-colonnes et d'un index séparé
   sur <literal>y</literal> est une solution raisonnable. Pour les requêtes qui
   n'impliquent que <literal>x</literal>, l'index multi-colonnes peut être
   utilisé, bien qu'il soit plus large et donc plus lent qu'un index sur <literal>x</literal> seul.
   La dernière alternative consiste à créer les trois index, mais cette
   solution n'est raisonnable que si la table est lue bien plus
   fréquemment qu'elle n'est mise à jour et que les trois types de requête sont
   communs. Si un des types de requête est bien moins courant que les autres,
   il est préférable de ne créer que les deux index qui
   correspondent le mieux aux types communs.
  </para>

 </sect1>


 <sect1 id="indexes-unique">
  <title>Index d'unicité</title>

  <indexterm zone="indexes-unique">
   <primary>index</primary>
   <secondary>unique</secondary>
  </indexterm>

  <para>
   Les index peuvent aussi être utilisés pour garantir l'unicité des
   valeurs d'une colonne, ou l'unicité des valeurs combinées de plusieurs 
   colonnes.
<synopsis>CREATE UNIQUE INDEX <replaceable>nom</replaceable> ON <replaceable>table</replaceable> (<replaceable>colonne</replaceable> <optional>, ...</optional>);</synopsis>
   À ce jour, seuls les index B-trees peuvent être déclarés uniques.
  </para>

  <para>
   Lorsqu'un index est déclaré unique, il ne peut exister plusieurs lignes
   d'une table qui possèdent la même valeur indexée. Les valeurs NULL ne sont pas
   considérées égales. Un index d'unicité multi-colonnes ne rejette que les
   cas où toutes les colonnes indexées sont égales dans plusieurs lignes.
  </para>

  <para>
   <productname>PostgreSQL</productname> crée automatiquement un index
   d'unicité à la déclaration d'une contrainte d'unicité ou d'une clé primaire
   sur une table. L'index porte sur les colonnes qui composent la clé primaire
   ou la contrainte d'unicité (au besoin, il s'agit d'un index multi-colonnes).
   C'est cet index qui assure le mécanisme de vérification de la contrainte.
  </para>

  <note>
   <para>
    La méthode la plus appropriée pour ajouter une contrainte à une table
    est <literal>ALTER TABLE ... ADD CONSTRAINT</literal>. L'utilisation des
    index pour vérifier les contraintes d'unicité peut être considérée comme
    un détail d'implantation qui ne doit pas être utilisé directement.
    Il n'est pas nécessaire de créer manuellement
    un index sur les colonnes uniques. Cela duplique l'index créé
    automatiquement.
   </para>
  </note>
 </sect1>


 <sect1 id="indexes-expressional">
  <title>Index d'expressions</title>

  <indexterm zone="indexes-expressional">
   <primary>index</primary>
   <secondary sortas="expressions">sur expressions</secondary>
  </indexterm>

  <para>
   Une colonne d'index ne correspond pas nécessairement exactement à une 
   colonne de la table associée, mais peut être une fonction ou une expression
   scalaire calculée à partir d'une ou plusieurs colonnes de la table.
   Cette fonctionnalité est utile pour obtenir un accès rapide aux tables
   en utilisant les résultat de calculs.
  </para>

  <para>
   Par exemple, une façon classique de faire des comparaisons indépendantes
   de la casse est d'utiliser la fonction <function>lower</function>&nbsp;:
<programlisting>SELECT * FROM test1 WHERE lower(col1) = 'valeur';</programlisting>
   Si un index a été défini sur le résultat de <literal>lower(col1)</literal>,
   cette requête peut l'utiliser.
   Un tel index est créé avec la commande&nbsp;:
<programlisting>CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));</programlisting>
  </para>

  <para>
   Si l'index est déclaré <literal>UNIQUE</literal>, il empêche
   la création de lignes dont les valeurs de la colonne <literal>col1</literal> ne
   diffèrent que par la casse, ainsi que celle de lignes dont les valeurs de la
   colonne <literal>col1</literal> sont identiques.
   Ainsi, les index d'expressions peuvent être utilisés pour
   appliquer des contraintes qui ne peuvent être définies avec une simple
   contrainte d'unicité.
  </para>

  <para>
   Autre exemple. Lorsque des requêtes comme &nbsp;:
<programlisting>SELECT * FROM personnes WHERE (prenom || ' ' || nom) = 'Jean Dupont';</programlisting>
   sont fréquentes, alors il peut être utile de créer un index comme&nbsp;:
<programlisting>CREATE INDEX personnes_noms ON personnes ((prenom || ' ' || nom));</programlisting>
  </para>

  <para>
   La syntaxe de la commande <command>CREATE INDEX</command> nécessite normalement
   de mettre des parenthèses autour de l'expression indexée, comme dans
   l'exemple précédent. Les parenthèses peuvent être omises quand l'expression
   est un simple appel de fonction, comme dans le premier exemple.
  </para>

  <para>
   Les expressions d'index sont relativement coûteuses à calculer car
   l'expression doit être recalculée à chaque insertion ou mise à jour de
   ligne. Néanmoins, les expressions d'index ne sont
   <emphasis>pas</emphasis> recalculées lors d'une recherche par index car elles sont
   déjà stockés dans l'index. Dans les deux exemples ci-dessus, le système
   voit la requête comme un <literal>WHERE colonne_indexée =
   'constante'</literal>. De ce fait, la recherche est aussi rapide que toute
   autre requête d'index. Ainsi, les index d'expressions sont utiles
   lorsque la rapidité de recherche est plus importante que la rapidité 
   d'insertion et de mise à jour.
  </para>
 </sect1>


 <sect1 id="indexes-partial">
  <title>Index partiels</title>

  <indexterm zone="indexes-partial">
   <primary>index</primary>
   <secondary>partiel</secondary>
  </indexterm>

  <para>
   Un <firstterm>index partiel</firstterm> est un index construit sur un
   sous-ensemble d'une table&nbsp;; le sous-ensemble est défini par une expression
   conditionnelle (appelée <firstterm>prédicat</firstterm> de l'index
   partiel). L'index ne contient des entrées que pour les lignes de la
   table qui satisfont au prédicat. Les index partiels sont une fonctionnalité
   spécialisée, mais ils trouvent leur utilité dans de nombreuses situations.
  </para>

  <para>
   Une raison majeure à l'utilisation d'index partiels est d'éviter
   d'indexer les valeurs courantes. Puisqu'une requête qui recherche une
   valeur courante (qui correspond à plus de quelques pourcents de toutes
   les lignes) n'utilise, de toute façon, pas cet index, il ne sert à rien
   de garder ces lignes dans l'index. Cela réduit la taille de l'index,
   ce qui accélèrera les requêtes qui l'utilisent. Cela accélère aussi nombre
   d'opérations de mise à jour de la table, car l'index n'a pas à être
   mis à jour à chaque fois. L'<xref linkend="indexes-partial-ex1"/> montre une
   application possible de cette idée.
  </para>

  <example id="indexes-partial-ex1">
   <title>Mettre en place un index partiel pour exclure des valeurs courantes</title>

   <para>
    Soit l'enregistrement d'un journal d'accès à un serveur web dans une base de données.
    La plupart des accès proviennent de classes d'adresses IP internes à 
    l'organisation, mais certaines proviennent de l'extérieur (des employés connectés
    par modem, par exemple).
    Si les recherches par adresses IP concernent essentiellement les accès
    extérieurs, il est inutile d'indexer les classes
    d'adresses IP qui correspondent au sous-réseau de l'organisation.

   </para>

   <para>
    Si la table ressemble à&nbsp;:
<programlisting>CREATE TABLE access_log (
    url varchar,
    client_ip inet,
    ...
);</programlisting>
   </para>

   <para>
    Pour créer un index partiel qui corresponde à l'exemple, il faut utiliser 
    une commande comme celle-ci&nbsp;:
<programlisting>CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)
    WHERE NOT (client_ip &gt; inet '192.168.100.0' AND
               client_ip &lt; inet '192.168.100.255');</programlisting>
   </para>

   <para>
    Une requête typique qui peut utiliser cet index est&nbsp;:
<programlisting>SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '212.78.10.32';</programlisting>
    Une requête qui ne peut pas l'utiliser est&nbsp;:
<programlisting>SELECT *
FROM access_log
WHERE client_ip = inet '192.168.100.23';</programlisting>
   </para>

   <para>
    Ce type d'index partiel nécessite que les valeurs courantes
    soient prédéterminées, de façon à ce que ce type d'index soit mieux utilisé
    avec une distribution des données qui ne change pas. Les index peuvent être
    recréés occasionnellement pour s'adapter aux nouvelles distributions de
    données, mais cela ajoute de la maintenance.
   </para>
  </example>

  <para>
   Une autre utilisation possible d'index partiel revient à exclure des
   valeurs de l'index qui ne correspondent pas aux requêtes courantes&nbsp;;
   ceci est montré dans l'<xref linkend="indexes-partial-ex2"/>. Cette méthode
   donne les mêmes avantages que la précédente mais empêche l'accès par l'index aux valeurs
   <quote>sans intérêt</quote>. Évidemment, mettre en place des index partiels
   pour ce genre de scénarios nécessite beaucoup de soin et d'expérimentation.
  </para>

  <example id="indexes-partial-ex2">
   <title>Mettre en place un index partiel pour exclure les valeurs inintéressantes</title>

   <para>
    Soit une table qui contient des commandes facturées et des
    commandes non facturées, avec les commandes non facturées qui ne prennent
    qu'une petite fraction de l'espace dans la table, et qu'elles sont les
    plus accédées. Il est possible d'améliorer les 
    performances en créant un index limité aux lignes non facturées.
    La commande pour créer l'index ressemble à&nbsp;:
<programlisting>CREATE INDEX index_commandes_nonfacturees ON commandes (no_commande)
    WHERE facturee is not true;</programlisting>
   </para>

   <para>
    La requête suivante utilise cet index&nbsp;:
<programlisting>SELECT * FROM commandes WHERE facturee is not true AND no_commande &lt; 10000;</programlisting>
    Néanmoins, l'index peut aussi être utilisé dans des requêtes qui
    n'utilisent pas <structfield>no_commande</structfield>, comme&nbsp;:
<programlisting>SELECT * FROM commandes WHERE facturee is not true AND montant &gt; 5000.00;</programlisting>
    Ceci n'est pas aussi efficace qu'un index partiel sur la colonne
    <structfield>montant</structfield>, car le système doit lire l'index en entier.
    Néanmoins, s'il y a assez peu de commandes non facturées, l'utilisation
    de cet index partiel pour trouver les commandes non facturées peut être
    plus efficace.
   </para>

   <para>
    La requête suivante ne peut pas utiliser cet index&nbsp;:
<programlisting>SELECT * FROM commandes WHERE no_commande = 3501;</programlisting>
    La commande 3501 peut faire partie des commandes facturées ou
    non facturées.
   </para>
  </example>

  <para>
   L'<xref linkend="indexes-partial-ex2"/> illustre aussi le fait que la colonne
   indexée et la colonne utilisée dans le prédicat ne sont pas nécessairement
   les mêmes. <productname>PostgreSQL</productname> supporte tous les
   prédicats sur les index partiels, tant que ceux-ci ne portent que sur des
   champs de la table indexée. Néanmoins, il faut se rappeler que le prédicat doit
   correspondre aux conditions utilisées dans les requêtes qui sont supposées
   profiter de l'index. Pour être précis, un index partiel ne peut être utilisé
   pour une requête que si le système peut reconnaître que la clause 
   <literal>WHERE</literal> de la requête implique mathématiquement le prédicat de
   l'index.
   <productname>PostgreSQL</productname> n'a pas de méthode sophistiquée de
   démonstration de théorème pour reconnaître que des expressions apparemment
   différentes sont mathématiquement équivalentes. (Non seulement une telle
   méthode générale de démonstration serait extrêmement complexe à créer
   mais, en plus, elle serait probablement trop lente pour être d'une quelconque
   utilité).
   Le système peut reconnaître des implications d'inégalités simples, par
   exemple <quote>x &lt; 1</quote> implique <quote>x &lt; 2</quote>&nbsp;;
   dans les autres cas, 
   la condition du prédicat doit correspondre exactement à une partie de la
   clause <literal>WHERE</literal> de la requête, sans quoi l'index ne peut pas
   être considéré utilisable. La correspondance prend place lors de l'exécution
   de la planification de la requête, pas lors de l'exécution. À ce titre, les
   clauses de requêtes à paramètres ne fonctionnent pas avec un index partiel.
   Par exemple, une requête préparée avec un paramètre peut indiquer
   <quote>x &lt; ?</quote> qui n'implique jamais
   <quote>x &lt; 2</quote> pour toutes les valeurs possibles du paramètre.
  </para>

  <para>
   Un troisième usage possible des index partiels ne nécessite pas que
   l'index soit utilisé dans des requêtes. L'idée ici est de créer un index
   d'unicité sur un sous-ensemble de la table, comme dans l'<xref
   linkend="indexes-partial-ex3"/>. Cela permet de mettre en place une unicité
   parmi le sous-ensemble des lignes de la table qui satisfont au prédicat,
   sans contraindre les lignes qui n'y satisfont pas.
  </para>

  <example id="indexes-partial-ex3">
   <title>Mettre en place un index d'unicité partiel</title>

   <para>
    Soit une table qui décrit des résultats de tests.
    On souhaite s'assurer qu'il n'y a qu'une seule entrée 
    <quote>succès</quote> (succes) pour chaque combinaison de sujet et de
    résultat, alors qu'il peut y avoir un nombre quelconque d'entrées
    <quote>echec</quote>. Une façon de procéder&nbsp;:
<programlisting>CREATE TABLE tests (
    sujet text,
    resultat text,
    succes boolean,
    ...
);

CREATE UNIQUE INDEX contrainte_tests_reussis ON tests (sujet, resultat)
    WHERE succes;</programlisting>
    C'est une méthode très efficace quand il y a peu de tests
    réussis et beaucoup de tests en échec.
   </para>
  </example>

  <para>
   Enfin, un index partiel peut aussi être utilisé pour surcharger les
   choix de plan d'exécution de requête du système.
   De plus, des jeux de données à distribution particulière peuvent inciter le
   système à utiliser un index alors qu'il ne devrait pas.
   Dans ce cas, on peut mettre en place l'index de telle façon qu'il ne soit 
   pas utilisé pour la requête qui pose problème.
   Normalement, <productname>PostgreSQL</productname> fait des choix d'usage d'index
   raisonnables. Par exemple, il les évite pour rechercher les valeurs communes,
   si bien que l'exemple précédent n'économise que la taille de l'index, il
   n'est pas nécessaire pour éviter l'utilisation de l'index.
   En fait, les choix de plan d'exécution incorrects doivent
   être traités comme des bogues, et être transmis à l'équipe de développement.
  </para>

  <para>
   Mettre en place un index partiel indique une connaissance au
   moins aussi étendue que celle de l'analyseur de requêtes, 
   en particulier, savoir quand un index peut être profitable.
   Une telle connaissance nécessite de l'expérience et une bonne
   compréhension du fonctionnement des index de <productname>PostgreSQL</productname>.
   Dans la plupart des cas, les index partiels ne représentent pas un
   gros gain par rapport aux index classiques.
  </para>

  <para>
   Plus d'informations sur les index partiels
   est disponible dans <xref linkend="ston89b"/>, <xref linkend="olson93"/>
   et <xref linkend="seshadri95"/>.
  </para>
 </sect1>

 <sect1 id="indexes-opclass">
  <title>Classes et familles d'opérateurs</title>

  <indexterm zone="indexes-opclass">
	  <primary>classe d'opérateurs</primary>
  </indexterm>

<!--  <indexterm zone="indexes-opfamily"> -->
  <indexterm>
	  <primary>famille d'opérateurs</primary>
  </indexterm>

  <para>
   Une définition d'index peut indiquer une <firstterm>classe 
   d'opérateurs</firstterm> pour chaque colonne de l'index.
<synopsis>CREATE INDEX <replaceable>nom</replaceable> ON <replaceable>table</replaceable> (<replaceable>colonne</replaceable> <replaceable>classe_operateur</replaceable>  <optional><replaceable>options de tri</replaceable></optional><optional>, ...</optional>);</synopsis>
   La classe d'opérateurs identifie les opérateurs que l'index doit utiliser 
   sur cette colonne. Par exemple, un index B-tree sur une colonne de type
   <type>int4</type> utilise la classe <literal>int4_ops</literal>.
   Cette classe d'opérateurs comprend des fonctions de comparaison pour les
   valeurs de type <type>int4</type>.
   En pratique, la classe d'opérateurs par défaut pour le type de données de la
   colonne est généralement suffisante. Les classes d'opérateurs sont utiles pour
   certains types de données, pour lesquels il peut y avoir plus d'un
   comportement utile de l'index.
   Par exemple, une donnée de type nombre complexe peut être classée
   par sa valeur absolue, ou par sa partie entière.
   Cela peut s'obtenir en définissant deux classes d'opérateurs pour ce 
   type de données et en sélectionnant la bonne classe à la création de l'index.
   La classe d'opérateur détermine l'ordre de tri basique (qui peut ensuite
   être modifié en ajoutant des options de tri comme
   <literal>COLLATE</literal>, <literal>ASC</literal>/<literal>DESC</literal> et/ou
   <literal>NULLS FIRST</literal>/<literal>NULLS LAST</literal>).
  </para>

  <para>
   Il y a quelques classes d'opérateurs en plus des classes par défaut&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Les classes d'opérateurs <literal>text_pattern_ops</literal>,
      <literal>varchar_pattern_ops</literal> et
      <literal>bpchar_pattern_ops</literal> supportent les index B-tree sur
      les types <type>text</type>, <type>varchar</type> et <type>char</type>,
      respectivement. À la différence des classes d'opérateurs par défaut, 
      les valeurs sont comparées strictement caractère par caractère plutôt 
      que suivant les règles de tri spécifiques à la localisation.
      Cela rend ces index utilisables pour des requêtes qui utilisent des
      recherches sur des motifs (<literal>LIKE</literal> ou des expressions 
      régulières POSIX) quand la base de données n'utilise pas la locale standard
      <quote>C</quote>.
      Par exemple, on peut indexer une colonne <type>varchar</type>
      comme ceci&nbsp;:
<programlisting>CREATE INDEX test_index ON test_table (col varchar_pattern_ops);</programlisting>
      Il faut créer un index avec la classe d'opérateurs par
      défaut pour que les requêtes qui utilisent une comparaison <literal>&lt;</literal>,
      <literal>&lt;=</literal>, <literal>&gt;</literal> ou <literal>&gt;=</literal>
      ordinaire utilisent un index. De telles requêtes ne peuvent pas utiliser
      les classes d'opérateurs 
      <literal><replaceable>xxx</replaceable>_pattern_ops</literal>.
      Néanmoins, des comparaisons d'égalité ordinaires peuvent utiliser ces
      classes d'opérateur. Il est possible de créer plusieurs index sur la
      même colonne avec différentes classes d'opérateurs.
      Si la locale C est utilisée, les classes
      d'opérateur <literal><replaceable>xxx</replaceable>_pattern_ops</literal>
      ne sont pas nécessaires, car un index avec une classe d'opérateurs
      par défaut est utilisable pour
      les requêtes de correspondance de modèles dans la locale C.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
    Les requêtes suivantes montrent les classes d'opérateurs prédéfinies&nbsp;:

<programlisting>SELECT am.amname AS index_method,
       opc.opcname AS opclass_name
    FROM pg_am am, pg_opclass opc
    WHERE opc.opcmethod = am.oid
    ORDER BY index_method, opclass_name;</programlisting>

  </para>

  <para>
   Une classe d'opérateurs n'est qu'un sous-ensemble d'une structure plus
   large appelée <firstterm>famille d'opérateurs</firstterm>. Dans les cas où
   plusieurs types de données ont des comportements similaires, il est
   fréquemment utile de définir des opérateurs identiques pour plusieurs types de
   données et d'autoriser leur utilisation avec des index. Pour cela, les
   classes d'opérateur de chacun de ces types doivent être groupés dans la
   même famille d'opérateurs. Les opérateurs inter-types sont membres de la
   famille, mais ne sont pas associés avec une seule classe de la famille.
  </para>

  <para>
    Cette requête affiche toutes les familles d'opérateurs définies et tous les
    opérateurs inclus dans chaque famille&nbsp;:
<programlisting>
SELECT am.amname AS index_method,
       opf.opfname AS opfamily_name,
       amop.amopopr::regoperator AS opfamily_operator
    FROM pg_am am, pg_opfamily opf, pg_amop amop
    WHERE opf.opfmethod = am.oid AND
          amop.amopfamily = opf.oid
    ORDER BY index_method, opfamily_name, opfamily_operator;
</programlisting>
  </para>
 </sect1>


 <sect1 id="indexes-collations">
  <title>Index et collationnements</title>

  <para>
   Un index peut supporter seulement un collationnement par colonne d'index.
   Si plusieurs collationnements ont un intérêt, plusieurs index pourraient
   être nécessaires.
  </para>

  <para>
   Regardez ces requêtes&nbsp;:
<programlisting>
CREATE TABLE test1c (
    id integer,
    content varchar COLLATE "x"
);

CREATE INDEX test1c_content_index ON test1c (content);
</programlisting>
   L'index utilise automatiquement le collationnement de la colonne
   sous-jacente. Donc une requête de la forme
<programlisting>
SELECT * FROM test1c WHERE content &gt; <replaceable>constant</replaceable>;
</programlisting>
   peut utiliser l'index car la comparaison utilisera par défaut le
   collationnement de la colonne. Néanmoins, cet index ne peut pas accélérer
   les requêtes qui impliquent d'autres collationnements. Donc, pour des
   requêtes de cette forme
<programlisting>
SELECT * FROM test1c WHERE content &gt; <replaceable>constant</replaceable> COLLATE "y";
</programlisting>
   un index supplémentaire, supportant le collationnement <literal>"y"</literal>
   peut être ajouté ainsi&nbsp;:
<programlisting>
CREATE INDEX test1c_content_y_index ON test1c (content COLLATE "y");
</programlisting>
  </para>
 </sect1>


 <sect1 id="indexes-examine">
  <title>Examiner l'utilisation des index</title>

  <indexterm zone="indexes-examine">
   <primary>index</primary>
   <secondary>examiner l'utilisation</secondary>
  </indexterm>

  <para>
   Bien que les index de <productname>PostgreSQL</productname> n'aient pas besoin
   de maintenance ou d'optimisation, il est important de s'assurer que les
   index sont effectivement utilisés sur un système en production.
   On vérifie l'utilisation d'un index pour une requête particulière avec
   la commande <xref linkend="sql-explain"/>.
   Son utilisation dans notre cas est expliquée dans la
   <xref linkend="using-explain"/>.
   Il est aussi possible de rassembler des statistiques globales
   sur l'utilisation des index sur un serveur en cours de fonctionnement,
   comme décrit dans la <xref linkend="monitoring-stats"/>.
  </para>

  <para>
   Il est difficile de donner une procédure générale pour déterminer
   les index à créer. Plusieurs cas typiques ont été
   cités dans les exemples précédents.
   Une bonne dose d'expérimentation est souvent nécessaire dans de nombreux cas.
   Le reste de cette section donne quelques pistes.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     La première chose à faire est de lancer 
     <xref linkend="sql-analyze"/>.
     Cette commande collecte les informations sur la distribution des
     valeurs dans la table. Cette information est nécessaire pour estimer
     le nombre de lignes retournées par une requête. L'optimiseur
     de requêtes en a besoin pour donner des coûts réalistes aux différents
     plans de requêtes possibles. En l'absence de statistiques réelles,
     le système utilise quelques valeurs par défaut, qui ont toutes les chances
     d'être inadaptées. Examiner l'utilisation des index par une application
     sans avoir lancé <command>ANALYZE</command> au préalable est, de ce fait,
     peine perdue. Voir <xref linkend="vacuum-for-statistics"
    /> et <xref linkend="autovacuum"
    /> pour plus d'informations.
    </para>
   </listitem>

   <listitem>
    <para>
     Utiliser des données réelles pour l'expérimentation. Utiliser des
     données de test pour mettre en place des index permet
     de trouver les index utiles pour les données de test,
     mais c'est tout.
    </para>

    <para>
     Il est particulièrement néfaste d'utiliser des jeux de données 
     très réduits.
     Alors qu'une requête sélectionnant 1000 lignes parmi 100000 peut
     utiliser un index, il est peu probable qu'une requête sélectionnant 1 ligne
     dans une table de 100 le fasse, parce que les 100 lignes
     tiennent probablement dans une seule page sur le disque, et qu'il n'y a
     aucun plan d'exécution qui puisse aller plus vite que la lecture 
     d'une seule page.
    </para>

    <para>
     Être vigilant en créant des données de test. C'est souvent
     inévitable quand l'application n'est pas encore en production.
     Des valeurs très similaires, complètement aléatoires, ou
     insérées déjà triées peuvent modifier la distribution des données et
     fausser les statistiques.
    </para>
   </listitem>

   <listitem>
    <para>
     Quand les index ne sont pas utilisés, il peut être utile pour
     les tests de forcer leur utilisation. Certains paramètres d'exécution
     du serveur peuvent interdire certains types de plans (voir
     la <xref linkend="runtime-config-query-enable"/>).
     Par exemple, en interdisant les lectures séquentielles de tables 
     <varname>enable_seqscan</varname>) et les jointures à boucles imbriquées
     (<varname>enable_nestloop</varname>), qui sont les deux plans les plus
     basiques, on force le système à utiliser un plan différent.
     Si le système continue néanmoins à choisir une lecture séquentielle
     ou une jointure à boucles imbriquées, alors il y a probablement
     une raison plus fondamentale qui empêche l'utilisation de l'index&nbsp;;
     la condition peut, par exemple, ne pas correspondre à l'index.
     (Les sections précédentes expliquent quelles sortes de requêtes peuvent
     utiliser quelles sortes d'index.)
    </para>
   </listitem>

   <listitem>
    <para>
     Si l'index est effectivement utilisé en forçant son utilisation,
     alors il y a deux possibilités&nbsp;: soit le système a raison et 
     l'utilisation de l'index est effectivement inappropriée, soit les
     coûts estimés des plans de requêtes ne reflètent pas la réalité.
     Il faut alors comparer la durée de la requête avec et sans
     index. La commande <command>EXPLAIN ANALYZE</command> peut être
     utile pour cela.
    </para>
   </listitem>

   <listitem>
    <para>
     S'il apparaît que les estimations de coûts sont fausses, il y a
     de nouveau deux possibilités. Le coût total est calculé à partir du
     coût par ligne de chaque n&oelig;ud du plan, multiplié par l'estimation de
     sélectivité du n&oelig;ud de plan.
     Le coût estimé des n&oelig;uds de plan peut être ajusté avec
     des paramètres d'exécution (décrits dans la <xref
     linkend="runtime-config-query-constants"/>).
     Une estimation de sélectivité inadaptée est due à des statistiques 
     insuffisantes. Il peut être possible de les améliorer en 
     optimisant les paramètres de collecte de statistiques.
     Voir <xref linkend="sql-altertable"/>.
    </para>

    <para>
     Si les coûts ne peuvent être ajustés à une meilleure représentation de la
     réalité, alors il faut peut-être forcer l'utilisation de l'index
     explicitement.
     Il peut aussi s'avérer utile de contacter les développeurs de
     <productname>PostgreSQL</productname> afin qu'ils examinent le problème.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
