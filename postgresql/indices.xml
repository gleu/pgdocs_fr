<?xml version="1.0" encoding="UTF-8"?>

<chapter id="indexes">
 <title>Index</title>

 <indexterm zone="indexes">
  <primary>index</primary>
 </indexterm>

 <para>
  L'utilisation d'index est une façon habituelle d'améliorer les performances
  d'une base de données. Un index permet au serveur de bases de données de
  retrouver une ligne spécifique bien plus rapidement. Mais les index ajoutent
  aussi une surcharge au système de base de données dans son ensemble, si bien
  qu'ils doivent être utilisés avec discernement.
 </para>

 <sect1 id="index-intro">
  <title>Introduction</title>

  <para>
   Soit une table définie ainsi&nbsp;:
   <programlisting>CREATE TABLE test1 (
    id integer,
    contenu varchar
);</programlisting>
   et une application qui utilise beaucoup de requêtes de la forme&nbsp;:
<programlisting>SELECT contenu FROM test1 WHERE id = <replaceable>constante</replaceable>;</programlisting>
   Sans préparation, le système doit lire la table
   <structname>test1</structname> dans son intégralité, ligne par ligne, pour
   trouver toutes les lignes qui correspondent. S'il y a beaucoup de lignes
   dans <structname>test1</structname>, et que seules quelques lignes
   correspondent à la requête (peut-être même zéro ou une seule), alors,
   clairement, la méthode n'est pas efficace. Mais si le système doit
   maintenir un index sur la colonne <structfield>id</structfield>, alors il
   peut utiliser une manière beaucoup plus efficace pour trouver les lignes
   recherchées. Il se peut qu'il n'ait ainsi qu'à parcourir quelques niveaux
   d'un arbre de recherche.
  </para>

  <para>
   Une approche similaire est utilisée dans la plupart des livres autres que
   ceux de fiction&nbsp;: les termes et concepts fréquemment recherchés par
   les lecteurs sont listés par ordre alphabétique à la fin du livre. Le
   lecteur qui recherche un mot particulier peut facilement parcourir l'index,
   puis aller directement à la page (ou aux pages) indiquée(s). De la même
   façon que l'auteur doit anticiper les sujets que les lecteurs risquent de
   rechercher, il est de la responsabilité du programmeur de prévoir les index
   qui sont utiles.
  </para>

  <para>
   La commande suivante peut être utilisée pour créer un index sur la colonne
   <structfield>id</structfield>&nbsp;:
<programlisting>CREATE INDEX test1_id_index ON test1 (id);</programlisting>
   Le nom <structname>test1_id_index</structname> peut être choisi
   librement, mais il est conseillé de choisir un nom qui rappelle le but
   de l'index.
  </para>

  <para>
   Pour supprimer l'index, on utilise la commande <command>DROP INDEX</command>.
   Les index peuvent être ajoutés et retirés des tables à tout moment.
  </para>

  <para>
   Une fois un index créé, aucune intervention supplémentaire n'est
   nécessaire&nbsp;:
   le système met à jour l'index lorsque la table est modifiée et utilise
   l'index dans les requêtes lorsqu'il pense que c'est plus efficace qu'une
   lecture complète de la table. Il faut néanmoins lancer la commande
   <command>ANALYZE</command> régulièrement pour permettre à l'optimiseur
   de requêtes de prendre les bonnes décisions.
   Voir le <xref linkend="performance-tips"/> pour comprendre quand et
   pourquoi l'optimiseur décide d'utiliser ou de ne
   <emphasis>pas</emphasis> utiliser un index.
  </para>

  <para>
   Les index peuvent aussi bénéficier aux commandes
   <command>UPDATE</command> et <command>DELETE</command> à
   conditions de recherche. De plus, les index peuvent être utilisés dans les
   jointures. Ainsi, un index défini sur une colonne qui fait partie d'une
   condition de jointure peut aussi accélérer significativement les requêtes avec
   jointures.
  </para>

  <para>
   Créer un index sur une grosse table peut prendre beaucoup de temps. Par
   défaut, <productname>PostgreSQL</productname> autorise la lecture
   (<command>SELECT</command>)
   sur la table pendant la création d'un index sur celle-ci, mais interdit les
   écritures (<command>INSERT</command>, <command>UPDATE</command>,
   <command>DELETE</command>). Elles sont bloquées jusqu'à la fin de la
   construction de l'index. Dans des environnements de production, c'est
   souvent inacceptable. Il est possible d'autoriser les écritures en
   parallèle de la création d'un index, mais quelques précautions sont à
   prendre. Pour plus d'informations, voir <xref
   linkend="sql-createindex-concurrently"/>.
  </para>

  <para>
   Après la création d'un index, le système doit le maintenir synchronisé avec
   la table. Cela rend plus lourdes les opérations de manipulation de
   données. C'est pourquoi les index qui sont peu, voire jamais, utilisés
   doivent être supprimés.
  </para>
 </sect1>


 <sect1 id="indexes-types">
  <title>Types d'index</title>

  <para>
   <productname>PostgreSQL</productname> propose plusieurs types d'index&nbsp;:
   B-tree, Hash, GiST, SP-GiST, GIN et BRIN. Chaque type d'index utilise un algorithme
   différent qui convient à un type particulier de requêtes. Par défaut, la
   commande <command>CREATE INDEX</command> crée un index B-tree, ce qui
   convient dans la plupart des situations.
   <indexterm>
    <primary>index</primary>
    <secondary>B-tree</secondary>
   </indexterm>
   <indexterm>
    <primary>B-tree</primary>
    <see>index</see>
   </indexterm>
   Les index B-tree savent traiter les requêtes d'égalité et par
   tranches sur des données qu'il est possible de trier. En particulier,
   l'optimiseur de requêtes de <productname>PostgreSQL</productname>
   considère l'utilisation d'un index B-tree lorsqu'une colonne indexée est
   utilisée dans une comparaison qui utilise un de ces opérateurs&nbsp;:

   <simplelist>
    <member><literal>&lt;</literal></member>
    <member><literal>&lt;=</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&gt;=</literal></member>
    <member><literal>&gt;</literal></member>
   </simplelist>

   Les constructions équivalentes à des combinaisons de ces opérateurs, comme
   <literal>BETWEEN</literal> et <literal>IN</literal>, peuvent aussi être
   implantées avec une recherche par index B-tree. Une condition
   <literal>IS NULL</literal> ou <literal>IS NOT NULL</literal> sur une colonne
   indexée peut aussi être utilisée avec un index B-tree.
  </para>

  <para>
   L'optimiseur peut aussi utiliser un index B-tree pour des requêtes
   qui utilisent les opérateurs de recherche de motif <literal>LIKE</literal>
   et <literal>~</literal> <emphasis>si</emphasis> le motif est une constante et
   se trouve au début de la chaîne à rechercher &mdash; par exemple,
   <literal>col LIKE 'foo%'</literal> ou <literal>col ~ '^foo'</literal>, mais
   pas <literal>col LIKE '%bar'</literal>. Toutefois, si la base de données
   n'utilise pas la locale C, il est nécessaire de créer l'index avec
   une classe d'opérateur spéciale pour supporter l'indexation à correspondance
   de modèles. Voir la <xref linkend="indexes-opclass"/> ci-dessous. Il est
   aussi possible d'utiliser des index B-tree pour <literal>ILIKE</literal> et
   <literal>~*</literal>, mais seulement si le modèle débute par des caractères
   non alphabétiques, c'est-à-dire des caractères non affectés par les
   conversions majuscules/minuscules.
  </para>

  <para>
   Les index B-tree peuvent aussi être utilisés pour récupérer des données
   triées. Ce n'est pas toujours aussi rapide qu'un simple parcours séquentiel
   suivi d'un tri, mais c'est souvent utile.
  </para>

  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>hash</secondary>
   </indexterm>
   <indexterm>
    <primary>hash</primary>
    <see>index</see>
   </indexterm>
   Les index hash ne peuvent gérer que des comparaisons d'égalité simple.
   Le planificateur de requêtes considère l'utilisation d'un index hash quand
   une colonne indexée est impliquée dans une comparaison avec l'opérateur
   <literal>=</literal>. La commande suivante est utilisée pour
   créer un index hash&nbsp;:
<synopsis>CREATE INDEX <replaceable>nom</replaceable> ON <replaceable>table</replaceable> USING HASH (<replaceable>column</replaceable>);
   </synopsis>
  </para>

  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>GiST</secondary>
   </indexterm>
   <indexterm>
    <primary>GiST</primary>
    <see>index</see>
   </indexterm>
   Les index GiST ne constituent pas un unique type d'index, mais plutôt une infrastructure
   à l'intérieur de laquelle plusieurs stratégies d'indexage peuvent être implantées.
   De cette façon, les opérateurs particuliers avec lesquels un index GiST peut
   être utilisé varient en fonction de la stratégie d'indexage (la <firstterm>classe
    d'opérateur</firstterm>). Par exemple, la distribution standard de
   <productname>PostgreSQL</productname> inclut des classes d'opérateurs GiST
   pour plusieurs types de données géométriques à deux dimensions, qui supportent
   des requêtes indexées utilisant ces opérateurs&nbsp;:

   <simplelist>
    <member><literal>&lt;&lt;</literal></member>
    <member><literal>&amp;&lt;</literal></member>
    <member><literal>&amp;&gt;</literal></member>
    <member><literal>&gt;&gt;</literal></member>
    <member><literal>&lt;&lt;|</literal></member>
    <member><literal>&amp;&lt;|</literal></member>
    <member><literal>|&amp;&gt;</literal></member>
    <member><literal>|&gt;&gt;</literal></member>
    <member><literal>@&gt;</literal></member>
    <member><literal>&lt;@</literal></member>
    <member><literal>~=</literal></member>
    <member><literal>&amp;&amp;</literal></member>
   </simplelist>

   Voir la <xref linkend="functions-geometry"/> pour connaître la
   signification de ces opérateurs.
   Les classes d'opérateurs GiST incluses dans la distribution standard sont
   documentées dans <xref linkend="gist-builtin-opclasses-table"/>.
   Beaucoup de classes d'opérateurs GiST sont disponibles dans l'ensemble
   des <literal>contrib</literal> ou comme projet séparé. Pour plus
   d'informations, voir <xref linkend="gist"/>.
  </para>

  <para>
   Les index GiST sont aussi capables d'optimiser des recherches du type
   <quote>voisin-le-plus-proche</quote>
   (<foreignphrase>nearest-neighbor</foreignphrase>), comme&nbsp;:
   <programlisting><![CDATA[
SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;
]]>
   </programlisting>
   qui trouve les dix places les plus proches d'une cible donnée. Cette
   fonctionnalité dépend de nouveau de la classe d'opérateurs utilisée.
   Dans <xref linkend="gist-builtin-opclasses-table"/>, les opérateurs pouvant
   être utilisés de cette façon sont listés dans la colonne <quote>Opérateurs
    de tri</quote>.
  </para>

  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>SP-GiST</secondary>
   </indexterm>
   <indexterm>
    <primary>SP-GiST</primary>
    <see>index</see>
   </indexterm>
   Les index SP-GiST, tout comme les index GiST, offrent une infrastructure
   qui supporte différents types de recherches. SP-GiST permet l'implémentation
   d'une grande étendue de structures de données non balancées, stockées sur
   disque comme les <foreignphrase>quadtrees</foreignphrase>, les arbres k-d, et
   les arbres <foreignphrase>radix</foreignphrase>.
   <productname>PostgreSQL</productname> inclut les classes
   d'opérateurs SP-GiST pour les points à deux dimensions, qui supportent les
   requêtes indexées en utilisant les opérateurs suivants&nbsp;:

   <simplelist>
    <member><literal>&lt;&lt;</literal></member>
    <member><literal>&gt;&gt;</literal></member>
    <member><literal>~=</literal></member>
    <member><literal>&lt;@</literal></member>
    <member><literal>&lt;^</literal></member>
    <member><literal>&gt;^</literal></member>
   </simplelist>

   (Voir <xref linkend="functions-geometry"/> pour la signification de ces
   opérateurs.)
   Les classes d'opérateur SP-GiST incluses dans la distribution standard sont
   documentées dans <xref linkend="spgist-builtin-opclasses-table"/>.
   Pour plus d'informations, voir <xref linkend="spgist"/>.
  </para>

  <para>
   Comme GiST, SP-GiST supporte les recherches de type
   <quote>voisin-le-plus-proche</quote>. Pour les classes d'opérateurs SP-GiST
   qui supportent le tri par distance, l'opérateur correspondant est spécifié
   dans la colonne <quote>Opérateurs d'ordre</quote> dans
   <xref linkend="spgist-builtin-opclasses-table"/>.
  </para>

  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>GIN</secondary>
   </indexterm>
   <indexterm>
    <primary>GIN</primary>
    <see>index</see>
   </indexterm>
   Les index GIN sont des <quote>index inversés</quote> qui sont appropriés
   quand les valeurs à index contiennent plusieurs valeurs composantes, comme
   les tableaux. Un index inversé contient une entrée séparée pour
   chaque valeur composante, et peut gérer efficacement les requêtes testant
   la présence de valeurs composantes spécifiques.
  </para>

  <para>
   Comme GiST et SP-GiST, GIN supporte
   différentes stratégies d'indexation utilisateur. Les
   opérateurs particuliers avec lesquels un index GIN peut être utilisé varient
   selon la stratégie d'indexation. Par exemple, la distribution standard de
   <productname>PostgreSQL</productname> inclut une classe d'opérateurs GIN pour
   des tableaux à une dimension qui supportent les requêtes indexées utilisant
   ces opérateurs&nbsp;:

   <simplelist>
    <member><literal>&lt;@</literal></member>
    <member><literal>@&gt;</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&amp;&amp;</literal></member>
   </simplelist>

   Voir <xref linkend="functions-array"/> pour la signification de ces
   opérateurs.
   Les classes d'opérateurs GIN incluses dans la distribution standard sont
   documentées dans <xref linkend="gin-builtin-opclasses-table"/>.
   Beaucoup d'autres classes d'opérateurs GIN sont disponibles dans les modules
   <literal>contrib</literal> ou dans des projets séparés. Pour plus d'informations,
   voir <xref linkend="gin"/>.
  </para>

  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>BRIN</secondary>
   </indexterm>
   <indexterm>
    <primary>BRIN</primary>
    <see>index</see>
   </indexterm>
   Les index BRIN (raccourci pour <foreignphrase>Block Range
    INdexes</foreignphrase>) stockent des résumés sur les valeurs enregistrées
   dans des blocs physiques successifs de la table. Comme GiST, SP-GiST et
   GIN, BRIN supporte plusieurs stratégies d'indexation, et les opérateurs
   compatibles avec un index BRIN varient suivant la stratégie d'indexation.
   Pour les types de données qui ont un ordre de tri linéaire, la donnée
   indexée correspond aux valeurs minimale et maximale des valeurs de la
   colonne pour chaque ensemble de blocs. Cela supporte les requêtes indexées
   utilisant ces opérateurs&nbsp;:

   <simplelist>
    <member><literal>&lt;</literal></member>
    <member><literal>&lt;=</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&gt;=</literal></member>
    <member><literal>&gt;</literal></member>
   </simplelist>

   Les classes d'opérateurs BRIN incluses dans la distribution standard sont
   documentées dans <xref linkend="brin-builtin-opclasses-table"/>. Pour plus
   d'informations, voir <xref linkend="brin"/>.
  </para>
 </sect1>

 <sect1 id="indexes-multicolumn">
  <title>Index multicolonnes</title>

  <indexterm zone="indexes-multicolumn">
   <primary>index</primary>
   <secondary>multicolonne</secondary>
  </indexterm>

  <para>
   Un index peut porter sur plusieurs colonnes d'une table. Soit, par exemple,
   une table de la forme&nbsp;:
   <programlisting>CREATE TABLE test2 (
  majeur int,
  mineur int,
  nom varchar
);</programlisting>
   (cas d'un utilisateur gardant son répertoire
   <filename class="directory">/dev</filename> dans une base de données...)
   et que des requêtes comme&nbsp;:
<programlisting>SELECT nom FROM test2 WHERE majeur = <replaceable>constante</replaceable> AND mineur = <replaceable>constante</replaceable>;</programlisting>
   sont fréquemment exécutées. Il peut alors être souhaitable de définir un
   index qui porte sur les deux colonnes
   <structfield>majeur</structfield> et
   <structfield>mineur</structfield>. Ainsi&nbsp;:
<programlisting>CREATE INDEX test2_mm_idx ON test2 (majeur, mineur);</programlisting>
  </para>

  <para>
   Actuellement, seuls les types d'index B-tree, GiST, GIN et BRIN supportent les
   index multicolonnes. 32 colonnes peuvent être précisées, au maximum.
   Cette limite peut être modifiée à la compilation de
   <productname>PostgreSQL</productname>. Voir le fichier
   <filename>pg_config_manual.h</filename>.
  </para>

  <para>
   Un index B-tree multicolonne peut être utilisé avec des conditions de
   requêtes impliquant un sous-ensemble quelconque de colonnes de l'index.
   L'index est toutefois plus efficace lorsqu'il y a des contraintes sur les
   premières colonnes (celles de gauche).
   La règle exacte est la suivante&nbsp;: les
   contraintes d'égalité sur les premières colonnes, et toute contrainte
   d'inégalité sur la première colonne qui ne possède pas de contrainte d'égalité
   sont utilisées pour limiter la partie parcourue de l'index. Les contraintes
   sur les colonnes à droite de ces colonnes sont vérifiées dans l'index, et
   limitent ainsi les visites de la table, mais elles ne réduisent pas la partie
   de l'index à parcourir.
  </para>

  <para>
   Par exemple, avec un index sur
   <literal>(a, b, c)</literal> et une condition de requête <literal>WHERE a =
   5 AND b &gt;= 42 AND c &lt; 77</literal>, l'index est parcouru à partir de
   la première entrée pour laquelle <literal>a</literal> = 5 et <literal>b</literal> = 42 jusqu'à la
   dernière entrée pour laquelle <literal>a</literal> = 5. Les entrées de l'index avec
   <literal>c</literal> &gt;= 77 sont sautées, mais elles sont toujours
   parcourues. En principe, cet index peut être utilisé pour les requêtes
   qui ont des contraintes sur <literal>b</literal> et/ou <literal>c</literal> sans contrainte
   sur <literal>a</literal> &mdash; mais l'index entier doit être parcouru, donc, dans
   la plupart des cas, le planificateur préfère un parcours séquentiel de la
   table à l'utilisation de l'index.
  </para>

  <para>
   Un index GiST multicolonne peut être utilisé avec des conditions de
   requête qui impliquent un sous-ensemble quelconque de colonnes de l'index. Les
   conditions sur des colonnes supplémentaires restreignent les entrées renvoyées
   par l'index, mais la condition sur la première colonne est la plus importante
   pour déterminer la part de l'index parcourue. Un index GiST est
   relativement inefficace si sa première colonne n'a que quelques valeurs
   distinctes, même s'il y a beaucoup de valeurs distinctes dans les colonnes
   supplémentaires.
  </para>

  <para>
   Un index multicolonne GIN peut être utilisé avec des conditions de requête
   qui impliquent tout sous-ensemble des colonnes de l'index. Contrairement à
   B-tree ou GiST, la qualité de la recherche dans l'index est identique quelles que
   soient les colonnes de l'index que la requête utilise.
  </para>

  <para>
   Un index BRIN multicolonne peut être utilisé avec des conditions dans la
   requête qui impliquent tout sous-ensemble de colonnes dans l'index. Comme
   GIN et contrairement à B-tree ou GiST, l'efficacité de la recherche par
   l'index est la même quelles que soient les colonnes utilisées dans les conditions
   de la requête. La seule raison d'avoir plusieurs index BRIN au lieu d'un
   index BRIN multicolonne sur une table est d'avoir un paramétrage de
   stockage <literal>pages_per_range</literal> différent.
  </para>

  <para>
   Chaque colonne doit évidemment être utilisée avec des opérateurs appropriés
   au type de l'index&nbsp;; les clauses qui impliquent d'autres opérateurs ne
   sont pas prises en compte.
  </para>

  <para>
   Il est préférable d'utiliser les index multicolonnes avec parcimonie. Dans la
   plupart des cas, un index sur une seule colonne est suffisant et préserve
   espace et temps. Les index de plus de trois colonnes risquent fort
   d'être inefficaces, sauf si l'utilisation de cette table est extrêmement
   stylisée. Voir aussi la <xref linkend="indexes-bitmap-scans"/> et
   <xref linkend="indexes-index-only-scans"/> pour les
   discussions sur les mérites des différentes configurations d'index.
  </para>
 </sect1>


 <sect1 id="indexes-ordering">
  <title>Index et <literal>ORDER BY</literal></title>

  <indexterm zone="indexes-ordering">
   <primary>index</primary>
   <secondary>et <literal>ORDER BY</literal></secondary>
  </indexterm>

  <para>
   Au-delà du simple fait de trouver les lignes à renvoyer à une requête, un index
   peut les renvoyer dans un ordre spécifique. Cela permet de résoudre une
   clause <literal>ORDER BY</literal> sans
   étape de tri séparée. De tous les types d'index actuellement supportés par
   <productname>PostgreSQL</productname>, seuls les B-tree peuvent produire une
   sortie triée &mdash; les autres types d'index renvoient les lignes
   correspondantes dans un ordre imprécis, dépendant de l'implantation.
  </para>

  <para>
   Le planificateur répond à une clause <literal>ORDER BY</literal>
   soit en parcourant un index disponible qui correspond à la
   clause, soit en parcourant la table dans l'ordre physique et en réalisant
   un tri explicite. Pour une requête qui nécessite de parcourir une fraction
   importante de la table, le tri explicite est probablement plus rapide que
   le parcours d'un index, car il nécessite moins d'entrées/sorties disque, du
   fait de son accès séquentiel. Les index sont plus utiles lorsqu'il s'agit
   de ne récupérer que
   quelques lignes. <literal>ORDER BY</literal>
   combiné à <literal>LIMIT</literal> <replaceable>n</replaceable> est un cas
   spécial très important&nbsp;:
   un tri explicite doit traiter toutes les données pour identifier les
   <replaceable>n</replaceable> premières lignes, mais s'il y a un index
   qui correspond à l'<literal>ORDER BY</literal>, alors les
   <replaceable>n</replaceable> premières lignes peuvent être récupérées directement
   sans qu'il soit nécessaire de parcourir les autres.
  </para>

  <para>
   Par défaut, les index B-tree stockent leurs entrées dans l'ordre ascendant,
   valeurs NULL en dernier (le TID de la table est traité comme une colonne de
   départage pour les entrées qui, sans quoi, seraient identiques). Cela signifie
   que le parcours avant d'un index sur une colonne <literal>x</literal>
   produit une sortie satisfaisant <literal>ORDER BY x</literal> (ou en plus
   verbeux <literal>ORDER BY x ASC NULLS LAST</literal>). L'index peut aussi
   être parcouru en arrière, produisant ainsi une sortie satisfaisant un
   <literal>ORDER BY x DESC</literal> (ou en plus verbeux <literal>ORDER BY x
   DESC NULLS FIRST</literal>, car <literal>NULLS FIRST</literal> est la valeur
   par défaut pour un <literal>ORDER BY DESC</literal>).
  </para>

  <para>
   L'ordre d'un index B-tree peut être défini à la création par l'inclusion des options
   <literal>ASC</literal>, <literal>DESC</literal>, <literal>NULLS FIRST</literal>,
   et/ou <literal>NULLS LAST</literal> lors de la création de l'index&nbsp;; par
   exemple&nbsp;:
<programlisting>
CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);
CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);
   </programlisting>
   Un index stocké en ordre ascendant avec les valeurs NULL en premier peut
   satisfaire soit <literal>ORDER BY x ASC NULLS FIRST</literal>, soit
   <literal>ORDER BY x DESC NULLS LAST</literal> selon la direction du
   parcours.
  </para>

  <para>
   On peut s'interroger sur l'intérêt de proposer quatre options, alors que
   deux options associées à la possibilité d'un parcours inverse semblent
   suffire à couvrir toutes les
   variantes d'<literal>ORDER BY</literal>. Dans les index monocolonnes,
   les options sont en effet redondantes, mais pour un index à plusieurs colonnes,
   elles sont utiles. Si l'on considère un index à deux colonnes
   <literal>(x, y)</literal>, il peut satisfaire une clause <literal>ORDER
    BY x, y</literal> sur un parcours avant, ou
   <literal>ORDER BY x DESC, y DESC</literal> sur un parcours inverse.
   Mais il se peut que l'application utilise fréquemment
   <literal>ORDER BY x ASC, y DESC</literal>. Il n'y a pas moyen d'obtenir cet
   ordre à partir d'un index plus simple, mais c'est possible si l'index est défini
   comme <literal>(x ASC, y DESC)</literal> or <literal>(x DESC, y
    ASC)</literal>.
  </para>

  <para>
   Les index d'ordre différent de celui par défaut sont visiblement une
   fonctionnalité très spécialisée, mais ils peuvent parfois être à l'origine
   d'accélérations spectaculaires des performances sur certaines requêtes.
   L'intérêt de maintenir un tel index dépend
   de la fréquence des requêtes qui nécessitent un tri particulier.
  </para>
 </sect1>


 <sect1 id="indexes-bitmap-scans">
  <title>Combiner des index multiples</title>

  <indexterm zone="indexes-bitmap-scans">
   <primary>index</primary>
   <secondary>combiner des index multiples</secondary>
  </indexterm>

  <indexterm zone="indexes-bitmap-scans">
   <primary>parcours de bitmap</primary>
  </indexterm>

  <para>
   Un parcours unique d'index ne peut utiliser que les clauses de la requête qui utilisent
   les colonnes de l'index avec les opérateurs de sa classe d'opérateurs et qui
   sont jointes avec <literal>AND</literal>. Par exemple, étant donné un index sur
   <literal>(a, b)</literal>, une condition de requête <literal>WHERE a = 5
    AND b = 6</literal> peut utiliser l'index, mais une requête
   <literal>WHERE a = 5 OR b = 6</literal> ne peut pas l'utiliser directement.
  </para>

  <para>
   Heureusement, <productname>PostgreSQL</productname> peut combiner
   plusieurs index (y compris plusieurs utilisations du même index) pour gérer
   les cas qui ne peuvent pas être résolus par des parcours d'index
   simples. Le système peut former des conditions <literal>AND</literal>
   et <literal>OR</literal> sur plusieurs parcours d'index. Par exemple,
   une requête comme <literal>WHERE x = 42 OR x = 47 OR x = 53 OR x = 99</literal>
   peut être divisée en quatre parcours distincts d'un index sur
   <literal>x</literal>, chaque parcours utilisant une des clauses de la requête. Les
   résultats de ces parcours sont alors assemblés par OR pour produire le
   résultat. Autre exemple, s'il existe des index séparés sur
   <literal>x</literal> et <literal>y</literal>, une résolution possible d'une requête
   comme <literal>WHERE x = 5 AND y = 6</literal> consiste à utiliser chaque index avec la
   clause de la requête appropriée et d'assembler les différents résultats
   avec un AND pour identifier les lignes résultantes.
  </para>

  <para>
   Pour combiner plusieurs index, le système parcourt chaque index nécessaire
   et prépare un <firstterm>bitmap</firstterm> en mémoire qui donne l'emplacement des
   lignes de table qui correspondent aux conditions de
   l'index. Les bitmaps sont ensuite assemblés avec des opérateurs AND ou OR
   selon les besoins de la requête. Enfin, les lignes réelles de la table
   sont visitées et renvoyées. Elles sont visitées dans l'ordre physique parce
   c'est ainsi que le bitmap est créé&nbsp;; cela signifie que l'ordre
   des index originaux est perdu et que, du coup, une étape de tri séparée est
   nécessaire si la requête comprend une clause <literal>ORDER BY</literal>. Pour
   cette raison, et parce que chaque parcours d'index supplémentaire ajoute
   un temps additionnel, le planificateur choisit quelques fois d'utiliser un
   parcours d'index simple même si des index supplémentaires sont disponibles
   et peuvent être utilisés.
  </para>

  <para>
   Le nombre de combinaisons d'index possibles croît parallèlement à la
   complexité des applications. Il est alors de la responsabilité du
   développeur de la base de décider des index à fournir. Il est quelques fois
   préférable de créer des index multicolonnes, mais il est parfois préférable
   de créer des index séparés et de s'appuyer sur la fonctionnalité de
   combinaison des index.
  </para>
  <para>
   Par exemple, si la charge inclut un mélange de requêtes qui impliquent
   parfois uniquement la colonne <literal>x</literal>, parfois uniquement
   la colonne <literal>y</literal> et quelques
   fois les deux colonnes, on peut choisir deux index séparés sur
   <literal>x</literal> et <literal>y</literal> et s'appuyer sur la combinaison d'index
   pour traiter les requêtes qui utilisent les deux colonnes. On peut aussi
   créer un index multicolonne sur <literal>(x, y)</literal>. Cet index est
   typiquement plus efficace que la combinaison d'index pour les requêtes
   impliquant les deux colonnes, mais, comme discuté dans la <xref
   linkend="indexes-multicolumn"/>, il est pratiquement inutile pour les
   requêtes n'impliquant que <literal>y</literal>. Il ne peut donc pas être le
   seul index. Une combinaison de l'index multicolonne et d'un index séparé
   sur <literal>y</literal> est une solution raisonnable. Pour les requêtes qui
   n'impliquent que <literal>x</literal>, l'index multicolonne peut être
   utilisé, bien qu'il soit plus large et donc plus lent qu'un index sur <literal>x</literal> seul.
   La dernière alternative consiste à créer les trois index, mais cette
   solution n'est raisonnable que si la table est lue bien plus
   fréquemment qu'elle n'est mise à jour et que les trois types de requêtes sont
   communs. Si un des types de requêtes est bien moins courant que les autres,
   il est préférable de ne créer que les deux index qui
   correspondent le mieux aux types communs.
  </para>

 </sect1>


 <sect1 id="indexes-unique">
  <title>Index d'unicité</title>

  <indexterm zone="indexes-unique">
   <primary>index</primary>
   <secondary>unique</secondary>
  </indexterm>

  <para>
   Les index peuvent aussi être utilisés pour garantir l'unicité des
   valeurs d'une colonne, ou l'unicité des valeurs combinées de plusieurs
   colonnes.
   <synopsis>CREATE UNIQUE INDEX <replaceable>nom</replaceable> ON <replaceable>table</replaceable> (<replaceable>colonne</replaceable> <optional>, ...</optional>);</synopsis>
   À ce jour, seuls les index B-tree peuvent être déclarés uniques.
  </para>

  <para>
   Lorsqu'un index est déclaré unique, il ne peut exister plusieurs lignes
   d'une table qui possèdent la même valeur indexée. Les valeurs NULL ne sont pas
   considérées comme égales. Un index d'unicité multicolonne ne rejette que les
   cas où toutes les colonnes indexées sont égales sur plusieurs lignes.
  </para>

  <para>
   <productname>PostgreSQL</productname> crée automatiquement un index
   d'unicité à la déclaration d'une contrainte d'unicité ou d'une clé primaire
   sur une table. L'index porte sur les colonnes qui composent la clé primaire
   ou la contrainte d'unicité (au besoin, il s'agit d'un index multicolonne).
   C'est cet index qui assure le mécanisme de vérification de la contrainte.
  </para>

  <note>
   <para>
    Il n'est pas nécessaire de créer manuellement un index sur les colonnes
    uniques. Cela duplique l'index créé automatiquement.
   </para>
  </note>
 </sect1>


 <sect1 id="indexes-expressional">
  <title>Index d'expressions</title>

  <indexterm zone="indexes-expressional">
   <primary>index</primary>
   <secondary sortas="expressions">sur expressions</secondary>
  </indexterm>

  <para>
   Une colonne d'index ne correspond pas nécessairement exactement à une
   colonne de la table associée, mais peut être une fonction ou une expression
   scalaire calculée à partir d'une ou plusieurs colonnes de la table.
   Cette fonctionnalité est utile pour obtenir un accès rapide aux tables
   en utilisant les résultats de calculs.
  </para>

  <para>
   Par exemple, une façon classique de faire des comparaisons indépendantes
   de la casse est d'utiliser la fonction <function>lower</function>&nbsp;:
<programlisting>SELECT * FROM test1 WHERE lower(col1) = 'valeur';</programlisting>
   Si un index a été défini sur le résultat de <literal>lower(col1)</literal>,
   cette requête peut l'utiliser.
   Un tel index est créé avec la commande&nbsp;:
<programlisting>CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));</programlisting>
  </para>

  <para>
   Si l'index est déclaré <literal>UNIQUE</literal>, il empêche
   la création de lignes dont les valeurs de la colonne <literal>col1</literal> ne
   diffèrent que par la casse, ainsi que celle de lignes dont les valeurs de la
   colonne <literal>col1</literal> sont identiques.
   Ainsi, les index d'expressions peuvent être utilisés pour
   appliquer des contraintes qui ne peuvent être définies avec une simple
   contrainte d'unicité.
  </para>

  <para>
   Autre exemple. Lorsque des requêtes comme &nbsp;:
<programlisting>SELECT * FROM personnes WHERE (prenom || ' ' || nom) = 'Jean Dupont';</programlisting>
   sont fréquentes, alors il peut être utile de créer un index comme&nbsp;:
<programlisting>CREATE INDEX personnes_noms ON personnes ((prenom || ' ' || nom));</programlisting>
  </para>

  <para>
   La syntaxe de la commande <command>CREATE INDEX</command> nécessite normalement
   de mettre des parenthèses autour de l'expression indexée, comme dans
   l'exemple précédent. Les parenthèses peuvent être omises quand l'expression
   est un simple appel de fonction, comme dans le premier exemple.
  </para>

  <para>
   Les expressions d'index sont relativement coûteuses à calculer, car
   l'expression doit être recalculée à chaque insertion ou mise à jour de
   ligne. Néanmoins, les expressions d'index ne sont
   <emphasis>pas</emphasis> recalculées lors d'une recherche par index, car elles sont
   déjà stockées dans l'index. Dans les deux exemples ci-dessus, le système
   voit la requête comme un <literal>WHERE colonne_indexée =
   'constante'</literal>. De ce fait, la recherche est aussi rapide que toute
   autre requête d'index. Ainsi, les index d'expressions sont utiles
   lorsque la rapidité de recherche est plus importante que la rapidité
   d'insertion et de mise à jour.
  </para>
 </sect1>


 <sect1 id="indexes-partial">
  <title>Index partiels</title>

  <indexterm zone="indexes-partial">
   <primary>index</primary>
   <secondary>partiel</secondary>
  </indexterm>

  <para>
   Un <firstterm>index partiel</firstterm> est un index construit sur un
   sous-ensemble d'une table&nbsp;; le sous-ensemble est défini par une expression
   conditionnelle (appelée <firstterm>prédicat</firstterm> de l'index
   partiel). L'index ne contient des entrées que pour les lignes de la
   table qui satisfont au prédicat. Les index partiels sont une fonctionnalité
   spécialisée, mais ils trouvent leur utilité dans de nombreuses situations.
  </para>

  <para>
   Une raison majeure à l'utilisation d'index partiels est d'éviter
   d'indexer les valeurs courantes. Puisqu'une requête qui recherche une
   valeur courante (qui correspond à plus de quelques pour cents de toutes
   les lignes) n'utilise, de toute façon, pas cet index, il ne sert à rien
   de garder ces lignes dans l'index. Cela réduit la taille de l'index,
   ce qui accélèrera les requêtes qui l'utilisent. Cela accélère aussi nombre
   d'opérations de mise à jour de la table, car l'index n'a pas à être
   mis à jour à chaque fois. L'<xref linkend="indexes-partial-ex1"/> montre une
   application possible de cette idée.
  </para>

  <example id="indexes-partial-ex1">
   <title>Mettre en place un index partiel pour exclure des valeurs courantes</title>

   <para>
    Soit l'enregistrement d'un journal d'accès à un serveur web dans une base de données.
    La plupart des accès proviennent de classes d'adresses IP internes à
    l'organisation, mais certaines proviennent de l'extérieur (des employés connectés
    par modem, par exemple).
    Si les recherches par adresses IP concernent essentiellement les accès
    extérieurs, il est inutile d'indexer les classes
    d'adresses IP qui correspondent au sous-réseau de l'organisation.

   </para>

   <para>
    Si la table ressemble à&nbsp;:
<programlisting>CREATE TABLE access_log (
    url varchar,
    client_ip inet,
    ...
);</programlisting>
   </para>

   <para>
    Pour créer un index partiel qui corresponde à l'exemple, il faut utiliser
    une commande comme celle-ci&nbsp;:
<programlisting>CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)
    WHERE NOT (client_ip &gt; inet '192.168.100.0' AND
               client_ip &lt; inet '192.168.100.255');</programlisting>
   </para>

   <para>
    Une requête typique qui peut utiliser cet index est&nbsp;:
<programlisting>SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '212.78.10.32';</programlisting>
    Ici l'adresse IP de la requête est couverte par un index partiel. La
    requête suivante ne peut pas utiliser l'index partiel, puisqu'elle utilise
    une adresse IP qui est exclue de l'index&nbsp;:
<programlisting>SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '192.168.100.23';</programlisting>
   </para>

   <para>
    Ce type d'index partiel nécessite que les valeurs courantes
    soient prédéterminées, de façon à ce que ce type d'index soit mieux utilisé
    avec une distribution des données qui ne change pas. Les index peuvent être
    recréés occasionnellement pour s'adapter aux nouvelles distributions de
    données, mais cela ajoute de la maintenance.
   </para>
  </example>

  <para>
   Une autre utilisation possible d'index partiel revient à exclure des
   valeurs de l'index qui ne correspondent pas aux requêtes courantes&nbsp;;
   ceci est montré dans l'<xref linkend="indexes-partial-ex2"/>. Cette méthode
   donne les mêmes avantages que la précédente, mais empêche l'accès par l'index aux valeurs
   <quote>sans intérêt</quote>. Évidemment, mettre en place des index partiels
   pour ce genre de scénarios nécessite beaucoup de soin et d'expérimentation.
  </para>

  <example id="indexes-partial-ex2">
   <title>Mettre en place un index partiel pour exclure les valeurs inintéressantes</title>

   <para>
    Soit une table qui contient des commandes facturées et des
    commandes non facturées, avec les commandes non facturées qui ne prennent
    qu'une petite fraction de l'espace dans la table, et qui sont les
    plus accédées. Il est possible d'améliorer les
    performances en créant un index limité aux lignes non facturées.
    La commande pour créer l'index ressemble à&nbsp;:
<programlisting>CREATE INDEX index_commandes_nonfacturees ON commandes (no_commande)
    WHERE facturee is not true;</programlisting>
   </para>

   <para>
    La requête suivante utilise cet index&nbsp;:
<programlisting>SELECT * FROM commandes WHERE facturee is not true AND no_commande &lt; 10000;</programlisting>
    Néanmoins, l'index peut aussi être utilisé dans des requêtes qui
    n'utilisent pas <structfield>no_commande</structfield>, comme&nbsp;:
<programlisting>SELECT * FROM commandes WHERE facturee is not true AND montant &gt; 5000.00;</programlisting>
    Ceci n'est pas aussi efficace qu'un index partiel sur la colonne
    <structfield>montant</structfield>, car le système doit lire l'index en entier.
    Néanmoins, s'il y a assez peu de commandes non facturées, l'utilisation
    de cet index partiel pour trouver les commandes non facturées peut être
    plus efficace.
   </para>

   <para>
    La requête suivante ne peut pas utiliser cet index&nbsp;:
<programlisting>SELECT * FROM commandes WHERE no_commande = 3501;</programlisting>
    La commande 3501 peut faire partie des commandes facturées ou
    non facturées.
   </para>
  </example>

  <para>
   L'<xref linkend="indexes-partial-ex2"/> illustre aussi le fait que la colonne
   indexée et la colonne utilisée dans le prédicat ne sont pas nécessairement
   les mêmes. <productname>PostgreSQL</productname> supporte tous les
   prédicats sur les index partiels, tant que ceux-ci ne portent que sur des
   champs de la table indexée. Néanmoins, il faut se rappeler que le prédicat doit
   correspondre aux conditions utilisées dans les requêtes qui sont supposées
   profiter de l'index. Pour être précis, un index partiel ne peut être utilisé
   pour une requête que si le système peut reconnaître que la clause
   <literal>WHERE</literal> de la requête implique mathématiquement le prédicat de
   l'index.
   <productname>PostgreSQL</productname> n'a pas de méthode sophistiquée de
   démonstration de théorème pour reconnaître que des expressions apparemment
   différentes sont mathématiquement équivalentes. (Non seulement une telle
   méthode générale de démonstration serait extrêmement complexe à créer,
   mais, en plus, elle serait probablement trop lente pour être d'une quelconque
   utilité).
   Le système peut reconnaître des implications d'inégalités simples, par
   exemple <quote>x &lt; 1</quote> implique <quote>x &lt; 2</quote>&nbsp;;
   dans les autres cas,
   la condition du prédicat doit correspondre exactement à une partie de la
   clause <literal>WHERE</literal> de la requête, sans quoi l'index ne peut pas
   être considéré comme utilisable. La correspondance prend place lors de l'exécution
   de la planification de la requête, pas lors de l'exécution. À ce titre, les
   clauses de requêtes à paramètres ne fonctionnent pas avec un index partiel.
   Par exemple, une requête préparée avec un paramètre peut indiquer
   <quote>x &lt; ?</quote> qui n'implique jamais
   <quote>x &lt; 2</quote> pour toutes les valeurs possibles du paramètre.
  </para>

  <para>
   Un troisième usage possible des index partiels ne nécessite pas que
   l'index soit utilisé dans des requêtes. L'idée ici est de créer un index
   d'unicité sur un sous-ensemble de la table, comme dans l'<xref
   linkend="indexes-partial-ex3"/>. Cela permet de mettre en place une unicité
   parmi le sous-ensemble des lignes de la table qui satisfont au prédicat,
   sans contraindre les lignes qui n'y satisfont pas.
  </para>

  <example id="indexes-partial-ex3">
   <title>Mettre en place un index d'unicité partielle</title>

   <para>
    Soit une table qui décrit des résultats de tests.
    On souhaite s'assurer qu'il n'y a qu'une seule entrée
    <quote>succès</quote> (succes) pour chaque combinaison de sujet et de
    résultat, alors qu'il peut y avoir un nombre quelconque d'entrées
    <quote>echec</quote>. Une façon de procéder&nbsp;:
<programlisting>CREATE TABLE tests (
    sujet text,
    resultat text,
    succes boolean,
    ...
);

CREATE UNIQUE INDEX contrainte_tests_reussis ON tests (sujet, resultat)
    WHERE succes;</programlisting>
    C'est une méthode très efficace quand il y a peu de tests réussis et
    beaucoup de tests en échec. Il est aussi possible de permettre une seule
    valeur NULL dans une colonne en créant un index partiel unique avec une
    restriction <literal>IS NULL</literal>.
   </para>
  </example>

  <para>
   Enfin, un index partiel peut aussi être utilisé pour surcharger les
   choix de plan d'exécution de requêtes du système.
   De plus, des jeux de données à distribution particulière peuvent inciter le
   système à utiliser un index alors qu'il ne le devrait pas.
   Dans ce cas, on peut mettre en place l'index de telle façon qu'il ne soit
   pas utilisé pour la requête qui pose problème.
   Normalement, <productname>PostgreSQL</productname> fait des choix d'usage d'index
   raisonnables. Par exemple, il les évite pour rechercher les valeurs communes,
   si bien que l'exemple précédent n'économise que la taille de l'index, il
   n'est pas nécessaire pour éviter l'utilisation de l'index.
   En fait, les choix de plan d'exécution incorrects doivent
   être traités comme des bogues, et être transmis à l'équipe de développement.
  </para>

  <para>
   Mettre en place un index partiel indique une connaissance au
   moins aussi étendue que celle de l'analyseur de requêtes,
   en particulier, savoir quand un index peut être profitable.
   Une telle connaissance nécessite de l'expérience et une bonne
   compréhension du fonctionnement des index de <productname>PostgreSQL</productname>.
   Dans la plupart des cas, les index partiels ne représentent pas un
   gros gain par rapport aux index classiques.
   Dans certains cas, ils sont même contre-productifs, comme dans <xref
   linkend="indexes-partial-ex4"/>.
  </para>

  <example id="indexes-partial-ex4">
   <title>Ne pas utiliser les index partiels comme substitut au partitionnement</title>

   <para>
    Vous pourriez être tenté de créer un gros ensemble d'index partiels
    qui ne se recouvrent pas, par exemple&nbsp;:

<programlisting>
CREATE INDEX mytable_cat_1 ON mytable (data) WHERE category = 1;
CREATE INDEX mytable_cat_2 ON mytable (data) WHERE category = 2;
CREATE INDEX mytable_cat_3 ON mytable (data) WHERE category = 3;
...
CREATE INDEX mytable_cat_<replaceable>N</replaceable> ON mytable (data) WHERE category = <replaceable>N</replaceable>;
   </programlisting>

   C'est une mauvaise idée&nbsp;! Pratiquement à coup sûr, vous seriez mieux avec
   un seul index complet, déclaré ainsi&nbsp;:

   <programlisting>
CREATE INDEX mytable_cat_data ON mytable (category, data);
   </programlisting>

   (Placez la colonne category en premier, pour les raisons décrites dans
   <xref linkend="indexes-multicolumn"/>.) Bien qu'une recherche dans cet
   index plus gros pourrait avoir à descendre quelques niveaux de plus dans
   l'arbre que ce que ferait une recherche dans un index plus petit, cela
   sera certainement moins cher que ce que va coûter l'effort du planificateur
   pour sélectionner le bon index parmi tous les index. Le cœur du problème
   est que le système ne comprend pas la relation entre les index partiels
   et va laborieusement tester chaque index pour vois s'il est applicable
   à la requête courante.
  </para>

  <para>
   Si votre table est suffisamment volumineuse pour qu'un index seul soit
   réellement une mauvaise idée, vous devriez plutôt regarder du côté du
   partitionnement (voir <xref linkend="ddl-partitioning"/>). Avec ce
   mécanisme, le système comprend que les tables et les index ne se croisent
   pas, et donc de meilleures performances sont possibles.
  </para>
 </example>

 <para>
  Plus d'informations sur les index partiels
  sont disponibles dans <xref linkend="ston89b"/>, <xref linkend="olson93"/>
  et <xref linkend="seshadri95"/>.
 </para>
</sect1>

<sect1 id="indexes-index-only-scans">
 <title>Parcours d'index seul et index couvrants</title>

 <indexterm zone="indexes-index-only-scans">
  <primary>index</primary>
  <secondary>parcours d'index seul</secondary>
 </indexterm>
 <indexterm zone="indexes-index-only-scans">
  <primary>parcours d'index seul</primary>
 </indexterm>
 <indexterm zone="indexes-index-only-scans">
  <primary>index</primary>
  <secondary>couvrant</secondary>
 </indexterm>
 <indexterm zone="indexes-index-only-scans">
  <primary>index couvrant</primary>
 </indexterm>

 <para>
  Tous les index dans <productname>PostgreSQL</productname> sont des index
  <firstterm>secondaires</firstterm>, ceci signifiant que chaque index
  est stocké séparément des données de la table (ce qui est appelé le
  <firstterm>heap</firstterm> dans la terminologie
  <productname>PostgreSQL</productname>). Ceci signifie que, dans un parcours
  d'index habituel, chaque récupération de ligne nécessite de récupérer les
  données de l'index et du heap. De plus, bien que les entrées d'un index
  correspondant à une condition <literal>WHERE</literal> indexable soient
  habituellement proches dans l'index, les lignes de la table qu'elles
  référencent peuvent se trouver n'importe où dans le heap. La portion
  accédée du heap pendant un parcours d'index implique donc beaucoup d'accès
  aléatoires au heap, ce qui peut être lent, tout particulièrement sur les
  disques magnétiques traditionnels. (Comme décrit dans <xref
  linkend="indexes-bitmap-scans"/>, les parcours de bitmap essaient de
  diminuer ce coût en réalisant les accès au heap de façon ordonnée, mais
  cette méthode a ses limites.)
 </para>

 <para>
  Pour résoudre ce problème de performances, <productname>PostgreSQL</productname>
  supporte les <firstterm>parcours d'index seul</firstterm>, qui peuvent
  répondre aux requêtes à partir d'un index seul sans aucun accès au heap.
  L'idée de base est de renvoyer les valeurs directement à partir de chaque
  entrée dans l'index au lieu de consulter l'entrée associée dans le heap.
  Il existe deux restrictions fondamentales pour l'utilisation de cette
  méthode&nbsp;:

  <orderedlist>
   <listitem>
    <para>
     Le type d'index doit supporter les parcours d'index seul. Les index
     B-tree peuvent toujours le faire. Les index GiST et SP-GiST supportent
     les parcours d'index seuls uniquement pour certaines classes d'opérateurs,
     mais pas pour les autres. D'autres types d'index n'ont aucun support.
     Le prérequis sous-jacent est que l'index doit enregistrer physiquement,
     ou être capable de reconstruire, les données originales pour chaque
     entrée d'index. En contre-exemple, les index GIN ne supportent pas les
     parcours d'index seul, car chaque entrée d'index contient typiquement
     seulement une partie de la valeur originale.
    </para>
   </listitem>

   <listitem>
    <para>
     La requête doit référencer seulement les colonnes enregistrées dans
     l'index. Par exemple, avec un index sur les colonnes
     <literal>x</literal> et <literal>y</literal> d'une table qui a aussi une
     colonne <literal>z</literal>, ces requêtes peuvent utiliser des parcours
     d'index seul&nbsp;:
     <programlisting>
SELECT x, y FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND y &lt; 42;
     </programlisting>
     alors que ces requêtes ne le peuvent pas&nbsp;:
     <programlisting>
SELECT x, z FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND z &lt; 42;
     </programlisting>
     (Les index fonctionnels et les index partiels compliquent cette règle,
     comme expliquée ci-dessous.)
    </para>
   </listitem>
  </orderedlist>
 </para>

 <para>
  Si ces deux prérequis fondamentaux sont rencontrés, alors toutes les valeurs
  requises par la requête sont disponibles dans l'index, donc un parcours
  d'index seul est physiquement possible. Mais il existe un prérequis
  supplémentaire pour tout parcours de table dans
  <productname>PostgreSQL</productname>&nbsp;: il doit vérifier que chaque
  ligne récupérée est <quote>visible</quote> dans le cadre du snapshot
  MVCC de la requête, comme indiqué dans <xref linkend="mvcc"/>. Les
  informations de visibilité ne sont pas enregistrées dans les entrées de
  l'index, uniquement dans les entrées de la table. Donc a priori, cela
  voudrait dire que chaque récupération de ligne nécessite un accès au heap
  de la table. Et c'est bien le cas si la ligne de la table a été modifiée
  récemment. Néanmoins, pour les données changeant peu, il y a toujours un
  moyen de contourner ce problème. <productname>PostgreSQL</productname> trace
  pour chaque page dans le heap de la table, si toutes les lignes enregistrées
  dans cette page sont suffisamment anciennes pour être visibles par toutes
  les transactions en cours et futures. Cette information est enregistrée dans
  un bit de la <firstterm>carte de visibilité</firstterm> de la table. Un
  parcours d'index seul, pour trouver une entrée d'index candidate, vérifie
  le bit de la carte de visibilité pour la page correspondante du heap. Si
  ce bit est vrai, la ligne est connue comme étant visible et donc la donnée
  peut être renvoyée sans plus de tests. Dans le cas contraire, l'entrée heap
  doit être visitée pour trouver si elle est visible, donc aucune amélioration
  des performances n'est obtenue par rapport à un parcours d'index standard.
  Même dans le cas d'une réussite, cette approche remplace des accès au heap
  par des accès à la carte de visibilité. Comme la carte de visibilité est
  quatre fois plus petite que le heap qu'elle décrit, moins d'accès IO sont
  nécessaires pour accéder à l'information. Dans la plupart des cas, la carte
  de visibilité reste en mémoire tout le temps.
 </para>

 <para>
  En bref, quand un parcours d'index seul est possible d'après les deux
  prérequis fondamentaux, son utilisation ne sera réellement intéressante
  que si une faction significative des blocs du heap de la table ont leur
  bit all-visible configuré. Mais les tables dont une large fraction des
  lignes ne changent pas sont habituellement suffisantes pour que ce type
  de parcours se révèle très utile en pratique.
 </para>

 <para>
  <indexterm>
   <primary><literal>INCLUDE</literal></primary>
   <secondary>dans la définition des index</secondary>
  </indexterm>
  Pour une utilisation efficace de la fonctionnalité du parcours d'index seul,
  vous pourriez choisir de créer un <firstterm>index couvrant</firstterm>, qui
  est un index conçu spécifiquement pour inclure les colonnes nécessaires pour
  un type particulier de requêtes que vous exécutez fréquemment. Comme les
  requêtes ont typiquement besoin de récupérer plus de colonnes que de colonnes
  incluses dans la recherche, <productname>PostgreSQL</productname> vous permet
  de créer un index pour lequel certaines colonnes ne sont qu'une
  <quote>charge</quote> et ne peuvent pas faire partie de la recherche. Ceci se
  fait en ajoutant la clause <literal>INCLUDE</literal> avec la liste des
  colonnes supplémentaires. Par exemple, si vous exécutez fréquemment des requêtes
  comme&nbsp;:
  <programlisting>
SELECT y FROM tab WHERE x = 'key';
  </programlisting>
  l'approche habituelle pour accélérer de telles requêtes est de créer un index
  uniquement sur <literal>x</literal>. Néanmoins, un index défini comme
  <programlisting>
CREATE INDEX tab_x_y ON tab(x) INCLUDE (y);
  </programlisting>
  peut gérer ces requêtes sous la forme de parcours d'index seul, car les
  valeurs de <literal>y</literal> peuvent être obtenues de l'index sans
  visiter la table.
 </para>

 <para>
  Comme la colonne <literal>y</literal> ne fait pas partie des clés
  de recherche de l'index, elle n'a pas besoin d'être d'un type de donnée
  que l'index peut gérer&nbsp;; la valeur est simplement enregistrée dans
  l'index et n'est pas interprétée par la machinerie de l'index. De plus,
  si l'index est un index unique, autrement dit
  <programlisting>
CREATE UNIQUE INDEX tab_x_y ON tab(x) INCLUDE (y);
  </programlisting>
  la condition d'unicité s'applique uniquement à la colonne
  <literal>x</literal>, et non pas à la combinaison
  <literal>x</literal> et <literal>y</literal>. (Une clause
  <literal>INCLUDE</literal> peut aussi être écrite dans les contraintes
  <literal>UNIQUE</literal> et <literal>PRIMARY KEY</literal>, fournissant
  une syntaxe alternative pour configurer ce type d'index.)
 </para>

 <para>
  Il est conseillé d'être conservateur sur l'ajout de colonnes non-clés dans
  un index, tout spécialement les colonnes volumineuses. Si un enregistrement
  d'index dépasse la taille maximale autorisée pour ce type d'index,
  l'insertion de données échouera. Dans tous les cas, les colonnes non-clés
  dupliquent les données de la table et augmentent la taille de l'index, ce
  qui peut ralentir les recherches. Et rappelez-vous qu'il y a peu d'intérêt
  d'inclure des colonnes non-clés dans un index, sauf si la table change très
  doucement pour qu'un parcours d'index seul n'ait pas besoin d'accéder à la
  table. Si la ligne de la table doit être visitée, cela ne coûte rien de
  récupérer la valeur de la colonne dans la table. Les autres restrictions
  sont que les expressions ne sont actuellement pas supportées dans les
  colonnes incluses, et que seuls les index B-tree et GiST supportent actuellement
  les colonnes incluses.
 </para>

 <para>
  Avant que <productname>PostgreSQL</productname> ne dispose de la
  fonctionnalité <literal>INCLUDE</literal>, les utilisateurs créaient
  parfois des index couvrants en ajoutant les colonnes non-clés comme des
  colonnes d'index habituels, par exemple
  <programlisting>
CREATE INDEX tab_x_y ON tab(x, y);
  </programlisting>
  même s'ils n'avaient jamais l'intention d'utiliser <literal>y</literal>
  comme partie de la clause <literal>WHERE</literal>. Ceci fonctionne bien
  tant que les colonnes supplémentaires sont les dernières colonnes&nbsp;; il
  est déconseillé de les ajouter comme premières colonnes pour les raisons
  expliquées dans <xref linkend="indexes-multicolumn"/>. Néanmoins, cette
  méthode ne supporte pas le cas où vous voulez que l'index assure l'unicité
  des colonnes clés.
 </para>

 <para>
  La <firstterm>troncature de suffixe</firstterm> supprime toujours les
  colonnes non-clé des niveaux supérieurs du B-Tree. En tant que colonnes de
  charge utile, elles ne sont jamais utilisées pour guider des parcours
  d'index. Le processus de troncature supprime également une ou plusieurs
  colonne(s) clé quand le reste du préfixe de colonnes(s) se montre suffisant
  pour décrire les tuples du plus bas niveau de B-Tree. Dans la pratique, les
  index couvrants sans clause <literal>INCLUDE</literal> évitent souvent de
  stocker les colonnes qui sont de la charge utile effective dans les niveaux
  supérieurs. Cependant, définir explicitement les colonnes de charge utile
  comme colonnes non-clé permet de conserver des tuples de petite taille dans
  les niveaux supérieurs <emphasis>de manière fiable</emphasis>.
 </para>

 <para>
  En principe, les parcours d'index seul peuvent être utilisés avec des index
  fonctionnels. Par exemple, avec un index sur <literal>f(x)</literal> où
  <literal>x</literal> est une colonne de table, il est possible de
  l'utiliser avec la requête suivante&nbsp;:
  <programlisting>
SELECT f(x) FROM tab WHERE f(x) &lt; 1;
  </programlisting>
  pour un parcours d'index seul&nbsp;; et c'est très intéressant si
  <literal>f()</literal> est une fonction coûteuse à l'exécution. Néanmoins,
  l'optimiseur de <productname>PostgreSQL</productname> n'est pas très
  intelligent actuellement avec de tels cas. Il considère qu'une requête
  est réalisable avec un parcours d'index seul uniquement quand toutes les
  <emphasis>colonnes</emphasis> nécessaires pour la requête sont disponibles
  à partir de l'index. Dans cet exemple, <literal>x</literal> n'est pas
  nécessaire, sauf dans le contexte <literal>f(x)</literal>, mais le
  planificateur ne le remarque pas et conclut qu'un parcours d'index seul
  n'est pas possible. Si un parcours d'index seul semble suffisamment
  intéressant, ceci peut être contourné en ajoutant <literal>x</literal>
  comme colonne incluse, par exemple
  <programlisting>
CREATE INDEX tab_f_x ON tab (f(x)) INCLUDE (x);
  </programlisting>
  Si le but
  est d'éviter de recalculer <literal>f(x)</literal>, une autre astuce est que
  l'optimiseur ne fera pas forcément une correspondance entre les
  utilisations de <literal>f(x)</literal> qui ne sont pas dans les clauses
  <literal>WHERE</literal> indexables et la colonne de l'index. Généralement,
  le test sera efficace pour les requêtes simples comme indiquées ci-dessus,
  mais pas pour les requêtes qui impliquent des jointures. Ces déficiences
  pourraient être corrigées dans les versions futures de
  <productname>PostgreSQL</productname>.
 </para>

 <para>
  Les index partiels ont aussi des interactions intéressantes avec les parcours
  d'index seul. Considérez l'index partiel indiqué dans <xref
  linkend="indexes-partial-ex3"/>&nbsp;:
  <programlisting>
CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;
  </programlisting>
  En principe, nous pouvons faire un parcours d'index seul sur cet index pour
  satisfaire une requête du type&nbsp;:
  <programlisting>
SELECT target FROM tests WHERE subject = 'some-subject' AND success;
  </programlisting>
  Mais il reste un problème&nbsp;: la clause <literal>WHERE</literal> fait
  référence à <literal>success</literal> qui n'est pas disponible comme colonne
  de résultat de l'index. Néanmoins, un parcours d'index seul est possible
  parce que le plan n'a pas besoin de vérifier de nouveau cette partie de la
  clause <literal>WHERE</literal> à l'exécution&nbsp;: toutes les entrées
  trouvées dans l'index ont obligatoirement <literal>success = true</literal>,
  donc il n'est pas nécessaire de le vérifier explicitement dans le plan. Les
  versions 9.6 et ultérieures de <productname>PostgreSQL</productname>
  reconnaîtront de tels cas et permettront aux parcours d'index seul d'être
  générés, mais les anciennes versions ne le pourront pas.
 </para>
</sect1>

<sect1 id="indexes-opclass">
 <title>Classes et familles d'opérateurs</title>

 <indexterm zone="indexes-opclass">
  <primary>classe d'opérateurs</primary>
 </indexterm>

 <!--  <indexterm zone="indexes-opfamily"> -->
 <indexterm>
  <primary>famille d'opérateurs</primary>
 </indexterm>

 <para>
  Une définition d'index peut indiquer une <firstterm>classe
   d'opérateurs</firstterm> pour chaque colonne de l'index.
  <synopsis>CREATE INDEX <replaceable>nom</replaceable> ON <replaceable>table</replaceable> (<replaceable>colonne</replaceable> <replaceable>classe_operateur</replaceable> [ ( <replaceable>options classe opérateur</replaceable> ) ] <optional><replaceable>options de tri</replaceable></optional> <optional>, ...</optional>);</synopsis>

   La classe d'opérateurs identifie les opérateurs que l'index doit utiliser
   sur cette colonne. Par exemple, un index B-tree sur une colonne de type
   <type>int4</type> utilise la classe <literal>int4_ops</literal>.
   Cette classe d'opérateurs comprend des fonctions de comparaison pour les
   valeurs de type <type>int4</type>.
   En pratique, la classe d'opérateurs par défaut pour le type de données de la
   colonne est généralement suffisante. Les classes d'opérateurs sont utiles pour
   certains types de données, pour lesquels il peut y avoir plus d'un
   comportement utile de l'index.
   Par exemple, une donnée de type nombre complexe peut être classée
   par sa valeur absolue, ou par sa partie entière.
   Cela peut s'obtenir en définissant deux classes d'opérateurs pour ce
   type de données et en sélectionnant la bonne classe à la création de l'index.
   La classe d'opérateurs détermine l'ordre de tri basique (qui peut ensuite
   être modifié en ajoutant des options de tri comme
   <literal>COLLATE</literal>, <literal>ASC</literal>/<literal>DESC</literal> et/ou
   <literal>NULLS FIRST</literal>/<literal>NULLS LAST</literal>).
  </para>

  <para>
   Il y a quelques classes d'opérateurs en plus des classes par défaut&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Les classes d'opérateurs <literal>text_pattern_ops</literal>,
      <literal>varchar_pattern_ops</literal> et
      <literal>bpchar_pattern_ops</literal> supportent les index B-tree sur
      les types <type>text</type>, <type>varchar</type> et <type>char</type>,
      respectivement. À la différence des classes d'opérateurs par défaut,
      les valeurs sont comparées strictement caractère par caractère plutôt
      que suivant les règles de tri spécifiques à la localisation.
      Cela rend ces index utilisables pour des requêtes qui effectuent des
      recherches sur des motifs (<literal>LIKE</literal> ou des expressions
      régulières POSIX) quand la base de données n'utilise pas la locale standard
      <quote>C</quote>.
      Par exemple, on peut indexer une colonne <type>varchar</type>
      comme ceci&nbsp;:
<programlisting>CREATE INDEX test_index ON test_table (col varchar_pattern_ops);</programlisting>
      Il faut créer un index avec la classe d'opérateurs par
      défaut pour que les requêtes qui utilisent une comparaison <literal>&lt;</literal>,
      <literal>&lt;=</literal>, <literal>&gt;</literal> ou <literal>&gt;=</literal>
      ordinaire utilisent un index. De telles requêtes ne peuvent pas utiliser
      les classes d'opérateurs
      <literal><replaceable>xxx</replaceable>_pattern_ops</literal>.
      Néanmoins, des comparaisons d'égalité ordinaires peuvent utiliser ces
      classes d'opérateurs. Il est possible de créer plusieurs index sur la
      même colonne avec différentes classes d'opérateurs.
      Si la locale C est utilisée, les classes
      d'opérateurs <literal><replaceable>xxx</replaceable>_pattern_ops</literal>
      ne sont pas nécessaires, car un index avec une classe d'opérateurs
      par défaut est utilisable pour
      les requêtes de correspondance de modèles dans la locale C.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
    Les requêtes suivantes montrent les classes d'opérateurs prédéfinies&nbsp;:

<programlisting>SELECT am.amname AS index_method,
       opc.opcname AS opclass_name,
       opc.opcintype::regtype AS indexed_type,
       opc.opcdefault AS is_default
    FROM pg_am am, pg_opclass opc
    WHERE opc.opcmethod = am.oid
    ORDER BY index_method, opclass_name;</programlisting>

  </para>

  <para>
   Une classe d'opérateurs n'est qu'un sous-ensemble d'une structure plus
   large appelée <firstterm>famille d'opérateurs</firstterm>. Dans les cas où
   plusieurs types de données ont des comportements similaires, il est
   fréquemment utile de définir des opérateurs identiques pour plusieurs types de
   données et d'autoriser leur utilisation avec des index. Pour cela, les
   classes d'opérateurs de chacun de ces types doivent être groupés dans la
   même famille d'opérateurs. Les opérateurs intertypes sont membres de la
   famille, mais ne sont pas associés avec une seule classe de la famille.
  </para>

  <para>
    Cette version étendue de la requête précédente montre la famille d'opérateurs
    à laquelle appartient chaque classe d'opérateurs&nbsp;:
<programlisting>
SELECT am.amname AS index_method,
       opc.opcname AS opclass_name,
       opf.opfname AS opfamily_name,
       opc.opcintype::regtype AS indexed_type,
       opc.opcdefault AS is_default
    FROM pg_am am, pg_opclass opc, pg_opfamily opf
    WHERE opc.opcmethod = am.oid AND
          opc.opcfamily = opf.oid
    ORDER BY index_method, opclass_name;
  </programlisting>
 </para>

 <para>
  Cette requête affiche toutes les familles d'opérateurs définies et tous les
  opérateurs inclus dans chaque famille&nbsp;:
  <programlisting>
SELECT am.amname AS index_method,
       opf.opfname AS opfamily_name,
       amop.amopopr::regoperator AS opfamily_operator
    FROM pg_am am, pg_opfamily opf, pg_amop amop
    WHERE opf.opfmethod = am.oid AND
          amop.amopfamily = opf.oid
    ORDER BY index_method, opfamily_name, opfamily_operator;
  </programlisting>
 </para>

 <tip>
  <para>
   <xref linkend="app-psql"/> dispose des méta-commandes
   <command>\dAc</command>, <command>\dAf</command> et
   <command>\dAo</command>, qui fournissent des versions un peu plus
   sophistiquées de ces requêtes.
  </para>
 </tip>
</sect1>


<sect1 id="indexes-collations">
 <title>Index et collationnements</title>

 <para>
  Un index peut supporter seulement un collationnement par colonne d'index.
  Si plusieurs collationnements ont un intérêt, plusieurs index pourraient
  être nécessaires.
 </para>

 <para>
  Regardez ces requêtes&nbsp;:
  <programlisting>
CREATE TABLE test1c (
    id integer,
    content varchar COLLATE "x"
);

CREATE INDEX test1c_content_index ON test1c (content);
  </programlisting>
  L'index utilise automatiquement le collationnement de la colonne
  sous-jacente. Donc une requête de la forme
  <programlisting>
SELECT * FROM test1c WHERE content &gt; <replaceable>constant</replaceable>;
  </programlisting>
  peut utiliser l'index, car la comparaison utilisera par défaut le
  collationnement de la colonne. Néanmoins, cet index ne peut pas accélérer
  les requêtes qui impliquent d'autres collationnements. Donc, pour des
  requêtes de cette forme
  <programlisting>
SELECT * FROM test1c WHERE content &gt; <replaceable>constant</replaceable> COLLATE "y";
  </programlisting>
  un index supplémentaire, supportant le collationnement <literal>"y"</literal>
  peut être ajouté ainsi&nbsp;:
  <programlisting>
CREATE INDEX test1c_content_y_index ON test1c (content COLLATE "y");
  </programlisting>
 </para>
</sect1>


<sect1 id="indexes-examine">
 <title>Examiner l'utilisation des index</title>

 <indexterm zone="indexes-examine">
  <primary>index</primary>
  <secondary>examiner l'utilisation</secondary>
 </indexterm>

 <para>
  Bien que les index de <productname>PostgreSQL</productname> n'aient pas besoin
  de maintenance ou d'optimisation, il est important de s'assurer que les
  index sont effectivement utilisés sur un système en production.
  On vérifie l'utilisation d'un index pour une requête particulière avec
  la commande <xref linkend="sql-explain"/>.
  Son utilisation dans notre cas est expliquée dans la
  <xref linkend="using-explain"/>.
  Il est aussi possible de rassembler des statistiques globales
  sur l'utilisation des index sur un serveur en cours de fonctionnement,
  comme décrit dans la <xref linkend="monitoring-stats"/>.
 </para>

 <para>
  Il est difficile de donner une procédure générale pour déterminer
  les index à créer. Plusieurs cas typiques ont été
  cités dans les exemples précédents.
  Une bonne dose d'expérimentation est souvent nécessaire dans de nombreux cas.
  Le reste de cette section donne quelques pistes.
 </para>

 <itemizedlist>
  <listitem>
   <para>
    La première chose à faire est de lancer
    <xref linkend="sql-analyze"/>.
    Cette commande collecte les informations sur la distribution des
    valeurs dans la table. Cette information est nécessaire pour estimer
    le nombre de lignes retournées par une requête. L'optimiseur
    de requêtes en a besoin pour donner des coûts réalistes aux différents
    plans de requêtes possibles. En l'absence de statistiques réelles,
    le système utilise quelques valeurs par défaut, qui ont toutes les chances
    d'être inadaptées. Examiner l'utilisation des index par une application
    sans avoir lancé <command>ANALYZE</command> au préalable est, de ce fait,
    peine perdue. Voir <xref linkend="vacuum-for-statistics"
     /> et <xref linkend="autovacuum"
     /> pour plus d'informations.
   </para>
  </listitem>

  <listitem>
   <para>
    Utiliser des données réelles pour l'expérimentation. Utiliser des
    données de test pour mettre en place des index permet
    de trouver les index utiles pour les données de test,
    mais c'est tout.
   </para>

   <para>
    Il est particulièrement néfaste d'utiliser des jeux de données
    très réduits.
    Alors qu'une requête sélectionnant 1000 lignes parmi 100000 peut
    utiliser un index, il est peu probable qu'une requête sélectionnant 1 ligne
    dans une table de 100 le fasse, parce que les 100 lignes
    tiennent probablement dans une seule page sur le disque, et qu'il n'y a
    aucun plan d'exécution qui puisse aller plus vite que la lecture
    d'une seule page.
   </para>

   <para>
    Être vigilant en créant des données de test. C'est souvent
    inévitable quand l'application n'est pas encore en production.
    Des valeurs très similaires, complètement aléatoires, ou
    insérées déjà triées peuvent modifier la distribution des données et
    fausser les statistiques.
   </para>
  </listitem>

  <listitem>
   <para>
    Quand les index ne sont pas utilisés, il peut être utile pour
    les tests de forcer leur utilisation. Certains paramètres d'exécution
    du serveur peuvent interdire certains types de plans (voir
    la <xref linkend="runtime-config-query-enable"/>).
    Par exemple, en interdisant les lectures séquentielles de tables
    <varname>enable_seqscan</varname>) et les jointures à boucles imbriquées
    (<varname>enable_nestloop</varname>), qui sont les deux plans les plus
    basiques, on force le système à utiliser un plan différent.
    Si le système continue néanmoins à choisir une lecture séquentielle
    ou une jointure à boucles imbriquées, alors il y a probablement
    une raison plus fondamentale qui empêche l'utilisation de l'index&nbsp;;
    la condition peut, par exemple, ne pas correspondre à l'index.
    (Les sections précédentes expliquent quelles sortes de requêtes peuvent
    utiliser quelles sortes d'index.)
   </para>
  </listitem>

  <listitem>
   <para>
    Si l'index est effectivement utilisé en forçant son utilisation,
    alors il y a deux possibilités&nbsp;: soit le système a raison et
    l'utilisation de l'index est effectivement inappropriée, soit les
    coûts estimés des plans de requêtes ne reflètent pas la réalité.
    Il faut alors comparer la durée de la requête avec et sans
    index. La commande <command>EXPLAIN ANALYZE</command> peut être
    utile pour cela.
   </para>
  </listitem>

  <listitem>
   <para>
    S'il apparaît que les estimations de coûts sont fausses, il y a
    de nouveau deux possibilités. Le coût total est calculé à partir du
    coût par ligne de chaque n&oelig;ud du plan, multiplié par l'estimation de
    sélectivité du n&oelig;ud de plan.
    Le coût estimé des n&oelig;uds de plan peut être ajusté avec
    des paramètres d'exécution (décrits dans la <xref
    linkend="runtime-config-query-constants"/>).
    Une estimation de sélectivité inadaptée est due à des statistiques
    insuffisantes. Il peut être possible de les améliorer en
    optimisant les paramètres de collecte de statistiques.
    Voir <xref linkend="sql-altertable"/>.
   </para>

   <para>
    Si les coûts ne peuvent pas être ajustés à une meilleure représentation de la
    réalité, alors il faut peut-être forcer l'utilisation de l'index
    explicitement.
    Il peut aussi s'avérer utile de contacter les développeurs de
    <productname>PostgreSQL</productname> afin qu'ils examinent le problème.
   </para>
  </listitem>
 </itemizedlist>
</sect1>
</chapter>
