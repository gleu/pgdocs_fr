<?xml version="1.0" encoding="UTF-8"?>
<!-- doc/src/sgml/amcheck.sgml -->

<sect1 id="amcheck" xreflabel="amcheck">
 <title>amcheck</title>

 <indexterm zone="amcheck">
  <primary>amcheck</primary>
 </indexterm>

 <para>
  Le module <filename>amcheck</filename> fournit des fonctions vous permettant
  de vérifier la cohérence logique de la structure des relations.  Si la structure
  semble valide, aucune erreur n'est levée.
 </para>

 <para>
  Les fonctions vérifient diverses <emphasis>propriétés invariables</emphasis>
  dans la structure de la représentation de certains relations. La justesse des
  fonctions permettant l'accès aux données durant les parcours d'index et
  d'autres opération importantes reposent sur le fait que ces propriétés
  invariables soient toujours vraies.  Par exemple, certaines fonctions
  vérifient, entre autres choses, que toutes les pages d'index B-Tree ont leurs
  éléments dans un ordre <quote>logique</quote> (par exemple, pour des index
  B-Tree sur un type  <type>text</type>, les lignes de l'index devraient être
  triées dans l'ordre alphabétique défini par la collation).  Si, quelque soit
  la raison,  cette propriété invariable spécifique n'est plus vérifiée, il
  faut s'attendre à ce que des recherches binaires sur la page affectée
  renseignent de manière erronée les parcours d'index, avec pour conséquence
  des résultats erronnés aux requêtes SQL.
 </para>
 <para>
  La vérification est réalisée en utilisant les même précédures que celles
  utilisées par les parcours d'index eux-même, qui peuvent très bien être du
  code utilisateur pour une classe d'opérateur.  Par exemple, la vérification
  d'index B-Tree s'appuie sur les comparaisons faites avec une ou plusieurs
  routines pour la fonction de support 1.  See <xref linkend="xindex-support"/>
  pour plus de détail sur les fonctions de support des classes d'opérateur.
 </para>
 <para>
  Les fonctions du module <filename>amcheck</filename> ne peuvent être
  exécutées que par des super utilisateurs.
 </para>

 <sect2>
  <title>Fonctions</title>

  <variablelist>
   <varlistentry>
    <term>
     <function>bt_index_check(index regclass, heapallindexed boolean) returns void</function>
     <indexterm>
      <primary>bt_index_check</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
         <function>bt_index_check</function> que sa cible, un index B-Tree,
      respecte une vériété de propriétés invariables.  Exemple d'utilisation :
<screen>
test=# SELECT bt_index_check(index =&gt; c.oid, heapallindexed =&gt; i.indisunique),
               c.relname,
               c.relpages
FROM pg_index i
JOIN pg_opclass op ON i.indclass[0] = op.oid
JOIN pg_am am ON op.opcmethod = am.oid
JOIN pg_class c ON i.indexrelid = c.oid
JOIN pg_namespace n ON c.relnamespace = n.oid
WHERE am.amname = 'btree' AND n.nspname = 'pg_catalog'
-- Ignore les tables temporaires, qui peuvent appartenir à d'autres sessions
AND c.relpersistence != 't'
-- La fonction peut renvoyer une erreur si cela est omis :
AND c.relkind = 'i' AND i.indisready AND i.indisvalid
ORDER BY c.relpages DESC LIMIT 10;
 bt_index_check |             relname             | relpages 
----------------+---------------------------------+----------
                | pg_depend_reference_index       |       43
                | pg_depend_depender_index        |       40
                | pg_proc_proname_args_nsp_index  |       31
                | pg_description_o_c_o_index      |       21
                | pg_attribute_relid_attnam_index |       14
                | pg_proc_oid_index               |       10
                | pg_attribute_relid_attnum_index |        9
                | pg_amproc_fam_proc_index        |        5
                | pg_amop_opr_fam_index           |        5
                | pg_amop_fam_strat_index         |        5
(10 rows)
</screen>
      Cet exemple montre une session qui effectue une vérification de chacun
      des index sur le catalogue dans la base de données <quote>test</quote>.
      Seul le détail des 10 plus gros index vérifiés est affiché. La
      vérification de la présence des lignes dans la table ainsi que des
      lignes dans l'index est requis uniquement pour les index d'unicité.
      Puisqu'aucune erreur n'est retournée, tous les index testés semblent
      être cohérent au niveau logique.  Bien évidemment, cette requête
      pourrait être facilement modifiée pour appeler
      <function>bt_index_check</function> sur chacun des index présents dans
      la base de données pour lesquels la vérification est supportée.
     </para>
     <para>
      <function>bt_index_check</function> acquiert un
      <literal>AccessShareLock</literal> sur l'index cible ainsi que sur la
      relation à laquelle il appartient.  Ce niveau de verrouillage est le
      même que celui acquis sur les relations lors d'une simple requête
      <literal>SELECT</literal>. <function>bt_index_check</function> ne
      vérifie pas les propriétés invariantes qui englobent les relations
      enfant/parent, mais vérifiera la présence de toutes les lignes de la
      table et des lignes d'index à l'intérieur de l'index quand
      <parameter>heapallindexed</parameter> vaut <literal>true</literal>.
      Quand un test léger, de routine, pour détecter des problèmes de
      corruption est nécessaire sur un environnement de production, utiliser
      <function>bt_index_check</function> offre généfalement le meilleur
      compromis entre la minutie de la vérification et l'impact limité sur les
      performances de l'application ainsi que sa disponibilité.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>bt_index_parent_check(index regclass, heapallindexed boolean) returns void</function>
     <indexterm>
      <primary>bt_index_parent_check</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>bt_index_parent_check</function> teste que sa cible, un index
      B-Tree, respecte un certain nombre de propriétés invariantes. En option,
      quand l'argument <parameter>heapallindexed</parameter> vaut
      <literal>true</literal>, la fonction vérifie la présence de toutes les
      lignes dans la table, et la présence de tous les liens dans la structure
      de l'index. Les vérifications réalisables par
      <function>bt_index_parent_check</function> sont un sur-ensemble des
      vérifications réalisées par <function>bt_index_check</function>.
      On peut voir <function>bt_index_parent_check</function> comme une version
      plus minitieuse de <function>bt_index_check</function> :
      contrairement à <function>bt_index_check</function>,
      <function>bt_index_parent_check</function> vérifie également les
      propriétés invariantes qui englobent les relations parent/enfant.
      <function>bt_index_parent_check</function>
      respecte la convention habituelle qui consiste à retourner une erreur si
      une incohérence ou tout autre problème est détecté.
     </para>
     <para>
      Un verrou de type <literal>ShareLock</literal> est requis sur l'index
      ciblé par <function>bt_index_parent_check</function> (un verrou de type
      <literal>ShareLock</literal> est également acquis sur la relation
      associée).  Ces verrous empêchent des modifications concurrentes par des
      commandes <command>INSERT</command>, <command>UPDATE</command>, et
      <command>DELETE</command>  Les verrous empêchent également la relation
      associée d'être traitée de manière concurrente par
      <command>VACUUM</command>, ainsi que toute autre commande qui n'est pas
      un ordre DML.  Il est à noter que cette fonction conserve les verrous
      uniquement durant son exécution et non pas durant l'intégralité de la
      transaction.
     </para>
     <para>
      La vérification supplémentaire de
      <function>bt_index_parent_check</function> est plus apte à détecter
      différents cas pathologiques.  Ces cas peuvent impliquer une classe
      d'opérateur B-Tree implémentée de manière incorrecte utilisée pout
      l'index vérifié, ou, hypothétiquement, des bugs non encore découverts
      dans le code de la méthode d'accès assocée à cet index B-Tree.  Il est à
      noter que <function>bt_index_parent_check</function> ne peut pas être
      utilisé lorsque le mode Hot Standby est activé (c'est-à-dire, sur un
      serveur secondaire disponible en lecture seule), contrairement à
      <function>bt_index_check</function>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2>
  <title>Optional <parameter>heapallindexed</parameter> verification</title>
 <para>
  When the <parameter>heapallindexed</parameter> argument to
  verification functions is <literal>true</literal>, an additional
  phase of verification is performed against the table associated with
  the target index relation.  This consists of a <quote>dummy</quote>
  <command>CREATE INDEX</command> operation, which checks for the
  presence of all hypothetical new index tuples against a temporary,
  in-memory summarizing structure (this is built when needed during
  the basic first phase of verification).  The summarizing structure
  <quote>fingerprints</quote> every tuple found within the target
  index.  The high level principle behind
  <parameter>heapallindexed</parameter> verification is that a new
  index that is equivalent to the existing, target index must only
  have entries that can be found in the existing structure.
 </para>
 <para>
  The additional <parameter>heapallindexed</parameter> phase adds
  significant overhead: verification will typically take several times
  longer.  However, there is no change to the relation-level locks
  acquired when <parameter>heapallindexed</parameter> verification is
  performed.
 </para>
 <para>
  The summarizing structure is bound in size by
  <varname>maintenance_work_mem</varname>.  In order to ensure that
  there is no more than a 2% probability of failure to detect an
  inconsistency for each heap tuple that should be represented in the
  index, approximately 2 bytes of memory are needed per tuple.  As
  less memory is made available per tuple, the probability of missing
  an inconsistency slowly increases.  This approach limits the
  overhead of verification significantly, while only slightly reducing
  the probability of detecting a problem, especially for installations
  where verification is treated as a routine maintenance task.  Any
  single absent or malformed tuple has a new opportunity to be
  detected with each new verification attempt.
 </para>

 </sect2>

 <sect2>
  <title>Utiliser <filename>amcheck</filename> efficacement</title>

 <para>
  <filename>amcheck</filename> peut être efficace pour détecter différents
  types de modes d'échec que les <link
      linkend="app-initdb-data-checksums"><application>sommes de contrôle de
  page </application></link> n'arriveront jamais à détecter.  Cela inclut :

  <itemizedlist>
   <listitem>
    <para>
     Les incohérences structurelles causée par des implémentations incorrectes
     de classe d"opérateur.
    </para>
    <para>
     Cela inclue également des problèmes causés par le changement des règles de
     comparaison des collations du système d'exploitation.  Les comparaisons
     des données d'un type ayant une collation comme <type>text</type> doivent
     être immuables (tout comme toutes les autres comparaisons utilisées pour
     les parcours d'index B-Tree doivent être immuables), ce qui implique que
     les règles de collation du système d'exploitation ne dois jamais changer.
     Bien que cela soit rare, des mises à jour des règles des collations du
     système d'exploitation peuvent causer ces problèmes.  Plus généralement,
     une incohérence dans l'ordre de collation entre un serveur primaire et son
     réplicat est impliqué, peut-être parce que la version
     <emphasis>major</emphasis> du système d'exploitation utilisée était
     incohérente.  De telles incohérences ne surviendront généralement que sur
     des serveur secondaires, et ne pourront par conséquent être détectées que
     sur des serveurs secondaires.
    </para>
    <para>
     Si un tel problème survient, il se peut que cela n'affecte par
     individuellement chaque index qui utilise le tri d'une collation affectée,
     tout simplement car les valeurs <emphasis>indexée</emphasis> pourraient
     avoir le même ordre de tri absolu indépendamment des incohérences
     comportementales.  Voir
     <xref linkend="locale"/> et <xref linkend="collation"/> pour plus de
     détails sur comment <productname>PostgreSQL</productname> utilise les
     locales et collations du système d'exploitation.
    </para>
   </listitem>
   <listitem>
    <para>
     Des incohérences dans la structure entre les index et les tables indexées
     (lors que la vérification <parameter>heapallindexed</parameter> est
     réalisée).
    </para>
    <para>
     Il n'y a pas de vérification avec la table initiale en temps normal. Les
     symptômes d'une corrution de la table peuvent être subtils.
    </para>
   </listitem>
   <listitem>
     <para>
     Une corruption causée par un hypothétique bug non encore découvert dans
     l'implémentation associée à la méthode d'accès, au code effectuant le
     tri ou à la gestion transactionnelle.
    </para>
    <para>
     La vérification automatique de l'intégrité structurelle des index joue un
     rôle sur les principaux tests des fonctionnalités nouvelles ou proposées
     dans <productname>PostgreSQL</productname> qui pourraient possiblement
     autoriser l'introduction d'incohérence logiques. La vérification de la
     structure de la table et des informations de visibilité et de statut des
     transactions associées joue un rôle similaire. Une stratégie de test
     évidente est d'appeler les fonctions d'<filename>amcheck</filename> de
     manière continue en même temps que les tests de régression standard sont
     lancés.  Voir <xref
     linkend="regress-run"/> pour plus de détail sur commencer lancer les
    tests.
    </para>
   </listitem>
   <listitem>
    <para>
     Les défauts du système de fichiers ou du sous système de stockage quand
     les vérifications des sommes de contrôles ne sont pas activées.
    </para>
    <para>
     Il est à noter que <filename>amcheck</filename> examine les pages telles
     que représentées dans des tampons en mémoire partagée au moment de la
     vérification s'il y a seulement un accès en mémoire partagée lors de
     l'accès au bloc.  Par conséquent, <filename>amcheck</filename> n'examine
     pas forcément les données lues depuis le système de fichiers au moment de
     la vérification.  De plus, quand les sommes de contrôles sont activées,
     <filename>amcheck</filename> peut lever une erreur de somme de contrôle
     incorrecte quand un block corrompu est lu vers un tampon.
    </para>
   </listitem>
   <listitem>
    <para>
     Les corruptions causée par une mémoire RAM défaillante, et plus largement
     le sous système mémoire ainsi que le système d'exploitation.
    </para>
    <para>
     <productname>PostgreSQL</productname> ne protège pas contre les erreurs
     mémoire corrigibles et il est supposé que vous utilisez de la mémoire RAM
     utilisant le standard de l'instrie Error Correcting Codes (ECC) ou une
     meilleure protection.  Cependant, la mémoire ECC est typiquement immunisée
     uniquement contre les erreurs d'un seul bit, et il ne faut pas partir du
     principe que ce type de mémoire fournit une protection
     <emphasis>absolue</emphasis> contre les défaillances résultant en une
     corruption mémoire.
    </para>
    <para>
     Quand la vérification <parameter>heapallindexed</parameter> est réalisée,
     il y a une chance fortement accrue de détecter des erreurs d'un bit car
     l'égalité binaire stricte est testée et les attributs indexés de la table
     sont testés.
    </para>
   </listitem>
  </itemizedlist>
  De manière générale, <filename>amcheck</filename> ne peut que prouver la
  présence d'une corruption; il ne peut pas en prouver l'absence.
 </para>

 </sect2>
 <sect2>
  <title>Réparer une corruption</title>
 <para>
  Aucune erreur concernant une corruption remontée par
  <filename>amcheck</filename> ne devrait être un faux positif.
  <filename>amcheck</filename> remonte des erreurs dans le cas où des
  conditions, par définition, ne devraient jamais arriver, et par conséquent
  une analyse minutieuse des erreurs remontées par <filename>amcheck</filename>
  est souvent nécessaire.
 </para>
 <para>
  Il n'y a pas de méthode générale pour réparer les problèmes que
  <filename>amcheck</filename> détecte.  Une explication de la cause principale
  menant à ce que la propriété invariable soit violée devrait être étudiée.
  <xref linkend="pageinspect"/> pourrait jouer un rôle utile dans le
  diagnostique de la corruption qu'<filename>amcheck</filename> détecte.  Un
  <command>REINDEX</command> pourrait ne pas être efficace pour réparer la
  corruption.
 </para>

 </sect2>

</sect1>
