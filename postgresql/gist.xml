<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="gist">
 <title>Index GiST</title>

 <indexterm>
  <primary>index</primary>
  <secondary>GiST</secondary>
 </indexterm>

 <sect1 id="gist-intro">
  <title>Introduction</title>

  <para>
   <acronym>GiST</acronym> est un acronyme de <foreignphrase>Generalized
    Search Tree</foreignphrase>, c'est-à-dire arbre de recherche généralisé.
   C'est une méthode d'accès balancée à structure de type arbre,
   qui agit comme un modèle de base dans lequel il est possible d'implanter
   des schémas d'indexage arbitraires. B-trees, R-trees et de nombreux autres
   schémas d'indexage peuvent être implantés en <acronym>GiST</acronym>.
  </para>

  <para>
   <acronym>GiST</acronym> a pour avantage d'autoriser le développement
   de types de données personnalisés avec les méthodes d'accès appropriées, par
   un expert en types de données, plutôt que par un expert en
   bases de données.
  </para>

  <para>
   Quelques informations disponibles ici sont dérivées du <ulink
   url="http://gist.cs.berkeley.edu/">site web</ulink> du projet d'indexage
   GiST de l'université de Californie à Berkeley et de la <ulink
   url="http://www.sai.msu.su/~megera/postgres/gist/papers/concurrency/access-methods-for-next-generation.pdf.gz">thèse
    de Marcel Kornacker,
    Méthodes d'accès pour les systèmes de bases de données de la prochaine
    génération</ulink>. L'implantation <acronym>GiST</acronym> de
   <productname>PostgreSQL</productname> est principalement maintenu
   par Teodor Sigaev et Oleg Bartunov. Leur <ulink
   url="http://www.sai.msu.su/~megera/postgres/gist/">site web</ulink> fournit
   de plus amples informations.
  </para>

 </sect1>

 <sect1 id="gist-builtin-opclasses">
  <title>Classes d'opérateur internes</title>

  <para>
   La distribution de <productname>PostgreSQL</productname> inclut les classes
   d'opérateur <acronym>GiST</acronym> indiquées dans <xref
   linkend="gist-builtin-opclasses-table"/>.
   (Quelques modules optionnels décrits dans <xref linkend="contrib"/>
   fournissent des classes d'opérateur <acronym>GiST</acronym> supplémentaires.)
  </para>

  <table id="gist-builtin-opclasses-table">
   <title>Classes d'opérateur <acronym>GiST</acronym> internes</title>
   <tgroup cols="4">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données indexé</entry>
      <entry>Opérateurs indexables</entry>
      <entry>Opérateurs de tri</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>box_ops</literal></entry>
      <entry><type>box</type></entry>
      <entry>
       <literal>&amp;&amp;</literal>
       <literal>&amp;&gt;</literal>
       <literal>&amp;&lt;</literal>
       <literal>&amp;&lt;|</literal>
       <literal>&gt;&gt;</literal>
       <literal>&lt;&lt;</literal>
       <literal>&lt;&lt;|</literal>
       <literal>&lt;@</literal>
       <literal>@&gt;</literal>
       <literal>@</literal>
       <literal>|&amp;&gt;</literal>
       <literal>|&gt;&gt;</literal>
       <literal>~</literal>
       <literal>~=</literal>
      </entry>
      <entry>
      </entry>
     </row>
     <row>
      <entry><literal>circle_ops</literal></entry>
      <entry><type>circle</type></entry>
      <entry>
       <literal>&amp;&amp;</literal>
       <literal>&amp;&gt;</literal>
       <literal>&amp;&lt;</literal>
       <literal>&amp;&lt;|</literal>
       <literal>&gt;&gt;</literal>
       <literal>&lt;&lt;</literal>
       <literal>&lt;&lt;|</literal>
       <literal>&lt;@</literal>
       <literal>@&gt;</literal>
       <literal>@</literal>
       <literal>|&amp;&gt;</literal>
       <literal>|&gt;&gt;</literal>
       <literal>~</literal>
       <literal>~=</literal>
      </entry>
      <entry>
       <literal>&lt;-&gt;</literal>
      </entry>
     </row>
     <row>
      <entry><literal>inet_ops</literal></entry>
      <entry><type>inet</type>, <type>cidr</type></entry>
      <entry>
       <literal>&amp;&amp;</literal>
       <literal>&gt;&gt;</literal>
       <literal>&gt;&gt;=</literal>
       <literal>&gt;</literal>
       <literal>&gt;=</literal>
       <literal>&lt;&gt;</literal>
       <literal>&lt;&lt;</literal>
       <literal>&lt;&lt;=</literal>
       <literal>&lt;</literal>
       <literal>&lt;=</literal>
       <literal>=</literal>
      </entry>
      <entry>
      </entry>
     </row>
     <row>
      <entry><literal>point_ops</literal></entry>
      <entry><type>point</type></entry>
      <entry>
       <literal>&gt;&gt;</literal>
       <literal>&gt;^</literal>
       <literal>&lt;&lt;</literal>
       <literal>&lt;@</literal>
       <literal>&lt;@</literal>
       <literal>&lt;@</literal>
       <literal>&lt;^</literal>
       <literal>~=</literal>
      </entry>
      <entry>
       <literal>&lt;-&gt;</literal>
      </entry>
     </row>
     <row>
      <entry><literal>poly_ops</literal></entry>
      <entry><type>polygon</type></entry>
      <entry>
       <literal>&amp;&amp;</literal>
       <literal>&amp;&gt;</literal>
       <literal>&amp;&lt;</literal>
       <literal>&amp;&lt;|</literal>
       <literal>&gt;&gt;</literal>
       <literal>&lt;&lt;</literal>
       <literal>&lt;&lt;|</literal>
       <literal>&lt;@</literal>
       <literal>@&gt;</literal>
       <literal>@</literal>
       <literal>|&amp;&gt;</literal>
       <literal>|&gt;&gt;</literal>
       <literal>~</literal>
       <literal>~=</literal>
      </entry>
      <entry>
       <literal>&lt;-&gt;</literal>
      </entry>
     </row>
     <row>
      <entry><literal>range_ops</literal></entry>
      <entry>any range type</entry>
      <entry>
       <literal>&amp;&amp;</literal>
       <literal>&amp;&gt;</literal>
       <literal>&amp;&lt;</literal>
       <literal>&gt;&gt;</literal>
       <literal>&lt;&lt;</literal>
       <literal>&lt;@</literal>
       <literal>-|-</literal>
       <literal>=</literal>
       <literal>@&gt;</literal>
       <literal>@&gt;</literal>
      </entry>
      <entry>
      </entry>
     </row>
     <row>
      <entry><literal>tsquery_ops</literal></entry>
      <entry><type>tsquery</type></entry>
      <entry>
       <literal>&lt;@</literal>
       <literal>@&gt;</literal>
      </entry>
      <entry>
      </entry>
     </row>
     <row>
      <entry><literal>tsvector_ops</literal></entry>
      <entry><type>tsvector</type></entry>
      <entry>
       <literal>@@</literal>
      </entry>
      <entry>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Pour des raisons historiques, la classe d'opérateur <literal>inet_ops</literal>
   n'est pas la classe par défaut pour les types <type>inet</type> et
   <type>cidr</type>. Pour l'utiliser, mentionnez le nom de la classe dans la
   commande <command>CREATE INDEX</command>, par exemple
   <programlisting>
CREATE INDEX ON ma_table USING GIST (ma_colonne_inet inet_ops);
   </programlisting>
  </para>

 </sect1>

 <sect1 id="gist-extensibility">
  <title>Extensibilité</title>

  <para>
   L'implantation d'une nouvelle méthode d'accès à un index
   a toujours été un travail complexe. Il est, en effet, nécessaire de comprendre le
   fonctionnement interne de la base de données, tel que le gestionnaire de
   verrous ou le WAL.
  </para>

  <para>
   L'interface <acronym>GiST</acronym> dispose d'un haut niveau
   d'abstraction, ce qui autorise le codeur de la méthode d'accès à
   ne coder que la sémantique du type de données accédé. La
   couche <acronym>GiST</acronym> se charge elle-même de la gestion des accès concurrents,
   des traces et de la recherche dans la structure en arbre.
  </para>

  <para>
   Cette extensibilité n'est pas comparable à celle des
   autres arbres de recherche standard en termes de données gérées. Par
   exemple, <productname>PostgreSQL</productname> supporte les B-trees et les
   index de hachage extensibles. Cela signifie qu'il est possible d'utiliser
   <productname>PostgreSQL</productname> pour construire un B-tree ou un hachage
   sur tout type de données. Mais, les B-trees ne supportent
   que les prédicats d'échelle (<literal>&lt;</literal>,
   <literal>=</literal>, <literal>&gt;</literal>), les index de hachage
   que les requêtes d'égalité.
  </para>

  <para>
   Donc, lors de l'indexation d'une collection d'images, par exemple, avec un B-tree
   <productname>PostgreSQL</productname>, seules peuvent être lancées des requêtes de type
   <quote>est-ce que imagex est égale à imagey</quote>,
   <quote>est-ce que imagex est plus petite que imagey</quote> et <quote>est-ce
    que imagex est plus grande que imagey</quote>. En fonction de la définition
   donnée à <quote>égale à</quote>, <quote>inférieure à</quote> ou
   <quote>supérieure à</quote>, cela peut avoir une utilité.
   Néanmoins, l'utilisation d'un index basé sur <acronym>GiST</acronym> permet
   de créer de nombreuses possibilités de poser des questions spécifiques au domaine,
   telles que <quote>trouver toutes les images de chevaux</quote> ou
   <quote>trouver toutes les images sur-exposées</quote>.
  </para>

  <para>
   Pour obtenir une méthode d'accès
   <acronym>GiST</acronym> fonctionnelle, il suffit de coder plusieurs méthodes
   utilisateur définissant le comportement des clés dans
   l'arbre. Ces méthodes doivent être suffisamment élaborées
   pour supporter des requêtes avancées, mais pour toutes les requêtes standard
   (B-trees, R-trees, etc.) elles sont relativement simples. En bref,
   <acronym>GiST</acronym> combine extensibilité, généralité,
   ré-utilisation de code et interface claire.
  </para>

  <para>
   Une classe d'opérateur d'index <acronym>GiST</acronym> doit fournir sept
   méthodes, et deux supplémentaires optionnelles. La précision de l'index est assurée par l'implantation des
   méthodes <function>same</function>, <function>consistent</function>
   et <function>union</function> alors que l'efficacité (taille et rapidité)
   de l'index dépendra des méthodes <function>penalty</function> et
   <function>picksplit</function>. Deux fonctions optionnelles sont
   <function>compress</function> et <function>decompress</function>, qui
   permettent à un index d'avoir des données internes de l'arbre d'un type
   différent de ceux des données qu'il indexe. Les feuilles doivent être du
   type des données indexées alors que les autres n&oelig;uds peuvent être de
   n'importe quelle structure C (mais vous devez toujours suivre les règles
   des types de données de <productname>PostgreSQL</productname> dans ce cas,
   voir ce qui concerne <literal>varlena</literal> pour les données de taille
   variable). Si le type de données interne de l'arbre existe au niveau SQL,
   l'option <literal>STORAGE</literal> de la commande <command>CREATE OPERATOR
   CLASS</command> peut être utilisée.
   La huitième méthode, optionnelle, est <function>distance</function>, qui
   est nécessaire si la classe d'opérateur souhaite supporter les parcours
   ordonnées (intéressant dans le cadre des recherches du voisin-le-plus-proche,
   <foreignphrase>nearest-neighbor</foreignphrase>). La neuvième méthode,
   optionnelle, nommée <function>fetch</function>, est nécessaire si la classe
   d'opérateur souhaite supporter les parcours d'index seuls, sauf quand la
   méthode <function>compress</function> est omise.
  </para>

  <variablelist>
   <varlistentry>
    <term><function>consistent</function></term>
    <listitem>
     <para>
      Étant donné une entrée d'index <literal>p</literal> et une valeur de
      requête <literal>q</literal>, cette fonction détermine si l'entrée de
      l'index est cohérente (<quote>consistent</quote> en anglais) avec la
      requête&nbsp;; c'est-à-dire, est-ce que le prédicat
      <quote><replaceable>colonne_indexée</replaceable>
       <replaceable>opérateur_indexable</replaceable> <literal>q</literal></quote>
      soit vrai pour toute ligne représentée par l'entrée de l'index&nbsp;?
      Pour une entrée de l'index de type feuille, c'est l'équivalent pour
      tester la condition indexable, alors que pour un n&oelig;ud interne de
      l'arbre, ceci détermine s'il est nécessaire de parcourir le sous-arbre de
      l'index représenté par le n&oelig;ud. Quand le résultat est
      <literal>true</literal>, un drapeau <literal>recheck</literal> doit
      aussi être renvoyé. Ceci indique si le prédicat est vrai à coup sûr ou
      seulement peut-être vrai. Si <literal>recheck</literal> =
      <literal>false</literal>, alors l'index a testé exactement la condition
      du prédicat, alors que si <literal>recheck</literal>
      = <literal>true</literal>, la ligne est seulement un correspondance de
      candidat. Dans ce cas, le système évaluera automatiquement
      l'<replaceable>opérateur_indexable</replaceable> avec la valeur actuelle
      de la ligne pour voir s'il s'agit réellement d'une correspondance. Cette
      convention permet à <acronym>GiST</acronym> de supporter à la fois les
      structures sans pertes et celles avec perte de l'index.
     </para>

     <para>
      La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
      ceci&nbsp;:

      <programlisting>
CREATE OR REPLACE FUNCTION my_consistent(internal, data_type, smallint, oid, internal)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
      </programlisting>

      Et le code correspondant dans le module C peut alors suivre ce
      squelette&nbsp;:

      <programlisting>
PG_FUNCTION_INFO_V1(my_consistent);

Datum
my_consistent(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    data_type  *query = PG_GETARG_DATA_TYPE_P(1);
    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
    /* Oid subtype = PG_GETARG_OID(3); */
    bool       *recheck = (bool *) PG_GETARG_POINTER(4);
    data_type  *key = DatumGetDataType(entry-&gt;key);
    bool        retval;

    /*
     * determine return value as a function of strategy, key and query.
     *
     * Use GIST_LEAF(entry) to know where you're called in the index tree,
     * which comes handy when supporting the = operator for example (you could
     * check for non empty union() in non-leaf nodes and equality in leaf
     * nodes).
     */

    *recheck = true;        /* or false if check is exact */

    PG_RETURN_BOOL(retval);
}
      </programlisting>

      Ici, <varname>key</varname> est un élément dans l'index et
      <varname>query</varname> la valeur la recherchée dans l'index. Le
      paramètre <literal>StrategyNumber</literal> indique l'opérateur
      appliqué de votre classe d'opérateur. Il correspond à un des nombres
      d'opérateurs dans la commande <command>CREATE OPERATOR CLASS</command>.
     </para>

     <para>
      Suivant les opérateurs inclus dans la classe, le type de données de
      <varname>query</varname> pourrait varier avec l'opérateur car il sera
      du type de ce qui se trouver sur le côté droit de l'opérateur, qui
      pourrait être différent du type de la donnée indexée apparaissant du
      côté gauche. (Le squelette de code ci-dessus suppose qu'un seul type
      est possible&nbsp;; dans le cas contraire, récupérer la valeur de
      l'argument <varname>query</varname> pourrait devoir dépendre de
      l'opérateur.) Il est recommendé que la déclaration SQL de la fonction
      <function>consistent</function> utilise le type de la donnée indexée de
      la classe d'opérateur pour l'argument <varname>query</varname>, même si
      le type réel pourrait être différent suivant l'opérateur.
     </para>

    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>union</function></term>
    <listitem>
     <para>
      Cette méthode consolide l'information dans l'arbre. Suivant un ensemble
      d'entrées, cette fonction génère une nouvelle entrée d'index qui
      représente toutes les entrées données.
     </para>

     <para>
      La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
      ceci&nbsp;:

      <programlisting>
CREATE OR REPLACE FUNCTION my_union(internal, internal)
RETURNS storage_type
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
      </programlisting>

      Et le code correspondant dans le module C peut alors suivre ce
      squelette&nbsp;:

      <programlisting>
PG_FUNCTION_INFO_V1(my_union);

Datum
my_union(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    GISTENTRY  *ent = entryvec-&gt;vector;
    data_type  *out,
               *tmp,
               *old;
    int         numranges,
                i = 0;

    numranges = entryvec-&gt;n;
    tmp = DatumGetDataType(ent[0].key);
    out = tmp;

    if (numranges == 1)
    {
        out = data_type_deep_copy(tmp);

        PG_RETURN_DATA_TYPE_P(out);
    }

    for (i = 1; i &lt; numranges; i++)
    {
        old = out;
        tmp = DatumGetDataType(ent[i].key);
        out = my_union_implementation(out, tmp);
    }

    PG_RETURN_DATA_TYPE_P(out);
}
      </programlisting>
     </para>

     <para>
      Comme vous pouvez le voir dans ce squelette, nous gérons un type de
      données où <literal>union(X, Y, Z) = union(union(X, Y), Z)</literal>.
      C'est assez simple pour supporter les types de données où ce n'est pas
      le cas, en implantant un autre algorithme d'union dans cette méthode
      de support <acronym>GiST</acronym>.
     </para>

     <para>
        Le résultat de la fonction <function>union</function> doit être une
        valeur du type de stockage de l'index, quelqu'il soit (il pourrait
        être ou non différent du type de la colonne indexée). La fonction
        <function>union</function> doit renvoyer un pointeur vers la mémoire
        nouvellement allouée avec <function>palloc()</function>. Vous ne
        pouvez pas seulement renvoyer la valeur en entrée directement,
        même s'il n'y a pas de changement de type.
      </para>

      <para>
       Comme indiqué ci-dessus, le premier argument <type>internal</type> de
       la fonction <function>union</function> est en réalité un pointeur
       <structname>GistEntryVector</structname>. Le deuxième argument est un
       pointeur vers une variable entière qui peut être ignorée. (Il était
       requis que la fonction <function>union</function> enregistre la taille
       de sa valeur résultat dans cette variable, mais ce n'est plus nécessaire.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>compress</function></term>
    <listitem>
     <para>
      Convertit l'élément de données dans un format compatible avec
      le stockage physique dans une page d'index. Si la méthode
      <function>compress</function> est omise, les éléments des données sont
      enregistrés dans l'index sans modification.
     </para>

     <para>
      La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
      ceci&nbsp;:

      <programlisting>
CREATE OR REPLACE FUNCTION my_compress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
      </programlisting>

      Et le code correspondant dans le module C peut alors suivre ce
      squelette&nbsp;:

      <programlisting>
PG_FUNCTION_INFO_V1(my_compress);

Datum
my_compress(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *retval;

    if (entry-&gt;leafkey)
    {
        /* replace entry-&gt;key with a compressed version */
        compressed_data_type *compressed_data = palloc(sizeof(compressed_data_type));

        /* fill *compressed_data from entry-&gt;key ... */

        retval = palloc(sizeof(GISTENTRY));
        gistentryinit(*retval, PointerGetDatum(compressed_data),
                      entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);
    }
    else
    {
        /* typically we needn't do anything with non-leaf entries */
        retval = entry;
    }

    PG_RETURN_POINTER(retval);
}
      </programlisting>
     </para>

     <para>
      Vous devez adapter <replaceable>compressed_data_type</replaceable> au type
      spécifique que vous essayez d'obtenir pour compresser les n&oelig;uds
      finaux.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>decompress</function></term>
    <listitem>
     <para>
      Convertit la représentation enregistrée d'un élément des données dans un
      format manipulable par les autres méthodes GiST dans la classe
      d'opérateur. Si la méthode <function>decompress</function> est omise, il
      est supposé que les autres méthodes GiST peuvent fonctionner directement
      dans le format de la donnée. (<function>decompress</function> n'est pas
      nécessairement l'inverse de la méthode
      <function>compress</function>&nbsp;; en particulier, si
      <function>compress</function> est à perte, alors il est impossible pour
      <function>decompress</function> de reconstruire exactement la donnée
      originale. <function>decompress</function> n'est pas nécessairement
      équivalent à <function>fetch</function>, car les autres méthodes GiST
      pourraient ne pas nécessiter la reconstruction complète des données.)
     </para>

     <para>
      La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
      ceci&nbsp;:

      <programlisting>
CREATE OR REPLACE FUNCTION my_decompress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
      </programlisting>

      Et le code correspondant dans le module C peut alors suivre ce
      squelette&nbsp;:

      <programlisting>
PG_FUNCTION_INFO_V1(my_decompress);

Datum
my_decompress(PG_FUNCTION_ARGS)
{
    PG_RETURN_POINTER(PG_GETARG_POINTER(0));
}
      </programlisting>

      Le squelette ci-dessus est convenable dans le cas iù aucune
      décompression n'est nécessaire. (Mais, bien sûr, omettre la méthode est
      encore plus simple et même recommendé dans ce cas.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>penalty</function></term>
    <listitem>
     <para>
      Renvoie une valeur indiquant le <quote>coût</quote> d'insertion
      d'une nouvelle entrée dans une branche particulière de l'arbre. Les
      éléments seront insérés dans l'ordre des pénalités moindres
      (<function>penalty</function>) de l'arbre. Les valeurs renvoyées
      par <function>penalty</function> doivent être positives ou nulles.
      Si une valeur négative est renvoyée, elle sera traitée comme valant
      zéro.
     </para>

     <para>
      La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
      ceci&nbsp;:

      <programlisting>
CREATE OR REPLACE FUNCTION my_penalty(internal, internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;  -- in some cases penalty functions need not be strict
      </programlisting>

      Et le code correspondant dans le module C peut alors suivre ce
      squelette&nbsp;:

      <programlisting>
PG_FUNCTION_INFO_V1(my_penalty);

Datum
my_penalty(PG_FUNCTION_ARGS)
{
    GISTENTRY  *origentry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *newentry = (GISTENTRY *) PG_GETARG_POINTER(1);
    float      *penalty = (float *) PG_GETARG_POINTER(2);
    data_type  *orig = DatumGetDataType(origentry-&gt;key);
    data_type  *new = DatumGetDataType(newentry-&gt;key);

    *penalty = my_penalty_implementation(orig, new);
    PG_RETURN_POINTER(penalty);
}
      </programlisting>

        Pour des raisons historiques, la fonction <function>penalty</function>
        ne renvoie pas seulement un résultat de type <type>float</type>&nbsp;;
        à la place, il enregistre la valeur à l'emplacement indiqué par le
        troisième argument. La valeur de retour est ignorée, bien que, par
        convention, l'adresse de l'argument est renvoyée.
     </para>

     <para>
      La fonction <function>penalty</function> est crucial pour de bonnes
      performances de l'index. Elle sera utilisée lors de l'insertion pour
      déterminer la branche à suivre pour savoir où ajoter la nouvelle entrée
      dans l'arbre. Lors de l'exécution de la requête, plus l'arbre sera bien
      balancé, plus l'exécution sera rapide.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>picksplit</function></term>
    <listitem>
     <para>
      Quand une division de page est nécessaire pour un index, cette fonction
      décide des entrées de la page qui resteront sur l'ancienne page et de
      celles qui seront déplacées sur la nouvelle page.
     </para>

     <para>
      La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
      ceci&nbsp;:

      <programlisting>
CREATE OR REPLACE FUNCTION my_picksplit(internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
      </programlisting>

      Et le code correspondant dans le module C peut alors suivre ce
      squelette&nbsp;:

      <programlisting>
PG_FUNCTION_INFO_V1(my_picksplit);

Datum
my_picksplit(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);
    OffsetNumber maxoff = entryvec-&gt;n - 1;
    GISTENTRY  *ent = entryvec-&gt;vector;
    GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);
    int         i,
                nbytes;
    OffsetNumber *left,
               *right;
    data_type  *tmp_union;
    data_type  *unionL;
    data_type  *unionR;
    GISTENTRY **raw_entryvec;

    maxoff = entryvec-&gt;n - 1;
    nbytes = (maxoff + 1) * sizeof(OffsetNumber);

    v-&gt;spl_left = (OffsetNumber *) palloc(nbytes);
    left = v-&gt;spl_left;
    v-&gt;spl_nleft = 0;

    v-&gt;spl_right = (OffsetNumber *) palloc(nbytes);
    right = v-&gt;spl_right;
    v-&gt;spl_nright = 0;

    unionL = NULL;
    unionR = NULL;

    /* Initialize the raw entry vector. */
    raw_entryvec = (GISTENTRY **) malloc(entryvec-&gt;n * sizeof(void *));
    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
        raw_entryvec[i] = &amp;(entryvec-&gt;vector[i]);

    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
    {
        int         real_index = raw_entryvec[i] - entryvec-&gt;vector;

        tmp_union = DatumGetDataType(entryvec-&gt;vector[real_index].key);
        Assert(tmp_union != NULL);

        /*
         * Choose where to put the index entries and update unionL and unionR
         * accordingly. Append the entries to either v-&gt;spl_left or
         * v-&gt;spl_right, and care about the counters.
         */

        if (my_choice_is_left(unionL, curl, unionR, curr))
        {
            if (unionL == NULL)
                unionL = tmp_union;
            else
                unionL = my_union_implementation(unionL, tmp_union);

            *left = real_index;
            ++left;
            ++(v-&gt;spl_nleft);
        }
        else
        {
            /*
             * Same on the right
             */
        }
    }

    v-&gt;spl_ldatum = DataTypeGetDatum(unionL);
    v-&gt;spl_rdatum = DataTypeGetDatum(unionR);
    PG_RETURN_POINTER(v);
}
      </programlisting>

       Notez que le résultat de la fonction <function>picksplit</function> est
       fourni en modifiant la structure <structname>v</structname> en
       référence. La valeur de retour réelle est ignorée, bien que la
       convention est de passer l'adresse de <structname>v</structname>.
     </para>

     <para>
      Comme <function>penalty</function>, la fonction <function>picksplit</function>
      est cruciale pour de bonnes performances de l'index. Concevoir des
      implantations convenables des fonctions <function>penalty</function> et
      <function>picksplit</function> est le challenge d'un index
      <acronym>GiST</acronym> performant.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>same</function></term>
    <listitem>
     <para>
      Renvoit true si les deux entrées de l'index sont identiques, faux sinon.
      (Un <quote>enregistrement d'index</quote> est une valeur du type de
      stockage de l'index, pas nécessairement le type original de la colonne
      indexée.)
     </para>

     <para>
      La déclaration <acronym>SQL</acronym> de la fonction ressemble à
      ceci&nbsp;:

      <programlisting>
CREATE OR REPLACE FUNCTION my_same(storage_type, storage_type, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
      </programlisting>

      Et le code correspondant dans le module C peut alors suivre ce
      squelette&nbsp;:

      <programlisting>
PG_FUNCTION_INFO_V1(my_same);

Datum
my_same(PG_FUNCTION_ARGS)
{
    prefix_range *v1 = PG_GETARG_PREFIX_RANGE_P(0);
    prefix_range *v2 = PG_GETARG_PREFIX_RANGE_P(1);
    bool       *result = (bool *) PG_GETARG_POINTER(2);

    *result = my_eq(v1, v2);
    PG_RETURN_POINTER(result);
}
      </programlisting>

      Pour des raisons historiques, la fonction <function>same</function> ne
      renvoie pas seulement un résultat booléen&nbsp;; à la place, il doit
      enregistrer le drapeau à l'emplacement indiqué par le troisième argument.
      La valeur de retour est ignoré, bien qu'il soit par convention de passer
      l'adresse de cet argument.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>distance</function></term>
    <listitem>
     <para>
      À partir d'une entrée d'index <literal>p</literal> et une valeur
      recherchée <literal>q</literal>, cette fonction détermine la
      <quote>distance</quote> entre l'entrée de l'index et la valeur
      recherchée. Cette fonction doit être fournie si la classe d'opérateur
      contient des opérateurs de tri. Une requête utilisant l'opérateur de
      tri sera implémentée en renvoyant les entrées d'index dont les valeurs
      de <quote>distance</quote> sont les plus petites, donc les résultats
      doivent être cohérents avec la sémantique de l'opérateur. Pour une
      entrée d'index de type feuille, le résultat représente seulement la
      distance vers l'entrée d'index. Pour un nœud de l'arbre interne, le
      résultat doit être la plus petite distance que toute entrée enfant
      représente.
     </para>

     <para>
      La déclaration <acronym>SQL</acronym> de la fonction doit ressembler
      à ceci&nbsp;:

      <programlisting>
CREATE OR REPLACE FUNCTION my_distance(internal, data_type, smallint, oid, internal)
RETURNS float8
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
      </programlisting>

      Et le code correspondant dans le module C peut correspondre à ce
      squelette&nbsp;:

      <programlisting>
PG_FUNCTION_INFO_V1(my_distance);

Datum
my_distance(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    data_type  *query = PG_GETARG_DATA_TYPE_P(1);
    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
    /* Oid subtype = PG_GETARG_OID(3); */
    /* bool *recheck = (bool *) PG_GETARG_POINTER(4); */
    data_type  *key = DatumGetDataType(entry-&gt;key);
    double      retval;

    /*
     * determine return value as a function of strategy, key and query.
     */

    PG_RETURN_FLOAT8(retval);
}
      </programlisting>

      Les arguments de la fonction <function>distance</function> sont
      identiques aux arguments de la fonction <function>consistent</function>.
      </para>

      <para>
       Quelques approximations sont autorisées pour déterminer la distance,
       pour que le résultat ne soit jamais plus grand que la distance réelle
       de l'entrée. De ce fait, par exemple, une distance dans une
       <foreignphrase>bounding box</foreignphrase> est généralement suffisante
       dans les applications géométriques. Pour un nœud d'un arbre interne, la
       distance renvoyée ne doit pas être plus grande que la distance vers
       tous les nœuds cibles. Si la distance renvoyée n'est pas exacte, la
       fonction doit configurer <literal>*recheck</literal> à true. (Ceci
       n'est pas nécessaire pour les nœuds de l'arbre interne&nbsp;; en ce qui
       les concerne, le calcul est supposé toujours inexact.) Dans ce cas,
       l'exécuteur calculera la distance précise après la récupération de la
       ligne à partir de la pile, et réordonnera les lignes si nécessaires.
      </para>

      <para>
       Si la fonction distance renvoie <literal>*recheck = true</literal> pour
       tout nœud feuille, le type de retour de l'opération de tri original
       doit être <type>float8</type> ou <type>float4</type>, et les valeurs
       résultats de la fonction distance doivent être comparables à ceux de
       l'opérateur original de tri, car l'exécuteur triera en utilisant les
       résultats de la fonction de distance et les résultats recalculés de
       l'opérateur de tri. Dans le cas contraire, les valeurs de résultats de
       la fonction distance peuvent être toute valeur <type>float8</type>
       finie, tant est que l'ordre relatif des valeurs résultats correspond à
       l'ordre renvoyé par l'opérateur de tri. (l'infinité, positif comme
       négatif, est utilisé en interne pour gérer des cas comme les valeurs
       NULL, donc il n'est pas recommandé que les fonctions
       <function>distance</function> renvoient ces valeurs.)
     </para>

    </listitem>
   </varlistentry>

    <varlistentry>
     <term><function>fetch</function></term>
     <listitem>
      <para>
       Convertit la représentation compressée de l'index pour un élément de
       données vers le type de données original pour les parcours d'index
       seuls. Les données renvoyées doivent être une copie exacte, sans perte
       de la valeur indexée à l'origine.
      </para>

      <para>
        La déclaration <acronym>SQL</acronym> de la fonction doit ressembler
        à ceci&nbsp;:

<programlisting>
CREATE OR REPLACE FUNCTION my_fetch(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        L'argument est un pointeur vers une structure
        <structname>GISTENTRY</structname>. En entrée, son champ <structfield>key</structfield> contient
        une donnée non NULL compressée. La valeur de retour est une autre
        structure <structname>GISTENTRY</structname> dont le champ <structfield>key</structfield>
        contient la même donnée que l'original, mais non compressée. Si la
        fonction de compression de la classe d'opérateur ne fait rien pour les
        enregistrements feuilles, la méthode <function>fetch</function> peut renvoyer l'argument
        tel quel. Ou, si la classe d'opérateur n'a pas de fonction de
        compression, la méthode <function>fetch</function> peut aussi être
        omise car elle ne ferait rien de toute façon.
       </para>

       <para>
        Le code correspondant dans le module C doit alors suivre ce
        squelette&nbsp;:

<programlisting>
PG_FUNCTION_INFO_V1(my_fetch);

Datum
my_fetch(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    input_data_type *in = DatumGetPointer(entry->key);
    fetched_data_type *fetched_data;
    GISTENTRY  *retval;

    retval = palloc(sizeof(GISTENTRY));
    fetched_data = palloc(sizeof(fetched_data_type));

    /*
     * Convertit 'fetched_data' en un Datum du type de données original.
     */

    /* remplit *retval à partir de fetched_data. */
    gistentryinit(*retval, PointerGetDatum(converted_datum),
                  entry->rel, entry->page, entry->offset, FALSE);

    PG_RETURN_POINTER(retval);
}
</programlisting>
      </para>

      <para>
       Si la méthode de compression est à perte pour les entrées feuilles, la
       classe d'opérateur ne supporte pas les parcours d'index seuls, et ne
       doit pas définir une fonction <function>fetch</function>.
      </para>

     </listitem>
    </varlistentry>
  </variablelist>

  <para>
   Toutes les méthodes de support GiST sont habituellement appelées dans
   des contextes mémoires à durée limitée. En fait,
   <varname>CurrentMemoryContext</varname> sera réinitialisé après le traitement
   de chaque ligne. Il n'est donc pas très important de s'inquiéter de libérer
   avec pfree tout ce que vous avez alloué avec palloc. Néanmoins, dans certains
   cas, une méthode de support peut avoir besoin de cacher des données à utiliser
   lors des prochains appels. Pour cela, allouez les données à durée de vie longue
   dans <literal>fcinfo-&gt;flinfo-&gt;fn_mcxt</literal> et conservez un pointeur
   vers ces données dans <literal>fcinfo-&gt;flinfo-&gt;fn_extra</literal>. Ce type
   de données va survivre pendant toute la durée de l'opération sur l'index (par
   exemple, un seul parcours d'index GiST, une construction d'index ou l'insertion
   d'une ligne dans un index). Faites attention à libérer avec pfree la valeur
   précédente lors du remplacement d'une valeur <literal>fn_extra</literal>.
   Dans le cas contraire, une perte mémoire s'accumulera pendant la durée de
   l'opération.
  </para>

 </sect1>

 <sect1 id="gist-implementation">
  <title>Implémentation</title>

  <sect2 id="gist-buffering-build">
   <title>Construction GiST avec tampon</title>
   <para>
    Construire de gros index GiST en insérant simplement toutes les lignes
    a tendance à être lent car si les lignes de l'index sont dispersées dans
    tout l'index et que l'index est suffisamment gros pour ne pas tenir dans
    le cache, les insertions ont besoin de réaliser un grand nombre d'opérations
    d'entrées/sorties aléatoires. À partir de la version 9.2, PostgreSQL supporte
    une méthode plus efficace pour construire des index GiST en se basant sur
    des tampons qui peuvent dramatiquement réduire le nombre d'entrées/sorties
    aléatoires nécessaires pour les ensembles de données non triées. Pour les
    ensembles de données déjà bien triées, le gain est plus petit, voire
    inexistant car seul un petit nombre de pages reçoit des nouvelles lignes
    à un même instant et ces pages tiennent généralement en cache même si
    l'index complet ne tient pas.
   </para>

   <para>
    Néanmoins, la construction d'index par tampon a besoin d'appeler la fonction
    <function>penalty</function> plus fréquemment, ce qui consomme un peu plus
    de ressources CPU. De plus, les tampons utilisés lors de cette construction
    ont besoin d'un espace disque temporaire, allant jusqu'à la taille de l'index
    résultant. L'utilisation de tampons peut aussi influencer la qualité de
    l'index résultant, de façon positive et négative. Cette influence dépend
    de plusieurs facteurs, comme la distribution des données en entrée et de
    l'implémentation de la classe d'opérateur.
   </para>

   <para>
    Par défaut, la construction d'un index GiST bascule sur la méthode avec
    tampons lorsque la taille de l'index atteint <xref
    linkend="guc-effective-cache-size"/>. Cette bascule peut être activée ou
    désactivée manuellement avec le paramètre <literal>BUFFERING</literal>
    de la commande CREATE INDEX. Le comportement par défaut est bon dans la
    plupart des cas, mais désactiver l'utilisation des tampons pourrait apporter
    une amélioration des performances lors de la construction sur les données
    en entrée sont déjà triées.
   </para>

  </sect2>

 </sect1>

 <sect1 id="gist-examples">
  <title>Exemples</title>

  <para>
   La distribution source de <productname>PostgreSQL</productname> inclut
   plusieurs exemples de méthodes d'indexation implantées selon
   <acronym>GiST</acronym>. Le système principal fournit des fonctionnalités
   de recherche plein texte (indexation des <type>tsvector</type> et
   <type>tsquery</type>) ainsi que des fonctionnalités équivalentes aux R-Tree
   pour certains types de données géométriques
   (voir <filename>src/backend/access/gist/gistproc.c</filename>). Les modules
   <filename>contrib</filename> suivants contiennent aussi des classes d'opérateur
   <acronym>GiST</acronym>&nbsp;:
  </para>

  <variablelist>
   <varlistentry>
    <term><filename>btree_gist</filename></term>
    <listitem>
     <para>Fonctionnalités équivalentes aux B-Tree pour plusieurs types de
      données</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><filename>cube</filename></term>
    <listitem>
     <para>Indexation de cubes multi-dimensionnels</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><filename>hstore</filename></term>
    <listitem>
     <para>Module pour le stockage des paires (clé, valeur)</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><filename>intarray</filename></term>
    <listitem>
     <para>RD-Tree pour tableaux uni-dimensionnels de valeurs int4</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><filename>ltree</filename></term>
    <listitem>
     <para>Indexation des structures de type arbre</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><filename>pg_trgm</filename></term>
    <listitem>
     <para>Similarité textuelle par correspondance de trigrammes</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><filename>seg</filename></term>
    <listitem>
     <para>Indexation pour les <quote>nombres
       flottants</quote></para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect1>

</chapter>
