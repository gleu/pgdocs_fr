<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->>

 <chapter id="extend">
  <title>Étendre <acronym>SQL</acronym></title>

   <indexterm zone="extend">
    <primary>Extension de SQL</primary>
   </indexterm>

  <para>
   Les sections qui suivent présentent les possibilités d'étendre le langage
   SQL de requêtage de <productname>PostgreSQL</productname> par l'ajout&nbsp;:
  <itemizedlist spacing="compact" mark="bullet">
    <listitem>
     <para>
      de fonctions (<xref linkend="xfunc"/>)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
      d'agrégats (<xref linkend="xaggr"/>)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
      de types de données (<xref linkend="xtypes"/>)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
      d'opérateurs (<xref linkend="xoper"/>)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
     de classes d'opérateurs pour les index (<xref linkend="xindex"/>).
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <sect1 id="extend-how">
   <title>L'extensibilité</title>

   <para>
    <productname>PostgreSQL</productname> est extensible parce qu'il opère
    grâce à un système de catalogues. Quiconque est familier des systèmes de
    bases de données relationnelles standard sait que les informations
    concernant les bases, les tables, les colonnes, etc. y sont stockées dans ce
    qu'on nomme communément des catalogues systèmes (certains systèmes appellent
    cela le dictionnaire de données). Pour l'utilisateur, les catalogues
    ressemblent à des tables ordinaires, mais le <acronym>SGBD</acronym>
    y enregistre ses registres <!-- bookkeeping --> internes. À la différence
    des autres systèmes, <productname>PostgreSQL</productname> enregistre
    beaucoup d'informations dans ses catalogues&nbsp;: non seulement
    l'information concernant les tables et les colonnes, mais aussi
    l'information concernant les types de données, les fonctions, les méthodes
    d'accès, etc.
   </para>
   <para>
    Ces tables peuvent être modifiées par l'utilisateur. Qui plus est, 
    puisque <productname>PostgreSQL</productname> fonde ses opérations sur ces
    tables, il peut être étendu par les utilisateurs. En comparaison, les systèmes de bases de 
    données conventionnels ne peuvent être étendus qu'en modifiant les
    procédures dans le code source ou en installant des modules spécifiquement
    écrits par le vendeur de <acronym>SGBD</acronym>.
  </para>
  
  <para>
   De plus, le serveur <productname>PostgreSQL</productname> peut
   incorporer du code utilisateur par chargement dynamique. C'est-à-dire
   que l'utilisateur peut indiquer un fichier de code objet (par exemple une
   bibliothèque partagée) qui code un nouveau type ou une nouvelle fonction
   et <productname>PostgreSQL</productname> le charge au besoin.
   Il est encore plus facile d'ajouter au serveur du code écrit en
   <acronym>SQL</acronym>. La possibilité de modifier son fonctionnement
   <quote>à la volée</quote> fait de <productname>PostgreSQL</productname>
   un outil unique pour le prototypage rapide de nouvelles applications et
   de structures de stockage.
  </para>
  
 </sect1>
   
   <sect1 id="extend-type-system"> 
     <title>Le système des types de <productname>PostgreSQL</productname></title>

   <indexterm zone="extend-type-system">
    <primary>type de base</primary>
   </indexterm>

   <indexterm zone="extend-type-system">
    <primary>type de données</primary>
    <secondary>base</secondary>
   </indexterm>

   <indexterm zone="extend-type-system">
    <primary>type composé</primary>
   </indexterm>

   <indexterm zone="extend-type-system">
    <primary>type de données</primary>
    <secondary>composé</secondary>
   </indexterm>

   <para>
    Les types de données de <productname>PostgreSQL</productname> sont répartis en types de base, 
    types composites, domaines et pseudo-types.
   </para>

  <sect2>
   <title>Les types de base</title>

   <para>
    Les types de base sont ceux qui, comme <type>int4</type>, sont implantés
    sous le niveau du langage <acronym>SQL</acronym> (typiquement dans un
    langage de bas niveau comme le C). Ils correspondent généralement à ce que
    l'on appelle les types de données abstraits.  
    <productname>PostgreSQL</productname> ne peut opérer sur de tels types
    qu'au moyen de fonctions utilisateur et n'en comprend le fonctionnement que
    dans la limite de la description qu'en a fait l'utilisateur. Les types
    de base sont divisés en types scalaires et types tableaux. Pour chaque type
    scalaire, un type tableau  est automatiquement créé destiné à
    contenir des tableaux de taille variable de ce type scalaire.
   </para>
   </sect2>

  <sect2>
   <title>Les types composites</title>

   <para>
    Les types composites, ou types lignes, sont créés chaque fois qu'un
    utilisateur crée une table. Il est égalment possible de définir un type
    composite autonome sans table associée. Un type composite n'est
    qu'une simple liste de types de base avec des noms de champs associés. Une
    valeur de type composite est une ligne ou un enregistrement de valeurs de
    champ. L'utilisateur peut accéder à ces champs à partir de requêtes
    <acronym>SQL</acronym>.  La <xref linkend="rowtypes"/>
    fournit de plus amples informations sur ces types.
   </para>
  </sect2>

  <sect2>
   <title>Les domaines</title>

   <para>
    Un domaine est fondé sur un type de base particulier. Il est, dans de
    nombreux cas, interchangeable avec ce type. Mais un domaine peut également
    posséder des contraintes qui restreignent ses valeurs à un sous-ensemble des
    valeurs autorisées pour le type de base.
   </para>

    <para>
     Les domaines peuvent être créés à l'aide de la commande
     <acronym>SQL</acronym> <xref linkend="sql-createdomain"/>.
     Leurs création et utilisation n'est pas l'objet de ce chapitre.
    </para>
   </sect2>

   <sect2>
    <title>Pseudo-types</title>

   <para>   
    Il existe quelques <quote>pseudo-types</quote> pour des besoins
    particuliers. Les pseudo-types ne peuvent pas apparaître comme champs de
    table ou comme attributs de types composites, mais ils peuvent être
    utilisés pour déclarer les types des arguments et des résultats de
    fonctions. Dans le système de typage, ils fournissent un mécanisme
    d'identification des classes spéciales de fonctions. La
    <xref linkend="datatype-pseudotypes-table"/> donne la liste des
    pseudo-types qui existent.   
   </para>

   </sect2>

   <sect2 id="extend-types-polymorphic">
    <title>Types et fonctions polymorphes</title>

   <indexterm zone="extend-types-polymorphic">
    <primary>type polymorphe</primary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
    <primary>fonction polymorphe</primary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
    <primary>type</primary>
    <secondary>polymorphe</secondary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
    <primary>fonction</primary>
    <secondary>polymorphe</secondary>
   </indexterm>

   <para>
    Quatre pseudo-types sont particulièrement intéressants&nbsp;:
    <type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type> et
    <type>anyenum</type>, collectivement appelés <firstterm>types
    polymorphes</firstterm>.
    Toute fonction déclarée utiliser ces types est dite <firstterm>fonction
    polymorphe</firstterm>. Une fonction polymorphe peut opérer sur de nombreux
    types de données différents, les types de données spécifiques étant
    déterminés par les types des données réellement passés lors d'un appel
    particulier de la fonction.
   </para>

   <para>
    Les arguments et résultats polymorphes sont liés entre eux et
    sont résolus dans un type de données spécifique quand une requête faisant
    appel à une fonction polymorphe est analysée. Chaque occurrence (argument
    ou valeur de retour) déclarée comme <type>anyelement</type>
    peut prendre n'importe quel type réel de données mais, lors d'un
    appel de fonction donné, elles doivent toutes avoir le
    <emphasis>même</emphasis> type réel. Chaque occurrence déclarée comme
    <type>anyarray</type> peut prendre n'importe quel type de données tableau
    mais, de la même façon, elles doivent toutes être du
    <emphasis>même</emphasis> type. Si des occurrences sont déclarées comme
    <type>anyarray</type> et d'autres comme <type>anyelement</type>, le type
    réel de tableau des occurrences <type>anyarray</type> doit être un tableau
    dont les éléments sont du même type que ceux apparaissant dans les
    occurrences de type <type>anyelement</type>.
    <type>anynonarray</type> est traité de la même façon que
    <type>anyelement</type> mais ajoute une contrainte supplémentaire. Le type
    réel ne doit pas être un tableau. <type>anyenum</type> est traité de la même
    façon que <type>anyelement</type> mais ajoute une contrainte supplémentaire.
    Le type doit être un type enuméré.
   </para>

   <para>
    Ainsi, quand plusieurs occurrences d'argument sont déclarées avec un type
    polymorphe, seules certaines combinaisons de
    types réels d'argument sont autorisées. Par exemple, une fonction déclarée
    comme <literal>foo(anyelement, anyelement)</literal> peut prendre comme
    arguments n'importe quelles valeurs à condition qu'elles soient du même
    type de données.
   </para>

   <para>
    Quand la valeur renvoyée par une fonction est déclarée de type polymorphe,
    il doit exister au moins une occurrence d'argument également polymorphe, et
    le type réel de donnée passé comme argument détermine le type réel de
    résultat renvoyé lors de cet appel à la fonction. Par exemple, s'il
    n'existe pas déjà un mécanisme d'indexation d'éléments de
    tableau, on peut définir une fonction qui code ce mécanisme&nbsp;:
    <literal>indice(anyarray, integer) returns anyelement</literal>. La
    déclaration de fonction contraint le premier argument réel à être de type
    tableau et permet à l'analyseur d'inférer le type correct de résultat à
    partir du type réel du premier argument. Une fonction déclarée de cette
    façon <literal>f(anyarray) returns anyenum</literal> n'accepte que des
    tableaux contenant des valeurs de type enum.
    </para>

    <para>
     <type>anynonarray</type> et <type>anyenum</type> ne représentent
     pas des variables de type séparé&nbsp;; elles sont du même type que
     <type>anyelement</type>, mais avec une contrainte supplémentaire. Par
     exemple, déclarer une fonction <literal>f(anyelement, anyenum)</literal>
     est équivalent à la déclarer <literal>f(anyenum, anyenum)</literal>&nbsp;:
     les deux arguments réels doivent être du même type enum.
    </para>

    <para>
     Une fonction variadic (c'est-à-dire une fonction acceptant un nombre
     variable d'arguments, comme dans <xref
     linkend="xfunc-sql-variadic-functions"/>) peut être polymorphique&nbsp;:
     cela se fait en déclarant son dernier paramètre <literal>VARIADIC</literal>
     <type>anyarray</type>. Pour s'assurer de la correspondance des arguments
     et déterminer le type de la valeur en retour, ce type de fonction se
     comporte de la même façon que si vous aviez écrit le nombre approprié de
     paramètres <type>anynonarray</type>.
    </para>
  </sect2>
 </sect1>

  &xfunc;
  &xaggr;
  &xtypes;
  &xoper;
  &xindex;

  <sect1 id="extend-Cpp">
   <title>Utiliser le langage C++</title>

   <indexterm zone="extend-Cpp">
    <primary>C++</primary>
   </indexterm>

   <para>
    Il est possible d'utiliser un compilateur C++ pour construire des
    extensions <productname>PostgreSQL</productname> en suivant les règles
    suivantes&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
        Toutes les fonctions utilisées par le serveur doivent présentées une
        interface C au serveur&nbsp;; ces fonctions C peuvent ensuite appeler
        des fonctions C++. Par exemple, le lien <literal>extern C</literal>
        est requis pour les fonctions utilisées par le serveur. Il est aussi
        nécessaire que chaque fonction passée comme pointeur entre le serveur
        et le code C++.
      </para>
     </listitem>
     <listitem>
      <para>
       Libérer la mémoire en utilisant la méthode appropriée de libération.
       Par exemple, la majorité de la mémoire serveur est allouée en utilisant
       la fonction <function>palloc()</function>, donc utilisez
       <function>pfree()</function> pour la libérer. Utiliser la fonction
       <function>delete()</function> de C++ pour ces cas échouera.
      </para>
     </listitem>
     <listitem>
      <para>
       Empêcher la propagation des exceptions dans le code C (utilisez un
       bloc capable de récupérer toutes les exceptions au plus haut niveau des
       fonctions <literal>extern C</literal>). Ceci est nécessaire même si le
       code C++ ne renvoie aucune exceptions car les événements comme les
       manques de mémoire renvoient toujours des exceptions. Toute exception
       doit être récupérée et une erreur appropriée doit être envoyée à
       l'interface C. Si possible, compilez C++ avec l'option
       <option>-fno-exceptions</option> pour complètement éliminer les
       exceptions&nbsp;; dans ce cas, vous devez vérifier les erreurs dans
       votre code C++, par exemple vérifier le renvoi de NULL suite à l'appel
       de la méthode <function>new()</function>.
      </para>
     </listitem>
     <listitem>
      <para>
       S'il doit y avoir des appels aux fonctions du serveur à partir du code
       C++, assurez-vous que la pile d'appels C++ contient seulement l'ancienne
       structure de données (<acronym>POD</acronym>). Cela est nécessaire
       car des erreurs du serveur génèrent un appel distant à
       <function>longjump()</function> qui ne dépile par proprement la pile
       d'appels C++ avec les objets autre que POD.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Pour résumé, il est préférable de placer le code C++ derrière un mur de
    fonctions <literal>extern C</literal> qui font l'interface avec le serveur,
    et d'éviter les fuites d'exception, de mémoire et de pile d'appels.
   </para>
  </sect1>

</chapter>
