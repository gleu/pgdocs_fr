<?xml version="1.0" encoding="UTF-8"?>
<chapter id="extend">
 <title>Étendre <acronym>SQL</acronym></title>

 <indexterm zone="extend">
  <primary>Extension de SQL</primary>
 </indexterm>

 <para>
  Les sections qui suivent présentent les possibilités d'étendre le langage
  SQL de requêtage de <productname>PostgreSQL</productname> par l'ajout&nbsp;:
  <itemizedlist spacing="compact" mark="bullet">
   <listitem>
    <para>
     de fonctions (<xref linkend="xfunc"/>)&nbsp;;
    </para>
   </listitem>
   <listitem>
    <para>
     d'agrégats (<xref linkend="xaggr"/>)&nbsp;;
    </para>
   </listitem>
   <listitem>
    <para>
     de types de données (<xref linkend="xtypes"/>)&nbsp;;
    </para>
   </listitem>
   <listitem>
    <para>
     d'opérateurs (<xref linkend="xoper"/>)&nbsp;;
    </para>
   </listitem>
   <listitem>
    <para>
     de classes d'opérateurs pour les index (<xref linkend="xindex"/>).
    </para>
   </listitem>
   <listitem>
    <para>
     d'extensions permettant de créer un paquetage d'objets qui disposent d'un point commun (voir <xref linkend="extend-extensions"/>)
    </para>
   </listitem>
  </itemizedlist>
 </para>

 <sect1 id="extend-how">
  <title>L'extensibilité</title>

  <para>
   <productname>PostgreSQL</productname> est extensible parce qu'il opère
   grâce à un système de catalogues. Quiconque est familier des systèmes de
   bases de données relationnelles standard sait que les informations
   concernant les bases, les tables, les colonnes, etc. y sont stockées dans ce
   qu'on nomme communément des catalogues systèmes (certains systèmes appellent
   cela le dictionnaire de données). Pour l'utilisateur, les catalogues
   ressemblent à des tables ordinaires, mais le <acronym>SGBD</acronym>
   y enregistre ses registres <!-- bookkeeping --> internes. À la différence
   des autres systèmes, <productname>PostgreSQL</productname> enregistre
   beaucoup d'informations dans ses catalogues&nbsp;: non seulement
   l'information concernant les tables et les colonnes, mais aussi
   l'information concernant les types de données, les fonctions, les méthodes
   d'accès, etc.
  </para>
  <para>
   Ces tables peuvent être modifiées par l'utilisateur. Qui plus est,
   puisque <productname>PostgreSQL</productname> fonde ses opérations sur ces
   tables, il peut être étendu par les utilisateurs. En comparaison, les systèmes de bases de
   données conventionnels ne peuvent être étendus qu'en modifiant les
   procédures dans le code source ou en installant des modules spécifiquement
   écrits par le vendeur du <acronym>SGBD</acronym>.
  </para>

  <para>
   De plus, le serveur <productname>PostgreSQL</productname> peut
   incorporer du code utilisateur par chargement dynamique. C'est-à-dire
   que l'utilisateur peut indiquer un fichier de code objet (par exemple une
   bibliothèque partagée) qui code un nouveau type ou une nouvelle fonction
   et <productname>PostgreSQL</productname> le charge au besoin.
   Il est encore plus facile d'ajouter au serveur du code écrit en
   <acronym>SQL</acronym>. La possibilité de modifier son fonctionnement
   <quote>à la volée</quote> fait de <productname>PostgreSQL</productname>
   un outil unique pour le prototypage rapide de nouvelles applications et
   de structures de stockage.
  </para>

 </sect1>

 <sect1 id="extend-type-system">
  <title>Le système des types de <productname>PostgreSQL</productname></title>

  <indexterm zone="extend-type-system">
   <primary>type de base</primary>
  </indexterm>

  <indexterm zone="extend-type-system">
   <primary>type de données</primary>
   <secondary>base</secondary>
  </indexterm>

  <indexterm zone="extend-type-system">
   <primary>type composé</primary>
  </indexterm>

  <indexterm zone="extend-type-system">
   <primary>type de données</primary>
   <secondary>composé</secondary>
  </indexterm>

  <indexterm zone="extend-type-system">
   <primary>type conteneur</primary>
  </indexterm>

  <indexterm zone="extend-type-system">
   <primary>type de données</primary>
   <secondary>conteneur</secondary>
  </indexterm>

  <para>
   Les types de données de <productname>PostgreSQL</productname> sont répartis
   en types de base, types conteneurs, domaines et pseudo-types.
  </para>

  <sect2>
   <title>Les types de base</title>

   <para>
    Les types de base sont ceux qui, comme <type>integer</type>, sont implantés
    sous le niveau du langage <acronym>SQL</acronym> (typiquement dans un
    langage de bas niveau comme le C). Ils correspondent généralement à ce que
    l'on appelle les types de données abstraits.
    <productname>PostgreSQL</productname> ne peut opérer sur de tels types
    qu'au moyen de fonctions utilisateur et n'en comprend le fonctionnement que
    dans la limite de la description qu'en a fait l'utilisateur. Les types de
    base internes sont décrits dans <xref linkend="datatype"/>.
   </para>

   <para>
    Les types énumérés (enum) peuvent être considérés comme une sous-catégorie
    des types de base. La différence principale est qu'ils peuvent être créés
    en utilisant juste les commandes <acronym>SQL</acronym>, sans
    programmation de bas niveau. Référez-vous à <xref
    linkend="datatype-enum"/> pour plus d'informations.
   </para>
  </sect2>

  <sect2>
   <title>Les types conteneurs</title>

   <para>
    <productname>PostgreSQL</productname> a trois genres de types
    <quote>conteneurs</quote>, qui sont des types contenant plusieurs valeurs
    d'autres types. Ce sont des tableaux, des valeurs composites et des
    intervalles.
   </para>

   <para>
    Les tableaux peuvent contenir plusieurs valeurs qui sont toutes du même
    type. Un type tableau est automatiquement créé pour chaque type de base,
    type composite, type intervalle et type domaine. Par contre, il n'y a pas
    de tableaux de tableaux. Pour ce qui concerne le système de typage, les
    tableaux multi-dimensionnels sont identiques aux tableaux
    uni-dimensionnels. Référez-vous à <xref linkend="arrays"/> pour plus
    d'informations.
   </para>

   <para>
    Les types composites, ou types lignes, sont créés chaque fois qu'un
    utilisateur crée une table. Il est également possible de définir un type
    composite autonome sans table associée. Un type composite n'est
    qu'une simple liste de types de base avec des noms de champs associés. Une
    valeur de type composite est une ligne ou un enregistrement de valeurs de
    champ. La <xref linkend="rowtypes"/>
    fournit de plus amples informations sur ces types.
   </para>

   <para>

    Un type intervalle (<foreignphrase>range</foreignphrase>) peut contenir
    deux valeurs de même type, qui sont les bornes inférieure et supérieure de
    l'intervalle. Les types intervalle sont créés par les utilisateurs,
    bien que quelques-uns soient intégrés.

    Référez-vous à <xref linkend="rangetypes"/> pour plus d'informations.
   </para>
  </sect2>

  <sect2 id="extend-type-system-domains">
   <title>Les domaines</title>

   <para>
    Un domaine est basé sur un type sous-jacent donné particulier, et est
    interchangeable avec ce type dans beaucoup d'utilisations. Cependant,
    un domaine peut avoir des contraintes restreignant ses valeurs à un
    sous-ensemble de ce que permet le type sous-jacent. Les domaines sont
    créés avec la fonction <acronym>SQL</acronym> <xref linkend="sql-createdomain"/>.
    Référez-vous à <xref linkend="domains"/> pour plus d'informations.
   </para>
  </sect2>

  <sect2>
   <title>Pseudo-types</title>

   <para>
    Il existe quelques <quote>pseudo-types</quote> pour des besoins
    particuliers. Les pseudo-types ne peuvent pas apparaître comme champs de
    table ou comme composants de types conteneurs, mais ils peuvent être
    utilisés pour déclarer les types des arguments et des résultats de
    fonctions. Dans le système de typage, ils fournissent un mécanisme
    d'identification des classes spéciales de fonctions. La
    <xref linkend="datatype-pseudotypes-table"/> donne la liste des
    pseudo-types qui existent.
   </para>

  </sect2>

  <sect2 id="extend-types-polymorphic">
   <title>Types et fonctions polymorphes</title>

   <indexterm zone="extend-types-polymorphic">
    <primary>type polymorphe</primary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
    <primary>fonction polymorphe</primary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
    <primary>type</primary>
    <secondary>polymorphe</secondary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
    <primary>fonction</primary>
    <secondary>polymorphe</secondary>
   </indexterm>

   <para>
    Les pseudo-types ayant un intérêt particulier sont les <firstterm>types
     polymorphiques</firstterm>, utilisés pour déclarer des
    <firstterm>fonctions polymorphiques</firstterm>. Cette puissante
    fonctionnalité permet à une définition unique de fonction d'opérer sur
    différents types de données, le type de données étant déterminé par le
    type passé lors d'un appel donné. Les types polymorphiques sont indiqués
    dans <xref linkend="extend-types-polymorphic-table"/>. Quelques exemples
    de leurs usages apparaissent dans <xref
    linkend="xfunc-sql-polymorphic-functions"/>.
   </para>

   <table id="extend-types-polymorphic-table">
    <title>Types polymorphiques</title>
    <tgroup cols="3">
     <colspec colname="col1" colwidth="2*"/>
     <colspec colname="col2" colwidth="1*"/>
     <colspec colname="col3" colwidth="2*"/>
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Famille</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><type>anyelement</type></entry>
       <entry>Simple</entry>
       <entry>Indique qu'une fonction accepte n'importe quel type de données</entry>
      </row>

      <row>
       <entry><type>anyarray</type></entry>
       <entry>Simple</entry>
       <entry>Indique qu'une fonction accepte n'importe quel type de données tableau.</entry>
      </row>

      <row>
       <entry><type>anynonarray</type></entry>
       <entry>Simple</entry>
       <entry>Indique qu'une fonction accepte n'importe quel type de données
        qui n'est pas un tableau</entry>
      </row>

      <row>
       <entry><type>anyenum</type></entry>
       <entry>Simple</entry>
       <entry>Indique que cette fonction accepte n'importe quel type de données enum
        (voir <xref linkend="datatype-enum"/>)
       </entry>
      </row>

      <row>
       <entry><type>anyrange</type></entry>
       <entry>Simple</entry>
       <entry>Indique que cette fonction accepte n'importe quel type interval
        (voir <xref linkend="rangetypes"/>)
       </entry>
      </row>

      <row>
       <entry><type>anymultirange</type></entry>
       <entry>Simple</entry>
       <entry>Indique qu'une fonction accepte tout type de données multirange
       (voir <xref linkend="rangetypes"/>)
       </entry>
      </row>

      <row>
       <entry><type>anycompatible</type></entry>
       <entry>Common</entry>
       <entry>
        Indique que la fonction accepte n'importe quel type de données, avec
        promotion automatique d'arguments multiples en un type de données commun.
       </entry>
      </row>

      <row>
       <entry><type>anycompatiblearray</type></entry>
       <entry>Common</entry>
       <entry>
        Indique que la fonction accepte n'importe quel type de données tableau, avec
        promotion automatique d'arguments multiples en un type de données commun.
       </entry>
      </row>

      <row>
       <entry><type>anycompatiblenonarray</type></entry>
       <entry>Common</entry>
       <entry>
        Indique que la fonction accepte n'importe quel type de données qui
        n'est pas un tableau, avec promotion automatique d'arguments multiples
        en un type de données commun.
       </entry>
      </row>

      <row>
       <entry><type>anycompatiblerange</type></entry>
       <entry>Common</entry>
       <entry>
        Indique que la fonction accepte n'importe quel type de données interval, avec
        promotion automatique d'arguments multiples en un type de données commun.
       </entry>
      </row>

      <row>
       <entry><type>anycompatiblemultirange</type></entry>
       <entry>Common</entry>
       <entry>Indique qu'une fonction accepte tout type de données multirange,
       avec une promotion automatique de plusieurs arguments vers un type de
       données commun</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Les arguments et résultats polymorphes sont liés entre eux et sont résolus
    dans un type de données spécifique quand une requête faisant appel à une
    fonction polymorphe est analysée. Quand il y a plus d'un argument
    polymorphique, les types de données courants doivent correspondre comme
    décrit ci-dessous. Si le type de résultat de la fonction est
    polymorphique, or que ses arguments de sortie sont de types
    polymorphiques, alors les types de ces résultats sont déduits par les
    types polymorphiques en entrée présents comme décrit ci-dessous.
   </para>

   <para>
    Pour les types polymorphiques de famille <quote>simple</quote>, la
    correspondance et les règles de déduction fonctionnent ainsi&nbsp;:
   </para>

   <para>
    Chaque occurrence (argument
    ou valeur de retour) déclarée comme <type>anyelement</type>
    peut prendre n'importe quel type réel de données mais, lors d'un
    appel de fonction donné, elles doivent toutes avoir le
    <emphasis>même</emphasis> type réel. Chaque occurrence déclarée comme
    <type>anyarray</type> peut prendre n'importe quel type de données tableau.
    De façon similaire, les occurences déclarées en tant que
    <type>anyrange</type> doivent toutes être du même type.
    <type>anymultirange</type>.
   </para>

   <para>
    De la même façon, si des occurrences sont déclarées comme
    <type>anyarray</type> et d'autres comme <type>anyelement</type> ou
    <type>anyarray</type>, le type réel de tableau des occurrences
    <type>anyarray</type> doit être un tableau dont les éléments sont du même
    type que ceux apparaissant dans les occurrences de type
    <type>anyelement</type>. <type>anynonarray</type> est traité de la même
    façon que <type>anyelement</type> mais ajoute une contrainte
    supplémentaire. Le type réel ne doit pas être un tableau.
    <type>anyenum</type> est traité de la même façon que
    <type>anyelement</type> mais ajoute une contrainte supplémentaire. Le
    type doit être un type enuméré.
   </para>

   <para>
    De façon similaire, S'il existe des positions déclarées
    <type>anyrange</type> et d'autres déclarées <type>anyelement</type> ou
    <type>anyarray</type>, le type intervalle réel dans les positions
    <type>anyrange</type> doit être un intervalle dont le sous-type est le
    même type apparaissant dans les positions <type>anyelement</type> et le
    même que le type élément des positions <type>anyarray</type>. S'il existe
    des positions déclarées <type>anymultirange</type>, leur type multirange
    réel doit contenir des intervalles correspondant aux paramètres déclarés
    <type>anyrange</type> et des éléments de base correspondant aux
    paramètres déclarés <type>anyelement</type> et <type>anyarray</type>.
   </para>

   <para>
    Ainsi, quand plusieurs occurrences d'argument sont déclarées avec un type
    polymorphe, seules certaines combinaisons de
    types réels d'argument sont autorisées. Par exemple, une fonction déclarée
    comme <literal>foo(anyelement, anyelement)</literal> peut prendre comme
    arguments n'importe quelles valeurs à condition qu'elles soient du même
    type de données.
   </para>

   <para>
    Quand la valeur renvoyée par une fonction est déclarée de type polymorphe,
    il doit exister au moins une occurrence d'argument également polymorphe, et
    le type réel de donnée passé comme argument détermine le(s) type(s) réel(s)
    du résultat renvoyé lors de cet appel à la fonction. Par exemple, s'il
    n'existe pas déjà un mécanisme d'indexation d'éléments de
    tableau, on peut définir une fonction qui code ce mécanisme&nbsp;:
    <literal>indice(anyarray, integer) returns anyelement</literal>. La
    déclaration de fonction contraint le premier argument réel à être de type
    tableau et permet à l'analyseur d'inférer le type correct de résultat à
    partir du type réel du premier argument. Une fonction déclarée de cette
    façon <literal>f(anyarray) returns anyenum</literal> n'accepte que des
    tableaux contenant des valeurs de type enum.
   </para>

   <para>
    Dans la plupart des cas, l'analyseur peut inférer que le type de données
    réel pour un type résultat polymorphique pour des arguments qui sont d'un
    type polymorphique différent dans la même famille&nbsp; par exemple
    <type>anyarray</type> peut
    être déduit à partir de <type>anyelement</type> et vice versa. Une exception
    est qu'un résultat polymorphique de type <type>anyrange</type> nécessite
    un argument de type <type>anyrange</type>&nbsp;; il ne peut pas être
    déduit d'arguments <type>anyarray</type> ou <type>anyelement</type>. Ceci
    est dû au fait qu'il pourrait y avoir plusieurs types d'intervalles avec
    le même sous-type.
   </para>

   <para>
    <type>anynonarray</type> et <type>anyenum</type> ne représentent
    pas des variables de type séparé&nbsp;; elles sont du même type que
    <type>anyelement</type>, mais avec une contrainte supplémentaire. Par
    exemple, déclarer une fonction <literal>f(anyelement, anyenum)</literal>
    est équivalent à la déclarer <literal>f(anyenum, anyenum)</literal>&nbsp;:
    les deux arguments réels doivent être du même type enum.
   </para>

   <para>
    Pour la famille de types polymorphiques <quote>common</quote>, la
    correspondance et les règles de déduction fonctionnent presque pareilles
    que pour la famille <quote>simple</quote>, avec une différence majeure&nbsp;:
    les types courants des arguments n'ont pas besoin d'être identiques,
    aussi longtemps qu'ils peuvent être implicitement convertis en un type commun simple.
    Le type commun est sélectionné en suivant la même règle que pour <literal>UNION</literal>
    et les constructions liées (voir <xref linkend="typeconv-union-case"/>).
    La sélection du type commun considère les types présents
    <type>anycompatible</type> et <type>anycompatiblenonarray</type> en entrée,
    les éléments de type tableau <type>anycompatiblearray</type> en entrée, et
    les sous-types <type>anycompatiblerange</type> et
    <type>anycompatiblemultirange</type> en entrée.
    Si <type>anycompatiblenonarray</type> est présent, alors le type commun doit
    être un type qui n'est pas un tableau. Une fois le type commun identifié, les arguments
    en position <type>anycompatible</type> et <type>anycompatiblenonarray</type>
    sont automatiquement convertis en ce type, et les arguments en position
    <type>anycompatiblearray</type> sont automatiquement convertis en type tableau
    pour ce type.

   </para>

   <para>
    Du fait qu'il n'y a pas de moyen de sélectionner le type interval à partir
    uniquement de son sous-type, l'usage de <type>anycompatiblerange</type>
    et/ou <type>anycompatiblemultirange</type> requiert que tous les
    arguments déclarés avec ce type aient le même type range et/ou
    multirange, et que le type du sous-type est en accord avec le type commun
    sélectionné, pour qu'il n'y ait pas de conversion nécessaire de la valeur
    de l'intervalle. Comme avec <type>anyrange</type> et
    <type>anymultirange</type>, l'usage de <type>anycompatiblerange</type> et
    <type>anymultirange</type> en tant que type de résultat de fonction
    demande qu'il y ait un argument <type>anycompatiblerange</type> ou
    <type>anycompatiblemultirange</type>.
   </para>

   <para>
    Notez qu'il n'y a aucun type <type>anycompatibleenum</type>. Un tel
    type ne serait pas très utile, du fait qu'il n'y a normalement aucune
    conversion implicite de types enum, signifiant ainsi qu'il n'y aura aucune
    façon de résoudre un type commun pour des entrées enum différentes.
   </para>

   <para>
    Les familles polymorphiques <quote>simple</quote> et <quote>common</quote>
    représentent deux ensembles de types de variable indépendants. Considérez
    par exemple&nbsp;:
    <programlisting>
CREATE FUNCTION myfunc(a anyelement, b anyelement,
                       c anycompatible, d anycompatible)
RETURNS anycompatible AS ...
    </programlisting>
    Dans un appel de cette fonction, les deux premières entrées doivent avoir
    le même type exact. Les deux dernières entrées doivent être convertibles
    en un type commun, mais ce type nécessite d'être complétement différent du type
    des deux premières entrées. Le résultat aura le type commun des deux
    dernières entrées.
   </para>

   <para>
    Une fonction variadic (c'est-à-dire une fonction acceptant un nombre
    variable d'arguments, comme dans <xref
    linkend="xfunc-sql-variadic-functions"/>) peut être polymorphique&nbsp;:
    cela se fait en déclarant son dernier paramètre <literal>VARIADIC</literal>
    <type>anyarray</type> ou <literal>VARIADIC</literal>
    <type>anycompatiblearray</type>. Pour s'assurer de la correspondance des
    arguments et déterminer le type de la valeur en retour, ce type de
    fonction se comporte de la même façon que si vous aviez écrit le nombre
    approprié de paramètres <type>anynonarray</type> ou
    <type>anycompatiblenonarray</type>.
   </para>
  </sect2>
 </sect1>

 &xfunc;
 &xaggr;
 &xtypes;
 &xoper;
 &xindex;

 <sect1 id="extend-extensions">
  <title>Empaqueter des objets dans une extension</title>

  <indexterm zone="extend-extensions">
   <primary>extension</primary>
  </indexterm>

  <para>
   Une extension à <productname>PostgreSQL</productname> utile contient généralement
   plusieurs objets SQL. Par exemple, un nouveau type de données va nécessiter de
   nouvelles fonctions, de nouveaux opérateurs et probablement de nouvelles méthodes
   d'indexation.
   Il peut être utile de les grouper en un unique paquetage pour simplifier la gestion
   des bases de données. Avec <productname>PostgreSQL</productname>, ces paquetages sont
   appelés <firstterm>extension</firstterm>. Pour créer une extension, vous avez besoin
   au minimum d'un <firstterm>fichier de script</firstterm> qui contient les commandes
   <acronym>SQL</acronym> permettant de créer ses objets, et un
   <firstterm>fichier de contrôle</firstterm> qui rapporte quelques propriétés de base
   de cette extension. Si cette extension inclut du code C, elle sera aussi généralement
   accompagnée d'une bibliothèque dans lequel le code C aura été compilé.
   Une fois ces fichiers en votre possession, un simple appel à la commande
   <link linkend="sql-createextension"><command>CREATE EXTENSION</command></link> vous permettra de charger ses objets dans la base
   de données.
  </para>

  <para>
   Le principal avantage des extensions n'est toutefois pas de pouvoir de charger une
   grande quantité d'objets dans votre base de donnée. Les extensions permettent en effet
   surtout à <productname>PostgreSQL</productname> de comprendre que ces objets sont liés par cette
   extension. Vous pouvez par exemple supprimer tous ces objets avec une simple commande
   <link linkend="sql-dropextension"><command>DROP EXTENSION</command></link>. Il n'est
   ainsi pas nécessaire de maintenir un script de
   <quote>désinstallation</quote>.
   Plus utile encore, l'outil <application>pg_dump</application> saura reconnaître les objets
   appartenant à une extension et, plutôt que de les extraire individuellement, ajoutera simplement
   une commande <command>CREATE EXTENSION</command> à la sauvegarde.
   Ce mécanisme simplifie aussi la migration à une nouvelle version de l'extension
   qui peut contenir de nouveaux objets ou des objets différents de la version d'origine.
   Notez bien toutefois qu'il est nécessaire de disposer des fichiers de contrôles, de script,
   et autres pour permettre la restauration d'une telle sauvegarde dans une nouvelle base
   de donnée.
  </para>

  <para>
   <productname>PostgreSQL</productname> ne vous laissera pas supprimer
   de manière individuelle les objets d'une extension sans supprimer
   l'extension tout entière.
   Aussi, bien que vous ayez la possibilité de modifier la définition d'un objet inclus dans
   une extension (par exemple via la commande <command>CREATE OR REPLACE FUNCTION</command> dans
   le cas d'une fonction), il faut garder en tête que cette modification ne sera pas sauvegardée
   par l'outil <application>pg_dump</application>. Une telle modification n'est en pratique raisonnable
   que si vous modifiez parallèlement le fichier de script de l'extension. Il existe toutefois des
   cas particuliers comme celui des tables qui contiennent des données de
   configuration (voir <xref linkend="extend-extensions-config-tables"/>.)
   Dans les situations de production, il est généralement préférable de créer
   un script de mise à jour de l'extension pour réaliser les modifications sur
   les objets membres de l'extension.
  </para>

  <para>
   Le script de l'extension peut mettre en place des droits sur les objets qui
   font partie de l'extension via les instructions <command>GRANT</command> et
   <command>REVOKE</command>. La configuration finale des droits pour chaque
   objet (si des droits sont à configurer) sera enregistrée dans le catalogue
   système <link
   linkend="catalog-pg-init-privs"><structname>pg_init_privs</structname></link>.
   Quand <application>pg_dump</application> est utilisé, la commande
   <command>CREATE EXTENSION</command> sera inclue dans la sauvegarde, suivi
   de la mise en place des instructions <command>GRANT</command> et
   <command>REVOKE</command> pour configurer les droits sur les objets, tels
   qu'ils étaient au moment où la sauvegarde a été faite.
  </para>

  <para>
   <productname>PostgreSQL</productname> ne supporte pas l'exécution
   d'instructions <command>CREATE POLICY</command> et <command>SECURITY
    LABEL</command> par le script. Elles doivent être exécutées après la
   création de l'extension. Toutes les politiques RLS et les labels de
   sécurité placés sur les objets d'une extension seront inclus dans les
   sauvegardes créées par <application>pg_dump</application>.
  </para>

  <para>
   Il existe aussi un mécanisme permettant de créer des scripts de mise à jour de la définition des objets
   <acronym>SQL</acronym> contenus dans une extension.
   Par exemple, si la version 1.1 d'une extension ajoute une fonction et change le corps d'une autre
   vis-à-vis de la version 1.0 d'origine, l'auteur de l'extension peut fournir un <firstterm>script
    de mise à jour</firstterm> qui effectue uniquement ces deux modifications. La commande <command>
    ALTER EXTENSION UPDATE</command> peut alors être utilisée pour appliquer ces changements et vérifier
   quelle version de l'extension est actuellement installée sur une base de donnée spécifiée.
  </para>

  <para>
   Les catégories d'objets <acronym>SQL</acronym> qui peuvent être inclus dans une extension
   sont spécifiées dans la description de la commande <link linkend="sql-alterextension"><command>ALTER EXTENSION</command></link>.
   D'une manière générale, les objets qui sont communs à l'ensemble de la base ou du cluster,
   comme les bases de données, les rôles, les tablespaces ne peuvent être inclus dans une
   extension car une extension n'est référencée qu'à l'intérieur d'une base de donnée.
   À noter que rien n'empêche la création de fichier de script qui crée de tels objets, mais
   qu'ils ne seront alors pas considérés après leur création comme faisant partie de l'extension.
   À savoir en outre que bien que les tables puissent être incluses dans une extension, les objets
   annexes tels que les index ne sont pas automatiquement inclus dans l'extension et devront être
   explicitement mentionnés dans les fichiers de script.
  </para>

  <para>
   Si un script d'extension créé n'importe quel objet temporaire (comme des
   tables temporaires), ces objets seront traités comme des membres de
   l'extension pour le reste de la session courante, mais seront
   automatiquement supprimés à la fin de la session, tout comme n'importe quel
   objet temporaire le serait également.  C'est une exception à la règle que
   les objets membres d'une extension ne peuvent pas être supprimés sans
   supprimer l'intégralité de l'extension.
  </para>

  <sect2>
   <title>Fichiers des extensions</title>

   <indexterm>
    <primary>Fichier de contrôle</primary>
   </indexterm>

   <para>
    La commande <command>CREATE EXTENSION</command> repose sur un fichier de contrôle
    associé à chaque extension. Ce fichier doit avoir le même nom que l'extension suivi du suffixe
    <literal>.control</literal>, et doit être placé dans le sous-répertoire <literal>SHAREDIR/extension</literal>
    du répertoire d'installation. Il doit être accompagné d'au moins un fichier de script <acronym>SQL</acronym>
    dont le nom doit répondre à la syntaxe <literal><replaceable>extension</replaceable>--<replaceable>version</replaceable>.sql</literal>
    (par exemple, <literal>foo--1.0.sql</literal> pour la version <literal>1.0</literal> de l'extension <literal>foo</literal>).
    Par défaut, les fichiers de script sont eux-aussi situés dans le répertoire <literal>SHAREDIR/extension</literal>. Le fichier
    de contrôle peut toutefois spécifier un répertoire différent pour chaque fichier de script.
   </para>

   <para>
    Le format du fichier de contrôle d'une extension est le même que pour le
    fichier <filename>postgresql.conf</filename>, à savoir une liste d'affectation
    <replaceable>nom_paramètre</replaceable> <literal>=</literal> <replaceable>valeur</replaceable>
    avec un maximum d'une affectation par ligne.
    Les lignes vides et les commentaires introduits par <literal>#</literal> sont eux-aussi autorisés.
    Prenez garde à placer entre guillemets les valeurs qui ne sont ni des nombres ni des mots isolés.
   </para>

   <para>
    Un fichier de contrôle peut définir les paramètres suivants&nbsp;:
   </para>

   <variablelist>
    <varlistentry>
     <term><varname>directory</varname> (<type>string</type>)</term>
     <listitem>
      <para>
       Le répertoire qui inclut les scripts <acronym>SQL</acronym> de l'extension.
       Si un chemin relatif est spécifié, le sous-répertoire <literal>SHAREDIR</literal>
       du répertoire d'installation sera choisi comme base.
       Le comportement par défaut de ce paramètre revient à le définir tel que
       <literal>directory = 'extension'</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>default_version</varname> (<type>string</type>)</term>
     <listitem>
      <para>
       La version par défaut de l'extension, qui sera installée si aucune
       version n'est spécifiée avec la commande <command>CREATE EXTENSION</command>.
       Ainsi, bien que ce paramètre puisse ne pas être précisé, il reste
       recommandé de le définir pour éviter que la commande
       <command>CREATE EXTENSION</command> ne provoque une erreur
       en l'absence de l'option <literal>VERSION</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>comment</varname> (<type>string</type>)</term>
     <listitem>
      <para>
       Un commentaire de type chaîne de caractère au sujet de l'extension. Le
       commentaire est appliqué à la création de l'extension, mais pas pendant
       les mises à jour de cette extension (car cela pourrait écraser des
       commentaires ajoutés par l'utilisateur). Une alternative consiste à
       utiliser la commande <xref linkend="sql-comment"/> dans le script de
       l'extension.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>encoding</varname> (<type>string</type>)</term>
     <listitem>
      <para>
       L'encodage des caractères utilisé par les fichiers de script. Ce paramètre
       doit être spécifié si les fichiers de script contiennent des caractères
       non ASCII. Le comportement par défaut en l'absence de ce paramètre consiste à utiliser
       l'encodage de la base de donnée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>module_pathname</varname> (<type>string</type>)</term>
     <listitem>
      <para>
       La valeur de ce paramètre sera utilisée pour toute référence à <literal>MODULE_PATHNAME</literal>
       dans les fichiers de script. Si ce paramètre n'est pas défini, la substitution ne sera pas effectuée.
       La valeur <literal>$libdir/<replaceable>nom_de_bibliothèque</replaceable></literal> lui est usuellement attribuée
       et dans ce cas, <literal>MODULE_PATHNAME</literal> est utilisé dans la commande <command>CREATE
        FUNCTION</command> concernant les fonctions en langage C, de manière à ne pas mentionner <quote>en dur</quote>
       le nom de la bibliothèque partagée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>requires</varname> (<type>string</type>)</term>
     <listitem>
      <para>
       Une liste de noms d'extension dont dépend cette extension, comme
       par exemple <literal>requires = 'foo, bar'</literal>.  Ces extensions
       doivent être installées avant que l'extension puisse être installée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>superuser</varname> (<type>boolean</type>)</term>
     <listitem>
      <para>
       Si ce paramètre est à <literal>true</literal> (il s'agit de la valeur par défaut),
       seuls les super-utilisateurs pourront créer cet extension ou la mettre à jour.
       Si ce paramètre est à <literal>false</literal>, seuls les droits nécessaires
       seront requis pour installer ou mettre à jour l'extension.
       Ce paramètre devrait normalement être mis à <literal>true</literal> si au moins
       une commandes du script nécessite les privilèges superuser. (Ces commandes
       échoueront en tous cas, mais il est plus convivial de fournir une erreur en amont.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>trusted</varname> (<type>boolean</type>)</term>
     <listitem>
      <para>
       Ce paramètre, si mis à <literal>true</literal> (qui n'est pas le défaut),
       permet à des utilisateurs standards, sans attribut <literal>SUPERUSER</literal>,
       d'installer une extension qui a
       <varname>superuser</varname> affecté à <literal>true</literal>.
       Plus précisemment, l'installation sera permise pour toute personne
       qui a le droit <literal>CREATE</literal> sur la base courante.
       Si l'utilisateur qui exécute <command>CREATE EXTENSION</command> n'est
       pas super-utilisateur mais est autorisé à installer de part ce paramètre, alors
       le script d'installation ou de mise à jour est exécuté comme bootstrap
       super-utilisateur, et non pas comme l'utilisateur appelant.
       Ce paramètre n'as pas d'effet si <varname>superuser</varname> est
       <literal>false</literal>.
       En général, le paramètre ne doit pas être mis à <literal>true</literal> pour
       les extensions qui peuvent autoriser des accès aux capacités réservées aux
       super-utilisateurs, telles que les accès au système de fichiers.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>relocatable</varname> (<type>boolean</type>)</term>
     <listitem>
      <para>
       Une extension est dite <quote>déplaçable</quote> (<firstterm>relocatable</firstterm>)
       s'il est possible de déplacer les objets qu'elle contient dans un schéma différent
       de celui attribué initialement par l'extension. La valeur par défaut est à
       <literal>false</literal>, ce qui signifie que l'extension n'est pas déplaçable.
       Voir <xref linkend="extend-extensions-relocation"/> pour des
       informations complémentaires.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>schema</varname> (<type>string</type>)</term>
     <listitem>
      <para>
       Ce paramètre ne peut être spécifié que pour les extensions non
       déplaçables. Il permet de forcer l'extension à charger ses objets dans
       le schéma spécifié et aucun autre. Le paramètre
       <varname>schema</varname> est uniquement consulté lors de la création
       initiale de l'extension, pas pendant ses mises à jour. Voir <xref
       linkend="extend-extensions-relocation"/> pour plus d'informations.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   <para>
    En complément au fichier de contrôle <literal><replaceable>extension</replaceable>.control</literal>,
    une extension peut disposer de fichiers de contrôle secondaires pour chaque version dont le nommage correspond à
    <literal><replaceable>extension</replaceable>--<replaceable>version</replaceable>.control</literal>.
    Ces fichiers doivent se trouver dans le répertoire des fichiers de script de l'extension.
    Les fichiers de contrôle secondaires suivent le même format que le fichier de contrôle principal.
    Tout paramètre spécifié dans un fichier de contrôle secondaire surcharge la valeur spécifiée dans le
    fichier de contrôle principal concernant les installations ou mises à jour à la version considérée.
    Cependant, il n'est pas possible de spécifier les paramètres <varname>directory</varname> et
    <varname>default_version</varname> dans un fichier de contrôle secondaire.
   </para>

   <para>
    Un fichier de script <acronym>SQL</acronym> d'une extension peut contenir toute commande
    SQL, à l'exception des commandes de contrôle de transaction (<command>BEGIN</command>,
    <command>COMMIT</command>, etc), et des commandes qui ne peuvent être exécutées au sein
    d'un bloc transactionnel (comme la commande <command>VACUUM</command>). Cette contrainte
    est liée au fait que les fichiers de script sont implicitement exécutés dans une transaction.
   </para>

   <para>
    Les scripts <acronym>SQL</acronym> d'une extension peuvent aussi contenir
    des lignes commençant par <literal>\echo</literal>, qui seront ignorées
    (traitées comme des commentaires) par le mécanisme d'extension. Ceci est
    souvent utilisé pour renvoyer une erreur si le script est passé à
    <application>psql</application> plutôt qu'exécuter par <command>CREATE
     EXTENSION</command> (voir un script d'exemple dans <xref
    linkend="extend-extensions-example"/>). Sans cela, les utilisateurs
    pourraient charger accidentellement le contenu de l'extension sous la
    forme d'objets <quote>autonomes</quote> plutôt que faisant partie d'une
    extension, ce qui est assez pénible à corriger.
   </para>

   <para>
    Si le script d'extension contient la chaine <literal>@extowner@</literal>,
    celle-ci est remplacé avec le nom (encadré de double apostrophe si nécessaire)
    de l'utilisateur exécutant <command>CREATE
     EXTENSION</command> ou <command>ALTER EXTENSION</command>. Habituellement,
    cette fonctionnalité est employée par les extensions notées de confiance pour
    affecter l'appropriation des objets sélectionnés par l'utilisateur exécutant plutôt
    que par le bootstrap superuser. (Il faut cependant être prudent avec cela. Par
    exemple, affecter à une fonction en langage C un propriétaire non super-utilisateur
    ouvre une voie pour une escalade de privilèges à cet utilisateur.)
   </para>

   <para>
    Bien que les fichiers de script puissent contenir n'importe quel caractère
    autorisé par l'encodage spécifié, les fichiers de contrôle ne peuvent
    contenir que des caractères ASCII non formatés. En effet,
    <productname>PostgreSQL</productname> ne peut pas déterminer l'encodage
    utilisé par les fichiers de contrôle. Dans la pratique, cela ne pose
    problème que dans le cas où vous voudriez utiliser des caractères non
    ASCII dans le commentaire de l'extension. Dans ce cas de figure, il est
    recommandé de ne pas utiliser le paramètre <varname>comment</varname> du
    fichier de contrôle pour définir ce commentaire, mais plutôt la commande
    <command>COMMENT ON EXTENSION</command> dans un fichier de script.
   </para>

  </sect2>

  <sect2 id="extend-extensions-relocation">
   <title>Possibilités concernant le déplacement des extensions</title>

   <para>
    Les utilisateurs souhaitent souvent charger les objets d'une extension
    dans un schéma différent de celui imposé par l'auteur. Trois niveaux
    de déplacement sont supportés&nbsp;:
   </para>

   <itemizedlist>
    <listitem>
     <para>
      Une extension supportant complétement le déplacement peut être déplacé
      dans un autre schéma à tout moment, y compris après son chargement
      dans une base de donnée.
      Initialement, tous les objets de l'extension installée appartiennent à un
      premier schéma (excepté les objets qui n'appartiennent à aucun schéma comme les
      langages procéduraux).
      L'opération de déplacement peut alors être réalisée avec la commande <command>ALTER EXTENSION SET SCHEMA</command>,
      qui renomme automatiquement tous les objets de l'extension pour être intégrés dans le nouveau
      schéma.  Le déplacement ne sera toutefois fonctionnel
      que si l'extension ne contient aucune référence de l'appartenance d'un de ses objets à un schéma.
      Dans ce cadre, il est alors possible de spécifier qu'une extension supporte complétement le déplacement en initialisant
      <literal>relocatable = true</literal> dans son fichier de contrôle.
     </para>
    </listitem>

    <listitem>
     <para>
      Une extension peut être déplaçable durant l'installation et ne plus l'être
      par la suite. Un exemple courant est celui du fichier de script de l'extension
      qui doit référencer un schéma cible de manière explicite pour des fonctions SQL, par exemple en définissant
      la propriété <literal>search_path</literal>.
      Pour de telles extensions, il faut définir <literal>relocatable = false</literal> dans
      son fichier de contrôle, et utiliser <literal>@extschema@</literal> pour référencer
      le schéma cible dans le fichier de script. Toutes les occurences de cette chaîne dans le
      fichier de script seront remplacées par le nom du schéma choisi avant son exécution.
      Le nom du schéma choisi peut être fixé par l'option <literal>SCHEMA</literal> de la
      commande <command>CREATE EXTENSION</command>.
     </para>
    </listitem>

    <listitem>
     <para>
      Si l'extension ne permet pas du tout le déplacement, il faut définir <literal>relocatable = false</literal>
      dans le fichier de contrôle, mais aussi définir <literal>schema</literal> comme étant le nom du schéma cible.
      Cette précaution permettra d'empêcher l'usage de l'option <literal>SCHEMA</literal> de la commande <command>CREATE
       EXTENSION</command>, à moins que cette option ne référence la même valeur que celle spécifiée dans le fichier de
      contrôle. Ce choix est à priori nécessaire si l'extension contient des références à des noms
      de schéma qui ne peuvent être remplacés par <literal>@extschema@</literal>. À noter que même si son usage reste
      relativement limité dans ce cas de figure puisque le nom du schéma est alors fixé dans le fichier de contrôle,
      le mécanisme de substitution de <literal>@extschema@</literal> reste toujours opérationnel.
     </para>
    </listitem>
   </itemizedlist>

   <para>
    Dans tous les cas, le fichier de script sera exécuté avec comme valeur de <xref linkend="guc-search-path"/>
    le schéma cible. Cela signifie que la commande <command>CREATE EXTENSION</command> réalisera l'équivalent
    de la commande suivante :
    <programlisting>
SET LOCAL search_path TO @extschema@, pg_temp;
    </programlisting>
    Cela permettra aux objets du fichier de script d'être créés dans le schéma cible. Le fichier de script
    peut toutefois modifier la valeur de <varname>search_path</varname> si nécessaire, mais cela n'est
    généralement pas le comportement souhaité. La variable <varname>search_path</varname> retrouvera sa valeur
    initiale à la fin de l'exécution de la commande <command>CREATE EXTENSION</command>.
   </para>

   <para>
    Le schéma cible est déterminé par le paramètre <varname>schema</varname> dans le
    fichier de contrôle s'il est précisé, sinon par l'option <literal>SCHEMA</literal>
    de la commande <command>CREATE EXTENSION</command> si elle est spécifiée, sinon
    par le schéma de création par défaut actuel (le premier rencontré en suivant le
    chemin de recherche <varname>search_path</varname> de l'appelant). Quand le paramètre
    <varname>schema</varname> du fichier de contrôle est utilisé, le schéma cible sera créé
    s'il n'existe pas encore. Dans les autres cas, il devra exister au préalable.
   </para>

   <para>
    Si des extensions requises sont définies par <varname>requires</varname> dans le fichier
    de contrôle, leur schéma cible est ajouté à la valeur initiale de
    <varname>search_path</varname>, d'après le schéma cible de la nouvelle
    extension.
    Cela permet à leurs objets d'être visibles dans le fichier de script de l'extension installée.
   </para>

   <para>
    Pour des raisons de sécurité, <literal>pg_temp</literal> est ajouté
    automatiquement à la fin de <varname>search_path</varname> dans tous les
    cas.
   </para>

   <para>
    Une extension peut contenir des objets répartis dans plusieurs schémas.
    Il est alors conseillé de regrouper dans un unique schéma l'ensemble des objets destinés à un usage
    externe à l'extension, qui sera alors le schéma cible de l'extension. Une telle organisation est compatible
    avec la définition par défaut de <varname>search_path</varname> pour la création d'extensions
    qui en seront dépendantes.
   </para>
  </sect2>

  <sect2 id="extend-extensions-config-tables">
   <title>Tables de configuration des extensions</title>

   <para>
    Certaines extensions incluent des tables de configuration, contenant
    des données qui peuvent être ajoutées ou changées par l'utilisateur
    après l'installation de l'extension. Normalement, si la table fait
    partie de l'extension, ni la définition de la table, ni son contenu
    ne sera sauvegardé par <application>pg_dump</application>. Mais
    ce comportement n'est pas celui attendu pour une table de configuration.
    Les données modifiées par un utilisateur nécessitent d'être sauvegardées,
    ou l'extension aura un comportement différent après rechargement.
   </para>

   <indexterm>
    <primary>pg_extension_config_dump</primary>
   </indexterm>

   <para>
    Pour résoudre ce problème, un fichier de script d'extension peut marquer
    une table ou une séquence comme étant une relation de configuration, ce qui indiquera à <application>pg_dump</application>
    d'inclure le contenu de la table ou de la séquence (et non sa définition) dans la sauvegarde. Pour cela, il s'agit d'appeler
    la fonction <function>pg_extension_config_dump(regclass, text)</function> après avoir
    créé la table ou la séquence, par exemple
    <programlisting>
CREATE TABLE my_config (key text, value text);
CREATE SEQUENCE my_config_seq;

SELECT pg_catalog.pg_extension_config_dump('my_config', '');
SELECT pg_catalog.pg_extension_config_dump('my_config_seq', '');
    </programlisting>
    Cette fonction permet de marquer autant de tables ou de séquences
    que nécessaire. Les séquences associées avec des colonnes de type
    <type>serial</type> ou <type>bigserial</type> peuvent être marquées
    ainsi.
   </para>

   <para>
    Si le second argument de <function>pg_extension_config_dump</function> est une
    chaîne vide, le contenu entier de la table sera sauvegardé par l'application
    <application>pg_dump</application>. Cela n'est correct que si la table
    était initialement vide après l'installation du script. Si un mélange de données
    initiales et de données ajoutées par l'utilisateur est présent dans la table,
    le second argument de <function>pg_extension_config_dump</function> permet de
    spécifier une condition <literal>WHERE</literal> qui sélectionne les données à
    sauvegarder.
    Par exemple, vous pourriez faire
    <programlisting>
CREATE TABLE my_config (key text, value text, standard_entry boolean);

SELECT pg_catalog.pg_extension_config_dump('my_config', 'WHERE NOT standard_entry');
    </programlisting>
    et vous assurer que la valeur de <structfield>standard_entry</structfield> soit
    true uniquement lorsque les lignes ont été créées par le script de l'extension.
   </para>

   <para>
    Pour les séquences, le deuxième argument de <function>pg_extension_config_dump</function>
    n'a pas d'effet.
   </para>

   <para>
    Des situations plus compliquées, comme des données initiales qui peuvent être modifiées
    par l'utilisateur, peuvent être prises en charge en créant des triggers sur la table de configuration
    pour s'assurer que les lignes ont été marquées correctement.
   </para>

   <para>
    Vous pouvez modifier la condition du filtre associé avec une table de
    configuration en appelant de nouveau
    <function>pg_extension_config_dump</function>. (Ceci serait typiquement
    utile dans un script de mise à jour d'extension.)  La seule façon de marquer
    une table est de la dissocier de l'extension avec la commande
    <command>ALTER EXTENSION ... DROP TABLE</command>.
   </para>

   <para>
    Notez que les relations de clés étrangères entre ces tables dicteront
    l'ordre dans lequel les tables seront sauvegardées par pg_dump. Plus
    spécifiquement, pg_dump tentera de sauvegarder en premier la table
    référencé, puis la table référante. Comme les relations de clés étrangères
    sont configurées lors du CREATE EXTENSION (avant que les données ne soient
    chargées dans les tables), les dépendances circulaires ne sont pas gérées.
    Quand des dépendances circulaires existent, les données seront toujours
    sauvegardées mais ne seront pas restaurables directement. Une intervention
    de l'utilisateur sera nécessaire.
   </para>

   <para>
    Les séquences associées avec des colonnes de type <type>serial</type> ou
    <type>bigserial</type> doivent être directement marquées pour sauvegarder
    leur état. Marquer la relation parent n'est pas suffisant pour ça.
   </para>
  </sect2>

  <sect2>
   <title>Mise à jour d'extension</title>

   <para>
    Un des avantages du mécanisme d'extension est de proposer un moyen
    simple de gérer la mise à jour des commandes SQL qui définissent les objets
    de l'extension. Cela est rendu possible par l'association d'un nom ou d'un numéro
    de version à chaque nouvelle version du script d'installation de l'extension.
    En complément, si vous voulez qu'un utilisateur soit capable de mettre à jour
    sa base de données dynamiquement d'une version à une autre, vous pouvez
    fournir <firstterm>des scripts de mise à jour</firstterm> qui feront les
    modifications nécessaires. Les scripts de mise à jour ont un nom qui correspond au format
    <literal><replaceable>extension</replaceable>--<replaceable>ancienne_version</replaceable>--<replaceable>nouvelle_version</replaceable>.sql</literal>
    (par exemple, <literal>foo--1.0--1.1.sql</literal> contient les commandes pour modifier
    la version <literal>1.0</literal> de l'extension <literal>foo</literal> en la version
    <literal>1.1</literal>).
   </para>

   <para>
    En admettant qu'un tel script de mise à jour soit disponible, la commande
    <command>ALTER EXTENSION UPDATE</command> mettra à jour une extension installée
    vers la nouvelle version spécifiée. Le script de mise à jour est exécuté dans le
    même environnement que celui que la commande <command>CREATE EXTENSION</command>
    fournit pour l'installation de scripts : en particulier, la variable <varname>search_path</varname>
    est définie de la même façon et tout nouvel objet créé par le script est automatiquement
    ajouté à l'extension.  De plus, si le script choisit de supprimer des
    objets membres de l'extension, ils sont automatiquement dissociés de
    l'extension.
   </para>

   <para>
    Si une extension a un fichier de contrôle secondaire, les paramètres de contrôle qui
    sont utilisés par un script de mise à jour sont ceux définis par le script de la version
    cible.
   </para>

   <para>
    La commande <command>ALTER EXTENSION</command> peut exécuter des mises à jour en séquence pour
    réussir une mise à jour. Par exemple, si seuls les fichiers <literal>foo--1.0--1.1.sql</literal>
    et <literal>foo--1.1--2.0.sql</literal> sont disponibles, la commande <command>ALTER
     EXTENSION</command> les exécutera séquentiellement si une mise à jour vers la version <literal>2.0</literal>
    est demandée alors que la version <literal>1.0</literal> est installée.
   </para>

   <para>
    <productname>PostgreSQL</productname> ne suppose rien au sujet des noms de version.
    Par exemple, il ne sait pas si <literal>1.1</literal> suit <literal>1.0</literal>.
    Il effectue juste une correspondance entre les noms de version et suit un chemin
    qui nécessite d'appliquer le moins de fichier de script possible.
    Un nom de version peut en réalité être toute chaîne qui ne contiendrait pas
    <literal>--</literal> ou qui ne commencerait ou ne finirait pas par <literal>-</literal>.
   </para>

   <para>
    Il peut parfois être utile de fournir des scripts de retour en arrière, comme par exemple
    <literal>foo--1.1--1.0.sql</literal> pour autoriser d'inverser les modifications effectuées
    par la mise à jour en version <literal>1.1</literal>. Si vous procédez ainsi, ayez conscience
    de la possibilité laissée à <productname>PostgreSQL</productname> d'exécuter un tel script de retour
    en arrière s'il permet d'atteindre la version cible d'une mise à jour en un nombre réduit d'étapes.
    La cause du risque se trouve dans les scripts de mise à jour optimisés permettant de passer
    plusieurs versions en un seul script. La longueur du chemin commençant par un retour en
    arrière suivi d'un script optimisé pourrait être inférieure à la longueur du chemin qui monterait
    de version une par une. Si le script de retour en arrière supprime un objet irremplaçable, les conséquences
    pourraient en être facheuses.
   </para>

   <para>
    Pour vérifier que vous ne serez pas confronté à des chemins de mise à jour inattendus, utilisez cette commande&nbsp;:
    <programlisting>
SELECT * FROM pg_extension_update_paths('<replaceable>extension_name</replaceable>');
    </programlisting>
    Cette commande permet d'afficher chaque paire de noms de version connues pour l'extension spécifiée, ainsi
    que le chemin de mise à jour qui serait suivi depuis la version de départ jusque la version cible, ou la valeur
    <literal>NULL</literal> si aucun chemin valable n'est disponible. Le chemin est affiché sous une forme textuelle
    avec des séparateurs <literal>--</literal>. Vous pouvez utiliser <literal>regexp_split_to_array(path,'--')</literal>
    si vous préférez le format tableau.
   </para>
  </sect2>

  <sect2>
   <title>Installer des extensions en utilisant des scripts de mise à jour</title>

   <para>
    Une extension qui a existé un certain temps existera probabement dans
    plusieurs version, pour lesquelles l'auteur devra écrire des scripts de
    mise à jour.  Par exemple, si vous avez sorti une extension
    <literal>foo</literal> dans les versions <literal>1.0</literal>,
    <literal>1.1</literal>, et <literal>1.2</literal>, il devrait exister les
    scripts de mise à jour <filename>foo--1.0--1.1.sql</filename> et
    <filename>foo--1.1--1.2.sql</filename>.  Avant
    <productname>PostgreSQL</productname> 10, il était nécessaire de créer
    également de nouveaux fichiers de scripts
    <filename>foo--1.1.sql</filename> et <filename>foo--1.2.sql</filename> qui
    construisent directement les nouvelles versions de l'extension, ou sinon
    les nouvelles version ne pourraient pas être installées directement, mais
    uniquement en installant <literal>1.0</literal> puis en effectuant les
    mises à jour.  C'était fastidieux et source de doublons, mais c'est
    maintenant inutile car <command>CREATE EXTENSION</command> peut suivre les
    chaînes de mise à jour automatiquement.
    Par exemple, si seuls les fichiers de script
    <filename>foo--1.0.sql</filename>, <filename>foo--1.0--1.1.sql</filename>,
    et <filename>foo--1.1--1.2.sql</filename> sont disponibles, alors une demande d'installation
    de la version <literal>1.2</literal> pourra être effectuée en lançant ces
    trois scripts les uns à la suite des autres.  Le traitement est le même
    que si vous aviez d'abord installé <literal>1.0</literal> puis mis à jour
    vers <literal>1.2</literal>.  (Comme pour <command>ALTER EXTENSION
     UPDATE</command>, si de multiples chemins sont disponibles alors le plus
    court sera choisi.)  Arranger les fichiers de script d'une extension de
    cette façon peut réduire la quantité nécessaire d'effort de maintenance à
    fournir pour produires de petites mises à jour.
   </para>

   <para>
    Si vous utilisez des fichiers de contrôle secondaires (spécifique à la
    version) avec une extension maintenant de cette façon, gardez à l'esprit
    que chaque version nécessite un fichier de contrôle même s'il n'y a pas de
    script d'installation spécifique pour cette version, car ce fichier de
    contrôle déterminera comment une mise à jour implicite vers cette version
    est effectuée.  Par exemple, si <filename>foo--1.0.control</filename>
    spécifie <literal>requires = 'bar'</literal> mais que l'autre fichier de
    contrôle de <literal>foo</literal> ne le spécifie pas, la dépendance sur
    l'extension <literal>bar</literal> sera supprimée lors de la mise à jour de
    <literal>1.0</literal> vers une autre version.
   </para>
  </sect2>

  <sect2 id="extend-extensions-security">
   <title>Considérations de sécurité pour les extensions</title>

   <para>
    Les extensions largement distribuées devraient assumer peu sur la base
    qu'elles occupent. De ce fait, il est adéquat d'écrire des fonctions
    fournies par une extension dans un style sécurisé qui ne peut pas être
    compromis par des attaques basées sur le search_path.
   </para>

   <para>
    Une extension qui dispose de la propriété <varname>superuser</varname>
    configurée à true doit aussi considérer les risques de sécurité pour les
    actions effectuées par ses scripts d'installation et de mise à jour. Il
    n'est pas particulièrement compliqué pour un utilisateur mal intentionné
    de créer des objets chevaux de Troie qui compromettront une exécution
    ultérieure d'un script d'extension mal écrit, permettant à son utilisateur
    de gagner les droits d'un super-utilisateur.
   </para>

   <para>
    Des conseils sur l'écriture de fonctions sécurisées sont donnés dans <xref
    linkend="extend-extensions-security-funcs"/> ci-dessous, et d'autres
    conseils, sur l'écriture de scripts d'installation sécurisés, sont donnés
    dans <xref linkend="extend-extensions-security-scripts"/>.
   </para>

   <sect3 id="extend-extensions-security-funcs">
    <title>Considérations de sécurité pour les fonctions d'extensions</title>

    <para>
     Les fonctions en langage SQL et PL fournies par les extensions peuvent
     être l'objet d'attaques basées sur le search_path quand elles sont
     exécutées car l'analyse de ces fonctions survient lors de leur exécution
     et non pas lors de leur création.
    </para>

    <para>
     La page de référence de <link
     linkend="sql-createfunction-security"><command>CREATE
       FUNCTION</command></link> contient des conseils sur la bonne écriture de
     fonctions <literal>SECURITY DEFINER</literal>. Il est conseillé
     d'appliquer ces techniques pour toute fonction fournie par une extension
     car la fonction pourrait être appelée par un utilisateur avec des droits
     importants.
    </para>

    <!-- XXX It's not enough to use qualified names, because one might write a
         qualified name to an object that itself uses unqualified names.  Many
         information_schema functions have that defect, for example.  However,
         that's a defect in the referenced object, and relatively few queries
         will be affected.  Also, we direct applications to secure search_path
         when connecting to an untrusted database; if applications do that,
         they are immune to known attacks even if some extension refers to a
         defective object.  Therefore, guide extension authors as though core
         PostgreSQL contained no such defect. -->
    <para>
     Si vous ne pouvez pas configurer le <varname>search_path</varname> pour
     contenir seulement les schémas sécurisés, supposez que chaque nom non
     qualifié pourrait désigner un objet défini par un utilisateur mal
     intentionné. Faites attention aux requêtes qui pourraient dépendre
     implicitement d'un <varname>search_path</varname>&nbsp;; par exemple,
     <token>IN</token> et <literal>CASE <replaceable>expression</replaceable>
      WHEN</literal> sélectionnent toujours un opérateur utilisant le chemin de
     recherche. À la place, utilisez
     <literal>OPERATOR(<replaceable>schema</replaceable>.=) ANY</literal> et
     <literal>CASE WHEN <replaceable>expression</replaceable></literal>.
    </para>

    <para>
     Une extension standard ne devrait généralement pas supposer qu'elle a été
     installée dans un schéma sécurisé, ce qui signifie que même les
     références à ses propres objets en qualifiant leur nom de celui du schéma
     ne sont pas entièrement sans risque. Par exemple, si l'extension a défini
     une fonction <literal>monschema.mafonction(bigint)</literal>, alors un
     appel tel que <literal>monschema.mafonction(42)</literal> pourrait être
     capturée par une fonction hostile
     <literal>monschema.mafonction(integer)</literal>. Faites attention que
     les types de données de la fonction et les paramètres de l'opérateur
     correspondent exactement aux types d'argument déclarés, en utilisant des
     conversions explicites si nécessaire.
    </para>
   </sect3>

   <sect3 id="extend-extensions-security-scripts">
    <title>Considérations de sécurité pour les scripts d'extension</title>

    <para>
     Un script d'installation ou de mise à jour d'extension devrait être écrit
     pour se garder contre les attaques se basant sur le schéma, survenant
     lors de l'exécution du script. Si la référence d'un objet dans le script
     peut se faire en résolvant un autre objet que celui voulu par l'auteur de
     script, une compromission peut survenir immédiatement ou ultérieurement
     quand l'object mal défini est utilisé.
    </para>

    <para>
     Les commandes DDL telles que <command>CREATE FUNCTION</command> et
     <command>CREATE OPERATOR CLASS</command> sont généralement sécurisées,
     mais il convient de faire attention à toute commande ayant une expression
     standard comme composant. Par exemple, <command>CREATE VIEW</command>
     nécessite d'être validé, comme une expression <literal>DEFAULT</literal>
     dans <command>CREATE FUNCTION</command>.
    </para>

    <para>
     Quelque fois, un script d'extension peut avoir besoin d'exécuter un SQL,
     par exemple pour réaliser des ajustements sur le catalogue qui ne
     seraient pas possibles via une DDL. Faites bien attention d'exécuter de
     telles commandes avec un <varname>search_path</varname> sécurisé&nbsp;;
     ne faites <emphasis>pas</emphasis> confiance au chemin fourni par
     <command>CREATE/ALTER EXTENSION</command> comme étant sécurisé. Une
     meilleure approche est de configurer temporairement
     <varname>search_path</varname> à <literal>'pg_catalog, pg_temp'</literal>
     et d'insérer explicitement des références au schéma d'installation de
     l'expression si nécessaire. (Cette pratique peut être utile pour créer
     des vues.) Des exemples sont disponibles dans les modules
     <filename>contrib</filename> de la distribution des sources de
     <productname>PostgreSQL</productname>.
    </para>

    <para>
     Les références entre extensions sont très difficiles à sécuriser
     complètement, en partie à cause de l'incertitude sur le schéma
     d'installation de l'autre extension. Ce risque est réduit si les deux
     extensions sont installées dans le même schéma parce que, dans ce cas, un
     objet hostile ne peut pas être placé avant l'extension référencée dans le
     <varname>search_path</varname> d'installation. Néanmoins, aucun mécanisme
     n'existe actuellement pour forcer cela.
    </para>

    <para>
     N'utilisez <emphasis>pas</emphasis> <command>CREATE OR REPLACE
      FUNCTION</command>, sauf dans un script de mise à jour qui doit modifier
     la définition d'une fonction connue en tant que membre de l'extension.
     (Et de la même façon pour l'option <literal>OR REPLACE</literal> d'autres
     types d'objet.) Utiliser <literal>OR REPLACE</literal> sans raison ajoute
     un risque d'écraser accidentellement la fonction de quelqu'un d'autre,
     mais crée un risque de sécurité puisque la fonction surchargée conservera
     son propriétaire original, qui pourrait la modifier de nouveau.
    </para>
   </sect3>
  </sect2>

  <sect2 id="extend-extensions-example">
   <title>Exemples d'extensions</title>

   <para>
    Ci-après, un exemple complet d'une extension écrite uniquement en <acronym>SQL</acronym>,
    un type composite de deux éléments qui peut stocker n'importe quelle valeur dans chaque
    emplacement, qui sont nommés <quote>k</quote> et <quote>v</quote>. Les valeurs non textuelles
    sont automatiquement changées en texte avant stockage.
   </para>

   <para>
    Le fichier de script <filename>pair--1.0.sql</filename> ressemble à ceci:

    <programlisting><![CDATA[
-- se plaint si le script est exécuté directement dans psql, plutôt que via CREATE EXTENSION
\echo Use "CREATE EXTENSION pair" to load this file. \quit

CREATE TYPE pair AS ( k text, v text );

CREATE pair(text, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::@extschema@.pair;';

CREATE OPERATOR ~> (LEFTARG = text, RIGHTARG = text, FUNCTION = pair);

-- "SET search_path" is easy to get right, but qualified names perform better.
CREATE FUNCTION lower(pair)
RETURNS pair LANGUAGE SQL
AS 'SELECT ROW(lower($1.k), lower($1.v))::@extschema@.pair;'
SET search_path = pg_temp;

CREATE FUNCTION pair_concat(pair, pair)
RETURNS pair LANGUAGE SQL
AS 'SELECT ROW($1.k OPERATOR(pg_catalog.||) $2.k,
               $1.v OPERATOR(pg_catalog.||) $2.v)::@extschema@.pair;';
]]>
    </programlisting>
   </para>

   <para>
    Le fichier de contrôle <filename>pair.control</filename> ressemble à ceci:

    <programlisting>
# extension pair
comment = 'Un type de donnees representant un couple clef/valeur'
default_version = '1.0'
# n'est pas déplaçable à cause de l'utilisation de @extschema@
relocatable = false
    </programlisting>
   </para>

   <para>
    Si vous avez besoin d'un fichier d'installation pour installer ces deux fichiers dans le bon répertoire,
    vous pouvez utiliser le fichier <filename>Makefile</filename> qui suit :

    <programlisting>
EXTENSION = pair
DATA = pair--1.0.sql

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
    </programlisting>

    Ce fichier d'installation s'appuye sur <acronym>PGXS</acronym>, qui est décrit dans <xref linkend="extend-pgxs"/>.
    La commande <literal>make install</literal> va installer les fichiers de contrôle et de script dans le
    répertoire adéquat tel qu'indiqué par <application>pg_config</application>.
   </para>

   <para>
    Une fois les fichiers installés, utilisez la commande <command>CREATE
    EXTENSION</command> pour charger les objets dans une base de donnée.
   </para>
  </sect2>
 </sect1>

 <sect1 id="extend-pgxs">
  <title>Outils de construction d'extension</title>

  <indexterm zone="extend-pgxs">
   <primary>pgxs</primary>
  </indexterm>

  <para>
   Si vous comptez distribuer vos propres modules d'extension <productname>PostgreSQL</productname>,
   la mise en œuvre d'un système de construction multiplateforme sera réellement difficile.
   Cependant, <productname>PostgreSQL</productname> met à disposition des outils pour construire
   des extensions, appelés <acronym>PGXS</acronym>, permettant à de simples extensions d'être
   construites sur un serveur déjà installé. <acronym>PGXS</acronym> est principalement destiné
   aux extensions qui incluent du code C, bien qu'il puisse être utilisé aussi pour des extensions composées
   exclusivement de code SQL. <acronym>PGXS</acronym> n'a pas toutefois été conçu pour être un framework
   de construction universel qui pourrait construire tout logiciel s'interfaçant avec <productname>PostgreSQL</productname>.
   Il automatise simplement des règles de construction communes pour des extensions simples. Pour des paquetages
   plus complexes, vous aurez toujours besoin d'écrire vos propres systèmes de construction.
  </para>

  <para>
   Pour utiliser le système <acronym>PGXS</acronym> pour votre extension, vous
   devez écrire un simple makefile. Dans ce makefile, vous devez définir
   plusieurs variables et inclure le makefile de <acronym>PGXS</acronym>.
   Voici un exemple qui construit une extension nommée
   <literal>isbn_issn</literal>, qui consiste en une bibliothèque qui contient
   du code C, un fichier de contrôle d'extension, un script SQL, un fichier
   d'en-tête (seulement nécessaire si les autres modules pourraient avoir
   besoin d'accéder aux fonctions de l'extension sans passer par le SQL) et
   une documentation texte&nbsp;:
   <programlisting>
MODULES = isbn_issn
EXTENSION = isbn_issn
DATA = isbn_issn--1.0.sql
DOCS = README.isbn_issn
HEADERS_isbn_issn = isbn_issn.h

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
   </programlisting>
   Les trois dernières lignes devraient toujours être les mêmes. En début de fichier, vous pouvez assigner des variables
   ou ajouter des règles <application>make</application> personnalisées.
  </para>

  <para>
   Définissez une de ces trois variables pour spécifier ce qui est construit&nbsp;:

   <variablelist>
    <varlistentry>
     <term><varname>MODULES</varname></term>
     <listitem>
      <para>
       liste des bibliothèques à construire depuis les fichiers sources communs (ne pas inclure les suffixes de bibliothèques dans la liste)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>MODULE_big</varname></term>
     <listitem>
      <para>
       Une bibliothèque à construire depuis plusieurs fichiers source
       (listez les fichiers objets dans la variable <varname>OBJS</varname>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>PROGRAM</varname></term>
     <listitem>
      <para>
       Un programme exécutable à construire
       (listez les fichiers objet dans la variable <varname>OBJS</varname>).
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Les variables suivantes peuvent aussi être définies&nbsp;:

   <variablelist>
    <varlistentry>
     <term><varname>EXTENSION</varname></term>
     <listitem>
      <para>
       Nom(s) de l'extension&nbsp;; pour chaque nom, vous devez fournir un fichier
       <literal><replaceable>extension</replaceable>.control</literal>,
       qui sera installé dans le répertoire
       <literal><replaceable>prefix</replaceable>/share/extension</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>MODULEDIR</varname></term>
     <listitem>
      <para>
       Sous-répertoire de <literal><replaceable>prefix</replaceable>/share</literal>
       dans lequel les fichiers DATA et DOCS seront installés
       (s'il n'est pas défini, la valeur par défaut est <literal>extension</literal> si
       <varname>EXTENSION</varname> est défini et <literal>contrib</literal> dans le cas
       contraire)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>DATA</varname></term>
     <listitem>
      <para>
       Fichiers divers à installer dans <literal><replaceable>prefix</replaceable>/share/$MODULEDIR</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>DATA_built</varname></term>
     <listitem>
      <para>
       Fichiers divers à installer dans
       <literal><replaceable>prefix</replaceable>/share/$MODULEDIR</literal>,
       qui nécessitent d'être construit au préalable
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>DATA_TSEARCH</varname></term>
     <listitem>
      <para>
       Fichiers divers à installer dans
       <literal><replaceable>prefix</replaceable>/share/tsearch_data</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>DOCS</varname></term>
     <listitem>
      <para>
       Fichiers divers à installer dans
       <literal><replaceable>prefix</replaceable>/doc/$MODULEDIR</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>HEADERS_built</varname></term>
     <listitem>
      <para>
       Fichiers pour (en option construire et) installer sous
       <literal><replaceable>prefix</replaceable>/include/server/$MODULEDIR/$MODULE_big</literal>.
      </para>
      <para>
       Contrairement à <literal>DATA_built</literal>, les fichiers dans
       <literal>HEADERS_built</literal> ne sont pas supprimés par la cible
       <literal>clean</literal>&nbsp;; si vous voulez les supprimer, ajoutez
       les aussi à <literal>EXTRA_CLEAN</literal> ou ajoutez vos propres
       règles pour le faire.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>HEADERS_built_$MODULE</varname></term>
     <listitem>
      <para>
       fichiers à installer (après la construction si indiqué) sous
       <literal><replaceable>prefix</replaceable>/include/server/$MODULEDIR/$MODULE</literal>,
       où <literal>$MODULE</literal> doit être un nom de module utilisé dans
       <literal>MODULES</literal> ou <literal>MODULE_big</literal>.
      </para>
      <para>
       Contrairement à <literal>DATA_built</literal>, les fichiers dans
       <literal>HEADERS_built_$MODULE</literal> ne sont pas supprimées par la
       cible <literal>clean</literal>&nbsp;; si vous voulez les supprimer,
       ajoutez les aussi à <literal>EXTRA_CLEAN</literal> ou ajoutez vos
       propres règles pour le faire.
      </para>
      <para>
       Il est autorisé d'utiliser les deux variables pour le même module ou
       toute combinaison, sauf si vous avez deux noms de module dans la liste
       <literal>MODULES</literal> qui diffèrent seulement par la présence d'un
       préfixe <literal>built_</literal>, qui causerait une ambiguité. Dans ce
       cas (peu) probable, vous devez utiliser seulement les variables
       <literal>HEADERS_built_$MODULE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>SCRIPTS</varname></term>
     <listitem>
      <para>
       Fichiers de scripts (non binaires) à installer dans
       <literal><replaceable>prefix</replaceable>/bin</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>SCRIPTS_built</varname></term>
     <listitem>
      <para>
       Fichiers de script (non binaires) à installer dans
       <literal><replaceable>prefix</replaceable>/bin</literal>,
       qui nécessitent d'être construit au préalable.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>REGRESS</varname></term>
     <listitem>
      <para>
       Liste de tests de regression (sans suffixe), voir plus bas
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>REGRESS_OPTS</varname></term>
     <listitem>
      <para>
       Options supplémentaires à passer à <application>pg_regress</application>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>ISOLATION</varname></term>
     <listitem>
      <para>
       Liste de cas de tests d'isolation, voir ci-dessous pour plus de détails
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>ISOLATION_OPTS</varname></term>
     <listitem>
      <para>
       Options supplémentaires pour réussir
       <application>pg_isolation_regress</application>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TAP_TESTS</varname></term>
     <listitem>
      <para>
       Option définissant si les tests TAP doivent être exécutées, voir
       ci-dessous.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>NO_INSTALL</varname></term>
     <listitem>
      <para>
       Ne pas définir de cible <literal>install</literal>, utile pour les
       modules de test qui n'ont pas besoin que le produit soit installé
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>NO_INSTALLCHECK</varname></term>
     <listitem>
      <para>
       Ne pas définir de cible <literal>installcheck</literal>, utile par
       exemple si les tests nécessitent une configuration spéciale, ou
       n'utilisent pas pg_regress
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>EXTRA_CLEAN</varname></term>
     <listitem>
      <para>
       Fichiers supplémentaire à supprimer par la commande <literal>make clean</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>PG_CPPFLAGS</varname></term>
     <listitem>
      <para>
       Sera ajouté au début de <varname>CPPFLAGS</varname>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>PG_CFLAGS</varname></term>
     <listitem>
      <para>
       Sera ajouté à <varname>CFLAGS</varname>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>PG_CXXFLAGS</varname></term>
     <listitem>
      <para>
       Sera ajouté à <varname>CXXFLAGS</varname>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>PG_LDFLAGS</varname></term>
     <listitem>
      <para>
       Sera ajouté au début de <varname>LDFLAGS</varname>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>PG_LIBS</varname></term>
     <listitem>
      <para>
       Sera ajouté à la ligne d'édition de lien de <varname>PROGRAM</varname>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>SHLIB_LINK</varname></term>
     <listitem>
      <para>
       Sera ajouté à la ligne d'édition de lien de <varname>MODULE_big</varname>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>PG_CONFIG</varname></term>
     <listitem>
      <para>
       Chemin vers le programme <application>pg_config</application> de l'installation
       de <productname>PostgreSQL</productname> pour laquelle construire la bibliothèque ou le binaire
       (l'utilisation de <literal>pg_config</literal> seul permet d'utiliser le premier accessible par votre
       <varname>PATH</varname>)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Placez ce fichier de construction comme <literal>Makefile</literal> dans le répertoire
   qui contient votre extension. Puis vous pouvez exécuter la commande <literal>make</literal>
   pour compiler, et ensuite <literal>make install</literal> pour déployer le module. Par défaut,
   l'extension est compilée et installée pour l'installation de <productname>PostgreSQL</productname>
   qui correspond au premier programme <command>pg_config</command> trouvé dans votre <varname>PATH</varname>.
   Vous pouvez utiliser une installation différente en définissant <varname>PG_CONFIG</varname> pour pointer
   sur le programme <command>pg_config</command> de votre choix, soit dans le fichier makefile, soit
   à partir de la ligne de commande de la commande <literal>make</literal>.
  </para>

  <para>
   Vous pouvez aussi exécuter <literal>make</literal> dans un répertoire en
   dehors de l'arborescence des sources de votre extension, notamment si
   vous voulez séparer le répertoire de construction. Cette procédure est
   aussi appelée une construction
   <indexterm><primary>VPATH</primary></indexterm><firstterm>VPATH</firstterm>.
   Voici comment&nbsp;:
   <programlisting>
mkdir build_dir
cd build_dir
make -f /path/to/extension/source/tree/Makefile
make -f /path/to/extension/source/tree/Makefile install
   </programlisting>
  </para>

  <para>
   Autrement, vous pouvez configurer un répertoire pour une construction VPATH
   d'une façon similaire à ce qui est fait pour le code du moteur. Une façon
   de le faire revient à utiliser le script
   <filename>config/prep_buildtree</filename>. Une fois que cela est fait, vous
   pouvez lancer la construction en configurant la variable
   <varname>VPATH</varname> de <literal>make</literal> ainsi&nbsp;
   <programlisting>
make VPATH=/path/to/extension/source/tree
make VPATH=/path/to/extension/source/tree install
   </programlisting>
   Cette procédure peut fonctionner avec une grande variété de disposition de
   répertoires.
  </para>

  <para>
   Les scripts listés dans la variable <varname>REGRESS</varname> sont utilisés pour
   des tests de regression de votre module, qui peut être invoqué par <literal>make
    installcheck</literal> après avoir effectué <literal>make install</literal>. Pour que
   cela fonctionne, vous devez lancer le serveur <productname>PostgreSQL</productname> préalablement.
   Les fichiers de script listés dans la variable <varname>REGRESS</varname> doivent
   apparaître dans le sous-répertoire appelé <literal>sql/</literal> du répertoire
   de votre extension. Ces fichiers doivent avoir l'extension <literal>.sql</literal>,
   qui ne doit pas être inclus dans la liste <varname>REGRESS</varname> du makefile.
   Pour chaque test, il doit aussi y avoir un fichier qui contient les résultats attendus
   dans un sous-répertoire nommé <literal>expected</literal>, avec le même nom mais l'extension
   <literal>.out</literal>. La commande <literal>make installcheck</literal> exécute chaque
   script de test avec <application>psql</application>, et compare la sortie résultante
   au fichier de résultat correspondant. Toute différence sera écrite dans le fichier
   <literal>regression.diffs</literal> au format <command>diff -c</command>. Notez que
   l'exécution d'un test qui ne dispose pas des fichiers nécessaires sera rapportée comme
   une erreur dans le test, donc assurez-vous que tous les fichiers nécessaires soient présents.
  </para>

  <para>
   Les scripts listés dans la variable <varname>ISOLATION</varname> sont
   utilisés pour des tests sur le comportement en cas de stress dû à des
   sessions concurrentes avec votre module, tests qui peuvent être invoqués
   par <literal>make installcheck</literal> après avoir exécuté <literal>make
    install</literal>. Pour que ceci fonctionne, vous devez avoir un serveur
   <productname>PostgreSQL</productname> fonctionnel. Les fichiers scripts
   listés dans <varname>ISOLATION</varname> doivent apparaître dans un
   sous-répertoire nommé <literal>specs/</literal> du répertoire de votre
   extension. Ces fichiers doivent avoir une extension
   <literal>.spec</literal>, qui ne doit pas être incluse dans la liste
   <varname>ISOLATION</varname> du makefile. Pour chaque test, il doit aussi
   y avoir un fichier contenant la sortie attendue dans un sous-répertoire
   nommé <literal>expected/</literal>, avec le même nom et une extension
   <literal>.out</literal>. <literal>make installcheck</literal> exécute
   chaque script de test et compare la sortie résultante au fichier
   correspondant attendu. Toute différence sera écrite dans le fichier
   <literal>output_iso/regression.diffs</literal> au format <command>diff
    -c</command>. Notez qu'essayer d'exécuter un test dont le fichier attendu
   manque sera rapporté comme un problème, donc assurez-vous que vous avez
   tous les fichiers attendus.
  </para>

  <para>
   <literal>TAP_TESTS</literal> active l'utilisation des tests TAP. Les données
   de chaque exécution sont présentes dans un sous-répertoire nommé
   <literal>tmp_check/</literal>. Voir aussi <xref linkend="regress-tap"/>
   pour plus de détails.
  </para>

  <tip>
   <para>
    Le moyen le plus simple de créer les fichiers nécessaires est de créer des fichiers vides,
    puis d'effectuer un jeu d'essai (qui bien sûr retournera des anomalies). Étudiez les
    résultats trouvés dans le répertoire <literal>results</literal> (for tests in <literal>REGRESS</literal>), or
    <literal>output_iso/results/</literal> directory (for tests in
    <literal>ISOLATION</literal>),  et copiez-les dans le répertoire
    <literal>expected/</literal> s'ils correspondent à ce que vous attendiez du test correspondant.
   </para>

  </tip>
 </sect1>

</chapter>
