<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

 <chapter id="extend">
  <title>Étendre <acronym>SQL</acronym></title>

   <indexterm zone="extend">
    <primary>Extension de SQL</primary>
   </indexterm>

  <para>
   Les sections qui suivent présentent les possibilités d'étendre le langage
   SQL de requêtage de <productname>PostgreSQL</productname> par l'ajout&nbsp;:
  <itemizedlist spacing="compact" mark="bullet">
    <listitem>
     <para>
      de fonctions (<xref linkend="xfunc"/>)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
      d'agrégats (<xref linkend="xaggr"/>)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
      de types de données (<xref linkend="xtypes"/>)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
      d'opérateurs (<xref linkend="xoper"/>)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
     de classes d'opérateurs pour les index (<xref linkend="xindex"/>).
     </para>
    </listitem>
    <listitem>
     <para>
	  d'extensions permettant de créer un paquetage d'objets qui disposent d'un point commun (voir <xref linkend="extend-extensions"/>)
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <sect1 id="extend-how">
   <title>L'extensibilité</title>

   <para>
    <productname>PostgreSQL</productname> est extensible parce qu'il opère
    grâce à un système de catalogues. Quiconque est familier des systèmes de
    bases de données relationnelles standard sait que les informations
    concernant les bases, les tables, les colonnes, etc. y sont stockées dans ce
    qu'on nomme communément des catalogues systèmes (certains systèmes appellent
    cela le dictionnaire de données). Pour l'utilisateur, les catalogues
    ressemblent à des tables ordinaires, mais le <acronym>SGBD</acronym>
    y enregistre ses registres <!-- bookkeeping --> internes. À la différence
    des autres systèmes, <productname>PostgreSQL</productname> enregistre
    beaucoup d'informations dans ses catalogues&nbsp;: non seulement
    l'information concernant les tables et les colonnes, mais aussi
    l'information concernant les types de données, les fonctions, les méthodes
    d'accès, etc.
   </para>
   <para>
    Ces tables peuvent être modifiées par l'utilisateur. Qui plus est, 
    puisque <productname>PostgreSQL</productname> fonde ses opérations sur ces
    tables, il peut être étendu par les utilisateurs. En comparaison, les systèmes de bases de 
    données conventionnels ne peuvent être étendus qu'en modifiant les
    procédures dans le code source ou en installant des modules spécifiquement
    écrits par le vendeur de <acronym>SGBD</acronym>.
  </para>
  
  <para>
   De plus, le serveur <productname>PostgreSQL</productname> peut
   incorporer du code utilisateur par chargement dynamique. C'est-à-dire
   que l'utilisateur peut indiquer un fichier de code objet (par exemple une
   bibliothèque partagée) qui code un nouveau type ou une nouvelle fonction
   et <productname>PostgreSQL</productname> le charge au besoin.
   Il est encore plus facile d'ajouter au serveur du code écrit en
   <acronym>SQL</acronym>. La possibilité de modifier son fonctionnement
   <quote>à la volée</quote> fait de <productname>PostgreSQL</productname>
   un outil unique pour le prototypage rapide de nouvelles applications et
   de structures de stockage.
  </para>
  
 </sect1>
   
   <sect1 id="extend-type-system"> 
     <title>Le système des types de <productname>PostgreSQL</productname></title>

   <indexterm zone="extend-type-system">
    <primary>type de base</primary>
   </indexterm>

   <indexterm zone="extend-type-system">
    <primary>type de données</primary>
    <secondary>base</secondary>
   </indexterm>

   <indexterm zone="extend-type-system">
    <primary>type composé</primary>
   </indexterm>

   <indexterm zone="extend-type-system">
    <primary>type de données</primary>
    <secondary>composé</secondary>
   </indexterm>

   <para>
    Les types de données de <productname>PostgreSQL</productname> sont répartis en types de base, 
    types composites, domaines et pseudo-types.
   </para>

  <sect2>
   <title>Les types de base</title>

   <para>
    Les types de base sont ceux qui, comme <type>int4</type>, sont implantés
    sous le niveau du langage <acronym>SQL</acronym> (typiquement dans un
    langage de bas niveau comme le C). Ils correspondent généralement à ce que
    l'on appelle les types de données abstraits.  
    <productname>PostgreSQL</productname> ne peut opérer sur de tels types
    qu'au moyen de fonctions utilisateur et n'en comprend le fonctionnement que
    dans la limite de la description qu'en a fait l'utilisateur. Les types
    de base sont divisés en types scalaires et types tableaux. Pour chaque type
    scalaire, un type tableau  est automatiquement créé destiné à
    contenir des tableaux de taille variable de ce type scalaire.
   </para>
   </sect2>

  <sect2>
   <title>Les types composites</title>

   <para>
    Les types composites, ou types lignes, sont créés chaque fois qu'un
    utilisateur crée une table. Il est égalment possible de définir un type
    composite autonome sans table associée. Un type composite n'est
    qu'une simple liste de types de base avec des noms de champs associés. Une
    valeur de type composite est une ligne ou un enregistrement de valeurs de
    champ. L'utilisateur peut accéder à ces champs à partir de requêtes
    <acronym>SQL</acronym>.  La <xref linkend="rowtypes"/>
    fournit de plus amples informations sur ces types.
   </para>
  </sect2>

  <sect2>
   <title>Les domaines</title>

   <para>
    Un domaine est fondé sur un type de base particulier. Il est, dans de
    nombreux cas, interchangeable avec ce type. Mais un domaine peut également
    posséder des contraintes qui restreignent ses valeurs à un sous-ensemble des
    valeurs autorisées pour le type de base.
   </para>

    <para>
     Les domaines peuvent être créés à l'aide de la commande
     <acronym>SQL</acronym> <xref linkend="sql-createdomain"/>.
     Leurs création et utilisation n'est pas l'objet de ce chapitre.
    </para>
   </sect2>

   <sect2>
    <title>Pseudo-types</title>

   <para>   
    Il existe quelques <quote>pseudo-types</quote> pour des besoins
    particuliers. Les pseudo-types ne peuvent pas apparaître comme champs de
    table ou comme attributs de types composites, mais ils peuvent être
    utilisés pour déclarer les types des arguments et des résultats de
    fonctions. Dans le système de typage, ils fournissent un mécanisme
    d'identification des classes spéciales de fonctions. La
    <xref linkend="datatype-pseudotypes-table"/> donne la liste des
    pseudo-types qui existent.   
   </para>

   </sect2>

   <sect2 id="extend-types-polymorphic">
    <title>Types et fonctions polymorphes</title>

   <indexterm zone="extend-types-polymorphic">
    <primary>type polymorphe</primary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
    <primary>fonction polymorphe</primary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
    <primary>type</primary>
    <secondary>polymorphe</secondary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
    <primary>fonction</primary>
    <secondary>polymorphe</secondary>
   </indexterm>

   <para>
    Quatre pseudo-types sont particulièrement intéressants&nbsp;:
    <type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type> et
    <type>anyenum</type>, collectivement appelés <firstterm>types
    polymorphes</firstterm>.
    Toute fonction déclarée utiliser ces types est dite <firstterm>fonction
    polymorphe</firstterm>. Une fonction polymorphe peut opérer sur de nombreux
    types de données différents, les types de données spécifiques étant
    déterminés par les types des données réellement passés lors d'un appel
    particulier de la fonction.
   </para>

   <para>
    Les arguments et résultats polymorphes sont liés entre eux et
    sont résolus dans un type de données spécifique quand une requête faisant
    appel à une fonction polymorphe est analysée. Chaque occurrence (argument
    ou valeur de retour) déclarée comme <type>anyelement</type>
    peut prendre n'importe quel type réel de données mais, lors d'un
    appel de fonction donné, elles doivent toutes avoir le
    <emphasis>même</emphasis> type réel. Chaque occurrence déclarée comme
    <type>anyarray</type> peut prendre n'importe quel type de données tableau
    mais, de la même façon, elles doivent toutes être du
    <emphasis>même</emphasis> type. Si des occurrences sont déclarées comme
    <type>anyarray</type> et d'autres comme <type>anyelement</type>, le type
    réel de tableau des occurrences <type>anyarray</type> doit être un tableau
    dont les éléments sont du même type que ceux apparaissant dans les
    occurrences de type <type>anyelement</type>.
    <type>anynonarray</type> est traité de la même façon que
    <type>anyelement</type> mais ajoute une contrainte supplémentaire. Le type
    réel ne doit pas être un tableau. <type>anyenum</type> est traité de la même
    façon que <type>anyelement</type> mais ajoute une contrainte supplémentaire.
    Le type doit être un type enuméré.
   </para>

   <para>
    Ainsi, quand plusieurs occurrences d'argument sont déclarées avec un type
    polymorphe, seules certaines combinaisons de
    types réels d'argument sont autorisées. Par exemple, une fonction déclarée
    comme <literal>foo(anyelement, anyelement)</literal> peut prendre comme
    arguments n'importe quelles valeurs à condition qu'elles soient du même
    type de données.
   </para>

   <para>
    Quand la valeur renvoyée par une fonction est déclarée de type polymorphe,
    il doit exister au moins une occurrence d'argument également polymorphe, et
    le type réel de donnée passé comme argument détermine le type réel de
    résultat renvoyé lors de cet appel à la fonction. Par exemple, s'il
    n'existe pas déjà un mécanisme d'indexation d'éléments de
    tableau, on peut définir une fonction qui code ce mécanisme&nbsp;:
    <literal>indice(anyarray, integer) returns anyelement</literal>. La
    déclaration de fonction contraint le premier argument réel à être de type
    tableau et permet à l'analyseur d'inférer le type correct de résultat à
    partir du type réel du premier argument. Une fonction déclarée de cette
    façon <literal>f(anyarray) returns anyenum</literal> n'accepte que des
    tableaux contenant des valeurs de type enum.
    </para>

    <para>
     <type>anynonarray</type> et <type>anyenum</type> ne représentent
     pas des variables de type séparé&nbsp;; elles sont du même type que
     <type>anyelement</type>, mais avec une contrainte supplémentaire. Par
     exemple, déclarer une fonction <literal>f(anyelement, anyenum)</literal>
     est équivalent à la déclarer <literal>f(anyenum, anyenum)</literal>&nbsp;:
     les deux arguments réels doivent être du même type enum.
    </para>

    <para>
     Une fonction variadic (c'est-à-dire une fonction acceptant un nombre
     variable d'arguments, comme dans <xref
     linkend="xfunc-sql-variadic-functions"/>) peut être polymorphique&nbsp;:
     cela se fait en déclarant son dernier paramètre <literal>VARIADIC</literal>
     <type>anyarray</type>. Pour s'assurer de la correspondance des arguments
     et déterminer le type de la valeur en retour, ce type de fonction se
     comporte de la même façon que si vous aviez écrit le nombre approprié de
     paramètres <type>anynonarray</type>.
    </para>
  </sect2>
 </sect1>

  &xfunc;
  &xaggr;
  &xtypes;
  &xoper;
  &xindex;

  <sect1 id="extend-extensions">
   <title>Empaqueter des objets dans une extension</title>

   <indexterm zone="extend-extensions">
    <primary>extension</primary>
    </indexterm>
 
    <para>
	Les extensions utiles à <productname>PostgreSQL</productname> contiennent généralement
	plusieurs objets SQL. Par exemple, un nouveau type de données va nécessiter de 
	nouvelles fonctions, de nouveaux opérateurs et probablement de nouvelles méthodes
	d'indexation.
	Il peut être utile de les grouper en un unique paquetage pour simplifier la gestion
	des bases de données. Avec <productname>PostgreSQL</productname>, ces paquetages sont
	appelés <firstterm>extension</firstterm>. Pour créer une extension, vous avez besoin
	au minimum d'un <firstterm>fichier de script</firstterm> qui contient les commandes
	<acronym>SQL</acronym> permettant de créer ses objets, et un 
	<firstterm>fichier de contrôle</firstterm> qui rapporte quelques propriétés de base
	de cette extension. Si cette extension inclut du code C, elle sera aussi généralement
	accompagnée d'une bibliothèque dans lequel le code C aura été compilé.
	Une fois ces fichiers en votre possession, un simple appel à la commande
	<xref linkend="sql-createextension"/> vous permettra de charger ses objets dans la base
	de données.
   </para>

   <para>
    Le principal avantage des extensions n'est toutefois pas de pouvoir de charger une
	grande quantité d'objets dans votre base de donnée. Les extensions permettent en effet
	surtout à <productname>PostgreSQL</productname> de comprendre que ces objets sont liés par cette
	extension. Vous pouvez par exemple supprimer tous ces objets avec une simple commande 
	<xref linkend="sql-dropextension"/>. Il n'est ainsi pas nécessaire de maintenir un script de 
	<quote>désintallation</quote>.
	Plus utile encore, l'outil <application>pg_dump</application> saura reconnaître les objets
	appartenant à une extension et, plutôt que de les extraire individuellement, ajoutera simplement
	une commande <command>CREATE EXTENSION</command> à la sauvegarde.
	Ce mécanisme simplifie aussi la migration à une nouvelle version de l'extension
	qui peut contenir de nouveaux objets ou des objets différents de la version d'origine.
	Notez bien toutefois qu'il est nécessaire de disposer des fichiers de contrôles, de script, 
	et autres pour permettre la restauration d'une telle sauvegarde dans une nouvelle base
	de donnée.
   </para>

   <para>
    <productname>PostgreSQL</productname> ne permet pas de supprimer de manière individuelle
	les objets d'une extension sans supprimer l'extension tout entière.
	Aussi, bien que vous ayez la possibilité de modifier la définition d'un objet inclus dans
	une extension (par exemple via la commande <command>CREATE OR REPLACE FUNCTION</command> dans
	le cas d'une fonction), il faut garder en tête que cette modification ne sera pas sauvegardée
	par l'outil <application>pg_dump</application>. Une telle modification n'est en pratique raisonnable
	que si vous modifiez parallèlement le fichier de script de l'extension. Il existe toutefois des 
	cas particuliers comme celui des tables qui contiennent des données de configuration (voir ci-dessous).
   </para>

   <para>
    Il existe aussi un mécanisme permettant de créer des scripts de mise à jour de la définition des objets
	<acronym>SQL</acronym> contenus dans une extension.
	Par exemple, si la version 1.1 d'une extension ajoute une fonction et change le corps d'une autre
	vis-à-vis de la version 1.0 d'origine, l'auteur de l'extension peut fournir un <firstterm>script
	de mise à jour</firstterm> qui effectue uniquement ces deux modifications. La commande <command>
	ALTER EXTENSION UPDATE</command> peut alors être utilisée pour appliquer ces changements et vérifier
	quelle version de l'extension est actuellement installée sur une base de donnée spécifiée.
   </para>

   <para>
    Les catégories d'objets <acronym>SQL</acronym> qui peuvent être inclus dans une extension
	sont spécifiées dans la description de la commande <xref linkend="sql-alterextension"/>.
	D'une manière générale, les objets qui sont communs à l'ensemble de la base ou du cluster, 
	comme les bases de données, les rôles, les tablespaces ne peuvent être inclus dans une 
	extension car une extension n'est référencée qu'à l'intérieur d'une base de donnée.
	À noter que rien n'empêche la création de fichier de script qui crée de tels objets, mais
	qu'ils ne seront alors pas considérés après leur création comme faisant partie de l'extension.
	À savoir en outre que bien que les tables puissent être incluses dans une extension, les objets
	annexes tels que les index ne sont pas automatiquement inclus dans l'extension et devront être 
	explicitement mentionnés dans les fichiers de script.
   </para>

   <sect2>
    <title>Fichiers des extensions</title>

   <indexterm>
    <primary>Fichier de contrôle</primary>
   </indexterm>

    <para>
	 La commande <xref linkend="sql-createextension"/> repose sur un fichier de contrôle
	 associé à chaque extension. Ce fichier doit avoir le même nom que l'extension suivi du suffixe
	 <literal>.control</literal>, et doit être placé dans le sous-répertoire <literal>SHAREDIR/extension</literal>
	 du répertoire d'installation. Il doit être accompagné d'au moins un fichier de script <acronym>SQL</acronym>
	 dont le nom doit répondre à la syntaxe <literal><replaceable>extension</replaceable>--<replaceable>version</replaceable>.sql</literal>
	 (par exemple, <literal>foo--1.0.sql</literal> pour la version <literal>1.0</literal> de l'extension <literal>foo</literal>).
	 Par défaut, les fichiers de script sont eux-aussi situés dans le répertoire <literal>SHAREDIR/extension</literal>. Le fichier
	 de contrôle peut toutefois spécifier un répertoire différent pour chaque fichier de script.
    </para>

    <para>
	 Le format du fichier de contrôle d'une extension est le même que pour le
	 fichier <filename>postgresql.conf</filename>, à savoir une liste d'affectation
	 <replaceable>nom_paramètre</replaceable> <literal>=</literal> <replaceable>valeur</replaceable>
	 avec un maximum d'une affectation par ligne.
     Les lignes vides et les commentaires introduits par <literal>#</literal> sont eux-aussi autorisés.
	 Prenez garde à placer entre guillemets les valeurs qui ne sont ni des nombres ni des mots isolés.
    </para>

    <para>
	 Un fichier de contrôle peut définir les paramètres suivants&nbsp;:
    </para>

    <variablelist>
     <varlistentry>
      <term><varname>directory</varname> (<type>string</type>)</term>
      <listitem>
       <para>
	    Le répertoire qui inclut les scripts <acronym>SQL</acronym> de l'extension.
		Si un chemin relatif est spécifié, le sous-répertoire <literal>SHAREDIR</literal>
		du répertoire d'installation sera choisi comme base.
		Le comportement par défaut de ce paramètre revient à le définir tel que
		<literal>directory = 'extension'</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>default_version</varname> (<type>string</type>)</term>
      <listitem>
       <para>
	    La version par défaut de l'extension, qui sera installée si aucune
		version n'est spécifiée avec la commande <command>CREATE EXTENSION</command>.
		Ainsi, bien que ce paramètre puisse ne pas être précisé, il reste
		recommandé de le définir pour éviter que la commande 
		<command>CREATE EXTENSION</command> ne provoque une erreur 
		en l'absence de l'option <literal>VERSION</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>comment</varname> (<type>string</type>)</term>
      <listitem>
       <para>
	    Un commentaire de type chaîne de caractère au sujet de l'extension. Une alternative
		consiste à utiliser la commande <xref linkend="sql-comment"/> dans
		le script de l'extension.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>encoding</varname> (<type>string</type>)</term>
      <listitem>
       <para>
	    L'encodage des caractères utilisé par les fichiers de script. Ce paramètre
		doit être spécifié si les fichiers de script contiennent des caractères
		non ASCII. Le comportement par défaut en l'absence de ce paramètre consiste à utiliser
		l'encodage de la base de donnée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>module_pathname</varname> (<type>string</type>)</term>
      <listitem>
       <para>
	    La valeur de ce paramètre sera utilisée pour toute référence à <literal>MODULE_PATHNAME</literal> 
		dans les fichiers de script. Si ce paramètre n'est pas défini, la substitution ne sera pas effectuée.
		La valeur <literal>$libdir/<replaceable>nom_de_bibliothèque</replaceable></literal> lui est usuellement attribuée
		et dans ce cas, <literal>MODULE_PATHNAME</literal> est utilisé dans la commande <command>CREATE
        FUNCTION</command> concernant les fonctions en langage C, de manière à ne pas mentionner <quote>en dur</quote>
		le nom de la bibliothèque partagée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>requires</varname> (<type>string</type>)</term>
      <listitem>
       <para>
	    Une liste de noms d'extension dont dépend cette extension, comme
		par exemple <literal>requires = 'foo, bar'</literal>.  Ces extensions
		doivent être installées avant que l'extension puisse être installée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>superuser</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
	    Si ce paramètre est à <literal>true</literal> (il s'agit de la valeur par défaut),
		seuls les superutilisateurs pourront créer cet extension ou la mettre à jour.
		Si ce paramètre est à <literal>false</literal>, seuls les droits nécessaires
		seront requis pour installer ou mettre à jour l'extension.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>relocatable</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
	    Une extension est dite <quote>déplaçable</quote> (<firstterm>relocatable</firstterm>)
		s'il est possible de déplacer les objets qu'elle contient dans un schéma différent 
		de celui attribué initialement par l'extension. La valeur par défaut est à 
		<literal>false</literal>, ce qui signifie que l'extension n'est pas déplaçable.
		Voir ci-dessous pour des informations complémentaires.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>schema</varname> (<type>string</type>)</term>
      <listitem>
       <para>
	    Ce paramètre ne peut être spécifié que pour les extensions non déplaçables.
		Il permet de forcer l'extension à charger ses objets dans le schéma spécifié
		et aucun autre. Voir ci-dessous pour des informations complémentaires.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    <para>
	 En complément au fichier de contrôle <literal><replaceable>extension</replaceable>.control</literal>, 
	 une extension peut disposer de fichiers de contrôle secondaires pour chaque version dont le nommage correspond à 
	 <literal><replaceable>extension</replaceable>--<replaceable>version</replaceable>.control</literal>.
	 Ces fichiers doivent se trouver dans le répertoire des fichiers de script de l'extension.
	 Les fichiers de contrôle secondaires suivent le même format que le fichier de contrôle principal.
	 Tout paramètre spécifié dans un fichier de contrôle secondaire surcharge la valeur spécifiée dans le
	 fichier de contrôle principal concernant les installations ou mises à jour à la version considérée. 
	 Cependant, il n'est pas possible de spécifier les paramètres <varname>directory</varname> et 
	 <varname>default_version</varname> dans un fichier de contrôle secondaire.
    </para>

    <para>
	 Un fichier de script <acronym>SQL</acronym> d'une extension peut contenir toute commande
	 SQL, à l'exception des commandes de contrôle de transaction (<command>BEGIN</command>,
     <command>COMMIT</command>, etc), et des commandes qui ne peuvent être exécutées au sein
	 d'un bloc transactionnel (comme la commande <command>VACUUM</command>). Cette contrainte
	 est liée au fait que les fichiers de script sont implicitement exécutés dans une transaction.
    </para>

    <para>
     An extension's <acronym>SQL</acronym> script files can also contain lines
     beginning with <literal>\echo</literal>, which will be ignored (treated as
     comments) by the extension mechanism.  This provision is commonly used
     to throw an error if the script file is fed to <application>psql</application>
     rather than being loaded via <command>CREATE EXTENSION</command> (see example
     script below).  Without that, users might accidentally load the
     extension's contents as <quote>loose</quote> objects rather than as an
     extension, a state of affairs that's a bit tedious to recover from.
    </para>

    <para>
	 Bien que les fichiers de script puissent contenir n'importe quel caractère autorisé
	 par l'encodage spécifié, les fichiers de contrôle ne peuvent contenir que des caractères
	 ASCII non formatés. En effet, <productname>PostgreSQL</productname> ne peut pas déterminer
	 l'encodage utilisé par les fichiers de contrôle. Dans la pratique, cela ne pose problème
	 que dans le cas où vous voudriez utiliser des caractères non ASCII dans le commentaire
	 de l'extension. Dans ce cas de figure, il est recommandé de ne pas utiliser le paramètre
	 <varname>comment</varname> du fichier de contrôle pour définir ce commentaire, mais plutôt
	 la commande <command>COMMENT ON EXTENSION</command> dans un fichier de script.
    </para>

   </sect2>

   <sect2>
    <title>Possibilités concernant le déplacement des extensions</title>

    <para>
	 Les utilisateurs souhaitent souvent charger les objets d'une extension
	 dans un schéma différent de celui imposé par l'auteur. Trois niveaux
	 de déplacement sont supportés :
    </para>
 
     <itemizedlist>
      <listitem>
       <para>
	   Une extension supportant complétement le déplacement peut être déplacé
	   dans un autre schéma à tout moment, y compris après son chargement
	   dans une base de donnée.
	   Initialement, tous les objets de l'extension installée appartiennent à un
	   premier schéma (excepté les objets qui n'appartiennent à aucun schéma comme les 
	   langages procéduraux).
	   L'opération de déplacement peut alors être réalisée avec la commande <command>ALTER EXTENSION SET SCHEMA</command>,
	   qui renomme automatiquement tous les objets de l'extension pour être intégrés dans le nouveau
	   schéma.  Le déplacement ne sera toutefois fonctionnel 
	   que si l'extension ne contient aucune référence de l'appartenance d'un de ses objets à un schéma.
	   Dans ce cadre, il est alors possible de spécifier qu'une extension supporte complétement le déplacement en initialisant
	   <literal>relocatable = true</literal> dans son fichier de contrôle.
       </para>
      </listitem>

      <listitem>
       <para>
	   Une extension peut être déplaçable durant l'installation et ne plus l'être 
	   par la suite. Un exemple courant est celui du fichier de script de l'extension
	   qui doit référencer un schéma cible de manière explicite pour des fonctions SQL, par exemple en définissant
	   la propriété <literal>search_path</literal>.
	   Pour de telles extensions, il faut définir <literal>relocatable = false</literal> dans
	   son fichier de contrôle, et utiliser <literal>@extschema@</literal> pour référencer
	   le schéma cible dans le fichier de script. Toutes les occurences de cette chaîne dans le 
	   fichier de script seront remplacées par le nom du schéma choisi avant son exécution.
	   Le nom du schéma choisi peut être fixé par l'option <literal>SCHEMA</literal> de la 
	   commande <command>CREATE EXTENSION></command>.
       </para>
      </listitem>

      <listitem>
       <para>
	   Si l'extension ne permet pas du tout le déplacement, il faut définir <literal>relocatable = false</literal>
	   dans le fichier de contrôle, mais aussi définir <literal>schema</literal> comme étant le nom du schéma cible.
	   Cette précaution permettra d'empêcher l'usage de l'option <literal>SCHEMA</literal> de la commande <command>CREATE
	    EXTENSION</command>, à moins que cette option ne référence la même valeur que celle spécifiée dans le fichier de 
	   contrôle. Ce choix est à priori nécessaire si l'extension contient des références à des noms
	   de schéma qui ne peuvent être remplacés par <literal>@extschema@</literal>. À noter que même si son usage reste
	   relativement limité dans ce cas de figure puisque le nom du schéma est alors fixé dans le fichier de contrôle,
	   le mécanisme de substitution de <literal>@extschema@</literal> reste toujours opérationnel.
       </para>
      </listitem>
     </itemizedlist>

    <para>
	 Dans tous les cas, le fichier de script sera exécuté avec comme valeur de <xref linkend="guc-search-path"/>
	 le schéma cible. Cela signifie que la commande <command>CREATE EXTENSION</command> réalisera l'équivalent
	 de la commande suivante :
<programlisting>
SET LOCAL search_path TO @extschema@;
</programlisting>
     Cela permettra aux objets du fichier de script d'être créés dans le schéma cible. Le fichier de script
	 peut toutefois modifier la valeur de <varname>search_path</varname> si nécessaire, mais cela n'est
	 généralement pas le comportement souhaité. La variable <varname>search_path</varname> retrouvera sa valeur
	 initiale à la fin de l'exécution de la commande <command>CREATE EXTENSION</command>.
    </para>

    <para>
	 Le schéma cible est déterminé par le paramètre <varname>schema</varname> dans le
	 fichier de contrôle s'il est précisé, sinon par l'option <literal>SCHEMA</literal>
	 de la commande <command>CREATE EXTENSION</command> si elle est spécifiée, sinon
	 par le schéma de création par défaut actuel (le premier rencontré en suivant le
	 chemin de recherche <varname>search_path</varname> de l'appelant). Quand le paramètre
	 <varname>schema</varname> du fichier de contrôle est utilisé, le schéma cible sera créé
	 s'il n'existe pas encore. Dans les autres cas, il devra exister au préalable.
    </para>

    <para>
	 Si des extensions requises sont définies par <varname>requires</varname> dans le fichier
	 de contrôle, leur schéma cible est ajouté à la valeur initiale de <varname>search_path</varname>.
	 Cela permet à leurs objets d'être visibles dans le fichier de script de l'extension installée.
    </para>

    <para>
	 Une extension peut contenir des objets répartis dans plusieurs schémas.
	 Il est alors conseillé de regrouper dans un unique schéma l'ensemble des objets destinés à un usage 
	 externe à l'extension, qui sera alors le schéma cible de l'extension. Une telle organisation est compatible
	 avec la définition par défaut de <varname>search_path</varname> pour la création d'extensions
	 qui en seront dépendantes.
    </para>
   </sect2>

   <sect2>
    <title>Tables de configuration des extensions</title>

    <para>
	 Certaines extensions incluent des tables de configuration, contenant
	 des données qui peuvent être ajoutées ou changées par l'utilisateur
	 après l'installation de l'extension. Normalement, si la table fait
	 partie de l'extension, ni la définition de la table, ni son contenu
	 ne sera sauvegardé par <application>pg_dump</application>. Mais
	 ce comportement n'est pas celui attendu pour une table de configuration.
	 Les données modifiées par un utilisateur nécessitent d'être sauvegardées,
	 ou l'extension aura un comportement différent après rechargement.
    </para>

    <para>
	 Pour résoudre ce problème, un fichier de script d'extension peut marquer
	 une table comme étant une table de configuration, ce qui indiquera à <application>pg_dump</application>
	 d'inclure le contenu de la table (et non sa définition) dans la sauvegarde. Pour cela, il s'agit d'appeler
	 la fonction <function>pg_extension_config_dump(regclass, text)</function> après avoir
	 créé la table, par exemple
<programlisting>
CREATE TABLE my_config (key text, value text);

SELECT pg_catalog.pg_extension_config_dump('my_config', '');
</programlisting>
     Cette fonction permet de marquer autant de tables que nécessaire.
    </para>

    <para>
	 Si le second argument de <function>pg_extension_config_dump</function> est une
	 chaîne vide, le contenu entier de la table sera sauvegardé par l'application
	 <application>pg_dump</application>. Cela n'est correct que si la table
	 était initialement vide après l'installation du script. Si un mélange de données
	 initiales et de données ajoutées par l'utilisateur est présent dans la table,
	 le second argument de <function>pg_extension_config_dump</function> permet de 
	 spécifier une condition <literal>WHERE</literal> qui selectionne les données à
	 sauvegarder.
	 Par exemple, vous pourriez faire
<programlisting>
CREATE TABLE my_config (key text, value text, standard_entry boolean);

SELECT pg_catalog.pg_extension_config_dump('my_config', 'WHERE NOT standard_entry');
</programlisting>
     et vous assurer que la valeur de <structfield>standard_entry</structfield> soit
	 true uniquement lorsque les lignes ont été créées par le script de l'extension.
    </para>

    <para>
	 Des situations plus compliquées, comme des données initiales qui peuvent être modifiées
	 par l'utilisateur, peuvent être prises en charge en créant des triggers sur la table de configuration
	 pour s'assurer que les lignes ont été marquées correctement.
    </para>
   </sect2>

   <sect2>
    <title>Mise à jour d'extension</title>

    <para>
	 Un des avantages du mécanisme d'extension est de proposer un moyen
	 simple de gérer la mise à jour des commandes SQL qui définissent les objets
	 de l'extension. Cela est rendu possible par l'association d'un nom ou d'un numéro
	 de version à chaque nouvelle version du script d'installation de l'extension.
	 En complément, si vous voulez qu'un utilisateur soit capable de mettre à jour
	 sa base de données dynamiquement d'une version à une autre, vous pouvez
	 fournir <firstterm>des scripts de mise à jour</firstterm> qui feront les
	 modifications nécessaires. Les scripts de mise à jour ont un nom qui correspond au format
	 <literal><replaceable>extension</replaceable>--<replaceable>oldversion</replaceable>--<replaceable>newversion</replaceable>.sql</literal>
	 (par exemple, <literal>foo--1.0--1.1.sql</literal> contient les commandes pour modifier
	 la version <literal>1.0</literal> de l'extension <literal>foo</literal> en la version
	 <literal>1.1</literal>).
    </para>

    <para>
	 En admettant qu'un tel script de mise à jour soit disponible, la commande
	 <command>ALTER EXTENSION UPDATE</command> mettra à jour une extension installée
	 vers la nouvelle version spécifiée. Le script de mise à jour est exécuté dans le
	 même environnement que celui que la commande <command>CREATE EXTENSION</command> 
	 fournit pour l'installation de scripts : en particulier, la variable <varname>search_path</varname>
	 est définie de la même façon et tout nouvel objet créé par le script est automatiquement
	 ajouté à l'extension.
    </para>

    <para>
	 Si une extension a un fichier de contrôle secondaire, les paramètres de contrôle qui 
	 sont utilisés par un script de mise à jour sont ceux définis par le script de la version
	 cible.
    </para>

    <para>
	 Le mécanisme de mise à jour peut être utilisé pour résoudre un cas particulier important :
	 convertir une collection éparse d'objets en une extension.
	 Avant que le mécanisme d'extension ne soit introduit à <productname>PostgreSQL</productname>
	 (dans la version 9.1), de nombreuses personnes écrivaient des modules d'extension qui créaient
	 simplement un assortiment d'objets non empaquetés.
	 Etant donné une base de donnée existante contenant de tels objets, comment convertir ces objets
	 en des extensions proprement empaquetées ? Les supprimer puis exécuter la commande <command>
	 CREATE EXTENSION</command> est une première méthode, mais elle n'est pas envisageable lorsque
	 les objets ont des dépendances (par exemple, s'il y a des colonnes de table dont le type de 
	 données appartient à une extension). Le moyen proposé pour résoudre ce problème est de créer
	 une extension vide, d'utiliser la commande <command>ALTER EXTENSION ADD</command> pour lier
	 chaque objet pré-existant à l'extension, et finalement créer les nouveaux objets présents dans
	 la nouvelle extension mais absents de celle non empaquetée. La commande <command>CREATE EXTENSION</command>
	 prend en charge cette fonction avec son option <literal>FROM</literal> <replaceable class="parameter">old_version</replaceable>,
	 qui permet de ne pas charger le script d'installation par défaut pour la version ciblée, mais celui nommé
	 <literal><replaceable>extension</replaceable>--<replaceable>old_version</replaceable>--<replaceable>target_version</replaceable>.sql</literal>.
	 Le choix de la valeur de <replaceable class="parameter">old_version</replaceable>
	 relève de la responsabilité de l'auteur de l'extension, même si <literal>unpackaged</literal> est souvent rencontré.
	 Il est aussi possible de multiplier les valeurs de <replaceable class="parameter">old_version</replaceable> pour prendre en compte
	 une mise à jour depuis différentes anciennes versions.
    </para>

    <para>
     La commande <command>ALTER EXTENSION</command> peut exécuter des mises à jour en séquence pour 
	 réussir une mise à jour. Par exemple, si seuls les fichiers <literal>foo--1.0--1.1.sql</literal>
	 et <literal>foo--1.1--2.0.sql</literal> sont disponibles, la commande <command>ALTER 
	 EXTENSION</command> les exécutera séquentiellement si une mise à jour vers la version <literal>2.0</literal>
	 est demandée alors que la version <literal>1.0</literal> est installée.
    </para>

    <para>
     <productname>PostgreSQL</productname> ne suppose rien au sujet des noms de version.
	 Par exemple, il ne sait pas si <literal>1.1</literal> suit <literal>1.0</literal>.
	 Il effectue juste une correspondance entre les noms de version et suit un chemin
	 qui nécessite d'appliquer le moins de fichier de script possible.
	 Un nom de version peut en réalité être toute chaîne qui ne contiendrait pas
	 <literal>--</literal> ou qui ne commencerait ou ne finirait pas par <literal>-</literal>.
    </para>

    <para>
	 Il peut parfois être utile de fournir des scripts de retour en arrière, comme par exemple
	 <literal>foo--1.1--1.0.sql</literal> pour autoriser d'inverser les modifications effectuées
	 par la mise à jour en version <literal>1.1</literal>. Si vous procédez ainsi, ayez conscience
	 de la possibilité laissée à <productname>PostgreSQL</productname> d'exécuter un tel script de retour
	 en arrière s'il permet d'atteindre la version cible d'une mise à jour en un nombre réduit d'étapes.
	 La cause du risque se trouve dans les scripts de mise à jour optimisés permettant de passer
	 plusieurs versions en un seul script. La longueur du chemin commençant par un retour en
	 arrière suivi d'un script optimisé pourrait être inférieure à la longueur du chemin qui monterait
	 de version une par une. Si le script de retour en arrière supprime un objet irremplaçable, les conséquences
	 pourraient en être facheuses.
    </para>

    <para>
	 Pour vérifier que vous ne serez pas confronté à des chemins de mise à jour inattendus, utilisez cette commande&nbsp;:
<programlisting>
SELECT * FROM pg_extension_update_paths('<replaceable>extension_name</replaceable>');
</programlisting>
     Cette commande permet d'afficher chaque paire de noms de version connues pour l'extension spécifiée, ainsi
	 que le chemin de mise à jour qui serait suivi depuis la version de départ jusque la version cible, ou la valeur
	 <literal>NULL</literal> si aucun chemin valable n'est disponible. Le chemin est affiché sous une forme textuelle
	 avec des séparateurs <literal>--</literal>. Vous pouvez utiliser <literal>regexp_split_to_array(path,'--')</literal>
	 si vous préférez le format tableau.
    </para>
   </sect2>

   <sect2>
    <title>Exemples d'extensions</title>

    <para>
	 Ci-après, un exemple complet d'une extension écrite uniquement en <acronym>SQL</acronym>,
	 un type composite de deux éléments qui peut stocker n'importe quelle valeur dans chaque
	 emplacement, qui sont nommés <quote>k</quote> et <quote>v</quote>. Les valeurs non textuelles
	 sont automatiquement changées en texte avant stockage.
    </para>

    <para>
	 Le fichier de script <filename>pair--1.0.sql</filename> ressemble à ceci:

<programlisting><![CDATA[
-- se plaint si le script est exécuté directement dans psql, plutôt que via CREATE EXTENSION
\echo Use "CREATE EXTENSION pair" to load this file. \quit

CREATE TYPE pair AS ( k text, v text );

CREATE OR REPLACE FUNCTION pair(anyelement, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(text, anyelement)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(anyelement, anyelement)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(text, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair;';

CREATE OPERATOR ~> (LEFTARG = text, RIGHTARG = anyelement, PROCEDURE = pair);
CREATE OPERATOR ~> (LEFTARG = anyelement, RIGHTARG = text, PROCEDURE = pair);
CREATE OPERATOR ~> (LEFTARG = anyelement, RIGHTARG = anyelement, PROCEDURE = pair);
CREATE OPERATOR ~> (LEFTARG = text, RIGHTARG = text, PROCEDURE = pair);
]]>
</programlisting>
    </para>

    <para>
	 Le fichier de contrôle <filename>pair.control</filename> ressemble à ceci:

<programlisting>
# extension pair
comment = 'Un type de donnees representant un couple clef/valeur'
default_version = '1.0'
relocatable = true
</programlisting>
    </para>

    <para>
	 Si vous avez besoin d'un fichier d'installation pour installer ces deux fichiers dans le bon répertoire,
	 vous pouvez utiliser le fichier <filename>Makefile</filename> qui suit :

<programlisting>
EXTENSION = pair
DATA = pair--1.0.sql

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
</programlisting>

     Ce fichier d'installation s'appuye sur <acronym>PGXS</acronym>, qui est décrit dans <xref linkend="extend-pgxs"/>.
	 La commande <literal>make install</literal> va installer les fichiers de contrôle et de script dans le
	 répertoire adéquat tel qu'indiqué par <application>pg_config</application>.
    </para>

    <para>
	 Une fois les fichiers installés, utilisez la commande <xref linkend="sql-createextension"/> pour charger
	 les objets dans une base de donnée.
    </para>
   </sect2>
  </sect1>

  <sect1 id="extend-pgxs">
   <title>Outils de construction d'extension</title>

   <indexterm zone="extend-pgxs">
    <primary>pgxs</primary>
   </indexterm>

   <para>
    Si vous comptez distribuer vos propres modules d'extension <productname>PostgreSQL</productname>,
	la mise en &oelig;uvre d'un système de construction multiplateforme sera réellement difficile.
	Cependant, <productname>PostgreSQL</productname> met à disposition des outils pour construire
	des extensions, appelés <acronym>PGXS</acronym>, permettant à de simples extensions d'être
	construites sur un serveur déjà installé. <acronym>PGXS</acronym> est principalement destiné
	aux extensions qui incluent du code C, bien qu'il puisse être utilisé aussi pour des extensions composées
	exclusivement de code SQL. <acronym>PGXS</acronym> n'a pas toutefois été conçu pour être un framework
	de construction universel qui pourrait construire tout logiciel s'interfaçant avec <productname>PostgreSQL</productname>.
	Il automatise simplement des règles de construction communes pour des extensions simples. Pour des paquetages
	plus complexes, vous aurez toujours besoin d'écrire vos propres systèmes de construction.
   </para>

   <para>
    Pour utiliser le système <acronym>PGXS</acronym> pour votre extension, vous devez écrire un simple makefile.
	Dans ce makefile, vous devez définir plusieurs variables et inclure le makefile de <acronym>PGXS</acronym>.
	Voici un exemple qui construit une extension nommée <literal>isbn_issn</literal>, qui consiste en une bibliothèque
	qui contient du code C, un fichier de contrôle d'extension, un script SQL et une documentation texte&nbsp;:
<programlisting>
MODULES = isbn_issn
EXTENSION = isbn_issn
DATA = isbn_issn--1.0.sql
DOCS = README.isbn_issn

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
</programlisting>
    Les trois dernières lignes devraient toujours être les mêmes. En début de fichier, vous pouvez assigner des variables
	ou ajouter des règles <application>make</application> personnalisées.
   </para>

   <para>
    Définissez une de ces trois variables pour spécifier ce qui est construit&nbsp;:

    <variablelist>
     <varlistentry>
      <term><varname>MODULES</varname></term>
      <listitem>
       <para>
	    liste des bibliothèques à constuire depuis les fichiers sources communs (ne pas inclure les suffixes de bibliothèques dans la liste)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>MODULE_big</varname></term>
      <listitem>
       <para>
	    Une bibliothèque à construire depuis plusieurs fichiers source
		(listez les fichiers objets dans la variable <varname>OBJS</varname>).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PROGRAM</varname></term>
      <listitem>
       <para>
	    Un programme exécutable à construire
		(listez les fichiers objet dans la variable <varname>OBJS</varname>).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

	Les variables suivantes peuvent aussi être définies&nbsp;:

    <variablelist>
     <varlistentry>
      <term><varname>EXTENSION</varname></term>
      <listitem>
       <para>
	    Nom(s) de l'extension&nbsp;; pour chaque nom, vous devez fournir un fichier
        <literal><replaceable>extension</replaceable>.control</literal>,
        qui sera installé dans le répertoire
        <literal><replaceable>prefix</replaceable>/share/extension</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>MODULEDIR</varname></term>
      <listitem>
       <para>
	    Sous-répertoire de <literal><replaceable>prefix</replaceable>/share</literal>
		dans lequel les fichiers DATA et DOCS seront installés
        (s'il n'est pas défini, la valeur par défaut est <literal>extension</literal> si
        <varname>EXTENSION</varname> est défini et <literal>contrib</literal> dans le cas
        contraire)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA</varname></term>
      <listitem>
       <para>
	    Fichiers divers à installer dans <literal><replaceable>prefix</replaceable>/share/$MODULEDIR</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA_built</varname></term>
      <listitem>
       <para>
	    Fichiers divers à installer dans
        <literal><replaceable>prefix</replaceable>/share/$MODULEDIR</literal>,
        qui nécessitent d'être construit au préalable
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA_TSEARCH</varname></term>
      <listitem>
       <para>
	    Fichiers divers à installer dans
        <literal><replaceable>prefix</replaceable>/share/tsearch_data</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DOCS</varname></term>
      <listitem>
       <para>
	    Fichiers divers à installer dans
        <literal><replaceable>prefix</replaceable>/doc/$MODULEDIR</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SCRIPTS</varname></term>
      <listitem>
       <para>
	    Fichiers de scripts (non binaires) à installer dans
        <literal><replaceable>prefix</replaceable>/bin</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SCRIPTS_built</varname></term>
      <listitem>
       <para>
	    Fichiers de script (non binaires) à installer dans
        <literal><replaceable>prefix</replaceable>/bin</literal>,
        qui nécessitent d'être construit au préalable.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>REGRESS</varname></term>
      <listitem>
       <para>
	    Liste de tests de regression (sans suffixe), voir plus bas
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>REGRESS_OPTS</varname></term>
      <listitem>
       <para>
        Options supplémentaires à passer à <application>pg_regress</application>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>EXTRA_CLEAN</varname></term>
      <listitem>
       <para>
	    Fichiers supplémentaire à supprimer par la commande <literal>make clean</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_CPPFLAGS</varname></term>
      <listitem>
       <para>
	    Sera ajouté à <varname>CPPFLAGS</varname>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_LIBS</varname></term>
      <listitem>
       <para>
	    Sera ajouté à la ligne d'édition de lien de <varname>PROGRAM</varname>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SHLIB_LINK</varname></term>
      <listitem>
       <para>
	    Sera ajouté à la ligne d'édition de lien de <varname>MODULE_big</varname>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_CONFIG</varname></term>
      <listitem>
       <para>
	    Chemin vers le programme <application>pg_config</application> de l'installation
		de <productname>PostgreSQL</productname> pour laquelle construire la bibliothèque ou le binaire
        (l'utilisation de <literal>pg_config</literal> seul permet d'utiliser le premier accessible par votre 
		<varname>PATH</varname>)
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    </para>
 
    <para>
	Placez ce fichier de construction comme <literal>Makefile</literal> dans le répertoire
	qui contient votre extension. Puis vous pouvez exécuter la commande <literal>make</literal>
	pour compiler, et ensuite <literal>make install</literal> pour déployer le module. Par défaut,
	l'extension est compilée et installée pour l'installation de <productname>PostgreSQL</productname>
	qui correspond au premier programme <command>pg_config</command> trouvé dans votre <varname>PATH</varname>.
	Vous pouvez utiliser une installation différente en définissant <varname>PG_CONFIG</varname> pour pointer
	sur le programme <command>pg_config</command> de votre choix, soit dans le fichier makefile, soit
	à partir de la ligne de commande de la commande <literal>make</literal>.
    </para>

   <caution>
    <para>
	 Modifier la variable <varname>PG_CONFIG</varname> ne fonctionne que lorsque l'on
	 compile pour <productname>PostgreSQL</productname> 8.3 et au delà.
	 Avec des versions plus anciennes, il n'est possible de spécifier que
	 <literal>pg_config</literal>. Vous devez modifier votre <varname>PATH</varname>
	 pour choisir l'installation souhaitée.
    </para>
   </caution>

   <para>
    Les scripts listés dans la variable <varname>REGRESS</varname> sont utilisés pour
	des tests de regression de votre module, qui peut être invoqué par <literal>make
	installcheck</literal> après avoir effectué <literal>make install</literal>. Pour que
	cela fonctionne, vous devez lancer le serveur <productname>PosgreSQL</productname> préalablement.
	Les fichiers de script listés dans la variable <varname>REGRESS</varname> doivent
	apparaître dans le sous-répertoire appelé <literal>sql/</literal> du répertoire
	de votre extension. Ces fichiers doivent avoir l'extension <literal>.sql</literal>, 
	qui ne doit pas être inclus dans la liste <varname>REGRESS</varname> du makefile.
	Pour chaque test, il doit aussi y avoir un fichier qui contient les résultats attendus
	dans un sous-répertoire nommé <literal>expected</literal>, avec le même nom mais l'extension
	<literal>.out</literal>. La commande <literal>make installcheck</literal> exécute chaque
	script de test avec <application>psql</application>, et compare la sortie resultante
	au fichier de résultat correspondant. Toute différence sera écrite dans le fichier
	<literal>regression.diffs</literal> au format <command>diff -c</command>. Notez que
	l'exécution d'un test qui ne dispose pas des fichiers nécessaires sera rapportée comme
	une erreur dans le test, donc assurez-vous que tous les fichiers nécessaires soient présents.
   </para>

   <tip>
    <para>
	 Le moyen le plus simple de créer les fichiers nécessaires est de créer des fichiers vides,
	 puis d'effectuer un jeu d'essai (qui bien sûr retournera des anomalies). Étudiez les 
	 résultats trouvés dans le répertoire <literal>results</literal> et copiez-les dans le répertoire
	 <literal>expected/</literal> s'ils correspondent à ce que vous attendiez du test correspondant.
    </para>

   </tip>
   </sect1>

</chapter>
