<?xml version="1.0" encoding="UTF-8"?>
<chapter id="functions">
 <title>Fonctions et opérateurs</title>

 <indexterm zone="functions">
  <primary>fonction</primary>
 </indexterm>

 <indexterm zone="functions">
  <primary>opérateur</primary>
 </indexterm>

 <para>
  <productname>PostgreSQL</productname> fournit un grand nombre de fonctions
  et d'opérateurs pour les types de données natifs. Ce chapitre en décrit la
  plupart, bien que certaines fonctions spéciales apparaissent dans des
  sections plus adéquates du manuel. Les utilisateurs peuvent aussi définir
  leur propres fonctions et opérateurs, comme décrit dans <xref
  linkend="server-programming"/>. Les méta-commandes <command>\df</command>
  et <command>\do</command> de <application>psql</application> peuvent être
  utilisées pour lister, respectivement, toutes les fonctions et tous les
  opérateurs disponibles.
 </para>

 <para>
  La notation utilisée dans ce chapitre pour décrire les types de données des
  arguments et du résultat d'une fonction ou d'un opérateur ressemble à
  ceci&nbsp;
  <synopsis>
<function>repeat</function> ( <type>text</type>, <type>integer</type> ) <returnvalue>text</returnvalue>
  </synopsis>
  qui signifie que la fonction <function>repeat</function> prend un premier
  argument de type <literal>text</literal> et un deuxième argument de type
  <literal>integer</literal>. La flèche droite est aussi utilisée pour
  indiquer le résultat d'un exemple, par exemple&nbsp;: one integer argument
  and returns a result of type text.  The right arrow is also used to
  indicate the result of an example, thus:
  <programlisting>
repeat('Pg', 4) <returnvalue>PgPgPgPg</returnvalue>
  </programlisting>
 </para>

 <para>
  Si vous êtes préoccupé par la portabilité, notez que la plupart des
  fonctions et opérateurs décrits dans ce chapitre, à l'exception des
  opérateurs arithmétiques et de comparaison triviaux, et de certaines
  fonctions indiquées explicitement, ne sont pas indiqués dans le standard
  <acronym>SQL</acronym>. Certaines sont présentes dans d'autres moteurs de
  bases de données. Dans certains cas, elles sont compatibles et cohérentes
  sur les différentes implémentations.
 </para>


 <sect1 id="functions-logical">
  <title>Opérateurs logiques</title>

  <indexterm zone="functions-logical">
   <primary>opérateur</primary>
   <secondary>logical</secondary>
  </indexterm>

  <indexterm>
   <primary>Booléen</primary>
   <secondary>opérateurs</secondary>
   <see>opérateurs, logique</see>
  </indexterm>

  <para>
   Les opérateurs logiques habituels sont disponibles&nbsp;:

   <indexterm>
    <primary>AND (opérateur)</primary>
   </indexterm>

   <indexterm>
    <primary>OR (opérateur)</primary>
   </indexterm>

   <indexterm>
    <primary>NOT (opérateur)</primary>
   </indexterm>

   <indexterm>
    <primary>conjunction</primary>
   </indexterm>

   <indexterm>
    <primary>disjunction</primary>
   </indexterm>

   <indexterm>
    <primary>negation</primary>
   </indexterm>

   <synopsis>
<type>boolean</type> <literal>AND</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
<type>boolean</type> <literal>OR</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
<literal>NOT</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
   </synopsis>

   Le <acronym>SQL</acronym> utilise un système logique en trois valeurs,
   avec true, false et <literal>null</literal>, qui représente une valeur
   <quote>inconnue</quote>. Voici les tables de vérités&nbsp;:

   <informaltable>
    <tgroup cols="4">
     <thead>
      <row>
       <entry><replaceable>a</replaceable></entry>
       <entry><replaceable>b</replaceable></entry>
       <entry><replaceable>a</replaceable> AND <replaceable>b</replaceable></entry>
       <entry><replaceable>a</replaceable> OR <replaceable>b</replaceable></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>TRUE</entry>
       <entry>TRUE</entry>
       <entry>TRUE</entry>
       <entry>TRUE</entry>
      </row>

      <row>
       <entry>TRUE</entry>
       <entry>FALSE</entry>
       <entry>FALSE</entry>
       <entry>TRUE</entry>
      </row>

      <row>
       <entry>TRUE</entry>
       <entry>NULL</entry>
       <entry>NULL</entry>
       <entry>TRUE</entry>
      </row>

      <row>
       <entry>FALSE</entry>
       <entry>FALSE</entry>
       <entry>FALSE</entry>
       <entry>FALSE</entry>
      </row>

      <row>
       <entry>FALSE</entry>
       <entry>NULL</entry>
       <entry>FALSE</entry>
       <entry>NULL</entry>
      </row>

      <row>
       <entry>NULL</entry>
       <entry>NULL</entry>
       <entry>NULL</entry>
       <entry>NULL</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>

   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry><replaceable>a</replaceable></entry>
       <entry>NOT <replaceable>a</replaceable></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>TRUE</entry>
       <entry>FALSE</entry>
      </row>

      <row>
       <entry>FALSE</entry>
       <entry>TRUE</entry>
      </row>

      <row>
       <entry>NULL</entry>
       <entry>NULL</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>

  <para>
   Les opérateurs <literal>AND</literal> et <literal>OR</literal> sont
   commutatifs, c'est-à-dire que vous pouvez intervertir les opérandes gauche
   et droit sans changer le résultat. (Néanmoins, il n'est pas garanti que
   l'opérande gauche est évaluée avant l'opérande droit. Voir <xref
   linkend="syntax-express-eval"/> pour plus d'informations sur l'ordre
   d'évaluation des sous-expressions.)
  </para>
 </sect1>

 <sect1 id="functions-comparison">
  <title>Fonctions et opérateurs de comparaison</title>

  <indexterm zone="functions-comparison">
   <primary>comparaison</primary>
   <secondary>opérateurs</secondary>
  </indexterm>

  <para>
   Les opérateurs de comparaison habituels sont disponibles comme indiqués
   dans <xref linkend="functions-comparison-op-table"/>.
  </para>

  <table id="functions-comparison-op-table">
   <title>Opérateurs de comparaison</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Opérateur</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <replaceable>datatype</replaceable> <literal>&lt;</literal> <replaceable>datatype</replaceable>
       <returnvalue>boolean</returnvalue>
      </entry>
      <entry>Inférieur à</entry>
     </row>

     <row>
      <entry>
       <replaceable>datatype</replaceable> <literal>&gt;</literal> <replaceable>datatype</replaceable>
       <returnvalue>boolean</returnvalue>
      </entry>
      <entry>Supérieur à</entry>
     </row>

     <row>
      <entry>
       <replaceable>datatype</replaceable> <literal>&lt;=</literal> <replaceable>datatype</replaceable>
       <returnvalue>boolean</returnvalue>
      </entry>
      <entry>Inférieur ou égal à</entry>
     </row>

     <row>
      <entry>
       <replaceable>datatype</replaceable> <literal>&gt;=</literal> <replaceable>datatype</replaceable>
       <returnvalue>boolean</returnvalue>
      </entry>
      <entry>Supérieur ou égal à</entry>
     </row>

     <row>
      <entry>
       <replaceable>datatype</replaceable> <literal>=</literal> <replaceable>datatype</replaceable>
       <returnvalue>boolean</returnvalue>
      </entry>
      <entry>Égal</entry>
     </row>

     <row>
      <entry>
       <replaceable>datatype</replaceable> <literal>&lt;&gt;</literal> <replaceable>datatype</replaceable>
       <returnvalue>boolean</returnvalue>
      </entry>
      <entry>Différent</entry>
     </row>

     <row>
      <entry>
       <replaceable>datatype</replaceable> <literal>!=</literal> <replaceable>datatype</replaceable>
       <returnvalue>boolean</returnvalue>
      </entry>
      <entry>Différent</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <literal>&lt;&gt;</literal> est la notation du standard SQL  <quote>non
     égal</quote>. <literal>!=</literal> est un alias, converti en
    <literal>&lt;&gt;</literal> au tout début de l'analyse. De ce fait, il
    n'est pas possible d'implémenter des opérateurs <literal>!=</literal> et
    <literal>&lt;&gt;</literal> qui se comporteraient différemment.
   </para>
  </note>

  <para>
   Ces opérateurs de comparaison sont disponibles pour les types de données
   natifs qui ont un tri naturel, incluant les types des nombres, des chaînes
   et des dates/heures. De plus, les tableaux, types composites et
   intervalles peuvent être comparés si le type de données de leurs éléments
   sont comparables.
  </para>

  <para>
   Il est généralement possible de comparer les valeurs de types de données
   en relation&nbsp;; par exemple <type>integer</type>
   <literal>&gt;</literal> <type>bigint</type> fonctionnera. Certains cas de
   ce type sont implémentés directement par des opérateurs de comparaison
   <quote>inter-type</quote>, mais si aucun opérateur de ce type n'est
   disponible, l'analyseur va forcer une conversion de type du type le plus
   spécifique au type le plus global., et appliquer l'opérateur de
   comparaison correspondant.
  </para>

  <para>
   Comme indiqué ci-dessus, tous les opérateurs de comparaison sont des
   opérateurs binaires, renvoyant des valeurs de type <type>boolean</type>.
   De ce fait, les expressions comme <literal>1 &lt; 2 &lt; 3</literal> ne
   sont pas valides (parce qu'il n'existe pas d'opérateur
   <literal>&lt;</literal> comparant une valeur booléenne avec
   <literal>3</literal>). Utilisez les prédicats <literal>BETWEEN</literal>
   affichés ci-dessous pour réaliser des tests sur des intervalles.
  </para>

  <para>
   Il existe aussi des prédicats de comparaison, comme indiqués dans <xref
   linkend="functions-comparison-pred-table"/>. Ils se comportent comme des
   opérateurs, mais disposent d'une syntaxe spéciale mandatée par le standard
   SQL.
  </para>

  <table id="functions-comparison-pred-table">
   <title>Prédicats de comparaison</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="func_table_entry"><para role="func_signature">
        Prédicat
       </para>
       <para>
        Description
       </para>
       <para>
        Exemple(s)
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>BETWEEN</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Entre (les points de départ et d'arrêt sont inclus).
       </para>
       <para>
        <literal>2 BETWEEN 1 AND 3</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>2 BETWEEN 3 AND 1</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOT BETWEEN</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Pas entre (la négation de <literal>BETWEEN</literal>).
       </para>
       <para>
        <literal>2 NOT BETWEEN 1 AND 3</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>BETWEEN SYMMETRIC</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Entre, après le tri des valeurs de départ et d'arrêt.
       </para>
       <para>
        <literal>2 BETWEEN SYMMETRIC 3 AND 1</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOT BETWEEN SYMMETRIC</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Pas entre, après le tri des valeurs de départ et d'arrêt.
       </para>
       <para>
        <literal>2 NOT BETWEEN SYMMETRIC 3 AND 1</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS DISTINCT FROM</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Différent, en traitant les valeurs NULL comme des valeurs comparables
        entre elles.
       </para>
       <para>
        <literal>1 IS DISTINCT FROM NULL</literal>
        <returnvalue>t</returnvalue> (plutôt que <literal>NULL</literal>)
       </para>
       <para>
        <literal>NULL IS DISTINCT FROM NULL</literal>
        <returnvalue>f</returnvalue> (plutôt que <literal>NULL</literal>)
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NOT DISTINCT FROM</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Égal, en traitant les valeurs NULL comme des valeurs comparables entre
        elles.
       </para>
       <para>
        <literal>1 IS NOT DISTINCT FROM NULL</literal>
        <returnvalue>f</returnvalue> (plutôt que <literal>NULL</literal>)
       </para>
       <para>
        <literal>NULL IS NOT DISTINCT FROM NULL</literal>
        <returnvalue>t</returnvalue> (plutôt que <literal>NULL</literal>)
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Teste si la valeur est NULL.
       </para>
       <para>
        <literal>1.5 IS NULL</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NOT NULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Teste si la valeur n'est pas NULL
       </para>
       <para>
        <literal>'null' IS NOT NULL</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>ISNULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Teste si la valeur est NULL (syntaxe non standard).
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOTNULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Teste si la valeur n'est pas NULL (syntaxe non standard).
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS TRUE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Teste si l'expression booléenne vaut true.
       </para>
       <para>
        <literal>true IS TRUE</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS TRUE</literal>
        <returnvalue>f</returnvalue> (plutôt que <literal>NULL</literal>)
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT TRUE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Teste si l'expression booléenne ne vaut pas true (donc false ou NULL).
       </para>
       <para>
        <literal>true IS NOT TRUE</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT TRUE</literal>
        <returnvalue>t</returnvalue> (plutôt que <literal>NULL</literal>)
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS FALSE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Teste si l'expression booléenne vaut false.
       </para>
       <para>
        <literal>true IS FALSE</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS FALSE</literal>
        <returnvalue>f</returnvalue> (plutôt que <literal>NULL</literal>)
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT FALSE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Teste si l'expression booléenne ne vaut pas false (donc soit true soit
        NULL).
       </para>
       <para>
        <literal>true IS NOT FALSE</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT FALSE</literal>
        <returnvalue>t</returnvalue> (plutôt que <literal>NULL</literal>)
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS UNKNOWN</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Teste si l'expression booléenne renvoie inconnu.
       </para>
       <para>
        <literal>true IS UNKNOWN</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS UNKNOWN</literal>
        <returnvalue>t</returnvalue> (plutôt que <literal>NULL</literal>)
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT UNKNOWN</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Teste si l'expression booléenne renvoie true ou false.
       </para>
       <para>
        <literal>true IS NOT UNKNOWN</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT UNKNOWN</literal>
        <returnvalue>f</returnvalue> (plutôt que <literal>NULL</literal>)
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <indexterm>
    <primary>BETWEEN</primary>
   </indexterm>
   <indexterm>
    <primary>BETWEEN SYMMETRIC</primary>
   </indexterm>
   Le prédicat <token>BETWEEN</token> simplifie les tests d'intervalle&nbsp;:
   <synopsis>
<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
   </synopsis>
   est équivalent à&nbsp;:
   <synopsis>
<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND <replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>
   </synopsis>
   Notez que <token>BETWEEN</token> traite les valeurs de départ et d'arrêt
   comme inclus à l'intervalle. <literal>BETWEEN SYMMETRIC</literal> est
   identique à <literal>BETWEEN</literal> sauf qu'il n'y a pas d'obligation
   que l'argument de gauche de <literal>AND</literal> soit inférieur ou égale
   à l'argument de droite. Dans le cas contraire, les deux arguments sont
   automatiquement inversés pour qu'un intervalle non vide soit toujours de
   rigueur.

  </para>

  <para>
   Les différentes variantes de <literal>BETWEEN</literal> sont implémentées
   dans les termes des opérateurs de comparaison standard et, de ce fait,
   fonctionneront pour tout type de données qui peut être comparé.
  </para>

  <note>
   <para>
    L'utilisation de <literal>AND</literal> dans la syntaxe
    <literal>BETWEEN</literal> crée une ambiguité avec l'utilisation de
    <literal>AND</literal> comme opérateur logique. Pour résoudre ceci, seul
    un ensemble limité de types d'expression est autorisé comme deuxième
    argument d'une clause <literal>BETWEEN</literal>. Si vous avez besoin
    d'écrire une sous-expression plus complexe dans
    <literal>BETWEEN</literal>, ajoutez des parenthèses autour de la
    sous-expression.
   </para>
  </note>

  <para>
   <indexterm>
    <primary>IS DISTINCT FROM</primary>
   </indexterm>
   <indexterm>
    <primary>IS NOT DISTINCT FROM</primary>
   </indexterm>
   Les opérateurs de comparaison habituels renvoient NULL (signifiant
   <quote>inconnu</quote>), et non pas true ou false, si l'argument
   est NULL. Par exemple, <literal>7 = NULL</literal> renvoie NULL, tout
   autant que <literal>7 &lt;&gt; NULL</literal>. Si ce comportement n'est
   pas adéquat, utilisez les prédicats <literal>IS <optional> NOT </optional>
    DISTINCT FROM</literal>&nbsp;:
   <synopsis>
<replaceable>a</replaceable> IS DISTINCT FROM <replaceable>b</replaceable>
<replaceable>a</replaceable> IS NOT DISTINCT FROM <replaceable>b</replaceable>
   </synopsis>
   Pour les valeurs non NULL, <literal>IS DISTINCT FROM</literal> est
   identique à l'opérateur <literal>&lt;&gt;</literal>. Néanmoins, si les
   deux arguments sont NULL, il renvoie false et si un seul des deux
   arguments est NULL, il renvoie true. De la même façon, <literal>IS NOT
    DISTINCT FROM</literal> est identique à <literal>=</literal> pour les
   arguments non NULL, mais il renvoie true quand les deux arguments sont
   NULL et false quand un seul argument est NULL. De ce fait, ces prédicats
   agissent comme si NULL était une valeur normale, plus
   qu'<quote>inconnue</quote>.
  </para>

  <para>
   <indexterm>
    <primary>IS NULL</primary>
   </indexterm>
   <indexterm>
    <primary>IS NOT NULL</primary>
   </indexterm>
   <indexterm>
    <primary>ISNULL</primary>
   </indexterm>
   <indexterm>
    <primary>NOTNULL</primary>
   </indexterm>
   Pour vérifier si une valeur est NULL ou non, utilisez le prédicat&nbsp;:
   <synopsis>
<replaceable>expression</replaceable> IS NULL
<replaceable>expression</replaceable> IS NOT NULL
   </synopsis>
   ou les prédicats équivalents, mais non standards&nbsp;:
   <synopsis>
<replaceable>expression</replaceable> ISNULL
<replaceable>expression</replaceable> NOTNULL
   </synopsis>
   <indexterm><primary>valeur null</primary><secondary>comparaison</secondary></indexterm>
  </para>

  <para>
   N'écrivez <emphasis>pas</emphasis>
   <literal><replaceable>expression</replaceable> = NULL</literal> car
   <literal>NULL</literal> n'est pas <quote>égal à</quote>
   <literal>NULL</literal>. (La valeur NULL représente une valeur inconnue,
   et il n'est pas possible de savoir si deux valeurs inconnues sont égales.)
  </para>

  <tip>
   <para>
    Certaines applications pourraient s'attendre que
    <literal><replaceable>expression</replaceable> = NULL</literal> renvoient
    true si <replaceable>expression</replaceable> s'évalue à la valeur NULL.
    Il est hautement recommandé que ces applications soient modifiées pour se
    conformer au standard SQL. Néanmoins, si cela ne peut pas se faire, le
    paramètre <xref linkend="guc-transform-null-equals"/> est disponible. S'il
    est activé, <productname>PostgreSQL</productname> convertira les clauses
    <literal>x = NULL</literal> en <literal>x IS NULL</literal>.
   </para>
  </tip>

  <para>
   Si l'<replaceable>expression</replaceable> est une valeur ligne, alors
   <literal>IS NULL</literal> est true quand l'expression de ligne elle-même
   est NULL ou quand tous les champs de la ligne sont NULL, alors que
   <literal>IS NOT NULL</literal> est true quand l'expression de ligne
   elle-même est non NULL et que tous les champs de la ligne sont non NULL. À
   cause de ce comportement, <literal>IS NULL</literal> et <literal>IS NOT
    NULL</literal> ne renvoient pas toujours des résultats inversés pour les
   expressions de ligne&nbsp;; en particulier, une expression de ligne qui
   contient des champs NULL et non NULL renverra false pour les deux tests.
   Dans certains cas, il pourrait être préférable d'écrire
   <replaceable>ligne</replaceable> <literal>IS DISTINCT FROM NULL</literal>
   ou <replaceable>ligne</replaceable> <literal>IS NOT DISTINCT FROM
    NULL</literal>, qui va simplement vérifier si la valeur de ligne globale
   est NULL, sans tester les champs de la ligne.
  </para>

  <para>
   <indexterm>
    <primary>IS TRUE</primary>
   </indexterm>
   <indexterm>
    <primary>IS NOT TRUE</primary>
   </indexterm>
   <indexterm>
    <primary>IS FALSE</primary>
   </indexterm>
   <indexterm>
    <primary>IS NOT FALSE</primary>
   </indexterm>
   <indexterm>
    <primary>IS UNKNOWN</primary>
   </indexterm>
   <indexterm>
    <primary>IS NOT UNKNOWN</primary>
   </indexterm>
   Les valeurs booléennes peuvent aussi être testées en utilisant les prédicats
   <synopsis>
<replaceable>boolean_expression</replaceable> IS TRUE
<replaceable>boolean_expression</replaceable> IS NOT TRUE
<replaceable>boolean_expression</replaceable> IS FALSE
<replaceable>boolean_expression</replaceable> IS NOT FALSE
<replaceable>boolean_expression</replaceable> IS UNKNOWN
<replaceable>boolean_expression</replaceable> IS NOT UNKNOWN
   </synopsis>
   Ils renverront toujours true ou false, jamais une valeur NULL, même quand
   l'opérande est NULL. Un argument NULL est traité comme la valeur logique
   <quote>inconnue</quote>. Notez que <literal>IS UNKNOWN</literal> et
   <literal>IS NOT UNKNOWN</literal> sont identiques à <literal>IS
    NULL</literal> et <literal>IS NOT NULL</literal>, respectivement, sauf que
   l'expression en argument doit être de type booléen.
  </para>

  <!-- IS OF does not conform to the ISO SQL behavior, so it is undocumented here
   <para>
    <indexterm>
     <primary>IS OF</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT OF</primary>
    </indexterm>
    It is possible to check the data type of an expression using the
    predicates
<synopsis>
<replaceable>expression</replaceable> IS OF (typename, ...)
<replaceable>expression</replaceable> IS NOT OF (typename, ...)
   </synopsis>
   They return a boolean value based on whether the expression's data
   type is one of the listed data types.
  </para>
  -->

 <para>
  Quelques fonctions de comparaison sont aussi disponibles, comme indiquées
  dans <xref linkend="functions-comparison-func-table"/>.
 </para>

 <table id="functions-comparison-func-table">
  <title>Fonctions de comparaison</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>num_nonnulls</primary>
       </indexterm>
       <function>num_nonnulls</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre d'arguments non NULL.
      </para>
      <para>
       <literal>num_nonnulls(1, NULL, 2)</literal>
       <returnvalue>2</returnvalue>
      </para></entry>
    </row>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>num_nulls</primary>
       </indexterm>
       <function>num_nulls</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre d'arguments NULL.
      </para>
      <para>
       <literal>num_nulls(1, NULL, 2)</literal>
       <returnvalue>1</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

</sect1>

<sect1 id="functions-math">
 <title>Fonctions et opérateurs mathématiques</title>

 <para>
  Les opérateurs mathématiques sont fournies pour de nombreux types de
  données pour <productname>PostgreSQL</productname>. Pour les types sans
  conventions mathématiques standards (par exemple les types dates/heures),
  nous décrivons le comportement réel dans les sections suivantes.
 </para>

 <para>
  <xref linkend="functions-math-op-table"/> affiche les opérateurs
  mathématiques disponibles pour les types numériques standards. Sauf note
  explicite, les opérateurs affichés comme acceptant
  <replaceable>numeric_type</replaceable> sont disponibles pour tous les
  types <type>smallint</type>, <type>integer</type>, <type>bigint</type>,
  <type>numeric</type>, <type>real</type> et <type>double precision</type>.
  Les opérateurs affichés comme acceptant
  <replaceable>integral_type</replaceable> sont disponibles pour les types
  <type>smallint</type>, <type>integer</type> et <type>bigint</type>. Sauf
  note explicite, chaque forme d'un opérateur renvoie le même type de
  données que ses arguments, Les appels impliquant plusieurs types de
  données en argument, tel que <type>integer</type> <literal>+</literal>
  <type>numeric</type>, sont résolus en utilisant le type apparaissant en
  dernier dans ces listes.
 </para>

 <table id="functions-math-op-table">
  <title>Opérateurs mathématiques</title>

  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Opérateur
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>numeric_type</replaceable> <literal>+</literal> <replaceable>numeric_type</replaceable>
       <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
      </para>
      <para>
       Addition
      </para>
      <para>
       <literal>2 + 3</literal>
       <returnvalue>5</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <literal>+</literal> <replaceable>numeric_type</replaceable>
       <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
      </para>
      <para>
       Plus unitaire (pas d'opération)
      </para>
      <para>
       <literal>+ 3.5</literal>
       <returnvalue>3.5</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>numeric_type</replaceable> <literal>-</literal> <replaceable>numeric_type</replaceable>
       <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
      </para>
      <para>
       Soustraction
      </para>
      <para>
       <literal>2 - 3</literal>
       <returnvalue>-1</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <literal>-</literal> <replaceable>numeric_type</replaceable>
       <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
      </para>
      <para>
       Négation
      </para>
      <para>
       <literal>- (-4)</literal>
       <returnvalue>4</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>numeric_type</replaceable> <literal>*</literal> <replaceable>numeric_type</replaceable>
       <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
      </para>
      <para>
       Multiplication
      </para>
      <para>
       <literal>2 * 3</literal>
       <returnvalue>6</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>numeric_type</replaceable> <literal>/</literal> <replaceable>numeric_type</replaceable>
       <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
      </para>
      <para>
       Division (pour les types entiers, la division tronque le résultat vers
       zéro)
      </para>
      <para>
       <literal>5.0 / 2</literal>
       <returnvalue>2.5000000000000000</returnvalue>
      </para>
      <para>
       <literal>5 / 2</literal>
       <returnvalue>2</returnvalue>
      </para>
      <para>
       <literal>(-5) / 2</literal>
       <returnvalue>-2</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>numeric_type</replaceable> <literal>%</literal> <replaceable>numeric_type</replaceable>
       <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
      </para>
      <para>
       Modulo (reste)&nbsp;; disponible pour <type>smallint</type>,
       <type>integer</type>, <type>bigint</type> et <type>numeric</type>
      </para>
      <para>
       <literal>5 % 4</literal>
       <returnvalue>1</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>numeric</type> <literal>^</literal> <type>numeric</type>
       <returnvalue>numeric</returnvalue>
      </para>
      <para role="func_signature">
       <type>double precision</type> <literal>^</literal> <type>double precision</type>
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Exposant (contrairement aux pratiques mathématiques typiques,
       plusieurs utilisations de <literal>^</literal> feront une association
       de gauche à droite)
      </para>
      <para>
       <literal>2 ^ 3</literal>
       <returnvalue>8</returnvalue>
      </para>
      <para>
       <literal>2 ^ 3 ^ 3</literal>
       <returnvalue>512</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <literal>|/</literal> <type>double precision</type>
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Racine carrée
      </para>
      <para>
       <literal>|/ 25.0</literal>
       <returnvalue>5</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <literal>||/</literal> <type>double precision</type>
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Racine cubique
      </para>
      <para>
       <literal>||/ 64.0</literal>
       <returnvalue>4</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>bigint</type> <literal>!</literal>
       <returnvalue>numeric</returnvalue>
      </para>
      <para>
       Factoriel
       (obsolète, utilisez à la place <link
       linkend="function-factorial"><function>factorial()</function></link>)
      </para>
      <para>
       <literal>5 !</literal>
       <returnvalue>120</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <literal>!!</literal> <type>bigint</type>
       <returnvalue>numeric</returnvalue>
      </para>
      <para>
       Factoriel (en tant qu'opérateur préfixe)
      </para>
      <para>
       <literal>!! 5</literal>
       <returnvalue>120</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <literal>@</literal> <replaceable>numeric_type</replaceable>
       <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
      </para>
      <para>
       Valeur absolue
      </para>
      <para>
       <literal>@ -5.0</literal>
       <returnvalue>5</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>integral_type</replaceable> <literal>&amp;</literal> <replaceable>integral_type</replaceable>
       <returnvalue><replaceable>integral_type</replaceable></returnvalue>
      </para>
      <para>
       AND bit à bit
      </para>
      <para>
       <literal>91 &amp; 15</literal>
       <returnvalue>11</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>integral_type</replaceable> <literal>|</literal> <replaceable>integral_type</replaceable>
       <returnvalue><replaceable>integral_type</replaceable></returnvalue>
      </para>
      <para>
       OR bit à bit
      </para>
      <para>
       <literal>32 | 3</literal>
       <returnvalue>35</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>integral_type</replaceable> <literal>#</literal> <replaceable>integral_type</replaceable>
       <returnvalue><replaceable>integral_type</replaceable></returnvalue>
      </para>
      <para>
       OR exclusif bit à bit
      </para>
      <para>
       <literal>17 # 5</literal>
       <returnvalue>20</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <literal>~</literal> <replaceable>integral_type</replaceable>
       <returnvalue><replaceable>integral_type</replaceable></returnvalue>
      </para>
      <para>
       NOT bit à bit
      </para>
      <para>
       <literal>~1</literal>
       <returnvalue>-2</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>integral_type</replaceable> <literal>&lt;&lt;</literal> <type>integer</type>
       <returnvalue><replaceable>integral_type</replaceable></returnvalue>
      </para>
      <para>
       Décalage à gauche bit à bit
      </para>
      <para>
       <literal>1 &lt;&lt; 4</literal>
       <returnvalue>16</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>integral_type</replaceable> <literal>&gt;&gt;</literal> <type>integer</type>
       <returnvalue><replaceable>integral_type</replaceable></returnvalue>
      </para>
      <para>
       Décalage à droite bit à bit
      </para>
      <para>
       <literal>8 &gt;&gt; 2</literal>
       <returnvalue>2</returnvalue>
      </para></entry>
    </row>

   </tbody>
  </tgroup>
 </table>

 <para>
  <xref linkend="functions-math-func-table"/> affiche les fonctions
  mathématiques disponibles. Beaucoup de ces fonctions sont fournies dans des
  formes différentes avec des types d'argument différents. Sauf note
  explicite, toute forme donnée d'une fonction renvoie le même type de donnée
  que ses arguments&nbsp;; les cas inter-type sont résolus de la même façon
  qu'expliqué ci-dessus pour les opérateurs. Les fonctions travaillant avec
  des données de type <type>double precision</type> sont implémentées
  majoritairement grâce à la bibliothèque C du système hôte&nbsp;; la
  précision et le comportement dans les cas limites peuvent donc varier
  suivant le système hôte.
 </para>

 <table id="functions-math-func-table">
  <title>Fonctions mathématiques</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>abs</primary>
       </indexterm>
       <function>abs</function> ( <replaceable>numeric_type</replaceable> )
       <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
      </para>
      <para>
       Valeur absolue
      </para>
      <para>
       <literal>abs(-17.4)</literal>
       <returnvalue>17.4</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>cbrt</primary>
       </indexterm>
       <function>cbrt</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Racine cubique
      </para>
      <para>
       <literal>cbrt(64.0)</literal>
       <returnvalue>4</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>ceil</primary>
       </indexterm>
       <function>ceil</function> ( <type>numeric</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para role="func_signature">
       <function>ceil</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Entier le plus proche plus grand ou égal à l'argument
      </para>
      <para>
       <literal>ceil(42.2)</literal>
       <returnvalue>43</returnvalue>
      </para>
      <para>
       <literal>ceil(-42.8)</literal>
       <returnvalue>-42</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>ceiling</primary>
       </indexterm>
       <function>ceiling</function> ( <type>numeric</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para role="func_signature">
       <function>ceiling</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Entier le plus proche plus grand ou égal à l'argument (identique à
       <function>ceil</function>)
      </para>
      <para>
       <literal>ceiling(95.3)</literal>
       <returnvalue>96</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>degrees</primary>
       </indexterm>
       <function>degrees</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Convertit des radians en degrés
      </para>
      <para>
       <literal>degrees(0.5)</literal>
       <returnvalue>28.64788975654116</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>div</primary>
       </indexterm>
       <function>div</function> ( <parameter>y</parameter> <type>numeric</type>,
       <parameter>x</parameter> <type>numeric</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para>
       Quotient entier de <parameter>y</parameter>/<parameter>x</parameter>
       (tronque vers zéro)
      </para>
      <para>
       <literal>div(9,4)</literal>
       <returnvalue>2</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>exp</primary>
       </indexterm>
       <function>exp</function> ( <type>numeric</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para role="func_signature">
       <function>exp</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Exponentiel (<literal>e</literal> élevé à la puissance donnée)
      </para>
      <para>
       <literal>exp(1.0)</literal>
       <returnvalue>2.7182818284590452</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm id="function-factorial">
        <primary>factorial</primary>
       </indexterm>
       <function>factorial</function> ( <type>bigint</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para>
       Factorielle
      </para>
      <para>
       <literal>factorial(5)</literal>
       <returnvalue>120</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>floor</primary>
       </indexterm>
       <function>floor</function> ( <type>numeric</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para role="func_signature">
       <function>floor</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Entier le plus proche plus petit ou égal à l'argument
      </para>
      <para>
       <literal>floor(42.8)</literal>
       <returnvalue>42</returnvalue>
      </para>
      <para>
       <literal>floor(-42.8)</literal>
       <returnvalue>-43</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>gcd</primary>
       </indexterm>
       <function>gcd</function> ( <replaceable>numeric_type</replaceable>, <replaceable>numeric_type</replaceable> )
       <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
      </para>
      <para>
       Plus grand commun diviseur (plus grand nombre positif qui divise les
       arguments en entrée sans reste)&nbsp;; renvoie <literal>0</literal> si
       les deux arguments valent zéro&nbsp;; disponible pour
       <type>integer</type>, <type>bigint</type>et <type>numeric</type>
      </para>
      <para>
       <literal>gcd(1071, 462)</literal>
       <returnvalue>21</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>lcm</primary>
       </indexterm>
       <function>lcm</function> ( <replaceable>numeric_type</replaceable>, <replaceable>numeric_type</replaceable> )
       <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
      </para>
      <para>
       Plus petit commun multiple (plus petit nombre strictement positif qui
       est un multiple entier des deux arguments en entrée)&nbsp;; renvoie
       <literal>0</literal> si les deux arguments valent zéro&nbsp;;
       disponible pour <type>integer</type>, <type>bigint</type>et
       <type>numeric</type>
      </para>
      <para>
       <literal>lcm(1071, 462)</literal>
       <returnvalue>23562</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>ln</primary>
       </indexterm>
       <function>ln</function> ( <type>numeric</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para role="func_signature">
       <function>ln</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Logarithme
      </para>
      <para>
       <literal>ln(2.0)</literal>
       <returnvalue>0.6931471805599453</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>log</primary>
       </indexterm>
       <function>log</function> ( <type>numeric</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para role="func_signature">
       <function>log</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Logarithme base 10
      </para>
      <para>
       <literal>log(100)</literal>
       <returnvalue>2</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>log10</primary>
       </indexterm>
       <function>log10</function> ( <type>numeric</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para role="func_signature">
       <function>log10</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Logarithme base 10 (identique à <function>log</function>)
      </para>
      <para>
       <literal>log10(1000)</literal>
       <returnvalue>3</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>log</function> ( <parameter>b</parameter> <type>numeric</type>,
       <parameter>x</parameter> <type>numeric</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para>
       Logarithme de <parameter>x</parameter> en base <parameter>b</parameter>
      </para>
      <para>
       <literal>log(2.0, 64.0)</literal>
       <returnvalue>6.0000000000</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>min_scale</primary>
       </indexterm>
       <function>min_scale</function> ( <type>numeric</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Échelle minimale (nombre de chiffres décimaux en fraction) nécessaire
       pour représenter la valeur fournie précisément
      </para>
      <para>
       <literal>min_scale(8.4100)</literal>
       <returnvalue>2</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>mod</primary>
       </indexterm>
       <function>mod</function> ( <parameter>y</parameter> <replaceable>numeric_type</replaceable>,
       <parameter>x</parameter> <replaceable>numeric_type</replaceable> )
       <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
      </para>
      <para>
       Reste de <parameter>y</parameter>/<parameter>x</parameter>&nbsp;;
       disponible pour <type>smallint</type>, <type>integer</type>,
       <type>bigint</type> et <type>numeric</type>
      </para>
      <para>
       <literal>mod(9,4)</literal>
       <returnvalue>1</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>pi</primary>
       </indexterm>
       <function>pi</function> (  )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Valeur approximative de <phrase role="symbol_font">&pi;</phrase>
      </para>
      <para>
       <literal>pi()</literal>
       <returnvalue>3.141592653589793</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>power</primary>
       </indexterm>
       <function>power</function> ( <parameter>a</parameter> <type>numeric</type>,
       <parameter>b</parameter> <type>numeric</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para role="func_signature">
       <function>power</function> ( <parameter>a</parameter> <type>double precision</type>,
       <parameter>b</parameter> <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       <parameter>a</parameter> élevé à la puissance de <parameter>b</parameter>
      </para>
      <para>
       <literal>power(9, 3)</literal>
       <returnvalue>729</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>radians</primary>
       </indexterm>
       <function>radians</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Convertit des degrés en radians
      </para>
      <para>
       <literal>radians(45.0)</literal>
       <returnvalue>0.7853981633974483</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>round</primary>
       </indexterm>
       <function>round</function> ( <type>numeric</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para role="func_signature">
       <function>round</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Arrondit à l'entier le plus proche
      </para>
      <para>
       <literal>round(42.4)</literal>
       <returnvalue>42</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>round</function> ( <parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para>
       Arrondit <parameter>v</parameter> à <parameter>s</parameter> positions
       décimales
      </para>
      <para>
       <literal>round(42.4382, 2)</literal>
       <returnvalue>42.44</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>scale</primary>
       </indexterm>
       <function>scale</function> ( <type>numeric</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Échelle de l'argument (le nombre de chiffres décimaux dans la partie
       fractionnelle)
      </para>
      <para>
       <literal>scale(8.4100)</literal>
       <returnvalue>4</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>sign</primary>
       </indexterm>
       <function>sign</function> ( <type>numeric</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para role="func_signature">
       <function>sign</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Signe de l'argument (-1, 0 ou +1)
      </para>
      <para>
       <literal>sign(-8.4)</literal>
       <returnvalue>-1</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>sqrt</primary>
       </indexterm>
       <function>sqrt</function> ( <type>numeric</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para role="func_signature">
       <function>sqrt</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Racine carrée
      </para>
      <para>
       <literal>sqrt(2)</literal>
       <returnvalue>1.4142135623730951</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>trim_scale</primary>
       </indexterm>
       <function>trim_scale</function> ( <type>numeric</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para>
       Réduit l'échelle de la valeur (nombre de chiffres décimaux
       fractionnels) en supprimant les zéro à la fin
      </para>
      <para>
       <literal>trim_scale(8.4100)</literal>
       <returnvalue>8.41</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>trunc</primary>
       </indexterm>
       <function>trunc</function> ( <type>numeric</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para role="func_signature">
       <function>trunc</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Tronque à l'entier (vers zéro)
      </para>
      <para>
       <literal>trunc(42.8)</literal>
       <returnvalue>42</returnvalue>
      </para>
      <para>
       <literal>trunc(-42.8)</literal>
       <returnvalue>-42</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>trunc</function> ( <parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para>
       Tronque <parameter>v</parameter> à <parameter>s</parameter> places
       décimales
      </para>
      <para>
       <literal>trunc(42.4382, 2)</literal>
       <returnvalue>42.43</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>width_bucket</primary>
       </indexterm>
       <function>width_bucket</function> ( <parameter>operand</parameter> <type>numeric</type>, <parameter>low</parameter> <type>numeric</type>, <parameter>high</parameter> <type>numeric</type>, <parameter>count</parameter> <type>integer</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para role="func_signature">
       <function>width_bucket</function> ( <parameter>operand</parameter> <type>double precision</type>, <parameter>low</parameter> <type>double precision</type>, <parameter>high</parameter> <type>double precision</type>, <parameter>count</parameter> <type>integer</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le numéro du compartiment dans lequel
       <parameter>operand</parameter> serait affecté dans un histogramme
       ayant <parameter>count</parameter> compartiments d'égale longueur
       répartis entre <parameter>low</parameter> et
       <parameter>high</parameter>. Renvoie <literal>0</literal> ou
       <literal><parameter>count</parameter>+1</literal> pour un argument en
       dehors de l'intervalle.
      </para>
      <para>
       <literal>width_bucket(5.35, 0.024, 10.06, 5)</literal>
       <returnvalue>3</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>width_bucket</function> ( <parameter>operand</parameter> <type>anyelement</type>, <parameter>thresholds</parameter> <type>anyarray</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le numéro du compartiment dans lequel
       <parameter>operand</parameter> serait affecté pour un tableau listant
       les limites basses des compartiments. Renvoie <literal>0</literal>
       pour un argument inférieur à la première limite basse.
       <parameter>operand</parameter> et les éléments du tableau peuvent être
       de tout type ayant des opérateurs de comparaison standards. Le tableau
       <parameter>thresholds</parameter> <emphasis>doit être
        triés</emphasis>, les plus petits en premier. Sinon, des résultats
       inattendus pourraient être obtenus.
      </para>
      <para>
       <literal>width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])</literal>
       <returnvalue>2</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
  <xref linkend="functions-math-random-table"/> affiche les fonctions pour
  générer des nombres aléatoires.
 </para>

 <table id="functions-math-random-table">
  <title>Fonctions aléatoires</title>

  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>random</primary>
       </indexterm>
       <function>random</function> ( )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Renvoie une valeur aléatoire comprise dans l'intervalle 0.0 &lt;= x
       &lt; 1.0
      </para>
      <para>
       <literal>random()</literal>
       <returnvalue>0.897124072839091</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>setseed</primary>
       </indexterm>
       <function>setseed</function> ( <type>double precision</type> )
       <returnvalue>void</returnvalue>
      </para>
      <para>
       Configure le sel pour les appels suivants à
       <literal>random()</literal>&nbsp;; l'argument doit être compris entre
       -1.0 et 1.0, valeurs comprises.
      </para>
      <para>
       <literal>setseed(0.12345)</literal>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
  La fonction <function>random()</function> utilise un algorithme
  congruentiel linéaire simple. Il est rapide mais non convenable pour des
  applications cryptographiques. Voir le module <xref linkend="pgcrypto"/>
  pour une alternative plus sécurisée. Si <function>setseed()</function> est
  appelé, la série de résultats d'appels en bouicle à
  <function>random()</function> dans la même session peut être répétée en
  ré-exécutant <function>setseed()</function> avec le même argument.
 </para>

 <para>
  <xref linkend="functions-math-trig-table"/> montre les fonctions
  trigonométriques disponibles. Chacune de ces fonctions vient en deux
  variantes, une pour mesurer les angles en radians et une pour les mesurer
  en degrés.
 </para>

 <table id="functions-math-trig-table">
  <title>Fonctions trigonométriques</title>

  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>acos</primary>
       </indexterm>
       <function>acos</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Cosinus inverse, résultat en radians
      </para>
      <para>
       <literal>acos(1)</literal>
       <returnvalue>0</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>acosd</primary>
       </indexterm>
       <function>acosd</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Cosinus inverse, résultat en degrés
      </para>
      <para>
       <literal>acosd(0.5)</literal>
       <returnvalue>60</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>asin</primary>
       </indexterm>
       <function>asin</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Sinus inverse, résultat en radians
      </para>
      <para>
       <literal>asin(1)</literal>
       <returnvalue>1.5707963267948966</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>asind</primary>
       </indexterm>
       <function>asind</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Sinus inverse, résultat en degrés
      </para>
      <para>
       <literal>asind(0.5)</literal>
       <returnvalue>30</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>atan</primary>
       </indexterm>
       <function>atan</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Tangente inverse, résultat en radians
      </para>
      <para>
       <literal>atan(1)</literal>
       <returnvalue>0.7853981633974483</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>atand</primary>
       </indexterm>
       <function>atand</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Tangente inverse, résultat en degrés
      </para>
      <para>
       <literal>atand(1)</literal>
       <returnvalue>45</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>atan2</primary>
       </indexterm>
       <function>atan2</function> ( <parameter>y</parameter> <type>double precision</type>,
       <parameter>x</parameter> <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Tangente inverse de
       <parameter>y</parameter>/<parameter>x</parameter>,
       résultat en radians
      </para>
      <para>
       <literal>atan2(1,0)</literal>
       <returnvalue>1.5707963267948966</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>atan2d</primary>
       </indexterm>
       <function>atan2d</function> ( <parameter>y</parameter> <type>double precision</type>,
       <parameter>x</parameter> <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Tangente inverse de
       <parameter>y</parameter>/<parameter>x</parameter>,
       résultat en degrés
      </para>
      <para>
       <literal>atan2d(1,0)</literal>
       <returnvalue>90</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>cos</primary>
       </indexterm>
       <function>cos</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Cosinus, argument en radians
      </para>
      <para>
       <literal>cos(0)</literal>
       <returnvalue>1</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>cosd</primary>
       </indexterm>
       <function>cosd</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Cosinus, argument en degrés
      </para>
      <para>
       <literal>cosd(60)</literal>
       <returnvalue>0.5</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>cot</primary>
       </indexterm>
       <function>cot</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Cotangente, argument en radians
      </para>
      <para>
       <literal>cot(0.5)</literal>
       <returnvalue>1.830487721712452</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>cotd</primary>
       </indexterm>
       <function>cotd</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Cotangente, argument en degrés
      </para>
      <para>
       <literal>cotd(45)</literal>
       <returnvalue>1</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>sin</primary>
       </indexterm>
       <function>sin</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Sinus, argument en radians
      </para>
      <para>
       <literal>sin(1)</literal>
       <returnvalue>0.8414709848078965</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>sind</primary>
       </indexterm>
       <function>sind</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Sinus, argument en degrés
      </para>
      <para>
       <literal>sind(30)</literal>
       <returnvalue>0.5</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>tan</primary>
       </indexterm>
       <function>tan</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Tangente, argument en radians
      </para>
      <para>
       <literal>tan(1)</literal>
       <returnvalue>1.5574077246549023</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>tand</primary>
       </indexterm>
       <function>tand</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Tangente, argument en degrés
      </para>
      <para>
       <literal>tand(45)</literal>
       <returnvalue>1</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <note>
  <para>
   Une autre façon de travailler avec des angles mesurés en degrés est
   d'utiliser les fonctions de transformation d'unité
   <literal><function>radians()</function></literal> et
   <literal><function>degrees()</function></literal> montrées plus tôt.
   Néanmoins, utiliser les fonctions trigonométriques basées sur les degrés
   est préféré, car cette façon évite les erreurs d'arrondi pour les cas
   spéciaux comme <literal>sind(30)</literal>.
  </para>
 </note>

 <para>
  <xref linkend="functions-math-hyp-table"/> affiche les fonctions
  hyperboliques.
 </para>

 <table id="functions-math-hyp-table">
  <title>Fonctions hyperboliques</title>

  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>sinh</primary>
       </indexterm>
       <function>sinh</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Sinus hyperbolique
      </para>
      <para>
       <literal>sinh(1)</literal>
       <returnvalue>1.1752011936438014</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>cosh</primary>
       </indexterm>
       <function>cosh</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Cosinus hyperbolique
      </para>
      <para>
       <literal>cosh(0)</literal>
       <returnvalue>1</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>tanh</primary>
       </indexterm>
       <function>tanh</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Tangente hyperbolique
      </para>
      <para>
       <literal>tanh(1)</literal>
       <returnvalue>0.7615941559557649</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>asinh</primary>
       </indexterm>
       <function>asinh</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Sinus inverse hyperbolique
      </para>
      <para>
       <literal>asinh(1)</literal>
       <returnvalue>0.881373587019543</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>acosh</primary>
       </indexterm>
       <function>acosh</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Cosinus inverse hyperbolique
      </para>
      <para>
       <literal>acosh(1)</literal>
       <returnvalue>0</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>atanh</primary>
       </indexterm>
       <function>atanh</function> ( <type>double precision</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Tangente inverse hyperbolique
      </para>
      <para>
       <literal>atanh(0.5)</literal>
       <returnvalue>0.5493061443340548</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

</sect1>


<sect1 id="functions-string">
 <title>Fonctions et opérateurs sur des chaînes de caractères</title>

 <para>
  Cette section décrit les fonctions et opérateurs pour l'examen et la
  manipulation de valeurs de type chaîne de caractères. Dans ce contexte,
  les chaînes incluent les valeurs de type <type>character</type>,
  <type>character varying</type> et <type>text</type>. Sauf note explicite,
  ces fonctions et opérateurs sont déclarés comme acceptant et renvoyant le
  type <type>text</type>. Ils accepteront directement des arguments de type
  <type>character varying</type>. Les valeurs de type <type>character</type>
  seront converties en <type>text</type> avant que la fonction ou
  l'opérateur ne soit exécuté, résultant en une suppression des espaces en
  fin de la valeur de type <type>character</type>.
 </para>

 <para>
  Le standard <acronym>SQL</acronym> définit certaines fonctions de chaîne
  de caractères comme utilisant des mots clés plutôt que des virgules pour
  séparer les arguments. Les détails sont disponibles dans <xref
  linkend="functions-string-sql"/>. <productname>PostgreSQL</productname>
  fournit aussi des versions de ces fonctions qui utilisent la syntaxe
  d'appel de fonctions standards (voir <xref
  linkend="functions-string-other"/>).
 </para>

 <note>
  <para>
   Avant <productname>PostgreSQL</productname> 8.3, ces fonctions
   acceptaient aussi silencieusement des valeurs de plusieurs types de
   données qui ne sont pas des chaînes de caractères, grâce à la présente de
   conversions implicites de ces types de données vers le type
   <type>text</type>. Ces conversions ont été supprimées parce qu'elles
   causaient fréquemment des comportements étonnants. Néanmoins, l'opérateur
   de concaténation de chaîne (<literal>||</literal>) accepte toujours des
   arguments qui ne sont pas des chaînes de caractères, comme montré dans
   <xref linkend="functions-string-sql"/>. Pour les autres cas, insérez une
   conversion explicite vers le type <type>text</type> si vous avez besoin
   de dupliquer le comportement précédent.
  </para>
 </note>

 <table id="functions-string-sql">
  <title>Fonctions et opérateurs <acronym>SQL</acronym> pour les chaînes de
   caractères</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction/Opérateur
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>chaîne de caractères</primary>
        <secondary>concaténation</secondary>
       </indexterm>
       <type>text</type> <literal>||</literal> <type>text</type>
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Concatène deux chaînes de caractères.
      </para>
      <para>
       <literal>'Post' || 'greSQL'</literal>
       <returnvalue>PostgreSQL</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>text</type> <literal>||</literal> <type>anynonarray</type>
       <returnvalue>text</returnvalue>
      </para>
      <para role="func_signature">
       <type>anynonarray</type> <literal>||</literal> <type>text</type>
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Convertit l'argument qui n'est pas une chaîne de caractère en texte,
       puis concatène les deux chapines. (L'argument qui n'est pas une chaîne
       ne peut pas être un tableau car cela causerait une ambiguité avec les
       opérateurs <literal>||</literal> pour les tableaux. Si vous voulez
       concaténer l'équivalent texte d'un tableau, vous devez préalablement
       le convertir explicitement vers le type <type>text</type>.)
      </para>
      <para>
       <literal>'Valeur: ' || 42</literal>
       <returnvalue>Valeur: 42</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>normalized</primary>
       </indexterm>
       <indexterm>
        <primary>normalisation Unicode</primary>
       </indexterm>
       <type>text</type> <literal>IS</literal> <optional><literal>NOT</literal></optional> <optional><parameter>form</parameter></optional> <literal>NORMALIZED</literal>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Vérifie si la chaîne est dans la forme de normalisation Unicode
       précisée. Le mot clé optionnel <parameter>form</parameter> indique la
       forme&nbsp;: <literal>NFC</literal> (valeur par défaut),
       <literal>NFD</literal>, <literal>NFKC</literal> ou
       <literal>NFKD</literal>. Cette expression peut seulement être utilisée
       quand l'encodage serveur est <literal>UTF8</literal>. Il faut noter
       que la vérification de la normalisation en utilisant cette expression
       est généralement plus rapide que de normaliser des chaînes déjà
       normalisées.
      </para>
      <para>
       <literal>U&amp;'\0061\0308bc' IS NFD NORMALIZED</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>bit_length</primary>
       </indexterm>
       <function>bit_length</function> ( <type>text</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre de bits dans la chaîne de caractères (8
       fois la valeur de <function>octet_length</function>).
      </para>
      <para>
       <literal>bit_length('jose')</literal>
       <returnvalue>32</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>char_length</primary>
       </indexterm>
       <indexterm>
        <primary>chaîne de caractères</primary>
        <secondary>longueur</secondary>
       </indexterm>
       <indexterm>
        <primary>longueur</primary>
        <secondary sortas="character string">d'une chaîne de caractères</secondary>
        <see>chaîne de caractères, longueur</see>
       </indexterm>
       <function>char_length</function> ( <type>text</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>character_length</primary>
       </indexterm>
       <function>character_length</function> ( <type>text</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre de caractères dans la chaîne.
      </para>
      <para>
       <literal>char_length('jos&eacute;')</literal>
       <returnvalue>4</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>lower</primary>
       </indexterm>
       <function>lower</function> ( <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Convertit la chaîne en minuscule, suivant les règles de la locale de
       la base de données.
      </para>
      <para>
       <literal>lower('TOM')</literal>
       <returnvalue>tom</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>normalize</primary>
       </indexterm>
       <indexterm>
        <primary>normalisation Unicode</primary>
       </indexterm>
       <function>normalize</function> ( <type>text</type>
       <optional>, <parameter>form</parameter> </optional> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Convertit la chaîne vers la forme de normalisation Unicode précisée.
       Le mot clé optionnel <parameter>form</parameter> indique la
       forme&nbsp;: <literal>NFC</literal> (valeur par défaut),
       <literal>NFD</literal>, <literal>NFKC</literal> ou
       <literal>NFKD</literal>. Cette fonction peut seulement être utilisée
       quand l'encodage serveur est <literal>UTF8</literal>.
      </para>
      <para>
       <literal>normalize(U&amp;'\0061\0308bc', NFC)</literal>
       <returnvalue>U&amp;'\00E4bc'</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>octet_length</primary>
       </indexterm>
       <function>octet_length</function> ( <type>text</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre d'octets dans la chaîne.
      </para>
      <para>
       <literal>octet_length('jos&eacute;')</literal>
       <returnvalue>5</returnvalue> (if server encoding is UTF8)
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>octet_length</primary>
       </indexterm>
       <function>octet_length</function> ( <type>character</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre d'octets dans la chaîne. Comme cette version de la
       fonction accepte directement le type <type>character</type>, il ne
       supprimera pas les espaces en fin de chaîne.
      </para>
      <para>
       <literal>octet_length('abc '::character(4))</literal>
       <returnvalue>4</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>overlay</primary>
       </indexterm>
       <function>overlay</function> ( <parameter>string</parameter> <type>text</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>text</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Remplace la sous-chaîne de <parameter>string</parameter> qui commence
       au <parameter>start</parameter>-ième caractère et continue pendant
       <parameter>count</parameter> caractères avec
       <parameter>newsubstring</parameter>. Si <parameter>count</parameter>
       est omis, sa valeur par défaut est la longueur de la chaîne
       <parameter>newsubstring</parameter>.
      </para>
      <para>
       <literal>overlay('Txxxxas' placing 'hom' from 2 for 4)</literal>
       <returnvalue>Thomas</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>position</primary>
       </indexterm>
       <function>position</function> ( <parameter>substring</parameter> <type>text</type> <literal>IN</literal> <parameter>string</parameter> <type>text</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie l'index de début de la chaîne <parameter>substring</parameter>
       dans <parameter>string</parameter>, ou zéro si elle n'est pas
       présente.
      </para>
      <para>
       <literal>position('om' in 'Thomas')</literal>
       <returnvalue>3</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>substring</primary>
       </indexterm>
       <function>substring</function> ( <parameter>string</parameter> <type>text</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Extrait la sous-chaîne de <parameter>string</parameter> commençant au
       <parameter>start</parameter>-ième caractère s'il est spécifié, et
       arrêtant après <parameter>count</parameter> caractère s'il est
       spécifié. Il est nécessaire de fournir au moins un des deux arguments,
       <parameter>start</parameter> et <parameter>count</parameter>.
      </para>
      <para>
       <literal>substring('Thomas' from 2 for 3)</literal>
       <returnvalue>hom</returnvalue>
      </para>
      <para>
       <literal>substring('Thomas' from 3)</literal>
       <returnvalue>omas</returnvalue>
      </para>
      <para>
       <literal>substring('Thomas' for 2)</literal>
       <returnvalue>Th</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>FROM</literal> <parameter>pattern</parameter> <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Extrait la sous-chaîne correspondant à une expression rationnelle
       POSIX&nbsp;; voir <xref linkend="functions-posix-regexp"/>.
      </para>
      <para>
       <literal>substring('Thomas' from '...$')</literal>
       <returnvalue>mas</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>FROM</literal> <parameter>pattern</parameter> <type>text</type> <literal>FOR</literal> <parameter>escape</parameter> <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Extrait la sous-chaîne correspondant à l'expression rationnelle
       <acronym>SQL</acronym>&nbsp;; voir <xref
       linkend="functions-similarto-regexp"/>.
      </para>
      <para>
       <literal>substring('Thomas' from '%#"o_a#"_' for '#')</literal>
       <returnvalue>oma</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>trim</primary>
       </indexterm>
       <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional>
       <optional> <parameter>characters</parameter> <type>text</type> </optional> <literal>FROM</literal>
       <parameter>string</parameter> <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Supprime la chaîne la plus longue contenant seulement des caractères
       parmi <parameter>characters</parameter> (un espace par défaut) à
       partir du début, de la fin ou des deux bouts (<literal>BOTH</literal>
       est la valeur par défaut) de <parameter>string</parameter>.
      </para>
      <para>
       <literal>trim(both 'xyz' from 'yxTomxx')</literal>
       <returnvalue>Tom</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional> <optional> <literal>FROM</literal> </optional>
       <parameter>string</parameter> <type>text</type> <optional>,
        <parameter>characters</parameter> <type>text</type> </optional> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Ceci est la syntaxe non standard pour <function>trim()</function>.
      </para>
      <para>
       <literal>trim(both from 'yxTomxx', 'xyz')</literal>
       <returnvalue>Tom</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>upper</primary>
       </indexterm>
       <function>upper</function> ( <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Convertit la chaîne en majuscule, suivant les règles de la locale de
       la base de données.
      </para>
      <para>
       <literal>upper('tom')</literal>
       <returnvalue>TOM</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
  Des fonctions supplémentaires de manipulation des chaînes de caractères
  sont disponibles et listées dans <xref linkend="functions-string-other"/>.
  Certaines sont utilisées en interne pour implémenter les fonctions de
  chaîne du standard <acronym>SQL</acronym> listées dans <xref
  linkend="functions-string-sql"/>.
 </para>

 <table id="functions-string-other">
  <title>Autres fonctions pour les chaînes de caractères</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>ascii</primary>
       </indexterm>
       <function>ascii</function> ( <type>text</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le code numérique du premier caractère de l'argument. Dans
       l'encodage <acronym>UTF8</acronym>, renvoie le point code Unicode du
       caractère. Dans les autres encodages multioctets, l'argument doit être
       un caractère <acronym>ASCII</acronym>.
      </para>
      <para>
       <literal>ascii('x')</literal>
       <returnvalue>120</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>btrim</primary>
       </indexterm>
       <function>btrim</function> ( <parameter>string</parameter> <type>text</type>
       <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Supprime la plus longue chaîne contenant seulement les caractères
       compris dans <parameter>characters</parameter> (un espace par défaut)
       au début et à la fin de <parameter>string</parameter>.
      </para>
      <para>
       <literal>btrim('xyxtrimyyx', 'xyz')</literal>
       <returnvalue>trim</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>chr</primary>
       </indexterm>
       <function>chr</function> ( <type>integer</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Renvoie le caractère avec le code donné. Dans l'encodage
       <acronym>UTF8</acronym>, l'argument est traité qu'un point code
       Unicode. Dans les autres encodages multi-octets, l'argument doit
       désigner un caractère <acronym>ASCII</acronym>.
       <literal>chr(0)</literal> est interdit parce que les types de données
       texte ne peuvent pas enregistrer ce caractère.
      </para>
      <para>
       <literal>chr(65)</literal>
       <returnvalue>A</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>concat</primary>
       </indexterm>
       <function>concat</function> ( <parameter>val1</parameter> <type>"any"</type>
       [, <parameter>val2</parameter> <type>"any"</type> [, ...] ] )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Concatène les représentations textuelles de tous les arguments. Les
       arguments NULL sont ignorés.
      </para>
      <para>
       <literal>concat('abcde', 2, NULL, 22)</literal>
       <returnvalue>abcde222</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>concat_ws</primary>
       </indexterm>
       <function>concat_ws</function> ( <parameter>sep</parameter> <type>text</type>,
       <parameter>val1</parameter> <type>"any"</type>
       [, <parameter>val2</parameter> <type>"any"</type> [, ...] ] )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Concatène tous les arguments sauf le premier, avec des séparateurs. Le
       premier argument est utilisé comme séparateur, et ne doit pas valoir
       NULL. Les autres arguments NULL sont ignorés.
      </para>
      <para>
       <literal>concat_ws(',', 'abcde', 2, NULL, 22)</literal>
       <returnvalue>abcde,2,22</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>format</primary>
       </indexterm>
       <function>format</function> ( <parameter>formatstr</parameter> <type>text</type>
       [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ] )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Formate les arguments suivant une chaîne de formatage&nbsp;; voir
       <xref linkend="functions-string-format"/>. Cette fonction est
       similaire à la fonction C <function>sprintf</function>.
      </para>
      <para>
       <literal>format('Hello %s, %1$s', 'World')</literal>
       <returnvalue>Hello World, World</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>initcap</primary>
       </indexterm>
       <function>initcap</function> ( <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Convertit la première lettre de chaque mot en majuscule et le reste en
       minuscule. Les mots sont des séquences de caractères alpha-numériques
       séparées par des caractères non alpha-numériques.
      </para>
      <para>
       <literal>initcap('hi THOMAS')</literal>
       <returnvalue>Hi Thomas</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>left</primary>
       </indexterm>
       <function>left</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>n</parameter> <type>integer</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Renvoie les <parameter>n</parameter> premiers caractères de la chaîne.
       Si <parameter>n</parameter> est négatif, renvoie tous les caractères
       sauf les |<parameter>n</parameter>| derniers.
      </para>
      <para>
       <literal>left('abcde', 2)</literal>
       <returnvalue>ab</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>length</primary>
       </indexterm>
       <function>length</function> ( <type>text</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre de caractères dans la chaîne.
      </para>
      <para>
       <literal>length('jose')</literal>
       <returnvalue>4</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>lpad</primary>
       </indexterm>
       <function>lpad</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>length</parameter> <type>integer</type>
       <optional>, <parameter>fill</parameter> <type>text</type> </optional> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Étend la chaîne <parameter>string</parameter> à la longueur
       <parameter>length</parameter> en ajoutant les caractères de la chaîne
       <parameter>fill</parameter> (un espace par défaut). Si la chaîne
       <parameter>string</parameter> est déjà plus longue que
       <parameter>length</parameter>, alors elle est tronquée (à partir de la
       droite).
      </para>
      <para>
       <literal>lpad('hi', 5, 'xy')</literal>
       <returnvalue>xyxhi</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>ltrim</primary>
       </indexterm>
       <function>ltrim</function> ( <parameter>string</parameter> <type>text</type>
       <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Supprime la chaîne la plus longue contenant seulement les caractères
       dans <parameter>characters</parameter> (un espace par défaut) à partir
       du début de <parameter>string</parameter>.
      </para>
      <para>
       <literal>ltrim('zzzytest', 'xyz')</literal>
       <returnvalue>test</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>md5</primary>
       </indexterm>
       <function>md5</function> ( <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Calcule le <link linkend="functions-hash-note">hachage</link> MD5 de
       l'argument, le résultat étant écrit en hexadécimal.
      </para>
      <para>
       <literal>md5('abc')</literal>
       <returnvalue>900150983cd24fb0&zwsp;d6963f7d28e17f72</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>parse_ident</primary>
       </indexterm>
       <function>parse_ident</function> ( <parameter>qualified_identifier</parameter> <type>text</type>
       [, <parameter>strict_mode</parameter> <type>boolean</type> <literal>DEFAULT</literal> <literal>true</literal> ] )
       <returnvalue>text[]</returnvalue>
      </para>
      <para>
       Divise <parameter>qualified_identifier</parameter> en un tableau
       d'identifiants, supprimant tout guillemet des identifiants
       individuels. Par défaut, les caractères supplémentaires après le
       dernier identifiant sont considérés comme une erreur&nbsp;; si le
       second paramètre est <literal>false</literal>, alors ces caractères
       supplémentaires sont ignorés. (Ce comportement est utile pour analuser
       les noms d'objets comme des fonctions.) Il faut noter que cette
       fonction ne tronque pas les identifiants dont les noms sont trop
       longs. Si vous voulez cette troncature, vous pouvez convertir le
       résultat avec le type <type>name[]</type>.
      </para>
      <para>
       <literal>parse_ident('"SomeSchema".someTable')</literal>
       <returnvalue>{SomeSchema,sometable}</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>pg_client_encoding</primary>
       </indexterm>
       <function>pg_client_encoding</function> ( )
       <returnvalue>name</returnvalue>
      </para>
      <para>
       Renvoie le nom de l'encodage client actuel.
      </para>
      <para>
       <literal>pg_client_encoding()</literal>
       <returnvalue>UTF8</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>quote_ident</primary>
       </indexterm>
       <function>quote_ident</function> ( <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Renvoie la chaîne donnée correctement placée entre guillemets comme un
       identifiant dans une requête <acronym>SQL</acronym>. Les guillemets ne
       sont ajoutés que s'ils sont nécessaires (c'est-à-dire si la chaîne
       contient des caractères qui ne font pas partie de ceux autorisés
       habituellement pour les identifiants ou des caractères majuscules).
       Les guillemets dans le nom sont aussi doublés. Voir aussi <xref
       linkend="plpgsql-quote-literal-example"/>.
      </para>
      <para>
       <literal>quote_ident('Foo bar')</literal>
       <returnvalue>"Foo bar"</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>quote_literal</primary>
       </indexterm>
       <function>quote_literal</function> ( <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Renvoie la chaîne donnée correctement placée entre guillemets pour
       être utilisé comme une valeur littérale de type chaîne dans une requête
       <acronym>SQL</acronym>. Les guillemets simples et antislashs présents
       dans la chaîne sont correctement doublés. Il faut noter que
       <function>quote_literal</function> renvoie NULL en cas d'argument
       NULL. Si l'argument pourrait être NULL,
       <function>quote_nullable</function> est généralement plus indiqué.
       Voir aussi <xref linkend="plpgsql-quote-literal-example"/>.
      </para>
      <para>
       <literal>quote_literal(E'O\'Reilly')</literal>
       <returnvalue>'O''Reilly'</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>quote_literal</function> ( <type>anyelement</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Convertit la valeur donnée dans le type text et ajoute des guillemets
       comme pour une valeur. Les guillemets simples et antislashs présents
       dans la chaîne sont correctement doublés.
      </para>
      <para>
       <literal>quote_literal(42.5)</literal>
       <returnvalue>'42.5'</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>quote_nullable</primary>
       </indexterm>
       <function>quote_nullable</function> ( <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Renvoie la chaîne donnée convenablement placée entre guillemets pour
       être utilisée comme un littéral de type chaîne dans une requête
       <acronym>SQL</acronym>&nbsp;; ou, si l'argument vaut NULL, renvoie
       <literal>NULL</literal>. Les guillemets simples et antislashs présents
       dans la chaîne sont correctement doublés. Voir aussi <xref
       linkend="plpgsql-quote-literal-example"/>.
      </para>
      <para>
       <literal>quote_nullable(NULL)</literal>
       <returnvalue>NULL</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>quote_nullable</function> ( <type>anyelement</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Convertit la valeur donnée dans le type text puis la place entre
       guillemets comme une valeur littérale&nbsp;; ou, si l'argument vaut
       NULL, renvoie <literal>NULL</literal>. Les guillemets simples et
       antislashs présents dans la chaîne sont correctement doublés.
      </para>
      <para>
       <literal>quote_nullable(42.5)</literal>
       <returnvalue>'42.5'</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>regexp_match</primary>
       </indexterm>
       <function>regexp_match</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
       <returnvalue>text[]</returnvalue>
      </para>
      <para>
       Renvoie le(s) sous-chaîne(s) capturée(s) résultant de la première
       correspondance avec une expression rationnelle POSIX vers
       <parameter>string</parameter>&nbsp;; voir <xref
       linkend="functions-posix-regexp"/>.
      </para>
      <para>
       <literal>regexp_match('foobarbequebaz', '(bar)(beque)')</literal>
       <returnvalue>{bar,beque}</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>regexp_matches</primary>
       </indexterm>
       <function>regexp_matches</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
       <returnvalue>setof text[]</returnvalue>
      </para>
      <para>
       Renvoie le(s) sous-chaîne(s) capturée(s) résultant de la
       correspondance d'une expression rationnelle POSIX vers
       <parameter>string</parameter>&nbsp;; voir <xref
       linkend="functions-posix-regexp"/>.
      </para>
      <para>
       <literal>regexp_matches('foobarbequebaz', 'ba.', 'g')</literal>
       <returnvalue></returnvalue>
       <programlisting>
 {bar}
 {baz}
       </programlisting>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>regexp_replace</primary>
       </indexterm>
       <function>regexp_replace</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>, <parameter>replacement</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Remplace le(s) sous-chaîne(s) correspondant à une expression
       rationnelle POSIX&nbsp;; voir <xref
       linkend="functions-posix-regexp"/>.
      </para>
      <para>
       <literal>regexp_replace('Thomas', '.[mN]a.', 'M')</literal>
       <returnvalue>ThM</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>regexp_split_to_array</primary>
       </indexterm>
       <function>regexp_split_to_array</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
       <returnvalue>text[]</returnvalue>
      </para>
      <para>
       Divise <parameter>string</parameter> en utilisant une expression
       rationnelle POSIX comme délimiteur&nbsp;; voir <xref
       linkend="functions-posix-regexp"/>.
      </para>
      <para>
       <literal>regexp_split_to_array('hello world', '\s+')</literal>
       <returnvalue>{hello,world}</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>regexp_split_to_table</primary>
       </indexterm>
       <function>regexp_split_to_table</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
       <returnvalue>setof text</returnvalue>
      </para>
      <para>
       Divise <parameter>string</parameter> en utilisant une expression
       rationnelle POSIX comme délimiteur&nbsp;; voir <xref
       linkend="functions-posix-regexp"/>.
      </para>
      <para>
       <literal>regexp_split_to_table('hello world', '\s+')</literal>
       <returnvalue></returnvalue>
       <programlisting>
 hello
 world
       </programlisting>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>repeat</primary>
       </indexterm>
       <function>repeat</function> ( <parameter>string</parameter> <type>text</type>, <parameter>number</parameter> <type>integer</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Répète <parameter>string</parameter> le nombre de fois spécifié par
       <parameter>number</parameter>.
      </para>
      <para>
       <literal>repeat('Pg', 4)</literal>
       <returnvalue>PgPgPgPg</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>replace</primary>
       </indexterm>
       <function>replace</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>from</parameter> <type>text</type>,
       <parameter>to</parameter> <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Remplace toutes les occurrences dans <parameter>string</parameter> de
       la sous-chaîne <parameter>from</parameter> avec la sous-chaîne
       <parameter>to</parameter>.
      </para>
      <para>
       <literal>replace('abcdefabcdef', 'cd', 'XX')</literal>
       <returnvalue>abXXefabXXef</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>reverse</primary>
       </indexterm>
       <function>reverse</function> ( <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Inverse l'ordre des caractères dans la chaîne.
      </para>
      <para>
       <literal>reverse('abcde')</literal>
       <returnvalue>edcba</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>right</primary>
       </indexterm>
       <function>right</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>n</parameter> <type>integer</type> )
       <type></type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Renvoie les <parameter>n</parameter> derniers caractères dans la
       chaîne, ou, si <parameter>n</parameter> est négatif, renvoie tous les
       caractères sauf les |<parameter>n</parameter>| premiers caractères.
      </para>
      <para>
       <literal>right('abcde', 2)</literal>
       <returnvalue>de</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>rpad</primary>
       </indexterm>
       <function>rpad</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>length</parameter> <type>integer</type>
       <optional>, <parameter>fill</parameter> <type>text</type> </optional> )
       <type></type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Étend <parameter>string</parameter> à la longueur
       <parameter>length</parameter> en ajoutant les caractères
       <parameter>fill</parameter> (un espace par défaut). Si
       <parameter>string</parameter> est déjà plus long que
       <parameter>length</parameter>, alors elle est tronquée.
      </para>
      <para>
       <literal>rpad('hi', 5, 'xy')</literal>
       <returnvalue>hixyx</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>rtrim</primary>
       </indexterm>
       <function>rtrim</function> ( <parameter>string</parameter> <type>text</type>
       <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Supprime la plus longue chaîne contenant seulement les caractères
       compris dans <parameter>characters</parameter> (un espace par défaut)
       à partir de la fin de <parameter>string</parameter>.
      </para>
      <para>
       <literal>rtrim('testxxzx', 'xyz')</literal>
       <returnvalue>test</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>split_part</primary>
       </indexterm>
       <function>split_part</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>delimiter</parameter> <type>text</type>,
       <parameter>n</parameter> <type>integer</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Divise <parameter>string</parameter> à chaque occurence de
       <parameter>delimiter</parameter> et renvoie le
       <parameter>n</parameter>-ième champ (en comptant à partir de 1).
      </para>
      <para>
       <literal>split_part('abc~@~def~@~ghi', '~@~', 2)</literal>
       <returnvalue>def</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>strpos</primary>
       </indexterm>
       <function>strpos</function> ( <parameter>string</parameter> <type>text</type>, <parameter>substring</parameter> <type>text</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie l'index de début de la chaîne <parameter>substring</parameter>
       spécifié à l'intérieur de <parameter>string</parameter>, ou zéro si
       elle n'est pas présente. (Identique à
       <literal>position(<parameter>substring</parameter> in
        <parameter>string</parameter>)</literal>, mais notez l'ordre inversé
       des arguments.)
      </para>
      <para>
       <literal>strpos('high', 'ig')</literal>
       <returnvalue>2</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>substr</primary>
       </indexterm>
       <function>substr</function> ( <parameter>string</parameter> <type>text</type>, <parameter>start</parameter> <type>integer</type> <optional>, <parameter>count</parameter> <type>integer</type> </optional> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Extrait la sous-chaîne de <parameter>string</parameter> en commençant
       au <parameter>start</parameter>-ième caractère, et étendant de
       <parameter>count</parameter> caractères si ce dernier est spécifié.
       (Identique à <literal>substring(<parameter>string</parameter> from
        <parameter>start</parameter> for
        <parameter>count</parameter>)</literal>.)
      </para>
      <para>
       <literal>substr('alphabet', 3)</literal>
       <returnvalue>phabet</returnvalue>
      </para>
      <para>
       <literal>substr('alphabet', 3, 2)</literal>
       <returnvalue>ph</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>starts_with</primary>
       </indexterm>
       <function>starts_with</function> ( <parameter>string</parameter> <type>text</type>, <parameter>prefix</parameter> <type>text</type> )
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Renvoie true si <parameter>string</parameter> commence avec
       <parameter>prefix</parameter>.
      </para>
      <para>
       <literal>starts_with('alphabet', 'alph')</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>to_ascii</primary>
       </indexterm>
       <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para role="func_signature">
       <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>encoding</parameter> <type>name</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para role="func_signature">
       <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>encoding</parameter> <type>integer</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Convertit <parameter>string</parameter> en <acronym>ASCII</acronym> à
       partir d'un autre encodage, qui peut être identifié par nom ou numéro.
       Si <parameter>encoding</parameter> est omis, l'encodage de la base est
       utilisé (ce qui, en réalité, est le seul cas utile). La conversion
       consiste principalement en la suppression des accents. La conversion
       est seulement supportée à partir des encodages
       <literal>LATIN1</literal>, <literal>LATIN2</literal>,
       <literal>LATIN9</literal> et <literal>WIN1250</literal>. (Voir le
       module <xref linkend="unaccent"/> pour une autre solution, plus
       flexible.)
      </para>
      <para>
       <literal>to_ascii('Kar&eacute;l')</literal>
       <returnvalue>Karel</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>to_hex</primary>
       </indexterm>
       <function>to_hex</function> ( <type>integer</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para role="func_signature">
       <function>to_hex</function> ( <type>bigint</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Convertit le nombre en sa représentation hexadécimale équivalente.
      </para>
      <para>
       <literal>to_hex(2147483647)</literal>
       <returnvalue>7fffffff</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>translate</primary>
       </indexterm>
       <function>translate</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>from</parameter> <type>text</type>,
       <parameter>to</parameter> <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Remplace chaque caractère de <parameter>string</parameter> qui
       correspond à un caractère dans l'ensemble <parameter>from</parameter>
       avec le caractère correspondant dans l'ensemble
       <parameter>to</parameter>. Si <parameter>from</parameter> est plus
       long que <parameter>to</parameter>, les occurrences des caractères
       supplémentaires dans <parameter>from</parameter> sont supprimées.
      </para>
      <para>
       <literal>translate('12345', '143', 'ax')</literal>
       <returnvalue>a2x5</returnvalue>
      </para></entry>
    </row>

   </tbody>
  </tgroup>
 </table>

 <para>
  Les fonctions <function>concat</function>, <function>concat_ws</function>
  et <function>format</function> ont un nombre d'arguments variables, donc
  il est possible de passer les valeurs à concaténer ou à formater sous la
  forme d'un tableau marqué avec le mot-clé <literal>VARIADIC</literal>
  (voir <xref linkend="xfunc-sql-variadic-functions"/>). Les éléments du
  tableau sont traités comme s'ils étaient des arguments séparés dans la
  fonction. Si l'argument tableau est NULL, <function>concat</function> et
  <function>concat_ws</function> renvoient NULL, mais
  <function>format</function> traite un NULL comme un tableau à zéro
  élément.
 </para>

 <para>
  Voir aussi la fonction d'agrégat <function>string_agg</function> in <xref
  linkend="functions-aggregate"/>, et les fonctions de conversions entre des
  chaînes de caractères et le type <type>bytea</type> dans <xref
  linkend="functions-binarystring-conversions"/>.
 </para>

 <sect2 id="functions-string-format">
  <title><function>format</function></title>

  <indexterm>
   <primary>format</primary>
  </indexterm>

  <para>
   La fonction <function>format</function> produit une sortie formatée
   suivant une chaîne de formatage, dans un style similaire à la fonction C
   <function>sprintf</function>.
  </para>

  <para>
   <synopsis>
<function>format</function>(<parameter>formatstr</parameter> <type>text</type> [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ])
   </synopsis>
   <parameter>formatstr</parameter> est une chaîne de formatage qui indique
   comment le résultat doit être formaté. Le texte de la chaîne de formatage
   est copié directement dans le résultat, à l'exception des
   <firstterm>jokers de format</firstterm>. Les jokers de format agissent
   comme des espaces réservés dans le chaîne définissant comment les
   arguments de la fonction doivent être formatés et insérés dans le
   résultat. Chaque argument <parameter>formatarg</parameter> est converti
   en texte suivant les règles d'affichage habituel pour son type de
   données, puis formaté et inséré dans la chaîne résultante suivant le
   joker de format.
  </para>

  <para>
   Les jokers de format commencent par un caractère <literal>%</literal> et ont la forme
   suivante
   <synopsis>
%[<parameter>position</parameter>][<parameter>flags</parameter>][<parameter>width</parameter>]<parameter>type</parameter>
   </synopsis>
   où les champs composants sont&nbsp;:

   <variablelist>
    <varlistentry>
     <term><parameter>position</parameter> (optionnel)</term>
     <listitem>
      <para>
       Une chaîne de la forme <literal><parameter>n</parameter>$</literal>
       où <parameter>n</parameter> est l'index de l'argument à afficher.
       L'index 1 correspond au premier argument après
       <parameter>formatstr</parameter>. Si <parameter>position</parameter>
       est omis, la valeur par défaut est d'utiliser le prochain argument en
       séquence.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>flags</parameter> (optionnel)</term>
     <listitem>
      <para>
       Des options supplémentaires contrôlant comme la sortie du joker est
       formatée. Actuellement, le seul drapeau supporté est un signe moins
       (<literal>-</literal>) qui causera l'alignement à gauche de la valeur
       du champ. Ceci n'a d'effet que si <parameter>width</parameter> est
       précisé.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>width</parameter> (optionnel)</term>
     <listitem>
      <para>
       Indique le nombre <emphasis>minimum</emphasis> de caractères à
       utiliser pour afficher la sortie du joker. La sortie est remplie à
       gauche ou à droite (suivant la présence du drapeau
       <literal>-</literal>) avec autant d'espaces que nécessaire pour
       remplir la largeur indiquée. Une largeur trop petite ne cause pas la
       trincature de la sortie, mais est tout simplement ignorée. La largeur
       pourrait être indiquée en utilisant soit un entier positif, soit une
       astérisque (<literal>*</literal>) pour utiliser le prochain argument
       de la fonction soit une chaîne de la forme
       <literal>*<parameter>n</parameter>$</literal> pour utiliser le
       <parameter>n</parameter>-ième argument de la fonction comme
       information de largeur.
      </para>

      <para>
       Si la largeur vient d'un argument de la fonction, cet argument est
       consommé avant l'argument utilisé pour la valeur du joker de format.
       Si l'argument de largeur est négatif, le résultat est un alignement à
       gauche (comme si le drapeau <literal>-</literal> avait été précisé) à
       l'intérieur du champ de longueur
       <function>abs</function>(<parameter>width</parameter>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>type</parameter> (requis)</term>
     <listitem>
      <para>
       Le type de conversion de format à utiliser pour produire le résultat
       du joker de format. Les types suivants sont supportés&nbsp;:
       <itemizedlist>
        <listitem>
         <para>
          <literal>s</literal> formate ma valeur en argument comme une
          simple chaîne. Une valeur NULL est traitée comme une chaîne vide.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>I</literal> traite la valeur en argument comme un
          identifiant SQL, la plaçant entre guillemets doubles si
          nécessaire. Une valeur NULL est traitée comme une erreur
          (équivalent à <function>quote_ident</function>).
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>L</literal> traite la valeur en argument comme un
          littérale SQL. Une valeur NULL est affichée comme la chaîne
          <literal>NULL</literal>, sans guillemets (équivalent à
          <function>quote_nullable</function>).
         </para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   En plus des jokers de format décrits ci-dessus, la séquence spéciale
   <literal>%%</literal> est utilisable pour ajouter un caractère
   <literal>%</literal>.
  </para>

  <para>
   Voici quelques exemples des conversions basiques de format&nbsp;:

   <screen>
SELECT format('Hello %s', 'World');
<lineannotation>Résultat : </lineannotation><computeroutput>Hello World</computeroutput>

SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');
<lineannotation>Résultat : </lineannotation><computeroutput>Testing one, two, three, %</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\'Reilly');
<lineannotation>Résultat : </lineannotation><computeroutput>INSERT INTO "Foo bar" VALUES('O''Reilly')</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'locations', 'C:\Program Files');
<lineannotation>Résultat : </lineannotation><computeroutput>INSERT INTO locations VALUES('C:\Program Files')</computeroutput>
   </screen>
  </para>

  <para>
   Voici quelques exemples d'utilisation du champ
   <parameter>width</parameter> et du drapeau <literal>-</literal>&nbsp;:

   <screen>
SELECT format('|%10s|', 'foo');
<lineannotation>Résultat : </lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%-10s|', 'foo');
<lineannotation>Résultat : </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%*s|', 10, 'foo');
<lineannotation>Résultat : </lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%*s|', -10, 'foo');
<lineannotation>Résultat : </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', 10, 'foo');
<lineannotation>Résultat : </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', -10, 'foo');
<lineannotation>Résultat : </lineannotation><computeroutput>|foo       |</computeroutput>
   </screen>
  </para>

  <para>
   Ces exemples montrent l'utilisation du champ
   <parameter>position</parameter>&nbsp;:

   <screen>
SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');
<lineannotation>Résultat : </lineannotation><computeroutput>Testing three, two, one</computeroutput>

SELECT format('|%*2$s|', 'foo', 10, 'bar');
<lineannotation>Résultat : </lineannotation><computeroutput>|       bar|</computeroutput>

SELECT format('|%1$*2$s|', 'foo', 10, 'bar');
<lineannotation>Résultat : </lineannotation><computeroutput>|       foo|</computeroutput>
   </screen>
  </para>

  <para>
   Contrairement à la fonction C standard <function>sprintf</function>, la
   fonction <function>format</function> de
   <productname>PostgreSQL</productname> autorise les jokers de format sans
   et avec des champs <parameter>position</parameter> mixés dans la même
   champs de formatage. Un joker de format sans champ
   <parameter>position</parameter> utilise toujours le prochain argument
   après le dernier argument consommé. De plus, la fonction
   <function>format</function> ne requiert pas que tous les arguments de la
   fonction soient utilisés dans la chaîne de format. Par exemple&nbsp;:

   <screen>
SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');
<lineannotation>Résultat : </lineannotation><computeroutput>Testing three, two, three</computeroutput>
   </screen>
  </para>

  <para>
   Les jokers de format <literal>%I</literal> et <literal>%L</literal> sont
   particulièrement utiles pour construire en toute sécurité des requêtes
   SQL dynamiques. Voir <xref linkend="plpgsql-quote-literal-example"/>.
  </para>
 </sect2>

</sect1>


<sect1 id="functions-binarystring">
 <title>Fonctions et opérateurs pour les chaînes binaires</title>

 <indexterm zone="functions-binarystring">
  <primary>données binaires</primary>
  <secondary>fonctions</secondary>
 </indexterm>

 <para>
  Cette section décrit les fonctions et opérateurs pour examiner et
  manipuler des chaînes binaires, c'est-à-dire des valeurs de type
  <type>bytea</type>. Beaucoup sont équivalentes, dans le but et dans la
  syntaxe, aux fonctions de chaînes de caractères décrites dans la section
  précédente.
 </para>

 <para>
  Le standard <acronym>SQL</acronym> définit certaines fonctions de chaînes
  de caractères utilisant des mots-clés plutôt que des virgules, pour
  séparer des arguments. Les détails sont dans <xref
  linkend="functions-binarystring-sql"/>.
  <productname>PostgreSQL</productname> fournit aussi des versions de ces
  fonctions utilisant la syntaxe d'appel de fonctions standards (voir <xref
  linkend="functions-binarystring-other"/>).
 </para>

 <table id="functions-binarystring-sql">
  <title>Fonctions et opérateurs <acronym>SQL</acronym> pour des chaînes binaires</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction/Opérateur
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>binary string</primary>
        <secondary>concaténation</secondary>
       </indexterm>
       <type>bytea</type> <literal>||</literal> <type>bytea</type>
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Concatène deux chaînes binaires.
      </para>
      <para>
       <literal>'\x123456'::bytea || '\x789a00bcde'::bytea</literal>
       <returnvalue>\x123456789a00bcde</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>bit_length</primary>
       </indexterm>
       <function>bit_length</function> ( <type>bytea</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre de bits dans la chaîne binaire (8
       fois le résultat de <function>octet_length</function>).
      </para>
      <para>
       <literal>bit_length('\x123456'::bytea)</literal>
       <returnvalue>24</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>octet_length</primary>
       </indexterm>
       <function>octet_length</function> ( <type>bytea</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre d'octets dans la chaîne binaire.
      </para>
      <para>
       <literal>octet_length('\x123456'::bytea)</literal>
       <returnvalue>3</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>overlay</primary>
       </indexterm>
       <function>overlay</function> ( <parameter>bytes</parameter> <type>bytea</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>bytea</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Remplace la sous-chaîne de <parameter>bytes</parameter> commençant au
       <parameter>start</parameter>-ième octet et s'étendant sur
       <parameter>count</parameter> octets avec
       <parameter>newsubstring</parameter>. Si <parameter>count</parameter>
       est omis, sa valeur par défaut est la taille de
       <parameter>newsubstring</parameter>.
      </para>
      <para>
       <literal>overlay('\x1234567890'::bytea placing '\002\003'::bytea from 2 for 3)</literal>
       <returnvalue>\x12020390</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>position</primary>
       </indexterm>
       <function>position</function> ( <parameter>substring</parameter> <type>bytea</type> <literal>IN</literal> <parameter>bytes</parameter> <type>bytea</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie la position de début de <parameter>substring</parameter> dans
       <parameter>bytes</parameter>, ou zéro s'il n'est pas présent.
      </para>
      <para>
       <literal>position('\x5678'::bytea in '\x1234567890'::bytea)</literal>
       <returnvalue>3</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>substring</primary>
       </indexterm>
       <function>substring</function> ( <parameter>bytes</parameter> <type>bytea</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Extrait la sous-chaîne de <parameter>bytes</parameter> commençant au
       <parameter>start</parameter>-ième octet s'il est indiqué, et
       s'arrêtant après <parameter>count</parameter> octets s'il est indiqué.
       Il est nécessaire de fournir au moins soit
       <parameter>start</parameter> soit <parameter>count</parameter>.
      </para>
      <para>
       <literal>substring('\x1234567890'::bytea from 3 for 2)</literal>
       <returnvalue>\x5678</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>trim</primary>
       </indexterm>
       <function>trim</function> ( <optional> <literal>BOTH</literal> </optional>
       <parameter>bytesremoved</parameter> <type>bytea</type> <literal>FROM</literal>
       <parameter>bytes</parameter> <type>bytea</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Supprime la plus longue chaîne contenant seulement les octets
       apparaissant dans <parameter>bytesremoved</parameter> à partir du
       début et de la fin de <parameter>bytes</parameter>.
      </para>
      <para>
       <literal>trim('\x9012'::bytea from '\x1234567890'::bytea)</literal>
       <returnvalue>\x345678</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>trim</function> ( <optional> <literal>BOTH</literal> </optional> <optional> <literal>FROM</literal> </optional>
       <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>bytesremoved</parameter> <type>bytea</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Ceci est une syntaxe non standard pour <function>trim()</function>.
      </para>
      <para>
       <literal>trim(both from '\x1234567890'::bytea, '\x9012'::bytea)</literal>
       <returnvalue>\x345678</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
  Des fonctions supplémentaires de manipulation de chaîne binaire sont
  disponibles et listées dans <xref
  linkend="functions-binarystring-other"/>. Certaines d'entre elles sont
  utilisées en interne pour implémenter les fonctions de chaînes du standard
  <acronym>SQL</acronym> listées dans <xref
  linkend="functions-binarystring-sql"/>.
 </para>

 <table id="functions-binarystring-other">
  <title>Autres fonctions de chaînes binaires</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>btrim</primary>
       </indexterm>
       <function>btrim</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>bytesremoved</parameter> <type>bytea</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Supprime la chaîne la plus longue contenant seulement des octets
       apparaissant dans <parameter>bytesremoved</parameter> à partir du
       début et à la fin de <parameter>bytes</parameter>.
      </para>
      <para>
       <literal>btrim('\x1234567890'::bytea, '\x9012'::bytea)</literal>
       <returnvalue>\x345678</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>get_bit</primary>
       </indexterm>
       <function>get_bit</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>n</parameter> <type>bigint</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Extrait le <link linkend="functions-zerobased-note">n</link>-ième bit
       de la chaîne binaire.
      </para>
      <para>
       <literal>get_bit('\x1234567890'::bytea, 30)</literal>
       <returnvalue>1</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>get_byte</primary>
       </indexterm>
       <function>get_byte</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>n</parameter> <type>integer</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Extrait le <link linkend="functions-zerobased-note">n</link>-ième
       octet de la chaîne binaire.
      </para>
      <para>
       <literal>get_byte('\x1234567890'::bytea, 4)</literal>
       <returnvalue>144</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>length</primary>
       </indexterm>
       <indexterm>
        <primary>binary string</primary>
        <secondary>length</secondary>
       </indexterm>
       <indexterm>
        <primary>length</primary>
        <secondary sortas="binary string">of a binary string</secondary>
        <see>binary strings, length</see>
       </indexterm>
       <function>length</function> ( <type>bytea</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre d'octets de la chaîne binaire.
      </para>
      <para>
       <literal>length('\x1234567890'::bytea)</literal>
       <returnvalue>5</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>length</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>encoding</parameter> <type>name</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre de caractères de la chaîne binaire, en supposant
       qu'il s'agit de texte dans l'encodage indiqué par
       <parameter>encoding</parameter>.
      </para>
      <para>
       <literal>length('jose'::bytea, 'UTF8')</literal>
       <returnvalue>4</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>md5</primary>
       </indexterm>
       <function>md5</function> ( <type>bytea</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Calcule le <link linkend="functions-hash-note">hachage</link> MD5 dans
       la chaîne binaire, le résultat étant écrit en hexadécimal.
      </para>
      <para>
       <literal>md5('Th\000omas'::bytea)</literal>
       <returnvalue>8ab2d3c9689aaf18&zwsp;b4958c334c82d8b1</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>set_bit</primary>
       </indexterm>
       <function>set_bit</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>n</parameter> <type>bigint</type>,
       <parameter>newvalue</parameter> <type>integer</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Initialise le <link linkend="functions-zerobased-note">n</link>-ième
       bit dans la chaîne binaire à la valeur
       <parameter>newvalue</parameter>.
      </para>
      <para>
       <literal>set_bit('\x1234567890'::bytea, 30, 0)</literal>
       <returnvalue>\x1234563890</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>set_byte</primary>
       </indexterm>
       <function>set_byte</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>n</parameter> <type>integer</type>,
       <parameter>newvalue</parameter> <type>integer</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Initialise le <link linkend="functions-zerobased-note">n</link>-ième
       octet dans la chaîne binaire à la valeur
       <parameter>newvalue</parameter>.
      </para>
      <para>
       <literal>set_byte('\x1234567890'::bytea, 4, 64)</literal>
       <returnvalue>\x1234567840</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>sha224</primary>
       </indexterm>
       <function>sha224</function> ( <type>bytea</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Calcule le <link linkend="functions-hash-note">hachage</link> SHA-224
       de la chaîne binaire.
      </para>
      <para>
       <literal>sha224('abc'::bytea)</literal>
       <returnvalue>\x23097d223405d8228642a477bda2&zwsp;55b32aadbce4bda0b3f7e36c9da7</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>sha256</primary>
       </indexterm>
       <function>sha256</function> ( <type>bytea</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Calcule le <link linkend="functions-hash-note">hachage</link> SHA-256
       de la chaîne binaire.
      </para>
      <para>
       <literal>sha256('abc'::bytea)</literal>
       <returnvalue>\xba7816bf8f01cfea414140de5dae2223&zwsp;b00361a396177a9cb410ff61f20015ad</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>sha384</primary>
       </indexterm>
       <function>sha384</function> ( <type>bytea</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Calcule le <link linkend="functions-hash-note">hachage</link> SHA-384
       de la chaîne binaire.
      </para>
      <para>
       <literal>sha384('abc'::bytea)</literal>
       <returnvalue>\xcb00753f45a35e8bb5a03d699ac65007&zwsp;272c32ab0eded1631a8b605a43ff5bed&zwsp;8086072ba1e7cc2358baeca134c825a7</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>sha512</primary>
       </indexterm>
       <function>sha512</function> ( <type>bytea</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Calcule le <link linkend="functions-hash-note">hachage</link> SHA-512
       de la chaîne binaire.
      </para>
      <para>
       <literal>sha512('abc'::bytea)</literal>
       <returnvalue>\xddaf35a193617abacc417349ae204131&zwsp;12e6fa4e89a97ea20a9eeee64b55d39a&zwsp;2192992a274fc1a836ba3c23a3feebbd&zwsp;454d4423643ce80e2a9ac94fa54ca49f</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>substr</primary>
       </indexterm>
       <function>substr</function> ( <parameter>bytes</parameter> <type>bytea</type>, <parameter>start</parameter> <type>integer</type> <optional>, <parameter>count</parameter> <type>integer</type> </optional> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Extrait la sous-chaîne de <parameter>bytes</parameter> commençant au
       <parameter>start</parameter>-ième octet, et s'étendant sur
       <parameter>count</parameter> octets si ce dernier est indiqué.
       (Identique à <literal>substring(<parameter>bytes</parameter> from
        <parameter>start</parameter> for
        <parameter>count</parameter>)</literal>.)
      </para>
      <para>
       <literal>substr('\x1234567890'::bytea, 3, 2)</literal>
       <returnvalue>\x5678</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para id="functions-zerobased-note">
  Les fonctions <function>get_byte</function> et
  <function>set_byte</function> numérotent le premier octet d'une chaîne
  binaire comme l'octet 0. Les fonctions <function>get_bit</function> et
  <function>set_bit</function> numérotent les bits à partir de la droite dans
  chaque octet. Par exemple, le bit 0 est le bit le moins significatif du
  premier octet, et le bit 15 est le bit le plus significatif du deuxième
  octet.
 </para>

 <para id="functions-hash-note">
  Pour des raisons historiques, la fonction <function>md5</function> renvoie
  une valeur encodée en hexadécimal de type <type>text</type> alors que les
  fonctions SHA-2 renvoient le type <type>bytea</type>. Utilisez les
  fonctions <link
  linkend="function-encode"><function>encode</function></link> et <link
  linkend="function-decode"><function>decode</function></link> pour convertir
  entre les deux. Par exemple, écrivez <literal>encode(sha256('abc'),
   'hex')</literal> pour obtenir une représentation textuelle encodée en
  hexadécimal ou <literal>decode(md5('abc'), 'hex')</literal> pour obtenir
  une valeur de type <type>bytea</type>.
 </para>

 <para>
  <indexterm>
   <primary>chaîne de caractères</primary>
   <secondary>convertir en une chaîne binaire</secondary>
  </indexterm>
  <indexterm>
   <primary>chaîne binaire</primary>
   <secondary>convertir en une chaîne de caractères</secondary>
  </indexterm>
  Les fonctions de conversion de chaîne entre des ensembles de caractères
  différents (encodage), et pour représenter des données binaires arbitraires
  dans leur forme textuelle, sont affichées dans <xref
  linkend="functions-binarystring-conversions"/>. Pour ces fonctions, un
  argument ou un résultat de type <type>text</type> est exprimé dans
  l'encodage par défaut de la base de données alors que les arguments ou
  résultats de type <type>bytea</type> sont dans un encodage nommé par un
  autre argument.
 </para>

 <table id="functions-binarystring-conversions">
  <title>Fonctions de conversion texte/binaire</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert</primary>
       </indexterm>
       <function>convert</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>src_encoding</parameter> <type>name</type>,
       <parameter>dest_encoding</parameter> <type>name</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Convertit une chaîne binaire représentant du texte dans l'encodage
       <parameter>src_encoding</parameter> en une chaîne binaire dans
       l'encodage <parameter>dest_encoding</parameter> (voir <xref
       linkend="multibyte-conversions-supported"/> pour les conversions
       disponibles).
      </para>
      <para>
       <literal>convert('text_in_utf8', 'UTF8', 'LATIN1')</literal>
       <returnvalue>\x746578745f696e5f75746638</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert_from</primary>
       </indexterm>
       <function>convert_from</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>src_encoding</parameter> <type>name</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Convertit une chaîne binaire représentant du texte dans l'encodage
       <parameter>src_encoding</parameter> vers le type <type>text</type> dans
       l'encodage de la base de données (voir <xref
       linkend="multibyte-conversions-supported"/> pour les conversions
       disponibles).
      </para>
      <para>
       <literal>convert_from('text_in_utf8', 'UTF8')</literal>
       <returnvalue>text_in_utf8</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert_to</primary>
       </indexterm>
       <function>convert_to</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>dest_encoding</parameter> <type>name</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Convertit une chaîne de type <type>text</type> (dans l'encodage de la
       base) en une chaîne binaire encodée dans l'encodage
       <parameter>dest_encoding</parameter> (voir <xref
       linkend="multibyte-conversions-supported"/> pour les conversions
       disponibles).
      </para>
      <para>
       <literal>convert_to('some_text', 'UTF8')</literal>
       <returnvalue>\x736f6d655f74657874</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm id="function-encode">
        <primary>encode</primary>
       </indexterm>
       <function>encode</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>format</parameter> <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Encode les données binaires dans leur représentation textuelle&nbsp;;
       les valeurs <parameter>format</parameter> disponibles sont&nbsp;:
       <link linkend="encode-format-base64"><literal>base64</literal></link>,
       <link linkend="encode-format-escape"><literal>escape</literal></link>,
       <link linkend="encode-format-hex"><literal>hex</literal></link>.
      </para>
      <para>
       <literal>encode('123\000\001', 'base64')</literal>
       <returnvalue>MTIzAAE=</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm id="function-decode">
        <primary>decode</primary>
       </indexterm>
       <function>decode</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>format</parameter> <type>text</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Décode les données binaires à partir d'une représentation
       textuelle&nbsp;; les valeurs supportées de
       <parameter>format</parameter> sont les mêmes que pour
       <function>encode</function>.
      </para>
      <para>
       <literal>decode('MTIzAAE=', 'base64')</literal>
       <returnvalue>\x3132330001</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
  Les fonctions <function>encode</function> et <function>decode</function>
  supportent les formats textuels suivants&nbsp;:

  <variablelist>
   <varlistentry id="encode-format-base64">
    <term>base64
     <indexterm>
      <primary>format base64</primary>
     </indexterm></term>
    <listitem>
     <para>
      Le format <literal>base64</literal> est celui de la <ulink
      url="https://tools.ietf.org/html/rfc2045#section-6.8">RFC 2045 Section
       6.8</ulink>. D'après la RFC, les lignes encodées sont réparties sur 76
      caractères. Néanmoins, à la place du marqueur de fin de ligne CRLF
      MIME, seul un caractère nouvelle ligne est utilisée pour une fin de
      ligne. La fonction <function>decode</function> ignore les caractères de
      retour chariot, de nouvelle ligne, l'espace et la tabulation. Sinon une
      erreur est levée  quand <function>decode</function> se voit fourni des
      données base64 invalides &mdash; ceci incluant quand le remplissage en
      fin est incorrect.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="encode-format-escape">
    <term>escape
     <indexterm>
      <primary>format escape</primary>
     </indexterm></term>
    <listitem>
     <para>
      Le format <literal>escape</literal> convertit les octets zéro et les
      octets avec le bit de poids fort configuré en séquences d'échappement
      octales (<literal>\</literal><replaceable>nnn</replaceable>), et il
      double les antislashes. Les autres valeurs d'octet sont représentées
      littéralement. La fonction <function>decode</function> lèvera une erreur
      si un antislash n'est pas suivi soit par un deuxième antislash ou par
      trois chiffres octals. Il accepte les autres valeurs sans changement.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="encode-format-hex">
    <term>hex
     <indexterm>
      <primary>format hex</primary>
     </indexterm></term>
    <listitem>
     <para>
      Le format <literal>hex</literal> représente chacun 4 bits de données
      sous la forme d'un chiffre hexadécimal, de <literal>0</literal> à
      <literal>f</literal>, en écrivant le chiffre de haut niveau de chaque
      octet en premier. La fonction <function>encode</function> affiche les
      chiffres hexadécimaux <literal>a</literal>-<literal>f</literal> en
      minuscule. Comme l'unité la plus petite des données est de 8 bits, un
      nombre pair de caractères est renvoyé par <function>encode</function>.
      La fonction <function>decode</function> accepte les caractères
      <literal>a</literal>-<literal>f</literal> en minuscule comme en
      majuscule. Une erreur est levée quand <function>decode</function> se
      voit fourni des données hexadécimales invalides &mdash; ceci incluant
      un nombre impair de caractères.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </para>

 <para>
  Voir aussi la fonction d'agrégat <function>string_agg</function> dans <xref
  linkend="functions-aggregate"/> et les fonctions sur les Large Objects dans
  <xref linkend="lo-funcs"/>.
 </para>
</sect1>


<sect1 id="functions-bitstring">
 <title>Fonctions et opérateurs pour les chaînes de bit</title>

 <indexterm zone="functions-bitstring">
  <primary>chaînes de bit</primary>
  <secondary>fonctions</secondary>
 </indexterm>

 <para>
  Cette section décrit les fonctions et opérateurs pour examiner et
  manipuler les chaînes de bit, c'est-à-dire des valeurs de type
  <type>bit</type> et <type>bit varying</type>. (Alors que seul le type
  <type>bit</type> est mentionné dans ces tables, les valeurs de type
  <type>bit varying</type> peuvent être utilisées de façon interchangeable.)
  Les chaînes de bit supportent les opérateurs de comparaison habituels
  indiqués dans <xref linkend="functions-comparison-op-table"/>, ainsi que
  les opérateurs montrés dans <xref
  linkend="functions-bit-string-op-table"/>.
 </para>

 <table id="functions-bit-string-op-table">
  <title>Opérateurs pour les chaînes de bit</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Opérateur
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>bit</type> <literal>||</literal> <type>bit</type>
       <returnvalue>bit</returnvalue>
      </para>
      <para>
       Concaténation
      </para>
      <para>
       <literal>B'10001' || B'011'</literal>
       <returnvalue>10001011</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>bit</type> <literal>&amp;</literal> <type>bit</type>
       <returnvalue>bit</returnvalue>
      </para>
      <para>
       AND bit à bit (les arguments doivent être de même longueur)
      </para>
      <para>
       <literal>B'10001' &amp; B'01101'</literal>
       <returnvalue>00001</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>bit</type> <literal>|</literal> <type>bit</type>
       <returnvalue>bit</returnvalue>
      </para>
      <para>
       OR bit à bit (les arguments doivent être de même longueur)
      </para>
      <para>
       <literal>B'10001' | B'01101'</literal>
       <returnvalue>11101</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>bit</type> <literal>#</literal> <type>bit</type>
       <returnvalue>bit</returnvalue>
      </para>
      <para>
       OR exclusif bit à bit (les arguments doivent être de même longueur)
      </para>
      <para>
       <literal>B'10001' # B'01101'</literal>
       <returnvalue>11100</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <literal>~</literal> <type>bit</type>
       <returnvalue>bit</returnvalue>
      </para>
      <para>
       NOT bit à bit
      </para>
      <para>
       <literal>~ B'10001'</literal>
       <returnvalue>01110</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>bit</type> <literal>&lt;&lt;</literal> <type>integer</type>
       <returnvalue>bit</returnvalue>
      </para>
      <para>
       Décalage à gauche bit à bit
       (la longueur de la chaîne est préservée)
      </para>
      <para>
       <literal>B'10001' &lt;&lt; 3</literal>
       <returnvalue>01000</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>bit</type> <literal>&gt;&gt;</literal> <type>integer</type>
       <returnvalue>bit</returnvalue>
      </para>
      <para>
       Décalage à droite bit à bit
       (la longueur de la chaîne est préservée)
      </para>
      <para>
       <literal>B'10001' &gt;&gt; 2</literal>
       <returnvalue>00100</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
  Certaines des fonctions disponibles pour les chaînes binaires sont aussi
  disponibles pour les chaînes de bit, comme indiquées dans <xref
  linkend="functions-bit-string-table"/>.
 </para>

 <table id="functions-bit-string-table">
  <title>Fonctions pour les chaînes de bit</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>bit_length</primary>
       </indexterm>
       <function>bit_length</function> ( <type>bit</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre de bits d'une chaîne de bit.
      </para>
      <para>
       <literal>bit_length(B'10111')</literal>
       <returnvalue>5</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>length</primary>
       </indexterm>
       <indexterm>
        <primary>chaîne de bit</primary>
        <secondary>longueur</secondary>
       </indexterm>
       <function>length</function> ( <type>bit</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre de bits d'une chaîne de bit.
      </para>
      <para>
       <literal>length(B'10111')</literal>
       <returnvalue>5</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>octet_length</primary>
       </indexterm>
       <function>octet_length</function> ( <type>bit</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre d'octets d'une chaîne de bit.
      </para>
      <para>
       <literal>octet_length(B'1011111011')</literal>
       <returnvalue>2</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>overlay</primary>
       </indexterm>
       <function>overlay</function> ( <parameter>bits</parameter> <type>bit</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>bit</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
       <returnvalue>bit</returnvalue>
      </para>
      <para>
       Remplace la sous-chaîne de <parameter>bits</parameter> commençant au
       <parameter>start</parameter>-ième bit et s'étendant sur
       <parameter>count</parameter> bits avec
       <parameter>newsubstring</parameter>. Si <parameter>count</parameter>
       est omis, sa valeur par défaut est la longueur de
       <parameter>newsubstring</parameter>.
      </para>
      <para>
       <literal>overlay(B'01010101010101010' placing B'11111' from 2 for 3)</literal>
       <returnvalue>0111110101010101010</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>position</primary>
       </indexterm>
       <function>position</function> ( <parameter>substring</parameter> <type>bit</type> <literal>IN</literal> <parameter>bits</parameter> <type>bit</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie la position de départ de <parameter>substring</parameter>
       dans <parameter>bits</parameter>, ou zéro s'il n'est pas présent.
      </para>
      <para>
       <literal>position(B'010' in B'000001101011')</literal>
       <returnvalue>8</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>substring</primary>
       </indexterm>
       <function>substring</function> ( <parameter>bits</parameter> <type>bit</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
       <returnvalue>bit</returnvalue>
      </para>
      <para>
       Extrait la sous-chaîne de <parameter>bits</parameter> commençant au
       <parameter>start</parameter>-ième bit s'il est précisé, et s'arrêtant
       après <parameter>count</parameter> bits s'il est précisé. Il est
       requis qu'au moins soit <parameter>start</parameter> soit
       <parameter>count</parameter> soient renseignés.
      </para>
      <para>
       <literal>substring(B'110010111111' from 3 for 2)</literal>
       <returnvalue>00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>get_bit</primary>
       </indexterm>
       <function>get_bit</function> ( <parameter>bits</parameter> <type>bit</type>,
       <parameter>n</parameter> <type>integer</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Extrait le <parameter>n</parameter>-ième bit de la chaîne de bits.
       Le premier bit (le plus à gauche) est le bit 0.
      </para>
      <para>
       <literal>get_bit(B'101010101010101010', 6)</literal>
       <returnvalue>1</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>set_bit</primary>
       </indexterm>
       <function>set_bit</function> ( <parameter>bits</parameter> <type>bit</type>,
       <parameter>n</parameter> <type>integer</type>,
       <parameter>newvalue</parameter> <type>integer</type> )
       <returnvalue>bit</returnvalue>
      </para>
      <para>
       Initialise le <parameter>n</parameter>-ième bit dans la chaîne de bit
       avec <parameter>newvalue</parameter>. Le premier bit (le plus à
       gauche) est le bit 0.
      </para>
      <para>
       <literal>set_bit(B'101010101010101010', 6, 0)</literal>
       <returnvalue>101010001010101010</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
  De plus, il est possible de convertir les valeurs intégrales à partir ou
  vers le type <type>bit</type>. Convertir un entier en <type>bit(n)</type>
  copie les <literal>n</literal> bits les plus à droite. Convertir un entier
  en une chaîne de bits, dont la largeur est plus importante que l'entier
  lui-même, l'étendra sur la gauche. Quelques exemples&nbsp;:
  <programlisting>
44::bit(10)                    <lineannotation>0000101100</lineannotation>
44::bit(3)                     <lineannotation>100</lineannotation>
cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>
'1110'::bit(4)::integer        <lineannotation>14</lineannotation>
  </programlisting>
  Il faut noter que la conversion vers simplement <quote>bit</quote>
  signifie une conversion vers <literal>bit(1)</literal>, et ne renverra
  donc que le bit le moins significatif de l'entier.
 </para>
</sect1>


<sect1 id="functions-matching">
 <title>Correspondance de motif</title>

 <indexterm zone="functions-matching">
  <primary>Correspondance de motif</primary>
 </indexterm>

 <para>
  Il existe trois approches séparées concernant la correspondance de motif
  fournies par <productname>PostgreSQL</productname>&nbsp;: l'opérateur
  <acronym>SQL</acronym> <function>LIKE</function> habituel, l'opérateur
  <function>SIMILAR TO</function> plus récent (ajouté dans SQL:1999), et les
  expressions rationnelles style <acronym>POSIX</acronym>. En dehors des
  opérateurs basiques du type <quote>est-ce que cette chaîne correspond à ce
   motif&nbsp;?</quote>, des fonctions sont disponibles pour extraire ou
  remplacer des sous-chaînes et pour diviser une chaîne aux emplacements
  correspondant.
 </para>

 <tip>
  <para>
   Si vous avez des besoins sur la correspondance de motif qui vont au dela
   de ceci, pensez à écrire une fonction en Perl ou Tcl.
  </para>
 </tip>

 <caution>
  <para>
   Bien que la plupart des recherches par expression rationnelles peut
   être exécutée très rapidement, des expressions rationnelles peuvent
   être conçues de telle façon qu'elles récupèrent des quantités
   arbitraires de temps et de mémoire pour le traitement. Faites attention
   si vous acceptez des expressions rationnelles à partir de sources hostiles.
   Si vous devez le faire, il est conseillé d'imposer une durée limite
   d'exécution pour
   la requête.
  </para>

  <para>
   Les recherches utilisant des motifs <function>SIMILAR TO</function> ont
   les mêmes problèmes de sécurité car <function>SIMILAR TO</function>
   fournit un grand nombre de fonctionnalités identiques à celles des
   expressions rationnelles style <acronym>POSIX</acronym>.
  </para>

  <para>
   Les recherches <function>LIKE</function>, étant plus simples que les deux
   autres options, sont plus sûres à utiliser avec des sources
   potentiellement hostiles.
  </para>
 </caution>

 <para>
  Les opérateurs de correspondance de motifs des trois types ne supportent
  pas les collations non déterministes. Si nécessaire, appliquez une
  collation différente à l'expression pour contourner cette limitation.
 </para>

 <sect2 id="functions-like">
  <title><function>LIKE</function></title>

  <indexterm>
   <primary>LIKE</primary>
  </indexterm>

  <synopsis>
<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
  </synopsis>

  <para>
   L'expression <function>LIKE</function> renvoie true si la chaîne
   <replaceable>string</replaceable> correspond au
   <replaceable>pattern</replaceable> fourni.  (Comme attendu, l'expression
   <function>NOT LIKE</function> renvoie false si <function>LIKE</function>
   renvoie true, et vice versa. Une expression équivalente est <literal>NOT
    (<replaceable>string</replaceable> LIKE
    <replaceable>pattern</replaceable>)</literal>.)
  </para>

  <para>
   Si <replaceable>pattern</replaceable> ne contient pas de signe pourcent
   ou de tiret bas, alors le motif représente seulement la chaîne
   elle-même&nbsp;; dans ce cas, <function>LIKE</function> agit comme
   l'opérateur d'égalité. Un tiret bas (<literal>_</literal>) dans
   <replaceable>pattern</replaceable> établit une correspondance avec
   n'importe quel caractère, mais un seul&nbsp;; un signe pourcent
   (<literal>%</literal>) établit une correspondance avec une séquence de
   zéro ou plusieurs caractères.
  </para>

  <para>
   Quelques exemples&nbsp;:
   <programlisting>
'abc' LIKE 'abc'    <lineannotation>true</lineannotation>
'abc' LIKE 'a%'     <lineannotation>true</lineannotation>
'abc' LIKE '_b_'    <lineannotation>true</lineannotation>
'abc' LIKE 'c'      <lineannotation>false</lineannotation>
   </programlisting>
  </para>

  <para>
   La correspondance de motif de <function>LIKE</function> couvre toujours la
   chaîne complète. Du coup, s'il est préféré de réaliser une correspondance
   sur une séquences n'importe où dans une chaîne, le motif doit commencer et
   finir avec un signe pourcent.
  </para>

  <para>
   Pour faire une correspondance avec un tiret bas ou un signe pourcent, le
   caractère respectif dans <replaceable>pattern</replaceable> doit être
   précédé d'un caractère d'échappement. Le caractère d'échappement par
   défaut est l'antislash mais il est possible d'en sélectionner un autre en
   utilisant la clause <literal>ESCAPE</literal>. Pour faire une
   correspondance avec l'un de ces deux caractères, il faut écrire deux fois
   les caractères d'échappement.
  </para>

  <note>
   <para>
    Si vous avez désactivé <xref linkend="guc-standard-conforming-strings"/>,
    tout antislash écrit dans les constantes de chaîne aura besoin d'être
    doublé. Voir <xref linkend="sql-syntax-strings"/> pour plus
    d'informations.
   </para>
  </note>

  <para>
   Il est aussi possible de sélectionner un autre caractère d'échappement en
   écrivant <literal>ESCAPE ''</literal>. Ceci a pour conséquence de
   désactiver le mécanisme d'échappement, ce qui rend impossible de
   désactiver la signification spéciale des signes tiret bas et pourcent dans
   le motif.
  </para>

  <para>
   D'après le standard SQL, omettre <literal>ESCAPE</literal> signifie qu'il
   n'y a pas de caractère d'échappement (plutôt que d'avoir antislash comme
   valeur par défaut), et une valeur <literal>ESCAPE</literal> de longueur
   zéro est interdite. Le comportement de
   <productname>PostgreSQL</productname> à ce niveau est donc contraire au
   standard.
  </para>

  <para>
   Le mot clé <token>ILIKE</token> peut être utilisé à la place de
   <token>LIKE</token> pour rendre la correspondance insensible à la casse
   d'après la locale active. Ce mot clé n'est pas défini dans le standard
   SQL, il s'agit d'une extension de <productname>PostgreSQL</productname>.
  </para>

  <para>
   L'opérateur <literal>~~</literal> est équivalent à
   <function>LIKE</function>, et <literal>~~*</literal> correspond à
   <function>ILIKE</function>. Il existe aussi les opérateurs
   <literal>!~~</literal> et <literal>!~~*</literal> qui représentent
   respectivement <function>NOT LIKE</function> et <function>NOT
    ILIKE</function>. Tous ces opérateurs sont spécifiques à
   <productname>PostgreSQL</productname>. Vous pourriez voir les noms de ces
   opérateurs dans le résultat de la commande <command>EXPLAIN</command> et
   dans des emplacements similaires, car l'analyseur traduit en fait
   <function>LIKE</function> et les autres en ces opérateurs.
  </para>

  <para>
   Les phrases <function>LIKE</function>, <function>ILIKE</function>,
   <function>NOT LIKE</function> et <function>NOT ILIKE</function> sont
   généralement traitées comme des opérateurs dans la syntaxe
   <productname>PostgreSQL</productname>&nbsp;; par exemple, elles peuvent
   être utilisées dans des constructions du style
   <replaceable>expression</replaceable> <replaceable>operateur</replaceable>
   ANY (<replaceable>sous-requete</replaceable>), bien qu'une clause
   <literal>ESCAPE</literal> ne puisse pas être inclus ici. Dans certains cas
   obscurs, il pourrait être nécessaire d' utiliser les noms d'opérateur
   sous-jacent à la place.
  </para>

  <para>
   De plus, voir l'opérateur de préfixe <literal>^@</literal> et la fonction
   correspondante <function>starts_with</function>, qui sont utiles dans les
   cas où une simple correspondance avec le début d'une chaîne est
   nécessaire.
  </para>
 </sect2>


 <sect2 id="functions-similarto-regexp">
  <title>Expressions rationnelles pour <function>SIMILAR TO</function></title>

  <indexterm>
   <primary>expression rationnelle</primary>
   <!-- <seealso>pattern matching</seealso> breaks index build -->
  </indexterm>

  <indexterm>
   <primary>SIMILAR TO</primary>
  </indexterm>
  <indexterm>
   <primary>sous-chaîne</primary>
  </indexterm>

  <synopsis>
<replaceable>string</replaceable> SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
  </synopsis>

  <para>
   L'opérateur <function>SIMILAR TO</function> renvoie true ou false suivant
   que le motif correspond ou non à la chaîne donnée. C'est similaire à
   <function>LIKE</function>, sauf qu'il interprète le motif en utilisant la
   définition du standard SQL d'une expression rationnelle. Les expressions
   rationnelles SQL sont un mixe étrange entre la notation
   <function>LIKE</function> et la notation d'expression rationnelle POSIX.
  </para>

  <para>
   Tout comme <function>LIKE</function>, l'opérateur <function>SIMILAR
    TO</function> réussit seulement si son motif correspond à la chaîne
   entière&nbsp;; c'est contraire au comportement commun des expressions
   rationnelles où le motif peut correspondre à toute partie de la chaîne.
   Encore une fois comme <function>LIKE</function>, <function>SIMILAR
    TO</function> utilise <literal>_</literal> et <literal>%</literal> comme
   caractère joker dénotant respectivement tout caractère simple et toute
   (ils sont comparables à <literal>.</literal> et <literal>.*</literal> dans
   les expressions rationnelles POSIX).
  </para>

  <para>
   En plus de ces possibilités empruntées à <function>LIKE</function>,
   <function>SIMILAR TO</function> accepte les méta-caractères de
   correspondance de motif empruntés aux expressions rationnelles
   POSIX&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      <literal>|</literal> dénote le choix (entre deux alternatives).
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>*</literal> dénote la répétition de l'élément précédent zéro ou
      plusieurs fois.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>+</literal> dénote la répétition de l'élément précédent une ou
      plusieurs fois.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>?</literal> dénote la répétition de l'élément précédent zéro ou
      une fois.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>}</literal>
      dénote la répétition de l'élément précédent exactement
      <replaceable>m</replaceable> fois.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>,}</literal>
      dénote la répétition de l'élément précédent <replaceable>m</replaceable>
      fois ou plus.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>
      dénote la répétition de l'élément précédent au moins
      <replaceable>m</replaceable> fois mais plus que que
      <replaceable>n</replaceable> fois.
     </para>
    </listitem>
    <listitem>
     <para>
      Les parenthèses <literal>()</literal> peuvent être utilisées pour
      grouper des éléments en un seul élément logique.
     </para>
    </listitem>
    <listitem>
     <para>
      Une expression entre crochets <literal>[...]</literal> indique une
      classe de caractères, tout comme dans les expressions rationnelles
      POSIX.
     </para>
    </listitem>
   </itemizedlist>

   Notez que le point (<literal>.</literal>) n'est pas un méta-caractère pour
   <function>SIMILAR TO</function>.
  </para>

  <para>
   Comme avec <function>LIKE</function>, un antislash désactive la
   signification spéciale d'un de ces méta-caractères. Un caractère
   d'échappement différent peut être indiqué avec <literal>ESCAPE</literal>,
   et la possibilité d'échappement peut être désactivé avec <literal>ESCAPE
    ''</literal>.
  </para>

  <para>
   D'après le standard SQL, omettre <literal>ESCAPE</literal> signifie
   qu'il n'y a pas de caractère d'échappement (plutôt que d'avoir comme
   valeur par défaut un antislash), et une valeur <literal>ESCAPE</literal>
   de longueur nulle est interdite. Le comportement de
   <productname>PostgreSQL</productname> dans ce cas est contraire au
   standard.
  </para>

  <para>
   Une autre extension non standard est que faire suivre le caractère
   d'échappement d'une lettre ou d'un chiffre fournit un accès aux séquences
   d'échappement définies par les expressions rationnelles POSIX&nbsp;; voir
   <xref linkend="posix-character-entry-escapes-table"/>,
   <xref linkend="posix-class-shorthand-escapes-table"/> et
   <xref linkend="posix-constraint-escapes-table"/> ci-dessous.
  </para>

  <para>
   Quelques exemples&nbsp;:
   <programlisting>
'abc' SIMILAR TO 'abc'          <lineannotation>true</lineannotation>
'abc' SIMILAR TO 'a'            <lineannotation>false</lineannotation>
'abc' SIMILAR TO '%(b|d)%'      <lineannotation>true</lineannotation>
'abc' SIMILAR TO '(b|c)%'       <lineannotation>false</lineannotation>
'-abc-' SIMILAR TO '%\mabc\M%'  <lineannotation>true</lineannotation>
'xabcy' SIMILAR TO '%\mabc\M%'  <lineannotation>false</lineannotation>
   </programlisting>
  </para>

  <para>
   La fonction <function>substring</function> avec trois paramètres fournit
   une extraction d'une sous-chaîne qui correspond à un motif d'expression
   rationnelle SQL. La fonction peut être écrite d'après la syntaxe
   SQL99&nbsp;:
   <synopsis>
substring(<replaceable>string</replaceable> from <replaceable>pattern</replaceable> for <replaceable>escape-character</replaceable>)
   </synopsis>
   ou comme une fonction simple avec trois arguments&nbsp;:
   <synopsis>
substring(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>, <replaceable>escape-character</replaceable>)
   </synopsis>
   Comme avec <literal>SIMILAR TO</literal>, le motif spécifié doit
   correspondre à la chaîne de données entière. Dans le cas contraire, la
   fonction échoue et renvoie NULL. Pour indiquer la partie du motif pour
   laquelle la sous-chaîne de données correspondante est intéressante, le
   motif doit contenir deux occurences du caractère d'échappement suivi par
   un guillemet double (<literal>"</literal>). <!-- " font-lock sanity --> Le
   texte correspondant à la portion du motif entre ces séparateurs est
   renvoyé quand la correspondance est réussie.
  </para>

  <para>
   Les séparateurs échappement-guillemet-double divisent en fait le motif de
   <function>substring</function> en trois expressions rationnelles
   indépendantes&nbsp;; par exemple, une barre verticale
   (<literal>|</literal>) dans une des trois sections affecte seulement
   uniquement cette section. De plus, la première et la troisième des
   expressions rationnelles sont définies pour correspondre à la plus petite
   quantité de texte, pas à la plus grande, quand il y a une ambiguité sur
   quelle quantité de données il y a correspondance avec le motif. (Dans la
   langue POSIX, on dit que la première et la troisième expressions
   rationnelles sont restreintes pour ne pas être gourmandes,
   <foreignphrase>non-greedy</foreignphrase> en anglais.)
  </para>

  <para>
   En tant qu'extension au standard SQL,
   <productname>PostgreSQL</productname> permet qu'il y ait juste un
   caractère pour l'échappement des guillemets doubles, auquel cas la
   troisième expression rationnelle est comprise comme vide&nbsp;; ou sans
   séparateur, auquel cas la première et la troisième expressions
   rationnelles sont comprises comme vides.
  </para>

  <para>
   Quelques exemples, avec <literal>#&quot;</literal> délimitant la chaîne en
   retour&nbsp;:
   <programlisting>
substring('foobar' from '%#"o_b#"%' for '#')   <lineannotation>oob</lineannotation>
substring('foobar' from '#"o_b#"%' for '#')    <lineannotation>NULL</lineannotation>
   </programlisting>
  </para>
 </sect2>

 <sect2 id="functions-posix-regexp">
  <title>Expressions rationnelles <acronym>POSIX</acronym></title>

  <indexterm zone="functions-posix-regexp">
   <primary>expression rationnelle</primary>
   <seealso>correspondance de motif</seealso>
  </indexterm>
  <indexterm>
   <primary>substring</primary>
  </indexterm>
  <indexterm>
   <primary>regexp_replace</primary>
  </indexterm>
  <indexterm>
   <primary>regexp_match</primary>
  </indexterm>
  <indexterm>
   <primary>regexp_matches</primary>
  </indexterm>
  <indexterm>
   <primary>regexp_split_to_table</primary>
  </indexterm>
  <indexterm>
   <primary>regexp_split_to_array</primary>
  </indexterm>

  <para>
   <xref linkend="functions-posix-table"/> liste les opérateurs disponibles
   pour faire de la correspondance de motif en utilisant les expressions
   rationnelles.
  </para>

  <table id="functions-posix-table">
   <title>Opérateurs de correspondance d'expressions rationnelles</title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="func_table_entry"><para role="func_signature">
        Opérateur
       </para>
       <para>
        Description
       </para>
       <para>
        Exemple(s)
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>~</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        La chaîne correspond à l'expression rationnelle, casse comprise
       </para>
       <para>
        <literal>'thomas' ~ '.*thom.*'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>~*</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        La chaîne correspond à l'expression rationnelle, sans prise en compte
        de la casse
       </para>
       <para>
        <literal>'thomas' ~* '.*Thom.*'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>!~</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        La chaîne ne correspond pas à l'expression rationnelle, casse comprise
       </para>
       <para>
        <literal>'thomas' !~ '.*thomas.*'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>!~*</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        La chaîne ne correspond pas à l'expression rationnelle, sans prise en
        compte de la casse
       </para>
       <para>
        <literal>'thomas' !~* '.*vadim.*'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les expressions rationnelles <acronym>POSIX</acronym> fournit un moyen
   bien plus puissant pour la correspondance de motif que les opérateurs
   <function>LIKE</function> et <function>SIMILAR TO</function>. Un grand
   nombre d'outils Unix comme <command>egrep</command>,
   <command>sed</command> ou <command>awk</command> utilise un langage de
   correspondance de motif similaire à celui décrit ici.
  </para>

  <para>
   Une expression rationnelle est une séquence de caractères qui est une
   définition courte d'un ensemble de chaînes (un <firstterm>ensemble
    rationnel</firstterm>). Une chaîne est dite correspondre à une expression
   rationnelle si elle est un membre de l'ensemble rationnel décrit par
   l'expression rationnelle. Tout comme avec <function>LIKE</function>, les
   caractères du motif correspondent exactement aux caractères de la chaîne
   sauf dans le cas de caractères spéciaux du langage d'expression
   rationnelle &mdash; mais les expressions rationnelles utilisent
   différents caractères spéciaux comme le fait <function>LIKE</function>.
   Contrairement aux motifs <function>LIKE</function>, une expression
   rationnelle est autorisée à établir une correspondance n'importe où dans
   une chaîne, sauf si l'expression rationnelle est explicitement ancrée au
   début ou à la fin de la chaîne.
  </para>

  <para>
   Quelques exemples&nbsp;:
   <programlisting>
'abc' ~ 'abc'    <lineannotation>true</lineannotation>
'abc' ~ '^a'     <lineannotation>true</lineannotation>
'abc' ~ '(b|d)'  <lineannotation>true</lineannotation>
'abc' ~ '^(b|c)' <lineannotation>false</lineannotation>
   </programlisting>
  </para>

  <para>
   Le langage de motif <acronym>POSIX</acronym> est décrit avec bien plus de
   détails ci-dessous.
  </para>

  <para>
   La fonction <function>substring</function> avec deux arguments,
   <function>substring(<replaceable>string</replaceable> from
    <replaceable>pattern</replaceable>)</function>, propose l'extraction
   d'une sous-chaîne correspondant à un motif d'expression rationnelle
   POSIX. Elle renvoie NULL s'il n'y a aucune correspondance, et renvoie la
   portion du texte correspondant au motif. Mais si le motif contient des
   parenthèses, la portion du texte correspondant à la première
   sous-expression entre parenthèses (celle où la parenthèse gauche arrive
   en premier) est renvoyée. Vous pouvez placer les parenthèses autour de
   l'expression entière si vous voulez utiliser des parenthèses dans le
   motif sans déclencher cette exception. Si vous avez besoin des
   parenthèses dans le motif avant la sous-expression que vous voulez
   extraire, voir les parenthèses sans capture décrites ci-dessous.
  </para>

  <para>
   Quelques exemples&nbsp;:
   <programlisting>
substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>
substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>
   </programlisting>
  </para>

  <para>
   La fonction <function>regexp_replace</function> propose la substitution
   d'un nouveau texte pour les sous-chaînes correspondant aux motifs d'une
   expression rationnelle POSIX. Elle a la syntaxe
   <function>regexp_replace</function>(<replaceable>source</replaceable>,
   <replaceable>pattern</replaceable>,
   <replaceable>replacement</replaceable> <optional>,
    <replaceable>flags</replaceable> </optional>). La chaîne
   <replaceable>source</replaceable> est renvoyée sans modification s'il n'y
   a pas de correspondance avec <replaceable>pattern</replaceable>. S'il y a
   correspondance, la chaîne <replaceable>source</replaceable> est renvoyée
   avec la chaîne <replaceable>replacement</replaceable> substituée pour la
   sous-chaîne correspondante. La chaîne
   <replaceable>replacement</replaceable> peut contenir
   <literal>\</literal><replaceable>n</replaceable>, où
   <replaceable>n</replaceable> vaut de 1 à 9, pour indiquer que la
   sous-chaîne source correspondant à la <replaceable>n</replaceable>-ième
   sous-expression entre parenthèses du motif devrait être inséré, et elle
   peut contenir <literal>\&amp;</literal> pour indiquer que la sous-chaîne
   correspondant au motif entier devrait être insérée. Écrivez
   <literal>\\</literal> si vous avez besoin de placer un antislash littéral
   comme texte de remplacement. Le paramètre
   <replaceable>flags</replaceable> parameter est une chaîne de texte
   optionnelle contenant zéro ou plusieurs drapeaux de lettres individuelles
   modifiant le comportement de la fonction. Le drapeau <literal>i</literal>
   indique une correspondance sans sensibilité à la casse, alors que le
   drapeau <literal>g</literal> indique le remplacement de chaque
   sous-chaîne correspondante plutôt que de seulement la première. Les
   drapeaux acceptés (sauf <literal>g</literal>) sont décrit dans <xref
   linkend="posix-embedded-options-table"/>.
  </para>

  <para>
   Quelques exemples&nbsp;:
   <programlisting>
regexp_replace('foobarbaz', 'b..', 'X')
                                   <lineannotation>fooXbaz</lineannotation>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <lineannotation>fooXX</lineannotation>
regexp_replace('foobarbaz', 'b(..)', 'X\1Y', 'g')
                                   <lineannotation>fooXarYXazY</lineannotation>
   </programlisting>
  </para>

  <para>
   La fonction <function>regexp_match</function> renvoie un tableau texte
   des sous-chaînes capturées résultant de la première correspondance au
   motif d'une expression rationnelle POSIX avec une chaîne. Elle a la
   syntaxe
   <function>regexp_match</function>(<replaceable>string</replaceable>,
   <replaceable>pattern</replaceable> <optional>,
    <replaceable>flags</replaceable> </optional>). S'il n'y a aucune
   correspondance, le résultat est <literal>NULL</literal>. Si une
   correspondance est trouvée et que <replaceable>pattern</replaceable> ne
   contient aucune sous-expression entre parenthèses, alors le résultat est
   un tableau texte à un seul élément contenant la sous-chaîne
   correspondance au motif entier. Si une correspondance est trouvée et que
   <replaceable>pattern</replaceable> contient des sous-expressions entre
   parenthèses, alors le résultat est un tableau texte où le
   <replaceable>n</replaceable>-ième élément est la sous-chaîne
   correspondant à la <replaceable>n</replaceable>-ième sous-expression
   entre parenthèses de <replaceable>pattern</replaceable> (sans compter les
   parenthèses <quote>sans capture</quote>&nbsp;; voir ci-dessous pour les
   détails). Le paramètre <replaceable>flags</replaceable> est une chaîne de
   texte optionnel contenant zéro ou plusieurs drapeaux de lettres
   individuelles qui changent le comportement de la fonction. Les drapeaux
   acceptés sont décrit dans <xref linkend="posix-embedded-options-table"/>.
  </para>

  <para>
   Quelques exemples&nbsp;:
   <programlisting>
SELECT regexp_match('foobarbequebaz', 'bar.*que');
 regexp_match
--------------
 {barbeque}
(1 row)

SELECT regexp_match('foobarbequebaz', '(bar)(beque)');
 regexp_match
--------------
 {bar,beque}
(1 row)
   </programlisting>
   Dans le cas habituel où vous voulez simplement la sous-chaîne correspondant
   exactement ou <literal>NULL</literal> dans le cas où il n'y a pas de correspondance,
   écrivez quelque chose comme&nbsp;:
   <programlisting>
SELECT (regexp_match('foobarbequebaz', 'bar.*que'))[1];
 regexp_match
--------------
 barbeque
(1 row)
   </programlisting>
  </para>

  <para>
   La fonction <function>regexp_matches</function> renvoie un ensemble de
   tableaux de texte des sous-chaînes capturées résultant d'une
   correspondance d'un motif d'expression rationnelle POSIX à une chaîne.
   Elle a la même syntaxe que <function>regexp_match</function>. Cette
   fonction ne renvoie aucune ligne s'il n'y a pas de correspondance, une
   ligne s'il y a une correspondance et que le drapeau <literal>g</literal>
   n'a pas été utilisé, ou <replaceable>N</replaceable> lignes s'il y a
   <replaceable>N</replaceable> correspondances et que le drapeau
   <literal>g</literal> a été utilisé. Chaque ligne renvoyée est un tableau
   texte contenant la sous-chaîne entière correspondante ou les sous-chaînes
   correspondant aux sous-expressions entre parenthèses de
   <replaceable>pattern</replaceable>, comme décrit ci-dessus pour
   <function>regexp_match</function>. <function>regexp_matches</function>
   accepte tous les drapeaux discutés dans <xref
   linkend="posix-embedded-options-table"/>, plus le drapeau
   <literal>g</literal> qui requiert le renvoi de toutes les
   correspondances, et non pas seulement de la première.
  </para>

  <para>
   Quelques exemples&nbsp;:
   <programlisting>
SELECT regexp_matches('foo', 'not there');
 regexp_matches
----------------
(0 rows)

SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
 regexp_matches
----------------
 {bar,beque}
 {bazil,barf}
(2 rows)
   </programlisting>
  </para>

  <tip>
   <para>
    Dans la plupart des cas, <function>regexp_matches()</function> devrait
    être utilisé avec le drapeau <literal>g</literal> car, si vous voulez
    seulement la première correspondance, il est plus simple et plus efficace
    d'utiliser <function>regexp_match()</function>. Néanmoins,
    <function>regexp_match()</function> existe seulement à partir de la
    version 10 de <productname>PostgreSQL</productname>. Sur les anciennes
    versions, une astuce connue est de placer un appel à
    <function>regexp_matches()</function> dans une sous-requête, par
    exemple&nbsp;:
    <programlisting>
SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;
    </programlisting>
    Ceci produit un tableau de texte s'il y a une correspondance ou
    <literal>NULL</literal> dans le cas contraire, comme le ferait
    <function>regexp_match()</function>. Sans la sous-requête, cette requête
    ne produirait aucun résultat pour les lignes de la table sans
    correspondance, ce qui n'est pas le comportement désiré habituellement.
   </para>
  </tip>

  <para>
   La fonction <function>regexp_split_to_table</function> divise une chaîne
   utilisant un motif d'expression rationnelle POSIX comme délimiteur. Elle
   a la syntaxe
   <function>regexp_split_to_table</function>(<replaceable>string</replaceable>,
   <replaceable>pattern</replaceable> <optional>,
    <replaceable>flags</replaceable> </optional>). S'il n'y a aucune
   correspondance avec <replaceable>pattern</replaceable>, la fonction
   renvoie <replaceable>string</replaceable>. S'il y a au moins une
   correspondance, pour chaque correspondance, elle renvoie le texte à
   partir de la fin de la dernière correspondance (ou du début de la chaîne)
   jusqu'au début de la correspondance. Quand il n'y a plus de
   correspondance, elle renvoie le texte de la fin de la dernière
   correspondance à la fin de la chaîne. Le paramètre
   <replaceable>flags</replaceable> est une chaîne de texte optionnelle
   contenant zéro ou plusieurs drapeaux de lettres individuelles qui
   modifient le comportement de la fonction.
   <function>regexp_split_to_table</function> accepte les drapeaux décrits
   dans <xref linkend="posix-embedded-options-table"/>.
  </para>

  <para>
   La fonction <function>regexp_split_to_array</function> se comporte de la
   même façon que <function>regexp_split_to_table</function>, sauf que
   <function>regexp_split_to_array</function> renvoie son résultat comme un
   tableau de <type>text</type>. Elle a la syntaxe
   <function>regexp_split_to_array</function>(<replaceable>string</replaceable>,
   <replaceable>pattern</replaceable> <optional>,
    <replaceable>flags</replaceable> </optional>). Les paramètres sont les
   mêmes que pour <function>regexp_split_to_table</function>.
  </para>

  <para>
   Quelques exemples&nbsp;:
   <programlisting>

SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', '\s+') AS foo;
  foo
-------
 the
 quick
 brown
 fox
 jumps
 over
 the
 lazy
 dog
(9 rows)

SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', '\s+');
              regexp_split_to_array
-----------------------------------------------
 {the,quick,brown,fox,jumps,over,the,lazy,dog}
(1 row)

SELECT foo FROM regexp_split_to_table('the quick brown fox', '\s*') AS foo;
 foo
-----
 t
 h
 e
 q
 u
 i
 c
 k
 b
 r
 o
 w
 n
 f
 o
 x
(16 rows)
   </programlisting>
  </para>

  <para>
   Comme le démontre le dernier exemple, les fonctions de division
   d'expressions rationnelles ignorent les correspondances de longueur zéro
   survenant au début et à la fin de la chaîne ou immédiatement après la
   correspondance précédente. Ceci est contraire à la définition stricte de la
   correspondance d'expression rationnelle telle qu'elle est implémentée par
   <function>regexp_match</function> et <function>regexp_matches</function>,
   mais c'est généralement le comportement le plus intéressant en pratique.
   Les autres logiciels tels que Perl utilisent des définitions similaires.
  </para>

  <!-- derived from the re_syntax.n man page -->

  <sect3 id="posix-syntax-details">
   <title>Détails sur les expressions rationnelles</title>

   <para>
    Les expressions rationnelles de <productname>PostgreSQL</productname> sont
    implémentées en utilisant un paquet logiciel écrit par Henry Spencer. La
    plupart des descriptions d'expressions rationnelles ci-dessous est copiée
    verbatim de son manuel.
   </para>

   <para>
    Les expressions rationnelles (connus sous l'acronyme
    <acronym>RE</acronym>), tel qu'elles sont définies dans
    <acronym>POSIX</acronym> 1003.2, viennent sous deux formes&nbsp;: les
    <acronym>RE</acronym> <firstterm>étendues</firstterm> ou
    <acronym>ERE</acronym> (en gros celles de <command>egrep</command>), et
    les <acronym>RE</acronym> <firstterm>basiques</firstterm> ou
    <acronym>BRE</acronym> (en gros celles de <command>ed</command>).
    <productname>PostgreSQL</productname> accepte les deux formes, et
    implémente aussi certaines extensions qui ne font pas partie du standard
    POSIC, mais sont devenues largement utilisées grâce à leur disponibilité
    dans les langages de programmation tels que Perl et Tcl. Les
    <acronym>RE</acronym> utilisant ces extensions de POSIX sont appelées des
    <acronym>RE</acronym> <firstterm>avancées</firstterm> ou
    <acronym>ARE</acronym> dans cette documentation. Les ARE sont pratiquement
    un sur-ensemble des ERE, mais les BRE ont des incompatibilités de notation
    (et sont bien plus limitées). Nous décrivons tout d'abord les formes ARE
    et ERE, en notant les fonctionnalités qui s'appliquent uniquement aux ARE,
    puis nous décrivons comment les BRE diffèrent.
   </para>

   <note>
    <para>
     <productname>PostgreSQL</productname> présume toujours au départ qu'une
     expression rationnelle suit les règles ARE. Néanmoins, les règles ERE
     plus limitées ou les règles BRE peuvent être choisies en ajoutant une
     <firstterm>option intégrée</firstterm> au motif RE, comme décrit dans
     <xref linkend="posix-metasyntax"/>. Ceci peut être utile pour la
     compatibilité avec les applications qui s'attendent à un respect strict
     des règles <acronym>POSIX</acronym> 1003.2.
    </para>
   </note>

   <para>
    Une expression rationnelle est définie comme une ou plusieurs
    <firstterm>branches</firstterm>, séparées par <literal>|</literal>. Elle
    correspond à tout ce qui correspond à une des branches.
   </para>

   <para>
    Une branche est zéro ou plus <firstterm>atomes quantifiés</firstterm> ou
    <firstterm>contraintes</firstterm>, concaténés. Elle établie une
    correspondance pour le premier, puis pour le second, etc&nbsp;; une
    branche vide établit une correspondance à une chaîne vide.
   </para>

   <para>
    Un atome quantifié est un <firstterm>atome</firstterm> potentiellement
    suivi par un <firstterm>quantifieur</firstterm> simple. Sans quantifieur,
    il peut établir une correspondance pour l'atome. Avec un quantifieur, il
    peut établir un certain nombre de correspondances à l'atome Un
    <firstterm>atom</firstterm> peut être une des possibilités indiquées dans
    <xref linkend="posix-atoms-table"/>. Les quantifieurs possibles et leur
    signification sont montrés dans <xref linkend="posix-quantifiers-table"/>.
   </para>

   <para>
    Une <firstterm>contrainte</firstterm> correspond à une chaîne vide, mais
    correspond seulement quand certaines conditions spécifiques sont
    rencontrées. Une contrainte peut être utilisée là où un atome peut être
    utilisé, sauf qu'il ne peut pas être suivi d'un quantifieur. Les
    contraintes simples sont montrées dans <xref
    linkend="posix-constraints-table"/>&nbsp;; d'autres contraintes sont
    décrites après.
   </para>


   <table id="posix-atoms-table">
    <title>Atomes d'expression rationnelle</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Atome</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>(</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> (où <replaceable>re</replaceable> est toute expression
        rationnelle) établit une correspondance pour
        <replaceable>re</replaceable>, avec une correspondance notée pour une
        capture possible </entry>
      </row>

      <row>
       <entry> <literal>(?:</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>comme ci-dessus, mais la correspondance n'est pas notée pour une
        capture (un ensemble de parenthèses <quote>sans capture</quote>) (ARE
        seulement)</entry>
      </row>

      <row>
       <entry> <literal>.</literal> </entry>
       <entry>correspond à tout caractère individuel</entry>
      </row>

      <row>
       <entry> <literal>[</literal><replaceable>chars</replaceable><literal>]</literal> </entry>
       <entry>une <firstterm>expression entre crochets</firstterm>,
        correspondant à un des caractères parmi <replaceable>chars</replaceable>
        (voir <xref linkend="posix-bracket-expressions"/> pour plus de détails)
       </entry>
      </row>

      <row>
       <entry> <literal>\</literal><replaceable>k</replaceable> </entry>
       <entry>(où <replaceable>k</replaceable> est un caractère non
        alpha-numérique)
        correspond à ce caractère pris comme un caractère ordinaire,
        par exemple <literal>\\</literal> correspond à un caractère antislash</entry>
      </row>

      <row>
       <entry> <literal>\</literal><replaceable>c</replaceable> </entry>
       <entry>où <replaceable>c</replaceable> est un caractère alpha-numérique
        (potentiellement suivi par d'autres caractères)
        est un <firstterm>échappement</firstterm>, voir <xref
        linkend="posix-escape-sequences"/> (ARE seulement&nbsp;; pour les ERE
        et BRE, ceci correspond à <replaceable>c</replaceable>)</entry>
      </row>

      <row>
       <entry> <literal>{</literal> </entry>
       <entry>quand suivi par un caractère autre qu'un chiffre,
        correspond au caractère <literal>{</literal>&nbsp;;
        quand suivi d'un chiffre, c'est le début d'une
        <replaceable>limite</replaceable> (voir ci-dessous)</entry>
      </row>

      <row>
       <entry> <replaceable>x</replaceable> </entry>
       <entry>où <replaceable>x</replaceable> est un simple caractère
        sans signification particulière, correspond à ce caractère</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Un RE ne peut pas se terminer avec un antislash (<literal>\</literal>).
   </para>

   <note>
    <para>
     Si vous avez désactivé <xref linkend="guc-standard-conforming-strings"/>,
     tout antislash que vous écrivez dans des constantes de chaînes de
     caractères devra être doublé. Voir <xref linkend="sql-syntax-strings"/>
     pour plus d'informations.
    </para>
   </note>

   <table id="posix-quantifiers-table">
    <title>Quantifieur pour expression rationnelle</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Quantifieur</entry>
       <entry>Correspondance</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>*</literal> </entry>
       <entry> une séquence de 0 ou plus correspondances de l'atome </entry>
      </row>

      <row>
       <entry> <literal>+</literal> </entry>
       <entry> une séquence de 1 ou plus correspondances de l'atome </entry>
      </row>

      <row>
       <entry> <literal>?</literal> </entry>
       <entry> une séquence de 0 ou 1 correspondances de l'atome </entry>
      </row>

      <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}</literal> </entry>
       <entry> une séquence de exactement <replaceable>m</replaceable>
        correspondances de l'atome </entry>
      </row>

      <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> </entry>
       <entry> une séquence de <replaceable>m</replaceable> ou plus
        correspondances de l'atome </entry>
      </row>

      <row>
       <entry>
        <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> </entry>
       <entry> une séquence de <replaceable>m</replaceable> à
        <replaceable>n</replaceable> correspondances (nombre inclus) de
        l'atome&nbsp;; <replaceable>m</replaceable> ne peut pas dépasser
        <replaceable>n</replaceable> </entry>
      </row>

      <row>
       <entry> <literal>*?</literal> </entry>
       <entry> version non gourmande de <literal>*</literal> </entry>
      </row>

      <row>
       <entry> <literal>+?</literal> </entry>
       <entry> version non gourmande de <literal>+</literal> </entry>
      </row>

      <row>
       <entry> <literal>??</literal> </entry>
       <entry> version non gourmande de <literal>?</literal> </entry>
      </row>

      <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}?</literal> </entry>
       <entry> version non gourmande de <literal>{</literal><replaceable>m</replaceable><literal>}</literal> </entry>
      </row>

      <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}?</literal> </entry>
       <entry> version non gourmande de <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> </entry>
      </row>

      <row>
       <entry>
        <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal> </entry>
       <entry> version non gourmande de <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Les formes utilisant
    <literal>{</literal><replaceable>...</replaceable><literal>}</literal>
    sont connues comme des <firstterm>limites</firstterm>. Les nombres
    <replaceable>m</replaceable> et <replaceable>n</replaceable> d'une limite
    sont des entiers décimaux non signés avec des valeurs autorisées allant de
    0 à 255, valeurs comprises.
   </para>

   <para>
    Des quantifieurs non gourmands (<firstterm>Non-greedy</firstterm> en VO),
    disponibles uniquement dans les ARE, correspondent aux mêmes capacités
    que leur version gourmande correspondante
    (<firstterm>greedy</firstterm>), mais préfèrent le plus petit nombre
    plutôt que le plus grand nombre de correspondantes. Voir <xref
    linkend="posix-matching-rules"/> pour plus de détails.
   </para>

   <note>
    <para>
     Un quantifieur ne peut pas suivre immédiatement un autre quantifieur, par
     exemple <literal>**</literal> est invalide. Un quantifieur ne peut pas
     commencer une expression ou une sous-expression, ou suivre
     <literal>^</literal> ou <literal>|</literal>.
    </para>
   </note>

   <table id="posix-constraints-table">
    <title>Contraintes d'expression rationnelle</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Contrainte</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>^</literal> </entry>
       <entry> correspond au début de la chaîne </entry>
      </row>

      <row>
       <entry> <literal>$</literal> </entry>
       <entry> correspond à la fin de la chaîne </entry>
      </row>

      <row>
       <entry> <literal>(?=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> <firstterm>recherche en avance positive</firstterm> correspond à tout point
        où une sous-chaîne correspondant à
        <replaceable>re</replaceable> commence
        (ARE seulement) </entry>
      </row>

      <row>
       <entry> <literal>(?!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> <firstterm>recherche en avance négative</firstterm> correspond
        à tout point où aucune sous-chaîne correspondant à
        <replaceable>re</replaceable> commence (ARE seulement) </entry>
      </row>

      <row>
       <entry> <literal>(?&lt;=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> <firstterm>recherche en arrière positive</firstterm> correspond
        à tout point où une sous-chaîne correspondant à
        <replaceable>re</replaceable> termine (ARE seulement) </entry>
      </row>

      <row>
       <entry> <literal>(?&lt;!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> <firstterm>recherche en arrière négative</firstterm> correspond
        à tout point où aucune sous-chaîne correspondant à
        <replaceable>re</replaceable> termine (ARE seulement) </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Les contraintes de recherche en avant et de recherche en arrière ne
    peuvent pas contenir des <firstterm>références arrières</firstterm> (voir
    <xref linkend="posix-escape-sequences"/>), et toutes les parenthèses
    comprises en elles sont considérées comme non capturantes.
   </para>
  </sect3>

  <sect3 id="posix-bracket-expressions">
   <title>Expressions entre crochets</title>

   <para>
    Une <firstterm>expression entre crochets</firstterm> est une liste de
    caractères compris dans <literal>[]</literal>. Cela établit habituellement
    une correspondance avec tout caractère seul à partir de la liste (mais
    voir ci-dessous). Si la liste commence avec <literal>^</literal>, cela
    établit une correspondance avec tout caractère seul ne faisant
    <emphasis>pas</emphasis> parti de la liste. Si deux caractères de la liste
    sont séparés par un caractère <literal>-</literal>, c'est un raccourci
    pour l'intervalle complet de caractères entre ces deux caractères (en les
    incluant) dans la séquence, par exemple <literal>[0-9]</literal> en
    <acronym>ASCII</acronym> correspond à tout chiffre décimal. Il est illégal
    pour deux intervalles de partager la même limite finale, par exemple
    <literal>a-c-e</literal>. Les intervalles sont particulièrement dépendants
    de la collation, donc les programmes portables devraient éviter de se
    baser sur eux.
   </para>

   <para>
    Pour inclure un caractère <literal>]</literal> littéral dans la liste,
    faites-en le premier caractère (après <literal>^</literal>, si
    nécessaire). Pour inclure un <literal>-</literal> littéral, faites-en le
    premier ou dernier caractère, ou le deuxième point final d'un intervalle.
    Pour utiliser un <literal>-</literal> littéral comme premier point final
    d'un intervalle, placez le entre <literal>[.</literal> et
    <literal>.]</literal> pour en faire un élément d'assemblage (voir
    ci-dessous). À l'exception de ces caractères, certaines combinaisons
    utilisant <literal>[</literal> (voir les prochains paragraphes), et des
    échappements (ARE seulement), tous les autres caractères spéciaux perdent
    leur signification à l'intérieur d'une expression entre crochets. En
    particulier, <literal>\</literal> n'est pas spécial quand il suit les
    règles ERE et BRE, bien qu'il soit spécial (pour introduire un
    échappement) dans les ARE.
   </para>

   <para>
    À l'intérieur d'une expression entre crochets, un élément d'assemblage (un
    caractère, une séquence multi-caractères qui s'assemblent comme s'il
    s'agissait d'un seul caractère, ou un nom de séquence d'assemblage)
    englobé dans <literal>[.</literal> and <literal>.]</literal> signifie la
    séquence de caractères de cet élément d'assemblage. La séquence est
    traitée comme un seul élément de liste d'expression entre crochets. Ceci
    permet à une expression entre crochets contenant un élément d'assemblage
    multi-caractères de correspondre à plus d'un caractère. Par exemple, si la
    séquence d'assemblage inclut un élément d'assemblage
    <literal>ch</literal>, alors le RE <literal>[[.ch.]]*c</literal>
    correspond aux cinq premiers caractères de <literal>chchcc</literal>.
   </para>

   <note>
    <para>
     <productname>PostgreSQL</productname> n'accepte pas actuellement les
     éléments d'assemblage multi-caractères. Cette information décrit un
     comportement futur possible.
    </para>
   </note>

   <para>
    À l'intérieur d'une expression entre crochets, un élément d'assemblage
    compris entre <literal>[=</literal> et <literal>=]</literal> est une
    <firstterm>classe d'équivalence</firstterm>, représentant les séquences de
    caractères de tous les éléments d'assemblage équivalent à cette classe,
    incluant lui-même. (S'il n'existe pas d'autres éléments d'assemblage
    équivalents, le traitement est identique, comme si les délimiteurs étaient
    <literal>[.</literal> et <literal>.]</literal>.) Par exemple, si
    <literal>o</literal> et <literal>^</literal> sont les membres d'une classe
    d'équivalence, alors <literal>[[=o=]]</literal>,
    <literal>[[=^=]]</literal> et <literal>[o^]</literal> sont tous synonymes.
    Une classe d'équivalent ne peut pas être un point final d'un intervalle.
   </para>

   <para>
    À l'intérieur d'une expression entre crochets, le nom d'une classe de
    caractères entouré entre <literal>[:</literal> et <literal>:]</literal>
    signifie la liste de tous les caractères appartenant à cette classe. Une
    classe de caractères ne peut pas être utilisée comme point final d'un
    intervalle. Le standard <acronym>POSIX</acronym> définit les noms de ces
    classes de caractères&nbsp;:
    <literal>alnum</literal> (lettres et chiffres),
    <literal>alpha</literal> (lettres),
    <literal>blank</literal> (espace et tabulation),
    <literal>cntrl</literal> (caractères de contrôle),
    <literal>digit</literal> (chiffres),
    <literal>graph</literal> (caractères affichages, sauf l'espace),
    <literal>lower</literal> (lettres minuscules),
    <literal>print</literal> (caractères affichages, incluant l'espace),
    <literal>punct</literal> (ponctuation),
    <literal>space</literal> (tout espace blanc),
    <literal>upper</literal> (lettres majuscules),
    et <literal>xdigit</literal> (chiffres hexadécimaux).
    Le comportement de ces classes de caractères standards est généralement
    cohérent sur les plateformes pour les caractères de l'ensemble ASCII 7
    bits. Qu'un caractère non ASCII donné appartienne ou non à une de ces
    classes dépend de la <firstterm>collation</firstterm> utilisée par la
    fonction ou l'opérateur de l'expression rationnelle, (voir <xref
    linkend="collation"/>), ou par défaut de la locale indiquée par
    <envar>LC_CTYPE</envar> pour cette base (voir <xref linkend="locale"/>).
    La classification de caractères non ASCII peut varier entre les
    plateformes même pour des locales de nom similaire. (Mais la locale
    <literal>C</literal> ne considère jamais tout caractère non ASCII comme
    appartenant à une de ces classes.) En plus de ces classes de caractères
    standard, <productname>PostgreSQL</productname> définit la classe de
    caractères <literal>ascii</literal>, qui contient l'ensemble ASCII 7 bits
    exactement.
   </para>

   <para>
    Il existe deux cas spéciaux d'expressions entre crochets&nbsp;: les
    expressions entre crochets <literal>[[:&lt;:]]</literal> et
    <literal>[[:&gt;:]]</literal> sont des contraintes, correspondant à des
    chaînes vides au début et à la fin d'un mot caractère respectivement. Un
    mot est défini comme une séquence de mots qui n'est ni précédée ni suivie
    de mots. Un mot caractère est un caractère <literal>alnum</literal> (comme
    défini par la classe de caractères <acronym>POSIX</acronym> définie
    ci-dessus). C'est une extension, compatible avec, mais non spécifiée par
    <acronym>POSIX</acronym> 1003.2, et elle devrait être utilisée avec
    précaution dans les logiciels portables sur d'autres systèmes. Les
    échappements de contrainte décrits ci-dessous sont généralement
    préférables&nbsp;; ils ne sont pas plus standard mais plus simples à
    écrire.
   </para>
  </sect3>

  <sect3 id="posix-escape-sequences">
   <title>Échappements d'expression rationnelle</title>

   <para>
    Les <firstterm>échappements</firstterm> sont des séquences spéciales
    commençant avec <literal>\</literal> et suivies par un caractère
    alphanumérique. Les échappements sont de différents types&nbsp;: entrée de
    caractère, raccourci de classe, échappements de contrainte, et références.
    Un <literal>\</literal> suivi d'un caractère alphanumérique mais ne
    constituant pas un échappement valide est illégal dans les ARE. Dans le
    ERE, il n'y a pas d'échappement&nbsp;: en dehors d'une expression entre
    crochets, un <literal>\</literal> suivi d'un caractère alpha-numérique
    signifie ce caractère alors qu'à l'intérieur d'une expression entre
    crochets, <literal>\</literal> est un caractère standard. (Ce dernier est
    la seule incompatibilité entre ERE et ARE.)
   </para>

   <para>
    Les <firstterm>échappements d'entrée de caractère</firstterm> existent
    pour rendre plus simple l'ajout de caractères non affichables, ainsi que
    d'autres caractères désagréables à saisir dans les RE. Ils sont affichés
    dans <xref linkend="posix-character-entry-escapes-table"/>.
   </para>

   <para>
    Les <firstterm>échappements de raccourci de classe</firstterm> fournissent
    des raccourcis pour certaines classes de caractères fréquemment utilisées.
    Ils sont affichés dans <xref
    linkend="posix-class-shorthand-escapes-table"/>.
   </para>

   <para>
    Un <firstterm>échappement de contrainte</firstterm> est une contrainte,
    correspondant à la chaîne vide si des conditions spécifiques sont
    rencontrées, écrites comme un échappement. Ils sont affichés dans <xref
    linkend="posix-constraint-escapes-table"/>.
   </para>

   <para>
    Une <firstterm>référence</firstterm>
    (<literal>\</literal><replaceable>n</replaceable>) établit une
    correspondance de la même chaîne avec la sous-expression entre parenthèses
    précédente spécifiée par le numéro <replaceable>n</replaceable> (voir
    <xref linkend="posix-constraint-backref-table"/>). Par exemple,
    <literal>([bc])\1</literal> établit une correspondance avec
    <literal>bb</literal> et <literal>cc</literal>, mais pas
    <literal>bc</literal> et <literal>cb</literal>. La sous-expression doit
    précéder entièrement la référence dans le RE. Les sous-expressions sont
    numérotées dans l'ordre de leur parenthèses de début. Les parenthèses sans
    capture ne définissent pas de sous-expressions.
   </para>

   <table id="posix-character-entry-escapes-table">
    <title>Échappements d'entrée de caractère pour les expressions rationnelles
    </title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Échappement</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>\a</literal> </entry>
       <entry> caractère alerte (cloche), comme en C </entry>
      </row>

      <row>
       <entry> <literal>\b</literal> </entry>
       <entry> suppression, comme en C </entry>
      </row>

      <row>
       <entry> <literal>\B</literal> </entry>
       <entry> synonyme pour antislash (<literal>\</literal>) pour aider à
        réduire le doublement d'antislash </entry>
      </row>

      <row>
       <entry> <literal>\c</literal><replaceable>X</replaceable> </entry>
       <entry> (où <replaceable>X</replaceable> est tout caractère)
        le caractère dont les 5 bits de poids faible sont les mêmes que
        <replaceable>X</replaceable>, et dont tous les autres bits valent zéro
       </entry>
      </row>

      <row>
       <entry> <literal>\e</literal> </entry>
       <entry> le caractère donc le nom de séquence d'assemblage est
        <literal>ESC</literal>,
        ou, en dehors de cela, le caractère de valeur octale
        <literal>033</literal> </entry>
      </row>

      <row>
       <entry> <literal>\f</literal> </entry>
       <entry> form feed, comme en C </entry>
      </row>

      <row>
       <entry> <literal>\n</literal> </entry>
       <entry> nouvelle ligne, comme en C </entry>
      </row>

      <row>
       <entry> <literal>\r</literal> </entry>
       <entry> retour chariot, comme en C </entry>
      </row>

      <row>
       <entry> <literal>\t</literal> </entry>
       <entry> tabulation horizontale, comme en C </entry>
      </row>

      <row>
       <entry> <literal>\u</literal><replaceable>wxyz</replaceable> </entry>
       <entry> (où <replaceable>wxyz</replaceable> est exactement quatre
        chiffres hexadécimaux)
        le caractère dont la valeur hexadécimale est
        <literal>0x</literal><replaceable>wxyz</replaceable>
       </entry>
      </row>

      <row>
       <entry> <literal>\U</literal><replaceable>stuvwxyz</replaceable> </entry>
       <entry> (où <replaceable>stuvwxyz</replaceable> est exactement huit
        chiffres hexadécimaux)
        le caractère dont la valeur hexadécimale est
        <literal>0x</literal><replaceable>stuvwxyz</replaceable>
       </entry>
      </row>

      <row>
       <entry> <literal>\v</literal> </entry>
       <entry> tabulation verticale, comme en C </entry>
      </row>

      <row>
       <entry> <literal>\x</literal><replaceable>hhh</replaceable> </entry>
       <entry> (où <replaceable>hhh</replaceable> est toute séquence de
        chiffres hexadécimaux)
        le caractère dont la valeur hexadécimale est
        <literal>0x</literal><replaceable>hhh</replaceable>
        (un seul caractère, peu importe le nombre de chiffres hexadécimaux
        utilisés)
       </entry>
      </row>

      <row>
       <entry> <literal>\0</literal> </entry>
       <entry> le caractère dont la valeur est <literal>0</literal> (l'octet
        nul)</entry>
      </row>

      <row>
       <entry> <literal>\</literal><replaceable>xy</replaceable> </entry>
       <entry> (où <replaceable>xy</replaceable> est exactement deux chiffres octals,
        et n'est pas une <firstterm>référence</firstterm>)
        le caractère dont la valeur octale est
        <literal>0</literal><replaceable>xy</replaceable> </entry>
      </row>

      <row>
       <entry> <literal>\</literal><replaceable>xyz</replaceable> </entry>
       <entry> (où <replaceable>xyz</replaceable> est exactement trois chiffres
        octales, et n'est pas une <firstterm>référence</firstterm>)
        le caractère dont la valeur octale est
        <literal>0</literal><replaceable>xyz</replaceable> </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Les chiffres hexadécimaux sont <literal>0</literal>-<literal>9</literal>,
    <literal>a</literal>-<literal>f</literal> et <literal>A</literal>-<literal>F</literal>.
    Les chiffres octaux sont <literal>0</literal>-<literal>7</literal>.
   </para>

   <para>
    Les échappements d'entrés de caractères numériques spécifiant des valeurs
    en dehors de l'intervalle ASCII (0&ndash;127) ont des significations
    dépendantes de l'encodage de la base de données. Quand l'encodage est
    UTF-8, les valeurs d'échappement sont équivalents à des points code
    Unicode. Par exemple, <literal>\u1234</literal> signifie le caractère
    <literal>U+1234</literal>. Pour les autres encodages multi-octets, les
    échappements d'entrée de caractères spécifient habituellement juste la
    concaténation des valeurs d'octet pour le caractère. Si la valeur
    d'échappement ne correspond pas à tout caractère légale dans l'encodage de
    la base de données, aucune erreur ne sera levée, mais elle ne correspondra
    à aucune donnée.
   </para>

   <para>
    Les échappements d'entrée de classe sont toujours pris comme des caractères
    ordinaires. Par exemple, <literal>\135</literal> est <literal>]</literal> en ASCII, mais
    <literal>\135</literal> ne termine pas une expression entre crochets.
   </para>

   <table id="posix-class-shorthand-escapes-table">
    <title>Échappements de raccourci de classe pour les expressions
     rationnelles</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Échappement</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>\d</literal> </entry>
       <entry> <literal>[[:digit:]]</literal> </entry>
      </row>

      <row>
       <entry> <literal>\s</literal> </entry>
       <entry> <literal>[[:space:]]</literal> </entry>
      </row>

      <row>
       <entry> <literal>\w</literal> </entry>
       <entry> <literal>[[:alnum:]_]</literal>
        (notez que le tiret bas est inclus) </entry>
      </row>

      <row>
       <entry> <literal>\D</literal> </entry>
       <entry> <literal>[^[:digit:]]</literal> </entry>
      </row>

      <row>
       <entry> <literal>\S</literal> </entry>
       <entry> <literal>[^[:space:]]</literal> </entry>
      </row>

      <row>
       <entry> <literal>\W</literal> </entry>
       <entry> <literal>[^[:alnum:]_]</literal>
        (notez que le tiret bas est inclus) </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    À l'intérieur des expressions entre crochets, <literal>\d</literal>, <literal>\s</literal>
    et <literal>\w</literal> perdent leur crochet externe, alors que
    <literal>\D</literal>, <literal>\S</literal> et <literal>\W</literal> sont illégaux.
    (Donc, par exemple, <literal>[a-c\d]</literal> est équivalent à
    <literal>[a-c[:digit:]]</literal>.
    De plus, <literal>[a-c\D]</literal>, qui est équivalent à
    <literal>[a-c^[:digit:]]</literal>, est illégal.)
   </para>

   <table id="posix-constraint-escapes-table">
    <title>Échappements de contraintes pour les expressions rationnelles</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Échappement</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>\A</literal> </entry>
       <entry> correspond seulement au début de la chaîne
        (voir <xref linkend="posix-matching-rules"/> sur comment cela diffère
        de <literal>^</literal>) </entry>
      </row>

      <row>
       <entry> <literal>\m</literal> </entry>
       <entry> correspond seulement au début d'un mot </entry>
      </row>

      <row>
       <entry> <literal>\M</literal> </entry>
       <entry> correspond seulement à la fin d'un mot </entry>
      </row>

      <row>
       <entry> <literal>\y</literal> </entry>
       <entry> correspond seulement au début ou à la fin d'un mot </entry>
      </row>

      <row>
       <entry> <literal>\Y</literal> </entry>
       <entry> correspond seulement à un point qui n'est pas le début ou la
        fin d'un mot </entry>
      </row>

      <row>
       <entry> <literal>\Z</literal> </entry>
       <entry> correspond seulement à la fin de la chaîne
        (voir <xref linkend="posix-matching-rules"/> sur comment cela diffère
        de <literal>$</literal>) </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Un mot est défini comme dans la spécification de
    <literal>[[:&lt;:]]</literal> et <literal>[[:&gt;:]]</literal> ci-dessus.
    Les échappements de contrainte sont illégales à l'intérieur d'une expression
    entre crochets.
   </para>

   <table id="posix-constraint-backref-table">
    <title>Références d'expressions rationnelles</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Échappement</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>\</literal><replaceable>m</replaceable> </entry>
       <entry> (où <replaceable>m</replaceable> est un chiffre différent de zéro)
        une référence à la <replaceable>m</replaceable>-ième sous-expression </entry>
      </row>

      <row>
       <entry> <literal>\</literal><replaceable>mnn</replaceable> </entry>
       <entry> (où <replaceable>m</replaceable> est un chiffre différent de zéro,
        et <replaceable>nn</replaceable> est quelques chiffres, et la valeur décimale
        de <replaceable>mnn</replaceable> n'est pas supérieure au nombre de parenthèses fermantes capturantes vues jusqu'à maintenant)
        une référence à la <replaceable>mnn</replaceable>-ième sous-expression </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
    <para>
     Il existe une ambiguité inhérente entre les échappements d'entrée de
     caractères en octal et les références. Cette ambiguité est résolue avec
     les heuristiques suivantes, comme indiqué ci-dessus. Un zéro en début
     indique toujours un échappement octal. Un chiffre seul différent de zéro,
     qui n'est pas suivi par un autre chiffre est toujours pris pour une
     référence. Une séquence de plusieurs chiffres ne commençant pas par un
     zéro est pris pour une référence si elle survient après une
     sous-expression acceptable (c'est-à-dire que le numéro est dans
     l'intervalle légal pour une référence), et sinon est pris pour un octal.
    </para>
   </note>
  </sect3>

  <sect3 id="posix-metasyntax">
   <title>Méta-syntaxe des expressions rationnelles</title>

   <para>
    En plus de la syntaxe principale décrite ci-dessus, il existe des formes
    spéciales et des fonctionnalités syntaxiques diverses disponibles.
   </para>

   <para>
    Une RE peut commencer avec un des deux préfixes
    <firstterm>director</firstterm> spéciaux. Si une RE commence avec
    <literal>***:</literal>, le reste de la RE est prise pour une ARE. (Ceci
    n'a normalement aucun effet dans <productname>PostgreSQL</productname>,
    car les RE sont supposées être des ARE&nbsp;; mais cela a un effet si le
    mode ERE ou le mode BRE a été spécifié avec le paramètre
    <replaceable>flags</replaceable> dans une fonction d'expression
    rationnelle.) Si une RE commence avec <literal>***=</literal>, le reste de
    la RE est prise comme une chaîne littérale, tous les caractères étant
    considérés comme des caractères ordinaires.
   </para>

   <para>
    Une ARE peut commander avec des <firstterm>options
     intégrées</firstterm>&nbsp;: une séquence
    <literal>(?</literal><replaceable>xyz</replaceable><literal>)</literal>
    (où <replaceable>xyz</replaceable> est un ou plusieurs caractères
    alphabétiques) indique des options affectant le reste de la RE. Ces
    options surchargent toutes les options préalablement déterminées &mdash;
    en particulier, elles peuvent surcharger le comportement de sensibilité à
    la base impliqué par un opérateur d'expression rationnelle ou le paramètre
    <replaceable>flags</replaceable> d'une fonction d'expression rationnelle.
    Les lettres disponibles pour les options sont indiquées dans <xref
    linkend="posix-embedded-options-table"/>. Notez que ces mêmes lettres sont
    utilisées dans les paramètres <replaceable>flags</replaceable> des
    fonctions d'expression rationnelle.
   </para>

   <table id="posix-embedded-options-table">
    <title>Lettres pour options intégrées des ARE</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Option</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>b</literal> </entry>
       <entry> le reste de la RE est une BRE </entry>
      </row>

      <row>
       <entry> <literal>c</literal> </entry>
       <entry> correspondance sensible à la casse (surcharge le type d'opérateur) </entry>
      </row>

      <row>
       <entry> <literal>e</literal> </entry>
       <entry> le reste de la RE est une ERE </entry>
      </row>

      <row>
       <entry> <literal>i</literal> </entry>
       <entry> correspondance insensible à la casse (voir
        <xref linkend="posix-matching-rules"/>) (surcharge le type d'opérateur) </entry>
      </row>

      <row>
       <entry> <literal>m</literal> </entry>
       <entry> synonyme historique pour <literal>n</literal> </entry>
      </row>

      <row>
       <entry> <literal>n</literal> </entry>
       <entry> correspondance sensible à la nouvelle ligne  (voir
        <xref linkend="posix-matching-rules"/>) </entry>
      </row>

      <row>
       <entry> <literal>p</literal> </entry>
       <entry> correspondance partielle sensible à la nouvelle ligne (voir
        <xref linkend="posix-matching-rules"/>) </entry>
      </row>

      <row>
       <entry> <literal>q</literal> </entry>
       <entry> le reste de la RE est une chaîne littérale (<quote>entre
         guillemets</quote>), avec tous les caractères ordinaires
       </entry>
      </row>

      <row>
       <entry> <literal>s</literal> </entry>
       <entry> correspondance non sensible à la nouvelle ligne (par défaut) </entry>
      </row>

      <row>
       <entry> <literal>t</literal> </entry>
       <entry> syntaxe serrée (par défaut&nbsp;; voir ci-dessous) </entry>
      </row>

      <row>
       <entry> <literal>w</literal> </entry>
       <entry> correspondance partielle inverse à la nouvelle ligne
        (voir <xref linkend="posix-matching-rules"/>) </entry>
      </row>

      <row>
       <entry> <literal>x</literal> </entry>
       <entry> syntaxe étendue (voir ci-dessous) </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Les options intégrées prennent effet au <literal>)</literal> terminant la
    séquence. Elles peuvent apparaître seulement au début d'une ARE (après le
    directeur <literal>***:</literal> le cas échéant).
   </para>

   <para>
    En plus de l'habituelle syntaxe RE (<firstterm>serrée</firstterm>), dans
    laquelle tous les caractères sont signifiants, il existe une syntaxe
    <firstterm>étendue</firstterm>, disponible en spécifiant l'option étendue
    <literal>x</literal>. Dans la syntaxe étendue, les caractères d'espace
    blanc de la RE sont ignorés, comme le sont tous les caractères entre un
    <literal>#</literal> et la nouvelle ligne suivante (ou la fin de la RE).
    Ceci permet les paragraphes et les commentaires dans une RE complexe. Il
    existe trois exceptions à cette règle basique&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       un caractère espace blanc ou un <literal>#</literal> précédé par
       <literal>\</literal> est retenu
      </para>
     </listitem>
     <listitem>
      <para>
       un espace blanc ou un <literal>#</literal> dans une expression entre
       crochets est retenu
      </para>
     </listitem>
     <listitem>
      <para>
       un espace blanc et les commentaires ne peuvent pas apparaître avec les
       symboles multi caractères, tels que <literal>(?:</literal>
      </para>
     </listitem>
    </itemizedlist>

    Pour cela, les caractères d'espace blanc sont un blanc, une tabulation, un
    retour à la ligne et tout caractère qui appartient à la classe de
    caractères <replaceable>space</replaceable>.
   </para>

   <para>
    Enfin, dans une ARE, les expressions en dehors des crochets, la séquence
    <literal>(?#</literal><replaceable>ttt</replaceable><literal>)</literal>
    (où <replaceable>ttt</replaceable> est tout texte ne contenant pas
    <literal>)</literal>) est un commentaire, complètement ignoré. Encore une
    fois, ceci n'est pas autorisé entre les caractères des symboles
    multi-caractères, comme <literal>(?:</literal>. De tels commentaires sont
    plus un artéfact historique qu'une fonctionnalité utile, et leur
    utilisation est déconseillée&nbsp;; utilisez la syntaxe étendue à la
    place.
   </para>

   <para>
    <emphasis>Aucune</emphasis> de ces extensions de métasyntaxe n'est
    disponible si un directeur <literal>***=</literal> initial n'a spécifié
    que l'entrée de l'utilisateur doit être traitée comme une chaîne littérale
    plutôt que comme une RE.
   </para>
  </sect3>

  <sect3 id="posix-matching-rules">
   <title>Règles de correspondance des expressions rationnelles</title>

   <para>
    Dans le cas où une RE correspond à plus d'une sous-chaîne d'une chaîne
    donnée, la RE établit une correspondance avec la sous-chaîne la plus
    proche du début de la chaîne. Si la RE correspond à plus d'une sous-chaîne
    commençant à ce point, la correspondance conservée sera soit la plus
    longue, soir, la plus courte, suivant que la RE est gourmande
    (<firstterm>greedy</firstterm>) ou non
    (<firstterm>non-greedy</firstterm>).
   </para>

   <para>
    Le fait qu'une RE est gourmande ou non se détermine avec les règles
    suivantes&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       La plupart des atomes, et toutes les contraintes, n'ont pas d'attribut
       de gourmandise (parce qu'ils ne peuvent pas correspondre à des
       quantités variables de texte).
      </para>
     </listitem>
     <listitem>
      <para>
       Ajouter des parenthèses autour d'une RE ne modifie pas sa gourmandise.
      </para>
     </listitem>
     <listitem>
      <para>
       Un atome quantifié avec un quantifieur de répétition fixe
       (<literal>{</literal><replaceable>m</replaceable><literal>}</literal>
       ou
       <literal>{</literal><replaceable>m</replaceable><literal>}?</literal>)
       a la même gourmandise (potentiellement aucune) que l'atome lui-même.
      </para>
     </listitem>
     <listitem>
      <para>
       Un atome quantifié avec d'autres quantifieurs standards (incluant
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>
       avec <replaceable>m</replaceable> égal à <replaceable>n</replaceable>)
       est gourmand (il préfère la correspondance la plus longue).
      </para>
     </listitem>
     <listitem>
      <para>
       Un atome quantifié avec un quantifieur non gourmand (incluant
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal>
       avec <replaceable>m</replaceable> égal à <replaceable>n</replaceable>)
       est non gourmand (il préfère la correspondance la plus courte).
      </para>
     </listitem>
     <listitem>
      <para>
       Une branche &mdash; autrement dit, une RE qui n'a pas d'opérateur
       <literal>|</literal> hhaut niveau &mdash; a la même gourmandise que
       le premier atome quantifié qui a un attribut de gourmandise.
      </para>
     </listitem>
     <listitem>
      <para>
       Une RE consistant en deux ou plusieurs branches connectés par
       l'opérateur <literal>|</literal> est toujours gourmand.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Les règles ci-dessus associent les attributs de gourmandise non seulement
    aux atomes quantifiés individuels mais aussi aux branches et aux RE
    complets qui contiennent des atomes quantifiés. Cela signifie que la
    correspondance est faite de tel façon que la branche ou la RE complète
    correspondant à la sous-chaîne la plus longue ou la plus courte
    <emphasis>au complet</emphasis>. Une fois que la longueur de la
    correspondance entière est déterminée, la partie de celle-ci correspondant
    à une sous-expression particulière est déterminée sur la base de
    l'attribut de gourmandise de cette sous-expression, avec les
    sous-expressions commençant plus tôt dans la RE prenant priorité sur les
    autres.
   </para>

   <para>
    Un exemple de ce que cela signifie&nbsp;:
    <screen>
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<lineannotation>Résultat : </lineannotation><computeroutput>123</computeroutput>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<lineannotation>Résultat : </lineannotation><computeroutput>1</computeroutput>
    </screen>
    Dans le premier cas, la RE complète est gourmande parce que
    <literal>Y*</literal> est gourmand. Elle peut correspondance en commençant
    au <literal>Y</literal>, et elle correspond à la chaîne la plus longue
    commençant là, donc <literal>Y123</literal>. La sortie est la partie entre
    parenthèse, ou <literal>123</literal>. Dans le deuxième cas, la RE
    complète est non gourmande parce que <literal>Y*?</literal> est non
    gourmande.  Elle peut correspondre en commençant à <literal>Y</literal>,
    et elle correspond à la chaîne laplus courte possible commençant là, donc
    <literal>Y1</literal>. La sous-expression <literal>[0-9]{1,3}</literal>
    est gourmande mais elle ne peut pas modifier la décision sur la longue de
    la correspondance&nbsp;; donc elle est forcée à une correspondance sur
    simplement <literal>1</literal>.
   </para>

   <para>
    En court, quand une RE contient des sous-expressions gourmandes et non
    gourmandes, la longueur de correspondance totale est soit aussi longue ou
    aussi courte que possible, suivant l'attribut affecté à la RE complète.
    Les attributs affectés aux sous-expressions affectent seulement la
    quantité de correspondance qu'elles sont autorisées de
    <quote>manger</quote> par rapport aux autres.
   </para>

   <para>
    Les quantifieurs <literal>{1,1}</literal> et <literal>{1,1}?</literal>
    peuvent être utilisés pour forcer la gourmandise ou la non gourmandise,
    respectivement, d'une sous-expression ou de la RE complète. Ceci est utile
    quand vous avez que la RE complète contienne un attribut de gourmandise
    différent de celui déduit de ces éléments. Comme exemple, supposez que
    nous essayons de séparer une chaîne contenant quelques chiffres dans les
    chiffres et les parties avant et après eux. Nous pourrions essayer de le
    faire ainsi&nbsp;:
    <screen>
SELECT regexp_match('abc01234xyz', '(.*)(\d+)(.*)');
<lineannotation>Résultat : </lineannotation><computeroutput>{abc0123,4,xyz}</computeroutput>
    </screen>
    Cela n'a pas fonctionné&nbsp;: le premier <literal>.*</literal> est
    gourmand donc il <quote>mange</quote> autant qu'il peut, laissant le
    <literal>\d+</literal> correspondre à la dernière place possible, le
    dernier chiffre. Nous pourrions essayer de corriger cela en le rendant non
    gourmand&nbsp;:
    <screen>
SELECT regexp_match('abc01234xyz', '(.*?)(\d+)(.*)');
<lineannotation>Résultat : </lineannotation><computeroutput>{abc,0,""}</computeroutput>
    </screen>
    Ceci n'a pas fonctionné non plus parce que, maintenant, la RE entière est
    non gourmande et donc, elle termine la correspondance globale aussi tôt
    que possible. Nous pouvons obtenir ce que vous voulons en forçant la RE
    entière à être gourmande&nbsp;:
    <screen>
SELECT regexp_match('abc01234xyz', '(?:(.*?)(\d+)(.*)){1,1}');
<lineannotation>Résultat : </lineannotation><computeroutput>{abc,01234,xyz}</computeroutput>
    </screen>
    Contrôler la gourmandise globale de la RE séparément de la gourmandise de
    ses composants donne plus de flexibilité dans la gestion des motifs de
    longueur variable.
   </para>

   <para>
    Lors de la décision sur ce qui est une correspondance longue ou courte,
    les longueurs des correspondances sont mesurés en caractères, pas en
    éléments. Toute chaîne vide est considérée plus longue qu'aucune
    correspondance. Par exemple&nbsp;: <literal>bb*</literal> correspond au
    trois caractères du milieu de <literal>abbbc</literal>&nbsp;;
    <literal>(week|wee)(night|knights)</literal> correspond aux dix caractères
    de <literal>weeknights</literal>&nbsp;; quand <literal>(.*).*</literal>
    est comparé à <literal>abc</literal>, la sous-expression entre parenthèses
    correspond aux trois caractères&nbsp;; et quand <literal>(a*)*</literal>
    est comparé à <literal>bc</literal>, la RE complète et la sous-expression
    entre parenthèses correspond à une chaîne vide.
   </para>

   <para>
    Si une correspondance indépendante à la casse est demandée, l'effet est
    comme si toutes les distinctions de casse disparaissaient de l'alphabet.
    Quand un caractère alphabétique qui existe dans plusieurs casses apparaît
    comme un caractère ordinaire en dehors d'une expression entre crochets, il
    est en fait transformé en une expression entre crochets contenant les deux
    casses, par exemple <literal>x</literal> devient <literal>[xX]</literal>.
    Quand il apparaît dans une expression entre crochets, toutes les casses
    sont ajoutées dans l'expression entre crochets, par exemple
    <literal>[x]</literal> devient <literal>[xX]</literal> et
    <literal>[^x]</literal> devient <literal>[^xX]</literal>.
   </para>

   <para>
    Si une correspondance sensible aux nouvelles lignes est spécifiée,
    <literal>.</literal> et les expressions entre crochets utilisant
    <literal>^</literal> ne correspondront jamais au caractère de nouvelle
    ligne (pour que les correspondances ne croissent jamais les nouvelles
    lignes sauf si la RE le fait explicitement) et <literal>^</literal> et
    <literal>$</literal> correspondront à la chaîne vide respectivement après
    et avant une nouvelle ligne,en plus d'une correspondance en début et en
    fin de chaîne respectivement. Cependant, les échappements d'ARE
    <literal>\A</literal> et <literal>\Z</literal> continuent de correspondre
    <emphasis>seulement</emphasis> au début et à la fin de chaine.
   </para>

   <para>
    Si la correspondance partielle sensible aux nouvelles lignes est
    spécifiée, ceci affecte <literal>.</literal> et les expressions entre
    crochets comme avec la correspondance sensible à la nouvelle ligne, mais
    pas à <literal>^</literal> et <literal>$</literal>.
   </para>

   <para>
    Si la correspondance partielle inverse sensible aux nouvelles lignes est
    spécifiée, ceci affecte <literal>^</literal> et <literal>$</literal> comme
    avec la correspondance sensible aux nouvelles lignes, mais pas à
    <literal>.</literal> et aux expressions entre crochets. Ceci n'est pas
    très utile mais est fourni pour la symétrie.
   </para>
  </sect3>

  <sect3 id="posix-limits-compatibility">
   <title>Limites et Compatibilités</title>

   <para>
    Aucune limite particulière n'est imposée sur la longueur des RE dans cette
    implémentation. Néanmoins, les programmes hautement portablees ne
    devraient pas employer des RE plus longs que 256 octets, car une
    implémentation compatible POSIX peut refuser de telles RE.
   </para>

   <para>
    La seule fonctionnalité des ARE actuellement incompatible avec les ERE
    POSIX est que <literal>\</literal> ne perd pas sa signification spéciale à
    l'intérieur des expressions entre crochets. Toutes les autres
    fonctionnalités ARE utilisent une syntaxe illégale ou a des effets non
    définis ou spécifiés dans les ERE POSIX&nbsp;; la syntaxe
    <literal>***</literal> des directeurs est en dehors de la syntaxe POSIX
    pour les BRE et les ERE.
   </para>

   <para>
    Beaucoup d'extensions ARE sont empruntés de Perl, mais certaines ont été
    modifiées pour les nettoyer, et quelques extensions Perl ne sont pas
    présentes. Les incompatibilités de note incluent <literal>\b</literal>,
    <literal>\B</literal>, le manque de traitement spécial pour une nouvelle
    ligne en fin, l'addition des expressions entre crochets complémentées, les
    restrictions sur les parenthèses et des références inverses dans les
    contraintes lookahead/lookbehind et les sémantiques de correspondance pour
    la correspondance la plus longue/courte (plutôt que la première
    correspondance).
   </para>

   <para>
    Deux incompatibilités signifiantes existent entre les syntaxes ARE et ERE
    reconnues par les versions de <productname>PostgreSQL</productname>
    antérieures à la 7.4&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       Dans les ARE, <literal>\</literal> suivi par un caractère
       alphanumérique est soit un échappement ou une erreur, alors que dans
       les versions précédentes, il s'agit juste d'une autre façon pour écrire
       l'alphanumérique. Ceci ne doit pas être particulièrement le même
       problème car il n'existe pas de raisons pour écrire une séquence de
       cette façon dans les versions précédentes.
      </para>
     </listitem>
     <listitem>
      <para>
       Dans les ARE, <literal>\</literal> reste un caractère special à
       l'intérieur des <literal>[]</literal>, donc un <literal>\</literal>
       littéral dans une expression entre crochet doit être écrit
       <literal>\\</literal>.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect3>

  <sect3 id="posix-basic-regexes">
   <title>Expressions rationnelles basiques</title>

   <para>
    Les BRE diffèrent des ERE dans différents aspects. Dans les BRE,
    <literal>|</literal>, <literal>+</literal> et <literal>?</literal> sont
    des caractères ordinaires et il n'existe pas d'équivalent à leur
    fonctionnalité. Les BRE diffèrent des ERE dans différents aspects. Dans
    les BRE, <literal>|</literal>, <literal>+</literal> et
    <literal>?</literal> sont des caractères ordinaires et il n'existe pas
    d'équivalent à leur fonctionnalité. Les délimiteurs des limites sont
    <literal>\{</literal> et <literal>\}</literal>. Les parenthèses pour les
    sous-expressions imbriquées sont <literal>\(</literal> and
    <literal>\)</literal>, with <literal>(</literal> et <literal>)</literal>.
    <literal>^</literal> est un caractère ordinaire, sauf en début de la RE ou
    au commencement de la sous-expression entre parenthèses,
    <literal>$</literal> est un caractère standard sauf en fin de RE ou en fin
    d'une sous-expression entre parenthèses, et <literal>*</literal> est un
    caractère standard s'il apparaît au début de la RE ou au début de la
    sous-expression entre parenthèses (après potentiellement un
    <literal>^</literal>). Enfin, les références inverses d'un simple chiffre
    sont disponibles, et <literal>\&lt;</literal> et <literal>\&gt;</literal>
    sont des synonymes pour, respectivement, <literal>[[:&lt;:]]</literal> and
    <literal>[[:&gt;:]]</literal>&nbsp; aucun autre échappement n'est
    dispn,ible dans le BRE.
   </para>
  </sect3>

  <!-- end re_syntax.n man page -->

  <sect3 id="posix-vs-xquery">
   <title>Différences de XQuery (<literal>LIKE_REGEX</literal>)</title>

   <indexterm zone="posix-vs-xquery">
    <primary><literal>LIKE_REGEX</literal></primary>
   </indexterm>

   <indexterm zone="posix-vs-xquery">
    <primary>expressions rationnelles XQuery</primary>
   </indexterm>

   <para>
    Depuis SQL:2008, le standard SQL inclut un opérateur
    <literal>LIKE_REGEX</literal> qui réalise de la correspondance de motif
    suivant le standard d'expression rationnelle XQuery.
    <productname>PostgreSQL</productname> n'implémente pas encore cet
    opérateur, mais vous pouvez obtenir un comportement très similaire en
    utilisant la fonction <function>regexp_match()</function>, car les
    expressions rationnelles de XQuery sont très proches de la syntaxe ARE
    décrite ci-dessus.
   </para>

   <para>
    Les différences notables entre la fonctionnalité existante d'expressions
    rationnelles POSIX et les expressions rationnelles XQuery incluent&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       La soustraction de classe d'opérateur XQuery n'est pas supportée. Un
       exemple de cette fonctionnalité est l'utilisation de la syntaxe
       suivante pour établir une correspondance avec uniquement des consonnes
       anglaises&nbsp;: <literal>[a-z-[aeiou]]</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       Les raccourcis de classe de caractères XQuery <literal>\c</literal>,
       <literal>\C</literal>, <literal>\i</literal>
       et <literal>\I</literal> ne sont pas supportés.
      </para>
     </listitem>
     <listitem>
      <para>
       Les éléments de classe de caractères XQuery utilisant
       <literal>\p{UnicodeProperty}</literal> ou l'inverse
       <literal>\P{UnicodeProperty}</literal> ne sont pas supportés.
      </para>
     </listitem>
     <listitem>
      <para>
       POSIX interprète les classes de caractères telles que
       <literal>\w</literal> (voir <xref
       linkend="posix-class-shorthand-escapes-table"/>) suivant la locale
       prévalente (que vous pouvez contrôler en attachant une clause
       <literal>COLLATE</literal> à l'opérateur ou la fonction). XQuery
       spécifie ces classes par référence aux propriétés de caractères
       Unicode, donc le comportement équivalent est obtenu seulement avec une
       locale qui suit les règles Unicode.
      </para>
     </listitem>
     <listitem>
      <para>
       Le standard SQL (pas XQuery lui-même) tente de répondre à plus de
       variantes de <quote>newline</quote> que POSIX. Les options de
       correspondance pour la sensibilité aux nouvelles lignes décrites
       ci-dessus considèrent seulement le code ASCII NL
       (<literal>\n</literal>) cmme étant une nouvelle ligne, mais SQL
       souhaiterait que nous traitions CR (<literal>\r</literal>), CRLF
       (<literal>\r\n</literal>) (une nouvelle ligne pour Windows), et
       certains caractères uniquement Unicode comme LINE SEPARATOR (U+2028)
       en tant que nouvelles lignes. Par exemple, <literal>.</literal> et
       <literal>\s</literal> peut compter <literal>\r\n</literal> comme un
       seul caractère, et non pas deux, suivant le SQL.
      </para>
     </listitem>
     <listitem>
      <para>
       Des échappements d'entrée de caractères décrits dans
       <xref linkend="posix-character-entry-escapes-table"/>,
       XQuery supporte seulement <literal>\n</literal>, <literal>\r</literal>
       et <literal>\t</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       XQuery ne supporte pas la syntaxe
       <literal>[:<replaceable>name</replaceable>:]</literal> pour les
       classes de caractères dans des expressions entre crochets.
      </para>
     </listitem>
     <listitem>
      <para>
       XQuery n'a pas de contraintes lookahead et lookbehind, ni aucun des
       échappements de contraintes décrits dans <xref
       linkend="posix-constraint-escapes-table"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       Les formes de métasyntaxe décrites dans <xref linkend="posix-metasyntax"/>
       n'existe pas dans XQuery.
      </para>
     </listitem>
     <listitem>
      <para>
       Les lettres drapeaux des expressions rationnelles définis par XQuery
       sont en relation mais pas identique aux lettres options pour POSIX
       (<xref linkend="posix-embedded-options-table"/>). Bien que les options
       <literal>i</literal> and <literal>q</literal> se comportent de la même
       façon, les autres ne le font pas&nbsp;:
       <itemizedlist>
        <listitem>
         <para>
          Les drapeaux <literal>s</literal> (permet à un point de
          correspondre à une nouvelle ligne) et <literal>m</literal>
          (autorise <literal>^</literal> et <literal>$</literal> à
          correspondre à de nouvelles lignes) de XQuery donnent accès aux
          mêmes comportements que les drapeaux <literal>n</literal>,
          <literal>p</literal> et <literal>w</literal> de POSIX, mais ils ne
          correspondent <emphasis>pas</emphasis> au comportement des drapeaux
          <literal>s</literal> et <literal>m</literal> de POSIX. Notez en
          particulier que le point-correspondant-nouvelle-ligne est le
          comportement par défaut de POSIX mais pas de XQuery.
         </para>
        </listitem>
        <listitem>
         <para>
          Le drapeau <literal>x</literal> de XQuery (ignore les espaces
          blancs dans le motif) est bien différent du drapeau mode étendu de
          POSIX. Le drapeau <literal>x</literal> de POSIX permet en plus à
          <literal>#</literal> de commencer un commentaire dans le motif, et
          POSIX n'ignorera pas un caractère espace blanc après un antislash.
         </para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
    </itemizedlist>
   </para>

  </sect3>
 </sect2>
</sect1>


<sect1 id="functions-formatting">
 <title>Fonctions de formatage de type de données</title>

 <indexterm>
  <primary>formatage</primary>
 </indexterm>

 <para>
  Les fonctions de formatage de <productname>PostgreSQL</productname>
  forment un ensemble puissant d'outils pour convertir différents types de
  données (date/heure, entier, nombre à virgule flottante, numérique) vers
  des chaînes formatées et pour convertir de chaînes formatées vers des
  types de données spécifiques. <xref linkend="functions-formatting-table"/>
  les liste. Ces fonctions suivent toutes une même convention de
  nommage&nbsp;: le premier argument est la valeur à formater et le second
  argument est un modèle qui définit le format de sortie ou d'entrée.
 </para>

 <table id="functions-formatting-table">
  <title>Fonctions de formatage</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>to_char</primary>
       </indexterm>
       <function>to_char</function> ( <type>timestamp</type>, <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para role="func_signature">
       <function>to_char</function> ( <type>timestamp with time zone</type>, <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Convertit une donnée de type timestamp en une chaîne suivant le format
       indiqué.
      </para>
      <para>
       <literal>to_char(timestamp '2002-04-20 17:31:12.66', 'HH12:MI:SS')</literal>
       <returnvalue>05:31:12</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>to_char</function> ( <type>interval</type>, <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Convertit un intervalle en une chaîne suivant le format indiqué.
      </para>
      <para>
       <literal>to_char(interval '15h 2m 12s', 'HH24:MI:SS')</literal>
       <returnvalue>15:02:12</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>to_char</function> ( <replaceable>numeric_type</replaceable>, <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Convertit un nombre en une chaîne suivant le format indiqué. Disponible
       pour les types <type>integer</type>, <type>bigint</type>, <type>numeric</type>,
       <type>real</type>, <type>double precision</type>.
      </para>
      <para>
       <literal>to_char(125, '999')</literal>
       <returnvalue>125</returnvalue>
      </para>
      <para>
       <literal>to_char(125.8::real, '999D9')</literal>
       <returnvalue>125.8</returnvalue>
      </para>
      <para>
       <literal>to_char(-125.8, '999D99S')</literal>
       <returnvalue>125.80-</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>to_date</primary>
       </indexterm>
       <function>to_date</function> ( <type>text</type>, <type>text</type> )
       <returnvalue>date</returnvalue>
      </para>
      <para>
       Convertit une chaîne en date suivant le format indiqué.
      </para>
      <para>
       <literal>to_date('05 Dec 2000', 'DD Mon YYYY')</literal>
       <returnvalue>2000-12-05</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>to_number</primary>
       </indexterm>
       <function>to_number</function> ( <type>text</type>, <type>text</type> )
       <returnvalue>numeric</returnvalue>
      </para>
      <para>
       Convertit une chaîne en type numeric suivant le format indiqué.
      </para>
      <para>
       <literal>to_number('12,454.8-', '99G999D9S')</literal>
       <returnvalue>-12454.8</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>to_timestamp</primary>
       </indexterm>
       <function>to_timestamp</function> ( <type>text</type>, <type>text</type> )
       <returnvalue>timestamp with time zone</returnvalue>
      </para>
      <para>
       Convertit une chaîne en type timestamp suivant le format indiqué.
       (Voir aussi <function>to_timestamp(double precision)</function> dans
       <xref linkend="functions-datetime-table"/>.)
      </para>
      <para>
       <literal>to_timestamp('05 Dec 2000', 'DD Mon YYYY')</literal>
       <returnvalue>2000-12-05 00:00:00-05</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <tip>
  <para>
   <function>to_timestamp</function> et <function>to_date</function>
   existent pour gérer les formats en entrée qui ne peuvent être convertis
   par une simple conversion. Pour les formats plus standards de date/heure,
   convertir simplement la chaîne source dans le type de données requis
   fonctionne, et est plus simple. De façon similaire,
   <function>to_number</function> n'est pas nécessaire pour les
   représentations standards en type numeric.
  </para>
 </tip>

 <para>
  Dans une chaîne modèle de sortie pour <function>to_char</function>, il
  existe certains motifs reconnus et remplacés avec les données formatées de
  façon appropriée basées sur la valeur donnée. Tout texte qui n'est pas un
  motif modèle est simplement copié directement. De façon similaire, dans
  une chaîne modèle en entrée (pour les autres fonctions), les motifs
  modèles identifient les valeurs à fournir par la chaîne de données en
  entrée. S'il existe des caractères dans la chaîne modèle qui ne sont pas
  des motifs modèles, les caractères correspondants dans la chaîne de
  données en entrée sont simplement ignorés (qu'ils soient égaux ou non aux
  caractères de la chaîne modèle).
 </para>

 <para>
  <xref linkend="functions-formatting-datetime-table"/> affiche les motifs
  modèles disponibles pour le formatage des valeurs date et heure.
 </para>

 <table id="functions-formatting-datetime-table">
  <title>Motifs modèles pour le formatage date/heure</title>
  <tgroup cols="2">
   <thead>
    <row>
     <entry>Motif</entry>
     <entry>Description</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>HH</literal></entry>
     <entry>heure du jour (01&ndash;12)</entry>
    </row>
    <row>
     <entry><literal>HH12</literal></entry>
     <entry>heure du jour (01&ndash;12)</entry>
    </row>
    <row>
     <entry><literal>HH24</literal></entry>
     <entry>heure du jour (00&ndash;23)</entry>
    </row>
    <row>
     <entry><literal>MI</literal></entry>
     <entry>minute (00&ndash;59)</entry>
    </row>
    <row>
     <entry><literal>SS</literal></entry>
     <entry>seconde (00&ndash;59)</entry>
    </row>
    <row>
     <entry><literal>MS</literal></entry>
     <entry>milliseconde (000&ndash;999)</entry>
    </row>
    <row>
     <entry><literal>US</literal></entry>
     <entry>microseconde (000000&ndash;999999)</entry>
    </row>
    <row>
     <entry><literal>FF1</literal></entry>
     <entry>dixième de seconde (0&ndash;9)</entry>
    </row>
    <row>
     <entry><literal>FF2</literal></entry>
     <entry>centième de seconde (00&ndash;99)</entry>
    </row>
    <row>
     <entry><literal>FF3</literal></entry>
     <entry>milliseconde (000&ndash;999)</entry>
    </row>
    <row>
     <entry><literal>FF4</literal></entry>
     <entry>dixième de milliseconde (0000&ndash;9999)</entry>
    </row>
    <row>
     <entry><literal>FF5</literal></entry>
     <entry>centième de milliseconde (00000&ndash;99999)</entry>
    </row>
    <row>
     <entry><literal>FF6</literal></entry>
     <entry>microseconde (000000&ndash;999999)</entry>
    </row>
    <row>
     <entry><literal>SSSS</literal>, <literal>SSSSS</literal></entry>
     <entry>secondes après minuit (0&ndash;86399)</entry>
    </row>
    <row>
     <entry><literal>AM</literal>, <literal>am</literal>,
      <literal>PM</literal> ou <literal>pm</literal></entry>
     <entry>indicateur de méridien (sans points)</entry>
    </row>
    <row>
     <entry><literal>A.M.</literal>, <literal>a.m.</literal>,
      <literal>P.M.</literal> or <literal>p.m.</literal></entry>
     <entry>indicateur de méridien (avec points)</entry>
    </row>
    <row>
     <entry><literal>Y,YYY</literal></entry>
     <entry>année (4 chiffres ou plus) avec virgule</entry>
    </row>
    <row>
     <entry><literal>YYYY</literal></entry>
     <entry>année (4 chiffres ou plus)</entry>
    </row>
    <row>
     <entry><literal>YYY</literal></entry>
     <entry>3 derniers chiffres de l'année</entry>
    </row>
    <row>
     <entry><literal>YY</literal></entry>
     <entry>2 derniers chiffres de l'année</entry>
    </row>
    <row>
     <entry><literal>Y</literal></entry>
     <entry>dernier chiffre de l'année</entry>
    </row>
    <row>
     <entry><literal>IYYY</literal></entry>
     <entry>année, numérotation ISO 8601 (4 chiffres ou plus)</entry>
    </row>
    <row>
     <entry><literal>IYY</literal></entry>
     <entry>3 derniers chiffres de l'année, numérotation ISO 8601</entry>
    </row>
    <row>
     <entry><literal>IY</literal></entry>
     <entry>2 derniers chiffres de l'année, numérotation ISO 8601</entry>
    </row>
    <row>
     <entry><literal>I</literal></entry>
     <entry>dernier chiffre de l'année, numérotation ISO 8601</entry>
    </row>
    <row>
     <entry><literal>BC</literal>, <literal>bc</literal>,
      <literal>AD</literal> ou <literal>ad</literal></entry>
     <entry>indicateur d'ère (sans points)</entry>
    </row>
    <row>
     <entry><literal>B.C.</literal>, <literal>b.c.</literal>,
      <literal>A.D.</literal> ou <literal>a.d.</literal></entry>
     <entry>indicateur d'ère (avec points)</entry>
    </row>
    <row>
     <entry><literal>MONTH</literal></entry>
     <entry>nom du mois en majuscule (sur 9 caractères)</entry>
    </row>
    <row>
     <entry><literal>Month</literal></entry>
     <entry>nom du mois en majuscule (sur 9 caractères)</entry>
    </row>
    <row>
     <entry><literal>month</literal></entry>
     <entry>nom du mois en minuscule (sur 9 caractères)</entry>
    </row>
    <row>
     <entry><literal>MON</literal></entry>
     <entry>abréviation du nom du mois en majuscule (3 caractères en anglais, peut varier ailleurs)</entry>
    </row>
    <row>
     <entry><literal>Mon</literal></entry>
     <entry>abréviation du nom du mois capitalisé (3 caractères en anglais, peut varier ailleurs)</entry>
    </row>
    <row>
     <entry><literal>mon</literal></entry>
     <entry>abréviation du nom du mois en minuscule (3 caractères en anglais, peut varier ailleurs)</entry>
    </row>
    <row>
     <entry><literal>MM</literal></entry>
     <entry>numéro du mois (01&ndash;12)</entry>
    </row>
    <row>
     <entry><literal>DAY</literal></entry>
     <entry>nom du jour en majuscule (sur 9 caractères)</entry>
    </row>
    <row>
     <entry><literal>Day</literal></entry>
     <entry>nom du jour en majuscule (sur 9 caractères)</entry>
    </row>
    <row>
     <entry><literal>day</literal></entry>
     <entry>nom du jour en minuscule (sur 9 caractères)</entry>
    </row>
    <row>
     <entry><literal>DY</literal></entry>
     <entry>abréviation du nom du jour en majuscule (3 caractères en anglais, peut varier ailleurs)</entry>
    </row>
    <row>
     <entry><literal>Dy</literal></entry>
     <entry>abréviation du nom du jour capitalisé (3 caractères en anglais, peut varier ailleurs)</entry>
    </row>
    <row>
     <entry><literal>dy</literal></entry>
     <entry>abréviation du nom du jour en minuscule (3 caractères en anglais, peut varier ailleurs)</entry>
    </row>
    <row>
     <entry><literal>DDD</literal></entry>
     <entry>jour de l'année (001&ndash;366)</entry>
    </row>
    <row>
     <entry><literal>IDDD</literal></entry>
     <entry>jour de l'année, d'après le standard ISO 8601 (001&ndash;371&nbsp;;
      la journée 1 de l'année est le lundi de la première semaine ISO)</entry>
    </row>
    <row>
     <entry><literal>DD</literal></entry>
     <entry>jour du mois (01&ndash;31)</entry>
    </row>
    <row>
     <entry><literal>D</literal></entry>
     <entry>jour de la semaine, de dimanche (<literal>1</literal>) à samedi (<literal>7</literal>)</entry>
    </row>
    <row>
     <entry><literal>ID</literal></entry>
     <entry>jour de la semaine d'après le standard ISO 8601, de lundi (<literal>1</literal>) à dimanche (<literal>7</literal>)</entry>
    </row>
    <row>
     <entry><literal>W</literal></entry>
     <entry>numéro de semaine du mois (1&ndash;5) (la première semaine commence le premier jour du mois)</entry>
    </row>
    <row>
     <entry><literal>WW</literal></entry>
     <entry>numéro de semaine de l'année (1&ndash;53) (la première semaine commence le premier jour de l'année)</entry>
    </row>
    <row>
     <entry><literal>IW</literal></entry>
     <entry>numéro de semaine de l'année, d'après le standard ISO 8601 (01&ndash;53&nbsp;; le premier jeudi de l'année est en semaine 1)</entry>
    </row>
    <row>
     <entry><literal>CC</literal></entry>
     <entry>siècle (2 chiffres) (le 21è siècle commence le 1er janvier 2001)</entry>
    </row>
    <row>
     <entry><literal>J</literal></entry>
     <entry>jour Julien (nombre de jours depuis le 24 novembre, 4714 avant JC à minuit UTC)</entry>
    </row>
    <row>
     <entry><literal>Q</literal></entry>
     <entry>quartier</entry>
    </row>
    <row>
     <entry><literal>RM</literal></entry>
     <entry>mois en majuscules suivant la convention romaine (I&ndash;XII; I=janvier)</entry>
    </row>
    <row>
     <entry><literal>rm</literal></entry>
     <entry>mois en minuscules suivant le convention romaine (i&ndash;xii; i=janvier)</entry>
    </row>
    <row>
     <entry><literal>TZ</literal></entry>
     <entry>abréviation du fuseau horaire, en majuscule
      (supporté uniquement avec <function>to_char</function>)</entry>
    </row>
    <row>
     <entry><literal>tz</literal></entry>
     <entry>abréviation du fuseau horaire, en minuscule
      (supporté uniquement avec <function>to_char</function>)</entry>
    </row>
    <row>
     <entry><literal>TZH</literal></entry>
     <entry>heures du fuseau horaire</entry>
    </row>
    <row>
     <entry><literal>TZM</literal></entry>
     <entry>minutes du fuseau horaire</entry>
    </row>
    <row>
     <entry><literal>OF</literal></entry>
     <entry>décalage du fuseau horaire à partir d'UTC
      (supporté uniquement avec <function>to_char</function>)</entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
  Les modificateurs peuvent être appliqués à tous les motifs modèles pour
  modifier leurs comportements. Par exemple, <literal>FMMonth</literal>
  est le motif <literal>Month</literal> avec le modificateur
  <literal>FM</literal>.
  <xref linkend="functions-formatting-datetimemod-table"/> affiche les motifs
  de modificateur pour le formatage date/heure.
 </para>

 <table id="functions-formatting-datetimemod-table">
  <title>Modificateurs des motifs modèles pour le formatage date/heure</title>
  <tgroup cols="3">
   <thead>
    <row>
     <entry>Modificateur</entry>
     <entry>Description</entry>
     <entry>Exemple</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry>préfixe <literal>FM</literal></entry>
     <entry>mode de remplissage (supprime les zéros avant et les blancs de
      remplissage)</entry>
     <entry><literal>FMMonth</literal></entry>
    </row>
    <row>
     <entry>Suffixe <literal>TH</literal></entry>
     <entry>suffixe du numéro ordinal en majuscule</entry>
     <entry><literal>DDTH</literal>, e.g., <literal>12TH</literal></entry>
    </row>
    <row>
     <entry>Suffixe <literal>th</literal></entry>
     <entry>suffixe du numéro ordinal en minuscule</entry>
     <entry><literal>DDth</literal>, e.g., <literal>12th</literal></entry>
    </row>
    <row>
     <entry>préfixe <literal>FX</literal></entry>
     <entry>option globale pour le format fixe (voir les notes d'utilisation)</entry>
     <entry><literal>FX&nbsp;Month&nbsp;DD&nbsp;Day</literal></entry>
    </row>
    <row>
     <entry>préfixe <literal>TM</literal></entry>
     <entry>mode de traduction (utilise les noms localisés du jour et du
      mois basés sur <xref linkend="guc-lc-time"/>)</entry>
     <entry><literal>TMMonth</literal></entry>
    </row>
    <row>
     <entry>Suffixe <literal>SP</literal></entry>
     <entry>spell mode (non implémenté)</entry>
     <entry><literal>DDSP</literal></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
  Notes d'utilisation du formatage date/heure&nbsp;:

  <itemizedlist>
   <listitem>
    <para>
     <literal>FM</literal> supprime les zéros en début et les blancs à la
     fin qui pourraient avoir été ajoutés pour s'assurer d'une taille fix de
     la sortie. Dans <productname>PostgreSQL</productname>,
     <literal>FM</literal> modifie seulement la spécification suivante alors
     que dans Oracle, <literal>FM</literal> affecte toutes les
     spécifications suivantes, et des modificateurs <literal>FM</literal>
     répétés vont basculer l'activation et la désactivation du mode de
     remplissage.
    </para>
   </listitem>

   <listitem>
    <para>
     <literal>TM</literal> supprime les espaces en fin de chaîne que
     <literal>FM</literal> soit spécifié ou non.
    </para>
   </listitem>

   <listitem>
    <para>
     <function>to_timestamp</function> et <function>to_date</function>
     ignorent la casse des lettres en entrée&nbsp;; donc par exemple
     <literal>MON</literal>, <literal>Mon</literal>, et
     <literal>mon</literal> acceptent toutes les mêmes chaînes. Lors de
     l'utilisation du modificateur <literal>TM</literal>, le changement de
     casse se fait suivant les règles de la collation pour les données en
     entrée de la fonction (voir <xref linkend="collation"/>).
    </para>
   </listitem>

   <listitem>
    <para>
     <function>to_timestamp</function> et <function>to_date</function>
     ignorent les nombreux espaces blancs au début de la chaîne en entrée et
     autour des valeurs de date et d'heure sauf si l'option
     <literal>FX</literal> est utilisée. Par exemple,
     <literal>to_timestamp('&nbsp;2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY
      MON')</literal> et <literal>to_timestamp('2000 - JUN',
      'YYYY-MON')</literal> fonctionnent, mais
     <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY
      MON')</literal> renvoie une erreur parce que
     <function>to_timestamp</function> s'attend seulement à un seul espace.
     <literal>FX</literal> doit être spécifié comme premier élément dans le
     modèle.
    </para>
   </listitem>

   <listitem>
    <para>
     Un séparateur (un espace ou un caractère qui n'est ni une lettre ni un
     chiffre) dans la chaîne modèle de <function>to_timestamp</function> et
     <function>to_date</function> correspond à tout séparateur dans la
     chaîne en entrée ou est ignoré, sauf si l'option <literal>FX</literal>
     est utilisée. Par exemple, <literal>to_timestamp('2000JUN',
      'YYYY///MON')</literal> et <literal>to_timestamp('2000/JUN', 'YYYY
      MON')</literal> fonctionnent mais <literal>to_timestamp('2000//JUN',
      'YYYY/MON')</literal> renvoie une erreur parce que le nombre de
     séparateurs dans la chaîne en entrée dépasse le nombre de séparateurs
     dans le modèle.
    </para>
    <para>
     Si <literal>FX</literal> est indiqué, un séparateur dans la chaîne
     modèle correspond exactement à un caractère dans la chaîne en entrée.
     Mais notez que le caractère de la chaîne en entrée n'a pas besoin
     d'être identique au séparateur de la chaîne modèle. Par exemple,
     <literal>to_timestamp('2000/JUN', 'FXYYYY MON')</literal> fonctionne
     mais <literal>to_timestamp('2000/JUN',
      'FXYYYY&nbsp;&nbsp;MON')</literal> renvoie une erreur parce que le
     deuxième espace dans la chaîne modèle consomme la lettre
     <literal>J</literal> de la chaîne en entrée.
    </para>
   </listitem>

   <listitem>
    <para>
     Un motif de modèle <literal>TZH</literal> peut correspondre à un nombre
     signé. Sans l'option <literal>FX</literal>, les signes moins pourraient
     être ambigus, et pourraient être interprétés comme un séparateur. Cette
     ambiguité est résolue ainsi&nbsp;; si le nombre de séparateurs avant
     <literal>TZH</literal> dans la chaîne modèle est inférieur au nombre de
     séparateur avant le signe moins dans la chaîne en entrée, le signe
     moins est interprété comme faisant partie de <literal>TZH</literal>.
     Sinon le signe moins est considéré être un séparateur entre les
     valeurs. Par exemple, <literal>to_timestamp('2000 -10', 'YYYY
      TZH')</literal> fait correspondre <literal>-10</literal> à
     <literal>TZH</literal>, mais <literal>to_timestamp('2000 -10',
      'YYYY&nbsp;&nbsp;TZH')</literal> fait correspondre
     <literal>10</literal> à <literal>TZH</literal>.
    </para>
   </listitem>

   <listitem>
    <para>
     Un texte ordinaire est autorisé dans les modèles
     <function>to_char</function> et sera affiché littéralement. Vous pouvez
     placer une sous-chaîne entre des guillemets doubles pour forcer son
     interprétation comme un texte littéral, même s'il contient des motifs
     de modèle. Par exemple, dans <literal>'"Hello Year "YYYY'</literal>, le
     texte <literal>YYYY</literal> sera remplacé par l'année, mais le simple
     <literal>Y</literal> dans <literal>Year</literal> ne le sera pas. Dans
     <function>to_date</function>, <function>to_number</function> et
     <function>to_timestamp</function>, le texte littéral et les chaînes
     entre guillemets doubles finissent en ignorant le nombre de caractères
     contenus dans la chaîne&nbsp;; par exemple, <literal>"XX"</literal>
     ignore les deux caractères en entrée (qu'ils soient ou non
     <literal>XX</literal>).
    </para>
    <tip>
     <para>
      Avant <productname>PostgreSQL</productname> 12, il était possible
      d'ignorer du texte arbitraire dans la chaîne en entrée en utilisant
      des caractères qui ne sont ni des lettres ni des chiffres. Par
      exemple, <literal>to_timestamp('2000y6m1d', 'yyyy-MM-DD')</literal>
      fonctionnait. Maintenant, vous pouvez seulement utiliser des
      caractères lettres pour cela. Par exemple,
      <literal>to_timestamp('2000y6m1d', 'yyyytMMtDDt')</literal> et
      <literal>to_timestamp('2000y6m1d', 'yyyy"y"MM"m"DD"d"')</literal>
      ignorent <literal>y</literal>, <literal>m</literal> et
      <literal>d</literal>.
     </para>
    </tip>
   </listitem>

   <listitem>
    <para>
     Si vous voulez avoir un guillemet double dans la sortie, vous devez la
     précéder avec un antislash, par exemple <literal>'\"YYYY
      Month\"'</literal>. En dehors de cela, les antislashs ne sont pas
     particulièrement spéciaux en dehors des chaînes entre guillemets
     doubles. À l'intérieur d'une chaîne entre guillemets doubles, un
     antislash peut faire que le prochain caractère soit considéré
     littéralement, quel qu'il soit (mais ceci n'a pas d'effet spécial sauf
     si le caractère suivant est un guillemet double ou un autre antislash).
    </para>
   </listitem>

   <listitem>
    <para>
     Dans <function>to_timestamp</function> et <function>to_date</function>,
     si la spécification du format de l'année fait moins de quatre chiffres,
     donc <literal>YYY</literal>, et que l'année indiquée fait moins de
     quatre chiffres, l'année sera ajustée au plus proche de l'année 2020,
     donc <literal>95</literal> devient 1995.
    </para>
   </listitem>

   <listitem>
    <para>
     Dans <function>to_timestamp</function> et <function>to_date</function>,
     les années négatives sont traitées comme signifiant avant Jésus Christ.
     Si vous écrivez à la fois une année négative et un champ
     <literal>BC</literal> explicite, vous obtenez après Jésus Christ de
     nouveau. Une entrée année zéro est traitée comme l'année 1 après Jésus
     Christ.
    </para>
   </listitem>

   <listitem>
    <para>
     Dans <function>to_timestamp</function> et <function>to_date</function>,
     la conversion <literal>YYYY</literal> a une restriction lors du
     traitement d'années avec plus de 4 chiffres. Vous devez utiliser
     certains caractères qui ne sont pas des chiffres ou un modèle après
     <literal>YYYY</literal>, sinon l'année est toujours interprétée avec 4
     chiffres. Par exemple (avec l'année 20000)&nbsp;:
     <literal>to_date('200001131', 'YYYYMMDD')</literal> sera interprété
     comme une année sur 4 chiffres&nbsp;; à la placez, utilisez un
     séparateur qui n'est pas un chiffre après l'année, comme par exemple
     <literal>to_date('20000-1131', 'YYYY-MMDD')</literal> ou
     <literal>to_date('20000Nov31', 'YYYYMonDD')</literal>.
    </para>
   </listitem>

   <listitem>
    <para>
     Dans <function>to_timestamp</function> et <function>to_date</function>,
     le champ <literal>CC</literal> (siècle) est accepté mais ignoré s'il
     existe un champ <literal>YYY</literal>, <literal>YYYY</literal> ou
     <literal>Y,YYY</literal>. Si <literal>CC</literal> est utilisé avec
     <literal>YY</literal> ou <literal>Y</literal>, alors le résultat est
     calculé comme l'année dans le siècle spécifié. Si le siècle est
     spécifié, mais pas l'année, la première année du siècle est présumée.
    </para>
   </listitem>

   <listitem>
    <para>
     Dans <function>to_timestamp</function> et <function>to_date</function>,
     les noms ou numéros des jours de la semaine (<literal>DAY</literal>,
     <literal>D</literal>, et les champs relatifs) sont acceptés mais
     ignorés pour calculer le résultat. Ceci est vrai aussi pour le champ
     <literal>Q</literal>.
    </para>
   </listitem>

   <listitem>
    <para>
     Dans <function>to_timestamp</function> et <function>to_date</function>,
     une date d'après la numérotation ISO 8601 (dans le sens distinct d'une
     date grégorienne) peut être indiqué de deux façons&nbsp;:
     <itemizedlist>
      <listitem>
       <para>
        Année, numéro de semaine et jour de la semaine&nbsp;: par exemple
        <literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal> renvoie la
        date date <literal>2006-10-19</literal>. Si vous omettez le jour de
        la semaine, il est supposé valoir 1 (lundi).
       </para>
      </listitem>
      <listitem>
       <para>
        Année et jour de l'année&nbsp;: par exemple
        <literal>to_date('2006-291', 'IYYY-IDDD')</literal> renvoie aussi
        <literal>2006-10-19</literal>.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Tenter de saisir une date en utilisant un mix de champs ISO 8601 et de
     champs grégoriens n'a pas de sens, et résultera en une erreur. Dans le
     contexte année-numéro de semaine sous l'ISO 8601, le concept d'un
     <quote>mois</quote> ou du <quote>jour d'un mois</quote> n'a pas de
     signification. Dans le contexte d'une année grégorienne, la semaine ISO
     n'a pas de signification.
    </para>
    <caution>
     <para>
      Alors que <function>to_date</function> rejettera un mix entre champs
      pour date grégorienne et pour date ISO, <function>to_char</function>
      ne le fera pas parce que les spécifications de format de sortie comme
      <literal>YYYY-MM-DD (IYYY-IDDD)</literal> peuvent se révéler utile.
      Mais évitez d'écrire quelque chose comme
      <literal>IYYY-MM-DD</literal>&nbsp;; cela pourrait amener des
      résultats surprenant près du début de l'année. (Voir <xref
      linkend="functions-datetime-extract"/> pour plus d'informations.)
     </para>
    </caution>
   </listitem>

   <listitem>
    <para>
     Dans <function>to_timestamp</function>, les champs milliseconde
     (<literal>MS</literal>) et microseconde (<literal>US</literal>) sont
     utilisés comme les chiffres secondes après le point décimal. Par
     exemple, <literal>to_timestamp('12.3', 'SS.MS')</literal> ne vaut pas 3
     millisecondes, mais 300 parce que la conversion la traite comme 12 +
     0,3 secondes. Donc, pour le format <literal>SS.MS</literal>, les
     valeurs en entrée <literal>12.3</literal>, <literal>12.30</literal> et
     <literal>12.300</literal> spécifient le même nombre de millisecondes.
     Pour obtenir trois millisecondes, il faut écrire
     <literal>12.003</literal>, que la conversion traite comme 12 + 0,003 =
     12,003 secondes.
    </para>

    <para>
     Voici un exemple plus complexe&nbsp;:
     <literal>to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')</literal>
     est 15 heures, 12 minutes, et 2 secondes + 20 millisecondes +
     1230 microsecondes = 2,021230 secondes.
    </para>
   </listitem>

   <listitem>
    <para>
     la numérotation du jour de la semaine à partir de
     <function>to_char(..., 'ID')</function> correspond à la fonction
     <function>extract(isodow from ...)</function> mais
     <function>to_char(..., 'D')</function> ne correspond pas à la
     numérotation des jours de <function>extract(dow from ...)</function>.
    </para>
   </listitem>

   <listitem>
    <para>
     <function>to_char(interval)</function> formate <literal>HH</literal>
     et <literal>HH12</literal> comme indiqué sur une horloge 12-heures,
     par exemple; l'heure zéro et l'heure 36 s'affichent toutes les deux
     comme  <literal>12</literal>, alors que <literal>HH24</literal>
     affiche la valeur complète de l'heure qui peut dépasser 23 dans une
     valeur de type <type>interval</type>.
    </para>
   </listitem>

  </itemizedlist>
 </para>

 <para>
  <xref linkend="functions-formatting-numeric-table"/> montre les motifs de
  modèle disponibles pour le formatage des valeurs numériques.
 </para>

 <table id="functions-formatting-numeric-table">
  <title>Motifs de modèle pour le formatage numérique</title>
  <tgroup cols="2">
   <thead>
    <row>
     <entry>Motif</entry>
     <entry>Description</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>9</literal></entry>
     <entry>position d'un chiffre (peut être supprimé si non significatif)</entry>
    </row>
    <row>
     <entry><literal>0</literal></entry>
     <entry>position d'un chiffre (ne sera pas supprimé même si non significatif)</entry>
    </row>
    <row>
     <entry><literal>.</literal> (point)</entry>
     <entry>point décimal</entry>
    </row>
    <row>
     <entry><literal>,</literal> (virgule)</entry>
     <entry>séparateur de groupe (milliers)</entry>
    </row>
    <row>
     <entry><literal>PR</literal></entry>
     <entry>valeur négative entre crochets</entry>
    </row>
    <row>
     <entry><literal>S</literal></entry>
     <entry>signe accroché au nombre (utilise la locale)</entry>
    </row>
    <row>
     <entry><literal>L</literal></entry>
     <entry>symbôle de monnaie (utilise la locale)</entry>
    </row>
    <row>
     <entry><literal>D</literal></entry>
     <entry>point décimal (utilise la locale)</entry>
    </row>
    <row>
     <entry><literal>G</literal></entry>
     <entry>séparateur de groupe (utilise la locale)</entry>
    </row>
    <row>
     <entry><literal>MI</literal></entry>
     <entry>signe moins dans la position spécifiée (si nombre &lt; 0)</entry>
    </row>
    <row>
     <entry><literal>PL</literal></entry>
     <entry>signe plus dans la position spécifiée (si nombre &gt; 0)</entry>
    </row>
    <row>
     <entry><literal>SG</literal></entry>
     <entry>signe plus/moins dans la position spécifiée</entry>
    </row>
    <row>
     <entry><literal>RN</literal></entry>
     <entry>nombre romain (entrée entre 1 et 3999)</entry>
    </row>
    <row>
     <entry><literal>TH</literal> or <literal>th</literal></entry>
     <entry>suffixe du numéro ordinal</entry>
    </row>
    <row>
     <entry><literal>V</literal></entry>
     <entry>décalage spécifié en nombre de chiffres (voir notes)</entry>
    </row>
    <row>
     <entry><literal>EEEE</literal></entry>
     <entry>exposant pour la notation scientifique</entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
  Notes d'utilisation pour le formatage numérique&nbsp;:

  <itemizedlist>
   <listitem>
    <para>
     <literal>0</literal> spécifie une position de chiffre qui sera toujours
     affiché, même s'il contient un zéro en début ou en fin.
     <literal>9</literal> spécifie aussi une position de chiffre mais, s'il
     s'agit un zéro en début, alors il sera remplacé par un espace, alors
     que s'il s'agit d'un zéro en fin et que le mode de remplissage est
     activé, alors il sera supprimé. (Pour <function>to_number()</function>,
     ces deux modèles sont équivalents.)
    </para>
   </listitem>

   <listitem>
    <para>
     Les caractères de modèle <literal>S</literal>, <literal>L</literal>,
     <literal>D</literal> et <literal>G</literal> représentent le signe, le
     symbôle de monnaie, le point décimal et le séparateur de milliers
     définis par la locale actuelle (voir <xref linkend="guc-lc-monetary"/>
     et <xref linkend="guc-lc-numeric"/>). Le point et la virgule
     représentent ces caractères avec la signification du point décimal et
     du séparateur de milliers, quelque soit la locale.
    </para>
   </listitem>

   <listitem>
    <para>
     Si aucune provision explicite n'est faite pour un signe dans le motif
     de <function>to_char()</function>, une colonne sera réservée pour le
     signe, et il sera ancré au chiffre (il apparaîtra à gauche). Si
     <literal>S</literal> apparaît juste à gauche de <literal>9</literal>,
     il sera quand même ancré au nombre.
    </para>
   </listitem>

   <listitem>
    <para>
     Un signe formaté utilisant <literal>SG</literal>, <literal>PL</literal>
     ou <literal>MI</literal> n'est pas ancré au nombre&nbsp;; par exemple,
     <literal>to_char(-12, 'MI9999')</literal> produit
     <literal>'-&nbsp;&nbsp;12'</literal> mais <literal>to_char(-12,
      'S9999')</literal> produit <literal>'&nbsp;&nbsp;-12'</literal>.
     (L'implémentation Oracle ne permet pas l'utilisation de
     <literal>MI</literal> avant <literal>9</literal>, mais nécessite plutôt
     que <literal>9</literal> précède <literal>MI</literal>.)
    </para>
   </listitem>

   <listitem>
    <para>
     <literal>TH</literal> ne convertit pas les valeurs inférieures à zéro et
     ne convertit pas les nombres fractionnés.
    </para>
   </listitem>

   <listitem>
    <para>
     <literal>PL</literal>, <literal>SG</literal> et
     <literal>TH</literal> sont des extensions de
     <productname>PostgreSQL</productname>.
    </para>
   </listitem>

   <listitem>
    <para>
     Dans <function>to_number</function>, si des motifs de modèle
     non-données tels que <literal>L</literal> ou <literal>TH</literal> sont
     utilisés, le nombre correspondant de caractères en entrée est ignoré
     qu'ils correspondent ou non au motif du modèle, sauf si ce sont des
     caractères de données (c'est-à-dire chiffres, signe, point décimal ou
     virgule). Par exemple, <literal>TH</literal> ignorerait les deux
     caractères qui ne sont pas des données.
    </para>
   </listitem>

   <listitem>
    <para>
     <literal>V</literal> avec <function>to_char</function> multiplie les
     valeurs en entrée par
     <literal>10^<replaceable>n</replaceable></literal>, où
     <replaceable>n</replaceable> est le nombre de chiffres suivant
     <literal>V</literal>. <literal>V</literal> avec
     <function>to_number</function> divise d'une façon similaire.
     <function>to_char</function> et <function>to_number</function> ne
     supportent pas l'utilisation de <literal>V</literal> en combinaison
     avec un point décimal (de ce fait, <literal>99.9V99</literal> n'est pas
     autorisé).
    </para>
   </listitem>

   <listitem>
    <para>
     <literal>EEEE</literal> (notation scientifique) ne peut pas être
     utilisé en combinaison avec tout autre motif de formatage ou
     modificateur autre que les motifs de chiffres et de point décimal, et
     doit être à la fin de la chaîne de format (autrement dit,
     <literal>9.99EEEE</literal> est un motif valide).
    </para>
   </listitem>
  </itemizedlist>
 </para>

 <para>
  Certains modificateurs peuvent être appliqués à tout motif de modèle pour
  modifier son comportement. Par exemple, <literal>FM99.99</literal> est le
  motif <literal>99.99</literal> avec le modificateur <literal>FM</literal>.
  <xref linkend="functions-formatting-numericmod-table"/> montre les motifs
  de modificateur pour le formatage numérique.
 </para>

 <table id="functions-formatting-numericmod-table">
  <title>Modificateurs de motifs de modèle pour le formatage numérique</title>
  <tgroup cols="3">
   <thead>
    <row>
     <entry>Modificateur</entry>
     <entry>Description</entry>
     <entry>Exemple</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry>préfixe <literal>FM</literal></entry>
     <entry>mode de remplissage (supprime les zéros en fin et les espaces d'alignement)</entry>
     <entry><literal>FM99.99</literal></entry>
    </row>
    <row>
     <entry>suffixe <literal>TH</literal></entry>
     <entry>suffixe du nombre ordinal en majuscule</entry>
     <entry><literal>999TH</literal></entry>
    </row>
    <row>
     <entry>suffixe <literal>th</literal></entry>
     <entry>suffixe du nombre ordinal en minuscule</entry>
     <entry><literal>999th</literal></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
  <xref linkend="functions-formatting-examples-table"/> montre quelques
  exemples de l'utilisation de la fonction <function>to_char</function>.
 </para>

 <table id="functions-formatting-examples-table">
  <title><function>to_char</function> Examples</title>
  <tgroup cols="2">
   <thead>
    <row>
     <entry>Expression</entry>
     <entry>Résultat</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
     <entry><literal>'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
     <entry><literal>'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(-0.1, '99.99')</literal></entry>
     <entry><literal>'&nbsp;&nbsp;-.10'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(-0.1, 'FM9.99')</literal></entry>
     <entry><literal>'-.1'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(-0.1, 'FM90.99')</literal></entry>
     <entry><literal>'-0.1'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(0.1, '0.9')</literal></entry>
     <entry><literal>'&nbsp;0.1'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(12, '9990999.9')</literal></entry>
     <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(12, 'FM9990999.9')</literal></entry>
     <entry><literal>'0012.'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(485, '999')</literal></entry>
     <entry><literal>'&nbsp;485'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(-485, '999')</literal></entry>
     <entry><literal>'-485'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(485, '9&nbsp;9&nbsp;9')</literal></entry>
     <entry><literal>'&nbsp;4&nbsp;8&nbsp;5'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(1485, '9,999')</literal></entry>
     <entry><literal>'&nbsp;1,485'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(1485, '9G999')</literal></entry>
     <entry><literal>'&nbsp;1&nbsp;485'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(148.5, '999.999')</literal></entry>
     <entry><literal>'&nbsp;148.500'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(148.5, 'FM999.999')</literal></entry>
     <entry><literal>'148.5'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(148.5, 'FM999.990')</literal></entry>
     <entry><literal>'148.500'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(148.5, '999D999')</literal></entry>
     <entry><literal>'&nbsp;148,500'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(3148.5, '9G999D999')</literal></entry>
     <entry><literal>'&nbsp;3&nbsp;148,500'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(-485, '999S')</literal></entry>
     <entry><literal>'485-'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(-485, '999MI')</literal></entry>
     <entry><literal>'485-'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(485, '999MI')</literal></entry>
     <entry><literal>'485&nbsp;'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(485, 'FM999MI')</literal></entry>
     <entry><literal>'485'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(485, 'PL999')</literal></entry>
     <entry><literal>'+485'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(485, 'SG999')</literal></entry>
     <entry><literal>'+485'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(-485, 'SG999')</literal></entry>
     <entry><literal>'-485'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(-485, '9SG99')</literal></entry>
     <entry><literal>'4-85'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(-485, '999PR')</literal></entry>
     <entry><literal>'&lt;485&gt;'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(485, 'L999')</literal></entry>
     <entry><literal>'DM&nbsp;485'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(485, 'RN')</literal></entry>
     <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(485, 'FMRN')</literal></entry>
     <entry><literal>'CDLXXXV'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(5.2, 'FMRN')</literal></entry>
     <entry><literal>'V'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(482, '999th')</literal></entry>
     <entry><literal>'&nbsp;482nd'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(485, '"Good&nbsp;number:"999')</literal></entry>
     <entry><literal>'Good&nbsp;number:&nbsp;485'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(485.8, '"Pre:"999"&nbsp;Post:"&nbsp;.999')</literal></entry>
     <entry><literal>'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(12, '99V999')</literal></entry>
     <entry><literal>'&nbsp;12000'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(12.4, '99V999')</literal></entry>
     <entry><literal>'&nbsp;12400'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(12.45, '99V9')</literal></entry>
     <entry><literal>'&nbsp;125'</literal></entry>
    </row>
    <row>
     <entry><literal>to_char(0.0004859, '9.99EEEE')</literal></entry>
     <entry><literal>' 4.86e-04'</literal></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

</sect1>


<sect1 id="functions-datetime">
 <title>Fonctions et opérateurs pour date/heure</title>

 <para>
  <xref linkend="functions-datetime-table"/> affiche les fonctions
  disponibles pour le traitement de valeurs date/heure, avec des détails dans
  les sections suivantes. <xref linkend="operators-datetime-table"/> illustre
  le comportement des opérateurs arithmétiques de base (<literal>+</literal>,
  <literal>*</literal>, etc.). Pour les fonctions de formatage, référez-vous
  à <xref linkend="functions-formatting"/>. Vous devez être déjà familier
  avec les types de données date/heure (voir <xref
  linkend="datatype-datetime"/>).
 </para>

 <para>
  Toutes les fonctions et tous les descripteurs décrits ci-dessous, prenant
  en entrée des arguments de type <type>time</type> ou <type>timestamp</type>
  viennent en deux variantes&nbsp;: une qui prend le type <type>time with
   time zone</type> ou <type>timestamp with time zone</type>, et une qui prend
  le type <type>time without time zone</type> ou <type>timestamp without time
   zone</type>. Pour ne pas trop grossir la documentation, ces variantes ne
  sont pas affichées séparément. De plus, les opérateurs <literal>+</literal>
  et <literal>*</literal> viennent sous la forme de paires commutatives (par
  exemple, à la fois date + integer et integer + date)&nbsp;; nous ne
  présentons qu'une seule des deux.
 </para>

 <table id="operators-datetime-table">
  <title>Opérateurs Date/Heure</title>

  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Opérateur
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>date</type> <literal>+</literal> <type>integer</type>
       <returnvalue>date</returnvalue>
      </para>
      <para>
       Ajoute un nombre de jours à une date
      </para>
      <para>
       <literal>date '2001-09-28' + 7</literal>
       <returnvalue>2001-10-05</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>date</type> <literal>+</literal> <type>interval</type>
       <returnvalue>timestamp</returnvalue>
      </para>
      <para>
       Ajouter un interval à une date
      </para>
      <para>
       <literal>date '2001-09-28' + interval '1 hour'</literal>
       <returnvalue>2001-09-28 01:00:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>date</type> <literal>+</literal> <type>time</type>
       <returnvalue>timestamp</returnvalue>
      </para>
      <para>
       Ajoute une heure du jour à une date
      </para>
      <para>
       <literal>date '2001-09-28' + time '03:00'</literal>
       <returnvalue>2001-09-28 03:00:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>interval</type> <literal>+</literal> <type>interval</type>
       <returnvalue>interval</returnvalue>
      </para>
      <para>
       Ajoute des intervalles
      </para>
      <para>
       <literal>interval '1 day' + interval '1 hour'</literal>
       <returnvalue>1 day 01:00:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>timestamp</type> <literal>+</literal> <type>interval</type>
       <returnvalue>timestamp</returnvalue>
      </para>
      <para>
       Ajoute un interval à un timestamp
      </para>
      <para>
       <literal>timestamp '2001-09-28 01:00' + interval '23 hours'</literal>
       <returnvalue>2001-09-29 00:00:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>time</type> <literal>+</literal> <type>interval</type>
       <returnvalue>time</returnvalue>
      </para>
      <para>
       Ajoute un interval à une heure
      </para>
      <para>
       <literal>time '01:00' + interval '3 hours'</literal>
       <returnvalue>04:00:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <literal>-</literal> <type>interval</type>
       <returnvalue>interval</returnvalue>
      </para>
      <para>
       Passe un interval en négatif
      </para>
      <para>
       <literal>- interval '23 hours'</literal>
       <returnvalue>-23:00:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>date</type> <literal>-</literal> <type>date</type>
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Soustrait des dates, produisant le nombre de jours passés
      </para>
      <para>
       <literal>date '2001-10-01' - date '2001-09-28'</literal>
       <returnvalue>3</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>date</type> <literal>-</literal> <type>integer</type>
       <returnvalue>date</returnvalue>
      </para>
      <para>
       Soustrait un nombre de jours d'une date
      </para>
      <para>
       <literal>date '2001-10-01' - 7</literal>
       <returnvalue>2001-09-24</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>date</type> <literal>-</literal> <type>interval</type>
       <returnvalue>timestamp</returnvalue>
      </para>
      <para>
       Soustrait un interval d'une date
      </para>
      <para>
       <literal>date '2001-09-28' - interval '1 hour'</literal>
       <returnvalue>2001-09-27 23:00:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>time</type> <literal>-</literal> <type>time</type>
       <returnvalue>interval</returnvalue>
      </para>
      <para>
       Soustrait des heures
      </para>
      <para>
       <literal>time '05:00' - time '03:00'</literal>
       <returnvalue>02:00:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>time</type> <literal>-</literal> <type>interval</type>
       <returnvalue>time</returnvalue>
      </para>
      <para>
       Soustrait un interval d'une heure
      </para>
      <para>
       <literal>time '05:00' - interval '2 hours'</literal>
       <returnvalue>03:00:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>timestamp</type> <literal>-</literal> <type>interval</type>
       <returnvalue>timestamp</returnvalue>
      </para>
      <para>
       Soustrait un interval d'un timestamp
      </para>
      <para>
       <literal>timestamp '2001-09-28 23:00' - interval '23 hours'</literal>
       <returnvalue>2001-09-28 00:00:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>interval</type> <literal>-</literal> <type>interval</type>
       <returnvalue>interval</returnvalue>
      </para>
      <para>
       Soustrait des intervalles
      </para>
      <para>
       <literal>interval '1 day' - interval '1 hour'</literal>
       <returnvalue>1 day -01:00:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>timestamp</type> <literal>-</literal> <type>timestamp</type>
       <returnvalue>interval</returnvalue>
      </para>
      <para>
       Soustrait des timestamps (convertissant des intervalles sur 24 heures
       en jours, de façon similaire à <function>justify_hours()</function>)
      </para>
      <para>
       <literal>timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'</literal>
       <returnvalue>1 day 15:00:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>interval</type> <literal>*</literal> <type>double precision</type>
       <returnvalue>interval</returnvalue>
      </para>
      <para>
       Multiplie un interval à une valeur scalaire
      </para>
      <para>
       <literal>interval '1 second' * 900</literal>
       <returnvalue>00:15:00</returnvalue>
      </para>
      <para>
       <literal>interval '1 day' * 21</literal>
       <returnvalue>21 days</returnvalue>
      </para>
      <para>
       <literal>interval '1 hour' * 3.5</literal>
       <returnvalue>03:30:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>interval</type> <literal>/</literal> <type>double precision</type>
       <returnvalue>interval</returnvalue>
      </para>
      <para>
       Divise un interval par une valeur scalaire
      </para>
      <para>
       <literal>interval '1 hour' / 1.5</literal>
       <returnvalue>00:40:00</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <table id="functions-datetime-table">
  <title>Fonctions Date/Heure</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>age</primary>
       </indexterm>
       <function>age</function> ( <type>timestamp</type>, <type>timestamp</type> )
       <returnvalue>interval</returnvalue>
      </para>
      <para>
       Soustrait les arguments, produisant un résultat <quote>symbolique</quote>
       qui utilise des années et des mois, plutôt que simplement des jours
      </para>
      <para>
       <literal>age(timestamp '2001-04-10', timestamp '1957-06-13')</literal>
       <returnvalue>43 years 9 mons 27 days</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>age</function> ( <type>timestamp</type> )
       <returnvalue>interval</returnvalue>
      </para>
      <para>
       Soustrait l'argument de <function>current_date</function> (à minuit)
      </para>
      <para>
       <literal>age(timestamp '1957-06-13')</literal>
       <returnvalue>62 years 6 mons 10 days</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>clock_timestamp</primary>
       </indexterm>
       <function>clock_timestamp</function> ( )
       <returnvalue>timestamp with time zone</returnvalue>
      </para>
      <para>
       Date et heure actuelles (change lors de l'exécution d'une requête)&nbsp;;
       voir <xref linkend="functions-datetime-current"/>
      </para>
      <para>
       <literal>clock_timestamp()</literal>
       <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>current_date</primary>
       </indexterm>
       <function>current_date</function>
       <returnvalue>date</returnvalue>
      </para>
      <para>
       Date actuelle&nbsp;; voir <xref linkend="functions-datetime-current"/>
      </para>
      <para>
       <literal>current_date</literal>
       <returnvalue>2019-12-23</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>current_time</primary>
       </indexterm>
       <function>current_time</function>
       <returnvalue>time with time zone</returnvalue>
      </para>
      <para>
       Heure actuelle du jour&nbsp;; voir <xref linkend="functions-datetime-current"/>
      </para>
      <para>
       <literal>current_time</literal>
       <returnvalue>14:39:53.662522-05</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>current_time</function> ( <type>integer</type> )
       <returnvalue>time with time zone</returnvalue>
      </para>
      <para>
       Haure actuelle du jour avec une précision limitée&nbsp;;
       voir <xref linkend="functions-datetime-current"/>
      </para>
      <para>
       <literal>current_time(2)</literal>
       <returnvalue>14:39:53.66-05</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>current_timestamp</primary>
       </indexterm>
       <function>current_timestamp</function>
       <returnvalue>timestamp with time zone</returnvalue>
      </para>
      <para>
       Date et heure actuelles (début de la transaction en cours)&nbsp;;
       voir <xref linkend="functions-datetime-current"/>
      </para>
      <para>
       <literal>current_timestamp</literal>
       <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>current_timestamp</function> ( <type>integer</type> )
       <returnvalue>timestamp with time zone</returnvalue>
      </para>
      <para>
       Date et heure actuelles (début de la transaction en cours) avec une
       précision limitée&nbsp;; voir <xref linkend="functions-datetime-current"/>
      </para>
      <para>
       <literal>current_timestamp(0)</literal>
       <returnvalue>2019-12-23 14:39:53-05</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>date_part</primary>
       </indexterm>
       <function>date_part</function> ( <type>text</type>, <type>timestamp</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Obtenir un champ du timestamp (équivalent à <function>extract</function>)&nbsp;;
       voir <xref linkend="functions-datetime-extract"/>
      </para>
      <para>
       <literal>date_part('hour', timestamp '2001-02-16 20:38:40')</literal>
       <returnvalue>20</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>date_part</function> ( <type>text</type>, <type>interval</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Obtenir un champ interval (équivalent à <function>extract</function>)&nbsp;;
       voir <xref linkend="functions-datetime-extract"/>
      </para>
      <para>
       <literal>date_part('month', interval '2 years 3 months')</literal>
       <returnvalue>3</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>date_trunc</primary>
       </indexterm>
       <function>date_trunc</function> ( <type>text</type>, <type>timestamp</type> )
       <returnvalue>timestamp</returnvalue>
      </para>
      <para>
       Tronque à la précision spécifiée&nbsp;; voir <xref
       linkend="functions-datetime-trunc"/>
      </para>
      <para>
       <literal>date_trunc('hour', timestamp '2001-02-16 20:38:40')</literal>
       <returnvalue>2001-02-16 20:00:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>date_trunc</function> ( <type>text</type>, <type>timestamp with time zone</type>, <type>text</type> )
       <returnvalue>timestamp with time zone</returnvalue>
      </para>
      <para>
       Tronque à une précision spécifiée dans le fuseau horaire indiqué&nbsp;;
       voir <xref linkend="functions-datetime-trunc"/>
      </para>
      <para>
       <literal>date_trunc('day', timestamptz '2001-02-16 20:38:40+00', 'Australia/Sydney')</literal>
       <returnvalue>2001-02-16 13:00:00+00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>date_trunc</function> ( <type>text</type>, <type>interval</type> )
       <returnvalue>interval</returnvalue>
      </para>
      <para>
       Tronque à la précision spécifiée&nbsp;; voir
       <xref linkend="functions-datetime-trunc"/>
      </para>
      <para>
       <literal>date_trunc('hour', interval '2 days 3 hours 40 minutes')</literal>
       <returnvalue>2 days 03:00:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>extract</primary>
       </indexterm>
       <function>extract</function> ( <parameter>field</parameter> <literal>from</literal> <type>timestamp</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Obtenir un champ du timestamp&nbsp;; voir <xref
       linkend="functions-datetime-extract"/>
      </para>
      <para>
       <literal>extract(hour from timestamp '2001-02-16 20:38:40')</literal>
       <returnvalue>20</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>extract</function> ( <parameter>field</parameter> <literal>from</literal> <type>interval</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Obtenir un champ interval&nbsp;; voir <xref linkend="functions-datetime-extract"/>
      </para>
      <para>
       <literal>extract(month from interval '2 years 3 months')</literal>
       <returnvalue>3</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>isfinite</primary>
       </indexterm>
       <function>isfinite</function> ( <type>date</type> )
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Test pour une date finie (différent de +/-infinity)
      </para>
      <para>
       <literal>isfinite(date '2001-02-16')</literal>
       <returnvalue>true</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>isfinite</function> ( <type>timestamp</type> )
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Test pour un timestamp fini (différent de +/-infinity)
      </para>
      <para>
       <literal>isfinite(timestamp 'infinity')</literal>
       <returnvalue>false</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>isfinite</function> ( <type>interval</type> )
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Test pour un interval fini (actuellement toujours vrai)
      </para>
      <para>
       <literal>isfinite(interval '4 hours')</literal>
       <returnvalue>true</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>justify_days</primary>
       </indexterm>
       <function>justify_days</function> ( <type>interval</type> )
       <returnvalue>interval</returnvalue>
      </para>
      <para>
       Ajuste un interval pour que les périodes de temps de 30 jours soient
       représentées comme des mois
      </para>
      <para>
       <literal>justify_days(interval '35 days')</literal>
       <returnvalue>1 mon 5 days</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>justify_hours</primary>
       </indexterm>
       <function>justify_hours</function> ( <type>interval</type> )
       <returnvalue>interval</returnvalue>
      </para>
      <para>
       Ajuste un interval pour que les périodes de temps de 24 heures soient
       représentées comme des jours
      </para>
      <para>
       <literal>justify_hours(interval '27 hours')</literal>
       <returnvalue>1 day 03:00:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>justify_interval</primary>
       </indexterm>
       <function>justify_interval</function> ( <type>interval</type> )
       <returnvalue>interval</returnvalue>
      </para>
      <para>
       Adjuste un interval en utilisant <function>justify_days</function>
       et <function>justify_hours</function>, avec des ajustements de signe
       supplémentaire
      </para>
      <para>
       <literal>justify_interval(interval '1 mon -1 hour')</literal>
       <returnvalue>29 days 23:00:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>localtime</primary>
       </indexterm>
       <function>localtime</function>
       <returnvalue>time</returnvalue>
      </para>
      <para>
       Heure actuelle du jour&nbsp;;
       voir <xref linkend="functions-datetime-current"/>
      </para>
      <para>
       <literal>localtime</literal>
       <returnvalue>14:39:53.662522</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>localtime</function> ( <type>integer</type> )
       <returnvalue>time</returnvalue>
      </para>
      <para>
       Heure actuelle du jour avec une précision limitée&nbsp;;
       voir <xref linkend="functions-datetime-current"/>
      </para>
      <para>
       <literal>localtime(0)</literal>
       <returnvalue>14:39:53</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>localtimestamp</primary>
       </indexterm>
       <function>localtimestamp</function>
       <returnvalue>timestamp</returnvalue>
      </para>
      <para>
       Date et heure actuelles (début de la transaction en cours)&nbsp;;
       voir <xref linkend="functions-datetime-current"/>
      </para>
      <para>
       <literal>localtimestamp</literal>
       <returnvalue>2019-12-23 14:39:53.662522</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>localtimestamp</function> ( <type>integer</type> )
       <returnvalue>timestamp</returnvalue>
      </para>
      <para>
       Date et heure actuelles (début de la transaction en cours), avec une
       précision limitée&nbsp;;
       voir <xref linkend="functions-datetime-current"/>
      </para>
      <para>
       <literal>localtimestamp(2)</literal>
       <returnvalue>2019-12-23 14:39:53.66</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>make_date</primary>
       </indexterm>
       <function>make_date</function> ( <parameter>year</parameter> <type>int</type>,
       <parameter>month</parameter> <type>int</type>,
       <parameter>day</parameter> <type>int</type> )
       <returnvalue>date</returnvalue>
      </para>
      <para>
       Crée une date à partir des champs année, mois et jour
      </para>
      <para>
       <literal>make_date(2013, 7, 15)</literal>
       <returnvalue>2013-07-15</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature"><indexterm>
        <primary>make_interval</primary>
       </indexterm>
       <function>make_interval</function> ( <optional> <parameter>years</parameter> <type>int</type>
        <optional>, <parameter>months</parameter> <type>int</type>
         <optional>, <parameter>weeks</parameter> <type>int</type>
          <optional>, <parameter>days</parameter> <type>int</type>
           <optional>, <parameter>hours</parameter> <type>int</type>
            <optional>, <parameter>mins</parameter> <type>int</type>
             <optional>, <parameter>secs</parameter> <type>double precision</type>
             </optional></optional></optional></optional></optional></optional></optional> )
       <returnvalue>interval</returnvalue>
      </para>
      <para>
       Crée un interval à partir des champs année, mois, semaine, jour,
       heure, minute et seconde, chacun ayant zéro comme valeur par défaut
      </para>
      <para>
       <literal>make_interval(days =&gt; 10)</literal>
       <returnvalue>10 days</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>make_time</primary>
       </indexterm>
       <function>make_time</function> ( <parameter>hour</parameter> <type>int</type>,
       <parameter>min</parameter> <type>int</type>,
       <parameter>sec</parameter> <type>double precision</type> )
       <returnvalue>time</returnvalue>
      </para>
      <para>
       Crée une heure à partir des champs heure, minute et seconde
      </para>
      <para>
       <literal>make_time(8, 15, 23.5)</literal>
       <returnvalue>08:15:23.5</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>make_timestamp</primary>
       </indexterm>
       <function>make_timestamp</function> ( <parameter>year</parameter> <type>int</type>,
       <parameter>month</parameter> <type>int</type>,
       <parameter>day</parameter> <type>int</type>,
       <parameter>hour</parameter> <type>int</type>,
       <parameter>min</parameter> <type>int</type>,
       <parameter>sec</parameter> <type>double precision</type> )
       <returnvalue>timestamp</returnvalue>
      </para>
      <para>
       Crée un timestamp à partir des champs année, mois, jour, heure, minute
       et seconde
      </para>
      <para>
       <literal>make_timestamp(2013, 7, 15, 8, 15, 23.5)</literal>
       <returnvalue>2013-07-15 08:15:23.5</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>make_timestamptz</primary>
       </indexterm>
       <function>make_timestamptz</function> ( <parameter>year</parameter> <type>int</type>,
       <parameter>month</parameter> <type>int</type>,
       <parameter>day</parameter> <type>int</type>,
       <parameter>hour</parameter> <type>int</type>,
       <parameter>min</parameter> <type>int</type>,
       <parameter>sec</parameter> <type>double precision</type>
       <optional>, <parameter>timezone</parameter> <type>text</type> </optional> )
       <returnvalue>timestamp with time zone</returnvalue>
      </para>
      <para>
       Crée un timestamp avec fuseau horaire à partir des champs année,
       mois, jour, heure, minute et seconde&nbsp;; si
       <parameter>timezone</parameter> n'est pas spécifié, le fuseau horaire
       actuel est utilisé
      </para>
      <para>
       <literal>make_timestamptz(2013, 7, 15, 8, 15, 23.5)</literal>
       <returnvalue>2013-07-15 08:15:23.5+01</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>now</primary>
       </indexterm>
       <function>now</function> ( )
       <returnvalue>timestamp with time zone</returnvalue>
      </para>
      <para>
       Date et heure actuelles (début de la transaction en cours)&nbsp;;
       voir <xref linkend="functions-datetime-current"/>
      </para>
      <para>
       <literal>now()</literal>
       <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>statement_timestamp</primary>
       </indexterm>
       <function>statement_timestamp</function> ( )
       <returnvalue>timestamp with time zone</returnvalue>
      </para>
      <para>
       Date et heure actuelles (début de la requête en cours)&nbsp;;
       voir <xref linkend="functions-datetime-current"/>
      </para>
      <para>
       <literal>statement_timestamp()</literal>
       <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>timeofday</primary>
       </indexterm>
       <function>timeofday</function> ( )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Date et heure actuelles (comme <function>clock_timestamp</function>,
       mais sous la forme d'une chaîne de type <type>text</type>)&nbsp;;
       voir <xref linkend="functions-datetime-current"/>
      </para>
      <para>
       <literal>timeofday()</literal>
       <returnvalue>Mon Dec 23 14:39:53.662522 2019 EST</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>transaction_timestamp</primary>
       </indexterm>
       <function>transaction_timestamp</function> ( )
       <returnvalue>timestamp with time zone</returnvalue>
      </para>
      <para>
       Date et heure actuelles (début de la transaction en cours)&nbsp;;
       voir <xref linkend="functions-datetime-current"/>
      </para>
      <para>
       <literal>transaction_timestamp()</literal>
       <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>to_timestamp</primary>
       </indexterm>
       <function>to_timestamp</function> ( <type>double precision</type> )
       <returnvalue>timestamp with time zone</returnvalue>
      </para>
      <para>
       Convertit un epoch Unix (secondes depuis 1970-01-01 00:00:00+00) en
       timestamp avec fuseau horaire
      </para>
      <para>
       <literal>to_timestamp(1284352323)</literal>
       <returnvalue>2010-09-13 04:32:03+00</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
  <indexterm>
   <primary>OVERLAPS</primary>
  </indexterm>
  En plus de ces fonctions, l'opérateur SQL <literal>OVERLAPS</literal> est
  géré&nbsp;:
  <synopsis>
(<replaceable>start1</replaceable>, <replaceable>end1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>end2</replaceable>)
(<replaceable>start1</replaceable>, <replaceable>length1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>length2</replaceable>)
  </synopsis>
  Cette expression renvoie true quand deux périodes de temps (définies par
  leur point final) se chevauchent et false dans le cas contraire. Les
  points finaux peuvent être indiqués sous la forme d'une paires de dates,
  heures ou dates et heures, ou à une date, heure ou date et heure suivie
  par un intervalle. Quand une paire de valeurs est fournie, soit le début
  soit la fin peuvent être écrit en premier&nbsp;;
  <literal>OVERLAPS</literal> prend automatiquement la valeur la plus
  ancienne de la paire comme valeur de départ. Chaque période de temps est
  considérée comme représentant l'intervalle à moitié ouvert
  <replaceable>start</replaceable> <literal>&lt;=</literal>
  <replaceable>time</replaceable> <literal>&lt;</literal>
  <replaceable>end</replaceable>, sauf si <replaceable>start</replaceable>
  et <replaceable>end</replaceable> sont égaux, auquel cas elle représente
  uniquement cet instant. Ceci signifie que deux périodes de temps avec
  seulement le point final en commun ne se surchargent pas.
 </para>

 <screen>
SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Résultat : </lineannotation><computeroutput>true</computeroutput>
SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Résultat : </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Résultat : </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Résultat : </lineannotation><computeroutput>true</computeroutput>
 </screen>

 <para>
  Lors de l'ajout (ou de la soustraction) d'une valeur <type>interval</type>
  à une valeur <type>timestamp with time zone</type>, le nombre de jours
  augmente ou décrémente la date de <type>timestamp with time zone</type> par
  le nombre de jours indiqué, conservant à l'identique l'heure du jour. Si
  cela intervient à une période de changement d'heure pour le fuseau horaire
  utilisé, cela signifie que <literal>interval '1 day'</literal> n'est pas
  forcément équivalent à <literal>interval '24 hours'</literal>. Par exemple,
  avec le fuseau horaire <literal>America/Denver</literal>&nbsp;:
  <screen>
SELECT timestamp with time zone '2005-04-02 12:00:00-07' + interval '1 day';
<lineannotation>Résultat : </lineannotation><computeroutput>2005-04-03 12:00:00-06</computeroutput>
SELECT timestamp with time zone '2005-04-02 12:00:00-07' + interval '24 hours';
<lineannotation>Résultat : </lineannotation><computeroutput>2005-04-03 13:00:00-06</computeroutput>
  </screen>
  Ceci survient parce qu'une heure a été ignorée à cause d'un changement
  d'heure à <literal>2005-04-03 02:00:00</literal> pour le fuseau horaire
  <literal>America/Denver</literal>.
 </para>

 <para>
  Notez qu'il peut avoir une ambiguïté dans le champ
  <literal>months</literal> renvoyé par la fonction <function>age</function>
  parce que des mois différents ont des numéros de jour différents.
  L'approche de <productname>PostgreSQL</productname> utilise le mois de la
  date la plus ancienne lors du calcul de mois partiels. Par exemple,
  <literal>age('2004-06-01', '2004-04-30')</literal> utilise avril pour
  renvoyer <literal>1 mon 1 day</literal>, alors que mai renverrait
  <literal>1 mon 2 days</literal> parce que mai a 31 jours alors qu'avril
  n'en a que 30.
 </para>

 <para>
  La soustraction de dates et de timestamps peut aussi être complexe. Une
  façon simple conceptuellement de réaliser une soustraction est de convertir
  chaque valeur en un nombre de secondes en utilisant <literal>EXTRACT(EPOCH
   FROM ...)</literal>, puis de soustraire les résultats&nbsp;; ceci donne un
  nombre de <emphasis>secondes</emphasis> entre les deux valeurs. Ceci
  provoquera un ajustement suivant le nombre de jours pour chaque mois, les
  changements de fuseaux horaires et les ajustements pour les changements
  d'heure. La soustraction de valeurs date ou timestamp avec l'opérateur
  <quote><literal>-</literal></quote> renvoie le nombre de jours (24 heures)
  et les heures/minutes/secondes entre les valeurs, en faisant les mêmes
  ajustements. La fonction <function>age</function> renvoie les années, mois,
  jours et heures/minutes/secondes, soustrayant champ par champ, puis
  ajustant les valeurs négatives. Les requêtes suivantes illustrent les
  différences dans ces approches. Les résultats correspondent au fuseau
  horaire <literal>timezone = 'US/Eastern'</literal>&nbsp;; il y a un
  changement d'heure entre les deux dates utilisées&nbsp;:
 </para>

 <screen>
SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');
<lineannotation>Résultat : </lineannotation><computeroutput>10537200</computeroutput>
SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))
        / 60 / 60 / 24;
<lineannotation>Résultat : </lineannotation><computeroutput>121.958333333333</computeroutput>
SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';
<lineannotation>Résultat : </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');
<lineannotation>Résultat : </lineannotation><computeroutput>4 mons</computeroutput>
 </screen>

 <sect2 id="functions-datetime-extract">
  <title><function>EXTRACT</function>, <function>date_part</function></title>

  <indexterm>
   <primary>date_part</primary>
  </indexterm>
  <indexterm>
   <primary>extract</primary>
  </indexterm>

  <synopsis>
EXTRACT(<replaceable>field</replaceable> FROM <replaceable>source</replaceable>)
  </synopsis>

  <para>
   La fonction <function>extract</function> récupère les champs tels que
   l'année ou l'heure de valeurs date/heure.
   <replaceable>source</replaceable> doit être l'expression d'une valeur de
   type <type>timestamp</type>, <type>time</type> ou <type>interval</type>.
   (Les expressions de type <type>date</type> sont converties en
   <type>timestamp</type> et peuvent de ce fait être aussi utilisées.)
   <replaceable>field</replaceable> est un identifiant ou une chaîne qui
   sélectionne le champ à extraire à partir de la valeur source. La fonction
   <function>extract</function> renvoie des valeurs de type <type>double
    precision</type>. Voici les noms de champ valides&nbsp;:

   <!-- alphabetical -->
   <variablelist>
    <varlistentry>
     <term><literal>century</literal></term>
     <listitem>
      <para>
       The century
      </para>

      <screen>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
<lineannotation>Résultat : </lineannotation><computeroutput>20</computeroutput>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Résultat : </lineannotation><computeroutput>21</computeroutput>
      </screen>

      <para>
       Le première siècle commence le 1er janvier après JC à minuit, bien
       qu'ils ne le savaient pas à ce moment-là. Cette définition s'applique
       à tous les pays utilisant le calendrier Grégorien. Il n'existe pas de
       siècle 0, nous passons du siècle -1 au siècle 1.

       Si vous n'êtes pas d'accord avec ça, merci de vous plaindre au pape,
       Cathédrale Saint Pierre de Rome, Vatican.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>day</literal></term>
     <listitem>
      <para>
       Pour les valeurs <type>timestamp</type>, le champ jour (du mois)
       (1&ndash;31)&nbsp;; pour les valeurs <type>interval</type>, le nombre
       de jours
      </para>

      <screen>
SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Résultat : </lineannotation><computeroutput>16</computeroutput>

SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
<lineannotation>Résultat : </lineannotation><computeroutput>40</computeroutput>
      </screen>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>decade</literal></term>
     <listitem>
      <para>
       Le champ année divisé par 10
      </para>

      <screen>
SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Résultat : </lineannotation><computeroutput>200</computeroutput>
      </screen>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>dow</literal></term>
     <listitem>
      <para>
       Le jour de la semaine du dimanche (<literal>0</literal>) au samedi
       (<literal>6</literal>)
      </para>

      <screen>
SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Résultat : </lineannotation><computeroutput>5</computeroutput>
      </screen>
      <para>
       Notez que la numérotation du jour de la semaine d'après
       <function>extract</function> diffère de celle de la fonction
       <function>to_char(..., 'D')</function>.
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>doy</literal></term>
     <listitem>
      <para>
       Le jour de l'année (1&ndash;365/366)
      </para>

      <screen>
SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Résultat : </lineannotation><computeroutput>47</computeroutput>
      </screen>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>epoch</literal></term>
     <listitem>
      <para>
       Pour les valeurs de type <type>timestamp with time zone</type>, le
       nombre de secondes depuis le 1er janvier 1970 à minuit UTC (peut être
       négatif)&nbsp;; pour les valeurs de type <type>date</type> et
       <type>timestamp</type>, le nombre de secondes depuis le 1er janvier
       1970 à minuit, heure locale&nbsp;; pour les valeurs de type
       <type>interval</type>, le nombre total de secondes dans l'intervalle
      </para>

      <screen>
SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');
<lineannotation>Résultat : </lineannotation><computeroutput>982384720.12</computeroutput>

SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
<lineannotation>Résultat : </lineannotation><computeroutput>442800</computeroutput>
      </screen>

      <para>
       Vous pouvez convertir une valeur epoch en une valeur de type timestamp
       avec la fonction <function>to_timestamp</function>&nbsp;:
      </para>
      <screen>
SELECT to_timestamp(982384720.12);
<lineannotation>Résultat : </lineannotation><computeroutput>2001-02-17 04:38:40.12+00</computeroutput>
      </screen>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hour</literal></term>
     <listitem>
      <para>
       Le champ heure (0&ndash;23)
      </para>

      <screen>
SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Résultat : </lineannotation><computeroutput>20</computeroutput>
      </screen>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>isodow</literal></term>
     <listitem>
      <para>
       Le jour de la semaine du lundi (<literal>1</literal>) au dimanche
       (<literal>7</literal>)
      </para>

      <screen>
SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
<lineannotation>Résultat : </lineannotation><computeroutput>7</computeroutput>
      </screen>
      <para>
       Ceci est identique à <literal>dow</literal> sauf pour les dimanches.
       Ceci correspond à la numérotation du jour de la semaine d'après
       <acronym>ISO</acronym> 8601.
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>isoyear</literal></term>
     <listitem>
      <para>
       L'année suivant la numérotation semaine <acronym>ISO</acronym> 8601
       dans laquelle la date tombe (non applicable aux intervalles)
      </para>

      <screen>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
<lineannotation>Résultat : </lineannotation><computeroutput>2005</computeroutput>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
<lineannotation>Résultat : </lineannotation><computeroutput>2006</computeroutput>
      </screen>

      <para>
       Chaque année suivant la numérotation semaine <acronym>ISO</acronym>
       8601 commence le lundi de la semaine contenant le 4 janvier, donc un
       janvier débutant tôt ou un décembre finissant tard pourrait faire que
       l'année <acronym>ISO</acronym> soit différente de l'année grégorienne.
       Voir le champ <literal>week</literal> pour plus d'informations.
      </para>
      <para>
       Ce champ n'est pas disponible dans les versions de PostgreSQL
       antérieures à la 8.3.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>microseconds</literal></term>
     <listitem>
      <para>
       Le champ des secondes, incluant la partie fractionnelle, multiplié par
       1 000 000&nbsp;; notez que ceci inclut des secondes complètes
      </para>

      <screen>
SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
<lineannotation>Résultat : </lineannotation><computeroutput>28500000</computeroutput>
      </screen>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>millennium</literal></term>
     <listitem>
      <para>
       Le millénaire
      </para>

      <screen>
SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Résultat : </lineannotation><computeroutput>3</computeroutput>
      </screen>

      <para>
       Les années 1900 sont dans le deuxième millénaire. Le troisième
       millénaire commence le 1er janvier 2001.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>milliseconds</literal></term>
     <listitem>
      <para>
       Le champ des secondes, incluant la partie fractionnelle, multipliée
       par 1000. Notez que ceci inclut des secondes complètes.
      </para>

      <screen>
SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
<lineannotation>Résultat : </lineannotation><computeroutput>28500</computeroutput>
      </screen>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>minute</literal></term>
     <listitem>
      <para>
       Le champ des minutes (0&ndash;59)
      </para>

      <screen>
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Résultat : </lineannotation><computeroutput>38</computeroutput>
      </screen>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>month</literal></term>
     <listitem>
      <para>
       Pour les valeurs <type>timestamp</type>, le numéro du mois dans
       l'année (1&ndash;12)&nbsp;; pour les valeurs <type>interval</type>,
       le numéro du mois, modulo 12 (0&ndash;11)
      </para>

      <screen>
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Résultat : </lineannotation><computeroutput>2</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
<lineannotation>Résultat : </lineannotation><computeroutput>3</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
<lineannotation>Résultat : </lineannotation><computeroutput>1</computeroutput>
      </screen>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>quarter</literal></term>
     <listitem>
      <para>
       Le trimestre de l'année (1&ndash;4) dans laquelle la date se trouve
      </para>

      <screen>
SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Résultat : </lineannotation><computeroutput>1</computeroutput>
      </screen>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>second</literal></term>
     <listitem>
      <para>
       Le champs secondes, incluant toutes secondes fractionnelles
      </para>

      <screen>
SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Résultat : </lineannotation><computeroutput>40</computeroutput>

SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
<lineannotation>Résultat : </lineannotation><computeroutput>28.5</computeroutput>
      </screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>timezone</literal></term>
     <listitem>
      <para>
       Le décalage du fuseau horaire, à partir d'UTC, mesuré en secondes. Les
       valeurs positives correspondent aux fuseaux horaires à l'est d'UTC,
       les valeurs négatives aux zones à l'ouest d'UTC. (Techniquement,
       <productname>PostgreSQL</productname> n'utilise pas UTC parce que les
       secondes perdues ne sont pas gérées.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>timezone_hour</literal></term>
     <listitem>
      <para>
       Le composant heure du décalage du fuseau horaire
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>timezone_minute</literal></term>
     <listitem>
      <para>
       Le composant minute du décalage du fuseau horaire
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>week</literal></term>
     <listitem>
      <para>
       Le numéro de la semaine de cette année d'après la numérotation de
       semaine de l'<acronym>ISO</acronym> 8601. Par définition, les semaines
       ISO commencent les lundis et la première semaine de l'année contient
       le 4 janvier de l'année. Autrement dit, le premier jeudi d'une année
       est dans la semaine 1 de cette année.
      </para>
      <para>
       Dans le système ISO de numérotation des semaines, il est possible que
       les dates de début janvier soient dans la semaine 52 ou 53 de l'année
       précédente, et pour les dates de fin décembre de faire partie de la
       première semaine de l'année suivante. Par exemple, le 1er janvier 2005
       fait partie de la semaine 53 de l'année 2004, et le 1er janvier 2006
       fait partie de la semaine 52 de l'année 2005, alors que le 31 décembre
       2012 fait partie de la première semaine de 2013. Il est recommandé
       d'utiliser le champ <literal>isoyear</literal> avec
       <literal>week</literal> pour obtenir des résultats cohérents.
      </para>

      <screen>
SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Résultat : </lineannotation><computeroutput>7</computeroutput>
      </screen>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>year</literal></term>
     <listitem>
      <para>
       Le champ année. Gardez en tête qu'il n'existe pas d'année <literal>0
        AD</literal>, donc soustraire <literal>BC</literal> années de
       <literal>AD</literal> années doit se faire avec prudence.
      </para>

      <screen>
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Résultat : </lineannotation><computeroutput>2001</computeroutput>
      </screen>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>

  <note>
   <para>
    Quand la valeur en entrée est +/-Infinity, <function>extract</function>
    renvoie +/-Infinity pour les champs à augmentation monotonique
    (<literal>epoch</literal>, <literal>julian</literal>,
    <literal>year</literal>, <literal>isoyear</literal>,
    <literal>decade</literal>, <literal>century</literal> et
    <literal>millennium</literal>). Pour les autres champs, NULL est renvoyé.
    Les versions de <productname>PostgreSQL</productname> avant la 9.6
    renvoyaient zéro pour tous les cas si l'entrée est infinie.
   </para>
  </note>

  <para>
   La fonction <function>extract</function> a principalement pour intérêt un
   traitement calculé. Pour le formatage de valeurs date/heure en vue d'un
   affichage, voir <xref linkend="functions-formatting"/>.
  </para>

  <para>
   La fonction <function>date_part</function> est modelée sur l'équivalent
   traditionnel d'<productname>Ingres</productname> pour la fonction
   <function>extract</function> du standard <acronym>SQL</acronym>&nbsp;:
   <synopsis>
date_part('<replaceable>field</replaceable>', <replaceable>source</replaceable>)
   </synopsis>
   Notez qu'ici le paramètre <replaceable>field</replaceable> doit être une
   chaîne, et non pas un nom. Les noms de champs valides pour
   <function>date_part</function> sont les mêmes que pour
   <function>extract</function>.
  </para>

  <screen>
SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Résultat : </lineannotation><computeroutput>16</computeroutput>

SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
<lineannotation>Résultat : </lineannotation><computeroutput>4</computeroutput>
  </screen>

 </sect2>

 <sect2 id="functions-datetime-trunc">
  <title><function>date_trunc</function></title>

  <indexterm>
   <primary>date_trunc</primary>
  </indexterm>

  <para>
   La fonction <function>date_trunc</function> est conceptuellement similaire
   à la fonction <function>trunc</function> pour les nombres.
  </para>

  <para>
   <synopsis>
date_trunc(<replaceable>field</replaceable>, <replaceable>source</replaceable> [, <replaceable>time_zone</replaceable> ])
   </synopsis>
   <replaceable>source</replaceable> est une expression de valeur de type
   <type>timestamp</type>, <type>timestamp with time zone</type> ou
   <type>interval</type>. (Les valeurs de type <type>date</type> et
   <type>time</type> sont converties automatiquement, et respectivement, en
   <type>timestamp</type> ou <type>interval</type>)
   <replaceable>field</replaceable> sélectionne la précision pour le
   troncage de la valeur en entrée. La valeur de retour est de type
   <type>timestamp</type>, <type>timestamp with time zone</type> ou
   <type>interval</type>, et elle contient tous les champs qui sont moins
   significatifs que le champ sélectionné, qui est initialisé à zéro (ou un
   pour le jour et le mois).
  </para>

  <para>
   Les valeurs valides pour <replaceable>field</replaceable> sont&nbsp;:
   <simplelist>
    <member><literal>microseconds</literal></member>
    <member><literal>milliseconds</literal></member>
    <member><literal>second</literal></member>
    <member><literal>minute</literal></member>
    <member><literal>hour</literal></member>
    <member><literal>day</literal></member>
    <member><literal>week</literal></member>
    <member><literal>month</literal></member>
    <member><literal>quarter</literal></member>
    <member><literal>year</literal></member>
    <member><literal>decade</literal></member>
    <member><literal>century</literal></member>
    <member><literal>millennium</literal></member>
   </simplelist>
  </para>

  <para>
   Quand la valeur en entrée est de type <type>timestamp with time
    zone</type>, la troncature est réalisée en respectant un fuseau horaire
   particulier&nbsp;; par exemple, la troncature à <literal>day</literal>
   crée une valeur à minuit de ce fuseau. Par défaut, une troncature se fait
   en respectant le paramètre <xref linkend="guc-timezone"/> mais l'argument
   optionnel <replaceable>time_zone</replaceable> peut être fourni pour
   indiquer un fuseau horaire différent. Le nom du fuseau horaire peut être
   indiqué parmi toutes les façons décrites dans <xref
   linkend="datatype-timezones"/>.
  </para>

  <para>
   Un fuseau horaire ne peut pas être indiqué lors du traitement de données
   <type>timestamp without time zone</type> ou <type>interval</type>. Ce sont
   toujours des valeurs prises directement, sans interprétation.
  </para>

  <para>
   Exemples (en supposant que le fuseau horaire local est
   <literal>America/New_York</literal>)&nbsp;:
   <screen>
SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Résultat : </lineannotation><computeroutput>2001-02-16 20:00:00</computeroutput>

SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Résultat : </lineannotation><computeroutput>2001-01-01 00:00:00</computeroutput>

SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00');
<lineannotation>Résultat : </lineannotation><computeroutput>2001-02-16 00:00:00-05</computeroutput>

SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00', 'Australia/Sydney');
<lineannotation>Résultat : </lineannotation><computeroutput>2001-02-16 08:00:00-05</computeroutput>

SELECT date_trunc('hour', INTERVAL '3 days 02:47:33');
<lineannotation>Résultat : </lineannotation><computeroutput>3 days 02:00:00</computeroutput>
   </screen>
  </para>
 </sect2>

 <sect2 id="functions-datetime-zoneconvert">
  <title><literal>AT TIME ZONE</literal></title>

  <indexterm>
   <primary>time zone</primary>
   <secondary>conversion</secondary>
  </indexterm>

  <indexterm>
   <primary>AT TIME ZONE</primary>
  </indexterm>

  <para>
   L'opérateur <literal>AT TIME ZONE</literal> convertit l'horodatage
   <emphasis>sans</emphasis> sans fuseau horaire en horodatage
   <emphasis>avec</emphasis> fuseau horaire, et des valeurs <type>time with
    time zone</type> dans différents fuseaux horaires. <xref
   linkend="functions-datetime-zoneconvert-table"/> montre les variantes.
  </para>

  <table id="functions-datetime-zoneconvert-table">
   <title>Variantes <literal>AT TIME ZONE</literal></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="func_table_entry"><para role="func_signature">
        Opérateur
       </para>
       <para>
        Description
       </para>
       <para>
        Exemple(s)
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <type>timestamp without time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Convertit l'horodatage donné <emphasis>sans</emphasis> fuseau horaire
        en horodatage <emphasis>avec</emphasis> fuseau horaire en supposant
        que la valeur indiquée est dans le fuseau horaire nommé.
       </para>
       <para>
        <literal>timestamp '2001-02-16 20:38:40' at time zone 'America/Denver'</literal>
        <returnvalue>2001-02-17 03:38:40+00</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <type>timestamp with time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
        <returnvalue>timestamp without time zone</returnvalue>
       </para>
       <para>
        Convertit l'horodatage donné <emphasis>avec</emphasis> fuseau horaire
        en horodatage <emphasis>sans</emphasis> sans fuseau horaire, comme si
        l'heure apparaissait dans ce fuseau.
       </para>
       <para>
        <literal>timestamp with time zone '2001-02-16 20:38:40-05' at time zone 'America/Denver'</literal>
        <returnvalue>2001-02-16 18:38:40</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <type>time with time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
        <returnvalue>time with time zone</returnvalue>
       </para>
       <para>
        Convertit l'heure donnée <emphasis>avec</emphasis> fuseau horaire
        dans un nouveau fuseau horaire. Comme aucune date n'est fournie, cela
        utilise le décalage UTC actuellement actif pour le fuseau horaire de
        destination.
       </para>
       <para>
        <literal>time with time zone '05:34:17-05' at time zone 'UTC'</literal>
        <returnvalue>10:34:17+00</returnvalue>
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Dans ces expressions, le fuseau horaire désiré
   <replaceable>zone</replaceable> peut être spécifié soit sous la forme
   d'une valeur de type texte (par exemple
   <literal>'America/Los_Angeles'</literal>) soit comme un intervalle (par
   exemple <literal>INTERVAL '-08:00'</literal>). Dans le cas du texte, le
   nom du fuseau horaire peut être indiqué d'une des façons décrites dans
   <xref linkend="datatype-timezones"/>. Dans le cas de l'intervalle, il est
   uniquement utile pour les fuseaux qui ont des décalages fixes d'UTC, donc
   ce n'est pas très courant.
  </para>

  <para>
   Exemples (en supposant que le paramètre <xref linkend="guc-timezone"/> a
   comme valeur actuelle <literal>America/Los_Angeles</literal>)&nbsp;:
   <screen>
SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'America/Denver';
<lineannotation>Résultat : </lineannotation><computeroutput>2001-02-16 19:38:40-08</computeroutput>

SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'America/Denver';
<lineannotation>Résultat : </lineannotation><computeroutput>2001-02-16 18:38:40</computeroutput>

SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'Asia/Tokyo' AT TIME ZONE 'America/Chicago';
<lineannotation>Résultat : </lineannotation><computeroutput>2001-02-16 05:38:40</computeroutput>
   </screen>
   Le premier exemple ajoute un fuseau horaire à une valeur qui en manque, et
   affiche la valeur en utilisant le paramétrage actuel de
   <varname>TimeZone</varname>. Le deuxième exemple décale l'horodatage avec
   fuseau horaire dans le fuseau horaire indiqué, et envoie la valeur sans
   fuseau horaire. Ceci permet le stockage et l'affichage de valeurs
   différentes de la configuration actuelle de <varname>TimeZone</varname>.
   Le troisième exemple convertit l'heure de Tokyo en heure de Chicago.
  </para>

  <para>
   La fonction
   <literal><function>timezone</function>(<replaceable>zone</replaceable>,
    <replaceable>timestamp</replaceable>)</literal> est équivalente à la
   construction conforme au standard SQL
   <literal><replaceable>timestamp</replaceable> AT TIME ZONE
    <replaceable>zone</replaceable></literal>.
  </para>
 </sect2>

 <sect2 id="functions-datetime-current">
  <title>Date/Heure actuelle</title>

  <indexterm>
   <primary>date</primary>
   <secondary>actuelle</secondary>
  </indexterm>

  <indexterm>
   <primary>heure</primary>
   <secondary>actuelle</secondary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> fournit un certain nombre de
   fonctions qui renvoient des valeurs relatives à la date et l'heure
   actuelles. Ces fonctions SQL renvoient des valeurs basées sur l'heure de
   début de la transaction&nbsp;:
   <synopsis>
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(<replaceable>precision</replaceable>)
CURRENT_TIMESTAMP(<replaceable>precision</replaceable>)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(<replaceable>precision</replaceable>)
LOCALTIMESTAMP(<replaceable>precision</replaceable>)
   </synopsis>
  </para>

  <para>
   <function>CURRENT_TIME</function> et
   <function>CURRENT_TIMESTAMP</function> renvoient des valeurs avec fuseau horaire&nbsp;;
   <function>LOCALTIME</function> et
   <function>LOCALTIMESTAMP</function> renvoient des valeurs sans fuseau horaire.
  </para>

  <para>
   <function>CURRENT_TIME</function>,
   <function>CURRENT_TIMESTAMP</function>,
   <function>LOCALTIME</function> et
   <function>LOCALTIMESTAMP</function>
   peuvent prendre en option un paramètre de précision qui impose que le
   résultat soit arrondi à ce nombre de chiffres dans le champ des secondes.
   Sans paramètre de précision, le résultat est donné avec toute la
   précision disponible.
  </para>

  <para>
   Quelques exemples&nbsp;:
   <screen>
SELECT CURRENT_TIME;
<lineannotation>Résultat : </lineannotation><computeroutput>14:39:53.662522-05</computeroutput>

SELECT CURRENT_DATE;
<lineannotation>Résultat : </lineannotation><computeroutput>2019-12-23</computeroutput>

SELECT CURRENT_TIMESTAMP;
<lineannotation>Résultat : </lineannotation><computeroutput>2019-12-23 14:39:53.662522-05</computeroutput>

SELECT CURRENT_TIMESTAMP(2);
<lineannotation>Résultat : </lineannotation><computeroutput>2019-12-23 14:39:53.66-05</computeroutput>

SELECT LOCALTIMESTAMP;
<lineannotation>Résultat : </lineannotation><computeroutput>2019-12-23 14:39:53.662522</computeroutput>
   </screen>
  </para>

  <para>
   Comme ces fonctions renvoient l'heure du début de la transaction en cours,
   leurs valeurs ne changent pas lors de la transaction courante. Ceci est
   considéré comme une fonctionnalité&nbsp;: le but est de permettre à une
   même transaction d'avoir une notion cohérente de l'heure
   <quote>actuelle</quote>, pour que plusieurs modifications au sein de la
   même transactions arrivent au même moment grâce à un même horodatage.
  </para>

  <note>
   <para>
    D'autres systèmes de bases de données pourraient mettre à jour ces
    valeurs plus fréquemment.
   </para>
  </note>

  <para>
   <productname>PostgreSQL</productname> fournit aussi des fonctions qui
   renvoient l'heure de début de la requête en cours, ainsi que l'heure
   actuelle au moment où la fonction est appelée. La liste complète des
   fonctions d'heure, ne faisant pas parti du standard SQL, est la
   suivante&nbsp;:
   <synopsis>
transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()
   </synopsis>
  </para>

  <para>
   <function>transaction_timestamp()</function> est équivalent à
   <function>CURRENT_TIMESTAMP</function>, mais est nommée ainsi pour
   refléter clairement ce qu'il renvoie.
   <function>statement_timestamp()</function> renvoie l'heure de début de la
   requête en cours (plus spécifiquement, l'heure de réception du dernier
   message de commande du client). <function>statement_timestamp()</function>
   et <function>transaction_timestamp()</function> renvoient la même valeur
   lors de la première commande d'une transaction, mais pourrait différer
   lors des commandes suivantes. <function>clock_timestamp()</function>
   renvoie l'heure actuelle, et de ce fait, sa valeur changera y compris au
   sein d'une même commande SQL. <function>timeofday()</function> est une
   fonction historique de <productname>PostgreSQL</productname>. Tout comme
   <function>clock_timestamp()</function>, elle renvoie l'heure actuelle,
   mais formatée sous la forme d'une chaîne de type <type>text</type> plutôt
   que sous la forme d'une valeur de type <type>timestamp with time
    zone</type>. <function>now()</function> est un équivalent historique de
   <productname>PostgreSQL</productname> pour
   <function>transaction_timestamp()</function>.
  </para>

  <para>
   Tous les types de données date/heure acceptent aussi la valeur littérale
   spéciale <literal>now</literal> pour indiquer la date et l'heure actuelle
   (encore une fois, interprété comme l'heure de début de la transaction). De
   ce fait, les trois suivants renvoient tous le même résultat&nbsp;:
   <programlisting>
SELECT CURRENT_TIMESTAMP;
SELECT now();
SELECT TIMESTAMP 'now'; -- mais voir l'astuce ci-dessous
   </programlisting>
  </para>

  <tip>
   <para>
    Ne pas utiliser la troisième forme lors de la spécification d'une valeur
    à évaluer ultérieurement, par exemple dans une clause
    <literal>DEFAULT</literal> de la colonne d'une table.  Le système
    convertirait <literal>now</literal> en valeur de type
    <type>timestamp</type> dès l'analyse de la constante. À chaque fois que
    la valeur par défaut est nécessaire, c'est l'heure de création de la
    table qui est alors utilisée. Les deux premières formes ne sont pas
    évaluées avant l'utilisation de la valeur par défaut, il s'agit d'appels
    de fonctions. C'est donc bien le comportement attendu, l'heure
    d'insertion comme valeur par défaut, qui est obtenu. (Voir aussi <xref
    linkend="datatype-datetime-special-values"/>.)
   </para>
  </tip>
 </sect2>

 <sect2 id="functions-datetime-delay">
  <title>Retarder l'exécution</title>

  <indexterm>
   <primary>pg_sleep</primary>
  </indexterm>
  <indexterm>
   <primary>pg_sleep_for</primary>
  </indexterm>
  <indexterm>
   <primary>pg_sleep_until</primary>
  </indexterm>
  <indexterm>
   <primary>sleep</primary>
  </indexterm>
  <indexterm>
   <primary>delay</primary>
  </indexterm>

  <para>
   Les fonctions suivants sont disponibles pour retarder l'exécution du
   traitement du serveur&nbsp;:
   <synopsis>
pg_sleep ( <type>double precision</type> )
pg_sleep_for ( <type>interval</type> )
pg_sleep_until ( <type>timestamp with time zone</type> )
   </synopsis>

   <function>pg_sleep</function> cause la pause du processus de la session en
   cours pour le nombre indiqué de secondes. Un délai peut être spécifié avec
   une partie fractionnelle pour les secondes
   <function>pg_sleep_for</function> est une fonction pratique pour indiquer
   le temps de pause sous la forme d'un <type>interval</type>.
   <function>pg_sleep_until</function> est une autre fonction pratique pour
   indiquer une heure de réveil, à la place d'une durée de pause. Par
   exemple&nbsp;:

   <programlisting>
SELECT pg_sleep(1.5);
SELECT pg_sleep_for('5 minutes');
SELECT pg_sleep_until('tomorrow 03:00');
   </programlisting>
  </para>

  <note>
   <para>
    La résolution réelle de l'intervalle de pause est spécifique à la
    plateforme&nbsp;; 0,01 secondes est une valeur assez générale. La durée
    de pause sera au moins aussi longue que celle indiquée. Elle pourra être
    plus longue suivant des facteurs comme la charge du serveur. En
    particulier, <function>pg_sleep_until</function> ne garantie pas de se
    réveiller précisément à l'heure indiquée, mais elle ne se réveillera pas
    avant.
   </para>
  </note>

  <warning>
   <para>
    Assurez-vous que votre session ne détient pas plus de verrous que
    nécessaire lors de l'appel de <function>pg_sleep</function> ou une de
    ses variantes. Sinon, d'autres sessions pourraient avoir à attendre le
    processus en attente, ralentissant le système entier.
   </para>
  </warning>
 </sect2>

</sect1>


<sect1 id="functions-enum">
 <title>Fonctions de support d'enum</title>

 <para>
  Pour les types enum (décrites dans <xref linkend="datatype-enum"/>), il
  existe différentes fonctions permettant une programmation propre sans
  codage en dur de valeurs particulières d'un type enum. Elles sont listées
  dans <xref linkend="functions-enum-table"/>. Les exemples supposent un type
  enum créé ainsi&nbsp;:

  <programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
  </programlisting>

 </para>

 <table id="functions-enum-table">
  <title>Fonctions de support des enum</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>enum_first</primary>
       </indexterm>
       <function>enum_first</function> ( <type>anyenum</type> )
       <returnvalue>anyenum</returnvalue>
      </para>
      <para>
       Renvoie la première valeur d'un type enum en entrée.
      </para>
      <para>
       <literal>enum_first(null::rainbow)</literal>
       <returnvalue>red</returnvalue>
      </para></entry>
    </row>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>enum_last</primary>
       </indexterm>
       <function>enum_last</function> ( <type>anyenum</type> )
       <returnvalue>anyenum</returnvalue>
      </para>
      <para>
       Renvoie la dernière valeur d'un type enum en entrée.
      </para>
      <para>
       <literal>enum_last(null::rainbow)</literal>
       <returnvalue>purple</returnvalue>
      </para></entry>
    </row>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>enum_range</primary>
       </indexterm>
       <function>enum_range</function> ( <type>anyenum</type> )
       <returnvalue>anyarray</returnvalue>
      </para>
      <para>
       Renvoie toutes les valeurs du type enum en entrée dans un tableau trié.
      </para>
      <para>
       <literal>enum_range(null::rainbow)</literal>
       <returnvalue>{red,orange,yellow,&zwsp;green,blue,purple}</returnvalue>
      </para></entry>
    </row>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>enum_range</function> ( <type>anyenum</type>, <type>anyenum</type> )
       <returnvalue>anyarray</returnvalue>
      </para>
      <para>
       Renvoie l'intervalle entre deux valeurs enum données, comme un tableau
       trié. Les valeurs doivent être dans le même type enum. Si le premier
       paramètre est NULL, le résultat commencera avec la première valeur du
       type enum. Si le second paramètre est NULL, le résultat se terminera
       avec la dernière valeur du type enum.
      </para>
      <para>
       <literal>enum_range('orange'::rainbow, 'green'::rainbow)</literal>
       <returnvalue>{orange,yellow,green}</returnvalue>
      </para>
      <para>
       <literal>enum_range(NULL, 'green'::rainbow)</literal>
       <returnvalue>{red,orange,&zwsp;yellow,green}</returnvalue>
      </para>
      <para>
       <literal>enum_range('orange'::rainbow, NULL)</literal>
       <returnvalue>{orange,yellow,green,&zwsp;blue,purple}</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
  Notez que, sauf pour la forme de <function>enum_range</function> à deux
  arguments, ces fonctions ignorent la valeur spécifique fournie. Seul
  importe le type de donnée déclaré. Peut être fourni soit NULL soit une
  valeur spécifique du type de données déclaré, avec le même résultat. Il
  est plus fréquent d'appliquer ces fonctions à une colonne d'une table ou à
  un argument d'une fonction qu'un nom de type codé en dur, comme utilisé
  dans les exemples.
 </para>
</sect1>

<sect1 id="functions-geometry">
 <title>Fonctions et opérateurs de géométrie</title>

 <para>
  Les types géométriques <type>point</type>, <type>box</type>,
  <type>lseg</type>, <type>line</type>, <type>path</type>,
  <type>polygon</type> et <type>circle</type> ont un large ensemble des
  fonctions et opérateurs de support natifs, affichés dans <xref
  linkend="functions-geometry-op-table"/>, <xref
  linkend="functions-geometry-func-table"/> et <xref
  linkend="functions-geometry-conv-table"/>.
 </para>

 <table id="functions-geometry-op-table">
  <title>Opérateurs géométriques</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Opérateur
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>+</literal> <type>point</type>
       <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
      </para>
      <para>
       Ajoute les coordonnées du deuxième <type>point</type> à celles du
       premier argument, réalisant ainsi la translation. Disponible pour les
       types <type>point</type>, <type>box</type>, <type>path</type>,
       <type>circle</type>.
      </para>
      <para>
       <literal>box '(1,1),(0,0)' + point '(2,0)'</literal>
       <returnvalue>(3,1),(2,0)</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>path</type> <literal>+</literal> <type>path</type>
       <returnvalue>path</returnvalue>
      </para>
      <para>
       Concatène deux chemins ouverts (renvoie NULL si un des chemins est fermé).
      </para>
      <para>
       <literal>path '[(0,0),(1,1)]' + path '[(2,2),(3,3),(4,4)]'</literal>
       <returnvalue>[(0,0),(1,1),(2,2),(3,3),(4,4)]</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>-</literal> <type>point</type>
       <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
      </para>
      <para>
       Soustrait les coordonnées du deuxième <type>point</type> de celle de
       chaque point du premier argument, réalisant ainsi la translation.
       Disponible pour les types <type>point</type>, <type>box</type>,
       <type>path</type>, <type>circle</type>.
      </para>
      <para>
       <literal>box '(1,1),(0,0)' - point '(2,0)'</literal>
       <returnvalue>(-1,1),(-2,0)</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>*</literal> <type>point</type>
       <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
      </para>
      <para>
       Multiplie chaque point du premier argument avec le second
       <type>point</type> (traitant un point comme étant un nombre complexe
       représenté par une partie réelle et une partie imaginaire, et
       réalisant ainsi une multiplication standard complexe). Si on
       interprète le deuxième <type>point</type> comme un vecteur, ceci est
       équivalent à mettre à l'échelle la taille et la distance de l'objet de
       l'origine par la longueur de la vecteur, et en faisant une rotation en
       sens inverse de l'horloge autour de l'origine par l'angle du vecteur
       sur l'axe <replaceable>x</replaceable>. Disponible pour les types
       <type>point</type>, <type>box</type>,<footnote
       id="functions-geometry-rotation-fn"><para>Faire une
         <quote>Rotation</quote> d'une boîte avec ces opérateurs déplace
         seulement ses coins&nbsp;: la boîte est toujours considérée avoir des
         côtés parallèles sur les axes. De ce fait, la taille de la boîte n'est
         pas préservée, bien qu'une vraie rotation le ferait.</para></footnote>
       <type>path</type>, <type>circle</type>.
      </para>
      <para>
       <literal>path '((0,0),(1,0),(1,1))' * point '(3.0,0)'</literal>
       <returnvalue>((0,0),(3,0),(3,3))</returnvalue>
      </para>
      <para>
       <literal>path '((0,0),(1,0),(1,1))' * point(cosd(45), sind(45))</literal>
       <returnvalue>((0,0),&zwsp;(0.7071067811865475,0.7071067811865475),&zwsp;(0,1.414213562373095))</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>/</literal> <type>point</type>
       <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
      </para>
      <para>
       Divise chaque point du premier argument par le deuxième
       <type>point</type> (traitant un point comme étant un nombre complexe
       représenté par les parties réelle et imaginaire, et réalisant la
       division complexe standard). Si on interprète le deuxième
       <type>point</type> comme un vecteur, ceci est équivalent à mettre à
       l'échelle la taille et la distance de l'objet à partir de l'origine
       sur la longueur du vecteur et en faisant une rotation en sens inverse
       de l'horloge autour de l'origine par l'angle du vecteur sur l'axe
       <replaceable>x</replaceable>. Disponible pour les types
       <type>point</type>, <type>box</type>,<footnoteref
       linkend="functions-geometry-rotation-fn"/> <type>path</type>,
       <type>circle</type>.
      </para>
      <para>
       <literal>path '((0,0),(1,0),(1,1))' / point '(2.0,0)'</literal>
       <returnvalue>((0,0),(0.5,0),(0.5,0.5))</returnvalue>
      </para>
      <para>
       <literal>path '((0,0),(1,0),(1,1))' / point(cosd(45), sind(45))</literal>
       <returnvalue>((0,0),&zwsp;(0.7071067811865476,-0.7071067811865476),&zwsp;(1.4142135623730951,0))</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <literal>@-@</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Calcule la longueur totale.
       Disponible pour les types <type>lseg</type>, <type>path</type>.
      </para>
      <para>
       <literal>@-@ path '[(0,0),(1,0),(1,1)]'</literal>
       <returnvalue>2</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <literal>@@</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>point</returnvalue>
      </para>
      <para>
       Calcule le point central.
       Disponible pour les types <type>box</type>, <type>lseg</type>, <type>path</type>,
       <type>polygon</type>, <type>circle</type>.
      </para>
      <para>
       <literal>@@ box '(2,2),(0,0)'</literal>
       <returnvalue>(1,1)</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <literal>#</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre de points.
       Disponible pour les types <type>path</type>, <type>polygon</type>.
      </para>
      <para>
       <literal># path '((1,0),(0,1),(-1,0))'</literal>
       <returnvalue>3</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>#</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>point</returnvalue>
      </para>
      <para>
       Calcule le point d'intersection, ou NULL s'il n'y en a pas.
       Disponible pour les types <type>lseg</type>, <type>line</type>.
      </para>
      <para>
       <literal>lseg '[(0,0),(1,1)]' # lseg '[(1,0),(0,1)]'</literal>
       <returnvalue>(0.5,0.5)</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>box</type> <literal>#</literal> <type>box</type>
       <returnvalue>box</returnvalue>
      </para>
      <para>
       Calcule de l'intersection de deux boîtes, ou NULL s'il n'y en a pas.
      </para>
      <para>
       <literal>box '(2,2),(-1,-1)' # box '(1,1),(-2,-2)'</literal>
       <returnvalue>(1,1),(-1,-1)</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>##</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>point</returnvalue>
      </para>
      <para>
       Calcule le point le plus proche du premier objet à partir du deuxième
       objet. Disponible pour ces paires de types&nbsp;:
       (<type>point</type>, <type>box</type>),
       (<type>point</type>, <type>lseg</type>),
       (<type>point</type>, <type>line</type>),
       (<type>lseg</type>, <type>box</type>),
       (<type>lseg</type>, <type>lseg</type>),
       (<type>lseg</type>, <type>line</type>),
       (<type>line</type>, <type>box</type>),
       (<type>line</type>, <type>lseg</type>).
      </para>
      <para>
       <literal>point '(0,0)' ## lseg '[(2,0),(0,2)]'</literal>
       <returnvalue>(1,1)</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>&lt;-&gt;</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Calcule la distance entre les objets. Disponible pour tous les sept
       types géométriques, pour toutes les combinaisons du <type>point</type>
       avec un autre type géométrique, et pour ces paires supplémentaires de
       types&nbsp;: (<type>box</type>, <type>lseg</type>), (<type>box</type>,
       <type>line</type>), (<type>lseg</type>, <type>line</type>),
       (<type>polygon</type>, <type>circle</type>) (et les cas de
       commutation).
      </para>
      <para>
       <literal>circle '&lt;(0,0),1&gt;' &lt;-&gt; circle '&lt;(5,0),1&gt;'</literal>
       <returnvalue>3</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>@&gt;</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que le premier objet contient le second&nbsp;?
       Disponible pour ces paires de types&nbsp;:
       (<literal>box</literal>, <literal>point</literal>),
       (<literal>box</literal>, <literal>box</literal>),
       (<literal>path</literal>, <literal>point</literal>),
       (<literal>polygon</literal>, <literal>point</literal>),
       (<literal>polygon</literal>, <literal>polygon</literal>),
       (<literal>circle</literal>, <literal>point</literal>),
       (<literal>circle</literal>, <literal>circle</literal>).
      </para>
      <para>
       <literal>circle '&lt;(0,0),2&gt;' @&gt; point '(1,1)'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>&lt;@</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que le premier objet est contenu dans le second&nbsp;?
       Disponibles pour ces paires de types&nbsp;:
       (<literal>point</literal>, <literal>box</literal>),
       (<literal>point</literal>, <literal>lseg</literal>),
       (<literal>point</literal>, <literal>line</literal>),
       (<literal>point</literal>, <literal>path</literal>),
       (<literal>point</literal>, <literal>polygon</literal>),
       (<literal>point</literal>, <literal>circle</literal>),
       (<literal>box</literal>, <literal>box</literal>),
       (<literal>lseg</literal>, <literal>box</literal>),
       (<literal>lseg</literal>, <literal>line</literal>),
       (<literal>polygon</literal>, <literal>polygon</literal>),
       (<literal>circle</literal>, <literal>circle</literal>).
      </para>
      <para>
       <literal>point '(1,1)' &lt;@ circle '&lt;(0,0),2&gt;'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>&amp;&amp;</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que ces objets se surchargent&nbsp;? (Un point en commun rend ceci vrai.)
       Disponible pour <type>box</type>, <type>polygon</type>,
       <type>circle</type>.
      </para>
      <para>
       <literal>box '(1,1),(0,0)' &amp;&amp; box '(2,2),(0,0)'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>&lt;&lt;</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que le premier objet est strictement à gauche du second&nbsp;?
       Disponible pour <type>point</type>, <type>box</type>,
       <type>polygon</type>, <type>circle</type>.
      </para>
      <para>
       <literal>circle '&lt;(0,0),1&gt;' &lt;&lt; circle '&lt;(5,0),1&gt;'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>&gt;&gt;</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que le premier objet est strictement à droite du second&nbsp;?
       Disponible pour <type>point</type>, <type>box</type>,
       <type>polygon</type>, <type>circle</type>.
      </para>
      <para>
       <literal>circle '&lt;(5,0),1&gt;' &gt;&gt; circle '&lt;(0,0),1&gt;'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>&amp;&lt;</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que le premier objet ne s'étend pas à droite du second&nbsp;?
       Disponible pour <type>box</type>, <type>polygon</type>,
       <type>circle</type>.
      </para>
      <para>
       <literal>box '(1,1),(0,0)' &amp;&lt; box '(2,2),(0,0)'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>&amp;&gt;</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que le premier objet ne s'étend pas à gauche du second&nbsp;?
       Disponible pour <type>box</type>, <type>polygon</type>,
       <type>circle</type>.
      </para>
      <para>
       <literal>box '(3,3),(0,0)' &amp;&gt; box '(2,2),(0,0)'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>&lt;&lt;|</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que le premier objet se trouve strictement en dessous du second&nbsp;?
       Disponible pour <type>box</type>, <type>polygon</type>,
       <type>circle</type>.
      </para>
      <para>
       <literal>box '(3,3),(0,0)' &lt;&lt;| box '(5,5),(3,4)'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>|&gt;&gt;</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que le premier objet se trouve strictement au-dessus du second&nbsp;?
       Disponible pour <type>box</type>, <type>polygon</type>,
       <type>circle</type>.
      </para>
      <para>
       <literal>box '(5,5),(3,4)' |&gt;&gt; box '(3,3),(0,0)'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>&amp;&lt;|</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Does first object not extend above second?
       Disponible pour <type>box</type>, <type>polygon</type>,
       <type>circle</type>.
      </para>
      <para>
       <literal>box '(1,1),(0,0)' &amp;&lt;| box '(2,2),(0,0)'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>|&amp;&gt;</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que le premier objet ne s'étend pas en dessous du second&nbsp;?
       Disponible pour <type>box</type>, <type>polygon</type>,
       <type>circle</type>.
      </para>
      <para>
       <literal>box '(3,3),(0,0)' |&amp;&gt; box '(2,2),(0,0)'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>box</type> <literal>&lt;^</literal> <type>box</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que le premier objet est en-dessous du second (les coins peuvent
       se toucher)&nbsp;?
      </para>
      <para>
       <literal>box '((1,1),(0,0))' &lt;^ box '((2,2),(1,1))'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>point</type> <literal>&lt;^</literal> <type>point</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que le premier objet se trouve strictement en dessous du second&nbsp;?
       (Cet opérateur est mal nommé&nbsp;; cela devrait être <literal>&lt;&lt;|</literal>.)
      </para>
      <para>
       <literal>point '(1,0)' &lt;^ point '(1,1)'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>box</type> <literal>&gt;^</literal> <type>box</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que le premier objet se trouve au dessus du second (les coins
       peuvent se toucher)&nbsp;?
      </para>
      <para>
       <literal>box '((2,2),(1,1))' &gt;^ box '((1,1),(0,0))'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>point</type> <literal>&gt;^</literal> <type>point</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que le première objet est strictement au dessus du second&nbsp;?
       (Cet opérateur est mal nommé&nbsp;; cela devrait être <literal>|&gt;&gt;</literal>.)
      </para>
      <para>
       <literal>point '(1,1)' &gt;^ point '(1,0)'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>?#</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que ces objets s'intersectent&nbsp;?
       Disponible pour ces paires de types&nbsp;:
       (<type>box</type>, <type>box</type>),
       (<type>lseg</type>, <type>box</type>),
       (<type>lseg</type>, <type>lseg</type>),
       (<type>lseg</type>, <type>line</type>),
       (<type>line</type>, <type>box</type>),
       (<type>line</type>, <type>line</type>),
       (<type>path</type>, <type>path</type>).
      </para>
      <para>
       <literal>lseg '[(-1,0),(1,0)]' ?# box '(2,2),(-2,-2)'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <literal>?-</literal> <type>line</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para role="func_signature">
       <literal>?-</literal> <type>lseg</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       La lign est-elle horizontale&nbsp;?
      </para>
      <para>
       <literal>?- lseg '[(-1,0),(1,0)]'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>point</type> <literal>?-</literal> <type>point</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Les points sont-ils alignés horizontalement (autrement dit, même coordonnée y)&nbsp;?
      </para>
      <para>
       <literal>point '(1,0)' ?- point '(0,0)'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <literal>?|</literal> <type>line</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para role="func_signature">
       <literal>?|</literal> <type>lseg</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       La ligne est-elle verticale&nbsp;?
      </para>
      <para>
       <literal>?| lseg '[(-1,0),(1,0)]'</literal>
       <returnvalue>f</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>point</type> <literal>?|</literal> <type>point</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Les points sont-ils alignés verticalement (autrement dit, même coordonnée x)&nbsp;?
      </para>
      <para>
       <literal>point '(0,1)' ?| point '(0,0)'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>line</type> <literal>?-|</literal> <type>line</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para role="func_signature">
       <type>lseg</type> <literal>?-|</literal> <type>lseg</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Les lignes sont-elles perpendiculaires&nbsp;?
      </para>
      <para>
       <literal>lseg '[(0,0),(0,1)]' ?-| lseg '[(0,0),(1,0)]'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>line</type> <literal>?||</literal> <type>line</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para role="func_signature">
       <type>lseg</type> <literal>?||</literal> <type>lseg</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Les lignes sont-elles parallèles&nbsp;?
      </para>
      <para>
       <literal>lseg '[(-1,0),(1,0)]' ?|| lseg '[(-1,2),(1,2)]'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <replaceable>geometric_type</replaceable> <literal>~=</literal> <replaceable>geometric_type</replaceable>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Ces objets sont-ils les mêmes&nbsp;?
       Disponible pour <type>point</type>, <type>box</type>,
       <type>polygon</type>, <type>circle</type>.
      </para>
      <para>
       <literal>polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <caution>
  <para>
   Notez que l'opérateur <quote>same as</quote>, <literal>~=</literal>,
   représente la notion habituelle d'égalité pour les types
   <type>point</type>, <type>box</type>, <type>polygon</type> et
   <type>circle</type>. Certains types géométriques ont aussi un opérateur
   <literal>=</literal> mais <literal>=</literal> compare seulement des
   <emphasis>aires</emphasis> égales. Les autres opérateurs de comparaison
   scalaires (<literal>&lt;=</literal> et ainsi de suite), si disponibles
   pour ces types, comparent aussi des aires.
  </para>
 </caution>

 <note>
  <para>
   Avant <productname>PostgreSQL</productname> 8.2, les opérateurs de
   confinement <literal>@&gt;</literal> et <literal>&lt;@</literal> étaient
   respectivement appelés <literal>~</literal> et <literal>@</literal>. Ces
   noms sont toujours disponibles mais sont obsolètes et finiront par être
   supprimés.
  </para>
 </note>

 <table id="functions-geometry-func-table">
  <title>Fonctions géométriques</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>area</primary>
       </indexterm>
       <function>area</function> ( <replaceable>geometric_type</replaceable> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Calcule l'aire.
       Disponible pour <type>box</type>, <type>path</type>, <type>circle</type>.
       Une entrée <type>path</type> doit être terminée, sinon NULL est
       renvoyé. De plus, si <type>path</type> s'intersecte lui-même, le
       résultat pourrait ne pas avoir de signification.
      </para>
      <para>
       <literal>area(box '(2,2),(0,0)')</literal>
       <returnvalue>4</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>center</primary>
       </indexterm>
       <function>center</function> ( <replaceable>geometric_type</replaceable> )
       <returnvalue>point</returnvalue>
      </para>
      <para>
       Calcule le point central.
       Disponible pour <type>box</type>, <type>circle</type>.
      </para>
      <para>
       <literal>center(box '(1,2),(0,0)')</literal>
       <returnvalue>(0.5,1)</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>diagonal</primary>
       </indexterm>
       <function>diagonal</function> ( <type>box</type> )
       <returnvalue>lseg</returnvalue>
      </para>
      <para>
       Extrait la diagonale de la boîte sous la forme d'un segment de ligne
       (identique à <function>lseg(box)</function>).
      </para>
      <para>
       <literal>diagonal(box '(1,2),(0,0)')</literal>
       <returnvalue>[(1,2),(0,0)]</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>diameter</primary>
       </indexterm>
       <function>diameter</function> ( <type>circle</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Calcule le diamètre d'un cercle.
      </para>
      <para>
       <literal>diameter(circle '&lt;(0,0),2&gt;')</literal>
       <returnvalue>4</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>height</primary>
       </indexterm>
       <function>height</function> ( <type>box</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Calcule la taille verticale d'une boîte.
      </para>
      <para>
       <literal>height(box '(1,2),(0,0)')</literal>
       <returnvalue>2</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>isclosed</primary>
       </indexterm>
       <function>isclosed</function> ( <type>path</type> )
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Le chemin est-il fermé&nbsp;?
      </para>
      <para>
       <literal>isclosed(path '((0,0),(1,1),(2,0))')</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>isopen</primary>
       </indexterm>
       <function>isopen</function> ( <type>path</type> )
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Le chemin est-il ouvert&nbsp;?
      </para>
      <para>
       <literal>isopen(path '[(0,0),(1,1),(2,0)]')</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>length</primary>
       </indexterm>
       <function>length</function> ( <replaceable>geometric_type</replaceable> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Calcule la longueur totale.
       Disponible pour <type>lseg</type>, <type>path</type>.
      </para>
      <para>
       <literal>length(path '((-1,0),(1,0))')</literal>
       <returnvalue>4</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>npoints</primary>
       </indexterm>
       <function>npoints</function> ( <replaceable>geometric_type</replaceable> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre de points.
       Disponible pour <type>path</type>, <type>polygon</type>.
      </para>
      <para>
       <literal>npoints(path '[(0,0),(1,1),(2,0)]')</literal>
       <returnvalue>3</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>pclose</primary>
       </indexterm>
       <function>pclose</function> ( <type>path</type> )
       <returnvalue>path</returnvalue>
      </para>
      <para>
       Convertit le chemin en un chemin fermé.
      </para>
      <para>
       <literal>pclose(path '[(0,0),(1,1),(2,0)]')</literal>
       <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>popen</primary>
       </indexterm>
       <function>popen</function> ( <type>path</type> )
       <returnvalue>path</returnvalue>
      </para>
      <para>
       Convertit le chemin en un chemin ouvert.
      </para>
      <para>
       <literal>popen(path '((0,0),(1,1),(2,0))')</literal>
       <returnvalue>[(0,0),(1,1),(2,0)]</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>radius</primary>
       </indexterm>
       <function>radius</function> ( <type>circle</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Calcule le rayon du cercle.
      </para>
      <para>
       <literal>radius(circle '&lt;(0,0),2&gt;')</literal>
       <returnvalue>2</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>slope</primary>
       </indexterm>
       <function>slope</function> ( <type>point</type>, <type>point</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Calcule la pente d'une ligne tracée entre les deux points.
      </para>
      <para>
       <literal>slope(point '(0,0)', point '(2,1)')</literal>
       <returnvalue>0.5</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>width</primary>
       </indexterm>
       <function>width</function> ( <type>box</type> )
       <returnvalue>double precision</returnvalue>
      </para>
      <para>
       Calcule la taille horizontale d'une boîte.
      </para>
      <para>
       <literal>width(box '(1,2),(0,0)')</literal>
       <returnvalue>1</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <table id="functions-geometry-conv-table">
  <title>Fonctions de conversion de type géométrique</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>
   <tbody>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>box</primary>
       </indexterm>
       <function>box</function> ( <type>circle</type> )
       <returnvalue>box</returnvalue>
      </para>
      <para>
       Calcule la boîte inscrite dans un cercle.
      </para>
      <para>
       <literal>box(circle '&lt;(0,0),2&gt;')</literal>
       <returnvalue>(1.414213562373095,1.414213562373095),&zwsp;(-1.414213562373095,-1.414213562373095)</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>box</function> ( <type>point</type> )
       <returnvalue>box</returnvalue>
      </para>
      <para>
       Convertit le point en boîte vide.
      </para>
      <para>
       <literal>box(point '(1,0)')</literal>
       <returnvalue>(1,0),(1,0)</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>box</function> ( <type>point</type>, <type>point</type> )
       <returnvalue>box</returnvalue>
      </para>
      <para>
       Convertit deux points (utilisés comme coins) en une boîte.
      </para>
      <para>
       <literal>box(point '(0,1)', point '(1,0)')</literal>
       <returnvalue>(1,1),(0,0)</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>box</function> ( <type>polygon</type> )
       <returnvalue>box</returnvalue>
      </para>
      <para>
       Calcule la boîte englobante d'un polygone.
      </para>
      <para>
       <literal>box(polygon '((0,0),(1,1),(2,0))')</literal>
       <returnvalue>(2,1),(0,0)</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>bound_box</primary>
       </indexterm>
       <function>bound_box</function> ( <type>box</type>, <type>box</type> )
       <returnvalue>box</returnvalue>
      </para>
      <para>
       Calcule la boîte englobante de deux boîtes.
      </para>
      <para>
       <literal>bound_box(box '(1,1),(0,0)', box '(4,4),(3,3)')</literal>
       <returnvalue>(4,4),(0,0)</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>circle</primary>
       </indexterm>
       <function>circle</function> ( <type>box</type> )
       <returnvalue>circle</returnvalue>
      </para>
      <para>
       Calcule le plus petit cercle englobant une boîte.
      </para>
      <para>
       <literal>circle(box '(1,1),(0,0)')</literal>
       <returnvalue>&lt;(0.5,0.5),0.7071067811865476&gt;</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>circle</function> ( <type>point</type>, <type>double precision</type> )
       <returnvalue>circle</returnvalue>
      </para>
      <para>
       Calcule le cercle à partir de son centre et de son rayon.
      </para>
      <para>
       <literal>circle(point '(0,0)', 2.0)</literal>
       <returnvalue>&lt;(0,0),2&gt;</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>circle</function> ( <type>polygon</type> )
       <returnvalue>circle</returnvalue>
      </para>
      <para>
       Convertit un poligône en cercle. Le centre du cercle est la moyenne
       des positions des points du polygone, et le rayon est la distance
       moyenne des points du polygone à partir de ce centre.
      </para>
      <para>
       <literal>circle(polygon '((0,0),(1,3),(2,0))')</literal>
       <returnvalue>&lt;(1,1),1.6094757082487299&gt;</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>line</primary>
       </indexterm>
       <function>line</function> ( <type>point</type>, <type>point</type> )
       <returnvalue>line</returnvalue>
      </para>
      <para>
       Convertit deux points en une ligne qui les traverse.
      </para>
      <para>
       <literal>line(point '(-1,0)', point '(1,0)')</literal>
       <returnvalue>{0,-1,0}</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>lseg</primary>
       </indexterm>
       <function>lseg</function> ( <type>box</type> )
       <returnvalue>lseg</returnvalue>
      </para>
      <para>
       Extrait la diagonale de la boîte en un segment de ligne.
      </para>
      <para>
       <literal>lseg(box '(1,0),(-1,0)')</literal>
       <returnvalue>[(1,0),(-1,0)]</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>lseg</function> ( <type>point</type>, <type>point</type> )
       <returnvalue>lseg</returnvalue>
      </para>
      <para>
       Construit le segment de ligne à partir de deux points finaux.
      </para>
      <para>
       <literal>lseg(point '(-1,0)', point '(1,0)')</literal>
       <returnvalue>[(-1,0),(1,0)]</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>path</primary>
       </indexterm>
       <function>path</function> ( <type>polygon</type> )
       <returnvalue>path</returnvalue>
      </para>
      <para>
       Convertit un polygone en un chemin fermé avec la même liste de points.
      </para>
      <para>
       <literal>path(polygon '((0,0),(1,1),(2,0))')</literal>
       <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>point</primary>
       </indexterm>
       <function>point</function> ( <type>double precision</type>, <type>double precision</type> )
       <returnvalue>point</returnvalue>
      </para>
      <para>
       Calcule un point à partir de ses coordonnées.
      </para>
      <para>
       <literal>point(23.4, -44.5)</literal>
       <returnvalue>(23.4,-44.5)</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>point</function> ( <type>box</type> )
       <returnvalue>point</returnvalue>
      </para>
      <para>
       Calcule le centre d'une boîte.
      </para>
      <para>
       <literal>point(box '(1,0),(-1,0)')</literal>
       <returnvalue>(0,0)</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>point</function> ( <type>circle</type> )
       <returnvalue>point</returnvalue>
      </para>
      <para>
       Calcule le centre d'un cercle.
      </para>
      <para>
       <literal>point(circle '&lt;(0,0),2&gt;')</literal>
       <returnvalue>(0,0)</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>point</function> ( <type>lseg</type> )
       <returnvalue>point</returnvalue>
      </para>
      <para>
       Calcule le centre d'un segment de ligne.
      </para>
      <para>
       <literal>point(lseg '[(-1,0),(1,0)]')</literal>
       <returnvalue>(0,0)</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>point</function> ( <type>polygon</type> )
       <returnvalue>point</returnvalue>
      </para>
      <para>
       Calcule le centre d'un polygone (la moyenne des positions
       des points du polygone).
      </para>
      <para>
       <literal>point(polygon '((0,0),(1,1),(2,0))')</literal>
       <returnvalue>(1,0.3333333333333333)</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>polygon</primary>
       </indexterm>
       <function>polygon</function> ( <type>box</type> )
       <returnvalue>polygon</returnvalue>
      </para>
      <para>
       Convertit une boîte en un polygone à 4 points.
      </para>
      <para>
       <literal>polygon(box '(1,1),(0,0)')</literal>
       <returnvalue>((0,0),(0,1),(1,1),(1,0))</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>polygon</function> ( <type>circle</type> )
       <returnvalue>polygon</returnvalue>
      </para>
      <para>
       Convertit un cercle en un polygone à 12 points.
      </para>
      <para>
       <literal>polygon(circle '&lt;(0,0),2&gt;')</literal>
       <returnvalue>((-2,0),&zwsp;(-1.7320508075688774,0.9999999999999999),&zwsp;(-1.0000000000000002,1.7320508075688772),&zwsp;(-1.2246063538223773e-16,2),&zwsp;(0.9999999999999996,1.7320508075688774),&zwsp;(1.732050807568877,1.0000000000000007),&zwsp;(2,2.4492127076447545e-16),&zwsp;(1.7320508075688776,-0.9999999999999994),&zwsp;(1.0000000000000009,-1.7320508075688767),&zwsp;(3.673819061467132e-16,-2),&zwsp;(-0.9999999999999987,-1.732050807568878),&zwsp;(-1.7320508075688767,-1.0000000000000009))</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>polygon</function> ( <type>integer</type>, <type>circle</type> )
       <returnvalue>polygon</returnvalue>
      </para>
      <para>
       Convertit un cercle en un polygone à <replaceable>n</replaceable> points.
      </para>
      <para>
       <literal>polygon(4, circle '&lt;(3,0),1&gt;')</literal>
       <returnvalue>((2,0),&zwsp;(3,1),&zwsp;(4,1.2246063538223773e-16),&zwsp;(3,-1))</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>polygon</function> ( <type>path</type> )
       <returnvalue>polygon</returnvalue>
      </para>
      <para>
       Convertit un chemin fermé en un polygone avec la même liste de points.
      </para>
      <para>
       <literal>polygon(path '((0,0),(1,1),(2,0))')</literal>
       <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
      </para></entry>
    </row>

   </tbody>
  </tgroup>
 </table>

 <para>
  Il est possible d'accéder aux deux nombres composants d'un
  <type>point</type> comme si le point était un tableau avec les index 0 et
  1. Par exemple, si <literal>t.p</literal> est une colonne
  <type>point</type>, alors <literal>SELECT p[0] FROM t</literal> récupère
  la coordonnée X et <literal>UPDATE t SET p[1] = ...</literal> modifie la
  coordonnée Y. De la même façon, une valeur de type <type>box</type> ou
  <type>lseg</type> peut être traitée comme un tableau de deux valeurs
  <type>point</type>.
 </para>

</sect1>


<sect1 id="functions-net">
 <title>Fonctions et opérateurs pour les adresses réseau</title>

 <para>
  Les types pour les adresses réseau IP, <type>cidr</type> et
  <type>inet</type>, supportent les opérateurs de comparaison habituels
  indiqués dans <xref linkend="functions-comparison-op-table"/> ainsi que les
  opérateurs et fonctions spécialisés indiqués dans <xref
  linkend="cidr-inet-operators-table"/> et <xref
  linkend="cidr-inet-functions-table"/>.
 </para>

 <para>
  Toute valeur <type>cidr</type> peut être convertie implicitement en
  <type>inet</type>&nbsp;; de ce fait, les opérateurs et fonctions indiqués
  ici comme travaillant sur des valeurs <type>inet</type> fonctionnent aussi
  sur des valeurs <type>cidr</type>. (Quand il y a des fonctions séparées
  pour <type>inet</type> et <type>cidr</type>, c'est dû au comportement
  différent pour les deux cas.) De plus, il est permis de convertir une
  valeur <type>inet</type> en une valeur <type>cidr</type>. Quand cela se
  fait, tout bit à droite du masque réseau est mis à zéro silencieusement
  pour créer une valeur <type>cidr</type> valide.
 </para>

 <table id="cidr-inet-operators-table">
  <title>Opérateurs d'adresse IP</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Opérateur
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>inet</type> <literal>&lt;&lt;</literal> <type>inet</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Le sous-réseau est-il strictement contenu dans l'autre
       sous-réseau&nbsp;? Cet opérateur, et les quatre suivants, testent
       l'inclusion du sous-réseau. Ils considèrent seulement les parties
       réseau des deux adresses (ignorant tout bit à droite des masques
       réseau), et déterminent si un réseau est identique ou un sous-réseau
       de l'autre.
      </para>
      <para>
       <literal>inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'</literal>
       <returnvalue>t</returnvalue>
      </para>
      <para>
       <literal>inet '192.168.0.5' &lt;&lt; inet '192.168.1/24'</literal>
       <returnvalue>f</returnvalue>
      </para>
      <para>
       <literal>inet '192.168.1/24' &lt;&lt; inet '192.168.1/24'</literal>
       <returnvalue>f</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>inet</type> <literal>&lt;&lt;=</literal> <type>inet</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que le sous-réseau est contenu dans ou égal au sous-réseau&nbsp;?
      </para>
      <para>
       <literal>inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>inet</type> <literal>&gt;&gt;</literal> <type>inet</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que ce sous-réseau est contenu strictement dans le sous-réseau&nbsp;?
      </para>
      <para>
       <literal>inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>inet</type> <literal>&gt;&gt;=</literal> <type>inet</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que le sous-réseau contient ou est égal au sous-réseau&nbsp;?
      </para>
      <para>
       <literal>inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>inet</type> <literal>&amp;&amp;</literal> <type>inet</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce qu'un des sous-réseaux contient ou est égale à l'autre&nbsp;?
      </para>
      <para>
       <literal>inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'</literal>
       <returnvalue>t</returnvalue>
      </para>
      <para>
       <literal>inet '192.168.1/24' &amp;&amp; inet '192.168.2.0/28'</literal>
       <returnvalue>f</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <literal>~</literal> <type>inet</type>
       <returnvalue>inet</returnvalue>
      </para>
      <para>
       Calcule un NOT bit à bit.
      </para>
      <para>
       <literal>~ inet '192.168.1.6'</literal>
       <returnvalue>63.87.254.249</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>inet</type> <literal>&amp;</literal> <type>inet</type>
       <returnvalue>inet</returnvalue>
      </para>
      <para>
       Calcule un AND bit à bit.
      </para>
      <para>
       <literal>inet '192.168.1.6' &amp; inet '0.0.0.255'</literal>
       <returnvalue>0.0.0.6</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>inet</type> <literal>|</literal> <type>inet</type>
       <returnvalue>inet</returnvalue>
      </para>
      <para>
       Calcule un OR bit à bit.
      </para>
      <para>
       <literal>inet '192.168.1.6' | inet '0.0.0.255'</literal>
       <returnvalue>192.168.1.255</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>inet</type> <literal>+</literal> <type>bigint</type>
       <returnvalue>inet</returnvalue>
      </para>
      <para>
       Ajoute un décalage à une adresse.
      </para>
      <para>
       <literal>inet '192.168.1.6' + 25</literal>
       <returnvalue>192.168.1.31</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>bigint</type> <literal>+</literal> <type>inet</type>
       <returnvalue>inet</returnvalue>
      </para>
      <para>
       Ajoute un décalage à une adresse.
      </para>
      <para>
       <literal>200 + inet '::ffff:fff0:1'</literal>
       <returnvalue>::ffff:255.240.0.201</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>inet</type> <literal>-</literal> <type>bigint</type>
       <returnvalue>inet</returnvalue>
      </para>
      <para>
       Soustrait un décalage à une adresse.
      </para>
      <para>
       <literal>inet '192.168.1.43' - 36</literal>
       <returnvalue>192.168.1.7</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>inet</type> <literal>-</literal> <type>inet</type>
       <returnvalue>bigint</returnvalue>
      </para>
      <para>
       Calcule la différence de deux adresses.
      </para>
      <para>
       <literal>inet '192.168.1.43' - inet '192.168.1.19'</literal>
       <returnvalue>24</returnvalue>
      </para>
      <para>
       <literal>inet '::1' - inet '::ffff:1'</literal>
       <returnvalue>-4294901760</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <table id="cidr-inet-functions-table">
  <title>Fonctions des adresses IP</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>abbrev</primary>
       </indexterm>
       <function>abbrev</function> ( <type>inet</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Crée un format d'affichage abrévié sous la forme d'un texte. (Le
       résultat est le même que ce que produit la fonction de sortie du type
       <type>inet</type>&nbsp;; c'est <quote>abrévié</quote> seulement en
       comparaison du résultat d'une conversion explicite vers du
       <type>text</type> qui, pour des raisons historiques, ne supprimera
       jamais la partie du masque réseau.)
      </para>
      <para>
       <literal>abbrev(inet '10.1.0.0/32')</literal>
       <returnvalue>10.1.0.0</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>abbrev</function> ( <type>cidr</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Crée un format d'affichage abrévié sous la forme d'un texte.
       (L'abréviation consiste en la suppression des octets zéro à droite du
       masque réseau&nbsp;; il y a plus d'exemples dans <xref
       linkend="datatype-net-cidr-table"/>.)
      </para>
      <para>
       <literal>abbrev(cidr '10.1.0.0/16')</literal>
       <returnvalue>10.1/16</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>broadcast</primary>
       </indexterm>
       <function>broadcast</function> ( <type>inet</type> )
       <returnvalue>inet</returnvalue>
      </para>
      <para>
       Calcule l'adresse de broadcast pour le réseau de l'adresse.
      </para>
      <para>
       <literal>broadcast(inet '192.168.1.5/24')</literal>
       <returnvalue>192.168.1.255/24</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>family</primary>
       </indexterm>
       <function>family</function> ( <type>inet</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie la famille de l'adresse&nbsp;: <literal>4</literal> pour IPv4,
       <literal>6</literal> pour IPv6.
      </para>
      <para>
       <literal>family(inet '::1')</literal>
       <returnvalue>6</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>host</primary>
       </indexterm>
       <function>host</function> ( <type>inet</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Renvoie l'adresse IP sous forme de texte, en ignorant le masque réseau.
      </para>
      <para>
       <literal>host(inet '192.168.1.0/24')</literal>
       <returnvalue>192.168.1.0</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>hostmask</primary>
       </indexterm>
       <function>hostmask</function> ( <type>inet</type> )
       <returnvalue>inet</returnvalue>
      </para>
      <para>
       Calcule le masque de l'hôte pour le réseau de l'adresse.
      </para>
      <para>
       <literal>hostmask(inet '192.168.23.20/30')</literal>
       <returnvalue>0.0.0.3</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>inet_merge</primary>
       </indexterm>
       <function>inet_merge</function> ( <type>inet</type>, <type>inet</type> )
       <returnvalue>cidr</returnvalue>
      </para>
      <para>
       Calcule le plus petit réseau qui inclut les deux réseaux donnés.
      </para>
      <para>
       <literal>inet_merge(inet '192.168.1.5/24', inet '192.168.2.5/24')</literal>
       <returnvalue>192.168.0.0/22</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>inet_same_family</primary>
       </indexterm>
       <function>inet_same_family</function> ( <type>inet</type>, <type>inet</type> )
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Teste si les adresses appartiennent à la même famille IP.
      </para>
      <para>
       <literal>inet_same_family(inet '192.168.1.5/24', inet '::1')</literal>
       <returnvalue>f</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>masklen</primary>
       </indexterm>
       <function>masklen</function> ( <type>inet</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie la longueur du masque réseau en bits.
      </para>
      <para>
       <literal>masklen(inet '192.168.1.5/24')</literal>
       <returnvalue>24</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>netmask</primary>
       </indexterm>
       <function>netmask</function> ( <type>inet</type> )
       <returnvalue>inet</returnvalue>
      </para>
      <para>
       Calcule le masque réseau pour le réseau de l'adresse.
      </para>
      <para>
       <literal>netmask(inet '192.168.1.5/24')</literal>
       <returnvalue>255.255.255.0</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>network</primary>
       </indexterm>
       <function>network</function> ( <type>inet</type> )
       <returnvalue>cidr</returnvalue>
      </para>
      <para>
       Renvoie la partie réseau de l'adresse, mettant à zéro tout ce qui se
       trouve à droit du masque réseau. (Ceci est équivalent à convertir la
       valeur en <type>cidr</type>.)
      </para>
      <para>
       <literal>network(inet '192.168.1.5/24')</literal>
       <returnvalue>192.168.1.0/24</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>set_masklen</primary>
       </indexterm>
       <function>set_masklen</function> ( <type>inet</type>, <type>integer</type> )
       <returnvalue>inet</returnvalue>
      </para>
      <para>
       Configure la longueur du masque réseau pour une valeur
       <type>inet</type>. La partie adresse ne change pas.
      </para>
      <para>
       <literal>set_masklen(inet '192.168.1.5/24', 16)</literal>
       <returnvalue>192.168.1.5/16</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>set_masklen</function> ( <type>cidr</type>, <type>integer</type> )
       <returnvalue>cidr</returnvalue>
      </para>
      <para>
       Configure la longueur du masque réseau pour une valeur
       <type>cidr</type>. Les bits d'adresse à droit du nouveau masque réseau
       sont configurés à zéro.
      </para>
      <para>
       <literal>set_masklen(cidr '192.168.1.0/24', 16)</literal>
       <returnvalue>192.168.0.0/16</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>text</primary>
       </indexterm>
       <function>text</function> ( <type>inet</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Renvoie l'adresse IP non abrévié et la longueur du masque réseau en
       texte. (Ceci a le même résultat qu'une conversion explicite vers
       <type>text</type>.)
      </para>
      <para>
       <literal>text(inet '192.168.1.5')</literal>
       <returnvalue>192.168.1.5/32</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <tip>
  <para>
   Les fonctions <function>abbrev</function>, <function>host</function> et
   <function>text</function> ont pour but principal d'offrir des formats
   d'affichage alternatifs pour les adresses IP.
  </para>
 </tip>

 <para>
  Les types d'adresse MAC, <type>macaddr</type> et <type>macaddr8</type>,
  supportent les opérateurs de comparaison habituels indiqués dans <xref
  linkend="functions-comparison-op-table"/> ainsi que les fonctions
  spécialisées indiquées dans <xref linkend="macaddr-functions-table"/>. De
  plus, ils supportent les opérateurs logiques bit à bit
  <literal>~</literal>, <literal>&amp;</literal> et <literal>|</literal>
  (NOT, AND et OR), comme indiqué ci-dessus pour les adresses IP.
 </para>

 <table id="macaddr-functions-table">
  <title>Fonctions pour les adresses MAC</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>trunc</primary>
       </indexterm>
       <function>trunc</function> ( <type>macaddr</type> )
       <returnvalue>macaddr</returnvalue>
      </para>
      <para>
       Configure les trois derniers octets de l'adresse à zéro. Le préfixe
       restant peut être associé avec un manufacturier particulier (en
       utilisant les données non inclus dans
       <productname>PostgreSQL</productname>).
      </para>
      <para>
       <literal>trunc(macaddr '12:34:56:78:90:ab')</literal>
       <returnvalue>12:34:56:00:00:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>trunc</function> ( <type>macaddr8</type> )
       <returnvalue>macaddr8</returnvalue>
      </para>
      <para>
       Configure les 5 derniers octets de l'adresse à zéro. Le préfixe
       restant peut être associé à un manufacturier particulier (en utilisant
       des données non inclus dans <productname>PostgreSQL</productname>).
      </para>
      <para>
       <literal>trunc(macaddr8 '12:34:56:78:90:ab:cd:ef')</literal>
       <returnvalue>12:34:56:00:00:00:00:00</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>macaddr8_set7bit</primary>
       </indexterm>
       <function>macaddr8_set7bit</function> ( <type>macaddr8</type> )
       <returnvalue>macaddr8</returnvalue>
      </para>
      <para>
       Configure le 7è bit de l'adresse à un, créant ce qui est connu comme
       un EUI-64 modifié, pour inclusion dans une adresse IPv6.
      </para>
      <para>
       <literal>macaddr8_set7bit(macaddr8 '00:34:56:ab:cd:ef')</literal>
       <returnvalue>02:34:56:ff:fe:ab:cd:ef</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

</sect1>


<sect1 id="functions-textsearch">
 <title>Fonctions et opérateurs de recherche plein texte</title>

 <indexterm zone="datatype-textsearch">
  <primary>recherche plein texte</primary>
  <secondary>fonctions et opérateurs</secondary>
 </indexterm>

 <indexterm zone="datatype-textsearch">
  <primary>recherche de texte</primary>
  <secondary>fonctions et opérateurs</secondary>
 </indexterm>

 <para>
  <xref linkend="textsearch-operators-table"/>,
  <xref linkend="textsearch-functions-table"/> et
  <xref linkend="textsearch-functions-debug-table"/>
  résument les fonctions et opérateurs fournis par la recherche plein texte.
  Voir <xref linkend="textsearch"/> pour une explication détaillée de la
  fonctionnalité de recherche de texte de
  <productname>PostgreSQL</productname>.
 </para>

 <table id="textsearch-operators-table">
  <title>Opérateurs de recherche plein texte</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Opérateur
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>tsvector</type> <literal>@@</literal> <type>tsquery</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para role="func_signature">
       <type>tsquery</type> <literal>@@</literal> <type>tsvector</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que le <type>tsvector</type> correspond au <type>tsquery</type>&nbsp;?
       (Les arguments peuvent être donnés dans n'importe quel ordre.)
      </para>
      <para>
       <literal>to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>text</type> <literal>@@</literal> <type>tsquery</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que la chaîne de texte, après appel implicite à
       <function>to_tsvector()</function>, correspond au
       <type>tsquery</type>&nbsp;?
      </para>
      <para>
       <literal>'fat cats ate rats' @@ to_tsquery('cat &amp; rat')</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>tsvector</type> <literal>@@@</literal> <type>tsquery</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para role="func_signature">
       <type>tsquery</type> <literal>@@@</literal> <type>tsvector</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Synonyme obsolète pour <literal>@@</literal>.
      </para>
      <para>
       <literal>to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>tsvector</type> <literal>||</literal> <type>tsvector</type>
       <returnvalue>tsvector</returnvalue>
      </para>
      <para>
       Concatène deux <type>tsvector</type>. Si les deux entrées contiennent
       des positions de lexème, les positions de la deuxième entrée sont
       ajustées.
      </para>
      <para>
       <literal>'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector</literal>
       <returnvalue>'a':1 'b':2,5 'c':3 'd':4</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>tsquery</type> <literal>&amp;&amp;</literal> <type>tsquery</type>
       <returnvalue>tsquery</returnvalue>
      </para>
      <para>
       Calcule un AND des deux <type>tsquery</type>, produisant une requête
       qui établit une correspondance avec les documents correspondant aux
       deux requêtes.
      </para>
      <para>
       <literal>'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery</literal>
       <returnvalue>( 'fat' | 'rat' ) &amp; 'cat'</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>tsquery</type> <literal>||</literal> <type>tsquery</type>
       <returnvalue>tsquery</returnvalue>
      </para>
      <para>
       Calcule un OR des deux <type>tsquery</type>, produisant une requête
       qui établit une correspondance avec les documents correspondant à
       au moins une des deux requêtes.
      </para>
      <para>
       <literal>'fat | rat'::tsquery || 'cat'::tsquery</literal>
       <returnvalue>'fat' | 'rat' | 'cat'</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <literal>!!</literal> <type>tsquery</type>
       <returnvalue>tsquery</returnvalue>
      </para>
      <para>
       Inverse la <type>tsquery</type>, produisant une requête qui établit
       une correspondance avec les documents qui ne correspondent pas à la
       requête en entrée.
      </para>
      <para>
       <literal>!! 'cat'::tsquery</literal>
       <returnvalue>!'cat'</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>tsquery</type> <literal>&lt;-&gt;</literal> <type>tsquery</type>
       <returnvalue>tsquery</returnvalue>
      </para>
      <para>
       Construit une requête de phrase, qui établit une correspondance si les
       deux requêtes en entrée correspondent aux lexèmes successifs.
      </para>
      <para>
       <literal>to_tsquery('fat') &lt;-&gt; to_tsquery('rat')</literal>
       <returnvalue>'fat' &lt;-&gt; 'rat'</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>tsquery</type> <literal>@&gt;</literal> <type>tsquery</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que le premier <type>tsquery</type> contient le second&nbsp;?
       (Ceci considère seulement si tous les lexèmes apparaissant dans une
       requêtes apparaissent dans l'autre, ignorant les opérateurs combinés.)
      </para>
      <para>
       <literal>'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery</literal>
       <returnvalue>f</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <type>tsquery</type> <literal>&lt;@</literal> <type>tsquery</type>
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Est-ce que le premier <type>tsquery</type> est contenu dans le
       second&nbsp;?  (Ceci considère seulement si tous les lexèmes
       apparaissant dans une requête apparaissent aussi dans l'autre,
       ignorant les opérateurs combinés.)
      </para>
      <para>
       <literal>'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery</literal>
       <returnvalue>t</returnvalue>
      </para>
      <para>
       <literal>'cat'::tsquery &lt;@ '!cat &amp; rat'::tsquery</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
  En plus de ces opérateurs spécialisés, les opérateurs de comparaison
  habituels indiqués dans <xref linkend="functions-comparison-op-table"/>
  sont disponibles pour les types <type>tsvector</type> et
  <type>tsquery</type>. Ils ne sont pas très utiles pour la recherche de
  texte mais permettent, par exemple, de construire des index d'unicité sur
  des colonnes de ce type.
 </para>

 <table id="textsearch-functions-table">
  <title>Fonctions de recherche plein texte</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>array_to_tsvector</primary>
       </indexterm>
       <function>array_to_tsvector</function> ( <type>text[]</type> )
       <returnvalue>tsvector</returnvalue>
      </para>
      <para>
       Convertit un tableau de lexèmes en un <type>tsvector</type>. Les
       chaînes données sont utilisées directement sans autre traitement.
      </para>
      <para>
       <literal>array_to_tsvector('{fat,cat,rat}'::text[])</literal>
       <returnvalue>'cat' 'fat' 'rat'</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>get_current_ts_config</primary>
       </indexterm>
       <function>get_current_ts_config</function> ( )
       <returnvalue>regconfig</returnvalue>
      </para>
      <para>
       Renvoie l'OID de la configuration actuelle de recherche plein
       texte (comme elle est configurée par <xref
       linkend="guc-default-text-search-config"/>).
      </para>
      <para>
       <literal>get_current_ts_config()</literal>
       <returnvalue>english</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>length</primary>
       </indexterm>
       <function>length</function> ( <type>tsvector</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre de lexèmes dans le <type>tsvector</type>.
      </para>
      <para>
       <literal>length('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
       <returnvalue>3</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>numnode</primary>
       </indexterm>
       <function>numnode</function> ( <type>tsquery</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre de lexèmes plus les opérateurs dans le
       <type>tsquery</type>.
      </para>
      <para>
       <literal>numnode('(fat &amp; rat) | cat'::tsquery)</literal>
       <returnvalue>5</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>plainto_tsquery</primary>
       </indexterm>
       <function>plainto_tsquery</function> (
       <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
       <parameter>query</parameter> <type>text</type> )
       <returnvalue>tsquery</returnvalue>
      </para>
      <para>
       Convertit le texte en un <type>tsquery</type>, normalisant les mots
       suivant la configuration spécifiée ou par défaut. Toute ponctuation
       dans la chaîne est ignorée (elle ne détermine pas les opérateurs de la
       requête). La requête résultante correspond aux documents contenant
       tous les mots du texte qui ne sont pas des mots à ignorer.
      </para>
      <para>
       <literal>plainto_tsquery('english', 'The Fat Rats')</literal>
       <returnvalue>'fat' &amp; 'rat'</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>phraseto_tsquery</primary>
       </indexterm>
       <function>phraseto_tsquery</function> (
       <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
       <parameter>query</parameter> <type>text</type> )
       <returnvalue>tsquery</returnvalue>
      </para>
      <para>
       Convertit du texte en <type>tsquery</type>, normalisant les mots
       suivant la configuration spécifiée ou par défaut. Toute ponctuation
       dans la chaîne est ignorée (elle ne détermine pas les opérateurs de
       requête). La requête résultante correspond aux phrases contenant tous
       les mots du texte qui ne sont pas des mots à ignorer.
      </para>
      <para>
       <literal>phraseto_tsquery('english', 'The Fat Rats')</literal>
       <returnvalue>'fat' &lt;-&gt; 'rat'</returnvalue>
      </para>
      <para>
       <literal>phraseto_tsquery('english', 'The Cat and Rats')</literal>
       <returnvalue>'cat' &lt;2&gt; 'rat'</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>websearch_to_tsquery</primary>
       </indexterm>
       <function>websearch_to_tsquery</function> (
       <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
       <parameter>query</parameter> <type>text</type> )
       <returnvalue>tsquery</returnvalue>
      </para>
      <para>
       Convertit du texte en un <type>tsquery</type>, normalisant des mots
       suivant la configuration spécifiée ou par défaut. Les séquences de
       mots entre guillemets sont converties pour phraser des tests. Le mot
       <quote>or</quote> est compris comme produisant un opérateur OR, et un
       tiret produit un opérateur NOT&nbsp;; les autres ponctuations sont
       ignorées. Ceci ressemble au comportement des outils de recherche web.
      </para>
      <para>
       <literal>websearch_to_tsquery('english', '"fat rat" or cat dog')</literal>
       <returnvalue>'fat' &lt;-&gt; 'rat' | 'cat' &amp; 'dog'</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>querytree</primary>
       </indexterm>
       <function>querytree</function> ( <type>tsquery</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Produit une représentation de portion indexable d'un
       <type>tsquery</type>. Un résultat qui est vide ou juste
       <literal>T</literal> indique une requête non indexable.
      </para>
      <para>
       <literal>querytree('foo &amp; ! bar'::tsquery)</literal>
       <returnvalue>'foo'</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>setweight</primary>
       </indexterm>
       <function>setweight</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weight</parameter> <type>"char"</type> )
       <returnvalue>tsvector</returnvalue>
      </para>
      <para>
       Assigne un poids (<parameter>weight</parameter>) spécifié pour chaque
       élément d'un <parameter>vector</parameter>.
      </para>
      <para>
       <literal>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')</literal>
       <returnvalue>'cat':3A 'fat':2A,4A 'rat':5A</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>setweight</primary>
        <secondary>setweight for specific lexeme(s)</secondary>
       </indexterm>
       <function>setweight</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weight</parameter> <type>"char"</type>, <parameter>lexemes</parameter> <type>text[]</type> )
       <returnvalue>tsvector</returnvalue>
      </para>
      <para>
       Assigne le poids (<parameter>weight</parameter>) spécifié aux éléments
       des <parameter>vector</parameter> qui sont listés dans les
       <parameter>lexemes</parameter>.
      </para>
      <para>
       <literal>setweight('fat:2,4 cat:3 rat:5,6B'::tsvector, 'A', '{cat,rat}')</literal>
       <returnvalue>'cat':3A 'fat':2,4 'rat':5A,6A</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>strip</primary>
       </indexterm>
       <function>strip</function> ( <type>tsvector</type> )
       <returnvalue>tsvector</returnvalue>
      </para>
      <para>
       Supprime les positions et les poids à partir d'un <type>tsvector</type>.
      </para>
      <para>
       <literal>strip('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
       <returnvalue>'cat' 'fat' 'rat'</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>to_tsquery</primary>
       </indexterm>
       <function>to_tsquery</function> (
       <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
       <parameter>query</parameter> <type>text</type> )
       <returnvalue>tsquery</returnvalue>
      </para>
      <para>
       Convertit le texte en <type>tsquery</type>, normalisant les mots
       suivant la configuration spécifiée ou par défaut. Les mots doivent
       être combinés par des opérateurs <type>tsquery</type> valides.
      </para>
      <para>
       <literal>to_tsquery('english', 'The &amp; Fat &amp; Rats')</literal>
       <returnvalue>'fat' &amp; 'rat'</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>to_tsvector</primary>
       </indexterm>
       <function>to_tsvector</function> (
       <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
       <parameter>document</parameter> <type>text</type> )
       <returnvalue>tsvector</returnvalue>
      </para>
      <para>
       Convertit du texte en un <type>tsvector</type>, normalisant les mots
       suivant la configuration spécifiée ou par défaut. L'information de
       position est inclus dans le résultat.
      </para>
      <para>
       <literal>to_tsvector('english', 'The Fat Rats')</literal>
       <returnvalue>'fat':2 'rat':3</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>to_tsvector</function> (
       <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
       <parameter>document</parameter> <type>json</type> )
       <returnvalue>tsvector</returnvalue>
      </para>
      <para role="func_signature">
       <function>to_tsvector</function> (
       <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
       <parameter>document</parameter> <type>jsonb</type> )
       <returnvalue>tsvector</returnvalue>
      </para>
      <para>
       Convertit chaque valeur chaîne du document JSON en un
       <type>tsvector</type>, normalisant les mots suivant la configuration
       spécifiée ou par défaut. Les résultats sont ensuite concaténées dans
       l'ordre du document pour produire la sortie. L'information de position
       est générée comme si un mot d'arrêt existe chaque paire de valeurs
       chaînes. (Attention que l'<quote>ordre du document</quote> des champs
       d'un objet JSON est dépendant de l'implémentation quand l'entrée est
       de type <type>jsonb</type>&nbsp;; observez la difference dans les
       exemples.)
      </para>
      <para>
       <literal>to_tsvector('english', '{"aa": "The Fat Rats", "b": "dog"}'::json)</literal>
       <returnvalue>'dog':5 'fat':2 'rat':3</returnvalue>
      </para>
      <para>
       <literal>to_tsvector('english', '{"aa": "The Fat Rats", "b": "dog"}'::jsonb)</literal>
       <returnvalue>'dog':1 'fat':4 'rat':5</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>json_to_tsvector</primary>
       </indexterm>
       <function>json_to_tsvector</function> (
       <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
       <parameter>document</parameter> <type>json</type>,
       <parameter>filter</parameter> <type>jsonb</type> )
       <returnvalue>tsvector</returnvalue>
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>jsonb_to_tsvector</primary>
       </indexterm>
       <function>jsonb_to_tsvector</function> (
       <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
       <parameter>document</parameter> <type>jsonb</type>,
       <parameter>filter</parameter> <type>jsonb</type> )
       <returnvalue>tsvector</returnvalue>
      </para>
      <para>
       Sélectionne chaque élément du document JSON qui est réclamé par le
       <parameter>filter</parameter> et convertit chacun en un
       <type>tsvector</type>, normalisant les mots suivant la configuration
       spécifiée ou par défaut. Les résultats sont ensuite concaténées dans
       l'ordre du document pour produire la sortie. L'information de position
       est générée comme si un mot d'arrêt existe entre chaque paire
       d'éléments sélectionnés. (Attention que l'<quote>ordre du
        document</quote> des champs d'un objet JSON est dépendant de
       l'implémentation quand l'entrée est de type <type>jsonb</type>.) Le
       <parameter>filter</parameter> doit être un tableau <type>jsonb</type>
       contenant zéro ou plusieurs de ces mots-clés&nbsp;:
       <literal>"string"</literal> (pour inclure toutes les valeurs chaînes),
       <literal>"numeric"</literal> (pour inclure toutes les valeurs
       numériques), <literal>"boolean"</literal> (pour inclure toutes les
       valeurs booléennes), <literal>"key"</literal> (pour inclure toutes les
       clés) ou <literal>"all"</literal> (pour tous ces mots-clés). Comme
       exception, <parameter>filter</parameter> peut aussi être une simple
       valeur JSON qui est un de ces mots-clés.
      </para>
      <para>
       <literal>json_to_tsvector('english', '{"a": "The Fat Rats", "b": 123}'::json, '["string", "numeric"]')</literal>
       <returnvalue>'123':5 'fat':2 'rat':3</returnvalue>
      </para>
      <para>
       <literal>json_to_tsvector('english', '{"cat": "The Fat Rats", "dog": 123}'::json, '"all"')</literal>
       <returnvalue>'123':9 'cat':1 'dog':7 'fat':4 'rat':5</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>ts_delete</primary>
       </indexterm>
       <function>ts_delete</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>lexeme</parameter> <type>text</type> )
       <returnvalue>tsvector</returnvalue>
      </para>
      <para>
       Supprime toute occurrence du <parameter>lexeme</parameter> donné
       à partir de <parameter>vector</parameter>.
      </para>
      <para>
       <literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, 'fat')</literal>
       <returnvalue>'cat':3 'rat':5A</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>ts_delete</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>lexemes</parameter> <type>text[]</type> )
       <returnvalue>tsvector</returnvalue>
      </para>
      <para>
       Supprime toute occurrence des lexèmes
       dans <parameter>lexemes</parameter>
       à partir de <parameter>vector</parameter>.
      </para>
      <para>
       <literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, ARRAY['fat','rat'])</literal>
       <returnvalue>'cat':3</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>ts_filter</primary>
       </indexterm>
       <function>ts_filter</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weights</parameter> <type>"char"[]</type> )
       <returnvalue>tsvector</returnvalue>
      </para>
      <para>
       Sélectionne seulement les éléments avec le <parameter>weights</parameter>
       donné à partir de <parameter>vector</parameter>.
      </para>
      <para>
       <literal>ts_filter('fat:2,4 cat:3b,7c rat:5A'::tsvector, '{a,b}')</literal>
       <returnvalue>'cat':3B 'rat':5A</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>ts_headline</primary>
       </indexterm>
       <function>ts_headline</function> (
       <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
       <parameter>document</parameter> <type>text</type>,
       <parameter>query</parameter> <type>tsquery</type>
       <optional>, <parameter>options</parameter> <type>text</type> </optional> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Affiche, dans sa forme abréviée, les correspondances de la
       <parameter>query</parameter> dans le <parameter>document</parameter>,
       qui doit être un texte brut, et non pas un <type>tsvector</type>. Les
       mots dans le document sont normalisés suivant la configuration
       spécifiée ou par défaut avant d'établir les correspondances avec la
       requête. L'utilisation de cette fonction est discutée dans <xref
       linkend="textsearch-headline"/>, quid écrit aussi les
       <parameter>options</parameter> disponibles.
      </para>
      <para>
       <literal>ts_headline('The fat cat ate the rat.', 'cat')</literal>
       <returnvalue>The fat &lt;b&gt;cat&lt;/b&gt; ate the rat.</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>ts_headline</function> (
       <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
       <parameter>document</parameter> <type>json</type>,
       <parameter>query</parameter> <type>tsquery</type>
       <optional>, <parameter>options</parameter> <type>text</type> </optional> )
       <returnvalue>text</returnvalue>
      </para>
      <para role="func_signature">
       <function>ts_headline</function> (
       <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
       <parameter>document</parameter> <type>jsonb</type>,
       <parameter>query</parameter> <type>tsquery</type>
       <optional>, <parameter>options</parameter> <type>text</type> </optional> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Affiche, dans une forme abréviée, les correspondances pour la
       <parameter>query</parameter> qui surviennent dans les valeurs de type
       chaîne dans le <parameter>document</parameter> JSON. Voir <xref
       linkend="textsearch-headline"/> pour plus de détails.
      </para>
      <para>
       <literal>ts_headline('{"cat":"raining cats and dogs"}'::jsonb, 'cat')</literal>
       <returnvalue>{"cat": "raining &lt;b&gt;cats&lt;/b&gt; and dogs"}</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>ts_rank</primary>
       </indexterm>
       <function>ts_rank</function> (
       <optional> <parameter>weights</parameter> <type>real[]</type>, </optional>
       <parameter>vector</parameter> <type>tsvector</type>,
       <parameter>query</parameter> <type>tsquery</type>
       <optional>, <parameter>normalization</parameter> <type>integer</type> </optional> )
       <returnvalue>real</returnvalue>
      </para>
      <para>
       Calcule un score indiquant le niveau de correspondance du
       <parameter>vector</parameter> avec la <parameter>query</parameter>.
       Voir <xref linkend="textsearch-ranking"/> pour plus de détails.
      </para>
      <para>
       <literal>ts_rank(to_tsvector('raining cats and dogs'), 'cat')</literal>
       <returnvalue>0.06079271</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>ts_rank_cd</primary>
       </indexterm>
       <function>ts_rank_cd</function> (
       <optional> <parameter>weights</parameter> <type>real[]</type>, </optional>
       <parameter>vector</parameter> <type>tsvector</type>,
       <parameter>query</parameter> <type>tsquery</type>
       <optional>, <parameter>normalization</parameter> <type>integer</type> </optional> )
       <returnvalue>real</returnvalue>
      </para>
      <para>
       Calcule un score indiquant le niveau de correspondance du
       <parameter>vector</parameter> avec la <parameter>query</parameter>, en
       utilisant un algorithme de densité de couverture. Voir <xref
       linkend="textsearch-ranking"/> pour les détails.
      </para>
      <para>
       <literal>ts_rank_cd(to_tsvector('raining cats and dogs'), 'cat')</literal>
       <returnvalue>0.1</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>ts_rewrite</primary>
       </indexterm>
       <function>ts_rewrite</function> ( <parameter>query</parameter> <type>tsquery</type>,
       <parameter>target</parameter> <type>tsquery</type>,
       <parameter>substitute</parameter> <type>tsquery</type> )
       <returnvalue>tsquery</returnvalue>
      </para>
      <para>
       Remplace les occurrences de <parameter>target</parameter> avec
       <parameter>substitute</parameter> dans <parameter>query</parameter>.
       Voir <xref linkend="textsearch-query-rewriting"/> pour les détails.
      </para>
      <para>
       <literal>ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)</literal>
       <returnvalue>'b' &amp; ( 'foo' | 'bar' )</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>ts_rewrite</function> ( <parameter>query</parameter> <type>tsquery</type>,
       <parameter>select</parameter> <type>text</type> )
       <returnvalue>tsquery</returnvalue>
      </para>
      <para>
       Remplace les portions de la <parameter>query</parameter> suivant les
       cibles et substituts obtenus en exécutant une commande
       <command>SELECT</command>. Voir <xref
       linkend="textsearch-query-rewriting"/> pour les détails.
      </para>
      <para>
       <literal>SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')</literal>
       <returnvalue>'b' &amp; ( 'foo' | 'bar' )</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>tsquery_phrase</primary>
       </indexterm>
       <function>tsquery_phrase</function> ( <parameter>query1</parameter> <type>tsquery</type>, <parameter>query2</parameter> <type>tsquery</type> )
       <returnvalue>tsquery</returnvalue>
      </para>
      <para>
       Construit une requête de phrases pour rechercher les correspondances
       de <parameter>query1</parameter> et <parameter>query2</parameter> sur
       des lexèmes successifs (identique à l'opérateur
       <literal>&lt;-&gt;</literal>).
      </para>
      <para>
       <literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'))</literal>
       <returnvalue>'fat' &lt;-&gt; 'cat'</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>tsquery_phrase</function> ( <parameter>query1</parameter> <type>tsquery</type>, <parameter>query2</parameter> <type>tsquery</type>, <parameter>distance</parameter> <type>integer</type> )
       <returnvalue>tsquery</returnvalue>
      </para>
      <para>
       Construit une requête de phrases pour rechercher les correspondances
       de <parameter>query1</parameter> et <parameter>query2</parameter> qui
       surviennent exactement entre <parameter>distance</parameter> lexèmes.
      </para>
      <para>
       <literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10)</literal>
       <returnvalue>'fat' &lt;10&gt; 'cat'</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>tsvector_to_array</primary>
       </indexterm>
       <function>tsvector_to_array</function> ( <type>tsvector</type> )
       <returnvalue>text[]</returnvalue>
      </para>
      <para>
       Convertit un <type>tsvector</type> en un tableau de lexèmes.
      </para>
      <para>
       <literal>tsvector_to_array('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
       <returnvalue>{cat,fat,rat}</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>unnest</primary>
        <secondary>for tsvector</secondary>
       </indexterm>
       <function>unnest</function> ( <type>tsvector</type> )
       <returnvalue>setof record</returnvalue>
       ( <parameter>lexeme</parameter> <type>text</type>,
       <parameter>positions</parameter> <type>smallint[]</type>,
       <parameter>weights</parameter> <type>text</type> )
      </para>
      <para>
       Étend un <type>tsvector</type> en un ensemble de lignes, une par lexème.
      </para>
      <para>
       <literal>select * from unnest('cat:3 fat:2,4 rat:5A'::tsvector)</literal>
       <returnvalue></returnvalue>
       <programlisting>
 lexeme | positions | weights
--------+-----------+---------
 cat    | {3}       | {D}
 fat    | {2,4}     | {D,D}
 rat    | {5}       | {A}
       </programlisting>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <note>
  <para>
   Toutes les fonctions de recherche plein texte qui acceptent un argument
   <type>regconfig</type> optionnel utiliseront la configuration indiquée par
   <xref linkend="guc-default-text-search-config"/> quand cet argument est
   omis.
  </para>
 </note>

 <para>
  Les fonctions de <xref linkend="textsearch-functions-debug-table"/> sont
  listées séparément parce qu'elles ne sont habituellement pas utilisées dans
  les opérations standard de recherche de texte. Elles sont principalement
  utiles pour le développement et le débogage des nouvelles configurations de
  recherche plein texte.
 </para>

 <table id="textsearch-functions-debug-table">
  <title>Fonctions de débogage de recherche plein texte</title>
  <tgroup cols="1">
   <thead>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       Fonction
      </para>
      <para>
       Description
      </para>
      <para>
       Exemple(s)
      </para></entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>ts_debug</primary>
       </indexterm>
       <function>ts_debug</function> (
       <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
       <parameter>document</parameter> <type>text</type> )
       <returnvalue>setof record</returnvalue>
       ( <parameter>alias</parameter> <type>text</type>,
       <parameter>description</parameter> <type>text</type>,
       <parameter>token</parameter> <type>text</type>,
       <parameter>dictionaries</parameter> <type>regdictionary[]</type>,
       <parameter>dictionary</parameter> <type>regdictionary</type>,
       <parameter>lexemes</parameter> <type>text[]</type> )
      </para>
      <para>
       Extrait et normalise les jetons d'un <parameter>document</parameter>
       suivant la configuration de recherche plein texte spécifié ou par
       défaut, et renvoie l'information sur la façon dont chaque jeton a été
       traité. Voir <xref linkend="textsearch-configuration-testing"/> pour
       plus de détails.
      </para>
      <para>
       <literal>ts_debug('english', 'The Brightest supernovaes')</literal>
       <returnvalue>(asciiword,"Word, all ASCII",The,{english_stem},english_stem,{}) ...</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>ts_lexize</primary>
       </indexterm>
       <function>ts_lexize</function> ( <parameter>dict</parameter> <type>regdictionary</type>, <parameter>token</parameter> <type>text</type> )
       <returnvalue>text[]</returnvalue>
      </para>
      <para>
       Renvoie un tableau de lexèmes de remplacement si le jeton en entrée
       est connu par le dictionnaire ou un tableau suivant si le jeton est
       connu du dictionnaire mais est un mot vide, ou NULL si ce n'est pas un
       mot connu. Voir <xref linkend="textsearch-dictionary-testing"/> pour
       les détails.
      </para>
      <para>
       <literal>ts_lexize('english_stem', 'stars')</literal>
       <returnvalue>{star}</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>ts_parse</primary>
       </indexterm>
       <function>ts_parse</function> ( <parameter>parser_name</parameter> <type>text</type>,
       <parameter>document</parameter> <type>text</type> )
       <returnvalue>setof record</returnvalue>
       ( <parameter>tokid</parameter> <type>integer</type>,
       <parameter>token</parameter> <type>text</type> )
      </para>
      <para>
       Extrait les jetons du <parameter>document</parameter> en utilisant
       l'analyseur nommé. Voir <xref linkend="textsearch-parser-testing"/>
       pour les détails.
      </para>
      <para>
       <literal>ts_parse('default', 'foo - bar')</literal>
       <returnvalue>(1,foo) ...</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>ts_parse</function> ( <parameter>parser_oid</parameter> <type>oid</type>,
       <parameter>document</parameter> <type>text</type> )
       <returnvalue>setof record</returnvalue>
       ( <parameter>tokid</parameter> <type>integer</type>,
       <parameter>token</parameter> <type>text</type> )
      </para>
      <para>
       Extrait les jetons du <parameter>document</parameter> en utilisant un
       analyseur spécifié par OID. Voir <xref
       linkend="textsearch-parser-testing"/> pour les détails.
      </para>
      <para>
       <literal>ts_parse(3722, 'foo - bar')</literal>
       <returnvalue>(1,foo) ...</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>ts_token_type</primary>
       </indexterm>
       <function>ts_token_type</function> ( <parameter>parser_name</parameter> <type>text</type> )
       <returnvalue>setof record</returnvalue>
       ( <parameter>tokid</parameter> <type>integer</type>,
       <parameter>alias</parameter> <type>text</type>,
       <parameter>description</parameter> <type>text</type> )
      </para>
      <para>
       Renvoie une table qui décrit chaque type de jeton que l'analyseur
       nommé peut reconnaître. Voir <xref
       linkend="textsearch-parser-testing"/> pour les détails.
      </para>
      <para>
       <literal>ts_token_type('default')</literal>
       <returnvalue>(1,asciiword,"Word, all ASCII") ...</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <function>ts_token_type</function> ( <parameter>parser_oid</parameter> <type>oid</type> )
       <returnvalue>setof record</returnvalue>
       ( <parameter>tokid</parameter> <type>integer</type>,
       <parameter>alias</parameter> <type>text</type>,
       <parameter>description</parameter> <type>text</type> )
      </para>
      <para>
       Renvoie une table qui décrit chaque type de jeton qu'un analyseur
       spécifié par OID peut reconnaître. Voir <xref
       linkend="textsearch-parser-testing"/> pour les détails.
      </para>
      <para>
       <literal>ts_token_type(3722)</literal>
       <returnvalue>(1,asciiword,"Word, all ASCII") ...</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>ts_stat</primary>
       </indexterm>
       <function>ts_stat</function> ( <parameter>sqlquery</parameter> <type>text</type>
       <optional>, <parameter>weights</parameter> <type>text</type> </optional> )
       <returnvalue>setof record</returnvalue>
       ( <parameter>word</parameter> <type>text</type>,
       <parameter>ndoc</parameter> <type>integer</type>,
       <parameter>nentry</parameter> <type>integer</type> )
      </para>
      <para>
       Exécute la <parameter>sqlquery</parameter>, qui doit renvoyer une
       seule colonne <type>tsvector</type>, et renvoyer des statistiques sur
       chaque lexème distinct contenu dans la donnée. Voir <xref
       linkend="textsearch-statistics"/> pour les détails.
      </para>
      <para>
       <literal>ts_stat('SELECT vector FROM apod')</literal>
       <returnvalue>(foo,10,15) ...</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

</sect1>

<sect1 id="functions-uuid">
 <title>Fonctions UUID</title>

 <indexterm zone="datatype-uuid">
  <primary>UUID</primary>
  <secondary>génération</secondary>
 </indexterm>

 <indexterm>
  <primary>gen_random_uuid</primary>
 </indexterm>

 <para>
  <productname>PostgreSQL</productname> inclut une fonction pour générer un
  UUID&nbsp;:
  <synopsis>
<function>gen_random_uuid</function> () <returnvalue>uuid</returnvalue>
  </synopsis>
  Cette fonction renvoie un UUID version 4 (aléatoire). Ceci est le type
  le plus communément utilisé d'UUID et est approprié pour la plupart
  des applications.
 </para>

 <para>
  Le module <xref linkend="uuid-ossp"/> fournit des fonctions supplémentaires
  implémentant d'autres algorithmes standards de génération d'UUID.
 </para>

 <para>
  <productname>PostgreSQL</productname> fournit aussi les opérateurs de
  comparaison habituels affichés dans <xref
  linkend="functions-comparison-op-table"/> pour les UUID.
 </para>
</sect1>

<sect1 id="functions-xml">

 <title>Fonctions XML</title>

 <indexterm>
  <primary>Fonctions XML</primary>
 </indexterm>

 <para>
  Les fonctions et les expressions décrites dans cette section opèrent sur
  des valeurs de type <type>xml</type>. Voir <xref linkend="datatype-xml"/>
  pour des informations sur le type <type>xml</type>. Les expressions
  <function>xmlparse</function> et <function>xmlserialize</function> pour
  convertir vers ou à partir d'un type <type>xml</type> sont documentées ici,
  et non pas dans cette section.
 </para>

 <para>
  L'utilisation de la plupart de ces fonctions requiert que
  <productname>PostgreSQL</productname> soit construit avec
  <command>configure --with-libxml</command>.
 </para>

 <sect2 id="functions-producing-xml">
  <title>Produire du contenu XML</title>

  <para>
   Un ensemble de fonctions et d'expressions est disponible pour produire du
   contenu XML à partir de données SQL. Elles sont donc tout particulièrement
   intéressantes pour formater le résultat de requêtes en des documents XML
   pour un traitement dans des applications clientes.
  </para>

  <sect3>
   <title><literal>xmlcomment</literal></title>

   <indexterm>
    <primary>xmlcomment</primary>
   </indexterm>

   <synopsis>
<function>xmlcomment</function> ( <type>text</type> ) <returnvalue>xml</returnvalue>
   </synopsis>

   <para>
    La fonction <function>xmlcomment</function> crée une valeur XML contenant
    un commentaire XML avec le texte spécifié comme contenu. Le texte ne peut
    pas contenir <quote><literal>--</literal></quote> ou se terminer avec un
    <quote><literal>-</literal></quote>, sinon la construction résultante
    serait un commentaire XML invalide. Si l'argument est NULL, le résultat
    est NULL.
   </para>

   <para>
    Example:
    <screen><![CDATA[
SELECT xmlcomment('hello');

  xmlcomment
--------------
 <!--hello-->
    ]]></screen>
  </para>
 </sect3>

 <sect3>
  <title><literal>xmlconcat</literal></title>

  <indexterm>
   <primary>xmlconcat</primary>
  </indexterm>

  <synopsis>
<function>xmlconcat</function> ( <type>xml</type> <optional>, ...</optional> ) <returnvalue>xml</returnvalue>
  </synopsis>

  <para>
   La fonction <function>xmlconcat</function> concatène une liste de valeurs
   XML individuelles pour créer une seule valeur contenant un fragment de
   contenu XML. Les valeurs NULL sont omises. Le résultat est NULL si tous
   les arguments sont NULL.
  </para>

  <para>
   Example:
   <screen><![CDATA[
SELECT xmlconcat('<abc/>', '<bar>foo</bar>');

      xmlconcat
----------------------
 <abc/><bar>foo</bar>
]]></screen>
    </para>

    <para>
     Les déclarations XML sont combinées ainsi. Si toutes les valeurs des
     arguments ont la même déclaration de version XML, cette version est
     utilisée comme résultat. Sinon, aucune version n'est utilisée. Si toutes
     les valeurs des arguments ont une valeur de déclarationl standalone à
     <quote>yes</quote>, alors cette valeur est utilisée dans le résultat. Si
     toutes les valeurs d'agument ont une valeur de déclaration standalone et
     qu'au moins une de ces valeurs est <quote>no</quote>, alors cette valeur
     est utilisée dans le résultat. Dans tous les autres cas, le résultat
     n'aura pas de déclaration standalone. Si le résultat nécessite une
     déclaration standalone, mais par de déclaration version, une déclaration
     version 1.0 sera utilisée car XML requiert qu'une déclaration XML
     contiennent une déclaration de version. Les déclarations d'encodage sont
     ignorés et supprimés dans tous les cas.
    </para>

    <para>
     Example:
<screen><![CDATA[
SELECT xmlconcat('<?xml version="1.1"?><foo/>', '<?xml version="1.1" standalone="no"?><bar/>');

             xmlconcat
-----------------------------------
 <?xml version="1.1"?><foo/><bar/>
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlelement</literal></title>

   <indexterm>
    <primary>xmlelement</primary>
   </indexterm>

<synopsis>
<function>xmlelement</function> ( <literal>NAME</literal> <replaceable>name</replaceable> <optional>, <literal>XMLATTRIBUTES</literal> ( <replaceable>attvalue</replaceable> <optional> <literal>AS</literal> <replaceable>attname</replaceable> </optional> <optional>, ...</optional> ) </optional> <optional>, <replaceable>content</replaceable> <optional>, ...</optional></optional> ) <returnvalue>xml</returnvalue>
   </synopsis>

   <para>
    L'expression <function>xmlelement</function> produit un élément XML avec
    le nom, les attributs et le contenu donnés. Les éléments
    <replaceable>name</replaceable> et <replaceable>attname</replaceable>
    affichés dans la syntaxe sont de simples identifiants, et non pas des
    valeurs. Les éléments <replaceable>attvalue</replaceable> et
    <replaceable>content</replaceable> sont des expressions, qui peuvent être
    de n'importe quel type de données <productname>PostgreSQL</productname>.
    Les arguments dans <literal>XMLATTRIBUTES</literal> génèrent les
    attributs de l'élément XML&nbsp;; les valeurs
    <replaceable>content</replaceable> sont concaténées pour former son
    contenu.
   </para>

   <para>
    Examples:
    <screen><![CDATA[
SELECT xmlelement(name foo);

 xmlelement
------------
 <foo/>

SELECT xmlelement(name foo, xmlattributes('xyz' as bar));

    xmlelement
------------------
 <foo bar="xyz"/>

SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');

             xmlelement
-------------------------------------
 <foo bar="2007-01-26">content</foo>
]]></screen>
    </para>

    <para>
     Les noms d'éléments et d'attributs qui ne sont pas des noms XML valides
     sont échappés en remplaçant les caractères problématiques par la séquence
     <literal>_x<replaceable>HHHH</replaceable>_</literal>, où
     <replaceable>HHHH</replaceable> est le point code Unicode du caractère
     dans sa notation hexadécimale. Par exemple&nbsp;:
<screen><![CDATA[
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&b"));

            xmlelement
----------------------------------
 <foo_x0024_bar a_x0026_b="xyz"/>
]]></screen>
    </para>

    <para>
     Un nom d'attribut explicite n'a pas besoin d'être spécifié si la valeur
     de l'attribut est une référence de colonne, auquel cas le nom de la
     colonne sera utilisé comme nom d'attribut par défaut. Dans les autres
     cas, l'attribut doit se voir donner un nom explicite. Donc cet exemple
     est valide&nbsp;:
<screen>
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
    </screen>
    Mais ces exemples ne le sont pas&nbsp;:
    <screen>
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
    </screen>
   </para>

   <para>
    Le contenu d'un élément, si indiqué, sera formaté suivant ton type de
    données. Si le contenu est lui-même de type <type>xml</type>, des
    documents XML complexes peuvent être construits. Par exemple&nbsp;:
    <screen><![CDATA[
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
                            xmlelement(name abc),
                            xmlcomment('test'),
                            xmlelement(name xyz));

                  xmlelement
----------------------------------------------
 <foo bar="xyz"><abc/><!--test--><xyz/></foo>
   ]]></screen>

  Le contenu des autres types sera formaté en une donnée caractère XML
  valide. Ceci signifie en particulier que les caractères &lt;, &gt;, et
  &amp; seront convertis en entités. Les données binaires (type de données
  <type>bytea</type>) seront représentées dans un encodage base64 ou hex,
  suivant la configuration du paramètre <xref linkend="guc-xmlbinary"/>. Le
  comportement particulier pour les types de données individuels devrait
  évoluer pour aligner les correspondances PostgreSQL avec ceux spécifiés
  dans SQL:2006 et ultérieurs, comme discuté dans <xref
  linkend="functions-xml-limits-casts"/>.
 </para>
</sect3>

<sect3>
 <title><literal>xmlforest</literal></title>

 <indexterm>
  <primary>xmlforest</primary>
 </indexterm>

 <synopsis>
<function>xmlforest</function> ( <replaceable>content</replaceable> <optional> <literal>AS</literal> <replaceable>name</replaceable> </optional> <optional>, ...</optional> ) <returnvalue>xml</returnvalue>
 </synopsis>

 <para>
  L'expression <function>xmlforest</function> produit une forêt (séquence)
  XML d'éléments en utilisant les noms et le contenu donnés. Quant à
  <function>xmlelement</function>, chaque <replaceable>name</replaceable>
  doit être un simple identifiant, alors que les expressions
  <replaceable>content</replaceable> peuvent avoir n'importe quel type de
  données.
 </para>

 <para>
  Exemples&nbsp;:
  <screen>
SELECT xmlforest('abc' AS foo, 123 AS bar);

          xmlforest
------------------------------
 &lt;foo&gt;abc&lt;/foo&gt;&lt;bar&gt;123&lt;/bar&gt;


SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';

                                xmlforest
------------------------------------&zwsp;-----------------------------------
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;&zwsp;&lt;column_name&gt;rolname&lt;/column_name&gt;
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;&zwsp;&lt;column_name&gt;rolsuper&lt;/column_name&gt;
 ...
  </screen>

  Comme indiqué dans le deuxième exemple, le nom de l'élément peut être
  omis si la valeur contenue est une référence de colonne, auquel cas le
  nom de l'élément est utilisé par défaut. Sinon un nom doit être spécifié.
 </para>

 <para>
  Les noms d'élément qui ne sont pas des noms XML valides sont échappés
  comme indiqué pour <function>xmlelement</function> ci-dessus. De façon
  similaire, les données du contenu sont échappées pour rendre le contenu
  XML valide, sauf s'il est déjà de type <type>xml</type>.
 </para>

 <para>
  Notez que les forêts XML ne sont pas des documents XML valides si elles
  consistent de plus d'un élément, donc il pourrait être utile d'envelopper
  les expressions <function>xmlforest</function> dans
  <function>xmlelement</function>.
 </para>
</sect3>

<sect3>
 <title><literal>xmlpi</literal></title>

 <indexterm>
  <primary>xmlpi</primary>
 </indexterm>

 <synopsis>
<function>xmlpi</function> ( <literal>NAME</literal> <replaceable>name</replaceable> <optional>, <replaceable>content</replaceable> </optional> ) <returnvalue>xml</returnvalue>
 </synopsis>

 <para>
  L'instruction <function>xmlpi</function> crée une instruction de
  traitement XML. Quant à <function>xmlelement</function>,
  <replaceable>name</replaceable> doit être un simple identifiant, alors
  que l'expression <replaceable>content</replaceable> peut contenir tout
  type de données. Si présent, <replaceable>content</replaceable> ne doit
  pas contenir la séquence de caractères <literal>?&gt;</literal>.
 </para>

 <para>
  Exemple&nbsp;:
  <screen><![CDATA[
SELECT xmlpi(name php, 'echo "hello world";');

            xmlpi
-----------------------------
 <?php echo "hello world";?>
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlroot</literal></title>

   <indexterm>
    <primary>xmlroot</primary>
   </indexterm>

<synopsis>
<function>xmlroot</function> ( <type>xml</type>, <literal>VERSION</literal> {<type>text</type>|<literal>NO VALUE</literal>} <optional>, <literal>STANDALONE</literal> {<literal>YES</literal>|<literal>NO</literal>|<literal>NO VALUE</literal>} </optional> ) <returnvalue>xml</returnvalue>
  </synopsis>

  <para>
   L'expression <function>xmlroot</function> altère les propriétés du nœud
   racine d'une valeur XML. Si une version est spécifiée, elle remplace la
   valeur dans la déclaration de version du nœud racine&nbsp;; si un
   paramètre standalone est spécifié, il remplace la valeur dans la
   déclaration standalone du nœud racine.
  </para>

  <para>
   <screen><![CDATA[
SELECT xmlroot(xmlparse(document '<?xml version="1.1"?><content>abc</content>'),
               version '1.0', standalone yes);

                xmlroot
----------------------------------------
 <?xml version="1.0" standalone="yes"?>
 <content>abc</content>
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-xmlagg">
    <title><literal>xmlagg</literal></title>

    <indexterm>
     <primary>xmlagg</primary>
    </indexterm>

<synopsis>
<function>xmlagg</function> ( <type>xml</type> ) <returnvalue>xml</returnvalue>
   </synopsis>

   <para>
    La fonction <function>xmlagg</function> est, contrairement aux autres
    fonctions décrites ici, une fonction d'agrégat. Elle concatène les
    valeurs en entrée à l'appel de fonction d'agrégat, tout comme le fait
    <function>xmlconcat</function>, sauf que la concaténation survient au
    travers des lignes plutôt qu'au travers des expressions dans une seule
    ligne. Voir <xref linkend="functions-aggregate"/> pour l'information
    supplémentaire sur les fonctions d'agrégat.
   </para>

   <para>
    Exemple&nbsp;:
    <screen><![CDATA[
CREATE TABLE test (y int, x xml);
INSERT INTO test VALUES (1, '<foo>abc</foo>');
INSERT INTO test VALUES (2, '<bar/>');
SELECT xmlagg(x) FROM test;
        xmlagg
----------------------
 <foo>abc</foo><bar/>
]]></screen>
    </para>

    <para>
     Pour déterminer l'ordre de la concaténation, une clause <literal>ORDER
     BY</literal> peut être ajouté à l'appel de l'agrégat comme décrit dans
     <xref linkend="syntax-aggregates"/>. Par exemple&nbsp;:

<screen><![CDATA[
SELECT xmlagg(x ORDER BY y DESC) FROM test;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>

    <para>
     L'approche non standard suivante était recommendée dans les versions
     précédentes et pourrait toujours être utile dans des cas
     spécifiques&nbsp;:

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>
   </sect3>
   </sect2>

   <sect2 id="functions-xml-predicates">
    <title>Prédicats XML</title>

    <para>
     Les expressions décrites dans cette section vérifient les propriétés des
     valeurs <type>xml</type>.
    </para>

   <sect3>
    <title><literal>IS DOCUMENT</literal></title>

    <indexterm>
     <primary>IS DOCUMENT</primary>
    </indexterm>

<synopsis>
<type>xml</type> <literal>IS DOCUMENT</literal> <returnvalue>boolean</returnvalue>
    </synopsis>

    <para>
     L'expression <literal>IS DOCUMENT</literal> renvoie true si la valeur de
     l'argument XML est un document XML propre, false si elle ne l'est pas
     (c'est-à-dire un fragment de contenu), ou null si l'argument est null.
     Voir <xref linkend="datatype-xml"/> sur la différence entre les documents
     et les fragments de contenu.
    </para>
   </sect3>

   <sect3>
    <title><literal>IS NOT DOCUMENT</literal></title>

    <indexterm>
     <primary>IS NOT DOCUMENT</primary>
    </indexterm>

    <synopsis>
<type>xml</type> <literal>IS NOT DOCUMENT</literal> <returnvalue>boolean</returnvalue>
    </synopsis>

    <para>
     L'expression <literal>IS NOT DOCUMENT</literal> renvoie false si la
     valeur de l'argument XML est un document XML propre, true si elle ne
     l'est pas (c'est-à-dire un fragment de contenu), ou null si l'argument
     est null.
    </para>
   </sect3>

   <sect3 id="xml-exists">
    <title><literal>XMLEXISTS</literal></title>

    <indexterm>
     <primary>XMLEXISTS</primary>
    </indexterm>

    <synopsis>
<function>XMLEXISTS</function> ( <type>text</type> <literal>PASSING</literal> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> <type>xml</type> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> ) <returnvalue>boolean</returnvalue>
    </synopsis>

    <para>
     La fonction <function>xmlexists</function> évalue une expression XPath
     1.0 (le premier argument), avec la valeur XML passée comme son élément de
     contexte. La fonction renvoie false si le résultat de cette évaluation
     renvoie un ensemble de nœud vide, true si elle renvoie toute autre
     valeur. La fonction renvoie null si un argument vaut null. Une valeur non
     null passée comme élément de contexte doit être un document XML, et non
     pas un fragment de contenu ou une valeur non XML.
    </para>

    <para>
     Example:
     <screen><![CDATA[
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY VALUE '<towns><town>Toronto</town><town>Ottawa</town></towns>');

 xmlexists
------------
 t
(1 row)
]]></screen>
    </para>

    <para>
     Les clauses <literal>BY REF</literal> et <literal>BY VALUE</literal> sont
     acceptées dans <productname>PostgreSQL</productname>, mais sont ignorées
     comme indiqué dans <xref linkend="functions-xml-limits-postgresql"/>.
    </para>

    <para>
     Dans le standard SQL, la fonction <function>xmlexists</function> évalue
     une expression dans le langage XML Query, mais
     <productname>PostgreSQL</productname> autorise seulement une expression
     XPath 1.0, comme discuté dans <xref
     linkend="functions-xml-limits-xpath1"/>.
    </para>
   </sect3>

   <sect3 id="xml-is-well-formed">
    <title><literal>xml_is_well_formed</literal></title>

    <indexterm>
     <primary>xml_is_well_formed</primary>
    </indexterm>

    <indexterm>
     <primary>xml_is_well_formed_document</primary>
    </indexterm>

    <indexterm>
     <primary>xml_is_well_formed_content</primary>
    </indexterm>

<synopsis>
<function>xml_is_well_formed</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
<function>xml_is_well_formed_document</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
<function>xml_is_well_formed_content</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
     </synopsis>

     <para>
      Ces fonctions vérifient si une chaîne de type <type>text</type>
      représente un XML bien formé, renvoyant un résultat booléen.
      <function>xml_is_well_formed_document</function> vérifie si le document
      est bien formé alors que <function>xml_is_well_formed_content</function>
      vérifie que c'est une contenu bien formé.
      <function>xml_is_well_formed</function> fait le premier si le paramètre
      de configuration <xref linkend="guc-xmloption"/> est configuré à
      <literal>DOCUMENT</literal>, et le deuxième s'il est configuré à
      <literal>CONTENT</literal>. Ceci signifie que
      <function>xml_is_well_formed</function> est utile pour voir si une simple
      conversion vers le type <type>xml</type> réussira, alors que les deux
      autres fonctions sont utiles pour voir si les variantes correspondantes
      de <function>XMLPARSE</function> réussira.
     </para>

     <para>
      Exemples&nbsp;:

      <screen><![CDATA[
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('<>');
 xml_is_well_formed
--------------------
 f
(1 row)

SELECT xml_is_well_formed('<abc/>');
 xml_is_well_formed
--------------------
 t
(1 row)

SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
 xml_is_well_formed
--------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
 xml_is_well_formed_document
-----------------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
 xml_is_well_formed_document
-----------------------------
 f
(1 row)
]]></screen>

     Le dernier exemple montre que les vérifications incluent une vérification
     de correspondance sur les espaces de nom.
    </para>
   </sect3>
  </sect2>

  <sect2 id="functions-xml-processing">
   <title>Traiter du XML</title>

   <para>
    Pour traiter les valeurs de type <type>xml</type>, PostgreSQL offre les
    fonctions <function>xpath</function> et <function>xpath_exists</function>,
    qui évaluent les expressions XPath 1.0 et la fonction de table
    <function>XMLTABLE</function>.
   </para>

   <sect3 id="functions-xml-processing-xpath">
    <title><literal>xpath</literal></title>

    <indexterm>
     <primary>XPath</primary>
    </indexterm>

<synopsis>
<function>xpath</function> ( <parameter>xpath</parameter> <type>text</type>, <parameter>xml</parameter> <type>xml</type> <optional>, <parameter>nsarray</parameter> <type>text[]</type> </optional> ) <returnvalue>xml[]</returnvalue>
      </synopsis>

      <para>
       La fonction <function>xpath</function> évalue l'expression XPath 1.0
       indiquée dans <parameter>xpath</parameter> (sous la forme d'une donnée de
       type text) avec la valeur XML de type <parameter>xml</parameter>. Elle
       renvoie des valeurs XML correspondant à l'ensemble de nœuds produits par
       l'expression XPath. Si l'expression XPath renvoie une valeur scalaire
       plutôt qu'un ensemble de nœuds, un tableau d'un seul élément est renvoyé.
      </para>

      <para>
       Le deuxième argument doit être un document XML bien formé. En
       particulier, il doit avoir un seul élément de nœud racine.
      </para>

      <para>
       Le troisième argument optionnel de la fonction est un tableau de
       correspondances d'espaces de nom. Ce tableau devrait être un tableau de
       <type>text</type> à deux dimensions avec la longueur du deuxième axe
       égale à 2 (cela devrait être un tableau de tableaux, chacun des deux
       contenant exactement deux éléments). Le premier élément de chaque entrée
       de tableau est le nom de l'espace de noms (alias), le second est l'URI de
       l'espace de noms. Il n'est pas requis que les alias fournis dans ce
       tableau soient identiques à ceux utilisés dans le document XML lui-même
       (en d'autres termes, dans le document XML et dans le contexte de la
       fonction <function>xpath</function> function context, les alias sont
       <emphasis>local</emphasis>).
      </para>

      <para>
       Exemple&nbsp;:
       <screen><![CDATA[
SELECT xpath('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
             ARRAY[ARRAY['my', 'http://example.com']]);

 xpath
--------
 {test}
(1 row)
]]></screen>
    </para>

    <para>
     Pour gérer les espaces de noms par défaut (anonymes), faire ceci&nbsp;:
<screen><![CDATA[
SELECT xpath('//mydefns:b/text()', '<a xmlns="http://example.com"><b>test</b></a>',
             ARRAY[ARRAY['mydefns', 'http://example.com']]);

 xpath
--------
 {test}
(1 row)
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-processing-xpath-exists">
    <title><literal>xpath_exists</literal></title>

    <indexterm>
     <primary>xpath_exists</primary>
    </indexterm>

<synopsis>
<function>xpath_exists</function> ( <parameter>xpath</parameter> <type>text</type>, <parameter>xml</parameter> <type>xml</type> <optional>, <parameter>nsarray</parameter> <type>text[]</type> </optional> ) <returnvalue>boolean</returnvalue>
       </synopsis>

       <para>
        La fonction <function>xpath_exists</function> est une forme spécialisée
        de la fonction <function>xpath</function>. Au lieu de renvoyer les
        valeurs XML individuelles satisfaisant l'expression XPath 1.0, cette
        fonction renvoie un booléen indiquant si la requête était satisfaite ou
        non (spécifiquement s'il produit une valeur autre qu'un ensemble vide de
        nœuds). Cette fonction est équivalente au prédicat
        <literal>XMLEXISTS</literal>, sauf qu'il offre aussi du support pour
        l'argument de correspondance d'espaces de noms.
       </para>

       <para>
        Example:
        <screen><![CDATA[
SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
                     ARRAY[ARRAY['my', 'http://example.com']]);

 xpath_exists
--------------
 t
(1 row)
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-processing-xmltable">
    <title><literal>xmltable</literal></title>

    <indexterm>
     <primary>xmltable</primary>
    </indexterm>

    <indexterm zone="functions-xml-processing-xmltable">
     <primary>fonction de table</primary>
     <secondary>XMLTABLE</secondary>
    </indexterm>

<synopsis>
<function>XMLTABLE</function> (
    <optional> <literal>XMLNAMESPACES</literal> ( <replaceable>namespace_uri</replaceable> <literal>AS</literal> <replaceable>namespace_name</replaceable> <optional>, ...</optional> ), </optional>
    <replaceable>row_expression</replaceable> <literal>PASSING</literal> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> <replaceable>document_expression</replaceable> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional>
    <literal>COLUMNS</literal> <replaceable>name</replaceable> { <replaceable>type</replaceable> <optional><literal>PATH</literal> <replaceable>column_expression</replaceable></optional> <optional><literal>DEFAULT</literal> <replaceable>default_expression</replaceable></optional> <optional><literal>NOT NULL</literal> | <literal>NULL</literal></optional>
                  | <literal>FOR ORDINALITY</literal> }
            <optional>, ...</optional>
) <returnvalue>setof record</returnvalue>
        </synopsis>

        <para>
         L'expression <function>xmltable</function> produit une table basée sur
         une valeur XML, un filtre XPath pour extraire les lignes et un ensemble
         de définition de colonnes. Bien que cela ressemble syntaxiquement à une
         fonction, il peut aussi apparaître comme une table dans la clause
         <literal>FROM</literal> de la requête.
        </para>

        <para>
         La clause <literal>XMLNAMESPACES</literal> optionnelle donne une liste,
         séparée par des virgules, des définitions d'espaces de nom, où chaque
         <replaceable>namespace_uri</replaceable> est une expression
         <type>text</type> et chaque <replaceable>namespace_name</replaceable> est
         un simple identifiant. Elle spécifie les espaces de nom XML utilisés dans
         le document et leur alias. La spécification d'un espace de nom par défaut
         n'est actuellement pas supportée.
        </para>

        <para>
         L'argument requis <replaceable>row_expression</replaceable> est une
         expression XPath 1.0 (donné sous la forme d'un <type>text</type>) qui est
         évaluée, passant la valeur XML
         <replaceable>document_expression</replaceable> sous la forme d'un élément
         de contexte, pour obtenir un ensemble de nœuds XML. Ces nœuds sont ce que
         <function>xmltable</function> transforme des lignes en sortie. Aucune
         ligne ne sera produite si <replaceable>document_expression</replaceable>
         est NULL, ou si <replaceable>row_expression</replaceable> produit un
         ensemble vide de nœuds ou tout autre valeur qu'un ensemble de nœuds.
        </para>

        <para>
         <replaceable>document_expression</replaceable> fournit l'élément de
         contexte pour <replaceable>row_expression</replaceable>. Cela doit être
         un document XML bien formé&nbsp;; les fragments/forêts ne sont pas
         acceptés. Les clauses <literal>BY REF</literal> et <literal>BY
          VALUE</literal> sont acceptées mais ignorées, comme discuté dans <xref
         linkend="functions-xml-limits-postgresql"/>.
        </para>

        <para>
         Dans le standard SQL, la fonction <function>xmltable</function> évalue
         des expressions dans le langage XML Query, mais
         <productname>PostgreSQL</productname> autorise seulement les expressions
         XPath 1.0, comme discutées dans <xref
         linkend="functions-xml-limits-xpath1"/>.
        </para>

        <para>
         La clause requise <literal>COLUMNS</literal> spécifie les colonnes
         produites dans la table en sortie. Voir le résumé de la syntaxe ci-dessus
         pour le format. Un nom est requis pour chaque colonne, comme l'est un
         type de données (sauf si <literal>FOR ORDINALITY</literal> est spécifié,
         auquel cas le type <type>integer</type> est implicite). Les clauses de
         chemin, de valeur par défaut et de nullabilité sont optionnelles.
        </para>

        <para>
         Une colonne marquée <literal>FOR ORDINALITY</literal> sera peuplée avec
         les numéros de lignes, commençant par 1, dans l'ordre des nœuds récupérés
         à partir de l'ensemble de nœuds résultats de
         <replaceable>row_expression</replaceable>. Au plus une colonne sera
         marquée <literal>FOR ORDINALITY</literal>.
        </para>

        <note>
         <para>
          XPath 1.0 ne spécifie pas d'ordre pour les nœuds dans un ensemble de
          nœuds, donc le code qui relie un ordre particulier de résultats sera
          dépendant de l'implémentation. Les détails sont disponibles dans <xref
          linkend="xml-xpath-1-specifics"/>.
         </para>
        </note>

        <para>
         Le <replaceable>column_expression</replaceable> pour un colonne est une
         expression XPath 1.0 qui est évaluée pour chaque ligne, avec le nœud
         courant provenant du résultat de
         <replaceable>row_expression</replaceable> comme son élément de contexte,
         pour trouver la valeur de la colonne. Si aucune
         <replaceable>column_expression</replaceable> n'est donnée, alors le nom
         de la colonne est utilisé comme un chemin implicite.
        </para>

        <para>
         Si une expression XPath de colonne renvoie une valeur non XML (qui est
         limitée à une chaîne, un booléen ou un double en XPath 1.0) et la colonne
         a un type type autre que <type>xml</type>, la colonne sera configurée
         ainsi en affectant la représentation textuelle de la valeur vers le type
         PostgreSQL. (Si la valeur est un booléen, sa représentation textuelle est
         comprise comme <literal>1</literal> ou <literal>0</literal> si la
         catégorie du type de la colonne en sortie est numérique, sinon
         <literal>true</literal> ou <literal>false</literal>.)
        </para>

        <para>
         Si l'expression XPath d'une colonne renvoie un ensemble non vide de nœuds
         XML et si le type PostgreSQL de la colonne est <type>xml</type>, la
         colonne sera affectée au résultat exact de l'expression s'il est de forme
         document ou contenu.
         <footnote>
          <para>
           Un résultat contenant plus d'un nœud élément au niveau haut ou du texte
           sans espace blanc à l'extérieur d'un élément, est un exemple de forme
           contenu. Un résultat XPath peut être de toute forme, par exemple s'il
           renvoie un nœud attribut sélectionné à partir de l'élément qui le
           contient. Un tel résultat sera placé dans sa forme contenu avec chacun
           des nœuds non autorisés replacés par sa valeur de chaîne de texte,
           comme définis pour la fonction <function>string</function> XPath 1.0.
          </para>
         </footnote>
        </para>

        <para>
         Un résultat non XML affecté à une colonne <type>xml</type> en sortie
         produit du contenu, un nœud texte simple avec la valeur chaîne du
         résultat. Un résultat XML affecté à une colonne de tout autre type
         pourrait ne pas avoir plus d'un nœud, sinon une erreur est levée. S'il y
         a exactement un nœud, la colonne sera configurée d'après son affectation
         de la valeur textuelle du nœud (comme défini pour la fonction
         <function>string</function> XPath 1.0) du type PostgreSQL.
        </para>

        <para>
         The string value of an XML element is the concatenation, in document order,
         of all text nodes contained in that element and its descendants. The string
         value of an element with no descendant text nodes is an
         empty string (not <literal>NULL</literal>).
         Any <literal>xsi:nil</literal> attributes are ignored.
         Note that the whitespace-only <literal>text()</literal> node between two non-text
         elements is preserved, and that leading whitespace on a <literal>text()</literal>
         node is not flattened.
         The XPath 1.0 <function>string</function> function may be consulted for the
         rules defining the string value of other XML node types and non-XML values.
        </para>

        <para>
         Les règles de conversion présentées ici ne sont pas exactement ceux du
         standard SQL, comme discuté dans <xref
         linkend="functions-xml-limits-casts"/>.
        </para>

        <para>
         Si l'expression de chemin renvoie un ensemble vide de nœuds (typiquement
         quand cela ne correspond pas) pour une ligne donnée, la colonne sera
         configurée à <literal>NULL</literal>, sauf si une
         <replaceable>default_expression</replaceable> est indiquée&nbsp;; alors
         la valeur résultant de l'évaluation d'une expression est utilisée.
        </para>

        <para>
         Une <replaceable>default_expression</replaceable>, plutôt qu'être évaluée
         immédiatement quand <function>xmltable</function> est appelée, est
         évaluée chaque fois qu'une valeur par défaut est nécessaire pour la
         colonne. Si l'expression qualifie comme stable ou immuable, l'évaluation
         de répétition peut être ignorée. Ceci signifie que vous pouvez utiliser
         utilement les fonctions volatiles comme <function>nextval</function> dans
         <replaceable>default_expression</replaceable>.
        </para>

        <para>
         Les colonnes peuvent être marquées <literal>NOT NULL</literal>. Si
         <replaceable>column_expression</replaceable> pour une colonne
         <literal>NOT NULL</literal> ne correspond à rien et qu'il n'y a ni valeur
         par défaut (<literal>DEFAULT</literal>) ni
         <replaceable>default_expression</replaceable>, elle s'évalue à NULL, une
         erreur est rapportée.
        </para>

        <para>
         Exemples&nbsp;:
         <screen><![CDATA[
CREATE TABLE xmldata AS SELECT
xml $$
<ROWS>
  <ROW id="1">
    <COUNTRY_ID>AU</COUNTRY_ID>
    <COUNTRY_NAME>Australia</COUNTRY_NAME>
  </ROW>
  <ROW id="5">
    <COUNTRY_ID>JP</COUNTRY_ID>
    <COUNTRY_NAME>Japan</COUNTRY_NAME>
    <PREMIER_NAME>Shinzo Abe</PREMIER_NAME>
    <SIZE unit="sq_mi">145935</SIZE>
  </ROW>
  <ROW id="6">
    <COUNTRY_ID>SG</COUNTRY_ID>
    <COUNTRY_NAME>Singapore</COUNTRY_NAME>
    <SIZE unit="sq_km">697</SIZE>
  </ROW>
</ROWS>
$$ AS data;

SELECT xmltable.*
  FROM xmldata,
       XMLTABLE('//ROWS/ROW'
                PASSING data
                COLUMNS id int PATH '@id',
                        ordinality FOR ORDINALITY,
                        "COUNTRY_NAME" text,
                        country_id text PATH 'COUNTRY_ID',
                        size_sq_km float PATH 'SIZE[@unit = "sq_km"]',
                        size_other text PATH
                             'concat(SIZE[@unit!="sq_km"], " ", SIZE[@unit!="sq_km"]/@unit)',
                        premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');

 id | ordinality | COUNTRY_NAME | country_id | size_sq_km |  size_other  | premier_name
----+------------+--------------+------------+------------+--------------+---------------
  1 |          1 | Australia    | AU         |            |              | not specified
  5 |          2 | Japan        | JP         |            | 145935 sq_mi | Shinzo Abe
  6 |          3 | Singapore    | SG         |        697 |              | not specified
]]></screen>

     L'exemple suivant montre une concaténation de plusieurs nœuds text(), une
     utilisation du nom de colonne en tant que filtre XPath, et le traitement
     des espaces blancs, des commentaires XML et le traitement des
     instructions&nbsp;:

  <screen><![CDATA[
CREATE TABLE xmlelements AS SELECT
xml $$
  <root>
   <element>  Hello<!-- xyxxz -->2a2<?aaaaa?> <!--x-->  bbb<x>xxx</x>CC  </element>
        </root>
        $$ AS data;

        SELECT xmltable.*
        FROM xmlelements, XMLTABLE('/root' PASSING data COLUMNS element text);
        element
        -------------------------
        Hello2a2   bbbxxxCC
        ]]></screen>
      </para>

      <para>
       L'exemple suivant illustre comment la clause
       <literal>XMLNAMESPACES</literal> peut être utilisé pour spécifier une
       liste d'espaces de noms utilisée dans le document XML ainsi que dans les
       expressions XPath&nbsp;:

       <screen><![CDATA[
WITH xmldata(data) AS (VALUES ('
<example xmlns="http://example.com/myns" xmlns:B="http://example.com/b">
 <item foo="1" B:bar="2"/>
 <item foo="3" B:bar="4"/>
 <item foo="4" B:bar="5"/>
</example>'::xml)
)
SELECT xmltable.*
  FROM XMLTABLE(XMLNAMESPACES('http://example.com/myns' AS x,
                              'http://example.com/b' AS "B"),
             '/x:example/x:item'
                PASSING (SELECT data FROM xmldata)
                COLUMNS foo int PATH '@foo',
                  bar int PATH '@B:bar');
 foo | bar
-----+-----
   1 |   2
   3 |   4
   4 |   5
(3 rows)
]]></screen>
    </para>
   </sect3>
  </sect2>

  <sect2 id="functions-xml-mapping">
   <title>Correspondances tables et XML</title>

   <indexterm zone="functions-xml-mapping">
    <primary>XML export</primary>
   </indexterm>

   <para>
    Les fonctions suivantes font correspondre le contenu des tables
    relationnelles aux valeurs XML. Elles peuvent être vues comme une
    fonctionnalité d'export du XML&nbsp;:
<synopsis>
<function>table_to_xml</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
               <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xml</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
               <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>cursor_to_xml</function> ( <parameter>cursor</parameter> <type>refcursor</type>, <parameter>count</parameter> <type>integer</type>, <parameter>nulls</parameter> <type>boolean</type>,
                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
       </synopsis>
      </para>

      <para>
       <function>table_to_xml</function> fait correspondre le contenu de la table
       nommée, passée en paramètre sous le nom de <parameter>table</parameter>.
       Le type <type>regclass</type> accepte les chaînes identifiant les tables
       en utilisant la notation habituelle incluant une qualification optionnelle
       avec le nom du schéma et les guillemets doubles.
       <function>query_to_xml</function> exécute la requête dont le texte est
       passé avec le paramètre <parameter>query</parameter> et fait la
       correspondance avec le résultat. <function>cursor_to_xml</function>
       récupère le nombre indiqué de lignes à partir du curseur indiqué par le
       paramètre <parameter>cursor</parameter>. Cette variante est recommandée si
       des tables volumineuses sont utilisées car la valeur de résultat est
       construire en mémoire par chaque fonction.
      </para>

      <para>
       Si <parameter>tableforest</parameter> vaut false, alors le document XML
       résultant ressemble à ceci&nbsp;:
       <screen><![CDATA[
<tablename>
  <row>
    <columnname1>data</columnname1>
    <columnname2>data</columnname2>
  </row>

  <row>
    ...
  </row>

  ...
</tablename>
]]></screen>

    Si <parameter>tableforest</parameter> vaut true, le résultat est un
    fragment de contenu XML qui ressemble à ceci&nbsp;:
<screen><![CDATA[
<tablename>
  <columnname1>data</columnname1>
  <columnname2>data</columnname2>
</tablename>

<tablename>
  ...
</tablename>

...
]]></screen>

    Si aucun nom de table n'est disponible, par exemple pour une requête ou un
    curseur, la chaîne indiquée pour <literal>table</literal> est utilisée
    pour le premier format, et <literal>row</literal> pour le deuxième format.
   </para>

   <para>
    Le choix entre ces formats dépend de l'utilisateur. Le premier format est
    un document XML propre, qui sera important pour de nombreuses
    applications. Le deuxième format tend à être plus utile dans la fonction
    <function>cursor_to_xml</function> si les valeurs du résultat sont à
    réassembler en un seul document plus tard. Les fonctions pour produire du
    contenu XML discutées ci-dessus, en particulier
    <function>xmlelement</function>, peuvent être utilisées pour modifier les
    résultats.
   </para>

   <para>
    Les valeurs des données sont projetées de la même façon que décrit pour la
    fonction <function>xmlelement</function> ci-dessus.
   </para>

   <para>
    Le paramètre <parameter>nulls</parameter> détermine si les valeurs NULL
    doivent être incluses dans la sortie. Si true, les valeurs NULL dans les
    colonnes sont représentées sous cette forme&nbsp;:
<screen><![CDATA[
<columnname xsi:nil="true"/>
]]></screen>
    où <literal>xsi</literal> est le préfixe de l'espace de nom XML pour XML
    Schema Instance. Une déclaration appropriée d'espace de nom sera ajoutée à
    la valeur résultat. Si false, les colonnes contenant des valeurs NULL
    seront simplement omises dans la sortie.
   </para>

   <para>
    Le paramètre <parameter>targetns</parameter> spécifie l'espace de nom XML
    désiré pour le résultat. Si aucun espace de nom n'est souhaité, une chaîne
    vide doit être passée.
   </para>

   <para>
    Les fonctions suivantes renvoient les documents XML Schema décrivant les
    correspondances réalisées par les fonctions ci-dessus&nbsp;:
<synopsis>
<function>table_to_xmlschema</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
                     <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xmlschema</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
                     <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>cursor_to_xmlschema</function> ( <parameter>cursor</parameter> <type>refcursor</type>, <parameter>nulls</parameter> <type>boolean</type>,
                      <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
       </synopsis>
       Il est essentiel que les mêmes paramètres soient passés dans l'ordre pour
       obtenir les projections de données XML correspondantes et les documents
       XML Schema.
      </para>

      <para>
       Les fonctions suivantes produisent les projections de données XML
       correspondantes et les documents XML Schema dans un document (ou forêt),
       liés ensemble. Elles peuvent être utiles lorsque des résultats auto
       contenus et auto descriptifs sont désirés&nbsp;:
       <synopsis>
<function>table_to_xml_and_xmlschema</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
                             <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xml_and_xmlschema</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
                             <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
       </synopsis>
      </para>

      <para>
       De plus, les fonctions suivantes sont disponibles pour produire des
       projections analogues de schémas entiers ou de la base de donnée
       courante entière&nbsp;:
       <synopsis>
<function>schema_to_xml</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>schema_to_xmlschema</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                      <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>schema_to_xml_and_xmlschema</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                              <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>

<function>database_to_xml</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                  <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>database_to_xmlschema</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                        <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>database_to_xml_and_xmlschema</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
       </synopsis>

       Ces fonctions ignorent les tables qui ne sont pas lisibles par
       l'utilisateur courant. Les fonctions sur la base entière ignorent en plus
       les schémas pour lesquels l'utilisateur actuel ne dispose pas du droit
       <literal>USAGE</literal>.
      </para>

      <para>
       Notez qu'elles peuvent produire beaucoup de données, entièrement stockées
       en mémoire. Lors de demandes de création de contenu à partir de gros
       schémas ou de base, il peut être intéressant de réfléchir à traiter les
       tables séparément, potentiellement même via un curseur.
      </para>

      <para>
       Le résultat d'un contenu de schéma ressemble à ceci&nbsp;:

       <screen><![CDATA[
<schemaname>

table1-mapping

table2-mapping

...

</schemaname>]]></screen>

    où le format de correspondance de table dépend du paramètre
    <parameter>tableforest</parameter> comme expliqué ci-dessus.
   </para>

   <para>
    Le résultat d'un contenu de base ressemble à ceci&nbsp;:

<screen><![CDATA[
<dbname>

<schema1name>
  ...
</schema1name>

<schema2name>
  ...
</schema2name>

...

</dbname>]]></screen>

    où la correspondance de schéma est indiquée ci-dessus.
   </para>

   <para>
    Comme exemple d'utilisation de la sortie de ces fonctions, <xref
    linkend="xslt-xml-html"/> montre une feuille de style XSLT qui convertit
    la sortie de <function>table_to_xml_and_xmlschema</function> en un
    document HTML contenant une représentation en tableau des données de la
    table. D'une façon similaire, le résultat de ces fonctions peut être
    converti en d'autres formats basés sur le XML.
   </para>

   <example id="xslt-xml-html">
    <title>Feuille de style XSLT pour convertir un résultat SQL/XML en HTML</title>
<programlisting><![CDATA[
<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="http://www.w3.org/1999/xhtml"
>

  <xsl:output method="xml"
      doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
      doctype-public="-//W3C/DTD XHTML 1.0 Strict//EN"
      indent="yes"/>

  <xsl:template match="/*">
    <xsl:variable name="schema" select="//xsd:schema"/>
    <xsl:variable name="tabletypename"
                  select="$schema/xsd:element[@name=name(current())]/@type"/>
    <xsl:variable name="rowtypename"
                  select="$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/xsd:element[@name='row']/@type"/>

    <html>
      <head>
        <title><xsl:value-of select="name(current())"/></title>
      </head>
      <body>
        <table>
          <tr>
            <xsl:for-each select="$schema/xsd:complexType[@name=$rowtypename]/xsd:sequence/xsd:element/@name">
              <th><xsl:value-of select="."/></th>
            </xsl:for-each>
          </tr>

          <xsl:for-each select="row">
            <tr>
              <xsl:for-each select="*">
                <td><xsl:value-of select="."/></td>
              </xsl:for-each>
            </tr>
          </xsl:for-each>
        </table>
      </body>
    </html>
  </xsl:template>

</xsl:stylesheet>
]]></programlisting>
   </example>
  </sect2>
 </sect1>

 <sect1 id="functions-json">
  <title>Fonctions et opérateurs JSON</title>

  <indexterm zone="functions-json">
   <primary>JSON</primary>
   <secondary>fonctions et opérateurs</secondary>
  </indexterm>

  <para>
   Cette section décrit&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      les fonctions et opérateurs pour traiter et créer des données JSON
     </para>
    </listitem>
    <listitem>
     <para>
      le langage de chemin SQL/JSON
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Pour en savoir plus sur le standard SQL/JSON, voir <xref
   linkend="sqltr-19075-6"/>. Pour des détails sur les types JSON supportés
   dans <productname>PostgreSQL</productname>, voir <xref
   linkend="datatype-json"/>.
  </para>

  <sect2 id="functions-json-processing">
   <title>Traiter et créer des données JSON</title>

  <para>
   <xref linkend="functions-json-op-table"/> affiche les opérateurs
   disponibles pour les types de données JSON (voir <xref
   linkend="datatype-json"/>). De plus, les opérateurs de comparaison
   habituels indiqués dans <xref linkend="functions-comparison-op-table"/>
   sont disponibles pour le type <type>jsonb</type>, mais pas pour le type
   <type>json</type>. Les opérateurs de comparaison suivent les règles de tri
   des opérateurs B-tree indiqués dans <xref linkend="json-indexing"/>.
  </para>

  <table id="functions-json-op-table">
    <title>Opérateurs <type>json</type> et <type>jsonb</type></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Opérateur
       </para>
       <para>
        Description
       </para>
       <para>
        Exemple(s)
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;</literal> <type>integer</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;</literal> <type>integer</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extrait le <parameter>n</parameter>-ième élément d'un tableau JSON
        (les éléments du tableau sont indexés à partir de zéro, mais les
        nombres négatifs sont pris en compte à partir de la fin).
       </para>
       <para>
        <literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; 2</literal>
        <returnvalue>{"c":"baz"}</returnvalue>
       </para>
       <para>
        <literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; -3</literal>
        <returnvalue>{"a":"foo"}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;</literal> <type>text</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;</literal> <type>text</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extrait le champ objet JSON avec la clé donnée.
       </para>
       <para>
        <literal>'{"a": {"b":"foo"}}'::json -&gt; 'a'</literal>
        <returnvalue>{"b":"foo"}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;&gt;</literal> <type>integer</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;&gt;</literal> <type>integer</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extrait le <parameter>n</parameter>-ième élément d'un tableau JSON,
        comme le <type>text</type>.
       </para>
       <para>
        <literal>'[1,2,3]'::json -&gt;&gt; 2</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;&gt;</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;&gt;</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extrait le champ objet JSON d'après la clé donnée, comme
        <type>text</type>.
       </para>
       <para>
        <literal>'{"a":1,"b":2}'::json -&gt;&gt; 'b'</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>#&gt;</literal> <type>text[]</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>#&gt;</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extrait le sous-objet JSON d'un chemin spécifié, où les éléments du
        chemin peuvent être soit les clés d'un champ, soit les indices d'un
        tableau.
       </para>
       <para>
        <literal>'{"a": {"b": ["foo","bar"]}}'::json #&gt; '{a,b,1}'</literal>
        <returnvalue>"bar"</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>#&gt;&gt;</literal> <type>text[]</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>#&gt;&gt;</literal> <type>text[]</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extrait le sous-objet JSON au chemin spécifié avec <type>text</type>.
       </para>
       <para>
        <literal>'{"a": {"b": ["foo","bar"]}}'::json #&gt;&gt; '{a,b,1}'</literal>
        <returnvalue>bar</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
   <para>
    Les opérateurs d'extraction champ/élément/chemin renvoient NULL, plutôt
    qu'une erreur, si l'entrée JSON n'a pas la bonne structure correspondant à
    la requête&nbsp;; par exemple si la clé ou l'élément du tableau n'existe
    pas.
   </para>
  </note>

  <para>
   Quelques opérateurs supplémentaires existent seulement pour le type
   <type>jsonb</type>, comme indiqué dans <xref
   linkend="functions-jsonb-op-table"/>. <xref linkend="json-indexing"/>
   décrit comment ces opérateurs peuvent être utilisés pour rechercher
   efficacement les données <type>jsonb</type> indexées.
  </para>

  <table id="functions-jsonb-op-table">
    <title>Opérateurs <type>jsonb</type> supplémentaires</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Opérateur
       </para>
       <para>
        Description
       </para>
       <para>
        Exemple(s)
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@&gt;</literal> <type>jsonb</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Est-ce que la première valeur JSON contient la seconde&nbsp;? (Voir
        <xref linkend="json-containment"/> pour les détails sur la notion de
        contenu.)
       </para>
       <para>
        <literal>'{"a":1, "b":2}'::jsonb &#64;&gt; '{"b":2}'::jsonb</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>&lt;@</literal> <type>jsonb</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Est-ce que la première valeur JSON est contenue dans la seconde&nbsp;?
       </para>
       <para>
        <literal>'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Est-ce que la chaîne de caractères existe comme clé de haut niveau
        ou élément de tableau dans la valeur JSON&nbsp;?
       </para>
       <para>
        <literal>'{"a":1, "b":2}'::jsonb ? 'b'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>'["a", "b", "c"]'::jsonb ? 'b'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?|</literal> <type>text[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Est-ce qu'une des chaînes du tableau de texte existe comme clé
        de haut niveau ou comme élément de tableau&nbsp;?
       </para>
       <para>
        <literal>'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'd']</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?&amp;</literal> <type>text[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Est-ce que toutes les chaînes du tableau de texte existent comme clés
        de haut niveau ou comme éléments de tableau&nbsp;?
       </para>
       <para>
        <literal>'["a", "b", "c"]'::jsonb ?&amp; array['a', 'b']</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>||</literal> <type>jsonb</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Concatène deux valeurs <type>jsonb</type>. Concaténer deux objets
        génère un objet avec l'union de leurs clés, en prenant la valeur du
        deuxième objet quand il existe deux clés dupliquées. N'est pas
        récursif&nbsp;: seul le tableau ou la structure objet de haut niveau
        est assemblé.
       </para>
       <para>
        <literal>'["a", "b"]'::jsonb || '["a", "d"]'::jsonb</literal>
        <returnvalue>["a", "b", "a", "d"]</returnvalue>
       </para>
       <para>
        <literal>'{"a": "b"}'::jsonb || '{"c": "d"}'::jsonb</literal>
        <returnvalue>{"a": "b", "c": "d"}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>text</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Supprime une clé (et sa valeur) à partir d'un objet JSON, ou les
        valeurs correspondantes de chaînes à partir d'un tableau JSON.
       </para>
       <para>
        <literal>'{"a": "b", "c": "d"}'::jsonb - 'a'</literal>
        <returnvalue>{"c": "d"}</returnvalue>
       </para>
       <para>
        <literal>'["a", "b", "c", "b"]'::jsonb - 'b'</literal>
        <returnvalue>["a", "c"]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Supprime toutes les clés ou tous les éléments de tableau correspondant
        à partir de l'opérande gauche.
       </para>
       <para>
        <literal>'{"a": "b", "c": "d"}'::jsonb - '{a,c}'::text[]</literal>
        <returnvalue>{}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>integer</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Supprime l'élément de tableau pour l'index spécifié (les nombres
        négatifs se décomptent à partir de la fin). Renvoie une erreur si la
        valeur JSON n'est pas un tableau.
       </para>
       <para>
        <literal>'["a", "b"]'::jsonb - 1 </literal>
        <returnvalue>["a"]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>#-</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Supprime le champ ou l'élément de tableau sur le chemin indiqué, les
        éléments du chemin pouvant être soit des clés de champ, soit des
        indices de tableau.
       </para>
       <para>
        <literal>'["a", {"b":1}]'::jsonb #- '{1,b}'</literal>
        <returnvalue>["a", {}]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@?</literal> <type>jsonpath</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Est-ce que le chemin JSON renvoie tout élément pour la valeur JSON
        spécifiée&nbsp;?
       </para>
       <para>
        <literal>'{"a":[1,2,3,4,5]}'::jsonb @? '$.a[*] ? (@ > 2)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@@</literal> <type>jsonpath</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Renvoie le résultat d'une vérification de prédicat du chemin JSON pour
        la valeur JSON indiquée. Seul le premier élément du résultat est pris
        en compte. Si le résultat n'est pas un booléen, alors
        <literal>NULL</literal> est renvoyé.
       </para>
       <para>
        <literal>'{"a":[1,2,3,4,5]}'::jsonb @@ '$.a[*] > 2'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
   <para>
    Les opérateurs <literal>@?</literal> et <literal>@@</literal> du type
    <type>jsonpath</type> suppriment les erreurs suivantes&nbsp;: champ objet
    ou élément de tableau manquant, type d'élément JSON inattendu, erreurs de
    date/heure ou de numérique. Les fonctions relatives à
    <type>jsonpath</type> décrites ci-dessous peuvent aussi supprimer ce type
    d'erreurs à la demande. Ce comportement pourrait être utile lors de la
    recherche de collections de documents JSON de différentes structures.
   </para>
  </note>

  <para>
   <xref linkend="functions-json-creation-table"/> montre les fonctions
   disponibles pour construire des valeurs <type>json</type> et
   <type>jsonb</type>.
  </para>

  <table id="functions-json-creation-table">
    <title>Fonctions de création de JSON</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Fonction
       </para>
       <para>
        Description
       </para>
       <para>
        Exemple(s)
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_json</primary>
        </indexterm>
        <function>to_json</function> ( <type>anyelement</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>to_jsonb</primary>
        </indexterm>
        <function>to_jsonb</function> ( <type>anyelement</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Convertit toute valeur SQL en <type>json</type> ou <type>jsonb</type>.
        Les tableaux et valeurs composites sont convertis récursivement en
        tableaux et en objets (les tableaux multidimensionnels deviennent des
        tableaux de tableaux en JSON). Sinon, s'il existe une conversion entre
        le type de données SQL et <type>json</type>, la fonction de conversion
        sera utilisée pour réaliser la conversion&nbsp;;<footnote>
         <para>
          Par exemple, l'extension <xref linkend="hstore"/> contient une
          conversion de <type>hstore</type> vers <type>json</type>, pour que
          les valeurs <type>hstore</type> converties par les fonctions de
          création JSON soient représentées en tant qu'objets JSON, et non pas
          comme des valeurs de type chaîne de caractères.
         </para>
        </footnote>
        sinon, une valeur JSON scalaire est produite. Pour tout scalaire autre
        qu'un nombre, un booléen ou une valeur NULL, la représentation
        textuelle sera utilisée avec les échappements nécessaires pour la
        transformer en valeur JSON valide.
       </para>
       <para>
        <literal>to_json('Fred said "Hi."'::text)</literal>
        <returnvalue>"Fred said \"Hi.\""</returnvalue>
       </para>
       <para>
        <literal>to_jsonb(row(42, 'Fred said "Hi."'::text))</literal>
        <returnvalue>{"f1": 42, "f2": "Fred said \"Hi.\""}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_json</primary>
        </indexterm>
        <function>array_to_json</function> ( <type>anyarray</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>json</returnvalue>
       </para>
       <para>
        Convertit un tableau SQL en tableau JSON. Le comportement est le même
        que <function>to_json</function> sauf que des sauts de ligne seront
        ajoutés entre les éléments de tableau de haut niveau si le paramètre
        booléen optionnel vaut true.
       </para>
       <para>
        <literal>array_to_json('{{1,5},{99,100}}'::int[])</literal>
        <returnvalue>[[1,5],[99,100]]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_to_json</primary>
        </indexterm>
        <function>row_to_json</function> ( <type>record</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>json</returnvalue>
       </para>
       <para>
        Convertit une valeur composite SQL en objet JSON. Le comportement est
        le même que <function>to_json</function> sauf que des sauts de ligne
        seront ajoutés entre les éléments de tableau de haut niveau si le
        paramètre booléen optionnel vaut true.
       </para>
       <para>
        <literal>row_to_json(row(1,'foo'))</literal>
        <returnvalue>{"f1":1,"f2":"foo"}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_build_array</primary>
        </indexterm>
        <function>json_build_array</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_build_array</primary>
        </indexterm>
        <function>jsonb_build_array</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Construit un tableau JSON avec des types potentiellement hétérogènes à
        partir d'une liste d'arguments de longueur variable. Chaque argument
        est converti avec la fonction <function>to_json</function> ou
        <function>to_jsonb</function>.
       </para>
       <para>
        <literal>json_build_array(1, 2, 'foo',4,5)</literal>
        <returnvalue>[1, 2, "foo", 4, 5]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_build_object</primary>
        </indexterm>
        <function>json_build_object</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_build_object</primary>
        </indexterm>
        <function>jsonb_build_object</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Construit un objet JSON à partir d'une liste d'arguments de longueur
        indéfinie. Par convention, la liste d'arguments consiste en des clés
        et valeurs en alternance. Les arguments clés sont convertis en
        texte&nbsp;; les arguments valeurs sont convertis via les fonctions
        <function>to_json</function> ou <function>to_jsonb</function>.
       </para>
       <para>
        <literal>json_build_object('foo', 1, 2, row(3, 'bar'))</literal>
        <returnvalue>{"foo" : 1, "2" : {"f1":3,"f2":"bar"}}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object</primary>
        </indexterm>
        <function>json_object</function> ( <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object</primary>
        </indexterm>
        <function>jsonb_object</function> ( <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Construit un objet JSON à partir d'un tableau de texte. Le tableau
        doit avoir soit exactement une dimension avec un nombre pair de
        membres, auquel cas ils sont pris comme des paires alternantes
        clé/valeur, ou deux dimensions de telle façon que le tableau interne a
        exactement deux éléments, pris comme une paire clé/valeur. Toutes les
        valeurs sont converties en chaîne JSON.
       </para>
       <para>
        <literal>json_object('{a, 1, b, "def", c, 3.5}')</literal>
        <returnvalue>{"a" : "1", "b" : "def", "c" : "3.5"}</returnvalue>
       </para>
        <para><literal>json_object('{{a, 1}, {b, "def"}, {c, 3.5}}')</literal>
        <returnvalue>{"a" : "1", "b" : "def", "c" : "3.5"}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>json_object</function> ( <parameter>keys</parameter> <type>text[]</type>, <parameter>values</parameter> <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <function>jsonb_object</function> ( <parameter>keys</parameter> <type>text[]</type>, <parameter>values</parameter> <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Cette forme de <function>json_object</function> prend les clés et
        valeurs à partir de tableaux de texte séparés. Pour le reste, elle est
        identique à la forme à un argument.
       </para>
       <para>
        <literal>json_object('{a, b}', '{1,2}')</literal>
        <returnvalue>{"a": "1", "b": "2"}</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   <xref linkend="functions-json-processing-table"/> montre les fonctions
   disponibles pour le traitement de valeurs <type>json</type> et
   <type>jsonb</type>.
  </para>

  <table id="functions-json-processing-table">
    <title>Fonctions de traitement JSON</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Fonction
       </para>
       <para>
        Description
       </para>
       <para>
        Exemple(s)
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_elements</primary>
        </indexterm>
        <function>json_array_elements</function> ( <type>json</type> )
        <returnvalue>setof json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_elements</primary>
        </indexterm>
        <function>jsonb_array_elements</function> ( <type>jsonb</type> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para>
        Étend le tableau JSON de haut niveau en un ensemble de valeurs JSON.
       </para>
       <para>
        <literal>select * from json_array_elements('[1,true, [2,false]]')</literal>
        <returnvalue></returnvalue>
<programlisting>
   value
-----------
 1
 true
 [2,false]
       </programlisting>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>json_array_elements_text</primary>
       </indexterm>
       <function>json_array_elements_text</function> ( <type>json</type> )
       <returnvalue>setof text</returnvalue>
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>jsonb_array_elements_text</primary>
       </indexterm>
       <function>jsonb_array_elements_text</function> ( <type>jsonb</type> )
       <returnvalue>setof text</returnvalue>
      </para>
      <para>
       Étend le tableau JSON de haut niveau en un ensemble de valeurs de type
       <type>text</type>.
      </para>
      <para>
       <literal>select * from json_array_elements_text('["foo", "bar"]')</literal>
       <returnvalue></returnvalue>
       <programlisting>
   value
-----------
 foo
 bar
       </programlisting>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>json_array_length</primary>
       </indexterm>
       <function>json_array_length</function> ( <type>json</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>jsonb_array_length</primary>
       </indexterm>
       <function>jsonb_array_length</function> ( <type>jsonb</type> )
       <returnvalue>integer</returnvalue>
      </para>
      <para>
       Renvoie le nombre d'éléments dans le tableau JSON de haut niveau.
      </para>
      <para>
       <literal>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</literal>
       <returnvalue>5</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>json_each</primary>
       </indexterm>
       <function>json_each</function> ( <type>json</type> )
       <returnvalue>setof record</returnvalue>
       ( <parameter>key</parameter> <type>text</type>,
       <parameter>value</parameter> <type>json</type> )
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>jsonb_each</primary>
       </indexterm>
       <function>jsonb_each</function> ( <type>jsonb</type> )
       <returnvalue>setof record</returnvalue>
       ( <parameter>key</parameter> <type>text</type>,
       <parameter>value</parameter> <type>jsonb</type> )
      </para>
      <para>
       Étend l'objet JSON de haut niveau en un ensemble de paires clé/valeur.
      </para>
      <para>
       <literal>select * from json_each('{"a":"foo", "b":"bar"}')</literal>
       <returnvalue></returnvalue>
       <programlisting>
 key | value
-----+-------
 a   | "foo"
 b   | "bar"
       </programlisting>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>json_each_text</primary>
       </indexterm>
       <function>json_each_text</function> ( <type>json</type> )
       <returnvalue>setof record</returnvalue>
       ( <parameter>key</parameter> <type>text</type>,
       <parameter>value</parameter> <type>text</type> )
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>jsonb_each_text</primary>
       </indexterm>
       <function>jsonb_each_text</function> ( <type>jsonb</type> )
       <returnvalue>setof record</returnvalue>
       ( <parameter>key</parameter> <type>text</type>,
       <parameter>value</parameter> <type>text</type> )
      </para>
      <para>
       Étend l'objet JSON de haut niveau en un ensemble de paires clé/valeur.
       Les <parameter>value</parameter> renvoyées seront de type
       <type>text</type>.
      </para>
      <para>
       <literal>select * from json_each_text('{"a":"foo", "b":"bar"}')</literal>
       <returnvalue></returnvalue>
       <programlisting>
 key | value
-----+-------
 a   | foo
 b   | bar
       </programlisting>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>json_extract_path</primary>
       </indexterm>
       <function>json_extract_path</function> ( <parameter>from_json</parameter> <type>json</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
       <returnvalue>json</returnvalue>
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>jsonb_extract_path</primary>
       </indexterm>
       <function>jsonb_extract_path</function> ( <parameter>from_json</parameter> <type>jsonb</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
       <returnvalue>jsonb</returnvalue>
      </para>
      <para>
       Extrait un sous-objet JSON au chemin spécifié. (Ceci est
       fonctionnellement équivalent à l'opérateur <literal>#&gt;</literal>,
       mais écrire le chemin sous la forme d'une liste peut être plus
       agréable dans certains cas.)
      </para>
      <para>
       <literal>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</literal>
       <returnvalue>"foo"</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>json_extract_path_text</primary>
       </indexterm>
       <function>json_extract_path_text</function> ( <parameter>from_json</parameter> <type>json</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>jsonb_extract_path_text</primary>
       </indexterm>
       <function>jsonb_extract_path_text</function> ( <parameter>from_json</parameter> <type>jsonb</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Extrait le sous-objet JSON au chemin spécifié sous la forme d'un
       <type>text</type>. (Ceci est équivalent fonctionnement à l'opérateur
       <literal>#&gt;&gt;</literal>.)
      </para>
      <para>
       <literal>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</literal>
       <returnvalue>foo</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>json_object_keys</primary>
       </indexterm>
       <function>json_object_keys</function> ( <type>json</type> )
       <returnvalue>setof text</returnvalue>
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>jsonb_object_keys</primary>
       </indexterm>
       <function>jsonb_object_keys</function> ( <type>jsonb</type> )
       <returnvalue>setof text</returnvalue>
      </para>
      <para>
       Renvoie l'ensemble de clés dans l'objet JSON de haut niveau.
      </para>
      <para>
       <literal>select * from json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</literal>
       <returnvalue></returnvalue>
       <programlisting>
 json_object_keys
------------------
 f1
 f2
       </programlisting>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>json_populate_record</primary>
       </indexterm>
       <function>json_populate_record</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>json</type> )
       <returnvalue>anyelement</returnvalue>
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>jsonb_populate_record</primary>
       </indexterm>
       <function>jsonb_populate_record</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>jsonb</type> )
       <returnvalue>anyelement</returnvalue>
      </para>
      <para>
       Étend l'objet JSON de haut niveau en une ligne ayant le type composite
       de l'argument <parameter>base</parameter>. L'objet JSON est parcouru
       pour y trouver les champs dont le nom correspond aux noms de colonnes
       du type de la ligne en sortie, et leurs valeurs sont insérées dans ces
       colonnes en sortie. (Les champs qui ne correspondent à aucun nom de
       colonne en sortie sont ignorés.) Dans le cas d'une utilisation
       typique, la valeur de <parameter>base</parameter> est simplement
       <literal>NULL</literal>, ce qui signifie que toute colonne en sortie
       qui ne correspond pas à un champ d'objet sera remplie avec un NULL.
       Néanmoins, si <parameter>base</parameter> ne vaut pas
       <literal>NULL</literal>, alors les valeurs qu'il contient seront
       utilisées pour les colonnes sans correspondance.
      </para>
      <para>
       Pour convertir une valeur JSON au type SQL d'une colonne en sortie,
       les règles suivantes sont appliquées sur cette séquence&nbsp;:
       <itemizedlist spacing="compact">
        <listitem>
         <para>
          Une valeur JSON null est convertie en NULL SQL dans tous les cas.
         </para>
        </listitem>
        <listitem>
         <para>
          Si la colonne en sortie est de type <type>json</type> ou
          <type>jsonb</type>, la valeur JSON est reproduite exactement.
         </para>
        </listitem>
        <listitem>
         <para>
          Si la colonne en sortie est un type (de ligne) composite, et que la
          valeur JSON est un objet JSON, les champs de l'objet sont convertis
          en colonnes du type de ligne par application récursive de ces
          règles.
         </para>
        </listitem>
        <listitem>
         <para>
          De la même façon, si la colonne en sortie est un type tableau et que
          la valeur JSON est un tableau JSON, les éléments du tableau JSON
          sont convertis en éléments du tableau en sortie par application
          récursive de ces règles.
         </para>
        </listitem>
        <listitem>
         <para>
          Sinon, si la valeur JSON est une chaîne, le contenu de la chaîne
          est donné à la fonction de conversion en entrée pour le type de
          données de la colonne.
         </para>
        </listitem>
        <listitem>
         <para>
          Sinon, la représentation textuelle habituelle de la valeur JSON est
          envoyée à la fonction de conversion en entrée pour le type de
          données de la colonne.
         </para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
       Bien que l'exemple ci-dessous utilise une valeur constante JSON, une
       utilisation typique serait de référencer une colonne <type>json</type>
       ou <type>jsonb</type> latéralement d'une autre table dans la clause
       <literal>FROM</literal> de la requête. Écrire
       <function>json_populate_record</function> dans la clause
       <literal>FROM</literal> est une bonne pratique, car toutes les colonnes
       extraites sont utilisables sans avoir à faire des appels dupliqués à
       la fonction.
      </para>
      <para>
       <literal>create type subrowtype as (d int, e text);</literal>
       <literal>create type myrowtype as (a int, b text[], c subrowtype);</literal>
      </para>
      <para>
       <literal>select * from json_populate_record(null::myrowtype,
        '{"a": 1, "b": ["2", "a b"], "c": {"d": 4, "e": "a  b c"}, "x": "foo"}')</literal>
       <returnvalue></returnvalue>
       <programlisting>
 a |   b       |      c
---+-----------+-------------
 1 | {2,"a b"} | (4,"a b c")
       </programlisting>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>json_populate_recordset</primary>
       </indexterm>
       <function>json_populate_recordset</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>json</type> )
       <returnvalue>setof anyelement</returnvalue>
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>jsonb_populate_recordset</primary>
       </indexterm>
       <function>jsonb_populate_recordset</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>jsonb</type> )
       <returnvalue>setof anyelement</returnvalue>
      </para>
      <para>
       Étend le tableau JSON de haut niveau composé d'objets en un ensemble
       de lignes ayant le type composite de l'argument
       <parameter>base</parameter>. Chaque élément du tableau JSON est traité
       comme décrit ci-dessus pour
       <function>json[b]_populate_record</function>.
      </para>
      <para>
       <literal>create type twoints as (a int, b int);</literal>
      </para>
      <para>
       <literal>select * from json_populate_recordset(null::twoints, '[{"a":1,"b":2}, {"a":3,"b":4}]')</literal>
       <returnvalue></returnvalue>
       <programlisting>
 a | b
---+---
 1 | 2
 3 | 4
       </programlisting>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>json_to_record</primary>
       </indexterm>
       <function>json_to_record</function> ( <type>json</type> )
       <returnvalue>record</returnvalue>
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>jsonb_to_record</primary>
       </indexterm>
       <function>jsonb_to_record</function> ( <type>jsonb</type> )
       <returnvalue>record</returnvalue>
      </para>
      <para>
       Étend l'objet JSON de haut niveau en une ligne ayant le type composite
       défini par une clause <literal>AS</literal>. (Comme avec toutes les
       fonctions renvoyant <type>record</type>, la requête appelante doit
       explicitement définir la structure de l'enregistrement avec une clause
       <literal>AS</literal>.) L'enregistrement en sortie est rempli avec les
       champs de l'objet JSON, de la même façon que décrite ci-dessus pour
       <function>json[b]_populate_record</function>. Comme il n'existe aucune
       valeur record en entrée, les colonnes sans correspondance sont
       remplies avec des NULL.
      </para>
      <para>
       <literal>create type myrowtype as (a int, b text);</literal>
      </para>
      <para>
       <literal>select * from json_to_record('{"a":1, "b":[1,2,3], "c":[1,2,3], "e":"bar", "r": {"a": 123, "b": "a b c"}}') as x(a int, b text, c int[], d text, r myrowtype)</literal>
       <returnvalue></returnvalue>
       <programlisting>
 a |    b    |    c    | d |       r
---+---------+---------+---+---------------
 1 | [1,2,3] | {1,2,3} |   | (123,"a b c")
       </programlisting>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>json_to_recordset</primary>
       </indexterm>
       <function>json_to_recordset</function> ( <type>json</type> )
       <returnvalue>setof record</returnvalue>
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>jsonb_to_recordset</primary>
       </indexterm>
       <function>jsonb_to_recordset</function> ( <type>jsonb</type> )
       <returnvalue>setof record</returnvalue>
      </para>
      <para>
       Étend le tableau JSON de haut niveau composé d'objets en un ensemble
       de lignes ayant le type composite défini par une clause
       <literal>AS</literal>. (Comme avec toutes les fonctions renvoyant
       <type>record</type>, la requête appelante doit explicitement définir
       la structure de l'enregistrement avec une clause
       <literal>AS</literal>.) Chaque élément du tableau JSON est traité
       comme décrit ci-dessus pour
       <function>json[b]_populate_record</function>.
      </para>
      <para>
       <literal>select * from json_to_recordset('[{"a":1,"b":"foo"}, {"a":"2","c":"bar"}]') as x(a int, b text)</literal>
       <returnvalue></returnvalue>
       <programlisting>
 a |  b
---+-----
 1 | foo
 2 |
       </programlisting>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>jsonb_set</primary>
       </indexterm>
       <function>jsonb_set</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>create_if_missing</parameter> <type>boolean</type> </optional> )
       <returnvalue>jsonb</returnvalue>
      </para>
      <para>
       Renvoie <parameter>target</parameter> avec l'élément désigné par
       <parameter>path</parameter> remplacé par
       <parameter>new_value</parameter> ou avec
       <parameter>new_value</parameter> ajouté si
       <parameter>create_if_missing</parameter> vaut true (ce qui est la
       valeur par défaut) et si l'élément désigné par
       <parameter>path</parameter> n'existe pas. Toutes les étapes
       précédentes dans le chemin doivent exister, sinon le
       <parameter>target</parameter> est renvoyé intact. Comme avec les
       opérateurs orientés chemin, les entiers négatifs qui apparaissent dans
       <parameter>path</parameter> se décomptent à partir de la fin des
       tableaux JSON. Si l'étape du dernier chemin est un index inexistant
       (hors limite) du tableau et si
       <parameter>create_if_missing</parameter> vaut true, la nouvelle valeur
       est ajoutée au début du tableau si l'index est négatif et à la fin du
       tableau s'il est positif.
      </para>
      <para>
       <literal>jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0,f1}','[2,3,4]', false)</literal>
       <returnvalue>[{"f1": [2, 3, 4], "f2": null}, 2, null, 3]</returnvalue>
      </para>
      <para>
       <literal>jsonb_set('[{"f1":1,"f2":null},2]', '{0,f3}', '[2,3,4]')</literal>
       <returnvalue>[{"f1": 1, "f2": null, "f3": [2, 3, 4]}, 2]</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>jsonb_set_lax</primary>
       </indexterm>
       <function>jsonb_set_lax</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>create_if_missing</parameter> <type>boolean</type> <optional>, <parameter>null_value_treatment</parameter> <type>text</type> </optional></optional> )
       <returnvalue>jsonb</returnvalue>
      </para>
      <para>
       Si <parameter>new_value</parameter> n'est pas <literal>NULL</literal>,
       se comporte de façon identique à <literal>jsonb_set</literal>. Sinon
       se comporte suivant la valeur de
       <parameter>null_value_treatment</parameter> qui doit être parmi
       <literal>'raise_exception'</literal>,
       <literal>'use_json_null'</literal>, <literal>'delete_key'</literal> ou
       <literal>'return_target'</literal>. Par défaut, il s'agit de
       <literal>'use_json_null'</literal>.
      </para>
      <para>
       <literal>jsonb_set_lax('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', null)</literal>
       <returnvalue>[{"f1":null,"f2":null},2,null,3]</returnvalue>
      </para>
      <para>
       <literal>jsonb_set_lax('[{"f1":99,"f2":null},2]', '{0,f3}', null, true, 'return_target')</literal>
       <returnvalue>[{"f1": 99, "f2": null}, 2]</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>jsonb_insert</primary>
       </indexterm>
       <function>jsonb_insert</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>insert_after</parameter> <type>boolean</type> </optional> )
       <returnvalue>jsonb</returnvalue>
      </para>
      <para>
       Renvoie <parameter>target</parameter> avec
       <parameter>new_value</parameter> inséré. Si l'élément désigné par
       <parameter>path</parameter> est un élément de tableau,
       <parameter>new_value</parameter> sera inséré avant cet élément si
       <parameter>insert_after</parameter> vaut false (ce qui est la valeur
       par défaut) ou après si <parameter>insert_after</parameter> vaut true.
       Si l'élément désigné par <parameter>path</parameter> est un champ
       objet, <parameter>new_value</parameter> sera inséré seulement si
       l'objet ne contient pas déjà cette clé. Toutes les étapes précédentes
       dans le chemin doivent exister, sinon <parameter>target</parameter>
       est renvoyé non modifié. Comme avec les opérateurs orientés chemin,
       les nombres négatifs qui apparaissent dans <parameter>path</parameter>
       sont décomptés à partir de la fin des tableaux JSON. Si la dernière
       étape du chemin est un index hors limite de tableau, la nouvelle
       valeur est ajoutée au début du tableau si l'index est négatif ou à la
       fin du tableau s'il est positif.
      </para>
      <para>
       <literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"')</literal>
       <returnvalue>{"a": [0, "new_value", 1, 2]}</returnvalue>
      </para>
      <para>
       <literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"', true)</literal>
       <returnvalue>{"a": [0, 1, "new_value", 2]}</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>json_strip_nulls</primary>
       </indexterm>
       <function>json_strip_nulls</function> ( <type>json</type> )
       <returnvalue>json</returnvalue>
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>jsonb_strip_nulls</primary>
       </indexterm>
       <function>jsonb_strip_nulls</function> ( <type>jsonb</type> )
       <returnvalue>jsonb</returnvalue>
      </para>
      <para>
       Supprime tous les champs objets ayant des valeurs NULL à partir de la
       valeur JSON donnée, de façon récurvise. Les valeurs NULL qui ne sont
       pas des champs objets ne sont pas touchées.
      </para>
      <para>
       <literal>json_strip_nulls('[{"f1":1, "f2":null}, 2, null, 3]')</literal>
       <returnvalue>[{"f1":1},2,null,3]</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>jsonb_path_exists</primary>
       </indexterm>
       <function>jsonb_path_exists</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Vérifie si le chemin JSON renvoie des éléments de la valeur JSON
       spécifiée. Si l'argument <parameter>vars</parameter> est indiqué, il
       doit correspondre à un objet JSON, et ses champs fournissent des
       valeurs nommées à substituer dans l'expression <type>jsonpath</type>.
       Si l'argument <parameter>silent</parameter> est indiqué et vaut
       <literal>true</literal>, la fonction supprime les mêmes erreurs que
       les opérateurs <literal>@?</literal> et <literal>@@</literal>.
      </para>
      <para>
       <literal>jsonb_path_exists('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2,"max":4}')</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>jsonb_path_match</primary>
       </indexterm>
       <function>jsonb_path_match</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
       <returnvalue>boolean</returnvalue>
      </para>
      <para>
       Renvoie le résultat de la vérification d'un prédicat de chemin JSON
       pour la valeur JSON spécifiée. Seul le premier élément du résultat est
       pris en compte. Si le résultat n'est pas un booléen, alors
       <literal>NULL</literal> est renvoyé. Les arguments optionnels
       <parameter>vars</parameter> et <parameter>silent</parameter> agissent
       de la même façon que pour <function>jsonb_path_exists</function>.
      </para>
      <para>
       <literal>jsonb_path_match('{"a":[1,2,3,4,5]}', 'exists($.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max))', '{"min":2,"max":4}')</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>jsonb_path_query</primary>
       </indexterm>
       <function>jsonb_path_query</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
       <returnvalue>setof jsonb</returnvalue>
      </para>
      <para>
       Renvoie tous les éléments JSON renvoyés par le chemin JSON pour la
       valeur JSON spécifiée. Les arguments optionnels
       <parameter>vars</parameter> et <parameter>silent</parameter> agissent
       de la même façon que pour <function>jsonb_path_exists</function>.
      </para>
      <para>
       <literal>select * from jsonb_path_query('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2,"max":4}')</literal>
       <returnvalue></returnvalue>
       <programlisting>
 jsonb_path_query
------------------
 2
 3
 4
       </programlisting>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>jsonb_path_query_array</primary>
       </indexterm>
       <function>jsonb_path_query_array</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
       <returnvalue>jsonb</returnvalue>
      </para>
      <para>
       Renvoie tous les éléments JSON renvoyés par le chemin JSON pour la
       valeur JSON spécifiée, sous la forme d'un tableau JSON. Les arguments
       optionnels <parameter>vars</parameter> et
       <parameter>silent</parameter> agissent de la même façon que pour
       <function>jsonb_path_exists</function>.
      </para>
      <para>
       <literal>jsonb_path_query_array('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
       <returnvalue>[2, 3, 4]</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>jsonb_path_query_first</primary>
       </indexterm>
       <function>jsonb_path_query_first</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
       <returnvalue>jsonb</returnvalue>
      </para>
      <para>
       Renvoie le premier élément JSON renvoyé par le chemin JSON pour la
       valeur JSON spécifiée. Renvoie <literal>NULL</literal> s'il n'y a pas
       de résultat. Les arguments optionnels <parameter>vars</parameter> et
       <parameter>silent</parameter> agissent de la même façon que pour
       <function>jsonb_path_exists</function>.
      </para>
      <para>
       <literal>jsonb_path_query_first('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
       <returnvalue>2</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>jsonb_path_exists_tz</primary>
       </indexterm>
       <function>jsonb_path_exists_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
       <returnvalue>boolean</returnvalue>
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>jsonb_path_match_tz</primary>
       </indexterm>
       <function>jsonb_path_match_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
       <returnvalue>boolean</returnvalue>
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>jsonb_path_query_tz</primary>
       </indexterm>
       <function>jsonb_path_query_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
       <returnvalue>setof jsonb</returnvalue>
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>jsonb_path_query_array_tz</primary>
       </indexterm>
       <function>jsonb_path_query_array_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
       <returnvalue>jsonb</returnvalue>
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>jsonb_path_query_first_tz</primary>
       </indexterm>
       <function>jsonb_path_query_first_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
       <returnvalue>jsonb</returnvalue>
      </para>
      <para>
       Ces fonctions agissent comme leurs homologues décrits ci-dessus sans
       le suffixe <literal>_tz</literal>, sauf que ces fonctions acceptent la
       comparaison de valeurs date/heure qui nécessitent des conversions
       adaptées suivant le fuseau horaire. L'exemple ci-dessous requiert
       l'interprétation de la valeur date seule <literal>2015-08-02</literal>
       comme un horodatage avec fuseau horaire, pour que le résultat dépende
       du paramétrage actuel de <xref linkend="guc-timezone"/>. Du fait de
       cette dépendance, ces fonctions sont marquées stables, ce qui signifie
       que ces fonctions ne peuvent pas être utilisées dans les index. Leurs
       homologues sont immuables, et donc peuvent être utilisés dans les
       index&nbsp;; cependant, elles renverront des erreurs si on leur
       demande ce type de comparaison.
      </para>
      <para>
       <literal>jsonb_path_exists_tz('["2015-08-01 12:00:00 -05"]', '$[*] ? (@.datetime() &lt; "2015-08-02".datetime())')</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>jsonb_pretty</primary>
       </indexterm>
       <function>jsonb_pretty</function> ( <type>jsonb</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Convertit la valeur JSON donnée en un texte proprement indenté.
      </para>
      <para>
       <literal>jsonb_pretty('[{"f1":1, "f2":null}, 2]')</literal>
       <returnvalue></returnvalue>
       <programlisting>
[
    {
        "f1": 1,
        "f2": null
    },
    2
]
       </programlisting>
      </para></entry>
    </row>

    <row>
     <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>json_typeof</primary>
       </indexterm>
       <function>json_typeof</function> ( <type>json</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para role="func_signature">
       <indexterm>
        <primary>jsonb_typeof</primary>
       </indexterm>
       <function>jsonb_typeof</function> ( <type>jsonb</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Renvoie le type de la valeur JSON de haut niveau sous la forme d'une
       chaîne de caractères. Les types possibles sont
       <literal>object</literal>, <literal>array</literal>,
       <literal>string</literal>, <literal>number</literal>,
       <literal>boolean</literal> et <literal>null</literal>. (Le résultat
       <literal>null</literal> ne doit pas être pris pour un NULL SQL&nbsp;;
       voir les exemples.)
      </para>
      <para>
       <literal>json_typeof('-123.4')</literal>
       <returnvalue>number</returnvalue>
      </para>
      <para>
       <literal>json_typeof('null'::json)</literal>
       <returnvalue>null</returnvalue>
      </para>
      <para>
       <literal>json_typeof(NULL::json) IS NULL</literal>
       <returnvalue>t</returnvalue>
      </para></entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
  Voir aussi <xref linkend="functions-aggregate"/> pour la fonction
  d'agrégat <function>json_agg</function> qui agrège les valeurs
  d'enregistrements sous la forme d'un JSON, pour la fonction d'agrégat
  <function>json_object_agg</function> qui agrège des paires de valeurs dans
  un objet JSON, et leurs équivalents <type>jsonb</type>, à savoir
  <function>jsonb_agg</function> et <function>jsonb_object_agg</function>.
 </para>
</sect2>

<sect2 id="functions-sqljson-path">
 <title>Le langage de chemin SQL/JSON</title>

 <indexterm zone="functions-sqljson-path">
  <primary>langage de chemin SQL/JSON</primary>
 </indexterm>

 <para>
  Les expressions de chemin SQL/JSON indiquent les éléments à récupérer à
  partir de données JSON, similaires aux expressions XPath utilisées pour
  l'accès SQL au XML. Dans <productname>PostgreSQL</productname>, les
  expressions de chemin sont implémentées sous la forme du type de données
  <type>jsonpath</type> et peuvent utiliser tout élément décrit dans <xref
  linkend="datatype-jsonpath"/>.
 </para>

 <para>
  Les fonctions et opérateurs de requêtes JSON passent l'expression de chemin
  fournie au <firstterm>moteur de chemin</firstterm> pour évaluation. Si
  l'expression correspond à la donnée JSON requêtée, l'élément JSON
  correspondant ou l'ensemble d'éléments est renvoyé. Les expressions de
  chemin sont écrites dans le langage de chemin SQL/JSON et peuvent inclure
  les expressions et fonctions arithmétiques.
 </para>

 <para>
  Une expression de chemin consiste en une séquence d'éléments autorisés par
  le type de données <type>jsonpath</type>. L'expression de chemin est
  habituellement évaluée de gauche à droite, mais vous pouvez utiliser les
  parenthèses pour modifier l'ordre des opérations. Si l'évaluation réussit,
  une séquence d'éléments JSON est produite et le résultat de l'évaluation
  est renvoyé à la fonction de requête JSON qui termine le traitement
  indiqué.
 </para>

 <para>
  Pour faire référence à la valeur JSON en cours de requêtage
  (l'<firstterm>élément de contexte</firstterm>), utilisez la variable
  <literal>$</literal> dans l'expression de chemin. Elle peut être suivie par
  un ou plusieurs <link linkend="type-jsonpath-accessors">opérateurs
   d'accesseurs</link>, qui descendent dans la structure JSON, étape par
  étape, pour récupérer les sous-éléments de l'élément de contexte. Chaque
  opérateur qui suit traite le résultat de l'étape d'évaluation précédente.
 </para>

 <para>
  Par exemple, supposez que vous ayez certaines données JSON à partir d'un
  traqueur GPS que vous voulez analyser, tel que&nbsp;:
  <programlisting>
{
  "track": {
    "segments": [
      {
        "location":   [ 47.763, 13.4034 ],
        "start time": "2018-10-14 10:05:14",
        "HR": 73
      },
      {
        "location":   [ 47.706, 13.2635 ],
        "start time": "2018-10-14 10:39:21",
        "HR": 135
      }
    ]
  }
}
  </programlisting>
 </para>

 <para>
  Pour récupérer les segments de piste disponibles, vous avez besoin
  d'utiliser l'opérateur d'accesseur
  <literal>.<replaceable>key</replaceable></literal> pour descendre à travers
  les objets JSON tout autour&nbsp;:
  <programlisting>
$.track.segments
  </programlisting>
 </para>

 <para>
  Pour récupérer le contenu d'un tableau, vous utilisez typiquement
  l'opérateur <literal>[*]</literal>. Par exemple, le chemin suivant renverra
  les coordonnées d'emplacement pour tous les segments de piste
  disponibles&nbsp;:
  <programlisting>
$.track.segments[*].location
  </programlisting>
 </para>

 <para>
  Pour renvoyer les coordonnées du premier segment seulement, vous pouvez
  indiquer l'indice correspondant dans l'opérateur <literal>[]</literal>.
  Rappellez-vous que les indices de tableau JSON commencent à 0&nbsp;:
  <programlisting>
$.track.segments[0].location
  </programlisting>
 </para>

 <para>
  Le résultat de chaque étape d'évaluation de chemin peut être traité par un
  ou plusieurs opérateurs et méthodes <type>jsonpath</type>, listés dans
  <xref linkend="functions-sqljson-path-operators"/>. Chaque nom de méthode
  doit être précédé d'un point. Par exemple, vous pouvez obtenir la taille
  d'un tableau&nbsp;:
  <programlisting>
$.track.segments.size()
  </programlisting>
  D'autres exemples d'utilisation d'opérateurs et méthodes
  <type>jsonpath</type> à l'intérieur d'expressions de chemins apparaissent
  ci-dessous dans <xref linkend="functions-sqljson-path-operators"/>.
 </para>

 <para>
  Lors de la définition d'un chemin, vous pouvez aussi utiliser une ou
  plusieurs <firstterm>expressions de filtre</firstterm> qui fonctionnent de
  façon similaire à la clause <literal>WHERE</literal> en SQL. Une expression
  de filtre commence avec un point d'interrogation et fournit une condition
  entre parenthèses&nbsp;:

  <programlisting>
? (<replaceable>condition</replaceable>)
  </programlisting>
 </para>

 <para>
  Les expressions de filtre doivent être écrites juste après l'étape
  d'évaluation du chemin auquel elles s'appliquent. Le résultat de cette
  étape est filtré pour inclure seulement les éléments qui satisfont la
  condition fournie. SQL/JSON définit une logique à trois valeurs, donc la
  condition peut valoir <literal>true</literal>, <literal>false</literal> ou
  <literal>unknown</literal>. La valeur <literal>unknown</literal> joue le
  même rôle que le <literal>NULL</literal> SQL et peut être testée avec le
  prédicat <literal>is unknown</literal>. Les étapes suivantes d'évaluation
  du chemin utilisent seulement les éléments pour lesquels l'expression de
  filtre renvoie <literal>true</literal>.
 </para>

 <para>
  Les fonctions et opérateurs pouvant être utilisés dans des expressions de
  filtre sont listés dans <xref
  linkend="functions-sqljson-filter-ex-table"/>. À l'intérieur d'une
  expression de filtre, la variable <literal>@</literal> dénote la valeur en
  cours de filtrage (un résultat de l'étape de chemin précédente). Vous
  pouvez écrire les opérateurs d'accesseurs après <literal>@</literal> pour
  récupérer les éléments du composant.
 </para>

 <para>
  Par exemple, supposez que vous vouliez récupérer toutes les valeurs de
  fréquence cardiaque supérieures à 130. Vous pouvez le faire en utilisant
  l'expression suivante&nbsp;:
  <programlisting>
$.track.segments[*].HR ? (@ &gt; 130)
  </programlisting>
 </para>

 <para>
  Pour obtenir les heures de début des segments ayant une telle valeur, vous
  devez filtrer les segments incompatiables avant de renvoyer les heures de
  début, donc l'expression de filtre est appliquée à l'étape précédente, et
  le chemin utilisé dans la condition est différent&nbsp;:

  <programlisting>
$.track.segments[*] ? (@.HR &gt; 130)."start time"
  </programlisting>
 </para>

 <para>
  Vous pouvez utiliser plusieurs expressions de filtre en séquence, si
  nécessaire. Par exemple, l'expression suivante sélectionne les heures de
  début de tous les segments qui contiennent des emplacements avec les bonnes
  coordonnées et les valeurs hautes de fréquence cardiaque&nbsp;:
  <programlisting>
$.track.segments[*] ? (@.location[1] &lt; 13.4) ? (@.HR &gt; 130)."start time"
  </programlisting>
 </para>

 <para>
  Il est aussi autorisé d'utiliser des expressions de filtre à différents
  niveaux de profondeur. L'exemple suivant filtre tout d'abord tous les
  segments par emplacement, puis renvoie les valeurs hautes de fréquence
  cardiaque sur ces segments, si disponibles&nbsp;:
  <programlisting>
$.track.segments[*] ? (@.location[1] &lt; 13.4).HR ? (@ &gt; 130)
  </programlisting>
 </para>

 <para>
  Vous pouvez aussi imbriquer les expressions de filtre&nbsp;:
  <programlisting>
$.track ? (exists(@.segments[*] ? (@.HR &gt; 130))).segments.size()
  </programlisting>
  Cette expression renvoie la taille de la trace si elle contient des
  segments avec des valeurs hautes de fréquence cardiaque ou, sinon, une
  séquence vide.
 </para>

 <para>
  L'implémentation <productname>PostgreSQL</productname> du langage de chemin
  SQL/JSON présente les différences suivantes sur le standard SQL/JSON&nbsp;:
 </para>

 <itemizedlist>
  <listitem>
   <para>
    Une expression de chemin peut être un prédicat booléen, bien que le
    standard SQL/JSON autorise les prédicats uniquement dans les filtres.
    Ceci est nécessaire pour l'implémentation de l'opérateur
    <literal>@@</literal>. Par exemple, l'expression <type>jsonpath</type>
    suivante est valide dans <productname>PostgreSQL</productname>&nbsp;:
    <programlisting>
$.track.segments[*].HR &lt; 70
    </programlisting>
   </para>
  </listitem>

  <listitem>
   <para>
    Il existe des différences mineures dans l'interprétation des motifs
    d'expression rationnelle utilisés dans les filtres
    <literal>like_regex</literal>, comme décrit dans <xref
    linkend="jsonpath-regular-expressions"/>.
   </para>
  </listitem>
 </itemizedlist>

 <sect3 id="strict-and-lax-modes">
  <title>Modes strict et permissif</title>
  <para>
   Quand vous requêtez des données JSON, l'expression de chemin pourrait ne
   pas correspondre à la structure de données JSON actuelle. Une tentative
   d'accéder à un membre inexistant d'un objet ou d'un élément d'un tableau
   résulterait en une erreur de structure. Les expressions de chemin
   SQL/JSON ont deux modes pour la gestion des erreurs de structure&nbsp;:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     lax (permissif, par défaut) &mdash; le moteur de chemin adapte
     implicitement la donnée requêtée au chemin spécifié. Toute erreur de
     structure restante est supprimée et convertie en des séquences SQL/JSON
     vides.
    </para>
   </listitem>
   <listitem>
    <para>
     strict &mdash; si une erreur de structure survient, une erreur est levée.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Le mode permissif facilite la correspondance de la structure d'un document
   JSON et celle d'une expression de chemin si la donnée JSON n'est pas
   conforme au schéma attendu. Si un opérande ne correspond pas aux demandes
   d'une opération particulière, il peut être automatiquement intégré à un
   tableau SQL/JSON ou déballé en convertissant ses éléments en une séquence
   SQL/JSON avant de réaliser cette opération. De plus, les opérateurs de
   comparaison déballent automatiquement leurs opérandes dans le mode
   permissif, donc vous pouvez directement comparer les tableaux SQL/JSON. Un
   tableau de taille 1 est considéré égal à son seul élément. Le déballage
   automatique n'est pas réaliser si&nbsp;:
   <itemizedlist>
    <listitem>
     <para>
      L'expression de chemin contient les méthodes <literal>type()</literal>
      ou <literal>size()</literal> qui renvoient respectivement le type et le
      nombre d'éléments dans le tableau.
     </para>
    </listitem>
    <listitem>
     <para>
      Les données JSON requêtées contiennent des tableaux imbriqués. Dans ce
      cas, seul le tableau externe est déballé alors que les tableaux
      internes restent inchangés. De ce fait, le déballage implicite peut
      seulement descendre d'un niveau à chaque étape d'évaluation du chemin.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Par exemple, lors du requêtage de données GPS ci-dessus, vous pouvez
   faire abstraction du fait qu'il stocke un tableau de segments en utilisant
   le mode permissif&nbsp;:
   <programlisting>
lax $.track.segments.location
   </programlisting>
  </para>

  <para>
   Dans le mode strict, le chemin spécifié doit correspondre exactement à la
   structure du document JSON requêté pour renvoyer un élément SQL/JSON, donc
   utiliser cette expression de chemin causera une erreur. Pour obtenir le
   même résultat que dans le mode permissif, vous devez explicitement
   déballer le tableau <literal>segments</literal>&nbsp;:
   <programlisting>
strict $.track.segments[*].location
   </programlisting>
  </para>

 </sect3>

 <sect3 id="functions-sqljson-path-operators">
  <title>Opérateurs et méthodes de chemin SQL/JSON</title>

  <para>
   <xref linkend="functions-sqljson-op-table"/> montre les opérateurs et
   méthodes disponibles pour <type>jsonpath</type>. Notez que, bien que les
   opérateurs et méthodes unaires puissent être appliqués à de nombreuses
   valeurs résultant d'une étape de chemin précédente, les opérateurs
   binaires (addition etc.) peuvent seulement être appliqués à des valeurs
   seules.
  </para>

  <table id="functions-sqljson-op-table">
   <title>Opérateurs et méthodes <type>jsonpath</type></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="func_table_entry"><para role="func_signature">
        Opérateur/Méthode
       </para>
       <para>
        Description
       </para>
       <para>
        Exemple(s)
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>+</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Addition
       </para>
       <para>
        <literal>jsonb_path_query('[2]', '$[0] + 3')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <literal>+</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Plus unaire (pas d'opération)&nbsp;; contrairement à l'addition, ceci
        peut itérer sur plusieurs valeurs
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": [2,3,4]}', '+ $.x')</literal>
        <returnvalue>[2, 3, 4]</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>-</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Soustraction
       </para>
       <para>
        <literal>jsonb_path_query('[2]', '7 - $[0]')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <literal>-</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Négation&nbsp;; contrairement à la soustraction, ceci peut itérer sur
        plusieurs valeurs
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": [2,3,4]}', '- $.x')</literal>
        <returnvalue>[-2, -3, -4]</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>*</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Multiplication
       </para>
       <para>
        <literal>jsonb_path_query('[4]', '2 * $[0]')</literal>
        <returnvalue>8</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>/</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Division
       </para>
       <para>
        <literal>jsonb_path_query('[8.5]', '$[0] / 2')</literal>
        <returnvalue>4.2500000000000000</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>%</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Modulo (reste)
       </para>
       <para>
        <literal>jsonb_path_query('[32]', '$[0] % 10')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>type()</literal>
        <returnvalue><replaceable>string</replaceable></returnvalue>
       </para>
       <para>
        Type de l'élément JSON (voir <function>json_typeof</function>)
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "2", {}]', '$[*].type()')</literal>
        <returnvalue>["number", "string", "object"]</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>size()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Taille de l'élément JSON (nombre d'éléments d'un tableau, ou 1 si ce
        n'est pas un tableau)
       </para>
       <para>
        <literal>jsonb_path_query('{"m": [11, 15]}', '$.m.size()')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>double()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Nombre flottant approximatif converti en nombre JSON ou en chaîne
       </para>
       <para>
        <literal>jsonb_path_query('{"len": "1.9"}', '$.len.double() * 2')</literal>
        <returnvalue>3.8</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>ceiling()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Entier le plus proche, plus grand ou égal au nombre donné
       </para>
       <para>
        <literal>jsonb_path_query('{"h": 1.3}', '$.h.ceiling()')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>floor()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Entier le plus proche, plus petit ou égal au nombre donné
       </para>
       <para>
        <literal>jsonb_path_query('{"h": 1.7}', '$.h.floor()')</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>abs()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Valeur absolue du nombre donné
       </para>
       <para>
        <literal>jsonb_path_query('{"z": -0.3}', '$.z.abs()')</literal>
        <returnvalue>0.3</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>.</literal> <literal>datetime()</literal>
        <returnvalue><replaceable>datetime_type</replaceable></returnvalue>
        (voir note)
       </para>
       <para>
        Valeur date/heure convertie en chaîne
       </para>
       <para>
        <literal>jsonb_path_query('["2015-8-1", "2015-08-12"]', '$[*] ? (@.datetime() &lt; "2015-08-2".datetime())')</literal>
        <returnvalue>"2015-8-1"</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>.</literal> <literal>datetime(<replaceable>template</replaceable>)</literal>
        <returnvalue><replaceable>datetime_type</replaceable></returnvalue>
        (voir note)
       </para>
       <para>
        Valeur date/heure convertie en une chaîne en utilisant le modèle
        <function>to_timestamp</function> indiqué
       </para>
       <para>
        <literal>jsonb_path_query_array('["12:30", "18:40"]', '$[*].datetime("HH24:MI")')</literal>
        <returnvalue>["12:30:00", "18:40:00"]</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>object</replaceable> <literal>.</literal> <literal>keyvalue()</literal>
        <returnvalue><replaceable>array</replaceable></returnvalue>
       </para>
       <para>
        Les paires clé-valeur de l'objet, représentées sous la forme d'un
        tableau d'objets contenant trois champs&nbsp;:
        <literal>"key"</literal>, <literal>"value"</literal> et
        <literal>"id"</literal>&nbsp;; <literal>"id"</literal> est un
        identifiant unique de l'objet auquel la paire clé-valeur appartient
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": "20", "y": 32}', '$.keyvalue()')</literal>
        <returnvalue>[{"id": 0, "key": "x", "value": "20"}, {"id": 0, "key": "y", "value": 32}]</returnvalue>
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    Le type de résultat des méthodes <literal>datetime()</literal> et
    <literal>datetime(<replaceable>template</replaceable>)</literal> peut
    être <type>date</type>, <type>timetz</type>, <type>time</type>,
    <type>timestamptz</type> ou <type>timestamp</type>. Les deux méthodes
    déterminent dynamiquement le type du résultat.
   </para>
   <para>
    La méthode <literal>datetime()</literal> trie en séquence pour faire
    correspondre sa chaîne en entrée aux formats ISO pour les types
    <type>date</type>, <type>timetz</type>, <type>time</type>,
    <type>timestamptz</type> et <type>timestamp</type>. Elle s'arrête au
    premier format correspondant et émet le type de données correspondant.
   </para>
   <para>
    La méthode <literal>datetime(<replaceable>template</replaceable>)</literal>
    détermine le type de résultat suivant les champs utilisés dans la chaîne
    modèle fournie.
   </para>
   <para>
    Les méthodes <literal>datetime()</literal> et
    <literal>datetime(<replaceable>template</replaceable>)</literal>
    utilisent les mêmes règles d'analyse que la fonction SQL
    <literal>to_timestamp</literal> (voir <xref
    linkend="functions-formatting"/>), avec trois exceptions. Tout d'abord,
    ces méthodes n'autorisent pas les motifs de modèle sans correspondance.
    Ensuite, seuls les séparateurs suivants sont autorisés dans la chaîne
    modèle&nbsp;: signe moins, point, barre oblique, virgule, apostrophe,
    point-virgule, deux-points et espace. Enfin, les séparateurs dans la
    chaîne modèle doivent correspondre exactement à la chaîne en entrée.
   </para>
   <para>
    Si différents types date/heure doivent être comparés, une conversion
    implicite est appliquée. Une valeur <type>date</type> peut être
    convertie en <type>timestamp</type> ou <type>timestamptz</type>, une
    valeur <type>timestamp</type> peut être convertie en
    <type>timestamptz</type>, et une valeur <type>time</type> en
    <type>timetz</type>. Néanmoins, toutes sauf la première de ces
    conversions dépendent du paramétrage actuel de <xref
    linkend="guc-timezone"/>, et de ce fait peuvent seulement être réalisées
    à travers les fonctions <type>jsonpath</type> sensibles au fuseau
    horaire.
   </para>
  </note>

  <para>
   <xref linkend="functions-sqljson-filter-ex-table"/> montre les éléments
   d'expression de filtre disponibles.
  </para>

  <table id="functions-sqljson-filter-ex-table">
   <title>Éléments d'expression de filtre <type>jsonpath</type></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="func_table_entry"><para role="func_signature">
        Prédicat/valeur
       </para>
       <para>
        Description
       </para>
       <para>
        Exemple(s)
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>==</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Comparaison d'égalité (ceci, et les autres opérateurs de comparaison,
        fonctionnent sur toutes les valeurs scalaires JSON)
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == 1)')</literal>
        <returnvalue>[1, 1]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == "a")')</literal>
        <returnvalue>["a"]</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>!=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;&gt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Comparaison de non égalité
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 1, 3]', '$[*] ? (@ != 1)')</literal>
        <returnvalue>[2, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;&gt; "b")')</literal>
        <returnvalue>["a", "c"]</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Comparaison inférieur
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &lt; 2)')</literal>
        <returnvalue>[1]</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Comparaison inférieur ou égal
       </para>
       <para>
        <literal>jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;= "b")')</literal>
        <returnvalue>["a", "b"]</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&gt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Comparaison supérieur
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt; 2)')</literal>
        <returnvalue>[3]</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&gt;=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Comparaison supérieur ou égal
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt;= 2)')</literal>
        <returnvalue>[2, 3]</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <literal>true</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Constante JSON <literal>true</literal>
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == true)')</literal>
        <returnvalue>{"name": "Chris", "parent": true}</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <literal>false</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Constante JSON <literal>false</literal>
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == false)')</literal>
        <returnvalue>{"name": "John", "parent": false}</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <literal>null</literal>
        <returnvalue><replaceable>value</replaceable></returnvalue>
       </para>
       <para>
        Constante JSON <literal>null</literal> (notez que, contrairement au
        SQL, la comparaison avec <literal>null</literal> fonctionne
        normalement)
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "Mary", "job": null}, {"name": "Michael", "job": "driver"}]', '$[*] ? (@.job == null) .name')</literal>
        <returnvalue>"Mary"</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>&amp;&amp;</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        AND booléen
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &gt; 1 &amp;&amp; @ &lt; 5)')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>||</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        OR booléen
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &lt; 1 || @ &gt; 5)')</literal>
        <returnvalue>7</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <literal>!</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        NOT booléen
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (!(@ &lt; 5))')</literal>
        <returnvalue>7</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>is unknown</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Teste si une condition booléenne est <literal>unknown</literal>.
       </para>
       <para>
        <literal>jsonb_path_query('[-1, 2, 7, "foo"]', '$[*] ? ((@ > 0) is unknown)')</literal>
        <returnvalue>"foo"</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>like_regex</literal> <replaceable>string</replaceable> <optional> <literal>flag</literal> <replaceable>string</replaceable> </optional>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Teste si le premier opérande correspond à l'expression rationnelle
        donnée par le deuxième opérande, optionnellement avec les
        modifications décrites par une chaîne avec les caractères de
        <literal>flag</literal> (voir <xref
        linkend="jsonpath-regular-expressions"/>).
       </para>
       <para>
        <literal>jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c")')</literal>
        <returnvalue>["abc", "abdacb"]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c" flag "i")')</literal>
        <returnvalue>["abc", "aBdC", "abdacb"]</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>starts with</literal> <replaceable>string</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Teste si le deuxième opérande est une sous-chaîne initiale du premier
        opérande.
       </para>
       <para>
        <literal>jsonb_path_query('["John Smith", "Mary Stone", "Bob Johnson"]', '$[*] ? (@ starts with "John")')</literal>
        <returnvalue>"John Smith"</returnvalue>
       </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <literal>exists</literal> <literal>(</literal> <replaceable>path_expression</replaceable> <literal>)</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Teste si une expression de chemin correspond à au moins un élément
        SQL/JSON. Renvoie <literal>unknown</literal> si l'expression de chemin
        retourne une erreur&nbsp;; le deuxième exemple utilise ceci pour
        éviter une erreur de clé inexistante dans le mode strict.
       </para>
       <para>
        <literal>jsonb_path_query('{"x": [1, 2], "y": [2, 4]}', 'strict $.* ? (exists (@ ? (@[*] &gt; 2)))')</literal>
        <returnvalue>[2, 4]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('{"value": 41}', 'strict $ ? (exists (@.name)) .name')</literal>
        <returnvalue>[]</returnvalue>
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect3>

 <sect3 id="jsonpath-regular-expressions">
  <title>Expressions rationnelles SQL/JSON</title>

  <indexterm zone="jsonpath-regular-expressions">
   <primary><literal>LIKE_REGEX</literal></primary>
   <secondary>en SQL/JSON</secondary>
  </indexterm>

  <para>
   Les expressions de chemin SQL/JSON permettent la correspondance de texte
   selon une expression rationnelle avec le filtre
   <literal>like_regex</literal>. Par exemple, la requête de chemin SQL/JSON
   suivante correspondrait, sans sensibilité à la casse, à toutes les
   chaînes d'un tableau commençant avec une voyelle anglaise&nbsp;:
   <programlisting>
$[*] ? (@ like_regex "^[aeiou]" flag "i")
   </programlisting>
  </para>

  <para>
   La chaîne optionnelle <literal>flag</literal> pourrait inclure un ou
   plusieurs caractères&nbsp;: <literal>i</literal> pour une recherche
   insensible à la casse, <literal>m</literal> pour autoriser
   <literal>^</literal> et <literal>$</literal> à correspondre aux nouvelles
   lignes, <literal>s</literal> pour autoriser <literal>.</literal> à
   correspondre à une nouvelle ligne, et <literal>q</literal> pour englober
   le motif complet (réduisant le comportement à une simple correspondance
   de sous-chaîne).
  </para>

  <para>
   Le standard SQL/JSON emprunte sa définition d'expressions rationnelles de
   l'opérateur <literal>LIKE_REGEX</literal> qui, à son tour, utilise le
   standard XQuery. PostgreSQL n'accepte pas actuellement l'opérateur
   <literal>LIKE_REGEX</literal>. De ce fait, le filtre
   <literal>like_regex</literal> est implémenté en utilisant le moteur
   d'expression rationnelle POSIX décrit dans <xref
   linkend="functions-posix-regexp"/>. Ceci amène différentes variations
   mineures du comportement du standard SQL/JSON, listées dans <xref
   linkend="posix-vs-xquery"/>. Notez, néanmoins, que les incompatibilités
   au niveau des lettres du drapeau décrites ici ne s'appliquent pas à
   SQL/JSON, car elles traduisent les lettres drapeau de XQuery pour
   correspondre à ce que le moteur POSIX attend.
  </para>

  <para>
   Gardez en tête que l'argument motif de <literal>like_regex</literal> est
   une chaîne littérale de chemin JSON, écrite suivant les règles données
   dans <xref linkend="datatype-jsonpath"/>. Ceci signifie en particulier
   que tout antislash utilisé dans l'expression rationnelle doit être
   doublé. Par exemple, pour établir une correspondance aux chaînes ne
   contenant que des chiffres&nbsp;:
   <programlisting>
$ ? (@ like_regex "^\\d+$")
   </programlisting>
  </para>
 </sect3>
</sect2>
</sect1>

<sect1 id="functions-sequence">
<title>Fonctions de manipulation de séquence</title>

<indexterm>
 <primary>séquence</primary>
</indexterm>

<para>
 Cette section décrit les fonctions pour opérer sur des <firstterm>objets
  séquence</firstterm>, aussi appelés des générateurs de séquence ou plus
 simplement séquences. Les objets séquence sont des tables spéciales à une
 ligne créées avec l'ordre <xref linkend="sql-createsequence"/>. Les objets
 séquence sont habituellement utilisés pour générer des identifiants uniques
 pour les lignes d'une table. Les fonctions pour séquence, listées dans
 <xref linkend="functions-sequence-table"/>, fournissent des méthodes
 simples, sûres pour la concurrence d'utilisateur, permettent d'obtenir des
 valeurs successives de séquence à partir d'objets séquence.
</para>

<table id="functions-sequence-table">
 <title>Fonctions pour séquence</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>nextval</primary>
      </indexterm>
      <function>nextval</function> ( <type>regclass</type> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para>
      Avance l'objet séquence à sa prochaine valeur et renvoie cette valeur.
      Ceci est fait de façon atomique&nbsp;: même si plusieurs sessions
      exécutent <function>nextval</function> en même temps, chacune recevra
      une valeur distincte de séquence. Si l'objet séquence a été créé avec
      les paramètres par défaut, les appels successifs à
      <function>nextval</function> renverront les valeurs successives en
      partant de 1. D'autres comportements peuvent être obtenus en utilisant
      les paramètres appropriés dans la commande <xref
      linkend="sql-createsequence"/>.
     </para>
     <para>
      Cette fonction nécessite le droit <literal>USAGE</literal> ou
      <literal>UPDATE</literal> sur la séquence.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>setval</primary>
      </indexterm>
      <function>setval</function> ( <type>regclass</type>, <type>bigint</type> <optional>, <type>boolean</type> </optional> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para>
      Configure la valeur actuelle de l'objet séquence, et en option son
      drapeau <literal>is_called</literal>. La syntaxe à deux paramètres
      configure le champ <literal>last_value</literal> à la valeur indiquée
      et configure le champ <literal>is_called</literal> à la valeur
      <literal>true</literal>, signifiant que le prochain appel à
      <function>nextval</function> avancera la séquence avant de renvoyer la
      valeur. La valeur qui sera alors rapportée par
      <function>currval</function> est aussi configurée à la valeur
      indiquée. Dans la syntaxe à trois paramètres,
      <literal>is_called</literal> peut être configuré à
      <literal>true</literal> ou à <literal>false</literal>.
      <literal>true</literal> a le même effet que dans la syntaxe à deux
      paramètres. S'il est configuré à <literal>false</literal>, le prochain
      appel à <function>nextval</function> renverra exactement la valeur
      indiqué, et l'avancement de la séquence commence avec le
      <function>nextval</function> suivant. De plus, la valeur renvoyée par
      <function>currval</function> n'est pas modifiée dans ce cas. Par
      exemple,
      <programlisting>
SELECT setval('myseq', 42);           <lineannotation>Le prochain <function>nextval</function> renverra 43</lineannotation>
SELECT setval('myseq', 42, true);     <lineannotation>Identique</lineannotation>
SELECT setval('myseq', 42, false);    <lineannotation>Le prochain <function>nextval</function> renverra 42</lineannotation>
      </programlisting>
      Le résultat renvoyé par <function>setval</function> est simplement la
      valeur de son deuxième argument.
     </para>
     <para>
      Cette fonction nécessite le droit <literal>UPDATE</literal> sur la
      séquence.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>currval</primary>
      </indexterm>
      <function>currval</function> ( <type>regclass</type> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para>
      Renvoie la valeur la plus récemment obtenue par
      <function>nextval</function> pour cette séquence dans le session
      courante. (Une erreur est renvoyée si <function>nextval</function> n'a
      jamais été appelé par cette séquence dans cette session.) Comme cela
      renvoie une valeur locale à la session, la réponse est prévisible que
      d'autres sessions aient <function>nextval</function> ou pas depuis que
      la session courant l'a fait.
     </para>
     <para>
      Cette fonction nécessite le droit <literal>USAGE</literal> ou le droit
      <literal>SELECT</literal> sur la séquence.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>lastval</primary>
      </indexterm>
      <function>lastval</function> ()
      <returnvalue>bigint</returnvalue>
     </para>
     <para>
      Renvoie la valeur la plus récemment renvoyée par la fonction
      <function>nextval</function> dans la session courante. Cette fonction
      est identique à <function>currval</function>, sauf qu'au lieu de
      prendre le nom de la séquence en argument, elle se réfère à la
      dernière séquence utilisée avec <function>nextval</function> dans la
      session courante. Une erreur est renvoyé si
      <function>lastval</function> a été appelée alors que
      <function>nextval</function> ne l'a pas été dans la session courante.
     </para>
     <para>
      Cette fonction nécessite le droit <literal>USAGE</literal> ou le droit
      <literal>SELECT</literal> sur la dernière séquence utilisée.
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

<caution>
 <para>
  Pour éviter que le blocage de transactions concurrentes cherchant à
  obtenir des nombres de la même séquence, une opération
  <function>nextval</function> n'est jamais annulable&nbsp;; autrement dit,
  une fois qu'une valeur a été récupérée, elle est considérée utilisée et ne
  sera jamais jamais renvoyée. Ceci est vrai même si la transaction
  englobante est annulée plus tard ou si la requête appelante n'utilise pas
  la valeur au final. Par exemple, un <command>INSERT</command> avec une
  clause <literal>ON CONFLICT</literal> calculera la ligne à insérer, en
  incluant les appels nécessaires à <function>nextval</function>, avant de
  détecter un conflit qui l'obligerait à suivre la règle <literal>ON
   CONFLICT</literal> à la place. De tels cas laisseront des
  <quote>trous</quote> inutilisés dans la séquence de valeurs assignées. De
  ce fait, les objets de séquence <productname>PostgreSQL</productname>
  <emphasis>ne peuvent pas être utilisé pour obtenir des séquences
   <quote>sans trou</quote></emphasis>.
 </para>

 <para>
  De la même façon, aucun changement d'état de la séquence réalisé par
  <function>setval</function> n'est annulé si la transaction est annulée.
 </para>
</caution>

<para>
 La séquence à traiter par une fonction de séquence est indiquée par un
 argument <type>regclass</type>, qui est simplement l'OID de la séquence
 dans le catalogue système <structname>pg_class</structname>. Vous n'avez
 pas besoin de rechercher l'OID manuellement car le convertisseur en entrée
 du type de donnée <type>regclass</type> fera ce travail pour vous? Écrivez
 simplement le nom de la séquence entre guillemets simples pour qu'il
 ressemble à une constante littérale. POur des raisons de compatibilité avec
 la gestion des noms <acronym>SQL</acronym> habituels, la chaîne sera
 convertie en minuscule, sauf si elle contient des guillemets doubles autour
 du nom de la séquence. De ce fait&nbsp;:
 <programlisting>
nextval('foo')      <lineannotation>opère sur la séquence <literal>foo</literal></lineannotation>
nextval('FOO')      <lineannotation>opère sur la séquence <literal>foo</literal></lineannotation>
nextval('"Foo"')    <lineannotation>opère sur la séquence <literal>Foo</literal></lineannotation>
 </programlisting>
 Le nom de la séquence peut être qualifié du nom du schéma si nécessaire&nbsp;:
 <programlisting>
nextval('myschema.foo')     <lineannotation>opère sur <literal>myschema.foo</literal></lineannotation>
nextval('"myschema".foo')   <lineannotation>identique à ci-dessus</lineannotation>
nextval('foo')              <lineannotation>recherche <literal>foo</literal> dans le chemin de recherche</lineannotation>
 </programlisting>
 Voir <xref linkend="datatype-oid"/> pour plus d'informations sur
 <type>regclass</type>.
</para>

<note>
 <para>
  Avant <productname>PostgreSQL</productname> 8.1, les arguments des
  fonctions séquence étaient de type <type>text</type>, et non pas
  <type>regclass</type>, et la conversion décrite ci-dessus partant d'une
  chaîne de texte pour aboutir à une valeur OID ne surviendrait qu'au moment
  de l'exécution pour chaque appel. Pour des raisons de compatibilité, ce
  fonctionnement existe toujours, mais en interne, il est maintenant géré
  comme une conversion implicite de <type>text</type> vers
  <type>regclass</type> avant que la fonction ne soit exécutée.
 </para>

 <para>
  Quand vous écrivez l'argument d'une fonction séquence comme une chaîne de
  caractères sans fioritures, il devient une constante de type
  <type>regclass</type>. Comme il s'agit juste d'un OID, il tracer la
  séquence identifiée à l'origine malgré un renommage ultérieur, une
  réaffectation de schéma, etc. Le comportement de <quote>référence en
   avance</quote> est généralement désirable pour les références de séquence
  dans les valeurs par défaut des colonnes ou dans les vues. Cependant,
  quelques fois, vous pourriez vouloir du <quote>référence tardive</quote>
  où la référence de la séquence est résolue à l'exécution. Pour obtenir ce
  comportement de référence tardive, forcez la constante à être stockée sous
  le type <type>text</type> au lieu de <type>regclass</type>&nbsp;:
  <programlisting>
nextval('foo'::text)      <lineannotation><literal>foo</literal> is looked up at runtime</lineannotation>
  </programlisting>
  Notez que la référence tardive était le seul comportement supporté pour
  les versions de <productname>PostgreSQL</productname> antérieures à la
  8.1, donc vous pourriez avoir besoin de préserver cette sémantique dans
  les anciennes applications.
 </para>

 <para>
  Bien sûr, l'argument d'une fonction séquence peut être une expression
  ainsi qu'une constante. S'il s'agit une expression de type texte, alors la
  conversion implicite résultera en une recherche lors de l'exécution.
 </para>
</note>

</sect1>


<sect1 id="functions-conditional">
<title>Expressions conditionnelles</title>

<indexterm>
 <primary>CASE</primary>
</indexterm>

<indexterm>
 <primary>expression conditionnelle</primary>
</indexterm>

<para>
 Cette section décrit les expressions conditionnelles compatibles
 <acronym>SQL</acronym> disponibles dans
 <productname>PostgreSQL</productname>.
</para>

<tip>
 <para>
  Si vos besoins dépassent les possibilités de ces expressions
  conditionnelles, il faudrait considérer l'écriture d'une fonction serveur
  dans un langage de programmation plus expressif.
 </para>
</tip>

<note>
 <para>
  Bien que <token>COALESCE</token>, <token>GREATEST</token> et
  <token>LEAST</token> sont syntaxiquement similaires aux fonctions, ce ne
  sont pas des fonctions ordinaires et, de ce fait, ne peuvent pas être
  utilisées avec des arguments de tableau <token>VARIADIC</token>.
 </para>
</note>

<sect2 id="functions-case">
 <title><literal>CASE</literal></title>

 <para>
  L'expression <acronym>SQL</acronym> <token>CASE</token> est une expression
  conditionnelle générique, similaire à des instructions if/else dans les
  autres langages de programmation&nbsp;:

  <synopsis>
CASE WHEN <replaceable>condition</replaceable> THEN <replaceable>result</replaceable>
     <optional>WHEN ...</optional>
     <optional>ELSE <replaceable>result</replaceable></optional>
END
  </synopsis>

  Les clauses <token>CASE</token> peuvent être utilisées partout où une
  expression est valide. Chaque <replaceable>condition</replaceable> est une
  expression qui renvoie un résultat <type>boolean</type>. Si le résultat de
  la condition est true, la valeur de l'expression <token>CASE</token> est le résultat
  <replaceable>result</replaceable> qui suit la condition, et le reste de l'expression
  <token>CASE</token> n'est pas traité. Si le résultat de la condition ne vaut pas
  true, toutes les clauses <token>WHEN</token> suivants sont examinées de la même
  manière. Si aucun <token>WHEN</token>
  <replaceable>condition</replaceable> ne renvoie true, la valeur de l'expression
  <token>CASE</token> est le <replaceable>result</replaceable> de la clause
  <token>ELSE</token>. S'il n'y a pas de clause <token>ELSE</token> et qu'aucune
  condition ne vaut true, le résultat est NULL.
 </para>

 <para>
  An example:
  <screen>
SELECT * FROM test;

 a
---
 1
 2
 3


SELECT a,
       CASE WHEN a=1 THEN 'one'
            WHEN a=2 THEN 'two'
            ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
  </screen>
 </para>

 <para>
  Les types de données de toutes les expressions <replaceable>result</replaceable>
  doivent être convertibles en un seul type de sortie. Voir
  <xref linkend="typeconv-union-case"/> pour plus de détails.
 </para>

 <para>
  Il existe une forme <quote>simple</quote> d'expression <token>CASE</token>
  qui est une variante de la forme générale ci-dessus&nbsp;:

  <synopsis>
CASE <replaceable>expression</replaceable>
    WHEN <replaceable>value</replaceable> THEN <replaceable>result</replaceable>
    <optional>WHEN ...</optional>
    <optional>ELSE <replaceable>result</replaceable></optional>
END
  </synopsis>

  La première <replaceable>expression</replaceable> est calculée, puis
  comparée à chacune des expressions <replaceable>value</replaceable> dans
  les clauses <token>WHEN</token> jusqu'à ce qu'une valeur égale soit
  trouvée. Si aucune égalité n'est trouvée, l'expression
  <replaceable>result</replaceable> de la clause <token>ELSE</token> (ou une
  valeur NULL) est renvoyée. Ceci est similaire à l'instruction
  <function>switch</function> en C.
 </para>

 <para>
  L'exemple ci-dessus peut être écrit en utilisant la syntaxe simple
  <token>CASE</token>&nbsp;:
  <screen>
SELECT a,
       CASE a WHEN 1 THEN 'one'
              WHEN 2 THEN 'two'
              ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
  </screen>
 </para>

 <para>
  Une expression <token>CASE</token> n'évalue pas les sous-expressions qui
  ne sont pas nécessaires pour déterminer le résultat. Par exemple, voici
  une façon possible d'éviter une erreur de division par zéro&nbsp;:
  <programlisting>
SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;
  </programlisting>
 </para>

 <note>
  <para>
   Comme décrit dans <xref linkend="syntax-express-eval"/>, il existe
   différentes situations pour lesquelles les sous-expressions d'une
   expression sont évaluées à différents moments, donc le principe pour
   lequel <quote><token>CASE</token> évalue seulement les sous-expressions
    nécessaires</quote> n'est pas sûr. Par exemple, une sous-expression
   constante <literal>1/0</literal> pourrait donner une erreur de division
   par zéro lors de l'optimisation de la requête, même si elle est dans une
   partie du <token>CASE</token> qui n'aurait pas été exécutée au moment de
   l'exécution.
  </para>
 </note>
</sect2>

<sect2 id="functions-coalesce-nvl-ifnull">
 <title><literal>COALESCE</literal></title>

 <indexterm>
  <primary>COALESCE</primary>
 </indexterm>

 <indexterm>
  <primary>NVL</primary>
 </indexterm>

 <indexterm>
  <primary>IFNULL</primary>
 </indexterm>

 <synopsis>
<function>COALESCE</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
 </synopsis>

 <para>
  La fonction <function>COALESCE</function> renvoie le premier de ses
  arguments non NULL. NULL est renvoyé seulement si tous les arguments sont
  NULL. Elle est souvent utilisée pour substituer une valeur par défaut pour
  les valeurs NULL quand les données sont récupérées pour affichage. Par
  exemple&nbsp;:
  <programlisting>
SELECT COALESCE(description, short_description, '(none)') ...
  </programlisting>
  Ceci renvoie <varname>description</varname> si ce champ n'est pas NULL,
  sinon <varname>short_description</varname> si ce champ n'est pas NULL, et
  sinon <literal>(none)</literal>.
 </para>

 <para>
  Les arguments doivent tous être convertible vers un type de données
  commun, qui* sera le type du résultat (voir <xref
  linkend="typeconv-union-case"/> pour les détails).
 </para>

 <para>
  Comme une expression <token>CASE</token>, <function>COALESCE</function>
  évalue seulement les arguments qui sont nécessaires pour déterminer le
  résultat&nbsp;; c'est-à-dire les arguments à droite du premier argument
  non NULL ne sont pas évalués. Cette fonction du standard SQL fournit des
  possibilités similaires à <function>NVL</function> et
  <function>IFNULL</function>, qui sont utilisées dans d'autres systèmes de
  bases de données.
 </para>
</sect2>

<sect2 id="functions-nullif">
 <title><literal>NULLIF</literal></title>

 <indexterm>
  <primary>NULLIF</primary>
 </indexterm>

 <synopsis>
<function>NULLIF</function>(<replaceable>value1</replaceable>, <replaceable>value2</replaceable>)
 </synopsis>

 <para>
  La fonction <function>NULLIF</function> renvoie une valeur NULL si
  <replaceable>value1</replaceable> est égal à
  <replaceable>value2</replaceable>&nbsp;; sinon, elle renvoie
  <replaceable>value1</replaceable>. Elle peut être utilisée pour réaliser
  l'opération inverse de l'exemple <function>COALESCE</function> donné
  ci-dessus&nbsp;:
  <programlisting>
SELECT NULLIF(value, '(none)') ...
  </programlisting>
  Dans cet exemple, si <literal>value</literal> vaut
  <literal>(none)</literal>, NULL est renvoyé, sinon la valeur de
  <literal>value</literal> est renvoyée.
 </para>

 <para>
  Les deux arguments doit être de types comparables. Pour être spécifique,
  ils sont comparés exactement comme si vous aviez écrit
  <literal><replaceable>value1</replaceable>
   = <replaceable>value2</replaceable></literal>, donc il doit y avoir un
  opérateur <literal>=</literal> convenable de disponible.
 </para>

 <para>
  Le résultat a le même type que le premier argument &mdash; mais il existe
  une subtilité. Ce qui est réellement renvoyé est le premier argument de
  l'opérateur <literal>=</literal> impliqué et, dans certains cas, aura été
  promu pour correspondre au type du deuxième argument. Par exemple,
  <literal>NULLIF(1, 2.2)</literal> renvoie <type>numeric</type> parce qu'il
  n'y a pas d'opérateur <type>integer</type> <literal>=</literal>
  <type>numeric</type>, seulement un <type>numeric</type>
  <literal>=</literal> <type>numeric</type>.
 </para>

</sect2>

<sect2 id="functions-greatest-least">
 <title><literal>GREATEST</literal> et <literal>LEAST</literal></title>

 <indexterm>
  <primary>GREATEST</primary>
 </indexterm>
 <indexterm>
  <primary>LEAST</primary>
 </indexterm>

 <synopsis>
<function>GREATEST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
 </synopsis>
 <synopsis>
<function>LEAST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
 </synopsis>

 <para>
  Les fonctions <function>GREATEST</function> et <function>LEAST</function>
  sélectionnent la valeur la plus grande ou la plus petite d'une liste
  d'expressions. Les expressions doivent toutes être convertibles en un
  type de donnée commun, qui sera le type du résultat (voir <xref
  linkend="typeconv-union-case"/> pour les détails). Les valeurs NULL de la
  liste sont ignorées. Le résultat sera NULL seulement si toutes les
  expressions sont évaluées à NULL.
 </para>

 <para>
  Notez que <function>GREATEST</function> and <function>LEAST</function> ne
  font pas partie du standard SQL mais sont une extension courante.
  Certaines autres bases de données les font renvoyer NULL si un argument
  est NULL, plutôt que quand toutes sont NULL.
 </para>
</sect2>
</sect1>

<sect1 id="functions-array">
<title>Fonctions et opérateurs tableau</title>

<para>
 <xref linkend="array-operators-table"/> montre les opérateurs spécialisés
 disponibles pour les types tableau. En plus de ces derniers, les opérateurs
 habituels de comparaison montrés dans <xref
 linkend="functions-comparison-op-table"/> sont disponibles pour les
 tableaux. Les opérateurs de comparaison comparent le contenu des tableaux
 éléments par éléments, en utilisant la fonction de comparaison B-tree par
 défaut pour le type de données de l'élément, et trient en se basant sur la
 première différence rencontrée. Dans les tableaux multi-dimensionnels, les
 éléments sont visités dans l'ordre des lignes (le dernier indice varie plus
 rapidement). Si les contenus de deux tableaux sont identiques mais que leur
 dimension est différente, la première différence dans l'information de
 dimension détermine l'ordre de tri. (Ceci change des versions de
 <productname>PostgreSQL</productname> antérieures à la 8.2&nbsp;: les
 anciennes versions penseront que deux tableaux de même contenu sont
 identiques, même si le nombre de dimensions ou l'étendu des indices est
 différent.)
</para>

<table id="array-operators-table">
 <title>Opérateurs de tableau</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Opérateur
     </para>
     <para>
      Description
     </para>
     <para>
      Exemple(s)
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyarray</type> <literal>@&gt;</literal> <type>anyarray</type>
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Est-ce que le premier tableau contient le second, autrement dit,
      est-ce que chaque élément apparaissant dans le deuxième tableau est
      égal à un élément du premier tableau&nbsp;? (les duplicats ne sont pas
      traités spécialement, donc <literal>ARRAY[1]</literal> et
      <literal>ARRAY[1,1]</literal> sont tous les deux considérés comme
      contenant l'autre.)
     </para>
     <para>
      <literal>ARRAY[1,4,3] @&gt; ARRAY[3,1,3]</literal>
      <returnvalue>t</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyarray</type> <literal>&lt;@</literal> <type>anyarray</type>
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Est-ce que le premier tableau est contenu par le second&nbsp;?
     </para>
     <para>
      <literal>ARRAY[2,2,7] &lt;@ ARRAY[1,7,4,2,6]</literal>
      <returnvalue>t</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyarray</type> <literal>&amp;&amp;</literal> <type>anyarray</type>
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Est-ce que les tableaux se surchargent, autrement dit ont des éléments
      en commun&nbsp;?
     </para>
     <para>
      <literal>ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]</literal>
      <returnvalue>t</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyarray</type> <literal>||</literal> <type>anyarray</type>
      <returnvalue>anyarray</returnvalue>
     </para>
     <para>
      Concatène les deux tableaux. Concaténer un tableau NULL ou un tableau
      vide est une opération vide&nbsp;; sinon les tableaux doivent avoir le
      même nombre de dimensions (comme illustré dans le premier exemple)
      ou différer de 1 dans le nombre de dimensions (comme illustré dans le
      second exemple).
     </para>
     <para>
      <literal>ARRAY[1,2,3] || ARRAY[4,5,6,7]</literal>
      <returnvalue>{1,2,3,4,5,6,7}</returnvalue>
     </para>
     <para>
      <literal>ARRAY[1,2,3] || ARRAY[[4,5,6],[7,8,9]]</literal>
      <returnvalue>{{1,2,3},{4,5,6},{7,8,9}}</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyelement</type> <literal>||</literal> <type>anyarray</type>
      <returnvalue>anyarray</returnvalue>
     </para>
     <para>
      Concatène un élément au début d'un tableau (qui doit être vide ou à une
      dimension).
     </para>
     <para>
      <literal>3 || ARRAY[4,5,6]</literal>
      <returnvalue>{3,4,5,6}</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyarray</type> <literal>||</literal> <type>anyelement</type>
      <returnvalue>anyarray</returnvalue>
     </para>
     <para>
      Concatène un élément à la fin d'un tableau (qui doit être vide ou à une
      dimension).
     </para>
     <para>
      <literal>ARRAY[4,5,6] || 7</literal>
      <returnvalue>{4,5,6,7}</returnvalue>
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

<para>
 Voir <xref linkend="arrays"/> pour plus de détails sur le comportement
 des opérateurs pour tableau. Voir <xref linkend="indexes-types"/> pour plus
 de détails sur les opérateurs supportant des opérations indexées.
</para>

<para>
 <xref linkend="array-functions-table"/> montre les fonctions disponibles
 pour utilisation avec des types tableau. Voir <xref linkend="arrays"/>
 pour plus d'informations et d'exemples sur l'utilisation de ces fonctions.
</para>

<table id="array-functions-table">
 <title>Fonctions tableau</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para>
     <para>
      Exemple(s)
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>array_append</primary>
      </indexterm>
      <function>array_append</function> ( <type>anyarray</type>, <type>anyelement</type> )
      <returnvalue>anyarray</returnvalue>
     </para>
     <para>
      Ajoute un élément à la fin d'un tableau (identique à l'opérateur
      <type>anyarray</type> <literal>||</literal> <type>anyelement</type>).
     </para>
     <para>
      <literal>array_append(ARRAY[1,2], 3)</literal>
      <returnvalue>{1,2,3}</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>array_cat</primary>
      </indexterm>
      <function>array_cat</function> ( <type>anyarray</type>, <type>anyarray</type> )
      <returnvalue>anyarray</returnvalue>
     </para>
     <para>
      Concatène deux tableaux (identique à l'opérateur
      <type>anyarray</type> <literal>||</literal> <type>anyarray</type>).
     </para>
     <para>
      <literal>array_cat(ARRAY[1,2,3], ARRAY[4,5])</literal>
      <returnvalue>{1,2,3,4,5}</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>array_dims</primary>
      </indexterm>
      <function>array_dims</function> ( <type>anyarray</type> )
      <returnvalue>text</returnvalue>
     </para>
     <para>
      Renvoie une représentation textuelle des dimensions du tableau.
     </para>
     <para>
      <literal>array_dims(ARRAY[[1,2,3], [4,5,6]])</literal>
      <returnvalue>[1:2][1:3]</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>array_fill</primary>
      </indexterm>
      <function>array_fill</function> ( <type>anyelement</type>, <type>integer[]</type>
      <optional>, <type>integer[]</type> </optional> )
      <returnvalue>anyarray</returnvalue>
     </para>
     <para>
      Renvoie un tableau rempli de copies de la valeur donnée, ayant les
      dimensions de longueurs spécifiés par le deuxième argument. Le
      troisième argument optionnel fournit des valeurs de limite basse pour
      chaque dimension (qui vaut par défaut <literal>1</literal>).
     </para>
     <para>
      <literal>array_fill(11, ARRAY[2,3])</literal>
      <returnvalue>{{11,11,11},{11,11,11}}</returnvalue>
     </para>
     <para>
      <literal>array_fill(7, ARRAY[3], ARRAY[2])</literal>
      <returnvalue>[2:4]={7,7,7}</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>array_length</primary>
      </indexterm>
      <function>array_length</function> ( <type>anyarray</type>, <type>integer</type> )
      <returnvalue>integer</returnvalue>
     </para>
     <para>
      Renvoie la longueur de la dimension réclamée du tableau.
     </para>
     <para>
      <literal>array_length(array[1,2,3], 1)</literal>
      <returnvalue>3</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>array_lower</primary>
      </indexterm>
      <function>array_lower</function> ( <type>anyarray</type>, <type>integer</type> )
      <returnvalue>integer</returnvalue>
     </para>
     <para>
      Renvoie la limite basse de la dimension réclamée du tableau.
     </para>
     <para>
      <literal>array_lower('[0:2]={1,2,3}'::integer[], 1)</literal>
      <returnvalue>0</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>array_ndims</primary>
      </indexterm>
      <function>array_ndims</function> ( <type>anyarray</type> )
      <returnvalue>integer</returnvalue>
     </para>
     <para>
      Renvoie le nombre de dimensions du tableau.
     </para>
     <para>
      <literal>array_ndims(ARRAY[[1,2,3], [4,5,6]])</literal>
      <returnvalue>2</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>array_position</primary>
      </indexterm>
      <function>array_position</function> ( <type>anyarray</type>, <type>anyelement</type> <optional>, <type>integer</type> </optional> )
      <returnvalue>integer</returnvalue>
     </para>
     <para>
      Renvoie l'indice de la première occurence du second argument dans le
      tableau, ou <literal>NULL</literal> s'il n'est pas présent. Si le
      troisième argument est donné, la recherche commence à cet indice. Le
      tableau doit être d'une dimension. Les comparaisons se font en
      utilisant les sémantiques de <literal>IS NOT DISTINCT FROM</literal>,
      donc il est possible de rechercher un <literal>NULL</literal>.
     </para>
     <para>
      <literal>array_position(ARRAY['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'], 'mon')</literal>
      <returnvalue>2</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>array_positions</primary>
      </indexterm>
      <function>array_positions</function> ( <type>anyarray</type>, <type>anyelement</type> )
      <returnvalue>integer[]</returnvalue>
     </para>
     <para>
      Renvoie un tableau des indices de toutes les occurrences du deuxième
      argument dans le tableau donné comme premier argument. Le tableau doit
      être à une dimension. Les comparaisons sont effectuées en utilisant
      les sémantiques de <literal>IS NOT DISTINCT FROM</literal>, il est
      donc possible de rechercher un <literal>NULL</literal>.
      <literal>NULL</literal> n'est renvoyé que si le tableau vaut
      <literal>NULL</literal>&nbsp;; si la valeur n'est pas trouvée dans le
      tableau, un tableau vide est renvoyé.
     </para>
     <para>
      <literal>array_positions(ARRAY['A','A','B','A'], 'A')</literal>
      <returnvalue>{1,2,4}</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>array_prepend</primary>
      </indexterm>
      <function>array_prepend</function> ( <type>anyelement</type>, <type>anyarray</type> )
      <returnvalue>anyarray</returnvalue>
     </para>
     <para>
      Ajoute un élément au début d'un tableau (identique à l'opérateur
      <type>anyelement</type> <literal>||</literal> <type>anyarray</type>).
     </para>
     <para>
      <literal>array_prepend(1, ARRAY[2,3])</literal>
      <returnvalue>{1,2,3}</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>array_remove</primary>
      </indexterm>
      <function>array_remove</function> ( <type>anyarray</type>, <type>anyelement</type> )
      <returnvalue>anyarray</returnvalue>
     </para>
     <para>
      Supprime tous les éléments identiques à la valeur donnée à partir du
      tableau. Le tableau doit être à une dimension. Les comparaisons sont
      faites en utilisant les sémantiques de <literal>IS NOT DISTINCT
       FROM</literal>, dont il est possible de supprimer un
      <literal>NULL</literal>.
     </para>
     <para>
      <literal>array_remove(ARRAY[1,2,3,2], 2)</literal>
      <returnvalue>{1,3}</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>array_replace</primary>
      </indexterm>
      <function>array_replace</function> ( <type>anyarray</type>, <type>anyelement</type>, <type>anyelement</type> )
      <returnvalue>anyarray</returnvalue>
     </para>
     <para>
      Remplace chaque élément de tableau égal au second argument avec le
      troisième argument.
     </para>
     <para>
      <literal>array_replace(ARRAY[1,2,5,4], 5, 3)</literal>
      <returnvalue>{1,2,3,4}</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>array_to_string</primary>
      </indexterm>
      <function>array_to_string</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
      <returnvalue>text</returnvalue>
     </para>
     <para>
      Convertit chaque élément de tableau en sa représentation textuelle, et
      les concatène en les séparant par la chaîne <parameter>delimiter</parameter>.
      Si <parameter>null_string</parameter> est indiqué et ne vaut pas
      <literal>NULL</literal>, alors les entrées de tableau <literal>NULL</literal>
      sont représentées par cette chaîne&nbsp;; sinon elles sont omises.
     </para>
     <para>
      <literal>array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')</literal>
      <returnvalue>1,2,3,*,5</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>array_upper</primary>
      </indexterm>
      <function>array_upper</function> ( <type>anyarray</type>, <type>integer</type> )
      <returnvalue>integer</returnvalue>
     </para>
     <para>
      Renvoie la limite haute de la dimension demandée du tableau.
     </para>
     <para>
      <literal>array_upper(ARRAY[1,8,3,7], 1)</literal>
      <returnvalue>4</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>cardinality</primary>
      </indexterm>
      <function>cardinality</function> ( <type>anyarray</type> )
      <returnvalue>integer</returnvalue>
     </para>
     <para>
      Renvoie le nombre total d'éléments dans le tableau, ou 0 si le tableau
      est vide.
     </para>
     <para>
      <literal>cardinality(ARRAY[[1,2],[3,4]])</literal>
      <returnvalue>4</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>string_to_array</primary>
      </indexterm>
      <function>string_to_array</function> ( <parameter>string</parameter> <type>text</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
      <returnvalue>text[]</returnvalue>
     </para>
     <para>
      Divise la chaîne <parameter>string</parameter> à chaque occurrence de
      <parameter>delimiter</parameter> et forme le reste des données dans le
      tableau <type>text</type>. Si <parameter>delimiter</parameter> est
      <literal>NULL</literal>, chaque caractère dans
      <parameter>string</parameter> deviendra un élément séparé dans le
      tableau. Si <parameter>delimiter</parameter> est une chaîne vide,
      alors <parameter>string</parameter> est traité comme un champ vide. Si
      <parameter>null_string</parameter> est fourni et non
      <literal>NULL</literal>, les champs correspondant à cette chaîne sont
      convertis en entrées <literal>NULL</literal>.
     </para>
     <para>
      <literal>string_to_array('xx~~yy~~zz', '~~', 'yy')</literal>
      <returnvalue>{xx,NULL,zz}</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>unnest</primary>
      </indexterm>
      <function>unnest</function> ( <type>anyarray</type> )
      <returnvalue>setof anyelement</returnvalue>
     </para>
     <para>
      Étend le tableau en un ensemble de lignes.
     </para>
     <para>
      <literal>unnest(ARRAY[1,2])</literal>
      <returnvalue></returnvalue>
      <programlisting>
 1
 2
      </programlisting>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <function>unnest</function> ( <type>anyarray</type>, <type>anyarray</type> <optional>, ... </optional> )
      <returnvalue>setof anyelement, anyelement [, ... ]</returnvalue>
     </para>
     <para>
      Étend plusieurs tableaux (potentiellement de types de données
      différents) en un ensemble de lignes. Si les tableaux ne sont pas de
      la même longueur, alors les plus courts sont alignés avec des
      <literal>NULL</literal>. Ceci est seulement autorisé dans la clause
      FROM d'une requête&nbsp;; voir <xref
      linkend="queries-tablefunctions"/>.
     </para>
     <para>
      <literal>select * from unnest(ARRAY[1,2], ARRAY['foo','bar','baz']) as x(a,b)</literal>
      <returnvalue></returnvalue>
      <programlisting>
 a |  b
---+-----
 1 | foo
 2 | bar
   | baz
      </programlisting>
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

<note>
 <para>
  Il existe deux différences dans le comportement de
  <function>string_to_array</function> pour les versions de
  <productname>PostgreSQL</productname> antérieures à la 9.1. Tout d'abord,
  elle renverra un tableau vide (zéro élément) plutôt qu'un
  <literal>NULL</literal> quand la chaîne en entrée est de taille zéro.
  Ensuite, si la chaîne délimiteur est <literal>NULL</literal>, la fonction
  divise l'entrée en caractères individuels, plutôt que de renvoyer
  <literal>NULL</literal> comme avant.
 </para>
</note>

<para>
 Voir aussi <xref linkend="functions-aggregate"/> sur la fonction d'agrégat
 <function>array_agg</function> pour une utilisation avec les tableaux.
</para>
</sect1>

<sect1 id="functions-range">
<title>Fonctions et opérateurs sur les intervalles</title>

<para>
 Voir <xref linkend="rangetypes"/> pour un aperçu les types d'intervalle.
</para>

<para>
 <xref linkend="range-operators-table"/> montre les opérateurs spécialisés
 disponibles pour les types d'intervalle. En plus de ces derniers, les
 opérateurs de comparaison habituels montrés dans <xref
 linkend="functions-comparison-op-table"/> sont disponibles pour les types
 d'intervalle. Les opérateurs de comparaison trient d'abord par les limites
 basses de l'intervalle et seulement si ces dernières sont identiques, par
 les limites hautes. Ceci ne donne généralement pas de résultat utile pour
 un tri, mais les opérateurs sont fournis pour autoriser la création d'index
 d'unicité sur des intervalles.
</para>

<table id="range-operators-table">
 <title>Opérateurs sur les intervalles</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Opérateur
     </para>
     <para>
      Description
     </para>
     <para>
      Exemple(s)
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyrange</type> <literal>@&gt;</literal> <type>anyrange</type>
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Est-ce que le premier intervalle contient le second&nbsp;?
     </para>
     <para>
      <literal>int4range(2,4) @&gt; int4range(2,3)</literal>
      <returnvalue>t</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyrange</type> <literal>@&gt;</literal> <type>anyelement</type>
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Est-ce que l'intervalle contient l'élément&nbsp;?
     </para>
     <para>
      <literal>'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp</literal>
      <returnvalue>t</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyrange</type> <literal>&lt;@</literal> <type>anyrange</type>
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Est-ce que le premier intervalle est contenu par le second&nbsp;?
     </para>
     <para>
      <literal>int4range(2,4) &lt;@ int4range(1,7)</literal>
      <returnvalue>t</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyelement</type> <literal>&lt;@</literal> <type>anyrange</type>
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Est-ce que l'élément est contenu dans l'intervalle&nbsp;?
     </para>
     <para>
      <literal>42 &lt;@ int4range(1,7)</literal>
      <returnvalue>f</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyrange</type> <literal>&amp;&amp;</literal> <type>anyrange</type>
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Est-ce que les intervalles se surchargent, c'est-à-dire ont-ils des
      éléments en commun&nbsp;?
     </para>
     <para>
      <literal>int8range(3,7) &amp;&amp; int8range(4,12)</literal>
      <returnvalue>t</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyrange</type> <literal>&lt;&lt;</literal> <type>anyrange</type>
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Est-ce que le premier intervalle se trouve strictement à gauche du
      second&nbsp;?
     </para>
     <para>
      <literal>int8range(1,10) &lt;&lt; int8range(100,110)</literal>
      <returnvalue>t</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyrange</type> <literal>&gt;&gt;</literal> <type>anyrange</type>
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Est-ce que le premier intervalle se trouve strictement à droite du
      second&nbsp;?
     </para>
     <para>
      <literal>int8range(50,60) &gt;&gt; int8range(20,30)</literal>
      <returnvalue>t</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyrange</type> <literal>&amp;&lt;</literal> <type>anyrange</type>
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Est-ce que le premier intervalle ne s'étend pas à droite du
      second&nbsp;?
     </para>
     <para>
      <literal>int8range(1,20) &amp;&lt; int8range(18,20)</literal>
      <returnvalue>t</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyrange</type> <literal>&amp;&gt;</literal> <type>anyrange</type>
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Est-ce que le premier intervalle ne s'étend pas à gauche du
      second&nbsp;?
     </para>
     <para>
      <literal>int8range(7,20) &amp;&gt; int8range(5,10)</literal>
      <returnvalue>t</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyrange</type> <literal>-|-</literal> <type>anyrange</type>
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Les deux intervalles sont-ils adjacents&nbsp;?
     </para>
     <para>
      <literal>numrange(1.1,2.2) -|- numrange(2.2,3.3)</literal>
      <returnvalue>t</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyrange</type> <literal>+</literal> <type>anyrange</type>
      <returnvalue>anyrange</returnvalue>
     </para>
     <para>
      Calcule l'union des intervalles. Les intervalles doivent se surcharger
      ou être adjacents, pour que l'union soit un intervalle simple
      (cependant voir <function>range_merge()</function>).
     </para>
     <para>
      <literal>numrange(5,15) + numrange(10,20)</literal>
      <returnvalue>[5,20)</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyrange</type> <literal>*</literal> <type>anyrange</type>
      <returnvalue>anyrange</returnvalue>
     </para>
     <para>
      Calcule l'intersection des intervalles.
     </para>
     <para>
      <literal>int8range(5,15) * int8range(10,20)</literal>
      <returnvalue>[10,15)</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <type>anyrange</type> <literal>-</literal> <type>anyrange</type>
      <returnvalue>anyrange</returnvalue>
     </para>
     <para>
      Calcule la différence des intervalles. Le deuxième intervalle ne doit
      pas être contenu dans le premier de tel façon que la différence ne
      formerait pas un intervalle simple.
     </para>
     <para>
      <literal>int8range(5,15) - int8range(10,20)</literal>
      <returnvalue>[5,10)</returnvalue>
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

<para>
 Les opérateurs gauche-de/droite-de/adjacent renvoient toujours false quand
 un intervalle vide est impliqué&nbsp;; autrement dit, un intervalle vide
 n'est pas considéré être avant ou après tout intervalle.
</para>

<para>
 <xref linkend="range-functions-table"/> montre les fonctions disponibles
 avec les types d'intervalle.
</para>

<table id="range-functions-table">
 <title>Fonctions d'intervalle</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para>
     <para>
      Exemple(s)
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>lower</primary>
      </indexterm>
      <function>lower</function> ( <type>anyrange</type> )
      <returnvalue>anyelement</returnvalue>
     </para>
     <para>
      Extrait la limite basse de l'intervalle (<literal>NULL</literal> si
      l'intervalle est vide ou si la limite basse est infinie).
     </para>
     <para>
      <literal>lower(numrange(1.1,2.2))</literal>
      <returnvalue>1.1</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>upper</primary>
      </indexterm>
      <function>upper</function> ( <type>anyrange</type> )
      <returnvalue>anyelement</returnvalue>
     </para>
     <para>
      Extrait la limite haute de l'intervalle (<literal>NULL</literal> si
      l'intervalle est vide ou si la limite haute est infinie).
     </para>
     <para>
      <literal>upper(numrange(1.1,2.2))</literal>
      <returnvalue>2.2</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>isempty</primary>
      </indexterm>
      <function>isempty</function> ( <type>anyrange</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Est-ce que l'intervalle est vide&nbsp;?
     </para>
     <para>
      <literal>isempty(numrange(1.1,2.2))</literal>
      <returnvalue>f</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>lower_inc</primary>
      </indexterm>
      <function>lower_inc</function> ( <type>anyrange</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Est-ce que la limite basse de l'intervalle est inclus&nbsp;?
     </para>
     <para>
      <literal>lower_inc(numrange(1.1,2.2))</literal>
      <returnvalue>t</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>upper_inc</primary>
      </indexterm>
      <function>upper_inc</function> ( <type>anyrange</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Est-ce que la limite haute de l'intervalle est inclus&nbsp;?
     </para>
     <para>
      <literal>upper_inc(numrange(1.1,2.2))</literal>
      <returnvalue>f</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>lower_inf</primary>
      </indexterm>
      <function>lower_inf</function> ( <type>anyrange</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Est-ce que la limite basse de l'intervalle est infinie&nbsp;?
     </para>
     <para>
      <literal>lower_inf('(,)'::daterange)</literal>
      <returnvalue>t</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>upper_inf</primary>
      </indexterm>
      <function>upper_inf</function> ( <type>anyrange</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Est-ce que la limite haute de l'intervalle est infinie&nbsp;?
     </para>
     <para>
      <literal>upper_inf('(,)'::daterange)</literal>
      <returnvalue>t</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>range_merge</primary>
      </indexterm>
      <function>range_merge</function> ( <type>anyrange</type>, <type>anyrange</type> )
      <returnvalue>anyrange</returnvalue>
     </para>
     <para>
      Calcule le plus petit intervalle incluant les deux intervalles.
     </para>
     <para>
      <literal>range_merge('[1,2)'::int4range, '[3,4)'::int4range)</literal>
      <returnvalue>[1,4)</returnvalue>
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

<para>
 Les fonctions <function>lower_inc</function>, <function>upper_inc</function>,
 <function>lower_inf</function> et <function>upper_inf</function>
 renvoient toutes false pour un intervalle vide.
</para>
</sect1>

<sect1 id="functions-aggregate">
<title>Fonctions d'agrégat</title>

<indexterm zone="functions-aggregate">
 <primary>fonction d'agrégat</primary>
 <secondary>native</secondary>
</indexterm>

<para>
 Les <firstterm>fonctions d'agrégat</firstterm> calculent un seul résultat à
 partir d'un ensemble de valeurs en entrée. Les fonctions d'agrégat natives
 à but général sont listées dans <xref linkend="functions-aggregate-table"/>
 alors que les agrégats statistiques sont dans <xref
 linkend="functions-aggregate-statistics-table"/>. Les fonctions d'agrégat
 natives à ensemble trié dans des groupes sont listées dans <xref
 linkend="functions-orderedset-table"/> alors que les fonctions à ensemble
 hypothétique dans des groupes sont dans <xref
 linkend="functions-hypothetical-table"/>. Les opérations de regroupement,
 qui sont fortement liées aux fonctions d'agrégat, sont listées dans <xref
 linkend="functions-grouping-table"/>. Les considérations spéciales de
 syntaxe pour les fonctions d'agrégat sont expliquées dans <xref
 linkend="syntax-aggregates"/>. Consultez <xref linkend="tutorial-agg"/>
 pour une introduction supplémentaire.
</para>

<para>
 Les fonctions d'agrégat qui supportent le <firstterm>Mode Partiel</firstterm>
 sont éligibles à participer à différentes optimisations, telles que
 l'agrégation parallélisée.
</para>

<table id="functions-aggregate-table">
 <title>Fonctions d'agrégat à but général</title>
 <tgroup cols="2">
  <colspec colname="col1" colwidth="10*"/>
  <colspec colname="col2" colwidth="1*"/>
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para></entry>
    <entry>Mode Partiel</entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>array_agg</primary>
      </indexterm>
      <function>array_agg</function> ( <type>anynonarray</type> )
      <returnvalue>anyarray</returnvalue>
     </para>
     <para>
      Récupère toutes les valeurs en entrée, y compris les NULL, et les place
      dans un tableau.
     </para></entry>
    <entry>No</entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <function>array_agg</function> ( <type>anyarray</type> )
      <returnvalue>anyarray</returnvalue>
     </para>
     <para>
      Concatène tous les tableaux en entrée dans un tableau d'une dimension
      supérieure. (Les entrées doivent toutes avoir la même dimension, et ne
      peuvent être ni vides ni NULL.)
     </para></entry>
    <entry>No</entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>average</primary>
      </indexterm>
      <indexterm>
       <primary>avg</primary>
      </indexterm>
      <function>avg</function> ( <type>smallint</type> )
      <returnvalue>numeric</returnvalue>
     </para>
     <para role="func_signature">
      <function>avg</function> ( <type>integer</type> )
      <returnvalue>numeric</returnvalue>
     </para>
     <para role="func_signature">
      <function>avg</function> ( <type>bigint</type> )
      <returnvalue>numeric</returnvalue>
     </para>
     <para role="func_signature">
      <function>avg</function> ( <type>numeric</type> )
      <returnvalue>numeric</returnvalue>
     </para>
     <para role="func_signature">
      <function>avg</function> ( <type>real</type> )
      <returnvalue>double precision</returnvalue>
     </para>
     <para role="func_signature">
      <function>avg</function> ( <type>double precision</type> )
      <returnvalue>double precision</returnvalue>
     </para>
     <para role="func_signature">
      <function>avg</function> ( <type>interval</type> )
      <returnvalue>interval</returnvalue>
     </para>
     <para>
      Calcule la moyenne (arithmétique) de toutes les valeurs en entrée, non
      NULL.
     </para></entry>
    <entry>Yes</entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>bit_and</primary>
      </indexterm>
      <function>bit_and</function> ( <type>smallint</type> )
      <returnvalue>smallint</returnvalue>
     </para>
     <para role="func_signature">
      <function>bit_and</function> ( <type>integer</type> )
      <returnvalue>integer</returnvalue>
     </para>
     <para role="func_signature">
      <function>bit_and</function> ( <type>bigint</type> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para role="func_signature">
      <function>bit_and</function> ( <type>bit</type> )
      <returnvalue>bit</returnvalue>
     </para>
     <para>
      Calcule un AND bit à bit de toutes les valeurs en entrée non NULL.
     </para></entry>
    <entry>Yes</entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>bit_or</primary>
      </indexterm>
      <function>bit_or</function> ( <type>smallint</type> )
      <returnvalue>smallint</returnvalue>
     </para>
     <para role="func_signature">
      <function>bit_or</function> ( <type>integer</type> )
      <returnvalue>integer</returnvalue>
     </para>
     <para role="func_signature">
      <function>bit_or</function> ( <type>bigint</type> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para role="func_signature">
      <function>bit_or</function> ( <type>bit</type> )
      <returnvalue>bit</returnvalue>
     </para>
     <para>
      Calcule un OR bit à bit de toutes les valeurs en entrée non NULL.
     </para></entry>
    <entry>Yes</entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>bool_and</primary>
      </indexterm>
      <function>bool_and</function> ( <type>boolean</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Renvoie true si toutes les valeurs en entrée non NULL valent true,
      sinon false.
     </para></entry>
    <entry>Yes</entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>bool_or</primary>
      </indexterm>
      <function>bool_or</function> ( <type>boolean</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Renvoie true si au moins une des valeurs en entrée non NULL vaut true,
      sinon false.
     </para></entry>
    <entry>Yes</entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>count</primary>
      </indexterm>
      <function>count</function> ( <literal>*</literal> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para>
      Calcule le nombre de lignes en entrée.
     </para></entry>
    <entry>Yes</entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <function>count</function> ( <type>"any"</type> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para>
      Calcule le nombre de lignes en entrée pour lesquelles la valeur n'est
      pas NULL.
     </para></entry>
    <entry>Yes</entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>every</primary>
      </indexterm>
      <function>every</function> ( <type>boolean</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Ceci est l'équivalent de <function>bool_and</function> pour le standard
      SQL.
     </para></entry>
    <entry>Yes</entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>json_agg</primary>
      </indexterm>
      <function>json_agg</function> ( <type>anyelement</type> )
      <returnvalue>json</returnvalue>
     </para>
     <para role="func_signature">
      <indexterm>
       <primary>jsonb_agg</primary>
      </indexterm>
      <function>jsonb_agg</function> ( <type>anyelement</type> )
      <returnvalue>jsonb</returnvalue>
     </para>
     <para>
      Récupère toutes les valeurs en entrée, y compris les NULL, et les place
      dans un tableau JSON. Les valeurs sont converties en JSON avec
      <function>to_json</function> ou <function>to_jsonb</function>.
     </para></entry>
    <entry>No</entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>json_object_agg</primary>
      </indexterm>
      <function>json_object_agg</function> ( <parameter>key</parameter>
      <type>"any"</type>, <parameter>value</parameter>
      <type>"any"</type> )
      <returnvalue>json</returnvalue>
     </para>
     <para role="func_signature">
      <indexterm>
       <primary>jsonb_object_agg</primary>
      </indexterm>
      <function>jsonb_object_agg</function> ( <parameter>key</parameter>
      <type>"any"</type>, <parameter>value</parameter>
      <type>"any"</type> )
      <returnvalue>jsonb</returnvalue>
     </para>
     <para>
      Récupère toutes les paires clé/valeur et les place dans un objet JSON.
      Les arguments clé sont convertis en texte&nbsp;; les arguments valeur
      sont convertis avec <function>to_json</function> ou
      <function>to_jsonb</function>. Les valeurs peuvent être NULL, mais pas
      les clés.
     </para></entry>
    <entry>No</entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>max</primary>
      </indexterm>
      <function>max</function> ( <replaceable>see text</replaceable> )
      <returnvalue><replaceable>same as input type</replaceable></returnvalue>
     </para>
     <para>
      Calcule la valeur maximale de toutes les valeurs en entrée non NULL.
      Disponible pour les types numeric, string, date/time ou enum type,
      ainsi que <type>inet</type>, <type>interval</type>,
      <type>money</type>, <type>oid</type>, <type>pg_lsn</type>,
      <type>tid</type> et les tableaux de chacun de ces types.
     </para></entry>
    <entry>Yes</entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>min</primary>
      </indexterm>
      <function>min</function> ( <replaceable>see text</replaceable> )
      <returnvalue><replaceable>same as input type</replaceable></returnvalue>
     </para>
     <para>
      Calcule la valeur minimale de toutes les valeurs en entrée non NULL.
      Disponible pour les types numeric, string, date/time ou enum type,
      ainsi que <type>inet</type>, <type>interval</type>,
      <type>money</type>, <type>oid</type>, <type>pg_lsn</type>,
      <type>tid</type> et les tableaux de chacun de ces types.
     </para></entry>
    <entry>Yes</entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>string_agg</primary>
      </indexterm>
      <function>string_agg</function> ( <parameter>value</parameter>
      <type>text</type>, <parameter>delimiter</parameter> <type>text</type> )
      <returnvalue>text</returnvalue>
     </para>
     <para role="func_signature">
      <function>string_agg</function> ( <parameter>value</parameter>
      <type>bytea</type>, <parameter>delimiter</parameter> <type>bytea</type> )
      <returnvalue>bytea</returnvalue>
     </para>
     <para>
      Concatène les valeurs en entrée non NULL dans une chaîne. Chaque valeur
      après la première est précédée par le <parameter>delimiter</parameter>
      correspondant (s'il n'est pas NULL).
     </para></entry>
    <entry>No</entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>sum</primary>
      </indexterm>
      <function>sum</function> ( <type>smallint</type> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para role="func_signature">
      <function>sum</function> ( <type>integer</type> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para role="func_signature">
      <function>sum</function> ( <type>bigint</type> )
      <returnvalue>numeric</returnvalue>
     </para>
     <para role="func_signature">
      <function>sum</function> ( <type>numeric</type> )
      <returnvalue>numeric</returnvalue>
     </para>
     <para role="func_signature">
      <function>sum</function> ( <type>real</type> )
      <returnvalue>real</returnvalue>
     </para>
     <para role="func_signature">
      <function>sum</function> ( <type>double precision</type> )
      <returnvalue>double precision</returnvalue>
     </para>
     <para role="func_signature">
      <function>sum</function> ( <type>interval</type> )
      <returnvalue>interval</returnvalue>
     </para>
     <para role="func_signature">
      <function>sum</function> ( <type>money</type> )
      <returnvalue>money</returnvalue>
     </para>
     <para>
      Calcule la somme de toutes les valeurs en entrée non NULL.
     </para></entry>
    <entry>Yes</entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>xmlagg</primary>
      </indexterm>
      <function>xmlagg</function> ( <type>xml</type> )
      <returnvalue>xml</returnvalue>
     </para>
     <para>
      Concatène toutes les valeurs XML en entrée non NULL (voir
      <xref linkend="functions-xml-xmlagg"/>).
     </para></entry>
    <entry>No</entry>
   </row>
  </tbody>
 </tgroup>
</table>

<para>
 Il doit être noté que, sauf pour <function>count</function>, ces fonctions
 renvoient NULL quand aucune ligne n'est sélectionnée. En particulier, le
 <function>sum</function> d'aucune ligne renvoie NULL, et non pas zéro comme
 certains s'y attendraient, et <function>array_agg</function> renvoie NULL
 plutôt qu'un tableau vide s'il n'y a pas de lignes en entrée. La fonction
 <function>coalesce</function> peut être utilisée pour substituer une valeur
 NULL à zéro ou un tableau vide quand cela s'avère nécessaire.
</para>

<para>
 Les fonctions d'agrégat <function>array_agg</function>,
 <function>json_agg</function>, <function>jsonb_agg</function>,
 <function>json_object_agg</function>,
 <function>jsonb_object_agg</function>, <function>string_agg</function> et
 <function>xmlagg</function>, ainsi que les fonctions d'agrégat utilisateurs
 similaires, produisent des valeurs de résultat différentes suivant l'ordre
 des valeurs en entrée. Cet ordre n'est pas spécifié par défaut, mais peut
 être contrôlé en écrivant une clause <literal>ORDER BY</literal> dans
 l'appel à l'agrégat, comme indiqué dans <xref
 linkend="syntax-aggregates"/>. Autrement, fournir les valeurs en entrée
 triées à partir d'une sous-requête fonctionne généralement. Par
 exemple&nbsp;:

 <screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;
]]></screen>

   Attention que cette approche peut échouer si le niveau de la requête
   externe contient un traitement supplémentaire, tel qu'une jointure, parce
   que cela pourrait remettre en cause la sortie de la sous-requête et
   notamment un nouveau tri avant le calcul de l'agrégat.
  </para>

  <note>
    <indexterm>
      <primary>ANY</primary>
    </indexterm>
    <indexterm>
      <primary>SOME</primary>
    </indexterm>
    <para>
      Les agrégats booléens <function>bool_and</function> et
      <function>bool_or</function> correspondent aux agrégats du standard SQL
      <function>every</function> et <function>any</function> ou
      <function>some</function>. <productname>PostgreSQL</productname> accepte
      <function>every</function>, mais pas <function>any</function> et
      <function>some</function>, car il y a une ambiguité dans la syntaxe
      standard&nbsp;:
<programlisting>
SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;
 </programlisting>
 Ici, <function>ANY</function> peut être considéré soit comme
 introduisant une sous-requête, soit comme étant une fonction d'agrégat,
 si la sous-requête renvoie une ligne avec une valeur booléenne. De ce
 fait, le nom standard ne peut pas être donné à ces agrégats.
</para>
</note>

<note>
<para>
 Les utilisateurs habitués à travailler avec d'autres systèmes de gestion
 de bases de données pourraient être déçus par les performances de l'agrégat
 <function>count</function> quand il est appliqué à la table entière. Une
 requête comme&nbsp;:
 <programlisting>
SELECT count(*) FROM sometable;
 </programlisting>
 nécessite un effort proportionnel à la taille de la table&nbsp;:
 <productname>PostgreSQL</productname> aura besoin de parcourir soit toute
 la table soit tout un index qui inclut toutes les lignes de la table.
</para>
</note>

<para>
<xref linkend="functions-aggregate-statistics-table"/> montre les fonctions
d'agrégat typiquement utilisées dans les analyses statistiques. (Elles sont
séparées principalement pour éviter d'encombrer la liste des agrégats plus
fréquemment utilisés.) Les fonctions acceptant
<replaceable>numeric_type</replaceable> sont disponibles pour les types
<type>smallint</type>, <type>integer</type>, <type>bigint</type>,
<type>numeric</type>, <type>real</type> et <type>double precision</type>.
Quand la description mentionne <parameter>N</parameter>, cela signifie le
nombre de lignes en entrée pour lesquelles les expressions en entrée ne
sont pas NULL. Dans tous les cas, NULL est renvoyé si le calcul n'a pas de
sens, par exemple quand <parameter>N</parameter> vaut zéro.
</para>

<indexterm>
<primary>statistics</primary>
</indexterm>
<indexterm>
<primary>régression linéaire</primary>
</indexterm>

<table id="functions-aggregate-statistics-table">
<title>Fonctions d'agrégat pour les statistiques</title>
<tgroup cols="2">
 <colspec colname="col1" colwidth="10*"/>
 <colspec colname="col2" colwidth="1*"/>
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para></entry>
   <entry>Mode Partiel</entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>correlation</primary>
     </indexterm>
     <indexterm>
      <primary>corr</primary>
     </indexterm>
     <function>corr</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
     <returnvalue>double precision</returnvalue>
    </para>
    <para>
     Calcule le coefficient de corrélation.
    </para></entry>
   <entry>Yes</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>covariance</primary>
      <secondary>population</secondary>
     </indexterm>
     <indexterm>
      <primary>covar_pop</primary>
     </indexterm>
     <function>covar_pop</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
     <returnvalue>double precision</returnvalue>
    </para>
    <para>
     Calcule la covariance de population.
    </para></entry>
   <entry>Yes</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>covariance</primary>
      <secondary>sample</secondary>
     </indexterm>
     <indexterm>
      <primary>covar_samp</primary>
     </indexterm>
     <function>covar_samp</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
     <returnvalue>double precision</returnvalue>
    </para>
    <para>
     Calcule la covariance d'échantillon.
    </para></entry>
   <entry>Yes</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>regr_avgx</primary>
     </indexterm>
     <function>regr_avgx</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
     <returnvalue>double precision</returnvalue>
    </para>
    <para>
     Calcule la moyenne de la variable indépendante,
     <literal>sum(<parameter>X</parameter>)/<parameter>N</parameter></literal>.
    </para></entry>
   <entry>Yes</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>regr_avgy</primary>
     </indexterm>
     <function>regr_avgy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
     <returnvalue>double precision</returnvalue>
    </para>
    <para>
     Calcule la moyenne de la variable dépendante,
     <literal>sum(<parameter>Y</parameter>)/<parameter>N</parameter></literal>.
    </para></entry>
   <entry>Yes</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>regr_count</primary>
     </indexterm>
     <function>regr_count</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
     <returnvalue>bigint</returnvalue>
    </para>
    <para>
     Calcule le nombre de lignes pour lesquelles les deux entrées sont
     non NULL.
    </para></entry>
   <entry>Yes</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>regression intercept</primary>
     </indexterm>
     <indexterm>
      <primary>regr_intercept</primary>
     </indexterm>
     <function>regr_intercept</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
     <returnvalue>double precision</returnvalue>
    </para>
    <para>
     Computes the y-intercept of the least-squares-fit linear equation
     determined by the
     (<parameter>X</parameter>, <parameter>Y</parameter>) pairs.
    </para></entry>
   <entry>Yes</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>regr_r2</primary>
     </indexterm>
     <function>regr_r2</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
     <returnvalue>double precision</returnvalue>
    </para>
    <para>
     Calcule le carré du coefficient de corrélation.
    </para></entry>
   <entry>Yes</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>regression slope</primary>
     </indexterm>
     <indexterm>
      <primary>regr_slope</primary>
     </indexterm>
     <function>regr_slope</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
     <returnvalue>double precision</returnvalue>
    </para>
    <para>
     Computes the slope of the least-squares-fit linear equation determined
     by the (<parameter>X</parameter>, <parameter>Y</parameter>)
     pairs.
    </para></entry>
   <entry>Yes</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>regr_sxx</primary>
     </indexterm>
     <function>regr_sxx</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
     <returnvalue>double precision</returnvalue>
    </para>
    <para>
     Calcule la <quote>somme des carrés</quote> de la variable indépendante,
     <literal>sum(<parameter>X</parameter>^2) - sum(<parameter>X</parameter>)^2/<parameter>N</parameter></literal>.
    </para></entry>
   <entry>Yes</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>regr_sxy</primary>
     </indexterm>
     <function>regr_sxy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
     <returnvalue>double precision</returnvalue>
    </para>
    <para>
     Calcule la <quote>somme des produits</quote> des variables dépendantes
     heures indépendantes,
     <literal>sum(<parameter>X</parameter>*<parameter>Y</parameter>) - sum(<parameter>X</parameter>) * sum(<parameter>Y</parameter>)/<parameter>N</parameter></literal>.
    </para></entry>
   <entry>Yes</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>regr_syy</primary>
     </indexterm>
     <function>regr_syy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
     <returnvalue>double precision</returnvalue>
    </para>
    <para>
     Calcule la <quote>somme des carrés</quote> de la variable dépendante,
     <literal>sum(<parameter>Y</parameter>^2) - sum(<parameter>Y</parameter>)^2/<parameter>N</parameter></literal>.
    </para></entry>
   <entry>Yes</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>standard deviation</primary>
     </indexterm>
     <indexterm>
      <primary>stddev</primary>
     </indexterm>
     <function>stddev</function> ( <replaceable>numeric_type</replaceable> )
     <returnvalue></returnvalue> <type>double precision</type>
     pour <type>real</type> ou <type>double precision</type>,
     sinon <type>numeric</type>
    </para>
    <para>
     Alias historique pour <function>stddev_samp</function>.
    </para></entry>
   <entry>Yes</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>standard deviation</primary>
      <secondary>population</secondary>
     </indexterm>
     <indexterm>
      <primary>stddev_pop</primary>
     </indexterm>
     <function>stddev_pop</function> ( <replaceable>numeric_type</replaceable> )
     <returnvalue></returnvalue> <type>double precision</type>
     pour <type>real</type> ou <type>double precision</type>,
     sinon <type>numeric</type>
    </para>
    <para>
     Calcule la déviation standard de la population pour les valeurs en
     entrée.
    </para></entry>
   <entry>Yes</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>standard deviation</primary>
      <secondary>sample</secondary>
     </indexterm>
     <indexterm>
      <primary>stddev_samp</primary>
     </indexterm>
     <function>stddev_samp</function> ( <replaceable>numeric_type</replaceable> )
     <returnvalue></returnvalue> <type>double precision</type>
     pour <type>real</type> ou <type>double precision</type>,
     sinon <type>numeric</type>
    </para>
    <para>
     Calcule la déviation standard d'échantillon des valeurs en entrée.
    </para></entry>
   <entry>Yes</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>variance</primary>
     </indexterm>
     <function>variance</function> ( <replaceable>numeric_type</replaceable> )
     <returnvalue></returnvalue> <type>double precision</type>
     pour <type>real</type> ou <type>double precision</type>,
     sinon <type>numeric</type>
    </para>
    <para>
     Alias historique pour <function>var_samp</function>.
    </para></entry>
   <entry>Yes</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>variance</primary>
      <secondary>population</secondary>
     </indexterm>
     <indexterm>
      <primary>var_pop</primary>
     </indexterm>
     <function>var_pop</function> ( <replaceable>numeric_type</replaceable> )
     <returnvalue></returnvalue> <type>double precision</type>
     pour <type>real</type> ou <type>double precision</type>,
     sinon <type>numeric</type>
    </para>
    <para>
     Calcule la variance de la population pour les valeurs en entrée
     (carré de la déviation standard de la population).
    </para></entry>
   <entry>Yes</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>variance</primary>
      <secondary>sample</secondary>
     </indexterm>
     <indexterm>
      <primary>var_samp</primary>
     </indexterm>
     <function>var_samp</function> ( <replaceable>numeric_type</replaceable> )
     <returnvalue></returnvalue> <type>double precision</type>
     for <type>real</type> or <type>double precision</type>,
     otherwise <type>numeric</type>
    </para>
    <para>
     Calcule la variance d'échantillon des valeurs en entrée (carré de la
     déviation standard d'échantillon).
    </para></entry>
   <entry>Yes</entry>
  </row>
 </tbody>
</tgroup>
</table>

<para>
<xref linkend="functions-orderedset-table"/> montre certaines fonctions
d'agrégat utilisant la syntaxe d'<firstterm>agrégat à ensemble
 ordonné</firstterm>. Ces fonctions sont parfois nommées fonctions à
<quote>distribution inverse</quote>. Leur entrée est introduite par
<literal>ORDER BY</literal>, et elles peuvent aussi prendre un
<firstterm>argument direct</firstterm> qui n'est pas agrégé mais calculé
une seule fois. Toutes ces fonctions ignorent les valeurs NULL dans leur
entrée agrégée. Pour celles qui prennent un paramètre
<parameter>fraction</parameter>, la valeur de la fraction est comprise
entre 0 et 1&nbsp;; une erreur est renvoyée dans le cas contraire.
Néanmoins une valeur de <parameter>fraction</parameter> NULL donne
simplement un résultat NULL.
</para>

<indexterm>
<primary>agrégat à ensemble trié</primary>
<secondary>natif</secondary>
</indexterm>
<indexterm>
<primary>distribution inverse</primary>
</indexterm>

<table id="functions-orderedset-table">
<title>Fonctions d'agrégat à ensemble trié</title>
<tgroup cols="2">
 <colspec colname="col1" colwidth="10*"/>
 <colspec colname="col2" colwidth="1*"/>
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para></entry>
   <entry>Mode Partiel</entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>mode</primary>
      <secondary>statistical</secondary>
     </indexterm>
     <function>mode</function> () <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
     <returnvalue>anyelement</returnvalue>
    </para>
    <para>
     Calcule le <firstterm>mode</firstterm>, la valeur la plus fréquente
     d'un argument agrégé (en choisissant arbitrairement le premier s'il
     y a plusieurs valeurs de fréquence égale). L'argument agrégé doit
     être d'un type triable.
    </para></entry>
   <entry>No</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>percentile</primary>
      <secondary>continuous</secondary>
     </indexterm>
     <function>percentile_cont</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>double precision</type> )
     <returnvalue>double precision</returnvalue>
    </para>
    <para role="func_signature">
     <function>percentile_cont</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>interval</type> )
     <returnvalue>interval</returnvalue>
    </para>
    <para>
     Calcule le <firstterm>pourcentage continu</firstterm>, une valeur
     correspondant à la <parameter>fraction</parameter> à l'intérieur d'un
     ensemble ordonné de valeurs d'argument agrégées. Ceci va interpoler
     entre les éléments en entrée adjacents si nécessaire.
    </para></entry>
   <entry>No</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <function>percentile_cont</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>double precision</type> )
     <returnvalue>double precision[]</returnvalue>
    </para>
    <para role="func_signature">
     <function>percentile_cont</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>interval</type> )
     <returnvalue>interval[]</returnvalue>
    </para>
    <para>
     Calcule plusieurs pourcentages continues. Le résultat est un tableau
     de mêmes dimensions que le paramètre <parameter>fractions</parameter>,
     avec chaque élément non NULL remplacé par la valeur (potentiellement
     interpolée) correspondance à ce pourcentage.
    </para></entry>
   <entry>No</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>percentile</primary>
      <secondary>discrete</secondary>
     </indexterm>
     <function>percentile_disc</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
     <returnvalue>anyelement</returnvalue>
    </para>
    <para>
     Calcule le <firstterm>pourcentage discret</firstterm>, la première
     valeur avec l'ensemble de tri des valeurs d'argument agrégé dont la
     position dans le tri est égale ou dépasse la
     <parameter>fraction</parameter> indiquée. L'argument agrégé doit être
     d'un type triable.
    </para></entry>
   <entry>No</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <function>percentile_disc</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
     <returnvalue>anyarray</returnvalue>
    </para>
    <para>
     Calcule plusieurs pourcentages discrets. Le résultat est un tableau de
     mêmes dimensions que le paramètre <parameter>fractions</parameter>,
     avec chaque élément non NULL remplacé par la valeur en entrée
     correspondant à ce pourcentage. L'argument agrégé doit être d'un type
     triable.
    </para></entry>
   <entry>No</entry>
  </row>
 </tbody>
</tgroup>
</table>

<indexterm>
<primary>hypothetical-set aggregate</primary>
<secondary>built-in</secondary>
</indexterm>

<para>
Chacun des agrégats d'<quote>ensemble hypothétique</quote> listés dans
<xref linkend="functions-hypothetical-table"/> est associé avec une
fonction de fenêtrage du même nom définie dans <xref
linkend="functions-window"/>. Dans chaque cas, le résultat de l'agrégat est
la valeur que la fonction de fenêtrage associée aurait renvoyée pour la
ligne <quote>hypothétique</quote> construite à partir de
<replaceable>args</replaceable>, si une telle ligne a été ajoutée au groupe
trié de lignes représenté par <replaceable>sorted_args</replaceable>. Pour
chacune de ces fonctions, la liste des arguments directs donnée dans
<replaceable>args</replaceable> doit correspondre au nombre et types des
arguments agrégés donnés dans <replaceable>sorted_args</replaceable>.
Contrairement à la plupart des agrégats natifs, ces agrégats ne sont pas
stricts, c'est-à-dire qu'ils ne suppriment pas les lignes en entrée
contenant des NULL. Les valeurs NULL se trient suivant la règle indiquée
dans la clause <literal>ORDER BY</literal>.
</para>

<table id="functions-hypothetical-table">
<title>Fonctions d'agrégat à ensemble hypothétique</title>
<tgroup cols="2">
 <colspec colname="col1" colwidth="10*"/>
 <colspec colname="col2" colwidth="1*"/>
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para></entry>
   <entry>Mode Partiel</entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>rank</primary>
      <secondary>hypothetical</secondary>
     </indexterm>
     <function>rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
     <returnvalue>bigint</returnvalue>
    </para>
    <para>
     Calcule le rang de la ligne hypothétique avec des trous&nbsp;;
     c'est-à-dire le numéro de la première ligne dans son groupe.
    </para></entry>
   <entry>No</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>dense_rank</primary>
      <secondary>hypothetical</secondary>
     </indexterm>
     <function>dense_rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
     <returnvalue>bigint</returnvalue>
    </para>
    <para>
     Calcule le rang de la ligne hypothétique sans trous&nbsp;; cette
     fonction compte réellement le nombre de groupes.
    </para></entry>
   <entry>No</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>percent_rank</primary>
      <secondary>hypothetical</secondary>
     </indexterm>
     <function>percent_rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
     <returnvalue>double precision</returnvalue>
    </para>
    <para>
     Calcule le rang relatif de la ligne hypothétique, c'est-à-dire
     (<function>rank</function> - 1) / (lignes totales - 1).
     La valeur est donc comprise entre 0 et 1, les deux étant inclus.
    </para></entry>
   <entry>No</entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>cume_dist</primary>
      <secondary>hypothetical</secondary>
     </indexterm>
     <function>cume_dist</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
     <returnvalue>double precision</returnvalue>
    </para>
    <para>
     Calcule la distribution cumulative, c'est-à-dire (nombre de lignes
     précédentes ou proches de la ligne hypothétique) / (total de lignes).
     La valeur est donc comprise entre 1/<parameter>N</parameter> et 1.
    </para></entry>
   <entry>No</entry>
  </row>
 </tbody>
</tgroup>
</table>

<table id="functions-grouping-table">
<title>Opérations de regroupement</title>
<tgroup cols="1">
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para></entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>GROUPING</primary>
     </indexterm>
     <function>GROUPING</function> ( <replaceable>group_by_expression(s)</replaceable> )
     <returnvalue>integer</returnvalue>
    </para>
    <para>
     Renvoie un masque de bits indiquant les expressions <literal>GROUP
      BY</literal> non incluses dans l'ensemble de regroupement actuel. Les
     bits sont affectés avec l'argument le plus à droit correspondant au
     bit de plus faible poids&nbsp;; chaque bit vaut 0 si l'expression
     correspondante est inclus dans le critère de regroupement de
     l'ensemble de regroupement générant la ligne résultat actuelle, et 1
     dans le cas contraire.
    </para></entry>
  </row>
 </tbody>
</tgroup>
</table>

<para>
Les opérations de regroupement affichées dans <xref
linkend="functions-grouping-table"/> sont utilisées en conjonction avec
les ensembles de regroupement (voir <xref
linkend="queries-grouping-sets"/>) pour distinguer les lignes résultats.
Les arguments à la fonction <literal>GROUPING</literal> ne sont pas
réellement évalués car ils doivent correspondre exactement aux expressions
données dans la clause <literal>GROUP BY</literal> du niveau de requête
associé. Par exemple&nbsp;:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>
 make  | model | sales
-------+-------+-------
 Foo   | GT    |  10
 Foo   | Tour  |  20
 Bar   | City  |  15
 Bar   | Sport |  5
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT make, model, GROUPING(make,model), sum(sales) FROM items_sold GROUP BY ROLLUP(make,model);</userinput>
 make  | model | grouping | sum
-------+-------+----------+-----
 Foo   | GT    |        0 | 10
 Foo   | Tour  |        0 | 20
 Bar   | City  |        0 | 15
 Bar   | Sport |        0 | 5
 Foo   |       |        1 | 30
 Bar   |       |        1 | 20
       |       |        3 | 50
(7 rows)
</screen>
Ici, la valeur <literal>0</literal> dans la colonne
<literal>grouping</literal> des quatre premières lignes montre qu'elles
ont été regroupées normalement par rapport aux colonnes de regroupement.
La valeur <literal>1</literal> indique que la colonne
<literal>model</literal> n'a pas été groupé dans les deux lignes
suivantes, et la valeur <literal>3</literal> indique que ni la colonne
<literal>make</literal> ni la colonne <literal>model</literal> n'ont été
regroupées dans la dernière ligne (qui, de ce fait, est un agrégat sur
tous les lignes en entrée).
</para>

</sect1>

<sect1 id="functions-window">
<title>Fonctions de fenêtrage</title>

<indexterm zone="functions-window">
<primary>fonction de fenêtrage</primary>
<secondary>native</secondary>
</indexterm>

<para>
Les <firstterm>fonctions de fenêtrage</firstterm> fournissent des moyens
pour réaliser des calculs sur des ensembles de lignes relatives à la ligne
actuelle de la requête. Voir <xref linkend="tutorial-window"/> pour une
introduction à cette fonctionnalité, et <xref
linkend="syntax-window-functions"/> pour les détails sur la syntaxe.
</para>

<para>
Les fonctions de fenêtrage natives sont montrées dans <xref
linkend="functions-window-table"/>. Notez que ces fonctions
<emphasis>doivent</emphasis> être appelées en utilisant la syntaxe des
fonctions de fénêtrage, c'est-à-dire en utilisant une clause
<literal>OVER</literal>.
</para>

<para>
En plus de ces fonctions, toute fonction d'agrégat standard native ou
définie par un utilisateur (donc pas les agrégats à ensemble ordonné ou à
ensemble hypothétique) peut être utilisée comme une fonction de
fenêtrage&nbsp;; voir <xref linkend="functions-aggregate"/> pour une liste
des agrégats natifs. Les fonctions d'agrégat agissent comme des fonctions
de fenêtrage quand une clause <literal>OVER</literal> est utilisée pour
l'appel&nbsp;; sinon elles agissent comme des agrégats standards et
renvoient une seule ligne pour un ensemble complet.
</para>

<table id="functions-window-table">
<title>Fonctions de fenêtrage à usage général</title>
<tgroup cols="1">
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para></entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>row_number</primary>
     </indexterm>
     <function>row_number</function> ()
     <returnvalue>bigint</returnvalue>
    </para>
    <para>
     Renvoie le nombre de la ligne courante dans sa partition, en commençant
     à 1.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>rank</primary>
     </indexterm>
     <function>rank</function> ()
     <returnvalue>bigint</returnvalue>
    </para>
    <para>
     Renvoie le range de la ligne courante, avec des trous&nbsp;;
     c'est-à-dire le <function>row_number</function> de la première ligne
     dans son groupe.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>dense_rank</primary>
     </indexterm>
     <function>dense_rank</function> ()
     <returnvalue>bigint</returnvalue>
    </para>
    <para>
     Renvoie le range de la ligne courante, sans trous&nbsp;; cette
     fonction compte réellement les groupes.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>percent_rank</primary>
     </indexterm>
     <function>percent_rank</function> ()
     <returnvalue>double precision</returnvalue>
    </para>
    <para>
     Renvoie le rang relatif de la ligne courante, c'est-à-dire
     (<function>rank</function> - 1) / (total de lignes dans la partition - 1).
     La valeur est donc comprise entre 0 et 1, les deux inclus.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>cume_dist</primary>
     </indexterm>
     <function>cume_dist</function> ()
     <returnvalue>double precision</returnvalue>
    </para>
    <para>
     Renvoie la distribution cumulative, c'est-à-dire (nombre de lignes dans
     la partition précédente ou nombre de groupes à partir de la ligne courante)
     / (total de lignes dans la partition).
     La valeur est donc comprise entre 1/<parameter>N</parameter> et 1.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>ntile</primary>
     </indexterm>
     <function>ntile</function> ( <parameter>num_buckets</parameter> <type>integer</type> )
     <returnvalue>integer</returnvalue>
    </para>
    <para>
     Renvoie un entier entre 1 et la valeur argument, divisant la partition
     aussi également que possible.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>lag</primary>
     </indexterm>
     <function>lag</function> ( <parameter>value</parameter> <type>anyelement</type>
     <optional>, <parameter>offset</parameter> <type>integer</type>
      <optional>, <parameter>default</parameter> <type>anyelement</type> </optional></optional> )
     <returnvalue>anyelement</returnvalue>
    </para>
    <para>
     Renvoie <parameter>value</parameter> évaluée à la ligne qui se trouve
     à <parameter>offset</parameter> lignes avant la ligne actuelle dans la
     partition&nbsp;; si une telle ligne n'existe pas, renvoie
     <parameter>default</parameter> à la place (qui doit être du même type
     que <parameter>value</parameter>). <parameter>offset</parameter> et
     <parameter>default</parameter> sont évalués suivant la ligne actuelle.
     Par défaut, <parameter>offset</parameter> vaut 1 et
     <parameter>default</parameter> vaut <literal>NULL</literal>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>lead</primary>
     </indexterm>
     <function>lead</function> ( <parameter>value</parameter> <type>anyelement</type>
     <optional>, <parameter>offset</parameter> <type>integer</type>
      <optional>, <parameter>default</parameter> <type>anyelement</type> </optional></optional> )
     <returnvalue>anyelement</returnvalue>
    </para>
    <para>
     Renvoie <parameter>value</parameter> évaluée à la ligne qui se trouve
     à <parameter>offset</parameter> lignes après la ligne actuelle dans la
     partition&nbsp;; si une telle ligne n'existe pas, renvoie
     <parameter>default</parameter> à la place (qui doit être du même type
     que <parameter>value</parameter>). <parameter>offset</parameter> et
     <parameter>default</parameter> sont évalués suivant la ligne actuelle.
     Par défaut, <parameter>offset</parameter> vaut 1 et
     <parameter>default</parameter> vaut <literal>NULL</literal>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>first_value</primary>
     </indexterm>
     <function>first_value</function> ( <parameter>value</parameter> <type>anyelement</type> )
     <returnvalue>anyelement</returnvalue>
    </para>
    <para>
     Renvoie <parameter>value</parameter> évaluée à la première ligne de la
     fenêtre.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>last_value</primary>
     </indexterm>
     <function>last_value</function> ( <parameter>value</parameter> <type>anyelement</type> )
     <returnvalue>anyelement</returnvalue>
    </para>
    <para>
     Renvoie <parameter>value</parameter> évaluée à la dernière ligne de la
     fenêtre.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>nth_value</primary>
     </indexterm>
     <function>nth_value</function> ( <parameter>value</parameter> <type>anyelement</type>, <parameter>n</parameter> <type>integer</type> )
     <returnvalue>anyelement</returnvalue>
    </para>
    <para>
     Renvoie <parameter>value</parameter> évaluée à la ligne qui se trouve
     à la <parameter>n</parameter>-ième ligne de la fenêtre (en comptant à
     partir de 1)&nbsp;; renvoie <literal>NULL</literal> si cette ligne
     n'existe pas.
    </para></entry>
  </row>
 </tbody>
</tgroup>
</table>

<para>
Toutes les fonctions listées dans <xref linkend="functions-window-table"/>
dépendent de l'ordre de tri indiqué par la clause <literal>ORDER
 BY</literal> sur la définition de la fenêtre associée. Les lignes qui ne
sont pas distinctes lors de la seule considération des colonnes
<literal>ORDER BY</literal> sont des <firstterm>peers</firstterm>. Les
quatre fonctions de rang (y compris <function>cume_dist</function>) sont
définies pour qu'elles donnent la même réponse pour toutes les lignes d'un
groupe peer.
</para>

<para>
Notez que les fonctions <function>first_value</function>,
<function>last_value</function> et <function>nth_value</function> ne
prennent en compte que les lignes à l'intérieur d'une
<quote>fenêtre</quote>, qui, par défaut, contient les lignes du début de la
partition jusqu'au dernier peer de la ligne actuelle. Ceci risque de donner
des résultats sans intérêt pour <function>last_value</function> et quelques
fois aussi pour <function>nth_value</function>. Vous pouvez redéfinir la
fenêtre en ajoutant une spécification convenable (<literal>RANGE</literal>,
<literal>ROWS</literal> ou <literal>GROUPS</literal>) à la clause
<literal>OVER</literal>. Voir <xref linkend="syntax-window-functions"/>
pour plus d'informations.
</para>

<para>
Quand une fonction d'agrégat est utilisée comme fonction de fenêtrage, elle
agrège les lignes dans la fenêtre de la ligne courante. Un agrégat utilisé
avec <literal>ORDER BY</literal> et la définition par défaut de la fenêtre
produit un type de comportement du style <quote>somme mouvante</quote>, qui
pourrait être ou pas ce qui est souhaité. Pour obtenir l'agrégat sur la
partition complète, n'utilisez pas <literal>ORDER BY</literal> ou utilisez
<literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED
 FOLLOWING</literal>. Les autres spécifications de fenêtre peuvent être
utilisées pour obtenir d'autres effets.
</para>

<note>
<para>
 Le standard SQL définit une option <literal>RESPECT NULLS</literal> ou
 <literal>IGNORE NULLS</literal> pour les fonctions
 <function>lead</function>, <function>lag</function>,
 <function>first_value</function>, <function>last_value</function> et
 <function>nth_value</function>. Ceci n'est pas couvert dans
 <productname>PostgreSQL</productname>&nbsp;: le comportement est toujours
 identique au comportement par défaut du standard, autrement dit
 <literal>RESPECT NULLS</literal>. De même, les options du standard
 <literal>FROM FIRST</literal> et <literal>FROM LAST</literal> pour
 <function>nth_value</function> ne sont pas supportées&nbsp;: seul le
 comportement par défaut, <literal>FROM FIRST</literal>, l'est. (Vous
 pouvez obtenir le résultat de <literal>FROM LAST</literal> en inversant le
 tri <literal>ORDER BY</literal>.)
</para>
</note>

</sect1>

<sect1 id="functions-subquery">
<title>Expressions de sous-requêtes</title>

<indexterm>
<primary>EXISTS</primary>
</indexterm>

<indexterm>
<primary>IN</primary>
</indexterm>

<indexterm>
<primary>NOT IN</primary>
</indexterm>

<indexterm>
<primary>ANY</primary>
</indexterm>

<indexterm>
<primary>ALL</primary>
</indexterm>

<indexterm>
<primary>SOME</primary>
</indexterm>

<indexterm>
<primary>subquery</primary>
</indexterm>

<para>
Cette section décrit les expressions de sous-requêtes, compatible
<acronym>SQL</acronym>, et disponible dans
<productname>PostgreSQL</productname>. Toutes les formes d'expression
documentées dans cette section renvoient des résultats booléens
(true/false).
</para>

<sect2 id="functions-subquery-exists">
<title><literal>EXISTS</literal></title>

<synopsis>
EXISTS (<replaceable>subquery</replaceable>)
</synopsis>

<para>
 L'argument de <token>EXISTS</token> est une requête
 <command>SELECT</command> arbitraire ou une
 <firstterm>sous-requête</firstterm>. La sous-requête est évaluée pour
 déterminer si elle renvoie des lignes. Si elle renvoie au moins une ligne,
 le résultat de <token>EXISTS</token> est <quote>true</quote>&nbsp;; si la
 sous-requête ne renvoie aucune ligne, le résultat de <token>EXISTS</token>
 est <quote>false</quote>.
</para>

<para>
 La sous-requête peut faire référence à des variables provenant de la
 requête englobante, qui agira comme constantes lors de toute évaluation de
 la sous-requête.
</para>

<para>
 La sous-requête s'exécutera seulement suffisamment longtemps pour
 déterminer qu'au moins une ligne sera renvoyée. Elle ne sera donc pas
 exécuté entièrement. Il est déconseillé d'écrire une sous-requête qui a des
 effets secondaires (tels qu'appeler des fonctions de séquence)&nbsp; le
 fait que les effets secondaires surviennent n'est pas prévisible.
</para>

<para>
 Comme le résultat dépend seulement du fait que des lignes sont renvoyées ou
 pas, et non pas sur le contenu de ces lignes, la liste en sortie de la
 sous-requête n'a pas d'importance. Une convention commune de codage est
 d'écrire tous les tests <literal>EXISTS</literal> sous la forme
 <literal>EXISTS(SELECT 1 WHERE ...)</literal>. Il existe néanmoins des
 exceptions à cette règle, comme les sous-requêtes qui utilisent
 <token>INTERSECT</token>.
</para>

<para>
 Cet exemple simple est comme une jointure interne sur
 <literal>col2</literal>, mais il produit au plus une ligne pour chaque
 ligne de <literal>tab1</literal>, même s'il existe plus lignes
 correspondantes dans <literal>tab2</literal>&nbsp;:
 <screen>
SELECT col1
FROM tab1
WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);
 </screen>
</para>
</sect2>

<sect2 id="functions-subquery-in">
<title><literal>IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>

<para>
 Le côté droit est une sous-requête entre parenthèses, qui doit renvoyer
 exactement une ligne. L'expression côté gauche est évaluée et comparée à
 chaque ligne du résultat de la sous-requête. Le résultat de
 <token>IN</token> vaut <quote>true</quote> si au moins une ligne identique
 est trouvée dans la sous-requête. Le résultat est <quote>false</quote> si
 aucune ligne identique n'a été trouvée (y compris dans le cas où la
 sous-requête ne renvoit aucune ligne).
</para>

<para>
 Notez que si l'expression côté gauche renvoie NULL ou s'il y a aucune
 valeur identique côté droit et au moins une ligne renvoyant NULL côté
 droit, le résultat de la construction <token>IN</token> sera NULL, et non
 pas false. Ceci est en accord avec les règles normales du SQL pour les
 combinaisons booléennes de valeurs NULL.
</para>

<para>
 Comme avec <token>EXISTS</token>, il est déconseillé de supposer que la
 sous-requête sera complètement évaluée.
</para>

<synopsis>
<replaceable>row_constructor</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>

<para>
 Le côté gauche de cette syntaxe de <token>IN</token> est un constructeur de
 ligne, comme décrit dans <xref linkend="sql-syntax-row-constructors"/>. Le
 côté droit est une sous-requête entre parenthèses, qui doit renvoyer
 exactement autant de colonnes qu'il y a d'expressions côté gauche. Les
 expressions du côté gauche sont évaluées et comparées, ligne par ligne, à
 chaque ligne du résultat de la sous-requête. Le résultat de
 <token>IN</token> vaut <quote>true</quote> si au moins une ligne identique
 est trouvée dans la sous-requête. Le résultat est <quote>false</quote> si
 aucune ligne identique n'est trouvée (y compris le cas où la sous-requête
 ne renvoie aucune ligne).
</para>

<para>
 Comme d'habitude, les valeurs NULL dans les lignes sont combinées par les
 règles habituelles des expressions SQL booléennes. Deux lignes sont
 considérées égales si tous leurs membres correspondance sont non NULL et
 égaux&nbsp;; les lignes ne sont pas égales si au moins un membre
 correspondant est non NULL et différent&nbsp;; sinon le résultat de cette
 comparaison de ligne est inconnue (NULL). Si tous les résultats ligne par
 ligne sont soit différents soit NULL, avec au moins un NULL, alors le
 résultat de <token>IN</token> est NULL.
</para>
</sect2>

<sect2 id="functions-subquery-notin">
<title><literal>NOT IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>

<para>
 Le côté droit est une sous-requête entre parenthèses, qui doit renvoyer
 exactement une colonne. L'expression côté gauche est évaluée et comparée à
 chaque ligne du résultat de la sous-requête. Le résultat de <token>NOT
  IN</token> vaut <quote>true</quote> si seulement des lignes différentes
 sont trouvées dans la sous-requête (y compris dans le cas où la
 sous-requête ne renvoie pas de lignes). Le résultat vaut
 <quote>false</quote> si au moins une ligne identique est trouvée.
</para>

<para>
 Notez que si l'expression côté gauche renvoie NULL ou s'il n'existe pas de
 valeurs identiques côté droit et qu'au moins une ligne côté droit renvoie
 NULL, le résultat de la construction <token>NOT IN</token> sera NULL, et
 non pas true. Ceci est en accord avec les règles standards du SQL pour les
 combinaisons booléennes de valeurs NULL.
</para>

<para>
 Tout comme <token>EXISTS</token>, il est déconseillé de supposer que la
 sous-requête sera totalement évaluée.
</para>

<synopsis>
<replaceable>row_constructor</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>

<para>
 Le côté gauche de cette syntaxe pour <token>NOT IN</token> est un
 constructeur de lignes, comme décrit dans <xref
 linkend="sql-syntax-row-constructors"/>. Le côté droit est une sous-requête
 entre parenthèses, qui doit renvoyer exactement autant de colonnes qu'il y
 a d'expressions du côté gauche. Les expressions du côté gauche sont
 évaluées et comparées ligne par ligne pour chaque ligne du résultat de la
 sous-requête. Le résultat de <token>NOT IN</token> vaut <quote>true</quote>
 si seules des lignes différentes sont trouvées dans la sous-requête (y
 compris dans le cas où la sous-requête ne renvoie aucune ligne). Le
 résultat vaut <quote>false</quote> si aucune ligne identique n'est trouvée.
</para>

<para>
 Comme d'habitude, les valeurs NULL dans les lignes sont combinées d'après
 les règles standards en SQL pour les expressions booléennes. Deux lignes
 sont considérées identiques si tous leurs membres correspondant sont non
 NULL et égaux&nbsp;; les lignes sont différentes si au moins un membre
 correspondant est non NULL et différent&nbsp;; sinon le résultat de cette
 comparaison de lignes est inconnu (NULL). Si tous les résultats ligne par
 ligne sont soit différentes soit NULL, avec au moins un NULL, alors le
 résultat de <token>NOT IN</token> is NULL.
</para>
</sect2>

<sect2 id="functions-subquery-any-some">
<title><literal>ANY</literal>/<literal>SOME</literal></title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>

<para>
 Le côté droit est une sous-requête entre parenthèses, qui doit renvoyer
 exactement une colonne. L'expression côté gauche est évaluée et comparée à
 chaque ligne du résultat de la sous-requête en utilisant l'opérateur
 <replaceable>operator</replaceable> indiquée, qui doit renvoyer un résultat
 booléen. Le résultat de <token>ANY</token> vaut <quote>true</quote> si au
 moins une valeur true est obtenue dans le résultat. Le résultat vaut
 <quote>false</quote> si aucun résultat true n'est trouvé (y compris dans le
 cas où la sous-requête ne renvoie aucune ligne).
</para>

<para>
 <token>SOME</token> est un synonyme pour <token>ANY</token>.
 <token>IN</token> est équivalent à <literal>= ANY</literal>.
</para>

<para>
 Notez qe s'il n'y a pas de succès et qu'au moins une ligne côté droit
 renvoie NULL comme résultat de l'opérateur, le résultat de la construction
 <token>ANY</token> sera NULL, et non pas false. Ceci est en accord avec les
 règles SQL habituelles sur les combinaisons booléennes de valeurs NULL.
</para>

<para>
 Comme avec <token>EXISTS</token>, il est déconseillé de supposer que la
 sous-requête sera totalement évaluée.
</para>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>

<para>
 Le côté gauche de cette syntaxe de <token>ANY</token> est un constructeur
 de lignes, comme décrit dans <xref linkend="sql-syntax-row-constructors"/>.
 Le côté droit est une sous-requête entre parenthèses, qui doit renvoyer
 autant de colonnes qu'il y a d'expressions sur la ligne côté gauche. Les
 expressions côté gauche sont évaluées et comparées ligne par ligne pour
 chaque ligne du résultat de la sous-requête, en utilisant l'opérateur
 <replaceable>operator</replaceable> indiqué. Le résultat de
 <token>ANY</token> vaut <quote>true</quote> si la comparaison renvoie true
 pour au moins une ligne de la sous-requête. Le résultat vaut
 <quote>false</quote> si la comparaison renvoie false pour chaque ligne de
 la sous-requête (y compris dans le cas où la sous-requête ne renvoie aucune
 ligne). Le résultat est NULL si aucune comparaison avec une ligne de la
 sous-requête ne renvoie true, et qu'au mpoins une comparaison renvoie NULL.
</para>

<para>
 Voir <xref linkend="row-wise-comparison"/> pour les détails sur la
 signification de la comparaison d'un constructeur de ligne.
</para>
</sect2>

<sect2 id="functions-subquery-all">
<title><literal>ALL</literal></title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>

<para>
 Le côté droit est une sous-requête entre parenthèses, qui doit renvoyer
 exactement une colonne. L'expression côté gauche est évaluée, et comparée à
 chaque ligne du résultat de la sous-requête en utilisant l'opérateur
 <replaceable>operator</replaceable> indiqué, qui doit renvoyer un résultat
 booléen. Le résultat de <token>ALL</token> vaut <quote>true</quote> si
 toutes les lignes renvoient true (y compris dans le cas où la sous-requête
 ne renvoie aucune ligne). Le résultat vaut <quote>false</quote> si un
 résultat false est trouvé. Le résultat est NULL si aucune comparaison avec
 une ligne de la sous-requête renvoie false et au moins une comparaison
 renvoie NULL.
</para>

<para>
 <token>NOT IN</token> est équivalent à <literal>&lt;&gt; ALL</literal>.
</para>

<para>
 Comme avec <token>EXISTS</token>, il est déconseillé de supposer que la
 sous-requête sera totalement évaluée.
</para>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>

<para>
 Le côté gauche de cette forme de <token>ALL</token> est un constructeur de
 lignes, comme décrit dans <xref linkend="sql-syntax-row-constructors"/>. Le
 côté droit est une sous-requête entre parenthèses, qui doit renvoyer
 exactement autant de colonnes qu'il y a d'expressions dans la ligne côté
 gauche. Les expressions côté gauche sont évaluées et comparées ligne par
 ligne à chaque ligne du résultat de la sous-requête, en utilisant
 l'opérateur <replaceable>operator</replaceable> donné. Le résultat de
 <token>ALL</token> vaut <quote>true</quote> si la comparaison renvoie true
 pour toutes les lignes de la sous-requête (y compris le cas où la
 sous-requête ne renvoie aucune ligne). Le résultat est <quote>false</quote>
 si la comparaison renvoie false pour une ligne de la sous-requête. Le
 résultat est NULL si aucune comparaison avec une ligne de la sous-requête
 renvoie false et au moins une comparaison renvoie NULL.
</para>

<para>
 Voir <xref linkend="row-wise-comparison"/> pour les détails sur la
 signification d'une comparaison de constructeur de ligne.
</para>
</sect2>

<sect2>
<title>Comparaison de ligne simple</title>

<indexterm zone="functions-subquery">
 <primary>comparaison</primary>
 <secondary>ligne résultat de la sous-requête</secondary>
</indexterm>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> (<replaceable>subquery</replaceable>)
</synopsis>

<para>
 Le côté gauche est un constructeur de lignes, comme décrit dans <xref
 linkend="sql-syntax-row-constructors"/>. Le côté droit est une sous-requête
 entre parenthèses, qui doit renvoyer exactement autant de colonnes qu'il y
 a d'expressions dans la ligne côté gauche. De plus, la sous-requête ne peut
 pas renvoyer plus d'une ligne. (Si elle renvoie zéro ligne, le résultat est
 pris pour NULL.) Le côté gauche est évalué et comparé ligne par ligne à la
 ligne seule du résultat de la sous-requête.
</para>

<para>
 See <xref linkend="row-wise-comparison"/> for details about the meaning
 of a row constructor comparison.
</para>
</sect2>
</sect1>


<sect1 id="functions-comparisons">
<title>Comparaisons de ligne et de tableau</title>

<indexterm>
<primary>IN</primary>
</indexterm>

<indexterm>
<primary>NOT IN</primary>
</indexterm>

<indexterm>
<primary>ANY</primary>
</indexterm>

<indexterm>
<primary>ALL</primary>
</indexterm>

<indexterm>
<primary>SOME</primary>
</indexterm>

<indexterm>
<primary>type composite</primary>
<secondary>comparaison</secondary>
</indexterm>

<indexterm>
<primary>comparaison de ligne entière</primary>
</indexterm>

<indexterm>
<primary>comparaison</primary>
<secondary>type composite</secondary>
</indexterm>

<indexterm>
<primary>comparaison</primary>
<secondary>constructeur de ligne</secondary>
</indexterm>

<indexterm>
<primary>IS DISTINCT FROM</primary>
</indexterm>

<indexterm>
<primary>IS NOT DISTINCT FROM</primary>
</indexterm>

<para>
Cette section décrit plusieurs constructions spécialisées pour réaliser
plusieurs comparaisons entre des groupes de valeurs. Ces formes sont
syntaxiquement en relation avec les formes de sous-requêtes de la section
précédente, mais n'impliquent pas de sous-requêtes. Les formes qui
impliquent des sous-expressions de tableau sont des extensions
<productname>PostgreSQL</productname>&nbsp;; le reste est compatible avec
la norme <acronym>SQL</acronym>. Toutes les formes d'expression documentées
dans cette section renvoient des résultats booléens (true/false).
</para>

<sect2 id="functions-comparisons-in-scalar">
<title><literal>IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

<para>
 Le côté droit est une liste entre parenthèses d'expressions scalaires. Le
 résultat est <quote>true</quote> si le résultat de l'expression côté gauche
 est égal à une des expressions côté droit. Cette notation est un raccourci
 pour

 <synopsis>
<replaceable>expression</replaceable> = <replaceable>value1</replaceable>
OR
<replaceable>expression</replaceable> = <replaceable>value2</replaceable>
OR
...
 </synopsis>
</para>

<para>
 Notez que si l'expression côté gauche renvoie NULL ou s'il n'existe pas de
 valeurs identiques côté droit et qu'au moins une expression côté droit
 renvoie NULL, le résultat de la construction <token>IN</token> sera NULL,
 et non pas false. Ceci est en accord avec les règles SQL habituelles pour
 les combinaisons booléennes de valeurs NULL.
</para>
</sect2>

<sect2>
<title><literal>NOT IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

<para>
 Le côté droit est une liste entre parenthèses d'expressions scalaires. Le
 résultat est <quote>true</quote> si le résultat de l'expression côté gauche
 est différent à toutes les expressions côté droit. Cette notation est un
 raccourci pour

 <synopsis>
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value1</replaceable>
AND
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value2</replaceable>
AND
...
 </synopsis>
</para>

<para>
 Notez que si l'expression côté gauche renvoie NULL ou s'il n'existe pas de
 valeurs identiques côté droit et qu'au moins une expression côté droit
 renvoie NULL, le résultat de la construction <token>NOT IN</token> sera
 NULL, et non pas true comme on pourrait s'y attendre. Ceci est en accord
 avec les règles SQL habituelles pour les combinaisons booléennes de valeurs
 NULL.
</para>

<tip>
 <para>
  <literal>x NOT IN y</literal> est équivalent à <literal>NOT (x IN
   y)</literal> dans tous les cas. Néanmoins, les valeurs NULL risquent bien
  plus souvent de tromper le novice lorsqu'il travaille avec <token>NOT
   IN</token> que quand il travaille avec <token>IN</token>. Il est préférable
  d'exprimer votre condition de façon positive si possible.
 </para>
</tip>
</sect2>

<sect2>
<title><literal>ANY</literal>/<literal>SOME</literal> (array)</title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>array expression</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>array expression</replaceable>)
</synopsis>

<para>
 Le côté droit est une expression entre parenthèses, qui doit renvoyer une
 valeur de type tableau. L'expression côté gauche est évaluée et comparée à
 chaque élément du tableau en utilisant l'opérateur
 <replaceable>operator</replaceable> indiqué, qui doit renvoyer un résultat
 booléen. Le résultat de <token>ANY</token> vaut <quote>true</quote> si
 aucun résultat true n'est obtenu. Le résultat vaut <quote>false</quote> si
 aucun résultat true n'est trouvé (y compris dans le cas où le tableau a
 zéro élément).
</para>

<para>
 Si l'expression de tableau renvoie un tableau NULL, le résultat de
 <token>ANY</token> sera NULL. Si l'expression côté gauche renvoie NULL, le
 résultat de <token>ANY</token> est habituellement NULL (bien qu'un
 opérateur de comparaison non strict pourrait renvoyer un résultat
 différent). De plus, si le tableau côté droit contient des éléments NULL et
 qu'aucun résultat de la comparaison ne renvoie true, le résultat d'
 <token>ANY</token> sera NULL, et non pas false (encore une fois, en
 supposant un opérateur de comparaison strict). Ceci est en accord avec les
 règles SQL habituelles pour la combinaison booléenne de valeurs NULL.
</para>

<para>
 <token>SOME</token> est un synonyme pour <token>ANY</token>.
</para>
</sect2>

<sect2>
<title><literal>ALL</literal> (array)</title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>array expression</replaceable>)
</synopsis>

<para>
 Le côté droit est une expression entre parenthèses, qui doit renvoyer une
 valeur de type tableau. L'expression côté gauche est évaluée et comparée à
 chaque élément du tableau en utilisant l'opérateur
 <replaceable>operator</replaceable> indiqué, qui doit renvoyer un résultat
 booléen. Le résultat de <token>ALL</token> vaut <quote>true</quote> si
 toutes les comparaisons ramènent true (y compris dans le cas où le tableau
 a zéro élément). Le résultat vaut <quote>false</quote> si au moins un
 résultat false est trouvé.
</para>

<para>
 Si l'expression de tableau renvoie un tableau NULL, le résultat de
 <token>ALL</token> sera NULL. Si l'expression côté gauche renvoie NULL, le
 résultat de <token>ALL</token> est habituellement NULL (bien qu'un
 opérateur de comparaison non strict pourrait renvoyer un résultat
 différent). De plus, si le tableau côté droit contient au moins un élément
 NULL et qu'aucun résultat de la comparaison ne renvoie false, le résultat
 de <token>ALL</token> sera NULL, et non pas true (encore une fois, en
 supposant un opérateur de comparaison strict). Ceci est en accord avec les
 règles SQL habituelles pour la combinaison booléenne de valeurs NULL.
</para>
</sect2>

<sect2 id="row-wise-comparison">
<title>Comparaison de constructeur de lignes</title>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> <replaceable>row_constructor</replaceable>
</synopsis>

<para>
 Chaque côté est un constructeur de lignes, comme décrit dans <xref
 linkend="sql-syntax-row-constructors"/>. Les deux valeurs de lignes doivent
 avoir le même nombre de champs. Chaque côté est évalué et est comparé ligne
 par ligne. Les comparaisons de constructeur de lignes sont autorisées quand
 l'opérateur<replaceable>operator</replaceable> est
 <literal>=</literal>,
 <literal>&lt;&gt;</literal>,
 <literal>&lt;</literal>,
 <literal>&lt;=</literal>,
 <literal>&gt;</literal> ou
 <literal>&gt;=</literal>.
 Chaque élément de ligne doit être d'un type disposant d'une classe
 d'opérateur B-tree par défaut. Dans le cas contraire, la tentative de
 comparaison renverra une erreur.
</para>

<note>
 <para>
  Les erreurs relatives au nombre ou aux types des éléments ne surviennent
  pas si la comparaison est résolue en utilisant les premières colonnes.
 </para>
</note>

<para>
 Les cas <literal>=</literal> et <literal>&lt;&gt;</literal> fonctionnent
 légèrement différemment des autres. Les deux lignes sont considérées égales
 si tous leurs membres correspondant sont non NULL et égaux&nbsp;; les
 lignes sont différentes si un des membres correspondant est non NULL et
 différent&nbsp;; sinon le résultat de la comparaison est inconnu (NULL).
</para>

<para>
 Pour les cas <literal>&lt;</literal>, <literal>&lt;=</literal>,
 <literal>&gt;</literal> et <literal>&gt;=</literal>, les éléments de ligne
 sont comparés de gauche à droite, en s'arrêtant  dès qu'une paire
 d'éléments différents ou NULL est trouvée. Si un des éléments est NULL, le
 résultat de la comparaison est inconnu (NULL)&nbsp;,; sinon la comparaison
 de cette paire d'éléments détermine le résultat. Par exemple,
 <literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</literal> renvoie true, et non pas
 NULL, parce que la troisième paire d'éléments n'est pas considérée.
</para>

<note>
 <para>
  Avant <productname>PostgreSQL</productname> 8.2, les cas
  <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal>
  et <literal>&gt;=</literal> n'étaient pas gérés par la spécification SQL.
  Une comparaison comme <literal>ROW(a,b) &lt; ROW(c,d)</literal> était
  implémentée comme <literal>a &lt; c AND b &lt; d</literal> alors que le
  comportement correct est équivalent à <literal>a &lt; c OR (a = c AND b
   &lt; d)</literal>.
 </para>
</note>

<synopsis>
<replaceable>row_constructor</replaceable> IS DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>

<para>
 Cette construction est similaire à une comparaison de ligne
 <literal>&lt;&gt;</literal> mais elle ne renvoie pas NULL pour des entrées
 NULL. À la place, toute valeur NULL est considérée différente (distincte
 de) toute valeur non NULL, et deux valeurs NULL sont considérées égales
 (non distinctes). De ce fait, le résultat sera soit true, soit false, mais
 jamais NULL.
</para>

<synopsis>
<replaceable>row_constructor</replaceable> IS NOT DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>

<para>
 Cette construction est similaire à une comparaison de ligne
 <literal>=</literal> mais elle ne renvoie pas NULL pour des entrées NULL. À
 la place, toute valeur NULL est considérée différente (distincte de) toute
 valeur non NULL, et deux valeurs NULL sont considérés égales (non
 distinctes). De ce fait, le résultat sera toujours soit true soit false,
 mais jamais NULL.
</para>

</sect2>

<sect2 id="composite-type-comparison">
<title>Comparaison de type composite</title>

<synopsis>
<replaceable>record</replaceable> <replaceable>operator</replaceable> <replaceable>record</replaceable>
</synopsis>

<para>
 La spécification SQL requiert que la comparaison de lignes renvoie NULL si
 le résultat depend de la comparaison de deux valeurs NULL, ou d'un NULL et
 d'un non NULL. <productname>PostgreSQL</productname> le fait seulement lors
 de la comparaison des résultats de deux constructeurs de ligne (comme dans
 <xref linkend="row-wise-comparison"/>) ou lors de la comparaison d'un
 constructeur de ligne et de la sortie d'une sous-requête (comme dans <xref
 linkend="functions-subquery"/>). Dans les autres contextes où les valeurs
 de deux types composites sont comparées, deux valeurs NULL sont considérées
 égales et un NULL est considéré plus grand qu'un non NULL. Ceci est
 nécessaire pour avoir un tri et une indexation cohérentes pour les types
 composites.
</para>

<para>
 Chaque côté est évalué, puis comparé ligne par ligne. Les comparaisons de
 type composite sont autorisées quand l'opérateur
 <replaceable>operator</replaceable> vaut
 <literal>=</literal>,
 <literal>&lt;&gt;</literal>,
 <literal>&lt;</literal>,
 <literal>&lt;=</literal>,
 <literal>&gt;</literal> ou
 <literal>&gt;=</literal>,
 ou a une sémantique similaire à ces derniers. (Pour être précis, un
 opérateur peut être un opérateur de comparaison de ligne s'il est membre
 d'une classe d'opérateur B-tree, ou s'il est la négation du membre
 <literal>=</literal> d'une classe d'opérateur B-tree.) Le comportement par
 défaut des opérateurs ci-dessus est identique à celui de <literal>IS [ NOT
  ] DISTINCT FROM</literal> pour les constructeurs de lignes (voir <xref
 linkend="row-wise-comparison"/>).
</para>

<para>
 Pour supporter la comparaison des lignes qui incluent des éléments sans une
 classe d'opérateur B-tree par défaut, les opérateurs suivants sont définis
 pour la comparaison de type composite&nbsp;:
 <literal>*=</literal>,
 <literal>*&lt;&gt;</literal>,
 <literal>*&lt;</literal>,
 <literal>*&lt;=</literal>,
 <literal>*&gt;</literal> et
 <literal>*&gt;=</literal>.
 Ces opérateurs comparent la représentation binaire interne de deux lignes.
 Les deux lignes peuvent avoir une représentation binaire différente même si
 la comparaison des deux lignes avec l'opérateur d'égalité est vraie.
 L'ordre des lignes sous ces opérateurs de comparaison est déterministique,
 mais sans sens. Ces opérateurs sont utilisés en interne pour les vues
 matérialisées et peuvent se révéler utile pour d'autres buts spécialisés
 tels que la réplication et la déduplication de B-Tree (voir <xref
 linkend="btree-deduplication"/>). Ils n'ont pas pour but d'être utilisés
 dans l'écriture de requêtes.
</para>
</sect2>
</sect1>

<sect1 id="functions-srf">
<title>Fonctions renvoyant des ensembles</title>

<indexterm zone="functions-srf">
<primary>fonctions renvoyant des ensembles</primary>
<secondary>fonctions</secondary>
</indexterm>

<para>
Cette section décrit les fonctions qui renvoient potentiellement plus d'une
ligne. Les fonctions les plus fréquemment utilisées de ce type sont celles
générant des séries, comme détaillées dans <xref
linkend="functions-srf-series"/> et <xref
linkend="functions-srf-subscripts"/>. D'autres, plus spécialisées, sont
décrites ailleurs dans ce manuel. Voir <xref
linkend="queries-tablefunctions"/> pour des façons de combiner plusieurs
fonctions renvoyant des ensembles.
</para>

<table id="functions-srf-series">
<title>Fonctions générant des séries</title>
<tgroup cols="1">
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para></entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>generate_series</primary>
     </indexterm>
     <function>generate_series</function> ( <parameter>start</parameter> <type>integer</type>, <parameter>stop</parameter> <type>integer</type> <optional>, <parameter>step</parameter> <type>integer</type> </optional> )
     <returnvalue>setof integer</returnvalue>
    </para>
    <para role="func_signature">
     <function>generate_series</function> ( <parameter>start</parameter> <type>bigint</type>, <parameter>stop</parameter> <type>bigint</type> <optional>, <parameter>step</parameter> <type>bigint</type> </optional> )
     <returnvalue>setof bigint</returnvalue>
    </para>
    <para role="func_signature">
     <function>generate_series</function> ( <parameter>start</parameter> <type>numeric</type>, <parameter>stop</parameter> <type>numeric</type> <optional>, <parameter>step</parameter> <type>numeric</type> </optional> )
     <returnvalue>setof numeric</returnvalue>
    </para>
    <para>
     Génère une série de valeurs à partir de <parameter>start</parameter>
     jusqu'à <parameter>stop</parameter>, avec un pas de
     <parameter>step</parameter>. <parameter>step</parameter> a 1 pour
     valeur par défaut.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <function>generate_series</function> ( <parameter>start</parameter> <type>timestamp</type>, <parameter>stop</parameter> <type>timestamp</type>, <parameter>step</parameter> <type>interval</type> )
     <returnvalue>setof timestamp</returnvalue>
    </para>
    <para role="func_signature">
     <function>generate_series</function> ( <parameter>start</parameter> <type>timestamp with time zone</type>, <parameter>stop</parameter> <type>timestamp with time zone</type>, <parameter>step</parameter> <type>interval</type> )
     <returnvalue>setof timestamp with time zone</returnvalue>
    </para>
    <para>
     Génère une série de valeurs à partir de <parameter>start</parameter>
     jusqu'à <parameter>stop</parameter>, avec un pas de
     <parameter>step</parameter>.
    </para></entry>
  </row>
 </tbody>
</tgroup>
</table>

<para>
Quand <parameter>step</parameter> est positif, aucune ligne n'est renvoyée si
<parameter>start</parameter> est supérieure à <parameter>stop</parameter>.
Par contre, quand <parameter>step</parameter> est négatif negative, aucune ligne n'est renvoyée
si <parameter>start</parameter> est inférieur à <parameter>stop</parameter>.
Aucune ligne n'est renvoyé si au moins une entrée est <literal>NULL</literal>.
Si <parameter>step</parameter> vaut zéro, c'est considéré comme une erreur.
Voici quelques exemples&nbsp;:
<programlisting>
SELECT * FROM generate_series(2,4);
 generate_series
-----------------
               2
               3
               4
(3 rows)

SELECT * FROM generate_series(5,1,-2);
 generate_series
-----------------
               5
               3
               1
(3 rows)

SELECT * FROM generate_series(4,3);
 generate_series
-----------------
(0 rows)

SELECT generate_series(1.1, 4, 1.3);
 generate_series
-----------------
             1.1
             2.4
             3.7
(3 rows)

-- cet exemple se base sur l'opérateur date-plus-integer :
SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);
   dates
------------
 2004-02-05
 2004-02-12
 2004-02-19
(3 rows)

SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,
                              '2008-03-04 12:00', '10 hours');
   generate_series
---------------------
 2008-03-01 00:00:00
 2008-03-01 10:00:00
 2008-03-01 20:00:00
 2008-03-02 06:00:00
 2008-03-02 16:00:00
 2008-03-03 02:00:00
 2008-03-03 12:00:00
 2008-03-03 22:00:00
 2008-03-04 08:00:00
(9 rows)
</programlisting>
</para>

<table id="functions-srf-subscripts">
<title>Fonctions générant des indices</title>
<tgroup cols="1">
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para></entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>generate_subscripts</primary>
     </indexterm>
     <function>generate_subscripts</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>dim</parameter> <type>integer</type> )
     <returnvalue>setof integer</returnvalue>
    </para>
    <para>
     Génère une série comprenant les indices valides de la
     <parameter>dim</parameter>-ème dimension du tableau fourni.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <function>generate_subscripts</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>dim</parameter> <type>integer</type>,  <parameter>reverse</parameter> <type>boolean</type> )
     <returnvalue>setof integer</returnvalue>
    </para>
    <para>
     Génère une série comprenant les indices valides de la
     <parameter>dim</parameter>-ième dimension du tableau fourni. Quand
     <parameter>reverse</parameter> vaut true, renvoie la série dans
     l'ordre inverse.
    </para></entry>
  </row>
 </tbody>
</tgroup>
</table>

<para>
<function>generate_subscripts</function> est une fonction de facilité qui génère
l'ensemble d'indices valides pour la dimension donnée pour le tableau.
Aucune ligne n'est renvoyée pour les tableaux qui n'ont pas la dimension
demandée ou si une des lignes vaut <literal>NULL</literal>.
Voici quelques exemples&nbsp;:
<programlisting>
-- utilisation basique :
SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;
 s
---
 1
 2
 3
 4
(4 rows)

-- à partir d'un tableau, l'indice et la valeur indicée
-- nécessite une sous-requête :
SELECT * FROM arrays;
         a
--------------------
 {-1,-2}
 {100,200,300}
(2 rows)

SELECT a AS array, s AS subscript, a[s] AS value
FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;
     array     | subscript | value
---------------+-----------+-------
 {-1,-2}       |         1 |    -1
 {-1,-2}       |         2 |    -2
 {100,200,300} |         1 |   100
 {100,200,300} |         2 |   200
 {100,200,300} |         3 |   300
(5 rows)

-- déballer un tableau 2D :
CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$
select $1[i][j]
   from generate_subscripts($1,1) g1(i),
        generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION
SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);
 unnest2
---------
       1
       2
       3
       4
(4 rows)
</programlisting>
</para>

<indexterm>
<primary>ordinality</primary>
</indexterm>

<para>
Quand une fonction dans la clause <literal>FROM</literal> a pour suffixe
<literal>WITH ORDINALITY</literal>, une colonne <type>bigint</type> est
ajoutée aux colonnes en sortie de la fonction, commençant à 1 et
s'incrémentant de 1 pour chaque ligne de la sortie de la fonction. Ceci est
plus utile dans le cas de fonctions renvoyant des ensembles comme
<function>unnest()</function>.

<programlisting>
-- fonction renvoyant un ensemble WITH ORDINALITY:
SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);
       ls        | n
-----------------+----
 pg_serial       |  1
 pg_twophase     |  2
 postmaster.opts |  3
 pg_notify       |  4
 postgresql.conf |  5
 pg_tblspc       |  6
 logfile         |  7
 base            |  8
 postmaster.pid  |  9
 pg_ident.conf   | 10
 global          | 11
 pg_xact         | 12
 pg_snapshots    | 13
 pg_multixact    | 14
 PG_VERSION      | 15
 pg_wal          | 16
 pg_hba.conf     | 17
 pg_stat_tmp     | 18
 pg_subtrans     | 19
(19 rows)
</programlisting>
</para>

</sect1>

<sect1 id="functions-info">
<title>Fonctions et opérateurs d'information sur le système</title>

<para>
<xref linkend="functions-info-session-table"/> montre différentes fonctions
pour extraire des informations sur les sessions et le système.
</para>

<para>
En plus des fonctions listées dans cette section, il existe plusieurs
fonctions relatives au système de statistiques qui fournissent aussi des
informations sur le système. Voir <xref linkend="monitoring-stats-views"/>
pour plus d'informations.
</para>

<table id="functions-info-session-table">
<title>Fonctions d'information sur la session</title>
<tgroup cols="1">
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para></entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>current_catalog</primary>
     </indexterm>
     <function>current_catalog</function>
     <returnvalue>name</returnvalue>
    </para>
    <para role="func_signature">
     <indexterm>
      <primary>current_database</primary>
     </indexterm>
     <function>current_database</function> ()
     <returnvalue>name</returnvalue>
    </para>
    <para>
     Renvoie le nom de la base actuelle. (Les bases sont appelées des
     <quote>catalogues</quote> dans le standard SQL, donc
     <function>current_catalog</function> est le terme du standard.)
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>current_query</primary>
     </indexterm>
     <function>current_query</function> ()
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Renvoie le texte de la requête en cours d'exécution telle qu'elle a
     été envoyée par le client (elle pourrait donc contenir plus d'une
     requête).
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>current_role</primary>
     </indexterm>
     <function>current_role</function>
     <returnvalue>name</returnvalue>
    </para>
    <para>
     Équivalent à <function>current_user</function>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>current_schema</primary>
     </indexterm>
     <indexterm>
      <primary>schema</primary>
      <secondary>current</secondary>
     </indexterm>
     <function>current_schema</function>
     <returnvalue>name</returnvalue>
    </para>
    <para role="func_signature">
     <function>current_schema</function> ()
     <returnvalue>name</returnvalue>
    </para>
    <para>
     Renvoie le nom du premier schéma dans le chemin de recherche (ou une
     valeur NULL si le chemin de recherche est vide). C'est le schéma qui
     sera utilisé par toute création de tables ou d'autres objets nommés si
     un schéma cible n'est pas précisé.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>current_schemas</primary>
     </indexterm>
     <indexterm>
      <primary>search path</primary>
      <secondary>current</secondary>
     </indexterm>
     <function>current_schemas</function> ( <parameter>include_implicit</parameter> <type>boolean</type> )
     <returnvalue>name[]</returnvalue>
    </para>
    <para>
     Renvoie un tableau de noms pour tous les schémas présents dans le
     chemin de recherche, dans leur ordre de priorité. (Les éléments dans
     le paramètre <xref linkend="guc-search-path"/> ne correspondant pas à
     des objets existants et cherchables sont omis.) Si l'argument booléen
     vaut <literal>true</literal>, alors les schémas systèmes implicites,
     tels que <literal>pg_catalog</literal> sont inclus dans le résultat.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>current_user</primary>
     </indexterm>
     <indexterm>
      <primary>user</primary>
      <secondary>current</secondary>
     </indexterm>
     <function>current_user</function>
     <returnvalue>name</returnvalue>
    </para>
    <para>
     Renvoie le nom de l'utilisateur dans le contexte d'exécution actuel.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>inet_client_addr</primary>
     </indexterm>
     <function>inet_client_addr</function> ()
     <returnvalue>inet</returnvalue>
    </para>
    <para>
     Renvoie l'adresse IP du client actuel ou <literal>NULL</literal> si la
     connexion actuelle a été réalisée via une socket de domaine Unix.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>inet_client_port</primary>
     </indexterm>
     <function>inet_client_port</function> ()
     <returnvalue>integer</returnvalue>
    </para>
    <para>
     Renvoie le numéro de port IP du client actuel, ou
     <literal>NULL</literal> si la connexion actuelle a été réalisée via
     une socket de domaine Unix.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>inet_server_addr</primary>
     </indexterm>
     <function>inet_server_addr</function> ()
     <returnvalue>inet</returnvalue>
    </para>
    <para>
     Renvoie l'adresse IP par laquelle le serveur a accepté la connexion
     actuelle, ou <literal>NULL</literal> si la connexion actuelle a été
     réalisée via une socket de domaine Unix.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>inet_server_port</primary>
     </indexterm>
     <function>inet_server_port</function> ()
     <returnvalue>integer</returnvalue>
    </para>
    <para>
     Renvoie le numéro de port IP par lequel le serveur a accepté la
     connexion actuelle, ou <literal>NULL</literal> si la connexion
     actuelle a été réalisée via une socket de domaine Unix.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_backend_pid</primary>
     </indexterm>
     <function>pg_backend_pid</function> ()
     <returnvalue>integer</returnvalue>
    </para>
    <para>
     Renvoie l'identifiant de processus du processus serveur attaché à la
     session actuelle.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_blocking_pids</primary>
     </indexterm>
     <function>pg_blocking_pids</function> ( <type>integer</type> )
     <returnvalue>integer[]</returnvalue>
    </para>
    <para>
     Renvoie un tableau d'identifiants de processus des sessions bloquant
     l'accès à un verrou pour le processus serveur dont l'identifiant a été
     donné. Renvoie un tableau vide si aucun processus ne le bloque.
    </para>
    <para>
     Un processus serveur bloque un autre processus s'il détient un verrou
     qui entre en conflit avec la demande de verrou du processus bloqué
     (blocage dur) ou s'il est en attente d'un verrou qui rentrerait en
     conflit avec la demande de verrou du processus bloqué et est devant
     lui dans la queue d'attente (verrou léger). Lors de l'utilisation de
     requêtes parallélisées, le résultat liste toujours les identifiants
     des processus visibles du client (autrement dit, le résultat de
     <function>pg_backend_pid</function>) même si le verrou réel est détenu
     ou attendu par un processus worker. Ceci résulte potentiellement en
     des PID dupliqués dans le résultat. De plus, notez que quand une
     transaction préparée détient un verrou en conflit, il sera représenté
     par un identifiant zéro.
    </para>
    <para>
     Les appels fréquents à cette fonction ont des impacts sur les
     performances de la base car il est nécessaire d'avoir un accès
     exclusif à l'état partagé du gestionnaire de verrous pour un court
     moment.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_conf_load_time</primary>
     </indexterm>
     <function>pg_conf_load_time</function> ()
     <returnvalue>timestamp with time zone</returnvalue>
    </para>
    <para>
     Renvoie l'horodatage du dernier chargement des fichiers de
     configuration. Si la session actuelle était vivante à ce moment, cela
     sera l'heure quand la session a elle-même relu les fichiers de
     configuration (donc le résultat peut légèrement varier sur les
     différentes sessions). Sinon c'est le moment où le processus postmater
     relit les fichiers de configuration.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_current_logfile</primary>
     </indexterm>
     <indexterm>
      <primary>Traces</primary>
      <secondary>fonction pg_current_logfile</secondary>
     </indexterm>
     <indexterm>
      <primary>current_logfiles</primary>
      <secondary>et la fonction pg_current_logfile</secondary>
     </indexterm>
     <indexterm>
      <primary>traces</primary>
      <secondary>fichier current_logfiles et la fonction pg_current_logfile</secondary>
     </indexterm>
     <function>pg_current_logfile</function> ( <optional> <type>text</type> </optional> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Renvoie le chemin du fichier de traces actuellement utilisé par le
     collecteur de traces. Le chemin inclut le répertoire <xref
     linkend="guc-log-directory"/> et le nom du fichier de traces
     individuel. Le résultat est <literal>NULL</literal> si le collecteur
     de traces est désactivé. Quand plusieurs fichiers de trace existent,
     chacun dans un format différent,
     <function>pg_current_logfile</function> sans argument renvoie le
     fichier vers le fichier ayant le premier format trouvé dans la liste
     ordonnée&nbsp;: <literal>stderr</literal>, <literal>csvlog</literal>.
     <literal>NULL</literal> est renvoyé si aucun fichier de trace n'a un
     de ces formats. Pour réclamer des informations sur un format
     spécifique de fichier de trace, indiquez soit
     <literal>csvlog</literal> soit <literal>stderr</literal> comme valeur
     au paramètre optionnel. Le résultat est <literal>NULL</literal> si le
     format de trace demandé n'est pas configuré dans <xref
     linkend="guc-log-destination"/>. Le résultat réflète le contenu du
     fichier <filename>current_logfiles</filename>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_my_temp_schema</primary>
     </indexterm>
     <function>pg_my_temp_schema</function> ()
     <returnvalue>oid</returnvalue>
    </para>
    <para>
     Renvoie l'OID du schéma temporaire de la session en cours, ou zéro
     si ce schéma n'existe pas (parce que la session n'a pas créé de
     tables temporaires).
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_is_other_temp_schema</primary>
     </indexterm>
     <function>pg_is_other_temp_schema</function> ( <type>oid</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Renvoie true si l'OID donné est l'OID du schéma temporaire d'une autre
     session. (Ceci peut être utile, par exemple, pour exclure les tables
     temporaires des autres sessions d'un affichage du catalogue.)
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_jit_available</primary>
     </indexterm>
     <function>pg_jit_available</function> ()
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Renvoie true si l'extension de compilation <acronym>JIT</acronym> est
     disponible (voir <xref linkend="jit"/>) et si le paramètre de
     configuration <xref linkend="guc-jit"/> est configuré à
     <literal>on</literal>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_listening_channels</primary>
     </indexterm>
     <function>pg_listening_channels</function> ()
     <returnvalue>setof text</returnvalue>
    </para>
    <para>
     Renvoie l'ensemble de noms des canaux de notification asynchrone sur
     lesquels la session actuelle écoute.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_notification_queue_usage</primary>
     </indexterm>
     <function>pg_notification_queue_usage</function> ()
     <returnvalue>double precision</returnvalue>
    </para>
    <para>
     Renvoie la fraction (0&ndash;1) de la taille maximale de la queue de
     notification asynchrone actuellement occupée par des notifications en
     attente de traitement. Voir <xref linkend="sql-listen"/> et <xref
     linkend="sql-notify"/> pour plus d'informations.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_postmaster_start_time</primary>
     </indexterm>
     <function>pg_postmaster_start_time</function> ()
     <returnvalue>timestamp with time zone</returnvalue>
    </para>
    <para>
     Renvoie l'heure de démarrage du serveur.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_safe_snapshot_blocking_pids</primary>
     </indexterm>
     <function>pg_safe_snapshot_blocking_pids</function> ( <type>integer</type> )
     <returnvalue>integer[]</returnvalue>
    </para>
    <para>
     Renvoie un tableau d'identifiants de processus des sessions bloquant
     le processus serveur avec l'identifiant de processus spécifié pour
     acquérir une image propre. Renvoie un tableau vide si ce processus
     n'existe pas ou s'il n'est pas bloqué.
    </para>
    <para>
     Une session exécutant une transaction <literal>SERIALIZABLE</literal>
     bloque une transaction <literal>SERIALIZABLE READ ONLY
      DEFERRABLE</literal> sur l'acquisition d'une image jusqu'à ce que ce
     dernier détermine s'il est sûr d'éviter de prendre des verrous de
     prédicat. Voir <xref linkend="xact-serializable"/> pour plus
     d'informations sur les transactions sérialisables et déferrables.
    </para>
    <para>
     Les appels fréquents à cette fonction pourraient avoir des impacts sur
     la performance des bases car elle a besoin d'accéder à l'état partagé
     du gestionnaire de verrous de prédicats pour un court moment.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_trigger_depth</primary>
     </indexterm>
     <function>pg_trigger_depth</function> ()
     <returnvalue>integer</returnvalue>
    </para>
    <para>
     Renvoie le niveau de profondeur actuel des triggers
     <productname>PostgreSQL</productname> (0 si non appelé, directement ou
     indirectement, à partir d'un trigger).
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>session_user</primary>
     </indexterm>
     <function>session_user</function>
     <returnvalue>name</returnvalue>
    </para>
    <para>
     Renvoie le nom d'utilisateur de la session.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>user</primary>
     </indexterm>
     <function>user</function>
     <returnvalue>name</returnvalue>
    </para>
    <para>
     Équivalent à <function>current_user</function>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>version</primary>
     </indexterm>
     <function>version</function> ()
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Renvoie une chaîne décrivant la version du serveur
     <productname>PostgreSQL</productname>. Vous pouvez aussi obtenir cette
     information à partir de <xref linkend="guc-server-version"/> ou, pour
     une version lisible par un logiciel, vous pouvez utiliser <xref
     linkend="guc-server-version-num"/>. Les développeurs de logiciels
     devraient utiliser <varname>server_version_num</varname> (disponible
     depuis la version 8.2) ou <xref linkend="libpq-PQserverVersion"/> au
     lieu d'analyser la version texte.
    </para></entry>
  </row>
 </tbody>
</tgroup>
</table>

<note>
<para>
 <function>current_catalog</function>,
 <function>current_role</function>,
 <function>current_schema</function>,
 <function>current_user</function>,
 <function>session_user</function>
 et <function>user</function> ont un statut syntaxique spécial en
 <acronym>SQL</acronym>&nbsp;: elles doivent être appelées sans les
 parenthèses. Dans PostgreSQL, les parenthèses peuvent être utilisées en
 option avec <function>current_schema</function>, mais pas avec les
 autres.
</para>
</note>

<para>
<function>session_user</function> est habituellement l'utilisateur qui a
initié la connexion à la base de données&nbsp;; les superutilisateurs
peuvent modifier ce paramètre avec <xref
linkend="sql-set-session-authorization"/>.
<function>current_user</function> est l'identifiant de l'utilisateur
applicable pour les vérifications de droits. Habituellement, il est égal à
l'utilisateur de la session mais il peut être changé avec <xref
linkend="sql-set-role"/>. Il peut aussi changer durant l'exécution d'une
fonction ayant l'attribut <literal>SECURITY DEFINER</literal>. Dans la
parlance Unix, l'utilisateur de session est le <quote>real user</quote> et
l'utilisateur courant est le <quote>effective user</quote>.
<function>current_role</function> et <function>user</function> sont des
synonymes pour <function>current_user</function>. (Le standard SQL fait
une distinction entre <function>current_role</function> et
<function>current_user</function>, mais
<productname>PostgreSQL</productname> ne la fait pas car il unifie les
utilisateurs et les rôles en une seule entité.)
</para>

<indexterm>
<primary>droit</primary>
<secondary>requêtage</secondary>
</indexterm>

<para>
<xref linkend="functions-info-access-table"/> liste les fonctions qui
permettent d'accéder programmatiquement aux droits d'accès aux objets.
(Voir <xref linkend="ddl-priv"/> pour plus d'informations sur les droits.)
Dans ces fonctions, l'utilisateur dont les droits sont interrogés peut être
indiqué par son nom ou son OID
(<structname>pg_authid</structname>.<structfield>oid</structfield>), ou si
le nom donné est <literal>public</literal>, alors la vérification se fait
sur les droits du pseudo-rôle PUBLIC. De plus, l'argument
<parameter>user</parameter> peut être complètement omis, auquel cas la
vérification se fera sur <function>current_user</function>. L'objet vérifié
peut être indiqué par son nom ou son OID. Dans le cas du nom, le nom du
schéma peut être inclus si nécessaire. Le droit d'accès d'intérêt est
indiqué par une chaîne de caractères qui doit correspondre à un des mots
clés approprié pour le type d'objet (par exemple
<literal>SELECT</literal>). En option, <literal>WITH GRANT OPTION</literal>
peut être ajouté au type de droit pour tester si le droit contient cette
option. De plus, plusieurs types de droits peuvent être listés en les
séparant par des virgules, auquel cas le résultat sera vrai si un des
droits est détenu (la casse n'est pas significative et les espaces blancs
supplémentaires sont autorisés entre les noms des droits, mais pas à
l'intérieur des noms.) Quelques exemples&nbsp;:
<programlisting>
SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');
</programlisting>
</para>

<table id="functions-info-access-table">
<title>Fonctions d'accès aux droits</title>
<tgroup cols="1">
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para></entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>has_any_column_privilege</primary>
     </indexterm>
     <function>has_any_column_privilege</function> (
     <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
     <parameter>table</parameter> <type>text</type> or <type>oid</type>,
     <parameter>privilege</parameter> <type>text</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Est-ce que l'utilisateur a le droit pour une colonne de la table&nbsp;?
     Ceci réussit si le droit est détenu pour la table entière ou s'il est
     détenu par au moins une colonne de la table. Les droits autorisés sont
     <literal>SELECT</literal>, <literal>INSERT</literal>,
     <literal>UPDATE</literal> et <literal>REFERENCES</literal>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>has_column_privilege</primary>
     </indexterm>
     <function>has_column_privilege</function> (
     <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
     <parameter>table</parameter> <type>text</type> or <type>oid</type>,
     <parameter>column</parameter> <type>text</type> or <type>smallint</type>,
     <parameter>privilege</parameter> <type>text</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Est-ce que l'utilisateur a le droit pour la colonne spécifié de la
     table&nbsp;? Ceci réussit si le droit est détenu pour la table entière
     ou s'il est détenu par cette colonne de la table. La colonne peut être
     spécifiée par son nom ou son numéro d'attribut
     (<structname>pg_attribute</structname>.<structfield>attnum</structfield>).
     Les droits autorisés sont <literal>SELECT</literal>,
     <literal>INSERT</literal>, <literal>UPDATE</literal> et
     <literal>REFERENCES</literal>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>has_database_privilege</primary>
     </indexterm>
     <function>has_database_privilege</function> (
     <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
     <parameter>database</parameter> <type>text</type> or <type>oid</type>,
     <parameter>privilege</parameter> <type>text</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Est-ce que l'utilisateur a le droit pour la base&nbsp;?
     Les droits autorisés sont
     <literal>CREATE</literal>,
     <literal>CONNECT</literal>,
     <literal>TEMPORARY</literal> et
     <literal>TEMP</literal> (qui est équivalent à
     <literal>TEMPORARY</literal>).
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>has_foreign_data_wrapper_privilege</primary>
     </indexterm>
     <function>has_foreign_data_wrapper_privilege</function> (
     <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
     <parameter>fdw</parameter> <type>text</type> or <type>oid</type>,
     <parameter>privilege</parameter> <type>text</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Est-ce que l'utilisateur a le droit pour le foreign data wrapper&nbsp;?
     Le seul droit autorisé est <literal>USAGE</literal>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>has_function_privilege</primary>
     </indexterm>
     <function>has_function_privilege</function> (
     <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
     <parameter>function</parameter> <type>text</type> or <type>oid</type>,
     <parameter>privilege</parameter> <type>text</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Est-ce que l'utilisateur a le droit pour la fonction&nbsp;?
     Le seul droit autorisé est <literal>EXECUTE</literal>.
    </para>
    <para>
     Lors de la spécification d'une fonction par nom, plutôt que par OID,
     l'entrée autorisée est la même que pour le type de données
     <type>regprocedure</type> (voir <xref linkend="datatype-oid"/>). En
     voici un exemple&nbsp;:
     <programlisting>
SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');
     </programlisting>
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>has_language_privilege</primary>
     </indexterm>
     <function>has_language_privilege</function> (
     <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
     <parameter>language</parameter> <type>text</type> or <type>oid</type>,
     <parameter>privilege</parameter> <type>text</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Est-ce que l'utilisateur a le droit pour le langage&nbsp;?
     Le seul droit autorisé est <literal>USAGE</literal>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>has_schema_privilege</primary>
     </indexterm>
     <function>has_schema_privilege</function> (
     <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
     <parameter>schema</parameter> <type>text</type> or <type>oid</type>,
     <parameter>privilege</parameter> <type>text</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Est-ce que l'utilisateur a le droit pour le schéma&nbsp;?
     Les droits autorisés sont
     <literal>CREATE</literal> et
     <literal>USAGE</literal>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>has_sequence_privilege</primary>
     </indexterm>
     <function>has_sequence_privilege</function> (
     <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
     <parameter>sequence</parameter> <type>text</type> or <type>oid</type>,
     <parameter>privilege</parameter> <type>text</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Est-ce que l'utilisateur a le droit pour la séquence&nbsp;?
     Les droits autorisés sont
     <literal>USAGE</literal>,
     <literal>SELECT</literal> et
     <literal>UPDATE</literal>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>has_server_privilege</primary>
     </indexterm>
     <function>has_server_privilege</function> (
     <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
     <parameter>server</parameter> <type>text</type> or <type>oid</type>,
     <parameter>privilege</parameter> <type>text</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Est-ce que l'utilisateur a le droit pour le serveur distant&nbsp;?
     Le seul droit autorisé est <literal>USAGE</literal>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>has_table_privilege</primary>
     </indexterm>
     <function>has_table_privilege</function> (
     <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
     <parameter>table</parameter> <type>text</type> or <type>oid</type>,
     <parameter>privilege</parameter> <type>text</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Est-ce que l'utilisateur a le droit pour la table&nbsp;?
     Les droits autorisés sont
     <literal>SELECT</literal>, <literal>INSERT</literal>,
     <literal>UPDATE</literal>, <literal>DELETE</literal>,
     <literal>TRUNCATE</literal>, <literal>REFERENCES</literal>
     et <literal>TRIGGER</literal>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>has_tablespace_privilege</primary>
     </indexterm>
     <function>has_tablespace_privilege</function> (
     <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
     <parameter>tablespace</parameter> <type>text</type> or <type>oid</type>,
     <parameter>privilege</parameter> <type>text</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Est-ce que l'utilisateur a le droit pour le tablespace&nbsp;?
     Le seul droit autorisé est <literal>CREATE</literal>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>has_type_privilege</primary>
     </indexterm>
     <function>has_type_privilege</function> (
     <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
     <parameter>type</parameter> <type>text</type> or <type>oid</type>,
     <parameter>privilege</parameter> <type>text</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Est-ce que l'utilisateur a le droit pour le type de données&nbsp;? Le
     seul droit autorisé est <literal>USAGE</literal>. Lors de la
     spécification d'un type par son nom plutôt que par son OID, l'entrée
     autorisée est la même que pour le type de données <type>regtype</type>
     (voir <xref linkend="datatype-oid"/>).
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_has_role</primary>
     </indexterm>
     <function>pg_has_role</function> (
     <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
     <parameter>role</parameter> <type>text</type> or <type>oid</type>,
     <parameter>privilege</parameter> <type>text</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Est-ce que l'utilisateur a le droit pour le rôle&nbsp;? Les droits
     autorisés sont <literal>MEMBER</literal> et <literal>USAGE</literal>.
     <literal>MEMBER</literal> dénote une appartenance de groupe directe ou
     indirecte dans le rôle (autrement dit, le droit d'exécuter
     <command>SET ROLE</command>), alors que <literal>USAGE</literal>
     dénote si les droits de ce rôle sont immédiatement disponibles sans
     exécuter <command>SET ROLE</command>. Cette fonction n'autorise pas le
     cas spécial de configurer <parameter>user</parameter> à
     <literal>public</literal>, car le pseudo-rôle PUBLIC ne peut jamais
     être un membre d'un vrai rôle.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>row_security_active</primary>
     </indexterm>
     <function>row_security_active</function> (
     <parameter>table</parameter> <type>text</type> or <type>oid</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Est-ce que la sécurité niveau ligne est active pour la table dans le
     contexte de l'utilisateur et de l'environnement actuels&nbsp;?
    </para></entry>
  </row>
 </tbody>
</tgroup>
</table>

<para>
<xref linkend="functions-aclitem-op-table"/> montre les opérateurs
disponibles pour le type <type>aclitem</type>, qui est la représentation
catalogue pour les droits d'accès. Voir <xref linkend="ddl-priv"/> pour des
informations sur la lecture des droits d'accès.
</para>

<table id="functions-aclitem-op-table">
<title>Opérateurs <type>aclitem</type></title>
<tgroup cols="1">
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Opérateur
    </para>
    <para>
     Description
    </para>
    <para>
     Exemple(s)
    </para></entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>aclitemeq</primary>
     </indexterm>
     <type>aclitem</type> <literal>=</literal> <type>aclitem</type>
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Est-ce que les <type>aclitem</type> sont identiques&nbsp;? (Notez que
     le type <type>aclitem</type> manque de l'ensemble habituel d'opérateurs
     de comparaison&nbsp;; il n'a que l'égalité. Cependant, les tableaux
     <type>aclitem</type> peuvent seulement être comparés par égalité.)
    </para>
    <para>
     <literal>'calvin=r*w/hobbes'::aclitem = 'calvin=r*w*/hobbes'::aclitem</literal>
     <returnvalue>f</returnvalue>
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>aclcontains</primary>
     </indexterm>
     <type>aclitem[]</type> <literal>@&gt;</literal> <type>aclitem</type>
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Est-ce que le tableau contient les droits indiqués&nbsp;? (Ceci vaut
     true s'il existe une entrée de tableau qui correspond à
     l'<type>aclitem</type> et a au moins l'ensemble indiqué de droits.)
    </para>
    <para>
     <literal>'{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem[] @&gt; 'calvin=r*/hobbes'::aclitem</literal>
     <returnvalue>t</returnvalue>
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <type>aclitem[]</type> <literal>~</literal> <type>aclitem</type>
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Alias obsolète pour <literal>@&gt;</literal>.
    </para>
    <para>
     <literal>'{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem[] ~ 'calvin=r*/hobbes'::aclitem</literal>
     <returnvalue>t</returnvalue>
    </para></entry>
  </row>
 </tbody>
</tgroup>
</table>

<para>
<xref linkend="functions-aclitem-op-table"/> montre quelques fonctions
supplémentaires pour la gestion du type <type>aclitem</type>.
</para>

<table id="functions-aclitem-fn-table">
<title>Fonctions <type>aclitem</type></title>
<tgroup cols="1">
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para></entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>acldefault</primary>
     </indexterm>
     <function>acldefault</function> (
     <parameter>type</parameter> <type>"char"</type>,
     <parameter>ownerId</parameter> <type>oid</type> )
     <returnvalue>aclitem[]</returnvalue>
    </para>
    <para>
     Construit un tableau d'<type>aclitem</type> détenant les droits
     d'accès par défaut d'un objet de type <parameter>type</parameter>
     appartenant au rôle d'OID <parameter>ownerId</parameter>. Ceci
     représente les droits d'accès supposés quand une entrée ACL d'un objet
     est NULL. (Les droits d'accès par défaut sont décrits dans <xref
     linkend="ddl-priv"/>.)
     Le paramètre <parameter>type</parameter> doit faire partie de
     'c' pour <literal>COLUMN</literal>,
     'r' pour <literal>TABLE</literal> ainsi que les objets de type table,
     's' pour <literal>SEQUENCE</literal>,
     'd' pour <literal>DATABASE</literal>,
     'f' pour <literal>FUNCTION</literal> ou <literal>PROCEDURE</literal>,
     'l' pour <literal>LANGUAGE</literal>,
     'L' pour <literal>LARGE OBJECT</literal>,
     'n' pour <literal>SCHEMA</literal>,
     't' pour <literal>TABLESPACE</literal>,
     'F' pour <literal>FOREIGN DATA WRAPPER</literal>,
     'S' pour <literal>FOREIGN SERVER</literal>,
     ou
     'T' pour <literal>TYPE</literal> ou <literal>DOMAIN</literal>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>aclexplode</primary>
     </indexterm>
     <function>aclexplode</function> ( <type>aclitem[]</type> )
     <returnvalue>setof record</returnvalue>
     ( <parameter>grantor</parameter> <type>oid</type>,
     <parameter>grantee</parameter> <type>oid</type>,
     <parameter>privilege_type</parameter> <type>text</type>,
     <parameter>is_grantable</parameter> <type>boolean</type> )
    </para>
    <para>
     Renvoie le tableau the <type>aclitem</type> sous la forme d'un
     ensemble de lignes. Si le bénéficiaire est le pseudo-rôle PUBLIC, il
     est représenté par zéro dans la colonne
     <parameter>grantee</parameter>. Chaque droit donné est représenté sous
     la forme <literal>SELECT</literal>, <literal>INSERT</literal>, etc.
     Notez que chaque droit est séparé sur sa propre ligne, donc un seul
     mot clé apparaît dans la colonne
     <parameter>privilege_type</parameter>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>makeaclitem</primary>
     </indexterm>
     <function>makeaclitem</function> (
     <parameter>grantee</parameter> <type>oid</type>,
     <parameter>grantor</parameter> <type>oid</type>,
     <parameter>privileges</parameter> <type>text</type>,
     <parameter>is_grantable</parameter> <type>boolean</type> )
     <returnvalue>aclitem</returnvalue>
    </para>
    <para>
     Construit un <type>aclitem</type> avec les propriétés données.
    </para></entry>
  </row>
 </tbody>
</tgroup>
</table>

<para>
<xref linkend="functions-info-schema-table"/> montre les fonctions qui
déterminent si un certain objet est <firstterm>visible</firstterm> dans le
chelub de recherche de schémas courant. Par exemple, une table est dite
visible si le schéma qui la contient est dans le chemin de recherche. C'est
équivalent au fait que la table doit être référencée par nom sans
qualification explicite par d'un schéma. De ce fait, pour lister les noms
des tables visibles&nbsp;:
<programlisting>
SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);
</programlisting>
Pour les fonctions et opérateurs, un objet dans le chemin de recherche est dit
visible si aucun objet du même nom <emphasis>et du même type</emphasis> se trouve
avant dans le chemin. Pour les classes et familles d'opérateur,
le nom et la méthode d'accès associé de l'index sont considérés.
</para>

<indexterm>
<primary>chemin de recherche</primary>
<secondary>visibilité de l'objet</secondary>
</indexterm>

<table id="functions-info-schema-table">
<title>Fonctions de vérification de la visibilité</title>
<tgroup cols="1">
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para></entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_collation_is_visible</primary>
     </indexterm>
     <function>pg_collation_is_visible</function> ( <parameter>collation</parameter> <type>oid</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     La collation est-elle visible dans le chemin de recherche&nbsp;?
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_conversion_is_visible</primary>
     </indexterm>
     <function>pg_conversion_is_visible</function> ( <parameter>conversion</parameter> <type>oid</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     La conversion est-elle visible dans le chemin de recherche&nbsp;?
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_function_is_visible</primary>
     </indexterm>
     <function>pg_function_is_visible</function> ( <parameter>function</parameter> <type>oid</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     La fonction est-elle visible dans le chemin de recherche&nbsp;?
     (Ceci fonctionne aussi pour les procédures et les agrégats.)
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_opclass_is_visible</primary>
     </indexterm>
     <function>pg_opclass_is_visible</function> ( <parameter>opclass</parameter> <type>oid</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     La classe d'opérateur est-elle visible dans le chemin de recherche&nbsp;?
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_operator_is_visible</primary>
     </indexterm>
     <function>pg_operator_is_visible</function> ( <parameter>operator</parameter> <type>oid</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     L'opérateur est-il visible dans le chemin de recherche&nbsp;?
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_opfamily_is_visible</primary>
     </indexterm>
     <function>pg_opfamily_is_visible</function> ( <parameter>opclass</parameter> <type>oid</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     La famille d'opérateur est-elle visible dans le chemin de
     recherche&nbsp;?
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_statistics_obj_is_visible</primary>
     </indexterm>
     <function>pg_statistics_obj_is_visible</function> ( <parameter>stat</parameter> <type>oid</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     L'objet statistique est-il visible dans le chemin de recherche&nbsp;?
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_table_is_visible</primary>
     </indexterm>
     <function>pg_table_is_visible</function> ( <parameter>table</parameter> <type>oid</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     La table est-elle visible dans le chemin de recherche&nbsp;?
     (Cela fonctionne aussi pour tous les types de relations, ceci incluant
     les vues, les vues matérialisées, les séquences et les tables externes.)
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_ts_config_is_visible</primary>
     </indexterm>
     <function>pg_ts_config_is_visible</function> ( <parameter>config</parameter> <type>oid</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     La configuration de recherche plein texte est-elle visible dans le
     chemin de recherche&nbsp;?
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_ts_dict_is_visible</primary>
     </indexterm>
     <function>pg_ts_dict_is_visible</function> ( <parameter>dict</parameter> <type>oid</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Le dictionnaire de recherche plein texte est-il visible dans le chemin
     de recherche&nbsp;?
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_ts_parser_is_visible</primary>
     </indexterm>
     <function>pg_ts_parser_is_visible</function> ( <parameter>parser</parameter> <type>oid</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     L'analyseur de recherche plein texte est-il visible dans le chemin de
     recherche&nbsp;?
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_ts_template_is_visible</primary>
     </indexterm>
     <function>pg_ts_template_is_visible</function> ( <parameter>template</parameter> <type>oid</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Le modèle de recherche plein texte est-il visible dans le chemin de
     recherche&nbsp;?
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_type_is_visible</primary>
     </indexterm>
     <function>pg_type_is_visible</function> ( <parameter>type</parameter> <type>oid</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Le type (ou domaine) est-il visible dans le chemin de recherche&nbsp;?
    </para></entry>
  </row>
 </tbody>
</tgroup>
</table>

<para>
Toutes ces fonctions requièrent les OID des objets pour identifier l'objet
à vérifier. Si vous voulez tester un objet par son nom, il est préférable
d'utiliser les types d'alias de l'OID (<type>regclass</type>, <type>regtype</type>,
<type>regprocedure</type>, <type>regoperator</type>, <type>regconfig</type>
ou <type>regdictionary</type>),
par exemple&nbsp;:
<programlisting>
SELECT pg_type_is_visible('myschema.widget'::regtype);
</programlisting>
Notez qu'il n'y aurait pas de sens à tester un nom de type non qualifié par
son schéma de cette façon &mdash; si le nom peut être reconnu, c'est qu'il
est visible.
</para>

<para>
<xref linkend="functions-info-catalog-table"/> liste les fonctions qui
extraient des informations des catalogues systèmes.
</para>

<table id="functions-info-catalog-table">
<title>Fonctions d'information sur les catalogues systèmes</title>
<tgroup cols="1">
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para></entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>format_type</primary>
     </indexterm>
     <function>format_type</function> ( <parameter>type</parameter> <type>oid</type>, <parameter>typemod</parameter> <type>integer</type> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Renvoie le nom SQL pour un type de données identifié par l'OID type et
     potentiellement par un modifieur de type. Envoyez NULL pour le
     modifieur si aucun modifieur spécifique n'est connu.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_get_constraintdef</primary>
     </indexterm>
     <function>pg_get_constraintdef</function> ( <parameter>constraint</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Reconstruit la commande de création pour une contrainte. (Ceci est une
     reconstruction décompilée, pas le texte original de la commande.)
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_get_expr</primary>
     </indexterm>
     <function>pg_get_expr</function> ( <parameter>expr</parameter> <type>pg_node_tree</type>, <parameter>relation</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Décompile la forme interne de l'expression stockée dans les catalogues
     systèmes, telle que la valeur par défaut pour une colonne. Si
     l'expression peut contenir Vars, indiquez l'OID de la relation à
     laquelle elles font référence dans le deuxième paramètre&nbsp;; si
     aucun Var n'est attendu, indiquer 0 est suffisant.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_get_functiondef</primary>
     </indexterm>
     <function>pg_get_functiondef</function> ( <parameter>func</parameter> <type>oid</type> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Reconstruit la commande de création pour une fonction ou une
     procédure. (C'est une reconstruction décompilée, pas le texte original
     de la commande.) Le résultat est une instruction complète,
     <command>CREATE OR REPLACE FUNCTION</command> ou <command>CREATE OR
      REPLACE PROCEDURE</command>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_get_function_arguments</primary>
     </indexterm>
     <function>pg_get_function_arguments</function> ( <parameter>func</parameter> <type>oid</type> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Reconstruit la liste d'argument d'une fonction ou procédure, dans la
     forme où elle devrait apparaître dans un <command>CREATE
      FUNCTION</command> (en incluant les valeurs par défaut).
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_get_function_identity_arguments</primary>
     </indexterm>
     <function>pg_get_function_identity_arguments</function> ( <parameter>func</parameter> <type>oid</type> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Reconstruit la liste d'arguments nécessaire pour identifier une
     fonction ou une procédure, sous la forme nécessaire pour intégrer une
     commande telle que <command>ALTER FUNCTION</command>. Cette forme omet
     les valeurs par défaut.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_get_function_result</primary>
     </indexterm>
     <function>pg_get_function_result</function> ( <parameter>func</parameter> <type>oid</type> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Reconstruit la clause <literal>RETURNS</literal> d'une function, dans
     la forme nécessaire pour apparaître dans <command>CREATE
      FUNCTION</command>. Renvoie <literal>NULL</literal> pour une
     procédure.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_get_indexdef</primary>
     </indexterm>
     <function>pg_get_indexdef</function> ( <parameter>index</parameter> <type>oid</type> <optional>, <parameter>column</parameter> <type>integer</type>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Reconstruit la commande de création pour un index (C'est une
     reconstruction décompilée, et non pas le texte original de la
     commande.) Si <parameter>column</parameter> est fourni et est
     différent de zéro, seule la définition de cette colonne est
     reconstruite.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_get_keywords</primary>
     </indexterm>
     <function>pg_get_keywords</function> ()
     <returnvalue>setof record</returnvalue>
     ( <parameter>word</parameter> <type>text</type>,
     <parameter>catcode</parameter> <type>"char"</type>,
     <parameter>catdesc</parameter> <type>text</type> )
    </para>
    <para>
     Renvoie un ensemble d'enregistrements décrivant les mots clés SQL
     reconnus par le serveur. La colonne <parameter>word</parameter>
     contient le mot clé. La colonne <parameter>catcode</parameter>
     contient un code de catégorie&nbsp;: <literal>U</literal> pour un mot
     clé non réservé, <literal>C</literal> pour un mot clé qui peut être un
     nom de colonne, <literal>T</literal> pour un mot clé qui peut être un
     nom de type ou de fonction, <literal>R</literal> pour un mot
     totalement réservé. La colonne <parameter>catdesc</parameter> contient
     une chaîne potentiellement localisée décrivant la catégorie.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_get_ruledef</primary>
     </indexterm>
     <function>pg_get_ruledef</function> ( <parameter>rule</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Reconstruit la commande de création pour une règle. (C'est une
     reconstruction décompilée, et non pas le texte original de la
     commande.)
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_get_serial_sequence</primary>
     </indexterm>
     <function>pg_get_serial_sequence</function> ( <parameter>table</parameter> <type>text</type>, <parameter>column</parameter> <type>text</type> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Renvoie le nom de la séquence associée à une colonne ou NULL si aucune
     séquence n'est associée à la colonne. Si la colonne est une colonne
     identité, la séquence associée est la séquence créée en interne pour
     cette colonne. Pour les colonnes créées en utilisant un des types
     serial (<type>serial</type>, <type>smallserial</type>,
     <type>bigserial</type>), il s'agit de la séquence crée pour la
     définition de la colonne serial. Dans ce dernier cas, l'association
     peut être modifiée ou supprimée avec <command>ALTER SEQUENCE OWNED
      BY</command>. (Cette fonction aurait due s'appeler
     <function>pg_get_owned_sequence</function>&nbsp;; son nom actuel
     reflète le fait qu'elle était historiquement utilisée avec des
     colonnes serial.) Le premier paramètre est un nom de tableau avec le
     schéma en option, et le deuxième paramètre est un nom de colonne.
     Comme le premier paramètre contient potentiellement un nom de schéma
     et un nom de table, il est analysé suivant les règles SQL
     habituelles, signifiant qu'il est mis en minuscule par défaut. Le
     second paramètre, étant juste un nom de colonne, est traité
     littéralement et conserve donc sa casse. Le résultat est formaté de
     façon convenable pour être donné à des fonctions de séquence (voir
     <xref linkend="functions-sequence"/>).
    </para>
    <para>
     Une utilisation typique est la lecture de la valeur actuelle d'une
     séquence pour une colonne identité ou serial. Par exemple&nbsp;:
     <programlisting>
SELECT currval(pg_get_serial_sequence('sometable', 'id'));
     </programlisting>
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_get_statisticsobjdef</primary>
     </indexterm>
     <function>pg_get_statisticsobjdef</function> ( <parameter>statobj</parameter> <type>oid</type> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Reconstruit le commande de création d'un objet statistique étendu.
     (Ceci est une reconstruction décompilée, par le texte de la commande
     originale.)
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_get_triggerdef</primary>
     </indexterm>
     <function>pg_get_triggerdef</function> ( <parameter>trigger</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Reconstruit la commande de création d'un trigger. (Ceci est une
     reconstruction décompilée, par le texte de la commande originale.)
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_get_userbyid</primary>
     </indexterm>
     <function>pg_get_userbyid</function> ( <parameter>role</parameter> <type>oid</type> )
     <returnvalue>name</returnvalue>
    </para>
    <para>
     Renvoie le nom d'un rôle d'après son OID.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_get_viewdef</primary>
     </indexterm>
     <function>pg_get_viewdef</function> ( <parameter>view</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Reconstruit la commande <command>SELECT</command> sous-jacente pour
     une vue ou une vue matérialisée. (Ceci est une reconstruction
     décompilée, par le texte de la commande originale.)
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <function>pg_get_viewdef</function> ( <parameter>view</parameter> <type>oid</type>, <parameter>wrap_column</parameter> <type>integer</type> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Reconstruit la commande <command>SELECT</command> sous-jacente pour
     une vue ou une vue matérialisée. (Ceci est une reconstruction
     décompilée, par le texte de la commande originale.) Dans cette forme
     de la fonction, l'affichage joli est toujours activé, et les longues
     lignes sont coupées pour essayer de les conserver plus petites que le
     nombre indiqué de colonnes.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <function>pg_get_viewdef</function> ( <parameter>view</parameter> <type>text</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Reconstruit la commande <command>SELECT</command> sous-jacente pour
     une vue ou une vue matérialisée, en travaillant à partir d'un nom pour
     la vue plutôt que de son OID. (Ceci est obsolète&nbsp;; utilisez la
     variante OID à la place.)
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_index_column_has_property</primary>
     </indexterm>
     <function>pg_index_column_has_property</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>column</parameter> <type>integer</type>, <parameter>property</parameter> <type>text</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Teste si une colonne d'index a la propriété nommée. Les propriétés
     communes de colonne d'index sont listées dans <xref
     linkend="functions-info-index-column-props"/>. (Notez que les méthodes
     d'accès d'extension peuvent définir des noms de propriété
     supplémentaires pour leurs index.) <literal>NULL</literal> est renvoyé
     si le nom de la propriété n'est pas connu ou ne s'applique pas à
     l'objet particulier ou si l'OID ou le numéro de colonne n'identifie
     pas un objet valide.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_index_has_property</primary>
     </indexterm>
     <function>pg_index_has_property</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>property</parameter> <type>text</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Teste si un index a la propriété nommée. Les propriétés communes
     d'index sont listées dans <xref
     linkend="functions-info-index-props"/>. (Notez que les méthodes
     d'accès d'extension peuvent définir des noms de propriété
     supplémentaires pour leurs index.) <literal>NULL</literal> est renvoyé
     si le nom de la propriété n'est pas connu ou ne s'applique pas à
     l'objet particulier ou si l'OID n'identifie pas un objet valide.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_indexam_has_property</primary>
     </indexterm>
     <function>pg_indexam_has_property</function> ( <parameter>am</parameter> <type>oid</type>, <parameter>property</parameter> <type>text</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Teste si une méthode d'accès aux index a la propriété nommée. Les
     propriétés communes des méthodes d'accès aux index sont listées dans
     <xref linkend="functions-info-indexam-props"/>.
     <literal>NULL</literal> est renvoyé si le nom de la propriété n'est
     pas connu ou ne s'applique pas à l'objet particulier ou si l'OID
     n'identifie pas un objet valide.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_options_to_table</primary>
     </indexterm>
     <function>pg_options_to_table</function> ( <parameter>options_array</parameter> <type>text[]</type> )
     <returnvalue>setof record</returnvalue>
     ( <parameter>option_name</parameter> <type>text</type>,
     <parameter>option_value</parameter> <type>text</type> )
    </para>
    <para>
     Renvoie l'ensemble d'options de stockage représenté par une valeur à
     partir de
     <structname>pg_class</structname>.<structfield>reloptions</structfield>
     ou
     <structname>pg_attribute</structname>.<structfield>attoptions</structfield>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_tablespace_databases</primary>
     </indexterm>
     <function>pg_tablespace_databases</function> ( <parameter>tablespace</parameter> <type>oid</type> )
     <returnvalue>setof oid</returnvalue>
    </para>
    <para>
     Renvoie l'ensemble d'OID des bases ayant des objets dans le tablespace
     indiqué. Si cette fonction renvoie des lignes, le tablespace n'est pas
     vide et ne peut pas être supprimé. Pour identifier les objets
     spécifiques peuplant le tablespace, vous aurez besoin de vous
     connecter aux bases identifiées par
     <function>pg_tablespace_databases</function> et de requêter leurs
     catalogues <structname>pg_class</structname>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_tablespace_location</primary>
     </indexterm>
     <function>pg_tablespace_location</function> ( <parameter>tablespace</parameter> <type>oid</type> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Renvoie le chemin du système de fichiers où ce tablespace est situé.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_typeof</primary>
     </indexterm>
     <function>pg_typeof</function> ( <type>"any"</type> )
     <returnvalue>regtype</returnvalue>
    </para>
    <para>
     Renvoie l'OID du type de données de la valeur qui lui est fournie.
     Ceci peut être utile pour débogguer ou pour construire dynamiquement
     des requêtes SQL. Cette fonction est déclarée renvoyer le type
     <type>regtype</type>, qui est un alias d'OID pour les objets types de
     données (voir <xref linkend="datatype-oid"/>)&nbsp;; ceci signifie
     qu'il est identique à un OID pour des comparaisons mais qu'il
     s'affiche sous la forme du nom du type.
    </para>
    <para>
     Par exemple&nbsp;:
     <programlisting>
SELECT pg_typeof(33);
 pg_typeof
-----------
 integer

SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
 typlen
--------
      4
     </programlisting>
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>COLLATION FOR</primary>
     </indexterm>
     <function>COLLATION FOR</function> ( <type>"any"</type> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Renvoie le nom de la collation de la valeur qui lui est fournie. La
     valeur est entre guillemet et qualifiée du schéma si nécessaire. Si
     aucune collation n'a été dérivée de l'expression de l'argument, alors
     <literal>NULL</literal> est renvoyée. Si l'argument n'est pas un type
     de données collationnable, alors une erreur est levée.
    </para>
    <para>
     Par exemple&nbsp;:
     <programlisting>
SELECT collation for (description) FROM pg_description LIMIT 1;
 pg_collation_for
------------------
 "default"

SELECT collation for ('foo' COLLATE "de_DE");
 pg_collation_for
------------------
 "de_DE"
     </programlisting>
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>to_regclass</primary>
     </indexterm>
     <function>to_regclass</function> ( <type>text</type> )
     <returnvalue>regclass</returnvalue>
    </para>
    <para>
     Traduit un nom de relation en son OID. Un résultat similaire est
     obtenu en convertissant la chaîne dans le type <type>regclass</type>
     (voir <xref linkend="datatype-oid"/>)&nbsp;; néanmoins, cette fonction
     renverra <literal>NULL</literal> plutôt que de lever une erreur si le
     nom n'est pas trouvé. De plus, contrairement à la conversion, ceci
     n'accepte pas un OID numérique en entrée.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>to_regcollation</primary>
     </indexterm>
     <function>to_regcollation</function> ( <type>text</type> )
     <returnvalue>regcollation</returnvalue>
    </para>
    <para>
     Traduit un nom de collation en son OID. Un résultat similaire est
     obtenu en convertissant la chaîne dans le type <type>regcollation</type>
     (voir <xref linkend="datatype-oid"/>)&nbsp;; néanmoins, cette fonction
     renverra <literal>NULL</literal> plutôt que de lever une erreur si le
     nom n'est pas trouvé. De plus, contrairement à la conversion, ceci
     n'accepte pas un OID numérique en entrée.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>to_regnamespace</primary>
     </indexterm>
     <function>to_regnamespace</function> ( <type>text</type> )
     <returnvalue>regnamespace</returnvalue>
    </para>
    <para>
     Traduit un nom de schéma en son OID. Un résultat similaire est
     obtenu en convertissant la chaîne dans le type <type>regnamespace</type>
     (voir <xref linkend="datatype-oid"/>)&nbsp;; néanmoins, cette fonction
     renverra <literal>NULL</literal> plutôt que de lever une erreur si le
     nom n'est pas trouvé. De plus, contrairement à la conversion, ceci
     n'accepte pas un OID numérique en entrée.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>to_regoper</primary>
     </indexterm>
     <function>to_regoper</function> ( <type>text</type> )
     <returnvalue>regoper</returnvalue>
    </para>
    <para>
     Traduit un nom d'opérateur en son OID. Un résultat similaire est
     obtenu en convertissant la chaîne dans le type <type>regoper</type>
     (voir <xref linkend="datatype-oid"/>)&nbsp;; néanmoins, cette fonction
     renverra <literal>NULL</literal> plutôt que de lever une erreur si le
     nom n'est pas trouvé. De plus, contrairement à la conversion, ceci
     n'accepte pas un OID numérique en entrée.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>to_regoperator</primary>
     </indexterm>
     <function>to_regoperator</function> ( <type>text</type> )
     <returnvalue>regoperator</returnvalue>
    </para>
    <para>
     Traduit un nom d'opérateur en son OID. Un résultat similaire est
     obtenu en convertissant la chaîne dans le type <type>regoperator</type>
     (voir <xref linkend="datatype-oid"/>)&nbsp;; néanmoins, cette fonction
     renverra <literal>NULL</literal> plutôt que de lever une erreur si le
     nom n'est pas trouvé. De plus, contrairement à la conversion, ceci
     n'accepte pas un OID numérique en entrée.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>to_regproc</primary>
     </indexterm>
     <function>to_regproc</function> ( <type>text</type> )
     <returnvalue>regproc</returnvalue>
    </para>
    <para>
     Traduit un nom de fonction ou procédure en son OID. Un résultat similaire est
     obtenu en convertissant la chaîne dans le type <type>regproc</type>
     (voir <xref linkend="datatype-oid"/>)&nbsp;; néanmoins, cette fonction
     renverra <literal>NULL</literal> plutôt que de lever une erreur si le
     nom n'est pas trouvé. De plus, contrairement à la conversion, ceci
     n'accepte pas un OID numérique en entrée.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>to_regprocedure</primary>
     </indexterm>
     <function>to_regprocedure</function> ( <type>text</type> )
     <returnvalue>regprocedure</returnvalue>
    </para>
    <para>
     Traduit un nom de fonction ou procédure en son OID. Un résultat similaire est
     obtenu en convertissant la chaîne dans le type <type>regprocedure</type>
     (voir <xref linkend="datatype-oid"/>)&nbsp;; néanmoins, cette fonction
     renverra <literal>NULL</literal> plutôt que de lever une erreur si le
     nom n'est pas trouvé. De plus, contrairement à la conversion, ceci
     n'accepte pas un OID numérique en entrée.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>to_regrole</primary>
     </indexterm>
     <function>to_regrole</function> ( <type>text</type> )
     <returnvalue>regrole</returnvalue>
    </para>
    <para>
     Traduit un nom de rôle en son OID. Un résultat similaire est
     obtenu en convertissant la chaîne dans le type <type>regrole</type>
     (voir <xref linkend="datatype-oid"/>)&nbsp;; néanmoins, cette fonction
     renverra <literal>NULL</literal> plutôt que de lever une erreur si le
     nom n'est pas trouvé. De plus, contrairement à la conversion, ceci
     n'accepte pas un OID numérique en entrée.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>to_regtype</primary>
     </indexterm>
     <function>to_regtype</function> ( <type>text</type> )
     <returnvalue>regtype</returnvalue>
    </para>
    <para>
     Traduit un nom de type en son OID. Un résultat similaire est
     obtenu en convertissant la chaîne dans le type <type>regtype</type>
     (voir <xref linkend="datatype-oid"/>)&nbsp;; néanmoins, cette fonction
     renverra <literal>NULL</literal> plutôt que de lever une erreur si le
     nom n'est pas trouvé. De plus, contrairement à la conversion, ceci
     n'accepte pas un OID numérique en entrée.
    </para></entry>
  </row>
 </tbody>
</tgroup>
</table>

<para>
La plupart des fonctions qui reconstruisent (décompilent) des objets de
base ont un drapeau <parameter>pretty</parameter>, qui à
<literal>true</literal>, cause que le résultat soit <quote>joliment
 affiché</quote>. Un bel affichage supprime les parenthèses inutiles et
ajoute des espaces blancs pour la lisibilité. Ce format est plus lisible
mais le format par défaut a plus de chance d'être interprété de la même
façon par les versions futures de
<productname>PostgreSQL</productname>&nbsp;; pour éviter d'utiliser une
sortie joliment affichée pour les sauvegardes. Configurer
<literal>false</literal> pour le paramètre <parameter>pretty</parameter>
donne le même résultat que d'omettre le paramètre.
</para>

<table id="functions-info-index-column-props">
<title>Propriétés des colonnes d'un index</title>
<tgroup cols="2">
 <thead>
  <row><entry>Nom</entry><entry>Description</entry></row>
 </thead>
 <tbody>
  <row>
   <entry><literal>asc</literal></entry>
   <entry>Est-ce que la colonne trie en ordre ascendant sur un parcours en
    avant&nbsp;?
   </entry>
  </row>
  <row>
   <entry><literal>desc</literal></entry>
   <entry>Est-ce que la colonne trie en ordre descendant sur un parcours en
    avant&nbsp;?
   </entry>
  </row>
  <row>
   <entry><literal>nulls_first</literal></entry>
   <entry>Est-ce que la colonne trie les valeurs NULL en premier sur un
    parcours en avant&nbsp;?
   </entry>
  </row>
  <row>
   <entry><literal>nulls_last</literal></entry>
   <entry>Est-ce que la colonne trie les valeurs NULL en dernier sur un
    parcours en avant&nbsp;?
   </entry>
  </row>
  <row>
   <entry><literal>orderable</literal></entry>
   <entry>Est-ce que la colonne possède un ordre de tri défini&nbsp;?
   </entry>
  </row>
  <row>
   <entry><literal>distance_orderable</literal></entry>
   <entry>Est-ce que la colonne peut être parcourue en ordre par un
    opérateur <quote>distance</quote>, par exemple
    <literal>ORDER BY col &lt;-&gt; constant</literal> ?
   </entry>
  </row>
  <row>
   <entry><literal>returnable</literal></entry>
   <entry>Est-ce que la valeur de la colonne peut être renvoyée par un
    parcours d'index seul&nbsp;?
   </entry>
  </row>
  <row>
   <entry><literal>search_array</literal></entry>
   <entry>Est-ce que la colonne supporte nativement les recherches
    <literal>col = ANY(array)</literal>&nbsp;?
   </entry>
  </row>
  <row>
   <entry><literal>search_nulls</literal></entry>
   <entry>Est-ce que la colonne supporte les recherches <literal>IS
     NULL</literal> et <literal>IS NOT NULL</literal>&nbsp;?
   </entry>
  </row>
 </tbody>
</tgroup>
</table>

<table id="functions-info-index-props">
<title>Propriétés des index</title>
<tgroup cols="2">
 <thead>
  <row><entry>Nom</entry><entry>Description</entry></row>
 </thead>
 <tbody>
  <row>
   <entry><literal>clusterable</literal></entry>
   <entry>L'index peut-il être utilisé dans une commande
    <literal>CLUSTER</literal>&nbsp;?
   </entry>
  </row>
  <row>
   <entry><literal>index_scan</literal></entry>
   <entry>L'index supporte-t-il les parcours simples (non bitmap)&nbsp;?
   </entry>
  </row>
  <row>
   <entry><literal>bitmap_scan</literal></entry>
   <entry>L'index supporte-t-il les parcours bitmap&nbsp;?
   </entry>
  </row>
  <row>
   <entry><literal>backward_scan</literal></entry>
   <entry>Est-ce que la direction du parcours peut être changée en milieu
    de parcours (pour accepter <literal>FETCH BACKWARD</literal> sur un
    curseur sans nécessiter de matérialisation)&nbsp;?
   </entry>
  </row>
 </tbody>
</tgroup>
</table>

<table id="functions-info-indexam-props">
<title>Propriétés des méthodes d'accès aux index</title>
<tgroup cols="2">
 <thead>
  <row><entry>Nom</entry><entry>Description</entry></row>
 </thead>
 <tbody>
  <row>
   <entry><literal>can_order</literal></entry>
   <entry>Est-ce que la méthode d'accès supporte <literal>ASC</literal>,
    <literal>DESC</literal> et les autres mots-clés dans
    <literal>CREATE INDEX</literal>&nbsp;?
   </entry>
  </row>
  <row>
   <entry><literal>can_unique</literal></entry>
   <entry>Est-ce que la méthode d'accès supporte les index d'unicité&nbsp;?
   </entry>
  </row>
  <row>
   <entry><literal>can_multi_col</literal></entry>
   <entry>Est-ce que la méthode d'accès supporte les index
    multi-colonnes&nbsp;?
   </entry>
  </row>
  <row>
   <entry><literal>can_exclude</literal></entry>
   <entry>Est-ce que la méthode d'accès supporte les contraintes
    d'exclusion&nbsp;?
   </entry>
  </row>
  <row>
   <entry><literal>can_include</literal></entry>
   <entry>Est-ce que la méthode d'accès supporte la clause
    <literal>INCLUDE</literal> de <literal>CREATE INDEX</literal>&nbsp;?
   </entry>
  </row>
 </tbody>
</tgroup>
</table>

<para>
<xref linkend="functions-info-object-table"/> liste les fonctions relatives
à l'identification et l'adressage des objets de la base.
</para>

<table id="functions-info-object-table">
<title>Fonctions d'information et d'adressage des objets</title>
<tgroup cols="1">
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para></entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_describe_object</primary>
     </indexterm>
     <function>pg_describe_object</function> ( <parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Renvoie une description textuelle d'un objet de base identifié par un
     OID de catalogue, un OID d'objet, et un identifiant de sous-objet (tel
     que le numéro de colonne dans une table&nbsp;; cet identifiant vaut
     zéro lorsqu'il référence un objet complet). Cette description a pour
     but d'être lisible par un humain, et pourrait être traduite, suivant
     la configuration du serveur. C'est particulièrement utile pour
     déterminer l'identité d'un objet référencé dans le catalogue
     <structname>pg_depend</structname>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_identify_object</primary>
     </indexterm>
     <function>pg_identify_object</function> ( <parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type> )
     <returnvalue>record</returnvalue>
     ( <parameter>type</parameter> <type>text</type>,
     <parameter>schema</parameter> <type>text</type>,
     <parameter>name</parameter> <type>text</type>,
     <parameter>identity</parameter> <type>text</type> )
    </para>
    <para>
     Renvoie une ligne contenant suffisamment d'informations pour
     identifier de façon unique l'objet de la base spécifié par un OID de
     catalogue, un OID d'objet et un identifiant de sous-objet. Cette
     information a pour but d'être lisible par un logiciel et n'est jamais
     traduite. <parameter>type</parameter> identifie le type d'objet de
     base&nbsp;; <parameter>schema</parameter> est le nom du schéma auquel
     l'objet appartient ou <literal>NULL</literal> pour les types d'objet
     n'appartenant pas à des schémas&nbsp;; <parameter>name</parameter> est
     le nom de l'objet, entre guillemets si nécessaire, si le nom (avec le
     nom du schéma le cas échéant) est suffisant pour identifier de façon
     unique l'objet, et <literal>NULL</literal> sinon&nbsp;;
     <parameter>identity</parameter> est l'identité complète de l'objet,
     avec le format précis dépendant du type d'objet, et chaque nom dans le
     format habituel (qualification avec le schéma et guillemets doubles si
     nécessaire).
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_identify_object_as_address</primary>
     </indexterm>
     <function>pg_identify_object_as_address</function> ( <parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type> )
     <returnvalue>record</returnvalue>
     ( <parameter>type</parameter> <type>text</type>,
     <parameter>object_names</parameter> <type>text[]</type>,
     <parameter>object_args</parameter> <type>text[]</type> )
    </para>
    <para>
     Renvoie une ligne contenant suffisamment d'informations pour
     identifier de façon unique l'objet de la base spécifié par un OID de
     catalogue, un OID d'objet et un identifiant de sous-objet.
     L'information renvoyé est indépendante du serveur, autrement dit il
     pourrait être utilisé pour idenfier un objet pareillement nommé sur un
     autre serveur. <parameter>type</parameter> identifie le type d'objet
     de base&nbsp;; <parameter>object_names</parameter> et
     <parameter>object_args</parameter> sont des tableaux de texte qui
     forment ensemble une référence à l'objet. Ces trois valeurs peuvent
     être passées à <function>pg_get_object_address</function> pour obtenir
     l'adresse interne de l'objet.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_get_object_address</primary>
     </indexterm>
     <function>pg_get_object_address</function> ( <parameter>type</parameter> <type>text</type>, <parameter>object_names</parameter> <type>text[]</type>, <parameter>object_args</parameter> <type>text[]</type> )
     <returnvalue>record</returnvalue>
     ( <parameter>classid</parameter> <type>oid</type>,
     <parameter>objid</parameter> <type>oid</type>,
     <parameter>objsubid</parameter> <type>integer</type> )
    </para>
    <para>
     Renvoie une ligne contenant suffisamment d'informations pour
     identifier de façon unique l'objet de base spécifié par le code type
     et le nom d'objet et les tableaux d'arguments. Les valeurs renvoyées
     sont celles qui seraient utilisées dans les catalogues systèmes tels
     que <structname>pg_depend</structname>&nbsp;; elles peuvent être
     fournies à d'autres fonctions systèmes telles que
     <function>pg_describe_object</function> ou
     <function>pg_identify_object</function>.
     <parameter>classid</parameter> est l'OID du catalogue système
     contenant l'objet&nbsp;; <parameter>objid</parameter> est l'OID de
     l'objet lui-même et <parameter>objsubid</parameter> est l'identifiant
     du sous-objet ou 0 si aucun. Cette fonction est l'inverse de
     <function>pg_identify_object_as_address</function>.
    </para></entry>
  </row>
 </tbody>
</tgroup>
</table>

<indexterm>
<primary>commentaire</primary>
<secondary sortas="database objects">sur les objets de la base</secondary>
</indexterm>

<para>
Les fonctions listées dans <xref linkend="functions-info-comment-table"/>
extraient les commentaires préalablement enregistrés avec la commande
<xref linkend="sql-comment"/>. Une valeur NULL est renvoyée si aucun
commentaire n'a été trouvé pour les paramètres donnés.
</para>

<table id="functions-info-comment-table">
<title>Fonctions d'informations sur les commentaires</title>
<tgroup cols="1">
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para></entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>col_description</primary>
     </indexterm>
     <function>col_description</function> ( <parameter>table</parameter> <type>oid</type>, <parameter>column</parameter> <type>integer</type> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Renvoie le commentaire pour une colonne de table, qui est spécifié par
     l'OID de la table et le numéro de colonne.
     (<function>obj_description</function> ne peut être utilisé pour les
     colonnes d'une table car les colonnes n'ont pas d'OID propre.)
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>obj_description</primary>
     </indexterm>
     <function>obj_description</function> ( <parameter>object</parameter> <type>oid</type>, <parameter>catalog</parameter> <type>name</type> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Renvoie le commentaire pour un objet de la base qui est spécifié par
     son OID et le nom du catalogue système le contenant. Par exemple,
     <literal>obj_description(123456, 'pg_class')</literal> récupérera le
     commentaire de la table d'OID 123456.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <function>obj_description</function> ( <parameter>object</parameter> <type>oid</type> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Renvoie le commentaire pour un objet de la base spécifié par son seul
     OID. Cette fonction est <emphasis>obsolète</emphasis> cat il n'existe
     aucune garantie que les OID soient uniques entre différents catalogues
     systèmes&nbsp;; de ce fait, un mauvais commentaire pourrait être
     renvoyé.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>shobj_description</primary>
     </indexterm>
     <function>shobj_description</function> ( <parameter>object</parameter> <type>oid</type>, <parameter>catalog</parameter> <type>name</type> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Renvoie le commentaire pour un objet de base partagé, spécifié par son
     OID et le nom du catalogue système le contenant. C'est comme
     <function>obj_description</function>, sauf que c'est utilisé pour
     récupérer les commentaires sur les objets partagés (donc les bases,
     les rôles et les tablespaces). Certains catalogues systèmes sont
     globaux à toutes les bases d'une instance, et les descriptions de ces
     objects sont stockées là-aussi globalement.
    </para></entry>
  </row>
 </tbody>
</tgroup>
</table>

<para>
Les fonctions listées dans <xref linkend="functions-pg-snapshot"/>
fournissent des informations sur la transaction serveur dans un format
exportable. L'utilisation principale de ces fonctions est de déterminer
les transactions validées entre deux images de base.
</para>

<table id="functions-pg-snapshot">
<title>Fonctions d'identifiants de transaction et d'informations sur les
 images de base</title>
<tgroup cols="1">
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para></entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_current_xact_id</primary>
     </indexterm>
     <function>pg_current_xact_id</function> ()
     <returnvalue>xid8</returnvalue>
    </para>
    <para>
     Renvoie l'identifiant actuel de la transaction. Il sera affecté si la
     transaction n'en a pas déjà un (ceci arrive si elle n'a pas encore
     réalisé d'écritures sur la base).
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_current_xact_id_if_assigned</primary>
     </indexterm>
     <function>pg_current_xact_id_if_assigned</function> ()
     <returnvalue>xid8</returnvalue>
    </para>
    <para>
     Renvoie l'identifiant actuel de la transaction ou <literal>NULL</literal> si
     aucun identifiant n'a encore été assigné. (Il est préférable d'utiliser cette
     variante si la transaction est habituellement en lecture seule pour éviter
     de consommer inutilement un identifiant de transaction.)
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_xact_status</primary>
     </indexterm>
     <function>pg_xact_status</function> ( <type>xid8</type> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Renvoie le statut de validation d'une transaction récente. Le résultat
     fait partie de <literal>in progress</literal>,
     <literal>committed</literal> ou <literal>aborted</literal>, en
     supposant que la transaction est suffisamment récente pour que le
     système dispose du statut de validation de cette transaction. S'il est
     assez ancien pour qu'aucune référence de la transaction n'est survécu
     au système et que le statut de validation ait disparu, le résultat est
     <literal>NULL</literal>. Les applications peuvent utiliser cette
     fonction pour déterminer, par exemple, si leur transaction a été
     validée ou annulée si l'application a été déconnectée alors qu'un
     <literal>COMMIT</literal> était en cours. Notez que les transactions
     préparées sont rapportés <literal>en cours</literal>&nbsp;; les
     applications doivent vérifier <link
     linkend="view-pg-prepared-xacts"><structname>pg_prepared_xacts</structname></link>
     si elles ont besoin de savoir si un identifiant de transaction
     appartient à une transaction préparée.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_current_snapshot</primary>
     </indexterm>
     <function>pg_current_snapshot</function> ()
     <returnvalue>pg_snapshot</returnvalue>
    </para>
    <para>
     Renvoie un <firstterm>snapshot</firstterm> (image) actuel, une
     structure de données indiquant les identifiants de transaction
     actuellement en cours.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_snapshot_xip</primary>
     </indexterm>
     <function>pg_snapshot_xip</function> ( <type>pg_snapshot</type> )
     <returnvalue>setof xid8</returnvalue>
    </para>
    <para>
     Renvoie l'ensemble des identifiants de transactions en cours contenu
     dans un snapshot (image de base).
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_snapshot_xmax</primary>
     </indexterm>
     <function>pg_snapshot_xmax</function> ( <type>pg_snapshot</type> )
     <returnvalue>xid8</returnvalue>
    </para>
    <para>
     Renvoie le <structfield>xmax</structfield> d'une image de base.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_snapshot_xmin</primary>
     </indexterm>
     <function>pg_snapshot_xmin</function> ( <type>pg_snapshot</type> )
     <returnvalue>xid8</returnvalue>
    </para>
    <para>
     Renvoie le <structfield>xmin</structfield> d'une image de base
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_visible_in_snapshot</primary>
     </indexterm>
     <function>pg_visible_in_snapshot</function> ( <type>xid8</type>, <type>pg_snapshot</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Est-ce que l'identifiant de transaction donné est
     <firstterm>visible</firstterm> d'après cette image de base (autrement
     dit, est-il terminé avant que l'image ne soit réalisée)&nbsp;? Notez
     que cette fonction ne renverra pas la bonne réponse pour un
     identifiant de sous-transaction.
    </para></entry>
  </row>
 </tbody>
</tgroup>
</table>

<para>
Le type interne des identifiants de transaction, <type>xid</type>, est sur
32 bits et boucle tous les 4 milliards de transactions. Néanmoins, les
fonctions listées dans <xref linkend="functions-pg-snapshot"/> utilisent
un type <type>xid8</type> sur 64 bits qui ne boucle pas sur toute la durée
de vie d'une instance, et qui peut être converti en <type>xid</type> par
conversion si nécessaire. Le type de données <type>pg_snapshot</type>
enregistre des informations sur la visibilité des identifiants de
transaction à un moment particulier. Ses composants sont décrits dans
<xref linkend="functions-pg-snapshot-parts"/>. La représentation textuelle
de <type>pg_snapshot</type> est
<literal><replaceable>xmin</replaceable>:<replaceable>xmax</replaceable>:<replaceable>xip_list</replaceable></literal>.
Par exemple, <literal>10:20:10,14,15</literal> signifie <literal>xmin=10,
 xmax=20, xip_list=10, 14, 15</literal>.
</para>

<table id="functions-pg-snapshot-parts">
<title>Composants d'image de base</title>
<tgroup cols="2">
 <thead>
  <row>
   <entry>Nom</entry>
   <entry>Description</entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry><structfield>xmin</structfield></entry>
   <entry>
    Plus petit identifiant de transaction toujours actif. Tous les
    identifiants de transaction inférieurs à
    <structfield>xmin</structfield> sont soit validés et visibles, soit
    annulés et morts.
   </entry>
  </row>

  <row>
   <entry><structfield>xmax</structfield></entry>
   <entry>
    L'identifiant de transaction après le dernier identifiant terminé.
    Tous les identifiants de transaction supérieurs ou égals à
    <structfield>xmax</structfield> ne sont pas encore terminés au moment
    de la création de l'image, et sont de ce fait invisibles.
   </entry>
  </row>

  <row>
   <entry><structfield>xip_list</structfield></entry>
   <entry>
    Transactions en cours au moment de la création de l'image de base.
    Un identifiant de transaction qui est
    <literal>xmin &lt;= <replaceable>X</replaceable> &lt;
     xmax</literal> et qui n'est pas dans cette liste a déjà été terminé
    au moins de la création de l'image et, de ce fait, est soit visible soit
    mort suivant son statut de validation. Cette liste n'inclut pas les
    identifiants de transaction des sous-transactions.
   </entry>
  </row>
 </tbody>
</tgroup>
</table>

<para>
Dans les versions de <productname>PostgreSQL</productname> antérieures à
la 13, le type <type>xid8</type> n'existait pas, donc des variantes de ces
fonctions étaient fournies. Elles utilisaient le type <type>bigint</type>
pour représenter un identifiant sur 64 bits, avec un type de données pour
l'image nommé <type>txid_snapshot</type>. Ces anciennes fonctions avaient
le mot <literal>txid</literal> dans leur nom. Elles sont toujours
acceptées pour des raisons de compatibilité ascendante, mais pourraient
être supprimées dans une version future. Voir <xref
linkend="functions-txid-snapshot"/>.
</para>

<table id="functions-txid-snapshot">
<title>Fonctions obsolètes sur les identifiants de transactions et les
 informations sur les images de base</title>
<tgroup cols="1">
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para></entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>txid_current</primary>
     </indexterm>
     <function>txid_current</function> ()
     <returnvalue>bigint</returnvalue>
    </para>
    <para>
     Voir <function>pg_current_xact_id()</function>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>txid_current_if_assigned</primary>
     </indexterm>
     <function>txid_current_if_assigned</function> ()
     <returnvalue>bigint</returnvalue>
    </para>
    <para>
     Voir <function>pg_current_xact_id_if_assigned()</function>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>txid_current_snapshot</primary>
     </indexterm>
     <function>txid_current_snapshot</function> ()
     <returnvalue>txid_snapshot</returnvalue>
    </para>
    <para>
     Voir <function>pg_current_snapshot()</function>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>txid_snapshot_xip</primary>
     </indexterm>
     <function>txid_snapshot_xip</function> ( <type>txid_snapshot</type> )
     <returnvalue>setof bigint</returnvalue>
    </para>
    <para>
     Voir <function>pg_snapshot_xip()</function>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>txid_snapshot_xmax</primary>
     </indexterm>
     <function>txid_snapshot_xmax</function> ( <type>txid_snapshot</type> )
     <returnvalue>bigint</returnvalue>
    </para>
    <para>
     Voir <function>pg_snapshot_xmax()</function>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>txid_snapshot_xmin</primary>
     </indexterm>
     <function>txid_snapshot_xmin</function> ( <type>txid_snapshot</type> )
     <returnvalue>bigint</returnvalue>
    </para>
    <para>
     Voir <function>pg_snapshot_xmin()</function>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>txid_visible_in_snapshot</primary>
     </indexterm>
     <function>txid_visible_in_snapshot</function> ( <type>bigint</type>, <type>txid_snapshot</type> )
     <returnvalue>boolean</returnvalue>
    </para>
    <para>
     Voir <function>pg_visible_in_snapshot()</function>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>txid_status</primary>
     </indexterm>
     <function>txid_status</function> ( <type>bigint</type> )
     <returnvalue>text</returnvalue>
    </para>
    <para>
     Voir <function>pg_xact_status()</function>.
    </para></entry>
  </row>
 </tbody>
</tgroup>
</table>

<para>
Les fonctions montrées dans <xref linkend="functions-commit-timestamp"/>
fournissent des informations sur le moment où d'anciennes transactions ont
été validées. Elles fournissent des informations utiles seulement quand le
paramètre <xref linkend="guc-track-commit-timestamp"/> est activé, et
seulement pour les transactions qui ont été validées après l'activation du
paramètre.
</para>

<table id="functions-commit-timestamp">
<title>Fonctions d'informations sur les transactions validées</title>
<tgroup cols="1">
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para></entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_xact_commit_timestamp</primary>
     </indexterm>
     <function>pg_xact_commit_timestamp</function> ( <type>xid</type> )
     <returnvalue>timestamp with time zone</returnvalue>
    </para>
    <para>
     Renvoie l'horodatage de validation d'une transaction.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_last_committed_xact</primary>
     </indexterm>
     <function>pg_last_committed_xact</function> ()
     <returnvalue>record</returnvalue>
     ( <parameter>xid</parameter> <type>xid</type>,
     <parameter>timestamp</parameter> <type>timestamp with time zone</type> )
    </para>
    <para>
     Renvoie l'identifiant de transaction et l'horodatage de sa validation
     pour la dernière transaction validée.
    </para></entry>
  </row>
 </tbody>
</tgroup>
</table>

<para>
Les fonctions listées dans <xref linkend="functions-controldata"/>
affichent des informations initialisées lors de l'exécution de la commande
<command>initdb</command>, telle que la version du catalogue. Elles
affichent aussi des informations sur les écritures dans les journaux de
transactions et le traitement des checkpoints. Ces informations sont
globales à l'instance, et non pas spécifique à une base. Ces fonctions
fournissent la plupart des informations en utilisant la mêle source que
l'application <xref linkend="app-pgcontroldata"/>.
</para>

<table id="functions-controldata">
<title>Fonctions des données de contrôle</title>
<tgroup cols="1">
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para></entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_control_checkpoint</primary>
     </indexterm>
     <function>pg_control_checkpoint</function> ()
     <returnvalue>record</returnvalue>
    </para>
    <para>
     Renvoie des informations sur l'état du checkpoint en cours, comme
     indiqué dans <xref linkend="functions-pg-control-checkpoint"/>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_control_system</primary>
     </indexterm>
     <function>pg_control_system</function> ()
     <returnvalue>record</returnvalue>
    </para>
    <para>
     Renvoie des informations sur l'état du fichier de contrôle en cours,
     comme indiqué dans <xref linkend="functions-pg-control-system"/>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_control_init</primary>
     </indexterm>
     <function>pg_control_init</function> ()
     <returnvalue>record</returnvalue>
    </para>
    <para>
     Renvoie des informations sur l'état d'initialisation de l'instance,
     comme indiqué dans <xref linkend="functions-pg-control-init"/>.
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>pg_control_recovery</primary>
     </indexterm>
     <function>pg_control_recovery</function> ()
     <returnvalue>record</returnvalue>
    </para>
    <para>
     Renvoie des informations sur l'état de restauration, comme indiqué
     dans <xref linkend="functions-pg-control-recovery"/>.
    </para></entry>
  </row>
 </tbody>
</tgroup>
</table>

<table id="functions-pg-control-checkpoint">
<title>Colonnes en sortie de <function>pg_control_checkpoint</function></title>
<tgroup cols="2">
 <thead>
  <row>
   <entry>Nom de la colonne</entry>
   <entry>Type de données</entry>
  </row>
 </thead>

 <tbody>

  <row>
   <entry><structfield>checkpoint_lsn</structfield></entry>
   <entry><type>pg_lsn</type></entry>
  </row>

  <row>
   <entry><structfield>redo_lsn</structfield></entry>
   <entry><type>pg_lsn</type></entry>
  </row>

  <row>
   <entry><structfield>redo_wal_file</structfield></entry>
   <entry><type>text</type></entry>
  </row>

  <row>
   <entry><structfield>timeline_id</structfield></entry>
   <entry><type>integer</type></entry>
  </row>

  <row>
   <entry><structfield>prev_timeline_id</structfield></entry>
   <entry><type>integer</type></entry>
  </row>

  <row>
   <entry><structfield>full_page_writes</structfield></entry>
   <entry><type>boolean</type></entry>
  </row>

  <row>
   <entry><structfield>next_xid</structfield></entry>
   <entry><type>text</type></entry>
  </row>

  <row>
   <entry><structfield>next_oid</structfield></entry>
   <entry><type>oid</type></entry>
  </row>

  <row>
   <entry><structfield>next_multixact_id</structfield></entry>
   <entry><type>xid</type></entry>
  </row>

  <row>
   <entry><structfield>next_multi_offset</structfield></entry>
   <entry><type>xid</type></entry>
  </row>

  <row>
   <entry><structfield>oldest_xid</structfield></entry>
   <entry><type>xid</type></entry>
  </row>

  <row>
   <entry><structfield>oldest_xid_dbid</structfield></entry>
   <entry><type>oid</type></entry>
  </row>

  <row>
   <entry><structfield>oldest_active_xid</structfield></entry>
   <entry><type>xid</type></entry>
  </row>

  <row>
   <entry><structfield>oldest_multi_xid</structfield></entry>
   <entry><type>xid</type></entry>
  </row>

  <row>
   <entry><structfield>oldest_multi_dbid</structfield></entry>
   <entry><type>oid</type></entry>
  </row>

  <row>
   <entry><structfield>oldest_commit_ts_xid</structfield></entry>
   <entry><type>xid</type></entry>
  </row>

  <row>
   <entry><structfield>newest_commit_ts_xid</structfield></entry>
   <entry><type>xid</type></entry>
  </row>

  <row>
   <entry><structfield>checkpoint_time</structfield></entry>
   <entry><type>timestamp with time zone</type></entry>
  </row>

 </tbody>
</tgroup>
</table>

<table id="functions-pg-control-system">
<title>Colonnes en sortie de <function>pg_control_system</function></title>
<tgroup cols="2">
 <thead>
  <row>
   <entry>Nom de colonne</entry>
   <entry>Type de données</entry>
  </row>
 </thead>

 <tbody>

  <row>
   <entry><structfield>pg_control_version</structfield></entry>
   <entry><type>integer</type></entry>
  </row>

  <row>
   <entry><structfield>catalog_version_no</structfield></entry>
   <entry><type>integer</type></entry>
  </row>

  <row>
   <entry><structfield>system_identifier</structfield></entry>
   <entry><type>bigint</type></entry>
  </row>

  <row>
   <entry><structfield>pg_control_last_modified</structfield></entry>
   <entry><type>timestamp with time zone</type></entry>
  </row>

 </tbody>
</tgroup>
</table>

<table id="functions-pg-control-init">
<title>Colonnes en sortie de <function>pg_control_init</function></title>
<tgroup cols="2">
 <thead>
  <row>
   <entry>Nom de colonne</entry>
   <entry>Type de données</entry>
  </row>
 </thead>

 <tbody>

  <row>
   <entry><structfield>max_data_alignment</structfield></entry>
   <entry><type>integer</type></entry>
  </row>

  <row>
   <entry><structfield>database_block_size</structfield></entry>
   <entry><type>integer</type></entry>
  </row>

  <row>
   <entry><structfield>blocks_per_segment</structfield></entry>
   <entry><type>integer</type></entry>
  </row>

  <row>
   <entry><structfield>wal_block_size</structfield></entry>
   <entry><type>integer</type></entry>
  </row>

  <row>
   <entry><structfield>bytes_per_wal_segment</structfield></entry>
   <entry><type>integer</type></entry>
  </row>

  <row>
   <entry><structfield>max_identifier_length</structfield></entry>
   <entry><type>integer</type></entry>
  </row>

  <row>
   <entry><structfield>max_index_columns</structfield></entry>
   <entry><type>integer</type></entry>
  </row>

  <row>
   <entry><structfield>max_toast_chunk_size</structfield></entry>
   <entry><type>integer</type></entry>
  </row>

  <row>
   <entry><structfield>large_object_chunk_size</structfield></entry>
   <entry><type>integer</type></entry>
  </row>

  <row>
   <entry><structfield>float8_pass_by_value</structfield></entry>
   <entry><type>boolean</type></entry>
  </row>

  <row>
   <entry><structfield>data_page_checksum_version</structfield></entry>
   <entry><type>integer</type></entry>
  </row>

 </tbody>
</tgroup>
</table>

<table id="functions-pg-control-recovery">
<title>Colonnes en sortie de <function>pg_control_recovery</function></title>
<tgroup cols="2">
 <thead>
  <row>
   <entry>Nom de colonne</entry>
   <entry>Type de données</entry>
  </row>
 </thead>

 <tbody>

  <row>
   <entry><structfield>min_recovery_end_lsn</structfield></entry>
   <entry><type>pg_lsn</type></entry>
  </row>

  <row>
   <entry><structfield>min_recovery_end_timeline</structfield></entry>
   <entry><type>integer</type></entry>
  </row>

  <row>
   <entry><structfield>backup_start_lsn</structfield></entry>
   <entry><type>pg_lsn</type></entry>
  </row>

  <row>
   <entry><structfield>backup_end_lsn</structfield></entry>
   <entry><type>pg_lsn</type></entry>
  </row>

  <row>
   <entry><structfield>end_of_backup_record_required</structfield></entry>
   <entry><type>boolean</type></entry>
  </row>

 </tbody>
</tgroup>
</table>

</sect1>

<sect1 id="functions-admin">
<title>Fonctions d'administration système</title>

<para>
Les fonctions décrites dans cette section sont utilisées pour contrôler
et superviser une installation <productname>PostgreSQL</productname>.
</para>

<sect2 id="functions-admin-set">
<title>Fonctions de configuration</title>

<indexterm>
 <primary>SET</primary>
</indexterm>

<indexterm>
 <primary>SHOW</primary>
</indexterm>

<indexterm>
 <primary>configuration</primary>
 <secondary sortas="server">du serveur</secondary>
 <tertiary>fonctions</tertiary>
</indexterm>

<para>
 <xref linkend="functions-admin-set-table"/> liste les fonctions
 disponibles pour requêter et modifier les paramètres de
 configuration.
</para>

<table id="functions-admin-set-table">
 <title>Fonctions de configuration</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para>
     <para>
      Exemple(s)
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>current_setting</primary>
      </indexterm>
      <function>current_setting</function> ( <parameter>setting_name</parameter> <type>text</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional> )
      <returnvalue>text</returnvalue>
     </para>
     <para>
      Renvoie la valeur actuelle du paramètre
      <parameter>setting_name</parameter>. Si ce paramètre n'existe pas,
      <function>current_setting</function> renvoie une erreur sauf si
      <parameter>missing_ok</parameter> est renseigné et vaut
      <literal>true</literal>. Cette fonction correspond à la commande
      <acronym>SQL</acronym> <command>SHOW</command>.
     </para>
     <para>
      <literal>current_setting('datestyle')</literal>
      <returnvalue>ISO, MDY</returnvalue>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>set_config</primary>
      </indexterm>
      <function>set_config</function> (
      <parameter>setting_name</parameter> <type>text</type>,
      <parameter>new_value</parameter> <type>text</type>,
      <parameter>is_local</parameter> <type>boolean</type> )
      <returnvalue>text</returnvalue>
     </para>
     <para>
      Configure le paramètre <parameter>setting_name</parameter> à
      <parameter>new_value</parameter>, et renvoie cette valeur. Si
      <parameter>is_local</parameter> vaut <literal>true</literal>, la
      nouvelle valeur s'appliquera uniquement pour la transaction en cours.
      Si vous voulez que la nouvelle valeur s'applique pour la session
      courante, utilisez <literal>false</literal> à la place. Cette fonction
      correspond à la commande SQL <command>SET</command>.
     </para>
     <para>
      <literal>set_config('log_statement_stats', 'off', false)</literal>
      <returnvalue>off</returnvalue>
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

</sect2>

<sect2 id="functions-admin-signal">
<title>Fonctions d'envoi de signaux</title>

<indexterm>
 <primary>signal</primary>
 <secondary sortas="backend">processus serveur</secondary>
</indexterm>

<para>
 Les fonctions listées dans <xref linkend="functions-admin-signal-table"/>
 envoient des signaux de contrôle aux autres processus serveur.
 L'utilisation de ces fonctions est restreinte aux superutilisateurs par
 défaut, mais un accès peut être fourni aux utilisateurs en utilisant la
 commande <command>GRANT</command>, avec quelques exceptions notables.
</para>

<para>
 Chacune de ces fonctions renvoient <literal>true</literal> en cas de
 succès et <literal>false</literal> autrement.
</para>

<table id="functions-admin-signal-table">
 <title>Fonctions d'envoi de signaux</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_cancel_backend</primary>
      </indexterm>
      <function>pg_cancel_backend</function> ( <parameter>pid</parameter> <type>integer</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Annule la requête en cours de la session du processus serveur dont
      l'identifiant de processus a été donné. Ceci est aussi autorisé si le
      rôle appelant est un membre de <literal>pg_signal_backend</literal>.
      Néanmoins, seuls les superutilisateurs peuvent annuler les processus
      des superutilisateurs.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_reload_conf</primary>
      </indexterm>
      <function>pg_reload_conf</function> ()
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Cause le rechargement des fichiers de configurations par tous les
      processus du serveur <productname>PostgreSQL</productname>. (Ceci se
      fait en envoyant un signal <systemitem>SIGHUP</systemitem> au
      processus postmaster qui, à son tour, envoie un signal
      <systemitem>SIGHUP</systemitem> à chacun de ses processus fils.)
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_rotate_logfile</primary>
      </indexterm>
      <function>pg_rotate_logfile</function> ()
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Signale au collecteur de traces qu'il doit changer de fichier de trace
      immédiatement. Ceci fonctionne seulement quand le collecteur de trace
      natif est en cours d'exécution.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_terminate_backend</primary>
      </indexterm>
      <function>pg_terminate_backend</function> ( <parameter>pid</parameter> <type>integer</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Termine la session pour le processus serveur dont l'identifiant de
      processus a été donné. Ceci est aussi autorisé si le rôle appelant est
      un membre du rôle dont le processus est en cours d'arrêt ou si le rôle
      appelant est membre de <literal>pg_signal_backend</literal>.
      Néanmoins, seuls les superutilisateurs peuvent terminer les processus
      des superutilisateurs.
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

<para>
 <function>pg_cancel_backend</function> et
 <function>pg_terminate_backend</function> envoient des signaux
 (respectivement <systemitem>SIGINT</systemitem> et
 <systemitem>SIGTERM</systemitem>) aux processus serveurs identifiés par
 leur PID. Le PID d'un processus serveur actif est disponible dans la
 colonne <structfield>pid</structfield> de la vue
 <structname>pg_stat_activity</structname> ou en listant les processus
 <command>postgres</command> sur le serveur (en utilisant
 <application>ps</application> sur Unix ou le <application>Task
  Manager</application> sur <productname>Windows</productname>). Le rôle
 d'un processus serveur actif est disponible dans la colonne
 <structfield>usename</structfield> de la vue
 <structname>pg_stat_activity</structname>.
</para>

</sect2>

<sect2 id="functions-admin-backup">
<title>Fonctions de contrôle de la sauvegarde</title>

<indexterm>
 <primary>sauvegarde</primary>
</indexterm>

<para>
 Les fonctions listées dans <xref linkend="functions-admin-backup-table"/>
 aident à la réalisation de sauvegardes en ligne. Ces fonctions ne peuvent
 pas être exécutées lors de la restauration (sauf pour
 <function>pg_start_backup</function> en mode non exclusif,
 <function>pg_stop_backup</function> en mode non exclusif,
 <function>pg_is_in_backup</function>,
 <function>pg_backup_start_time</function> et
 <function>pg_wal_lsn_diff</function>).
</para>

<para>
 Pour les détails sur l'utilisation correcte de ces fonctions, voir
 <xref linkend="continuous-archiving"/>.
</para>

<table id="functions-admin-backup-table">
 <title>Fonctions de contrôle de la sauvegarde</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_create_restore_point</primary>
      </indexterm>
      <function>pg_create_restore_point</function> ( <parameter>name</parameter> <type>text</type> )
      <returnvalue>pg_lsn</returnvalue>
     </para>
     <para>
      Crée un enregistrement marqueur nommé dans le journal de transactions.
      Ce marqueur peut ensuite être utilisé comme cible de restauration et
      renvoie l'emplacement correspondant dans le journal de transactions.
      Le nom donné peut être utilisé avec <xref
      linkend="guc-recovery-target-name"/> pour indiquer le point final de
      restauration. Évitez de créer plusieurs points de restauration de même
      nom car la restauration s'arrêtera au premier marqueur rencontré dont
      le nom correspond à la cible de restauration.
     </para>
     <para>
      Cette fonction est par défaut restreinte aux superutilisateurs mais
      les autres utilisateurs peuvent se voir donner le droit EXECUTE pour
      exécuter cette fonction.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_current_wal_flush_lsn</primary>
      </indexterm>
      <function>pg_current_wal_flush_lsn</function> ()
      <returnvalue>pg_lsn</returnvalue>
     </para>
     <para>
      Renvoie l'emplacement actuel de vidage du journal de transaction
      (voir les notes ci-dessous).
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_current_wal_insert_lsn</primary>
      </indexterm>
      <function>pg_current_wal_insert_lsn</function> ()
      <returnvalue>pg_lsn</returnvalue>
     </para>
     <para>
      Renvoie l'emplacement actuel d'insertion du journal de transaction
      (voir les notes ci-dessous).
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_current_wal_lsn</primary>
      </indexterm>
      <function>pg_current_wal_lsn</function> ()
      <returnvalue>pg_lsn</returnvalue>
     </para>
     <para>
      Renvoie l'emplacement actuel d'écriture du journal de transaction
      (voir les notes ci-dessous).
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_start_backup</primary>
      </indexterm>
      <function>pg_start_backup</function> (
      <parameter>label</parameter> <type>text</type>
      <optional>, <parameter>fast</parameter> <type>boolean</type>
       <optional>, <parameter>exclusive</parameter> <type>boolean</type>
       </optional></optional> )
      <returnvalue>pg_lsn</returnvalue>
     </para>
     <para>
      Prépare le serveur à commencer une sauvegarde en ligne. Le seul
      paramètre requi est un label arbitraire défini par l'utilisateur.
      (Typiquement, ce serait nom sous lequel le fichier de sauvegarde sera
      stocké.) Si le deuxième paramètre optionnel est donné à
      <literal>true</literal>, il demande l'exécution aussi rapide que
      possible de <function>pg_start_backup</function>. Ceci force un
      checkpoint immédiat ce qui va cause un pic dans les opérations
      disques, ralentissant les requêtes en cours d'exécution. Le troisième
      paramètre, optionnel, indique s'il faut réaliser une sauvegarde
      exclusive ou non (par défaut exclusive).
     </para>
     <para>
      Lors d'une sauvegarde exclusive, cette fonction écrit le fichier label
      (<filename>backup_label</filename>) et, s'il existe des liens dans le
      répertoire <filename>pg_tblspc/</filename>, un fichier de
      correspondance des tablespaces (<filename>tablespace_map</filename>)
      dans le répertoire des données principal de l'instance, puis exécute
      un checkpoint et enfin renvoie l'emplacement actuel du journal de
      transactions pour le début de la sauvegarde. (L'utilisateur peut
      ignorer la valeur en résultat mais elle est fournie au cas où elle
      serait utile.) Quand il s'agit d'une sauvegarde en mode non exclusif,
      le contenu de ces fichiers est renvoyé par la fonction
      <function>pg_stop_backup</function> et doit être copié dans l'espace
      de sauvegarde par l'utilisateur.
     </para>
     <para>
      Cette fonction est par défaut restreinte aux superutilisateurs mais
      les autres utilisateurs peuvent se voir donner le droit EXECUTE pour
      exécuter cette fonction.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_stop_backup</primary>
      </indexterm>
      <function>pg_stop_backup</function> (
      <parameter>exclusive</parameter> <type>boolean</type>
      <optional>, <parameter>wait_for_archive</parameter> <type>boolean</type>
      </optional> )
      <returnvalue>setof record</returnvalue>
      ( <parameter>lsn</parameter> <type>pg_lsn</type>,
      <parameter>labelfile</parameter> <type>text</type>,
      <parameter>spcmapfile</parameter> <type>text</type> )
     </para>
     <para>
      Termine la réalisation d'une sauvegarde en ligne exclusive ou non. Le
      paramètre <parameter>exclusive</parameter> doit correspondre à celui
      du précédent appel à <function>pg_start_backup</function>. Pour une
      sauvegarde exclusive, <function>pg_stop_backup</function> supprime le
      fichier label et, s'il existe, le fichier de correspondance des
      tablespaces créés par <function>pg_start_backup</function>. Pour une
      sauvegarde non exclusive, le contenu de ces fichiers est renvoyé en
      résultat de cette fonction et doit être écrit dans des fichiers à
      placer dans l'espace de sauvegarde (et non pas dans le répertoire des
      données).
     </para>
     <para>
      Il existe un deuxième paramètre optionnel de type
      <type>boolean</type>. À false, la fonction se terminera immédiatement
      après la fin de sauvegarde, sans attendre l'archivage des journaux de
      transactions. Ce comportement est seulement utile pour les logiciels
      de sauvegarde qui surveillent indépendamment l'archivage des journaux
      de transactions. Sinon, les journaux requis pour rendre la sauvegarde
      cohérente pourraient manquer et rendre la sauvegarde inutilisable. Par
      défaut ou quand ce paramètre vaut true,
      <function>pg_stop_backup</function> attendra l'archivage des journaux
      de transactions si l'archivage est activé. (Sur un serveur secondaire,
      cela signifie qu'elle attendra que si <varname>archive_mode</varname>
      est configuré à <literal>always</literal>. Si l'activité en écriture
      est faible sur le serveur primaire, il pourrait être utile d'exécuter
      un <function>pg_switch_wal</function> sur le serveur primaire pour
      forcer un changement de journal.)
     </para>
     <para>
      Lors d'une exécution sur un serveur primaire, cette option crée aussi
      un fichier d'historique de sauvegarde dans la zone d'archivage des
      journaux de transactions. Le fichier d'historique inclut un label
      donné par <function>pg_start_backup</function>, les emplacements de
      début et de fin de la sauvegarde, et les dates et heures de début et
      de fin de la sauvegarde. Après l'enregistrement de l'emplacement de
      fin, le point d'insertion actuel dans les journaux de transactions est
      automatiquement avancé au prochain journal, pour que le journal de fin
      de sauvegarde soit immédiatement archivé pour terminer la sauvegarde.
     </para>
     <para>
      Le résultat de la fonction est un simple enregistrement. La colonne
      <parameter>lsn</parameter> détient l'emplacement de la fin de la
      sauvegarde dans les journaux de transactions (qui peut de nouveau être
      ignoré). La deuxième et la troisième colonne valent
      <literal>NULL</literal> à la fin d'une sauvegarde exclusive&nbsp;;
      après une sauvegarde non exclusive, elles contiennent le contenu
      désiré des fichiers label et de correspondance de tablespaces.
     </para>
     <para>
      Cette fonction est par défaut restreinte aux superutilisateurs mais
      les autres utilisateurs peuvent se voir donner le droit EXECUTE pour
      exécuter cette fonction.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <function>pg_stop_backup</function> ()
      <returnvalue>pg_lsn</returnvalue>
     </para>
     <para>
      Termine la réalisation d'une sauvegarde en ligne exclusive. Cette
      version simplifiée est équivalente à <literal>pg_stop_backup(true,
       true)</literal>, sauf qu'elle n'envoie que le résultat de
      <type>pg_lsn</type>.
     </para>
     <para>
      Cette fonction est par défaut restreinte aux superutilisateurs mais
      les autres utilisateurs peuvent se voir donner le droit EXECUTE pour
      exécuter cette fonction.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_is_in_backup</primary>
      </indexterm>
      <function>pg_is_in_backup</function> ()
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Renvoie true si une sauvegarde en ligne exclusive est en cours.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_backup_start_time</primary>
      </indexterm>
      <function>pg_backup_start_time</function> ()
      <returnvalue>timestamp with time zone</returnvalue>
     </para>
     <para>
      Renvoie l'heure de début de la sauvegarde en ligne exclusive si une
      sauvegarde est en cours. Sinon, renvoie <literal>NULL</literal>.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_switch_wal</primary>
      </indexterm>
      <function>pg_switch_wal</function> ()
      <returnvalue>pg_lsn</returnvalue>
     </para>
     <para>
      Force le serveur à utiliser un nouveau journal de transactions, ce qui
      permet au journal actuel d'être archivé (en supposant que vous
      utilisez l'archivage continu). Le résultat est l'emplacement de fin du
      journal plus 1 dans le journal tout juste terminé. S'il n'y a pas eu
      d'activité d'écriture depuis le dernier changement de journal,
      <function>pg_switch_wal</function> ne fait rien et renvoie
      l'emplacement de début du journal actuellement utilisé.
     </para>
     <para>
      Cette fonction est par défaut restreinte aux superutilisateurs mais
      les autres utilisateurs peuvent se voir donner le droit EXECUTE pour
      exécuter cette fonction.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_walfile_name</primary>
      </indexterm>
      <function>pg_walfile_name</function> ( <parameter>lsn</parameter> <type>pg_lsn</type> )
      <returnvalue>text</returnvalue>
     </para>
     <para>
      Convertit un emplacement d'un journal de transaction par le nom du fichier
      du journal de transaction détenant cet emplacement.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_walfile_name_offset</primary>
      </indexterm>
      <function>pg_walfile_name_offset</function> ( <parameter>lsn</parameter> <type>pg_lsn</type> )
      <returnvalue>record</returnvalue>
      ( <parameter>file_name</parameter> <type>text</type>,
      <parameter>file_offset</parameter> <type>integer</type> )
     </para>
     <para>
      Convertit un emplacement d'un journal de transaction par le nom du fichier
      du journal de transaction détenant cet emplacement et le décalage en octets
      pour aller sur cet emplacement.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_wal_lsn_diff</primary>
      </indexterm>
      <function>pg_wal_lsn_diff</function> ( <parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>lsn</parameter> <type>pg_lsn</type> )
      <returnvalue>numeric</returnvalue>
     </para>
     <para>
      Calcule la différence en octets entre deux emplacements dans les
      journaux de transactions. Cette fonction peut être utilisée avec
      <structname>pg_stat_replication</structname> ou certaines des
      fonctions listées dans <xref linkend="functions-admin-backup-table"/>
      pour obtenir le retard de réplication.
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

<para>
 <function>pg_current_wal_lsn</function> affiche l'emplacement actuel
 d'écriture dans le journal de transaction en cours, dans le même format
 que celui utilisé par les fonctions ci-dessus. De même,
 <function>pg_current_wal_insert_lsn</function> affiche l'emplacement
 d'insertion actuel et <function>pg_current_wal_flush_lsn</function>
 affiche l'emplacement de vidage actuel. L'emplacement d'insertion est la
 fin <quote>logiqie</quote> du journal de transaction à n'importe quel
 moment, alors que l'emplacement d'écriture est la fin de ce qui a été
 réellement écrit à partir des caches internes du serveur, et l'emplacement
 de vidage est le dernier emplacement connu pour avoir été réellement écrit
 sur disque. L'emplacement d'écriture est la fin de ce qui doit être
 examiné en dehors du serveur et est habituellement ce que vous voulez si
 vous êtes intéressé par l'archivage des journaux partiellement complets.
 Les emplacements d'insertion et de vidage sont rendus disponibles
 principalement dans un but de débogage. Ce sont des opérations de lecture
 seule et ne nécessite pas l'attribut superutilisateur.
</para>

<para>
 Vous pouvez utiliser <function>pg_walfile_name_offset</function> pour
 extrait le nom du fichier et le décalage en octet du journal de
 transaction correspondant à partir d'une valeur <type>pg_lsn</type>. Par
 exemple&nbsp;:
 <programlisting>
postgres=# SELECT * FROM pg_walfile_name_offset(pg_stop_backup());
        file_name         | file_offset
--------------------------+-------------
 00000001000000000000000D |     4039624
(1 row)
 </programlisting>
 De la même façon, <function>pg_walfile_name</function> extrait juste le
 nom du fichier du journal de transactions. Quand l'emplacement donné est
 exactement à la limite du fichier, ces deux fonctions renvoient le nom du
 journal précédent. Ceci est généralement le comportement souhaité pour
 gérer l'archivage car le fichier précédent est le dernier qui doit être
 archivé.
</para>

</sect2>

<sect2 id="functions-recovery-control">
<title>Fonctions de contrôle de la restauration</title>

<para>
 Les fonctions listées dans <xref linkend="functions-recovery-info-table"/>
 fournissent des informations sur le statut actuel d'un serveur secondaire.
 Ces fonctions peuvent être exécutées pendant une restauration et pendant
 une exécution normale.
</para>

<table id="functions-recovery-info-table">
 <title>Fonctions d'information sur la restauration</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_is_in_recovery</primary>
      </indexterm>
      <function>pg_is_in_recovery</function> ()
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Renvoie true si la restauration est toujours en cours.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_last_wal_receive_lsn</primary>
      </indexterm>
      <function>pg_last_wal_receive_lsn</function> ()
      <returnvalue>pg_lsn</returnvalue>
     </para>
     <para>
      Renvoie le dernier emplacement des journaux de transactions, reçu et
      synchronisé sur disque par la réplication en flux. Tant que la
      réplication en flux est en cours, ceci augmentera de façon monotique.
      Si la restauration s'est terminée, alors cela restera statique à
      l'emplacement du dernier enregistrement reçu et synchronisé sur disque
      lors de la restauration. Si la réplication en flux est désactivée ou
      qu'elle n'a pas commencé, la fonction renvoie <literal>NULL</literal>.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_last_wal_replay_lsn</primary>
      </indexterm>
      <function>pg_last_wal_replay_lsn</function> ()
      <returnvalue>pg_lsn</returnvalue>
     </para>
     <para>
      Renvoie le dernier emplacement des journaux de transactions, rejoué
      lors de la restauration. Si la restauration est toujours en cours,
      ceci augmentera de façon monotique. Si la restauration s'est terminée,
      alors cela restera statique à l'emplacement du dernier enregistrement
      appliqué lors de la restauration. Quand le serveur a été démarré
      normalement sans restauration, la fonction renvoie
      <literal>NULL</literal>.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_last_xact_replay_timestamp</primary>
      </indexterm>
      <function>pg_last_xact_replay_timestamp</function> ()
      <returnvalue>timestamp with time zone</returnvalue>
     </para>
     <para>
      Renvoie l'horodatage de la dernière transaction rejouée pendant la
      restauration. C'est le moment où l'enregistrement de validation ou
      d'annulation a été généré sur le serveur promaire. Si aucune
      transaction n'a été rejouée pendant la restauration, la fonction
      renvoie <literal>NULL</literal>. Sinon, si la restauration est
      toujours en cours, ceci augmentera de façon monotonique. Si la
      restauration s'est terminée, alors cela restera statique à partir du
      moment de la dernière transaction appliquée à la restauration. Quand
      le serveur est démarré normalement sans restauration, la fonction
      renvoie <literal>NULL</literal>.
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

<para>
 Les fonctions listées dans <xref
 linkend="functions-recovery-control-table"/> contrôlent la progression de
 la restauration. Ces fonctions peuvent seulement être exécutées lors d'une
 restauration.
</para>

<table id="functions-recovery-control-table">
 <title>Fonctions de contrôle de la restauration</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_is_wal_replay_paused</primary>
      </indexterm>
      <function>pg_is_wal_replay_paused</function> ()
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Renvoie true si la restauration est en pause.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_promote</primary>
      </indexterm>
      <function>pg_promote</function> ( <parameter>wait</parameter> <type>boolean</type> <literal>DEFAULT</literal> <literal>true</literal>, <parameter>wait_seconds</parameter> <type>integer</type> <literal>DEFAULT</literal> <literal>60</literal> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Promeut un serveur secondaire au statut primaire. Avec
      <parameter>wait</parameter> configuré à <literal>true</literal> (la
      valeur par défaut), la fonction attend jusqu'à ce que la promotion
      soit terminée ou jusqu'à ce que <parameter>wait_seconds</parameter> se
      soient écoulées, et renvoie <literal>true</literal> si la promotion a
      réussi. Elle renvoie <literal>false</literal> dans les autres cas. Si
      <parameter>wait</parameter> est configuré à <literal>false</literal>,
      la fonction renvoie <literal>true</literal> immédiatement après avoir
      envoyé le signal <literal>SIGUSR1</literal> au postmaster pour
      déclencher sa promotion.
     </para>
     <para>
      Cette fonction est par défaut restreinte aux superutilisateurs mais
      les autres utilisateurs peuvent se voir donner le droit EXECUTE pour
      exécuter cette fonction.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_wal_replay_pause</primary>
      </indexterm>
      <function>pg_wal_replay_pause</function> ()
      <returnvalue>void</returnvalue>
     </para>
     <para>
      Met la restauration en pause. Lorsque la restauration est en pause,
      aucune modification n'est appliquée sur la base de données. Si le
      serveur secondaire est un hot standby, toutes les nouvelles requêtes
      verront la même image cohérente de la base et aucun conflit de requête
      ne sera généré jusqu'à ce que la restauration reprenne.
     </para>
     <para>
      Cette fonction est par défaut restreinte aux superutilisateurs mais
      les autres utilisateurs peuvent se voir donner le droit EXECUTE pour
      exécuter cette fonction.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_wal_replay_resume</primary>
      </indexterm>
      <function>pg_wal_replay_resume</function> ()
      <returnvalue>void</returnvalue>
     </para>
     <para>
      Relance la restauration si elle était en pause.
     </para>
     <para>
      Cette fonction est par défaut restreinte aux superutilisateurs mais
      les autres utilisateurs peuvent se voir donner le droit EXECUTE pour
      exécuter cette fonction.
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

<para>
 <function>pg_wal_replay_pause</function> et
 <function>pg_wal_replay_resume</function> ne peuvent pas être exécutés
 quand une promotion est en cours. Si une promotion est déclenchée alors
 que la restauration est en pause, l'état de pause se termine et la
 promotion continue.
</para>

<para>
 Si la réplication en flux est désactivé, l'état de pause peut continuer
 indéfiniment sans problème. Si la réplication en flux est en cours, alors
 les enregistrements des journaux de transactions continuent à être rçus,
 ce qui finira par remplir l'espace disque disponible, suivant la durée de
 la pause, le taux de génération des journaux de transactions et l'espace
 disque disponible.
</para>

</sect2>

<sect2 id="functions-snapshot-synchronization">
<title>Fonctions de synchronisation d'image</title>

<para>
 <productname>PostgreSQL</productname> permet aux sessions des bases de
 données de synchroniser leur image de base. Une image de base (ou
 <firstterm>snapshot</firstterm>) détermine les données visibles pour la
 transaction utilisant l'image. Les images synchronisées sont nécessaires
 quand deux sessions ou plus ont besoin de voir un contenu identique de la
 base de données. Si deux sessions démarrent leur transaction
 indépendamment, il existe toujours une possibilité qu'une autre
 transaction valid entre l'exécution des deux commandes <command>START
  TRANSACTION</command>, de telle façon qu'une session voit l'effet de cette
 transaction alors que l'autre ne la voit pas.
</para>

<para>
 Pour résoudre ce problème, <productname>PostgreSQL</productname> autorise
 une transaction à <firstterm>exporter</firstterm> l'image qu'elle utilise.
 Tant que la transaction exportée reste ouverte, les autres transactions
 peuvent <firstterm>importer</firstterm> son image et, de ce fait, garantir
 qu'elles partagent exactement la même vue de la base que la première
 transaction. Mais notez que tout changement effectué par une de ces
 transactions reste invisible aux autres transactions, comme d'habitude
 pour les modifications réalisées par des transactions non validées. Donc
 les transactions sont synchronisées suivant les données pré-existantes,
 mais agissent normalement pour les modifications qu'elles réalisent.
</para>

<para>
 Les images sont exportées avec la fonction
 <function>pg_export_snapshot</function>, affichée dans <xref
 linkend="functions-snapshot-synchronization-table"/>, et importées avec la
 commande <xref linkend="sql-set-transaction"/>.
</para>

<table id="functions-snapshot-synchronization-table">
 <title>Fonctions de synchronisation d'image</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_export_snapshot</primary>
      </indexterm>
      <function>pg_export_snapshot</function> ()
      <returnvalue>text</returnvalue>
     </para>
     <para>
      Sauvegarde l'image actuelle de la transaction et renvoie une donnée de
      type <type>text</type> identifiant l'image. Cette chaîne doit être
      fournie (en dehors de la base) aux clients qui veulent importer
      l'image. L'image est disponible à l'import seulement jusqu'à la fin de
      la transaction qui l'a exporté.
     </para>
     <para>
      Une transaction peut exporter plus d'une image, si nécessaire. Notez
      que faire cela n'est utile que pour les transactions en niveau
      <literal>READ COMMITTED</literal> car, dans les niveaux d'isolation
      <literal>REPEATABLE READ</literal> et supérieurs, les transactions
      utilisent la même image tout au long de leur vie. Une fois qu'une
      transaction a export une image, elle ne peut pas être préparée avec
      <xref linkend="sql-prepare-transaction"/>.
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

</sect2>

<sect2 id="functions-replication">
<title>Fonctions de gestion de la réplication</title>

<para>
 Les fonctions listées dans <xref linkend="functions-replication-table"/>
 sont pour le contrôle et l'interaction avec les fonctionnalités de
 réplication. Voir <xref linkend="streaming-replication"/>, <xref
 linkend="streaming-replication-slots"/> et <xref
 linkend="replication-origins"/> pour des informations sur les
 fonctionnalités sous-jacentes. L'utilisation de fonctions pour l'origine
 de réplication est seulement autorisée aux superutilisateurs par défaut,
 mais peut être autorisée aux autres utilisateurs en utilisant la commande
 <literal>GRANT</literal>. L'utilisation des fonctions pour les slots de
 réplication est restreinte aux superutilisateurs et aux utilisateurs ayant
 l'attribut <literal>REPLICATION</literal>.
</para>

<para>
 La plupart de ces fonctions ont des commandes équivalentes dans le
 protocole de réplication&nbsp;; voir <xref
 linkend="protocol-replication"/>.
</para>

<para>
 Les fonctions décrites dans
 <xref linkend="functions-admin-backup"/>,
 <xref linkend="functions-recovery-control"/> et
 <xref linkend="functions-snapshot-synchronization"/>
 sont aussi adéquates pour la réplication.
</para>

<table id="functions-replication-table">
 <title>Fonctions de gestion de la réplication</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_create_physical_replication_slot</primary>
      </indexterm>
      <function>pg_create_physical_replication_slot</function> ( <parameter>slot_name</parameter> <type>name</type> <optional>, <parameter>immediately_reserve</parameter> <type>boolean</type>, <parameter>temporary</parameter> <type>boolean</type> </optional> )
      <returnvalue>record</returnvalue>
      ( <parameter>slot_name</parameter> <type>name</type>,
      <parameter>lsn</parameter> <type>pg_lsn</type> )
     </para>
     <para>
      Crée un nouveau slot de réplication physique nommé
      <parameter>slot_name</parameter>. Le deuxième paramètre, optionnel,
      indique, quand il vaut <literal>true</literal>, que le
      <acronym>LSN</acronym> pour ce slot de réplication doit être réservé
      immédiatement. Dans le cas contraire, le <acronym>LSN</acronym> est
      réservé lors de la première connexion à partir d'un client de
      réplication de flux. Les changements en flux d'un slot de réplication
      sont seulement possible avec le protocole de réplication de flux
      &mdash; voir <xref linkend="protocol-replication"/>. Le troisième
      argument, optionnel, nommé <parameter>temporary</parameter>, indique,
      quand il vaut true, que le slot ne doit pas être enregistré de façon
      permanente sur disque et qu'il a seulement pour but d'être utilisé
      dans la session en cours. Les slots temporaires sont aussi supprimés
      dès qu'une erreur survient. Cette fonction correspond à la commande
      <literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal> du protocole
      de réplication.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_drop_replication_slot</primary>
      </indexterm>
      <function>pg_drop_replication_slot</function> ( <parameter>slot_name</parameter> <type>name</type> )
      <returnvalue>void</returnvalue>
     </para>
     <para>
      Supprime le slot de réplication physique ou logique nommé
      <parameter>slot_name</parameter>. Elle est identique à la commande
      <literal>DROP_REPLICATION_SLOT</literal> du protocole de réplication.
      Pour les slots logiques, elle doit être appelée en étant connecté sur
      la même base que celle du slot de réplication.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_create_logical_replication_slot</primary>
      </indexterm>
      <function>pg_create_logical_replication_slot</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>plugin</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type> </optional> )
      <returnvalue>record</returnvalue>
      ( <parameter>slot_name</parameter> <type>name</type>,
      <parameter>lsn</parameter> <type>pg_lsn</type> )
     </para>
     <para>
      Crée un nouveau slot de réplication logique (décodage) nommé
      <parameter>slot_name</parameter> en utilisant le plugin de sortie
      <parameter>plugin</parameter>. Le troisième paramètre, optionnel,
      nommé <parameter>temporary</parameter> indique, quand il vaut true,
      que le slot ne devrait pas être stockée de façon permanente sur disque
      et a seulement pour but d'être utilisé par la session en cours. Les
      slots temporaires sont aussi supprimés en cas d'erreur. Un appel à
      cette fonction a le même effet que la commande
      <literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal> du protocole de
      réplication.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_copy_physical_replication_slot</primary>
      </indexterm>
      <function>pg_copy_physical_replication_slot</function> ( <parameter>src_slot_name</parameter> <type>name</type>, <parameter>dst_slot_name</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type> </optional> )
      <returnvalue>record</returnvalue>
      ( <parameter>slot_name</parameter> <type>name</type>,
      <parameter>lsn</parameter> <type>pg_lsn</type> )
     </para>
     <para>
      Copie un slot de réplication physique existant, nommé
      <parameter>src_slot_name</parameter>, en un slot de réplication
      physique nommé <parameter>dst_slot_name</parameter>. Le slot physique
      copié commencera à réserver les journaux de transactions à partir du
      même <acronym>LSN</acronym> que celui du slot copié. Le paramètre
      <parameter>temporary</parameter> est en option. Si
      <parameter>temporary</parameter> est omis, la valeur du slot source
      est utilisée.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_copy_logical_replication_slot</primary>
      </indexterm>
      <function>pg_copy_logical_replication_slot</function> ( <parameter>src_slot_name</parameter> <type>name</type>, <parameter>dst_slot_name</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type> <optional>, <parameter>plugin</parameter> <type>name</type> </optional></optional> )
      <returnvalue>record</returnvalue>
      ( <parameter>slot_name</parameter> <type>name</type>,
      <parameter>lsn</parameter> <type>pg_lsn</type> )
     </para>
     <para>
      Copie un slot existant de réplication logique nommé named
      <parameter>src_slot_name</parameter> en un slot de réplication logique
      nommé <parameter>dst_slot_name</parameter>, en changeant en option son
      plugin de sortie et sa persistence. Le slot logique copié commence à
      partir du même <acronym>LSN</acronym> que celui du slot logique
      source. Les paramètres <parameter>temporary</parameter> et
      <parameter>plugin</parameter> sont optionnels&nbsp;; s'ils sont omis,
      leur valeur sur le slot source est utilisée.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_logical_slot_get_changes</primary>
      </indexterm>
      <function>pg_logical_slot_get_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
      <returnvalue>setof record</returnvalue>
      ( <parameter>lsn</parameter> <type>pg_lsn</type>,
      <parameter>xid</parameter> <type>xid</type>,
      <parameter>data</parameter> <type>text</type> )
     </para>
     <para>
      Renvoie les changements dans le slot <parameter>slot_name</parameter>,
      en commençant à partir du point où les changements ont été consommés
      en dernier. Si <parameter>upto_lsn</parameter> et
      <parameter>upto_nchanges</parameter> sont NULL, le décodage logique
      continuera jusqu'à la fin des journaux de transactions. Si
      <parameter>upto_lsn</parameter> n'est pas NULL, le décodage incluera
      seulement les transactions dont la validation date d'avant le LSN
      indiqué. Si <parameter>upto_nchanges</parameter> n'est pas NULL, le
      décodage stoppera quand le nombre de lignes produites par le décodage
      dépasse la valeur indiquée. Cependant, notez que le nombre réel de
      lignes renvoyées pourrait être plus important car cette limite est
      seulement vérifiée après l'ajout des lignes produites lors du décodage
      de chaque nouvelle validation de transaction.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_logical_slot_peek_changes</primary>
      </indexterm>
      <function>pg_logical_slot_peek_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
      <returnvalue>setof record</returnvalue>
      ( <parameter>lsn</parameter> <type>pg_lsn</type>,
      <parameter>xid</parameter> <type>xid</type>,
      <parameter>data</parameter> <type>text</type> )
     </para>
     <para>
      Se comporte comme la fonction
      <function>pg_logical_slot_get_changes()</function>, sauf que les
      changements ne sont pas consommés&nbsp;; autrement dit, ils sont de
      nouveau renvoyés lors des prochains appels.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_logical_slot_get_binary_changes</primary>
      </indexterm>
      <function>pg_logical_slot_get_binary_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
      <returnvalue>setof record</returnvalue>
      ( <parameter>lsn</parameter> <type>pg_lsn</type>,
      <parameter>xid</parameter> <type>xid</type>,
      <parameter>data</parameter> <type>bytea</type> )
     </para>
     <para>
      Se comporte comme la fonction
      <function>pg_logical_slot_get_changes()</function>, sauf que les
      changements sont renvoyés comme des <type>bytea</type>.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_logical_slot_peek_binary_changes</primary>
      </indexterm>
      <function>pg_logical_slot_peek_binary_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
      <returnvalue>setof record</returnvalue>
      ( <parameter>lsn</parameter> <type>pg_lsn</type>,
      <parameter>xid</parameter> <type>xid</type>,
      <parameter>data</parameter> <type>bytea</type> )
     </para>
     <para>
      Se comporte comme la fonction
      <function>pg_logical_slot_peek_changes()</function>, sauf que les
      modifications sont renvoyées sous la forme de <type>bytea</type>.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_replication_slot_advance</primary>
      </indexterm>
      <function>pg_replication_slot_advance</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type> )
      <returnvalue>record</returnvalue>
      ( <parameter>slot_name</parameter> <type>name</type>,
      <parameter>end_lsn</parameter> <type>pg_lsn</type> )
     </para>
     <para>
      Avance la position confirmée actuelle pour le slot de réplication
      nommé <parameter>slot_name</parameter>. Le slot ne sera pas déplacé en
      arrière, et il ne sera pas déplacé après l'emplacement d'insertion
      actuel. Renvoie le nom du slot et la position où il a été réellement
      avancé. L'information mise à jour de position du slot est écrite dans
      le prochain checkpoint si l'avance a été possible. Dans le cas d'un
      crash, le slot pourrait retourner à une position précédente.
     </para></entry>
   </row>

   <row>
    <entry id="pg-replication-origin-create" role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_replication_origin_create</primary>
      </indexterm>
      <function>pg_replication_origin_create</function> ( <parameter>node_name</parameter> <type>text</type> )
      <returnvalue>oid</returnvalue>
     </para>
     <para>
      Crée une origine de réplication avec le nom externe donné, et renvoie
      l'identifiant interne qui lui a été affecté.
     </para></entry>
   </row>

   <row>
    <entry id="pg-replication-origin-drop" role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_replication_origin_drop</primary>
      </indexterm>
      <function>pg_replication_origin_drop</function> ( <parameter>node_name</parameter> <type>text</type> )
      <returnvalue>void</returnvalue>
     </para>
     <para>
      Supprime une origine de réplication précédemment créée, incluant toute
      progression de rejeu associée.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_replication_origin_oid</primary>
      </indexterm>
      <function>pg_replication_origin_oid</function> ( <parameter>node_name</parameter> <type>text</type> )
      <returnvalue>oid</returnvalue>
     </para>
     <para>
      Recherche une origine de réplication par son nom et renvoie son
      identifiant interne. Si cette origine de réplication n'existe pas, une
      erreur est renvoyée.
     </para></entry>
   </row>

   <row>
    <entry id="pg-replication-origin-session-setup" role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_replication_origin_session_setup</primary>
      </indexterm>
      <function>pg_replication_origin_session_setup</function> ( <parameter>node_name</parameter> <type>text</type> )
      <returnvalue>void</returnvalue>
     </para>
     <para>
      Marque la session en cours comme rejouant à partir de l'origine
      donnée, en autorisant le traçage de la progression du rejeu. Peut
      seulement être utilisée si aucune origine n'est actuellement
      sélectionnée. Utilisez
      <function>pg_replication_origin_session_reset</function> pour annuler.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_replication_origin_session_reset</primary>
      </indexterm>
      <function>pg_replication_origin_session_reset</function> ()
      <returnvalue>void</returnvalue>
     </para>
     <para>
      Annule les effets de
      <function>pg_replication_origin_session_setup()</function>.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_replication_origin_session_is_setup</primary>
      </indexterm>
      <function>pg_replication_origin_session_is_setup</function> ()
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Renvoie true si une origine de réplication a été sélectionnée dans la
      session en cours.
     </para></entry>
   </row>

   <row>
    <entry id="pg-replication-origin-session-progress" role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_replication_origin_session_progress</primary>
      </indexterm>
      <function>pg_replication_origin_session_progress</function> ( <parameter>flush</parameter> <type>boolean</type> )
      <returnvalue>pg_lsn</returnvalue>
     </para>
     <para>
      Renvoie l'emplacement de rejeu pour l'origine de réplication
      sélectionnée dans la session en cours. Le paramètre
      <parameter>flush</parameter> détermine si la transaction locale
      correspondance sera garantie d'être vidée sur disque ou pas.
     </para></entry>
   </row>

   <row>
    <entry id="pg-replication-origin-xact-setup" role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_replication_origin_xact_setup</primary>
      </indexterm>
      <function>pg_replication_origin_xact_setup</function> ( <parameter>origin_lsn</parameter> <type>pg_lsn</type>, <parameter>origin_timestamp</parameter> <type>timestamp with time zone</type> )
      <returnvalue>void</returnvalue>
     </para>
     <para>
      Marque la transaction en cours comme rejouant une transaction qui a
      été validée au <acronym>LSN</acronym> et à l'horodatage donnés. Peut
      être appelé quand une origine de réplication a été sélectionnée en
      utilisant <function>pg_replication_origin_session_setup</function>.
     </para></entry>
   </row>

   <row>
    <entry id="pg-replication-origin-xact-reset" role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_replication_origin_xact_reset</primary>
      </indexterm>
      <function>pg_replication_origin_xact_reset</function> ()
      <returnvalue>void</returnvalue>
     </para>
     <para>
      Annule les effets de
      <function>pg_replication_origin_xact_setup()</function>.
     </para></entry>
   </row>

   <row>
    <entry id="pg-replication-origin-advance" role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_replication_origin_advance</primary>
      </indexterm>
      <function>pg_replication_origin_advance</function> ( <parameter>node_name</parameter> <type>text</type>, <parameter>lsn</parameter> <type>pg_lsn</type> )
      <returnvalue>void</returnvalue>
     </para>
     <para>
      Configure la progression de la réplication pour le nœud donné à
      l'emplacement donné. Ceci est principalement utile pour configurer
      l'emplacement initial ou pour configurer un nouvel emplacement après
      des changements de configuration ou similaires. Faites attention
      qu'une mauvaise utilisation de cette fonction peut amener à des
      données répliquées de façon incohérente.
     </para></entry>
   </row>

   <row>
    <entry id="pg-replication-origin-progress" role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_replication_origin_progress</primary>
      </indexterm>
      <function>pg_replication_origin_progress</function> ( <parameter>node_name</parameter> <type>text</type>, <parameter>flush</parameter> <type>boolean</type> )
      <returnvalue>pg_lsn</returnvalue>
     </para>
     <para>
      Renvoie l'emplacement de rejeu pour l'origine de réplication donnée.
      Le paramètre <parameter>flush</parameter> détermine si la transaction
      locale correspondante sera garantie d'être vidée sur disque ou pas.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_logical_emit_message</primary>
      </indexterm>
      <function>pg_logical_emit_message</function> ( <parameter>transactional</parameter> <type>boolean</type>, <parameter>prefix</parameter> <type>text</type>, <parameter>content</parameter> <type>text</type> )
      <returnvalue>pg_lsn</returnvalue>
     </para>
     <para role="func_signature">
      <function>pg_logical_emit_message</function> ( <parameter>transactional</parameter> <type>boolean</type>, <parameter>prefix</parameter> <type>text</type>, <parameter>content</parameter> <type>bytea</type> )
      <returnvalue>pg_lsn</returnvalue>
     </para>
     <para>
      Émet un message de décodage logique. Cela peut être utilisé pour
      passer des messages génériques aux plugins de décodage logique via les
      journaux de transactions. Le paramètre
      <parameter>transactional</parameter> indique si le message devrait
      faire partie de la transaction en cours ou s'il devrait être écrit
      immédiatement et décodé dès que le décodeur logique lit
      l'enregistrement. Le paramètre <parameter>prefix</parameter> est un
      préfixe textuel qui peut être utilisé par les plugins de décodage
      logique pour reconnaître facilement les messages qui les intéressent.
      Le paramètre <parameter>content</parameter> est le contenu du message,
      donné soit au format texte soit au format binaire.
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

</sect2>

<sect2 id="functions-admin-dbobject">
<title>Fonctions de gestion des objets de la base</title>

<para>
 Les fonctions listées dans <xref linkend="functions-admin-dbsize"/>
 calculent l'utilisation de l'espace disque des objets de la base, ou
 assistent dans la présentation de ces résultats. Toutes ces fonctions
 renvoient la taille mesurée en octets. <literal>NULL</literal> est renvoyé
 si un OID qui ne représente pas un objet existant est fourni à une de ces
 fonctions.
</para>

<table id="functions-admin-dbsize">
 <title>Fonctions de taille des objets</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_column_size</primary>
      </indexterm>
      <function>pg_column_size</function> ( <type>"any"</type> )
      <returnvalue>integer</returnvalue>
     </para>
     <para>
      Affiche le nombre d'octets utilisés pour enregistrer une valeur
      individuelle. Si elle est appliquée directement à une valeur d'une
      colonne de la table, cela représente la compression effectuée.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_database_size</primary>
      </indexterm>
      <function>pg_database_size</function> ( <type>name</type> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para role="func_signature">
      <function>pg_database_size</function> ( <type>oid</type> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para>
      Calcule l'espace disque total utilisé par la base dont le nom ou l'OID
      est indiqué. Pour utiliser cette fonction, vous devez avoir le droit
      <literal>CONNECT</literal> sur la base (qui est donné par défaut) ou
      être un membre du rôle <literal>pg_read_all_stats</literal>.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_indexes_size</primary>
      </indexterm>
      <function>pg_indexes_size</function> ( <type>regclass</type> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para>
      Calcule l'espace disque total utilisé par les index attachés à une
      table spécifique.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_relation_size</primary>
      </indexterm>
      <function>pg_relation_size</function> ( <parameter>relation</parameter> <type>regclass</type> <optional>, <parameter>fork</parameter> <type>text</type> </optional> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para>
      Calcule l'espace disque utilisé par un <quote>élément</quote> de la
      relation indiquée. (Notez que, dans la plupart des cas, il est
      préférable d'utiliser les fonctions
      <function>pg_total_relation_size</function> et
      <function>pg_table_size</function>, qui additionnent les tailles de
      tous les éléments d'une relation.) Avec un argument, ceci renvoie la
      taille de l'élément principal de la relation. Le second argument
      permet de préciser l'élément à examiner&nbsp;:
      <itemizedlist spacing="compact">
       <listitem>
        <para>
         <literal>main</literal> renvoie la taille de l'élément principal de
         la relation.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>fsm</literal> renvoie la taille de la carte des espaces
         libres (voir <xref linkend="storage-fsm"/>) associée à cette
         relation.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>vm</literal> renvoie la taille de la carte de visibilité
         (voir <xref linkend="storage-vm"/>) associée à cette relation.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>init</literal> renvoie la taille de l'élément
         d'initialisation, si elle existe, associée à cette relation.
        </para>
       </listitem>
      </itemizedlist>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_size_bytes</primary>
      </indexterm>
      <function>pg_size_bytes</function> ( <type>text</type> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para>
      Convertit la taille indiquée dans un format lisible par un humain
      (tel qu'il est donné par <function>pg_size_pretty</function>) en un
      nombre d'octets.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_size_pretty</primary>
      </indexterm>
      <function>pg_size_pretty</function> ( <type>bigint</type> )
      <returnvalue>text</returnvalue>
     </para>
     <para role="func_signature">
      <function>pg_size_pretty</function> ( <type>numeric</type> )
      <returnvalue>text</returnvalue>
     </para>
     <para>
      Convertit une taille indiquée en octets dans un format plus facilement
      lisible par un humain avec des unités (bytes, kB, MB, GB ou TB suivant
      le cas). Notez que les unités sont des puissances de 2, plutôt que des
      puissances de 10, donc 1kB vaut 1024 octets,
      1MB vaut 1024<superscript>2</superscript> = 1048576 octets, et ainsi
      de suite.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_table_size</primary>
      </indexterm>
      <function>pg_table_size</function> ( <type>regclass</type> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para>
      Calcule l'espace disque utilisé par la table indiquée, en excluant les
      index (mais en incluant la table TOAST si elle existe, la carte des
      espaces libres et la carte de visibilité).
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_tablespace_size</primary>
      </indexterm>
      <function>pg_tablespace_size</function> ( <type>name</type> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para role="func_signature">
      <function>pg_tablespace_size</function> ( <type>oid</type> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para>
      Calcule l'espace disque total utilisé dans le tablespace indiqué par
      son nom ou son OID. Pour utiliser cette fonction, vous devez avoir le
      droit <literal>CREATE</literal> sur le tablespace ou être un membre du
      rôle <literal>pg_read_all_stats</literal>, sauf s'il s'agit du
      tablespace par défaut de la base actuelle.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_total_relation_size</primary>
      </indexterm>
      <function>pg_total_relation_size</function> ( <type>regclass</type> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para>
      Calcule l'espace disque utilisé par la table indiquée, en incluant
      tous les index et les données <acronym>TOAST</acronym>. Le résultat
      est équivalent à <function>pg_table_size</function>
      <literal>+</literal> <function>pg_indexes_size</function>.
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

<para>
 Les fonctions ci-dessus qui opèrent sur les tables et sur les index
 acceptent un argument <type>regclass</type>, qui est simplement l'OID de
 la table ou de l'index dans le catalogue système
 <structname>pg_class</structname>. Néanmoins, vous n'avez pas besoin de
 rechercher manuellement l'OID comme le convertisseur en entrée du type de
 données <type>regclass</type> fera ce travail pour vous. Écrivez
 simplement le nom de la table entre des guillemets simples pour qu'il
 ressemble  à une constante littérale. Pour la compatibilité avec la
 gestion habituelle des noms <acronym>SQL</acronym>, la chaîne sera
 convertie en minuscules à moins qu'elle ne contienne des guillemets
 doubles autour du nom de la table.
</para>

<para>
 Les fonctions listées dans <xref linkend="functions-admin-dblocation"/>
 assistent à l'identification des fichiers spécifiques associés aux objets
 de la base.
</para>

<table id="functions-admin-dblocation">
 <title>Fonctions d'emplacement des objets de la base</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_relation_filenode</primary>
      </indexterm>
      <function>pg_relation_filenode</function> ( <parameter>relation</parameter> <type>regclass</type> )
      <returnvalue>oid</returnvalue>
     </para>
     <para>
      Renvoie le numéro <quote>filenode</quote> actuellement affecté à la
      relation indiquée. Ce numéro est le composant de base du nom du
      fichier utilisé pour la relation (voir <xref
      linkend="storage-file-layout"/> pour plus d'informations). Pour la
      plupart des relations, le résultat est identique à
      <structname>pg_class</structname>.<structfield>relfilenode</structfield>,
      mais pour certains catalogues systèmes, le
      <structfield>relfilenode</structfield> vaut zéro et cette fonction
      doit être utilisée pour obtenir la valeur correcte. La fonction
      renvoie NULL si on lui passe une relation qui n'a pas de stockage,
      comme une vue.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_relation_filepath</primary>
      </indexterm>
      <function>pg_relation_filepath</function> ( <parameter>relation</parameter> <type>regclass</type> )
      <returnvalue>text</returnvalue>
     </para>
     <para>
      Renvoie le chemin complet avec le nom du fichier pour cette relation
      (chemin relatif au répertoire principal des données de l'instance,
      <varname>PGDATA</varname>).
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_filenode_relation</primary>
      </indexterm>
      <function>pg_filenode_relation</function> ( <parameter>tablespace</parameter> <type>oid</type>, <parameter>filenode</parameter> <type>oid</type> )
      <returnvalue>regclass</returnvalue>
     </para>
     <para>
      Renvoie l'OID d'une relation d'après l'OID de son tablespace et son
      filenode. Ceci est la correspondance inverse de
      <function>pg_relation_filepath</function>. Pour une relation dans le
      tablespace par défaut de la base, le tablespace peut être indiqué par
      un zéro. Renvoie <literal>NULL</literal> si aucune relation n'est
      associée aux valeurs données dans la base en cours.
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

<para>
 <xref linkend="functions-admin-collation"/> liste les fonctions utilisées
 pour gérer les collations.
</para>

<table id="functions-admin-collation">
 <title>Fonctions de gestion des collations</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_collation_actual_version</primary>
      </indexterm>
      <function>pg_collation_actual_version</function> ( <type>oid</type> )
      <returnvalue>text</returnvalue>
     </para>
     <para>
      Renvoie la version actuelle de l'objet collation tel qu'il est installé
      sur le système d'exploitation. S'il est différent de la valeur dans
      <structname>pg_collation</structname>.<structfield>collversion</structfield>,
      alors les objets dépendant de la collation doivent être reconstruits. Voir
      aussi <xref linkend="sql-altercollation"/>.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_import_system_collations</primary>
      </indexterm>
      <function>pg_import_system_collations</function> ( <parameter>schema</parameter> <type>regnamespace</type> )
      <returnvalue>integer</returnvalue>
     </para>
     <para>
      Ajoute des collations dans le catalogue système
      <structname>pg_collation</structname> basé sur toutes les locales
      trouvées dans le système d'exploitation. Ceci est ce que
      <command>initdb</command> utilise&nbsp;; voir <xref
      linkend="collation-managing"/> pour plus de détails. Si les locales
      supplémentaires sont installées plus tard dans le système
      d'exploitation, cette fonction doit être de nouveau exécutée pour
      ajouter des collations pour les nouvelles locales. Les locales
      correspondant à des entrées existantes dans
      <structname>pg_collation</structname> seront ignorées. (Mais les
      objets de collation basés sur des locales qui ne sont plus présentes
      au niveau du système d'exploitation ne sont pas supprimées par cette
      fonction.) Le paramètre <parameter>schema</parameter> sera typiquement
      <literal>pg_catalog</literal>, mais ce n'est pas obligatoire&nbsp;;
      les collations peuvent être installés dans d'autres schémas. La
      fonction renvoie le nombre des nouveaux objets collations créés.
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

<para>
 <xref linkend="functions-info-partition"/> liste les fonctions qui
 fournissent des informations sur la structure des tables partitionnées.
</para>

<table id="functions-info-partition">
 <title>Fonctions d'information sur le partitionnement</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_partition_tree</primary>
      </indexterm>
      <function>pg_partition_tree</function> ( <type>regclass</type> )
      <returnvalue>setof record</returnvalue>
      ( <parameter>relid</parameter> <type>regclass</type>,
      <parameter>parentrelid</parameter> <type>regclass</type>,
      <parameter>isleaf</parameter> <type>boolean</type>,
      <parameter>level</parameter> <type>integer</type> )
     </para>
     <para>
      Liste les tables ou index dans l'arbre de partitionnement de la table
      ou de l'index partitionné indiqué, avec une ligne pour chaque
      partition. Les informations fournies incluent l'OID de la partition,
      l'OID de son parent immédiat, une valeur booléenne indiquant si la
      partition est une feuille et un entier indiquant son niveau dans la
      hiérarchie. Le niveau 0 correspond à la table ou l'index en entrée, 1
      pour ses partitions immédiates, 2, pour leurs partitions, et ainsi de
      suite. Ne renvoie aucune ligne si la relation n'existe pas ou s'il ne
      s'agit ni d'une table partitionnée ni d'une partition.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_partition_ancestors</primary>
      </indexterm>
      <function>pg_partition_ancestors</function> ( <type>regclass</type> )
      <returnvalue>setof regclass</returnvalue>
     </para>
     <para>
      Liste les relations ancêtres d'une partition donnée, y compris cette
      relation. Ne renvoie aucune ligne si la relation n'existe pas ou s'il
      ne s'agit ni d'une table partitionnée ni d'une partition.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_partition_root</primary>
      </indexterm>
      <function>pg_partition_root</function> ( <type>regclass</type> )
      <returnvalue>regclass</returnvalue>
     </para>
     <para>
      Renvoie le parent de plus haut niveau de l'arbre de partition à
      laquelle appartient la relation donnée. Renvoie
      <literal>NULL</literal> si la relation n'existe pas ou s'il ne s'agit
      ni d'une table partitionnée ni d'une partition.
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

<para>
 Par exemple, pour vérifier la taille totale de la donnée contenue dans une
 table partitionnée <structname>measurement</structname>, il est possible
 d'utiliser la requête suivante&nbsp;:
 <programlisting>
SELECT pg_size_pretty(sum(pg_relation_size(relid))) AS total_size
  FROM pg_partition_tree('measurement');
 </programlisting>
</para>

</sect2>

<sect2 id="functions-admin-index">
<title>Fonctions de maintenance des index</title>

<para>
 <xref linkend="functions-admin-index-table"/> liste les fonctions
 disponibles pour les tâches de maintenance d'index. (Notez que ces tâches
 de maintenance sont normalement réalisés par l'autovacuum&nbsp;;
 l'utilisation de ces fonctions est seulement requise dans des cas
 particuliers.) Ces fonctions ne peuvent pas être exécutées lors de la
 restauration. L'utilisation de ces fonctions est restreinte aux
 superutilisateurs et au propriétaire de l'index donné.
</para>

<table id="functions-admin-index-table">
 <title>Fonctions de maintenance des index</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>brin_summarize_new_values</primary>
      </indexterm>
      <function>brin_summarize_new_values</function> ( <parameter>index</parameter> <type>regclass</type> )
      <returnvalue>integer</returnvalue>
     </para>
     <para>
      Parcourt l'index BRIN spécifié pour trouver les intervalles de blocs
      da la table qui ne sont pas actuellement résumés par l'index&nbsp;;
      pour chaque intervalle, il crée un nouvel enregistrement de résumé
      dans l'index en parcourant ces blocs dans la table. Renvoie le nombre
      de nouveaux résumés d'intervalle de blocs insérés dans l'index.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>brin_summarize_range</primary>
      </indexterm>
      <function>brin_summarize_range</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>blockNumber</parameter> <type>bigint</type> )
      <returnvalue>integer</returnvalue>
     </para>
     <para>
      Résume l'intervalle de blocs couvrant le bloc donné, s'il n'est pas
      déjà résumé. Cela ressemble à
      <function>brin_summarize_new_values</function>, sauf qu'il traite
      seulement l'intervalle de blocs qui couvre le numéro de bloc de la
      table donnée.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>brin_desummarize_range</primary>
      </indexterm>
      <function>brin_desummarize_range</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>blockNumber</parameter> <type>bigint</type> )
      <returnvalue>void</returnvalue>
     </para>
     <para>
      Supprime l'enregistement de l'index BRIN qui résume l'intervalle de
      blocs couvrant le bloc de la table donnée, s'il y en a un.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>gin_clean_pending_list</primary>
      </indexterm>
      <function>gin_clean_pending_list</function> ( <parameter>index</parameter> <type>regclass</type> )
      <returnvalue>bigint</returnvalue>
     </para>
     <para>
      Supprime la liste <quote>pending</quote> de l'index GIN spécifié en
      déplaçant les enregistrements à l'intérieur, en masse, vers la
      structure principale de données GIN. Renvoie le nombre de blocs
      supprimés dans la liste d'attente. Si l'argument est un index GIN
      construit avec l'option <literal>fastupdate</literal> désactivée,
      aucun nettoyage ne survient et le résultat vaut zéro car l'index n'a
      pas de liste d'attente. Voir <xref linkend="gin-fast-update"/> et
      <xref linkend="gin-tips"/> pour les détails sur la liste d'attente et
      l'option <literal>fastupdate</literal>.
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

</sect2>

<sect2 id="functions-admin-genfile">
<title>Fonctions génériques d'accès aux fichiers</title>

<para>
 Les fonctions listées dans <xref linkend="functions-admin-genfile-table"/>
 fournissent des accès natifs aux fichiers du serveur gérant le serveur.
 Seuls les fichiers à l'intérieur du répertoire d'instance de la base et
 ceux ciblés par le paramètre <varname>log_directory</varname> peuvent être
 accédés, que l'utilisateur est un superutilisateur ou s'est vu donné le
 rôle <literal>pg_read_server_files</literal>. Utilisez un chemin relatif
 pour les fichiers du répertoire principal des données, et un chemin
 correspondant à la configuration du paramètre
 <varname>log_directory</varname> pour les fichiers de trace.
</para>

<para>
 Notez que donner aux utilisateurs le droit EXECUTE sur
 <function>pg_read_file()</function>, ou les fonctions relatives, les
 autorise à lire tout fichier du serveur que le processus serveur peut
 lire. Ces fonctions contournent toutes les vérifications de droit d'accès
 à la base. Ceci signifie que, pour un exemple, un utilisateur avec un tel
 accès est capable de lire le contenu de la table
 <structname>pg_authid</structname> où l'information d'authentification est
 stockée dans les données de la table de la base. De ce fait, donner
 l'accès à ces fonctions devrait être considéré avec attention.
</para>

<para>
 Certaines de ces fonctions prennent un paramètre
 <parameter>missing_ok</parameter> qui modifie le comportement quand le
 fichier ou le répertoire n'existe pas. Si <literal>true</literal>, la
 fonction renvoie <literal>NULL</literal> ou un ensemble vide de résultats,
 comme approprié. Si <literal>false</literal>, une erreur est levée. La
 valeur par défaut est <literal>false</literal>.
</para>

<table id="functions-admin-genfile-table">
 <title>Fonctions génériques d'accès aux fichiers</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_ls_dir</primary>
      </indexterm>
      <function>pg_ls_dir</function> ( <parameter>dirname</parameter> <type>text</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type>, <parameter>include_dot_dirs</parameter> <type>boolean</type> </optional> )
      <returnvalue>setof text</returnvalue>
     </para>
     <para>
      Renvoie le nom de tous les fichiers (et répertoires et autres fichiers
      spéciaux) dans le répertoire donné. Le paramètre
      <parameter>include_dot_dirs</parameter> indique si les
      pseudo-répertoires <quote>.</quote> et <quote>..</quote> sont à
      inclure dans le résultat&nbsp;; par défaut, ils sont exclus. Les
      inclure peut être utile dans <parameter>missing_ok</parameter> vaut
      <literal>true</literal> pour distinguer un répertoire vide d'un
      répertoire inexistant.
     </para>
     <para>
      Cette fonction est restreinte par défaut aux superutilisateurs, mais
      d'autres utilisateurs peuvent se voir donner le droit EXECUTE pour
      cette fonction.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_ls_logdir</primary>
      </indexterm>
      <function>pg_ls_logdir</function> ()
      <returnvalue>setof record</returnvalue>
      ( <parameter>name</parameter> <type>text</type>,
      <parameter>size</parameter> <type>bigint</type>,
      <parameter>modification</parameter> <type>timestamp with time zone</type> )
     </para>
     <para>
      Renvoie le nom, la taille et l'horodatage de la dernière modification
      de chaque fichier ordinaire dans le répertoire des traces du serveur.
      Les fichiers dont le nom commence avec un point, les répertoires et
      les autres fichiers spéciaux sont exclus.
     </para>
     <para>
      Cette fonction est restreinte par défaut aux superutilisateurs et aux
      utilisateurs membres du rôle <literal>pg_monitor</literal>, mais
      d'autres utilisateurs peuvent se voir donner le droit EXECUTE pour
      cette fonction.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_ls_waldir</primary>
      </indexterm>
      <function>pg_ls_waldir</function> ()
      <returnvalue>setof record</returnvalue>
      ( <parameter>name</parameter> <type>text</type>,
      <parameter>size</parameter> <type>bigint</type>,
      <parameter>modification</parameter> <type>timestamp with time zone</type> )
     </para>
     <para>
      Renvoie le nom, la taille et l'horodatage de la dernière modification
      de chaque fichier ordinaire dans le répertoire des journaux de
      transactions. Les fichiers dont le nom commence avec un point, les
      répertoires et les autres fichiers spéciaux sont exclus.
     </para>
     <para>
      Cette fonction est restreinte par défaut aux superutilisateurs et aux
      utilisateurs membres du rôle <literal>pg_monitor</literal>, mais
      d'autres utilisateurs peuvent se voir donner le droit EXECUTE pour
      cette fonction.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_ls_archive_statusdir</primary>
      </indexterm>
      <function>pg_ls_archive_statusdir</function> ()
      <returnvalue>setof record</returnvalue>
      ( <parameter>name</parameter> <type>text</type>,
      <parameter>size</parameter> <type>bigint</type>,
      <parameter>modification</parameter> <type>timestamp with time zone</type> )
     </para>
     <para>
      Renvoie le nom, la taille et l'horodatage de la dernière modification
      de chaque fichier ordinaire dans le répertoire des statuts d'archivage.
      Les fichiers dont le nom commence avec un point, les répertoires et
      les autres fichiers spéciaux sont exclus.
     </para>
     <para>
      Cette fonction est restreinte par défaut aux superutilisateurs et aux
      utilisateurs membres du rôle <literal>pg_monitor</literal>, mais
      d'autres utilisateurs peuvent se voir donner le droit EXECUTE pour
      cette fonction.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">

      <indexterm>
       <primary>pg_ls_tmpdir</primary>
      </indexterm>
      <function>pg_ls_tmpdir</function> ( <optional> <parameter>tablespace</parameter> <type>oid</type> </optional> )
      <returnvalue>setof record</returnvalue>
      ( <parameter>name</parameter> <type>text</type>,
      <parameter>size</parameter> <type>bigint</type>,
      <parameter>modification</parameter> <type>timestamp with time zone</type> )
     </para>
     <para>
      Renvoie le nom, la taille et l'horodatage de la dernière modification
      de chaque fichier ordinaire dans le répertoire des fichiers
      temporaires pour le <parameter>tablespace</parameter> indiqué. Si
      <parameter>tablespace</parameter> est omis, le tablespace
      <literal>pg_default</literal> est examiné. Les fichiers dont le nom
      commence avec un point, les répertoires et les autres fichiers
      spéciaux sont exclus.
     </para>
     <para>
      Cette fonction est restreinte par défaut aux superutilisateurs et aux
      utilisateurs membres du rôle <literal>pg_monitor</literal>, mais
      d'autres utilisateurs peuvent se voir donner le droit EXECUTE pour
      cette fonction.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_read_file</primary>
      </indexterm>
      <function>pg_read_file</function> ( <parameter>filename</parameter> <type>text</type> <optional>, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>bigint</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional></optional> )
      <returnvalue>text</returnvalue>
     </para>
     <para>
      Renvoie tout ou partie d'un fichier texte, en commençant à l'octet
      indiqué par <parameter>offset</parameter>, en renvoyant au plus
      <parameter>length</parameter> octets (moins si la fin du fichier est
      atteinte avant). Si <parameter>offset</parameter> est négatif, il est
      relatif à la fin du fichier. Si <parameter>offset</parameter> et
      <parameter>length</parameter> sont omis, le fichier entier est
      renvoyé. Les octets lus dans le fichier sont interprétés comme une
      chaîne dans l'encodage de la base&nbsp;; une erreur est renvoyée s'ils
      ne sont pas valides pour cet encodage.
     </para>
     <para>
      Cette fonction est restreinte par défaut aux superutilisateurs, mais
      d'autres utilisateurs peuvent se voir donner le droit EXECUTE pour
      cette fonction.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_read_binary_file</primary>
      </indexterm>
      <function>pg_read_binary_file</function> ( <parameter>filename</parameter> <type>text</type> <optional>, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>bigint</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional></optional> )
      <returnvalue>bytea</returnvalue>
     </para>
     <para>
      Renvoie tout ou partie d'un fichier. Cette fonction est identique à
      <function>pg_read_file</function> sauf qu'elle peut lire toute donnée
      binaire, en renvoyant le résultat sous la forme d'un
      <type>bytea</type>, et non pas d'un <type>text</type>&nbsp;; de ce
      fait, aucune vérification d'encodage n'est réalisée.
     </para>
     <para>
      Cette fonction est restreinte par défaut aux superutilisateurs, mais
      d'autres utilisateurs peuvent se voir donner le droit EXECUTE pour
      cette fonction.
     </para>
     <para>
      En combinant avec la fonction <function>convert_from</function>, cette
      fonction peut être utilisée pour lire un fichier texte dans un
      encodage spécial et le convertir dans l'encodage de la base&nbsp;:
      <programlisting>
SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');
      </programlisting>
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_stat_file</primary>
      </indexterm>
      <function>pg_stat_file</function> ( <parameter>filename</parameter> <type>text</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional> )
      <returnvalue>record</returnvalue>
      ( <parameter>size</parameter> <type>bigint</type>,
      <parameter>access</parameter> <type>timestamp with time zone</type>,
      <parameter>modification</parameter> <type>timestamp with time zone</type>,
      <parameter>change</parameter> <type>timestamp with time zone</type>,
      <parameter>creation</parameter> <type>timestamp with time zone</type>,
      <parameter>isdir</parameter> <type>boolean</type> )
     </para>
     <para>
      Renvoie un enregistement contenant la taille du fichier, son
      horodatage de dernier accès, celui de dernière modification, celui de
      dernier changement de statut (plateformes Unix uniquement),
      l'horodatage de création (Windows uniquement), et un drapeau indiquant
      si c'est un répertoire.
     </para>
     <para>
      Cette fonction est restreinte par défaut aux superutilisateurs, mais
      d'autres utilisateurs peuvent se voir donner le droit EXECUTE pour
      cette fonction.
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

</sect2>

<sect2 id="functions-advisory-locks">
<title>Fonctions sur les verrous consultatifs</title>

<para>
 Les fonctions listées dans <xref
 linkend="functions-advisory-locks-table"/> gèrent les verrous
 consultatifs. Pour les détails sur une utilisation correcte de ces
 fonctions, voir <xref linkend="advisory-locks"/>.
</para>

<para>
 Toutes ces fonctions ont pour but d'être utilisées pour verrouiller des
 ressources définies par l'application, qui peuvent être identifiées soit
 par une valeur de clé sur 64 bits, soit par deux valeurs de clés sur 32
 bits (notez que ces deux espaces de clés ne se surchargente pas). Si une
 autre session détient déjà un verrou conflictuel sur le même identifiant
 de ressource, les fonctions devront soit attendre que la ressource
 devienne disponible, soit renvoyer un résultat <literal>false</literal>,
 comme approprié pour la fonction. Les verrous peuvent être soit partagés
 soit exclusifs&nbsp;; un verrou partagé n'entre pas en conflit avec
 d'autres verrous partagés sur la même ressource, mais entre en conflit
 avec les verrous exclusifs. Les verrous peuvent se prendre au niveau de la
 session (pour qu'ils soient détenus jusqu'à leur suppression ou jusqu'à la
 fin de la session) ou au niveau de la transaction (pour qu'ils soient
 détenus jusqu'à la fin de la transaction&nbsp;; il n'existe pas de moyen
 pour les supprimer manuellement). Les demandes multiples de verrou au
 niveau session s'empilent, pour que, si le même identifiant de ressource
 est verrouillé trois fois, alors il doit y avoir trois demandes de
 déverrouillage pour relâcher la ressource avant que la session se termine.
</para>

<table id="functions-advisory-locks-table">
 <title>Fonctions pour les verrous informatifs</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_advisory_lock</primary>
      </indexterm>
      <function>pg_advisory_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
      <returnvalue>void</returnvalue>
     </para>
     <para role="func_signature">
      <function>pg_advisory_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
      <returnvalue>void</returnvalue>
     </para>
     <para>
      Obtient un verrou informatif exclusif niveau session, en attendant si nécessaire.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_advisory_lock_shared</primary>
      </indexterm>
      <function>pg_advisory_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
      <returnvalue>void</returnvalue>
     </para>
     <para role="func_signature">
      <function>pg_advisory_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
      <returnvalue>void</returnvalue>
     </para>
     <para>
      Obtient un verrou informatif partagé niveau session, en attendant si nécessaire.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_advisory_unlock</primary>
      </indexterm>
      <function>pg_advisory_unlock</function> ( <parameter>key</parameter> <type>bigint</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para role="func_signature">
      <function>pg_advisory_unlock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Relâche un verrou informatif exclusif niveau session précédemment
      acquis. Renvoie <literal>true</literal> si le verrou a été relâché
      avec succès. Si le verrou n'était pas détenu, <literal>false</literal>
      est renvoyé et, en plus, un message d'avertissement SQL est reporté au
      serveur.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_advisory_unlock_all</primary>
      </indexterm>
      <function>pg_advisory_unlock_all</function> ()
      <returnvalue>void</returnvalue>
     </para>
     <para>
      Relâche tous les verrous informatifs niveau session détenus par la
      session en cours. (Cette fonction est appelée implicitement à la fin
      d'une session, même si le client s'est mal déconnecté.)
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_advisory_unlock_shared</primary>
      </indexterm>
      <function>pg_advisory_unlock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para role="func_signature">
      <function>pg_advisory_unlock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Relâche un verrou informatif partagé niveau session précédemment
      acquis. Renvoie <literal>true</literal> si le verrou a été relâché
      avec succès. Si le verrou n'était pas détenu, <literal>false</literal>
      est renvoyé et, en plus, un message d'avertissement SQL est reporté au
      serveur.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_advisory_xact_lock</primary>
      </indexterm>
      <function>pg_advisory_xact_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
      <returnvalue>void</returnvalue>
     </para>
     <para role="func_signature">
      <function>pg_advisory_xact_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
      <returnvalue>void</returnvalue>
     </para>
     <para>
      Obtient un verrou informatif exclusif niveau transaction, en attendant
      si nécessaire.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_advisory_xact_lock_shared</primary>
      </indexterm>
      <function>pg_advisory_xact_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
      <returnvalue>void</returnvalue>
     </para>
     <para role="func_signature">
      <function>pg_advisory_xact_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
      <returnvalue>void</returnvalue>
     </para>
     <para>
      Obtient un verrou informatif partagé niveau transaction, en attendant
      si nécessaire.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_try_advisory_lock</primary>
      </indexterm>
      <function>pg_try_advisory_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para role="func_signature">
      <function>pg_try_advisory_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Obtient un verrou informatif exclusif niveau session si disponible.
      Cela va soit obtenir immédiatement le verrou et renvoyer
      <literal>true</literal>, soit renvoyer <literal>false</literal> sans
      attendre si le verrou ne peut pas être acquis immédiatement.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_try_advisory_lock_shared</primary>
      </indexterm>
      <function>pg_try_advisory_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para role="func_signature">
      <function>pg_try_advisory_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Obtient un verrou informatif partagé niveau session si disponible.
      Cela va soit obtenir immédiatement le verrou et renvoyer
      <literal>true</literal>, soit renvoyer <literal>false</literal> sans
      attendre si le verrou ne peut pas être acquis immédiatement.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_try_advisory_xact_lock</primary>
      </indexterm>
      <function>pg_try_advisory_xact_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para role="func_signature">
      <function>pg_try_advisory_xact_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Obtient un verrou informatif exclusif niveau transaction si disponible.
      Cela va soit obtenir immédiatement le verrou et renvoyer
      <literal>true</literal>, soit renvoyer <literal>false</literal> sans
      attendre si le verrou ne peut pas être acquis immédiatement.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_try_advisory_xact_lock_shared</primary>
      </indexterm>
      <function>pg_try_advisory_xact_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para role="func_signature">
      <function>pg_try_advisory_xact_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
      <returnvalue>boolean</returnvalue>
     </para>
     <para>
      Obtient un verrou informatif partagé niveau transaction si disponible.
      Cela va soit obtenir immédiatement le verrou et renvoyer
      <literal>true</literal>, soit renvoyer <literal>false</literal> sans
      attendre si le verrou ne peut pas être acquis immédiatement.
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

</sect2>

</sect1>

<sect1 id="functions-trigger">
<title>Fonctions trigger</title>

<para>
Bien que la très grande majorité des triggers implique des fonctions
triggers écrites par les utilisateurs,
<productname>PostgreSQL</productname> fournit quelques fonctions triggers
natives, pouvant être utilisées directement dans des triggers définis par
un utilisateur. Elles sont résumées dans <xref
linkend="builtin-triggers-table"/>. (Des fonctions triggers natives
supplémentaires existent pour implémenter des contraintes de clés
étrangères et des contraintes d'index différés. Ce ne sont pas celles
documentées ici car les utilisateurs ne les utilisent pas directement.)
</para>

<para>
Pour plus d'informations sur la création de triggers, voir <xref
linkend="sql-createtrigger"/>.
</para>

<table id="builtin-triggers-table">
<title>Fonctions triggers natives</title>
<tgroup cols="1">
 <thead>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     Fonction
    </para>
    <para>
     Description
    </para>
    <para>
     Exemple d'utilisation
    </para></entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>suppress_redundant_updates_trigger</primary>
     </indexterm>
     <function>suppress_redundant_updates_trigger</function> ( )
     <returnvalue>trigger</returnvalue>
    </para>
    <para>
     Supprime les opérations de mise à jour à vide. Voir ci-dessous pour
     les détails.
    </para>
    <para>
     <literal>CREATE TRIGGER ... suppress_redundant_updates_trigger()</literal>
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>tsvector_update_trigger</primary>
     </indexterm>
     <function>tsvector_update_trigger</function> ( )
     <returnvalue>trigger</returnvalue>
    </para>
    <para>
     Met à jour automatiquement une colonne <type>tsvector</type> à partir
     de la ou les colonnes documents associées. La configuration de
     recherche plein texte à utiliser est indiquée par son nom comme
     argument du trigger. Voir <xref linkend="textsearch-update-triggers"/>
     pour les détails.
    </para>
    <para>
     <literal>CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.swedish', title, body)</literal>
    </para></entry>
  </row>

  <row>
   <entry role="func_table_entry"><para role="func_signature">
     <indexterm>
      <primary>tsvector_update_trigger_column</primary>
     </indexterm>
     <function>tsvector_update_trigger_column</function> ( )
     <returnvalue>trigger</returnvalue>
    </para>
    <para>
     Met à jour automatiquement une colonne <type>tsvector</type> à partir
     d'une ou plusieurs colonnes textes associées. La configuration de
     recherche plein texte à utiliser est prise à partir d'une colonne de
     type <type>regconfig</type> dans la table. Voir <xref
     linkend="textsearch-update-triggers"/> pour les détails.
    </para>
    <para>
     <literal>CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, tsconfigcol, title, body)</literal>
    </para></entry>
  </row>
 </tbody>
</tgroup>
</table>

<para>
La fonction <function>suppress_redundant_updates_trigger</function>, quand
appliqué sur un trigger <literal>BEFORE UPDATE</literal> niveau ligne,
empêchera toute mise à jour qui ne change pas réellement les données dans
la ligne. Ceci surcharge le comportement habituel qui est de toujours
réaliser une mise à jour physique de la ligne, que les données changent ou
pas. (Ce comportement habituel rend les mises à jour plus rapides vu qu'il
n'est pas besoin de vérifier, et est aussi plus utile dans certains cas.)
</para>

<para>
Idéalement, vous devriez éviter d'exécuter des mises à jour qui ne
changent pas vraiment les données de l'enregistrement. Des mises à jour
redondantes peuvent prendre un temps considérable, tout spécialement si
beaucoup d'index sont à mettre à jour, et l'espace des lignes mortes sera
à nettoyer plus tard. Cependant, détecter ce genre de cas dans le code
client n'est pas toujours simple, voire possible, et écrire des
expressions pour les détecter peut être source d'erreurs. Une alternative
revient à utiliser
<function>suppress_redundant_updates_trigger</function>, qui ignorera les
mises à jour qui ne modifient pas les données. Vous devez faire attention
en l'utilisant. Le trigger prend un peu de temps pour chaque
enregistrement, donc si la majorité des enregistrements affectés par les
mises à jour fait un changement, l'utilisation de ce trigger rendra les
mises à jour plus lentes en moyenne.
</para>

<para>
La fonction <function>suppress_redundant_updates_trigger</function> peut
être ajoutée ainsi à une table&nbsp;:
<programlisting>
CREATE TRIGGER z_min_update
BEFORE UPDATE ON tablename
FOR EACH ROW EXECUTE FUNCTION suppress_redundant_updates_trigger();
</programlisting>
Dans la plupart des cas, vous avez besoin d'exécuter ce trigger à la fin
pour chaque ligne, pour qu'il n'écrase pas l'exécution d'autres triggers
qui voudraient modifier la ligne. Gardez en tête que les triggers sont
exécutés dans l'ordre alphabétique de leur nom, vous devez de ce fait
choisir un nom de trigger qui le fait arriver en dernier parmi les
triggers de cette table. (D'où le préfixe <quote>z</quote> dans
l'exemple.)
</para>
</sect1>

<sect1 id="functions-event-triggers">
<title>Fonctions de trigger d'événement</title>

<para>
<productname>PostgreSQL</productname> fournit des fonctions d'aide pour
récupérer des informations sur les triggers d'événement.
</para>

<para>
Pour plus d'informations sur les triggers d'événement, voir <xref
linkend="event-triggers"/>.
</para>

<sect2 id="pg-event-trigger-ddl-command-end-functions">
<title>Capturer les modifications à la fin d'une commande</title>

<indexterm>
 <primary>pg_event_trigger_ddl_commands</primary>
</indexterm>

<synopsis>
<function>pg_event_trigger_ddl_commands</function> () <returnvalue>setof record</returnvalue>
</synopsis>

<para>
 <function>pg_event_trigger_ddl_commands</function> renvoie une liste de
 commandes <acronym>DDL</acronym> exécutées par chaque action utilisateur,
 lorsqu'elles sont appelées dans une fonction attachée à un trigger
 d'événement <literal>ddl_command_end</literal>. Si appelé d'un autre
 contexte, une erreur est levée.
 <function>pg_event_trigger_ddl_commands</function> renvoie une ligne pour
 chaque commande de base exécutée&nbsp;; certaines commandes qui sont une
 simple phrase SQL pourraient renvoyer plus d'une ligne. Cette fonction
 renvoie les colonnes suivantes&nbsp;:

 <informaltable>
  <tgroup cols="3">
   <thead>
    <row>
     <entry>Nom</entry>
     <entry>Type</entry>
     <entry>Description</entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry><literal>classid</literal></entry>
     <entry><type>oid</type></entry>
     <entry>OID du catalogue d'appartenance de l'objet</entry>
    </row>
    <row>
     <entry><literal>objid</literal></entry>
     <entry><type>oid</type></entry>
     <entry>OID de l'objet lui-même</entry>
    </row>
    <row>
     <entry><literal>objsubid</literal></entry>
     <entry><type>integer</type></entry>
     <entry>identifiant du sous-objet (par exemple, le numéro d'attribut
      pour une colonne)</entry>
    </row>
    <row>
     <entry><literal>command_tag</literal></entry>
     <entry><type>text</type></entry>
     <entry>Balise de commande</entry>
    </row>
    <row>
     <entry><literal>object_type</literal></entry>
     <entry><type>text</type></entry>
     <entry>Type de l'objet</entry>
    </row>
    <row>
     <entry><literal>schema_name</literal></entry>
     <entry><type>text</type></entry>
     <entry>
      Nom du schéma d'appartenance de l'objet, s'il existe&nbsp;;
      sinon <literal>NULL</literal>. Aucun guillemet n'est utilisé.
     </entry>
    </row>
    <row>
     <entry><literal>object_identity</literal></entry>
     <entry><type>text</type></entry>
     <entry>
      Texte indiquant l'identité de l'objet, qualifié du schéma. Chaque
      identifiant inclus dans l'identifié est entre guillemets si
      nécessaire.
     </entry>
    </row>
    <row>
     <entry><literal>in_extension</literal></entry>
     <entry><type>boolean</type></entry>
     <entry>True si la commande fait partie d'un script d'extension</entry>
    </row>
    <row>
     <entry><literal>command</literal></entry>
     <entry><type>pg_ddl_command</type></entry>
     <entry>
      Une représentation complète de la commande dans le format interne.
      Ceci ne peut être affiché directement mais peut être passé à d'autres
      fonctions pour obtenir différentes pièces d'information sur la
      commande.
     </entry>
    </row>
   </tbody>
  </tgroup>
 </informaltable>
</para>
</sect2>

<sect2 id="pg-event-trigger-sql-drop-functions">
<title>Traitement des objets supprimés par une commande DDL</title>

<indexterm>
 <primary>pg_event_trigger_dropped_objects</primary>
</indexterm>

<synopsis>
<function>pg_event_trigger_dropped_objects</function> () <returnvalue>setof record</returnvalue>
</synopsis>

<para>
 <function>pg_event_trigger_dropped_objects</function> renvoie une liste de
 tous les objets supprimés par la commande pour laquelle l'événement
 <literal>sql_drop</literal> a été appelé. Si elle est appelée dans un
 autre contexte, une erreur est levée. Cette fonction renvoie les colonnes
 suivantes&nbsp;:

 <informaltable>
  <tgroup cols="3">
   <thead>
    <row>
     <entry>Nom</entry>
     <entry>Type</entry>
     <entry>Description</entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry><literal>classid</literal></entry>
     <entry><type>oid</type></entry>
     <entry>OID du catalogue d'appartenance de l'objet</entry>
    </row>
    <row>
     <entry><literal>objid</literal></entry>
     <entry><type>oid</type></entry>
     <entry>OID de l'objet lui-même</entry>
    </row>
    <row>
     <entry><literal>objsubid</literal></entry>
     <entry><type>integer</type></entry>
     <entry>Identifiant du sous-objet (par exemple le numéro d'attribut
      d'une colonne)</entry>
    </row>
    <row>
     <entry><literal>original</literal></entry>
     <entry><type>boolean</type></entry>
     <entry>True s'il s'agit d'un des objets racines de la suppression</entry>
    </row>
    <row>
     <entry><literal>normal</literal></entry>
     <entry><type>boolean</type></entry>
     <entry>
      True s'il y avait une relation de dépendance normale dans le graphe
      de dépendance amenant à cet objet
     </entry>
    </row>
    <row>
     <entry><literal>is_temporary</literal></entry>
     <entry><type>boolean</type></entry>
     <entry>
      True si c'était un objet temporaire
     </entry>
    </row>
    <row>
     <entry><literal>object_type</literal></entry>
     <entry><type>text</type></entry>
     <entry>Type de l'objet</entry>
    </row>
    <row>
     <entry><literal>schema_name</literal></entry>
     <entry><type>text</type></entry>
     <entry>
      Nom du schéma d'appartenance de l'objet, s'il existe&nbsp;;
      sinon <literal>NULL</literal>. Aucun guillemet n'est utilisé.
     </entry>
    </row>
    <row>
     <entry><literal>object_name</literal></entry>
     <entry><type>text</type></entry>
     <entry>
      Nom de l'objet, si la combinaison du schéma et du nom peut être
      utilisée comme un identifiant unique pour l'objet&nbsp;; sinon
      <literal>NULL</literal>. Aucun guillemet n'est utilisé, et le nom
      n'est jamais qualifié du schéma.
     </entry>
    </row>
    <row>
     <entry><literal>object_identity</literal></entry>
     <entry><type>text</type></entry>
     <entry>
      Texte indiquant l'identité de l'objet, qualifié du schéma. Chaque
      identifiant inclus dans l'identifié est entre guillemets si
      nécessaire.
     </entry>
    </row>
    <row>
     <entry><literal>address_names</literal></entry>
     <entry><type>text[]</type></entry>
     <entry>
      Un tableau qui, avec <literal>object_type</literal> et
      <literal>address_args</literal>, peut être utilisé dans la fonction
      <function>pg_get_object_address</function> pour recréer l'adresse de
      l'objet dans un serveur distant contenant un objet nommé de façon
      identique et de même type.
     </entry>
    </row>
    <row>
     <entry><literal>address_args</literal></entry>
     <entry><type>text[]</type></entry>
     <entry>
      Complément pour <literal>address_names</literal>
     </entry>
    </row>
   </tbody>
  </tgroup>
 </informaltable>
</para>

<para>
 La fonction <function>pg_event_trigger_dropped_objects</function> peut être
 utilisée dans un trigger d'événement tel que&nbsp;:
 <programlisting>
CREATE FUNCTION test_event_trigger_for_drops()
        RETURNS event_trigger LANGUAGE plpgsql AS $$
DECLARE
    obj record;
BEGIN
    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
    LOOP
        RAISE NOTICE '% dropped object: % %.% %',
                     tg_tag,
                     obj.object_type,
                     obj.schema_name,
                     obj.object_name,
                     obj.object_identity;
    END LOOP;
END
$$;
CREATE EVENT TRIGGER test_event_trigger_for_drops
   ON sql_drop
   EXECUTE FUNCTION test_event_trigger_for_drops();
 </programlisting>
</para>
</sect2>

<sect2 id="pg-event-trigger-table-rewrite-functions">
<title>Gérer un événement de réécriture de table</title>

<para>
 Les fonctions listées dans <xref
 linkend="functions-event-trigger-table-rewrite"/> fournissent des
 informations sur une table pour laquelle l'événement
 <literal>table_rewrite</literal> a été justement appelé. Si appelée dans
 un autre contexte, une erreur est levée.
</para>

<table id="functions-event-trigger-table-rewrite">
 <title>Fonctions d'informations sur la réécriture de table</title>
 <tgroup cols="1">
  <thead>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      Fonction
     </para>
     <para>
      Description
     </para></entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_event_trigger_table_rewrite_oid</primary>
      </indexterm>
      <function>pg_event_trigger_table_rewrite_oid</function> ()
      <returnvalue>oid</returnvalue>
     </para>
     <para>
      Renvoie l'OID de la table à réécrire.
     </para></entry>
   </row>

   <row>
    <entry role="func_table_entry"><para role="func_signature">
      <indexterm>
       <primary>pg_event_trigger_table_rewrite_reason</primary>
      </indexterm>
      <function>pg_event_trigger_table_rewrite_reason</function> ()
      <returnvalue>integer</returnvalue>
     </para>
     <para>
      Renvoie un code expliquant les raisons de la réécriture. La
      signification exacte de ces codes dépend de la version.
     </para></entry>
   </row>
  </tbody>
 </tgroup>
</table>

<para>
 Ces fonctions peuvent être utilisées dans un trigger d'événement
 ainsi&nbsp;:
 <programlisting>
CREATE FUNCTION test_event_trigger_table_rewrite_oid()
 RETURNS event_trigger
 LANGUAGE plpgsql AS
$$
BEGIN
  RAISE NOTICE 'rewriting table % for reason %',
                pg_event_trigger_table_rewrite_oid()::regclass,
                pg_event_trigger_table_rewrite_reason();
END;
$$;

CREATE EVENT TRIGGER test_table_rewrite_oid
                  ON table_rewrite
   EXECUTE FUNCTION test_event_trigger_table_rewrite_oid();
 </programlisting>
</para>
</sect2>
</sect1>

<sect1 id="functions-statistics">
<title>Fonctions d'informations statistiques</title>

<indexterm zone="functions-statistics">
<primary>fonction</primary>
<secondary>statistiques</secondary>
</indexterm>

<para>
<productname>PostgreSQL</productname> fournit une fonction pour inspecter
les statistiques complexes définies en utilisant la commande
<command>CREATE STATISTICS</command>.
</para>

<sect2 id="functions-statistics-mcv">
<title>Inspecter les listes MCV</title>

<indexterm>
 <primary>pg_mcv_list_items</primary>
</indexterm>

<synopsis>
<function>pg_mcv_list_items</function> ( <type>pg_mcv_list</type> ) <returnvalue>setof record</returnvalue>
</synopsis>

<para>
 <function>pg_mcv_list_items</function> renvoie un ensemble d'enregistrements
 décrivant tous les éléments enregistrés dans une liste <acronym>MCV</acronym>
 multi-colonnes. Elle renvoie les colonnes suivantes&nbsp;:

 <informaltable>
  <tgroup cols="3">
   <thead>
    <row>
     <entry>Nom</entry>
     <entry>Type</entry>
     <entry>Description</entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry><literal>index</literal></entry>
     <entry><type>integer</type></entry>
     <entry>index de l'élément dans la liste <acronym>MCV</acronym></entry>
    </row>
    <row>
     <entry><literal>values</literal></entry>
     <entry><type>text[]</type></entry>
     <entry>valeurs enregistrées dans l'élément MCV</entry>
    </row>
    <row>
     <entry><literal>nulls</literal></entry>
     <entry><type>boolean[]</type></entry>
     <entry>drapeaux identifiant les valeurs <literal>NULL</literal></entry>
    </row>
    <row>
     <entry><literal>frequency</literal></entry>
     <entry><type>double precision</type></entry>
     <entry>fréquence de cet élément <acronym>MCV</acronym></entry>
    </row>
    <row>
     <entry><literal>base_frequency</literal></entry>
     <entry><type>double precision</type></entry>
     <entry>fréquence de base de cet élément <acronym>MCV</acronym></entry>
    </row>
   </tbody>
  </tgroup>
 </informaltable>
</para>

<para>
 La fonction <function>pg_mcv_list_items</function> peut être utilisée comme
 ceci&nbsp;:

 <programlisting>
SELECT m.* FROM pg_statistic_ext join pg_statistic_ext_data on (oid = stxoid),
                pg_mcv_list_items(stxdmcv) m WHERE stxname = 'stts';
 </programlisting>

 Les valeurs du type <type>pg_mcv_list</type> peut être obtenues seulement
 à partir de la colonne
 <structname>pg_statistic_ext_data</structname>.<structfield>stxdmcv</structfield>.
</para>
</sect2>

</sect1>

</chapter>
