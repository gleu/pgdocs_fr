<?xml version="1.0" encoding="UTF-8"?>
<chapter id="source">
 <title>Conventions de codage pour PostgreSQL</title>

 <sect1 id="source-format">
  <title>Formatage</title>

  <para>
   Le formatage du code source utilise un espacement de quatre colonnes
   pour les tabulations, avec préservation de celles-ci
   (c'est-à-dire que les tabulations ne sont pas converties en
   espaces). Chaque niveau logique d'indentation est une tabulation
   supplémentaire.
  </para>

  <para>
   Les règles de disposition (positionnement des parenthèses, etc) suivent
   les conventions BSD. En particulier, les accolades pour les blocs de
   contrôle <literal>if</literal>, <literal>while</literal>,
   <literal>switch</literal>, etc ont leur propre ligne.
  </para>

  <para>
   Limiter la longueur des lignes pour que le code soit lisible avec une
   fenêtre de 80 colonnes. (Cela ne signifie pas que vous ne devez jamais
   dépasser 80 colonnes. Par exemple, diviser un long message d'erreur en
   plusieurs morceaux arbitraires pour respecter la consigne des 80 colonnes
   ne sera probablement pas un grand gain en lisibilité.)
  </para>

  <para>
   Pour maintenir un style de codage cohérent, ne pas utiliser les
   commentaires style C++ (<literal>//</literal>).
   <application>pgindent</application> les remplacera par <literal>/* ...
    */</literal>.
  </para>

  <para>
   Le style préféré pour les blocs multilignes de commentaires est&nbsp;:
   <programlisting>
/*
 * le commentaire commence ici
 * et continue ici
 */
   </programlisting>
   Notez que les blocs de commentaire commençant en colonne 1 seront préservés
   par <application>pgindent</application>, mais qu'il déplacera (au niveau de
   la colonne) les blocs de commentaires indentés comme tout autre texte. Si
   vous voulez préserver les retours à la ligne dans un bloc indenté, ajoutez
   des tirets comme ceci&nbsp;:
   <programlisting>
    /*----------
     * le commentaire commence ici
     * et continue ici
     *----------
     */
   </programlisting>
  </para>

  <para>
   Bien que les correctifs (patchs) soumis ne soient absolument pas tenus de
   suivre ces règles de formatage, il est recommandé de le faire. Le
   code est passé dans <application>pgindent</application> avant la sortie de
   la prochaine version, donc il n'y a pas de raison de l'écrire avec une autre
   convention de formatage.
   Une bonne règle pour les correctifs est de <quote>faire en sorte que le
    nouveau code ressemble au code existant qui l'entoure</quote>.
  </para>

  <para>
   Le répertoire <filename>src/tools</filename> contient des fichiers d'exemples
   de configuration qui peuvent être employés avec les éditeurs <productname>emacs</productname>,
   <productname>xemacs</productname> ou <productname>vim</productname>
   pour valider que le format du code écrit respecte ces conventions.
  </para>

  <para>
   Les outils de parcours de texte <application>more</application> et
   <application>less</application> peuvent être appelés de la manière
   suivante&nbsp;:
   <programlisting>more -x4
less -x4
   </programlisting>
   pour qu'ils affichent correctement les tabulations.
  </para>
 </sect1>

 <sect1 id="error-message-reporting">
  <title>Reporter les erreurs dans le serveur</title>

  <indexterm>
   <primary>ereport</primary>
  </indexterm>
  <indexterm>
   <primary>elog</primary>
  </indexterm>

  <para>
   Les messages d'erreurs, d'alertes et de traces produites dans
   le code du serveur doivent être créés avec
   <function>ereport</function> ou son ancien cousin <function>elog</function>.
   L'utilisation de cette fonction est suffisamment complexe pour nécessiter
   quelques explications.
  </para>

  <para>
   Il y a deux éléments requis pour chaque message&nbsp;: un niveau de
   sévérité (allant de <literal>DEBUG</literal> à <literal>PANIC</literal>) et un
   message texte primaire.  De plus, il y a des éléments optionnels,
   le plus commun d'entre eux est le code identifiant de l'erreur
   qui suit les conventions SQLSTATE des spécifications SQL.
   <function>ereport</function> en elle-même n'est qu'une macro shell qui
   existe principalement pour des convenances syntaxiques faisant
   ressembler la génération de messages à un seul appel d'une fonction dans
   un code source C.  Le seul paramètre directement accepté par
   <function>ereport</function> est le niveau de sévérité.  Le message texte
   primaire et les autres éléments de messages optionnels sont
   produits par appel de fonctions auxiliaires, comme
   <function>errmsg</function>, dans l'appel à
   <function>ereport</function>.
  </para>

  <para>
   Un appel typique à <function>ereport</function> peut ressembler à&nbsp;:
   <programlisting>ereport(ERROR,
        errcode(ERRCODE_DIVISION_BY_ZERO),
        errmsg("division by zero"));
   </programlisting>
   Le niveau de sévérité de l'erreur est ainsi positionné à <literal>ERROR</literal>
   (une erreur banale).  L'appel à <function>errcode</function> précise
   l'erreur SQLSTATE en utilisant une macro définie dans
   <filename>src/include/utils/errcodes.h</filename>.  L'appel à
   <function>errmsg</function> fournit le message texte primaire.
  </para>

  <para>
   Vous verrez aussi fréquemment cet ancien style, avec un ensemble
   supplémentaire de parenthèses entourant les appels de fonction
   auxiliaire&nbsp;:
   <programlisting>
ereport(ERROR,
        (errcode(ERRCODE_DIVISION_BY_ZERO),
         errmsg("division by zero")));
   </programlisting>
   Les parenthèses supplémentaires sont nécessaires pour les versions de
   <productname>PostgreSQL</productname> antérieures à la version 12, et sont
   depuis optionnelles.
  </para>

  <para>
   Exemple plus complexe&nbsp;:
   <programlisting>ereport(ERROR,
        errcode(ERRCODE_AMBIGUOUS_FUNCTION),
        errmsg("function %s is not unique",
               func_signature_string(funcname, nargs,
                                     NIL, actual_arg_types)),
        errhint("Unable to choose a best candidate function. "
                "You might need to add explicit typecasts."));
   </programlisting>
   Cela illustre l'utilisation des codes de formatage pour intégrer des
   valeurs d'exécution dans un message texte.  Un message
   <quote>conseil</quote>, optionnel, est également fourni. Les appels de
   fonction auxiliaire peuvent être écrits dans tout ordre, bien que la
   convention est de fait apparaître <function>errcode</function> et
   <function>errmsg</function> en premier.
  </para>

  <para>
   Si le niveau de sévérité est <literal>ERROR</literal> ou plus,
   <function>ereport</function> annule l'exécution de la requête en cours
   et ne rend pas la main à l'appelant.  Si le niveau de
   sévérité est moins qu'<literal>ERROR</literal>, <function>ereport</function>
   rend la main normalement.
  </para>

  <para>
   Les routines auxiliaires disponibles pour <function>ereport</function>
   sont&nbsp;:
   <itemizedlist>
    <listitem>
     <para>
      <function>errcode(sqlerrcode)</function> précise le code SQLSTATE de
      l'identifiant erreur pour la condition.  Si cette routine
      n'est pas appelée, l'identifiant l'erreur est, par défaut,
      <literal>ERRCODE_INTERNAL_ERROR</literal> quand le niveau de sévérité de
      l'erreur est <literal>ERROR</literal> ou plus haut,
      <literal>ERRCODE_WARNING</literal> quand le niveau d'erreur est
      <literal>WARNING</literal> et <literal>ERRCODE_SUCCESSFUL_COMPLETION</literal>
      pour <literal>NOTICE</literal> et inférieur.  Bien que ces valeurs par
      défaut soient souvent commodes, il faut se demander si elles
      sont appropriées avant d'omettre l'appel à
      <function>errcode()</function>.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errmsg(const char *msg, ...)</function> indique le message
      texte primaire de l'erreur et les possibles valeurs d'exécutions
      à y insérer.  Les insertions sont précisées par les codes
      de formatage dans le style <function>sprintf</function>. En plus des
      codes de formatage standard acceptés par <function>sprintf</function>,
      le code <literal>%m</literal> peut être utilisé pour insérer le message
      d'erreur retourné par <function>strerror</function> pour la valeur
      courante de <literal>errno</literal>.
      <footnote>
       <para>
        C'est-à-dire la valeur qui était courante quand l'appel à
        <function>ereport</function> a été atteinte&nbsp;; les changements
        d'<literal>errno</literal> dans les routines auxiliaires de rapports
        ne l'affecteront pas.  Cela ne sera pas vrai si vous devez
        écrire explicitement <literal>strerror(errno)</literal> dans la liste
        de paramètres de <function>errmsg</function>&nbsp;; en conséquence ne faites
        pas comme ça.
       </para>
      </footnote>
      <literal>%m</literal> ne nécessite aucune entrée correspondante dans la
      liste de paramètres pour <function>errmsg</function>.  Notez que la
      chaîne de caractères du message sera passée à travers
      <function>gettext</function> pour une possible adaptation linguistique
      avant que les codes de formatage ne soient exécutés.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errmsg_internal(const char *msg, ...)</function> fait la même
      chose que <function>errmsg</function> à l'exception que la chaîne de
      caractères du message ne sera ni traduite ni incluse dans le dictionnaire
      de messages d'internationalisation.  Cela devrait être utilisé
      pour les cas qui <quote>ne peuvent pas arriver</quote> et pour
      lesquels il n'est probablement pas intéressant de déployer un
      effort de traduction.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errmsg_plural(const char *fmt_singular, const char *fmt_plural,
       unsigned long n, ...)</function> est identique à <function>errmsg</function>
      mais avec le support pour plusieurs formes de pluriel du message.
      <replaceable>fmt_singular</replaceable> est le format singulier de
      l'anglais, <replaceable>fmt_plural</replaceable> est le format pluriel en
      anglais, <replaceable>n</replaceable> est la valeur entière qui détermine
      la forme utilisée. Les arguments restants sont formatés suivant le chaîne
      de format sélectionnée. Pour plus d'informations, voir
      <xref linkend="nls-guidelines"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errdetail(const char *msg, ...)</function> fournit un message
      <quote>détail</quote> optionnel&nbsp;; cela est utilisé quand il y a des
      informations supplémentaires qu'il semble inadéquat de mettre
      dans le message primaire. La chaîne de caractères du message est
      traitée de la même manière que celle de <function>errmsg</function>.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errdetail_internal(const char *msg, ...)</function> est
      identique à <function>errdetail</function>, sauf que le message ne
      sera ni traduit ni inclut dans le dictionnaire des messages à
      traduire. Elle doit être utilisée pour les messages de niveau détail
      pour lequel un effort de traduction est inutile, par exemple parce
      qu'ils sont trop techniques pour que cela soit utile à la majorité
      des utilisateurs.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errdetail_plural(const char *fmt_singular, const char *fmt_plural,
       unsigned long n, ...)</function> est identique à <function>errdetail</function>
      mais avec le support de plusieurs formes de pluriel pour le message. Pour
      plus d'information, voir <xref linkend="nls-guidelines"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errdetail_log(const char *msg, ...)</function> est identique à
      <function>errdetail</function> sauf que cette chaîne ne va que dans les
      traces du serveur. Elle n'est jamais envoyée au client. Si
      <function>errdetail</function> (ou un de ses équivalents ci-dessus)
      et <function>errdetail_log</function> sont
      utilisées ensemble, alors une chaîne est envoyés au client et l'autre dans
      les traces du serveur. C'est utile pour les détails d'erreur qui concernent
      la sécurité ou qui sont trop techniques pour être inclus dans le rapport
      envoyé au client.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errdetail_log_plural(const char *fmt_singular, const char
       *fmt_plural, unsigned long n, ...)</function> est identique à
      <function>errdetail_log</function>, mais avec le support de plusieurs
      formes de pluriel pour le message.
      Pour plus d'informations, voir <xref linkend="nls-guidelines"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errhint(const char *msg, ...)</function> fournit un message
      <quote>conseil</quote> optionnel&nbsp;; cela est utilisé pour offrir des
      suggestions sur la façon de régler un problème, par opposition aux
      détails effectifs au sujet de ce qui a mal tourné.  La chaîne de
      caractères du message est traitée de la même manière que celle de
      <function>errmsg</function>.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errcontext(const char *msg, ...)</function> n'est normalement
      pas appelée directement depuis un site de message de
      <function>ereport</function> mais plutôt elle est utilisée dans les
      fonctions de rappels <literal>error_context_stack</literal> pour fournir
      des informations à propos du contexte dans lequel une erreur
      s'est produite, comme les endroits courants dans la fonction PL.
      La chaîne de caractères du message est traitée de la même manière
      que celle de <function>errmsg</function>. À l'inverse des autres
      fonctions auxiliaires, celle-ci peut être appelée plus d'une fois
      dans un appel de <function>ereport</function>&nbsp;; les chaînes successives
      ainsi fournies sont concaténées et séparées pas des caractères
      d'interlignes (NL).
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errposition(int cursorpos)</function> spécifie l'endroit
      textuel d'une erreur dans la chaîne de caractères de la
      requête. Actuellement, c'est seulement utile pour les erreurs
      détectées dans les phases d'analyses lexicales et syntaxiques du
      traitement de la requête.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errtable(Relation rel)</function> spécifie une relation dont le
      nom et le schéma doivent être inclus comme champs auxiliaires du rapport
      d'erreur.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errtablecol(Relation rel, int attnum)</function> indique une
      colonne dont le nom, le nom de la table et le nom du schéma doivent être
      inclus comme champs auxiliaires du rapport d'erreur.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errtableconstraint(Relation rel, const char *conname)</function>
      spécifie une contrainte de table dont le nom, le nom de la table et le
      nom du schéma doivent être inclus comme champs du rapport d'erreur. Les
      index doivent être considérés comme des contraintes dans ce but, qu'ils
      soient ou non associés à une entrée dans
      <structname>pg_constraint</structname>. Faites attention à fournir la
      relation principale sous-jacente et non pas l'index lui-même, via
      <literal>rel</literal>.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errdatatype(Oid datatypeOid)</function> spécifie un type de
      données dont le nom et le nom du schéma doivent être inclus comme
      champs auxiliaires dans le rapport d'erreur.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errdomainconstraint(Oid datatypeOid, const char *conname)</function>
      spécifie une contrainte de domaine dont le nom, le nom du domaine et le
      nom du schéma doivent être inclus comme champs auxiliaires du rapport
      d'erreur.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errcode_for_file_access()</function> est une fonction commode
      qui sélectionne l'identifiant d'erreur SQLSTATE approprié pour
      une défaillance dans l'appel système relatif à l'accès d'un
      fichier.  Elle utilise le <literal>errno</literal> sauvegardé pour
      déterminer quel code d'erreur générer.  Habituellement cela
      devrait être utilisé en combinaison avec <literal>%m</literal> dans le
      texte du message d'erreur primaire.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errcode_for_socket_access()</function> est une fonction commode
      qui sélectionne l'identifiant d'erreur SQLSTATE approprié pour
      une défaillance dans l'appel système relatif à une socket.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errhidestmt(bool hide_stmt)</function> peut être appelé pour
      indiquer la suppression de la portion <literal>STATEMENT:</literal> d'un
      message dans le journal applicatif de postmaster. Habituellement, c'est
      approprié si le texte du message contient déjà l'instruction en cours.
     </para>
    </listitem>
    <listitem>
     <para>
      <function>errhidecontext(bool hide_ctx)</function> peut être appelé pour
      spécifier la suppression de la portion <literal>CONTEXT:</literal> d'un
      message dans les traces de postmaster. Ceci devrait seulement être utilisé
      pour les messages verbeux de débogage où l'inclusion répétée de contexte
      ferait grossir les journaux trop fortement.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <note>
   <para>
    Au moins une des fonctions <function>errtable</function>,
    <function>errtablecol</function>, <function>errtableconstraint</function>,
    <function>errdatatype</function> ou <function>errdomainconstraint</function>
    doivent être utilisées dans un appel à <function>ereport</function>. Ces
    fonctions existent pour permettre aux applications d'extraire le nom de
    l'objet de la base associé à l'erreur sans avoir à examiner le texte du
    messahe d'erreur potentiellement traduit. Ces fonctions doivent être
    utilisées dans les rapports d'erreur pour lesquels il est probable que
    les applications voudraient une gestion automatique des erreurs. À partir
    de <productname>PostgreSQL</productname> 9.3, une couverture complète existe
    pour les erreurs de la classe SQLSTATE 23 (violation des contraintes
    d'intégrité), mais il est probable que cette couverture soit étendue dans
    les prochaines versions.
   </para>
  </note>

  <para>
   Il y a une plus ancienne fonction nommée <function>elog</function>, qui
   est toujours largement utilisée.  Un appel à <function>elog</function>&nbsp;:
   <programlisting>elog(niveau, "chaine format", ...);</programlisting>
    est strictement équivalent à&nbsp;:
<programlisting>ereport(level, errmsg_internal("chaine format", ...));</programlisting>
    Le code d'erreur SQLSTATE est toujours celui par défaut,
    la chaîne de caractères du message n'est pas sujette à traduction.
    Par conséquent,
    <function>elog</function> ne devrait être utilisé que pour les erreurs
    internes et l'enregistrement de trace de débogage de bas niveau.
    N'importe quel message susceptible d'intéresser
    les utilisateurs ordinaires devrait passer par
    <function>ereport</function>.  Néanmoins, il y a suffisamment de contrôles
    des erreurs internes qui <quote>ne peuvent pas arriver</quote> dans le
    système, pour que <function>elog</function> soit toujours largement
    utilisée&nbsp;; elle est préférée pour ces messages du fait de sa simplicité
    d'écriture.
   </para>

   <para>
    Des conseils sur l'écriture de bons messages d'erreurs peuvent
    être trouvés dans la <xref linkend="error-style-guide"/>.
   </para>
  </sect1>

  <sect1 id="error-style-guide">
   <title>Guide de style des messages d'erreurs</title>

   <para>
    Ce guide de style est fourni dans l'espoir de maintenir une
    cohérence et un style facile à comprendre dans tous les messages
    générés par <productname>PostgreSQL</productname>.
   </para>

  <simplesect>
   <title>Ce qui va où</title>

   <para>
    Le message primaire devrait être court, factuel et éviter les
    références aux détails d'exécution comme le nom de fonction
    spécifique. <quote>Court</quote> veut dire <quote>devrait tenir
    sur une ligne dans des conditions normales</quote>.  Utilisez un
    message détail si nécessaire pour garder le message primaire court
    ou si vous sentez le besoin de mentionner les détails de
    l'implémentation comme un appel système particulier qui échoue.
    Les messages primaires et détails doivent être factuels.  Utilisez
    un message conseil pour les suggestions à propos de quoi faire
    pour fixer le problème, spécialement si la suggestion ne pourrait
    pas toujours être applicable.
   </para>

   <para>
    Par exemple, au lieu de&nbsp;:
<programlisting>IpcMemoryCreate: shmget(clé=%d, taille=%u, 0%o) a échoué : %m
(plus un long supplément qui est basiquement un conseil)</programlisting>
écrivez&nbsp;:
<programlisting>Primaire:    Ne peut pas créer un segment en mémoire partagée : %m
Détail:      L'appel système qui a échoué était shmget(key=%d, size=%u, 0%o).
Astuce:     Le supplément</programlisting>
   </para>

   <para>
    Raisonnement&nbsp;: garder le message primaire court aide à le garder
    au point et laisse les clients présenter un espace à l'écran sur
    la supposition qu'une ligne est suffisante pour les messages
    d'erreurs. Les messages détails et conseils peuvent être relégués
    à un mode verbeux ou peut-être dans une fenêtre pop-up détaillant
    l'erreur. De plus, les détails et les conseils devront
    normalement être supprimés des traces du serveur pour gagner de
    l'espace.  La référence aux détails d'implémentation est à éviter
    puisque les utilisateurs ne sont pas supposés connaître tous les
    détails.
   </para>

  </simplesect>

  <simplesect>
   <title>Formatage</title>

   <para>
    N'émettez pas d'hypothèses spécifiques à propos du formatage dans
    les messages textes.  Attendez-vous à ce que les clients et les traces
    du serveur enveloppent les lignes pour correspondre à leurs
    propres besoins.  Dans les messages longs, les caractères
    d'interlignes (\n) peuvent être utilisés pour indiquer les
    coupures suggérées d'un paragraphe.  Ne terminez pas un message
    avec un caractère d'interlignes.  N'utilisez pas des tabulations
    ou d'autres caractères de formatage (dans les affichages des
    contextes d'erreurs, les caractères d'interlignes sont
    automatiquement ajoutés pour séparer les niveaux d'un contexte
    comme dans les appels aux fonctions).
   </para>

   <para>
    Raisonnement&nbsp;: les messages ne sont pas nécessairement affichés
    dans un affichage de type terminal.  Dans les interfaces
    graphiques ou les navigateurs, ces instructions de formatage sont,
    au mieux, ignorées.
   </para>

  </simplesect>

  <simplesect>
   <title>Guillemets</title>

   <para>
    Les textes en anglais devraient utiliser des guillemets doubles
    quand la mise entre guillemets est appropriée.  Les textes dans
    les autres langues devraient uniformément employer un genre de
    guillemets qui est conforme aux coutumes de publication et à la
    sortie visuelle des autres programmes.
   </para>

   <para>
    Raisonnement&nbsp;: le choix des guillemets doubles sur celui des
    guillemets simples est quelque peu arbitraire mais tend à être
    l'utilisation préférée.  Certains ont suggéré de choisir le type
    de guillemets en fonction du type d'objets des conventions SQL
    (notamment, les chaînes de caractères entre guillemets simples,
    les identifiants entre guillemets doubles).  Mais ceci est un
    point technique à l'intérieur du langage avec lequel beaucoup
    d'utilisateurs ne sont pas familiers&nbsp;; les conventions SQL ne
    prennent pas en compte les autres genres de termes entre
    guillemets, ne sont pas traduites dans d'autres langues et
    manquent un peu de sens aussi.
   </para>

  </simplesect>

  <simplesect>
   <title>Utilisation des guillemets</title>

   <para>
    Utilisez toujours les guillemets pour délimiter les noms de
    fichiers, les identifiants fournis par les utilisateurs et les
    autres variables qui peuvent contenir des mots.  Ne les utilisez
    pas pour marquer des variables qui ne contiennent pas de mots (par
    exemple, les noms d'opérateurs).
   </para>

   <para>
    Il y a des fonctions au niveau du serveur qui vont, au besoin,
    mettre entre guillemets leur propre flux de sortie (par exemple,
    <function>format_type_be()</function>).  Ne mettez pas de guillemets
    supplémentaires autour du flux de sortie de ce genre de fonctions.
   </para>

   <para>
    Raisonnement&nbsp;: les objets peuvent avoir un nom qui crée une
    ambiguïté une fois incorporé dans un message. Soyez prudent en
    indiquant où un nom commence et fini.  Mais n'encombrez pas les
    messages avec des guillemets qui ne sont pas nécessaires ou qui
    sont dupliqués.
   </para>

  </simplesect>

  <simplesect>
   <title>Grammaire et ponctuation</title>

   <para>
    Les règles sont différentes pour les messages d'erreurs primaires
    et pour les messages détails/conseils&nbsp;:
   </para>

   <para>
    Messages d'erreurs primaires&nbsp;: ne mettez pas en majuscule la
    première lettre.  Ne terminez pas un message avec un point.  Ne
    pensez même pas à finir un message avec un point d'exclamation.
   </para>

   <para>
    Messages détails et conseils&nbsp;: utilisez des phrases complètes et
    toutes terminées par des points. Mettez en majuscule le premier mot
    des phrases. Placez deux espaces après le point si une autre phrase
    suit (pour un texte en anglais... cela pourrait être différent dans une
    autre langue).
   </para>

   <para>
    Chaînes de contexte d'erreur: Ne mettez pas en majuscule la première
    lettre et ne terminer pas la chaîne avec un point. Les chaînes de
    contexte ne sont normalement pas des phrases complètes.
   </para>

   <para>
    Raisonnement&nbsp;: éviter la ponctuation rend plus facile, pour les
    applications clientes, l'intégration du message dans des contextes
    grammaticaux variés. Souvent, les messages primaires ne sont de
    toute façon pas des phrases complètes (et s'ils sont assez longs
    pour être sur plusieurs phrases, ils devraient être divisés en une
    partie primaire et une partie détail). Cependant, les messages
    détails et conseils sont longs et peuvent avoir besoin d'inclure
    de nombreuses phrases. Pour la cohérence, ils devraient suivre le
    style des phrases complètes même s'il y a seulement une phrase.
   </para>

  </simplesect>

  <simplesect>
   <title>Majuscule contre minuscule</title>

   <para>
    Utilisez les minuscules pour les mots d'un message, inclus la
    première lettre d'un message d'erreur primaire.  Utilisez les
    majuscules pour les commandes et les mots-clé SQL s'ils
    apparaissent dans le message.
   </para>

   <para>
    Raisonnement&nbsp;: il est plus facile de rendre toutes les choses plus
    cohérentes au regard de cette façon, puisque certains messages
    sont des phrases complètes et d'autres non.
   </para>

  </simplesect>

  <simplesect>
   <title>Éviter la voix passive</title>

   <para>
    Utilisez la voix active. Utilisez des phrases complètes quand il
    y a un sujet (<quote>A ne peut pas faire B</quote>). Utilisez le
    style télégramme, sans sujet, si le sujet est le programme
    lui-même&nbsp;; n'utilisez pas <quote>Je</quote> pour le programme.
   </para>

   <para>
    Raisonnement&nbsp;: le programme n'est pas humain. Ne prétendez pas
    autre chose.
   </para>

  </simplesect>

  <simplesect>
   <title>Présent contre passé</title>

   <para>
    Utilisez le passé si une tentative de faire quelque chose
    échouait, mais pourrait peut-être réussir la prochaine fois
    (peut-être après avoir corriger certains problèmes). Utilisez le
    présent si l'échec est sans doute permanent.
   </para>

   <para>
    Il y a une différence sémantique non triviale entre les phrases de
    la forme&nbsp;:
<programlisting>n'a pas pu ouvrir le fichier "%s": %m</programlisting>
et&nbsp;:
<programlisting>ne peut pas ouvrir le dossier "%s"</programlisting>
    La première forme signifie que la tentative d'ouverture du fichier
    a échoué.  Le message devrait donner une raison comme
    <quote>disque plein</quote> ou
    <quote>le fichier n'existe pas</quote>. Le passé est approprié
    parce que la prochaine fois le disque peut ne plus être plein ou
    le fichier en question peut exister.
   </para>

   <para>
    La seconde forme indique que la fonctionnalité d'ouvrir le fichier
    nommé n'existe pas du tout dans le programme ou que c'est
    conceptuellement impossible.  Le présent est approprié car la
    condition persistera indéfiniment.
   </para>

   <para>
    Raisonnement&nbsp;: d'accord, l'utilisateur moyen ne sera pas capable
    de tirer de grandes conclusions simplement à partir du temps du
    message mais, puisque la langue nous fournit une grammaire, nous
    devons l'utiliser correctement.
   </para>

  </simplesect>

  <simplesect>
   <title>Type de l'objet</title>

   <para>
    En citant le nom d'un objet, spécifiez quel genre d'objet c'est.
   </para>

   <para>
    Raisonnement&nbsp;: sinon personne ne saura ce qu'est
    <quote>foo.bar.baz</quote>.
   </para>

  </simplesect>

  <simplesect>
   <title>Crochets</title>

   <para>
    Les crochets sont uniquement utilisés (1) dans les synopsis des
    commandes pour indiquer des arguments optionnels ou (2) pour
    indiquer l'indice inférieur d'un tableau.
   </para>

   <para>
    Raisonnement&nbsp;: rien de ce qui ne correspond pas à l'utilisation
    habituelle, largement connue troublera les gens.
   </para>

  </simplesect>

  <simplesect>
   <title>Assembler les messages d'erreurs</title>

   <para>
   Quand un message inclut du texte produit ailleurs,
   il est intégré dans ce style&nbsp;:
<programlisting>n'a pas pu ouvrir le fichier %s: %m</programlisting>
   </para>

   <para>
    Raisonnement&nbsp;: il serait difficile d'expliquer tous les codes
    d'erreurs possibles pour coller ceci dans une unique phrase douce,
    ainsi une certaine forme de ponctuation est nécessaire.  Mettre le
    texte inclus entre parenthèses a été également suggéré, mais ce
    n'est pas naturel si le texte inclus est susceptible d'être la
    partie la plus importante du message, comme c'est souvent le cas.
   </para>

  </simplesect>

  <simplesect>
   <title>Raisons pour les erreurs</title>

   <para>
    Les messages devraient toujours indiquer la raison pour laquelle
    une erreur s'est produite. Par exemple&nbsp;:
<programlisting>MAUVAIS :  n'a pas pu ouvrir le fichier %s
MEILLEUR : n'a pas pu ouvrir le fichier %s (échec E/S)</programlisting>
    Si aucune raison n'est connue, vous feriez mieux de corriger le code.
   </para>

  </simplesect>

  <simplesect>
   <title>Nom des fonctions</title>

   <para>
    N'incluez pas le nom de la routine de rapport dans le texte de
    l'erreur.  Nous avons d'autres mécanismes pour trouver cela quand
    c'est nécessaire et, pour la plupart des utilisateurs, ce n'est pas
    une information utile. Si le texte de l'erreur n'a plus beaucoup
    de sens sans le nom de la fonction, reformulez-le.
<programlisting>+BAD:    pg_strtoint32: error in "z": cannot parse "z"
BETTER: invalid input syntax for type integer: "z"</programlisting>
   </para>

   <para>
    Évitez de mentionner le nom des fonctions appelées, au lieu de
    cela dites ce que le code essayait de faire&nbsp;:
<programlisting>MAUVAIS :  ouvrir() a échoué : %m
MEILLEUR : n'a pas pu ouvrir le fichier %s: %m</programlisting>
    Si cela semble vraiment nécessaire, mentionnez l'appel système
    dans le message détail (dans certains cas, fournir les valeurs
    réelles passées à l'appel système pourrait être une information
    appropriée pour le message détail).
   </para>

   <para>
    Raisonnement&nbsp;: les utilisateurs ne savent pas tout ce que ces
    fonctions font.
   </para>

  </simplesect>

  <simplesect>
   <title>Mots délicats à éviter</title>

  <formalpara>
    <title>Incapable</title>
   <para>
    <quote>Incapable</quote> est presque la voix passive.  Une
    meilleure utilisation est <quote>ne pouvait pas</quote> ou
    <quote>ne pourrait pas</quote> selon les cas.
   </para>
  </formalpara>

  <formalpara>
    <title>Mauvais</title>
   <para>
    Les messages d'erreurs comme <quote>mauvais résultat</quote> sont
    vraiment difficile à interpréter intelligemment. Cela est mieux
    d'écrire pourquoi le résultat est <quote>mauvais</quote>, par
    exemple, <quote>format invalide</quote>.
   </para>
  </formalpara>

  <formalpara>
    <title>Illégal</title>
   <para>
    <quote>Illégal</quote> représente une violation de la loi, le
    reste est <quote>invalide</quote>. Meilleur encore, dites
    pourquoi cela est invalide.
   </para>
  </formalpara>

  <formalpara>
   <title>Inconnu</title>
   <para>
    Essayez d'éviter <quote>inconnu</quote>.  Considérez
    <quote>erreur : réponse inconnue</quote>.  Si vous ne savez pas
    qu'elle est la réponse, comment savez-vous que cela est
    incorrect&nbsp;? <quote>Non reconnu</quote> est souvent un meilleur
    choix.  En outre, assurez-vous d'inclure la valeur pour laquelle il
    y a un problème.
<programlisting>MAUVAIS :  type de n&oelig;ud inconnu
MEILLEUR : type de n&oelig;ud non reconnu : 42</programlisting>
   </para>
  </formalpara>

  <formalpara>
    <title>Trouver contre Exister</title>
   <para>
    Si le programme emploie un algorithme non trivial pour localiser
    une ressource (par exemple, une recherche de chemin) et que
    l'algorithme échoue, il est juste de dire que le programme n'a pas
    pû <quote>trouver</quote> la ressource. D'un autre côté, si
    l'endroit prévu pour la ressource est connu mais que le programme
    ne peut pas accéder à celle-ci, alors dites que la ressource
    n'<quote>existe</quote> pas. Utilisez <quote>trouvez</quote> dans
    ce cas là semble faible et embrouille le problème.
   </para>
  </formalpara>

  <formalpara>
    <title>May vs. Can vs. Might</title>
   <para>
    <quote>May</quote> suggère un droit (par exemple <foreignphrase>You may
    borrow my rake.</foreignphrase>) et a peu d'utilité dans la documentation
    et dans les messages d'erreur.
    <quote>Can</quote> suggère une capacité (par exemple <foreignphrase>I can
    lift that log.</foreignphrase>), et <quote>might</quote> suggère une
    possibilité (par exemple <foreignphrase>It might rain today.</foreignphrase>).
    Utiliser le bon mot clarifie la signification et aide les traducteurs.
   </para>
  </formalpara>

  <formalpara>
    <title>Contractions</title>
   <para>
    Éviter les contractions comme <quote>can't</quote>&nbsp;; utilisez
    <quote>cannot</quote> à la place.
   </para>
  </formalpara>

  </simplesect>

  <simplesect>
   <title>Orthographe appropriée</title>

   <para>
    Orthographiez les mots en entier.  Par exemple, évitez&nbsp;:
  <itemizedlist>
   <listitem>
    <para>
     spec (NdT&nbsp;: spécification)
    </para>
   </listitem>
   <listitem>
    <para>
     stats (NdT&nbsp;: statistiques)
    </para>
   </listitem>
   <listitem>
    <para>
     params (NdT&nbsp;: paramètres)
    </para>
   </listitem>
   <listitem>
    <para>
     auth (NdT&nbsp;: authentification)
    </para>
   </listitem>
   <listitem>
    <para>
     xact (NdT&nbsp;: transaction)
    </para>
   </listitem>
  </itemizedlist>
   </para>

   <para>
    Raisonnement&nbsp;: cela améliore la cohérence.
   </para>

  </simplesect>

  <simplesect>
   <title>Adaptation linguistique</title>

   <para>
    Gardez à l'esprit que les textes des messages d'erreurs ont besoin
    d'être traduit en d'autres langues.  Suivez les directives dans la
    <xref linkend="nls-guidelines"/> pour éviter de rendre la vie
    difficile aux traducteurs.
   </para>
  </simplesect>

  </sect1>

  <sect1 id="source-conventions">
   <title>Conventions diverses de codage</title>

   <simplesect>
    <title>Standard C</title>
    <para>
     Le code dans <productname>PostgreSQL</productname> devrait seulement se
     baser sur les fonctionnalités disponibles dans le standard C99. Ceci
     signifie qu'un compilateur se conformant au standard C99 doit être
     capable de compiler PostgreSQL, à l'exception possible de quelques
     parties dépendantes de la plateforme.
    </para>
    <para>
     Certaines fonctionnalités incluses dans le standard C99 ne sont
     actuellement pas autorisées dans le code principal de
     <productname>PostgreSQL</productname>. Ceci inclut actuellement les
     tableaux de longueur variable, les déclarations mêlées dans le code, les
     commentaires <literal>//</literal>, les noms de caractères universels.
     Les raisons incluent entre autre la portabilité et les pratiques
     historiques.
    </para>
    <para>
     Les fonctionnalités des révisions ultérieures du standard C ou du
     compilateur peuvent être utilisées si un contournement est fourni.
    </para>
    <para>
     Par exemple <literal>_Static_assert()</literal> et
     <literal>__builtin_constant_p</literal> sont actuellement utilisés, même
     s'ils font partie, respectivement, d'une révision plus récente du
     standard C et d'une extension <productname>GCC</productname>. S'ils ne
     sont pas disponibles, nous retournons respectivement vers l'utilisation
     d'un remplacement C99 compatible réalisant les mêmes vérifications, mais
     émet des messages plutôt incompréhensibles et nous n'utilisons pas
     <literal>__builtin_constant_p</literal>.
    </para>
   </simplesect>

   <simplesect>
    <title>Macros du style fonctions et fonctions inline</title>
    <para>
     Les macros avec arguments et les fonctions <literal>static inline</literal>
     peuvent être utilisés. Ces dernières sont préférables s'il y a un risque
     d'évaluations multiples si elles sont écrites en tant que macro, comme par
     exemple le cas avec&nbsp;
<programlisting>
#define Max(x, y)       ((x) &gt; (y) ? (x) : (y))
   </programlisting>
   ou quand la macro deviendrait très longue. Dans d'autres cas, il est
   possible d'utiliser des macros ou au moins plus facilement. Par
   exemple parce que des expressions de types divers ont besoin d'être passées
   à la macro.
  </para>
  <para>
   Quand la définition d'une fonction inline référence des symboles
   (autrement dit des variables, des fonctions) uniquement disponibles dans le
   moteur, la fonction pourrait ne pas être visible lorsqu'elle est incluse
   dans le code frontend.
   <programlisting>
#ifndef FRONTEND
static inline MemoryContext
MemoryContextSwitchTo(MemoryContext context)
{
    MemoryContext old = CurrentMemoryContext;

    CurrentMemoryContext = context;
    return old;
}
#endif   /* FRONTEND */
   </programlisting>
   Dans cet exemple, <literal>CurrentMemoryContext</literal>, qui est
   seulement disponible dans le moteur, est référencé et la fonction
   est donc cachée avec un <literal>#ifndef FRONTEND</literal>. Cette règle
   existe parce que certains compilateurs émettent des références aux symboles
   contenus dans les fonctions inline même si la fonction n'est pas utilisée.
  </para>
 </simplesect>

 <simplesect>
  <title>Écrire des gestionnaires de signaux</title>
  <para>
   Pour pouvoir être exécuté à l'intérieur d'un gestionnaire de signal, le
   code doit être écrit avec beaucoup d'attention. Le problème fondamental
   est qu'un gestion de signal peut interrompre le code à tout moment, sauf
   s'il est bloqué. Si le code à l'intérieur d'un gestionnaire de signal
   utilise le même état que le code en dehors, un grand chaos peut survenir.
   Comme exemple, pensez à ce qui arriverait si un gestionnaire de signal
   essaie d'obtenir un verrou qui est déjà détenu par le code interrompu.
  </para>
  <para>
   En dehors d'arrangements spéciaux, le code dans les gestionnaires de
   signaux doit seulement appeler des fonctions saines de signal
   asynchrone (d'après la définition de POSIX) et accèder à des variables
   de type <literal>volatile sig_atomic_t</literal>. Quelques fonctions
   dans <command>postgres</command> sont aussi déclarées comme saines pour
   les signaux, notamment <literal>SetLatch()</literal>.
  </para>
  <para>
   Dans la plupart des cas, les gestionnaires de signaux ne devraient rien
   faire de plus que de noter qu'un signal est arrivé, et réveiller du code
   à l'extérieur du gestionnaire en utilisant un
   <foreignphrase>latch</foreignphrase>. Voici un exemple d'un tel
   gestionnaire&nbsp;:
   <programlisting>
static void
handle_sighup(SIGNAL_ARGS)
{
    int         save_errno = errno;

    got_SIGHUP = true;
    SetLatch(MyLatch);

    errno = save_errno;
}
   </programlisting>
   <literal>errno</literal> est sauvegardé puis restauré parce que
   <function>SetLatch()</function> pourrait le modifier. Si cela n'était pas
   fait, le code interrompi qui était en train d'inspecter
   <varname>errno</varname> pourrait voir la mauvaise valeur.
  </para>
 </simplesect>

 <simplesect>
  <title>Appeler des pointeurs de fonction</title>

  <para>
   Pour plus de clareté, il est préféré de déréférencer explicitement un
   pointeur de fonction lors de l'appel de cette fonction si le pointeur est
   une simple variable, par exemple&nbsp;:
   <programlisting>
(*emit_log_hook) (edata);
   </programlisting>
   (même si <literal>emit_log_hook(edata)</literal> fonctionnerait aussi).
   Quand le pointeur de fonction fait partie d'une structure, la ponctuation
   supplémentaire peut et devrait habituellement être omise. Par
   exemple&nbsp;:
   <programlisting>
paramInfo->paramFetch(paramInfo, paramId);
   </programlisting>
  </para>
 </simplesect>
</sect1>
</chapter>
