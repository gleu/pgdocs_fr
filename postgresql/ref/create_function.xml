<?xml version="1.0" encoding="UTF-8"?>
<refentry id="sql-createfunction">
 <indexterm zone="sql-createfunction">
  <primary>CREATE FUNCTION</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE FUNCTION</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE FUNCTION</refname>
  <refpurpose>Définir une nouvelle fonction</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <synopsis>CREATE [ OR REPLACE ] FUNCTION
    <replaceable class="parameter">nom</replaceable> ( [ [ <replaceable class="parameter">modearg</replaceable> ] [ <replaceable class="parameter">nomarg</replaceable> ] <replaceable class="parameter">typearg</replaceable>  [ { DEFAULT | = } <replaceable class="parameter">expression_par_defaut</replaceable> ] [, ...] ] ) ] )
    [ RETURNS <replaceable class="parameter">type_ret</replaceable>
      | RETURNS TABLE ( <replaceable class="parameter">nom_colonne</replaceable> <replaceable class="parameter">type_colonne</replaceable> [, ...] ) ]
  { LANGUAGE <replaceable class="parameter">nom_lang</replaceable>
    | TRANSFORM { FOR TYPE <replaceable class="parameter">nom_type</replaceable> } [, ... ]
    | WINDOW
    | IMMUTABLE | STABLE | VOLATILE | [ NOT ] LEAKPROOF
    | CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
    | [EXTERNAL] SECURITY INVOKER | [EXTERNAL] SECURITY DEFINER
    | PARALLEL { UNSAFE | RESTRICTED | SAFE }
    | COST <replaceable class="parameter">cout_execution</replaceable>
    | ROWS <replaceable class="parameter">nb_lignes_resultat</replaceable>
    | SUPPORT <replaceable class="parameter">fonction_support</replaceable>
    | SET <replaceable class="parameter">parametre</replaceable> { TO <replaceable class="parameter">value</replaceable> | = <replaceable class="parameter">value</replaceable> | FROM CURRENT }
    | AS '<replaceable class="parameter">definition</replaceable>'
    | AS '<replaceable class="parameter">fichier_obj</replaceable>', '<replaceable class="parameter">symbole_lien</replaceable>'
  } ...
  </synopsis>
 </refsynopsisdiv>

 <refsect1 id="sql-createfunction-description">
  <title>Description</title>

  <para>
   <command>CREATE FUNCTION</command> définit une nouvelle fonction.
   <command>CREATE OR REPLACE FUNCTION</command> crée une nouvelle fonction
   ou la remplace si elle existe déjà.
   Pour pouvoir créer une fonction, l'utilisateur doit avoir le droit
   <literal>USAGE</literal> sur le langage associé.
  </para>

  <para>
   Si un nom de schéma est précisé, la fonction est créée dans le schéma
   indiqué. Sinon, elle est créée dans le schéma courant. Le nom de la
   nouvelle fonction ne peut pas correspondre à celui d'une fonction ou
   procédure existante avec les mêmes types d'arguments en entrée dans le même
   schéma. Toutefois, les fonctions et procédures de types d'arguments
   différents peuvent partager le même nom (ceci est appelé
   <firstterm>surcharge</firstterm>).
  </para>

  <para>
   Pour remplacer la définition actuelle d'une fonction existante,
   <command>CREATE OR REPLACE FUNCTION</command> est utilisé. Il n'est pas possible de
   changer le nom ou les types d'argument d'une fonction de cette façon
   (cela crée une nouvelle fonction distincte). De
   même, <command>CREATE OR REPLACE FUNCTION</command> ne permet pas
   de modifier le type retour d'une fonction existante. Pour cela, il est nécessaire
   de supprimer et de recréer la fonction. (Lors de l'utilisation de paramètres
   <literal>OUT</literal>, cela signifie que le type d'un paramètre
   <literal>OUT</literal> ne peut être modifié que par
   la suppression de la fonction.)
  </para>

  <para>
   Quand <command>CREATE OR REPLACE FUNCTION</command> est utilisé pour
   remplacer une fonction existante, le propriétaire et les droits de la
   fonction ne changent pas. Toutes les autres propriétés de la fonction se
   voient affectées les valeurs spécifiées dans la commande ou implicites pour
   les autres. Vous devez être le propriétaire de la fonction pour la
   remplacer ou être un membre du rôle propriétaire de la fonction.
  </para>

  <para>
   En cas de suppression et de recréation d'une fonction, la nouvelle fonction n'est pas
   la même entité que l'ancienne&nbsp;; il faut supprimer les règles, vues,
   déclencheurs, etc. qui référencent l'ancienne fonction.
   <command>CREATE OR REPLACE FUNCTION</command> permet de modifier la définition
   d'une fonction sans casser les objets qui s'y réfèrent.
   De plus, <command>ALTER FUNCTION</command> peut être utilisé pour modifier la
   plupart des propriétés supplémentaires d'une fonction existante.
  </para>

  <para>
   L'utilisateur qui crée la fonction en devient le propriétaire.
  </para>

  <para>
   Pour pouvoir créer une fonction, vous devez avoir le droit
   <literal>USAGE</literal> sur les types des arguments et de la valeur de
   retour.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>

   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>

    <listitem>
     <para>
      Le nom de la fonction à créer (éventuellement qualifié du nom du schéma).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">modearg</replaceable></term>

    <listitem>
     <para>
      Le mode d'un argument&nbsp;: <literal>IN</literal>,
      <literal>OUT</literal>, <literal>INOUT</literal> ou
      <literal>VARIADIC</literal>. En cas d'omission, la valeur par défaut est
      <literal>IN</literal>.
      Seuls des arguments <literal>OUT</literal> peuvent suivre un argument
      <literal>VARIADIC</literal>.
      Par ailleurs, des arguments <literal>OUT</literal> et <literal>INOUT</literal> ne peuvent
      pas être utilisés en même temps que la notation <literal>RETURNS TABLE</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nomarg</replaceable></term>

    <listitem>
     <para>
      Le nom d'un argument. Quelques langages (incluant SQL et PL/pgSQL)
      permettent d'utiliser ce nom dans le corps de la fonction.
      Pour les autres langages, le nom d'un argument en entrée est purement
      documentaire en ce qui concerne la fonction elle-même. Mais vous pouvez
      utiliser les noms d'arguments en entrée lors de l'appel d'une fonction
      pour améliorer la lisibilité (voir <xref
      linkend="sql-syntax-calling-funcs"/>). Dans tous les cas, le nom d'un
      argument en sortie a une utilité car il définit le nom de la colonne
      dans la ligne résultat. (En cas d'omission du nom d'un argument en
      sortie, le système choisit un nom de colonne par défaut.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">argtype</replaceable></term>

    <listitem>
     <para>
      Le(s) type(s) de données des arguments de la fonction (éventuellement
      qualifié du nom du schéma), s'il y en a. Les types des arguments
      peuvent être basiques, composites ou de domaines, ou
      faire référence au type d'une colonne.
     </para>
     <para>
      En fonction du langage, il est possible d'indiquer
      des <quote>pseudotypes</quote>, tel que <type>cstring</type>. Les
      pseudotypes indiquent que le type d'argument réel est soit non
      complètement spécifié, soit en dehors de l'ensemble des types de données
      ordinaires du SQL.
     </para>
     <para>
      Il est fait référence au type d'une colonne par
      <literal><replaceable class="parameter">nom_table</replaceable>.<replaceable class="parameter">nomcolonne</replaceable>%TYPE</literal>.
      Cette fonctionnalité peut servir à rendre une fonction
      indépendante des modifications de la définition d'une table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">expression_par_defaut</replaceable></term>

    <listitem>
     <para>
      Une expression à utiliser en tant que valeur par défaut si le
      paramètre n'est pas spécifié. L'expression doit pouvoir être coercible
      dans le type d'argument du paramètre.
      Seuls les paramètres d'entrée (dont les <literal>INOUT</literal>) peuvent
      avoir une valeur par défaut. Tous les paramètres d'entrée suivant un
      paramètre avec une valeur par défaut doivent aussi avoir une valeur par
      défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_ret</replaceable></term>

    <listitem>
     <para>
      Le type de données en retour (éventuellement qualifié du nom du schéma).
      Le type de retour peut être un type basique, composite ou de domaine,
      ou faire référence au type d'une colonne
      existante. En fonction du langage, il est possible d'indiquer
      un <quote>pseudotype</quote>, tel que <type>cstring</type>.
      Si la fonction ne doit pas renvoyer de valeur, on indique
      <type>void</type> comme type de retour.
     </para>
     <para>
      Quand il y a des paramètres <literal>OUT</literal> ou <literal>INOUT</literal>, la
      clause <literal>RETURNS</literal> peut être omise. Si elle est présente, elle
      doit correspondre au type de résultat imposé par les paramètres de
      sortie&nbsp;: <literal>RECORD</literal> s'il y en a plusieurs,
      ou le type du seul paramètre en sortie.
     </para>
     <para>
      Le modificateur <literal>SETOF</literal> indique que la fonction retourne
      un ensemble d'éléments plutôt qu'un seul.
     </para>
     <para>
      Il est fait référence au type d'une colonne par
      <literal><replaceable class="parameter">nom_table</replaceable>.<replaceable class="parameter">nomcolonne</replaceable>%TYPE</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_colonne</replaceable></term>

    <listitem>
     <para>
      Le nom d'une colonne de sortie dans la syntaxe <literal>RETURNS TABLE</literal>.
      C'est une autre façon de déclarer un paramètre OUT nommé, à la différence près
      que <literal>RETURNS TABLE</literal> implique aussi <literal>RETURNS SETOF</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_colonne</replaceable></term>

    <listitem>
     <para>
      Le type de données d'une colonne de sortie dans la syntaxe
      <literal>RETURNS TABLE</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_lang</replaceable></term>

    <listitem>
     <para>
      Le nom du langage d'écriture de la fonction. Peut
      être <literal>SQL</literal>, <literal>C</literal>,
      <literal>internal</literal> ou le nom d'un langage procédural
      utilisateur, e.g. <literal>plpgsql</literal>. Entourer le nom de
      guillemets simples est une pratique obsolète et nécessite la
      bonne casse.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TRANSFORM { FOR TYPE <replaceable class="parameter">nom_type</replaceable> } [, ... ] }</literal></term>

    <listitem>
     <para>
      Indique la transformation s'appliquant pour un appel à la fonction. Les
      transformations convertissent des types de données SQL en des types de
      données spécifiques au langage. Voir <xref
      linkend="sql-createtransform"/>. Les implémentations des langages de
      procédure stockée ont une connaissance codée en dur des types internes,
      donc ces derniers n'ont pas besoin d'être listés ici. Si
      l'implémentation d'un langage de procédure ne sait pas gérer un type et
      qu'aucune transformation n'est fournie, il y a un retour au comportement
      par défaut pour les conversions des types de données mais ceci dépends
      de l'implémentation.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WINDOW</literal></term>

    <listitem>
     <para>
      <literal>WINDOW</literal> indique que la fonction est une
      <firstterm>fonction window</firstterm> plutôt qu'une fonction simple.
      Ceci n'est à l'heure actuelle utilisable que pour les fonctions écrites
      en C. L'attribut <literal>WINDOW</literal> ne peut pas être changé lors
      du remplacement d'une définition de fonction existante.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>IMMUTABLE</literal></term>
    <term><literal>STABLE</literal></term>
    <term><literal>VOLATILE</literal></term>

    <listitem>
     <para>
      Ces attributs informent l'optimiseur de requêtes sur le comportement
      de la fonction. Un seul choix est possible. En son absence,
      <literal>VOLATILE</literal> est utilisé.
     </para>

     <para>
      <literal>IMMUTABLE</literal> indique que la fonction ne peut pas modifier
      la base de données et qu'à arguments constants, la fonction renvoie
      toujours le même résultat&nbsp;;
      c'est-à-dire qu'elle n'effectue pas de recherches dans la base de données,
      ou alors qu'elle utilise des informations non directement présentes
      dans la liste d'arguments. Si cette option est précisée, tout appel de la
      fonction avec des arguments constants peut être immédiatement remplacé
      par la valeur de la fonction.
     </para>

     <para>
      <literal>STABLE</literal> indique que la fonction ne peut pas modifier
      la base de données et qu'à l'intérieur d'un seul parcours de
      la table, à arguments constants, la fonction retourne le même résultat,
      mais celui-ci varie en fonction des instructions SQL. Cette option est
      appropriée pour les fonctions dont les résultats dépendent des
      recherches en base, des variables de paramètres (tel que la zone
      horaire courante), etc. (Ce mode est inapproprié pour les triggers
      <literal>AFTER</literal> qui souhaitent voir les lignes modifiées par
      la commande en cours.) La famille de fonctions
      <function>current_timestamp</function> est qualifiée de stable car les
      valeurs de ces fonctions ne changent pas à l'intérieur d'une
      transaction.
     </para>

     <para>
      <literal>VOLATILE</literal> indique que la valeur de la fonction peut
      changer même au cours d'un seul parcours de table. Aucune optimisation ne
      peut donc être réalisée. Relativement peu de fonctions de bases de données
      sont volatiles dans ce sens&nbsp;; quelques exemples sont
      <literal>random()</literal>, <literal>currval()</literal>, <literal>timeofday()</literal>.
      Toute fonction qui a des effets de bord doit être classée
      volatile, même si son résultat est assez prévisible. Cela afin d'éviter
      l'optimisation des appels&nbsp;; <literal>setval()</literal> en est un exemple.
     </para>

     <para>
      Pour des détails complémentaires, voir <xref linkend="xfunc-volatility"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>LEAKPROOF</literal></term>
    <listitem>
     <para>
      <literal>LEAKPROOF</literal> indique que la fonction n'a pas d'effets de
      bord. Elle ne fournit aucune information sur ces arguments autrement que
      par sa valeur de retour. Par exemple, une fonction qui renvoie un
      message d'erreur pour certaines valeurs d'arguments et pas pour
      d'autres, ou qui inclut les valeurs des arguments dans des messages
      d'erreur, ne peut pas utiliser cette clause. Ceci affecte la façon dont
      le système exécute des requêtes contre les vues créées avec l'option
      <literal>security_barrier</literal> ou les tables avec la fonctionnalité
      RLS activée. Le système force les conditions des politiques de sécurité
      et les vues avec barrière de sécurité avant toute condition fournie par
      l'utilisateur sur la requête appelante qui contient des fonctions non
      sécurisées (non LEAKPROOF), pour empêcher toute exposition involontaire
      des données. Les fonctions et opérateurs marquées LEAKPROOF sont
      supposés être sûrs, et peuvent être exécutées avant les conditions des
      politiques de sécurité et les vues avec barrière de sécurité. De plus,
      les fonctions qui ne prennent pas d'arguments ou qui ne se voient pas
      fournies d'arguments par la vue ou la table n'ont pas besoin d'être
      marquées comme LEAKPROOF pour être exécutées avant les conditions de
      sécurité. Voir <xref linkend="sql-createview"/> et <xref
      linkend="rules-privileges"/>. Cette option peut seulement être utilisée
      par un superutilisateur.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CALLED ON NULL INPUT</literal></term>
    <term><literal>RETURNS NULL ON NULL INPUT</literal></term>
    <term><literal>STRICT</literal></term>

    <listitem>
     <para>
      <literal>CALLED ON NULL INPUT</literal> (la valeur par défaut) indique
      que la fonction est appelée normalement si certains de ses arguments
      sont NULL. C'est alors de la responsabilité de l'auteur de la fonction de
      gérer les valeurs NULL.
     </para>

     <para>
      <literal>RETURNS NULL ON NULL INPUT</literal> ou
      <literal>STRICT</literal> indiquent que la fonction renvoie toujours
      NULL si l'un de ses arguments est NULL. Lorsque ce paramètre est utilisé
      et qu'un des arguments est NULL, la fonction n'est pas exécutée, mais un résultat NULL
      est automatiquement retourné.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal><optional>EXTERNAL</optional> SECURITY INVOKER</literal></term>
    <term><literal><optional>EXTERNAL</optional> SECURITY DEFINER</literal></term>

    <listitem>
     <para>
      <literal>SECURITY INVOKER</literal> indique que la fonction est
      exécutée avec les droits de l'utilisateur qui l'appelle. C'est la valeur
      par défaut. <literal>SECURITY DEFINER</literal> spécifie que la fonction
      est exécutée avec les droits de l'utilisateur qui en est le propriétaire.
     </para>

     <para>
      Le mot clé <literal>EXTERNAL</literal> est autorisé pour la conformité SQL
      mais il est optionnel car, contrairement à SQL, cette fonctionnalité
      s'applique à toutes les fonctions, pas seulement celles externes.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>PARALLEL</literal></term>

    <listitem>
     <para><literal>PARALLEL UNSAFE</literal> indique que la fonction ne peut
      pas être exécutée dans le mode parallèle. La présence d'une fonction de
      ce type dans une requête SQL force un plan d'exécution en série. C'est
      la valeur par défaut. <literal>PARALLEL RESTRICTED</literal> indique
      que la fonction peut être exécutée en mode parallèle mais l'exécution
      est restreinte au processus principal d'exécution. <literal>PARALLEL
       SAFE</literal> indique que la fonction s'exécute correctement dans le
      mode parallèle sans restriction.
     </para>

     <para>
      Les fonctions doivent être marquées comme non parallélisable si elles
      modifient l'état d'une base ou si elles font des changements sur la
      transaction telles que l'utilisation de sous-transactions ou si elles
      accèdent à des séquences ou tentent de faire des modifications
      persistentes aux configurations (par exemple
      <literal>setval</literal>). Elles doivent être marquées comme restreintes
      au parallélisme si elles accèdent aux tables temporaires, à l'état de
      connexion des clients, aux curseurs, aux requêtes préparées ou à un
      état local du moteur où le système ne peut pas synchroniser en mode
      parallèle (par exemple, <literal>setseed</literal> ne peut pas être
      exécuté autrement que par le processus principal car une modification
      réalisée par un autre processus ne pourrait pas être reflété dans le
      processus principal). En général, si une fonction est marquée sûre à
      la parallélisation alors qu'elle est restreinte ou non parallélisable
      ou si elle est marquée restreinte quand elle est en fait non
      parallélisable, elle pourrait renvoyer des erreurs ou fournir de mauvaises
      réponses lorsqu'elle est utilisée dans une requête parallèle. Les
      fonctions en langage C peuvent en théorie afficher un comportement
      indéfini si elles sont marquées de façon erronée car le système ne peut
      pas se protéger comme du code C arbitraire mais, généralement, le
      résultat ne sera pas pire que pour toute autre fonction. En cas de doute,
      les fonctions doivent être marquées comme <literal>UNSAFE</literal>, ce qui
      correspond à la valeur par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>COST</literal> <replaceable class="parameter">cout_execution</replaceable></term>

    <listitem>
     <para>
      Un nombre positif donnant le coût estimé pour l'exécution de la fonction
      en unité de <xref linkend="guc-cpu-operator-cost"/>. Si la fonction
      renvoie plusieurs lignes, il s'agit d'un coût par ligne renvoyée. Si le
      coût n'est pas spécifié, une unité est supposée pour les fonctions en
      langage C et les fonctions internes. Ce coût est de 100 unités pour les
      fonctions dans tout autre langage. Des valeurs plus importantes feront
      que le planificateur tentera d'éviter l'évaluation de la fonction
      aussi souvent que possible.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ROWS</literal> <replaceable class="parameter">nb_lignes_resultat</replaceable></term>

    <listitem>
     <para>
      Un nombre positif donnant le nombre estimé de lignes que la fonction
      renvoie, information utile au planificateur. Ceci est seulement
      autorisé pour les fonctions qui renvoient plusieurs lignes (fonctions
      SRF). La valeur par défaut est de 1000 lignes.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SUPPORT</literal> <replaceable class="parameter">fonction_support</replaceable></term>

    <listitem>
     <para>
      Le nom (optionnellement qualifié du nom du schéma) d'une <firstterm>fonction
       de support de planification</firstterm> à utiliser pour cette fonction.
      Voir <xref linkend="xfunc-optimization"/> pour plus d'informations.
      Il faut être superutilisateur pour utiliser cette option.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable>parametre</replaceable></term>
    <term><replaceable>valeur</replaceable></term>
    <listitem>
     <para>
      La clause <literal>SET</literal> fait que le paramètre de configuration
      indiquée est initialisée avec la valeur précisée au lancement de la
      fonction, puis restaurée à sa valeur d'origine lors de la sortie de la
      fonction.
      <literal>SET FROM CURRENT</literal> sauvegarde la valeur actuelle du
      paramètre quand <command>ALTER FUNCTION</command> est exécuté comme
      valeur à appliquer lors de l'exécution de la fonction.
     </para>

     <para>
      Si une clause <literal>SET</literal> est attachée à une fonction, alors
      les effets de la commande <command>SET LOCAL</command> exécutée à
      l'intérieur de la fonction pour la même variable sont restreints à la
      fonction&nbsp;: la valeur précédente du paramètre de configuration est
      de nouveau restaurée en sortie de la fonction. Néanmoins, une commande
      <command>SET</command> ordinaire (c'est-à-dire sans
      <literal>LOCAL</literal>) surcharge la clause <literal>SET</literal>,
      comme il le ferait pour une précédente commande <command>SET
       LOCAL</command>&nbsp;: les effets d'une telle commande persisteront
      après la sortie de la fonction sauf si la transaction en cours est
      annulée.
     </para>

     <para>
      Voir <xref linkend="sql-set"/> et
      <xref linkend="runtime-config"/> pour plus d'informations sur les
      paramètres et valeurs autorisés.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">definition</replaceable></term>

    <listitem>
     <para>
      Une constante de type chaîne définissant la fonction&nbsp;; la
      signification dépend du langage. Cela peut être un nom de fonction
      interne, le chemin vers un
      fichier objet, une commande SQL ou du texte en langage procédural.
     </para>

     <para>
      Il est souvent utile d'utiliser les guillemets dollar (voir <xref
      linkend="sql-syntax-dollar-quoting"/>) pour écrire le code de la
      fonction, au lie des la syntaxe habituelle des guillemets. Sans les
      guillemets dollar, tout guillemet ou antislash dans la définition de
      la fonction doit être échappé en les doublant.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal><replaceable class="parameter">fichier_obj</replaceable>, <replaceable class="parameter">symbole_lien</replaceable></literal></term>

    <listitem>
     <para>
      Cette forme de clause <literal>AS</literal> est utilisée pour les
      fonctions en langage C chargeables dynamiquement lorsque le nom de la
      fonction dans le code source C n'est pas le même que celui de la fonction
      SQL. La chaîne <replaceable class="parameter">fichier_obj</replaceable> est
      le nom du fichier de la bibliothèque partagée contenant la fonction C
      compilée et est interprété comme pour une commande <xref
      linkend="sql-load"/>. La chaîne
      <replaceable class="parameter">symbole_lien</replaceable> est le symbole
      de lien de la fonction, c'est-à-dire le nom de la fonction dans le code
      source C. Si ce lien est omis, il est supposé être le même que le nom de
      la fonction SQL définie. Les noms C de toutes les fonctions doivent être
      différents, donc vous devez donner aux fonctions C surchargés des noms C
      différents (par exemple, utilisez les types d'arguments comme partie des
      noms C).
     </para>

     <para>
      Lors d'appels répétés à <command>CREATE FUNCTION</command> se référant
      au même fichier objet, il est chargé seulement une fois par session.
      Pour décharger et recharger le fichier (par exemple lors du
      développement de la fonction), démarrez une nouvelle session.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   La lecture de <xref linkend="xfunc"/> fournit des informations
   supplémentaires sur l'écriture de fonctions.
  </para>
 </refsect1>

 <refsect1 id="sql-createfunction-overloading">
  <title>Overloading</title>

  <para>
   <productname>PostgreSQL</productname> autorise la
   <firstterm>surcharge</firstterm> des fonctions&nbsp;; c'est-à-dire que le
   même nom peut être utilisé pour des fonctions différentes si tant est
   qu'elles aient des types d'arguments en entrée distincts. Que vous
   l'utilisiez ou non, cette capacité implique des précautions au niveau de la
   sécurité lors de l'appel des fonctions dans les bases de données où
   certains utilisateurs ne font pas confiance à d'autres utilisateurs&nbsp;;
   voir <xref linkend="typeconv-func"/>.
  </para>

  <para>
   Deux fonctions sont considérées identiques si elles partagent le même nom
   et les mêmes types d'argument en <emphasis>entrée</emphasis>, sans considération des
   paramètres <literal>OUT</literal>. Les déclarations suivantes sont, de fait, en conflit&nbsp;:
   <programlisting>CREATE FUNCTION truc(int) ...
CREATE FUNCTION truc(int, out text) ...
   </programlisting>
  </para>

  <para>
   Des fonctions ayant des listes de types d'arguments différents ne seront
   pas considérées comme en conflit au moment de leur création, mais si des
   valeurs par défauts sont fournies, elles peuvent se retrouver en conflit
   au moment de l'invocation. Considérez par exemple&nbsp;:
   <programlisting>
CREATE FUNCTION truc(int) ...
CREATE FUNCTION truc(int, int default 42) ...
   </programlisting>
   Un appel <literal>truc(10)</literal> échouera à cause de l'ambiguïté sur la
   fonction à appeler.
  </para>

 </refsect1>

 <refsect1 id="sql-createfunction-notes">
  <title>Notes</title>

  <para>
   La syntaxe <acronym>SQL</acronym> complète des types est autorisé pour
   déclarer les arguments en entrée et la valeur de sortie d'une fonction.
   Néanmoins, les modificateurs du type de la fonction (par exemple le
   champ précision pour un <type>numeric</type>) sont ignorés par
   <command>CREATE FUNCTION</command>. Du coup, par exemple,
   <literal>CREATE FUNCTION foo (varchar(10)) ...</literal> est identique à
   <literal>CREATE FUNCTION foo (varchar) ...</literal>.
  </para>

  <para>
   Lors du remplacement d'une fonction existante avec <command>CREATE OR
    REPLACE FUNCTION</command>, il existe des restrictions sur le changement
   des noms de paramètres. Vous ne pouvez pas modifier le nom de paramètre
   en entrée déjà affecté mais vous pouvez ajouter des noms aux paramètres
   qui n'en avaient pas. S'il y a plus d'un paramètre en sortie, vous ne
   pouvez pas changer les noms des paramètres en sortie car cela changera les
   noms de colonne du type composite anonyme qui décrit le résultat de la
   fonction. Ces restrictions sont là pour assurer que les appels suivants à
   la fonction ne s'arrêtent pas de fonctionner lorsqu'elle est remplacée.
  </para>

 </refsect1>

 <refsect1 id="sql-createfunction-examples">
  <title>Exemples</title>

  <para>
   Quelques exemples triviaux pour bien débuter sont présentés ci-après. Pour plus
   d'informations et d'exemples, voir <xref linkend="xfunc"/>.
   <programlisting>CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
   </programlisting>
  </para>

  <para>
   Incrémenter un entier, en utilisant le nom de l'argument, dans
   <application>PL/pgSQL</application>&nbsp;:

   <programlisting>CREATE OR REPLACE FUNCTION increment(i integer) RETURNS integer AS $$
        BEGIN
                RETURN i + 1;
        END;
$$ LANGUAGE plpgsql;
   </programlisting>
  </para>

  <para>
   Renvoyer un enregistrement contenant plusieurs paramètres en sortie&nbsp;:
   <programlisting>CREATE FUNCTION dup(in int, out f1 int, out f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
   </programlisting>
   La même chose, en plus verbeux, avec un type composite
   nommé explicitement&nbsp;:
   <programlisting>CREATE TYPE dup_result AS (f1 int, f2 text);

CREATE FUNCTION dup(int) RETURNS dup_result
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
   </programlisting>
   Une autre façon de renvoyer plusieurs colonnes est d'utiliser une fonction
   <literal>TABLE</literal>&nbsp;:
   <programlisting>
CREATE FUNCTION dup(int) RETURNS TABLE(f1 int, f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
   </programlisting>
   Toutefois, une fonction <literal>TABLE</literal> est différente des
   exemples précédents parce qu'elle retourne en fait un <emphasis>ensemble</emphasis>
   d'enregistrements, pas juste un enregistrement.
  </para>
 </refsect1>

 <refsect1 id="sql-createfunction-security">
  <title>Écrire des fonctions <literal>SECURITY DEFINER</literal> en toute
   sécurité</title>

  <para>
   <indexterm>
    <primary>paramètre de configuration <varname>search_path</varname></primary>
    <secondary>utilisé pour sécuriser les fonctions</secondary>
   </indexterm>

   Parce qu'une fonction <literal>SECURITY DEFINER</literal> est exécutée
   avec les droits de l'utilisateur qui en est le propriétaire, une certaine attention
   est nécessaire pour s'assurer que la fonction ne peut pas être
   utilisée de façon maline. Pour des raisons de sécurité,
   <xref linkend="guc-search-path"/> doit être configuré pour exclure les
   schémas modifiables par des utilisateurs indignes de confiance.
   Cela empêche des utilisateurs malveillants de créer des
   objets (par exemple tables, fonctions et opérateurs) qui masquent les
   objets utilisés par la fonction. Dans
   ce sens, le schéma des tables temporaires est particulièrement
   important car il est le premier schéma parcouru et qu'il est normalement
   modifiable par tous les utilisateurs. Une solution consiste à forcer
   le parcours de ce schéma en dernier lieu.
   Pour cela, on écrit <literal>pg_temp</literal><indexterm><primary>pg_temp</primary><secondary>sécuriser les fonctions</secondary></indexterm> comme dernière entrée de
   <varname>search_path</varname>. La fonction suivante illustre une
   utilisation sûre&nbsp;:

   <programlisting>
CREATE FUNCTION verifie_motdepasse(unom TEXT, motpasse TEXT)
RETURNS BOOLEAN AS $$
DECLARE ok BOOLEAN;
BEGIN
        -- Effectuer le travail sécurisé de la fonction.
        SELECT  (motdepasse = $2) INTO ok
        FROM    motsdepasse
        WHERE   nomutilisateur = $1;

        RETURN ok;
END;
$$  LANGUAGE plpgsql
    SECURITY DEFINER
    -- Configure un search_path sécurisée : les schémas de confiance, puis 'pg_temp'.
    SET search_path = admin, pg_temp;
   </programlisting>

   Le but de cette fonction est d'accéder à une table
   <literal>admin.motsdepasse</literal>. Mais sans la clause
   <literal>SET</literal> ou avec une clause <literal>SET</literal>
   mentionnant uniquement <literal>admin</literal>, la fonction pourrait être
   transformée en créant une table temporaire nommée
   <literal>motsdepasse</literal>.
  </para>

  <para>
   Avant <productname>PostgreSQL</productname> 8.3, la clause
   <literal>SET</literal> n'était pas disponible, donc les anciennes fonctions
   pouvaient contenir un code assez complexe pour sauvegarder, initialiser
   puis restaurer un paramètre comme <varname>search_path</varname>. La clause
   <literal>SET</literal> est plus simple à utiliser dans ce but.
  </para>

  <para>
   Un autre point à garder en mémoire est que, par défaut, le droit d'exécution
   est donné à <literal>PUBLIC</literal> pour les fonctions nouvellement
   créées (voir <xref linkend="ddl-priv"/> pour plus
   d'informations). Fréquemment, vous souhaiterez restreindre l'utilisation
   d'une fonction « security definer » à seulement quelques utilisateurs. Pour
   cela, vous devez révoquer les droits <literal>PUBLIC</literal> puis donner
   le droit d'exécution aux utilisateurs sélectionnés. Pour éviter que la
   nouvelle fonction soit accessible à tous pendant un court moment, créez-la
   et initialisez les droits dans une même transaction. Par exemple&nbsp;:
  </para>

  <programlisting>
BEGIN;
CREATE FUNCTION verifie_motdepasse(unom TEXT, motpasse TEXT) ... SECURITY DEFINER;
REVOKE ALL ON FUNCTION verifie_motdepasse(unom TEXT, motpasse TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION verifie_motdepasse(unom TEXT, motpasse TEXT) TO admins;
COMMIT;
  </programlisting>

 </refsect1>

 <refsect1 id="sql-createfunction-compat">
  <title>Compatibilité</title>

  <para>
   Une commande <command>CREATE FUNCTION</command> est définie dans le standard SQL.
   La version <productname>PostgreSQL</productname> est similaire
   mais pas entièrement compatible. Les attributs ne sont pas portables, pas
   plus que les différents langages disponibles.
  </para>

  <para>
   Pour des raisons de compatibilité avec d'autres systèmes de bases de données,
   <replaceable class="parameter">modearg</replaceable> peut être écrit
   avant ou après <replaceable class="parameter">nomarg</replaceable>. Mais
   seule la première façon est compatible avec le standard.
  </para>

  <para>
   Pour les valeurs par défaut des paramètres, le standard SQL spécifie seulement
   la syntaxe du mot clé <literal>DEFAULT</literal>. La syntaxe utilisant
   <literal>=</literal> est utilisé dans T-SQL et Firebird.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterfunction"/></member>
   <member><xref linkend="sql-dropfunction"/></member>
   <member><xref linkend="sql-grant"/></member>
   <member><xref linkend="sql-load"/></member>
   <member><xref linkend="sql-revoke"/></member>
  </simplelist>
 </refsect1>

</refentry>
