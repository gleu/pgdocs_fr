<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20070906 : PG823 -->

<refentry id="sql-createfunction">
 <refmeta>
  <refentrytitle>CREATE FUNCTION</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE FUNCTION</refname>
  <refpurpose>Définir une nouvelle fonction</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE [ OR REPLACE ] FUNCTION
    <replaceable class="parameter">nom</replaceable> ( [ [ <replaceable class="parameter">modearg</replaceable> ] [ <replaceable class="parameter">nomarg</replaceable> ] <replaceable class="parameter">typearg</replaceable>  [ { DEFAULT | = } <replaceable class="parameter">expression_par_defaut</replaceable> ] [, ...] ] ) ] )
    [ RETURNS <replaceable class="parameter">type_ret</replaceable>
      | RETURNS TABLE ( <replaceable class="parameter">nom_colonne</replaceable> <replaceable class="parameter">type_colonne</replaceable> [, ...] ) ]
  { LANGUAGE <replaceable class="parameter">nom_lang</replaceable>
    | WINDOW
    | IMMUTABLE | STABLE | VOLATILE | [ NOT ] LEAKPROOF
    | CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
    | [EXTERNAL] SECURITY INVOKER | [EXTERNAL] SECURITY DEFINER
    | COST <replaceable class="parameter">cout_execution</replaceable>
    | ROWS <replaceable class="parameter">nb_lignes_resultat</replaceable>
    | SET <replaceable class="parameter">parametre</replaceable> { TO <replaceable class="parameter">value</replaceable> | = <replaceable class="parameter">value</replaceable> | FROM CURRENT }
    | AS '<replaceable class="parameter">definition</replaceable>'
    | AS '<replaceable class="parameter">fichier_obj</replaceable>', '<replaceable class="parameter">symbole_lien</replaceable>'
  } ...
    [ WITH ( <replaceable class="parameter">attribut</replaceable> [, ...] ) ]
</synopsis>
 </refsynopsisdiv>
  
 <refsect1 id="sql-createfunction-description">
  <title>Description</title>
  <indexterm zone="sql-createfunction">
   <primary>CREATE FUNCTION</primary>
  </indexterm>

  <para>
   <command>CREATE FUNCTION</command> définit une nouvelle fonction.
   <command>CREATE OR REPLACE FUNCTION</command> crée une nouvelle fonction
   ou la remplace si elle existe déjà.
   Pour pouvoir créer une fonction, l'utilisateur doit avoir le droit
   <literal>USAGE</literal> sur le langage associé.
  </para>

  <para>
   Si un nom de schéma est précisé, la fonction est créée dans le schéma
   indiqué. Sinon, elle est créée dans le schéma courant. Le nom de la nouvelle
   fonction ne peut pas correspondre à celui d'une fonction existant avec les
   mêmes types d'arguments en entrée dans le même schéma. Toutefois, les fonctions de types
   d'arguments différents peuvent partager le même nom (ceci est appelé
   <firstterm>surcharge</firstterm>).
  </para>

  <para>
   Pour remplacer la définition actuelle d'une fonction existante, 
   <command>CREATE OR REPLACE FUNCTION</command> est utilisé. Il n'est pas possible de
   changer le nom ou les types d'argument d'une fonction de cette façon 
   (cela crée une nouvelle fonction distincte). De
   même, <command>CREATE OR REPLACE FUNCTION</command> ne permet pas
   de modifier le type retour d'une fonction existante. Pour cela, il est nécessaire
   de supprimer et de recréer la fonction. (Lors de l'utilisation de paramètres
   <literal>OUT</literal>, cela signifie que le type d'un paramètre
   <literal>OUT</literal> ne peut être modifié que par 
   la suppression de la fonction.)
  </para>

  <para>
   Quand <command>CREATE OR REPLACE FUNCTION</command> est utilisé pour
   remplacer une fonction existante, le propriétaire et les droits de la
   fonction ne changent pas. Toutes les autres propriétés de la fonction se
   voient affectées les valeurs spécifiées dans la commande ou implicites pour
   les autres. Vous devez être le propriétaire de la fonction pour la
   remplacer ou être un membre du rôle propriétaire de la fonction.
  </para>

  <para>
   En cas de suppression et de recréaction d'une fonction, la nouvelle fonction n'est pas
   la même entité que l'ancienne&nbsp;; il faut supprimer les règles, vues,
   déclencheurs, etc. qui référencent l'ancienne fonction. 
   <command>CREATE OR REPLACE FUNCTION</command> permet de modifier la définition
   d'une fonction sans casser les objets qui s'y réfèrent.
   De plus, <command>ALTER FUNCTION</command> peut être utilisé pour modifier la
   plupart des propriétés supplémentaires d'une fonction existante.
  </para>

  <para>
   L'utilisateur qui crée la fonction en devient le propriétaire.
  </para>

  <para>
   Pour pouvoir créer une fonction, vous devez avoir le droit
   <literal>USAGE</literal> sur les types des arguments et de la valeur de
   retour.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

   <variablelist>

    <varlistentry>
     <term><replaceable class="parameter">nom</replaceable></term>

     <listitem>
      <para>
       Le nom de la fonction à créer (éventuellement qualifié du nom du schéma).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">modearg</replaceable></term>

     <listitem>
      <para>
       Le mode d'un argument&nbsp;: <literal>IN</literal>,
       <literal>OUT</literal>, <literal>INOUT</literal> ou
       <literal>VARIADIC</literal>. En cas d'omission, la valeur par défaut est
       <literal>IN</literal>.
       Seuls des arguments <literal>OUT</literal> peuvent suivre un argument
       <literal>VARIADIC</literal>.
       Par ailleurs, des arguments <literal>OUT</literal> et <literal>INOUT</literal> ne peuvent
       pas être utilisés en même temps que la notation <literal>RETURNS TABLE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nomarg</replaceable></term>

     <listitem>
      <para>
       Le nom d'un argument. Quelques langages (uniquement PL/pgSQL, en
       réalité) permettent d'utiliser ce nom dans le corps de la fonction.
       Pour les autres langages, le nom d'un argument en entrée est purement
       documentaire en ce qui concerne la fonction elle-même. Mais vous pouvez
       utiliser les noms d'arguments en entrée lors de l'appel d'une fonction
       pour améliorer la lisibilité (voir <xref
       linkend="sql-syntax-calling-funcs"/>). Dans tous les cas, le nom d'un
       argument en sortie a une utilité car il définit le nom de la colonne
       dans la ligne résultat. (En cas d'omission du nom d'un argument en
       sortie, le système choisit un nom de colonne par défaut.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">argtype</replaceable></term>

     <listitem>
      <para>
       Le(s) type(s) de données des arguments de la fonction (éventuellement
       qualifié du nom du schéma), s'il y en a. Les types des arguments
       peuvent être basiques, composites ou de domaines, ou 
       faire référence au type d'une colonne.
      </para>
      <para>
       En fonction du langage, il est possible d'indiquer
       des <quote>pseudotypes</quote>, tel que <type>cstring</type>. Les
       pseudotypes indiquent que le type d'argument réel est soit non
       complètement spécifié, soit en dehors de l'ensemble des types de données
       ordinaires du SQL.
      </para>
      <para>
       Il est fait référence au type d'une colonne par
       <literal><replaceable class="parameter">nom_table</replaceable>.<replaceable class="parameter">nomcolonne</replaceable>%TYPE</literal>. 
       Cette fonctionnalité peut servir à rendre une fonction
       indépendante des modifications de la définition d'une table.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">expression_par_defaut</replaceable></term>

     <listitem>
      <para>
       Une expression à utiliser en tant que valeur par défaut si le
       paramètre n'est pas spécifié. L'expression doit pouvoir être coercible
       dans le type d'argument du paramètre.
       Seuls les paramètres d'entrée (dont les <literal>INOUT</literal>) peuvent
       avoir une valeur par défaut. Tous les paramètres d'entrée suivant un
       paramètre avec une valeur par défaut doivent aussi avoir une valeur par
       défaut.
   </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">type_ret</replaceable></term>

     <listitem>
      <para>
       Le type de données en retour (éventuellement qualifié du nom du schéma).
       Le type de retour peut être un type basique, composite ou de domaine,
       ou faire référence au type d'une colonne
       existante. En fonction du langage, il est possible d'indiquer
       un <quote>pseudotype</quote>, tel que <type>cstring</type>.
       Si la fonction ne doit pas renvoyer de valeur, on indique
       <type>void</type> comme type de retour.
      </para>
      <para>
       Quand il y a des paramètres <literal>OUT</literal> ou <literal>INOUT</literal>, la
       clause <literal>RETURNS</literal> peut être omise. Si elle est présente, elle
       doit correspondre au type de résultat imposé par les paramètres de
       sortie&nbsp;: <literal>RECORD</literal> s'il y en a plusieurs,
       ou le type du seul paramètre en sortie.
      </para>
      <para>
       Le modificateur <literal>SETOF</literal> indique que la fonction retourne
       un ensemble d'éléments plutôt qu'un seul.
      </para>
      <para>
       Il est fait référence au type d'une colonne par 
       <literal><replaceable class="parameter">nom_table</replaceable>.<replaceable class="parameter">nomcolonne</replaceable>%TYPE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nom_colonne</replaceable></term>

     <listitem>
      <para>
       Le nom d'une colonne de sortie dans la syntaxe <literal>RETURNS TABLE</literal>.
       C'est une autre façon de déclarer un paramètre OUT nommé, à la différence près
       que <literal>RETURNS TABLE</literal> implique aussi <literal>RETURNS SETOF</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">type_colonne</replaceable></term>

     <listitem>
      <para>
       Le type de données d'une colonne de sortie dans la syntaxe
       <literal>RETURNS TABLE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nom_lang</replaceable></term>

     <listitem>
      <para>
       Le nom du langage d'écriture de la fonction. Peut
       être <literal>SQL</literal>, <literal>C</literal>,
       <literal>internal</literal> ou le nom d'un langage procédural
       utilisateur. Pour des raisons de compatibilité descendante, le
       nom peut être écrit entre guillemets simples.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>WINDOW</literal></term>

     <listitem>
      <para>
       <literal>WINDOW</literal> indique que la fonction est une 
       <firstterm>fonction window</firstterm> plutôt qu'une fonction simple.
       Ceci n'est à l'heure actuelle utilisable que pour les fonctions écrites
       en C. L'attribut <literal>WINDOW</literal> ne peut pas être changé lors
       du remplacement d'une définition de fonction existante.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>IMMUTABLE</literal></term>
     <term><literal>STABLE</literal></term>
     <term><literal>VOLATILE</literal></term>

     <listitem>
      <para>
       Ces attributs informent l'optimiseur de requêtes sur le comportement
       de la fonction. Un seul choix est possible. En son absence,
       <literal>VOLATILE</literal> est utilisé.
      </para>

      <para>
       <literal>IMMUTABLE</literal> indique que la fonction ne peut pas modifier
       la base de données et qu'à arguments constants, la fonction renvoie
       toujours le même résultat&nbsp;;
       c'est-à-dire qu'elle n'effectue pas de recherches dans la base de données,
       ou alors qu'elle utilise des informations non directement présentes
       dans la liste d'arguments. Si cette option est précisée, tout appel de la
       fonction avec des arguments constants peut être immédiatement remplacé
       par la valeur de la fonction.
      </para>

      <para>
       <literal>STABLE</literal> indique que la fonction ne peut pas modifier
       la base de données et qu'à l'intérieur d'un seul parcours de
       la table, à arguments constants, la fonction retourne le même résultat,
       mais celui-ci varie en fonction des instructions SQL. Cette option est
       appropriée pour les fonctions dont les résultats dépendent des
       recherches en base, des variables de paramètres (tel que la zone
       horaire courante), etc. (Ce mode est inapproprié pour les triggers
       <literal>AFTER</literal> qui souhaitent voir les lignes modifiées par
       la commande en cours.) La famille de fonctions
       <function>current_timestamp</function> est qualifiée de stable car les
       valeurs de ces fonctions ne changent pas à l'intérieur d'une
       transaction.
      </para>

      <para>
       <literal>VOLATILE</literal> indique que la valeur de la fonction peut
       changer même au cours d'un seul parcours de table. Aucune optimisation ne
       peut donc être réalisée. Relativement peu de fonctions de bases de données
       sont volatiles dans ce sens&nbsp;; quelques exemples sont
       <literal>random()</literal>, <literal>currval()</literal>, <literal>timeofday()</literal>.
       Toute fonction qui a des effets de bord doit être classée
       volatile, même si son résultat est assez prévisible. Cela afin d'éviter
       l'optimisation des appels&nbsp;; <literal>setval()</literal> en est un exemple.
      </para>

      <para>
       Pour des détails complémentaires, voir <xref linkend="xfunc-volatility"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>LEAKPROOF</literal></term>
     <listitem>
      <para>
       <literal>LEAKPROOF</literal> indique que la fonction n'a pas d'effets
       de bord. Elle ne fournit aucune information sur ces arguments autrement
       que par sa valeur de retour. Par exemple, une fonction qui renvoie un
       message d'erreur pour certaines valeurs d'arguments et pas pour d'autres,
       ou qui inclut les valeurs des arguments dans des messages d'erreur,
       ne peut pas utiliser cette clause. Le planificateur de requêtes peut
       pousser les fonctions de ce type (mais pas les autres) en des vues
       créées avec l'option <literal>security_barrier</literal>. Voir
       <xref linkend="sql-createview"/> et <xref linkend="rules-privileges"/>.
       Cette option peut seulement être utilisée par un superutilisateur.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>CALLED ON NULL INPUT</literal></term>
     <term><literal>RETURNS NULL ON NULL INPUT</literal></term>
     <term><literal>STRICT</literal></term>

     <listitem>
      <para>
       <literal>CALLED ON NULL INPUT</literal> (la valeur par défaut) indique
       que la fonction est appelée normalement si certains de ses arguments
       sont NULL. C'est alors de la responsabilité de l'auteur de la fonction de
       gérer les valeurs NULL.
      </para>

      <para>
       <literal>RETURNS NULL ON NULL INPUT</literal> ou
       <literal>STRICT</literal> indiquent que la fonction renvoie toujours
       NULL si l'un de ses arguments est NULL. Lorsque ce paramètre est utilisé 
       et qu'un des arguments est NULL, la fonction n'est pas exécutée, mais un résultat NULL
       est automatiquement retourné.
      </para>
     </listitem>
    </varlistentry>

   <varlistentry>
    <term><literal><optional>EXTERNAL</optional> SECURITY INVOKER</literal></term>
    <term><literal><optional>EXTERNAL</optional> SECURITY DEFINER</literal></term>

    <listitem>
     <para>
      <literal>SECURITY INVOKER</literal> indique que la fonction est
      exécutée avec les droits de l'utilisateur qui l'appelle. C'est la valeur
      par défaut. <literal>SECURITY DEFINER</literal> spécifie que la fonction
      est exécutée avec les droits de l'utilisateur qui l'a créé.
     </para>

     <para>
      Le mot clé <literal>EXTERNAL</literal> est autorisé pour la conformité SQL
      mais il est optionnel car, contrairement à SQL, cette fonctionnalité
      s'applique à toutes les fonctions, pas seulement celles externes.
     </para>
    </listitem>
   </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">cout_execution</replaceable></term>

     <listitem>
      <para>
       Un nombre positif donnant le coût estimé pour l'exécution de la fonction
       en unité de <xref linkend="guc-cpu-operator-cost"/>. Si la fonction
       renvoie plusieurs lignes, il s'agit d'un coût par ligne renvoyée. Si le
       coût n'est pas spécifié, une unité est supposée pour les fonctions en
       langage C et les fonctions internes. Ce coût est de 100 unités pour les
       fonctions dans tout autre langage. Des valeurs plus importantes feront
       que le planificateur tentera d'éviter l'évaluation de la fonction
       aussi souvent que possible.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nb_lignes_resultat</replaceable></term>

     <listitem>
      <para>
       Un nombre positif donnant le nombre estimé de lignes que la fonction
       renvoie, information utile au planificateur. Ceci est seulement
       autorisé pour les fonctions qui renvoient plusieurs lignes (fonctions
       SRF). La valeur par défaut est de 1000 lignes.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>parametre</replaceable></term>
     <term><replaceable>valeur</replaceable></term>
     <listitem>
      <para>
       La clause <literal>SET</literal> fait que le paramètre de configuration
       indiquée est initialisée avec la valeur précisée au lancement de la
       fonction, puis restaurée à sa valeur d'origine lors de la sortie de la
       fonction. <literal>SET FROM CURRENT</literal> utilise la valeur actuelle
       de la session comme valeur à appliquer au lancement de la fonction.
      </para>

      <para>
       Si une clause <literal>SET</literal> est attachée à une fonction, alors
       les effets de la commande <command>SET LOCAL</command> exécutée à
       l'intérieur de la fonction pour la même variable sont restreints à la
       fonction&nbsp;: la valeur précédente du paramètre de configuration est
       de nouveau restaurée en sortie de la fonction. Néanmoins, une commande
       <command>SET</command> ordinaire (c'est-à-dire sans
       <literal>LOCAL</literal>) surcharge la clause <literal>SET</literal>,
       comme il le ferait pour une précédente commande <command>SET
       LOCAL</command>&nbsp;: les effets d'une telle commande persisteront
       après la sortie de la fonction sauf si la transaction en cours est
       annulée.
      </para>
   
      <para>
       Voir <xref linkend="sql-set"/> et
       <xref linkend="runtime-config"/> pour plus d'informations sur les
       paramètres et valeurs autorisés.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">definition</replaceable></term>

     <listitem>
      <para>
       Une constante de type chaîne définissant la fonction&nbsp;; la
       signification dépend du langage. Cela peut être un nom de fonction
       interne, le chemin vers un
       fichier objet, une commande SQL ou du texte en langage procédural.
      </para>

      <para>
       Il est souvent utile d'utiliser les guillemets dollar (voir <xref
       linkend="sql-syntax-dollar-quoting"/>) pour écrire le code de la
       fonction, au lie des la syntaxe habituelle des guillemets. Sans les
       guillemets dollar, tout guillemet ou antislash dans la définition de
       la fonction doit être échappé en les doublant.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal><replaceable class="parameter">fichier_obj</replaceable>, <replaceable class="parameter">symbole_lien</replaceable></literal></term>

     <listitem>
      <para>
       Cette forme de clause <literal>AS</literal> est utilisée pour les
       fonctions en langage C chargeables dynamiquement lorsque le nom de la
       fonction dans le code source C n'est pas le même que celui de la fonction
       SQL. La chaîne <replaceable class="parameter">fichier_obj</replaceable> est
       le nom du fichier contenant l'objet chargeable dynamiquement et
       <replaceable class="parameter">symbole_lien</replaceable> est le symbole
       de lien de la fonction, c'est-à-dire le nom de la fonction dans le code
       source C. Si ce lien est omis, il est supposé être le même que le nom de
       la fonction SQL définie.
      </para>

      <para>
       Lors d'appels répétés à <command>CREATE FUNCTION</command> se référant
       au même fichier objet, il est chargé seulement une fois par session.
       Pour décharger et recharger le fichier (par exemple lors du
       développement de la fonction), démarrez une nouvelle session.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">attribut</replaceable></term>

     <listitem>
      <para>
       Façon historique d'indiquer des informations optionnelles
       concernant la fonction. Les attributs suivants peuvent apparaître ici&nbsp;:

      <variablelist>
       <varlistentry>
        <term><literal>isStrict</literal></term>
        <listitem>
         <para>
          Équivalent à <literal>STRICT</literal> ou <literal>RETURNS NULL ON
          NULL INPUT</literal>.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>isCachable</literal></term>
        <listitem>
         <para>
          <literal>isCachable</literal> est un équivalent obsolète de
          <literal>IMMUTABLE</literal>&nbsp;; il est toujours accepté pour des
          raisons de compatibilité ascendante.
         </para>
        </listitem>
       </varlistentry>

      </variablelist>

      Les noms d'attribut sont insensibles à la casse.
     </para>
    </listitem>
   </varlistentry>

   </variablelist>

   <para>
    La lecture de <xref linkend="xfunc"/> fournit des informations 
    supplémentaires sur l'écriture de fonctions.
   </para>
 </refsect1>

 <refsect1 id="sql-createfunction-overloading">
  <title>Overloading</title>

   <para>
    <productname>PostgreSQL</productname> autorise la
    <firstterm>surcharge</firstterm> des fonctions&nbsp;; c'est-à-dire que
    le même nom peut être utilisé pour des fonctions différentes si tant
    est qu'elles aient des types d'arguments en entrée distincts. Néanmoins, les noms C de
    toutes les fonctions doivent être différents. Il est donc nécessaire de donner des
    noms différents aux fonctions C suchargées (on peut, par exemple, utiliser le type
    des arguments dans le nom de la fonction).
   </para>

   <para>
    Deux fonctions sont considérées identiques si elles partagent le même nom
    et les mêmes types d'argument en <emphasis>entrée</emphasis>, sans considération des
    paramètres <literal>OUT</literal>. Les déclarations suivantes sont, de fait, en conflit&nbsp;:
<programlisting>CREATE FUNCTION truc(int) ...
CREATE FUNCTION truc(int, out text) ...
</programlisting>
   </para>

   <para>
    Des fonctions ayant des listes de types d'arguments différents ne seront
    pas considérées comme en conflit au moment de leur création, mais si des
    valeurs par défauts sont fournies, elles peuvent se retrouver en conflit
    au moment de l'invocation. Considérez par exemple&nbsp;:
<programlisting>
CREATE FUNCTION truc(int) ...
CREATE FUNCTION truc(int, int default 42) ...
</programlisting>
    Un appel <literal>truc(10)</literal> échouera à cause de l'ambiguïté sur la
    fonction à appeler.
   </para>

 </refsect1>

 <refsect1 id="sql-createfunction-notes">
  <title>Notes</title>

   <para>
    La syntaxe <acronym>SQL</acronym> complète des types est autorisé pour
    les arguments en entrée et la valeur de retour. Néanmoins, certains détails
    de la spécification de type (par exemple le champ de précision pour le
    type <type>numeric</type>) sont de la responsabilité de la fonction
    sous-jacente et sont du coup silencieusement ignorés (c'est-à-dire non
    reconnus ou forcés) par la commande <command>CREATE FUNCTION</command>.
   </para>

   <para>
    Lors du remplacement d'une fonction existante avec <command>CREATE OR
    REPLACE FUNCTION</command>, il existe des restrictions sur le changement
    des noms de paramètres. Vous ne pouvez pas modifier le nom de paramètre
    en entrée déjà affecté mais vous pouvez ajouter des noms aux paramètres
    qui n'en avaient pas. S'il y a plus d'un paramètre en sortie, vous ne
    pouvez pas changer les noms des paramètres en sortie car cela changera les
    noms de colonne du type composite anonyme qui décrit le résultat de la
    fonction. Ces restrictions sont là pour assurer que les appels suivants à
    la fonction ne s'arrêtent pas de fonctionner lorsqu'elle est remplacée.
   </para>

 </refsect1>

 <refsect1 id="sql-createfunction-examples">
  <title>Exemples</title>

  <para>
   Quelques exemples triviaux pour bien débuter sont présentés ci-après. Pour plus
   d'informations et d'exemples, voir <xref linkend="xfunc"/>.
<programlisting>CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
</programlisting>
  </para>
 
   <para>
   Incrémenter un entier, en utilisant le nom de l'argument, dans
   <application>PL/pgSQL</application>&nbsp;:

<programlisting>CREATE OR REPLACE FUNCTION increment(i integer) RETURNS integer AS $$
        BEGIN
                RETURN i + 1;
        END;
$$ LANGUAGE plpgsql;
</programlisting>
  </para>

  <para>
   Renvoyer un enregistrement contenant plusieurs paramètres en sortie&nbsp;:
<programlisting>CREATE FUNCTION dup(in int, out f1 int, out f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
   La même chose, en plus verbeux, avec un type composite
   nommé explicitement&nbsp;:
<programlisting>CREATE TYPE dup_result AS (f1 int, f2 text);

CREATE FUNCTION dup(int) RETURNS dup_result
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
   Une autre façon de renvoyer plusieurs colonnes est d'utiliser une fonction
   <literal>TABLE</literal>&nbsp;:
<programlisting>
CREATE FUNCTION dup(int) RETURNS TABLE(f1 int, f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
   Toutefois, une fonction <literal>TABLE</literal> est différente des
   exemples précédents parce qu'elle retourne en fait un <emphasis>ensemble</emphasis>
   d'enregistrements, pas juste un enregistrement.
  </para>
</refsect1>

 <refsect1 id="sql-createfunction-security">
  <title>Écrire des fonctions <literal>SECURITY DEFINER</literal> en toute
    sécurité</title>

   <para>
    Parce qu'une fonction <literal>SECURITY DEFINER</literal> est exécutée
    avec les droits de l'utilisateur qui l'a créé, une certaine attention
    est nécessaire pour s'assurer que la fonction ne peut pas être
    utilisée de façon maline. Pour des raisons de sécurité,
    <xref linkend="guc-search-path"/> doit être configuré pour exclure les
    schémas modifiables par des utilisateurs indignes de confiance.
    Cela empêche des utilisateurs malveillants de créer des
    objets qui masquent les objets utilisés par la fonction. Dans
    ce sens, le schéma des tables temporaires est particulièrement
    important car il est le premier schéma parcouru et qu'il est normalement
    modifiable par tous les utilisateurs. Une solution consiste à forcer
    le parcours de ce schéma en dernier lieu.
    Pour cela, on écrit <literal>pg_temp</literal> comme dernière entrée de
    <varname>search_path</varname>. La fonction suivante illustre une
    utilisation sûre&nbsp;:
   </para>

<programlisting>
CREATE FUNCTION verifie_motdepasse(unom TEXT, motpasse TEXT)
RETURNS BOOLEAN AS $$
DECLARE ok BOOLEAN;
BEGIN
        -- Effectuer le travail sécurisé de la fonction.
        SELECT  (motdepasse = $2) INTO ok
        FROM    motsdepasse
        WHERE   nomutilisateur = $1;

        RETURN ok;
END;
$$  LANGUAGE plpgsql
    SECURITY DEFINER
    -- Configure un search_path sécurisée : les schémas de confiance, puis 'pg_temp'.
    SET search_path = admin, pg_temp;
</programlisting>

   <para>
    Avant <productname>PostgreSQL</productname> 8.3, l'option
    <literal>SET</literal> n'était pas disponible, donc les anciennes fonctions
    pouvaient contenir un code assez complexe pour sauvegarder, initialiser
    puis restaurer un paramètre comme <varname>search_path</varname>. L'option <literal>SET</literal> est plus simple à utiliser dans ce but.
   </para>

   <para>
    Un autre point à garder en mémoire est que, par défaut, le droit d'exécution
    est donné à <literal>PUBLIC</literal> pour les fonctions nouvellement
    créées (voir <xref linkend="sql-grant"/> pour plus
    d'informations). Fréquemment, vous souhaiterez restreindre l'utilisation
    d'une fonction « security definer » à seulement quelques utilisateurs. Pour
    cela, vous devez révoquer les droits <literal>PUBLIC</literal> puis donner
    le droit d'exécution aux utilisateurs sélectionnés. Pour éviter que la
    nouvelle fonction soit accessible à tous pendant un court moment, créez-la
    et initialisez les droits dans une même transaction. Par exemple&nbsp;:
   </para>

<programlisting>
BEGIN;
CREATE FUNCTION verifie_motdepasse(unom TEXT, motpasse TEXT) ... SECURITY DEFINER;
REVOKE ALL ON FUNCTION verifie_motdepasse(unom TEXT, motpasse TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION verifie_motdepasse(unom TEXT, motpasse TEXT) TO admins;
COMMIT;
</programlisting>

 </refsect1>

 <refsect1 id="sql-createfunction-compat">
  <title>Compatibilité</title>

  <para>
   Une commande <command>CREATE FUNCTION</command> est définie en SQL:1999 et
   ultérieur. La version <productname>PostgreSQL</productname> est similaire
   mais pas entièrement compatible. Les attributs ne sont pas portables, pas
   plus que les différents langages disponibles.
  </para>

  <para>
   Pour des raisons de compatibilité avec d'autres systèmes de bases de données, 
   <replaceable class="parameter">modearg</replaceable> peut être écrit 
   avant ou après <replaceable class="parameter">nomarg</replaceable>. Mais
   seule la première façon est compatible avec le standard.
  </para>

  <para>
   Le standard SQL ne définit pas de paramètres par défaut. La syntaxe
   avec le mot clé <literal>DEFAULT</literal> provient d'Oracle, et elle
   est assez proche de l'esprit du standard&nbsp;: SQL/PSQL l'utilise pour les
   valeurs par défaut de variables. La syntaxe avec <literal>=</literal>
   est utilisée dans T-SQL et Firebird.
  </para>
 </refsect1>
 
 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterfunction"/></member>
   <member><xref linkend="sql-dropfunction"/></member>
   <member><xref linkend="sql-grant"/></member>
   <member><xref linkend="sql-load"/></member>
   <member><xref linkend="sql-revoke"/></member>
   <member><xref linkend="app-createlang"/></member>
  </simplelist>
 </refsect1>

</refentry>
