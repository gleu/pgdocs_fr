<?xml version="1.0" encoding="UTF-8"?>
<!--
doc/src/sgml/ref/merge.sgml
PostgreSQL documentation
-->

<refentry id="sql-merge">

 <refmeta>
  <refentrytitle>MERGE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>MERGE</refname>
  <refpurpose>Insère, met à jour ou efface des lignes d'une table selon une condition</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
[ WITH <replaceable class="parameter">clause_with</replaceable> [, ...] ]
MERGE INTO <replaceable class="parameter">nom_table_cible</replaceable> [ [ AS ] <replaceable class="parameter">alias_cible</replaceable> ]
USING <replaceable class="parameter">source_des_données</replaceable> ON <replaceable class="parameter">condition_de_jointure</replaceable>
<replaceable class="parameter">clause_when</replaceable> [...]

<phrase>où <replaceable class="parameter">source_des_données</replaceable> est&nbsp;:</phrase>

{ <replaceable class="parameter">nom_table_source</replaceable> | ( <replaceable class="parameter">requête_source</replaceable> ) } [ [ AS ] <replaceable class="parameter">alias_source</replaceable> ]

<phrase>et <replaceable class="parameter">clause_when</replaceable> est&nbsp;:</phrase>

{ WHEN MATCHED [ AND <replaceable class="parameter">condition</replaceable> ] THEN { <replaceable class="parameter">merge_update</replaceable> | <replaceable class="parameter">merge_delete</replaceable> | DO NOTHING } |
  WHEN NOT MATCHED [ AND <replaceable class="parameter">condition</replaceable> ] THEN { <replaceable class="parameter">merge_insert</replaceable> | DO NOTHING } }

<phrase>et <replaceable class="parameter">merge_insert</replaceable> est&nbsp;:</phrase>

INSERT [( <replaceable class="parameter">nom_de_colonne</replaceable> [, ...] )]
[ OVERRIDING { SYSTEM | USER } VALUE ]
{ VALUES ( { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...] ) | DEFAULT VALUES }

<phrase>et <replaceable class="parameter">merge_update</replaceable> est&nbsp;:</phrase>

UPDATE SET { <replaceable class="parameter">nom_de_colonne</replaceable> = { <replaceable class="parameter">expression</replaceable> | DEFAULT } |
             ( <replaceable class="parameter">nom_de_colonne</replaceable> [, ...] ) = ( { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...] ) } [, ...]

<phrase>et <replaceable class="parameter">merge_delete</replaceable> est :</phrase>

DELETE
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>MERGE</command> exécute des actions qui modifient des lignes dans
   <replaceable class="parameter">nom_table_cible</replaceable>,
   en utilisant la <replaceable class="parameter">source_des_données</replaceable>.
   <command>MERGE</command> fournit un ordre <acronym>SQL</acronym>
   qui, à lui seul et selon la condition, peut opérer un <command>INSERT</command>,
   un <command>UPDATE</command> ou un <command>DELETE</command> sur des lignes,
   un rôle qui nécessiterait sinon de multiples appels dans un langage procédural.
  </para>

  <para>
   La commande <command>MERGE</command> commence par faire une jointure
   de <replaceable class="parameter">source_des_données</replaceable> et
   <replaceable class="parameter">nom_table_cible</replaceable>
   et obtient zéro ou plus ligne(s) candidates au changement. Pour chacune,
   le statut <literal>MATCHED</literal> ou <literal>NOT MATCHED</literal>
   est posé une seule fois, puis les clauses <literal>WHEN</literal> sont
   évaluées dans l'ordre spécifié. Pour chaque ligne candidate à un changement,
   la première clause évaluée à Vrai est exécutée. Il est exécuté au plus
   une clause <literal>WHEN</literal> pour chaque ligne candidate au changement.
  </para>

  <para>
   Les opérations de <command>MERGE</command> ont le même effet que les
   commandes <command>UPDATE</command>, <command>INSERT</command>, ou
   <command>DELETE</command> de même nom. La syntaxe de ces commandes
   diffère, notamment sur l'absence de clause <literal>WHERE</literal>
   et de nom de table.
   Toutes les actions se réfèrent à la table
   <replaceable class="parameter">nom_table_cible</replaceable>,
   bien que des modifications sur d'autres tables puissent être faites
   par triggers.
  </para>

  <para>
   Si <literal>DO NOTHING</literal> est précisé, la ligne source est passée.
   Comme les actions sont évaluées dans l'ordre spécifié,
   il peut être utile de sauter les lignes source sans intérêt
   avant une gestion plus fine.
  </para>

  <para>
   Il n'y a pas de privilège <literal>MERGE</literal> dédié.
   Si vous spécifiez une mise à jour, vous devez posséder le
   privilège <literal>UPDATE</literal> sur les colonnes
   de <replaceable class="parameter">nom_table_cible</replaceable>
   mentionnées dans <literal>SET</literal>.
   Si vous spécifiez une insertion, vous devez posséder le privilège
   <literal>INSERT</literal> sur <replaceable class="parameter">nom_table_cible</replaceable>.
   Si vous spécifiez une suppression, vous devez posséder le privilège
   <literal>DELETE</literal> sur <replaceable class="parameter">nom_table_cible</replaceable>.
   Les privilèges sont testés et vérifiés une fois au démarrage de l'ordre,
   que les clauses <literal>WHEN</literal> concernées soient exécutées ou pas.
   Vous aurez besoin du privilège <literal>SELECT</literal> sur
   <replaceable class="parameter">source_des_données</replaceable>
   et toute(s) colonne(s) de <replaceable class="parameter">nom_table_cible</replaceable>
   référencée dans <literal>condition</literal>.
  </para>

  <para>
   <command>MERGE</command> n'est pas supporté si
   <replaceable class="parameter">nom_table_cible</replaceable>
   est une vue matérialisée, une table étrangère,
   ou si des règles y sont définies.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom_table_cible</replaceable></term>
    <listitem>
     <para>
      Nom (éventuellement avec le schéma) de la table cible où fusionner
      des informations.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">alias_cible</replaceable></term>
    <listitem>
     <para>
      Un nom à substituer à la table cible. Quand un alias est fourni,
      il cache complètement le nom réel de la table.
      Par exemple, avec <literal>MERGE INTO foo AS f</literal>,
      le reste de l'ordre <command>MERGE</command> devra appeler la
      table avec <literal>f</literal> et non <literal>foo</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_table_source</replaceable></term>
    <listitem>
     <para>
      Le nom (éventuellement qualifié avec le schéma) de la source, vue
      ou table de transition source.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">requête_source</replaceable></term>
    <listitem>
     <para>
      Une requête (commande <command>SELECT</command> ou <command>VALUES</command>)
      fournissant les lignes à fusionner dans 
      <replaceable class="parameter">nom_table_cible</replaceable>.
      Se référer à la documentation de <xref linkend="sql-select"/> ou
      <xref linkend="sql-values"/> pour une description de leurs syntaxes.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">alias_source</replaceable></term>
    <listitem>
     <para>
      Un nom substitut de la source de données.
      Quand un alias est fourni, il cache complètement le nom réel de la table
      ou le fait qu'une requête ait été fournie.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">condition_de_jointure</replaceable></term>
    <listitem>
     <para>
      <replaceable class="parameter">condition_de_jointure</replaceable> est
      Une expression dont le résultat est un
      <type>boolean</type> (similaire à une clause <literal>WHERE</literal>),
      lequel spécifie quelles lignes de 
      <replaceable class="parameter">source_des_données</replaceable>
      correspondent à des lignes dans
      <replaceable class="parameter">nom_table_cible</replaceable>.
     </para>
     <warning>
      <para>
       Seules les colonnes de <replaceable class="parameter">nom_table_cible</replaceable>
       qui cherchent une similitude dans <replaceable class="parameter">source_des_données</replaceable>
       devraient apparaître dans <replaceable class="parameter">condition_de_jointure</replaceable>.
       Les sous-expressions qui ne référencent que <replaceable class="parameter">nom_table_cible</replaceable>
       peuvent affecter le choix de l'action, souvent de manière surprenante.
      </para>
     </warning>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">clause_when</replaceable></term>
    <listitem>
     <para>
      Au moins une clause <literal>WHEN</literal> est nécessaire.
     </para>
     <para>
      Si la clause <literal>WHEN</literal> indique <literal>WHEN MATCHED</literal>
      et que la ligne candidate correspond à une ligne de 
      <replaceable class="parameter">nom_table_cible</replaceable>,
      et si <replaceable class="parameter">condition</replaceable>
      est absente ou évaluée à <literal>true</literal>,
      alors la clause <literal>WHEN</literal> est exécutée.
     </para>
     <para>
      À l'inverse, si la clause <literal>WHEN</literal> spécifie
      <literal>WHEN NOT MATCHED</literal>,
      et que la ligne candidate n'a pas de ligne correspondante dans
      <replaceable class="parameter">nom_table_cible</replaceable>,
      alors la clause <literal>WHEN</literal> est exécutée,
      si <replaceable class="parameter">condition</replaceable>
      est absente ou évaluée à <literal>true</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">condition</replaceable></term>
    <listitem>
     <para>
      Une expression dont le résultat est un <type>boolean</type>.
      Si cette expression renvoie <literal>true</literal>,
      alors la clause <literal>WHEN</literal> qu'elle accompagne
      est exécutée pour la ligne en cours.
     </para>
     <para>
      Une condition d'une clause <literal>WHEN MATCHED</literal> peut
      se référer à des colonnes de la relation source comme de la cible.
      Une condition d'une clause <literal>WHEN NOT MATCHED</literal>
      ne peut se référer qu'à des colonnes de la relation source,
      puisque, par définition, il n'y a pas de ligne correspondante
      dans la cible. Seuls les attributs de la table cible sont
      modifiables.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">merge_insert</replaceable></term>
    <listitem>
     <para>
      Spécification de la clause <literal>INSERT</literal> qui insère une
      ou plusieurs lignes dans la table cible. Les noms des colonnes cibles
      peuvent être listés dans n'importe quel ordre. Si aucune liste n'est
      donnée, le défaut est l'ensemble des colonnes de la table dans leur
      ordre de déclaration.
     </para>
     <para>
      Chaque colonne absente de la liste des champs, explicite ou implicite,
      sera remplie par une valeur par défaut, soit sa valeur par défaut
      déclarée, soit null.
     </para>
     <para>
      Si l'expression d'une colonne quelconque n'est pas du bon type de
      données, une conversion automatique du type sera tentée.
     </para>
     <para>
      Si <replaceable class="parameter">nom_table_cible</replaceable>
      est une table partitionnée, chaque ligne est routée vers la
      partitions appropriée et insérée dedans.
      Si <replaceable class="parameter">nom_table_cible</replaceable>
      est une partition, une erreur se produira si une ligne quelconque
      viole la contrainte de partitionnement.
     </para>
     <para>
      Les noms de colonnes ne peuvent être spécifiés qu'une fois.
      Les commandes <command>INSERT</command> ne peuvent contenir
      des sous-selects.
     </para>
     <para>
      Une seule clause <literal>VALUES</literal> peut être spécifiée.
      La clause <literal>VALUES</literal> ne peut se référer qu'à des
      colonnes de la table source, puisque par définition il n'y a
      pas de ligne cible correspondante. 
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">merge_update</replaceable></term>
    <listitem>
     <para>
      Spécification de la commande <literal>UPDATE</literal> qui met à jour
      la ligne courante de <replaceable class="parameter">nom_table_cible</replaceable>.
      Les noms de colonnes ne peuvent être utilisés plus d'une fois.
     </para>
     <para>
      Ne sont permis ni un nom de table, ni une clause <literal>WHERE</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">merge_delete</replaceable></term>
    <listitem>
     <para>
      Spécifie une action <literal>DELETE</literal> qui efface la ligne courante
      de  <replaceable class="parameter">nom_table_cible</replaceable>.
      N'incluez ni le nom de la table ni aucune autre clause,
      comme vous le feriez pour une commande <xref linkend="sql-delete"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_de_colonne</replaceable></term>
    <listitem>
     <para>
      Le nom d'une colonne dans
      <replaceable class="parameter">nom_table_cible</replaceable>.
      Au besoin, il peut être complété avec un nom de sous-champ
      ou un indice de tableau.
      (N'insérer que dans certains champs d'une colonne composée laisse
      les autres champs à null).
      N'incluez par le nom de la table dans la définition d'une colonne cible.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OVERRIDING SYSTEM VALUE</literal></term>
    <listitem>
     <para>
      Sans cette clause, une erreur sera levée si une valeur explicite
      (other than <literal>DEFAULT</literal>) est spécifiée pour une
      colonne identité définie comme <literal>GENERATED ALWAYS</literal>.
      Cette clause passe outre à la restriction.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OVERRIDING USER VALUE</literal></term>
    <listitem>
     <para>
      Avec cette clause, toutes les valeur fournies pour des colonnes
      identités définies comme <literal>GENERATED BY DEFAULT</literal>
      sont ignorées, et les valeurs générées par séquence sont appliquées.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT VALUES</literal></term>
    <listitem>
     <para>
      Toutes les colonnes seront remplies avec leur valeur par défaut.
      (Une clause <literal>OVERRIDING</literal> n'est alors pas permise.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">expression</replaceable></term>
    <listitem>
     <para>
      Une expression à assigner à une colonne.
      Au sein d'une clause <literal>WHEN MATCHED</literal>,
      elle peut utiliser des valeurs de la ligne originale dans
      la table cible, et des valeurs de la ligne issue de
      <literal>source_des_données</literal>.
      Dans une clause <literal>WHEN NOT MATCHED</literal>,
      l'expression peut utiliser des valeurs de
      <literal>source_des_données</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT</literal></term>
    <listitem>
     <para>
      Positionne une colonne à sa valeur par défaut
      (qui sera <literal>NULL</literal> si aucune autre n'a été définie).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">clause_with</replaceable></term>
    <listitem>
     <para>
      La clause <literal>WITH</literal>  vous permet de préciser une
      ou plusieurs sous-requêtes référençables par la requête
      <command>MERGE</command>. Voir <xref linkend="queries-with"/>
      et <xref linkend="sql-select"/> pour les détails.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
 </refsect1>

 <refsect1>
  <title>Outputs</title>

  <para>
   Si elle termine avec succès, la commande <command>MERGE</command>
   renvoie un résultat de la forme&nbsp;:
<screen>
MERGE <replaceable class="parameter">nombre_total</replaceable>
</screen>
   <replaceable class="parameter">nombre_total</replaceable> est le
   nombre total des lignes changées (insérées, mises à jour comme effacées).
   Si <replaceable class="parameter">nombre_total</replaceable> vaut 0,
   aucune ligne n'a été changée de quelque manière que ce soit.
  </para>

 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
      Les étapes suivantes se déroulent pendant l'exécution
      de <command>MERGE</command>.
    <orderedlist>
     <listitem>
      <para>
       Exécute tous les triggers <literal>BEFORE STATEMENT</literal>
       de chaque action spécifiée, que leur clause
       <literal>WHEN</literal> renvoie quelque chose ou non.
      </para>
     </listitem>
     <listitem>
      <para>
       Fait une jointure entre la source et la table cible.
       La requête résultante sera optimisée comme à l'habitude,
       et produira un ensemble de lignes candidates au changement.
       Pour chacune&nbsp;:
          
       <orderedlist>
        <listitem>
         <para>
          Évalue pour chaque ligne si elle a une correspondance
          (<literal>MATCHED</literal>) ou pas
          (<literal>NOT MATCHED</literal>).
         </para>
        </listitem>
        <listitem>
         <para>
          Teste chaque condition <literal>WHEN</literal> dans
          l'ordre spécifié jusqu'à ce qu'une renvoie Vrai.
         </para>
        </listitem>
        <listitem>
         <para>
          Quand une condition renvoie Vrai, exécute les actions
          suivantes&nbsp;:
          <orderedlist>
           <listitem>
            <para>
             exécute tous les triggers <literal>BEFORE ROW</literal>
             qui se déclenchent sur ce type d'action.
            </para>
           </listitem>
           <listitem>
            <para>
             exécute l'action spécifiées, en vérifiant toute
             contrainte sur la table cible&nbsp;;
            </para>
           </listitem>
           <listitem>
            <para>
             exécute tous les triggers <literal>AFTER ROW</literal>
             qui se déclenchent sur ce type d'action.
            </para>
           </listitem>
          </orderedlist></para>
        </listitem>
       </orderedlist></para>
     </listitem>
     <listitem>
      <para>
       Exécute tous les triggers <literal>AFTER STATEMENT</literal>
       pour les actions spécifiées, qu'elles se soient ou non
       produites. C'est équivalent à un ordre <command>UPDATE</command>
       qui ne modifie aucune ligne.
      </para>
     </listitem>
    </orderedlist>
   En résumé, les triggers de niveau instruction (par exemple
   <command>INSERT</command>) seront déclenchés à chaque
   <emphasis>spécification</emphasis> d'une action de ce genre.
   Par contre, les triggers de niveau ligne se déclencheront
   uniquement pour les types d'événements
   <emphasis>exécutés</emphasis>.
   Ainsi un ordre <command>MERGE</command> peut déclencher à la fois
   des triggers sur instruction <command>UPDATE</command> et sur <command>INSERT</command>, même si seuls des triggers de
   ligne sur <command>UPDATE</command> sont déclenchés.
  </para>

  <para>
   Vous devez vous assurer que la jointure produit au plus une
   ligne candidate pour chaque ligne de la source. En d'autres termes,
   une ligne cible ne devrait pas être jointe à plus d'une ligne
   de données source. Si cela devait arriver, une seule ligne parmi
   les candidates sera utilisée pour modifier la ligne cible&nbsp;
   une erreur sera levée lors des tentatives suivantes de
   modification de la ligne.
   Cela peut arriver si des triggers sur ligne modifient la table
   cible et que les lignes modifiées sont par la suite aussi
   modifiées par <command>MERGE</command>.
   
   Si l'action répétée est un <command>INSERT</command>,
   cela provoquera une violation d'unicité, alors que des ordres
   <command>UPDATE</command> ou <command>DELETE</command> répétés
   causeront une violation de cardinalité&nbsp;; ce dernier
   comportement est exigé par le standard <acronym>SQL</acronym>.
   Cela diffère du comportement historique de
   <productname>PostgreSQL</productname> dans les jointures
   au sein d'ordres <command>UPDATE</command> et <command>DELETE</command>,
   où le deuxième essai de modification d'une même ligne est simplement
   ignoré, tout comme les suivants.
  </para>

  <para>
   Si une clause <literal>WHEN</literal> omet une sous-clause
   <literal>AND</literal>, elle devient l'état final atteignable
   par ce type (<literal>MATCHED</literal> ou <literal>NOT MATCHED</literal>).
   Si une autre clause <literal>WHEN</literal> est spécifiée
   pour le même type, elle serait probablement inatteignable,
   et une erreur est levée.
   Si aucun état final n'est spécifié pour un type, il est
   possible qu'aucune action ne soit exécutée pour la ligne candidate.
  </para>

  <para>
   L'ordre dans lequel les lignes seront générées depuis la source des
   données est par défaut indéterminé.
   Au besoin, une <replaceable class="parameter">requête_source</replaceable>
   peut être utilisée pour définir un ordre consistent, qui pourrait
   être nécessaire pour éviter des verrous mutuels entre transactions
   simultanées.
  </para>

  <para>
   Il n'y a pas de clause <literal>RETURNING</literal> à une
   commande <command>MERGE</command>.
   Les action <command>INSERT</command>, <command>UPDATE</command> et
   <command>DELETE</command> ne peuvent contenir de clauses
   <literal>RETURNING</literal> ou <literal>WITH</literal>.
  </para>

  <para>
   Quand <command>MERGE</command> est lancé en parallèle à d'autres
   commandes qui modifient la table cible, les règles usuelles d'isolation
   des transactions s'appliquent&nbdp;; voir <xref linkend="transaction-iso"/> 
   pour une explication du comportement de chaque niveau d'isolation.
   Comme alternative permettant de lancer un ordre <command>UPDATE</command>
   en même temps que se déroule un <command>INSERT</command>,
   vous pouvez considérer  <command>INSERT ... ON CONFLICT</command>.
   Il y a une telle diversité de différence et de limites entre les deux
   ordres qu'ils ne sont pas interchangeables.
  </para>
 </refsect1>

 <refsect1>
  <title>Examples</title>

  <para>
   Perform maintenance on <literal>CustomerAccounts</literal> based
   upon new <literal>Transactions</literal>.

<programlisting>
MERGE INTO CustomerAccount CA
USING RecentTransactions T
ON T.CustomerId = CA.CustomerId
WHEN MATCHED THEN
  UPDATE SET Balance = Balance + TransactionValue
WHEN NOT MATCHED THEN
  INSERT (CustomerId, Balance)
  VALUES (T.CustomerId, T.TransactionValue);
</programlisting>
  </para>

  <para>
   Notice that this would be exactly equivalent to the following
   statement because the <literal>MATCHED</literal> result does not change
   during execution.

<programlisting>
MERGE INTO CustomerAccount CA
USING (Select CustomerId, TransactionValue From RecentTransactions) AS T
ON CA.CustomerId = T.CustomerId
WHEN NOT MATCHED THEN
  INSERT (CustomerId, Balance)
  VALUES (T.CustomerId, T.TransactionValue)
WHEN MATCHED THEN
  UPDATE SET Balance = Balance + TransactionValue;
</programlisting>
  </para>

  <para>
   Attempt to insert a new stock item along with the quantity of stock. If
   the item already exists, instead update the stock count of the existing
   item. Don't allow entries that have zero stock.
<programlisting>
MERGE INTO wines w
USING wine_stock_changes s
ON s.winename = w.winename
WHEN NOT MATCHED AND s.stock_delta > 0 THEN
  INSERT VALUES(s.winename, s.stock_delta)
WHEN MATCHED AND w.stock + s.stock_delta > 0 THEN
  UPDATE SET stock = w.stock + s.stock_delta
WHEN MATCHED THEN
  DELETE;
</programlisting>

   The <literal>wine_stock_changes</literal> table might be, for example, a
   temporary table recently loaded into the database.
  </para>

 </refsect1>

 <refsect1>
  <title>Compatibility</title>
   <para>
    This command conforms to the <acronym>SQL</acronym> standard.
  </para>
   <para>
    The WITH clause and <literal>DO NOTHING</literal> action are extensions to
    the <acronym>SQL</acronym> standard.
  </para>
 </refsect1>
</refentry>
