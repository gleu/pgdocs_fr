<?xml version="1.0" encoding="UTF-8"?>
<refentry id="sql-merge">
 <indexterm zone="sql-merge">
  <primary>MERGE</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>MERGE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>MERGE</refname>
  <refpurpose>Insère, met à jour ou efface des lignes d'une table selon une
   condition</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
[ WITH <replaceable class="parameter">clause_with</replaceable> [, ...] ]
MERGE INTO <replaceable class="parameter">nom_table_cible</replaceable> [ [ AS ] <replaceable class="parameter">alias_cible</replaceable> ]
USING <replaceable class="parameter">source_des_données</replaceable> ON <replaceable class="parameter">condition_de_jointure</replaceable>
<replaceable class="parameter">clause_when</replaceable> [...]

<phrase>où <replaceable class="parameter">source_des_données</replaceable> est&nbsp;:</phrase>

{ <replaceable class="parameter">nom_table_source</replaceable> | ( <replaceable class="parameter">requête_source</replaceable> ) } [ [ AS ] <replaceable class="parameter">alias_source</replaceable> ]

<phrase>et <replaceable class="parameter">clause_when</replaceable> est&nbsp;:</phrase>

{ WHEN MATCHED [ AND <replaceable class="parameter">condition</replaceable> ] THEN { <replaceable class="parameter">merge_update</replaceable> | <replaceable class="parameter">merge_delete</replaceable> | DO NOTHING } |
  WHEN NOT MATCHED [ AND <replaceable class="parameter">condition</replaceable> ] THEN { <replaceable class="parameter">merge_insert</replaceable> | DO NOTHING } }

<phrase>et <replaceable class="parameter">merge_insert</replaceable> est&nbsp;:</phrase>

INSERT [( <replaceable class="parameter">nom_de_colonne</replaceable> [, ...] )]
[ OVERRIDING { SYSTEM | USER } VALUE ]
{ VALUES ( { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...] ) | DEFAULT VALUES }

<phrase>et <replaceable class="parameter">merge_update</replaceable> est&nbsp;:</phrase>

UPDATE SET { <replaceable class="parameter">nom_de_colonne</replaceable> = { <replaceable class="parameter">expression</replaceable> | DEFAULT } |
             ( <replaceable class="parameter">nom_de_colonne</replaceable> [, ...] ) = ( { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...] ) } [, ...]

<phrase>et <replaceable class="parameter">merge_delete</replaceable> est&nbsp;:</phrase>

DELETE
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>MERGE</command> exécute des actions qui modifient des lignes dans
   <replaceable class="parameter">nom_table_cible</replaceable>, à partir d'une
   <replaceable class="parameter">source_des_données</replaceable>.
   <command>MERGE</command> est un ordre <acronym>SQL</acronym> qui, à lui seul
   et selon la condition, peut opérer un <command>INSERT</command>, un
   <command>UPDATE</command> ou un <command>DELETE</command> sur des lignes, une
   tâche qui nécessiterait sinon de multiples appels en langage procédural.
  </para>

  <para>
   Tout d'abord, la commande <command>MERGE</command> fait une jointure entre
   <replaceable class="parameter">source_des_données</replaceable> et
   <replaceable class="parameter">nom_table_cible</replaceable>, ce qui donne
   zéro ou plus ligne(s) candidates au changement. Pour chacune, on définit le
   statut <literal>MATCHED</literal> ou <literal>NOT MATCHED</literal> une fois
   pour toutes&nbsp;; puis les clauses <literal>WHEN</literal> sont évaluées
   dans l'ordre spécifié. Pour chaque ligne candidate à un changement, la
   première clause évaluée à true est exécutée. Au plus une clause
   <literal>WHEN</literal> est exécutée pour chaque ligne candidate au
   changement.
  </para>

  <para>
   Les opérations de <command>MERGE</command> ont le même effet que les
   commandes <command>UPDATE</command>, <command>INSERT</command>, ou
   <command>DELETE</command> de même nom. La syntaxe de ces commandes diffère,
   notamment sur l'absence de clause <literal>WHERE</literal> et de nom de
   table.  Toutes les actions opèrent sur la table <replaceable
   class="parameter">nom_table_cible</replaceable>, bien que des modifications
   sur d'autres tables puissent être faites en passant par des triggers.
  </para>

  <para>
   Si <literal>DO NOTHING</literal> est précisé, la ligne source est passée.
   Comme les actions sont évaluées dans l'ordre spécifié, il peut être pratique
   de sauter les lignes source sans intérêt avant une gestion plus fine.
  </para>

  <para>
   Il n'y a pas de droit <literal>MERGE</literal> dédié.  Si vous spécifiez une
   mise à jour, vous devez posséder le droit <literal>UPDATE</literal> sur les
   colonnes de <replaceable class="parameter">nom_table_cible</replaceable>
   mentionnées dans la clause <literal>SET</literal>.  Pour une insertion, vous
   devez posséder le droit <literal>INSERT</literal> sur <replaceable
   class="parameter">nom_table_cible</replaceable>.  Et pour une suppression,
   vous devez posséder le droit <literal>DELETE</literal> sur <replaceable
   class="parameter">nom_table_cible</replaceable>.  Les droits sont testés et
   vérifiés une fois au démarrage de l'ordre, que les clauses
   <literal>WHEN</literal> concernées soient exécutées ou pas.  Vous aurez
   besoin du droit <literal>SELECT</literal> sur <replaceable
   class="parameter">source_des_données</replaceable> et sur toute colonne de
   <replaceable class="parameter">nom_table_cible</replaceable> référencée dans
   <literal>condition</literal>.
  </para>

  <para>
   <command>MERGE</command> n'est pas supporté si <replaceable
   class="parameter">nom_table_cible</replaceable> est une vue matérialisée, une
   table étrangère, ou si des règles y ont été posées.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom_table_cible</replaceable></term>
    <listitem>
     <para>
      Nom (éventuellement qualifié du schéma) de la table cible où fusionner des
      informations.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">alias_cible</replaceable></term>
    <listitem>
     <para>
      Un nom à substituer à la table cible. Quand un alias est fourni, il cache
      complètement le nom réel de la table.  Par exemple, avec <literal>MERGE
      INTO foo AS f</literal>, le reste de l'ordre <command>MERGE</command>
      devra appeler la table avec <literal>f</literal> et non
      <literal>foo</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_table_source</replaceable></term>
    <listitem>
     <para>
      Le nom (éventuellement qualifié du schéma) de la table, vue ou table de
      transition source.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">requête_source</replaceable></term>
    <listitem>
     <para>
      Une requête (commande <command>SELECT</command> ou
      <command>VALUES</command>) fournissant les lignes à fusionner dans
      <replaceable class="parameter">nom_table_cible</replaceable>.  Se référer
      à la documentation de <xref linkend="sql-select"/> ou <xref
      linkend="sql-values"/> pour une description des syntaxes.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">alias_source</replaceable></term>
    <listitem>
     <para>
      Un nom substitut de la source de données. Quand un alias est fourni, il
      cache complètement le nom réel de la table ou le fait qu'une requête ait
      été fournie.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">condition_de_jointure</replaceable></term>
    <listitem>
     <para>
      <replaceable class="parameter">condition_de_jointure</replaceable> est une
      expression dont le résultat est un <type>boolean</type> (similaire à une
      clause <literal>WHERE</literal>), lequel indique quelles lignes de
      <replaceable class="parameter">source_des_données</replaceable>
      correspondent à des lignes dans <replaceable
      class="parameter">nom_table_cible</replaceable>.
     </para>

     <warning>
      <para>
       Seules les colonnes de <replaceable
       class="parameter">nom_table_cible</replaceable> que l'on tente de
       rapprocher de <replaceable
       class="parameter">source_des_données</replaceable> devraient apparaître
       dans <replaceable class="parameter">condition_de_jointure</replaceable>.
       Les sous-expressions de la condition qui ne référencent que <replaceable
       class="parameter">nom_table_cible</replaceable> peuvent affecter le choix
       de l'action, souvent de manière surprenante.
      </para>
     </warning>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">clause_when</replaceable></term>
    <listitem>
     <para>
      Au moins une clause <literal>WHEN</literal> est nécessaire.
     </para>

     <para>
      Si la clause <literal>WHEN</literal> indique <literal>WHEN
      MATCHED</literal> et que la ligne candidate correspond à une ligne de
      <replaceable class="parameter">nom_table_cible</replaceable>, et si
      <replaceable class="parameter">condition</replaceable> est absente ou
      évaluée à <literal>true</literal>, alors la clause <literal>WHEN</literal>
      est exécutée.
     </para>

     <para>
      À l'inverse, si la clause <literal>WHEN</literal> indique <literal>WHEN
      NOT MATCHED</literal>, et que la ligne candidate n'a pas de ligne
      correspondante dans <replaceable
      class="parameter">nom_table_cible</replaceable>, et si <replaceable
      class="parameter">condition</replaceable> est absente ou évaluée à
      <literal>true</literal>, alors la clause <literal>WHEN</literal> est
      exécutée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">condition</replaceable></term>
    <listitem>
     <para>
      Une expression dont le résultat est un <type>boolean</type>. Si cette
      expression renvoie <literal>true</literal>, alors la clause
      <literal>WHEN</literal> qu'elle accompagne est exécutée pour la ligne en
      cours.
     </para>

     <para>
      Une condition d'une clause <literal>WHEN MATCHED</literal> peut se référer
      à des colonnes de la relation source comme de la cible. Une condition
      d'une clause <literal>WHEN NOT MATCHED</literal> ne peut se référer qu'à
      des colonnes de la relation source, puisque, par définition, il n'y a pas
      de ligne correspondante dans la cible. Seuls les attributs système de la
      table cible sont accessibles.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">merge_insert</replaceable></term>
    <listitem>
     <para>
      Spécification de la clause <literal>INSERT</literal> qui insère une ou
      plusieurs lignes dans la table cible. Les noms des colonnes cibles peuvent
      être listés dans n'importe quel ordre. Si aucune liste n'est donnée, le
      défaut est l'ensemble des colonnes de la table dans leur ordre de
      déclaration.
     </para>

     <para>
      Chaque colonne absente de la liste des champs, explicite ou implicite,
      sera remplie par une valeur par défaut, soit sa valeur par défaut
      déclarée, soit NULL.
     </para>

     <para>
      Si <replaceable class="parameter">nom_table_cible</replaceable> est une
      table partitionnée, chaque ligne est routée vers la partition appropriée
      et insérée dedans. Si <replaceable
      class="parameter">nom_table_cible</replaceable> est une partition, une
      erreur se produira si une ligne quelconque viole la contrainte de
      partitionnement.
     </para>

     <para>
      Les noms de colonnes ne peuvent être spécifiés qu'une fois. Les commandes
      <command>INSERT</command> ne peuvent pas contenir des sous-SELECT.
     </para>

     <para>
      Une seule clause <literal>VALUES</literal> peut être spécifiée. Elle ne
      peut se référer qu'à des colonnes de la table source, puisque par
      définition il n'y a pas de ligne cible correspondante.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">merge_update</replaceable></term>
    <listitem>
     <para>
      Spécification de la commande <literal>UPDATE</literal> qui met à jour la
      ligne courante de <replaceable
      class="parameter">nom_table_cible</replaceable>. Les noms de colonnes ne
      peuvent être utilisés plus d'une fois.
     </para>

     <para>
      Ne sont permis ni un nom de table, ni une clause <literal>WHERE</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">merge_delete</replaceable></term>
    <listitem>
     <para>
      Spécifie une action <literal>DELETE</literal> qui efface la ligne courante
      de  <replaceable class="parameter">nom_table_cible</replaceable>.
      N'incluez ni le nom de la table ni aucune autre clause, comme vous le
      feriez pour une commande <xref linkend="sql-delete"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_de_colonne</replaceable></term>
    <listitem>
     <para>
      Le nom d'une colonne dans <replaceable
      class="parameter">nom_table_cible</replaceable>. Au besoin, il peut être
      complété avec un nom de sous-champ ou un indice de tableau. (N'insérer
      que dans certains champs d'une colonne composée laisse les autres champs à
      NULL). N'incluez pas le nom de la table dans la définition d'une colonne
      cible.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OVERRIDING SYSTEM VALUE</literal></term>
    <listitem>
     <para>
      Sans cette clause, une erreur sera levée si une valeur explicite (autre
      que <literal>DEFAULT</literal>) est spécifiée pour une colonne identité
      définie comme <literal>GENERATED ALWAYS</literal>. Cette clause passe
      outre à la restriction.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OVERRIDING USER VALUE</literal></term>
    <listitem>
     <para>
      Avec cette clause, toutes les valeurs fournies pour des colonnes identité
      définies comme <literal>GENERATED BY DEFAULT</literal> sont ignorées, et
      les valeurs générées par séquence sont appliquées.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT VALUES</literal></term>
    <listitem>
     <para>
      Toutes les colonnes seront remplies avec leur valeur par défaut. (Une
      clause <literal>OVERRIDING</literal> n'est alors pas permise.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">expression</replaceable></term>
    <listitem>
     <para>
      Une expression à assigner à une colonne. Au sein d'une clause
      <literal>WHEN MATCHED</literal>, elle peut utiliser des valeurs de la
      ligne originale dans la table cible, et des valeurs de la ligne issue de
      <literal>source_des_données</literal>. Dans une clause <literal>WHEN NOT
      MATCHED</literal>, l'expression peut utiliser des valeurs de
      <literal>source_des_données</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT</literal></term>
    <listitem>
     <para>
      Positionne une colonne à sa valeur par défaut (qui sera
      <literal>NULL</literal> si aucune n'a été définie).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">clause_with</replaceable></term>
    <listitem>
     <para>
      La clause <literal>WITH</literal> vous permet de préciser une ou plusieurs
      sous-requêtes référençables par la requête <command>MERGE</command>. Voir
      <xref linkend="queries-with"/> et <xref linkend="sql-select"/> pour les
      détails.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
 </refsect1>

 <refsect1>
  <title>Résultats</title>

  <para>
   Si elle termine avec succès, la commande <command>MERGE</command> renvoie un
   résultat de la forme&nbsp;:
<screen>
MERGE <replaceable class="parameter">nombre_total</replaceable>
</screen>
   <replaceable class="parameter">nombre_total</replaceable> est le nombre total
   des lignes changées (qu'elles aient été insérées, mises à jour ou effacées).
   Si <replaceable class="parameter">nombre_total</replaceable> vaut 0, aucune
   ligne n'a été changée de quelque manière que ce soit.
  </para>

 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   Les étapes suivantes se déroulent pendant l'exécution
   de <command>MERGE</command>.
   <orderedlist>
    <listitem>
     <para>
      Exécute tous les triggers <literal>BEFORE STATEMENT</literal> de chaque
      action spécifiée, que leur clause <literal>WHEN</literal> renvoie quelque
      chose ou non.
     </para>
    </listitem>

    <listitem>
     <para>
      Fait une jointure entre la source et la table cible. La requête
      résultante sera optimisée comme à l'habitude, et produira un ensemble de
      lignes candidates au changement.  Pour chacune&nbsp;:

      <orderedlist>
       <listitem>
        <para>
         Évalue pour chaque ligne si elle a une correspondance
         (<literal>MATCHED</literal>) ou pas (<literal>NOT MATCHED</literal>).
        </para>
       </listitem>

       <listitem>
        <para>
         Teste chaque condition <literal>WHEN</literal> dans l'ordre spécifié
         jusqu'à ce qu'une renvoie true.
        </para>
       </listitem>

       <listitem>
        <para>
         Quand une condition renvoie true, exécute les actions suivantes&nbsp;:

         <orderedlist>
          <listitem>
           <para>
            exécute tous les triggers <literal>BEFORE ROW</literal> qui se
            déclenchent sur ce type d'action&nbsp;;
           </para>
          </listitem>

          <listitem>
           <para>
            exécute l'action spécifiée, en vérifiant toutes les contraintes sur
            la table cible&nbsp;;
           </para>
          </listitem>

          <listitem>
           <para>
            exécute tous les triggers <literal>AFTER ROW</literal> qui se
            déclenchent sur ce type d'action.
           </para>
          </listitem>
         </orderedlist>
        </para>
       </listitem>
      </orderedlist>
     </para>
    </listitem>

    <listitem>
     <para>
      Exécute tous les triggers <literal>AFTER STATEMENT</literal> pour les
      actions spécifiées, qu'elles se soient ou non réellement produites. C'est
      équivalent à un ordre <command>UPDATE</command> qui ne modifie aucune
      ligne.
     </para>
    </listitem>
   </orderedlist>

   En résumé, les triggers de niveau instruction (par exemple
   <command>INSERT</command>) seront déclenchés à chaque
   <emphasis>spécification</emphasis> d'une action de leur genre. Par contre,
   les triggers de niveau ligne se déclencheront uniquement pour les types
   d'événements <emphasis>exécutés</emphasis>. Ainsi un ordre
   <command>MERGE</command> peut déclencher à la fois des triggers sur
   instruction <command>UPDATE</command> et sur <command>INSERT</command>, même
   si seuls des triggers de ligne sur <command>UPDATE</command> sont déclenchés.
  </para>

  <para>
   Vous devez vous assurer que la jointure produit au plus une ligne candidate
   pour chaque ligne de la source. En d'autres termes, une ligne cible ne
   devrait pas être jointe à plus d'une ligne de données source. Si cela devait
   arriver, une seule ligne parmi les candidates sera utilisée pour modifier la
   ligne cible&nbsp;; une erreur sera levée lors des tentatives suivantes de
   modification de la ligne.  Cela peut arriver si des triggers sur ligne
   modifient la table cible et que les lignes modifiées sont par la suite aussi
   modifiées par <command>MERGE</command>. Si l'action répétée est un
   <command>INSERT</command>, cela provoquera une violation d'unicité, alors que
   des ordres <command>UPDATE</command> ou <command>DELETE</command> répétés
   causeront une violation de cardinalité&nbsp;; ce dernier comportement est
   exigé par le standard <acronym>SQL</acronym>. Cela diffère du comportement
   historique de <productname>PostgreSQL</productname> dans les jointures au
   sein d'ordres <command>UPDATE</command> et <command>DELETE</command>, où le
   deuxième essai de modification d'une même ligne est simplement ignoré, tout
   comme les suivants.
  </para>

  <para>
   Si une clause <literal>WHEN</literal> omet une sous-clause
   <literal>AND</literal>, elle devient la clause finale atteinte pour ce type
   (<literal>MATCHED</literal> ou <literal>NOT MATCHED</literal>). Si une autre
   clause <literal>WHEN</literal> est spécifiée pour le même type, elle serait
   probablement inatteignable et une erreur est levée. Si aucune clause finale
   n'est spécifiée pour un type, il est possible qu'aucune action ne soit
   exécutée pour la ligne candidate.
  </para>

  <para>
   L'ordre dans lequel les lignes seront générées depuis la source des données
   est par défaut indéterminé. Au besoin, une <replaceable
   class="parameter">requête_source</replaceable> peut être utilisée pour
   définir un ordre cohérent, qui pourrait être nécessaire pour éviter des
   verrous mutuels entre transactions simultanées.
  </para>

  <para>
   Il n'y a pas de clause <literal>RETURNING</literal> à une commande
   <command>MERGE</command>. Les action <command>INSERT</command>,
   <command>UPDATE</command> et <command>DELETE</command> ne peuvent contenir de
   clauses <literal>RETURNING</literal> ou <literal>WITH</literal>.
  </para>

  <para>
   Quand <command>MERGE</command> est lancé en parallèle à d'autres commandes
   qui modifient la table cible, les règles usuelles d'isolation des
   transactions s'appliquent&nbsp;; voir <xref linkend="transaction-iso"/> pour
   une explication du comportement de chaque niveau d'isolation.  Comme
   alternative permettant de lancer un ordre <command>UPDATE</command> en même
   temps que se déroule un <command>INSERT</command>, vous pouvez considérer
   <command>INSERT ... ON CONFLICT</command>.  Il y a beaucoup de différences
   entre les deux ordres, et leurs limites diffèrent, si bien qu'ils ne sont pas
   interchangeables.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Effectue une maintenance sur <literal>CustomerAccounts</literal> à partir de
   nouvelles <literal>Transactions</literal>.

<programlisting>
MERGE INTO CustomerAccount CA
USING RecentTransactions T
ON T.CustomerId = CA.CustomerId
WHEN MATCHED THEN
  UPDATE SET Balance = Balance + TransactionValue
WHEN NOT MATCHED THEN
  INSERT (CustomerId, Balance)
  VALUES (T.CustomerId, T.TransactionValue);
</programlisting>
  </para>

  <para>
   Notez que c'est exactement la même chose que l'ordre suivant, car le résultat
   du <literal>MATCHED</literal> ne change pas pendant l'exécution.

<programlisting>
MERGE INTO CustomerAccount CA
USING (Select CustomerId, TransactionValue From RecentTransactions) AS T
ON T.CustomerId = CA.CustomerId
WHEN MATCHED THEN
  UPDATE SET Balance = Balance + TransactionValue;
WHEN NOT MATCHED THEN
  INSERT (CustomerId, Balance)
  VALUES (T.CustomerId, T.TransactionValue)
</programlisting>
  </para>

  <para>
   Tente d'insérer un nouvel article dans un stock avec sa quantité. Si
   l'article existe déjà, met plutôt à jour son stock existant. Interdit les
   entrées avec un stock à zéro.

<programlisting>
MERGE INTO wines w
USING wine_stock_changes s
ON s.winename = w.winename
WHEN NOT MATCHED AND s.stock_delta > 0 THEN
  INSERT VALUES(s.winename, s.stock_delta)
WHEN MATCHED AND w.stock + s.stock_delta > 0 THEN
  UPDATE SET stock = w.stock + s.stock_delta
WHEN MATCHED THEN
  DELETE;
</programlisting>

   La table <literal>wine_stock_changes</literal> peut être, par exemple, une
   table temporaire récemment chargée dans la base.
  </para>

 </refsect1>

 <refsect1>
  <title>Compatibilité</title>
   <para>
    Cette commande se conforme au standard <acronym>SQL</acronym>.
  </para>

  <para>
   La clause WITH et l'action <literal>DO NOTHING</literal> sont des extensions
   au standard <acronym>SQL</acronym>.
  </para>
 </refsect1>
</refentry>
