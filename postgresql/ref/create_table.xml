<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<refentry id="sql-createtable">
 <indexterm zone="sql-createtable">
  <primary>CREATE TABLE</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE TABLE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TABLE</refname>
  <refpurpose>Définir une nouvelle table</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <synopsis>CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="PARAMETER">nom_table</replaceable> ( [
  { <replaceable class="PARAMETER">nom_colonne</replaceable> <replaceable class="PARAMETER">type_donnees</replaceable> [ COLLATE <replaceable>collation</replaceable> ] [ <replaceable class="PARAMETER">contrainte_colonne</replaceable> [ ... ] ]
    | <replaceable>contrainte_table</replaceable>
    | LIKE <replaceable>table_source</replaceable> [ <replaceable>option_like</replaceable> ... ] }
    [, ... ]
] )
[ INHERITS ( <replaceable>table_parent</replaceable> [, ... ] ) ]
[ PARTITION BY { RANGE | LIST | HASH } ( { <replaceable class="parameter">nom_colonne</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ... ] ) ]
[ WITH ( <replaceable class="parameter">parametre_stockage</replaceable> [= <replaceable class="parameter">valeur</replaceable>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="parameter">nom_tablespace</replaceable> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE <replaceable class="PARAMETER">nom_table</replaceable>
    OF <replaceable class="PARAMETER">nom_type</replaceable> [ (
  { <replaceable class="PARAMETER">nom_colonne</replaceable> [ WITH OPTIONS ] [ <replaceable class="PARAMETER">contrainte_colonne</replaceable> [ ... ] ]
    | <replaceable>contrainte_table</replaceable> }
    [, ... ]
) ]
[ PARTITION BY { RANGE | LIST | HASH } ( { <replaceable class="parameter">nom_colonne</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ... ] ) ]
[ WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="PARAMETER">nom_tablespace</replaceable> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="PARAMETER">table_name</replaceable>
    PARTITION OF <replaceable class="PARAMETER">parent_table</replaceable> [ (
  { <replaceable class="PARAMETER">nom_colonne</replaceable> [ WITH OPTIONS ] [ <replaceable class="PARAMETER">contrainte_colonne</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable> }
    [, ... ]
) ] { FOR VALUES <replaceable class="parameter">spec_limites_partition</replaceable> | DEFAULT }
[ PARTITION BY { RANGE | LIST } ( { <replaceable class="parameter">nom_colonne</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ... ] ) ]
[ WITH ( <replaceable class="PARAMETER">parametre_stockage</replaceable> [= <replaceable class="PARAMETER">valeur</replaceable>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="PARAMETER">nom_tablespace</replaceable> ]

<phrase>où <replaceable class="parameter">contrainte_colonne</replaceable>
peut être&nbsp;:</phrase>

[ CONSTRAINT <replaceable class="parameter">nom_contrainte</replaceable> ]
{ NOT NULL | NULL |
  CHECK ( <replaceable class="PARAMETER">expression</replaceable> ) [ NO INHERIT ] |
  DEFAULT <replaceable>expression_par_défaut</replaceable> |
  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>options_sequence</replaceable> ) ] |
  UNIQUE <replaceable class="parameter">parametres_index</replaceable> |
  PRIMARY KEY <replaceable class="parameter">parametres_index</replaceable> |
  EXCLUDE [ USING <replaceable class="parameter">methode_index</replaceable> ] ( <replaceable class="parameter">élément_exclude</replaceable> WITH <replaceable class="parameter">opérateur</replaceable> [, ... ] ) <replaceable class="parameter">paramètres_index</replaceable> [ WHERE ( <replaceable class="parameter">prédicat</replaceable> ) ] |
  REFERENCES <replaceable class="parameter">table_reference</replaceable> [ ( <replaceable class="parameter">colonne_reference</replaceable> ) ] [ MATCH FULL
| MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>et <replaceable class="PARAMETER">option_like</replaceable> peut
valoir&nbsp;:</phrase>

{ INCLUDING | EXCLUDING } { COMMENTS | CONSTRAINTS | DEFAULTS | IDENTITY | INDEXES | STATISTICS | STORAGE | ALL }

<phrase>and <replaceable class="PARAMETER">spec_limites_partition</replaceable> is:</phrase>

IN ( { <replaceable class="PARAMETER">littéral_numérique</replaceable> | <replaceable class="PARAMETER">littéral_chaine</replaceable> | TRUE | FALSE | NULL } [, ...] ) |
FROM ( { <replaceable class="PARAMETER">littéral_numérique</replaceable> | <replaceable class="PARAMETER">littéral_chaine</replaceable> | TRUE | FALSE | MINVALUE | MAXVALUE } [, ...] )
  TO ( { <replaceable class="PARAMETER">littéral_numérique</replaceable> | <replaceable class="PARAMETER">littéral_chaine</replaceable> | TRUE | FALSE | MINVALUE | MAXVALUE } [, ...] )
WITH ( MODULUS <replaceable class="parameter">littéral_numérique</replaceable>, REMAINDER <replaceable class="parameter">littéral_numérique</replaceable> )

<phrase>et <replaceable class="parameter">contrainte_table</replaceable>&nbsp;:</phrase>

[ CONSTRAINT <replaceable class="parameter">nom_contrainte</replaceable> ]
{ UNIQUE ( <replaceable class="parameter">nom_colonne</replaceable> [, ... ] ) <replaceable class="parameter">parametres_index</replaceable> |
  PRIMARY KEY ( <replaceable class="parameter">nom_colonne</replaceable> [, ... ] ) <replaceable class="parameter">parametres_index</replaceable> |
  CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  FOREIGN KEY ( <replaceable class="parameter">nom_colonne</replaceable> [, ...
] ) REFERENCES <replaceable class="parameter">table_reference</replaceable> [ (
<replaceable class="parameter">colonne_reference</replaceable> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

Les <replaceable class="parameter">paramètres_index</replaceable> dans les
contraintes <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal> et
<literal>EXCLUDE</literal> sont&nbsp;:

[ INCLUDE ( <replaceable class="parameter">nom_colonne</replaceable> [, ... ] ) ]
[ WITH ( <replaceable class="parameter">paramètre_stockage</replaceable> [= <replaceable class="parameter">valeur</replaceable>] [, ... ] ) ]
[ USING INDEX TABLESPACE <replaceable class="parameter">nom_tablespace</replaceable> ]

<phrase><replaceable class="PARAMETER">exclude_element</replaceable> dans une
contrainte <literal>EXCLUDE</literal> peut valoir&nbsp;:</phrase>

{ <replaceable class="parameter">nom_colonne</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">opclass</replaceable> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]
  </synopsis>

 </refsynopsisdiv>

 <refsect1 id="sql-createtable-description">
  <title>Description</title>

  <para>
   <command>CREATE TABLE</command> crée une nouvelle table initialement vide
   dans la base de données courante. La table appartient à
   l'utilisateur qui exécute cette commande.
  </para>

  <para>
   Si un nom de schéma est donné (par exemple, <literal>CREATE TABLE monschema.matable ...</literal>),
   alors la table est créée dans le schéma spécifié.
   Dans le cas contraire, elle est créée dans le schéma courant. Les tables temporaires existent
   dans un schéma spécial, il n'est donc pas nécessaire de fournir un nom de schéma
   lors de la création d'une table temporaire. Le nom de la table doit être distinct
   du nom des autres tables, séquences, index, vues ou tables distantes dans le même schéma.
  </para>

  <para>
   <command>CREATE TABLE</command> crée aussi automatiquement un type de
   données qui représente le type composé correspondant à une ligne de la
   table. Ainsi, les tables doivent avoir un nom distinct de tout type de
   données du même schéma.
  </para>

  <para>
   Les clauses de contrainte optionnelles précisent les contraintes (ou
   tests) que les nouvelles lignes ou les lignes mises à jour doivent satisfaire
   pour qu'une opération d'insertion ou de mise à jour réussisse. Une contrainte
   est un objet SQL qui aide à définir l'ensemble des valeurs valides de
   différentes façons.
  </para>

  <para>
   Il existe deux façons de définir des contraintes&nbsp;: celles
   de table et celles de colonnes. Une contrainte de colonne fait partie
   de la définition de la colonne. Une définition de contrainte
   de tables n'est pas liée à une colonne particulière et peut englober plusieurs
   colonnes. Chaque contrainte de colonne peut être écrite comme une
   contrainte de table&nbsp;; une contrainte de colonne n'est qu'un outil
   de notation utilisé lorsque la contrainte n'affecte qu'une colonne.
  </para>

  <para>
   Pour pouvoir créer une table, vous devez avoir le droit
   <literal>USAGE</literal> sur les types de chaque colonne ou sur le type
   indiqué dans la clause <literal>OF</literal>.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>

   <varlistentry id="sql-createtable-temporary">
    <term><literal>TEMPORARY</literal> ou <literal>TEMP</literal></term>
    <listitem>
     <para>
      La table est temporaire. Les tables
      temporaires sont automatiquement supprimées à la fin d'une session ou,
      optionnellement, à la fin de la transaction en cours (voir <command>ON COMMIT</command>
      ci-dessous). Les tables permanentes qui portent le même nom ne sont
      pas visibles dans la session courante tant que la table temporaire existe
      sauf s'il y est fait référence par leur nom qualifié du schéma. Tous les
      index créés sur une table temporaire sont automatiquement temporaires.
     </para>

     <para>
      Le <link linkend="autovacuum">démon autovacuum</link> ne peut pas
      accéder et, du coup, ne peut pas exécuter un VACUUM ou un ANALYZE sur
      les tables temporaires. Pour cette raison, les opérations VACUUM et
      ANALYZE doivent être traitées via des commandes SQL de session. Par
      exemple, si une table temporaire doit être utilisée dans des requêtes
      complexes, il est raisonnable d'exécuter <command>ANALYZE</command> sur
      la table temporaire après qu'elle ait été peuplée.
     </para>

     <para>
      On peut éventuellement écrire <literal>GLOBAL</literal> ou <literal>LOCAL</literal>
      avant <literal>TEMPORARY</literal> ou <literal>TEMP</literal>. Cela
      ne fait pas de différence dans <productname>PostgreSQL</productname> (cf.
      Cela ne fait actuellement pas de différence dans <productname>PostgreSQL</productname>
      et est obsolète&nbsp;; voir <xref linkend="sql-createtable-compatibility"/>).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-createtable-unlogged">
    <term><literal>UNLOGGED</literal></term>
    <listitem>
     <para>
      Si spécifié, la table est créée en tant que table non tracée. Les données
      écrites dans ce type de table ne sont pas écrites dans les journaux de
      transactions (voir <xref linkend="wal"/>), ce qui les rend
      considérablement plus rapides que les tables ordinaires. Néanmoins,
      elles ne sont pas sûres en cas d'arrêt brutal&nbsp;: une table non tracée
      est automatiquement vidée après un arrêt brutal. Le contenu d'une table
      non tracée n'est pas répliqué vers les serveurs en attente. Tout index
      créé sur une table non tracée est aussi automatiquement non tracé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>IF NOT EXISTS</literal></term>
    <listitem>
     <para>
      N'affiche pas d'erreur si une relation de même nom existe déjà. Un
      message de niveau notice est retourné dans ce cas. Notez qu'il n'existe
      aucune garantie que la relation existante ressemble à celle qui devait
      être créée..
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_table</replaceable></term>
    <listitem>
     <para>
      Le nom (éventuellement qualifié du nom du schéma) de la table à créer.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OF <replaceable class="PARAMETER">nom_type</replaceable></literal></term>
    <listitem>
     <para>
      Crée une <firstterm>table typée</firstterm>, qui prend sa structure à
      partir du type composite spécifié (son nom peut être qualifié du schéma).
      Une table typée est liée à son type&nbsp;; par exemple, la table sera
      supprimée si le type est supprimé (avec <literal>DROP TYPE ...
       CASCADE</literal>).
     </para>

     <para>
      Quand une table typée est créée, les types de données des colonnes sont
      déterminés par le type composite sous-jacent et ne sont pas indiqués
      par la commande <literal>CREATE TABLE</literal>. Mais la commande
      <literal>CREATE TABLE</literal> peut ajouter des valeurs par défaut et
      des contraintes à la table. Elle peut aussi indiquer des paramètres de
      stockage.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_colonne</replaceable></term>
    <listitem>
     <para>
      Le nom d'une colonne de la nouvelle table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_données</replaceable></term>
    <listitem>
     <para>
      Le type de données de la colonne. Cela peut inclure des spécificateurs
      de tableaux. Pour plus d'informations sur les types de données supportés
      par <productname>PostgreSQL</productname>, on se référera à <xref
      linkend="datatype"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>COLLATE <replaceable>collation</replaceable></literal></term>
    <listitem>
     <para>
      La clause <literal>COLLATE</literal> affecte un collationnement à une
      colonne (qui doit être d'un type de données collationnable). Sans
      information, le collationnement par défaut du type de données de la
      colonne est utilisé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INHERITS ( <replaceable>table_parent</replaceable> [, ... ])</literal></term>
    <listitem>
     <para>
      La clause optionnelle <literal>INHERITS</literal> indique une liste de
      tables dont les colonnes sont automatiquement héritées par la nouvelle
      table. Les tables parents peuvent être des tables standards ou des
      tables distantes.
     </para>

     <para>
      L'utilisation d'<literal>INHERITS</literal> crée une relation
      persistante entre la nouvelle table enfant et sa table parent. Les
      modifications de schéma du(des) parent(s) se propagent normalement aux
      enfants et, par défaut, les données de la table enfant sont incluses
      dans les parcours de(s) parent(s).
     </para>

     <para>
      Si un même nom de colonne existe dans plusieurs tables parentes, une
      erreur est rapportée, à moins que les types de données des colonnes ne
      correspondent dans toutes les tables parentes. S'il n'y a pas de
      conflit, alors les colonnes dupliquées sont assemblées pour former une
      seule colonne dans la nouvelle table. Si la liste des noms de colonnes
      de la nouvelle table contient un nom de colonne hérité, le type de
      données doit correspondre à celui des colonnes héritées et les
      définitions des colonnes sont fusionnées. Si la nouvelle table spécifie
      explicitement une valeur par défaut pour la colonne, cette valeur
      surcharge toute valeur par défaut héritée. Dans le cas contraire, les
      parents qui spécifient une valeur par défaut doivent tous spécifier la
      même, sans quoi une erreur est rapportée.
     </para>

     <para>
      Les contraintes <literal>CHECK</literal> sont fusionnées, dans les
      grandes lignes, de la même façon que les colonnes&nbsp;: si des tables
      parentes multiples et/ou la nouvelle définition de table contient des
      contraintes <literal>CHECK</literal> de même nom, ces contraintes
      doivent toutes avoir la même expression de vérification, ou une erreur
      sera retournée. Les contraintes qui ont le même nom et la même
      expression seront fusionnées en une seule. Une contrainte marquée
      <literal>NO INHERIT</literal> dans une table parent ne sera pas prise en
      compte. Notez qu'une contrainte <literal>CHECK</literal> non nommée dans
      la nouvelle table ne sera jamais fusionnée puisqu'un nom unique lui sera
      toujours affecté.
     </para>

     <para>
      Les paramètres <literal>STORAGE</literal> de la colonne sont aussi
      copiés des tables parents.
     </para>

     <para>
      Si une colonne de la table parente est une colonne d'identité, cette
      propriété n'est pas héritée.  Une colone dans la table enfant peut être
      déclarée comme colonne d'identité si l'on veut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>PARTITION BY { RANGE | LIST | HASH } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">opclass</replaceable> ] [, ...] ) </literal></term>
    <listitem>
     <para>
      La clause facultative <literal>PARTITION BY</literal> spécifie une
      statégie pour partitionner la table.  La table ainsi crée est appelée
      table <firstterm>partitionnée</firstterm>.  La liste de colonnes ou
      d'expressions entre parenthèses forme la <firstterm>clé de
      partitionnement</firstterm> de la table.  Quand un partitionnement par
      intervalle ou hachage est utilisé, la clé de partitionnement peut
      inclure de multiples colonnes ou expressions (jusqu'à 32, mais cette
      limite peut être modifiée lors de la compilation de
      <productname>PostgreSQL</productname>.), mais pour le partitionnement
      par liste, la clé de partitionnement doit être constituée d'une seule
      colonne ou expression.
     </para>

     <para>
	  Les partitionnements par intervalle ou par liste nécessitent une
	  classe d'opérateur btree, alors que le partitionnement par hachage
	  exige une classe d'opérateur hash. Si aucune classe d'opérateur n'est
	  précisée explicitement, la classe d'opérateur par défaut du type
	  approprié sera utilisée&nbsp;; si aucune classe d'opérateur n'existe,
	  une erreur sera levée. Si le partitionnement par hachage est utilisé,
	  la classe d'opérateur utilisée doit implémenter la fonction
	  de support 2 (voir <xref linkend="xindex-support"/> pour les détails).
     </para>

     <para>
      Une table partitionnée est divisée en sous tables (appelées partitions),
      qui sont créées en utilisant des commandes <literal>CREATE
      TABLE</literal> séparées.  La table partitionnée est elle-même vide.
      Une ligne de données insérée dans la table est redirigée vers une
      partition en fonction de la valeur des colonnes ou expressions de la clé
      de partitionnement.  S'il n'existe pas de partition correspondant aux
      valeurs de la nouvelle ligne, une erreur sera levée.
     </para>

     <para>
	  Les tables partitionnées ne supportent pas les contraintes
	  <literal>EXCLUDE</literal>&nbsp;; cependant vous pouvez définir ces
	  contraintes sur des partitions individuelles. De plus, bien qu'il soit
	  possible de créer des contraintes <literal>PRIMARY KEY</literal>
	  sur les tables partitionnées, créer des clés étrangères qui
	  référencent une table partitionnée n'est pas encore supporté.
     </para>

     <para>
      Voir <xref linkend="ddl-partitioning"/> pour plus de détails sur le
	  partitionnement des tables.
     </para>

    </listitem>
   </varlistentry>

   <varlistentry id="sql-createtable-partition">
    <term><literal>PARTITION OF <replaceable class="parameter">table_parent</replaceable> { FOR VALUES <replaceable class="parameter">spec_limites_partition</replaceable> | DEFAULT }</literal></term>
    <listitem>
     <para>
      Crée la table comme une <firstterm>partition</firstterm> de la table
      parente spécifiée. La table peut être créée, soit comme une partition
      pour des valeurs spécifiques avec <literal>FOR VALUES</literal>, soit
      comme la partition par défaut avec <literal>DEFAULT</literal>. Tout
      index, toute constrainte et tout trigger de niveau ligne défini par
      l'utilisateur existant dans la table parent est clonée sur la nouvelle
      partition.
     </para>

     <para>
      Le paramètre <replaceable
      class="PARAMETER">spec_limites_partition</replaceable> doit correspondre
      à la méthode et à la clé de partitionnement de la table parent, et ne
      doit pas déborder sur toute partition existante du parent. La forme avec
      <literal>IN</literal> est utilisée pour le partitionnement de liste,
      la forme avec <literal>FROM</literal> et <literal>TO</literal> est
      utilisée pour le partitionnement par intervalles, et la forme avec
      <literal>WITH</literal> est utilisée pour le partitionnement par hachage.
     </para>

     <para>
      Chacune des valeurs spécifiées dans <replaceable
      class="PARAMETER">spec_limites_partition</replaceable> de la partition
      est un libellé, <literal>NULL</literal>, <literal>MINVALUE</literal> ou
      <literal>MAXVALUE</literal>. Chaque valeur littérale doit être soit une
      constante numérique convertible dans le type de la colonne de la clé de
      partitionnement correspondante, ou une chaîne littérale considérée comme
      une valeur valide pour ce type.
     </para>

     <para>
      Lors de la création d'une partition en liste, <literal>NULL</literal>
      peut être indiquer pour signifier que la partition permet à la colonne
      de clé de partitionnement d'être NULL. Néanmoins, il ne peut y avoir
      plus d'une partition de ce type pour une table parent donnée.
      <literal>NULL</literal> n'est pas accepté pour les partitions par
      intervalle.
     </para>

     <para>
      Lorsqu'une partition de type intervalle est créée, la borne inférieure
      spécifiée avec <literal>FROM</literal> est une borne inclusive, alors
      que la borne supérieure spécifiée avec <literal>TO</literal> est une
      borne exclusive.  C'est-à-dire que les valeurs spécifiées dans la liste
      <literal>FROM</literal> sont des valeurs valides des colonnes
      correspondantes de la clé de partitionnement pour cette partition, alors
      que celles dans la liste <literal>TO</literal> ne le sont pas. Notez que
      ceci doit être compris suivant les règles de la comparaison de lignes
      (<xref linkend="row-wise-comparison"/>). Par exemple, étant donné
      <literal>PARTITION BY RANGE (x,y)</literal>, une limite de partition
      <literal>FROM (1, 2) TO (3, 4)</literal> permet <literal>x=1</literal>
      pour tout <literal>y&gt;=2</literal>, <literal>x=2</literal> avec tout
      <literal>y</literal> non NULL, et <literal>x=3</literal> avec tout
      <literal>y&lt;4</literal>.
     </para>

     <para>
      Les valeurs spéciales <literal>MINVALUE</literal> et
      <literal>MAXVALUE</literal> peuvent être utilisées lors de la création
      d'une partition par intervalles pour indiquer qu'il n'y a pas de limite
      basse ou haute sur la valeur de la colonne. Par exemple, une partition
      définie comme utilisant <literal>FROM (MINVALUE) TO (10)</literal>
      accepte toutes les valeurs inférieures à 10, et une partition définie en
      utilisant <literal>FROM (10) TO (MAXVALUE)</literal> accepte toutes les
      valeurs supérieures ou égales à 10.
     </para>

     <para>
      Lors de la création d'une partition par intervalles impliquant plus d'une
      colonne, il est aussi sensé d'utiliser <literal>MAXVALUE</literal> comme
      élément de la limite basse et <literal>MINVALUE</literal> comme élément
      de limite haute. Par exemple, une partition définie en utilisant
      <literal>FROM (0, MAXVALUE) TO (10, MAXVALUE)</literal> accepte toute
      ligne où la première colonne de la clé de partitionnement est supérieure
      à zéro et inférieure ou égale à dix. De la même façon, une partition
      définie en utilisant <literal>FROM ('a', MINVALUE) TO ('b',
      MINVALUE)</literal> accepte toute ligne où la première colonne de la clé
      de partitionnement commence avec la lettre a.
     </para>

     <para>
      Notez que si <literal>MINVALUE</literal> ou <literal>MAXVALUE</literal>
      est utilisé pour une colonne d'une limite de partitionnement, la même
      valeur doit être utilisée pour toutes les colonnes suivantes. Par
      exemple, <literal>(10, MINVALUE, 0)</literal> n'est pas une limite
      valide. Vous devriez écrire <literal>(10, MINVALUE, MINVALUE)</literal>.
     </para>

     <para>
      De plus, notez que certains types d'éléments, tels que
      <literal>timestamp</literal>, ont une notion d'infinité, qui est
      simplement une autre valeur qui peut être enregistré. Ceci est différent
      de <literal>MINVALUE</literal> et <literal>MAXVALUE</literal>, qui ne
      sont pas de vraies valeurs pouvant être enregistrées, mais plutôt une
      façon de dire que la valeur est sans limite. <literal>MAXVALUE</literal>
      peut être vu comme étant supérieur à toute autre valeur, ceci includant
      infinity et <literal>MINVALUE</literal> comme étant inférieure à toute
      autre valeur, ceci incluant moins infinity. De ce fait, l'intervalle
      <literal>FROM ('infinity') TO (MAXVALUE)</literal> n'est pas un
      intervalle vide. Il autorise le stockage d'une seule valeur &mdash;
      "infinity".
     </para>

     <para>
      Quand une partition par liste de valeurs est créée,
      <literal>NULL</literal> peut être spécifié pour dire que la partition
      autorise la colonne de la clé de partitionnement à être NULL.  Cepdnant,
      il ne peut pas y avoir plus d'une partition par liste de ce type pour une
      même table parente.  <literal>NULL</literal> ne peut pas être utilisé
      pour les partitions par intervalles.
     </para>

     <para>
      Si <literal>DEFAULT</literal> est spécifié, la table sera créée comme
	  partition par défaut de la table parente. Cette option n'est pas disponible
    pour les tables partitionnées par hachage. Une clé de partition qui ne
	  passe dans aucune autre partition de la table parente sera orientée
	  vers la partition par défaut.
     </para>

     <para>
      Si une table possède une partition <literal>DEFAULT</literal> et qu'on
	  lui ajoute une nouvelle partition, la partition par défaut
	  doit être parcourue pour vérifier qu'elle ne contient aucune ligne
	  qui appartient normalement à la nouvelle partition. Si la partition par
	  défaut contient un grand nombre de lignes, cela peut être long. Ce
	  parcours peut être évité si la partition par défaut est une table
	  étrangère ou possède une contrainte prouvant qu'elle ne peut contenir
	  des lignes qui devraient appartenir à la nouvelle partition.
     </para>

     <para>
	  À la création d'une partition par hachage, un diviseur et un reste doivent
	  être spécifiés.
	  Le diviseur doit être un entier positif, et le reste un entier non
	  négatif inférieur au diviseur. Typiquement, au début de la mise en place
	  d'un partitionnement par hachage, vous devrez choisir un diviseur égal au
	  nombre de partitions et assigner à chaque table le même diviseur et un reste
	  différent (voir les exemples plus bas).
	  Cependant, il n'est pas obligatoire que chaque partition ait le même
	  diviseur, juste que chaque diviseur apparaissant dans une table
	  partitionnée par hachage soit un facteur du diviseur immédiatement
	  supérieur. Cela permet d'augmenter le nombre de partitions de manière
	  incrémentale sans avoir besoin de déplacer toutes les données d'un coup.
	  Par exemple, supposons que vous ayez une table partitionnée par hachage
	  avec 8 partitions, toutes de diviseur 8, mais que vous trouvez qu'il faille
	  augmenter le nombre de partitions à 16. Vous pouvez détacher une des
	  partitions de diviseur 8, créer deux nouvelles partitions de diviseur 16
	  couvrant la même partie de l'espace des clés (une avec un reste égal
	  au reste de la partition détachée, l'autre avec un reste de cette valeur
	  plus 8), et les peupler avec les données. Vous pouvez répéter ceci &mdash;
	  peut-être plus tard &mdash; pour chaque partition de diviseur 8 jusqu'à ce
	  qu'il n'y en ait plus. Bien que cela implique de grands mouvements de
	  données à chaque étape, c'est toujours mieux qu'avoir à créer toute une
	  nouvelle table et d'avoir à déplacer toutes les données en une seule fois.
     </para>

     <para>
      Une partition doit avoir les même noms de colonne et types de données
      que la table partitionnée à laquelle elle appartient.  Si le parent est
      spécifié <literal>WITH OIDS</literal> alors toutes les partitions
      doivent avoir des OIDs; la colonne OID parente sera héritée par touts
      les partitions tout comme n'importe quelle autre colonne.  Les
      modifications des noms ou types de colonne d'une table partitionnée, ou
      l'ajout ou suppression d'une colonne OID, se propagera automatiquement à
      toutes les partitions.  Les contraintes <literal>CHECK</literal> seront
      automatiquement héritées par toutes les partitions, mais une partition
      individuelle peut spécifier des contraintes <literal>CHECK</literal>
      additionnelles&nbsp;; les contraintes individuelles avec le même nom et
      la même condition que pour la table parente seront intégrées avec la
      contrainte parente.  Les valeurs par défaut peuvent être spécifiées
      séparément pour chaque partition. Notez que la valeur par défaut d'une
      partition ne s'applique pas quand l'insertion de la ligne se fait via la
      table partitionnée.
     </para>

     <para>
      Les lignes insérées dans une table partitionnées seront automatiquement
      redirigées vers la bonne partition.  Si aucune des partitions existantes
      ne convient, une erreur sera levée.
     </para>

     <para>
      Les opérations telles que TRUNCATE qui n'affectent normalement une table
      ainsi que tous ses enfants hérités seront cascadées sur toutes les
      partitions, mais peuvent aussi être effectuées sur une partition
      individuelle.  Veuillez noter que supprimer une partition avec
      <literal>DROP TABLE</literal> nécessite de prendre un verrou de type
      <literal>ACCESS EXCLUSIVE</literal> sur la table parente.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>LIKE <replaceable>table_source</replaceable> [ <replaceable>option_like</replaceable> ... ]</literal></term>
    <listitem>
     <para>
      La clause <literal>LIKE</literal> spécifie une table à partir de laquelle
      la nouvelle table copie automatiquement tous les noms de colonnes, leur
      types de données et les contraintes non NULL.
     </para>
     <para>
      Contrairement à <literal>INHERITS</literal>, la nouvelle table et la
      table originale sont complètement découplées à la fin de la création.
      Les modifications sur la table originale ne sont pas appliquées à la
      nouvelle table et les données de la
      nouvelle table sont pas prises en compte lors du parcours de l'ancienne table.
     </para>
     <para>
      Les expressions par défaut des définitions de colonnes ne seront copiées
      que si <literal>INCLUDING DEFAULTS</literal> est spécifié. Le
      comportement par défaut les exclut, ce qui conduit à des valeurs par
      défaut NULL pour les colonnes copiées de la nouvelle table. Notez que
      copier les valeurs par défaut appelant des fonctions de modification de
      la base de données, comme <function>nextval</function>, pourraient créer
      un lien fonctionnel entre les tables originale et nouvelle.
     </para>
     <para>
      Toutes les spécifications d'identité de définitions de colonne copiée ne
      seront copiées que si <literal>INCLUDING IDENTITY</literal> est spécifié.
      Une nouvelle séquence est crée pour chaque colonne d'identité de la
      nouvelle table, séparément des colonnes associées à l'ancienne table.
     </para>
     <para>
      Les contraintes NOT NULL sont toujours copiées sur la nouvelle table.
      Les contraintes <literal>CHECK</literal> sont copiées seulement si la
      clause <literal>INCLUDING CONSTRAINTS</literal> est précisée. Aucune
      distinction n'est faite entre les contraintes au niveau colonne et les
      contraintes au niveau table.
     </para>
     <para>
      Les statistiques étendues sont copiées sur la nouvelle table si
      <literal>INCLUDING STATISTICS</literal> est indiqué.
     </para>
     <para>
      Les index, les contraintes <literal>PRIMARY KEY</literal>,
      <literal>UNIQUE</literal> et <literal>EXCLUDE</literal> sur la table
      originale seront créés sur la nouvelle table seulement si la clause
      <literal>INCLUDING INDEXES</literal> est spécifiée. Les noms des
      nouveaux index et des nouvelles contraintes sont choisis suivant les
      règles par défaut, quelque soit la façon dont les originaux étaient
      appelés. (Ce comportement évite les potentiels échecs de nom dupliqué
      pour les nouveaux index.)
     </para>
     <para>
      Des paramètres <literal>STORAGE</literal> pour les définitions de la
      colonne copiée seront seulement copiés si <literal>INCLUDING
       STORAGE</literal> est spécifié. Le comportement par défaut est d'exclure
      des paramètres <literal>STORAGE</literal>, résultant dans les colonnes
      copiées dans la nouvelle table ayant des paramètres par défaut
      spécifiques par type. Pour plus d'informations sur
      <literal>STORAGE</literal>, voir <xref linkend="storage-toast"/>.
     </para>
     <para>
      Les commentaires pour les colonnes, contraintes et index copiés seront
      seulement copiés si <literal>INCLUDING COMMENTS</literal> est spécifié.
      Le comportement par défaut est d'exclure les commentaires, ce qui
      résulte dans des colonnes et contraintes copiées dans la nouvelle table
      mais sans commentaire.
     </para>
     <para>
      <literal>INCLUDING ALL</literal> est une forme abrégée de
      <literal>INCLUDING COMMENTS INCLUDING CONSTRAINTS INCLUDING DEFAULTS INCLUDING IDENTITY INCLUDING INDEXES INCLUDING STATISTICS INCLUDING STORAGE</literal>.
     </para>
     <para>
      Contrairement à <literal>INHERITS</literal>, les
      colonnes et les contraintes copiées par <literal>LIKE</literal> ne sont
      pas assemblées avec des colonnes et des contraintes nommées de façon
      similaire. Si le même nom est indiqué explicitement ou dans une autre
      clause <literal>LIKE</literal>, une erreur est rapportée.
     </para>
     <para>
      La clause <literal>LIKE</literal> peut aussi être utilisée pour copier les
      définitions de colonne des vues, tables distantes et types composites. Les options
      inapplicables (comme <literal>INCLUDING INDEXES</literal> à partir d'une vue)
      sont ignorées.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CONSTRAINT <replaceable class="parameter">nom_contrainte</replaceable></literal></term>
    <listitem>
     <para>
      Le nom optionnel d'une contrainte de colonne ou de table. Si la contrainte
      est violée, le nom de la contrainte est présente dans les messages d'erreur.
      Donc les noms de contraintes comme <literal>col doit être positive</literal>
      peut être utilisés pour communiquer des informations utiles aux applications
      clients. (Des doubles guillemets sont nécessaires pour indiquer les noms des
      contraintes qui contiennent des espaces.) Si un nom de contrainte n'est pas
      donné, le système en crée un.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NOT NULL</literal></term>
    <listitem>
     <para>
      Interdiction des valeurs NULL dans la colonne.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NULL</literal></term>
    <listitem>
     <para>
      Les valeurs NULL sont autorisées pour la colonne. Comportement par défaut.
     </para>

     <para>
      Cette clause n'est fournie que pour des raisons de compatibilité avec les
      bases de données SQL non standard. Son utilisation n'est pas encouragée
      dans les nouvelles applications.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ]</literal></term>
    <listitem>
     <para>
      La clause <literal>CHECK</literal> spécifie une expression de
      résultat booléen que les nouvelles lignes ou celles mises à jour
      doivent satisfaire pour qu'une opération d'insertion ou de mise à jour
      réussisse. Les expressions de résultat TRUE ou UNKNOWN réussissent.
      Si une des lignes de l'opération d'insertion ou de mise à jour produit un résultat
      FALSE, une exception est levée et la base de données n'est pas modifiée.
      Une contrainte de vérification sur une colonne ne fait référence qu'à la valeur de la colonne
      tandis qu'une contrainte sur la table fait référence à plusieurs colonnes.
     </para>

     <para>
      Actuellement, les expressions <literal>CHECK</literal> ne peuvent ni
      contenir des sous-requêtes ni faire référence à des variables autres que
      les colonnes de la ligne courante (voir <xref
      linkend="ddl-constraints-check-constraints"/>). La colonne système
      <literal>tableoid</literal> peut être référencé contrairement aux autres
      colonnes systèmes.
     </para>

     <para>
      Une contrainte marquée <literal>NO INHERIT</literal> ne sera pas propagée
      aux tables filles.
     </para>

     <para>
      Quand une table a plusieurs contraintes <literal>CHECK</literal>, elles
      seront testées pour chaque ligne dans l'ordre alphabétique de leur nom,
      après la vérification des contraintes <literal>NOT NULL</literal>. (Les
      versions de <productname>PostgreSQL</productname> antérieures à la 9.5
      ne respectaient pas d'ordre de déclenchement particulier pour les
      contraintes <literal>CHECK</literal>.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT
      <replaceable>expression_par_défaut</replaceable></literal></term>
    <listitem>
     <para>
      La clause <literal>DEFAULT</literal>, apparaissant dans la définition
      d'une colonne, permet de lui affecter une valeur par défaut. La valeur est une
      expression libre de variable (les sous-requêtes et références croisées aux
      autres colonnes de la table courante ne sont pas autorisées). Le type de
      données de l'expression par défaut doit correspondre au type de données de
      la colonne.
     </para>

     <para>
      L'expression par défaut est utilisée dans les opérations d'insertion
      qui ne spécifient pas de valeur pour la colonne. S'il n'y a pas de valeur
      par défaut pour une colonne, elle est NULL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>options_sequence</replaceable> ) ]</literal></term>
    <listitem>
     <para>
      Cette clause crée la colonne comme une <firstterm>colonne
      d'identité</firstterm>.  Elle aura une séquence implicite attachée à elle
      et la colonne dans les nouvelles lignes auront automatiquement des
      valeurs récupérées de la séquence qui lui est assignée.
     </para>

     <para>
      Les clauses <literal>ALWAYS</literal> et <literal>BY DEFAULT</literal>
      déterminent comment la valeur de la séquence est prioritaire par rapport
      à une valeur définie par l'utilisateur dans un ordre
      <command>INSERT</command>.  Si <literal>ALWAYS</literal> est spécifié,
      une valeur définie par l'utilisateur ne sera acceptée que si l'ordre
      <command>INSERT</command> spécifie <literal>OVERRIDING SYSTEM
      VALUE</literal>.  Si <literal>BY DEFAULT</literal> est spécifié, alors la
      valeur spécifiée par l'utilisateur est prioritaire.  Voir <xref
      linkend="sql-insert"/> pour plus de détails.  (Avec une commande
      <command>COPY</command>, les valeurs spécifiées par l'utilisateur sont
      toujours utilisée quelque soit ce paramètre.)
     </para>

     <para>
      La clause facultative <replaceable>options_sequence</replaceable> peut
      être utilisée pour surcharger les options d'une séquence.  Voir <xref
      linkend="sql-createsequence"/> pour plus de détails.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>UNIQUE</literal> (contrainte de colonne)</term>
    <term><literal>UNIQUE ( <replaceable class="PARAMETER">nom_colonne</replaceable> [, ... ] )</literal>
    <optional> INCLUDE ( <replaceable class="parameter">nom_colonne</replaceable> [, ...]) </optional> (contrainte de table)</term>

    <listitem>
     <para>
      La contrainte <literal>UNIQUE</literal> indique qu'un groupe d'une ou
      plusieurs colonnes d'une table ne peut contenir que des valeurs
      uniques. Le comportement de la contrainte de table unique est le même
      que celui des contraintes de colonnes avec la capacité supplémentaire
      de traiter plusieurs colonnes.
     </para>

     <para>
      Pour une contrainte unique, les valeurs NULL ne sont pas considérées
      comme égales.
     </para>

     <para>
      Chaque contrainte unique de table doit nommer un ensemble de colonnes
      qui est différent de l'ensemble de colonnes nommées par toute autre
      contrainte unique ou de clé primaire définie pour la table. (Sinon
      elle ne ferait que lister la même contrainte deux fois.)
     </para>

     <para>
	  Lors de la mise en place d'une contrainte unique sur une hiérarchie
	  de partitions à plusieurs niveaux, toutes les colonnes de la clé de
	  partitionnement de la table partitionnée cible, ainsi que celles des
	  tables partitionnées filles, doivent être incluses dans la définition
	  de la contrainte.
     </para>

     <para>
	  Ajouter une contrainte unique va automatiquement créer un index btree unique
	  sur la colonne ou le groupe de colonnes utilisée(s) dans la contrainte.
	  La clause optionnelle <literal>INCLUDE</literal> ajoute à cet index une
	  ou plusieurs colonnes, qui ne sont pas concernée par l'unicité.
	  Notez cependant que si la contrainte n'est pas appliquée sur ces colonnes
	  incluses, elle en dépend tout de même. En conséquence, certaines opérations
	  sur ces colonnes (par exemple <literal>DROP COLUMN</literal>) peuvent causer
	  une suppression en cascade de la contrainte et de l'index.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>PRIMARY KEY</literal> (contrainte de colonne)</term>
    <term><literal>PRIMARY KEY ( <replaceable class="PARAMETER">nom_colonne</replaceable> [, ... ] )</literal>
    <optional> INCLUDE ( <replaceable class="parameter">nom_colonne</replaceable> [, ...]) </optional> (contrainte de table)</term>
    <listitem>
     <para>
      La contrainte <literal>PRIMARY KEY</literal> indique qu'une ou plusieurs
      colonnes d'une table peuvent uniquement contenir des valeurs uniques
      (pas de valeurs dupliquées) et non NULL. Une table ne peut avoir qu'une
      seule clé primaire, que ce soit une contrainte au niveau de la colonne
      ou au niveau de la table.
     </para>

     <para>
      La contrainte clé primaire doit nommer un ensemble de colonnes différent
      de l'ensemble de colonnes nommé par toute contrainte unique définie sur
      la même table. (Sinon, la contrainte unique est redondante et sera
      ignorée.)
     </para>

     <para>
      <literal>PRIMARY KEY</literal> force les mêmes contraintes sur les
      données que la combinaison <literal>UNIQUE</literal> et <literal>NOT
      NULL</literal> mais identifier un ensemble de colonnes comme une clé
      primaire fournit aussi des métadonnées sur la conception du schéma car
      une clé primaire implique que les autres tables peuvent s'appuyer sur
      cet ensemble de colonnes comme un identifiant unique des lignes de la
      table.
     </para>

     <para>
      Les contraintes <literal>PRIMARY KEY</literal> partagent les restrictions
      des contraintes <literal>UNIQUE</literal> placées sur des tables
	  partitionnées.
      tables.
     </para>

     <para>
      Ajouter une contrainte <literal>PRIMARY KEY</literal> va automatiquement
	  créer un index btree unique sur la colonne ou le groupe de colonnes
	  utilisée(s) dans la contrainte. La clause optionnelle
	  <literal>INCLUDE</literal> permet de spécifier une liste de colonnes qui
	  seront incluses dans l'index, hors des clés. Bien que l'unicité ne soit
	  pas appliquée sur ces colonnes, la contrainte en dépend. En
	  conséquence, certaines opérations sur les colonnes incluses (par exemple
	  <literal>DROP COLUMN</literal>) peuvent causer par cascade la suppression
	  de contraintes et d'index.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-createtable-exclude">
    <term><literal>EXCLUDE [ USING <replaceable class="parameter">méthode_index</replaceable> ] ( <replaceable class="parameter">élément_exclusion</replaceable> WITH <replaceable class="parameter">opérateur</replaceable> [, ... ] ) <replaceable class="parameter">paramètres_index</replaceable> [ WHERE ( <replaceable class="parameter">prédicat</replaceable> ) ]</literal></term>
    <listitem>
     <para>
      La clause <literal>EXCLUDE</literal> définit une contrainte d'exclusion
      qui garantit que si deux lignes sont comparées sur la ou les colonnes
      spécifiées ou des expressions utilisant le ou les opérateurs spécifiés,
      seulement certaines de ces comparaisons, mais pas toutes, renverront
      <literal>TRUE</literal>. Si tous les opérateurs spécifiés testent une
      égalité, ceci est équivalent à une contrainte <literal>UNIQUE</literal>
      bien qu'une contrainte unique ordinaire sera plus rapide. Néanmoins, ces
      contraintes d'exclusion peuvent spécifier des contraintes qui sont plus
      générales qu'une simple égalité. Par exemple, vous pouvez spécifier
      qu'il n'y a pas deux lignes dans la table contenant des cercles de
      surcharge (voir <xref linkend="datatype-geometric"/>) en utilisant
      l'opérateur <literal>&amp;&amp;</literal>.
     </para>

     <para>
      Des contraintes d'exclusion sont implantées en utilisant un index,
      donc chaque opérateur précisé doit être associé avec une classe
      d'opérateurs appropriée (voir <xref linkend="indexes-opclass"/>) pour la
      méthode d'accès par index, nommée <replaceable>méthode_index</replaceable>.
      Les opérateurs doivent être commutatifs. Chaque <replaceable
      class="parameter">élément_exclusion</replaceable> peut spécifier en
      option une classe d'opérateur et/ou des options de tri&nbsp;; ils sont
      décrits complètement sous <xref linkend="sql-createindex"/>.
     </para>

     <para>
      La méthode d'accès doit supporter <literal>amgettuple</literal> (voir
      <xref linkend="indexam"/>)&nbsp;; dès à présent, cela signifie que
      <acronym>GIN</acronym> ne peut pas être utilisé. Bien que cela soit
      autorisé, il existe peu de raison pour utiliser des index B-tree ou hash
      avec une contrainte d'exclusion parce que cela ne fait rien de mieux que
      ce que peut faire une contrainte unique ordinaire. Donc, en pratique,
      la méthode d'accès sera toujours <acronym>GiST</acronym> ou
      <acronym>SP-GiST</acronym>.
     </para>

     <para>
      Le <replaceable class="parameter">prédicat</replaceable> vous permet de
      spécifier une contrainte d'exclusion sur un sous-ensemble de la
      table&nbsp;; en interne, un index partiel est créé. Notez que ces
      parenthèses sont requis autour du prédicat.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>REFERENCES <replaceable class="parameter">table_reference</replaceable> [ ( <replaceable class="parameter">colonne_reference</replaceable> ) ]
      [ MATCH <replaceable class="parameter">matchtype</replaceable> ]
      [ ON DELETE <replaceable class="parameter">action</replaceable> ]
      [ ON UPDATE <replaceable class="parameter">action</replaceable> ]</literal> (contrainte de colonne)</term>

    <term><literal>FOREIGN KEY ( <replaceable
      class="parameter">nom_colonne</replaceable> [, ... ] )
      REFERENCES <replaceable class="parameter">table_reference</replaceable> [ (
      <replaceable class="parameter">colonne_reference</replaceable> [, ... ] ) ]
      [ MATCH <replaceable class="parameter">matchtype</replaceable> ]
      [ ON DELETE <replaceable class="parameter">action</replaceable> ]
      [ ON UPDATE <replaceable class="parameter">action</replaceable> ]</literal>
     (contrainte de colonne)</term>

    <listitem>
     <para>
      Ces clauses spécifient une contrainte de clé étrangère. Cela signifie
      qu'un groupe de colonnes de la nouvelle table ne peut contenir que des
      valeurs correspondant à celles des colonnes de référence de la table de
      référence. Si la liste <replaceable
      class="parameter">colonne_reference</replaceable> est omise, la clé
      primaire de la <replaceable
      class="parameter">table_reference</replaceable> est utilisée. Les
      colonnes référencées doivent être celles d'une contrainte d'unicité ou
      de clé primaire, non déferrable, dans la table référencée.
      L'utilisateur doit avoir la permission <literal>REFERENCES</literal> sur
      la table référencée (soit toute la table, ou la colonne référencée
      spécifiquement). L'ajout d'une contrainte de type clé étrangère requiert
      un verrou <literal>SHARE ROW EXCLUSIVE</literal> sur la table
      référencée. Les contraintes de type clé étrangère ne peuvent pas être
      définies entre des tables temporaires et des tables permanentes. Notez
      aussi que bien qu'il soit possible de définir une clé étrangère dans une
      table partitionnée, il n'est pas possible de déclarer une clé étrangère
      qui référence une table partitionnée.
     </para>

     <para>
      Une valeur insérée dans les colonnes de la nouvelle table est comparée aux
      valeurs des colonnes de référence dans la table de référence à l'aide du
      type de concordance fourni. Il existe trois types de correspondance&nbsp;:
      <literal>MATCH FULL</literal> (NDT&nbsp;: correspondance totale),
      <literal>MATCH PARTIAL</literal> (NDT&nbsp;: correspondance partielle) et
      <literal>MATCH SIMPLE</literal> (NDT&nbsp;: correspondance simple), qui
      est aussi la valeur par défaut. <literal>MATCH FULL</literal> n'autorise
      une colonne d'une clé étrangère composite à être NULL que si l'ensemble
      des colonnes de la clé étrangère sont NULL. Si elles sont NULL, la ligne
      n'a pas besoin d'avoir une correspondance dans la table référencée.
      <literal>MATCH SIMPLE</literal> permet à n'importe quel colonne d'une clé
      étrangère d'être NULL&nbsp;; si l'une d'entre elles est NULL, la ligne
      n'a pas besoin d'avoir une correspondance dans la table référencée.
      <literal>MATCH PARTIAL</literal> n'est pas encore implémentée. Bien sûr,
      les contraintes <literal>NOT NULL</literal> peuvent être appliquées sur
      la (ou les) colonne(s) référençantes pour empêcher ces cas de survenir.
     </para>

     <para>
      Lorsque les données des colonnes référencées sont modifiées,
      des actions sont réalisées sur les données de la table référençant.
      La clause <literal>ON DELETE</literal> spécifie l'action à
      réaliser lorsqu'une ligne référencée de la table de référence est supprimée.
      De la même façon, la clause <literal>ON UPDATE</literal>
      spécifie l'action à réaliser lorsqu'une colonne référencée est mise à jour.
      Si la ligne est mise à jour sans que la valeur de la colonne référencée ne soit
      modifiée, aucune action n'est réalisée. Les actions référentielles autres
      que la vérification <literal>NO ACTION</literal> ne peuvent
      pas être différées même si la contrainte est déclarée retardable.
      Les actions suivantes sont possibles pour chaque clause&nbsp;:

      <variablelist>
       <varlistentry>
        <term><literal>NO ACTION</literal></term>
        <listitem>
         <para>
          Une erreur est produite pour indiquer que la suppression ou la mise à jour
          entraîne une violation de la contrainte de clé étrangère. Si la
          contrainte est différée, cette erreur est produite au moment
          de la vérification, si toutefois il existe encore des lignes
          de référence. C'est le comportement par défaut.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>RESTRICT</literal></term>
        <listitem>
         <para>
          Une erreur est produite pour indiquer que la suppression ou la mise à jour
          entraîne une violation de la contrainte de clé étrangère. Ce comportement
          est identique à <literal>NO ACTION</literal>, si ce n'est que la vérification
          n'est pas décalable dans le temps.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>CASCADE</literal></term>
        <listitem>
         <para>
          La mise à jour ou la suppression de la ligne de référence est propagée
          à l'ensemble des lignes qui la référencent, qui sont, respectivement,
          mises à jour ou supprimées.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET NULL</literal></term>
        <listitem>
         <para>
          La valeur de la colonne qui référence est positionnée à NULL.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET DEFAULT</literal></term>
        <listitem>
         <para>
          (Il doit existe une ligne dans la table référencée correspondant
          aux valeurs par défaut, si elles ne sont pas NULL. Dans le cas
          contraire, l'opération échouera.)
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>

     <para>
      Si les colonnes référencées sont modifiées fréquemment, il est
      conseillé d'ajouter un index sur les colonnes référençantes pour
      que les actions associées à la contrainte de clé étrangère soient
      plus performantes.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFERRABLE</literal></term>
    <term><literal>NOT DEFERRABLE</literal></term>
    <listitem>
     <para>
      Ces clauses contrôlent la possibilité de différer la contrainte. Une contrainte qui
      n'est pas décalable dans le temps est vérifiée immédiatement après chaque commande. La
      vérification des contraintes décalables est repoussée à la
      fin de la transaction (à l'aide de la commande
      <xref linkend="sql-set-constraints"/>).
      <literal>NOT DEFERRABLE</literal> est la valeur par défaut.
      Actuellement, seules les contraintes <literal>UNIQUE</literal>,
      <literal>PRIMARY KEY</literal>, <literal>EXCLUDE</literal> et
      <literal>REFERENCES</literal> (clé étrangère) acceptent cette clause.
      Les contraintes <literal>NOT NULL</literal> et <literal>CHECK</literal>
      ne sont pas diferrables. Notez que les contraintes différables ne
      peuvent pas être utilisées comme arbitres d'un conflit dans une commande
      <command>INSERT</command> qui inclut une clause <literal>ON CONFLICT DO
      UPDATE</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INITIALLY IMMEDIATE</literal></term>
    <term><literal>INITIALLY DEFERRED</literal></term>
    <listitem>
     <para>
      Si une contrainte est décalable dans le temps, cette clause précise le
      moment de la vérification. Si la contrainte est
      <literal>INITIALLY IMMEDIATE</literal>, elle est vérifiée après chaque
      instruction. Si la contrainte est <literal>INITIALLY DEFERRED</literal>,
      elle n'est vérifiée qu'à la fin de la transaction. Le moment de
      vérification de la contrainte peut être modifié avec la commande <xref
      linkend="sql-set-constraints"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH ( <replaceable class="parameter">paramètre_stockage</replaceable> [= <replaceable class="parameter">valeur</replaceable>] [, ... ] )</literal></term>
    <listitem>
     <para>
      Cette clause spécifie les paramètres de stockage optionnels pour une
      table ou un index&nbsp;; voir <xref linkend="sql-createtable-storage-parameters"
       /> pour plus
      d'informations. La clause <literal>WITH</literal> peut aussi inclure pour
      une table <literal>OIDS=TRUE</literal> (ou simplement <literal>OIDS</literal>)
      pour indiquer que les lignes de la nouvelle table doivent se voir affecter
      des OID (identifiants d'objets) ou <literal>OIDS=FALSE</literal> pour
      indiquer que les lignes ne doivent pas avoir d'OID. Si <literal>OIDS</literal>
      n'est pas indiqué, la valeur par défaut dépend du paramètre de configuration
      <xref linkend="guc-default-with-oids"/>. (Si la nouvelle table hérite d'une
      table qui a des OID, alors<literal>OIDS=TRUE</literal> est forcé même si la
      commande précise <literal>OIDS=FALSE</literal>.)
     </para>

     <para>
      Si <literal>OIDS=FALSE</literal> est indiqué ou implicite, la nouvelle
      table ne stocke pas les OID et aucun OID n'est affecté pour une ligne
      insérée dans cette table. Ceci est généralement bien considéré car
      cela réduit la consommation des OID et retarde du coup le retour à
      zéro du compteur sur 32 bits. Une fois que le compteur est revenu
      à zéro, les OID ne sont plus considérés uniques ce qui les rend
      beaucoup moins utiles. De plus, exclure les OID d'une table réduit
      l'espace requis pour stocker la table sur le disque de quatre octets
      par ligne (la plupart des machines), améliorant légèrement les
      performances.
     </para>

     <para>
      Pour supprimer les OID d'une table une fois qu'elle est créée, utilisez
      <xref linkend="sql-altertable"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH OIDS</literal></term>
    <term><literal>WITHOUT OIDS</literal></term>
    <listitem>
     <para>
      Ce sont les syntaxes obsolètes mais équivalentes, respectivement de
      <literal>WITH (OIDS)</literal> et <literal>WITH (OIDS=FALSE)</literal>. Si
      vous souhaitez indiquer à la fois l'option <literal>OIDS</literal> et les
      paramètres de stockage, vous devez utiliser la syntaxe
      <literal>WITH ( ... )</literal>&nbsp;; voir ci-dessus.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ON COMMIT</literal></term>
    <listitem>
     <para>
      Le comportement des tables temporaires à la fin d'un bloc de transactions
      est contrôlé à l'aide de la clause <literal>ON COMMIT</literal>. Les trois
      options sont&nbsp;:

      <variablelist>
       <varlistentry>
        <term><literal>PRESERVE ROWS</literal></term>
        <listitem>
         <para>
          Aucune action n'est entreprise à la fin des transactions. Comportement par défaut.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DELETE ROWS</literal></term>
        <listitem>
         <para>
          Toutes les lignes de la table temporaire sont détruites à la fin de
          chaque bloc de transactions. En fait, un <xref
          linkend="sql-truncate"/> automatique est réalisé à chaque validation.
          Lorsque cette clause est utilisée sur une table partitionnée, elle
          n'est pas exécutée en cascade sur ses partitions.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DROP</literal></term>
        <listitem>
         <para>
          La table temporaire est supprimée à la fin du bloc de transaction.
          Lorsque cette clause est utilisée sur une table partitionnée, cette
          action supprime les partitions et. Quand elle est utilisée sur une
          table ayant des tables filles, ces dernières sont aussi supprimées.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TABLESPACE <replaceable class="parameter">nom_tablespace</replaceable></literal></term>
    <listitem>
     <para>
      <replaceable class="parameter">nom_tablespace</replaceable> est le
      nom du tablespace dans lequel est créée la nouvelle table. S'il
      n'est pas spécifié, <xref linkend="guc-default-tablespace"/> est consulté, sauf
      si la table est temporaire auquel cas <xref linkend="guc-temp-tablespaces"/>
      est utilisé.

     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>USING INDEX TABLESPACE <replaceable class="parameter">nom_tablespace</replaceable></literal></term>
    <listitem>
     <para>
      Les index associés à une contrainte <literal>UNIQUE</literal>,
      <literal>PRIMARY KEY</literal>, ou <literal>EXCLUDE</literal> sont créés dans le tablespace
      nommé <replaceable class="parameter">nom_tablespace</replaceable>.
      S'il n'est pas précisé, <xref linkend="guc-default-tablespace"/> est consulté, sauf
      si la table est temporaire auquel cas <xref linkend="guc-temp-tablespaces"/>
      est utilisé.

     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <refsect2 id="sql-createtable-storage-parameters">
   <title id="sql-createtable-storage-parameters-title">Paramètres de stockage</title>

   <indexterm zone="sql-createtable-storage-parameters">
    <primary>paramètres de stockage</primary>
   </indexterm>

   <para>
    La clause <literal>WITH</literal> spécifie des <firstterm>paramètres de
     stockage</firstterm> pour les tables ainsi que pour les index associés
     avec une contrainte <literal>UNIQUE</literal>, <literal>PRIMARY
     KEY</literal>, ou <literal>EXCLUDE</literal>. Les paramètres de stockage
     des index sont documentés dans <xref linkend="sql-createindex"/>. Les
     paramètres de stockage actuellement disponibles pour les tables sont
     listés ci-dessous. Pour beaucoup de ces paramètres, comme indiqué, il y a
     un paramètre additionnel, de même nom mais préfixé par
     <literal>toast.</literal>, qui contrôle le le comportement de la table
     <acronym>TOAST</acronym> (stockage supplémentaire), si elle existe (voir
     <xref linkend="storage-toast"/> pour plus d'informations sur TOAST). Si
     une valeur de paramètre d'une table est configuré et que le paramètre
     équivalent <literal>toast.</literal> ne l'est pas, la partie TOAST
     utilisera la valeur du paramètre de la table.
     Spécifier ces paramètres pour les tables partitionnées n'est pas supporté,
     mais vous pouvez les spécifier pour chaque partition n'ayant pas de sous
     partition.
   </para>

   <variablelist>

    <varlistentry>
     <term><literal>fillfactor</literal> (<type>integer</type>)</term>
     <listitem>
      <para>
       Le facteur de remplissage d'une table est un pourcentage entre 10 et 100.
       100 (paquet complet) est la valeur par défaut. Quand un facteur de remplissage
       plus petit est indiqué, les opérations <command>INSERT</command> remplissent
       les pages de table d'au maximum ce pourcentage&nbsp;; l'espace restant sur
       chaque page est réservé à la mise à jour des lignes sur cette page. Cela
       donne à <command>UPDATE</command> une chance de placer la copie d'une ligne
       mise à jour sur la même page que l'original, ce qui est plus efficace que de
       la placer sur une page différente. Pour une table dont les entrées ne sont
       jamais mises à jour, la valeur par défaut est le meilleur choix, mais pour
       des tables mises à jour fréquemment, des facteurs de remplissage plus petits
       sont mieux appropriés. Ce paramètre n'est pas disponible pour la table
       TOAST.
      </para>
     </listitem>
    </varlistentry>

   <varlistentry>
    <term><literal>toast_tuple_target</literal> (<type>integer</type>)</term>
    <listitem>
     <para>
      <literal>toast_tuple_target</literal> spécifie la taille de tuple
	  minimale requise avant de tenter de déplacer les champs de grande taille
	  vers des tables TOAST, et est aussi la taille cible à laquelle l'on tente
	  de réduire la taille une fois cette opération démarrée.

	  Cela n'affecte que les colonnes marquées <literal>External</literal>
	  ou <literal>Extended</literal> et ne s'applique qu'aux nouveaux
	  enregistrements &mdash; cela n'a pas d'effet sur les lignes existantes.
	  Par défaut ce paramètre est configuré pour permettre au moins 4 lignes
	  par bloc, ce qui donnera 2040&nbsp;octets avec la taille de bloc par
	  défaut. Les valeurs valides sont entre 128&nbsp;octets et (taille des
	  blocs - entête), par défaut 8160&nbsp;octets.
	  Changer cette valeur n'est pas très utile pour les lignes très courtes
	  ou très longues. Notez que la valeur par défaut est souvent proche de
	  la valeur optimale, et qu'il est possible que modifier ce paramètre
	  ait des effets négatifs dans certains cas.
	  Ce paramètre ne peut être positionné pour les tables TOAST.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>parallel_workers</literal> (<type>integer</type>)</term>
    <listitem>
     <para>
      Ce paramètre configure le nombre de processus pouvant être utilisés pour
      aider lors d'un parcours parallélisé de cette table. Si ce paramètre
      n'est pas configuré, le système déterminera une valeur en se basant sur
      la taille de la relation. Le nombre réel de processus choisis par le
      planificateur ou par des instructions utilitaires qui utilisent des
      parcours séquentiels pourrait être moindre, par exemple suite à la
      configuration de <xref linkend="guc-max-worker-processes"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
     <term><literal>autovacuum_enabled</literal>,
      <literal>toast.autovacuum_enabled</literal> (<type>boolean</type>)</term>
     <listitem>
      <para>
       Active ou désactive le démon autovacuum pour une table particulière. Si
       elle vaut true, le démon autovacuum réalise des
       <command>VACUUM</command> et/ou <command>ANALYZE</command> automatiques
       sur cette table en suivant les règles discutées dans <xref
       linkend="autovacuum"/>. À false, cette table ne sera pas traitée par le
       démon autovacuum, sauf s'il y a un risque de réutilisation des
       identifiants de transaction. Voir <xref
       linkend="vacuum-for-wraparound"/> pour plus d'informations sur la
       prévention de ce problème. Notez que le démon autovacuum n'est pas
       lancé (sauf pour prévenir la réutilisation des identifiants de
       transaction) si le paramètre <xref linkend="guc-autovacuum"/> vaut
       false&nbsp;; configurer les paramètres de stockage d'une table ne
       surcharge pas cela. De ce fait, il y a peu d'intérêt de configurer ce
       paramètre à <literal>true</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>autovacuum_vacuum_threshold</literal>,
      <literal>toast.autovacuum_vacuum_threshold</literal> (<type>integer</type>)</term>
     <listitem>
      <para>
      Valeur spécifique à la table pour le paramètre <xref
      linkend="guc-autovacuum-vacuum-threshold"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>autovacuum_vacuum_scale_factor</literal>,
      <literal>toast.autovacuum_vacuum_scale_factor</literal> (<type>floating point</type>)</term>
     <listitem>
      <para>
      Valeur spécifique à la table pour le paramètre <xref
      linkend="guc-autovacuum-vacuum-scale-factor"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>autovacuum_analyze_threshold</literal> (<type>integer</type>)</term>
     <listitem>
      <para>
      Valeur spécifique à la table pour le paramètre <xref
      linkend="guc-autovacuum-analyze-threshold"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>autovacuum_analyze_scale_factor</literal> (<type>floating point</type>)</term>
     <listitem>
      <para>
      Valeur spécifique à la table pour le paramètre <xref
      linkend="guc-autovacuum-analyze-scale-factor"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>autovacuum_vacuum_cost_delay</literal>,
      <literal>toast.autovacuum_vacuum_cost_delay</literal> (<type>integer</type>)</term>
     <listitem>
      <para>
      Valeur spécifique à la table pour le paramètre <xref
      linkend="guc-autovacuum-vacuum-cost-delay"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>autovacuum_vacuum_cost_limit</literal>,
      <literal>toast.autovacuum_vacuum_cost_limit</literal> (<type>integer</type>)</term>
     <listitem>
      <para>
      Valeur spécifique à la table pour le paramètre <xref
      linkend="guc-autovacuum-vacuum-cost-limit"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>autovacuum_freeze_min_age</literal>,
      <literal>toast.autovacuum_freeze_min_age</literal> (<type>integer</type>)</term>
     <listitem>
      <para>
      Valeur spécifique à la table pour le paramètre <xref
      linkend="guc-vacuum-freeze-min-age"/>. Notez que l'autovacuum ignorera
      les paramètres <literal>autovacuum_freeze_min_age</literal> spécifiques
      à la table qui sont plus importants que la moitié du paramètre <xref
      linkend="guc-autovacuum-freeze-max-age"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>autovacuum_freeze_max_age</literal>,
      <literal>toast.autovacuum_freeze_max_age</literal> (<type>integer</type>)</term>
     <listitem>
      <para>
      Valeur spécifique à la table pour le paramètre <xref
      linkend="guc-autovacuum-freeze-max-age"/>. Notez que l'autovacuum ignorera
      les paramètres <literal>autovacuum_freeze_max_age</literal> spécifiques
      à la table qui sont plus importants que la configuration globale (elle ne
      peut être que plus petite).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>autovacuum_freeze_table_age</literal>,
      <literal>toast.autovacuum_freeze_table_age</literal> (<type>integer</type>)</term>
     <listitem>
      <para>
      Valeur spécifique à la table pour le paramètre <xref
      linkend="guc-vacuum-freeze-table-age"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>autovacuum_multixact_freeze_min_age</literal>, <literal>toast.autovacuum_multixact_freeze_min_age</literal> (<type>integer</type>)</term>
     <listitem>
      <para>
       Valeur spécifique à la table pour le paramètre <xref
       linkend="guc-vacuum-multixact-freeze-min-age"/>. Notez que l'autovacuum
       ignorera les paramètres
       <literal>autovacuum_multixact_freeze_min_age</literal> spécifiques à la
       table si leur configuration est supérieure à la moitié de la valeur du
       paramètre global <xref
       linkend="guc-autovacuum-multixact-freeze-max-age"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>autovacuum_multixact_freeze_max_age</literal>, <literal>toast.autovacuum_multixact_freeze_max_age</literal> (<type>integer</type>)</term>
     <listitem>
      <para>
       Valeur spécifique à la table pour le paramètre <xref
       linkend="guc-autovacuum-multixact-freeze-max-age"/>. Notez que
       l'autovacuum ignorera les paramètres
       <literal>autovacuum_multixact_freeze_max_age</literal> spécifiques à la
       table si leur configuration est supérieure à la valeur du paramètre
       global (elle peut seulement être inférieure).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>autovacuum_multixact_freeze_table_age</literal>, <literal>toast.autovacuum_multixact_freeze_table_age</literal> (<type>integer</type>)</term>
     <listitem>
      <para>
      Valeur spécifique à la table pour le paramètre <xref
      linkend="guc-vacuum-multixact-freeze-table-age"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>log_autovacuum_min_duration</literal>, <literal>toast.log_autovacuum_min_duration</literal> (<type>integer</type>)</term>
    <listitem>
     <para>
      Valeur spécifique à la table pour le paramètre <xref
      linkend="guc-log-autovacuum-min-duration"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>user_catalog_table</literal> (<type>boolean</type>)</term>
     <listitem>
      <para>
       Déclare la table comme une autre table du catalogue dans le cadre de la
       réplication logique. Voir <xref
       linkend="logicaldecoding-capabilities"/> pour les détails. Ce paramètre
       ne peut pas être configuré pour les tables TOAST.
      </para>
     </listitem>
    </varlistentry>

   </variablelist>

  </refsect2>
 </refsect1>

 <refsect1 id="sql-createtable-notes">
  <title>Notes</title>

  <para>
   Utiliser les OID dans les nouvelles applications n'est pas recommandé&nbsp;:
   dans la mesure du possible, une colonne d'identité ou un autre
   générateur de séquence sera utilisé comme clé primaire de la table.
   Néanmoins, si l'application utilise les OID pour identifier des
   lignes spécifiques d'une table, il est recommandé de créer une contrainte
   unique sur la colonne <structfield>oid</structfield> de cette table afin de s'assurer
   que les OID de la table identifient les lignes de façon réellement unique
   même si le compteur est réinitialisé. Il n'est pas garanti que les OID soient
   uniques sur l'ensemble des tables. Dans le cas où un identifiant unique sur
   l'ensemble de la base de données est nécessaire, on utilise préférentiellement une combinaison de
   <structfield>tableoid</structfield> et de l'OID de la ligne.
  </para>

  <tip>
   <para>
    L'utilisation de <literal>OIDS=FALSE</literal> est déconseillée
    pour les tables dépourvues de clé primaire. En effet, sans OID ou clé de
    données unique, il est difficile d'identifier des lignes spécifiques.
   </para>
  </tip>

  <para>
   <productname>PostgreSQL</productname> crée automatiquement un index pour
   chaque contrainte d'unicité ou clé primaire afin d'assurer l'unicité.
   Il n'est donc pas nécessaire de créer un index
   spécifiqueme pour les colonnes de clés primaires. Voir <xref
   linkend="sql-createindex"/> pour plus
   d'informations.
  </para>

  <para>
   Les contraintes d'unicité et les clés primaires ne sont pas héritées dans
   l'implantation actuelle. Cela diminue la fonctionnalité des combinaisons d'héritage
   et de contraintes d'unicité.
  </para>

  <para>
   Une table ne peut pas avoir plus de 1600 colonnes (en pratique, la limite
   réelle est habituellement plus basse du fait de contraintes sur la longueur
   des lignes).
  </para>

 </refsect1>


 <refsect1 id="sql-createtable-examples">
  <title>Exemples</title>

  <para>
   Créer une table <structname>films</structname> et une table
   <structname>distributeurs</structname>&nbsp;:

   <programlisting>CREATE TABLE films (
    code        char(5) CONSTRAINT premierecle PRIMARY KEY,
    titre       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    genre       varchar(10),
    duree       interval hour to minute
);

CREATE TABLE distributeurs (
     did    integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
     nom    varchar(40) NOT NULL CHECK (nom &lt;&gt; '')
);
   </programlisting>
  </para>

  <para>
   Créer une table contenant un tableau à deux dimensions&nbsp;:

   <programlisting>CREATE TABLE array_int (
    vecteur  int[][]
);
   </programlisting>
  </para>

  <para>
   Définir une contrainte d'unicité pour la table
   <literal>films</literal>. Les contraintes d'unicité de table peuvent être
   définies sur une ou plusieurs colonnes de la table&nbsp;:

   <programlisting>CREATE TABLE films (
    code        char(5),
    titre       varchar(40),
    did         integer,
    date_prod   date,
    genre       varchar(10),
    duree       interval hour to minute,
    CONSTRAINT production UNIQUE(date_prod)
);
   </programlisting>
  </para>

  <para>
   Définir une contrainte de vérification sur une colonne&nbsp;:

   <programlisting>CREATE TABLE distributeurs (
    did     integer CHECK (did &gt; 100),
    nom    varchar(40)
);
   </programlisting>
  </para>

  <para>
   Définir une contrainte de vérification sur la table&nbsp;:

   <programlisting>CREATE TABLE distributeurs (
    did     integer,
    nom     varchar(40),
    CONSTRAINT con1 CHECK (did &gt; 100 AND nom &lt;&gt; '')
);
   </programlisting>
  </para>

  <para>
   Définir une contrainte de clé primaire sur la table <structname>films</structname>.

   <programlisting>CREATE TABLE films (
    code        char(5),
    titre       varchar(40),
    did         integer,
    date_prod   date,
    genre       varchar(10),
    duree       interval hour to minute,
    CONSTRAINT code_titre PRIMARY KEY(code,titre)
);
   </programlisting>
  </para>

  <para>
   Définir une contrainte de clé primaire pour la table
   <structname>distributeurs</structname>. Les deux exemples suivants sont équivalents,
   le premier utilise la syntaxe de contrainte de table, le second la
   syntaxe de contrainte de colonne&nbsp;:

   <programlisting>CREATE TABLE distributeurs (
    did     integer,
    nom     varchar(40),
    PRIMARY KEY(did)
);

CREATE TABLE distributeurs (
    did     integer PRIMARY KEY,
    nom     varchar(40)
);
   </programlisting>
  </para>

  <para>
   Affecter une valeur par défaut à la colonne <literal>nom</literal>,
   une valeur par défaut à la colonne <literal>did</literal>,
   engendrée à l'aide d'une séquence, et une valeur par défaut à
   la colonne <literal>modtime</literal>, équivalente au moment où la ligne
   est insérée&nbsp;:

   <programlisting>CREATE TABLE distributeurs (
    name      varchar(40) DEFAULT 'Luso Films',
    did       integer DEFAULT nextval('distributeurs_serial'),
    modtime   timestamp DEFAULT current_timestamp
);
   </programlisting>
  </para>

  <para>
   Définir deux contraintes de colonnes <literal>NOT NULL</literal> sur la table
   <classname>distributeurs</classname>, dont l'une est explicitement nommée&nbsp;:

   <programlisting>CREATE TABLE distributeurs (
    did     integer CONSTRAINT no_null NOT NULL,
    nom     varchar(40) NOT NULL
);
   </programlisting>
  </para>

  <para>
   Définir une contrainte d'unicité sur la colonne <literal>nom</literal>&nbsp;:

   <programlisting>CREATE TABLE distributeurs (
    did     integer,
    nom     varchar(40) UNIQUE
);
   </programlisting>

   La même chose en utilisant une contrainte de table&nbsp;:

   <programlisting>CREATE TABLE distributeurs (
    did     integer,
    nom     varchar(40),
    UNIQUE(nom)
);
   </programlisting>
  </para>

  <para>
   Créer la même table en spécifiant un facteur de remplissage de 70% pour la
   table et les index uniques&nbsp;:

   <programlisting>
CREATE TABLE distributeurs (
    did     integer,
    nom     varchar(40),
    UNIQUE(nom) WITH (fillfactor=70)
)
WITH (fillfactor=70);
   </programlisting>
  </para>

  <para>
   Créer une table <structname>cercles</structname> avec une contrainte
   d'exclusion qui empêche le croisement de deux cercles&nbsp;:

   <programlisting>
CREATE TABLE cercles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
   </programlisting>
  </para>

  <para>
   Créer une table <structname>cinemas</structname> dans le tablespace
   <structname>diskvol1</structname>&nbsp;:

   <programlisting>CREATE TABLE cinemas (
    id serial,
    nom text,
    emplacement text
) TABLESPACE diskvol1;
   </programlisting>
  </para>

  <para>
   Créer un type composite et une table typée&nbsp;:
   <programlisting>
CREATE TYPE type_employe AS (nom text, salaire numeric);

CREATE TABLE employes OF type_employe (
    PRIMARY KEY (nom),
    salaire WITH OPTIONS DEFAULT 1000
);
   </programlisting>
  </para>

  <para>
   Créer une table partitionée par intervalles :
<programlisting>
CREATE TABLE measurement (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
</programlisting></para>

  <para>
   Créer une table partitionnée par intervalles avec plusieurs colonnes dans la
   clé de partitionnement :
<programlisting>
CREATE TABLE measurement_year_month (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (EXTRACT(YEAR FROM logdate), EXTRACT(MONTH FROM logdate));
</programlisting></para>

  <para>
   Créer une table partitionnée par liste de valeurs :
<programlisting>
CREATE TABLE cities (
    city_id      bigserial not null,
    name         text not null,
    population   bigint
) PARTITION BY LIST (left(lower(name), 1));
</programlisting></para>

  <para>
   Créer une table partitionnée par hachage&nbsp;:
<programlisting>
CREATE TABLE orders (
    order_id     bigint not null,
    cust_id      bigint not null,
    status       text
) PARTITION BY HASH (order_id);
</programlisting></para>

  <para>
   Créer une partition d'une table partitionnée par intervalles :
<programlisting>
CREATE TABLE measurement_y2016m07
    PARTITION OF measurement (
    unitsales DEFAULT 0
) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
</programlisting></para>

  <para>
   Créer quelques partitions d'une table partitionnée par intervalles avec
   plusieurs colonnes dans la clé de partitionnement :
<programlisting>
CREATE TABLE measurement_ym_older
    PARTITION OF measurement_year_month
    FOR VALUES FROM (MINVALUE, MINVALUE) TO (2016, 11);

CREATE TABLE measurement_ym_y2016m11
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2016, 11) TO (2016, 12);

CREATE TABLE measurement_ym_y2016m12
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2016, 12) TO (2017, 01);

CREATE TABLE measurement_ym_y2017m01
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2017, 01) TO (2017, 02);
</programlisting></para>

  <para>
   Créer une partition d'une table partitionnée par liste de valeur :
<programlisting>
CREATE TABLE cities_ab
    PARTITION OF cities (
    CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN ('a', 'b');
</programlisting></para>

  <para>
   Créer une partition d'une table partitionnée par liste e valeur qui est
   elle-même partitionnée, puis y ajouter une partition :
<programlisting>
CREATE TABLE cities_ab
    PARTITION OF cities (
    CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN ('a', 'b') PARTITION BY RANGE (population);

CREATE TABLE cities_ab_10000_to_100000
    PARTITION OF cities_ab FOR VALUES FROM (10000) TO (100000);
</programlisting></para>

  <para>
   Créer des partitions d'une table partitionnée par hachage&nbsp;:
<programlisting>
CREATE TABLE orders_p1 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE orders_p2 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE orders_p3 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE orders_p4 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 3);
</programlisting></para>

  <para>
   Créer une partition par défaut&nbsp;:
<programlisting>
CREATE TABLE cities_partdef
    PARTITION OF cities DEFAULT;
</programlisting></para>
 </refsect1>

 <refsect1 id="sql-createtable-compatibility">
  <title id="sql-createtable-compatibility-title">Compatibilité</title>

  <para>
   La commande <command>CREATE TABLE</command> est conforme au standard
   <acronym>SQL</acronym>, aux exceptions indiquées ci-dessous.
  </para>

  <refsect2>
   <title>Tables temporaires</title>

   <para>
    Bien que la syntaxe de <literal>CREATE TEMPORARY TABLE</literal> ressemble
    à celle du SQL standard, l'effet n'est pas le même. Dans le standard, les
    tables temporaires sont définies une seule fois et existent
    automatiquement (vide de tout contenu au démarrage) dans toute session les
    utilisant. <productname>PostgreSQL</productname>, au contraire, impose
    à chaque session de lancer une commande <literal>CREATE TEMPORARY
     TABLE</literal> pour chaque table temporaire utilisée. Cela permet à
    des sessions différentes d'utiliser le même nom de table temporaire dans des
    buts différents (le standard contraint toutes les
    instances d'une table temporaire donnée à pointer sur la même structure de
    table).
   </para>

   <para>
    Le comportement des tables temporaires tel que défini par le standard est
    largement ignorée. Le comportement de <productname>PostgreSQL</productname>
    sur ce point est similaire à celui de nombreuses autres bases de données
    SQL.
   </para>

   <para>
    Le standard SQL distingue aussi les tables temporaires globales et locales.
    Une table temporaire local a un contenu séparé pour chaque module SQL à
    l'intérieur de chaque session bien que sa définition est toujours partagée
    entre les sessions. Comme <productname>PostgreSQL</productname> ne supporte
    pas les modules SQL, la distinction n'a pas de raison d'être avec
    <productname>PostgreSQL</productname>.
   </para>

   <para>
    Pour des raisons
    de compatibilité, <productname>PostgreSQL</productname> accepte
    néanmoins les mots-clés <literal>GLOBAL</literal> et <literal>LOCAL</literal>
    dans la définition d'une table temporaire, mais ils n'ont actuellement aucun effet.
    L'utilisation de ces mots clés n'est pas conseillée car les versions futures
    de <productname>PostgreSQL</productname> pourrait adopter une interprétation
    plus standard de leur signification.
   </para>

   <para>
    La clause <literal>ON COMMIT</literal> sur les tables temporaires
    diffère quelque peu du standard SQL. Si la clause
    <literal>ON COMMIT</literal> est omise, SQL spécifie <literal>ON COMMIT DELETE ROWS</literal>
    comme comportemant par défaut. <productname>PostgreSQL</productname> utilise
    <literal>ON COMMIT PRESERVE ROWS</literal> par défaut. De plus, l'option
    <literal>ON COMMIT DROP</literal> n'existe pas en SQL.
   </para>
  </refsect2>

  <refsect2>
   <title>Contraintes d'unicité non déferrées</title>

   <para>
    Quand une contrainte <literal>UNIQUE</literal> ou <literal>PRIMARY
     KEY</literal> est non déferrable, <productname>PostgreSQL</productname>
    vérifie l'unicité immédiatement après qu'une ligne soit insérée ou
    modifiée. Le standard SQL indique que l'unicité doit être forcée seulement
    à la fin de l'instruction&nbsp;; ceci fait une différence quand, par
    exemple, une seule commande met à jour plusieurs valeurs de clés. Pour
    obtenir un comportement compatible au standard, déclarez la contrainte
    comme <literal>DEFERRABLE</literal> mais non déferrée (c'est-à-dire que
    <literal>INITIALLY IMMEDIATE</literal>). Faites attention que cela peut
    être beaucoup plus lent qu'une vérification d'unicité immédiate.
   </para>
  </refsect2>

  <refsect2>
   <title>Contraintes de vérification de colonnes</title>

   <para>
    Dans le standard, les contraintes de vérification <literal>CHECK</literal>
    de colonne ne peuvent faire référence qu'à la colonne à laquelle elles
    s'appliquent&nbsp;; seules les contraintes <literal>CHECK</literal> de table
    peuvent faire référence à plusieurs colonnes.
    <productname>PostgreSQL</productname> n'impose pas cette restriction&nbsp;;
    les contraintes de vérifications de colonnes et de table ont un traitement
    identique.
   </para>
  </refsect2>

  <refsect2>
   <title><literal>EXCLUDE</literal> Constraint</title>

   <para>
    Le type de contrainte <literal>EXCLUDE</literal> est une extension
    <productname>PostgreSQL</productname>.
   </para>
  </refsect2>

  <refsect2>
   <title>Contrainte <literal>NULL</literal></title>

   <para>
    La <quote>contrainte</quote> <literal>NULL</literal> (en fait, une
    non-contrainte) est une extension <productname>PostgreSQL</productname> au
    standard SQL, incluse pour des raisons de compatibilité avec d'autres
    systèmes de bases de données (et par symétrie avec la contrainte
    <literal>NOT NULL</literal>). Comme c'est la valeur par défaut de toute
    colonne, sa présence est un simple bruit.
   </para>
  </refsect2>

  <refsect2>
   <title>Nommage de contrainte</title>

   <para>
    Le standard SQL stipule que les contraintes de table et de domaine doivent
    avoir des noms uniques sur le schéma contenant la table ou le domaine.
    <productname>PostgreSQL</productname> est laxiste&nbsp;: il requiert
    seulement que le nom des contraintes soit unique parmi les contraintes
    attachées à une table ou un domaine particulier. Néanmoins, cette liberté
    supplémentaire n'existe pas pour les contraintes basées sur des index
    (contraintes <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal> et
    <literal>EXCLUDE</literal>) parce que l'index associé est nommé de la même
    façon que la contrainte, et les noms d'index doivent être uniques parmi
    toutes les relations du même schéma.
   </para>

   <para>
    Actuellement, <productname>PostgreSQL</productname> n'enregistre pas de
    noms pour les contraintes <literal>NOT NULL</literal>, donc elles ne sont
    pas sujettes aux restrictions d'unicité. Ceci pourrait changer dans une
    prochaine version.
   </para>
  </refsect2>

  <refsect2>
   <title>Héritage</title>

   <para>
    L'héritage multiple via la clause <literal>INHERITS</literal> est une
    extension du langage <productname>PostgreSQL</productname>. SQL:1999 et
    les versions ultérieures définissent un héritage simple en utilisant une
    syntaxe et des sémantiques différentes. L'héritage style SQL:1999 n'est pas
    encore supporté par <productname>PostgreSQL</productname>.
   </para>
  </refsect2>

  <refsect2>
   <title>Tables sans colonne</title>

   <para>
    <productname>PostgreSQL</productname> autorise la création de tables sans
    colonne (par exemple, <literal>CREATE TABLE foo();</literal>). C'est une
    extension du standard SQL, qui ne le permet pas. Les tables sans colonne ne
    sont pas très utiles mais les interdire conduit à un comportement étrange de
    <command>ALTER TABLE DROP COLUMN</command>. Il est donc plus sage
    d'ignorer simplement cette restriction.
   </para>
  </refsect2>

  <refsect2>
   <title>Colonnes d'identités multiples</title>

   <para>
    <productname>PostgreSQL</productname> autorise une table à avoir plus d'une
    colonne d'identité.  le standard spécifie qu'une table peut avoir au plus
    une colonne d'identité.  Cette règle est assouplie principalement pour
    donner plus de flexibilité pour effectuer des changements de schéma ou des
    migrations.  Veuillez noter que la commande <command>INSERT</command>
    supporte uniquement une seule clause de surcharge qui s'appliquent à la
    comande entière, et donc avoir de multiples colonnes d'identités avec des
    comportements différents n'est pas bien supporté.
   </para>
  </refsect2>

  <refsect2>
   <title>Clause <literal>LIKE</literal></title>

   <para>
    Alors qu'une clause <literal>LIKE</literal> existe dans le standard SQL,
    beaucoup des options acceptées par <productname>PostgreSQL</productname>
    ne sont pas dans le standard, et certaines options du standard ne sont pas
    implémentées dans <productname>PostgreSQL</productname>.
   </para>
  </refsect2>

  <refsect2>
   <title>Clause <literal>WITH</literal></title>

   <para>
    La clause <literal>WITH</literal> est une extension
    <productname>PostgreSQL</productname>&nbsp;; ni les paramètres de stockage
    ni les OID ne sont dans le standard.
   </para>
  </refsect2>

  <refsect2>
   <title>Tablespaces</title>

   <para>
    Le concept <productname>PostgreSQL</productname> de tablespace n'est
    pas celui du standard. De ce fait, les clauses <literal>TABLESPACE</literal>
    et <literal>USING INDEX TABLESPACE</literal> sont des extensions.
   </para>
  </refsect2>

  <refsect2>
   <title>Tables typées</title>

   <para>
    Les tables typées implémentent un sous-ensemble du standard SQL. Suivant
    le standard, une table typée a des colonnes correspondant au type
    composite ainsi qu'une autre colonne qui est la <quote>colonne
     auto-référente</quote>. PostgreSQL ne supporte pas ces colonnes
    auto-référentes explicitement mais le même effet est disponible en
    utilisant la fonctionnalité OID.
   </para>
  </refsect2>

  <refsect2>
   <title>Clause <literal>PARTITION BY</literal></title>

   <para>
    La clause<literal>PARTITION BY</literal> est une extension
    <productname>PostgreSQL</productname> de la norme SQL.
   </para>
  </refsect2>

  <refsect2>
   <title>Clause <literal>PARTITION OF</literal></title>

   <para>
    La clause <literal>PARTITION OF</literal> est une extension
    <productname>PostgreSQL</productname> de la norme SQL.
   </para>
  </refsect2>

 </refsect1>


 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-altertable"/></member>
   <member><xref linkend="sql-droptable"/></member>
   <member><xref linkend="sql-createtableas"/></member>
   <member><xref linkend="sql-createtablespace"/></member>
  </simplelist>
 </refsect1>
</refentry>
