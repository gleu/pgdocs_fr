<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060618 -->

<refentry id="sql-createtrigger">
 <refmeta>
  <refentrytitle>CREATE TRIGGER</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TRIGGER</refname>
  <refpurpose>Définir un nouveau déclencheur</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE [ CONSTRAINT ] TRIGGER <replaceable class="PARAMETER">nom</replaceable> { BEFORE | AFTER | INSTEAD OF } { <replaceable class="PARAMETER">evenement</replaceable> [ OR ... ] }
    ON <replaceable class="PARAMETER">table</replaceable>
    [ FROM <replaceable class="parameter">referenced_table_name</replaceable> ]
    { NOT DEFERRABLE | [ DEFERRABLE ] { INITIALLY IMMEDIATE | INITIALLY DEFERRED } }
    [ FOR [ EACH ] { ROW | STATEMENT } ]
    [ WHEN ( <replaceable class="parameter">condition</replaceable> ) ]
    EXECUTE PROCEDURE <replaceable class="parameter">nom_fonction</replaceable> ( <replaceable class="parameter">arguments</replaceable> )

<phrase>where <replaceable class="parameter">event</replaceable> can be one of:</phrase>

    INSERT
    UPDATE [ OF <replaceable class="parameter">column_name</replaceable> [, ... ] ]
    DELETE
    TRUNCATE
</synopsis>
 </refsynopsisdiv>
 
 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-createtrigger">
   <primary>CREATE TRIGGER</primary>
  </indexterm>

  <para>
   <command>CREATE TRIGGER</command> crée un nouveau déclencheur. Le
   déclencheur est associé à la table ou à la vue spécifiée et exécute la fonction
   <replaceable class="parameter">nom_fonction</replaceable> lorsque
   certains événements surviennent.
  </para>

  <para>
   L'appel du déclencheur peut avoir lieu avant que l'opération
   ne soit tentée sur une ligne (avant la vérification des contraintes et 
   la tentative d'<command>INSERT</command>, <command>UPDATE</command> ou
   <command>DELETE</command>) ou une fois que l'opération est
   terminée (après la vérification des contraintes et la fin de la commande
   <command>INSERT</command>, <command>UPDATE</command> ou 
   <command>DELETE</command>); or instead of the operation
   (in the case of inserts, updates or deletes on a view). Si le déclencheur est lancé avant
   l'événement or instead of the event, le déclencheur peut ignorer l'opération sur la ligne
   courante ou modifier la ligne en cours d'insertion (uniquement pour les
   opérations <command>INSERT</command> et <command>UPDATE</command>). Si le
   déclencheur est activé après l'événement, toute modification, dont les
   autres triggers, est <quote>visible</quote>
   par le déclencheur.
  </para>

  <para>
   Un déclencheur marqué <literal>FOR EACH ROW</literal> est appelé pour
   chaque ligne que l'opération modifie. Par exemple, un
   <command>DELETE</command> affectant dix lignes entraîne dix appels distincts
   de tout déclencheur <literal>ON DELETE</literal> sur la relation cible,
   une fois par ligne supprimée. Au contraire, un
   déclencheur marqué <literal>FOR EACH STATEMENT</literal> ne s'exécute
   qu'une fois pour une opération donnée, quelque soit le nombre de lignes
   modifiées (en particulier, une opération qui ne modifie aucune ligne résulte
   toujours en l'exécution des déclencheurs <literal>FOR EACH STATEMENT</literal> applicables).
  </para>

  <para>
   In addition, triggers may be defined to fire for a
   Triggers that are specified to fire <literal>INSTEAD OF</literal> the trigger
   event must be marked <literal>FOR EACH ROW</literal>, and can only be defined
   on views. <literal>BEFORE</literal> and <literal>AFTER</literal> triggers on a view
   must be marked as <literal>FOR EACH STATEMENT</literal>.
  </para>

  <para>
   The following table summarizes which types of triggers may be used on
   tables and views:
  </para>

  <informaltable id="supported-trigger-types">
   <tgroup cols="4">
    <thead>
     <row>
      <entry>When</entry>
      <entry>Event</entry>
      <entry>Row-level</entry>
      <entry>Statement-level</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry align="center" morerows="1"><literal>BEFORE</literal></entry>
      <entry align="center"><command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command></entry>
      <entry align="center">Tables</entry>
      <entry align="center">Tables and views</entry>
     </row>
     <row>
      <entry align="center"><command>TRUNCATE</command></entry>
      <entry align="center">&mdash;</entry>
      <entry align="center">Tables</entry>
     </row>
     <row>
      <entry align="center" morerows="1"><literal>AFTER</literal></entry>
      <entry align="center"><command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command></entry>
      <entry align="center">Tables</entry>
      <entry align="center">Tables and views</entry>
     </row>
     <row>
      <entry align="center"><command>TRUNCATE</command></entry>
      <entry align="center">&mdash;</entry>
      <entry align="center">Tables</entry>
     </row>
     <row>
      <entry align="center" morerows="1"><literal>INSTEAD OF</literal></entry>
      <entry align="center"><command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command></entry>
      <entry align="center">Views</entry>
      <entry align="center">&mdash;</entry>
     </row>
     <row>
      <entry align="center"><command>TRUNCATE</command></entry>
      <entry align="center">&mdash;</entry>
      <entry align="center">&mdash;</entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>

  <para>
   De plus, les triggers peuvent être définis pour être déclenchés suite à
   l'exécution d'un <command>TRUNCATE</command>, mais seulement dans le cas d'un
   trigger <literal>FOR EACH STATEMENT</literal>.
  </para>

  <para>
   De plus, la définition d'un trigger peut spécifier une condition
   <literal>WHEN</literal> qui sera testée pour voir si le trigger doit
   réellement être déclenché. Dans les triggers au niveau ligne, la condition
   <literal>WHEN</literal> peut examiner l'ancienne et/ou la nouvelle valeurs
   des colonnes de la ligne. Les triggers au niveau instruction peuvent aussi
   avoir des conditions <literal>WHEN</literal>, bien que la fonctionnalité
   n'est pas aussi utile pour elles car la condition ne peut pas faire
   référence aux valeurs de la table.
  </para>

  <para>
   Si plusieurs déclencheurs du même genre sont définis pour le même événement,
   ils sont déclenchés suivant l'ordre alphabétique de leur nom.
  </para>

  <para>
   When the <literal>CONSTRAINT</literal> option is specified, this command creates a
   <firstterm>constraint trigger</firstterm>.  This is the same as a regular trigger
   except that the timing of the trigger firing can be adjusted using
   <xref linkend="SQL-SET-CONSTRAINTS"/>.
   Constraint triggers must be <literal>AFTER ROW</literal> triggers.  They can
   be fired either at the end of the statement causing the triggering event,
   or at the end of the containing transaction; in the latter case they are
   said to be <firstterm>deferred</firstterm>.  A pending deferred-trigger firing can
   also be forced to happen immediately by using <command>SET CONSTRAINTS</command>.
   Constraint triggers are expected to raise an exception when the constraints
   they implement are violated.
  </para>

  <para>
   <command>SELECT</command> ne modifie aucune ligne&nbsp;; la création de
   déclencheurs sur <command>SELECT</command> n'est donc pas possible.
   Les règles et vues sont plus appropriées dans ce cas.
  </para>

  <para>
   <xref linkend="triggers"/> présente de plus amples informations sur les
   déclencheurs.
  </para>
 </refsect1>
  
 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
      Le nom du nouveau déclencheur. Il doit être distinct du nom de
      tout autre déclencheur sur la table.
      The name cannot be schema-qualified &mdash; the trigger inherits the
      schema of its table.  For a constraint trigger, this is also the name to
      use when modifying the trigger's behavior using
      <command>SET CONSTRAINTS</command>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>BEFORE</literal></term>
    <term><literal>AFTER</literal></term>
    <term><literal>INSTEAD OF</literal></term>
    <listitem>
     <para>
      Détermine si la fonction est appelée avant, après , or instead of
      the event.  A constraint trigger can only be specified as
      <literal>AFTER</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">événement</replaceable></term>
    <listitem>
     <para>
      Peut-être <literal>INSERT</literal>, <literal>UPDATE</literal> ou
      <literal>DELETE</literal> ou <literal>TRUNCATE</literal>&nbsp;;
      précise l'événement qui active le
      déclencheur. Plusieurs événements peuvent être précisés en les séparant par
      <literal>OR</literal>.
     </para>

     <para>
      Pour les triggers se déclenchant suite à un <literal>UPDATE</literal>,
      il est possible de spécifier une liste de colonnes utilisant cette
      syntaxe&nbsp;:
<synopsis>
UPDATE OF <replaceable>nom_colonne_1</replaceable> [, <replaceable>nom_colonne_2</replaceable> ... ]
</synopsis>
      Le trigger se déclenchera seulement si au moins une des colonnes listées
      est mentionnée comme cible de la commande <command>UPDATE</command>.
     </para>

     <para>
      <literal>INSTEAD OF UPDATE</literal> events do not support lists of columns.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">table</replaceable></term>
    <listitem>
     <para>
      Le nom (éventuellement qualifié du nom du schéma) de la table ou de la
      vue à laquelle est rattaché le déclencheur.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">referenced_table_name</replaceable></term>
    <listitem>
     <para>
      The (possibly schema-qualified) name of another table referenced by the
      constraint.  This option is used for foreign-key constraints and is not
      recommended for general use.  This can only be specified for
      constraint triggers.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFERRABLE</literal></term>
    <term><literal>NOT DEFERRABLE</literal></term>
    <term><literal>INITIALLY IMMEDIATE</literal></term>
    <term><literal>INITIALLY DEFERRED</literal></term>
    <listitem>
     <para>
      The default timing of the trigger.
      See the <xref linkend="SQL-CREATETABLE"/> documentation for details of
      these constraint options.  This can only be specified for constraint
      triggers.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FOR EACH ROW</literal></term>
    <term><literal>FOR EACH STATEMENT</literal></term>

    <listitem>
     <para>
      Précise si la procédure du déclencheur doit être lancée 
      pour chaque ligne affectée par l'événement ou
      simplement pour chaque instruction SQL. <literal>FOR EACH STATEMENT</literal>
      est la valeur par défaut. Constraint triggers can only
      be specified <literal>FOR EACH ROW</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">condition</replaceable></term>
    <listitem>
     <para>
      Une expression booléenne qui détermine si la fonction trigger sera
      réellement exécutée. Si <literal>WHEN</literal> est indiqué, la fonction
      sera seulement appelée si la <replaceable
      class="parameter">condition</replaceable> renvoie <literal>true</literal>.
      Pour les triggers <literal>FOR EACH ROW</literal>, la condition
      <literal>WHEN</literal> peut faire référence aux valeurs des colonnes
      des ancienne et nouvelle lignes en utilisant la notation
      <literal>OLD.<replaceable
      class="parameter">nom_colonne</replaceable></literal> ou
      <literal>NEW.<replaceable
      class="parameter">nom_colonne</replaceable></literal>, respectivement.
      Bien sûr, le triggers sur <literal>INSERT</literal> ne peuvent pas
      faire référence à <literal>OLD</literal> et ceux sur
      <literal>DELETE</literal> ne peuvent pas faire référence à
      <literal>NEW</literal>.
     </para>

     <para>
      <literal>INSTEAD OF</literal> triggers do not support <literal>WHEN</literal>
      conditions.
     </para>

     <para>
      Actuellement, les expressions <literal>WHEN</literal> ne peuvent pas
      contenir de sous-requêtes.
     </para>

     <para>
      Note that for constraint triggers, evaluation of the <literal>WHEN</literal>
      condition is not deferred, but occurs immediately after the row update
      operation is performed. If the condition does not evaluate to true then
      the trigger is not queued for deferred execution.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_fonction</replaceable></term>
    <listitem>
     <para>
      Une fonction utilisateur, déclarée sans argument et renvoyant le type <literal>trigger</literal>, exécutée
      à l'activation du déclencheur.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">arguments</replaceable></term>
    <listitem>
     <para>
      Une liste optionnelle d'arguments séparés par des virgules à fournir à la
      fonction lors de l'activation du déclencheur. Les arguments sont des
      chaînes littérales constantes. Il est possible d'écrire ici de 
      simples noms et des constantes numériques mais ils sont tous convertis
      en chaîne. L'accès aux arguments du trigger depuis la fonction peut
      différer de l'accès aux arguments d'une fonction standard&nbsp;; la consultation
      des caractéristiques d'implantation du langage de la fonction peut alors s'avérer
      utile.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1 id="sql-createtrigger-notes">
  <title>Notes</title>

  <para>
   Pour créer un déclencheur sur une table, l'utilisateur doit posséder le droit
   <literal>TRIGGER</literal> sur la table.
  </para>

  <para>
   Utiliser <xref linkend="sql-droptrigger"/>
   pour supprimer un déclencheur.
  </para>

  <para>
   Un trigger sur colonne spécifique (one defined using the <literal>UPDATE OF
   <replaceable>nom_colonne</replaceable></literal> syntax) se déclenchera quand
   une des colonnes indiquées est listée comme cible de la liste
   <literal>SET</literal> pour la commande <command>UPDATE</command>. Il est
   possible qu'une valeur de colonne change même si le trigger n'est pas
   déclenché parceque les modifications au contenu de la ligne par les triggers
   <literal>BEFORE UPDATE</literal> ne sont pas pris en compte. De même, une
   commande comme <literal>UPDATE ... SET x = x ...</literal> déclenchera le
   trigger sur la colonne <literal>x</literal>, bien que la valeur de cette
   colonne ne changera pas.
  </para>

  <para>
   Dans un trigger <literal>BEFORE</literal>, la condition
   <literal>WHEN</literal> est évaluée juste avant l'exécution de la fonction,
   donc utiliser <literal>WHEN</literal> n'est pas matériellement différent
   de tester la même condition au début de la fonction trigger. Notez en
   particulier que la ligne <literal>NEW</literal> vu par la condition est sa
   valeur courante et possiblement modifiée par des triggers précédents. De
   plus, la condition <literal>WHEN</literal> d'un trigger
   <literal>BEFORE</literal> n'est pas autorisé à examiner les colonnes
   système de la ligne <literal>NEW</literal> (comme l'<literal>oid</literal>),
   car elles n'auront pas encore été initialisées.
  </para>

  <para>
   Dans un trigger <literal>AFTER</literal>, la condition
   <literal>WHEN</literal> est évaluée juste après la mise à jour de la ligne
   et elle détermine si un événement doit déclencher le trigger à la fin de
   l'instruction. Donc, quand la condition <literal>WHEN</literal> d'un
   trigger <literal>AFTER</literal> ne renvoie pas true, il n'est pas
   nécessaire de préparer un événement ou de relire la ligne à la fin de
   l'instruction. Cela peut apporter une amélioration significative des
   performances dans les instructions qui modifient de nombreuses lignes, si
   le trigger a besoin d'être déclencher pour quelques lignes.
  </para>

  <para>
   Dans les versions de <productname>PostgreSQL</productname> antérieures à la
   7.3, il était nécessaire de déclarer un type <type>opaque</type> de 
   retour pour les fonctions déclencheur, plutôt que <type>trigger</type>. Pour
   pouvoir charger d'anciens fichiers de sauvegarde,
   <command>CREATE TRIGGER</command> accepte qu'une fonction déclare une valeur de retour de type
   <type>opaque</type>, mais il affiche un message d'avertissement et change le
   type de retour déclaré en <type>trigger</type>.
  </para>
 </refsect1>

 <refsect1 id="r1-sql-createtrigger-examples">
  <title>Exemples</title>

  <para>
   Exécutez la fonction <function>check_account_update</function> quand une
   ligne de la table <literal>accounts</literal> est sur le point d'être mise
   à jour&nbsp;:

<programlisting>
CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    EXECUTE PROCEDURE check_account_update();
</programlisting>

   Idem, mais avec une exécution de la fonction seulement si la colonne
   <literal>balance</literal> est spécifiée comme cible de la commande
   <command>UPDATE</command>&nbsp;:

<programlisting>
CREATE TRIGGER check_update
    BEFORE UPDATE OF balance ON accounts
    FOR EACH ROW
    EXECUTE PROCEDURE check_account_update();
</programlisting>

   Cette forme exécute la fonction seulement si la colonne
   <literal>balance</literal> a réellement changé de valeur&nbsp;:

<programlisting>
CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.balance IS DISTINCT FROM NEW.balance)
    EXECUTE PROCEDURE check_account_update();
</programlisting>

   Appelle une fonction pour tracer les mises à jour de la table
   <literal>accounts</literal>, mais seulement si quelque chose a changé&nbsp;:

<programlisting>
CREATE TRIGGER log_update
    AFTER UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.* IS DISTINCT FROM NEW.*)
    EXECUTE PROCEDURE log_account_update();
</programlisting>

   Execute the function <function>view_insert_row</function> for each row to insert
   rows into the tables underlying a view:

<programlisting>
CREATE TRIGGER view_insert
    INSTEAD OF INSERT ON my_view
    FOR EACH ROW
    EXECUTE PROCEDURE view_insert_row();
</programlisting>
  </para>

  <para>
   <xref linkend="trigger-example"/> contient un exemple complet d'une
   fonction trigger écrit en C.
  </para>
 </refsect1>

 <refsect1 id="sql-createtrigger-compatibility">
  <title>Compatibilité</title>

  <para>
   L'instruction <command>CREATE TRIGGER</command> de
   <productname>PostgreSQL</productname> implante un sous-ensemble du standard
   <acronym>SQL</acronym>. Les fonctionnalités manquantes sont&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      SQL permet de définir des alias pour les lignes
      <quote>old</quote> et <quote>new</quote> ou pour les tables utilisée
      dans la définition des actions déclenchées (c'est-à-dire
      <literal>CREATE TRIGGER ... ON nomtable REFERENCING OLD ROW AS unnom NEW ROW AS unautrenom...</literal>).
      <productname>PostgreSQL</productname> autorise
      l'écriture de procédures de déclencheurs dans tout langage
      l'utilisateur. De ce fait, l'accès aux données est géré spécifiquement pour
      chaque langage.
     </para>
    </listitem>

    <listitem>
     <para>
      <productname>PostgreSQL</productname> n'autorise comme action déclenchée
      que l'exécution d'une fonction utilisateur. Le standard SQL, en revanche,
      autorise l'exécution d'autres commandes SQL, telles que
      <command>CREATE TABLE</command>. Cette limitation de <productname>PostgreSQL</productname>
      peut être facilement contournée par la création d'une fonction
      utilisateur qui exécute les commandes désirées.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Le standard SQL définit l'ordre de création comme ordre de lancement
   des déclencheurs multiples. <productname>PostgreSQL</productname> utilise
   l'ordre alphabétique de leur nom, jugé plus pratique.
  </para>

  <para>
   Le standard SQL précise que les déclencheurs <literal>BEFORE DELETE</literal> sur des
   suppressions en cascade se déclenchent <emphasis>après</emphasis> la fin du
   <literal>DELETE</literal> en cascade. 
   <productname>PostgreSQL</productname> définit que <literal>BEFORE DELETE</literal>
   se déclenche toujours avant l'action de suppression, même lors
   d'une action en cascade. Cela semble plus cohérent. Il existe aussi un
   comportement non standard quand les triggers <literal>BEFORE</literal>
   modifient les lignes ou empêchent les mises à jour causées par une action
   référente. Ceci peut amener à des violations de contraintes ou au stockage
   de données qui n'honorent pas la contrainte référentielle.
  </para>

  <para>
   La capacité à préciser plusieurs actions pour un seul déclencheur avec
   <literal>OR</literal> est une extension <productname>PostgreSQL</productname>.
  </para>

  <para>
   La possibilité d'exécuter un trigger suite à une commande
   <command>TRUNCATE</command> est une extension
   <productname>PostgreSQL</productname> du standard SQL, as is the
   ability to define statement-level triggers on views.
  </para>

  <para>
   <command>CREATE CONSTRAINT TRIGGER</command> is a
   <productname>PostgreSQL</productname> extension of the <acronym>SQL</acronym>
   standard.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createfunction"/></member>
   <member><xref linkend="sql-altertrigger"/></member>
   <member><xref linkend="sql-droptrigger"/></member>
   <member><xref linkend="sql-set-constraints"/></member>
  </simplelist>
 </refsect1>
</refentry>
