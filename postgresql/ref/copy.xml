<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060616 -->

<refentry id="sql-copy">
 <refmeta>
  <refentrytitle>COPY</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>COPY</refname>
  <refpurpose>Copier des données depuis/vers un fichier vers/depuis une table</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
COPY <replaceable class="parameter">nom_table</replaceable> [ ( <replaceable class="parameter">nom_colonne</replaceable> [, ...] ) ]
    FROM { '<replaceable class="parameter">nom_fichier</replaceable>' | STDIN }
    [ [ WITH ] ( <replaceable class="parameter">option</replaceable> [, ...] ) ]

COPY { <replaceable class="parameter">nom_table</replaceable> [ ( <replaceable class="parameter">nom_colonne</replaceable> [, ...] ) ] | ( <replaceable class="parameter">requête</replaceable> ) }
    TO { '<replaceable class="parameter">nom_fichier</replaceable>' | STDOUT }
    [ [ WITH ] ( <replaceable class="parameter">option</replaceable> [, ...] ) ]

<phrase>où <replaceable class="parameter">option</replaceable> fait partie
de&nbsp;:</phrase>

    FORMAT <replaceable class="parameter">nom_format</replaceable>
    OIDS [ <replaceable class="parameter">oids</replaceable> ]
    DELIMITER '<replaceable class="parameter">caractère_délimiteur</replaceable>'
    NULL '<replaceable class="parameter">chaîne_null</replaceable>'
    HEADER [ <replaceable class="parameter">booléean</replaceable> ]
    QUOTE '<replaceable class="parameter">caractère_guillemet</replaceable>'
    ESCAPE '<replaceable class="parameter">caractère_échappement</replaceable>'
    FORCE_QUOTE { ( <replaceable class="parameter">nom_colonne</replaceable> [, ...] ) | * }
    FORCE_NOT_NULL ( <replaceable class="parameter">nom_colonne</replaceable> [, ...] ) |
    ENCODING '<replaceable class="parameter">nom_encodage</replaceable>'
</synopsis>
 </refsynopsisdiv>
 
 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-copy">
   <primary>COPY</primary>
  </indexterm>

  <para>
   <command>COPY</command> transfère des données entre les tables de
   <productname>PostgreSQL</productname> et les fichiers du système de
   fichiers standard. <command>COPY TO</command> copie le contenu d'une table
   <emphasis>vers</emphasis> un fichier tandis que <command>COPY FROM</command> copie
   des données <emphasis>depuis</emphasis> un fichier vers une table (ajoutant les
   données à celles déjà dans la table). <command>COPY TO</command>
   peut aussi copier le résultat d'une requête <command>SELECT</command>.
  </para>

  <para>
   Si une liste de colonnes est précisée, <command>COPY</command> ne copie
   que les données des colonnes spécifiées vers ou depuis le fichier.
   <command>COPY FROM</command> insère les valeurs par défaut des
   colonnes qui ne sont pas précisées dans la liste.
  </para>

  <para>
   Si un nom de fichier est précisé, <command>COPY</command> lit ou écrit
   directement dans le fichier. Ce fichier doit être accessible par le
   serveur et son nom doit être spécifié du point de vue du serveur.
   Si <literal>STDIN</literal> ou <literal>STDOUT</literal> est indiqué,
   les données sont transmises au travers de la connexion entre le client et
   le serveur.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom_table</replaceable></term>
    <listitem>
     <para>
     Le nom de la table (éventuellement qualifié du nom du schéma).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_colonne</replaceable></term>
     <listitem>
     <para>
      Une liste optionnelle de colonnes à copier. Sans précision,
      toutes les colonnes de la table seront copiées.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">requête</replaceable></term>
    <listitem>
     <para>
      Une commande <xref linkend="sql-select"/> ou
      <xref linkend="sql-values"/> dont les résultats
      doivent être copiés. Notez que les parenthèses sont requises autour de la
      requête.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_fichier</replaceable></term>
    <listitem>
     <para>
      Le chemin absolu du fichier en entrée ou en sortie. Les utilisateurs sous
      Windows peuvent avoir besoin d'utiliser une chaîne <literal>E''</literal>
      et de doubler tous les antislashs utilisés comme
      séparateurs de chemin.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>STDIN</literal></term>
    <listitem>
     <para>
      Les données en entrée proviennent de l'application cliente.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>STDOUT</literal></term>
    <listitem>
     <para>
      Les données en sortie vont sur l'application cliente.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">boolean</replaceable></term>
    <listitem>
     <para>
      Spécifie si l'option sélectionnée doit être activée ou non. Vous pouvez
      écrire <literal>TRUE</literal>, <literal>ON</literal> ou
      <literal>1</literal> pour activer l'option, et <literal>FALSE</literal>,
      <literal>OFF</literal> ou <literal>0</literal> pour la désactiver. La
      valeur <replaceable class="parameter">boolean</replaceable> peut aussi
      être omise, auquel cas la valeur <literal>TRUE</literal> est prise en
      compte.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORMAT</literal></term>
    <listitem>
     <para>
      Sélectionne le format des données pour la lecture ou l'écriture&nbsp;:
      <literal>text</literal>,
      <literal>csv</literal> (valeurs séparées par des virgules),
      ou <literal>binary</literal>.
      la valeur par défaut est <literal>text</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OIDS</literal></term>
    <listitem>
     <para>
      Copie l'OID de chaque ligne. Une erreur est rapportée si
      <literal>OIDS</literal> est utilisé pour une table qui ne possède pas
      d'OID, ou dans le cas de la copie du résultat d'une <replaceable
      class="parameter">requête</replaceable>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DELIMITER</literal></term>
    <listitem>
     <para>
      Spécifie le caractère qui sépare les colonnes sur chaque ligne du
      fichier. La valeur par défaut est une tabulation dans le format texte et
      une virgule dans le format <literal>CSV</literal>. Il doit être un
      seul caractère sur un seul octet. Cette option n'est pas autorisée lors
      de l'utilisation du format <literal>binary</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NULL</literal></term>
    <listitem>
     <para>
      Spécifie la chaîne qui représente une valeur NULL. La valeur par défaut
      est <literal>\N</literal> (antislash-N) dans le format texte et une
      chaîne vide sans guillemets dans le format <literal>CSV</literal>. Vous
      pouvez préférer une chaîne vide même dans le format texte pour les cas
      où vous ne voulez pas distinguer les valeurs NULL des chaînes vides.
      Cette option n'est pas autorisée lors de l'utilisation du format
      <literal>binary</literal>.
     </para>

     <note>
      <para>
       Lors de l'utilisation de <command>COPY FROM</command>, tout élément de données
       qui correspond à cette chaîne est stocké comme valeur NULL. Il est donc utile
       de s'assurer que c'est la même chaîne que celle précisée pour le 
       <command>COPY TO</command> qui est utilisée.
      </para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>HEADER</literal></term>
    <listitem>
     <para>
      Le fichier contient une ligne d'en-tête avec les noms de chaque
      colonne. En sortie, la première ligne contient les noms de
      colonne de la table. En entrée, elle est ignorée. Cette option n'est
      autorisée que lors de l'utilisation du format <literal>CSV</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>QUOTE</literal></term>
    <listitem>
     <para>
      Spécifie le caractère guillemet à utiliser lorsqu'une valeur doit être
      entre guillemets. Par défaut, il s'agit du guillemet double. Cela doit
      de toute façon être un seul caractère sur un seul octet. Cette option
      n'est autorisée que lors de l'utilisation du format
      <literal>CSV</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ESCAPE</literal></term>
    <listitem>
     <para>
      Spécifie le caractère qui doit apparaître avant un caractère de données
      qui correspond à la valeur <literal>QUOTE</literal>. La valeur par
      défaut est la même que la valeur <literal>QUOTE</literal> (du coup,
      le caractère guillemet est doublé s'il apparaît dans les données). Cela
      doit être un seul caractère codé en un seul octet. Cette option n'est
      autorisée que lors de l'utilisation du format <literal>CSV</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORCE_QUOTE</literal></term>
    <listitem>
     <para>
      Force l'utilisation des guillemets pour toutes les valeurs non
      <literal>NULL</literal> dans chaque colonne spécifiée. La sortie
      <literal>NULL</literal> n'est jamais entre guillemets. Si
      <literal>*</literal> est indiqué, les valeurs non <literal>NULL</literal>
      seront entre guillemets pour toutes les colonnes. Cette option est
      seulement autorisée avec <command>COPY TO</command> et seulement quand
      le format <literal>CSV</literal> est utilisé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORCE_NOT_NULL</literal></term>
    <listitem>
     <para>
      Ne fait pas correspondre les valeurs des colonnes spécifiées avec la
      chaîne nulle. Dans le cas par défaut où la chaîne nulle est vide, cela
      signifie que les valeurs vides seront lues comme des chaînes de longueur
      nulle plutôt que comme des NULL, même si elles ne sont pas entre
      guillemets. Cette option est seulement autorisée avec <command>COPY
      FROM</command> et seulement quand le format <literal>CSV</literal> est
      utilisé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ENCODING</literal></term>
    <listitem>
     <para>
      Spécifie que le fichier est dans l'encodage <replaceable
      class="parameter">nom_encodage</replaceable>. Si cette option est omis,
      l'encodage client par défaut est utilisé. Voir la partie Notes ci-dessous
      pour plus de détails.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Affichage</title>

  <para>
   En cas de succès, une commande <command>COPY</command> renvoie une balise
   de la forme
<screen>
COPY <replaceable class="parameter">nombre</replaceable>
</screen>
   Le <replaceable class="parameter">nombre</replaceable> correspond au nombre
   de lignes copiées.
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

   <para>
    <command>COPY</command> ne peut être utilisé qu'avec des tables réelles,
    pas avec des vues. Néanmoins, vous pouvez écrire <literal>COPY (SELECT * FROM
    <replaceable class="parameter">nom_vue</replaceable>) TO ...</literal>.
   </para>

   <para>
    <command>COPY</command> gère seulement la table nommée&nbsp;; cette
    commande ne copie pas les données provenant ou vers des tables filles.
    Donc, par exemple, <literal>COPY <replaceable
    class="parameter">table</replaceable> TO</literal> affiche les mêmes
    données que <literal>SELECT * FROM ONLY <replaceable
    class="parameter">table</replaceable></literal>. Mais <literal>COPY
    (SELECT * FROM <replaceable class="parameter">table</replaceable>) TO ...</literal>
    peut être utilisé pour sauvegarder toutes les données d'un héritage.
   </para>

   <para>
    Le droit SELECT est requis sur la table dont les valeurs sont
    lues par <command>COPY TO</command> et le droit INSERT sur la table dont les
    valeurs sont insérées par <command>COPY FROM</command>. Il est suffisant
    d'avoir des droits sur les colonnes listées dans la commande.
   </para>

   <para>
    Les fichiers nommés dans une commande <command>COPY</command> sont lus ou
    écrits directement par le serveur, non par l'application cliente. De ce fait,
    la machine hébergeant le serveur de
    bases de données doit les héberger ou pouvoir y accéder.
    L'utilisateur <productname>PostgreSQL</productname> (l'identifiant de
    l'utilisateur qui exécute le serveur), non le client, doit pouvoir
    y accéder et les lire ou les modifier.
    L'utilisation de <command>COPY</command> avec un fichier n'est autorisé qu'aux
    superutilisateurs de la base de données car <command>COPY</command> autorise la lecture et
    l'écriture de tout fichier accessible au serveur.
   </para>

   <para>
    Il ne faut pas confondre <command>COPY</command> et l'instruction
    <command><link linkend="APP-PSQL-meta-commands-copy">\copy</link></command>
    de <application>psql</application>.
    <command>\copy</command> appelle <command>COPY FROM STDIN</command> ou
    <command>COPY TO STDOUT</command>, puis lit/stocke les données dans un
    fichier accessible au client <application>psql</application>. 
    L'accès au fichier et les droits d'accès dépendent alors du client et non du
    serveur.
   </para>

   <para>
    Il est recommandé que le chemin absolu du fichier utilisé dans
    <command>COPY</command> soit toujours précisé. Ceci
    est assuré par le serveur dans le cas d'un <command>COPY TO</command>
    mais, pour les <command>COPY FROM</command>, il est possible de
    lire un fichier spécifié par un chemin relatif. Le chemin est
    interprété relativement au répertoire de travail du processus serveur
    (habituellement dans le répertoire des données), pas par rapport au répertoire
    de travail du client.
   </para>

   <para>
    <command>COPY FROM</command> appelle tous les déclencheurs et 
    contraintes de vérification sur la table de destination, mais pas les
    règles.
   </para>

   <para>
    L'entrée et la sortie de <command>COPY</command> sont sensibles à
    <varname>datestyle</varname>. Pour assurer la portabilité vers
    d'autres installations de <productname>PostgreSQL</productname> qui
    éventuellement utilisent des paramétrages <varname>datestyle</varname>
    différents de ceux par défaut, il est préférable de configurer
    <varname>datestyle</varname> en <literal>ISO</literal> avant d'utiliser
    <command>COPY TO</command>. Éviter d'exporter les données avec le
    <varname>IntervalStyle</varname> configuré à <literal>sql_standard</literal>
    est aussi une bonne idée car les valeurs négatives d'intervalles pourraient
    être mal interprétées par un serveur qui a une autre configuration pour
    <varname>IntervalStyle</varname>.
   </para>

   <para>
    Les données en entrée sont interprétées suivant la clause
    <literal>ENCODING</literal> ou suivant l'encodage actuel du
    client. Les données en sortie sont codées suivant la clause
    <literal>ENCODING</literal> ou suivant l'encodage actuel du
    client. Ceci est valable même si les données ne passent pas par le client,
    c'est-à-dire si elles sont lues et écrites directement sur un fichier du
    serveur.
   </para>

   <para>
    <command>COPY</command> stoppe l'opération à la première erreur. Si cela ne
    porte pas à conséquence dans le cas d'un <command>COPY TO</command>, il en va
    différemment dans le cas d'un <command>COPY FROM</command>. Dans ce cas, la table cible
    a déjà reçu les lignes précédentes. Ces lignes ne sont ni visibles, ni accessibles,
    mais occupent de l'espace disque. Il peut en résulter une perte importante 
    d'espace disque si l'échec se produit lors d'une copie volumineuse.
    L'espace perdu peut alors être récupéré avec la commande <command>VACUUM</command>.
   </para>

   <para>
    Les données en entrée sont interprétées suivant l'encodage actuel du
    client et les données en sortie sont encodées suivant l'encodage client
    même si les données ne passent pas par le client mais sont lues à partir
    d'un fichier ou écrites dans un fichier.
   </para>

 </refsect1>

 <refsect1>
  <title>Formats de fichiers</title>

  <refsect2>
   <title>Format texte</title>

   <para>
    Quand le format <literal>text</literal> est utilisé, les données sont lues
    ou écrites dans un 
    fichier texte, chaque ligne correspondant à une ligne de la table. Les colonnes
    sont séparées, dans une ligne, par le caractère de délimitation. Les valeurs
    des colonnes sont des chaînes, engendrées par la fonction de sortie ou utilisables
    par celle d'entrée, correspondant au type de données des attributs. La chaîne 
    de spécification des valeurs NULL est utilisée en lieu et place des valeurs nulles.
    <command>COPY FROM</command> lève une erreur si une ligne du fichier ne contient
    pas le nombre de colonnes attendues. Si <literal>OIDS</literal> est précisé, 
    l'OID est lu ou écrit dans la première colonne, avant celles des données utilisateur.
   </para>

   <para>
    La fin des données peut être représentée par une ligne ne contenant
    qu'un antislash et un point (<literal>\.</literal>). Ce marqueur de fin de
    données n'est pas nécessaire lors de la lecture d'un fichier, la fin du
    fichier tenant ce rôle. Il n'est réellement nécessaire que lors d'une copie de
    données vers ou depuis une application cliente qui utilise un protocole
    client antérieur au 3.0.
   </para>

   <para>
    Les caractères antislash (<literal>\</literal>) peuvent être utilisés dans les
    données de <command>COPY</command> pour échapper les caractères qui,
    sans cela, seraient considérés comme des délimiteurs de ligne ou de
    colonne. Les caractères suivants, en particulier, <emphasis>doivent</emphasis> être
    précédés d'un antislash s'ils apparaissent dans la
    valeur d'une colonne&nbsp;: l'antislash lui-même, le saut de ligne, le retour
    chariot et le délimiteur courant.
   </para>

   <para>
    La chaîne NULL spécifiée est envoyée par <command>COPY TO</command> sans
    ajout d'antislash&nbsp;; au contraire, <command>COPY FROM</command>
    teste l'entrée au regard de la chaîne NULL avant la suppression des antislash.
    Ainsi, une chaîne NULL telle que <literal>\N</literal> ne peut pas être
    confondue avec la valeur de donnée réelle <literal>\N</literal> 
    (représentée dans ce cas par <literal>\\N</literal>).
   </para>

   <para>
    Les séquences spéciales suivantes sont reconnues par <command>COPY FROM</command>&nbsp;:

   <informaltable>
    <tgroup cols="2">
     <colspec colnum="1" colwidth="1*"/>
     <colspec colnum="2" colwidth="2*"/>
     <thead>
      <row>
       <entry>Séquence</entry>
       <entry>Représente</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\b</literal></entry>
       <entry>Retour arrière (<foreignphrase>backspace</foreignphrase>) (ASCII 8)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>Retour chariot (ASCII 12)</entry>
      </row>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>Nouvelle ligne (ASCII 10)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>Retour chariot (ASCII 13)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>Tabulation (ASCII 9)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>Tabulation verticale (ASCII 11)</entry>
      </row>
      <row>
       <entry><literal>\</literal><replaceable>chiffres</replaceable></entry>
       <entry>Antislash suivi d'un à trois chiffres en octal représente le
	 caractère qui possède ce code numérique</entry>
      </row>
      <row>
       <entry><literal>\x</literal><replaceable>digits</replaceable></entry>
       <entry>Antislash <literal>x</literal> suivi d'un ou deux chiffres hexadécimaux
        représente le caractère qui possède ce code numérique</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>

    Actuellement, <command>COPY TO</command> n'émet pas de séquence
    octale ou hexadécimale mais utilise les autres séquences listées
    ci-dessus pour les caractères de contrôle.
   </para>

   <para>
    Tout autre caractère précédé d'un antislash se représente lui-même. 
    Cependant, il faut faire attention à ne pas ajouter d'antislash 
    qui ne soit pas absolument nécessaire afin d'éviter le risque
    d'obtenir accidentellement une correspondance avec
    le marqueur de fin de données (<literal>\.</literal>) ou la chaîne NULL
    (<literal>\N</literal> par défaut)&nbsp;; ces chaînes sont reconnues avant tout
    traitement des antislashs.
   </para>

   <para>
    Il est fortement recommandé que les applications qui engendrent des
    données <command>COPY</command> convertissent les données de nouvelle ligne
    et de retour chariot par les séquences respectives <literal>\n</literal> et <literal>\r</literal>.
    A l'heure actuelle, il est possible de représenter un retour chariot par
    un antislash et un retour chariot, et une nouvelle ligne par un antislash
    et une nouvelle ligne. Cependant, il n'est pas certain que ces représentations
    soient encore acceptées dans les prochaines versions. Celles-ci sont, de plus, 
    extrêmement sensibles à la corruption si le fichier de <command>COPY</command>
    est transféré sur d'autres plateformes (d'un Unix vers un Windows ou inversement, par exemple).
   </para>

   <para>
    <command>COPY TO</command> termine chaque ligne par une
    nouvelle ligne de style Unix (<quote><literal>\n</literal></quote>). Les serveurs
    fonctionnant sous Microsoft Windows engendrent un retour chariot/nouvelle ligne
    (<quote><literal>\r\n</literal></quote>), mais uniquement lorsque
    les données engendrées par <command>COPY</command> sont envoyées dans un
    fichier sur le serveur.
    Pour des raisons de cohérence entre les
    plateformes, <command>COPY TO STDOUT</command> envoie toujours
    <quote><literal>\n</literal></quote> quelque soit la plateforme du serveur.
    <command>COPY FROM</command> sait gérer les lignes terminant par une nouvelle
    ligne, un retour chariot ou un retour chariot suivi d'une nouvelle ligne.
    Afin de réduire les risques d'erreurs engendrées par des nouvelles lignes
    ou des retours chariot non précédés d'antislash, considéré de fait comme
    des données, <command>COPY FROM</command> émet un avertissement si les
    fins de lignes ne sont pas toutes identiques.
   </para>
  </refsect2>

  <refsect2>
  <title>Format CSV</title>

  <para>
   Ce format est utilisé pour importer et exporter des données au format 
   de fichier <literal>CSV</literal> (acronyme de
   <foreignphrase>Comma Separated Value</foreignphrase>, littéralement
   valeurs séparées par des virgules). Ce format est utilisé par un grand nombre de
   programmes, tels les tableurs. À la place des règles d'échappement utilisées par le format
   texte standard de <productname>PostgreSQL</productname>, il produit et
   reconnaît le mécanisme d'échappement habituel de CSV.
  </para>

  <para>
   Les valeurs de chaque enregistrement sont séparées par le caractère
   <literal>DELIMITER</literal>. Si la valeur contient ce caractère, le caractère
   <literal>QUOTE</literal>, la chaîne <literal>NULL</literal>, un retour chariot
   ou un saut de ligne, la valeur complète est préfixée et suffixée
   par le caractère <literal>QUOTE</literal>. De plus, toute occurrence du caractère
   <literal>QUOTE</literal> ou du caractère <literal>ESCAPE</literal> est précédée du
   caractère d'échappement. <literal>FORCE QUOTE</literal> peut également être utilisé
   pour forcer les guillemets lors de l'affichage de valeur non-NULL dans
   des colonnes spécifiques.
  </para>

  <para>
    Le format <literal>CSV</literal> n'a pas de façon standard de distinguer
    une valeur <literal>NULL</literal> d'une chaîne vide. La commande <command>COPY</command>
    de <productname>PostgreSQL</productname> gère cela avec les guillemets. Un
    <literal>NULL</literal> est affiché suivant le paramètre <literal>NULL</literal>
    et n'est pas entre guillemets, alors qu'une valeur non <literal>NULL</literal>
    correspondant au paramètre <literal>NULL</literal> est entre guillemets. Par
    exemple, avec la configuration par défaut, un <literal>NULL</literal> est
    écrit avec la chaîne vide sans guillemets alors qu'une chaîne vide est écrit
    avec des guillemets doubles (<literal>""</literal>). La lecture des valeurs
    suit des règles similaires. Vous pouvez utiliser <literal>FORCE NOT
    NULL</literal> pour empêcher les comparaisons d'entrée <literal>NULL</literal>
    pour des colonnes spécifiques.
  </para>

   <para>
    L'antislash n'est pas un caractère spécial dans le format <literal>CSV</literal>.
    De ce fait, le marqueur de fin de données, <literal>\.</literal>, peut apparaître
    dans les donnée. Afin d'éviter toute mauvaise interprétation, une valeur <literal>\.</literal>
    qui apparaît seule sur une ligne est automatiquement placée
    entre guillemets en sortie. En entrée, si elle est entre guillemets, elle
    n'est pas interprétée comme un marqueur de fin de données.
    Lors du chargement d'un fichier qui ne contient qu'une colonne, dont les valeurs ne sont pas placées entre
    guillemets, créé par une autre application, qui contient une valeur 
    <literal>\.</literal>, il est nécessaire de placer cette valeur entre guillemets.
   </para>

   <note>
    <para>
     Dans le format <literal>CSV</literal>, tous les caractères sont significatifs.
     Une valeur entre guillemets entourée d'espaces ou de tout
     autre caractère différent de <literal>DELIMITER</literal> inclut ces caractères.
     Cela peut être source d'erreurs en cas d'import de données à partir d'un système
     qui complète les lignes <literal>CSV</literal> avec des espaces fines pour
     atteindre une longueur fixée. Dans ce cas, il est nécessaire de pré-traiter
     le fichier <literal>CSV</literal> afin de supprimer les espaces de complètement
     avant d'insérer les données dans <productname>PostgreSQL</productname>.
    </para>
   </note>

  <note>
   <para>
    Le format CSV sait reconnaître et produire des fichiers CSV dont les valeurs entre
    guillemets contiennent des retours chariot et des sauts de ligne. De ce fait,
    les fichiers ne contiennent pas strictement une ligne par ligne de table comme
    les fichiers du format texte.
   </para>
  </note>

  <note>
   <para>
    Beaucoup de programmes produisent des fichiers CSV étranges et parfois pervers&nbsp;;
    le format de fichier est donc plus une convention qu'un standard.
    Il est alors possible de rencontrer des fichiers que ce mécanisme ne sait
    pas importer. De plus, <command>COPY</command> peut produire des fichiers 
    inutilisables par d'autres programmes.
   </para>
  </note>

  </refsect2>

  <refsect2>
   <title>Format binaire</title>

   <para>
    Le format <literal>binary</literal> fait que toutes les données sont
    stockées/lues au format binaire plutôt que texte. Il est un peu plus
    rapide que les formats texte et <literal>CSV</literal> mais un fichier au
    format binaire est moins portable suivant les architectures des machines
    et les versions de <productname>PostgreSQL</productname>. De plus, le
    format binaire est très spécifique au type des données&nbsp;; par exemple,
    un export de données binaires d'une colonne <type>smallint</type> ne
    pourra pas être importé dans une colonne <type>integer</type>, même si
    cela aurait fonctionné dans le format texte.
   </para>

   <para>
    Le format de fichier <literal>binary</literal> consiste en un en-tête de
    fichier, zéro ou plusieurs lignes contenant les données de la ligne et
    un bas-de-page du fichier. Les en-têtes et les données sont dans l'ordre
    réseau des octets.
   </para>

   <note>
    <para>
     Les versions de <productname>PostgreSQL</productname> antérieures à la
     7.4 utilisaient un format de fichier binaire différent.
    </para>
   </note>

   <refsect3>
    <title>Entête du fichier</title>

    <para>
     L'en-tête du fichier est constitutée de 15 octets de champs fixes, suivis par une
     aire d'extension de l'en-tête de longueur variable. Les champs fixes
     sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term>Signature</term>
      <listitem>
       <para>
	séquence de 11 octets <literal>PGCOPY\n\377\r\n\0</literal> &mdash;
	l'octet zéro est une partie obligatoire de la signature. La signature est
	conçue pour permettre une identification aisée des fichiers qui ont été
	déteriorés par un transfert non respectueux des huit bits. Cette
	signature est modifiée par les filtres de traduction de fin de ligne,
	la suppression des octets zéro, la suppression des bits de poids forts ou
	la modification de la parité.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Champs de commutateurs</term>
      <listitem>
       <para>
	masque entier de 32 bits décrivant les aspects importants du format de
	fichier. Les bits sont numérotés de 0 (<acronym>LSB</acronym>,
	ou <foreignphrase>Least Significant Bit</foreignphrase>, bit de poids faible) à 31
	(<acronym>MSB</acronym>, ou <foreignphrase>Most Significant Bit</foreignphrase>, bit de poids fort).
	Ce champ est stocké dans l'ordre réseau des octets
	(l'octet le plus significatif en premier), comme le sont tous
	les champs entier utilisés dans le format de fichier. Les bits 16 à 31
	sont réservés aux problèmes critiques de format de
	fichier&nbsp;; tout lecteur devrait annuler l'opération s'il trouve un bit
	inattendu dans cet ensemble. Les bits 0 à 15 sont réservés pour signaler
	les problèmes de compatibilité de formats&nbsp;; un lecteur devrait
	simplement ignorer les bits inattendus dans cet ensemble. Actuellement,
	seul un bit est défini, le reste doit être à zéro&nbsp;:
        <variablelist>
         <varlistentry>
          <term>Bit 16</term>
          <listitem>
           <para>
            si 1, les OID sont inclus dans la donnée&nbsp;; si 0, non
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Longueur de l'aire d'extension de l'en-tête</term>
      <listitem>
       <para>
	entier sur 32 bits, longueur en octets du reste de l'en-tête, octets de 
	stockage de la longueur non-compris. À l'heure actuelle ce champ vaut zéro. La première ligne
	suit immédiatement. De futures modifications du format pourraient
	permettre la présence de données supplémentaires dans l'en-tête. Tout
	lecteur devrait ignorer silencieusement toute donnée de l'extension de
	l'en-tête qu'il ne sait pas traitée.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    </para>

    <para>
     L'aire d'extension de l'en-tête est prévue pour contenir une séquence de morceaux
     s'auto-identifiant. Le champ de commutateurs n'a pas pour but
     d'indiquer aux lecteurs ce qui se trouve dans l'aire d'extension. La
     conception spécifique du contenu de l'extension de l'en-tête est pour
     une prochaine version.
    </para>

    <para>
     Cette conception permet l'ajout d'en-têtes compatible (ajout de
     morceaux d'extension d'en-tête, ou initialisation des octets commutateurs de poids faible)
     et les modifications non compatibles (initialisation des octets commutateurs de
     poids fort pour signaler de telles modifications, et ajout des données de support dans
     l'aire d'extension si nécessaire).
    </para>
   </refsect3>

   <refsect3>
    <title>Tuples</title>
    <para>
     Chaque tuple débute par un compteur, entier codé sur 16 bits, représentant le nombre de champs 
     du tuple. (Actuellement, tous les tuples d'une table ont le même compteur,
     mais il est probable que cela ne soit pas toujours le cas.) On trouve ensuite, 
     répété pour chaque champ du tuple, un mot de 32 bits annonçant le nombre
     d'octets de stockage de la donnée qui suivent. (Ce mot n'inclut pas
     sa longueur propre et peut donc être nul.) -1, cas spécial, indique une
     valeur de champ NULL. Dans ce cas, aucun octet de valeur ne suit.
    </para>

    <para>
     Il n'y a ni complètement d'alignement ni toute autre donnée supplémentaire
     entre les champs.
    </para>

    <para>
     Actuellement, toutes les valeurs d'un fichier d'un format binaire sont
     supposées être dans un format binaire (code de format).
     Il est probable qu'une extension future ajoute un champ d'en-tête
     autorisant la spécification de codes de format par colonne.
    </para>

    <para>
     La consultation du code source de <productname>PostgreSQL</productname>, et en
     particulier les fonctions <function>*send</function> et <function>*recv</function>
     associées à chaque type de données de la colonne, 
     permet de déterminer le format binaire approprié à la donnée réelle.
     Ces fonctions se situent dans le répertoire <filename>src/backend/utils/adt/</filename> des
     sources.
    </para>

    <para>
     Lorsque les OID sont inclus dans le fichier, le champ OID suit immédiatement
     le compteur de champ. C'est un champ normal, à ceci près qu'il n'est pas
     inclus dans le compteur. En fait, il contient un mot de stockage de la longueur
     &mdash; ceci permet de faciliter le passage d'OID sur quatre octets 
     aux OID sur huit octets et permet d'afficher les OID comme étant NULL en cas de besoin.
    </para>
   </refsect3>

   <refsect3>
    <title>Queue du fichier</title>

    <para>
     La fin du fichier consiste en un entier sur 16 bits contenant -1. Cela permet
     de le
     distinguer aisément du compteur de champs d'un tuple.
    </para>

    <para>
     Il est souhaitable que le lecteur rapporte une erreur si le mot compteur de champ ne vaut
     ni -1 ni le nombre attendu de colonnes. Cela assure une vérification
     supplémentaire d'une éventuelle désynchronisation d'avec les
     données.
    </para>
   </refsect3>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Copier une table vers le client en utilisant la barre
   verticale (<literal>|</literal>) comme délimiteur de champ&nbsp;:
<programlisting>COPY pays TO STDOUT (DELIMITER '|');
</programlisting>
  </para>

  <para>
   Copier des données d'un fichier vers la table <literal>pays</literal>&nbsp;:
<programlisting>COPY pays FROM '/usr1/proj/bray/sql/pays_donnees';
</programlisting>
  </para>

  <para>
   Pour copier dans un fichier les pays dont le nom commence par 'A'&nbsp;:
<programlisting>
COPY (SELECT * FROM pays WHERE nom_pays LIKE 'A%') TO '/usr1/proj/bray/sql/une_liste_de_pays.copy';
</programlisting>
  </para>

  <para>
   Exemple de données convenables pour une copie vers une table depuis
   <literal>STDIN</literal>&nbsp;:
<programlisting>AF      AFGHANISTAN
AL      ALBANIE
DZ      ALGERIE
ZM      ZAMBIE
ZW      ZIMBABWE
</programlisting>
   L'espace sur chaque ligne est en fait un caractère de
   tabulation.
  </para>

  <para>
   Les mêmes données, extraites au format binaire. Les données sont
   affichées après filtrage au travers de l'outil Unix <command>od -c</command>. La
   table a trois colonnes&nbsp;; la première est de type <type>char(2)</type>,
   la deuxième de type <type>text</type> et la troisième de type <type>integer</type>.
   Toutes les lignes ont une valeur NULL sur la troisième colonne.
<programlisting>0000000   P   G   C   O   P   Y  \n 377  \r  \n  \0  \0  \0  \0  \0  \0
0000020  \0  \0  \0  \0 003  \0  \0  \0 002   A   F  \0  \0  \0 013   A
0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \0 003
0000060  \0  \0  \0 002   A   L  \0  \0  \0 007   A   L   B   A   N   I
0000100   E 377 377 377 377  \0 003  \0  \0  \0 002   D   Z  \0  \0  \0
0000120 007   A   L   G   E   R   I   E 377 377 377 377  \0 003  \0  \0
0000140  \0 002   Z   M  \0  \0  \0 006   Z   A   M   B   I   E 377 377
0000160 377 377  \0 003  \0  \0  \0 002   Z   W  \0  \0  \0  \b   Z   I
0000200   M   B   A   B   W   E 377 377 377 377 377 377
</programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Il n'existe pas d'instruction <command>COPY</command> dans le standard SQL.
  </para>

  <para>
   La syntaxe suivante était utilisée avant <productname>PostgreSQL</productname>
   9.0 et est toujours supportée&nbsp;:

<synopsis>COPY <replaceable class="parameter">nomtable</replaceable> [ ( <replaceable class="parameter">colonne</replaceable> [, ...] ) ]
    FROM { '<replaceable class="parameter">nomfichier</replaceable>' | STDIN }
    [ [ WITH ] 
        [ BINARY ] 
	[ OIDS ]
	[ DELIMITER [ AS ] '<replaceable class="parameter">délimiteur</replaceable>' ]
	[ NULL [ AS ] '<replaceable class="parameter">chaîne NULL</replaceable>' ]
	[ CSV [ HEADER ]
	      [ QUOTE [ AS ] '<replaceable class="parameter">guillemet</replaceable>' ] 
	      [ ESCAPE [ AS ] '<replaceable class="parameter">échappement</replaceable>' ]
	      [ FORCE NOT NULL <replaceable class="parameter">colonne</replaceable> [, ...] ] ] ]

COPY { <replaceable class="parameter">nomtable</replaceable> [ ( <replaceable class="parameter">colonne</replaceable> [, ...] ) ] | ( <replaceable class="parameter">requête</replaceable> ) }
    TO { '<replaceable class="parameter">nomfichier</replaceable>' | STDOUT }
    [ [ WITH ] 
        [ BINARY ]
	[ OIDS ]
	[ DELIMITER [ AS ] '<replaceable class="parameter">délimiteur</replaceable>' ]
	[ NULL [ AS ] '<replaceable class="parameter">chaîne NULL</replaceable>' ]
	[ CSV [ HEADER ]
	      [ QUOTE [ AS ] '<replaceable class="parameter">guillemet</replaceable>' ] 
	      [ ESCAPE [ AS ] '<replaceable class="parameter">échappement</replaceable>' ]
	      [ FORCE QUOTE <replaceable class="parameter">colonne</replaceable> [, ...] | * } ] ] ]
</synopsis>

   Notez que, dans cette syntaxe, <literal>BINARY</literal> et
   <literal>CSV</literal> sont traités comme des mots-clés indépendants, pas
   comme des arguments à l'option <literal>FORMAT</literal>.
  </para>

  <para>
   La syntaxe suivante, utilisée avant <productname>PostgreSQL</productname>
   version 7.3, est toujours supportée&nbsp;:

<synopsis>COPY [ BINARY ] <replaceable class="parameter">nom_table</replaceable> [ WITH OIDS ]
    FROM { '<replaceable class="parameter">nom_fichier</replaceable>' | STDIN }
    [ [USING] DELIMITERS '<replaceable class="parameter">caractère_délimiteur</replaceable>' ]
    [ WITH NULL AS '<replaceable class="parameter">chaîne NULL</replaceable>' ]

COPY [ BINARY ] <replaceable class="parameter">nom_table</replaceable> [ WITH OIDS ]
    TO { '<replaceable class="parameter">nom_fichier</replaceable>' | STDOUT }
    [ [USING] DELIMITERS '<replaceable class="parameter">caractère_délimiteur</replaceable>' ]
    [ WITH NULL AS '<replaceable class="parameter">chaîne NULL</replaceable>' ]
</synopsis>
  </para>
 </refsect1>
</refentry>
