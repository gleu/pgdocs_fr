<?xml version="1.0" encoding="UTF-8"?>
<refentry id="sql-copy">
 <indexterm zone="sql-copy">
  <primary>COPY</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>COPY</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>COPY</refname>
  <refpurpose>Copier des données depuis/vers un fichier vers/depuis une table</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <synopsis>
COPY <replaceable class="parameter">nom_table</replaceable> [ ( <replaceable class="parameter">nom_colonne</replaceable> [, ...] ) ]
    FROM { '<replaceable class="parameter">nom_fichier</replaceable>' | PROGRAM '<replaceable class="parameter">commande</replaceable>' | STDIN }
    [ [ WITH ] ( <replaceable class="parameter">option</replaceable> [, ...] ) ]
    [ WHERE <replaceable class="parameter">condition</replaceable> ]

COPY { <replaceable class="parameter">nom_table</replaceable> [ ( <replaceable class="parameter">nom_colonne</replaceable> [, ...] ) ] | ( <replaceable class="parameter">requête</replaceable> ) }
    TO { '<replaceable class="parameter">nom_fichier</replaceable>' | PROGRAM '<replaceable class="parameter">commande</replaceable>' | STDOUT }
    [ [ WITH ] ( <replaceable class="parameter">option</replaceable> [, ...] ) ]

<phrase>où <replaceable class="parameter">option</replaceable> fait partie
de&nbsp;:</phrase>

    FORMAT <replaceable class="parameter">nom_format</replaceable>
    FREEZE [ <replaceable class="parameter">booléen</replaceable> ]
    DELIMITER '<replaceable class="parameter">caractère_délimiteur</replaceable>'
    NULL '<replaceable class="parameter">chaîne_null</replaceable>'
    HEADER [ <replaceable class="parameter">booléen</replaceable> ]
    QUOTE '<replaceable class="parameter">caractère_guillemet</replaceable>'
    ESCAPE '<replaceable class="parameter">caractère_échappement</replaceable>'
    FORCE_QUOTE { ( <replaceable class="parameter">nom_colonne</replaceable> [, ...] ) | * }
    FORCE_NOT_NULL ( <replaceable class="parameter">nom_colonne</replaceable> [, ...] )
    FORCE_NULL ( <replaceable class="parameter">nom_colonne</replaceable> [, ...] )
    ENCODING '<replaceable class="parameter">nom_encodage</replaceable>'
  </synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>COPY</command> transfère des données entre les tables de
   <productname>PostgreSQL</productname> et les fichiers du système de
   fichiers standard. <command>COPY TO</command> copie le contenu d'une table
   <emphasis>vers</emphasis> un fichier tandis que <command>COPY FROM</command> copie
   des données <emphasis>depuis</emphasis> un fichier vers une table (ajoutant les
   données à celles déjà présentes dans la table). <command>COPY TO</command>
   peut aussi copier le résultat d'une requête <command>SELECT</command>.
  </para>

  <para>
   Si une liste de colonnes est indiquée, <command>COPY TO</command> copie
   seulement les données des colonnes spécifiées dans le fichier. Pour
   <command>COPY FROM</command>, chaque champ du fichier est inséré, dans
   l'ordre, dans la colonne spécifiée. Les colonnes de la table non spécifiées
   dans la liste de colonnes de <command>COPY FROM</command> recevront leur
   valeur par défaut.
  </para>

  <para>
   La commande <command>COPY</command> avec un nom de fichier force
   <productname>PostgreSQL</productname> à lire ou écrire directement
   dans un fichier. Il doit être accessible par l'utilisateur
   <productname>PostgreSQL</productname> (l'utilisateur exécutant le serveur)
   et le nom doit être spécifié du point de vue du serveur. Quand
   <literal>PROGRAM</literal> est indiqué, le serveur exécute la commande
   donnée, et lit la sortie standard du programme ou écrit dans l'entrée
   standard du programme. La commande doit être spécifiée du point de vue
   du serveur, et être exécutable par l'utilisateur
   <productname>PostgreSQL</productname>.
   Si <literal>STDIN</literal> ou <literal>STDOUT</literal> est indiqué,
   les données sont transmises au travers de la connexion entre le client et
   le serveur.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom_table</replaceable></term>
    <listitem>
     <para>
      Le nom de la table (éventuellement qualifié du nom du schéma).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_colonne</replaceable></term>
    <listitem>
     <para>
      Une liste optionnelle de colonnes à copier. Sans précision,
      toutes les colonnes de la table seront copiées.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">requête</replaceable></term>
    <listitem>
     <para>
      Une commande <xref linkend="sql-select"/>, <xref linkend="sql-values"/>,
      <xref linkend="sql-insert"/>, <xref linkend="sql-update"/> ou
      <xref linkend="sql-delete"/> dont les résultats sont à copier.
      Notez que des parenthèses sont requises autour de la requête.
     </para>
     <para>
      Pour les requêtes <command>INSERT</command>, <command>UPDATE</command> et
      <command>DELETE</command>, une clause RETURNING doit être fournie, et
      la relation cible ne doit avoir ni règle conditionnelle, ni règle
      <literal>ALSO</literal>, ni règle <literal>INSTEAD</literal> qui
      ajoute plusieurs requêtes.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_fichier</replaceable></term>
    <listitem>
     <para>
      Le chemin vers le fichier en entrée ou en sortie. Un nom de fichier en
      entrée peut avoir un chemin absolu ou relatif mais un nom de fichier en
      sortie doit absolument avoir un chemin absolu. Les utilisateurs Windows
      peuvent avoir besoin d'utiliser la syntaxe <literal>E''</literal> et de
      doubler tous les antislashs utilisés dans le nom du chemin.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>PROGRAM</literal></term>
    <listitem>
     <para>
      Une commande à exécuter. Avec <command>COPY FROM</command>, l'entrée est
      lue de la sortie standard de la commande alors qu'avec <command>COPY
       TO</command>, la sortie est écrite dans l'entrée standard de la commande.
     </para>
     <para>
      Notez que la commande est appelée par le shell. Si vous avez besoin de
      passer à la commande shell des arguments qui viennent d'une source sans
      confiance, vous devez faire particulièrement attention à supprimer ou
      échapper tous les caractères spéciaux qui pourraient avoir une
      signification particulière pour le shell. Pour des raisons de sécurité,
      il est préférable d'utiliser une chaîne de commande fixe ou, tout du moins,
      d'éviter de lui passer une entrée utilisateurq.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>STDIN</literal></term>
    <listitem>
     <para>
      Les données en entrée proviennent de l'application cliente.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>STDOUT</literal></term>
    <listitem>
     <para>
      Les données en sortie vont sur l'application cliente.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">boolean</replaceable></term>
    <listitem>
     <para>
      Spécifie si l'option sélectionnée doit être activée ou non. Vous pouvez
      écrire <literal>TRUE</literal>, <literal>ON</literal> ou
      <literal>1</literal> pour activer l'option, et <literal>FALSE</literal>,
      <literal>OFF</literal> ou <literal>0</literal> pour la désactiver. La
      valeur <replaceable class="parameter">boolean</replaceable> peut aussi
      être omise, auquel cas la valeur <literal>TRUE</literal> est prise en
      compte.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORMAT</literal></term>
    <listitem>
     <para>
      Sélectionne le format des données pour la lecture ou l'écriture&nbsp;:
      <literal>text</literal>,
      <literal>csv</literal> (valeurs séparées par des virgules),
      ou <literal>binary</literal>.
      la valeur par défaut est <literal>text</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FREEZE</literal></term>
    <listitem>
     <para>
      Demande la copie des données dans des lignes déjà gelées (donc dans le même
      état qu'après un <command>VACUUM FREEZE</command>). Ceci est une option de
      performance pour un chargement initial des données. Les lignes seront
      gelées seulement si la table en cours de chargement a été créée ou
      tronquée dans la même sous-transaction, qu'il n'y a pas de curseurs ouverts
      ou d'anciennes images de la base de données détenus par cette transaction.
      Il n'est actuellement pas possible de réaliser un <command>COPY FREEZE</command>
      sur une table partitionnée.
     </para>
     <para>
      Notez que toutes les autres sessions seront immédiatement capables de voir
      les données une fois qu'elles auront été chargées. Ceci viole les règles
      habituelles de la visibilité d'après MVCC. Les utilisateurs intéressées
      par cette option doivent être conscients des problèmes potentiels que cela
      peut poser.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DELIMITER</literal></term>
    <listitem>
     <para>
      Spécifie le caractère qui sépare les colonnes sur chaque ligne du
      fichier. La valeur par défaut est une tabulation dans le format texte et
      une virgule dans le format <literal>CSV</literal>. Il doit être un
      seul caractère sur un seul octet. Cette option n'est pas autorisée lors
      de l'utilisation du format <literal>binary</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NULL</literal></term>
    <listitem>
     <para>
      Spécifie la chaîne qui représente une valeur NULL. La valeur par défaut
      est <literal>\N</literal> (antislash-N) dans le format texte et une
      chaîne vide sans guillemets dans le format <literal>CSV</literal>. Vous
      pouvez préférer une chaîne vide même dans le format texte pour les cas
      où vous ne voulez pas distinguer les valeurs NULL des chaînes vides.
      Cette option n'est pas autorisée lors de l'utilisation du format
      <literal>binary</literal>.
     </para>

     <note>
      <para>
       Lors de l'utilisation de <command>COPY FROM</command>, tout élément de données
       qui correspond à cette chaîne est stocké comme valeur NULL. Il est donc utile
       de s'assurer que c'est la même chaîne que celle précisée pour le
       <command>COPY TO</command> qui est utilisée.
      </para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>HEADER</literal></term>
    <listitem>
     <para>
      Le fichier contient une ligne d'en-tête avec les noms de chaque
      colonne. En sortie, la première ligne contient les noms de
      colonne de la table. En entrée, elle est ignorée. Cette option n'est
      autorisée que lors de l'utilisation du format <literal>CSV</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>QUOTE</literal></term>
    <listitem>
     <para>
      Spécifie le caractère guillemet à utiliser lorsqu'une valeur doit être
      entre guillemets. Par défaut, il s'agit du guillemet double. Cela doit
      de toute façon être un seul caractère sur un seul octet. Cette option
      n'est autorisée que lors de l'utilisation du format
      <literal>CSV</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ESCAPE</literal></term>
    <listitem>
     <para>
      Spécifie le caractère qui doit apparaître avant un caractère de données
      qui correspond à la valeur <literal>QUOTE</literal>. La valeur par
      défaut est la même que la valeur <literal>QUOTE</literal> (du coup,
      le caractère guillemet est doublé s'il apparaît dans les données). Cela
      doit être un seul caractère codé en un seul octet. Cette option n'est
      autorisée que lors de l'utilisation du format <literal>CSV</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORCE_QUOTE</literal></term>
    <listitem>
     <para>
      Force l'utilisation des guillemets pour toutes les valeurs non
      <literal>NULL</literal> dans chaque colonne spécifiée. La sortie
      <literal>NULL</literal> n'est jamais entre guillemets. Si
      <literal>*</literal> est indiqué, les valeurs non <literal>NULL</literal>
      seront entre guillemets pour toutes les colonnes. Cette option est
      seulement autorisée avec <command>COPY TO</command> et seulement quand
      le format <literal>CSV</literal> est utilisé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORCE_NOT_NULL</literal></term>
    <listitem>
     <para>
      Ne fait pas correspondre les valeurs des colonnes spécifiées avec la
      chaîne nulle. Dans le cas par défaut où la chaîne nulle est vide, cela
      signifie que les valeurs vides seront lues comme des chaînes de longueur
      nulle plutôt que comme des NULL, même si elles ne sont pas entre
      guillemets. Cette option est seulement autorisée avec <command>COPY
       FROM</command> et seulement quand le format <literal>CSV</literal> est
      utilisé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORCE_NULL</literal></term>
    <listitem>
     <para>
      Essaie d'établir une correspondance entre les valeurs des colonnes
      spécifiées avec la chaîne NULL, même si elle est entre guillemets.
      Si une correspondance est trouvée, configure la valeur à
      <literal>NULL</literal>. Dans le cas par défaut où la chaîne NULL est
      vide, cela convertit une chaîne vide entre guillemets en valeur
      NULL. Cette option est uniquement autorisée avec <command>COPY
       FROM</command>, et seulement avec le format <literal>CSV</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ENCODING</literal></term>
    <listitem>
     <para>
      Spécifie que le fichier est dans l'encodage <replaceable
      class="parameter">nom_encodage</replaceable>. Si cette option est omise,
      l'encodage client par défaut est utilisé. Voir la partie Notes ci-dessous
      pour plus de détails.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WHERE</literal></term>
    <listitem>
     <para>
      La clause optionnelle <literal>WHERE</literal> a la forme générale
      <synopsis>
WHERE <replaceable class="parameter">condition</replaceable>
      </synopsis>
      La <replaceable class="parameter">condition</replaceable> where est
      une expression qui, évaluée ramènera un résultat de type <type>booléen</type>.
      Toutes les lignes qui ne valident pas la condition ne seront
      pas insérées dans la table.
      On considère qu'une ligne qui valide la condition est une ligne qui renvoie
      true lorsque la valeur réelle dans la table est comparée avec la condition.
     </para>

     <para>
      Pour le moment, les sous requêtes ne sont pas autorisées dans
      l'expression du <literal>WHERE</literal>, et l'évaluation ne verra
      pas les changements réalisés par la commande <command>COPY</command> elle même.
      (Cela a son importance lorsque l'expression utilisée contient des appels à
      des fonctions <literal>VOLATILE</literal>)
     </para>

    </listitem>
   </varlistentry>

  </variablelist>
 </refsect1>

 <refsect1>
  <title>Affichage</title>

  <para>
   En cas de succès, une commande <command>COPY</command> renvoie une balise
   de la forme
   <screen>
COPY <replaceable class="parameter">nombre</replaceable>
   </screen>
   Le <replaceable class="parameter">nombre</replaceable> correspond au nombre
   de lignes copiées.
  </para>

  <note>
   <para>
    <application>psql</application> affichera cette balise de commande seulement
    si la commande n'est pas <literal>COPY ... TO STDOUT</literal> ou son équivalent
    sous <application>psql</application> (la méta-commande
    <literal>\copy ... to stdout</literal>). Ceci a pour but d'empêcher toute
    confusion entre la balise de commande et les données affichées.
   </para>
  </note>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   <command>COPY TO</command> ne peut être utilisé qu'avec des tables réelles,
   pas avec des vues. Néanmoins, vous pouvez écrire <literal>COPY (SELECT * FROM
    <replaceable class="parameter">nom_vue</replaceable>) TO ...</literal>
   pour copier le contenu actuel d'une vue.
  </para>

  <para>
   <command>COPY FROM</command> peut être utilisée avec une table standard et
   avec des vues ayant des déclencheurs <literal>INSTEAD OF INSERT</literal>.
  </para>

  <para>
   <command>COPY</command> gère seulement la table nommée&nbsp;; cette
   commande ne copie pas les données provenant ou vers des tables filles.
   Donc, par exemple, <literal>COPY <replaceable
    class="parameter">table</replaceable> TO</literal> affiche les mêmes
   données que <literal>SELECT * FROM ONLY <replaceable
    class="parameter">table</replaceable></literal>. Mais <literal>COPY
    (SELECT * FROM <replaceable class="parameter">table</replaceable>) TO ...</literal>
   peut être utilisé pour sauvegarder toutes les données d'un héritage.
  </para>

  <para>
   Le droit SELECT est requis sur la table dont les valeurs sont
   lues par <command>COPY TO</command> et le droit INSERT sur la table dont les
   valeurs sont insérées par <command>COPY FROM</command>. Il est suffisant
   d'avoir des droits sur les colonnes listées dans la commande.
  </para>

  <para>
   Si la sécurité de niveau ligne est activée pour la table, les politiques
   <command>SELECT</command> associées seront exécutées pour les instructions
   <literal>COPY <replaceable class="parameter">table</replaceable>
    TO</literal>. Actuellement, <command>COPY FROM</command> n'est pas supporté
   pour les tables ayant une sécurité au niveau ligne. Utilisez les
   instructions <command>INSERT</command> équivalentes à la place.
  </para>

  <para>
   Les fichiers nommés dans une commande <command>COPY</command> sont lus ou
   écrits directement par le serveur, non par l'application cliente. De ce
   fait, la machine hébergeant le serveur de bases de données doit les héberger
   ou pouvoir y accéder. L'utilisateur <productname>PostgreSQL</productname>
   (l'identifiant de l'utilisateur qui exécute le serveur), et non pas le
   client, doit pouvoir y accéder et les lire ou les modifier. De la même
   façon, la commande qui utilise <literal>PROGRAM</literal> est exécutée
   directement par le serveur, et non pas par l'application cliente. Elle doit
   être exécutable par l'utilisateur <productname>PostgreSQL</productname>.
   L'utilisation de <command>COPY</command> avec un fichier n'est autorisé
   qu'aux superutilisateurs de la base de données ou aux utilisateurs membres
   des rôles par défaut <literal>pg_read_server_files</literal>,
   <literal>pg_write_server_files</literal> ou
   <literal>pg_execute_server_program</literal> car <command>COPY</command>
   autorise la lecture et l'écriture de tout fichier accessible au serveur.
  </para>

  <para>
   Il ne faut pas confondre <command>COPY</command> et l'instruction
   <command><link linkend="app-psql-meta-commands-copy">\copy</link></command>
   de <application>psql</application>.
   <command>\copy</command> appelle <command>COPY FROM STDIN</command> ou
   <command>COPY TO STDOUT</command>, puis lit/stocke les données dans un
   fichier accessible au client <application>psql</application>.
   L'accès au fichier et les droits d'accès dépendent alors du client et non du
   serveur.
  </para>

  <para>
   Il est recommandé que le chemin absolu du fichier utilisé dans
   <command>COPY</command> soit toujours précisé. Ceci
   est assuré par le serveur dans le cas d'un <command>COPY TO</command>
   mais, pour les <command>COPY FROM</command>, il est possible de
   lire un fichier spécifié par un chemin relatif. Le chemin est
   interprété relativement au répertoire de travail du processus serveur
   (habituellement dans le répertoire des données), pas par rapport au répertoire
   de travail du client.
  </para>

  <para>
   Exécuter une commande avec <literal>PROGRAM</literal> peut être restreint
   par des mécanismes de contrôle d'accès du système d'exploitation, comme
   par exemple SELinux.
  </para>

  <para>
   <command>COPY FROM</command> appelle tous les déclencheurs et
   contraintes de vérification sur la table de destination, mais pas les
   règles.
  </para>

  <para>
   Pour les colonnes d'identité, la commande <command>COPY FROM</command>
   écrira toujours les valeurs des colonnes fournies dans les données en
   entrée, comme l'option <command>INSERT</command> pour <literal>OVERRIDING SYSTEM
    VALUE</literal>.
  </para>

  <para>
   L'entrée et la sortie de <command>COPY</command> sont sensibles à
   <varname>datestyle</varname>. Pour assurer la portabilité vers
   d'autres installations de <productname>PostgreSQL</productname> qui
   éventuellement utilisent des paramétrages <varname>datestyle</varname>
   différents de ceux par défaut, il est préférable de configurer
   <varname>datestyle</varname> en <literal>ISO</literal> avant d'utiliser
   <command>COPY TO</command>. Éviter d'exporter les données avec le
   <varname>IntervalStyle</varname> configuré à <literal>sql_standard</literal>
   est aussi une bonne idée car les valeurs négatives d'intervalles pourraient
   être mal interprétées par un serveur qui a une autre configuration pour
   <varname>IntervalStyle</varname>.
  </para>

  <para>
   Les données en entrée sont interprétées suivant la clause
   <literal>ENCODING</literal> ou suivant l'encodage actuel du
   client. Les données en sortie sont codées suivant la clause
   <literal>ENCODING</literal> ou suivant l'encodage actuel du
   client. Ceci est valable même si les données ne passent pas par le client,
   c'est-à-dire si elles sont lues et écrites directement sur un fichier du
   serveur.
  </para>

  <para>
   <command>COPY</command> stoppe l'opération à la première erreur. Si cela ne
   porte pas à conséquence dans le cas d'un <command>COPY TO</command>, il en va
   différemment dans le cas d'un <command>COPY FROM</command>. Dans ce cas, la table cible
   a déjà reçu les lignes précédentes. Ces lignes ne sont ni visibles, ni accessibles,
   mais occupent de l'espace disque. Il peut en résulter une perte importante
   d'espace disque si l'échec se produit lors d'une copie volumineuse.
   L'espace perdu peut alors être récupéré avec la commande <command>VACUUM</command>.
  </para>

  <para>
   <literal>FORCE_NULL</literal> et <literal>FORCE_NOT_NULL</literal> peuvent
   être utilisés simultanément sur la même colonne. Cela a pour résultat la
   conversion des chaînes NULL entre guillemets en valeurs NULL et la
   conversion de chaînes NULL sans guillemets en chaînes vides.
  </para>

  <para>
   Les données en entrée sont interprétées suivant l'encodage actuel du
   client et les données en sortie sont encodées suivant l'encodage client
   même si les données ne passent pas par le client mais sont lues à partir
   d'un fichier ou écrites dans un fichier.
  </para>

 </refsect1>

 <refsect1>
  <title>Formats de fichiers</title>

  <refsect2>
   <title>Format texte</title>

   <para>
    Quand le format <literal>text</literal> est utilisé, les données sont lues
    ou écrites dans un
    fichier texte, chaque ligne correspondant à une ligne de la table. Les colonnes
    sont séparées, dans une ligne, par le caractère de délimitation. Les valeurs
    des colonnes sont des chaînes, engendrées par la fonction de sortie ou utilisables
    par celle d'entrée, correspondant au type de données des attributs. La chaîne
    de spécification des valeurs NULL est utilisée en lieu et place des valeurs nulles.
    <command>COPY FROM</command> lève une erreur si une ligne du fichier ne contient
    pas le nombre de colonnes attendues.
   </para>

   <para>
    La fin des données peut être représentée par une ligne ne contenant
    qu'un antislash et un point (<literal>\.</literal>). Ce marqueur de fin de
    données n'est pas nécessaire lors de la lecture d'un fichier, la fin du
    fichier tenant ce rôle. Il n'est réellement nécessaire que lors d'une copie de
    données vers ou depuis une application cliente qui utilise un protocole
    client antérieur au 3.0.
   </para>

   <para>
    Les caractères antislash (<literal>\</literal>) peuvent être utilisés dans les
    données de <command>COPY</command> pour échapper les caractères qui,
    sans cela, seraient considérés comme des délimiteurs de ligne ou de
    colonne. Les caractères suivants, en particulier, <emphasis>doivent</emphasis> être
    précédés d'un antislash s'ils apparaissent dans la
    valeur d'une colonne&nbsp;: l'antislash lui-même, le saut de ligne, le retour
    chariot et le délimiteur courant.
   </para>

   <para>
    La chaîne NULL spécifiée est envoyée par <command>COPY TO</command> sans
    ajout d'antislash&nbsp;; au contraire, <command>COPY FROM</command>
    teste l'entrée au regard de la chaîne NULL avant la suppression des antislash.
    Ainsi, une chaîne NULL telle que <literal>\N</literal> ne peut pas être
    confondue avec la valeur de donnée réelle <literal>\N</literal>
    (représentée dans ce cas par <literal>\\N</literal>).
   </para>

   <para>
    Les séquences spéciales suivantes sont reconnues par <command>COPY FROM</command>&nbsp;:

    <informaltable>
     <tgroup cols="2">
      <colspec colnum="1" colwidth="1*"/>
      <colspec colnum="2" colwidth="2*"/>
      <thead>
       <row>
        <entry>Séquence</entry>
        <entry>Représente</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>\b</literal></entry>
        <entry>Retour arrière (<foreignphrase>backspace</foreignphrase>) (ASCII 8)</entry>
       </row>
       <row>
        <entry><literal>\f</literal></entry>
        <entry>Retour chariot (ASCII 12)</entry>
       </row>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>Nouvelle ligne (ASCII 10)</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>Retour chariot (ASCII 13)</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>Tabulation (ASCII 9)</entry>
       </row>
       <row>
        <entry><literal>\v</literal></entry>
        <entry>Tabulation verticale (ASCII 11)</entry>
       </row>
       <row>
        <entry><literal>\</literal><replaceable>chiffres</replaceable></entry>
        <entry>Antislash suivi d'un à trois chiffres en octal représente le
         caractère qui possède ce code numérique</entry>
       </row>
       <row>
        <entry><literal>\x</literal><replaceable>digits</replaceable></entry>
        <entry>Antislash <literal>x</literal> suivi d'un ou deux chiffres hexadécimaux
         représente le caractère qui possède ce code numérique</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

    Actuellement, <command>COPY TO</command> n'émet pas de séquence
    octale ou hexadécimale mais utilise les autres séquences listées
    ci-dessus pour les caractères de contrôle.
   </para>

   <para>
    Tout autre caractère précédé d'un antislash se représente lui-même.
    Cependant, il faut faire attention à ne pas ajouter d'antislash
    qui ne soit pas absolument nécessaire afin d'éviter le risque
    d'obtenir accidentellement une correspondance avec
    le marqueur de fin de données (<literal>\.</literal>) ou la chaîne NULL
    (<literal>\N</literal> par défaut)&nbsp;; ces chaînes sont reconnues avant tout
    traitement des antislashs.
   </para>

   <para>
    Il est fortement recommandé que les applications qui engendrent des
    données <command>COPY</command> convertissent les données de nouvelle ligne
    et de retour chariot par les séquences respectives <literal>\n</literal> et <literal>\r</literal>.
    A l'heure actuelle, il est possible de représenter un retour chariot par
    un antislash et un retour chariot, et une nouvelle ligne par un antislash
    et une nouvelle ligne. Cependant, il n'est pas certain que ces représentations
    soient encore acceptées dans les prochaines versions. Celles-ci sont, de plus,
    extrêmement sensibles à la corruption si le fichier de <command>COPY</command>
    est transféré sur d'autres plateformes (d'un Unix vers un Windows ou inversement, par exemple).
   </para>

   <para>
    <command>COPY TO</command> termine chaque ligne par une
    nouvelle ligne de style Unix (<quote><literal>\n</literal></quote>). Les serveurs
    fonctionnant sous Microsoft Windows engendrent un retour chariot/nouvelle ligne
    (<quote><literal>\r\n</literal></quote>), mais uniquement lorsque
    les données engendrées par <command>COPY</command> sont envoyées dans un
    fichier sur le serveur.
    Pour des raisons de cohérence entre les
    plateformes, <command>COPY TO STDOUT</command> envoie toujours
    <quote><literal>\n</literal></quote> quelque soit la plateforme du serveur.
    <command>COPY FROM</command> sait gérer les lignes terminant par une nouvelle
    ligne, un retour chariot ou un retour chariot suivi d'une nouvelle ligne.
    Afin de réduire les risques d'erreurs engendrées par des nouvelles lignes
    ou des retours chariot non précédés d'antislash, considéré de fait comme
    des données, <command>COPY FROM</command> émet un avertissement si les
    fins de lignes ne sont pas toutes identiques.
   </para>
  </refsect2>

  <refsect2>
   <title>Format CSV</title>

   <para>
    Ce format est utilisé pour importer et exporter des données au format
    de fichier <literal>CSV</literal> (acronyme de
    <foreignphrase>Comma Separated Value</foreignphrase>, littéralement
    valeurs séparées par des virgules). Ce format est utilisé par un grand nombre de
    programmes, tels les tableurs. À la place des règles d'échappement utilisées par le format
    texte standard de <productname>PostgreSQL</productname>, il produit et
    reconnaît le mécanisme d'échappement habituel de CSV.
   </para>

   <para>
    Les valeurs de chaque enregistrement sont séparées par le caractère
    <literal>DELIMITER</literal>. Si la valeur contient ce caractère, le caractère
    <literal>QUOTE</literal>, la chaîne <literal>NULL</literal>, un retour chariot
    ou un saut de ligne, la valeur complète est préfixée et suffixée
    par le caractère <literal>QUOTE</literal>. De plus, toute occurrence du caractère
    <literal>QUOTE</literal> ou du caractère <literal>ESCAPE</literal> est précédée du
    caractère d'échappement. <literal>FORCE QUOTE</literal> peut également être utilisé
    pour forcer les guillemets lors de l'affichage de valeur non-NULL dans
    des colonnes spécifiques.
   </para>

   <para>
    Le format <literal>CSV</literal> n'a pas de façon standard de distinguer
    une valeur <literal>NULL</literal> d'une chaîne vide. La commande <command>COPY</command>
    de <productname>PostgreSQL</productname> gère cela avec les guillemets. Un
    <literal>NULL</literal> est affiché suivant le paramètre <literal>NULL</literal>
    et n'est pas entre guillemets, alors qu'une valeur non <literal>NULL</literal>
    correspondant au paramètre <literal>NULL</literal> est entre guillemets. Par
    exemple, avec la configuration par défaut, un <literal>NULL</literal> est
    écrit avec la chaîne vide sans guillemets alors qu'une chaîne vide est écrit
    avec des guillemets doubles (<literal>""</literal>). La lecture des valeurs
    suit des règles similaires. Vous pouvez utiliser <literal>FORCE NOT
     NULL</literal> pour empêcher les comparaisons d'entrée <literal>NULL</literal>
    pour des colonnes spécifiques. Vous pouvez aussi utiliser
    <literal>FORCE_NULL</literal> pour convertir des valeurs de chaînes NULL
    entre guillemets en <literal>NULL</literal>.
   </para>

   <para>
    L'antislash n'est pas un caractère spécial dans le format <literal>CSV</literal>.
    De ce fait, le marqueur de fin de données, <literal>\.</literal>, peut apparaître
    dans les donnée. Afin d'éviter toute mauvaise interprétation, une valeur <literal>\.</literal>
    qui apparaît seule sur une ligne est automatiquement placée
    entre guillemets en sortie. En entrée, si elle est entre guillemets, elle
    n'est pas interprétée comme un marqueur de fin de données.
    Lors du chargement d'un fichier qui ne contient qu'une colonne, dont les valeurs ne sont pas placées entre
    guillemets, créé par une autre application, qui contient une valeur
    <literal>\.</literal>, il est nécessaire de placer cette valeur entre guillemets.
   </para>

   <note>
    <para>
     Dans le format <literal>CSV</literal>, tous les caractères sont significatifs.
     Une valeur entre guillemets entourée d'espaces ou de tout
     autre caractère différent de <literal>DELIMITER</literal> inclut ces caractères.
     Cela peut être source d'erreurs en cas d'import de données à partir d'un système
     qui complète les lignes <literal>CSV</literal> avec des espaces fines pour
     atteindre une longueur fixée. Dans ce cas, il est nécessaire de pré-traiter
     le fichier <literal>CSV</literal> afin de supprimer les espaces de complètement
     avant d'insérer les données dans <productname>PostgreSQL</productname>.
    </para>
   </note>

   <note>
    <para>
     Le format CSV sait reconnaître et produire des fichiers CSV dont les valeurs entre
     guillemets contiennent des retours chariot et des sauts de ligne. De ce fait,
     les fichiers ne contiennent pas strictement une ligne par ligne de table comme
     les fichiers du format texte.
    </para>
   </note>

   <note>
    <para>
     Beaucoup de programmes produisent des fichiers CSV étranges et parfois pervers&nbsp;;
     le format de fichier est donc plus une convention qu'un standard.
     Il est alors possible de rencontrer des fichiers que ce mécanisme ne sait
     pas importer. De plus, <command>COPY</command> peut produire des fichiers
     inutilisables par d'autres programmes.
    </para>
   </note>

  </refsect2>

  <refsect2>
   <title>Format binaire</title>

   <para>
    Le format <literal>binary</literal> fait que toutes les données sont
    stockées/lues au format binaire plutôt que texte. Il est un peu plus
    rapide que les formats texte et <literal>CSV</literal> mais un fichier au
    format binaire est moins portable suivant les architectures des machines
    et les versions de <productname>PostgreSQL</productname>. De plus, le
    format binaire est très spécifique au type des données&nbsp;; par exemple,
    un export de données binaires d'une colonne <type>smallint</type> ne
    pourra pas être importé dans une colonne <type>integer</type>, même si
    cela aurait fonctionné dans le format texte.
   </para>

   <para>
    Le format de fichier <literal>binary</literal> consiste en un en-tête de
    fichier, zéro ou plusieurs lignes contenant les données de la ligne et
    un bas-de-page du fichier. Les en-têtes et les données sont dans l'ordre
    réseau des octets.
   </para>

   <note>
    <para>
     Les versions de <productname>PostgreSQL</productname> antérieures à la
     7.4 utilisaient un format de fichier binaire différent.
    </para>
   </note>

   <refsect3>
    <title>Entête du fichier</title>

    <para>
     L'en-tête du fichier est constitutée de 15 octets de champs fixes, suivis par une
     aire d'extension de l'en-tête de longueur variable. Les champs fixes
     sont&nbsp;:

     <variablelist>
      <varlistentry>
       <term>Signature</term>
       <listitem>
        <para>
         séquence de 11 octets <literal>PGCOPY\n\377\r\n\0</literal> &mdash;
         l'octet zéro est une partie obligatoire de la signature. La signature est
         conçue pour permettre une identification aisée des fichiers qui ont été
         détériorés par un transfert non respectueux des huit bits. Cette
         signature est modifiée par les filtres de traduction de fin de ligne,
         la suppression des octets zéro, la suppression des bits de poids forts ou
         la modification de la parité.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Champs de commutateurs</term>
       <listitem>
        <para>
         masque entier de 32 bits décrivant les aspects importants du format de
         fichier. Les bits sont numérotés de 0 (<acronym>LSB</acronym>,
         ou <foreignphrase>Least Significant Bit</foreignphrase>, bit de poids faible) à 31
         (<acronym>MSB</acronym>, ou <foreignphrase>Most Significant Bit</foreignphrase>, bit de poids fort).
         Ce champ est stocké dans l'ordre réseau des octets
         (l'octet le plus significatif en premier), comme le sont tous
         les champs entier utilisés dans le format de fichier. Les bits 16 à 31
         sont réservés aux problèmes critiques de format de
         fichier&nbsp;; tout lecteur devrait annuler l'opération s'il trouve un bit
         inattendu dans cet ensemble. Les bits 0 à 15 sont réservés pour signaler
         les problèmes de compatibilité de formats&nbsp;; un lecteur devrait
         simplement ignorer les bits inattendus dans cet ensemble. Actuellement,
         seul un bit est défini, le reste doit être à zéro&nbsp;:
         <variablelist>
          <varlistentry>
           <term>Bit 16</term>
           <listitem>
            <para>
             si 1, les OID sont inclus dans la donnée&nbsp;; si 0, non. Les colonnes système OID
             ne sont plus supportées dans <productname>PostgreSQL</productname> mais
             le format contient toujours l'indicateur.
            </para>
           </listitem>
          </varlistentry>
         </variablelist>
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Longueur de l'aire d'extension de l'en-tête</term>
       <listitem>
        <para>
         entier sur 32 bits, longueur en octets du reste de l'en-tête, octets de
         stockage de la longueur non-compris. À l'heure actuelle ce champ vaut zéro. La première ligne
         suit immédiatement. De futures modifications du format pourraient
         permettre la présence de données supplémentaires dans l'en-tête. Tout
         lecteur devrait ignorer silencieusement toute donnée de l'extension de
         l'en-tête qu'il ne saurait pas traiter.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para>
     L'aire d'extension de l'en-tête est prévue pour contenir une séquence de morceaux
     s'auto-identifiant. Le champ de commutateurs n'a pas pour but
     d'indiquer aux lecteurs ce qui se trouve dans l'aire d'extension. La
     conception spécifique du contenu de l'extension de l'en-tête est pour
     une prochaine version.
    </para>

    <para>
     Cette conception permet l'ajout d'en-têtes compatible (ajout de
     morceaux d'extension d'en-tête, ou initialisation des octets commutateurs de poids faible)
     et les modifications non compatibles (initialisation des octets commutateurs de
     poids fort pour signaler de telles modifications, et ajout des données de support dans
     l'aire d'extension si nécessaire).
    </para>
   </refsect3>

   <refsect3>
    <title>Tuples</title>
    <para>
     Chaque tuple débute par un compteur, entier codé sur 16 bits, représentant le nombre de champs
     du tuple. (Actuellement, tous les tuples d'une table ont le même compteur,
     mais il est probable que cela ne soit pas toujours le cas.) On trouve ensuite,
     répété pour chaque champ du tuple, un mot de 32 bits annonçant le nombre
     d'octets de stockage de la donnée qui suivent. (Ce mot n'inclut pas
     sa longueur propre et peut donc être nul.) -1, cas spécial, indique une
     valeur de champ NULL. Dans ce cas, aucun octet de valeur ne suit.
    </para>

    <para>
     Il n'y a ni complètement d'alignement ni toute autre donnée supplémentaire
     entre les champs.
    </para>

    <para>
     Actuellement, toutes les valeurs d'un fichier d'un format binaire sont
     supposées être dans un format binaire (code de format).
     Il est probable qu'une extension future ajoute un champ d'en-tête
     autorisant la spécification de codes de format par colonne.
    </para>

    <para>
     La consultation du code source de <productname>PostgreSQL</productname>, et en
     particulier les fonctions <function>*send</function> et <function>*recv</function>
     associées à chaque type de données de la colonne,
     permet de déterminer le format binaire approprié à la donnée réelle.
     Ces fonctions se situent dans le répertoire <filename>src/backend/utils/adt/</filename> des
     sources.
    </para>

    <para>
     Lorsque les OID sont inclus dans le fichier, le champ OID suit immédiatement
     le compteur de champ. C'est un champ normal, à ceci près qu'il n'est pas
     inclus dans le compteur. Notez que les colonnes système OID ne sont pas
     supportées dans la version courante de <productname>PostgreSQL</productname>.
    </para>
   </refsect3>

   <refsect3>
    <title>Queue du fichier</title>

    <para>
     La fin du fichier consiste en un entier sur 16 bits contenant -1. Cela permet
     de le
     distinguer aisément du compteur de champs d'un tuple.
    </para>

    <para>
     Il est souhaitable que le lecteur rapporte une erreur si le mot compteur de champ ne vaut
     ni -1 ni le nombre attendu de colonnes. Cela assure une vérification
     supplémentaire d'une éventuelle désynchronisation d'avec les
     données.
    </para>
   </refsect3>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Copier une table vers le client en utilisant la barre
   verticale (<literal>|</literal>) comme délimiteur de champ&nbsp;:
   <programlisting>COPY pays TO STDOUT (DELIMITER '|');
   </programlisting>
  </para>

  <para>
   Copier des données d'un fichier vers la table <literal>pays</literal>&nbsp;:
   <programlisting>COPY pays FROM '/usr1/proj/bray/sql/pays_donnees';
   </programlisting>
  </para>

  <para>
   Pour copier dans un fichier les pays dont le nom commence par 'A'&nbsp;:
   <programlisting>
COPY (SELECT * FROM pays WHERE nom_pays LIKE 'A%') TO '/usr1/proj/bray/sql/une_liste_de_pays.copy';
   </programlisting>
  </para>

  <para>
   Pour copier dans un fichier compressé, vous pouvez envoyer la sortie à un
   programme de compression externe&nbsp;:
   <programlisting>
COPY pays TO PROGRAM 'gzip > /usr1/proj/bray/sql/donnees_pays.gz';
   </programlisting>
  </para>

  <para>
   Exemple de données convenables pour une copie vers une table depuis
   <literal>STDIN</literal>&nbsp;:
   <programlisting>AF      AFGHANISTAN
AL      ALBANIE
DZ      ALGERIE
ZM      ZAMBIE
ZW      ZIMBABWE
   </programlisting>
   L'espace sur chaque ligne est en fait un caractère de
   tabulation.
  </para>

  <para>
   Les mêmes données, extraites au format binaire. Les données sont
   affichées après filtrage au travers de l'outil Unix <command>od -c</command>. La
   table a trois colonnes&nbsp;; la première est de type <type>char(2)</type>,
   la deuxième de type <type>text</type> et la troisième de type <type>integer</type>.
   Toutes les lignes ont une valeur NULL sur la troisième colonne.
   <programlisting>0000000   P   G   C   O   P   Y  \n 377  \r  \n  \0  \0  \0  \0  \0  \0
0000020  \0  \0  \0  \0 003  \0  \0  \0 002   A   F  \0  \0  \0 013   A
0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \0 003
0000060  \0  \0  \0 002   A   L  \0  \0  \0 007   A   L   B   A   N   I
0000100   E 377 377 377 377  \0 003  \0  \0  \0 002   D   Z  \0  \0  \0
0000120 007   A   L   G   E   R   I   E 377 377 377 377  \0 003  \0  \0
0000140  \0 002   Z   M  \0  \0  \0 006   Z   A   M   B   I   E 377 377
0000160 377 377  \0 003  \0  \0  \0 002   Z   W  \0  \0  \0  \b   Z   I
0000200   M   B   A   B   W   E 377 377 377 377 377 377
   </programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Il n'existe pas d'instruction <command>COPY</command> dans le standard SQL.
  </para>

  <para>
   La syntaxe suivante était utilisée avant <productname>PostgreSQL</productname>
   9.0 et est toujours supportée&nbsp;:

   <synopsis>COPY <replaceable class="parameter">nomtable</replaceable> [ ( <replaceable class="parameter">colonne</replaceable> [, ...] ) ]
    FROM { '<replaceable class="parameter">nomfichier</replaceable>' | STDIN }
    [ [ WITH ]
        [ BINARY ]
	[ DELIMITER [ AS ] '<replaceable class="parameter">caractère_délimiteur</replaceable>' ]
	[ NULL [ AS ] '<replaceable class="parameter">chaîne NULL</replaceable>' ]
	[ CSV [ HEADER ]
	      [ QUOTE [ AS ] '<replaceable class="parameter">caractère_guillemet</replaceable>' ]
	      [ ESCAPE [ AS ] '<replaceable class="parameter">caractère_échappement</replaceable>' ]
	      [ FORCE NOT NULL <replaceable class="parameter">colonne</replaceable> [, ...] ] ] ]

COPY { <replaceable class="parameter">nomtable</replaceable> [ ( <replaceable class="parameter">colonne</replaceable> [, ...] ) ] | ( <replaceable class="parameter">requête</replaceable> ) }
    TO { '<replaceable class="parameter">nomfichier</replaceable>' | STDOUT }
    [ [ WITH ]
        [ BINARY ]
	[ DELIMITER [ AS ] '<replaceable class="parameter">caractère_délimiteur</replaceable>' ]
	[ NULL [ AS ] '<replaceable class="parameter">chaîne NULL</replaceable>' ]
	[ CSV [ HEADER ]
	      [ QUOTE [ AS ] '<replaceable class="parameter">caractère_guillemet</replaceable>' ]
	      [ ESCAPE [ AS ] '<replaceable class="parameter">caractère_échappement</replaceable>' ]
	      [ FORCE QUOTE <replaceable class="parameter">colonne</replaceable> [, ...] | * } ] ] ]
   </synopsis>

   Notez que, dans cette syntaxe, <literal>BINARY</literal> et
   <literal>CSV</literal> sont traités comme des mots-clés indépendants, pas
   comme des arguments à l'option <literal>FORMAT</literal>.
  </para>

  <para>
   La syntaxe suivante, utilisée avant <productname>PostgreSQL</productname>
   version 7.3, est toujours supportée&nbsp;:

   <synopsis>COPY [ BINARY ] <replaceable class="parameter">nom_table</replaceable>
    FROM { '<replaceable class="parameter">nom_fichier</replaceable>' | STDIN }
    [ [USING] DELIMITERS '<replaceable class="parameter">caractère_délimiteur</replaceable>' ]
    [ WITH NULL AS '<replaceable class="parameter">chaîne NULL</replaceable>' ]

COPY [ BINARY ] <replaceable class="parameter">nom_table</replaceable>
    TO { '<replaceable class="parameter">nom_fichier</replaceable>' | STDOUT }
    [ [USING] DELIMITERS '<replaceable class="parameter">caractère_délimiteur</replaceable>' ]
    [ WITH NULL AS '<replaceable class="parameter">chaîne NULL</replaceable>' ]
   </synopsis>
  </para>
 </refsect1>
</refentry>
