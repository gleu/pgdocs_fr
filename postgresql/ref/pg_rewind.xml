<?xml version="1.0" encoding="UTF-8"?>
<!--
doc/src/sgml/ref/pg_rewind.sgml
PostgreSQL documentation
-->

<refentry id="app-pgrewind">
 <indexterm zone="app-pgrewind">
  <primary>pg_rewind</primary>
 </indexterm>
 
 <refmeta>
  <refentrytitle><application>pg_rewind</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>
 
 <refnamediv>
  <refname>pg_rewind</refname>
  <refpurpose>synchronise le répertoire des données de
   <productname>PostgreSQL</productname> avec un autre répertoire de données
  </refpurpose>
 </refnamediv>
 
 <refsynopsisdiv>
  <cmdsynopsis>
   <command>pg_rewind</command>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <group choice="plain">
    <group choice="req">
     <arg choice="plain"><option>-D </option></arg>
     <arg choice="plain"><option>--target-pgdata</option></arg>
    </group>
    <replaceable> directory</replaceable>
    <group choice="req">
     <arg choice="plain"><option>--source-pgdata=<replaceable>répertoire</replaceable></option></arg>
     <arg choice="plain"><option>--source-server=<replaceable>chaine_de_connexion</replaceable></option></arg>
    </group>
   </group>
  </cmdsynopsis>
 </refsynopsisdiv>
 
 <refsect1>
  <title>Description</title>
  
  <para>
   <application>pg_rewind</application> est un outil qui permet de
   synchroniser une instance PostgreSQL avec une copie de cette même
   instance, a postériori de la séparation des timelines.
   Le scénario classique consiste à réactiver un ancien serveur primaire,
   après une bascule, en tant que serveur secondaire répliqué depuis le
   nouveau serveur primaire.
  </para>
  
  <para>
   Le résultat est le même que lorsqu'on remplace le répertoire de données
   cible avec celui de la source. Seuls les blocs modifiés des fichiers des
   relations déjà existants sont copiés, tous les autres fichiers sont copiés
   intégralement, fichiers de configurations compris. L'avantage de
   <application>pg_rewind</application> par rapport à la réalisation d'une
   nouvelle sauvegarde de base, ou l'utilisation d'un outil tel que
   <application>rsync</application>, est que
   <application>pg_rewind</application> n'a pas besoin de lire tous les blocs
   non modifiés des fichiers de l'ancienne instance. Cela rend l'opération
   éminement plus rapide lorsqu'on est face à une volumétrie conséquente et
   qu'il a peu de différences entre les deux instances.
  </para>
  
  <para>
   <application>pg_rewind</application> inspecte l'historique de la
   timeline de l'instance source et de l'instance cible pour déterminer
   à quel moment a eu lieu la séparation, et s'attend à trouver tous les
   fichiers WAL jusqu'au moment de la bascule dans le répertoire
   <filename>pg_xlog</filename>. Le point de divergence peut être trouvé
   soit sur la ligne de temps cible, soit sur la ligne de temps source,
   soit sur leur ancêtre commun.
   Dans un scénario de bascule classique, où l'instance cible a été
   arrêtée peu après le changement, cela ne pose aucun problème. En
   revanche, si l'instance cible a travaillé un certain temps après le
   changement, les anciens fichiers WAL peuvent ne plus être présents dans
   le répertoire <filename>pg_xlog</filename>.
   Dans ce cas, ils peuvent être copiés à la main depuis les fichiers WAL
   archivés vers le répertoire <filename>pg_xlog</filename>.
   L'utilisation de <application>pg_rewind</application> n'est pas limitée au
   failover&nbsp;: un serveur standby peut être promu, écrire quelques
   transactions, puis transformé de nouveau en standby avec cet outil.
  </para>
  
  <para>
   Lorsque l'instance cible est démarrée pour la première fois après avoir
   utilisé <application>pg_rewind</application>, elle va se mettre en mode
   de restauration (<foreignphrase>recovery</foreignphrase>) et va rejouer
   tous les fichiers WAL générés par l'instance source depuis la bascule.
   Si certains fichiers WAL ne sont plus disponibles sur la source
   lorsque <application>pg_rewind</application> est en cours, ils
   ne peuvent donc plus être copiés par la session <application>pg_rewind</application>.
   Il est alors nécessaire de faire en sorte
   qu'ils puissent être disponibles lorsque le serveur cible sera démarré.
   Cela est possible en créant un fichier <filename>recovery.conf</filename>
   dans le répertoire principal cible des données, en utilisant le
   paramètre <varname>restore_command</varname> de manière appropriée.
  </para>
  
  <para>
   <application>pg_rewind</application> nécessite que l'instance cible
   ait l'option <xref linkend="guc-wal-log-hints"/> activée dans le
   fichier de configuration <filename>postgresql.conf</filename> ou que les
   sommes de contrôle sur les données aient été activés lorsque l'instance
   a été initialisée par la commande <application>initdb</application>.
   Aucune de ces options n'est active par défaut.
   Le paramètre <xref linkend="guc-full-page-writes"/> doit lui aussi
   être activé. Il l'est par défaut.
  </para>
  
  <warning>
   <para>
    Si <application>pg_rewind</application> échoue lors du traitement, le
    répertoire des données de la cible a de forte chance de ne pas être dans
    un état récupérable. Dans de tels cas, il est recommandé de réaliser une
    nouvelle sauvegarde.
   </para>
   
   <para>
    <application>pg_rewind</application> échouera immédiatement s'il trouve
    des fichiers sur lesquels il ne peut pas écrire. Ceci peut arriver par
    exemple quand les serveurs source et cible utilisent la même
    correspondance de fichier pour les clés et certificats SSL en lecture
    seule. Si de tels fichiers sont présents sur le serveur cible, il est
    recommander de les supprimer avant d'exécuter
    <application>pg_rewind</application>. Après son exécution, certains de ces
    fichiers pourront être copiés de la source, auquel cas il pourrait être
    nécessaire de copier les données et de restaurer l'ensemble de liens
    utilisés avant l'opération.
   </para>
  </warning>
 </refsect1>
 
 <refsect1>
  <title>Options</title>
  
  <para>
   <application>pg_rewind</application> accepte les arguments suivants
   en ligne de commande&nbsp;:
   
   <variablelist>
    <varlistentry>
     <term><option>-D <replaceable class="parameter">répertoire</replaceable></option></term>
     <term><option>--target-pgdata=<replaceable class="parameter">répertoire</replaceable></option></term>
     <listitem>
      <para>
       Cette option définit le répertoire de données cible qui va être
       synchronisé avec le répertoire source. Cette option requiert que le
       serveur source ait été arrêté proprement.
      </para>
     </listitem>
    </varlistentry>
    
    <varlistentry>
     <term><option>--source-pgdata=<replaceable class="parameter">répertoire</replaceable></option></term>
     <listitem>
      <para>
       Cette option définit le répertoire de données source qui va
       être synchronisé avec le répertoire cible. Si cette option est
       utilisée, l'instance source doit être arrêtée proprement.
      </para>
     </listitem>
    </varlistentry>
    
    <varlistentry>
     <term><option>--source-server=<replaceable class="parameter">chaine de connexion</replaceable></option></term>
     <listitem>
      <para>
       Définit une chaine de connexion libpq permettant d'accéder à
       l'instance <productname>PostgreSQL</productname> source de
       façon à pouvoir la synchroniser avec la cible.
       Cette option requiert l'utilisation d'une connexion standard avec un utilisant
       disposant de l'attribut SUPERUSER.
       L'instance source doit être opérationnelle et ne doit pas être en mode
       de restauration (recovery).
      </para>
     </listitem>
    </varlistentry>
    
    <varlistentry>
     <term><option>-n</option></term>
     <term><option>--dry-run</option></term>
     <listitem>
      <para>
       Réalise toutes les opérations sans modifier le répertoire cible.
      </para>
     </listitem>
    </varlistentry>
    
    <varlistentry>
     <term><option>-P</option></term>
     <term><option>--progress</option></term>
     <listitem>
      <para>
       Permet d'activer les traces. Activer cette option vous fournira
       les informations au fil de l'eau sur l'avancée de la copie des
       données depuis l'instance source.
      </para>
     </listitem>
    </varlistentry>
    
    <varlistentry>
     <term><option>--debug</option></term>
     <listitem>
      <para>
       Affiche les détails de la sortie debug, ce qui est surtout
       utile aux développeurs qui corrigent <application>pg_rewind</application>.
      </para>
     </listitem>
    </varlistentry>
    
    <varlistentry>
     <term><option>-V</option></term>
     <term><option>--version</option></term>
     <listitem><para>Affiche les informations concernant la version,
       puis quitte.</para></listitem>
    </varlistentry>
    
    <varlistentry>
     <term><option>-?</option></term>
     <term><option>--help</option></term>
     <listitem><para>Affiche l'aide, puis quitte.</para></listitem>
    </varlistentry>
    
   </variablelist>
  </para>
 </refsect1>
 
 <refsect1>
  <title>Environnement</title>
  
  <para>
   Lorsque l'option <option>--source-server</option> est utilisée,
   <application>pg_rewind</application> utilise aussi les variables
   d'environnement supportées par la bibliothèque
   <application>libpq</application>
   (voir <xref linkend="libpq-envars"/>).
  </para>
 </refsect1>
 
 <refsect1>
  <title>Notes</title>
  
  <para>
   Lors de l'exécution de <application>pg_rewind</application> sur une
   instance en ligne comme source récemment promue, il est nécessaire
   d'exécuter un <command>CHECKPOINT</command> après la promotion pour que son
   fichier de contrôle reflète des informations de timeline à jour, qui est
   utilisé par <application>pg_rewind</application> pour vérifier si
   l'instance cible peut être rembobiné en utilisant l'instance source
   désignée.
  </para>
  
  <refsect2>
   <title>Fonctionnement</title>
   
   <para>
    L'idée de base est de copier toutes les modifications de fichiers au
    niveau système de fichiers de l'instance source vers l'instance
    cible&nbsp;:
   </para>
   
   <procedure>
    <step>
     <para>
      Parcourir les journaux de transactions de l'instance cible, en
      commançant du dernier checkpoint avant le moment où l'historique de
      timeline de l'instance source a dévié de celle de l'instance cible. Pour
      chaque enregistrement dans les journaux de transactions, enregistrer
      chaque bloc de données modifié. Ceci a pour résultat une liste de tous
      les blocs de données modifiés dans l'instance cible, après la séparation
      avec l'instance source.
     </para>
    </step>
    <step>
     <para>
      Copier tous les blocs modifiés de l'instance source vers l'instance
      cible, soit en utilisant un accès direct au système de fichiers
      (<option>--source-pgdata</option>) soit en SQL
      (<option>--source-server</option>).
     </para>
    </step>
    <step>
     <para>
      Copier tous les autres fichiers, tels que <filename>pg_clog</filename>
      et les fichiers de configuration de l'instance source vers l'instance
      cible (sauf les fichiers des relations).
     </para>
    </step>
    <step>
     <para>
      Appliquer les enregistrements des journaux de transactions provenant de
      l'instance source, en commençant à partir du checkpoint créé au moment
      du failover. (En fait, <application>pg_rewind</application> n'applique
      pas les journaux de transactions. Il crée simplement un fichier
      backup_label qui fera en sorte que <productname>PostgreSQL</productname>
      démarre en rejoutant les enregistrements des journaux de transactions à
      partir de ce checkpoint.)
     </para>
    </step>
   </procedure>
  </refsect2>
 </refsect1>
 
</refentry>
