<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060313 pour la relecture -->

<refentry id="sql-select">
 <refmeta>
  <refentrytitle id="sql-select-title">SELECT</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>SELECT</refname>
  <refname>TABLE</refname>
  <refname>WITH</refname>
  <refpurpose>récupère des lignes d'une table ou d'une vue</refpurpose>
 </refnamediv>

 <indexterm zone="sql-select">
  <primary>SELECT</primary>
 </indexterm>

 <indexterm zone="sql-select">
  <primary>commande TABLE</primary>
 </indexterm>

 <indexterm zone="sql-select">
  <primary>WITH</primary>
  <secondary>dans un SELECT</secondary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>[ WITH [ RECURSIVE ] <replaceable class="parameter">requête_with</replaceable> [, ...] ]
SELECT [ ALL | DISTINCT [ ON ( <replaceable class="parameter">expression</replaceable> [, ...] ) ] ]
    * | <replaceable class="parameter">expression</replaceable> [ [ AS ] <replaceable class="parameter">nom_d_affichage</replaceable> ] [, ...]
    [ FROM <replaceable class="parameter">éléments_from</replaceable> [, ...] ]
    [ WHERE <replaceable class="parameter">condition</replaceable> ]
    [ GROUP BY <replaceable class="parameter">expression</replaceable> [, ...] ]
    [ HAVING <replaceable class="parameter">condition</replaceable> [, ...] ]
    [ WINDOW <replaceable class="parameter">nom_window</replaceable> AS ( <replaceable class="parameter">définition_window</replaceable> ) [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL ] <replaceable class="parameter">select</replaceable> ]
    [ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">opérateur</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { <replaceable class="parameter">nombre</replaceable> | ALL } ]
    [ OFFSET <replaceable class="parameter">début</replaceable> ] [ ROW | ROWS ] ]
    [ FETCH { FIRST | NEXT } [ <replaceable class="parameter">total</replaceable> ] { ROW | ROWS } ONLY ]
    [ FOR { UPDATE | SHARE } [ OF <replaceable class="parameter">nom_table</replaceable> [, ...] ] [ NOWAIT ] [...] ]

avec <replaceable class="parameter">éléments_from</replaceable> qui peut être&nbsp;:

    [ ONLY ] <replaceable class="parameter">nom_table</replaceable> [ * ] [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">alias_colonne</replaceable> [, ...] ) ] ]
    ( <replaceable class="parameter">select</replaceable> ) [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">alias_colonne</replaceable> [, ...] ) ]
    <replaceable class="parameter">with_query_name</replaceable> [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">column_alias</replaceable> [, ...] ) ] ]
    <replaceable class="parameter">nom_fonction</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] ) [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">alias_colonne</replaceable> [, ...] | <replaceable class="parameter">définition_colonne</replaceable> [, ...] ) ]
    <replaceable class="parameter">nom_fonction</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] ) AS ( <replaceable class="parameter">définition_colonne</replaceable> [, ...] )
    <replaceable class="parameter">éléments_from</replaceable> [ NATURAL ] <replaceable class="parameter">type_jointure</replaceable> <replaceable class="parameter">éléments_from</replaceable> [ ON <replaceable class="parameter">condition_jointure</replaceable> | USING ( <replaceable class="parameter">colonne_jointure</replaceable> [, ...] ) ]

and <replaceable class="parameter">with_query</replaceable> is:

    <replaceable class="parameter">with_query_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ] AS ( <replaceable class="parameter">select</replaceable> )

TABLE { [ ONLY ] <replaceable class="parameter">table_name</replaceable> [ * ] | <replaceable class="parameter">with_query_name</replaceable> }
</synopsis>

 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-select">
   <primary>SELECT</primary>
  </indexterm>

  <para>
   <command>SELECT</command> récupère des lignes de zéro ou plusieurs
   tables. Le traitement général de <command>SELECT</command> est le
   suivant&nbsp;:

   <orderedlist>
    <listitem>
     <para>
      All queries in the <literal>WITH</literal> list are computed.
      These effectively serve as temporary tables that can be referenced
      in the <literal>FROM</literal> list.  A <literal>WITH</literal> query
      that is referenced more than once in <literal>FROM</literal> is
      computed only once.
      (See <xref linkend="sql-with" endterm="sql-with-title"/> below.)
     </para>
    </listitem>

    <listitem>
     <para>
      Tous les éléments de la liste <literal>FROM</literal> sont calculés.
      (Chaque élément dans la liste <literal>FROM</literal> est une table 
      réelle ou virtuelle.) Si plus d'un élément sont spécifiés dans la liste
      <literal>FROM</literal>, ils font l'objet d'une jointure croisée (cross-join). (Voir <xref
      linkend="sql-from" endterm="sql-from-title"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>WHERE</literal> est spécifiée, toutes les lignes
      qui ne satisfont pas les conditions sont éliminées de l'affichage. (Voir
      <xref linkend="sql-where" endterm="sql-where-title"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>GROUP BY</literal> est spécifiée, l'affichage est
      divisé en groupes de lignes qui correspondent à une ou plusieurs valeurs.
      Si la clause <literal>HAVING</literal> est présente, elle élimine les
      groupes qui ne satisfont pas la condition donnée. (Voir <xref
      linkend="sql-groupby" endterm="sql-groupby-title"/> et <xref
      linkend="sql-having" endterm="sql-having-title"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Les lignes retournées sont traitées en utilisant les expressions de sortie
      de <command>SELECT</command> pour chaque ligne sélectionnée. (Voir <xref
      linkend="sql-select-list" endterm="sql-select-list-title"/> ci-dessous.)
    </para>
    </listitem>

    <listitem>
     <para>
      En utilisant les opérateurs <literal>UNION</literal>,
      <literal>INTERSECT</literal> et <literal>EXCEPT</literal>, l'affichage de
      plusieurs instructions <command>SELECT</command> peut être combiné pour
      former un ensemble unique de résultats. L'opérateur <literal>UNION</literal>
      renvoie toutes les lignes qui appartiennent, au moins, à l'un des ensembles de
      résultats. L'opérateur <literal>INTERSECT</literal> renvoie toutes les
      lignes qui sont dans tous les ensembles de résultats.
      L'opérateur <literal>EXCEPT</literal> renvoie les lignes qui sont
      présentes dans le premier ensemble de résultats mais pas dans le 
      deuxième. Dans les trois cas, les lignes dupliquées sont éliminées sauf
      si <literal>ALL</literal> est spécifié. (Voir <xref linkend="sql-union"
      endterm="sql-union-title"/>, <xref linkend="sql-intersect"
      endterm="sql-intersect-title"/> et <xref linkend="sql-except"
      endterm="sql-except-title"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>ORDER BY</literal> est spécifiée, les lignes
      renvoyées sont triées dans l'ordre spécifié. Si <literal>ORDER
      BY</literal> n'est pas indiqué, les lignes sont retournées dans l'ordre 
      qui permet la réponse la plus rapide du système. (Voir <xref
      linkend="sql-orderby" endterm="sql-orderby-title"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      <literal>DISTINCT</literal> élimine les lignes dupliquées du résultat.
      <literal>DISTINCT ON</literal> élimine les lignes qui correspondent à
      toutes les expressions données. <literal>ALL</literal> (la valeur par
      défaut) renvoie toutes les lignes candidates, y compris les lignes
      dupliquées. (Voir <xref linkend="sql-distinct"
      endterm="sql-distinct-title"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si les clauses <literal>LIMIT</literal> (ou <literal>FETCH FIRST</literal>)
      ou <literal>OFFSET</literal> sont
      spécifiées, l'instruction <command>SELECT</command> ne renvoie qu'un
      sous-ensemble de lignes de résultats. (Voir <xref linkend="sql-limit"
      endterm="sql-limit-title"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>FOR UPDATE</literal> ou <literal>FOR
      SHARE</literal> est spécifiée, l'instruction <command>SELECT</command>
      verrouille les lignes sélectionnées contre les mises à jour concurrentes.
      (Voir <xref linkend="sql-for-update-share"
      endterm="sql-for-update-share-title"/> ci-dessous.)
     </para>
    </listitem>
   </orderedlist>
  </para>

  <para>
   Le droit <literal>SELECT</literal> sur chaque colonne utilisée dans une
   commande <command>SELECT</command> est nécessaire pour lire
   ses valeurs. L'utilisation de <literal>FOR UPDATE</literal> ou de
   <literal>FOR SHARE</literal> requiert en plus le droit 
   <literal>UPDATE</literal> (pour au moins une colonne de chaque table
   sélectionnée).
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <refsect2 id="SQL-WITH">
   <title id="sql-with-title"><literal>WITH</literal> Clause</title>

   <para>
    The <literal>WITH</literal> clause allows you to specify one or more
    subqueries that can be referenced by name in the primary query.
    The subqueries effectively act as temporary tables or views
    for the duration of the primary query.
   </para>

   <para>
    A name (without schema qualification) must be specified for each
    <literal>WITH</literal> query.  Optionally, a list of column names
    can be specified; if this is omitted,
    the column names are inferred from the subquery.
   </para>

   <para>
    If <literal>RECURSIVE</literal> is specified, it allows a
    subquery to reference itself by name.  Such a subquery must have
    the form
<synopsis>
<replaceable class="parameter">non_recursive_term</replaceable> UNION [ ALL ] <replaceable class="parameter">recursive_term</replaceable>
</synopsis>
    where the recursive self-reference must appear on the right-hand
    side of the <literal>UNION</literal>.  Only one recursive self-reference
    is permitted per query.
   </para>

   <para>
    Another effect of <literal>RECURSIVE</literal> is that
    <literal>WITH</literal> queries need not be ordered: a query
    can reference another one that is later in the list.  (However,
    circular references, or mutual recursion, are not implemented.)
    Without <literal>RECURSIVE</literal>, <literal>WITH</literal> queries
    can only reference sibling <literal>WITH</literal> queries
    that are earlier in the <literal>WITH</literal> list.
   </para>

   <para>
    A useful property of <literal>WITH</literal> queries is that they
    are evaluated only once per execution of the primary query,
    even if the primary query refers to them more than once.
   </para>

   <para>
    See <xref linkend="queries-with"/> for additional information.
   </para>
  </refsect2>

  <refsect2 id="sql-from">
   <title id="sql-from-title">Clause <literal>FROM</literal></title>

   <para>
    La clause <literal>FROM</literal> spécifie une ou plusieurs tables source
    pour le <command>SELECT</command>. Si plusieurs sources sont spécifiées, le
    résultat est un produit cartésien (jointure croisée) de toutes les sources.
    Mais habituellement, des conditions de qualification sont ajoutées pour
    restreindre les lignes renvoyées à un petit sous-ensemble du produit
    cartésien.
   </para>

   <para>
    La clause <literal>FROM</literal> peut contenir les éléments
    suivants&nbsp;:

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">nom_table</replaceable></term>
      <listitem>
       <para>
        Le nom (éventuellement qualifié par le nom du schéma) d'une table existante
	ou d'une vue. Si <literal>ONLY</literal> est spécifié, seule cette table est
	parcourue. Dans le cas contraire, la table et toutes ses
	descendantes (s'il y en a) sont parcourues. <literal>*</literal> peut
	être ajouté au nom de la table pour indiquer que les tables descendantes
	doivent être parcourues mais, dans la version actuelle, c'est le
	comportement par défaut. Dans les versions précédant la 7.1,
	<literal>ONLY</literal> était le comportement par défaut.
	Ce dernier peut être modifié à l'aide de l'option de configuration
	<xref linkend="guc-sql-inheritance"/>.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><replaceable class="parameter">alias</replaceable></term>
      <listitem>
       <para>
        Un nom de substitution pour l'élément <literal>FROM</literal> contenant
	l'alias. Un alias est utilisé par brièveté ou pour lever toute
	ambiguïté lors d'auto-jointures (la même table est parcourue plusieurs
	fois). Quand un alias est fourni, il cache complètement le nom réel de
	la table ou fonction&nbsp;; par exemple, avec <literal>FROM foo AS</literal>,
	le reste du <command>SELECT</command> doit faire référence à cet
	élément de <literal>FROM</literal> par <literal>f</literal> et non pas par
	<literal>foo</literal>. Si un alias est donné, une liste d'alias de colonnes
	peut aussi être saisi comme noms de substitution pour différentes
	colonnes de la table.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><replaceable class="parameter">select</replaceable></term>
      <listitem>
       <para>
        Un sous-<command>SELECT</command> peut apparaître dans la clause
        <literal>FROM</literal>. Il agit comme si sa sortie était 
        transformée en table temporaire pour la durée de cette seule commande
        <command>SELECT</command>. Le sous-<command>SELECT</command>
        doit être entouré de parenthèses et un alias
	<emphasis>doit</emphasis> lui être fourni.
	Une commande <xref linkend="sql-values" endterm="sql-values-title"/>
        peut aussi être utilisée ici.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">with_query_name</replaceable></term>
      <listitem>
       <para>
        A <literal>WITH</literal> query is referenced by writing its name,
        just as though the query's name were a table name.  (In fact,
        the <literal>WITH</literal> query hides any real table of the same name
        for the purposes of the primary query.  If necessary, you can
        refer to a real table of the same name by schema-qualifying
        the table's name.)
        An alias can be provided in the same way as for a table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nom_fonction</replaceable></term>
      <listitem>
       <para>
        Des appels de fonctions peuvent apparaître dans la clause
	<literal>FROM</literal>. (Cela est particulièrement utile pour les
	fonctions renvoyant des ensembles de résultats, mais n'importe quelle fonction peut
	être utilisée.) Un appel de fonction agit comme si la sortie était
	transformée en table temporaire pour la durée de cette seule commande
	<command>SELECT</command>.
<!-- J'ai l'impression qu'il y a là une imprécision dans la documentation
officielle. Il ne s'agit pas ici de sous-select, mais d'un appel de fonction.
Ce qui diffère légèrement d'un sous-select. A moins qu'un raccourci ne soit pris
pour considérer un appel de fonction comme un sous-select. SAS -->
	Un alias peut aussi être utilisé. Si un
	alias est donné, une liste d'alias de colonnes peut être ajoutée pour
	fournir des noms de substitution pour un ou plusieurs attributs du type
	composé de retour de la fonction. Si la fonction a été définie comme
	renvoyant le type de données <type>record</type>, alors un alias ou un mot
	clé <literal>AS</literal> doit être présent, suivi par une liste de définitions
	de colonnes de la forme <literal>( <replaceable
	class="parameter">nom_colonne</replaceable> <replaceable
	class="parameter">type_données</replaceable> <optional>, ... </optional>
	)</literal>. La liste de définitions de colonnes doit correspondre au
	nombre réel et aux types réels des colonnes renvoyées par la fonction.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><replaceable class="parameter">type_jointure</replaceable></term>
      <listitem>
       <para>
        Un des éléments 
        <itemizedlist>
         <listitem>
          <para><literal>[ INNER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>LEFT [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>RIGHT [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>FULL [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>CROSS JOIN</literal></para>
         </listitem>
        </itemizedlist>

        Pour les types de jointures <literal>INNER</literal> et <literal>OUTER</literal>, une
	condition de jointure doit être spécifiée, à choisir parmi
        <literal>NATURAL</literal>, <literal>ON <replaceable
        class="parameter">condition_jointure</replaceable></literal> ou
        <literal>USING (<replaceable
        class="parameter">colonne_jointure</replaceable> [, ...])</literal>.
        Voir ci-dessous pour la signification. Pour <literal>CROSS
	JOIN</literal>, aucune de ces clauses ne doit apparaître.
       </para>

       <para>
        Une clause <literal>JOIN</literal> combine deux éléments
        <literal>FROM</literal>. Les parenthèses peuvent être utilisées pour
	déterminer l'ordre d'imbrication. En l'absence de parenthèses,
	les <literal>JOIN</literal> sont imbriqués de gauche à droite. Dans
	tous les cas, <literal>JOIN</literal> est plus prioritaire que les
	virgules séparant les éléments <literal>FROM</literal>.
       </para>

       <para>
        <literal>CROSS JOIN</literal> et <literal>INNER JOIN</literal> produisent un
	simple produit cartésien. Le résultat est identique à celui obtenu 
	lorsque les deux éléments sont listés au premier niveau du <literal>FROM</literal>, mais
	restreint par la condition de jointure (si elle existe). <literal>CROSS
	JOIN</literal> est équivalent à <literal>INNER JOIN ON (TRUE)</literal>, c'est-à-dire
	qu'aucune ligne n'est supprimée par qualification. Ces types de
	jointure sont essentiellement une aide à la notation car ils ne font rien de
	plus qu'un simple <literal>FROM</literal> et <literal>WHERE</literal>.
       </para>

       <para>
        <literal>LEFT OUTER JOIN</literal> renvoie toutes les lignes du produit
	cartésien qualifié (c'est-à-dire toutes les lignes combinées qui
	satisfont la condition de jointure), plus une copie de chaque ligne
	de la table de gauche pour laquelle il n'y a pas de ligne à droite
	qui satisfasse la condition de jointure. La ligne de gauche est
	étendue à la largeur complète de la table jointe par insertion de
	valeurs NULL pour les colonnes de droite. Seule la
	condition de la clause <literal>JOIN</literal> est utilisée pour décider des
	lignes qui correspondent. Les conditions externes sont appliquées après
	coup.
       </para>

       <para>
        À l'inverse, <literal>RIGHT OUTER JOIN</literal> renvoie toutes les lignes
	jointes plus une ligne pour chaque ligne de droite sans correspondance
	(complétée par des NULL pour le côté gauche). C'est une simple aide à
	la notation car il est aisément convertible en <literal>LEFT</literal> en
	inversant les entrées gauche et droite.
       </para>

       <para>
        <literal>FULL OUTER JOIN</literal> renvoie toutes les lignes jointes, plus
	chaque ligne gauche sans correspondance (étendue par des NULL à droite),
	plus chaque ligne droite sans correspondance (étendue par des NULL à
	gauche).
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><literal>ON <replaceable class="parameter">condition_jointure</replaceable></literal></term>
      <listitem>
       <para>
        <replaceable class="parameter">condition_jointure</replaceable> 
	est une expression qui retourne une valeur de type <type>boolean</type>
	(comme une clause <literal>WHERE</literal>) qui spécifie les
	lignes d'une jointure devant correspondre.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><literal>USING (<replaceable
	class="parameter">colonne_jointure</replaceable> [,
	...])</literal></term>
      <listitem>
       <para>
        Une clause de la forme <literal>USING ( a, b, ... )</literal> est un
	raccourci pour <literal>ON table_gauche.a = table_droite.a AND table_gauche.b
	= table_droite.b ...</literal>. De plus, <literal>USING</literal> implique 
	l'affichage d'une seule paire des colonnes correspondantes dans la sortie
	de la jointure.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NATURAL</literal></term>
      <listitem>
       <para>
        <literal>NATURAL</literal> est un raccourci pour une liste
        <literal>USING</literal> qui mentionne toutes les colonnes de même nom dans les deux 
        tables.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>
   
  <refsect2 id="sql-where">
   <title id="sql-where-title">Clause <literal>WHERE</literal></title>

   <para>
    La clause <literal>WHERE</literal> optionnelle a la forme générale
<synopsis>WHERE <replaceable class="parameter">condition</replaceable>
</synopsis>
    où <replaceable class="parameter">condition</replaceable> est une 
    expression dont le résultat est de type <type>boolean</type>. Toute ligne qui ne
    satisfait pas cette condition est éliminée de la sortie. Une ligne
    satisfait la condition si elle retourne vrai quand les valeurs réelles
    de la ligne sont substituées à toute référence de variable.
   </para>
  </refsect2>
  
  <refsect2 id="sql-groupby">
   <title id="sql-groupby-title">Clause <literal>GROUP BY</literal></title>

   <para>
    La clause <literal>GROUP BY</literal> optionnelle a la forme générale
<synopsis>GROUP BY <replaceable class="parameter">expression</replaceable> [, ...]
</synopsis>
   </para>

   <para>
    <literal>GROUP BY</literal> condense en une seule ligne toutes les lignes
    sélectionnées qui partagent les mêmes valeurs pour les expressions
    regroupées. <replaceable class="parameter">expression</replaceable> peut être
    le nom d'une colonne en entrée, le nom ou le numéro d'une colonne
    en sortie (élément de la liste <command>SELECT</command>), ou une 
    expression
    quelconque formée de valeurs de colonnes en entrée. En cas
    d'ambiguïté, un nom de <literal>GROUP BY</literal> est interprété comme un nom
    de colonne en entrée, non en sortie.
   </para>

   <para>
    Les fonctions d'agrégat, si utilisées, sont calculées pour
    toutes les lignes composant un groupe, produisant une valeur séparée
    pour chaque groupe (alors que sans <literal>GROUP BY</literal>, un agrégat
    produit une valeur unique calculée pour toutes les lignes
    sélectionnées). Quand <literal>GROUP BY</literal> est présent, 
    les expressions du <command>SELECT</command> ne peuvent faire
    référence qu'à des colonnes groupées, sauf à l'intérieur de fonctions
    d'agrégat, la valeur de retour d'une colonne non-groupée n'étant
    pas unique.
   </para>
  </refsect2>

  <refsect2 id="sql-having">
   <title id="sql-having-title">Clause <literal>HAVING</literal></title>

   <para>
    La clause optionnelle <literal>HAVING</literal> a la forme générale
<synopsis>HAVING <replaceable class="parameter">condition</replaceable>
</synopsis>
    où <replaceable class="parameter">condition</replaceable> est identique à
    celle spécifiée pour la clause <literal>WHERE</literal>.
   </para>
    
   <para>
    <literal>HAVING</literal> élimine les lignes groupées qui ne satisfont
    pas à la condition. <literal>HAVING</literal> est différent de
    <literal>WHERE</literal>&nbsp;: <literal>WHERE</literal> filtre les lignes
    individuelles avant l'application de <literal>GROUP BY</literal> alors que
    <literal>HAVING</literal> filtre les lignes groupées créées par
    <literal>GROUP BY</literal>. Chaque colonne référencée dans <replaceable
    class="parameter">condition</replaceable> doit faire référence sans ambiguïté 
    à une colonne groupée, sauf si la référence apparaît dans une fonction
    d'agrégat.
   </para>
    
   <para>
    Même en l'absence de clause <literal>GROUP BY</literal>, la présence de
    <literal>HAVING</literal> transforme une requête en requête groupée.
    Cela correspond au comportement d'une requête contenant des fonctions
    d'agrégats mais pas de clause <literal>GROUP BY</literal>. Les lignes 
    sélectionnées ne forment qu'un groupe, la liste du <command>SELECT</command>
    et la clause <literal>HAVING</literal> ne peuvent donc faire référence
    qu'à des colonnes à l'intérieur de fonctions d'agrégats. Une telle
    requête ne produira qu'une seule ligne si la condition <literal>HAVING</literal>
    est réalisée, aucune dans le cas contraire.
   </para>
  </refsect2>

  <refsect2 id="sql-window">
   <title id="sql-window-title"><literal>WINDOW</literal> Clause</title>

   <para>
    The optional <literal>WINDOW</literal> clause has the general form
<synopsis>
WINDOW <replaceable class="parameter">window_name</replaceable> AS ( <replaceable class="parameter">window_definition</replaceable> ) [, ...]
</synopsis>
    where <replaceable class="parameter">window_name</replaceable> is
    a name that can be referenced from subsequent window definitions or
    <literal>OVER</literal> clauses, and
    <replaceable class="parameter">window_definition</replaceable> is
<synopsis>
[ <replaceable class="parameter">existing_window_name</replaceable> ]
[ PARTITION BY <replaceable class="parameter">expression</replaceable> [, ...] ]
[ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <replaceable class="parameter">frame_clause</replaceable> ]
</synopsis>
   </para>

   <para>
    If an <replaceable class="parameter">existing_window_name</replaceable>
    is specified it must refer to an earlier entry in the
    <literal>WINDOW</literal>
    list; the new window copies its partitioning clause from that entry,
    as well as its ordering clause if any.  In this case the new window cannot
    specify its own <literal>PARTITION BY</literal> clause, and it can specify
    <literal>ORDER BY</literal> only if the copied window does not have one.
    The new window always uses its own frame clause; the copied window
    must not specify a frame clause.
   </para>

   <para>
    The elements of the <literal>PARTITION BY</literal> list are interpreted in
    the same fashion as elements of a
    <xref linkend="sql-groupby" endterm="sql-groupby-title"/>, and
    the elements of the <literal>ORDER BY</literal> list are interpreted in the
    same fashion as elements of an
    <xref linkend="sql-orderby" endterm="sql-orderby-title"/>.
    The only difference is that these expressions can contain aggregate
    function calls, which are not allowed in a regular <literal>GROUP
    BY</literal>
    clause.  They are allowed here because windowing occurs after grouping
    and aggregation.
   </para>

   <para>
    The optional <replaceable class="parameter">frame_clause</replaceable> defines
    the <firstterm>window frame</firstterm> for window functions that depend on the
    frame (not all do).  It can be one of
<synopsis>
RANGE UNBOUNDED PRECEDING
RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
ROWS UNBOUNDED PRECEDING
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
</synopsis>
    The first two are equivalent and are also the default: they set the
    frame to be all rows from the partition start up through the current row's
    last peer in the <literal>ORDER BY</literal> ordering (which means all rows if
    there is no <literal>ORDER BY</literal>).  The options
    <literal>RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED
    FOLLOWING</literal> and
    <literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</literal>
    are also equivalent: they always select all rows in the partition.
    Lastly, <literal>ROWS UNBOUNDED PRECEDING</literal> or its verbose equivalent
    <literal>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</literal> select
    all rows up through the current row (regardless of duplicates).
    Beware that this option can produce implementation-dependent results
    if the <literal>ORDER BY</literal> ordering does not order the rows uniquely.
   </para>

   <para>
    The purpose of a <literal>WINDOW</literal> clause is to specify the
    behavior of <firstterm>window functions</firstterm> appearing in the query's
    <xref linkend="sql-select-list" endterm="sql-select-list-title"/> or
    <xref linkend="sql-orderby" endterm="sql-orderby-title"/>.  These functions
    can reference the <literal>WINDOW</literal> clause entries by name
    in their <literal>OVER</literal> clauses.  A <literal>WINDOW</literal> clause
    entry does not have to be referenced anywhere, however; if it is not
    used in the query it is simply ignored.  It is possible to use window
    functions without any <literal>WINDOW</literal> clause at all, since
    a window function call can specify its window definition directly in
    its <literal>OVER</literal> clause.  However, the <literal>WINDOW</literal>
    clause saves typing when the same window definition is needed for more
    than one window function.
   </para>

   <para>
    Window functions are described in detail in
    <xref linkend="tutorial-window"/>,
    <xref linkend="syntax-window-functions"/>, and
    <xref linkend="queries-window"/>.
   </para>
  </refsect2>

  <refsect2 id="sql-select-list">
   <title id="sql-select-list-title">Liste <command>SELECT</command></title>

   <para>
    La liste <command>SELECT</command> (entre les mots clés
    <literal>SELECT</literal> et <literal>FROM</literal>) spécifie les expressions qui
    forment les lignes en sortie de l'instruction <command>SELECT</command>.
    Il se peut que les expressions fassent (en général elles le font) référence aux colonnes
    traitées dans la clause <literal>FROM</literal>. 
   </para>

   <para>
    Just as in a table, every output column of a <command>SELECT</command>
    has a name.  In a simple <command>SELECT</command> this name is just
    used to label the column for display, but when the
    <command>SELECT</command>
    is a sub-query of a larger query, the name is seen by the larger query
    as the column name of the virtual table produced by the sub-query.
    To specify the name to use for an output column, write
    <literal>AS</literal> <replaceable class="parameter">output_name</replaceable>
    after the column's expression.  (You can omit <literal>AS</literal>,
    but only if the desired output name does not match any
    <productname>PostgreSQL</productname> keyword (see <xref
    linkend="sql-keywords-appendix"/>).  For protection against possible
    future keyword additions, it is recommended that you always either
    write <literal>AS</literal> or double-quote the output name.)
    If you do not specify a column name, a name is chosen automatically
    by <productname>PostgreSQL</productname>.  If the column's expression
    is a simple column reference then the chosen name is the same as that
    column's name; in more complex cases a generated name looking like
    <literal>?column<replaceable>N</replaceable>?</literal> is usually chosen.
   </para>

   <para>
    An output column's name can be used to refer to the column's value in
    <literal>ORDER BY</literal> and <literal>GROUP BY</literal> clauses, but not in the
    <literal>WHERE</literal> or <literal>HAVING</literal> clauses; there you must write
    out the expression instead.
   </para>

   <para>
    <literal>*</literal> peut être utilisé, à la place d'une expression, dans la
    liste de sortie comme raccourci pour toutes les colonnes des lignes
    sélectionnées. De plus, 
    <literal><replaceable class="parameter">nom_table</replaceable>.*</literal>
    peut être écrit comme raccourci pour toutes les colonnes de cette table. In these
    cases it is not possible to specify new names with <literal>AS</literal>;
    the output column names will be the same as the table columns' names.
   </para>
  </refsect2>

  <refsect2 id="sql-union">
   <title id="sql-union-title">Clause <literal>UNION</literal></title>

   <para>
    La clause <literal>UNION</literal> a la forme générale&nbsp;:
<synopsis><replaceable class="parameter">instruction_select</replaceable> UNION [ ALL ] <replaceable class="parameter">instruction_select</replaceable>
</synopsis>
    <replaceable class="parameter">instruction_select</replaceable> est une
    instruction <command>SELECT</command> sans clause <literal>ORDER BY</literal>,
    <literal>LIMIT</literal>, <literal>FOR SHARE</literal> ou <literal>FOR
    UPDATE</literal>. (<literal>ORDER BY</literal> et
    <literal>LIMIT</literal> peuvent être attachés à une sous-expression si elle est
    entourée de parenthèses. Sans parenthèses, ces clauses s'appliquent
    au résultat de l'<literal>UNION</literal>, non à l'expression à sa droite.)
   </para>
    
   <para>
    L'opérateur <literal>UNION</literal> calcule l'union ensembliste des
    lignes renvoyées par les instructions <command>SELECT</command> impliquées.
    Une ligne est dans l'union de deux ensembles de résultats si elle apparaît
    dans au moins un des ensembles. Les deux instructions
    <command>SELECT</command> qui représentent les opérandes directes de
    l'<literal>UNION</literal> doivent produire le même nombre de colonnes et
    les colonnes correspondantes doivent être d'un type de données compatible.
   </para>
    
   <para>
    Sauf lorsque l'option <literal>ALL</literal> est spécifiée, il n'y a pas
    de doublons dans le résultat de <literal>UNION</literal>. <literal>ALL</literal>
    empêche l'élimination des lignes dupliquées. <literal>UNION
    ALL</literal> est donc significativement plus rapide qu'<literal>UNION</literal>, 
    et sera préféré.
   </para>
    
   <para>
    Si une instruction
    <command>SELECT</command> contient plusieurs opérateurs <literal>UNION</literal>,
    ils sont évalués de gauche à droite, sauf si l'utilisation de parenthèses
    impose un comportement différent.
   </para>
    
   <para>
    Actuellement, <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal> ne peuvent
    pas être spécifiés pour un résultat d'<literal>UNION</literal> ou pour toute entrée
    d'un <literal>UNION</literal>.
   </para>
  </refsect2>

  <refsect2 id="sql-intersect">
   <title id="sql-intersect-title">Clause <literal>INTERSECT</literal></title>

   <para>
    La clause <literal>INTERSECT</literal> a la forme générale&nbsp;:
<synopsis><replaceable class="parameter">instruction_select</replaceable> INTERSECT [ ALL ] <replaceable class="parameter">instruction_select</replaceable>
</synopsis>
    <replaceable class="parameter">instruction_select</replaceable> est une
    instruction <command>SELECT</command> sans clause <literal>ORDER BY</literal>,
    <literal>LIMIT</literal>, <literal>FOR UPDATE</literal> ou <literal>FOR SHARE</literal>.
   </para>

   <para>
    L'opérateur <literal>INTERSECT</literal> calcule l'intersection des lignes
    renvoyées par les instructions <command>SELECT</command> impliquées. Une
    ligne est dans l'intersection des deux ensembles de résultats si elle
    apparaît dans chacun des deux ensembles.
   </para>
    
   <para>
    Le résultat d'<literal>INTERSECT</literal> ne contient aucune ligne
    dupliquée sauf si l'option <literal>ALL</literal> est spécifiée. Dans ce cas,
    une ligne dupliquée <replaceable>m</replaceable> fois dans
    la table gauche et <replaceable>n</replaceable> fois dans la table droite
    apparaît min(<replaceable>m</replaceable>,<replaceable>n</replaceable>) fois dans
    l'ensemble de résultats.
   </para>
    
   <para>
    Si une instruction
    <command>SELECT</command> contient plusieurs opérateurs <literal>INTERSECT</literal>,
    ils sont évalués de gauche à droite, sauf si l'utilisation de parenthèses
    impose un comportement différent. <literal>INTERSECT</literal> a une 
    priorité supérieur à celle d'<literal>UNION</literal>. C'est-à-dire que <literal>A 
    UNION B INTERSECT C</literal> est lu comme <literal>A UNION (B INTERSECT
    C)</literal>.
   </para>

   <para>
    Actuellement, <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal> ne peuvent 
    pas être spécifiés pour un résultat d'<literal>INTERSECT</literal> ou pour une
    entrée d'<literal>INTERSECT</literal>.
   </para>
  </refsect2>

  <refsect2 id="sql-except">
   <title id="sql-except-title">Clause <literal>EXCEPT</literal></title>

   <para>
    La clause <literal>EXCEPT</literal> a la forme générale&nbsp;:
<synopsis><replaceable class="parameter">instruction_select</replaceable> EXCEPT [ ALL ] <replaceable class="parameter">instruction_select</replaceable>
</synopsis>
    <replaceable class="parameter">instruction_select</replaceable> est une
    instruction <command>SELECT</command> sans clause <literal>ORDER
    BY</literal>, <literal>LIMIT</literal>, <literal>FOR UPDATE</literal> ou
    <literal>FOR SHARE</literal>.
   </para>

   <para>
    L'opérateur <literal>EXCEPT</literal> calcule l'ensemble de lignes qui appartiennent
    au résultat de l'instruction <command>SELECT</command> de gauche mais
    pas à celui de droite.
   </para>
    
   <para>
    Le résultat d'<literal>EXCEPT</literal> ne contient aucune ligne
    dupliquée sauf si l'option <literal>ALL</literal> est spécifiée. Dans ce cas,
    une ligne dupliquée <replaceable>m</replaceable> fois dans
    la table gauche et <replaceable>n</replaceable> fois dans la table droite
    apparaît max(<replaceable>m</replaceable>-<replaceable>n</replaceable>,0) fois dans
    l'ensemble de résultats.
   </para>
    
   <para>
    Si une instruction
    <command>SELECT</command> contient plusieurs opérateurs <literal>EXCEPT</literal>,
    ils sont évalués de gauche à droite, sauf si l'utilisation de parenthèses
    impose un comportement différent. <literal>EXCEPT</literal> a la même priorité
    qu'<literal>UNION</literal>.
   </para>

   <para>
    Actuellement, <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal> ne peuvent 
    pas être spécifiés dans un résultat <literal>EXCEPT</literal> ou pour une entrée
    d'un <literal>EXCEPT</literal>.
   </para>
  </refsect2>

  <refsect2 id="sql-orderby">
   <title id="sql-orderby-title">Clause <literal>ORDER BY</literal></title>

   <para>
    La clause optionnelle <literal>ORDER BY</literal> a la forme
    générale&nbsp;:
 <synopsis>ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">opérateur</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...]
</synopsis>
    La clause <literal>ORDER BY</literal> impose le tri des lignes de résultat 
    suivant les expressions spécifiées. Si deux lignes sont
    identiques suivant l'expression la plus à gauche, elles sont comparées avec
    l'expression suivante et ainsi de suite. Si elles sont identiques pour
    toutes les expressions de tri, elles sont renvoyées dans un ordre
    dépendant de l'implantation.
   </para>

   <para>
    Chaque <replaceable class="parameter">expression</replaceable> peut être le
    nom ou le numéro ordinal d'une colonne en sortie (élément de la liste
    <command>SELECT</command>). Elle peut aussi être une expression arbitraire
    formée à partir de valeurs des colonnes.
   </para>

   <para>
    Le numéro ordinal fait référence à la position ordinale (de gauche à 
    droite) de la colonne de résultat. Cette fonctionnalité permet de définir un ordre
    sur la base d'une colonne dont le nom n'est pas unique. Ce n'est 
    pas particulièrement nécessaire parce qu'il est toujours possible d'affecter un nom à
    une colonne de résultat avec la clause <literal>AS</literal>.
   </para>
    
   <para>
    Il est aussi possible d'utiliser des expressions quelconques dans la clause
    <literal>ORDER BY</literal>, ce qui inclut des colonnes qui n'apparaissent pas
    dans la liste résultat du <command>SELECT</command>. Ainsi,
    l'instruction suivante est valide&nbsp;:
<programlisting>SELECT nom FROM distributeurs ORDER BY code;
</programlisting>
    Il y a toutefois une limitation à cette fonctionnalité. La clause
    <literal>ORDER BY</literal> qui s'applique au résultat d'une clause <literal>UNION</literal>,
    <literal>INTERSECT</literal> ou <literal>EXCEPT</literal> ne peut spécifier
    qu'un nom ou numéro de colonne en sortie, pas une expression.
   </para>
    
   <para>
    Si une expression <literal>ORDER BY</literal> est un nom qui correspond à
    la fois à celui d'une colonne résultat et à celui d'une colonne en entrée,
    <literal>ORDER BY</literal> l'interprète comme le nom de la colonne résultat.
    Ce comportement est à l'opposé de celui de <literal>GROUP BY</literal> dans la même
    situation. Cette incohérence est imposée par la compatibilité avec le
    standard SQL.
   </para>
    
   <para>
    Un mot clé <literal>ASC</literal> (ascendant) ou <literal>DESC</literal> (descendant) 
    peut être ajouté après toute expression de la
    clause <literal>ORDER BY</literal>. <literal>ASC</literal> est la valeur utilisée par défaut.
    Un nom d'opérateur d'ordre spécifique
    peut également être fourni dans la clause <literal>USING</literal>.
    Un opérateur de tri doit être un membre plus-petit-que ou plus-grand-que de
    certaines familles d'opérateur B-tree.
    <literal>ASC</literal> est
    habituellement équivalent à <literal>USING &lt;</literal> et <literal>DESC</literal>
    à <literal>USING &gt;</literal>. Le créateur d'un
    type de données utilisateur peut définir à sa guise le tri par
    défaut qui peut alors correspondre à des opérateurs de nom différent.
   </para>

   <para>
    Si <literal>NULLS LAST</literal> est indiqué, les valeurs NULL sont listées
    après toutes les valeurs non NULL&nbsp; si <literal>NULLS FIRST</literal>
    est indiqué, les valeurs NULL apparaissent avant toutes les valeurs non
    NULL. Si aucune des deux n'est présente, le comportement par défaut est
    <literal>NULLS LAST</literal> quand <literal>ASC</literal> est utilisé
    (de façon explicite ou non) et <literal>NULLS FIRST</literal> quand
    <literal>DESC</literal> est utilisé (donc la valeur par défaut est d'agir
    comme si les NULL étaient plus grands que les non NULL). Quand
    <literal>USING</literal> est indiqué, le tri des NULL par défaut dépend
    du fait que l'opérateur est un plus-petit-que ou un plus-grand-que.
   </para>

   <para>
    Notez que les options de tri s'appliquent seulement à l'expression qu'elles
    suivent. Par exemple, <literal>ORDER BY x, y DESC</literal> ne signifie pas
    la même chose que <literal>ORDER BY x DESC, y DESC</literal>.
   </para>

   <para>
    Les données de chaînes de caractères sont triées suivant l'ordre spécifique
    à la locale, ordre établi au moment de la création de la base de données.
   </para>
  </refsect2>

  <refsect2 id="sql-distinct">
  <title id="sql-distinct-title">Clause <literal>DISTINCT</literal></title>

  <para>
   Si <literal>DISTINCT</literal> est spécifié, toutes les lignes dupliquées sont
   supprimées de l'ensemble de résultats (une ligne est conservée pour chaque
   groupe de lignes dupliquées). <literal>ALL</literal> spécifie le contraire&nbsp;:
   toutes les lignes sont conservées&nbsp;; c'est la valeur par défaut.
  </para>

  <para>
   <literal>DISTINCT ON ( <replaceable class="parameter">expression</replaceable> [, ...] )</literal>
   ne conserve que la première ligne de chaque ensemble pour lesquels il y a 
   identité des expressions. Les expressions 
   <literal>DISTINCT ON</literal> sont interprétées en utilisant les mêmes règles que pour
   <literal>ORDER BY</literal> (voir ci-dessus). La <quote>première
   ligne</quote> de chaque ensemble n'est pas prévisible sauf si <literal>ORDER
   BY</literal> est utilisé. 
   Par exemple&nbsp;:
<programlisting>  SELECT DISTINCT ON (emplacement) emplacement, heure, rapport
  FROM rapports_meteo
  ORDER BY emplacement, heure DESC;
</programlisting>
   récupère le rapport météo le plus récent de chaque emplacement. 
   Si <literal>ORDER BY</literal> n'est pas utilisé pour forcer l'ordre
   descendant des valeurs heure de chaque emplacement, le
   rapport est ordonné suivant des temps aléatoires.
  </para>

  <para>
   Le(s) expression(s) <literal>DISTINCT ON</literal> doi(ven)t correspondre à
   l'ordre des expression <literal>ORDER BY</literal>. La clause <literal>ORDER
   BY</literal> contient des expressions supplémentaires qui déterminent
   la précédence désirée des lignes à l'intérieur de chaque groupe
   <literal>DISTINCT ON</literal>.
  </para>
  </refsect2>

 <refsect2 id="sql-limit">
   <title id="sql-limit-title">Clause <literal>LIMIT</literal></title>

   <para>
    La clause <literal>LIMIT</literal> est constituée de deux sous-clauses
    indépendantes&nbsp;:
<synopsis>LIMIT { <replaceable class="parameter">nombre</replaceable> | ALL }
OFFSET <replaceable class="parameter">début</replaceable>
</synopsis>
    <replaceable class="parameter">nombre</replaceable> spécifie le nombre
    maximum de lignes à renvoyer alors que <replaceable
    class="parameter">début</replaceable> spécifie le nombre de lignes à passer
    avant de commencer à renvoyer des lignes. Lorsque les deux clauses sont spécifiées,
    <replaceable class="parameter">début</replaceable> lignes sont passées 
    avant de commencer à compter les <replaceable
    class="parameter">nombre</replaceable> lignes à renvoyer.
   </para>

   <para>
    If the <replaceable class="parameter">count</replaceable> expression
    evaluates to NULL, it is treated as <literal>LIMIT ALL</literal>, i.e., no
    limit.  If <replaceable class="parameter">start</replaceable> evaluates
    to NULL, it is treated the same as <literal>OFFSET 0</literal>.
   </para>

   <para>
    SQL:2008 introduced a different syntax to achieve the same thing,
    which PostgreSQL also supports.  It is:
<synopsis>
OFFSET <replaceable class="parameter">start</replaceable> { ROW | ROWS }
FETCH { FIRST | NEXT } [ <replaceable class="parameter">count</replaceable> ] { ROW | ROWS } ONLY
</synopsis>
    Both clauses are optional, but if present
    the <literal>OFFSET</literal> clause must come before
    the <literal>FETCH</literal> clause.  <literal>ROW</literal>
    and <literal>ROWS</literal> as well as <literal>FIRST</literal>
    and <literal>NEXT</literal> are noise words that don't influence
    the effects of these clauses.  In this syntax, when using expressions
    other than simple constants for <replaceable
    class="parameter">start</replaceable>
    or <replaceable class="parameter">count</replaceable>, parentheses will be
    necessary in most cases.  If <replaceable
    class="parameter">count</replaceable> is
    omitted in <literal>FETCH</literal>, it defaults to 1.
   </para>

   <para>
    Avec <literal>LIMIT</literal>, utiliser la clause
    <literal>ORDER BY</literal> permet de contraindre l'ordre des lignes de
    résultat. Dans le cas contraire, le sous-ensemble obtenu n'est pas prévisible &mdash;
    rien ne permet de savoir à quel ordre correspondent les lignes retournées. 
    Celui-ci ne sera pas connu tant qu'<literal>ORDER BY</literal> n'aura pas été précisé.
   </para>

   <para>
    Lors de la génération d'un plan de requête, le planificateur tient compte
    de <literal>LIMIT</literal>. Le risque est donc grand d'obtenir des plans
    qui diffèrent (ordres des lignes différents) suivant les valeurs
    utilisées pour <literal>LIMIT</literal> et <literal>OFFSET</literal>. Ainsi, sélectionner
    des sous-ensembles différents d'un résultat à partir de valeurs différentes
    de <literal>LIMIT</literal>/<literal>OFFSET</literal> <emphasis>aboutit à des résultats
    incohérents</emphasis> à moins d'avoir figé l'ordre des lignes à l'aide
    de la clause <literal>ORDER BY</literal>. Ce n'est pas un bogue, mais une conséquence
    du fait que SQL n'assure pas l'ordre de présentation des résultats sans
    utilisation d'une clause <literal>ORDER BY</literal>.
   </para>

   <para>
    Il est même possible pour des exécutions répétées de la même requête
    <literal>LIMIT</literal> de renvoyer différents sous-ensembles des lignes
    d'une table s'il n'y a pas de clause <literal>ORDER BY</literal> pour forcer
    la sélection d'un sous-ensemble déterministe. Encore une fois, ce n'est pas
    un bogue&nbsp;; le déterminisme des résultats n'est tout simplement pas
    garanti dans un tel cas.
   </para>
  </refsect2>

  <refsect2 id="sql-for-update-share">
   <title id="sql-for-update-share-title">Clause <literal>FOR UPDATE</literal>/<literal>FOR SHARE</literal></title>

   <para>
    La clause <literal>FOR UPDATE</literal> a la forme&nbsp;:
<synopsis>FOR UPDATE [ OF <replaceable class="parameter">nom_table</replaceable> [, ...] ] [ NOWAIT ]
</synopsis>
   </para>

   <para>
    La clause liée, <literal>FOR SHARE</literal>, a la forme&nbsp;:
<synopsis>FOR SHARE [ OF <replaceable class="parameter">nom_table</replaceable> [, ...] ] [ NOWAIT ]
</synopsis>
   </para>


   <para>
    <literal>FOR UPDATE</literal> verrouille pour modification les lignes récupérées par
    l'instruction <command>SELECT</command>.
    Cela les empêche d'être modifiées ou supprimées par les autres transactions
    jusqu'à la fin de la transaction en cours. Les autres
    transactions qui tentent des <command>UPDATE</command>,
    <command>DELETE</command> ou <command>SELECT FOR UPDATE</command> sur ces
    lignes sont bloquées jusqu'à la fin de la transaction courante. De
    plus, si un <command>UPDATE</command>, <command>DELETE</command> ou
    <command>SELECT FOR UPDATE</command> a
    déjà verrouillé une ligne ou un ensemble de lignes à partir d'une autre transaction,
    <command>SELECT FOR UPDATE</command> attend la fin de l'autre transaction puis verrouille et
    renvoie la ligne modifiée (ou aucune ligne si elle a été supprimée). Pour
    plus d'informations, voir <xref linkend="mvcc"/>.
   </para>

   <para>
    Pour éviter à l'opération d'attendre la validation des autres transactions,
    on utilise l'option <literal>NOWAIT</literal>. <command>SELECT FOR UPDATE
    NOWAIT</command> rapporte une erreur si une ligne
    sélectionnée ne peut pas être verrouillée immédiatement. Il n'y a pas 
    d'attente.
    <literal>NOWAIT</literal> s'applique seulement au(x) verrou(x) niveau ligne
    &mdash; le verrou niveau table <literal>ROW SHARE</literal> est toujours
    pris de façon ordinaire (voir <xref linkend="mvcc"/>). 
    L'option <literal>NOWAIT</literal> de <xref linkend="sql-lock" endterm="sql-lock-title"/>
    peut toujours être utilisée pour acquérir le verrou niveau table sans attendre.
   </para>

   <para>
    <literal>FOR SHARE</literal> a un comportement similaire. La différence
    se situe dans le type de verrou acquis. Contrairement à 
    <literal>FOR UPDATE</literal> qui pose un verrou exclusif,
    <literal>FOR SHARE</literal> pose un verrou partagé sur chaque ligne récupérée.
    Un verrou partagée bloque les instructions <command>UPDATE</command>,
    <command>DELETE</command> ou <command>SELECT FOR UPDATE</command>
    des transaction concurrentes accédant à ces lignes, mais il n'interdit
    pas les <command>SELECT FOR SHARE</command>.
   </para>

   <para>
    Si des tables particulières sont nommées dans les clauses <literal>FOR UPDATE</literal>
    et <literal>FOR SHARE</literal>, alors seules les lignes provenant de ces
    tables sont verrouillées&nbsp;; toute autre table utilisée dans le
    <command>SELECT</command> est simplement lue. Une clause
    <literal>FOR UPDATE</literal> ou <literal>FOR SHARE</literal> sans liste de
    tables affecte toute les tables utilisées dans la commande. Si
    <literal>FOR UPDATE</literal> ou <literal>FOR SHARE</literal> est appliquée
    à une vue ou à une sous-requête, cela affecte toutes les tables utilisées
    dans la vue ou la sous-requête.
   </para>

   <para>
    Plusieurs clauses <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal>
    peuvent être données si il est nécessaire de spécifier différents
    comportements de verrouillage pour différentes tables. Si la même table
    est mentionné (ou affectée implicitement) par les clauses
    <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal>, alors elle
    est traitée comme un simple <literal>FOR UPDATE</literal>. De façon similaire,
    une table est traitée avec <literal>NOWAIT</literal> si c'est spécifiée sur
    au moins une des clauses qui l'affectent.
   </para>

   <para>
    <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal> nécessitent
    que chaque ligne retournée soit clairement identifiable par une ligne
    individuelle d'une table&nbsp;; ces options ne peuvent, par exemple, pas être
    utilisées avec des fonctions d'aggrégats.
   </para>

  <caution>
   <para>
    Évitez de verrouiller une ligne puis de la modifier après un nouveau point
    de sauvegarde ou après un bloc d'exception <application>PL/pgSQL</application>.
    L'annulation suivante pourrait causer la perte du verrou. Par exemple&nbsp;:
<programlisting>
BEGIN;
SELECT * FROM ma_table WHERE cle = 1 FOR UPDATE;
SAVEPOINT s;
UPDATE ma_table SET ... WHERE cle = 1;
ROLLBACK TO s;
</programlisting>
    Après le <command>ROLLBACK</command>, la ligne est réellement déverrouillée
    au lieu de retourner à son état avant le point de sauvegarde. Ceci peut
    arriver si une ligne verrouillée dans la transaction en cours est mise à
    jour ou supprimée, ou si un verrou partagé est passé en verrou exclusif&nbsp;:
    dans tous ces cas, l'état précédent du verrou est oublié. Si la transation
    est ensuite annulée à un état entre la commande de verrou initiale et la
    modification qui a suivi, la ligne n'apparaîtra plus verrouillée. Ceci est
    une déficience de l'implémentation qui sera corrigée dans une prochaine
    version de <productname>PostgreSQL</productname>.
   </para>
  </caution>

  <caution>
   <para>
    Il est possible qu'une commande <command>SELECT</command> qui utilise
    simultanément les clauses <literal>LIMIT</literal> et
    <literal>FOR UPDATE/SHARE</literal> retourne moins de lignes que
    le nombre spécifié par <literal>LIMIT</literal>. En effet, 
    <literal>LIMIT</literal> est appliqué le premier. La commande 
    sélectionne le nombre de lignes spécifiées, mais peut être bloquée
    en essayant d'obtenir un verrou sur l'une ou l'autre de ces lignes.
    Lorsque le <literal>SELECT</literal> est débloqué, la ligne peut avoir été 
    supprimée ou modifiée de telle sorte qu'elle ne remplisse plus les
    conditions imposées par la clause <literal>WHERE</literal>. Dans ce cas, 
    elle n'est pas retournée.
   </para>
  </caution>
  
  <caution>
   <para>
    De façon similaire, il est possible qu'une commande <command>SELECT</command>
    utilisant <literal>ORDER BY</literal> et <literal>FOR
    UPDATE/SHARE</literal> renvoient les lignes dans un ordre différent. Ceci
    est dû au fait que <literal>ORDER BY</literal> est d'abord appliqué. La commande
    trie le résultat mais pourrait ensuite bloquer en essayant d'obtenir un
    verrou sur une ou plusieurs lignes. Une fois que le <literal>SELECT</literal>
    est débloqué, une des colonnes ordonnées peut avoir été modifiée et être
    renvoyée dans un ordre différent. Un contournement de ce problème revient à
    réaliser un <command>SELECT ... FOR UPDATE/SHARE</command> et ensuite un
    <command>SELECT ... ORDER BY</command>.
   </para>
  </caution>

  </refsect2>

  <refsect2 id="SQL-TABLE">
   <title><literal>TABLE</literal> Command</title>

   <para>
    The command
<programlisting>
TABLE <replaceable class="parameter">name</replaceable>
</programlisting>
    is completely equivalent to
<programlisting>
SELECT * FROM <replaceable class="parameter">name</replaceable>
</programlisting>
    It can be used as a top-level command or as a space-saving syntax
    variant in parts of complex queries.
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Joindre la table <literal>films</literal> avec la table
   <literal>distributeurs</literal>&nbsp;:

<programlisting>SELECT f.titre, f.did, d.nom, f.date_prod, f.genre
    FROM distributeurs d, films f
    WHERE f.did = d.did

       titre       | did |     nom      | date_prod  |   genre
-------------------+-----+--------------+------------+------------
 The Third Man     | 101 | British Lion | 1949-12-23 | Drame
 The African Queen | 101 | British Lion | 1951-08-11 | Romantique
 ...
</programlisting>
  </para>

  <para>
   Additionner la colonne <literal>longueur</literal> de tous les films,
   grouper les résultats par <literal>genre</literal>&nbsp;:

<programlisting>SELECT genre, sum(longueur) AS total FROM films GROUP BY genre;

   genre    | total
------------+-------
 Action     | 07:34
 Comédie    | 02:58
 Drame      | 14:28
 Musical    | 06:42
 Romantique | 04:38
</programlisting>
  </para>

  <para>
   Additionner la colonne <literal>longueur</literal> de tous les films,
   grouper les résultats par <literal>genre</literal> et afficher les groupes 
   dont les totaux font moins de cinq heures&nbsp;:

<programlisting>SELECT genre, sum(longueur) AS total
    FROM films
    GROUP BY genre
    HAVING sum(longueur) &lt; interval '5 hours';

   genre    | total
------------+-------
 Comedie    | 02:58
 Romantique | 04:38
</programlisting>
  </para>

  <para>
   Les deux exemples suivants représentent des façons identiques de trier les résultats
   individuels en fonction du contenu de la deuxième colonne (<literal>nom</literal>)&nbsp;:

<programlisting>SELECT * FROM distributeurs ORDER BY nom;
SELECT * FROM distributeurs ORDER BY 2;

 did |       nom
-----+------------------
 109 | 20th Century Fox
 110 | Bavaria Atelier
 101 | British Lion
 107 | Columbia
 102 | Jean Luc Godard
 113 | Luso films
 104 | Mosfilm
 103 | Paramount
 106 | Toho
 105 | United Artists
 111 | Walt Disney
 112 | Warner Bros.
 108 | Westward
</programlisting>
  </para>

  <para>
   L'exemple suivant présente l'union des tables
   <literal>distributeurs</literal> et <literal>acteurs</literal>, restreignant
   les résultats à ceux de chaque table dont la première lettre est un W.
   Le mot clé <literal>ALL</literal> est omis, ce qui permet de n'afficher que
   les lignes distinctes.

<programlisting>distributeurs:               acteurs:
 did |     nom               id |     nom
-----+--------------        ----+----------------
 108 | Westward               1 | Woody Allen
 111 | Walt Disney            2 | Warren Beatty
 112 | Warner Bros.           3 | Walter Matthau
 ...                         ...

SELECT distributeurs.nom
    FROM distributeurs
    WHERE distributeurs.nom LIKE 'W%'
UNION
SELECT actors.nom
    FROM acteurs
    WHERE acteurs.nom LIKE 'W%';

      nom
----------------
 Walt Disney
 Walter Matthau
 Warner Bros.
 Warren Beatty
 Westward
 Woody Allen
</programlisting>
  </para>

  <para>
   L'exemple suivant présente l'utilisation d'une fonction dans la clause <literal>FROM</literal>,
   avec et sans liste de définition de colonnes&nbsp;:

<programlisting>CREATE FUNCTION distributeurs(int) RETURNS SETOF distributeurs AS $$
    SELECT * FROM distributeurs WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributeurs(111);
 did |    name
-----+-------------
 111 | Walt Disney

CREATE FUNCTION distributeurs_2(int) RETURNS SETOF record AS $$
    SELECT * FROM distributeurs WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributeurs_2(111) AS (f1 int, f2 text);
 f1  |     f2
-----+-------------
 111 | Walt Disney
</programlisting>
  </para>

  <para>
   This example shows how to use a simple <literal>WITH</literal> clause:

<programlisting>
WITH t AS (
    SELECT random() as x FROM generate_series(1, 3)
  )
SELECT * FROM t
UNION ALL
SELECT * FROM t

         x          
--------------------
  0.534150459803641
  0.520092216785997
 0.0735620250925422
  0.534150459803641
  0.520092216785997
 0.0735620250925422
</programlisting>

   Notice that the <literal>WITH</literal> query was evaluated only once,
   so that we got two sets of the same three random values.
  </para>

  <para>
   This example uses <literal>WITH RECURSIVE</literal> to find all
   subordinates (direct or indirect) of the employee Mary, and their
   level of indirectness, from a table that shows only direct
   subordinates:

<programlisting>
WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (
    SELECT 1, employee_name, manager_name
    FROM employee
    WHERE manager_name = 'Mary'
  UNION ALL
    SELECT er.distance + 1, e.employee_name, e.manager_name
    FROM employee_recursive er, employee e
    WHERE er.employee_name = e.manager_name
  )
SELECT distance, employee_name FROM employee_recursive;
</programlisting>

   Notice the typical form of recursive queries:
   an initial condition, followed by <literal>UNION</literal>,
   followed by the recursive part of the query. Be sure that the
   recursive part of the query will eventually return no tuples, or
   else the query will loop indefinitely.  (See <xref linkend="queries-with"/>
   for more examples.)
  </para>
 </refsect1>
 
 <refsect1>
  <title>Compatibilité</title>

  <para>
   L'instruction <command>SELECT</command> est évidemment compatible avec le
   standard SQL. Mais il y a des extensions et quelques fonctionnalités
   manquantes.
  </para>
  
  <refsect2>
   <title>Clauses <literal>FROM</literal> omises</title>

   <para>
    <productname>PostgreSQL</productname> autorise l'omission de la clause
    <literal>FROM</literal>. Cela permet par exemple de calculer le
    résultat d'expressions simples&nbsp;:
<programlisting>SELECT 2+2;

 ?column?
----------
        4
</programlisting>
    D'autres bases de données <acronym>SQL</acronym> interdisent ce comportement,
    sauf à introduire une table virtuelle d'une seule ligne sur laquelle exécuter
    la commande <command>SELECT</command>.
   </para>

   <para>
    S'il n'y a pas de clause <literal>FROM</literal>, la requête ne
    peut pas référencer les tables de la base de données. La
    requête suivante est, ainsi, invalide&nbsp;:
<programlisting>SELECT distributors.* WHERE distributors.name = 'Westward';
</programlisting>
    Les versions antérieures à <productname>PostgreSQL</productname> 8.1 
    acceptaient les requêtes de cette forme en ajoutant une entrée implicite à
    la clause <literal>FROM</literal> pour chaque table référencée.
    Ce n'est plus le comportement par défaut, d'une part
    parce qu'il n'est pas compatible avec le standard SQL et, d'autre part,
    parce que considéré par beaucoup comme générateur d'erreurs. Pour des
    raisons de compatibilité avec les applications utilisant ce
    comportement, la variable de configuration <xref
    linkend="guc-add-missing-from"/> peut toujours être activée.
   </para>
  </refsect2>

  <refsect2>
   <title>Omitting the <literal>AS</literal> Key Word</title>

   <para>
    In the SQL standard, the optional key word <literal>AS</literal> can be
    omitted before an output column name whenever the new column name
    is a valid column name (that is, not the same as any reserved
    keyword).  <productname>PostgreSQL</productname> is slightly more
    restrictive: <literal>AS</literal> is required if the new column name
    matches any keyword at all, reserved or not.  Recommended practice is
    to use <literal>AS</literal> or double-quote output column names, to prevent
    any possible conflict against future keyword additions.
   </para>

   <para>
    In <literal>FROM</literal> items, both the standard and
    <productname>PostgreSQL</productname> allow <literal>AS</literal> to
    be omitted before an alias that is an unreserved keyword.  But
    this is impractical for output column names, because of syntactic
    ambiguities.
   </para>
  </refsect2>

  <refsect2>
   <title><literal>ONLY</literal> and Parentheses</title>

   <para>
    The SQL standard requires parentheses around the table name
    after <literal>ONLY</literal>, as in <literal>SELECT * FROM ONLY
    (tab1), ONLY (tab2) WHERE ...</literal>.  PostgreSQL supports that
    as well, but the parentheses are optional.  (This point applies
    equally to all SQL commands supporting the <literal>ONLY</literal>
    option.)
   </para>
  </refsect2>

  <refsect2>
   <title>Espace logique disponible pour <literal>GROUP BY</literal> et
    <literal>ORDER BY</literal></title>
   
   <para>
    Dans le standard SQL-92, une clause <literal>ORDER BY</literal>
    ne peut utiliser que les noms ou numéros des colonnes en sortie, une clause 
    <literal>GROUP BY</literal> que des expressions fondées sur les noms de
    colonnes en entrée. <productname>PostgreSQL</productname> va plus loin, puisqu'il 
    autorise chacune de ces clauses à utiliser également l'autre possibilité.
    En cas d'ambiguïté, c'est l'interprétation du standard qui prévaut.
    <productname>PostgreSQL</productname> autorise aussi l'utilisation d'expressions
    quelconques dans les deux clauses. 
    Les noms apparaissant dans ces expressions sont toujours considérés comme nom de
    colonne en entrée, pas en tant que nom de colonne du résultat.
   </para>

   <para>
    SQL:1999 et suivant utilisent une définition légèrement différente,
    pas totalement compatible avec le SQL-92. Néanmoins, dans la plupart des
    cas, <productname>PostgreSQL</productname> interprète une expression
    <literal>ORDER BY</literal> ou <literal>GROUP BY</literal> en suivant
    la norme SQL:1999.
   </para>
  </refsect2>

  <refsect2>
   <title><literal>WINDOW</literal> Clause Restrictions</title>

   <para>
    The SQL standard provides additional options for the window
    <replaceable class="parameter">frame_clause</replaceable>.
    <productname>PostgreSQL</productname> currently supports only the
    options listed above.
   </para>
  </refsect2>

  <refsect2>
   <title><literal>LIMIT</literal> and <literal>OFFSET</literal></title>

   <para>
    The clauses <literal>LIMIT</literal> and <literal>OFFSET</literal>
    are <productname>PostgreSQL</productname>-specific syntax, also
    used by <productname>MySQL</productname>.  The SQL:2008 standard
    has introduced the clauses <literal>OFFSET ... FETCH {FIRST|NEXT}
    ...</literal> for the same functionality, as shown above
    in <xref linkend="sql-limit" endterm="sql-limit-title"/>, and this
    syntax is also used by <productname>IBM DB2</productname>.
    (Applications written for <productname>Oracle</productname>
    frequently use a workaround involving the automatically
    generated <literal>rownum</literal> column, not available in
    PostgreSQL, to implement the effects of these clauses.)
   </para>
  </refsect2>

  <refsect2>
   <title>Clauses non standard</title>

   <para>
    La clause <literal>DISTINCT ON</literal> n'est pas définie dans le standard
    SQL.
   </para>
  </refsect2>
 </refsect1>
</refentry>
