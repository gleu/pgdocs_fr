<?xml version="1.0" encoding="UTF-8"?>
<refentry id="sql-select">
 <indexterm zone="sql-select">
  <primary>SELECT</primary>
 </indexterm>

 <indexterm zone="sql-select">
  <primary>commande TABLE</primary>
 </indexterm>

 <indexterm zone="sql-select">
  <primary>WITH</primary>
  <secondary>dans un SELECT</secondary>
 </indexterm>

 <refmeta>
  <refentrytitle>SELECT</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>SELECT</refname>
  <refname>TABLE</refname>
  <refname>WITH</refname>
  <refpurpose>récupère des lignes d'une table ou d'une vue</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <synopsis>[ WITH [ RECURSIVE ] <replaceable class="parameter">requête_with</replaceable> [, ...] ]
SELECT [ ALL | DISTINCT [ ON ( <replaceable class="parameter">expression</replaceable> [, ...] ) ] ]
    [ * | <replaceable class="parameter">expression</replaceable> [ [ AS ] <replaceable class="parameter">nom_d_affichage</replaceable> ] [, ...] ]
    [ FROM <replaceable class="parameter">éléments_from</replaceable> [, ...] ]
    [ WHERE <replaceable class="parameter">condition</replaceable> ]
    [ GROUP BY <replaceable class="parameter">element_regroupement</replaceable> [, ...] ]
    [ HAVING <replaceable class="parameter">condition</replaceable> ]
    [ WINDOW <replaceable class="parameter">nom_window</replaceable> AS ( <replaceable class="parameter">définition_window</replaceable> ) [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] <replaceable class="parameter">select</replaceable> ]
    [ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">opérateur</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { <replaceable class="parameter">nombre</replaceable> | ALL } ]
    [ OFFSET <replaceable class="parameter">début</replaceable> ] [ ROW | ROWS ] ]
    [ FETCH { FIRST | NEXT } [ <replaceable class="parameter">total</replaceable> ] { ROW | ROWS } { ONLY | WITH TIES } ]
    [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF <replaceable class="parameter">nom_table</replaceable> [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]

<phrase>avec <replaceable class="parameter">éléments_from</replaceable> qui peut être&nbsp;:</phrase>

    [ ONLY ] <replaceable class="parameter">nom_table</replaceable> [ * ] [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">alias_colonne</replaceable> [, ...] ) ] ]
                [ TABLESAMPLE <replaceable class="parameter">methode_echantillonnage</replaceable> ( <replaceable class="parameter">argument</replaceable> [, ...] ) [ REPEATABLE ( <replaceable class="parameter">pourcentage_echantillon</replaceable> ) ] ]
    [ LATERAL ] ( <replaceable class="parameter">select</replaceable> ) [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">alias_colonne</replaceable> [, ...] ) ]
    <replaceable class="parameter">nom_requête_with</replaceable> [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">alias_colonne</replaceable> [, ...] ) ] ]
    [ LATERAL ] <replaceable class="parameter">nom_fonction</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] )
                [ WITH ORDINALITY ] [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">alias_colonne</replaceable> [, ...] ) ] ]
    [ LATERAL ] <replaceable class="parameter">nom_fonction</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] ) [ AS ] <replaceable class="parameter">alias</replaceable> ( <replaceable class="parameter">définition_colonne</replaceable> [, ...] )
     [ LATERAL ] <replaceable class="parameter">nom_fonction</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] ) AS ( <replaceable class="parameter">définition_colonne</replaceable> [, ...] )
    [ LATERAL ] ROWS FROM( <replaceable class="parameter">nom_fonction</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] ) [ AS ( <replaceable class="parameter">définition_colonne</replaceable> [, ...] ) ] [, ...] )
                [ WITH ORDINALITY ] [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">alias_colonne</replaceable> [, ...] ) ] ]
    <replaceable class="parameter">éléments_from</replaceable> [ NATURAL ] <replaceable class="parameter">type_jointure</replaceable> <replaceable class="parameter">éléments_from</replaceable> [ ON <replaceable class="parameter">condition_jointure</replaceable> | USING ( <replaceable class="parameter">colonne_jointure</replaceable> [, ...] ) ]

<phrase>et <replaceable class="parameter">element_regroupement</replaceable> peut valoir&nbsp;:</phrase>

    ( )
    <replaceable class="parameter">expression</replaceable>
    ( <replaceable class="parameter">expression</replaceable> [, ...] )
    ROLLUP ( { <replaceable class="parameter">expression</replaceable> | ( <replaceable class="parameter">expression</replaceable> [, ...] ) } [, ...] )
    CUBE ( { <replaceable class="parameter">expression</replaceable> | ( <replaceable class="parameter">expression</replaceable> [, ...] ) } [, ...] )
    GROUPING SETS ( <replaceable class="parameter">element_regroupement</replaceable> [, ...] )

<phrase>et <replaceable class="parameter">requête_with</replaceable> est&nbsp;:</phrase>

    <replaceable class="parameter">nom_requête_with</replaceable> [ ( <replaceable class="parameter">nom_colonne</replaceable> [, ...] ) ] AS [ [ NOT ] MATERIALIZED ] ( <replaceable class="parameter">select</replaceable> | <replaceable class="parameter">valeurs</replaceable> | <replaceable class="parameter">insert</replaceable> | <replaceable class="parameter">update</replaceable> | <replaceable class="parameter">delete</replaceable> )

TABLE [ ONLY ] <replaceable class="parameter">nom_table</replaceable> [ * ]
  </synopsis>

 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-select">
   <primary>SELECT</primary>
  </indexterm>

  <para>
   <command>SELECT</command> récupère des lignes de zéro ou plusieurs
   tables. Le traitement général de <command>SELECT</command> est le
   suivant&nbsp;:

   <orderedlist>
    <listitem>
     <para>
      Toutes les requêtes dans la liste <literal>WITH</literal> sont évaluées.
      Elles jouent le rôle de tables temporaires qui peuvent être référencées
      dans la liste <literal>FROM</literal>. Une requête
      <literal>WITH</literal> qui est référencée plus d'une fois dans
      <literal>FROM</literal> n'est calculée qu'une fois,
      unless specified otherwise with <literal>NOT MATERIALIZED</literal>
      (voir <xref linkend="sql-with"/> ci-dessous).
     </para>
    </listitem>

    <listitem>
     <para>
      Tous les éléments de la liste <literal>FROM</literal> sont calculés.
      (Chaque élément dans la liste <literal>FROM</literal> est une table
      réelle ou virtuelle.) Si plus d'un élément sont spécifiés dans la liste
      <literal>FROM</literal>, ils font l'objet d'une jointure croisée (cross-join). (Voir <xref
      linkend="sql-from"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>WHERE</literal> est spécifiée, toutes les lignes
      qui ne satisfont pas les conditions sont éliminées de l'affichage. (Voir
      <xref linkend="sql-where"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>GROUP BY</literal> est spécifiée or if there are
      aggregate function calls, l'affichage est divisé en groupes de lignes qui
      correspondent à une ou plusieurs valeurs, et aux résultats des fonctions
      d'agrégat calculés.
      Si la clause <literal>HAVING</literal> est présente, elle élimine les
      groupes qui ne satisfont pas la condition donnée. (Voir <xref
      linkend="sql-groupby"/> et <xref
      linkend="sql-having"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Les lignes retournées sont traitées en utilisant les expressions de sortie
      de <command>SELECT</command> pour chaque ligne ou groupe de ligne sélectionné. (Voir <xref
      linkend="sql-select-list"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      <literal>SELECT DISTINCT</literal> élimine du résultat les lignes en double.
      <literal>SELECT DISTINCT ON</literal> élimine les lignes qui correspondent sur toute l'expression spécifiée.
      <literal>SELECT ALL</literal>
      (l'option par défaut) retourne toutes les lignes, y compris les doublons.
      (cf. <xref linkend="sql-distinct"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      En utilisant les opérateurs <literal>UNION</literal>,
      <literal>INTERSECT</literal> et <literal>EXCEPT</literal>, l'affichage
      de plusieurs instructions <command>SELECT</command> peut être combiné
      pour former un ensemble unique de résultats. L'opérateur
      <literal>UNION</literal> renvoie toutes les lignes qui appartiennent, au
      moins, à l'un des ensembles de résultats. L'opérateur
      <literal>INTERSECT</literal> renvoie toutes les lignes qui sont dans
      tous les ensembles de résultats. L'opérateur <literal>EXCEPT</literal>
      renvoie les lignes qui sont présentes dans le premier ensemble de
      résultats mais pas dans le deuxième. Dans les trois cas, les lignes
      dupliquées sont éliminées sauf si <literal>ALL</literal> est spécifié.
      Le mot-clé supplémentaire <literal>DISTINCT</literal> peut être ajouté
      pour signifier explicitement que les lignes en doublon sont éliminées.
      Notez bien que <literal>DISTINCT</literal> est là le comportement par
      défaut, bien que <literal>ALL</literal> soit le défaut pour la commande
      <command>SELECT</command>. (Voir <xref linkend="sql-union"/>, <xref
      linkend="sql-intersect"/> et <xref linkend="sql-except"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>ORDER BY</literal> est spécifiée, les lignes
      renvoyées sont triées dans l'ordre spécifié. Si <literal>ORDER
       BY</literal> n'est pas indiqué, les lignes sont retournées dans l'ordre
      qui permet la réponse la plus rapide du système. (Voir <xref
      linkend="sql-orderby"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si les clauses <literal>LIMIT</literal> (ou <literal>FETCH FIRST</literal>)
      ou <literal>OFFSET</literal> sont
      spécifiées, l'instruction <command>SELECT</command> ne renvoie qu'un
      sous-ensemble de lignes de résultats. (Voir <xref linkend="sql-limit"
       /> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>FOR UPDATE</literal>, <literal>FOR NO KEY UPDATE</literal>,
      <literal>FOR SHARE</literal> ou <literal>FOR KEY SHARE</literal> est spécifiée,
      l'instruction <command>SELECT</command>
      verrouille les lignes sélectionnées contre les mises à jour concurrentes.
      (Voir <xref linkend="sql-for-update-share"
       /> ci-dessous.)
     </para>
    </listitem>
   </orderedlist>
  </para>

  <para>
   Le droit <literal>SELECT</literal> sur chaque colonne utilisée dans une
   commande <command>SELECT</command> est nécessaire pour lire
   ses valeurs. L'utilisation de <literal>FOR NO KEY UPDATE</literal>,
   <literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal> ou
   <literal>FOR KEY SHARE</literal> requiert en plus le droit
   <literal>UPDATE</literal> (pour au moins une colonne de chaque table
   sélectionnée).
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <refsect2 id="sql-with" xreflabel="Clause WITH">
   <title>Clause <literal>WITH</literal></title>

   <para>
    La clause <literal>WITH</literal> vous permet de spécifier une ou plusieurs
    sous-requêtes qui peuvent être utilisées par leur nom dans la requête
    principale.
    Les sous-requêtes se comportent comme des tables temporaires ou des vues
    pendant la durée d'exécution de la requête principale.
    Chaque sous-requête peut être un ordre <command>SELECT</command>, <command>TABLE</command>, <command>VALUES</command>,
    <command>INSERT</command>, <command>UPDATE</command> ou bien
    <command>DELETE</command>.
    Lorsque vous écrivez un ordre de modification de données (<command>INSERT</command>,
    <command>UPDATE</command> ou <command>DELETE</command>) dans une clause
    <literal>WITH</literal>, il est habituel d'inclure une clause <literal>RETURNING</literal>.
    C'est la sortie de cette clause <literal>RETURNING</literal>, <emphasis>et non pas</emphasis> la table sous-jacente
    que l'ordre modifie, qui donne lieu à la table temporaire lue par la requête principale.
    Si la clause <literal>RETURNING</literal> est omise, l'ordre est tout de même exécuté,
    mais il ne produit pas de sortie&nbsp;; il ne peut donc pas être référencé comme une table
    par la requête principale.
   </para>

   <para>
    Un nom (sans qualification de schéma) doit être spécifié pour chaque requête
    <literal>WITH</literal>. En option, une liste de noms de colonnes
    peut être spécifié&nbsp;; si elle est omise, les noms de colonnes sont déduites
    de la sous-requête.
   </para>

   <para>
    Si <literal>RECURSIVE</literal> est spécifié, la sous-requête <command>SELECT</command> peut se
    référencer elle même. Une sous-requête de ce type doit avoir la forme
    <synopsis>
<replaceable class="parameter">terme_non_récursif</replaceable> UNION [ ALL | DISTINCT ] <replaceable class="parameter">terme_récursif</replaceable>
    </synopsis>
    où l'auto-référence récursive doit apparaître dans la partie droite
    de l'<literal>UNION</literal>. Seule une auto-référence récursive
    est autorisée par requête. Les ordres de modification récursifs ne sont pas supportés,
    mais vous pouvez utiliser le résultat d'une commande
    <command>SELECT</command> récursive dans un ordre de modification.
    Voir <xref linkend="queries-with"/> pour un exemple.
   </para>

   <para>
    Un autre effet de <literal>RECURSIVE</literal> est que les requêtes
    <literal>WITH</literal> n'ont pas besoin d'être ordonnées&nbsp;: une
    requête peut en référencer une autre qui se trouve plus loin dans la liste
    (toutefois, les références circulaires, ou récursion mutuelle, ne sont pas
    implémentées). Sans <literal>RECURSIVE</literal>, les requêtes
    <literal>WITH</literal> ne peuvent référencer d'autres requêtes
    <literal>WITH</literal> so&oelig;urs que si elles sont déclarées avant dans
    la liste <literal>WITH</literal>.
   </para>

   <para>
    La requête principale et les requêtes <literal>WITH</literal> sont toutes
    exécutées en même temps. Ceci implique que les effets d'une requête
    modifiant des données dans la clause <literal>WITH</literal> ne peuvent
    pas être vus des autres parties de la requête, autrement qu'en lisant son
    retour avec la clause <literal>RETURNING</literal>. Si des telles
    instructions de modification de données essaient de modifier la même
    ligne, les résultats sont inconnus.
   </para>

   <para>
    Quand il y a plusieurs requêtes dans la clause <literal>WITH</literal>,
    <literal>RECURSIVE</literal> ne devra être écrit qu'une seule fois,
    immédiatement après <literal>WITH</literal>. Cela s'applique à toutes les
    requêtes de la clause <literal>WITH</literal>, bien que cela n'a pas
    d'effet sur les requêtes qui n'utilisent pas de récursion de référence en
    avant (<foreignphrase>forward references</foreignphrase>).
   </para>

   <para>
    Une propriété clé des requêtes <literal>WITH</literal> est qu'elles ne sont
    normalement évaluées qu'une seule fois par exécution de la requête principale,
    même si la 1requête principale les utilise plus d'une fois.
    En particulier, vous avez la garantie que les traitements de modification de données
    sont exécutés une seule et unique fois, que la requête principale lise tout ou partie de leur sortie.
   </para>

   <para>
    Néanmoins, une requête <literal>WITH</literal> peut être marquée
    <literal>NOT MATERIALIZED</literal> pour supprimer cette garantie. Dans ce
    cas, la requête <literal>WITH</literal> peut être intégrée dans la requête
    principale comme s'il s'agissait d'un simple
    sous-<literal>SELECT</literal> dans la clause <literal>FROM</literal> de
    la requête principale. Ceci résulte en des calculs dupliquées sur la
    requête principale fait référence à la requête <literal>WITH</literal>
    plus d'une fois&nbsp;; mais si chaque utilisation requiert seulement
    quelques lignes de la sortie complète de la requête
    <literal>WITH</literal>, la clause <literal>NOT MATERIALIZED</literal>
    peut apporter un gain net en autorisant les requêtes à être optimisées
    globalement. <literal>NOT MATERIALIZED</literal> est ignoré s'il est
    attaché à une requête <literal>WITH</literal> récursive ou qui n'est pas
    sans effet de bord (autrement dit, pas un simple <literal>SELECT</literal>
    contenant aucune fonction volatile).
   </para>

   <para>
    Par défaut, une requête <literal>WITH</literal> sans effet de bord est
    intégrée dans la requête principale si elle est utilisée exactement une
    fois dans la clause <literal>FROM</literal> de la requête. Ceci permet une
    optimisation de la jointure des deux requêtes dans des situations où cela
    serait sémantiquement invisible. Néanmoins, cette intégration peut être
    empêchée en marquant la requête <literal>WITH</literal> avec le mot-clé
    <literal>MATERIALIZED</literal>. Ceci peut être utile si la requête
    <literal>WITH</literal> est utilisée comme barrière d'optimisation pour
    empêcher le planificateur de choisir un mauvais plan. Les versions de
    <productname>PostgreSQL</productname> antérieures à la 12 ne faisaient
    jamais ce type d'intégration, donc les requêtes écrites pour les versions
    précédentes pourraient se fier sur <literal>WITH</literal> comme barrières
    d'optimisation.
   </para>

   <para>
    Voir <xref linkend="queries-with"/> pour plus d'informations.
   </para>
  </refsect2>

  <refsect2 id="sql-from" xreflabel="Clause FROM">
   <title>Clause <literal>FROM</literal></title>

   <para>
    La clause <literal>FROM</literal> spécifie une ou plusieurs tables source
    pour le <command>SELECT</command>. Si plusieurs sources sont spécifiées, le
    résultat est un produit cartésien (jointure croisée) de toutes les sources.
    Mais habituellement, des conditions de qualification (via
    <literal>WHERE</literal>) sont ajoutées pour
    restreindre les lignes renvoyées à un petit sous-ensemble du produit
    cartésien.
   </para>

   <para>
    La clause <literal>FROM</literal> peut contenir les éléments
    suivants&nbsp;:

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">nom_table</replaceable></term>
      <listitem>
       <para>
        Le nom (éventuellement qualifié par le nom du schéma) d'une table ou
        vue existante. Si <literal>ONLY</literal> est spécifié avant le nom de
        la table, seule cette table est parcourue. Dans le cas contraire, la
        table et toutes ses tables filles (s'il y en a) sont parcourues. En
        option, <literal>*</literal> peut être ajouté après le nom de la table
        pour indiquer explicitement que les tables filles sont inclues.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">alias</replaceable></term>
      <listitem>
       <para>
        Un nom de substitution pour l'élément <literal>FROM</literal> contenant
        l' alias. Un alias est utilisé par brièveté ou pour lever toute
        ambiguïté lors d'auto-jointures (la même table est parcourue plusieurs
        fois). Quand un alias est fourni, il cache complètement le nom réel de
        la table ou fonction&nbsp;; par exemple, avec <literal>FROM truc AS</literal>,
        le reste du <command>SELECT</command> doit faire référence à cet
        élément de <literal>FROM</literal> par <literal>f</literal> et non pas par
        <literal>truc</literal>. Si un alias est donné, une liste d' alias de colonnes
        peut aussi être saisi comme noms de substitution pour différentes
        colonnes de la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>TABLESAMPLE <replaceable class="parameter">methode_echantillonnage</replaceable> ( <replaceable class="parameter">argument</replaceable> [, ...] ) [ REPEATABLE ( <replaceable class="parameter">pourcentage_echantillon</replaceable> ) ]</literal></term>
      <listitem>
       <para>
        Une clause <literal>TABLESAMPLE</literal> après un <replaceable
        class="parameter">nom_table</replaceable> indique que la <replaceable
        class="parameter">methode_echantillonnage</replaceable> indiquée doit
        être utilisé pour récupérer un sous-ensemble des lignes de cette
        table. Cet échantillonnage précède l'application de tout autre filtre
        tel que la clause <literal>WHERE</literal>. La distribution standard
        de <productname>PostgreSQL</productname> inclut deux méthodes
        d'échantillonnage, <literal>BERNOULLI</literal>et
        <literal>SYSTEM</literal> mais d'autres méthodes d'échantillonnage
        peuvent être installées via des extensions.
       </para>

       <para>
        Les méthodes d'échantillonnage <literal>BERNOULLI</literal> et
        <literal>SYSTEM</literal> acceptent chacune un seul <replaceable
        class="parameter">argument</replaceable> correspondant à la fraction à
        échantillonner pour la table, exprimée sous la forme d'un pourcentage
        entre 0 et 100.  Cet argument peut être une expression renvoyant un
        flottant (<type>real</type>).  (D'autres méthodes d'échantillonnage
        pourraient accepter plus d'arguments ou des arguments différents.) Ces
        deux méthodes retournent chacune un sous-ensemble choisi au hasard de
        la table qui contiendra approximativement le pourcentage indiqué de
        lignes pour cette table. La méthode <literal>BERNOULLI</literal>
        parcourt la table complète et sélectionne ou ignore des lignes
        individuelles indépendemment avec la probabilité sélectionnée. La
        méthode <literal>SYSTEM</literal> fait un échantillonnage au niveau
        des blocs, chaque bloc ayant la chance indiquée d'être
        sélectionnée&nbsp;; toutes les lignes de chaque bloc sélectionné sont
        renvoyées. La méthode <literal>SYSTEM</literal> est bien plus rapide
        que la méthode <literal>BERNOULLI</literal> quand un petit pourcentage
        est indiqué pour l'échantillonnage mais elle peut renvoyer un
        échantillon moins aléatoire de la table, dû aux effets de l'ordre des
        lignes. </para>

       <para>
        La clause optionnelle <literal>REPEATABLE</literal> indique un nombre
        <replaceable class="parameter">seed</replaceable> ou une expression à
        utiliser pour générer des nombres aléatoires pour la méthode
        d'échantillonnage. La valeur peut être toute valeur flottante non
        NULL. Deux requêtes précisant la même valeur seed et les mêmes valeurs
        en <replaceable class="parameter">argument</replaceable>
        sélectionneront le même échantillon de la table si celle-ci n'a pas
        changé entre temps. Mais différentes valeurs seed produiront
        généralement des échantillons différents. Si
        <literal>REPEATABLE</literal> n'est pas indiqué, alors un nouvel
        échantillon est choisi au hasard pour chaque requête, basé sur une
        graine générée par le système. Notez que
        certaines méthodes d'échantillonage supplémentaires pourraient ne pas
        accepter la clausse <literal>REPEATABLE</literal>, et toujours
        produire de nouveau échantillon à chaque utilisation.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">select</replaceable></term>
      <listitem>
       <para>
        Un sous-<command>SELECT</command> peut apparaître dans la clause
        <literal>FROM</literal>. Il agit comme si sa sortie était
        transformée en table temporaire pour la durée de cette seule commande
        <command>SELECT</command>. Le sous-<command>SELECT</command>
        doit être entouré de parenthèses et un alias
        <emphasis>doit</emphasis> lui être fourni.
        Une commande <xref linkend="sql-values"/>
        peut aussi être utilisée ici.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">requête_with</replaceable></term>
      <listitem>
       <para>
        Une requête <literal>WITH</literal> est référencée par l'écriture de
        son nom, exactement comme si le nom de la requête était un nom de table
        (en fait, la requête <literal>WITH</literal> cache toutes les tables
        qui auraient le même nom dans la requête principale. Si nécessaire, vous
        pouvez accéder à une table réelle du même nom en précisant le schéma
        du nom de la table).
        Un alias peut être indiqué de la même façon que pour une table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nom_fonction</replaceable></term>
      <listitem>
       <para>
        Des appels de fonctions peuvent apparaître dans la clause
        <literal>FROM</literal>. (Cela est particulièrement utile pour les
        fonctions renvoyant des ensembles de résultats, mais n'importe quelle fonction peut
        être utilisée.) Un appel de fonction agit comme si la sortie de la
        fonction était créée comme une table temporaire pour la durée de
        cette seule commande <command>SELECT</command>. Quand la clause
        optionnelle <command>WITH ORDINALITY</command> est ajoutée à l'appel
        de la fonction, une nouvelle colonne est ajoutée après toutes les
        colonnes en sortie de la fonction numérotant ainsi chaque ligne.
       </para>

       <para>
        Un alias peut être fourni de la même façon pour une table. Si un alias
        de table est donné, une liste d'alias de colonnes peut aussi être écrite
        pour fournir des noms de substitution pour un ou plusieurs attributs du
        type composite en retour de la fonction, ceci incluant la colonne ajoutée
        par <literal>ORDINALITY</literal>.
       </para>

       <para>
        Plusieurs appels de fonction peuvent être combinés en un seul élément
        dans la clause <literal>FROM</literal> en les entourant de <literal>ROWS
         FROM( ... )</literal>. La sortie d'un tel élément est la concaténation
        de la première ligne de chaque fonction, puis la deuxième ligne de
        chaque fonction, etc. Si certaines fonctions produisent moins de lignes
        que d'autres, des NULL sont ajoutées pour les données manquantes, ce
        qui permet d'avoir comme nombre de lignes celui de la fonction qui en
        renvoit le plus.
       </para>

       <para>
        Si la fonction a été définie comme renvoyant le type de données
        <type>record</type>, un alias ou le mot clé <literal>AS</literal> doivent
        être présents, suivi par une liste de définition de colonnes de la
        forme <literal>( <replaceable
         class="parameter">nom_colonne</replaceable> <replaceable
         class="parameter">type_donnée</replaceable> <optional>, ...
         </optional>)</literal>. La liste de définition des colonnes doit
        correspondre au nombre réel et aux types réels des colonnes renvoyées
        par la fonction.
       </para>

       <para>
        Lors de l'utilisation de la syntaxe <literal>ROWS FROM( ... )</literal>,
        si une des fonctions nécessite une liste de définition des colonnes, il
        est préférable de placer la liste de définition des colonnes après l'appel
        de la fonction dans <literal>ROWS FROM( ... )</literal>. Une liste ded
        définition des colonnes peut être placé après la construction
        <literal>ROWS FROM( ... )</literal> seulement s'il n'y a qu'une seule
        fonction et pas de clause <literal>WITH ORDINALITY</literal>.
       </para>

       <para>
        Pour utiliser <literal>ORDINALITY</literal> avec une liste de définition
        de colonnes, vous devez utiliser la syntaxe <literal>ROWS
         FROM( ... )</literal> et placer la liste de définition de colonnes dans
        <literal>ROWS FROM( ... )</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">type_jointure</replaceable></term>
      <listitem>
       <para>
        Un des éléments
        <itemizedlist>
         <listitem>
          <para><literal>[ INNER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>LEFT [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>RIGHT [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>FULL [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>CROSS JOIN</literal></para>
         </listitem>
        </itemizedlist>

        Pour les types de jointures <literal>INNER</literal> et <literal>OUTER</literal>, une
        condition de jointure doit être spécifiée, à choisir parmi
        <literal>NATURAL</literal>, <literal>ON <replaceable
         class="parameter">condition_jointure</replaceable></literal> ou
        <literal>USING (<replaceable
         class="parameter">colonne_jointure</replaceable> [, ...])</literal>.
        Voir ci-dessous pour la signification. Pour <literal>CROSS
         JOIN</literal>, aucune de ces clauses ne doit apparaître.
       </para>

       <para>
        Une clause <literal>JOIN</literal> combine deux éléments
        <literal>FROM</literal>, que nous allons appelons <quote>tables</quote>
        par simplicité bien qu'ils puissent être n'importe quel élément
        utilisable dans une clause <literal>FROM</literal>. Les parenthèses
        peuvent être utilisées pour déterminer l'ordre d'imbrication. En l'absence de parenthèses,
        les <literal>JOIN</literal> sont imbriqués de gauche à droite. Dans
        tous les cas, <literal>JOIN</literal> est plus prioritaire que les
        virgules séparant les éléments <literal>FROM</literal>.
       </para>

       <para>
        <literal>CROSS JOIN</literal> et <literal>INNER JOIN</literal> produisent un
        simple produit cartésien. Le résultat est identique à celui obtenu
        lorsque les deux tables sont listés au premier niveau du <literal>FROM</literal>, mais
        restreint par la condition de jointure (si elle existe). <literal>CROSS
         JOIN</literal> est équivalent à <literal>INNER JOIN ON (TRUE)</literal>, c'est-à-dire
        qu'aucune ligne n'est supprimée par qualification. Ces types de
        jointure sont essentiellement une aide à la notation car ils ne font rien de
        plus qu'un simple <literal>FROM</literal> et <literal>WHERE</literal>.
       </para>

       <para>
        <literal>LEFT OUTER JOIN</literal> renvoie toutes les lignes du produit
        cartésien qualifié (c'est-à-dire toutes les lignes combinées qui
        satisfont la condition de jointure), plus une copie de chaque ligne
        de la table de gauche pour laquelle il n'y a pas de ligne à droite
        qui satisfasse la condition de jointure. La ligne de gauche est
        étendue à la largeur complète de la table jointe par insertion de
        valeurs NULL pour les colonnes de droite. Seule la
        condition de la clause <literal>JOIN</literal> est utilisée pour décider des
        lignes qui correspondent. Les conditions externes sont appliquées après
        coup.
       </para>

       <para>
        À l'inverse, <literal>RIGHT OUTER JOIN</literal> renvoie toutes les lignes
        jointes plus une ligne pour chaque ligne de droite sans correspondance
        (complétée par des NULL pour le côté gauche). C'est une simple aide à
        la notation car il est aisément convertible en <literal>LEFT</literal> en
        inversant les tables gauche et droite.
       </para>

       <para>
        <literal>FULL OUTER JOIN</literal> renvoie toutes les lignes jointes, plus
        chaque ligne gauche sans correspondance (étendue par des NULL à droite),
        plus chaque ligne droite sans correspondance (étendue par des NULL à
        gauche).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ON <replaceable class="parameter">condition_jointure</replaceable></literal></term>
      <listitem>
       <para>
        <replaceable class="parameter">condition_jointure</replaceable>
        est une expression qui retourne une valeur de type <type>boolean</type>
        (comme une clause <literal>WHERE</literal>) qui spécifie les
        lignes d'une jointure devant correspondre.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>USING (<replaceable
        class="parameter">colonne_jointure</replaceable> [,
        ...])</literal></term>
      <listitem>
       <para>
        Une clause de la forme <literal>USING ( a, b, ... )</literal> est un
        raccourci pour <literal>ON table_gauche.a = table_droite.a AND table_gauche.b
         = table_droite.b ...</literal>. De plus, <literal>USING</literal> implique
        l'affichage d'une seule paire des colonnes correspondantes dans la sortie
        de la jointure.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NATURAL</literal></term>
      <listitem>
       <para>
        <literal>NATURAL</literal> est un raccourci pour une liste
        <literal>USING</literal> qui mentionne toutes les colonnes de même nom
        dans les deux tables. <literal>USING</literal> qui mentionne toutes
        les colonnes de même nom dans les deux tables. S'il n'y a pas de noms
        de colonnes communs, <literal>NATURAL</literal> est équivalent à
        <literal>ON TRUE</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>LATERAL</literal></term>
      <listitem>
       <para>
        Le mot clé <literal>LATERAL</literal> peut précéder un élément
        sous-<command>SELECT</command> de la clause <literal>FROM</literal>. Ceci
        permet au sous-<command>SELECT</command> de faire référence aux colonnes
        des éléments du <literal>FROM</literal> qui apparaissent avant lui dans
        la liste <literal>FROM</literal>. (Sans <literal>LATERAL</literal>, chaque
        sous-<command>SELECT</command> est évalué indépendamment et donc ne peut
        pas faire référence à tout autre élément de la clause
        <literal>FROM</literal>.)
       </para>

       <para>
        <literal>LATERAL</literal> peut aussi précéder un élément fonction dans
        la clause <literal>FROM</literal> mais dans ce cas, ce n'est pas requis
        car l'expression de la fonction peut faire référence aux éléments du
        <literal>FROM</literal> dans tous les cas.
       </para>

       <para>
        Un élément <literal>LATERAL</literal> peut apparaître au niveau haut
        dans la liste <literal>FROM</literal> ou à l'intérieur d'un arbre
        <literal>JOIN</literal>. Dans ce dernier cas, il peut aussi faire
        référence à tout élément qui se trouvent à la gauche d'un
        <literal>JOIN</literal> qui est à sa droite.
       </para>

       <para>
        Quand un élément du <literal>FROM</literal> des références
        <literal>LATERAL</literal>, l'évaluation se fait ainsi&nbsp;: pour chaque
        ligne d'un élément <literal>FROM</literal> fournissant une colonne
        référencée ou un ensemble de lignes provenant de plusieurs éléments
        <literal>FROM</literal> fournissant les colonnes, l'élément
        <literal>LATERAL</literal> est évaluée en utilisant la valeur des
        colonnes de cette (ou ces) ligne(s). Les lignes résultantes sont
        jointes comme d'habitude avec les lignes pour lesquelles elles ont
        été calculées. Ceci est répété pour chaque ligne ou chaque ensemble de
        lignes provenant de la table contenant les colonnes référencées.
       </para>

       <para>
        Le(s) table(s) contenant les colonnes référencées doivent être jointes
        avec <literal>INNER</literal> ou <literal>LEFT</literal> à l'élément
        <literal>LATERAL</literal>. Sinon il n'y aurait pas un ensemble bien
        défini de lignes à partir duquel on pourrait construire chaque ensemble
        de lignes pour l'élément <literal>LATERAL</literal>. Du coup, bien qu'une
        construction comme <literal><replaceable>X</replaceable> RIGHT JOIN
         LATERAL <replaceable>Y</replaceable></literal> est valide
        syntaxiquement, il n'est pas permis à <replaceable>Y</replaceable> de
        référencer <replaceable>X</replaceable>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>

  <refsect2 id="sql-where" xreflabel="Clause WHERE">
   <title>Clause <literal>WHERE</literal></title>

   <para>
    La clause <literal>WHERE</literal> optionnelle a la forme générale
    <synopsis>WHERE <replaceable class="parameter">condition</replaceable>
    </synopsis>
    où <replaceable class="parameter">condition</replaceable> est une
    expression dont le résultat est de type <type>boolean</type>. Toute ligne qui ne
    satisfait pas cette condition est éliminée de la sortie. Une ligne
    satisfait la condition si elle retourne vrai quand les valeurs réelles
    de la ligne sont substituées à toute référence de variable.
   </para>
  </refsect2>

  <refsect2 id="sql-groupby" xreflabel="Clause GROUP BY">
   <title>Clause <literal>GROUP BY</literal></title>

   <para>
    La clause <literal>GROUP BY</literal> optionnelle a la forme générale
    <synopsis>GROUP BY <replaceable class="parameter">element_regroupement</replaceable> [, ...]
    </synopsis>
   </para>

   <para>
    <literal>GROUP BY</literal> condensera en une seule ligne toutes les
    lignes sélectionnées partageant les mêmes valeurs pour les expressions
    regroupées. Une <replaceable class="parameter">expression</replaceable>
    utilisée à l'intérieur d'un <replaceable
    class="parameter">element_regroupement</replaceable> peut être un nom de
    colonne en entrée, ou le nom ou le numéro d'une colonne en sortie (élément
    de la liste <command>SELECT</command>), ou une expression arbitraire
    formée à partir des valeurs ou colonnes en entrée. En cas d'ambiguité, un
    nom <literal>GROUP BY</literal> sera interprété comme un nom de colonne en
    entrée plutôt qu'en tant que nom de colonne en sortie.
   </para>

   <para>
    Si une clause parmi <literal>GROUPING SETS</literal>,
    <literal>ROLLUP</literal> ou <literal>CUBE</literal> est présente comme
    élément de regroupement, alors la clause <literal>GROUP BY</literal> dans
    sa globalité définit un certain nombre d'<replaceable>ensembles de
     regroupement</replaceable> indépendants. L'effet de ceci est l'équivalent
    de la construction d'un <literal>UNION ALL</literal> des sous-requêtes
    pour chaque ensemble de regroupement individuel avec leur propre clause
    <literal>GROUP BY</literal>. Pour plus de détails sur la gestion des
    ensembles de regroupement, voir <xref linkend="queries-grouping-sets"/>.
   </para>

   <para>
    Les fonctions d'agrégat, si utilisées, sont calculées pour toutes les lignes
    composant un groupe, produisant une valeur séparée pour chaque groupe. (S'il
    y a des fonctions d'agrégat mais pas de clause <literal>GROUP BY</literal>,
    la requête est traitée comme ayant un seul groupe contenant toutes les lignes
    sélectionnées.)
    L'ensemble de lignes envoyées à la fonction d'agrégat peut être en plus filtré
    en ajoutant une clause <literal>FILTER</literal> lors de l'appel à la fonction
    d'agrégat&nbsp;; voir <xref linkend="syntax-aggregates"/> pour plus
    d'informations. Quand une clause <literal>FILTER</literal> est présente,
    seules les lignes correspondant au filtre sont incluses en entrée de cette
    fonction d'agrégat.
   </para>

   <para>
    Quand <literal>GROUP BY</literal> est présent ou que des fonctions d'agrégat
    sont présentes, les expressions du <command>SELECT</command> ne peuvent faire
    référence qu'à des colonnes groupées, sauf à l'intérieur de fonctions
    d'agrégat, ou bien si la colonne non groupée dépend fonctionnellement des colonnes groupées.
    En effet, s'il en était autrement, il y aurait plus d'une valeur possible pour la colonne non groupée.
    Une dépendance fonctionnelle existe si les colonnes groupées (ou un sous-ensemble de ces dernières) sont la clé primaire de la
    table contenant les colonnes non groupées.
   </para>

   <para>
    Rappelez-vous que toutes les fonctions d'agrégat sont évaluées avant
    l'évaluation des expressions <quote>scalaires</quote> dans la clause
    <literal>HAVING</literal> ou la liste <literal>SELECT</literal>. Ceci
    signifie que, par exemple, une expression <literal>CASE</literal> ne
    peut pas être utilisée pour ignorer l'évaluation de la fonction
    d'agrégat&nbsp;; voir <xref linkend="syntax-express-eval"/>.
   </para>

   <para>
    Actuellement, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR
     UPDATE</literal>, <literal>FOR SHARE</literal> et <literal>FOR KEY
     SHARE</literal> ne peuvent pas être spécifiées avec <literal>GROUP
     BY</literal>.
   </para>
  </refsect2>

  <refsect2 id="sql-having" xreflabel="Clause HAVING">
   <title>Clause <literal>HAVING</literal></title>

   <para>
    La clause optionnelle <literal>HAVING</literal> a la forme générale
    <synopsis>HAVING <replaceable class="parameter">condition</replaceable>
    </synopsis>
    où <replaceable class="parameter">condition</replaceable> est identique à
    celle spécifiée pour la clause <literal>WHERE</literal>.
   </para>

   <para>
    <literal>HAVING</literal> élimine les lignes groupées qui ne satisfont
    pas à la condition. <literal>HAVING</literal> est différent de
    <literal>WHERE</literal>&nbsp;: <literal>WHERE</literal> filtre les lignes
    individuelles avant l'application de <literal>GROUP BY</literal> alors que
    <literal>HAVING</literal> filtre les lignes groupées créées par
    <literal>GROUP BY</literal>. Chaque colonne référencée dans <replaceable
    class="parameter">condition</replaceable> doit faire référence sans ambiguïté
    à une colonne groupée, sauf si la référence apparaît dans une fonction
    d'agrégat ou que les colonnes non groupées sont fonctionnement dépendantes
    des colonnes groupées.
   </para>

   <para>
    Même en l'absence de clause <literal>GROUP BY</literal>, la présence de
    <literal>HAVING</literal> transforme une requête en requête groupée.
    Cela correspond au comportement d'une requête contenant des fonctions
    d'agrégats mais pas de clause <literal>GROUP BY</literal>. Les lignes
    sélectionnées ne forment qu'un groupe, la liste du <command>SELECT</command>
    et la clause <literal>HAVING</literal> ne peuvent donc faire référence
    qu'à des colonnes à l'intérieur de fonctions d'agrégats. Une telle
    requête ne produira qu'une seule ligne si la condition <literal>HAVING</literal>
    est réalisée, aucune dans le cas contraire.
   </para>

   <para>
    Actuellement, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR
     UPDATE</literal>, <literal>FOR SHARE</literal> et <literal>FOR KEY
     SHARE</literal> ne peuvent pas être spécifiées avec <literal>GROUP
     BY</literal>.
   </para>
  </refsect2>

  <refsect2 id="sql-window" xreflabel="Clause WINDOW">
   <title>Clause <literal>WINDOW</literal></title>

   <para>
    La clause optionnelle <literal>WINDOW</literal> a la forme générale
    <synopsis>
WINDOW <replaceable class="parameter">nom_window</replaceable> AS ( <replaceable class="parameter">définition_window</replaceable> ) [, ...]
    </synopsis>
    où <replaceable class="parameter">nom_window</replaceable> est un nom qui
    peut être référencé par des clauses <literal>OVER</literal> ou par des
    définitions Window, et
    <replaceable class="parameter">définition_window</replaceable>
    est
    <synopsis>
[ <replaceable class="parameter">nom_window_existante</replaceable> ]
[ PARTITION BY <replaceable class="parameter">expression</replaceable> [, ...] ]
[ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operateur</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <replaceable class="parameter">clause_frame</replaceable> ]
    </synopsis>
   </para>

   <para>
    Si un <replaceable class="parameter">nom_window_existante</replaceable> est
    spécifié, il doit se référer à une entrée précédente dans la liste
    <literal>WINDOW</literal>&nbsp;; la nouvelle Window copie sa clause de
    partitionnement de cette entrée, ainsi que sa clause de tri s'il y en a.
    Dans ce cas, la nouvelle Window ne peut pas spécifier sa propre clause
    <literal>PARTITION BY</literal>, et ne peut spécifier de
    <literal>ORDER BY</literal> que si la Window copiée n'en a pas.
    La nouvelle Window utilise toujours sa propre clause frame&nbsp;; la Window
    copiée ne doit pas posséder de clause frame.
   </para>

   <para>
    Les éléments de la liste <literal>PARTITION BY</literal> sont interprétés
    à peu près de la même façon que des éléments d'une clause <link
    linkend="sql-groupby"><literal>GROUP BY</literal></link>, sauf qu'ils sont
    toujours des expressions simples et jamais le nom ou le numéro d'une
    colonne en sortie. Une autre différence est que ces expressions peuvent
    contenir des appels à des fonctions d' agrégat, ce qui n'est pas autorisé
    dans une clause <literal>GROUP BY</literal> classique. Ceci est autorisé
    ici parce que le windowing se produit après le regroupement et l'
    agrégation.
   </para>

   <para>
    De façon similaire, les éléments de la liste <literal>ORDER BY</literal>
    sont interprétés à peu près de la même façon que les éléments d'un <link
    linkend="sql-orderby"><literal>ORDER BY</literal></link>, sauf que les
    expressions sont toujours prises comme de simples expressions et jamais
    comme le nom ou le numéro d'une colonne en sortie.
   </para>

   <para>
    La clause <replaceable class="parameter">clause_frame</replaceable>
    optionnelle définit la <firstterm>frame window</firstterm> pour les
    fonctions window qui dépendent de la frame (ce n'est pas le cas de toutes).
    La frame window est un ensemble de lignes liées à chaque ligne de la requête (appelée la <firstterm>ligne courante</firstterm>).
    La <replaceable class="parameter">clause_frame</replaceable> peut être une des clauses suivantes&nbsp;:


    <synopsis>
{ RANGE | ROWS | GROUPS } <replaceable>début_portée</replaceable> [ <replaceable>exclusion_portée</replaceable> ]
{ RANGE | ROWS | GROUPS } BETWEEN <replaceable>début_portée</replaceable> AND <replaceable>fin_portée</replaceable> [ <replaceable>exclusion_portée</replaceable> ]
    </synopsis>

    où <replaceable>début_frame</replaceable> et <replaceable>fin_frame</replaceable> peuvent valoir

    <synopsis>
UNBOUNDED PRECEDING
<replaceable>décalage</replaceable> PRECEDING
CURRENT ROW
<replaceable>décalage</replaceable> FOLLOWING
UNBOUNDED FOLLOWING
    </synopsis>

    et <replaceable>exclusion_portée</replaceable> peut valoir

    <synopsis>
EXCLUDE CURRENT ROW
EXCLUDE GROUP
EXCLUDE TIES
EXCLUDE NO OTHERS
    </synopsis>

    Si <replaceable>fin_frame</replaceable> n'est pas précisé, il vaut par défaut <literal>CURRENT
     ROW</literal>.  Les restrictions sont les suivantes&nbsp;:
    <replaceable>début_frame</replaceable> ne peut pas valoir <literal>UNBOUNDED FOLLOWING</literal>,
    <replaceable>fin_frame</replaceable> ne peut pas valoir <literal>UNBOUNDED PRECEDING</literal>,
    et le choix <replaceable>fin_frame</replaceable> ne peut apparaître avant les options
    <replaceable>frame_start</replaceable> et <replaceable>frame_end</replaceable> que le choix
    <replaceable>début_frame</replaceable>  &mdash; par exemple
    <literal>RANGE BETWEEN CURRENT ROW AND <replaceable>décalage</replaceable>
     PRECEDING</literal> n'est pas permis.
   </para>

   <para>
    L'option de portée par défaut est <literal>RANGE UNBOUNDED
     PRECEDING</literal>, qui est identique à <literal>RANGE BETWEEN UNBOUNDED
     PRECEDING AND CURRENT ROW</literal>&nbsp;; cela configure la portée à
    toutes les lignes du début de la partition jusqu'au dernier
    <firstterm>peer</firstterm> de la ligne courant (une ligne que la clause
    <literal>ORDER BY</literal> de fenêtrage considère équivalente à la ligne
    courante&nbsp;; toutes les lignes sont dans ce cas s'il n'y a pas
    d'<literal>ORDER BY</literal>). En général, <literal>UNBOUNDED
     PRECEDING</literal> signifie que la portée comment avec la première ligne
    de la partition et, de façon similaire, <literal>UNBOUNDED
     FOLLOWING</literal> signifie que la portée se termine avec la dernière
    ligne de la partition, quelque soit le mot (<literal>RANGE</literal>,
    <literal>ROWS</literal> or <literal>GROUPS</literal>). Dans le mode
    <literal>ROWS</literal>, <literal>CURRENT ROW</literal> signifie que la
    portée commence ou se termine avec la ligne actuelle&nbsp;; mais dans les
    modes <literal>RANGE</literal> et <literal>GROUPS</literal>, il signifie
    que la portée commence ou se termine avec le premier ou le dernier
    équivalent de la ligne courante d'après le tri <literal>ORDER
     BY</literal>. Les options <replaceable>offset</replaceable>
    <literal>PRECEDING</literal> et <replaceable>offset</replaceable>
    <literal>FOLLOWING</literal> varient en signification suivant le mode de
    portée. Dans le mode <literal>ROWS</literal>,
    <replaceable>offset</replaceable> est un entier indiquant que la portée
    commence ou se termine par ce nombre de lignes avant ou après la ligne
    actuelle. Dans le mode <literal>GROUPS</literal>,
    <replaceable>offset</replaceable> est un entier indiquant que la portée
    commence ou se termine par ce nombre de groupes d'équivalents avant ou
    après le groupe d'équivalents de la ligne courante, où un
    <firstterm>groupe d'équivalents</firstterm> est un groupe de lignes
    équivalentes suivant la clause <literal>ORDER BY</literal> de fenêtrage.
    Dans le mode <literal>RANGE</literal>, l'utilisation de l'option
    <replaceable>offset</replaceable> requiert qu'il y ait exactement une
    colonne <literal>ORDER BY</literal> dans la définition de la fenêtre.
    Ensuite, la portée contient ces lignes dont la valeur de la colonne de tri
    n'est pas inférieur de <replaceable>offset</replaceable> (pour
    <literal>PRECEDING</literal>) ou supérieur (pour
    <literal>FOLLOWING</literal>) à la valeur de la colonne de tri de la ligne
    courante. Dans ces cas, le type de données de l'expression
    <replaceable>offset</replaceable> dépend du typ de données de la colonne
    de tri. Pour les colonnes numériques, il s'agit typiquement du même type
    que la colonne de tri. Pour les colonnes date/heure, il s'agit typiquement
    d'un <type>interval</type>. Dans tous les cas, la valeur de
    <replaceable>offset</replaceable> doit être non NULL et non négative. De
    plus, alors que <replaceable>offset</replaceable> n'a pas besoin d'être
    une simple constante, elle ne peut pas contenir des variables, des
    fonctions d'agrégat et des fonctions de fenêtrage.
   </para>

   <para>
    L'option <replaceable>exclusion_portée</replaceable> autorise les lignes
    autour de la ligne courante d'être exclues de la portée, même si elles
    devraient être includes d'après les options de début et de fin de portée.
    <literal>EXCLUDE CURRENT ROW</literal> exclut la ligne courante de la
    portée. <literal>EXCLUDE GROUP</literal> exclut la ligne courante et ses
    équivalents de tri à partir de la portée. <literal>EXCLUDE TIES</literal>
    exclut tout équivalent de la ligne courante à partir de la portée, mais
    pas la ligne courante elle-même. <literal>EXCLUDE NO OTHERS</literal>
    indique seulement explicitement le comportement par défaut qui est de ne
    pas exclure la ligne courante et ses équivalents.
   </para>

   <para>
    Notez que le mode <literal>ROWS</literal> peut produire des résultats
    inattendus si la clause <literal>ORDER BY</literal> ne trie pas les lignes
    de façon unique. Les modes <literal>RANGE</literal> et
    <literal>GROUPS</literal> sont conçus pour s'assurer que les lignes
    équivalents d'après le tri <literal>ORDER BY</literal> sont traitées de la
    même façon &nbsp;: toutes les lignes d'un groupe d'équivalent sera inclus
    dans la portée ou en sera exclus.
   </para>

   <para>
    L'utilité d'une clause <literal>WINDOW</literal> est de spécifier le
    comportement des <firstterm>fonctions window</firstterm> apparaissant dans
    la clause <link linkend="sql-select-list"><command>SELECT</command></link>
    ou la clause <link linkend="sql-orderby"><literal>ORDER BY</literal></link>
    de la requête. Ces fonctions peuvent référencer les entrées de clauses
    <literal>WINDOW</literal> par nom dans leurs clauses <literal>OVER</literal>.
    Toutefois, il n'est pas obligatoire qu'une entrée de clause
    <literal>WINDOW</literal> soit référencée quelque part&nbsp;; si elle n'est
    pas utilisée dans la requête, elle est simplement ignorée. Il est possible
    d'utiliser des fonctions window sans aucune clause <literal>WINDOW</literal>
    puisqu'une fonction window peut spécifier sa propre définition de window
    directement dans sa clause <literal>OVER</literal>. Toutefois, la clause
    <literal>WINDOW</literal> économise de la saisie quand la même définition
    window est utilisée pour plus d'une fonction window.
   </para>

   <para>
    Actuellement, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR
     UPDATE</literal>, <literal>FOR SHARE</literal> et <literal>FOR KEY
     SHARE</literal> ne peuvent pas être spécifiées avec <literal>GROUP
     BY</literal>.
   </para>

   <para>
    Les fonctions window sont décrites en détail dans
    <xref linkend="tutorial-window"/>,
    <xref linkend="syntax-window-functions"/> et
    <xref linkend="queries-window"/>.
   </para>
  </refsect2>

  <refsect2 id="sql-select-list" xreflabel="Liste SELECT">
   <title>Liste <command>SELECT</command></title>

   <para>
    La liste <command>SELECT</command> (entre les mots clés
    <literal>SELECT</literal> et <literal>FROM</literal>) spécifie les
    expressions qui forment les lignes en sortie de l'instruction
    <command>SELECT</command>. Il se peut que les expressions fassent référence
    aux colonnes traitées dans la clause <literal>FROM</literal>. En fait, en
    général, elles le font.
   </para>

   <para>
    Comme pour une table, chaque colonne de sortie d'un <command>SELECT</command>
    a un nom. Dans un <command>SELECT</command> simple, ce nom est juste
    utilisé pour donner un titre à la colonne pour l'affichage, mais quand le
    <command>SELECT</command> est une sous-requête d'une requête plus grande,
    le nom est vu par la grande requête comme le nom de colonne de la table
    virtuelle produite par la sous-requête.
    Pour indiquer le nom à utiliser pour une colonne de sortie, écrivez
    <literal>AS</literal> <replaceable class="parameter">nom_de_sortie</replaceable>
    après l'expression de la colonne. (Vous pouvez omettre <literal>AS</literal>
    seulement si le nom de colonne souhaité n'est pas un mot clé réservé par
    <productname>PostgreSQL</productname> (voir <xref
    linkend="sql-keywords-appendix"/>). Pour vous protéger contre l'ajout futur
    d'un mot clé, il est recommandé que vous écriviez toujours
    <literal>AS</literal> ou que vous mettiez le nom de sortie entre guillemets.
    Si vous n'indiquez pas de nom de colonne, un nom est choisi automatiquement
    par <productname>PostgreSQL</productname>. Si l'expression de la colonne
    est une simple référence à une colonne alors le nom choisi est le même que
    le nom de la colonne.  Dans les cas plus complexes, un nom de fonction ou
    de type peut être utilisé, ou le système peut opter pour un nom généré
    automatiquement tel que  <literal>?column?</literal>.
   </para>

   <para>
    Un nom de colonne de sortie peut être utilisé pour se référer à la valeur de
    la colonne dans les clauses <literal>ORDER BY</literal> et
    <literal>GROUP BY</literal>, mais pas dans la clause<literal>WHERE</literal>
    ou <literal>HAVING</literal>&nbsp;; à cet endroit, vous devez écrire
    l'expression.
   </para>

   <para>
    <literal>*</literal> peut être utilisé, à la place d'une expression, dans la
    liste de sortie comme raccourci pour toutes les colonnes des lignes
    sélectionnées. De plus,
    <literal><replaceable class="parameter">nom_table</replaceable>.*</literal>
    peut être écrit comme raccourci pour toutes les colonnes de cette table. Dans
    ces cas, il est impossible de spécifier de nouveaux noms avec
    <literal>AS</literal>&nbsp;;
    les noms des colonnes de sorties seront les même que ceux de la table.
   </para>

   <para>
    Suivant le standard SQL, les expressions dans la liste en sortie doivent
    être calculées avant d'appliquer les clauses <literal>DISTINCT</literal>,
    <literal>ORDER BY</literal> et <literal>LIMIT</literal>. Ceci est
    évidemment nécessaire lors de l'utilisation de <literal>DISTINCT</literal>
    car, dans le cas contraire, il est difficile de distinguer les valeurs.
    Néanmoins, dans de nombreux cas, il est plus intéressant que les
    expressions en sortie soient calculées après les clauses <literal>ORDER
     BY</literal> et <literal>LIMIT</literal>, tout particulièrement si la liste
    en sortie contient des fonctions volatiles ou coûteuses. Avec ce
    comportement, l'ordre d'évaluation des fonctions est plus intuitive et il
    n'y aurait pas d'évaluations correspondant aux lignes n'apparaissant pas
    en sortie. <productname>PostgreSQL</productname> évaluera réellement les
    expressions en sortie après le tri et la limite, si tant est que ces
    expressions ne sont pas référencées dans les clauses
    <literal>DISTINCT</literal>, <literal>ORDER BY</literal>
    et <literal>GROUP BY</literal>. (En contre-exemple, <literal>SELECT
     f(x) FROM tab ORDER BY 1</literal> doit forcément évaluer
    <function>f(x)</function> avant de réaliser le tri.) Les expressions en
    sortie contenant des fonctions renvoyant plusieurs lignes sont réellement
    évaluées après le tri et avant l'application de la limite, pour que
    <literal>LIMIT</literal> permette d'éviter l'exécution inutile de la
    fonction.
   </para>

   <note>
    <para>
     Les versions de <productname>PostgreSQL</productname> antérieures à la 9.6
     ne fournissaient pas de garantie sur la durée de l'évaluation des
     expressions en sortie par rapport aux tris et aux limites. Cela dépendait
     de la forme du plan d'exécution sélectionné.
    </para>
   </note>
  </refsect2>

  <refsect2 id="sql-distinct" xreflabel="Clause DISTINCT">
   <title>Clause <literal>DISTINCT</literal></title>

   <para>
    Si <literal>SELECT DISTINCT</literal> est spécifié, toutes les lignes en double sont
    supprimées de l'ensemble de résultats (une ligne est conservée pour chaque groupe
    de doublons).   <literal>SELECT ALL</literal> spécifie le contraire : toutes les lignes sont
    conservées. C'est l'option par défaut.
   </para>

   <para>
    <literal>SELECT DISTINCT ON ( <replaceable
     class="parameter">expression</replaceable> [, ...] )</literal>
    conserve seulement la première ligne de chaque ensemble de lignes pour lesquelles le résultat
    de l'expression est identique. Les expressions <literal>DISTINCT ON</literal>
    expressions sont interprétées avec les mêmes règles que pour
    <literal>ORDER BY</literal> (voir ci-dessous).  Notez que la <quote>première ligne</quote>
    de chaque ensemble est imprévisible, à moins que la clause <literal>ORDER
     BY</literal> ne soit utilisée, assurant ainsi que la ligne souhaitée apparaisse en premier. Par exemple :
    <programlisting>
SELECT DISTINCT ON (lieu) lieu, heure, rapport
    FROM rapport_météo
    ORDER BY lieu, heure DESC;
    </programlisting>
    renvoie le rapport météo le plus récent de chaque endroit. Mais
    si nous n'avions pas utilisé <literal>ORDER BY</literal> afin de forcer le tri du temps dans le sens descendant
    des temps pour chaque endroit, nous aurions récupéré, pour chaque lieu, n'importe quel bulletin de ce lieu.
   </para>

   <para>
    La (ou les) expression(s) <literal>DISTINCT ON</literal> doivent correspondre à l'expression (ou aux expressions)
    <literal>ORDER BY</literal> la(les) plus à gauche.  La clause <literal>ORDER BY</literal>  contient habituellement des
    expressions supplémentaires qui déterminent l'ordre des lignes au sein de chaque groupe <literal>DISTINCT ON</literal>.
   </para>

   <para>
    Actuellement, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR
     UPDATE</literal>, <literal>FOR SHARE</literal> et <literal>FOR KEY
     SHARE</literal> ne peuvent pas être spécifiées avec
    <literal>DISTINCT</literal>.
   </para>
  </refsect2>

  <refsect2 id="sql-union" xreflabel="Clause UNION">
   <title>Clause <literal>UNION</literal></title>

   <para>
    La clause <literal>UNION</literal> a la forme générale&nbsp;:
    <synopsis><replaceable class="parameter">instruction_select</replaceable> UNION [ ALL | DISTINCT ] <replaceable class="parameter">instruction_select</replaceable>
    </synopsis>
    <replaceable class="parameter">instruction_select</replaceable> est une
    instruction <command>SELECT</command> sans clause <literal>ORDER BY</literal>,
    <literal>LIMIT</literal>, <literal>FOR SHARE</literal> ou <literal>FOR
     UPDATE</literal>. (<literal>ORDER BY</literal> et
    <literal>LIMIT</literal> peuvent être attachés à une sous-expression si elle est
    entourée de parenthèses. Sans parenthèses, ces clauses s'appliquent
    au résultat de l'<literal>UNION</literal>, non à l'expression à sa droite.)
   </para>

   <para>
    L'opérateur <literal>UNION</literal> calcule l'union ensembliste des
    lignes renvoyées par les instructions <command>SELECT</command> impliquées.
    Une ligne est dans l'union de deux ensembles de résultats si elle apparaît
    dans au moins un des ensembles. Les deux instructions
    <command>SELECT</command> qui représentent les opérandes directes de
    l'<literal>UNION</literal> doivent produire le même nombre de colonnes et
    les colonnes correspondantes doivent être d'un type de données compatible.
   </para>

   <para>
    Sauf lorsque l'option <literal>ALL</literal> est spécifiée, il n'y a pas
    de doublons dans le résultat de <literal>UNION</literal>. <literal>ALL</literal>
    empêche l'élimination des lignes dupliquées. <literal>UNION
     ALL</literal> est donc significativement plus rapide qu'<literal>UNION</literal>,
    et sera préféré. <literal>DISTINCT</literal> peut éventuellement être ajouté pour préciser explicitement
    le comportement par défaut&nbsp;: l'élimination des lignes en double.
   </para>

   <para>
    Si une instruction
    <command>SELECT</command> contient plusieurs opérateurs <literal>UNION</literal>,
    ils sont évalués de gauche à droite, sauf si l'utilisation de parenthèses
    impose un comportement différent.
   </para>

   <para>
    Actuellement, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>,
    <literal>FOR SHARE</literal> et <literal>FOR KEY SHARE</literal> ne peuvent
    pas être spécifiés pour un résultat d'<literal>UNION</literal> ou pour toute entrée
    d'un <literal>UNION</literal>.
   </para>
  </refsect2>

  <refsect2 id="sql-intersect" xreflabel="Clause INTERSECT">
   <title>Clause <literal>INTERSECT</literal></title>

   <para>
    La clause <literal>INTERSECT</literal> a la forme générale&nbsp;:
    <synopsis><replaceable class="parameter">instruction_select</replaceable> INTERSECT [ ALL | DISTINCT ] <replaceable class="parameter">instruction_select</replaceable>
    </synopsis>
    <replaceable class="parameter">instruction_select</replaceable> est une
    instruction <command>SELECT</command> sans clause <literal>ORDER BY</literal>,
    <literal>LIMIT</literal>, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>,
    <literal>FOR SHARE</literal> ou <literal>FOR KEY SHARE</literal>.
   </para>

   <para>
    L'opérateur <literal>INTERSECT</literal> calcule l'intersection des lignes
    renvoyées par les instructions <command>SELECT</command> impliquées. Une
    ligne est dans l'intersection des deux ensembles de résultats si elle
    apparaît dans chacun des deux ensembles.
   </para>

   <para>
    Le résultat d'<literal>INTERSECT</literal> ne contient aucune ligne
    dupliquée sauf si l'option <literal>ALL</literal> est spécifiée. Dans ce cas,
    une ligne dupliquée <replaceable>m</replaceable> fois dans
    la table gauche et <replaceable>n</replaceable> fois dans la table droite
    apparaît min(<replaceable>m</replaceable>,<replaceable>n</replaceable>) fois dans
    l'ensemble de résultats.
    <literal>DISTINCT</literal> peut éventuellement être ajouté pour préciser explicitement
    le comportement par défaut&nbsp;: l'élimination des lignes en double.
   </para>

   <para>
    Si une instruction
    <command>SELECT</command> contient plusieurs opérateurs <literal>INTERSECT</literal>,
    ils sont évalués de gauche à droite, sauf si l'utilisation de parenthèses
    impose un comportement différent. <literal>INTERSECT</literal> a une
    priorité supérieur à celle d'<literal>UNION</literal>. C'est-à-dire que <literal>A
     UNION B INTERSECT C</literal> est lu comme <literal>A UNION (B INTERSECT
     C)</literal>.
   </para>

   <para>
    Actuellement, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>,
    <literal>FOR SHARE</literal> et <literal>FOR KEY SHARE</literal> ne peuvent
    pas être spécifiés pour un résultat d'<literal>INTERSECT</literal> ou pour une
    entrée d'<literal>INTERSECT</literal>.
   </para>
  </refsect2>

  <refsect2 id="sql-except" xreflabel="Clause EXCEPT">
   <title>Clause <literal>EXCEPT</literal></title>

   <para>
    La clause <literal>EXCEPT</literal> a la forme générale&nbsp;:
    <synopsis><replaceable class="parameter">instruction_select</replaceable> EXCEPT [ ALL | DISTINCT ] <replaceable class="parameter">instruction_select</replaceable>
    </synopsis>
    <replaceable class="parameter">instruction_select</replaceable> est une
    instruction <command>SELECT</command> sans clause <literal>ORDER
     BY</literal>, <literal>LIMIT</literal>, <literal>FOR NO KEY UPDATE</literal>,
    <literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal> ou
    <literal>FOR KEY SHARE</literal>.
   </para>

   <para>
    L'opérateur <literal>EXCEPT</literal> calcule l'ensemble de lignes qui appartiennent
    au résultat de l'instruction <command>SELECT</command> de gauche mais
    pas à celui de droite.
   </para>

   <para>
    Le résultat d'<literal>EXCEPT</literal> ne contient aucune ligne
    dupliquée sauf si l'option <literal>ALL</literal> est spécifiée. Dans ce cas,
    une ligne dupliquée <replaceable>m</replaceable> fois dans
    la table gauche et <replaceable>n</replaceable> fois dans la table droite
    apparaît max(<replaceable>m</replaceable>-<replaceable>n</replaceable>,0) fois dans
    l'ensemble de résultats.
    <literal>DISTINCT</literal> peut éventuellement être ajouté pour préciser explicitement
    le comportement par défaut&nbsp;: l'élimination des lignes en double.
   </para>

   <para>
    Si une instruction
    <command>SELECT</command> contient plusieurs opérateurs <literal>EXCEPT</literal>,
    ils sont évalués de gauche à droite, sauf si l'utilisation de parenthèses
    impose un comportement différent. <literal>EXCEPT</literal> a la même priorité
    qu'<literal>UNION</literal>.
   </para>

   <para>
    Actuellement, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>,
    <literal>FOR SHARE</literal> et <literal>FOR KEY SHARE</literal> ne peuvent
    pas être spécifiés dans un résultat <literal>EXCEPT</literal> ou pour une entrée
    d'un <literal>EXCEPT</literal>.
   </para>
  </refsect2>

  <refsect2 id="sql-orderby" xreflabel="Clause ORDER BY">
   <title>Clause <literal>ORDER BY</literal></title>

   <para>
    La clause optionnelle <literal>ORDER BY</literal> a la forme
    générale&nbsp;:
    <synopsis>ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">opérateur</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...]
    </synopsis>
    La clause <literal>ORDER BY</literal> impose le tri des lignes de résultat
    suivant les expressions spécifiées. Si deux lignes sont
    identiques suivant l'expression la plus à gauche, elles sont comparées avec
    l'expression suivante et ainsi de suite. Si elles sont identiques pour
    toutes les expressions de tri, elles sont renvoyées dans un ordre
    dépendant de l'implantation.
   </para>

   <para>
    Chaque <replaceable class="parameter">expression</replaceable> peut être le
    nom ou le numéro ordinal d'une colonne en sortie (élément de la liste
    <command>SELECT</command>). Elle peut aussi être une expression arbitraire
    formée à partir de valeurs des colonnes.
   </para>

   <para>
    Le numéro ordinal fait référence à la position ordinale (de gauche à
    droite) de la colonne de résultat. Cette fonctionnalité permet de définir un ordre
    sur la base d'une colonne dont le nom n'est pas unique. Ce n'est
    pas particulièrement nécessaire parce qu'il est toujours possible d'affecter un nom à
    une colonne de résultat avec la clause <literal>AS</literal>.
   </para>

   <para>
    Il est aussi possible d'utiliser des expressions quelconques dans la clause
    <literal>ORDER BY</literal>, ce qui inclut des colonnes qui n'apparaissent pas
    dans la liste résultat du <command>SELECT</command>. Ainsi,
    l'instruction suivante est valide&nbsp;:
    <programlisting>SELECT nom FROM distributeurs ORDER BY code;
    </programlisting>
    Il y a toutefois une limitation à cette fonctionnalité. La clause
    <literal>ORDER BY</literal> qui s'applique au résultat d'une clause <literal>UNION</literal>,
    <literal>INTERSECT</literal> ou <literal>EXCEPT</literal> ne peut spécifier
    qu'un nom ou numéro de colonne en sortie, pas une expression.
   </para>

   <para>
    Si une expression <literal>ORDER BY</literal> est un nom qui correspond à
    la fois à celui d'une colonne résultat et à celui d'une colonne en entrée,
    <literal>ORDER BY</literal> l'interprète comme le nom de la colonne résultat.
    Ce comportement est à l'opposé de celui de <literal>GROUP BY</literal> dans la même
    situation. Cette incohérence est imposée par la compatibilité avec le
    standard SQL.
   </para>

   <para>
    Un mot clé <literal>ASC</literal> (ascendant) ou <literal>DESC</literal> (descendant)
    peut être ajouté après toute expression de la
    clause <literal>ORDER BY</literal>. <literal>ASC</literal> est la valeur utilisée par défaut.
    Un nom d'opérateur d'ordre spécifique
    peut également être fourni dans la clause <literal>USING</literal>.
    Un opérateur de tri doit être un membre plus-petit-que ou plus-grand-que de
    certaines familles d'opérateur B-tree.
    <literal>ASC</literal> est
    habituellement équivalent à <literal>USING &lt;</literal> et <literal>DESC</literal>
    à <literal>USING &gt;</literal>. Le créateur d'un
    type de données utilisateur peut définir à sa guise le tri par
    défaut qui peut alors correspondre à des opérateurs de nom différent.
   </para>

   <para>
    Si <literal>NULLS LAST</literal> est indiqué, les valeurs NULL sont listées
    après toutes les valeurs non NULL&nbsp; si <literal>NULLS FIRST</literal>
    est indiqué, les valeurs NULL apparaissent avant toutes les valeurs non
    NULL. Si aucune des deux n'est présente, le comportement par défaut est
    <literal>NULLS LAST</literal> quand <literal>ASC</literal> est utilisé
    (de façon explicite ou non) et <literal>NULLS FIRST</literal> quand
    <literal>DESC</literal> est utilisé (donc la valeur par défaut est d'agir
    comme si les NULL étaient plus grands que les non NULL). Quand
    <literal>USING</literal> est indiqué, le tri des NULL par défaut dépend
    du fait que l'opérateur est un plus-petit-que ou un plus-grand-que.
   </para>

   <para>
    Notez que les options de tri s'appliquent seulement à l'expression qu'elles
    suivent. Par exemple, <literal>ORDER BY x, y DESC</literal> ne signifie pas
    la même chose que <literal>ORDER BY x DESC, y DESC</literal>.
   </para>

   <para>
    Les chaînes de caractères sont triées suivant le collationnement qui
    s'applique à la colonne triée. Ce collationnement est surchargeable
    si nécessaire en ajoutant une clause <literal>COLLATE</literal> dans
    l'<replaceable class="parameter">expression</replaceable>, par
    exemple <literal>ORDER BY mycolumn COLLATE "en_US"</literal>.
    Pour plus d'informations, voir <xref linkend="sql-syntax-collate-exprs"/>
    et <xref linkend="collation"/>.
   </para>
  </refsect2>

  <refsect2 id="sql-limit" xreflabel="Clause LIMIT">
   <title>Clause <literal>LIMIT</literal></title>

   <para>
    La clause <literal>LIMIT</literal> est constituée de deux sous-clauses
    indépendantes&nbsp;:
    <synopsis>LIMIT { <replaceable class="parameter">nombre</replaceable> | ALL }
OFFSET <replaceable class="parameter">début</replaceable>
    </synopsis>
    <replaceable class="parameter">nombre</replaceable> spécifie le nombre
    maximum de lignes à renvoyer alors que <replaceable
    class="parameter">début</replaceable> spécifie le nombre de lignes à passer
    avant de commencer à renvoyer des lignes. Lorsque les deux clauses sont spécifiées,
    <replaceable class="parameter">début</replaceable> lignes sont passées
    avant de commencer à compter les <replaceable
    class="parameter">nombre</replaceable> lignes à renvoyer.
   </para>

   <para>
    Si l'expression de <replaceable class="parameter">compte</replaceable>
    est évaluée à NULL, il est traité comme <literal>LIMIT ALL</literal>,
    c'est-à-dire sans limite. Si <replaceable class="parameter">début</replaceable>
    est évalué à NULL, il est traité comme <literal>OFFSET 0</literal>.
   </para>

   <para>
    SQL:2008 a introduit une sytaxe différente pour obtenir le même résultat.
    <productname>PostgreSQL</productname> supporte aussi cette syntaxe.
    <synopsis>
OFFSET <replaceable class="parameter">début</replaceable> { ROW | ROWS }
FETCH { FIRST | NEXT } [ <replaceable class="parameter">compte</replaceable> ] { ROW | ROWS } { ONLY | WITH TIES }
    </synopsis>
    Avec cette syntaxe, le standard SQL exige que la valeur de <replaceable
    class="parameter">start</replaceable> ou <replaceable
    class="parameter">count</replaceable> soit une constante litérale, un
    paramètre ou un nom de variable. <productname>PostgreSQL</productname>
    propose en extension l'utilisation d'autres expressions. Ces dernières
    devront généralement être entre parenthèses pour éviter toute ambiguïté.
    Si <replaceable class="parameter">compte</replaceable> est omis dans une
    clause <literal>FETCH</literal>, il vaut 1 par défaut. L'option
    <literal>WITH TIES</literal> est utilisée pour renvoyer toute ligne
    supplémentaire qui se lie pour la dernière place dans le jeu de résultats
    selon la clause <literal>ORDER BY</literal>&nbsp;; <literal>ORDER
     BY</literal> est requis dans ce cas. <literal>ROW</literal> et
    <literal>ROWS</literal> ainsi que <literal>FIRST</literal> et
    <literal>NEXT</literal> sont des mots qui n'influencent pas les effets de
    ces clauses. D'après le standard, la clause <literal>OFFSET</literal> doit
    venir avant la clause <literal>FETCH</literal> si les deux sont
    présentes&nbsp;; <productname>PostgreSQL</productname> est plus  laxiste
    et autorise un ordre différent.
   </para>

   <para>
    Avec <literal>LIMIT</literal>, utiliser la clause
    <literal>ORDER BY</literal> permet de contraindre l'ordre des lignes de
    résultat. Dans le cas contraire, le sous-ensemble obtenu n'est pas prévisible &mdash;
    rien ne permet de savoir à quel ordre correspondent les lignes retournées.
    Celui-ci ne sera pas connu tant qu'<literal>ORDER BY</literal> n'aura pas été précisé.
   </para>

   <para>
    Lors de la génération d'un plan de requête, le planificateur tient compte
    de <literal>LIMIT</literal>. Le risque est donc grand d'obtenir des plans
    qui diffèrent (ordres des lignes différents) suivant les valeurs
    utilisées pour <literal>LIMIT</literal> et <literal>OFFSET</literal>. Ainsi, sélectionner
    des sous-ensembles différents d'un résultat à partir de valeurs différentes
    de <literal>LIMIT</literal>/<literal>OFFSET</literal> <emphasis>aboutit à des résultats
     incohérents</emphasis> à moins d'avoir figé l'ordre des lignes à l'aide
    de la clause <literal>ORDER BY</literal>. Ce n'est pas un bogue, mais une conséquence
    du fait que SQL n'assure pas l'ordre de présentation des résultats sans
    utilisation d'une clause <literal>ORDER BY</literal>.
   </para>

   <para>
    Il est même possible pour des exécutions répétées de la même requête
    <literal>LIMIT</literal> de renvoyer différents sous-ensembles des lignes
    d'une table s'il n'y a pas de clause <literal>ORDER BY</literal> pour forcer
    la sélection d'un sous-ensemble déterministe. Encore une fois, ce n'est pas
    un bogue&nbsp;; le déterminisme des résultats n'est tout simplement pas
    garanti dans un tel cas.
   </para>
  </refsect2>

  <refsect2 id="sql-for-update-share" xreflabel="Clause de verrouillage">
   <title>Clause de verrouillage</title>

   <para>
    <literal>FOR UPDATE</literal>, <literal>FOR NO KEY UPDATE</literal>,
    <literal>FOR SHARE</literal> et <literal>FOR KEY SHARE</literal> sont des
    <firstterm>clauses de verrouillage</firstterm>. Elles affectent la façon
    dont <literal>SELECT</literal> verrouille les lignes au moment de leur
    obtention sur la table.
   </para>

   <para>
    La clause de verrouillage a la forme suivante&nbsp;:

    <synopsis>
FOR <replaceable>force_verrou</replaceable> [ OF <replaceable class="parameter">nom_table</replaceable> [, ...] ] [ NOWAIT | SKIP LOCKED ]
    </synopsis>

    où <replaceable>force_verrou</replaceable> fait partie de&nbsp;:

    <synopsis>
UPDATE
NO KEY UPDATE
SHARE
KEY SHARE
    </synopsis>
   </para>

   <para>
    Pour plus d'informations sur chaque mode de verrouillage au niveau ligne,
    voir <xref linkend="locking-rows"/>.
   </para>

   <para>
    Pour éviter que l'opération attende la validation d'autres transactions,
    utilisez soit l'option <literal>NOWAIT</literal> soit l'option
    <literal>SKIP LOCKED</literal>. Avec <literal>NOWAIT</literal>,
    l'instruction renvoie une erreur, plutôt que de rester en attente, si une
    ligne sélectionnée ne peut pas être immédiatement verrouillée. Avec
    <literal>SKIP LOCKED</literal>, toute ligne sélectionnée qui ne peut pas
    être immédiatement verrouillée est ignorée. Ignorer les lignes
    verrouillées fournit une vue incohérente des données, donc ce n'est pas
    acceptable dans un cadre général, mais ça peut être utilisé pour éviter
    les contentions de verrou lorsque plusieurs consommateurs cherchent à
    accéder à une table de style queue. Notez que <literal>NOWAIT</literal> et
    <literal>SKIP LOCKED</literal> s'appliquent seulement au(x) verrou(x)
    niveau ligne &mdash; le verrou niveau table <literal>ROW SHARE</literal>
    est toujours pris de façon ordinaire (voir <xref linkend="mvcc"/>).
    L'option <literal>NOWAIT</literal> de <xref linkend="sql-lock"/> peut
    toujours être utilisée pour acquérir le verrou niveau table sans attendre.
   </para>

   <para>
    Si des tables particulières sont nommées dans une clause de verrouillage,
    alors seules les lignes provenant de ces tables sont verrouillées&nbsp;;
    toute autre table utilisée dans le <command>SELECT</command> est simplement
    lue. Une clause de verrouillage sans liste de tables affecte toutes les
    tables utilisées dans l'instruction. Si une clause de verrouillage est
    appliquée à une vue ou à une sous-requête, cela affecte toutes les tables
    utilisées dans la vue ou la sous-requête. Néanmoins, ces clauses ne
    s'appliquent pas aux requêtes <literal>WITH</literal> référencées par la
    clé primaire.
    Si vous voulez qu'un verrouillage de lignes intervienne dans une requête
    <literal>WITH</literal>, spécifiez une clause de verrouillage à l'intérieur
    de la requête <literal>WITH</literal>.
   </para>

   <para>
    Plusieurs clauses de verrouillage peuvent être données si il est nécessaire
    de spécifier différents comportements de verrouillage pour différentes
    tables. Si la même table est mentionné (ou affectée implicitement) par plus
    d'une clause de verrouillage, alors elle est traitée comme la clause la plus
    forte. De façon similaire, une table est traitée avec <literal>NOWAIT</literal>
    si c'est spécifiée sur au moins une des clauses qui l'affectent. Sinon, il
    est traité comme <literal>SKIP LOCKED</literal> si c'est indiqué dans une
    des clauses qui l'affectent.
   </para>

   <para>
    Les clauses de verrouillage nécessitent
    que chaque ligne retournée soit clairement identifiable par une ligne
    individuelle d'une table&nbsp;; ces options ne peuvent, par exemple, pas être
    utilisées avec des fonctions d'agrégats.
   </para>

   <para>
    Quand une clause de verrouillage
    apparaissent au niveau le plus élevé d'une requête <command>SELECT</command>, les lignes
    verrouillées sont exactement celles qui sont renvoyées par la requête&nbsp;; dans le
    cas d'une requête avec jointure, les lignes verrouillées sont celles qui contribuent
    aux lignes jointes renvoyées.
    De plus, les lignes qui ont satisfait aux conditions de la requête au moment de la prise de son instantané
    sont verrouillées, bien qu'elles ne seront pas retournées si elles ont été modifiées après la prise du
    snapshot et ne satisfont plus les conditions de la requête.  Si <literal>LIMIT</literal>
    est utilisé, le verrouillage cesse une fois que suffisamment de lignes ont été renvoyées
    pour satisfaire la limite (mais notez que les lignes ignorées à cause de la clause
    <literal>OFFSET</literal> seront verrouillées).  De la même manière,
    si une clause de verrouillage
    est utilisé pour la requête d'un curseur, seules les lignes réellement récupérées ou parcourues par le curseur
    seront verrouillées.
   </para>

   <para>
    Si une clause de verrouillage apparait dans un sous-<command>SELECT</command>, les lignes verrouillées sont celles
    renvoyées par la sous-requête à la requête externe. Cela peut concerner
    moins de lignes que l'étude de la sous-requête seule pourrait faire penser,
    parce que les conditions de la requête externe peuvent être utilisées
    pour optimiser l'exécution de la sous-requête. Par exemple,
    <programlisting>
SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;
    </programlisting>
    verrouillera uniquement le lignes pour lesquelles <literal>col1 = 5</literal>,
    même si cette condition n'est pas écrite dans la sous-requête.
   </para>

   <para>
    Les anciennes versions échouaient à préserver un verrou qui est mis à jour
    par un point de sauvegarde ultérieur. Par exemple, ce code&nbsp;:
    <programlisting>
BEGIN;
SELECT * FROM ma_table WHERE cle = 1 FOR UPDATE;
SAVEPOINT s;
UPDATE ma_table SET ... WHERE cle = 1;
ROLLBACK TO s;
    </programlisting>
    va échouer à conserver le verrou <literal>FOR UPDATE</literal> après la
    commande <command>ROLLBACK TO</command>. Ceci a été corrigé en 9.3.
   </para>

   <caution>
    <para>
     Il est possible qu'une commande <command>SELECT</command> exécutée
     au niveau d'isolation <literal>READ COMMITTED</literal> et utilisant
     <literal>ORDER BY</literal> et une clause de verrouillage
     renvoie les lignes dans le
     désordre. C'est possible car l' <literal>ORDER BY</literal> est appliqué en premier.
     La commande trie le résultat, mais peut alors être bloquée le temps d'obtenir un verrou
     sur une ou plusieurs des lignes. Une fois que le <literal>SELECT</literal> est débloqué, des
     valeurs sur la colonne qui sert à ordonner peuvent avoir été modifiées, ce qui entraîne ces
     lignes apparaissant dans le désordre (bien qu'elles soient dans l'ordre par rapport aux valeurs
     d'origine de ces colonnes). Ceci peut être contourné si besoin en
     plaçant la clause <literal>FOR UPDATE/SHARE</literal> dans une sous-requête,
     par exemple
     <programlisting>
SELECT * FROM (SELECT * FROM matable FOR UPDATE) ss ORDER BY column1;
     </programlisting>
     Notez que cela entraîne le verrouillage de toutes les lignes de <structname>matable</structname>,
     alors que <literal>FOR UPDATE</literal> au niveau supérieur verrouillerait seulement les
     lignes réellement renvoyées. Cela peut causer une différence de performance significative,
     en particulier si l' <literal>ORDER BY</literal> est combiné avec
     <literal>LIMIT</literal> ou d'autres restrictions.  Cette technique est donc recommandée uniquement si
     vous vous attendez à des mises à jour concurrentes sur les colonnes servant à l'ordonnancement
     et qu'un résultat strictement ordonné est requis.
    </para>

    <para>
     Au niveau d'isolation de transactions <literal>REPEATABLE READ</literal>
     et <literal>SERIALIZABLE</literal>, cela causera une erreur de
     sérialisation (avec un <literal>SQLSTATE</literal> valant
     <literal>'40001'</literal>), donc il n'est pas possible de recevoir
     des lignes non triées avec ces niveaux d'isolation.
    </para>
   </caution>

  </refsect2>

  <refsect2 id="sql-table">
   <title>Commande <literal>TABLE</literal></title>

   <para>
    La commande
    <programlisting>
TABLE <replaceable class="parameter">nom</replaceable>
    </programlisting>
    est équivalente à
    <programlisting>
SELECT * FROM <replaceable class="parameter">nom</replaceable>
    </programlisting>
    Elle peut être utilisée comme commande principale d'une requête,
    ou bien comme une variante syntaxique permettant de gagner de la place
    dans des parties de requêtes complexes. Seuls les clauses de verrou de
    <literal>WITH</literal>, <literal>UNION</literal>,
    <literal>INTERSECT</literal>, <literal>EXCEPT</literal>, <literal>ORDER
     BY</literal>, <literal>LIMIT</literal>, <literal>OFFSET</literal>,
    <literal>FETCH</literal> et <literal>FOR</literal> peuvent être utilisées
    avec <command>TABLE</command>&nbsp;; la clause <literal>WHERE</literal> et
    toute forme d'agrégation ne peuvent pas être utilisées.
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Joindre la table <literal>films</literal> avec la table
   <literal>distributeurs</literal>&nbsp;:

   <programlisting>SELECT f.titre, f.did, d.nom, f.date_prod, f.genre
    FROM distributeurs d, films f
    WHERE f.did = d.did

       titre       | did |     nom      | date_prod  |   genre
-------------------+-----+--------------+------------+------------
 The Third Man     | 101 | British Lion | 1949-12-23 | Drame
 The African Queen | 101 | British Lion | 1951-08-11 | Romantique
 ...
   </programlisting>
  </para>

  <para>
   Additionner la colonne <literal>longueur</literal> de tous les films,
   grouper les résultats par <literal>genre</literal>&nbsp;:

   <programlisting>SELECT genre, sum(longueur) AS total FROM films GROUP BY genre;

   genre    | total
------------+-------
 Action     | 07:34
 Comédie    | 02:58
 Drame      | 14:28
 Musical    | 06:42
 Romantique | 04:38
   </programlisting>
  </para>

  <para>
   Additionner la colonne <literal>longueur</literal> de tous les films,
   grouper les résultats par <literal>genre</literal> et afficher les groupes
   dont les totaux font moins de cinq heures&nbsp;:

   <programlisting>SELECT genre, sum(longueur) AS total
    FROM films
    GROUP BY genre
    HAVING sum(longueur) &lt; interval '5 hours';

   genre    | total
------------+-------
 Comedie    | 02:58
 Romantique | 04:38
   </programlisting>
  </para>

  <para>
   Les deux exemples suivants représentent des façons identiques de trier les résultats
   individuels en fonction du contenu de la deuxième colonne (<literal>nom</literal>)&nbsp;:

   <programlisting>SELECT * FROM distributeurs ORDER BY nom;
SELECT * FROM distributeurs ORDER BY 2;

 did |       nom
-----+------------------
 109 | 20th Century Fox
 110 | Bavaria Atelier
 101 | British Lion
 107 | Columbia
 102 | Jean Luc Godard
 113 | Luso films
 104 | Mosfilm
 103 | Paramount
 106 | Toho
 105 | United Artists
 111 | Walt Disney
 112 | Warner Bros.
 108 | Westward
   </programlisting>
  </para>

  <para>
   L'exemple suivant présente l'union des tables
   <literal>distributeurs</literal> et <literal>acteurs</literal>, restreignant
   les résultats à ceux de chaque table dont la première lettre est un W.
   Le mot clé <literal>ALL</literal> est omis, ce qui permet de n'afficher que
   les lignes distinctes.

   <programlisting>distributeurs:               acteurs:
 did |     nom               id |     nom
-----+--------------        ----+----------------
 108 | Westward               1 | Woody Allen
 111 | Walt Disney            2 | Warren Beatty
 112 | Warner Bros.           3 | Walter Matthau
 ...                         ...

SELECT distributeurs.nom
    FROM distributeurs
    WHERE distributeurs.nom LIKE 'W%'
UNION
SELECT actors.nom
    FROM acteurs
    WHERE acteurs.nom LIKE 'W%';

      nom
----------------
 Walt Disney
 Walter Matthau
 Warner Bros.
 Warren Beatty
 Westward
 Woody Allen
   </programlisting>
  </para>

  <para>
   L'exemple suivant présente l'utilisation d'une fonction dans la clause <literal>FROM</literal>,
   avec et sans liste de définition de colonnes&nbsp;:

   <programlisting>CREATE FUNCTION distributeurs(int) RETURNS SETOF distributeurs AS $$
    SELECT * FROM distributeurs WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributeurs(111);
 did |    name
-----+-------------
 111 | Walt Disney

CREATE FUNCTION distributeurs_2(int) RETURNS SETOF record AS $$
    SELECT * FROM distributeurs WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributeurs_2(111) AS (f1 int, f2 text);
 f1  |     f2
-----+-------------
 111 | Walt Disney
   </programlisting>
  </para>

  <para>
   Voici un exemple d'une fonction avec la colonne ordinality&nbsp;:

   <programlisting>
SELECT * FROM unnest(ARRAY['a','b','c','d','e','f']) WITH ORDINALITY;
 unnest | ordinality
--------+----------
 a      |        1
 b      |        2
 c      |        3
 d      |        4
 e      |        5
 f      |        6
(6 rows)
   </programlisting>
  </para>

  <para>
   Cet exemple montre comment utiliser une clause <literal>WITH</literal> simple:

   <programlisting>
WITH t AS (
    SELECT random() as x FROM generate_series(1, 3)
  )
SELECT * FROM t
UNION ALL
SELECT * FROM t

         x
--------------------
  0.534150459803641
  0.520092216785997
 0.0735620250925422
  0.534150459803641
  0.520092216785997
 0.0735620250925422
   </programlisting>

   Notez que la requête <literal>WITH</literal> n'a été évaluée qu'une seule
   fois, ce qui fait qu'on a deux jeux contenant les mêmes trois valeurs.
  </para>

  <para>
   Cet exemple utilise <literal>WITH RECURSIVE</literal> pour trouver tous
   les subordonnés (directs ou indirects) de l'employée Marie, et leur niveau
   de subordination, à partir d'une table qui ne donne que les subordonnés
   directs&nbsp;:

   <programlisting>
WITH RECURSIVE recursion_employes(distance, nom_employe, nom_manager) AS (
    SELECT 1, nom_employe, nom_manager
    FROM employe
    WHERE nom_manager = 'Marie'
  UNION ALL
    SELECT er.distance + 1, e.nom_employe, e.nom_manager
    FROM recursion_employes er, employe e
    WHERE er.nom_employe = e.nom_manager
  )
SELECT distance, nom_employe FROM recursion_employes;
   </programlisting>

   Notez la forme typique des requêtes récursives&nbsp;:
   une condition initiale, suivie par <literal>UNION</literal>, suivis par
   la partie récursive de la requête. Assurez-vous que la partie récursive
   de la requête finira par ne plus retourner d'enregistrement, sinon la
   requête bouclera indéfiniment (Voir <xref linkend="queries-with"/> pour
   plus d'exemples).
  </para>

  <para>
   Cet exemple utilise <literal>LATERAL</literal> pour appliquer une fonction
   renvoyant des lignes, <function>recupere_nom_produits()</function>, pour
   chaque ligne de la table <structname>manufacturiers</structname>&nbsp;:

   <programlisting>
SELECT m.nom AS mnom, pnom
FROM manufacturiers m, LATERAL recupere_nom_produits(m.id) pnom;
   </programlisting>

   Les manufacturiers qui n'ont pas encore de produits n'apparaîtront pas dans
   le résultat car la jointure est interne. Si vous voulons inclure les noms
   de ces manufacturiers, la requête doit être écrite ainsi&nbsp;:

   <programlisting>
SELECT m.name AS mnom, pnom
FROM manufacturiers m LEFT JOIN LATERAL recupere_nom_produits(m.id) pnom ON true;
   </programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   L'instruction <command>SELECT</command> est évidemment compatible avec le
   standard SQL. Mais il y a des extensions et quelques fonctionnalités
   manquantes.
  </para>

  <refsect2>
   <title>Clauses <literal>FROM</literal> omises</title>

   <para>
    <productname>PostgreSQL</productname> autorise l'omission de la clause
    <literal>FROM</literal>. Cela permet par exemple de calculer le
    résultat d'expressions simples&nbsp;:
    <programlisting>SELECT 2+2;

 ?column?
----------
        4
    </programlisting>
    D'autres bases de données <acronym>SQL</acronym> interdisent ce comportement,
    sauf à introduire une table virtuelle d'une seule ligne sur laquelle exécuter
    la commande <command>SELECT</command>.
   </para>

   <para>
    S'il n'y a pas de clause <literal>FROM</literal>, la requête ne
    peut pas référencer les tables de la base de données. La
    requête suivante est, ainsi, invalide&nbsp;:
    <programlisting>SELECT distributors.* WHERE distributors.name = 'Westward';
    </programlisting>
    Les versions antérieures à <productname>PostgreSQL</productname> 8.1
    acceptaient les requêtes de cette forme en ajoutant une entrée implicite à
    la clause <literal>FROM</literal> pour chaque table référencée.
    Ce n'est plus autorisé.
   </para>
  </refsect2>

  <refsect2>
   <title>Listes <literal>SELECT</literal> vides</title>

   <para>
    La liste des expressions en sortie après <literal>SELECT</literal> peut
    être vide, produisant ainsi une table de résultats à zéro colonne. Ceci
    n'est pas une syntaxe valide suivant le standard SQL.
    <productname>PostgreSQL</productname> l'autorise pour être cohérent avec le
    fait qu'il accepte des tables à zéro colonne. Néanmoins, une liste vide
    n'est pas autorisé quand un <literal>DISTINCT</literal> est utilisé.
   </para>
  </refsect2>

  <refsect2>
   <title>Omettre le mot clé <literal>AS</literal></title>

   <para>
    Dans le standard SQL, le mot clé <literal>AS</literal> peut être omis
    devant une colonne de sortie à partir du moment où le nouveau nom de colonne
    est un nom valide de colonne (c'est-à-dire, différent d'un mot clé réservé).
    <productname>PostgreSQL</productname> est légèrement plus restrictif&nbsp;:
    <literal>AS</literal> est nécessaire si le nouveau nom de colonne est un
    mot clé quel qu'il soit, réservé ou non. Il est recommandé d'utiliser
    <literal>AS</literal> ou des colonnes de sortie entourées de guillemets, pour
    éviter tout risque de conflit en cas d'ajout futur de mot clé.
   </para>

   <para>
    Dans les éléments de <literal>FROM</literal>, le standard et
    <productname>PostgreSQL</productname> permettent que <literal>AS</literal>
    soit omis avant un alias qui n'est pas un mot clé réservé. Mais
    c'est peu pratique pour les noms de colonnes, à causes d'ambiguïtés
    syntaxiques.
   </para>
  </refsect2>

  <refsect2>
   <title><literal>ONLY</literal> et l'héritage</title>

   <para>
    Le standard SQL impose des parenthèses autour du nom de table après la
    clause <literal>ONLY</literal>, comme dans <literal>SELECT * FROM ONLY
     (tab1), ONLY (tab2) WHERE ...</literal>.
    <productname>PostgreSQL</productname> considère les parenthèses comme étant
    optionnelles.
   </para>

   <para>
    <productname>PostgreSQL</productname> autorise une <literal>*</literal> en
    fin pour indiquer explicitement le comportement opposé de la clause
    <literal>ONLY</literal> (donc inclure les tables filles). Le standard ne le
    permet pas.
   </para>

   <para>
    (Ces points s'appliquent de la même façon à toutes les commandes SQL
    supportant l'option <literal>ONLY</literal>.)
   </para>
  </refsect2>

  <refsect2>
   <title>Restrictions de la clause <literal>TABLESAMPLE</literal></title>

   <para>
    La clause <literal>TABLESAMPLE</literal> est actuellement seulement
    acceptée pour les tables standards et les vues matérialisées. D'après le
    standard SQL, il devrait être possible de l'appliquer à tout élément
    faisant partie de la clause <literal>FROM</literal>.
   </para>
  </refsect2>

  <refsect2>
   <title>Appels de fonction dans la clause <literal>FROM</literal></title>

   <para>
    <productname>PostgreSQL</productname> autorise un appel de fonction dans
    la liste <literal>FROM</literal>. Pour le standard SQL, il serait
    nécessaire de placer cet appel de fonction dans un
    sous-<command>SELECT</command>&nbsp;; autrement dit, la syntaxe
    <literal>FROM <replaceable>fonc</replaceable>(...) <replaceable>alias</replaceable></literal>
    est à peu près équivalente à
    <literal>FROM LATERAL (SELECT <replaceable>fonc</replaceable>(...)) <replaceable>alias</replaceable></literal>.
    Notez que <literal>LATERAL</literal> est considéré comme étant
    implicite&nbsp;; ceci est dû au fait que le standard réclame la sémantique de
    <literal>LATERAL</literal> pour un élément <literal>UNNEST()</literal> dans
    la clause <literal>FROM</literal>.
    <productname>PostgreSQL</productname> traite <literal>UNNEST()</literal> de
    la même façon que les autres fonctions renvoyant des lignes.
   </para>
  </refsect2>

  <refsect2>
   <title>Espace logique disponible pour <literal>GROUP BY</literal> et
    <literal>ORDER BY</literal></title>

   <para>
    Dans le standard SQL-92, une clause <literal>ORDER BY</literal>
    ne peut utiliser que les noms ou numéros des colonnes en sortie, une clause
    <literal>GROUP BY</literal> que des expressions fondées sur les noms de
    colonnes en entrée. <productname>PostgreSQL</productname> va plus loin, puisqu'il
    autorise chacune de ces clauses à utiliser également l'autre possibilité.
    En cas d'ambiguïté, c'est l'interprétation du standard qui prévaut.
    <productname>PostgreSQL</productname> autorise aussi l'utilisation d'expressions
    quelconques dans les deux clauses.
    Les noms apparaissant dans ces expressions sont toujours considérés comme nom de
    colonne en entrée, pas en tant que nom de colonne du résultat.
   </para>

   <para>
    SQL:1999 et suivant utilisent une définition légèrement différente,
    pas totalement compatible avec le SQL-92. Néanmoins, dans la plupart des
    cas, <productname>PostgreSQL</productname> interprète une expression
    <literal>ORDER BY</literal> ou <literal>GROUP BY</literal> en suivant
    la norme SQL:1999.
   </para>
  </refsect2>

  <refsect2>
   <title>Dépendances fonctionnelles</title>

   <para>
    <productname>PostgreSQL</productname> reconnaît les dépendances fonctionnelles
    (qui permettent que les nom des colonnes ne soient pas dans le <literal>GROUP BY</literal>) seulement lorsqu'une clé primaire
    est présente dans la liste du <literal>GROUP BY</literal>.
    Le standard SQL spécifie des configurations supplémentaires qui doivent être reconnues.
   </para>
  </refsect2>

  <refsect2>
   <title><literal>LIMIT</literal> et <literal>OFFSET</literal></title>

   <para>
    Les clauses <literal>LIMIT</literal> et <literal>OFFSET</literal>
    sont une syntaxe spécifique à <productname>PostgreSQL</productname>, aussi
    utilisée dans <productname>MySQL</productname>. La norme SQL:2008 a
    introduit les clauses <literal>OFFSET ... FETCH {FIRST|NEXT}...</literal>
    pour la même fonctionnalité, comme montré plus haut dans
    <xref linkend="sql-limit"/>. Cette syntaxe
    est aussi utilisée par <productname>IBM DB2</productname>.
    (Les applications écrites pour <productname>Oracle</productname> contournent
    fréquemment le problème par l'utilisation de la colonne auto-générée
    <literal>rownum</literal> pour obtenir les effets de ces clauses, qui n'est
    pas disponible sous PostgreSQL).
   </para>
  </refsect2>

  <refsect2>
   <title><literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal>, <literal>FOR KEY SHARE</literal></title>

   <para>
    Bien que <literal>FOR UPDATE</literal> soit présent dans le standard SQL, le standard
    ne l'autorise que comme une option de <command>DECLARE CURSOR</command>.
    <productname>PostgreSQL</productname> l'autorise dans toute requête <command>SELECT</command>
    et dans toute sous-requête <command>SELECT</command>, mais c'est une extension.
    Les variantes <literal>FOR NO KEY UPDATE</literal>, <literal>FOR
     SHARE</literal> et <literal>FOR KEY SHARE</literal>, ainsi que
    <literal>NOWAIT</literal> et <literal>SKIP LOCKED</literal>,
    n'apparaissent pas dans le standard.
   </para>
  </refsect2>

  <refsect2>
   <title>Ordre de modification de données dans un <literal>WITH</literal></title>

   <para>
    <productname>PostgreSQL</productname> permet que les clauses <command>INSERT</command>,
    <command>UPDATE</command>, et <command>DELETE</command> soient utilisées comme requêtes <literal>WITH</literal>.
    Ceci n'est pas présent dans le standard SQL.
   </para>
  </refsect2>

  <refsect2>
   <title>Clauses non standard</title>

   <para>
    La clause <literal>DISTINCT ON</literal> est une extension du standard
    SQL.
   </para>

   <para>
    <literal>ROWS FROM( ... )</literal> est une extension du standard
    SQL.
   </para>

   <para>
    Les options <literal>MATERIALIZED</literal> et <literal>NOT
     MATERIALIZED</literal> de la clause <literal>WITH</literal> sont des
    extensions au standard SQL.
   </para>
  </refsect2>
 </refsect1>
</refentry>
