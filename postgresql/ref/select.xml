<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060313 pour la relecture -->

<refentry id="sql-select">
 <refmeta>
  <refentrytitle>SELECT</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>SELECT</refname>
  <refname>TABLE</refname>
  <refname>WITH</refname>
  <refpurpose>récupère des lignes d'une table ou d'une vue</refpurpose>
 </refnamediv>

 <indexterm zone="sql-select">
  <primary>SELECT</primary>
 </indexterm>

 <indexterm zone="sql-select">
  <primary>commande TABLE</primary>
 </indexterm>

 <indexterm zone="sql-select">
  <primary>WITH</primary>
  <secondary>dans un SELECT</secondary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>[ WITH [ RECURSIVE ] <replaceable class="parameter">requête_with</replaceable> [, ...] ]
SELECT [ ALL | DISTINCT [ ON ( <replaceable class="parameter">expression</replaceable> [, ...] ) ] ]
    * | <replaceable class="parameter">expression</replaceable> [ [ AS ] <replaceable class="parameter">nom_d_affichage</replaceable> ] [, ...]
    [ FROM <replaceable class="parameter">éléments_from</replaceable> [, ...] ]
    [ WHERE <replaceable class="parameter">condition</replaceable> ]
    [ GROUP BY <replaceable class="parameter">expression</replaceable> [, ...] ]
    [ HAVING <replaceable class="parameter">condition</replaceable> [, ...] ]
    [ WINDOW <replaceable class="parameter">nom_window</replaceable> AS ( <replaceable class="parameter">définition_window</replaceable> ) [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] <replaceable class="parameter">select</replaceable> ]
    [ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">opérateur</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { <replaceable class="parameter">nombre</replaceable> | ALL } ]
    [ OFFSET <replaceable class="parameter">début</replaceable> ] [ ROW | ROWS ] ]
    [ FETCH { FIRST | NEXT } [ <replaceable class="parameter">total</replaceable> ] { ROW | ROWS } ONLY ]
    [ FOR { UPDATE | SHARE } [ OF <replaceable class="parameter">nom_table</replaceable> [, ...] ] [ NOWAIT ] [...] ]

<phrase>avec <replaceable class="parameter">éléments_from</replaceable> qui peut être&nbsp;:</phrase>

    [ ONLY ] <replaceable class="parameter">nom_table</replaceable> [ * ] [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">alias_colonne</replaceable> [, ...] ) ] ]
    ( <replaceable class="parameter">select</replaceable> ) [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">alias_colonne</replaceable> [, ...] ) ]
    <replaceable class="parameter">nom_requête_with</replaceable> [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">alias_colonne</replaceable> [, ...] ) ] ]
    <replaceable class="parameter">nom_fonction</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] ) [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">alias_colonne</replaceable> [, ...] | <replaceable class="parameter">définition_colonne</replaceable> [, ...] ) ]
    <replaceable class="parameter">nom_fonction</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] ) AS ( <replaceable class="parameter">définition_colonne</replaceable> [, ...] )
    <replaceable class="parameter">éléments_from</replaceable> [ NATURAL ] <replaceable class="parameter">type_jointure</replaceable> <replaceable class="parameter">éléments_from</replaceable> [ ON <replaceable class="parameter">condition_jointure</replaceable> | USING ( <replaceable class="parameter">colonne_jointure</replaceable> [, ...] ) ]

<phrase>et <replaceable class="parameter">requête_with</replaceable> est&nbsp;:</phrase>

    <replaceable class="parameter">nom_requête_with</replaceable> [ ( <replaceable class="parameter">nom_colonne</replaceable> [, ...] ) ] AS ( <replaceable class="parameter">select</replaceable> | <replaceable class="parameter">values</replaceable> | <replaceable class="parameter">insert</replaceable> | <replaceable class="parameter">update</replaceable> | <replaceable class="parameter">delete</replaceable> )

TABLE [ ONLY ] <replaceable class="parameter">nom_table</replaceable> [ * ]
</synopsis>

 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-select">
   <primary>SELECT</primary>
  </indexterm>

  <para>
   <command>SELECT</command> récupère des lignes de zéro ou plusieurs
   tables. Le traitement général de <command>SELECT</command> est le
   suivant&nbsp;:

   <orderedlist>
    <listitem>
     <para>
      Toutes les requêtes dans la liste <literal>WITH</literal> sont évaluées.
      Elles jouent le rôle de tables temporaires qui peuvent être référencées
      dans la liste <literal>FROM</literal>. Une requête
      <literal>WITH</literal> qui est référencée plus d'une fois dans
      <literal>FROM</literal> n'est calculée qu'une fois
      (voir <xref linkend="sql-with"/> ci-dessous).
     </para>
    </listitem>

    <listitem>
     <para>
      Tous les éléments de la liste <literal>FROM</literal> sont calculés.
      (Chaque élément dans la liste <literal>FROM</literal> est une table 
      réelle ou virtuelle.) Si plus d'un élément sont spécifiés dans la liste
      <literal>FROM</literal>, ils font l'objet d'une jointure croisée (cross-join). (Voir <xref
      linkend="sql-from"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>WHERE</literal> est spécifiée, toutes les lignes
      qui ne satisfont pas les conditions sont éliminées de l'affichage. (Voir
      <xref linkend="sql-where"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>GROUP BY</literal> est spécifiée, l'affichage est
      divisé en groupes de lignes qui correspondent à une ou plusieurs valeurs.
      Si la clause <literal>HAVING</literal> est présente, elle élimine les
      groupes qui ne satisfont pas la condition donnée. (Voir <xref
      linkend="sql-groupby"/> et <xref
      linkend="sql-having"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Les lignes retournées sont traitées en utilisant les expressions de sortie
      de <command>SELECT</command> pour chaque ligne ou groupe de ligne sélectionné. (Voir <xref
      linkend="sql-select-list"/> ci-dessous.)
    </para>
    </listitem>

    <listitem>
     <para>
      <literal>SELECT DISTINCT</literal> élimine du résultat les lignes en double.
      <literal>SELECT DISTINCT ON</literal> élimine les lignes qui correspondent sur toute l'expression spécifiée.
      <literal>SELECT ALL</literal>
      (l'option par défaut) retourne toutes les lignes, y compris les doublons.
      (cf. <xref linkend="sql-distinct"
      endterm="sql-distinct-title"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      En utilisant les opérateurs <literal>UNION</literal>,
      <literal>INTERSECT</literal> et <literal>EXCEPT</literal>, l'affichage de
      plusieurs instructions <command>SELECT</command> peut être combiné pour
      former un ensemble unique de résultats. L'opérateur <literal>UNION</literal>
      renvoie toutes les lignes qui appartiennent, au moins, à l'un des ensembles de
      résultats. L'opérateur <literal>INTERSECT</literal> renvoie toutes les
      lignes qui sont dans tous les ensembles de résultats.
      L'opérateur <literal>EXCEPT</literal> renvoie les lignes qui sont
      présentes dans le premier ensemble de résultats mais pas dans le 
      deuxième. Dans les trois cas, les lignes dupliquées sont éliminées sauf
      si <literal>ALL</literal> est spécifié. Le mot-clé supplémentaire
      <literal>DISTINCT</literal> peut être ajouté pour signifier explicitement que
      les lignes en doublon sont éliminées. Notez bien que <literal>DISTINCT</literal> est 
      là le comportement par défaut, bien que <literal>ALL</literal> soit
      le défaut pour la commande <command>SELECT</command>. (Voir <xref linkend="sql-union"
     />, <xref linkend="sql-intersect"
     /> et <xref linkend="sql-except"
     /> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>ORDER BY</literal> est spécifiée, les lignes
      renvoyées sont triées dans l'ordre spécifié. Si <literal>ORDER
      BY</literal> n'est pas indiqué, les lignes sont retournées dans l'ordre 
      qui permet la réponse la plus rapide du système. (Voir <xref
      linkend="sql-orderby"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si les clauses <literal>LIMIT</literal> (ou <literal>FETCH FIRST</literal>)
      ou <literal>OFFSET</literal> sont
      spécifiées, l'instruction <command>SELECT</command> ne renvoie qu'un
      sous-ensemble de lignes de résultats. (Voir <xref linkend="sql-limit"
     /> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>FOR UPDATE</literal> ou <literal>FOR
      SHARE</literal> est spécifiée, l'instruction <command>SELECT</command>
      verrouille les lignes sélectionnées contre les mises à jour concurrentes.
      (Voir <xref linkend="sql-for-update-share"
     /> ci-dessous.)
     </para>
    </listitem>
   </orderedlist>
  </para>

  <para>
   Le droit <literal>SELECT</literal> sur chaque colonne utilisée dans une
   commande <command>SELECT</command> est nécessaire pour lire
   ses valeurs. L'utilisation de <literal>FOR UPDATE</literal> ou de
   <literal>FOR SHARE</literal> requiert en plus le droit 
   <literal>UPDATE</literal> (pour au moins une colonne de chaque table
   sélectionnée).
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <refsect2 id="sql-with">
   <title id="sql-with-title">Clause <literal>WITH</literal></title>

   <para>
    La clause <literal>WITH</literal> vous permet de spécifier une ou plusieurs
    sous-requêtes qui peuvent être utilisées par leur nom dans la requête
    principale.
    Les sous-requêtes se comportent comme des tables temporaires ou des vues
    pendant la durée d'exécution de la requête principale.
    Chaque sous-requête peut être un ordre <command>SELECT</command>, <command>VALUES</command>,
    <command>INSERT</command>, <command>UPDATE</command> ou bien
    <command>DELETE</command>.
    Lorsque vous écrivez un ordre de modification de données (<command>INSERT</command>,
    <command>UPDATE</command> ou <command>DELETE</command>) dans une clause
    <literal>WITH</literal>, il est habituel d'inclure une clause <literal>RETURNING</literal>.
    C'est la sortie de cette clause <literal>RETURNING</literal>, <emphasis>et non pas</emphasis> la table sous-jacente
    que l'ordre modifie, qui donne lieu à la table temporaire lue par la requête principale. 
    Si la clause <literal>RETURNING</literal> est omise, l'ordre est tout de même exécuté,
    mais il ne produit pas de sortie ; il ne peut donc pas être référencé comme une table 
    par la requête principale.
   </para>

   <para>
    Un nom (sans qualification de schéma) doit être spécifié pour chaque requête
    <literal>WITH</literal>. En option, une liste de noms de colonnes
    peut être spécifié&nbsp;; si elle est omise, les noms de colonnes sont déduites
    de la sous-requête.
   </para>

   <para>
    Si <literal>RECURSIVE</literal> est spécifié, la sous-requête <command>SELECT</command> peut se
    référencer elle même. Une sous-requête de ce type doit avoir la forme
<synopsis>
<replaceable class="parameter">terme_non_récursif</replaceable> UNION [ ALL | DISTINCT ] <replaceable class="parameter">terme_récursif</replaceable>
</synopsis>
    où l'auto-référence récursive doit apparaître dans la partie droite
    de l'<literal>UNION</literal>. Seule une auto-référence récursive
    est autorisée par requête. Les ordres de modification récursifs ne sont pas supportés,
    mais vous pouvez utiliser le résultat d'une commande
    <command>SELECT</command> récursive dans un ordre de modification.
    Voir <xref linkend="queries-with"/> pour un exemple.
   </para>

   <para>
    Un autre effet de <literal>RECURSIVE</literal> est que les requêtes
    <literal>WITH</literal> n'ont pas besoin d'être ordonnées&nbsp;: une
    requête peut en référencer une autre qui se trouve plus loin dans la liste
    (toutefois, les références circulaires, ou récursion mutuelle, ne sont pas
    implémentées). Sans <literal>RECURSIVE</literal>, les requêtes
    <literal>WITH</literal> ne peuvent référencer d'autres requêtes
    <literal>WITH</literal> so&oelig;urs que si elles sont déclarées avant dans
    la liste <literal>WITH</literal>.
   </para>

   <para>
    Une propriété clé des requêtes <literal>WITH</literal> est qu'elles ne sont
    évaluées qu'une seule fois par exécution de la requête principale,
    même si la requête principale les utilise plus d'une fois.
    En particulier, vous avez la garantie que les traitements de modification de données
    sont exécutés une seule et unique fois, que la requête principale lise tout ou partie de leur sortie.
   </para>

   <para>
    Tout se passe comme si la requête principale et les requêtes <literal>WITH</literal> étaient toutes
    exécutées en même temps. Ceci a pour conséquence que les effets d'un ordre de modification dans une clause
    <literal>WITH</literal> ne peuvent pas être vues des autres parties de la requête, sauf en lisant la sortie
    de <literal>RETURNING</literal>. Si deux de ces ordres de modifications tentent de modifier la même ligne, 
    les résultats sont imprévisibles.
   </para>

   <para>
    Voir <xref linkend="queries-with"/> pour plus d'informations.
   </para>
  </refsect2>

  <refsect2 id="sql-from">
   <title id="sql-from-title">Clause <literal>FROM</literal></title>

   <para>
    La clause <literal>FROM</literal> spécifie une ou plusieurs tables source
    pour le <command>SELECT</command>. Si plusieurs sources sont spécifiées, le
    résultat est un produit cartésien (jointure croisée) de toutes les sources.
    Mais habituellement, des conditions de qualification sont ajoutées pour
    restreindre les lignes renvoyées à un petit sous-ensemble du produit
    cartésien.
   </para>

   <para>
    La clause <literal>FROM</literal> peut contenir les éléments
    suivants&nbsp;:

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">nom_table</replaceable></term>
      <listitem>
       <para>
        Le nom (éventuellement qualifié par le nom du schéma) d'une table existante
	ou d'une vue. Si <literal>ONLY</literal> est spécifié, seule cette table est
	parcourue. Dans le cas contraire, la table et toutes ses
	descendantes (s'il y en a) sont parcourues.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><replaceable class="parameter">alias</replaceable></term>
      <listitem>
       <para>
        Un nom de substitution pour l'élément <literal>FROM</literal> contenant
	l' alias. Un alias est utilisé par brièveté ou pour lever toute
	ambiguïté lors d'auto-jointures (la même table est parcourue plusieurs
	fois). Quand un alias est fourni, il cache complètement le nom réel de
	la table ou fonction&nbsp;; par exemple, avec <literal>FROM truc AS</literal>,
	le reste du <command>SELECT</command> doit faire référence à cet
	élément de <literal>FROM</literal> par <literal>f</literal> et non pas par
	<literal>truc</literal>. Si un alias est donné, une liste d' alias de colonnes
	peut aussi être saisi comme noms de substitution pour différentes
	colonnes de la table.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><replaceable class="parameter">select</replaceable></term>
      <listitem>
       <para>
        Un sous-<command>SELECT</command> peut apparaître dans la clause
        <literal>FROM</literal>. Il agit comme si sa sortie était 
        transformée en table temporaire pour la durée de cette seule commande
        <command>SELECT</command>. Le sous-<command>SELECT</command>
        doit être entouré de parenthèses et un alias
	<emphasis>doit</emphasis> lui être fourni.
	Une commande <xref linkend="sql-values"/>
        peut aussi être utilisée ici.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">requête_with</replaceable></term>
      <listitem>
       <para>
        Une requête <literal>WITH</literal> est référencée par l'écriture de
        son nom, exactement comme si le nom de la requête était un nom de table
        (en fait, la requête <literal>WITH</literal> cache toutes les tables
        qui auraient le même nom dans la requête principale. Si nécessaire, vous
        pouvez accéder à une table réelle du même nom en précisant le schéma
        du nom de la table).
        Un alias peut être indiqué de la même façon que pour une table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nom_fonction</replaceable></term>
      <listitem>
       <para>
        Des appels de fonctions peuvent apparaître dans la clause
	<literal>FROM</literal>. (Cela est particulièrement utile pour les
	fonctions renvoyant des ensembles de résultats, mais n'importe quelle fonction peut
	être utilisée.) Un appel de fonction agit comme si la sortie était
	transformée en table temporaire pour la durée de cette seule commande
	<command>SELECT</command>.
<!-- J'ai l'impression qu'il y a là une imprécision dans la documentation
officielle. Il ne s'agit pas ici de sous-select, mais d'un appel de fonction.
Ce qui diffère légèrement d'un sous-select. A moins qu'un raccourci ne soit pris
pour considérer un appel de fonction comme un sous-select. SAS -->
	Un alias peut aussi être utilisé. Si un
	alias est donné, une liste d' alias de colonnes peut être ajoutée pour
	fournir des noms de substitution pour un ou plusieurs attributs du type
	composé de retour de la fonction. Si la fonction a été définie comme
	renvoyant le type de données <type>record</type>, alors un alias ou un mot
	clé <literal>AS</literal> doit être présent, suivi par une liste de définitions
	de colonnes de la forme <literal>( <replaceable
	class="parameter">nom_colonne</replaceable> <replaceable
	class="parameter">type_données</replaceable> <optional>, ... </optional>
	)</literal>. La liste de définitions de colonnes doit correspondre au
	nombre réel et aux types réels des colonnes renvoyées par la fonction.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><replaceable class="parameter">type_jointure</replaceable></term>
      <listitem>
       <para>
        Un des éléments 
        <itemizedlist>
         <listitem>
          <para><literal>[ INNER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>LEFT [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>RIGHT [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>FULL [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>CROSS JOIN</literal></para>
         </listitem>
        </itemizedlist>

        Pour les types de jointures <literal>INNER</literal> et <literal>OUTER</literal>, une
	condition de jointure doit être spécifiée, à choisir parmi
        <literal>NATURAL</literal>, <literal>ON <replaceable
        class="parameter">condition_jointure</replaceable></literal> ou
        <literal>USING (<replaceable
        class="parameter">colonne_jointure</replaceable> [, ...])</literal>.
        Voir ci-dessous pour la signification. Pour <literal>CROSS
	JOIN</literal>, aucune de ces clauses ne doit apparaître.
       </para>

       <para>
        Une clause <literal>JOIN</literal> combine deux éléments
        <literal>FROM</literal>. Les parenthèses peuvent être utilisées pour
	déterminer l'ordre d'imbrication. En l'absence de parenthèses,
	les <literal>JOIN</literal> sont imbriqués de gauche à droite. Dans
	tous les cas, <literal>JOIN</literal> est plus prioritaire que les
	virgules séparant les éléments <literal>FROM</literal>.
       </para>

       <para>
        <literal>CROSS JOIN</literal> et <literal>INNER JOIN</literal> produisent un
	simple produit cartésien. Le résultat est identique à celui obtenu 
	lorsque les deux éléments sont listés au premier niveau du <literal>FROM</literal>, mais
	restreint par la condition de jointure (si elle existe). <literal>CROSS
	JOIN</literal> est équivalent à <literal>INNER JOIN ON (TRUE)</literal>, c'est-à-dire
	qu'aucune ligne n'est supprimée par qualification. Ces types de
	jointure sont essentiellement une aide à la notation car ils ne font rien de
	plus qu'un simple <literal>FROM</literal> et <literal>WHERE</literal>.
       </para>

       <para>
        <literal>LEFT OUTER JOIN</literal> renvoie toutes les lignes du produit
	cartésien qualifié (c'est-à-dire toutes les lignes combinées qui
	satisfont la condition de jointure), plus une copie de chaque ligne
	de la table de gauche pour laquelle il n'y a pas de ligne à droite
	qui satisfasse la condition de jointure. La ligne de gauche est
	étendue à la largeur complète de la table jointe par insertion de
	valeurs NULL pour les colonnes de droite. Seule la
	condition de la clause <literal>JOIN</literal> est utilisée pour décider des
	lignes qui correspondent. Les conditions externes sont appliquées après
	coup.
       </para>

       <para>
        À l'inverse, <literal>RIGHT OUTER JOIN</literal> renvoie toutes les lignes
	jointes plus une ligne pour chaque ligne de droite sans correspondance
	(complétée par des NULL pour le côté gauche). C'est une simple aide à
	la notation car il est aisément convertible en <literal>LEFT</literal> en
	inversant les entrées gauche et droite.
       </para>

       <para>
        <literal>FULL OUTER JOIN</literal> renvoie toutes les lignes jointes, plus
	chaque ligne gauche sans correspondance (étendue par des NULL à droite),
	plus chaque ligne droite sans correspondance (étendue par des NULL à
	gauche).
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><literal>ON <replaceable class="parameter">condition_jointure</replaceable></literal></term>
      <listitem>
       <para>
        <replaceable class="parameter">condition_jointure</replaceable> 
	est une expression qui retourne une valeur de type <type>boolean</type>
	(comme une clause <literal>WHERE</literal>) qui spécifie les
	lignes d'une jointure devant correspondre.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><literal>USING (<replaceable
	class="parameter">colonne_jointure</replaceable> [,
	...])</literal></term>
      <listitem>
       <para>
        Une clause de la forme <literal>USING ( a, b, ... )</literal> est un
	raccourci pour <literal>ON table_gauche.a = table_droite.a AND table_gauche.b
	= table_droite.b ...</literal>. De plus, <literal>USING</literal> implique 
	l'affichage d'une seule paire des colonnes correspondantes dans la sortie
	de la jointure.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NATURAL</literal></term>
      <listitem>
       <para>
        <literal>NATURAL</literal> est un raccourci pour une liste
        <literal>USING</literal> qui mentionne toutes les colonnes de même nom dans les deux 
        tables.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>
   
  <refsect2 id="sql-where">
   <title id="sql-where-title">Clause <literal>WHERE</literal></title>

   <para>
    La clause <literal>WHERE</literal> optionnelle a la forme générale
<synopsis>WHERE <replaceable class="parameter">condition</replaceable>
</synopsis>
    où <replaceable class="parameter">condition</replaceable> est une 
    expression dont le résultat est de type <type>boolean</type>. Toute ligne qui ne
    satisfait pas cette condition est éliminée de la sortie. Une ligne
    satisfait la condition si elle retourne vrai quand les valeurs réelles
    de la ligne sont substituées à toute référence de variable.
   </para>
  </refsect2>
  
  <refsect2 id="sql-groupby">
   <title id="sql-groupby-title">Clause <literal>GROUP BY</literal></title>

   <para>
    La clause <literal>GROUP BY</literal> optionnelle a la forme générale
<synopsis>GROUP BY <replaceable class="parameter">expression</replaceable> [, ...]
</synopsis>
   </para>

   <para>
    <literal>GROUP BY</literal> condense en une seule ligne toutes les lignes
    sélectionnées qui partagent les mêmes valeurs pour les expressions
    regroupées. <replaceable class="parameter">expression</replaceable> peut être
    le nom d'une colonne en entrée, le nom ou le numéro d'une colonne
    en sortie (élément de la liste <command>SELECT</command>), ou une 
    expression
    quelconque formée de valeurs de colonnes en entrée. En cas
    d'ambiguïté, un nom de <literal>GROUP BY</literal> est interprété comme un nom
    de colonne en entrée, non en sortie.
   </para>

   <para>
    Les fonctions d'agrégat, si utilisées, sont calculées pour
    toutes les lignes composant un groupe, produisant une valeur séparée
    pour chaque groupe (alors que sans <literal>GROUP BY</literal>, un agrégat
    produit une valeur unique calculée pour toutes les lignes
    sélectionnées). Quand <literal>GROUP BY</literal> est présent, 
    les expressions du <command>SELECT</command> ne peuvent faire
    référence qu'à des colonnes groupées, sauf à l'intérieur de fonctions
    d'agrégat, ou bien si la colonne non groupée dépend fonctionnellement des colonnes groupées.
    En effet, s'il en était autrement, il y aurait plus d'une valeur possible pour la colonne non groupée.
    Une dépendance fonctionnelle existe si les colonnes groupées (ou un sous-ensemble de ces dernières) sont la clé primaire de la
    table contenant les colonnes non groupées.
   </para>
  </refsect2>

  <refsect2 id="sql-having">
   <title id="sql-having-title">Clause <literal>HAVING</literal></title>

   <para>
    La clause optionnelle <literal>HAVING</literal> a la forme générale
<synopsis>HAVING <replaceable class="parameter">condition</replaceable>
</synopsis>
    où <replaceable class="parameter">condition</replaceable> est identique à
    celle spécifiée pour la clause <literal>WHERE</literal>.
   </para>
    
   <para>
    <literal>HAVING</literal> élimine les lignes groupées qui ne satisfont
    pas à la condition. <literal>HAVING</literal> est différent de
    <literal>WHERE</literal>&nbsp;: <literal>WHERE</literal> filtre les lignes
    individuelles avant l'application de <literal>GROUP BY</literal> alors que
    <literal>HAVING</literal> filtre les lignes groupées créées par
    <literal>GROUP BY</literal>. Chaque colonne référencée dans <replaceable
    class="parameter">condition</replaceable> doit faire référence sans ambiguïté 
    à une colonne groupée, sauf si la référence apparaît dans une fonction
    d'agrégat.
   </para>
    
   <para>
    Même en l'absence de clause <literal>GROUP BY</literal>, la présence de
    <literal>HAVING</literal> transforme une requête en requête groupée.
    Cela correspond au comportement d'une requête contenant des fonctions
    d'agrégats mais pas de clause <literal>GROUP BY</literal>. Les lignes 
    sélectionnées ne forment qu'un groupe, la liste du <command>SELECT</command>
    et la clause <literal>HAVING</literal> ne peuvent donc faire référence
    qu'à des colonnes à l'intérieur de fonctions d'agrégats. Une telle
    requête ne produira qu'une seule ligne si la condition <literal>HAVING</literal>
    est réalisée, aucune dans le cas contraire.
   </para>
  </refsect2>

  <refsect2 id="sql-window">
   <title id="sql-window-title">Clause <literal>WINDOW</literal></title>

   <para>
    La clause optionnelle <literal>WINDOW</literal> a la forme générale
<synopsis>
WINDOW <replaceable class="parameter">nom_window</replaceable> AS ( <replaceable class="parameter">définition_window</replaceable> ) [, ...]
</synopsis>
    où <replaceable class="parameter">nom_window</replaceable> est un nom qui
    peut être référencé par des définitions Window ou des clauses
    <literal>OVER</literal>, et
    <replaceable class="parameter">définition_window</replaceable>
    est
<synopsis>
[ <replaceable class="parameter">nom_window_existante</replaceable> ]
[ PARTITION BY <replaceable class="parameter">expression</replaceable> [, ...] ]
[ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operateur</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <replaceable class="parameter">clause_frame</replaceable> ]
</synopsis>
   </para>

   <para>
    Si un <replaceable class="parameter">nom_window_existante</replaceable> est
    spécifié, il doit se référer à une entrée précédente dans la liste
    <literal>WINDOW</literal>&nbsp;; la nouvelle Window copie sa clause de
    partitionnement de cette entrée, ainsi que sa clause de tri s'il y en a.
    Dans ce cas, la nouvelle Window ne peut pas spécifier sa propre clause
    <literal>PARTITION BY</literal>, et ne peut spécifier de
    <literal>ORDER BY</literal> que si la Window copiée n'en a pas.
    La nouvelle Window utilise toujours sa propre clause frame&nbsp;; la Window
    copiée ne doit pas posséder de clause frame.
   </para>

   <para>
    Les éléments de la liste <literal>PARTITION BY</literal> sont interprétés
    à peu près de la même façon que des éléments de <xref linkend="sql-groupby"
   />, sauf qu'ils sont toujours des expressions
    simples et jamais le nom ou le numéro d'une colonne en sortie.
    Une autre différence est que ces expressions peuvent contenir des appels
    à des fonctions d' agrégat, ce qui n'est pas autorisé dans une clause
    <literal>GROUP BY</literal> classique. Ceci est autorisé ici parce que
    le windowing se produit après le regroupement et l' agrégation.
   </para>

   <para>
    De façon similaire, les éléments de la liste <literal>ORDER BY</literal>
    sont interprétés à peu près de la même façon que les éléments d'un <xref
    linkend="sql-orderby"/>, sauf que les expressions
    sont toujours prises comme de simples expressions et jamais comme le nom ou
    le numéro d'une colonne en sortie.
   </para>

   <para>
    La clause <replaceable class="parameter">clause_frame</replaceable>
    optionnelle définit la <firstterm>frame window</firstterm> pour les
    fonctions window qui dépendent de la frame (ce n'est pas le cas de toutes).
    La frame window est un ensemble de lignes liées à chaque ligne de la requête (appelée la <firstterm>ligne courante</firstterm>).
    La <replaceable class="parameter">clause_frame</replaceable> peut être une des clauses suivantes&nbsp;:
    

<synopsis>
[ RANGE | ROWS ] <replaceable>début_frame</replaceable>
[ RANGE | ROWS ] BETWEEN <replaceable>début_frame</replaceable> AND <replaceable>fin_frame</replaceable>
</synopsis>

    où <replaceable>début_frame</replaceable> et <replaceable>fin_frame</replaceable> peuvent valoir

<synopsis>
UNBOUNDED PRECEDING
<replaceable>valeur</replaceable> PRECEDING
CURRENT ROW
<replaceable>valeur</replaceable> FOLLOWING
UNBOUNDED FOLLOWING
</synopsis>

    Si <replaceable>fin_frame</replaceable> n'est pas précisé, il vaut par défaut <literal>CURRENT
    ROW</literal>.  Les restrictions sont les suivantes&nbsp;: 
    <replaceable>début_frame</replaceable> ne peut pas valoir <literal>UNBOUNDED FOLLOWING</literal>,
    <replaceable>fin_frame</replaceable> ne peut pas valoir <literal>UNBOUNDED PRECEDING</literal>,
    et le choix <replaceable>fin_frame</replaceable> ne peut apparaître avant le choix 
    <replaceable>début_frame</replaceable>  &mdash; par exemple
    <literal>RANGE BETWEEN CURRENT ROW AND <replaceable>valeur</replaceable>
    PRECEDING</literal> n'est pas permis.
   </para>

   <para>
    L'option par défaut pour la clause frame est <literal>RANGE UNBOUNDED PRECEDING</literal>,
    ce qui revient au même que <literal>RANGE BETWEEN UNBOUNDED PRECEDING AND
    CURRENT ROW</literal>&nbsp;; il positionne la frame pour qu'il couvre toutes les lignes à partir du début de la partition
    jusqu'à la dernière ligne à égalité avec la ligne courante dans l'ordre défini par l' <literal>ORDER BY</literal>
     (ce qui signifie toutes les lignes s'il n'y a pas d' <literal>ORDER BY</literal>).
    Généralement, <literal>UNBOUNDED PRECEDING</literal> signifie que la frame commence
    à la première ligne de la partition, et de même 
    <literal>UNBOUNDED FOLLOWING</literal> signifie que la frame se termine avec la dernière ligne 
    de la partition (quel que soit le mode, <literal>RANGE</literal> ou bien <literal>ROWS</literal>
    ).  Dans le mode <literal>ROWS</literal>, <literal>CURRENT ROW</literal>
    signifie que la frame commence ou se termine sur la ligne courante &nbsp;; mais
    dans le mode <literal>RANGE</literal> cela signifie que la frame débute ou se termine
    sur la première ou la dernière des lignes à égalité avec la ligne courante 
    dans l'ordre de la clause <literal>ORDER BY</literal>.
    Les <replaceable>valeur</replaceable> <literal>PRECEDING</literal> et 
    <replaceable>valeur</replaceable> <literal>FOLLOWING</literal> sont actuellement seulement
    permis en mode <literal>ROWS</literal>.  Ils indiquent que la frame débute ou se termine
    autant de lignes avant ou après la ligne courante.
    <replaceable>valeur</replaceable> doit être une expression entière,
    ne contenant aucune variable, fonction d' agrégat ni fonction window.
    La valeur ne doit être ni null ni négative &nbsp;; mais elle peut être de zéro, ce qui sélectionne
    la ligne courante elle-même.
   </para>

   <para>
    Attention, les options <literal>ROWS</literal> peuvent produire des résultats imprévisibles
    si l'ordre défini par l' <literal>ORDER BY</literal> n'ordonne pas les lignes de 
    manière unique. Les options <literal>RANGE</literal> sont conçues pour s'assurer que
    les lignes qui sont à égalité suivant l'ordre de l' <literal>ORDER BY</literal> sont traitées 
    de la même manière &nbsp;; toutes les lignes à égalité
    seront ensemble dans la frame ou ensemble hors de la frame.
   </para>

   <para>
    L'utilité d'une clause <literal>WINDOW</literal> est de spécifier le
    comportement des <firstterm>fonctions window</firstterm> apparaissant dans
    la clause <xref linkend="sql-select-list"/>
    ou la clause <xref linkend="sql-orderby"/> de
    la requête. Ces fonctions peuvent référencer les entrées de clauses
    <literal>WINDOW</literal> par nom dans leurs clauses <literal>OVER</literal>.
    Toutefois, il n'est pas obligatoire qu'une entrée de clause
    <literal>WINDOW</literal> soit référencée quelque part&nbsp;; si elle n'est
    pas utilisée dans la requête, elle est simplement ignorée. Il est possible
    d'utiliser des fonctions window sans aucune clause <literal>WINDOW</literal>
    puisqu'une fonction window peut spécifier sa propre définition de window
    directement dans sa clause <literal>OVER</literal>. Toutefois, la clause
    <literal>WINDOW</literal> économise de la saisie quand la même définition
    window est utilisée pour plus d'une fonction window.
   </para>

   <para>
    Les fonctions window sont décrites en détail dans
    <xref linkend="tutorial-window"/>,
    <xref linkend="syntax-window-functions"/> et
    <xref linkend="queries-window"/>.
   </para>
  </refsect2>

  <refsect2 id="sql-select-list">
   <title id="sql-select-list-title">Liste <command>SELECT</command></title>

   <para>
    La liste <command>SELECT</command> (entre les mots clés
    <literal>SELECT</literal> et <literal>FROM</literal>) spécifie les
    expressions qui forment les lignes en sortie de l'instruction
    <command>SELECT</command>. Il se peut que les expressions fassent référence
    aux colonnes traitées dans la clause <literal>FROM</literal>. En fait, en
    général, elles le font.
   </para>

   <para>
    Comme pour une table, chaque colonne de sortie d'un <command>SELECT</command>
    a un nom. Dans un <command>SELECT</command> simple, ce nom est juste
    utilisé pour donner un titre à la colonne pour l'affichage, mais quand le
    <command>SELECT</command> est une sous-requête d'une requête plus grande,
    le nom est vu par la grande requête comme le nom de colonne de la table
    virtuelle produite par la sous-requête.
    Pour indiquer le nom à utiliser pour une colonne de sortie, écrivez
    <literal>AS</literal> <replaceable class="parameter">nom_de_sortie</replaceable>
    après l'expression de la colonne. (Vous pouvez omettre <literal>AS</literal>
    seulement si le nom de colonne souhaité n'est pas un mot clé réservé par
    <productname>PostgreSQL</productname> (voir <xref
    linkend="sql-keywords-appendix"/>). Pour vous protéger contre l'ajout futur
    d'un mot clé, il est recommandé que vous écriviez toujours
    <literal>AS</literal> ou que vous mettiez le nom de sortie entre guillemets.
    Si vous n'indiquez pas de nom de colonne, un nom est choisi automatiquement
    par <productname>PostgreSQL</productname>. Si l'expression de la colonne
    est une simple référence à une colonne alors le nom choisi est le même que
    le nom de la colonne.  In more complex cases a function or type name may be
    used, or the system may fall back on a generated name such as
    <literal>?column?</literal>.
   </para>

   <para>
    Un nom de colonne de sortie peut être utilisé pour se référer à la valeur de
    la colonne dans les clauses <literal>ORDER BY</literal> et
    <literal>GROUP BY</literal>, mais pas dans la clause<literal>WHERE</literal>
    ou <literal>HAVING</literal>&nbsp;; à cet endroit, vous devez écrire
    l'expression.
   </para>

   <para>
    <literal>*</literal> peut être utilisé, à la place d'une expression, dans la
    liste de sortie comme raccourci pour toutes les colonnes des lignes
    sélectionnées. De plus, 
    <literal><replaceable class="parameter">nom_table</replaceable>.*</literal>
    peut être écrit comme raccourci pour toutes les colonnes de cette table. Dans
    ces cas, il est impossible de spécifier de nouveaux noms avec
    <literal>AS</literal>&nbsp;;
    les noms des colonnes de sorties seront les même que ceux de la table.
   </para>
  </refsect2>

  <refsect2 id="sql-distinct">
   <title id="sql-distinct-title"><literal>DISTINCT</literal> Clause</title>

   <para>
         Si <literal>SELECT DISTINCT</literal> est spécifié, toutes les lignes en double sont
	 supprimées de l'ensemble de résultats (une ligne est conservée pour chaque groupe
	 de doublons).   <literal>SELECT ALL</literal> spécifie le contraire : toutes les lignes sont
	 conservées. C'est l'option par défaut.
   </para>

   <para>
    <literal>SELECT DISTINCT ON ( <replaceable
    class="parameter">expression</replaceable> [, ...] )</literal>
    conserve seulement la première ligne de chaque ensemble de lignes pour lesquelles le résultat
    de l'expression est identique. Les expressions <literal>DISTINCT ON</literal>
    expressions sont interprétées avec les mêmes règles que pour 
    <literal>ORDER BY</literal> (voir ci-dessous).  Notez que la <quote>première ligne</quote> 
    de chaque ensemble est imprévisible, à moins que la clause <literal>ORDER
    BY</literal> ne soit utilisée, assurant ainsi que la ligne souhaitée apparaisse en premier. Par exemple :
<programlisting>
SELECT DISTINCT ON (lieu) lieu, heure, rapport
    FROM rapport_météo
    ORDER BY lieu, heure DESC;
</programlisting>
    renvoie le rapport météo le plus récent de chaque endroit. Mais
    si nous n'avions pas utilisé <literal>ORDER BY</literal> afin de forcer le tri du temps dans le sens descendant
    des temps pour chaque endroit, nous aurions récupéré, pour chaque lieu, n'importe quel bulletin de ce lieu.
   </para>

   <para>
    La (ou les ) expression(s) <literal>DISTINCT ON</literal> doivent correspondre à l'expression (ou aux expressions)
    <literal>ORDER BY</literal> la(les) plus à gauche.  La clause <literal>ORDER BY</literal>  contient habituellement des 
    expressions supplémentaires qui déterminent l'ordre des lignes au sein de chaque groupe <literal>DISTINCT ON</literal>.
   </para>
  </refsect2>

  <refsect2 id="sql-union">
   <title id="sql-union-title">Clause <literal>UNION</literal></title>

   <para>
    La clause <literal>UNION</literal> a la forme générale&nbsp;:
<synopsis><replaceable class="parameter">instruction_select</replaceable> UNION [ ALL | DISTINCT ] <replaceable class="parameter">instruction_select</replaceable>
</synopsis>
    <replaceable class="parameter">instruction_select</replaceable> est une
    instruction <command>SELECT</command> sans clause <literal>ORDER BY</literal>,
    <literal>LIMIT</literal>, <literal>FOR SHARE</literal> ou <literal>FOR
    UPDATE</literal>. (<literal>ORDER BY</literal> et
    <literal>LIMIT</literal> peuvent être attachés à une sous-expression si elle est
    entourée de parenthèses. Sans parenthèses, ces clauses s'appliquent
    au résultat de l'<literal>UNION</literal>, non à l'expression à sa droite.)
   </para>
    
   <para>
    L'opérateur <literal>UNION</literal> calcule l'union ensembliste des
    lignes renvoyées par les instructions <command>SELECT</command> impliquées.
    Une ligne est dans l'union de deux ensembles de résultats si elle apparaît
    dans au moins un des ensembles. Les deux instructions
    <command>SELECT</command> qui représentent les opérandes directes de
    l'<literal>UNION</literal> doivent produire le même nombre de colonnes et
    les colonnes correspondantes doivent être d'un type de données compatible.
   </para>
    
   <para>
    Sauf lorsque l'option <literal>ALL</literal> est spécifiée, il n'y a pas
    de doublons dans le résultat de <literal>UNION</literal>. <literal>ALL</literal>
    empêche l'élimination des lignes dupliquées. <literal>UNION
    ALL</literal> est donc significativement plus rapide qu'<literal>UNION</literal>, 
    et sera préféré. <literal>DISTINCT</literal> peut éventuellement être ajouté pour préciser explicitement
    le comportement par défaut : l'élimination des lignes en double.
   </para>
    
   <para>
    Si une instruction
    <command>SELECT</command> contient plusieurs opérateurs <literal>UNION</literal>,
    ils sont évalués de gauche à droite, sauf si l'utilisation de parenthèses
    impose un comportement différent.
   </para>
    
   <para>
    Actuellement, <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal> ne peuvent
    pas être spécifiés pour un résultat d'<literal>UNION</literal> ou pour toute entrée
    d'un <literal>UNION</literal>.
   </para>
  </refsect2>

  <refsect2 id="sql-intersect">
   <title id="sql-intersect-title">Clause <literal>INTERSECT</literal></title>

   <para>
    La clause <literal>INTERSECT</literal> a la forme générale&nbsp;:
<synopsis><replaceable class="parameter">instruction_select</replaceable> INTERSECT [ ALL | DISTINCT ] <replaceable class="parameter">instruction_select</replaceable>
</synopsis>
    <replaceable class="parameter">instruction_select</replaceable> est une
    instruction <command>SELECT</command> sans clause <literal>ORDER BY</literal>,
    <literal>LIMIT</literal>, <literal>FOR UPDATE</literal> ou <literal>FOR SHARE</literal>.
   </para>

   <para>
    L'opérateur <literal>INTERSECT</literal> calcule l'intersection des lignes
    renvoyées par les instructions <command>SELECT</command> impliquées. Une
    ligne est dans l'intersection des deux ensembles de résultats si elle
    apparaît dans chacun des deux ensembles.
   </para>
    
   <para>
    Le résultat d'<literal>INTERSECT</literal> ne contient aucune ligne
    dupliquée sauf si l'option <literal>ALL</literal> est spécifiée. Dans ce cas,
    une ligne dupliquée <replaceable>m</replaceable> fois dans
    la table gauche et <replaceable>n</replaceable> fois dans la table droite
    apparaît min(<replaceable>m</replaceable>,<replaceable>n</replaceable>) fois dans
    l'ensemble de résultats.
    <literal>DISTINCT</literal> peut éventuellement être ajouté pour préciser explicitement
    le comportement par défaut : l'élimination des lignes en double.
   </para>
    
   <para>
    Si une instruction
    <command>SELECT</command> contient plusieurs opérateurs <literal>INTERSECT</literal>,
    ils sont évalués de gauche à droite, sauf si l'utilisation de parenthèses
    impose un comportement différent. <literal>INTERSECT</literal> a une 
    priorité supérieur à celle d'<literal>UNION</literal>. C'est-à-dire que <literal>A 
    UNION B INTERSECT C</literal> est lu comme <literal>A UNION (B INTERSECT
    C)</literal>.
   </para>

   <para>
    Actuellement, <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal> ne peuvent 
    pas être spécifiés pour un résultat d'<literal>INTERSECT</literal> ou pour une
    entrée d'<literal>INTERSECT</literal>.
   </para>
  </refsect2>

  <refsect2 id="sql-except">
   <title id="sql-except-title">Clause <literal>EXCEPT</literal></title>

   <para>
    La clause <literal>EXCEPT</literal> a la forme générale&nbsp;:
<synopsis><replaceable class="parameter">instruction_select</replaceable> EXCEPT [ ALL | DISTINCT ] <replaceable class="parameter">instruction_select</replaceable>
</synopsis>
    <replaceable class="parameter">instruction_select</replaceable> est une
    instruction <command>SELECT</command> sans clause <literal>ORDER
    BY</literal>, <literal>LIMIT</literal>, <literal>FOR UPDATE</literal> ou
    <literal>FOR SHARE</literal>.
   </para>

   <para>
    L'opérateur <literal>EXCEPT</literal> calcule l'ensemble de lignes qui appartiennent
    au résultat de l'instruction <command>SELECT</command> de gauche mais
    pas à celui de droite.
   </para>
    
   <para>
    Le résultat d'<literal>EXCEPT</literal> ne contient aucune ligne
    dupliquée sauf si l'option <literal>ALL</literal> est spécifiée. Dans ce cas,
    une ligne dupliquée <replaceable>m</replaceable> fois dans
    la table gauche et <replaceable>n</replaceable> fois dans la table droite
    apparaît max(<replaceable>m</replaceable>-<replaceable>n</replaceable>,0) fois dans
    l'ensemble de résultats.
    <literal>DISTINCT</literal> peut éventuellement être ajouté pour préciser explicitement
    le comportement par défaut : l'élimination des lignes en double.
   </para>
    
   <para>
    Si une instruction
    <command>SELECT</command> contient plusieurs opérateurs <literal>EXCEPT</literal>,
    ils sont évalués de gauche à droite, sauf si l'utilisation de parenthèses
    impose un comportement différent. <literal>EXCEPT</literal> a la même priorité
    qu'<literal>UNION</literal>.
   </para>

   <para>
    Actuellement, <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal> ne peuvent 
    pas être spécifiés dans un résultat <literal>EXCEPT</literal> ou pour une entrée
    d'un <literal>EXCEPT</literal>.
   </para>
  </refsect2>

  <refsect2 id="sql-orderby">
   <title id="sql-orderby-title">Clause <literal>ORDER BY</literal></title>

   <para>
    La clause optionnelle <literal>ORDER BY</literal> a la forme
    générale&nbsp;:
 <synopsis>ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">opérateur</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...]
</synopsis>
    La clause <literal>ORDER BY</literal> impose le tri des lignes de résultat 
    suivant les expressions spécifiées. Si deux lignes sont
    identiques suivant l'expression la plus à gauche, elles sont comparées avec
    l'expression suivante et ainsi de suite. Si elles sont identiques pour
    toutes les expressions de tri, elles sont renvoyées dans un ordre
    dépendant de l'implantation.
   </para>

   <para>
    Chaque <replaceable class="parameter">expression</replaceable> peut être le
    nom ou le numéro ordinal d'une colonne en sortie (élément de la liste
    <command>SELECT</command>). Elle peut aussi être une expression arbitraire
    formée à partir de valeurs des colonnes.
   </para>

   <para>
    Le numéro ordinal fait référence à la position ordinale (de gauche à 
    droite) de la colonne de résultat. Cette fonctionnalité permet de définir un ordre
    sur la base d'une colonne dont le nom n'est pas unique. Ce n'est 
    pas particulièrement nécessaire parce qu'il est toujours possible d'affecter un nom à
    une colonne de résultat avec la clause <literal>AS</literal>.
   </para>
    
   <para>
    Il est aussi possible d'utiliser des expressions quelconques dans la clause
    <literal>ORDER BY</literal>, ce qui inclut des colonnes qui n'apparaissent pas
    dans la liste résultat du <command>SELECT</command>. Ainsi,
    l'instruction suivante est valide&nbsp;:
<programlisting>SELECT nom FROM distributeurs ORDER BY code;
</programlisting>
    Il y a toutefois une limitation à cette fonctionnalité. La clause
    <literal>ORDER BY</literal> qui s'applique au résultat d'une clause <literal>UNION</literal>,
    <literal>INTERSECT</literal> ou <literal>EXCEPT</literal> ne peut spécifier
    qu'un nom ou numéro de colonne en sortie, pas une expression.
   </para>
    
   <para>
    Si une expression <literal>ORDER BY</literal> est un nom qui correspond à
    la fois à celui d'une colonne résultat et à celui d'une colonne en entrée,
    <literal>ORDER BY</literal> l'interprète comme le nom de la colonne résultat.
    Ce comportement est à l'opposé de celui de <literal>GROUP BY</literal> dans la même
    situation. Cette incohérence est imposée par la compatibilité avec le
    standard SQL.
   </para>
    
   <para>
    Un mot clé <literal>ASC</literal> (ascendant) ou <literal>DESC</literal> (descendant) 
    peut être ajouté après toute expression de la
    clause <literal>ORDER BY</literal>. <literal>ASC</literal> est la valeur utilisée par défaut.
    Un nom d'opérateur d'ordre spécifique
    peut également être fourni dans la clause <literal>USING</literal>.
    Un opérateur de tri doit être un membre plus-petit-que ou plus-grand-que de
    certaines familles d'opérateur B-tree.
    <literal>ASC</literal> est
    habituellement équivalent à <literal>USING &lt;</literal> et <literal>DESC</literal>
    à <literal>USING &gt;</literal>. Le créateur d'un
    type de données utilisateur peut définir à sa guise le tri par
    défaut qui peut alors correspondre à des opérateurs de nom différent.
   </para>

   <para>
    Si <literal>NULLS LAST</literal> est indiqué, les valeurs NULL sont listées
    après toutes les valeurs non NULL&nbsp; si <literal>NULLS FIRST</literal>
    est indiqué, les valeurs NULL apparaissent avant toutes les valeurs non
    NULL. Si aucune des deux n'est présente, le comportement par défaut est
    <literal>NULLS LAST</literal> quand <literal>ASC</literal> est utilisé
    (de façon explicite ou non) et <literal>NULLS FIRST</literal> quand
    <literal>DESC</literal> est utilisé (donc la valeur par défaut est d'agir
    comme si les NULL étaient plus grands que les non NULL). Quand
    <literal>USING</literal> est indiqué, le tri des NULL par défaut dépend
    du fait que l'opérateur est un plus-petit-que ou un plus-grand-que.
   </para>

   <para>
    Notez que les options de tri s'appliquent seulement à l'expression qu'elles
    suivent. Par exemple, <literal>ORDER BY x, y DESC</literal> ne signifie pas
    la même chose que <literal>ORDER BY x DESC, y DESC</literal>.
   </para>

   <para>
	Les chaînes de caractères sont triées suivant le collationnement qui
	s'applique à la colonne triée. Ce collationnement est surchargeable
	si nécessaire en ajoutant une clause <literal>COLLATE</literal> dans
	l'<replaceable class="parameter">expression</replaceable>, par
	exemple <literal>ORDER BY mycolumn COLLATE "en_US"</literal>.
    Pour plus d'informations, voir <xref linkend="sql-syntax-collate-exprs"/>
    et <xref linkend="collation"/>.
   </para>
  </refsect2>

 <refsect2 id="sql-limit">
   <title id="sql-limit-title">Clause <literal>LIMIT</literal></title>

   <para>
    La clause <literal>LIMIT</literal> est constituée de deux sous-clauses
    indépendantes&nbsp;:
<synopsis>LIMIT { <replaceable class="parameter">nombre</replaceable> | ALL }
OFFSET <replaceable class="parameter">début</replaceable>
</synopsis>
    <replaceable class="parameter">nombre</replaceable> spécifie le nombre
    maximum de lignes à renvoyer alors que <replaceable
    class="parameter">début</replaceable> spécifie le nombre de lignes à passer
    avant de commencer à renvoyer des lignes. Lorsque les deux clauses sont spécifiées,
    <replaceable class="parameter">début</replaceable> lignes sont passées 
    avant de commencer à compter les <replaceable
    class="parameter">nombre</replaceable> lignes à renvoyer.
   </para>

   <para>
    Si l'expression de <replaceable class="parameter">compte</replaceable>
    est évaluée à NULL, il est traité comme <literal>LIMIT ALL</literal>,
    c'est-à-dire sans limite. Si <replaceable class="parameter">début</replaceable>
    est évalué à NULL, il est traité comme <literal>OFFSET 0</literal>.
   </para>

   <para>
    SQL:2008 a introduit une sytaxe différente pour obtenir le même résultat.
    <productname>PostgreSQL</productname> supporte aussi cette syntaxe.
<synopsis>
OFFSET <replaceable class="parameter">début</replaceable> { ROW | ROWS }
FETCH { FIRST | NEXT } [ <replaceable class="parameter">compte</replaceable> ] { ROW | ROWS } ONLY
</synopsis>
    Avec cette syntaxe, pour écrire tout sauf une simple constant de type
    entier pour <replaceable class="parameter">début</replaceable> ou
    <replaceable class="parameter">compte</replaceable>, vous devez
    l'entourer de parenthèses.
    Si <replaceable class="parameter">compte</replaceable> est omis dans une clause
    <literal>FETCH</literal>, il vaut 1 par défaut.
    <literal>ROW</literal> et <literal>ROWS</literal> ainsi que <literal>FIRST</literal>
    et <literal>NEXT</literal> sont des mots qui n'influencent pas les
    effets de ces clauses.
    D'après le standard, la clause <literal>OFFSET</literal> doit venir
    avant la clause <literal>FETCH</literal> si les deux sont
    présentes&nbsp;; <productname>PostgreSQL</productname> est plus  laxiste et
    autorise un ordre différent.
   </para>

   <para>
    Avec <literal>LIMIT</literal>, utiliser la clause
    <literal>ORDER BY</literal> permet de contraindre l'ordre des lignes de
    résultat. Dans le cas contraire, le sous-ensemble obtenu n'est pas prévisible &mdash;
    rien ne permet de savoir à quel ordre correspondent les lignes retournées. 
    Celui-ci ne sera pas connu tant qu'<literal>ORDER BY</literal> n'aura pas été précisé.
   </para>

   <para>
    Lors de la génération d'un plan de requête, le planificateur tient compte
    de <literal>LIMIT</literal>. Le risque est donc grand d'obtenir des plans
    qui diffèrent (ordres des lignes différents) suivant les valeurs
    utilisées pour <literal>LIMIT</literal> et <literal>OFFSET</literal>. Ainsi, sélectionner
    des sous-ensembles différents d'un résultat à partir de valeurs différentes
    de <literal>LIMIT</literal>/<literal>OFFSET</literal> <emphasis>aboutit à des résultats
    incohérents</emphasis> à moins d'avoir figé l'ordre des lignes à l'aide
    de la clause <literal>ORDER BY</literal>. Ce n'est pas un bogue, mais une conséquence
    du fait que SQL n'assure pas l'ordre de présentation des résultats sans
    utilisation d'une clause <literal>ORDER BY</literal>.
   </para>

   <para>
    Il est même possible pour des exécutions répétées de la même requête
    <literal>LIMIT</literal> de renvoyer différents sous-ensembles des lignes
    d'une table s'il n'y a pas de clause <literal>ORDER BY</literal> pour forcer
    la sélection d'un sous-ensemble déterministe. Encore une fois, ce n'est pas
    un bogue&nbsp;; le déterminisme des résultats n'est tout simplement pas
    garanti dans un tel cas.
   </para>
  </refsect2>

  <refsect2 id="sql-for-update-share">
   <title id="sql-for-update-share-title">Clause <literal>FOR UPDATE</literal>/<literal>FOR SHARE</literal></title>

   <para>
    La clause <literal>FOR UPDATE</literal> a la forme&nbsp;:
<synopsis>FOR UPDATE [ OF <replaceable class="parameter">nom_table</replaceable> [, ...] ] [ NOWAIT ]
</synopsis>
   </para>

   <para>
    La clause liée, <literal>FOR SHARE</literal>, a la forme&nbsp;:
<synopsis>FOR SHARE [ OF <replaceable class="parameter">nom_table</replaceable> [, ...] ] [ NOWAIT ]
</synopsis>
   </para>


   <para>
    <literal>FOR UPDATE</literal> verrouille pour modification les lignes récupérées par
    l'instruction <command>SELECT</command>.
    Cela les empêche d'être modifiées ou supprimées par les autres transactions
    jusqu'à la fin de la transaction en cours. Les autres
    transactions qui tentent des <command>UPDATE</command>,
    <command>DELETE</command> ou <command>SELECT FOR UPDATE</command> sur ces
    lignes sont bloquées jusqu'à la fin de la transaction courante. De
    plus, si un <command>UPDATE</command>, <command>DELETE</command> ou
    <command>SELECT FOR UPDATE</command> a
    déjà verrouillé une ligne ou un ensemble de lignes à partir d'une autre transaction,
    <command>SELECT FOR UPDATE</command> attend la fin de l'autre transaction puis verrouille et
    renvoie la ligne modifiée (ou aucune ligne si elle a été supprimée).
    Cependant, au sein d'une transaction <literal>REPEATABLE READ</literal> ou <literal>SERIALIZABLE</literal>,
    une erreur est levée si une ligne à verrouiller à changé depuis le début de la
    transaction. Pour
    plus d'informations, voir <xref linkend="mvcc"/>.
   </para>

   <para>
    <literal>FOR SHARE</literal> a un comportement similaire. La différence
    se situe dans le type de verrou acquis. Contrairement à 
    <literal>FOR UPDATE</literal> qui pose un verrou exclusif,
    <literal>FOR SHARE</literal> pose un verrou partagé sur chaque ligne récupérée.
    Un verrou partagée bloque les instructions <command>UPDATE</command>,
    <command>DELETE</command> ou <command>SELECT FOR UPDATE</command>
    des transaction concurrentes accédant à ces lignes, mais il n'interdit
    pas les <command>SELECT FOR SHARE</command>.
   </para>

   <para>
    Pour éviter à l'opération d'attendre la validation des autres transactions,
    on utilise l'option <literal>NOWAIT</literal>. <command>SELECT FOR UPDATE
    NOWAIT</command> rapporte une erreur si une ligne
    sélectionnée ne peut pas être verrouillée immédiatement. Il n'y a pas 
    d'attente.
    <literal>NOWAIT</literal> s'applique seulement au(x) verrou(x) niveau ligne
    &mdash; le verrou niveau table <literal>ROW SHARE</literal> est toujours
    pris de façon ordinaire (voir <xref linkend="mvcc"/>). 
    L'option <literal>NOWAIT</literal> de <xref linkend="sql-lock"/>
    peut toujours être utilisée pour acquérir le verrou niveau table sans attendre.
   </para>

   <para>
    Si des tables particulières sont nommées dans les clauses <literal>FOR UPDATE</literal>
    et <literal>FOR SHARE</literal>, alors seules les lignes provenant de ces
    tables sont verrouillées&nbsp;; toute autre table utilisée dans le
    <command>SELECT</command> est simplement lue. Une clause
    <literal>FOR UPDATE</literal> ou <literal>FOR SHARE</literal> sans liste de
    tables affecte toute les tables utilisées dans l'instruction. Si
    <literal>FOR UPDATE</literal> ou <literal>FOR SHARE</literal> est appliquée
    à une vue ou à une sous-requête, cela affecte toutes les tables utilisées
    dans la vue ou la sous-requête.
    Néanmoins, <literal>FOR UPDATE</literal>/<literal>FOR SHARE</literal>
    ne s'appliquent pas aux requêtes <literal>WITH</literal> référencées par la
    clé primaire. Si vous voulez qu'un verrouillage de lignes intervienne dans
    une requête <literal>WITH</literal>, spécifiez <literal>FOR UPDATE</literal>
    ou <literal>FOR SHARE</literal> à l'intérieur de la requête
    <literal>WITH</literal>.
   </para>

   <para>
    Plusieurs clauses <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal>
    peuvent être données si il est nécessaire de spécifier différents
    comportements de verrouillage pour différentes tables. Si la même table
    est mentionné (ou affectée implicitement) par les clauses
    <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal>, alors elle
    est traitée comme un simple <literal>FOR UPDATE</literal>. De façon similaire,
    une table est traitée avec <literal>NOWAIT</literal> si c'est spécifiée sur
    au moins une des clauses qui l'affectent.
   </para>

   <para>
    <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal> nécessitent
    que chaque ligne retournée soit clairement identifiable par une ligne
    individuelle d'une table&nbsp;; ces options ne peuvent, par exemple, pas être
    utilisées avec des fonctions d'agrégats.
   </para>

   <para>
    Quand <literal>FOR UPDATE</literal> ou <literal>FOR SHARE</literal>
    apparaissent au niveau le plus élevé d'une requête <command>SELECT</command>, les lignes
    verrouillées sont exactement celles qui sont renvoyées par la requête&nbsp;; dans le 
    cas d'une requête avec jointure, les lignes verrouillées sont celles qui contribuent
    aux lignes jointes renvoyées. De plus, les lignes qui 
    De plus, les lignes qui ont satisfait aux conditions de la requête au moment de la prise de son instantané
    sont verrouillées, bien qu'elles ne seront pas retournées si elles ont été modifiées après la prise du
    snapshot et ne satisfont plus les conditions de la requête.  Si <literal>LIMIT</literal> 
    est utilisé, le verrouillage cesse une fois que suffisamment de lignes ont été renvoyées 
    pour satisfaire la limite (mais notez que les lignes ignorées à cause de la clause
     <literal>OFFSET</literal> seront verrouillées).  De la même manière,
    si <literal>FOR UPDATE</literal> ou <literal>FOR SHARE</literal>
    est utilisé pour la requête d'un curseur, seules les lignes réellement récupérées ou parcourues par le curseur 
    seront verrouillées.
   </para>

   <para>
    Si <literal>FOR UPDATE</literal> ou <literal>FOR SHARE</literal>
    apparaissent dans un sous-<command>SELECT</command>, les lignes verrouillées sont celles
    renvoyées par la sous-requête à la requête externe. Cela peut concerner
    moins de lignes que l'étude de la sous-requête seule pourrait faire penser,
    parce que les conditions de la requête externe peuvent être utilisées 
    pour optimiser l'exécution de la sous-requête. Par exemple, 
<programlisting>
SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;
</programlisting>
    verrouillera uniquement le lignes pour lesquelles <literal>col1 = 5</literal>, 
    même si cette condition n'est pas écrite dans la sous-requête.
   </para>

  <caution>
   <para>
    Évitez de verrouiller une ligne puis de la modifier après un nouveau point
    de sauvegarde ou après un bloc d'exception <application>PL/pgSQL</application>.
    L'annulation suivante pourrait causer la perte du verrou. Par exemple&nbsp;:
<programlisting>
BEGIN;
SELECT * FROM ma_table WHERE cle = 1 FOR UPDATE;
SAVEPOINT s;
UPDATE ma_table SET ... WHERE cle = 1;
ROLLBACK TO s;
</programlisting>
    Après le <command>ROLLBACK</command>, la ligne est réellement déverrouillée
    au lieu de retourner à son état avant le point de sauvegarde. Ceci peut
    arriver si une ligne verrouillée dans la transaction en cours est mise à
    jour ou supprimée, ou si un verrou partagé est passé en verrou exclusif&nbsp;:
    dans tous ces cas, l'état précédent du verrou est oublié. Si la transaction
    est ensuite annulée à un état entre la commande de verrou initiale et la
    modification qui a suivi, la ligne n'apparaîtra plus verrouillée. Ceci est
    une déficience de l'implémentation qui sera corrigée dans une prochaine
    version de <productname>PostgreSQL</productname>.
   </para>
  </caution>

  <caution>
   <para>
    Il est possible qu'une commande <command>SELECT</command> exécutée
    au niveau d'isolation <literal>READ COMMITTED</literal> et utilisant
    <literal>ORDER BY</literal> et <literal>FOR UPDATE/SHARE</literal>
    renvoie les lignes dans le
    désordre. C'est possible car l' <literal>ORDER BY</literal> est appliqué en premier.
    La commande trie le résultat, mais peut alors être bloquée le temps d'obtenir un verrou
    sur une ou plusieurs des lignes. Une fois que le <literal>SELECT</literal> est débloqué, des
    valeurs sur la colonne qui sert à ordonner peuvent avoir été modifiées, ce qui entraîne ces
    lignes apparaissant dans le désordre (bien qu'elles soient dans l'ordre par rapport aux valeurs
    d'origine de ces colonnes). Ceci peut être contourné si besoin en 
    plaçant la clause <literal>FOR UPDATE/SHARE</literal> dans une sous-requête,
    par exemple 
<programlisting>
SELECT * FROM (SELECT * FROM matable FOR UPDATE) ss ORDER BY column1;
</programlisting>
    Notez que cela entraîne le verrouillage de toutes les lignes de <structname>matable</structname>,
    alors que <literal>FOR UPDATE</literal> au niveau supérieur verrouillerait seulement les 
    lignes réellement renvoyées. Cela peut causer une différence de performance significative,
    en particulier si l' <literal>ORDER BY</literal> est combiné avec
    <literal>LIMIT</literal> ou d'autres restrictions.  Cette technique est donc recommandée uniquement si
    vous vous attendez à des mises à jour concurrentes sur les colonnes servant à l'ordonnancement
    et qu'un résultat strictement ordonné est requis.
   </para>

   <para>
    Au niveau d'isolation de transactions <literal>REPEATABLE READ</literal>
    et <literal>SERIALIZABLE</literal>, cela causera une erreur de
    sérialisation (avec un <literal>SQLSTATE</literal> valant
    <literal>'40001'</literal>), donc il n'est pas possible de recevoir
    des lignes non triées avec ces niveaux d'isolation.
   </para>
  </caution>

  </refsect2>

  <refsect2 id="sql-table">
   <title>Commande <literal>TABLE</literal></title>

   <para>
    La commande
<programlisting>
TABLE <replaceable class="parameter">nom</replaceable>
</programlisting>
    est complètement équivalente à
<programlisting>
SELECT * FROM <replaceable class="parameter">nom</replaceable>
</programlisting>
    Elle peut être utilisée comme commande principale d'une requête,
    ou bien comme une variante syntaxique permettant de gagner de la place
    dans des parties de requêtes complexes.
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Joindre la table <literal>films</literal> avec la table
   <literal>distributeurs</literal>&nbsp;:

<programlisting>SELECT f.titre, f.did, d.nom, f.date_prod, f.genre
    FROM distributeurs d, films f
    WHERE f.did = d.did

       titre       | did |     nom      | date_prod  |   genre
-------------------+-----+--------------+------------+------------
 The Third Man     | 101 | British Lion | 1949-12-23 | Drame
 The African Queen | 101 | British Lion | 1951-08-11 | Romantique
 ...
</programlisting>
  </para>

  <para>
   Additionner la colonne <literal>longueur</literal> de tous les films,
   grouper les résultats par <literal>genre</literal>&nbsp;:

<programlisting>SELECT genre, sum(longueur) AS total FROM films GROUP BY genre;

   genre    | total
------------+-------
 Action     | 07:34
 Comédie    | 02:58
 Drame      | 14:28
 Musical    | 06:42
 Romantique | 04:38
</programlisting>
  </para>

  <para>
   Additionner la colonne <literal>longueur</literal> de tous les films,
   grouper les résultats par <literal>genre</literal> et afficher les groupes 
   dont les totaux font moins de cinq heures&nbsp;:

<programlisting>SELECT genre, sum(longueur) AS total
    FROM films
    GROUP BY genre
    HAVING sum(longueur) &lt; interval '5 hours';

   genre    | total
------------+-------
 Comedie    | 02:58
 Romantique | 04:38
</programlisting>
  </para>

  <para>
   Les deux exemples suivants représentent des façons identiques de trier les résultats
   individuels en fonction du contenu de la deuxième colonne (<literal>nom</literal>)&nbsp;:

<programlisting>SELECT * FROM distributeurs ORDER BY nom;
SELECT * FROM distributeurs ORDER BY 2;

 did |       nom
-----+------------------
 109 | 20th Century Fox
 110 | Bavaria Atelier
 101 | British Lion
 107 | Columbia
 102 | Jean Luc Godard
 113 | Luso films
 104 | Mosfilm
 103 | Paramount
 106 | Toho
 105 | United Artists
 111 | Walt Disney
 112 | Warner Bros.
 108 | Westward
</programlisting>
  </para>

  <para>
   L'exemple suivant présente l'union des tables
   <literal>distributeurs</literal> et <literal>acteurs</literal>, restreignant
   les résultats à ceux de chaque table dont la première lettre est un W.
   Le mot clé <literal>ALL</literal> est omis, ce qui permet de n'afficher que
   les lignes distinctes.

<programlisting>distributeurs:               acteurs:
 did |     nom               id |     nom
-----+--------------        ----+----------------
 108 | Westward               1 | Woody Allen
 111 | Walt Disney            2 | Warren Beatty
 112 | Warner Bros.           3 | Walter Matthau
 ...                         ...

SELECT distributeurs.nom
    FROM distributeurs
    WHERE distributeurs.nom LIKE 'W%'
UNION
SELECT actors.nom
    FROM acteurs
    WHERE acteurs.nom LIKE 'W%';

      nom
----------------
 Walt Disney
 Walter Matthau
 Warner Bros.
 Warren Beatty
 Westward
 Woody Allen
</programlisting>
  </para>

  <para>
   L'exemple suivant présente l'utilisation d'une fonction dans la clause <literal>FROM</literal>,
   avec et sans liste de définition de colonnes&nbsp;:

<programlisting>CREATE FUNCTION distributeurs(int) RETURNS SETOF distributeurs AS $$
    SELECT * FROM distributeurs WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributeurs(111);
 did |    name
-----+-------------
 111 | Walt Disney

CREATE FUNCTION distributeurs_2(int) RETURNS SETOF record AS $$
    SELECT * FROM distributeurs WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributeurs_2(111) AS (f1 int, f2 text);
 f1  |     f2
-----+-------------
 111 | Walt Disney
</programlisting>
  </para>

  <para>
   Cet exemple montre comment utiliser une clause <literal>WITH</literal> simple:

<programlisting>
WITH t AS (
    SELECT random() as x FROM generate_series(1, 3)
  )
SELECT * FROM t
UNION ALL
SELECT * FROM t

         x          
--------------------
  0.534150459803641
  0.520092216785997
 0.0735620250925422
  0.534150459803641
  0.520092216785997
 0.0735620250925422
</programlisting>

   Notez que la requête <literal>WITH</literal> n'a été évaluée qu'une seule
   fois, ce qui fait qu'on a deux jeux contenant les mêmes trois valeurs.
  </para>

  <para>
   Cet exemple utilise <literal>WITH RECURSIVE</literal> pour trouver tous
   les subordonnés (directs ou indirects) de l'employée Marie, et leur niveau
   de subordination, à partir d'une table qui ne donne que les subordonnés
   directs&nbsp;:

<programlisting>
WITH RECURSIVE recursion_employes(distance, nom_employe, nom_manager) AS (
    SELECT 1, nom_employe, nom_manager
    FROM employe
    WHERE nom_manager = 'Marie'
  UNION ALL
    SELECT er.distance + 1, e.nom_employe, e.nom_manager
    FROM recursion_employes er, employe e
    WHERE er.nom_employe = e.nom_manager
  )
SELECT distance, nom_employe FROM recursion_employes;
</programlisting>

   Notez la forme typique des requêtes récursives&nbsp;:
   une condition initiale, suivie par <literal>UNION</literal>, suivis par
   la partie récursive de la requête. Assurez-vous que la partie récursive
   de la requête finira par ne plus retourner d'enregistrement, sinon la
   requête bouclera indéfiniment (Voir <xref linkend="queries-with"/> pour
   plus d'exemples).
  </para>
 </refsect1>
 
 <refsect1>
  <title>Compatibilité</title>

  <para>
   L'instruction <command>SELECT</command> est évidemment compatible avec le
   standard SQL. Mais il y a des extensions et quelques fonctionnalités
   manquantes.
  </para>
  
  <refsect2>
   <title>Clauses <literal>FROM</literal> omises</title>

   <para>
    <productname>PostgreSQL</productname> autorise l'omission de la clause
    <literal>FROM</literal>. Cela permet par exemple de calculer le
    résultat d'expressions simples&nbsp;:
<programlisting>SELECT 2+2;

 ?column?
----------
        4
</programlisting>
    D'autres bases de données <acronym>SQL</acronym> interdisent ce comportement,
    sauf à introduire une table virtuelle d'une seule ligne sur laquelle exécuter
    la commande <command>SELECT</command>.
   </para>

   <para>
    S'il n'y a pas de clause <literal>FROM</literal>, la requête ne
    peut pas référencer les tables de la base de données. La
    requête suivante est, ainsi, invalide&nbsp;:
<programlisting>SELECT distributors.* WHERE distributors.name = 'Westward';
</programlisting>
    Les versions antérieures à <productname>PostgreSQL</productname> 8.1 
    acceptaient les requêtes de cette forme en ajoutant une entrée implicite à
    la clause <literal>FROM</literal> pour chaque table référencée.
    Ce n'est plus autorisé.
   </para>
  </refsect2>

  <refsect2>
   <title>Omettre le mot clé <literal>AS</literal></title>

   <para>
    Dans le standard SQL, le mot clé <literal>AS</literal> peut être omis
    devant une colonne de sortie à partir du moment où le nouveau nom de colonne
    est un nom valide de colonne (c'est-à-dire, différent d'un mot clé réservé).
    <productname>PostgreSQL</productname> est légèrement plus restrictif&nbsp;:
    <literal>AS</literal> est nécessaire si le nouveau nom de colonne est un
    mot clé quel qu'il soit, réservé ou non. Il est recommandé d'utiliser
    <literal>AS</literal> ou des colonnes de sortie entourées de guillemets, pour
    éviter tout risque de conflit en cas d'ajout futur de mot clé.
   </para>

   <para>
    Dans les éléments de <literal>FROM</literal>, le standard et
    <productname>PostgreSQL</productname> permettent que <literal>AS</literal>
    soit omis avant un alias qui n'est pas un mot clé réservé. Mais
    c'est peu pratique pour les noms de colonnes, à causes d'ambiguïtés
    syntaxiques.
   </para>
  </refsect2>

  <refsect2>
   <title><literal>ONLY</literal> et les parenthèses</title>

   <para>
    Le standard SQL impose des parenthèses autour du nom de table après
    <literal>ONLY</literal>, comme dans <literal>SELECT * FROM ONLY
    (tab1), ONLY (tab2) WHERE ...</literal>. PostgreSQL supporte ceci aussi, mais
    les parenthèses sont optionnelles (ce point s'applique également à toutes
    les commandes SQL supportant l'option <literal>ONLY</literal>).
   </para>
  </refsect2>

  <refsect2>
   <title>Espace logique disponible pour <literal>GROUP BY</literal> et
    <literal>ORDER BY</literal></title>
   
   <para>
    Dans le standard SQL-92, une clause <literal>ORDER BY</literal>
    ne peut utiliser que les noms ou numéros des colonnes en sortie, une clause 
    <literal>GROUP BY</literal> que des expressions fondées sur les noms de
    colonnes en entrée. <productname>PostgreSQL</productname> va plus loin, puisqu'il 
    autorise chacune de ces clauses à utiliser également l'autre possibilité.
    En cas d'ambiguïté, c'est l'interprétation du standard qui prévaut.
    <productname>PostgreSQL</productname> autorise aussi l'utilisation d'expressions
    quelconques dans les deux clauses. 
    Les noms apparaissant dans ces expressions sont toujours considérés comme nom de
    colonne en entrée, pas en tant que nom de colonne du résultat.
   </para>

   <para>
    SQL:1999 et suivant utilisent une définition légèrement différente,
    pas totalement compatible avec le SQL-92. Néanmoins, dans la plupart des
    cas, <productname>PostgreSQL</productname> interprète une expression
    <literal>ORDER BY</literal> ou <literal>GROUP BY</literal> en suivant
    la norme SQL:1999.
   </para>
  </refsect2>

  <refsect2>
   <title>Dépendances fonctionnelles</title>

   <para>
    <productname>PostgreSQL</productname> reconnaît les dépendances fonctionnelles
    (qui permettent que les nom des colonnes ne soient pas dans le <literal>GROUP BY</literal>) seulement lorsqu'une clé primaire
    est présente dans la liste du <literal>GROUP BY</literal>.
    Le standard SQL spécifie des configurations supplémentaires qui doivent être reconnues.
   </para>
  </refsect2>

  <refsect2>
   <title>Restrictions sur la clause <literal>WINDOW</literal></title>

   <para>
    Le standard SQL fournit des options additionnelles pour la
    <replaceable class="parameter">clause_frame</replaceable> des window.
    <productname>PostgreSQL</productname> ne supporte à ce jour que les options
    mentionnées précédemment.
   </para>
  </refsect2>

  <refsect2>
   <title><literal>LIMIT</literal> et <literal>OFFSET</literal></title>

   <para>
    Les clauses <literal>LIMIT</literal> et <literal>OFFSET</literal>
    sont une syntaxe spécifique à <productname>PostgreSQL</productname>, aussi
    utilisée dans <productname>MySQL</productname>. La norme SQL:2008 a
    introduit les clauses <literal>OFFSET ... FETCH {FIRST|NEXT}...</literal>
    pour la même fonctionnalité, comme montré plus haut dans
    <xref linkend="sql-limit"/>. Cette syntaxe
    est aussi utilisée par <productname>IBM DB2</productname>.
    (Les applications écrites pour <productname>Oracle</productname> contournent
    fréquemment le problème par l'utilisation de la colonne auto-générée
    <literal>rownum</literal> pour obtenir les effets de ces clauses, qui n'est
    pas disponible sous PostgreSQL,)
   </para>
  </refsect2>

  <refsect2>
   <title><literal>FOR UPDATE</literal> and <literal>FOR SHARE</literal></title>

   <para>
    Bien que <literal>FOR UPDATE</literal> soit présent dans le standard SQL, le standard 
    ne l'autorise que comme une option de <command>DECLARE CURSOR</command>.
    <productname>PostgreSQL</productname> l'autorise dans toute requête <command>SELECT</command>
    et dans toute sous-requête <command>SELECT</command>, mais c'est une extension.
    Ni la variante <literal>FOR SHARE</literal>, ni l'option <literal>NOWAIT</literal> n'apparaissent
    dans le standard.
   </para>
  </refsect2>

  <refsect2>
   <title>Ordre de modification de données dans un <literal>WITH</literal></title>

   <para>
    <productname>PostgreSQL</productname> permet que les clauses <command>INSERT</command>,
    <command>UPDATE</command>, et <command>DELETE</command> soient utilisées comme requêtes <literal>WITH</literal>.
    Ceci n'est pas présent dans le standard SQL.
   </para>
  </refsect2>

  <refsect2>
   <title>Clauses non standard</title>

   <para>
    La clause <literal>DISTINCT ON</literal> n'est pas définie dans le standard
    SQL.
   </para>
  </refsect2>
 </refsect1>
</refentry>
