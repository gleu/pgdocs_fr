<?xml version="1.0" encoding="UTF-8"?>
<!-- doc/src/sgml/ref/pgbench.sgml -->

<refentry id="pgbench">
 <indexterm zone="pgbench">
  <primary>pgbench</primary>
 </indexterm>

 <refmeta>
  <refentrytitle><application>pgbench</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>pgbench</refname>
  <refpurpose>Réalise un test de benchmark pour
  <productname>PostgreSQL</productname></refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <cmdsynopsis>
   <command>pgbench</command>
   <arg choice="plain"><option>-i</option></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>nom_base</replaceable></arg>
  </cmdsynopsis>
  <cmdsynopsis>
   <command>pgbench</command>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>nom_base</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
 <para>
  <application>pgbench</application> est un programme pour réaliser des
  tests de performances (<foreignphrase>benchmark</foreignphrase> en anglais)
  sur <productname>PostgreSQL</productname>.  Il
  exécute la même séquence de commandes SQL en continu, potentiellement
  avec plusieurs sessions concurrentes et ensuite il calcule le taux de
  transactions moyen (en transactions par secondes).
  Par défaut, <application>pgbench</application> teste un scénario
  vaguement basé sur TPC-B, impliquant cinq commandes <command>SELECT</command>,
  <command>UPDATE</command> et <command>INSERT</command> par
  transaction.
  Toutefois, il est facile de tester d'autres scénarios en écrivant
  ses propres scripts de transactions.
 </para>

 <para>
  Une sortie classique de <application>pgbench</application> ressemble
  à ceci&nbsp;:

<screen>
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 85.184871 (including connections establishing)
tps = 85.296346 (excluding connections establishing)
</screen>

  Les six premières lignes rapportent quelques-uns des paramètres
  les plus importants qui ont été définis.
  La ligne suivante remonte le nombre de transactions réalisées et
  prévues. (La seconde rapporte juste le ratio entre le nombre de
  clients et le nombre de transactions par client).
  Ils seront équivalents à moins que l'exécution ait échoué avant la fin.
  (Avec le mode <option>-T</option>, seul le nombre réel de transactions
  est affiché.)
  Les deux dernières lignes remontent le nombre de transactions par
  secondes incluant ou pas le temps utilisé à démarrer une session.
 </para>

  <para>
   Les transactions tests, par défaut TPC-B, nécessitent d'avoir défini
   des tables spécfiques au préalable.
   <application>pgbench</application> devrait être utilisé avec l'option
   <option>-i</option> (initialisation) pour créer et peupler ces tables.
   (Si vous testez un script personnalisé, vous n'aurez pas besoin de
   cette étape, mais vous aurez besoin de mettre en place tout ce dont
   votre script aura besoin pour réaliser ces tests).
   Une initialisation ressemble à ça&nbsp;:

<programlisting>
pgbench -i <optional> <replaceable>autres-options</replaceable>
</optional> <replaceable>nom_base</replaceable>
</programlisting>

   Où <replaceable>nom_base</replaceable> est le nom de la base de données
   existante sur laquelle on conduit les tests. (Vous aurez aussi
   probablement besoin des options <option>-h</option>,
   <option>-p</option> et/ou <option>-U</option> qui spécifient comment
   se connecter à l'instance de base de données.)
  </para>

  <caution>
   <para>
    <literal>pgbench -i</literal> crée quatre tables nommées
    <structname>pgbench_accounts</structname>,
    <structname>pgbench_branches</structname>,
    <structname>pgbench_history</structname> et
    <structname>pgbench_tellers</structname>,
    détruisant toute table qui porterait l'un de ces noms.
    Attention à utiliser une autre base de données si vous avez
    des tables qui portent ces noms&nbsp;!
   </para>
  </caution>

  <para>
   Par défaut, avec un facteur d'échelle de 1, les tables contiennent
   intialement le nombre de lignes suivant&nbsp;:
<screen>
table                   # de lignes
---------------------------------
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0
</screen>
   Vous pouvez (et, dans la plupart des cas, devriez) augmenter le nombre de
   lignes en utilisant l'option <option>-s</option>. Le facteur de remplissage
   <option>-F</option> peut aussi être utilisée à cet effet.
  </para>

  <para>
   Une fois les installations préliminaires réalisées, vous pouvez
   lancer vos benchmarks avec les options qui conviennent et ne plus
   utiliser l'option <option>-i</option>&nbsp;:

<programlisting>
pgbench <optional> <replaceable>options</replaceable> </optional>
<replaceable>nom_base</replaceable>
</programlisting>

   Dans presque tous les cas, vous allez avoir besoin de certaines
   options pour rendre vos tests plus pertinents.
   Les options les plus importantes sont celles qui concernent&nbsp;:
   le nombre de clients (<option>-c</option>),
   le nombre de transactions (<option>-t</option>),
   l'intervalle de temps (<option>-T</option>)  et
   le script à lancer (<option>-f</option>).
   Vous trouverez ci-dessous toutes les options disponibles.
  </para>
 </refsect1>

 <refsect1>
  <title>Options</title>

  <para>
   La partie suivante est divisée en trois sous-parties&nbsp;: Les
   options utiles à la phase d'initialisation sont différentes
   des options utilisées pendant les test de performances, et certaines
   options sont utiles dans les deux cas.
  </para>

 <refsect2 id="pgbench-init-options">
  <title>Options d'initialisation</title>

   <para>
    Pour réaliser l'initialisation, <application>pgbench</application>
    accepte les arguments suivants en ligne de commande&nbsp;:

    <variablelist>

     <varlistentry>
      <term><option>-i</option></term>
      <term><option>--initialize</option></term>
      <listitem>
       <para>
        Nécessaire pour être en mode initialisation.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-F</option>
      <replaceable>fillfactor</replaceable></term>
      <term><option>--fillfactor=
      </option><replaceable>fillfactor</replaceable></term>
      <listitem>
       <para>
        Crée les tables <structname>pgbench_accounts</structname>,
        <structname>pgbench_tellers</structname> et
        <structname>pgbench_branches</structname> avec le facteur de
        remplissage (fillfactor) spécifié.
        La valeur par défaut est 100.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>--no-vacuum</option></term>
      <listitem>
       <para>
        Ne réalise pas d'opération de VACUUM après l'initialisation.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-q</option></term>
      <term><option>--quiet</option></term>
      <listitem>
       <para>
		Passe du mode verbeux au mode silencieux, en affichant seulement
		un message toutes les cinq secondes.
		Par défaut, on affiche un message toutes les 100000 lignes, ce
		qui engendre souvent la génération de plusieurs lignes de journal
		toutes les secondes (particulierement sur du bon matériel)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option>
      <replaceable>scale_factor</replaceable></term>
      <term><option>--scale=</option>
      <replaceable>scale_factor</replaceable></term>
      <listitem>
       <para>
        Multiplie le nombre de lignes générées par le facteur d'échelle (scale
        factor) Par exemple, <literal>-s 100</literal> va créer 10 millions de
        lignes dans la table <structname>pgbench_accounts</structname>. La
        valeur par défaut est 1. Lorsque l'échelle dépasse 20&nbsp;000, les
        colonnes utilisées pour contenir les identifiants de compte (colonnes
        <structfield>aid</structfield>) vont être converties en grands entiers
        (<type>bigint</type>), de manière à être suffisament grandes pour
        contenir un grand intervalle d'identifiants de compte.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--foreign-keys</option></term>
      <listitem>
       <para>
        Crée une contrainte de type clé étrangère entre les tables standards.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--index-tablespace=<replaceable>index_tablespace</replaceable>
      </option></term>
      <listitem>
       <para>
        Crée un index sur le tablespace spécifié, plutôt que sur le
        tablespace par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--tablespace=<replaceable>tablespace</replaceable>
      </option></term>
      <listitem>
       <para>
        Crée une table sur le tablespace spécifié, plutôt que sur le
        tablespace par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--unlogged-tables</option></term>
      <listitem>
       <para>
        Crée toutes les tables en tant que tables non journalisées,
        plutôt qu'en tant que des tables permanentes.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </refsect2>

 <refsect2 id="pgbench-run-options">
  <title>Options Benchmark</title>

   <para>
    Pour réaliser un benchmark <application>pgbench</application>
    accepte les arguments suivants en ligne de commande&nbsp;:

    <variablelist>

     <varlistentry>
      <term><option>-b</option> <replaceable>nom_script[@poids]</replaceable></term>
      <term><option>--builtin</option>=<replaceable>nom_script[@poids]</replaceable></term>
      <listitem>
       <para>
        Ajoute le script interne spécifié à la liste des scripts exécutés.  Un
        entier optionnel, le poids, peut être saisi après un caractère
        <literal>@</literal>. Il permet d'ajusrer la probabilité d'exécution
        du script. S'il n'est pas indiqué, le poids vaut 1. Tous les scripts
        internes disponibles sont <literal>tpcb-like</literal>, <literal
        >simple-update</literal> et <literal>select-only</literal>.
        L'utilisation des préfixes non ambigus des noms de scripts internes
        est acceptée. En utilisant le nom spécial <literal>list</literal>, la
        commande affiche la liste des scripts internes, puis quitte
        immédiatement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-c</option> <replaceable>clients</replaceable></term>
      <term><option>--client=
      </option><replaceable>clients</replaceable></term>
      <listitem>
       <para>
        Nombre de clients simulés, c'est-à-dire le nombre
        de sessions concurentes sur la base de données.
        La valeur par défaut est à 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-C</option></term>
      <term><option>--connect</option></term>
      <listitem>
       <para>
		Établit une nouvelle connexion pour chaque transaction, plutôt
		que de ne le faire qu'une seule fois par session cliente.
		C'est une option très utile pour mesurer la surcharge engendrée
		par la connexion.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-d</option></term>
      <term><option>--debug</option></term>
      <listitem>
       <para>
        Affiche les informations de debug.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-D</option> <replaceable>variable</replaceable>
      <literal>=</literal><replaceable>value</replaceable></term>
      <term><option>--define=</option><replaceable>variable</replaceable>
      <literal>=</literal><replaceable>value</replaceable></term>
      <listitem>
       <para>
        Définit une variable à utiliser pour un script personnalisé
        Voir ci-dessous pour plus de détails.
        Il est possible d'utiliser plusieurs fois l'option <option>-D</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-f</option> <replaceable>nom_fichier[@poids]</replaceable></term>
      <term><option>--file=</option><replaceable>nom_fichier[@poids]</replaceable></term>
      <listitem>
       <para>
        Ajouter un script de transactions nommé
        <replaceable>nom_fichier</replaceable> à la liste des scripts
        exécutés. Il est possible de préciser un poids, sous la forme d'un
        entier optionnel après le caractère <literal>@</literal> pour
        permettre d'ajuster la probabilité d'exécuter le test. Voir ci-dessous
        pour les détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-j</option> <replaceable>threads</replaceable></term>
      <term><option>--jobs=</option>
      <replaceable>threads</replaceable></term>
      <listitem>
       <para>
        Nombre de processus utilisés dans
        <application>pgbench</application>.
        Utiliser plus d'un thread peut être utile sur des machines
        possédant plusieurs cœurs.
        Les clients sont distribués de la manière la plus égale possible
        parmi les threads.
        La valeur par défaut est 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-l</option></term>
      <term><option>--log</option></term>
      <listitem>
       <para>
        Rapporte les informations sur chaque transaction dans le fichier
        journal.
        Voir ci-dessous pour plus de détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-L</option> <replaceable>limite</replaceable></term>
      <term><option>--latency-limit=</option><replaceable>limite</replaceable></term>
      <listitem>
       <para>
        Chaque transaction dont la durée est supérieure à la limite
        définie par <replaceable>limite</replaceable> (en milliseconde)
        est comptabilisée et rapportée séparement en tant que
        <firstterm>late</firstterm>.
       </para>
       <para>
        Lorsqu'un bridage est spécifié(<option>--rate=... </option>),
        les transactions, qui ont en terme de
        planification un retard supérieur à
        <replaceable>limite</replaceable> (en milliseconde) et celles
        qui n'ont pas la possibilité de rattraper la limite de latence,
        ne sont simplement pas envoyées à l'instance.
        Elles sont comptabilisées et rapportées séparément en tant que
        <firstterm>skipped</firstterm> (ignorées).
       </para>
       </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-M</option>
      <replaceable>querymode</replaceable></term>
      <term><option>--protocol=</option>
      <replaceable>querymode</replaceable></term>
      <listitem>
       <para>
		Protocole à utiliser pour soumettre des requêtes au serveur:
          <itemizedlist>
           <listitem>
            <para><literal>simple</literal>&nbsp;: utilisation du protocole
            de requêtes standards.</para>
           </listitem>
           <listitem>
            <para><literal>extended</literal>&nbsp;: utilisation du protocole
            de requêtes étendues.</para>
           </listitem>
           <listitem>
            <para><literal>prepared</literal>&nbsp;: utilisation du protocole
            de requêtes étendues avec instructions préparées.</para>
           </listitem>
          </itemizedlist>
        Par défaut, le protocole de requêtes standards est utilisé
        (voir <xref linkend="protocol"/> pour plus d'informations).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>--no-vacuum</option></term>
      <listitem>
       <para>
		Ne réalise pas l'opération de maintenance VACUUM avant de lancer
		le test.
		Cette option est <emphasis>nécessaire</emphasis> si vous lancez
		un scénario de test personnalisé qui n'utilise pas les tables
		standards <structname>pgbench_accounts</structname>,
        <structname>pgbench_branches</structname>, <structname>
	    pgbench_history</structname> et <structname>pgbench_tellers
	    </structname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-N</option></term>
      <term><option>--skip-some-updates</option></term>
      <listitem>
       <para>
        Exécute le script interne simple-update. C'est un raccourci pour
        <option>-b simple-update</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-P</option> <replaceable>sec</replaceable></term>
      <term><option>--progress=</option>
      <replaceable>sec</replaceable></term>
      <listitem>
       <para>
        Affiche le rapport de progression toutes les
        <replaceable>sec</replaceable> secondes.
        Ce rapport inclut la durée du test, le nombre de
        transactions par seconde depuis le dernier rapport, et la
        latence moyenne sur les transactions ainsi que la déviation
        depuis le dernier rapport.
        Avec le bridage, la latence est calculée en fonction de la date
        de démarrage planifiée de la transaction
        (option <option>-R</option>). Elle y inclut aussi la latence
        moyenne du temps de planification.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-r</option></term>
      <term><option>--report-latencies</option></term>
      <listitem>
       <para>
        Rapporte la latence moyenne par instruction (temps d'exécution
        du point de vue du client) de chaque commande après la fin du
        benchmark.
        Voir ci-dessous pour plus de détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-R</option> <replaceable>rate</replaceable></term>
      <term><option>--rate=</option><replaceable>rate</replaceable></term>
      <listitem>
       <para>
		Plutôt que d'aller le plus vite possible, l'exécution des
		transactions vise à atteindre le ratio spécifié (fonctionnement
		par défaut). Le taux est donné en transactions par seconde.
		Si le ratio visé est supérieur au ratio maximum possible, la
		limite de ratio n'aura aucune influence sur le résultat.
       </para>
       <para>
		Ce ratio est visé en appliquant une loi de poisson sur le temps
		pour ordonnançer les transactions.
		La date de démarrage prévue est avancée au moment où le client a
		démarré sa transaction et pas sur le moment où la dernière
		transaction s'est arrêtée.
		Cette manière de procéder signifie que, si une transaction
		dépasse sa date de fin prévue, un rattrapage est encore possible
		pour les suivantes.
       </para>
       <para>
		Lorsque le bridage est actif, à la fin de l'exécution, on
		calcule, à partir de la date de démarrage, la latence de la
		transaction, c'est-à-dire que l'on calcule le temps d'attente
		pour chaque transaction que la précédente se soit terminée.
		Ce temps d'attente est appelé temps de latence d'ordonnancement,
		et ses valeurs moyenne et maximum sont rapportées séparément.
		Le temps de latence d'ordonnancement respecte la date réelle de
		démarrage. Par exemple, le temps d'exécution d'une transaction
		dans la base peut être récupéré en soustrayant le temps de
		latence d'ordonnancement à la latence précisée dans le rapport.
       </para>

       <para>
        Si l'option <option>--latency-limit</option> est utilisée avec
        l'option  <option>--rate</option>, une transaction peut avoir
        une telle latence qu'elle serait déja supérieure à limite de
        latence lorsque la transaction précédente se termine, car la
        latence est calculée au moment de la date de démarrage planifiée.
        Les transactions concernées ne sont pas envoyées à l'instance,
        elles sont complètement ignorées et comptabilisées séparément.
       </para>

       <para>
		Une latence de planification élevée est un indicateur sur le
		fait que le système ne peut pas traiter les transactions du
		ratio (nombre de processus - nombres de clients) spécifié.
		Lorsque le temps moyen d'exécution est plus important que
		l'intervalle planifié prévu entre chaque transaction, chaque
		transaction successive va prendre du retard, et la latence de
		planification va continuer de croître tout le long de la durée
		du test.
		Si cela se produit, vous devez réduire le taux de transaction
		que vous avez spécifié.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>scale_factor</replaceable></term>
      <term><option>--scale=</option><replaceable>scale_factor</replaceable></term>
      <listitem>
       <para>
		    Rapporte le facteur d'échelle dans la sortie de <application>pgbench</application>.
        Avec des tests encastrés, ce n'est pas nécessaire&nbsp;; le facteur
        d'échelle approprié sera détecté en comptant le nombre de lignes
        dans la table <structname>pgbench_branches</structname>.
        Toutefois, lors de l'utilisation d'un benchmark avec un scénario
        personnalisé (option <option>-f</option>), le facteur
        d'échelle sera ramené à 1 à moins que cette option ne soit utilisée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-S</option></term>
      <term><option>--select-only</option></term>
      <listitem>
       <para>
        Exécute le script interne select-only. C'est un raccourci pour
        <option>-b select-only</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-t</option>
      <replaceable>transactions</replaceable></term>
      <term><option>--transactions=</option>
      <replaceable>transactions</replaceable></term>
      <listitem>
       <para>
		Nombre de transactions lancées par chaque client.
		La valeur par défaut est 10.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-T</option> <replaceable>seconds</replaceable></term>
      <term><option>--time=</option><replaceable>seconds</replaceable></term>
      <listitem>
       <para>
        Lance le test pour la durée spécifiée en secondes, plutôt que
        pour un nombre fixe de transactions par client.
        Les options <option>-t</option> et <option>-T</option> ne sont
        pas compatibles.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <term><option>--vacuum-all</option></term>
      <listitem>
       <para>
        Réalise l'opération de VACUUM sur les quatre tables standards avant de
        lancer le test. Sans l'option <option>-n</option> ou
        <option>-v</option>, <application>pgbench</application> fera un VACUUM
        sur les tables <structname>pgbench_tellers</structname> et
        <structname>pgbench_branches</structname>, puis tronquera
        <structname>pgbench_history</structname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--aggregate-interval=
      <replaceable>secondes</replaceable></option></term>
      <listitem>
       <para>
        Taille de l'intervalle d'agrégation (en secondes). Cette option peut
        uniquement être utilisée avec l'option <application>-l</application>.
        Avec cette option, le journal contiendra des résumés par
        intervalle, résumé décrit ci-dessous.
       </para>
       <para>
        Cette option n'est pour l'instant pas supportée sur les
        systèmes d'exploitation Windows.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--progress-timestamp</option></term>
      <listitem>
       <para>
        Lorsque la progression est affichée (option <option>-P</option>),
        utilise un horodatage de type timestamp (epoch Unix) au lieu d'un
        nombre de secondes depuis le début de l'exécution. L'unité est en
        secondes avec une précision en milli-secondes après le point. Ceci
        aide à comparer les traces générées par les différents outils.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--sampling-rate=
      <replaceable>rate</replaceable></option></term>
      <listitem>
       <para>
        Le taux d'échantillonnage, est utilisé lors de l'écriture des
        données dans les journaux, afin de réduire la quantité de
        journaux générés.
		Si cette option est utilisée, il n'y a qu'une portion des
		transactions qui sont journalisées, suivant la proportion spécifiée.
		1.0 signifie que toutes les transactions sont journalisées,
		0.05 signifie que 5% de toutes les transactions sont
		journalisées.
       </para>
       <para>
		Pensez à prendre le taux d'échantillonnage en compte lorsque vous
		allez consulter le journal.
		Par exemple, lorsque vous évaluez les TPS, vous devrez multiplier
		les nombres en concordance. (Exemple, avec un taux
		d'échantillonage de 0.01, vous n'obtiendrez que 1/100 des TPS
		réelles).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--log-prefix=<replaceable>prefix</replaceable></option></term>
      <listitem>
       <para>
	Définit le préfixe des fichiers logs créés par <option>--log</option>.
	Par défaut, celui-ci sera <literal>pgbench_log</literal>.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </refsect2>

 <refsect2 id="pgbench-common-options">
  <title>Options habituelles</title>

   <para>
    <application>pgbench</application> accepte les arguments suivants en
    ligne de commande&nbsp;:

    <variablelist>

     <varlistentry>
      <term><option>-h</option>
      <replaceable>hostname</replaceable></term>
      <term><option>--host=</option>
      <replaceable>hostname</replaceable></term>
      <listitem>
       <para>
        Le nom du serveur de base de données.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-p</option>
      <replaceable>port</replaceable></term>
      <term><option>--port=</option>
      <replaceable>port</replaceable></term>
      <listitem>
       <para>
        Le port d'écoute de l'instance sur le serveur de base de données.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-U</option>
      <replaceable>login</replaceable></term>
      <term><option>--username=</option>
      <replaceable>login</replaceable></term>
      <listitem>
       <para>
        Le nom de l'utilisateur avec lequel on se connecte à l'instance.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-V</option></term>
      <term><option>--version</option></term>
      <listitem>
       <para>
        Affiche la version de <application>pgbench</application>
        puis quitte.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-?</option></term>
      <term><option>--help</option></term>
      <listitem>
       <para>
         Affiche l'aide sur les arguments en ligne de commande de
		<application>pgbench</application> puis quitte.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

 </refsect2>
 </refsect1>

 <refsect1>
  <title>Notes</title>

 <refsect2>
  <title>Quelles sont les <quote>transactions</quote> réellement exécutées
  dans <application>pgbench</application>&nbsp;?</title>

  <para>
   <application>pgbench</application> exécute des scripts de tests choisis de
   façon aléatoire à partir d'une sélection. Cela inclut des scripts internes
   avec l'option <option>-b</option> et des scripts personnalisés
   d'utilisateurs avec l'option <option>-f</option>. Chaque script peut se
   voir associé un poids relatif, indiqué avec le symbôle <literal>@</literal>
   pour changer sa probabilité d'exécution. Le poids par défaut est de
   <literal>1</literal>. Les scripts ayant un poids de <literal>0</literal>
   sont ignorés.
  </para>

  <para>
   Le script interne de transaction par défaut (aussi appelé avec <option>-b
   tpcb-like</option>) exécute sept commandes par transaction choisies de
   façon aléatoire parmi <literal>aid</literal>, <literal>tid</literal>,
   <literal>bid</literal> et <literal>balance</literal>. Le scénario s'inspire
   du jeu de tests de performance TPC-B benchmark mais il ne s'agit pas
   réellement de TPC-B, d'où son nom.
  </para>

  <orderedlist>
   <listitem><para><literal>BEGIN;</literal></para></listitem>
   <listitem><para><literal>
   UPDATE pgbench_accounts SET abalance = abalance + :delta
   WHERE aid = :aid;</literal></para></listitem>
   <listitem><para><literal>SELECT abalance FROM pgbench_accounts
   WHERE aid = :aid;</literal></para></listitem>
   <listitem><para><literal>UPDATE pgbench_tellers
   SET tbalance = tbalance + :delta
   WHERE tid = :tid;</literal></para></listitem>
   <listitem><para><literal>UPDATE pgbench_branches
   SET bbalance = bbalance + :delta
   WHERE bid = :bid;</literal></para></listitem>
   <listitem><para><literal>INSERT
   INTO pgbench_history (tid, bid, aid, delta, mtime)
   VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
   </literal></para></listitem>
   <listitem><para><literal>END;</literal></para></listitem>
  </orderedlist>

  <para>
   Si vous sélectionnez le script interne <literal>simple-update</literal> (ou
   <option>-N</option>), les étapes 4 et 5 ne sont pas inclus dans la
   transaction. Ceci évitera des contentions au niveau des mises à jour sur
   ces tables. De ce fait, le test ressemblera moins à TPC-B.
  </para>

  <para>
   Si vous sélectionnez le script interne <literal>select-only</literal> (ou
   <option>-S</option>), alors seule l'instruction only the
   <command>SELECT</command> est exécutée.
  </para>
 </refsect2>

 <refsect2>
  <title>Scripts personnalisés</title>

  <para>
   <application>pgbench</application> est capable d'utiliser des
   scénarios de test de performances personnalisés qui remplacent le
   script de transactions par défaut (décrit ci-dessus) par un script de
   transactions lu depuis le fichier spécifié avec l'option
   (<option>-f</option>).
   Dans ce cas, une <quote>transaction</quote> est comptabilisée comme
   une exécution d'un fichier script.
  </para>

  <para>
   Un fichier script contient une ou plusieurs commandes SQL terminées par des
   points-virgules. Les lignes vides et les lignes commençant par
   <literal>--</literal> sont ignorées. Les fichiers scripts peuvent aussi
   contenir des <quote>méta-commandes</quote>, qui seront interprétées par
   <application>pgbench</application> comme décrit dans la partie suivante.
  </para>

  <note>
   <para>
    Avant <productname>PostgreSQL</productname> 9.6, les commandes SQL compris
    dans les fichiers scripts étaient terminées par un retour à la ligne.
    Elles ne pouvaient donc pas être écrites sur plusieurs lignes. Maintenant,
    un point-virgule est <emphasis>requis</emphasis> pour séparer des
    commandes SQL consécutives (bien qu'une commande SQL n'en a pas besoin si
    elle est suivie par une méta-comande). Si vous avez besoin de créer un
    fichier script qui fonctionne avec les anciennes et nouvelles versions de
    <application>pgbench</application>, assurez-vous d'écrire chaque commande
    SQL sur une seule ligne et en terminant avec un point-virgule.
   </para>
  </note>

  <para>
   Il est possible simplement de substituer les variables dans les
   fichiers scripts.
   Les variables peuvent être instanciées via la ligne de commande avec
   l'option <option>-D</option> comme décrit ci-dessus ou grâce aux
   méta-commandes décrites ci-dessous.
   En plus des commandes pré-définies par l'option de la ligne de
   commande <option>-D</option>, il y a quelques variables qui sont
   automatiquement prédéfinies, listées sous
   <xref linkend="pgbench-automatic-variables"/>.
    Si une valeur pour l'une de ces variables a été définie via la
    ligne de commande avec l'option <option>-D</option>, elle sera prise
    en compte en priorité par rapport à la valeur définie
    automatiquement. Une fois définie, la valeur d'une variable peut
    être insérée dans les commandes SQL en écrivant <literal>:</literal>
    <replaceable>nom_variable</replaceable>.
    S'il y a plus d'une session par client, chaque session possède son
    propre jeu de variables.
  </para>

   <table id="pgbench-automatic-variables">
    <title>Variables automatiques</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Variable</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>scale</literal></entry>
       <entry>facteur d'echelle courant</entry>
      </row>

      <row>
       <entry><literal>client_id</literal></entry>
       <entry>nombre unique permettant d'identifier la session client
       (commence à zero)</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   Dans les fichiers de scripts, les méta-commandes commencent avec un anti-
   slash (<literal>\</literal>) et s'étendent jusqu'à la fin de la ligne, même si elles peuvent
   être continuées sur plusieurs lignes en écrivant anti-slash suivi d'un retour chariot. Les
   arguments d'une méta-commande sont séparés par des espaces vides. Les méta-
   commmandes suivantes sont supportées&nbsp;:
  </para>

  <variablelist>
   <varlistentry id='pgbench-metacommand-set'>
    <term>
     <literal>\set <replaceable>nom_variable</replaceable>
     <replaceable>expression</replaceable></literal>
    </term>

    <listitem>
     <para>
      Définit la variable <replaceable>nom_variable</replaceable> à une valeur
      définie par <replaceable>expression</replaceable>. L'expression peut
      contenir un entier fixé comme <literal>5432</literal>, double constants
      such as <literal>3.14159</literal>, référencer des variables
      <literal>:</literal><replaceable>nom_variable</replaceable>, opérateurs
      unitaires (<literal>+</literal>, <literal>-</literal>) et opérateurs
      binaires (<literal>+</literal>, <literal>-</literal>,
      <literal>*</literal>, <literal>/</literal>, <literal>%</literal>) avec
      leur précédence et associativité habituelles, <link
      linkend="pgbench-builtin-functions">appels de fonction</link>, et
      parenthèses.
     </para>

     <para>
      Exemples&nbsp;:
<programlisting>
\set ntellers 10 * :scale
\set aid (1021 * random(1, 100000 * :scale)) % \
           (100000 * :scale) + 1
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\sleep
     <replaceable>number</replaceable> [ us | ms | s ]</literal>
    </term>

    <listitem>
     <para>
	  Entraîne la suspension de l'exécution du script pendant la durée
	  spécifiée en microsecondes (<literal>us</literal>), millisecondes
	  (<literal>ms</literal>) ou secondes (<literal>s</literal>).
	  Si l'unité n'est pas définie, l'unité par défaut est la seconde.
	  Il peut être soit un entier constant, soit une référence
	  <literal>:</literal><replaceable>nom_variable</replaceable> vers
	  une variable retournant un entier.
     </para>

     <para>
      Exemple&nbsp;:
<programlisting>
\sleep 10 ms
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\setshell <replaceable>nom_variable</replaceable>
     <replaceable>commande</replaceable> [
     <replaceable>argument</replaceable> ... ]</literal>
    </term>

    <listitem>
     <para>
      Définit la variable <replaceable>nom_variable</replaceable> comme le
      résultat d'une commande shell nommée <replaceable>commande</replaceable>
      aves le(s) <replaceable>argument</replaceable>(s) donné(s). La commande
      doit retourner un entier sur la sortie standard.
     </para>

     <para>
      <replaceable>commande</replaceable> et chaque <replaceable>argument</replaceable> peuvent être soit une
      constante de type text soit une référence <literal>:</literal><replaceable>nom_variable</replaceable> à
      une variable. Si vous voulez utiliser un <replaceable>argument</replaceable> commençant avec un
      symbôle deux-points, écrivez un symbôle deux-points supplémentaire au début de
       <replaceable>argument</replaceable>.
     </para>

     <para>
      Exemple&nbsp;:
<programlisting>
\setshell variable_à_utiliser commande argument_litéral :variable
::literal_commencant_avec_deux_points
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\shell <replaceable>commande
     </replaceable> [ <replaceable>argument</replaceable> ... ]
     </literal>
    </term>

    <listitem>
     <para>
      Identique à <literal>\setshell</literal>, mais le résultat de la
      commande sera ignoré.
     </para>

     <para>
      Exemple&nbsp;:
<programlisting>
\shell command literal_argument :variable ::literal_starting_with_colon
</programlisting></para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect2>

 <refsect2 id="pgbench-builtin-functions">
  <title>Fonctions internes</title>

  <para>
   Les fonctions listées dans <xref linkend="pgbench-functions"/> sont
   construites dans <application>pgbench</application> et peuvent être
   utilisées dans des expressions apparaissant dans <link
   linkend="pgbench-metacommand-set"><literal>\set</literal></link>.
  </para>

   <!-- list pgbench functions in alphabetical order -->
   <table id="pgbench-functions">
    <title>Fonctions pgbench</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Fonction</entry>
       <entry>Type de retour</entry>
       <entry>Description</entry>
       <entry>Exemple</entry>
       <entry>Résultat</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal><function>abs(<replaceable>a</replaceable>)</function></literal></entry>
       <entry>identique à <replaceable>a</replaceable></entry>
       <entry>valeur absolue</entry>
       <entry><literal>abs(-17)</literal></entry>
       <entry><literal>17</literal></entry>
      </row>
      <row>
       <entry><literal><function>debug(<replaceable>a</replaceable>)</function></literal></entry>
       <entry>identique à <replaceable>a</replaceable> </entry>
       <entry>affiche <replaceable>a</replaceable> sur <systemitem>stderr</systemitem>,
        et renvoie <replaceable>a</replaceable></entry>
       <entry><literal>debug(5432.1)</literal></entry>
       <entry><literal>5432.1</literal></entry>
      </row>
      <row>
       <entry><literal><function>double(<replaceable>i</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>convertie en un double</entry>
       <entry><literal>double(5432)</literal></entry>
       <entry><literal>5432.0</literal></entry>
      </row>
      <row>
       <entry><literal><function>greatest(<replaceable>a</replaceable> [, <replaceable>...</replaceable> ] )</function></literal></entry>
       <entry>double si <replaceable>a</replaceable> est double, sinon integer</entry>
       <entry>valeur la plus large parmi les arguments</entry>
       <entry><literal>greatest(5, 4, 3, 2)</literal></entry>
       <entry><literal>5</literal></entry>
      </row>
      <row>
       <entry><literal><function>int(<replaceable>x</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>convertie en int</entry>
       <entry><literal>int(5.4 + 3.8)</literal></entry>
       <entry><literal>9</literal></entry>
      </row>
      <row>
       <entry><literal><function>least(<replaceable>a</replaceable> [, <replaceable>...</replaceable> ] )</function></literal></entry>
       <entry>double si <replaceable>a</replaceable> est double, sinon integer</entry>
       <entry>plus petite valeur parmi les arguments</entry>
       <entry><literal>least(5, 4, 3, 2.1)</literal></entry>
       <entry><literal>2.1</literal></entry>
      </row>
      <row>
       <entry><literal><function>pi()</function></literal></entry>
       <entry>double</entry>
       <entry>valeur de la constante PI</entry>
       <entry><literal>pi()</literal></entry>
       <entry><literal>3.14159265358979323846</literal></entry>
      </row>
      <row>
       <entry><literal><function>random(<replaceable>lb</replaceable>, <replaceable>ub</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>entier aléatoire uniformément distribué parmi <literal>[lb, ub]</literal></entry>
       <entry><literal>random(1, 10)</literal></entry>
       <entry>un entier entre <literal>1</literal> et <literal>10</literal></entry>
      </row>
      <row>
       <entry><literal><function>random_exponential (<replaceable>lb</replaceable>, <replaceable>ub</replaceable>, <replaceable>parameter</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>entier aléatoire distribué exponentiellement parmi <literal>[lb, ub]</literal>,
              voir ci-dessous</entry>
       <entry><literal>random_exponential(1, 10, 3.0)</literal></entry>
       <entry>un entier entre <literal>1</literal> et <literal>10</literal></entry>
      </row>
      <row>
       <entry><literal><function>random_gaussian (<replaceable>lb</replaceable>, <replaceable>ub</replaceable>, <replaceable>parameter</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>entier aléatoire distribué de façon gaussienne parmi <literal>[lb, ub]</literal>,
              voir ci-dessus</entry>
       <entry><literal>random_gaussian(1, 10, 2.5)</literal></entry>
       <entry>un entier entre <literal>1</literal> et <literal>10</literal></entry>
      </row>
      <row>
       <entry><literal><function>sqrt(<replaceable>x</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>racine carrée</entry>
       <entry><literal>sqrt(2.0)</literal></entry>
       <entry><literal>1.414213562</literal></entry>
      </row>
     </tbody>
     </tgroup>
   </table>

   <para>
    La fonction <literal>random</literal> génère des valeurs en utilisant une
    distribution uniforme, autrement dit toutes les valeurs sont dans
    l'intervalle spécifiée avec une probabilité identique. Les fonctions
    <literal>random_exponential</literal> et
    <literal>random_gaussian</literal> requièrent un paramètre supplémentaire
    de type double qui détermine le contour précis de cette distribution.
   </para>

   <itemizedlist>
    <listitem>
     <para>
      Pour une distribution exponentielle,
      <replaceable>parameter</replaceable> contrôle la distribution en
      tronquant une distribution exponentielle en décroissance rapide à
      <replaceable>parameter</replaceable>, puis en projetant le résultant sur
      des entiers entre les limites. Pour être précis&nbsp;:
<literallayout>
f(x) = exp(-parameter * (x - min) / (max - min + 1)) / (1 - exp(-parameter))
</literallayout>
      Puis la valeur <replaceable>i</replaceable> entre les valeurs
      <replaceable>min</replaceable> et <replaceable>max</replaceable>, en les
      incluant, est récupérée avec la probabilité&nbsp;:
      <literal>f(x) - f(x + 1)</literal>.
     </para>

     <para>
      Intuitivement, plus <replaceable>parameter</replaceable> est grand, plus
      les valeurs fréquentes proches de <replaceable>min</replaceable> sont
      accédées et moins les valeurs fréquentes proches de
      <replaceable>max</replaceable> sont accédées. Plus
      <replaceable>parameter</replaceable> est proche de 0, plus la
      distribution d'accès sera plate (uniforme). Une grosse approximation de
      la distribution est que les 1% de valeurs les plus fréquentes, dans
      l'intervalle, proches de <replaceable>min</replaceable>, sont ramenées à
      <replaceable>parameter</replaceable>% du temps. La valeur de
      <replaceable>parameter</replaceable> doit être strictement positive.
     </para>
    </listitem>

    <listitem>
     <para>
      Pour une distribution gaussienne, l'intervalle correspond à une
      distribution normale standard (la courbe gaussienne classique en forme
      de coche) tronqué à <literal>-parameter</literal> sur la gauche et à
      <literal>+parameter</literal> sur la droite. Les valeurs au milieu de
      l'intervalle Les valeurs au milieu de l'intervalle sont plus
      susceptibles d'être sélectionnées. Pour être précis, si
      <literal>PHI(x)</literal> est la fonction de distribution cumulative de
      la distribution normale standard, avec une moyenne <literal>mu</literal>
      définie comme <literal>(max + min) / 2.0</literal>, avec
<literallayout>
f(x) = PHI(2.0 * parameter * (x - mu) / (max - min + 1)) /
       (2.0 * PHI(parameter) - 1)
</literallayout>
      alors la valeur value <replaceable>i</replaceable> entre
      <replaceable>min</replaceable> et <replaceable>max</replaceable>
      (inclus) est sélectionnée avec une probabilité&nbsp;: <literal>f(i +
      0.5) - f(i - 0.5)</literal>. Intuitivement, plus
      <replaceable>parameter</replaceable> est grand, et plus les valeurs
      fréquentes proches du centre de l'intervalle sont sélectionnées, et
      moins les valeurs fréquentes proches des bornes
      <replaceable>min</replaceable> et <replaceable>max</replaceable>.
      Environ 67% des valeurs sont sélectionnées à partir du centre
      <literal>1.0 / parameter</literal>, c'est une valeur relative
      <literal>0.5 / parameter</literal> autour de la moyenne, et 95% dans le
      centre <literal>2.0 / parameter</literal>, c'est une valeur relative
      <literal>1.0 / parameter</literal> autour de la moyenne&nbsp;; par
      exemple, si <replaceable>parameter</replaceable> vaut 4.0, 67% des
      valeurs sont sélectionnées à partir du quart centre (1.0 / 4.0) de
      l'intervalle (ou à partir de <literal>3.0 / 8.0</literal> jusqu'à
      <literal>5.0 / 8.0</literal>) et 95% à partir du centre de la moitié
      (<literal>2.0 / 4.0</literal>) de l'intervalle (deuxième et troisième
      quarts). Le <replaceable>parameter</replaceable> minimale est 2.0 pour
      les performances de la transformation Box-Muller.
     </para>
    </listitem>
   </itemizedlist>

   <para>
   En tant qu'exemple, la définition complète de la construction
   de la transaction style TPC-B est&nbsp;:

<programlisting>
\set aid random(1, 100000 * :scale)
\set bid random(1, 1 * :scale)
\set tid random(1, 10 * :scale)
\set delta random(-5000, 5000)
BEGIN;
UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
END;
</programlisting>
   Ce script autorise chaque itération de la transaction à référencer
   des lignes différentes, sélectionnées aléatoirement.
   (Cet exemple montre aussi pourquoi il est important que chaque session
   cliente ait ses propres variables &mdash; sinon elles n'affecteront
   pas les différentes lignes de façon indépendantes.
  </para>

 </refsect2>

 <refsect2>
  <title>Connexion par transaction</title>

  <para>
   Avec l'option <option>-l</option> (mais sans l'option
   <option>--aggregate-interval</option>),
   <application>pgbench</application> va écrire des informations sur
   chaque transaction dans un fichier journal.
   <filename><replaceable>prefix</replaceable>.<replaceable>nnn</replaceable></filename>,
   où <replaceable>prefix</replaceable> vaut par défaut <literal>pgbench_log</literal>, et
   <replaceable>nnn</replaceable> est le PID du processus 
   <application>pgbench</application>.
   Le prefixe peut être changé en utilisant l'option <option>--log-prefix</option>.	  
   Si l'option <option>-j</option> est positionnée à 2 ou plus,
   créant plusieurs processus de travail (<foreignphrase>worker</foreignphrase>),
   chacun aura son propre fichier journal.
   Le premier worker utilisera le même nom pour son fichier journal
   que dans le cas d'un seul processus.
   Les fichiers journaux supplémentaires s'appelleront
   <filename><replaceable>prefix</replaceable>.<replaceable>nnn</replaceable>.<replaceable>mmm</replaceable></filename>,
   où <replaceable>mmm</replaceable> est un numéro de séquence,
   identifiant chaque worker supplémentaire, en commençant à 1.
  </para>

  <para>
   Le format du journal est le suivant&nbsp;:

<synopsis>
<replaceable>id_client</replaceable> <replaceable>no_transaction</replaceable> <replaceable>temps</replaceable> <replaceable>no_script</replaceable> <replaceable>time_epoch</replaceable> <replaceable>time_us</replaceable> <optional> <replaceable>schedule_lag</replaceable> </optional>
</synopsis>

   où 
   <replaceable>client_id</replaceable> indique quelle session client a exécuté la transaction,
   <replaceable>transaction_no</replaceable> compte combien de transactions ont été exécutées
   par cette session,
   <replaceable>temps</replaceable> est la durée totale de la
   transaction en micro secondes, <replaceable>no_script</replaceable>
   identifie quel fichier script est utilisé (très utile lorsqu'on
   utilise plusieurs scripts avec l'option <option>-f</option> ou
   <option>-b</option>), et
   <replaceable>time_epoch</replaceable>/<replaceable>time_us</replaceable>
   est un horodatage unix avec un décalage en micro secondes (utilisable pour
   créer un horodatage ISO 8601 avec des secondes fractionnées) qui montre
   à quel moment la transaction s'est terminée.

   Le champ <replaceable>schedule_lag</replaceable> est la différence
   entre la date de début planifiée de la transaction et la date de
   début effective de la transaction, en micro secondes.
   Il est présent uniquement lorsque l'option <option>--rate</option> est
   utilisée.
   Quand les options <option>--rate</option> et <option>--latency-limit</option>
   sont utilisées en même temp, le champ <replaceable>time</replaceable> pour
   une transaction ignorée sera rapportée en tant que <literal>skipped</literal>.

   Le dernier champ <replaceable>skipped_transactions</replaceable>
   rapporte le nombre de transactions ignorées car elles avaient trop de
   retard par rapport à la planification.
   Il est uniquement présent lorsque les deux options
   <option>--rate</option> et <option>--latency-limit</option>
   sont utilisées.
  </para>

  <para>
   Ci-dessous un extrait du fichier journal généré avec un seul client&nbsp;:
<screen>
0 199 2241 0 1175850568 995598
0 200 2465 0 1175850568 998079
0 201 2513 0 1175850569 608
0 202 2038 0 1175850569 2663
</screen>

   Un autre exemple avec les options <literal>--rate=100</literal> et
   <literal>--latency-limit=5</literal> (vous noterez
   la colonne supplémentaire <replaceable>schedule_lag</replaceable> )&nbsp;:
<screen>
0 81 4621 0 1412881037 912698 3005
0 82 6173 0 1412881037 914578 4304
0 83 skipped 0 1412881037 914578 5217
0 83 skipped 0 1412881037 914578 5099
0 83 4722 0 1412881037 916203 3108
0 84 4142 0 1412881037 918023 2333
0 85 2465 0 1412881037 919759 740
</screen>
   Dans cet exemple, la transaction 82 est en retard, elle affiche une
   latence (6,173 ms) supérieure à la limite de 5 ms.
   Les deux transactions suivantes ont été ignorées car elles avaient
   déjà du retard avant même le début de la transaction.
  </para>

  <para>
   Dans le cas où on lance un test long, sur du matériel qui peut
   supporter un grand nombre de transactions, le fichier journal
   peut devenir très volumineux.
   L'option <option>--sampling-rate</option> peut être utilisée pour
   journaliser seulement un extrait aléatoire des transactions
   effectuées.
  </para>
 </refsect2>

 <refsect2>
  <title>Agrégation de la journalisation</title>

  <para>
   Avec l'option <option>--aggregate-interval</option>, les fichiers
   journaux utilisent un format quelque peu différent&nbsp;:

<synopsis>
<replaceable>début_intervalle</replaceable> <replaceable>nombre_de_transations</replaceable> <replaceable>somme_latence</replaceable> <replaceable>somme_latence_2</replaceable> <replaceable>latence_minimum</replaceable> <replaceable>latence_maximum</replaceable> <optional> <replaceable>somme_retard</replaceable> <replaceable>somme_retard_2</replaceable> <replaceable>retard_min</replaceable> <replaceable>retard_max</replaceable> <optional> <replaceable>transactions_ignorées</replaceable> </optional> </optional>
</synopsis>

   Où <replaceable>début_intervalle</replaceable> est le début de
   l'intervalle (au format horodatage unix),
   <replaceable>nombre_de_transations</replaceable>  est le nombre de
   transactions dans l'intervalle,
   <replaceable>somme_latence</replaceable> est le cumul des latences
   (ce qui vous permet de déduire facilement la latence moyenne).
   Les deux champs suivants sont très utiles pour calculer la variance.
   En effet, <replaceable>somme_latence</replaceable> est la somme des
   latences, alors que <replaceable>somme_latence_2</replaceable> est la
   somme des latences au carré. Les deux derniers champs sont
   <replaceable>latence_min</replaceable>, la latence minimum dans
   l'intervalle, et <replaceable>latence_max</replaceable>, la latence
   maximum dans l'intervalle. Une transaction est comptée dans un
   intervalle à partir du moment où elle a été validée.
   Les derniers champs <replaceable>somme_retard</replaceable>,
   <replaceable>somme_retard_2</replaceable>,
   <replaceable>retard_min</replaceable>,
   et <replaceable>retard_max</replaceable> sont présents uniquement si
   l'option <option>--rate</option> a été spécifiée.
   Le tout dernier champ,
   <replaceable>transactions_ignorées</replaceable>, est présent
   uniquement si l'option <option>--latency-limit</option> a aussi été
   utilisée.
   Ils sont calculés sur le delta entre le moment où la transaction a
   pu commencer par rapport au moment la dernière s'est terminée,
   précisément la différence pour chaque transaction entre le moment où
   il était prévu qu'elle commence et le moment où elle a effectivement
   pu commencer.
  </para>

  <para>
   Voici un exemple de sortie&nbsp;:
<screen>
1345828501 5601 1542744 483552416 61 2573
1345828503 7884 1979812 565806736 60 1479
1345828505 7208 1979422 567277552 59 1391
1345828507 7685 1980268 569784714 60 1398
1345828509 7073 1979779 573489941 236 1411
</screen></para>

  <para>
   Notez que tandis que le fichier journal brut (c'est-à-dire non
   agrégé) contient une référence des fichiers scripts personnalisés, 
   le fichier journal agrégé n'en contient pas. De ce fait, si vous
   avez besoin des données de vos scripts, vous devrez agréger ces
   données vous-même.  
  </para>

 </refsect2>

 <refsect2>
  <title>Latences par requête</title>

  <para>
   Avec l'option <option>-r</option>, <application>pgbench</application>
   collecte le temps de transaction écoulé pour chaque requête,
   exécutée par chaque client.
   Une fois que le test de performance est terminé, il rapporte une
   moyenne de ces valeurs, référencée comme la latence de chaque requête.
  </para>

  <para>
   Pour le script par défaut, le résultat aura la forme suivante&nbsp;:
<screen>
starting vacuum...end.
transaction type: &lt;builtin: TPC-B (sort of)&gt;
 scaling factor: 1
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
latency average = 15.844 ms
latency stddev = 2.715 ms
tps = 618.764555 (including connections establishing)
tps = 622.977698 (excluding connections establishing)
script statistics:
 - statement latencies in milliseconds:
        0.002  \set aid random(1, 100000 * :scale)
        0.005  \set bid random(1, 1 * :scale)
        0.002  \set tid random(1, 10 * :scale)
        0.001  \set delta random(-5000, 5000)
        0.326  BEGIN;
        0.603  UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
        0.454  SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
        5.528  UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
        7.335  UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
        0.371  INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
        1.212  END;
</screen>
  </para>

  <para>
   Les moyennes seront rapportées séparément si plusieurs scripts ont
   été spécifiés.
  </para>

  <para>
   Notez que la collecte supplémentaire des informations de
   chronométrage nécessaires pour la récupération de la latence par
   transaction induit une certaine surcharge.
   En effet, cela va réduire la vitesse moyenne calculée pour l'exécution
   des transactions et réduire le taux calculé des TPS.
   Le ralentissement varie de manière significative selon la
   plateforme et le matériel qui est utilisé pour le test.
   Comparer la moyenne des valeurs de TPS avec et sans l'intégration
   de la latence dans le test est une bonne manière de se rendre compte
   si la surcharge induite par le chronométrage est importante ou pas.
  </para>
 </refsect2>

 <refsect2>
  <title>Bonnes pratiques</title>

  <para>
   Il facile de se retrouver à utiliser
   <application>pgbench</application> et ne produire finalement que
   des résultats complètement insignifiants&nbsp;!
   Voici quelques conseils pour vous aider à récupérer des résultats
   pertinents.
  </para>

  <para>
   Tout d'abord, ne pensez <emphasis>jamais</emphasis> qu'un test ne
   peut durer que quelques secondes.
   Utilisez l'option <option>-t</option> ou <option>-T</option>
   pour vous assurer que le test dure au moins quelques minutes, de
   façon à lisser le bruit.
   Dans certains cas, il vous faudra des heures pour récupérer des
   valeurs reproductibles.
   Une bonne idée, lancez plusieurs fois votre test, de manière à vous
   rendre compte si les chiffres que vous obtenez sont ou pas
   reproductibles.
  </para>

  <para>
   Pour le scénario de test par défaut typé TPC-B, l'initialisation
   du facteur d'échelle (<option>-s</option>) devrait être au moins
   aussi grand que le nombre maximum de clients que vous avez
   l'intention de tester (<option>-c</option>)&nbsp;; sinon vous allez
   principalement tester la contention induite par les mises à jour.
   il n'y a que <option>-s</option> lignes dans la table
   <structname>pgbench_branches</structname>, et chaque transaction
   veut mettre à jour l'une de ces lignes, donc si la valeur de
   <option>-c</option> est supérieure à la valeur de <option>-s</option>,
   indubitablement, il en résultera de nombreuses transactions bloquées
   en attente de la fin d'autres transactions.
  </para>

  <para>
   Le moment où les tables ont été créées va sensiblement influencer le
   résultat du scénario de test par défaut, compte tenu de l'accumulation
   des lignes et espaces morts dans les tables lors du test.
   Pour comprendre les résultats, vous devriez garder une trace du
   nombre total de mises à jour ainsi que le moment où l'opération
   de VACUUM a lieu. Si la tâche autovacuum est active, il peut en
   résulter des variations imprévisibles dans les performances mesurées.
  </para>

  <para>
   Une limitation de <application>pgbench</application> est qu'il peut
   lui-même devenir le goulet d'étranglement lorsqu'il essaye de tester
   un grand nombre de sessions clientes.
   Cela peut être attenué en utilisant <application>pgbench</application>
   depuis une machine différente de la machine où se trouve la base
   de données, bien qu'une faible latence sur le réseau soit dans ce cas
   essentielle.
   Il peut même être utile de lancer plusieurs fois
   <application>pgbench</application> de manière concurrente, depuis
   plusieurs machines clientes vers le même serveur de base de données.
  </para>
 </refsect2>
 </refsect1>
</refentry>
