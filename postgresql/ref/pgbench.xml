<?xml version="1.0" encoding="UTF-8"?>
<refentry id="pgbench">
 <indexterm zone="pgbench">
  <primary>pgbench</primary>
 </indexterm>

 <refmeta>
  <refentrytitle><application>pgbench</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>pgbench</refname>
  <refpurpose>Réalise un test de benchmark pour
   <productname>PostgreSQL</productname></refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <cmdsynopsis>
   <command>pgbench</command>
   <arg choice="plain"><option>-i</option></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>nom_base</replaceable></arg>
  </cmdsynopsis>
  <cmdsynopsis>
   <command>pgbench</command>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>nom_base</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <para>
   <application>pgbench</application> est un programme pour réaliser simplement des
   tests de performance (<foreignphrase>benchmark</foreignphrase>)
   sur <productname>PostgreSQL</productname>.  Il
   exécute la même séquence de commandes SQL en continu, potentiellement
   avec plusieurs sessions concurrentes puis calcule le taux de
   transactions moyen (en transactions par secondes).
   Par défaut, <application>pgbench</application> teste un scénario
   vaguement basé sur TPC-B, impliquant cinq commandes <command>SELECT</command>,
   <command>UPDATE</command> et <command>INSERT</command> par
   transaction.
   Toutefois, il est facile de tester d'autres scénarios en écrivant
   vos propres scripts de transactions.
  </para>

  <para>
   Une sortie classique de <application>pgbench</application> ressemble
   à ceci&nbsp;:

   <screen>
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
latency average = 11.013 ms
latency stddev = 7.351 ms
initial connection time = 45.758 ms
tps = 896.967014 (without initial connection time)
   </screen>

   Les six premières lignes rapportent quelques-uns des paramètres
   les plus importants qui ont été définis.
   La ligne suivante remonte le nombre de transactions réalisées et
   prévues. (La seconde rapporte juste le ratio entre le nombre de
   clients et le nombre de transactions par client).
   Ils seront équivalents à moins que l'exécution ait échoué avant la fin.
   (Avec le mode <option>-T</option>, seul le nombre réel de transactions
   est affiché.)
   La dernière ligne indique le nombre de transactions par seconde.
  </para>

  <para>
   Les transactions de ce test, proche de TPC-B, nécessitent d'avoir défini
   au préalable quelques tables spécifiques.
   <application>pgbench</application> devrait être utilisé avec l'option
   <option>-i</option> (initialisation) pour créer et remplir ces tables.
   (Si vous testez un script personnalisé, vous n'aurez pas besoin de
   cette étape, mais vous aurez besoin de mettre en place tout ce dont
   votre script aura besoin).
   Une initialisation ressemble à cela&nbsp;:

   <programlisting>
pgbench -i <optional> <replaceable>autres-options</replaceable>
</optional> <replaceable>nom_base</replaceable>
   </programlisting>

   où <replaceable>nom_base</replaceable> est le nom de la base de données
   pré-existante sur laquelle on conduit les tests. (Vous aurez aussi
   probablement besoin des options <option>-h</option>,
   <option>-p</option> et/ou <option>-U</option> pour spécifier comment
   se connecter au serveur de base de données.)
  </para>

  <caution>
   <para>
    <literal>pgbench -i</literal> crée quatre tables nommées
    <structname>pgbench_accounts</structname>,
    <structname>pgbench_branches</structname>,
    <structname>pgbench_history</structname> et
    <structname>pgbench_tellers</structname>,
    détruisant toute table qui porterait l'un de ces noms.
    Attention à utiliser une autre base de données si vous avez
    des tables qui portent ces noms&nbsp;!
   </para>
  </caution>

  <para>
   Par défaut, avec un facteur d'échelle de 1, les tables contiennent
   initialement les nombres de lignes suivants&nbsp;:
   <screen>
table                   # de lignes
---------------------------------
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0
   </screen>
   Vous pouvez (et, dans la plupart des cas, devriez) augmenter le nombre de
   lignes en utilisant l'option <option>-s</option>. Le facteur de remplissage
   <option>-F</option> peut aussi être utilisée à cet effet.
  </para>

  <para>
   Une fois la mise en place terminée, vous pouvez
   lancer vos benchmarks sans inclure l'option <option>-i</option>,
   c'est-à-dire&nbsp;:

   <programlisting>
pgbench <optional> <replaceable>options</replaceable> </optional>
<replaceable>nom_base</replaceable>
   </programlisting>

   Dans presque tous les cas, vous allez avoir besoin de certaines
   options pour rendre vos tests plus pertinents.
   Les options les plus importantes sont&nbsp;:
   <option>-c</option> (le nombre de clients),
   <option>-t</option> (le nombre de transactions),
   <option>-T</option> (l'intervalle de temps)
   et <option>-f</option> (le script à lancer).
   Vous trouverez ci-dessous toutes les options disponibles.
  </para>
 </refsect1>

 <refsect1>
  <title>Options</title>

  <para>
   La partie suivante est divisée en trois sous-parties&nbsp;: des options
   différentes sont utilisées pendant l'initialisation et pendant les tests ;
   certaines options sont utiles dans les deux cas.
  </para>

  <refsect2 id="pgbench-init-options">
   <title>Options d'initialisation</title>

   <para>
    Pour réaliser l'initialisation, <application>pgbench</application>
    accepte les arguments suivants en ligne de commande&nbsp;:

    <variablelist>

     <varlistentry>
      <term><replaceable class="parameter">dbname</replaceable></term>
      <listitem>
       <para>
        Indique le nom de la base à tester. Si elle n'est pas spécifier, la
        variable d'environnement <envar>PGDATABASE</envar> est utilisée. Si
        elle n'est pas configurée, le nom d'utilisateur indiqué pour la
        connexion est utilisé.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-i</option></term>
      <term><option>--initialize</option></term>
      <listitem>
       <para>
        Nécessaire pour passer en mode initialisation.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-I <replaceable>init_steps</replaceable></option></term>
      <term><option>--init-steps=<replaceable>init_steps</replaceable></option></term>
      <listitem>
       <para>
        N'effectue qu'une partie des étapes d'initialisation habituelles.
        <replaceable>init_steps</replaceable> spécifie les étapes
        d'initialisation à exécuter, à raison d'un caractère par étape.
        Chaque étape est appelée dans l'ordre indiqué.
        La valeur par défaut est <literal>dtgvp</literal>. Voici la liste
        des différentes étapes disponibles&nbsp;:

        <variablelist>
         <varlistentry>
          <term><literal>d</literal> (Détruit)</term>
          <listitem>
           <para>
            Supprime toutes les tables <application>pgbench</application>
            déjà présentes.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>t</literal> (crée Tables)</term>
          <listitem>
           <para>
            Crée les tables utilisées par le scénario
            <application>pgbench</application> standard, à savoir
            <structname>pgbench_accounts</structname>,
            <structname>pgbench_branches</structname>,
            <structname>pgbench_history</structname> et
            <structname>pgbench_tellers</structname>.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>g</literal> ou <literal>G</literal> (génère des données, côté client ou côté serveur)</term>
          <listitem>
           <para>
            Génère des données et les charge dans les tables standards,
            remplaçant toutes les données déjà présentes.
           </para>
           <para>
            Avec <literal>g</literal> (génération de données côté client),
            les données sont générées dans le client <command>pgbench</command>,
            puis envoyées au serveur. Cela utilise une commande <command>COPY</command>
            et consomme beaucoup de bande passante entre le client et le serveur.
            Avec <literal>g</literal>, la trace affiche un message toutes les
            100&nbsp;000 lignes lors de la génération de <structname>pgbench_accounts</structname>.
           </para>
           <para>
            Avec <literal>G</literal> (génération côté serveur), seules de petites
            requêtes sont envoyées depuis le client <command>pgbench</command>,
            et les données sont ensuite générées sur le serveur.
            Aucune bande passante significative n'est nécessaire dans cette variante,
            mais le serveur travaillera plus.
            Avec <literal>G</literal>, la trace n'affichera aucun message de
            progression pendant la génération des données.
           </para>
           <para>
            Par défaut, l'initialisation utilise la génération des données
            côté client (soit <literal>g</literal>).
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>v</literal> (Vacuum)</term>
          <listitem>
           <para>
            Appelle <command>VACUUM</command> sur les tables standards.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>p</literal> (clés Primaires)</term>
          <listitem>
           <para>
            Crée les clés primaires sur les tables standards.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>f</literal> (<foreignphrase>Foreign keys
           </foreignphrase>)</term>
          <listitem>
           <para>
            Crée les contraintes de clés étrangères entre les
            différentes tables standards.
            (Notez que cette étape n'est pas exécutée par défaut.)
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-F</option>
       <replaceable>fillfactor</replaceable></term>
      <term><option>--fillfactor=
       </option><replaceable>fillfactor</replaceable></term>
      <listitem>
       <para>
        Crée les tables <structname>pgbench_accounts</structname>,
        <structname>pgbench_tellers</structname> et
        <structname>pgbench_branches</structname> avec le facteur de
        remplissage (<foreignphrase>fillfactor</foreignphrase>) spécifié.
        La valeur par défaut est 100.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>--no-vacuum</option></term>
      <listitem>
       <para>
        Ne réalise pas de VACUUM après l'initialisation.
        (Cette option supprime l'étape d'initialisation <literal>v</literal>,
        même si elle était précisée dans <option>-I</option>.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-q</option></term>
      <term><option>--quiet</option></term>
      <listitem>
       <para>
        Passe du mode verbeux au mode silencieux, en n'affichant qu'un message
        toutes les 5 secondes. Par défaut, on affiche un message toutes les
        100&nbsp;000 lignes, ce qui engendre souvent plusieurs lignes toutes
        les secondes (particulièrement sur du bon matériel)
       </para>
       <para>
        Ce paramètre n'a pas d'effet si <literal>G</literal> est spécifié
        dans l'option <option>-I</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option>
       <replaceable>scale_factor</replaceable></term>
      <term><option>--scale=</option>
       <replaceable>scale_factor</replaceable></term>
      <listitem>
       <para>
        Multiplie le nombre de lignes générées par le facteur d'échelle
        (<foreignphrase>scale factor</foreignphrase>). Par exemple,
        <literal>-s 100</literal> va créer 10 millions de
        lignes dans la table <structname>pgbench_accounts</structname>. La
        valeur par défaut est 1. Lorsque l'échelle dépasse 20&nbsp;000, les
        colonnes utilisées pour contenir les identifiants de compte (colonnes
        <structfield>aid</structfield>) vont être converties en grands entiers
        (<type>bigint</type>), de manière à être suffisamment grandes pour
        contenir l'espace des identifiants de compte.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--foreign-keys</option></term>
      <listitem>
       <para>
        Crée des contraintes de type clé étrangère entre les tables standards.
        (Cette option ajoute l'étape d'initialisation <literal>f</literal>,
        si elle n'est pas déjà présente.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--index-tablespace=<replaceable>index_tablespace</replaceable>
       </option></term>
      <listitem>
       <para>
        Crée un index dans le tablespace spécifié plutôt que dans le
        tablespace par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--partition-method=<replaceable>NOM</replaceable></option></term>
      <listitem>
       <para>
        Crée une table partitionnée <literal>pgbench_accounts</literal>
        par la méthode <replaceable>NOM</replaceable>.
        Les valeurs attendues sont <literal>range</literal> ou <literal>hash</literal>.
        Cette option nécessite que <option>--partitions</option> soit différente
        de zéro. Sans précision, le défaut est <literal>range</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--partitions=<replaceable>NUM</replaceable></option></term>
      <listitem>
       <para>
        Crée une table partitionnée <literal>pgbench_accounts</literal>
        avec <replaceable>NUM</replaceable> partitions de taille à peu près
        égale pour le nombre de clients indiqué par l'échelle.
        Le défaut est <literal>0</literal>, ce qui signifie qu'il n'y a pas de partitionnement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--tablespace=<replaceable>tablespace</replaceable>
       </option></term>
      <listitem>
       <para>
        Crée une table dans le tablespace spécifié plutôt que dans le
        tablespace par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--unlogged-tables</option></term>
      <listitem>
       <para>
        Crée toutes les tables en tant que tables non journalisées
        (<foreignphrase>unlogged tables</foreignphrase>)
        plutôt qu'en tant que tables permanentes.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

  </refsect2>

  <refsect2 id="pgbench-run-options">
   <title>Options des benchmarks</title>

   <para>
    Pour réaliser un benchmark <application>pgbench</application>
    accepte les arguments suivants en ligne de commande&nbsp;:

    <variablelist>

     <varlistentry>
      <term><option>-b</option> <replaceable>nom_script[@poids]</replaceable></term>
      <term><option>--builtin</option>=<replaceable>nom_script[@poids]</replaceable></term>
      <listitem>
       <para>
        Ajoute le script interne spécifié à la liste des scripts à exécuter.
        Les scripts internes disponibles sont <literal>tpcb-like</literal>,
        <literal>simple-update</literal> et <literal>select-only</literal>.
        L'utilisation des préfixes non ambigus des noms de scripts internes
        est acceptée. En utilisant le nom spécial <literal>list</literal>, la
        commande affiche la liste des scripts internes, puis quitte
        immédiatement.
       </para>
       <para>
        En option, il est possibl d'écrire un poids en entier après
        <literal>@</literal> pour ajuster la probabilité de sélectionner ce
        script plutôt que les autres. Le poids par défaut est de 1. Voir
        ci-dessous pour les détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-c</option> <replaceable>clients</replaceable></term>
      <term><option>--client=
       </option><replaceable>clients</replaceable></term>
      <listitem>
       <para>
        Nombre de clients simulés, c'est-à-dire le nombre
        de sessions concurrentes sur la base de données.
        La valeur par défaut est à 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-C</option></term>
      <term><option>--connect</option></term>
      <listitem>
       <para>
        Établit une nouvelle connexion pour chaque transaction, plutôt
        que de ne le faire qu'une seule fois par session cliente.
        C'est une option très utile pour mesurer la surcharge engendrée
        par la connexion.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-d</option></term>
      <term><option>--debug</option></term>
      <listitem>
       <para>
        Affiche les informations de debug.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-D</option> <replaceable>variable</replaceable>
       <literal>=</literal><replaceable>value</replaceable></term>
      <term><option>--define=</option><replaceable>variable</replaceable>
       <literal>=</literal><replaceable>value</replaceable></term>
      <listitem>
       <para>
        Définit une variable à utiliser pour un script personnalisé
        Voir ci-dessous pour plus de détails.
        Il est possible d'utiliser plusieurs fois l'option <option>-D</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-f</option> <replaceable>nom_fichier[@poids]</replaceable></term>
      <term><option>--file=</option><replaceable>nom_fichier[@poids]</replaceable></term>
      <listitem>
       <para>
        Ajoute un script de transactions nommé
        <replaceable>nom_fichier</replaceable> à la liste des scripts à
        exécuter.
       </para>
       <para>
        En option, il est possible d'écrire un poids sous la forme d'un entier
        après le symbole <literal>@</literal> pour ajuster la probabilité de
        sélectionner ce script plutôt qu'unautre. Le poids par défaut est de
        1. (Pour utiliser un nom de fichier incluant un caractère
        <literal>@</literal>, ajoutez un poids pour qu'il n'y ait pas
        d'ambiguité, par exemple <literal>filen@me@1</literal>.) Voir
        ci-dessous pour les détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-j</option> <replaceable>threads</replaceable></term>
      <term><option>--jobs=</option>
       <replaceable>threads</replaceable></term>
      <listitem>
       <para>
        Nombre de processus utilisés dans
        <application>pgbench</application>.
        Utiliser plus d'un thread peut être utile sur des machines
        possédant plusieurs cœurs.
        Les clients sont distribués de la manière la plus uniforme possible
        parmi les threads.
        La valeur par défaut est 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-l</option></term>
      <term><option>--log</option></term>
      <listitem>
       <para>
        Rapporte les informations sur chaque transaction dans un fichier
        journal.
        Voir ci-dessous pour plus de détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-L</option> <replaceable>limite</replaceable></term>
      <term><option>--latency-limit=</option><replaceable>limite</replaceable></term>
      <listitem>
       <para>
        Les transactions durant plus de <replaceable>limite</replaceable> millisecondes
        sont comptabilisée et rapportées séparément en tant que
        <firstterm>late</firstterm>.
       </para>
       <para>
        Lorsqu'un bridage est spécifié(<option>--rate=... </option>),
        les transactions qui accusent un retard sur la planification supérieur à
        <replaceable>limite</replaceable> millisecondes, et celles
        qui n'ont aucune chance de respecter la limite de latence
        ne sont pas du tout envoyées au serveur.
        Elles sont comptabilisées et rapportées séparément en tant que
        <firstterm>skipped</firstterm> (ignorées).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-M</option>
       <replaceable>querymode</replaceable></term>
      <term><option>--protocol=</option>
       <replaceable>querymode</replaceable></term>
      <listitem>
       <para>
        Protocole à utiliser pour soumettre des requêtes au serveur&nbsp;:
        <itemizedlist>
         <listitem>
          <para><literal>simple</literal>&nbsp;: utilisation du protocole
           de requêtes standards.</para>
         </listitem>
         <listitem>
          <para><literal>extended</literal>&nbsp;: utilisation du protocole
           de requête étendu.</para>
         </listitem>
         <listitem>
          <para><literal>prepared</literal>&nbsp;: utilisation du protocole
           de requête étendu avec instructions préparées.</para>
         </listitem>
        </itemizedlist>

        Comme dans le mode <literal>prepared</literal>,
        <application>pgbench</application> réutilise le résultat de l'analyse
        pour la deuxième itération et les suivantes,
        <application>pgbench</application> s'exécute plus rapidement dans le
        mode <literal>prepared</literal> que dans les autres modes.
       </para>
       <para>
        Par défaut, le protocole de requête standard est utilisé
        (voir <xref linkend="protocol"/> pour plus d'informations).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>--no-vacuum</option></term>
      <listitem>
       <para>
        Ne réalise pas de VACUUM avant de lancer le test.
        Cette option est <emphasis>nécessaire</emphasis> si vous lancez
        un scénario de test personnalisé qui n'utilise pas les tables
        standards <structname>pgbench_accounts</structname>,
        <structname>pgbench_branches</structname>, <structname>
         pgbench_history</structname> et <structname>pgbench_tellers
        </structname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-N</option></term>
      <term><option>--skip-some-updates</option></term>
      <listitem>
       <para>
        Exécute le script interne simple-update. Raccourci pour
        <option>-b simple-update</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-P</option> <replaceable>sec</replaceable></term>
      <term><option>--progress=</option>
       <replaceable>sec</replaceable></term>
      <listitem>
       <para>
        Affiche un rapport de progression toutes les
        <replaceable>sec</replaceable> secondes.
        Ce rapport inclut la durée du test, le nombre de
        transactions par seconde depuis le dernier rapport et la
        latence moyenne des transactions, ainsi que la déviation
        depuis le dernier rapport.
        Avec le bridage (option <option>-R</option>), la latence est calculée
        en fonction de la date de démarrage ordonnancée de la transaction et non
        de son temps de démarrage réel, donc elle inclut aussi la latence
        moyenne du temps d'ordonnancement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-r</option></term>
      <term><option>--report-latencies</option></term>
      <listitem>
       <para>
        Rapporte la latence moyenne par instruction (temps d'exécution
        du point de vue du client) de chaque commande après la fin du
        benchmark.
        Voir ci-dessous pour plus de détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-R</option> <replaceable>rate</replaceable></term>
      <term><option>--rate=</option><replaceable>rate</replaceable></term>
      <listitem>
       <para>
        Exécute les transactions en visant le débit spécifié,
        au lieu d'aller le plus vite possible (le défaut).
        Le débit est donné en transactions par seconde.
        Si le débit visé est supérieur au maximum possible, la
        limite de débit n'aura aucune influence sur le résultat.
       </para>
       <para>
        Pour atteindre ce débit, les transactions sont ordonnancées avec
        une distribution suivant une loi de Poisson.
        La date de démarrage prévue se calcule depuis le moment où le client a
        démarré et pas depuis le moment où la dernière transaction s'est achevée.
        Cette approche signifie que, si une transaction
        dépasse sa date de fin prévue, un rattrapage est encore possible
        pour les suivantes.
       </para>
       <para>
        Lorsque le bridage est actif, la latence de la transaction rapportée en
        fin de test est calculée à partir des dates de démarrage ordonnancées,
        c'est-à-dire qu'elle inclut le temps où chaque transaction attend
        que la précédente se termine.
        Le temps d'attente est appelé temps de latence d'ordonnancement,
        et ses valeurs moyenne et maximum sont rapportées séparément.
        La latence de transaction par rapport au temps de démarrage réel,
        c'est-à-dire le temps d'exécution de la transaction
        dans la base, peut être récupérée en soustrayant le temps de
        latence d'ordonnancement à la latence précisée dans les journaux.
       </para>

       <para>
        Si l'option <option>--latency-limit</option> est utilisée avec
        l'option  <option>--rate</option>, une transaction peut avoir
        une telle latence qu'elle serait déjà supérieure à limite de
        latence lorsque la transaction précédente se termine, car la
        latence est calculée au moment de la date de démarrage planifiée.
        Les transactions concernées ne sont pas envoyées à l'instance,
        elles sont complètement ignorées et comptabilisées séparément.
       </para>

       <para>
        Une latence de planification élevée est une indication
        que le système n'arrive pas à traiter les transactions à la vitesse
        demandée, avec les nombres de clients et threads indiqués.
        Lorsque le temps moyen d'exécution est plus important que
        l'intervalle prévu entre chaque transaction, les transactions
        vont prendre du retard une-à-une, et la latence de
        planification va continuer de croître tout le long de la durée
        du test.
        Si cela se produit, vous devrez réduire le taux de transaction
        que vous avez spécifié.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>scale_factor</replaceable></term>
      <term><option>--scale=</option><replaceable>scale_factor</replaceable></term>
      <listitem>
       <para>
        Affiche le facteur d'échelle dans la sortie de <application>pgbench</application>.
        Avec les tests internes, ce n'est pas nécessaire&nbsp;; le facteur
        d'échelle approprié sera détecté en comptant le nombre de lignes
        dans la table <structname>pgbench_branches</structname>.
        Toutefois, lors de l'utilisation d'un benchmark avec un scénario
        personnalisé (option <option>-f</option>), le facteur
        d'échelle sera affiché à 1 à moins que cette option soit utilisée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-S</option></term>
      <term><option>--select-only</option></term>
      <listitem>
       <para>
        Exécute le script interne select-only. Raccourci pour
        <option>-b select-only</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-t</option>
       <replaceable>transactions</replaceable></term>
      <term><option>--transactions=</option>
       <replaceable>transactions</replaceable></term>
      <listitem>
       <para>
        Nombre de transactions lancées par chaque client.
        La valeur par défaut est 10.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-T</option> <replaceable>seconds</replaceable></term>
      <term><option>--time=</option><replaceable>seconds</replaceable></term>
      <listitem>
       <para>
        Lance le test pour la durée spécifiée en secondes, plutôt que
        pour un nombre fixe de transactions par client.
        Les options <option>-t</option> et <option>-T</option> ne sont
        pas compatibles.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <term><option>--vacuum-all</option></term>
      <listitem>
       <para>
        Réalise un VACUUM sur les quatre tables standards avant de
        lancer le test. Sans l'option <option>-n</option> ou
        <option>-v</option>, <application>pgbench</application> lancera un VACUUM
        sur les tables <structname>pgbench_tellers</structname> et
        <structname>pgbench_branches</structname>, puis tronquera
        <structname>pgbench_history</structname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--aggregate-interval=
        <replaceable>secondes</replaceable></option></term>
      <listitem>
       <para>
        Taille de l'intervalle d'agrégation (en secondes). Ne peut
        être utilisée qu'avec l'option <application>-l</application>.
        Avec cette option, le journal contiendra des résumés par
        intervalle, comme décrit ci-dessous.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--log-prefix=<replaceable>prefix</replaceable></option></term>
      <listitem>
       <para>
        Définit le préfixe des fichiers logs créés par <option>--log</option>.
        Le défaut est <literal>pgbench_log</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--progress-timestamp</option></term>
      <listitem>
       <para>
        Lorsque la progression est affichée (option <option>-P</option>),
        utilise un horodatage de type timestamp (epoch Unix) au lieu d'un
        nombre de secondes depuis le début de l'exécution. L'unité est la
        seconde avec une précision en millisecondes après le point. Ceci
        aide à comparer les traces générées par différents outils.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--random-seed=</option><replaceable>graine</replaceable></term>
      <listitem>
       <para>
        Fournit la graine du générateur de nombres aléatoires, qui produira
        alors une séquence d'états initiaux du générateur, un pour chaque
        thread.
        Les valeurs pour <replaceable>graine</replaceable> peuvent être
        <literal>time</literal> (par défaut, la graine est basée sur l'heure en
        cours), <literal>rand</literal> (utilise une source fortement aléatoire,
        et tombe en échec si aucune n'est disponible), ou une valeur entière
        non signée.
        Le générateur aléatoire est appelé depuis un script
        pgbench explicitement (fonctions <literal>random...</literal>) ou
        implicitement (par exemple l'option <option>--rate</option> l'utilise
        pour planifier les transactions).
        Si elle est mise en place explicitement, la valeur utilisée comme
        graine est affichée sur le terminal.
        N'importe quelle valeur autorisée pour <replaceable>graine</replaceable>
        peut aussi être fournie par la variable d'environnement
        <literal>PGBENCH_RANDOM_SEED</literal>.
        Pour garantir que la graine fournie couvre tous les cas d'usage
        possibles, mettez cette fonction en premier ou utilisez la variable
        d'environnement.
       </para>
       <para>
        Placer cette variable explicitement permet de reproduire un run
        <command>pgbench</command> exactement identique, du moins en ce qui
        concerne les nombres aléatoires.
        Comme l'état du générateur aléatoire est géré par thread,
        <command>pgbench</command> s'exécutera à l'identique s'il y a un client
        par thread et pas de dépendance externe ou par rapport aux données.
        D'un point de vue statistique, reproduire des runs est une mauvaise
        idée, car cela peut masquer la variabilité des performances ou
        améliorer les performances excessivement, par exemple en appelant les
        mêmes pages qu'un run précédent.
        Cependant, ce peut être d'une grande aide pour déboguer, par exemple
        pour reproduire un cas tordu provoquant une erreur. À utiliser
        judicieusement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--sampling-rate=
        <replaceable>rate</replaceable></option></term>
      <listitem>
       <para>
        Taux d'échantillonnage utilisé lors de l'écriture des
        données dans les journaux, afin d'en réduire la quantité.
        Si cette option est utilisée, n'y sera écrite que la proportion
        indiquée des transactions.
        1.0 signifie que toutes les transactions seront journalisées,
        0.05 signifie que 5% de toutes les transactions le seront.
       </para>
       <para>
        Pensez à prendre le taux d'échantillonnage en compte en consultant
        le journal.
        Par exemple, lorsque vous évaluez le nombre de transactions par seconde,
        vous devrez multiplier les nombres en conséquence. (Par exemple,
        avec un taux d'échantillonnage de 0,01, vous n'obtiendrez que 1/100 du
        tps réel).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--show-script</option><replaceable>scriptname</replaceable></term>
      <listitem>
       <para>
        Show the actual code of builtin script <replaceable>scriptname</replaceable>
        on stderr, and exit immediately.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

  </refsect2>

  <refsect2 id="pgbench-common-options">
   <title>Options courantes</title>

   <para>
    <application>pgbench</application> accepte aussi les arguments suivants en
    ligne de commande pour les paramètres de connexion&nbsp;:

    <variablelist>

     <varlistentry>
      <term><option>-h</option>
       <replaceable>hostname</replaceable></term>
      <term><option>--host=</option>
       <replaceable>hostname</replaceable></term>
      <listitem>
       <para>
        Le nom du serveur de base de données
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-p</option>
       <replaceable>port</replaceable></term>
      <term><option>--port=</option>
       <replaceable>port</replaceable></term>
      <listitem>
       <para>
        Le port d'écoute de l'instance sur le serveur de base de données
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-U</option>
       <replaceable>login</replaceable></term>
      <term><option>--username=</option>
       <replaceable>login</replaceable></term>
      <listitem>
       <para>
        Le nom de l'utilisateur avec lequel on se connecte
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-V</option></term>
      <term><option>--version</option></term>
      <listitem>
       <para>
        Affiche la version de <application>pgbench</application>
        puis quitte.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-?</option></term>
      <term><option>--help</option></term>
      <listitem>
       <para>
        Affiche l'aide sur les arguments en ligne de commande de
        <application>pgbench</application> puis quitte.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

  </refsect2>
 </refsect1>

 <refsect1>
  <title>Code de sortie</title>

  <para>
   Une exécution réussie renverra le code statut 0. Un code statut 1 indique
   des problèmes statiques comme des options invalides en ligne de commande.
   Des erreurs lors de l'exécution, comme des erreurs de base de données ou
   des problèmes dans le script, renverront le code statut 2. Dans ce dernier
   cas, <application>pgbench</application> affichera des résultats partiels.
  </para>
 </refsect1>

 <refsect1>
  <title>Environnement</title>

  <variablelist>
   <varlistentry>
    <term><envar>PGDATABASE</envar></term>
    <term><envar>PGHOST</envar></term>
    <term><envar>PGPORT</envar></term>
    <term><envar>PGUSER</envar></term>

    <listitem>
     <para>
      Paramètres de connexion par défaut.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Cet outil, comme la plupart des autres outils
   <productname>PostgreSQL</productname>, utilise les variables
   d'environnement supportées par la <application>libpq</application> (voir
   <xref linkend="libpq-envars"/>).
  </para>

  <para>
   La variable d'environnement <envar>PG_COLOR</envar> précise si l'on
   doit utiliser la couleur dans les messages de diagnostique.
   Les valeurs possibles sont
   <literal>always</literal>, <literal>auto</literal> et
   <literal>never</literal>.
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <refsect2>
   <title>Quelles sont les <quote>transactions</quote> réellement exécutées
    dans <application>pgbench</application>&nbsp;?</title>

   <para>
    <application>pgbench</application> exécute des scripts de tests choisis de
    façon aléatoire à partir d'une sélection. Les scripts pourraient inclure
    des scripts internes indiqués avec l'option <option>-b</option> et des
    scripts fournis par l'utilisateur indiqués avec l'option
    <option>-f</option>. Chaque script peut se voir affecter un poids
    spécifique après un caractère <literal>@</literal> pour modifier sa
    probabilité de sélection. Le poids par défaut est de <literal>1</literal>.
    Les scripts avec un poids de <literal>0</literal> sont ignorés.
   </para>

   <para>
    Le script interne par défaut (aussi appelé avec <option>-b tpcb-like</option>)
    exécute sept commandes par transaction choisies de
    façon aléatoire parmi <literal>aid</literal>, <literal>tid</literal>,
    <literal>bid</literal> et <literal>delta</literal>. Le scénario s'inspire
    du jeu de tests de performance TPC-B benchmark mais il ne s'agit pas
    réellement de TPC-B, d'où son nom.
   </para>

   <orderedlist>
    <listitem><para><literal>BEGIN;</literal></para></listitem>
    <listitem><para><literal>
       UPDATE pgbench_accounts SET abalance = abalance + :delta
       WHERE aid = :aid;</literal></para></listitem>
    <listitem><para><literal>SELECT abalance FROM pgbench_accounts
       WHERE aid = :aid;</literal></para></listitem>
    <listitem><para><literal>UPDATE pgbench_tellers
       SET tbalance = tbalance + :delta
       WHERE tid = :tid;</literal></para></listitem>
    <listitem><para><literal>UPDATE pgbench_branches
       SET bbalance = bbalance + :delta
       WHERE bid = :bid;</literal></para></listitem>
    <listitem><para><literal>INSERT
       INTO pgbench_history (tid, bid, aid, delta, mtime)
       VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
      </literal></para></listitem>
    <listitem><para><literal>END;</literal></para></listitem>
   </orderedlist>

   <para>
    Si vous sélectionnez le script interne <literal>simple-update</literal> (ou
    <option>-N</option>), les étapes 4 et 5 ne sont pas incluses dans la
    transaction. Ceci évitera des contentions au niveau des mises à jour sur
    ces tables, mais le test ressemblera encore moins à TPC-B.
   </para>

   <para>
    Si vous sélectionnez le script interne <literal>select-only</literal> (ou
    <option>-S</option>), alors seul le <command>SELECT</command> est exécuté.
   </para>
  </refsect2>

  <refsect2>
   <title>Scripts personnalisés</title>

   <para>
    <application>pgbench</application> est capable d'utiliser des
    scénarios de test de performance personnalisés, en remplaçant le
    script de transactions par défaut (décrit ci-dessus) par un script de
    transactions lu depuis un fichier spécifié avec l'option
    (<option>-f</option>).
    Dans ce cas, une <quote>transaction</quote> est comptabilisée comme
    une exécution du fichier script.
   </para>

   <para>
    Un fichier script contient une ou plusieurs commandes SQL terminées par des
    points-virgules. Les lignes vides et les lignes commençant par
    <literal>--</literal> sont ignorées. Les fichiers scripts peuvent aussi
    contenir des <quote>méta-commandes</quote>, qui seront interprétées par
    <application>pgbench</application> comme indiqué plus bas.
   </para>

   <note>
    <para>
     Avant <productname>PostgreSQL</productname> 9.6, les commandes SQL comprises
     dans les fichiers scripts étaient terminées par un retour à la ligne.
     Elles ne pouvaient donc pas être écrites sur plusieurs lignes. Maintenant,
     un point-virgule est <emphasis>requis</emphasis> pour séparer des
     commandes SQL consécutives (bien qu'une commande SQL n'en a pas besoin si
     elle est suivie par une méta-commande). Si vous avez besoin de créer un
     fichier script qui fonctionne avec les anciennes et nouvelles versions de
     <application>pgbench</application>, assurez-vous d'écrire chaque commande
     SQL sur une seule ligne et en terminant avec un point-virgule.
    </para>
   </note>

   <para>
    Il est possible de procéder facilement à de la substitution de variables
    dans les fichiers scripts.
    Les noms de variables doivent consister en lettres (y compris des caractères
    non latins), chiffres et soulignés (<literal>_</literal>), mais le premier
    caractère ne doit pas être un chiffre.
    Les variables peuvent être instanciées via
    l'option <option>-D</option> de la ligne de commande comme décrit ci-dessus,
    ou grâce aux méta-commandes décrites ci-dessous.
    En plus des commandes pré-définies par l'option de la ligne de
    commande <option>-D</option>, quelques variables sont
    automatiquement prédéfinies, listées sous
    <xref linkend="pgbench-automatic-variables"/>.
    Une valeur de ces variables définie via l'option <option>-D</option>
    aura priorité sur la valeur définie
    automatiquement. Une fois définie, la valeur d'une variable peut
    être insérée dans les commandes SQL en écrivant <literal>:</literal>
    <replaceable>nom_variable</replaceable>.
    S'il y a plus d'une session par client, chaque session possède son
    propre jeu de variables.
    <application>pgbench</application> supports up to 255 variable uses in one
    statement.
   </para>

   <table id="pgbench-automatic-variables">
    <title>Variables automatiques de pgbench</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="2*"/>
     <thead>
      <row>
       <entry>Variable</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>client_id</literal></entry>
       <entry>nombre unique permettant d'identifier la session client
        (commence à zéro)</entry>
      </row>

      <row>
       <entry> <literal>default_seed</literal> </entry>
       <entry>graine utilisée par défaut dans les fonctions de hachage
        et de permutation pseudo-aléatoire</entry>
      </row>

      <row>
       <entry> <literal>random_seed</literal> </entry>
       <entry>graine du générateur aléatoire (si pas remplacée avec
        <option>-D</option>)</entry>
      </row>

      <row>
       <entry><literal>scale</literal></entry>
       <entry>facteur d'échelle courant</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Dans les fichiers de scripts, les méta-commandes commencent avec un
    anti-slash (<literal>\</literal>) et s'étendent jusqu'à la fin de la ligne,
    même si elles peuvent s'étendre sur plusieurs lignes en écrivant anti-slash
    puis un retour chariot. Les
    arguments d'une méta-commande sont séparés par des espaces vides. Les
    méta-commandes suivantes sont supportées&nbsp;:
   </para>

   <variablelist>
    <varlistentry id='pgbench-metacommand-gset'>
     <term>
      <literal>\gset [<replaceable>prefix</replaceable>]</literal>
      <literal>\aset [<replaceable>prefix</replaceable>]</literal>
     </term>

     <listitem>
      <para>
       Cette commande peut être utilisée pour marquer la fin de requêtes SQL,
       prenant ainsi la place du point-virgule final (<literal>;</literal>).
      </para>

      <para>
       Quand la commande <literal>\gset</literal> est utilisée,
       la requête SQL précédente doit renvoyer une ligne.
       Les valeurs de ses colonnes sont enregistrées dans
       des variables nommées d'après les noms de colonnes, préfixées avec
       <replaceable>prefix</replaceable>, si ce dernier est fourni.
      </para>

      <para>
       Quand la commande <literal>\aset</literal> est utilisée, toutes les requêtes
       (séparées par <literal>\;</literal>) voient leurs colonnes stockées dans
       des variables nommées d'après elles, préfixées de <replaceable>prefix</replaceable>
       s'il est fourni.
       Si une requête ne retourne aucune ligne, aucune affectation n'est faite.
       On peut tester l'existence de la variable pour détecter ce cas.
       Si une requête retourne plus d'une ligne, la dernière valeur est conservée.
      </para>

      <para>
       <literal>\gset</literal> et <literal>\aset</literal> ne peuvent être
       utilisées en mode pipeline, puisque les résultats des requêtes ne sont pas
       encore disponibles au moment où la commande en a besoin.
      </para>

      <para>
       L'exemple suivant place la balance finale du compte provenant de la
       première requête dans la variable <replaceable>abalance</replaceable>,
       et remplit les variables <replaceable>p_two</replaceable> et
       <replaceable>p_three</replaceable> avec les entiers provenant de la
       troisième requête. Le résultat de la deuxième requête est ignoré.
       Les résultats des deux dernières requêtes combinées sont stockés dans
       les variables
       <replaceable>four</replaceable> et <replaceable>five</replaceable>.
       <programlisting>
UPDATE pgbench_accounts
  SET abalance = abalance + :delta
  WHERE aid = :aid
  RETURNING abalance \gset
-- compound of two queries
SELECT 1 \;
SELECT 2 AS two, 3 AS three \gset p_
SELECT 4 AS four \; SELECT 5 AS five \aset
       </programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>\if</literal> <replaceable class="parameter">expression</replaceable></term>
     <term><literal>\elif</literal> <replaceable class="parameter">expression</replaceable></term>
     <term><literal>\else</literal></term>
     <term><literal>\endif</literal></term>
     <listitem>
      <para>
       Ce groupe de commandes implémente des blocs conditionnels imbriquables,
       de manière similaire au <xref linkend="psql-metacommand-if"/> de
       <literal>psql</literal>.
       Les expressions conditionnelles sont identiques à celles avec
       <literal>\set</literal>, les valeurs autres que zéro valant
       <literal>true</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id='pgbench-metacommand-set'>
     <term>
      <literal>\set <replaceable>nom_variable</replaceable>
       <replaceable>expression</replaceable></literal>
     </term>

     <listitem>
      <para>
       Définit la variable <replaceable>nom_variable</replaceable> à une valeur
       définie par <replaceable>expression</replaceable>.

       L'expression peut contenir la constante <literal>NULL</literal>,
       les constantes booléennes <literal>TRUE</literal> et
       <literal>FALSE</literal>, des constantes entières comme
       <literal>5432</literal>, des constantes double précision comme
       <literal>3.14159</literal>, des références à des variables
       <literal>:</literal><replaceable>nomvariable</replaceable>,
       des <link linkend="pgbench-builtin-operators">opérateurs</link> avec leur
       priorité et leur associativité habituelles en SQL,
       <link linkend="pgbench-builtin-functions">des appels de fonction</link>,
       des
       <link linkend="functions-case">expressions conditionnelles génériques SQL
        avec <token>CASE</token></link> et des parenthèses.
      </para>

      <para>
       Les fonctions et la plupart des opérateurs retournent
       <literal>NULL</literal> en cas d'entrée à <literal>NULL</literal>.
      </para>

      <para>
       En ce qui concerne les conditions, les valeurs numériques différentes de
       zéro valent <literal>TRUE</literal>, les valeurs numériques à zéro et
       <literal>NULL</literal> sont <literal>FALSE</literal>.
      </para>

      <para>
       Des constantes entières ou à virgule flottante ainsi que des opérateurs
       arithmétiques entiers (<literal>+</literal>, <literal>-</literal>,
       <literal>*</literal> et <literal>/</literal>), trop larges ou trop
       petites, renvoient des erreurs de dépassement.
      </para>

      <para>
       Quand aucune clause finale <token>ELSE</token> n'est fournie à un
       <token>CASE</token>, la valeur par défaut est <literal>NULL</literal>.
      </para>

      <para>
       Exemples&nbsp;:
       <programlisting>
\set ntellers 10 * :scale
\set aid (1021 * random(1, 100000 * :scale)) % \
           (100000 * :scale) + 1
\set divx CASE WHEN :x &lt;&gt; 0 THEN :y/:x ELSE NULL END
       </programlisting></para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal>\sleep
       <replaceable>nombre</replaceable> [ us | ms | s ]</literal>
     </term>

     <listitem>
      <para>
       Entraîne la suspension de l'exécution du script pendant la durée
       spécifiée en microsecondes (<literal>us</literal>), millisecondes
       (<literal>ms</literal>) ou secondes (<literal>s</literal>).
       Si l'unité n'est pas définie, l'unité par défaut est la seconde.
       Ce peut être soit un entier constant, soit une référence
       <literal>:</literal><replaceable>nom_variable</replaceable> vers
       une variable retournant un entier.
      </para>

      <para>
       Exemple&nbsp;:
       <programlisting>
\sleep 10 ms
       </programlisting></para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal>\setshell <replaceable>nom_variable</replaceable>
       <replaceable>commande</replaceable> [
       <replaceable>argument</replaceable> ... ]</literal>
     </term>

     <listitem>
      <para>
       Définit la variable <replaceable>nom_variable</replaceable> comme le
       résultat d'une commande shell nommée <replaceable>commande</replaceable>
       aves le(s) <replaceable>argument</replaceable>(s) donné(s). La commande
       doit retourner un entier sur la sortie standard.
      </para>

      <para>
       <replaceable>commande</replaceable> et chaque
       <replaceable>argument</replaceable> peuvent être soit une constante de
       type text, soit une référence
       <literal>:</literal><replaceable>nom_variable</replaceable> à une variable.
       Si vous voulez utiliser un <replaceable>argument</replaceable> commençant
       avec un symbole deux-points, écrivez un deux-points supplémentaire au
       début de l'<replaceable>argument</replaceable>.
      </para>

      <para>
       Exemple&nbsp;:
       <programlisting>
\setshell variable_à_utiliser commande argument_litéral :variable
::literal_commencant_avec_deux_points
       </programlisting></para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal>\shell <replaceable>commande
       </replaceable> [ <replaceable>argument</replaceable> ... ]
      </literal>
     </term>

     <listitem>
      <para>
       Identique à <literal>\setshell</literal>, mais le résultat de la
       commande sera ignoré.
      </para>

      <para>
       Exemple&nbsp;:
       <programlisting>
\shell command literal_argument :variable ::literal_starting_with_colon
       </programlisting></para>
     </listitem>
    </varlistentry>

    <varlistentry id='pgbench-metacommand-pipeline'>
     <term><literal>\startpipeline</literal></term>
     <term><literal>\endpipeline</literal></term>
 
     <listitem>
       <para>
         Ces commandes définissent le début et la fin de requêtes SQL.
         En mode pipeline, celles-ci sont envoyées au serveur sans attendre le
         résultat des requêtes précédentes.
         Voir <xref linkend="libpq-pipeline-mode"/> pour plus de détails.
         Le mode pipeline impose l'utilisation du protocole de requête étendu.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect2>

  <refsect2 id="pgbench-builtin-operators">
   <title>Opérateurs intégrés</title>

   <para>
    Les opérateurs arithmétiques, de manipulation de bits, de comparaison et
    logiques listés dans <xref linkend="pgbench-operators"/> sont intégrés
    dans <application>pgbench</application> et peuvent être utilisés dans des
    expressions apparaissant dans <link linkend="pgbench-metacommand-set">
     <literal>\set</literal></link>.
    Les opérateurs sont listés par priorité croissante.
    Sauf indication contraire, les opérateurs prenant deux paramètres
    en entrée produiront un nombre en double précision, si une des entrées
    est en double précision, sinon le résultat produit sera entier.
   </para>

   <table id="pgbench-operators">
    <title>Opérateurs pgbench</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
         Opérateur
        </para>
        <para>
         Description
        </para>
        <para>
         Exemple(s)
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>booléen</replaceable> <literal>OR</literal> <replaceable>booléen</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         OU logique
        </para>
        <para>
         <literal>5 or 0</literal>
         <returnvalue>TRUE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>booléen</replaceable> <literal>AND</literal> <replaceable>booléen</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         ET logique
        </para>
        <para>
         <literal>3 and 0</literal>
         <returnvalue>FALSE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <literal>NOT</literal> <replaceable>booléen</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         NON logique
        </para>
        <para>
         <literal>not false</literal>
         <returnvalue>TRUE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>booléen</replaceable> <literal>IS [NOT] (NULL|TRUE|FALSE)</literal>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         Tests de valeur booléenne
        </para>
        <para>
         <literal>1 is null</literal>
         <returnvalue>FALSE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>valeur</replaceable> <literal>ISNULL|NOTNULL</literal>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         Tests de nullité
        </para>
        <para>
         <literal>1 notnull</literal>
         <returnvalue>TRUE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>=</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         Est égal
        </para>
        <para>
         <literal>5 = 4</literal>
         <returnvalue>FALSE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>&lt;&gt;</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         N'est pas égal
        </para>
        <para>
         <literal>5 &lt;&gt; 4</literal>
         <returnvalue>TRUE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>!=</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         N'est pas égal
        </para>
        <para>
         <literal>5 != 5</literal>
         <returnvalue>FALSE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>&lt;</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         Inférieur à
        </para>
        <para>
         <literal>5 &lt; 4</literal>
         <returnvalue>FALSE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>&lt;=</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         Inférieur ou égal à
        </para>
        <para>
         <literal>5 &lt;= 4</literal>
         <returnvalue>FALSE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>&gt;</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         Plus grand que
        </para>
        <para>
         <literal>5 &gt; 4</literal>
         <returnvalue>TRUE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>&gt;=</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         Plus grand ou égal à
        </para>
        <para>
         <literal>5 &gt;= 4</literal>
         <returnvalue>TRUE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>entier</replaceable> <literal>|</literal> <replaceable>entier</replaceable>
         <returnvalue><replaceable>entier</replaceable></returnvalue>
        </para>
        <para>
         OU binaire
        </para>
        <para>
         <literal>1 | 2</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>entier</replaceable> <literal>#</literal> <replaceable>entier</replaceable>
         <returnvalue><replaceable>entier</replaceable></returnvalue>
        </para>
        <para>
         XOR binaire
        </para>
        <para>
         <literal>1 # 3</literal>
         <returnvalue>2</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>entier</replaceable> <literal>&amp;</literal> <replaceable>entier</replaceable>
         <returnvalue><replaceable>entier</replaceable></returnvalue>
        </para>
        <para>
         ET binaire
        </para>
        <para>
         <literal>1 &amp; 3</literal>
         <returnvalue>1</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <literal>~</literal> <replaceable>entier</replaceable>
         <returnvalue><replaceable>entier</replaceable></returnvalue>
        </para>
        <para>
         NON binaire
        </para>
        <para>
         <literal>~ 1</literal>
         <returnvalue>-2</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>entier</replaceable> <literal>&lt;&lt;</literal> <replaceable>entier</replaceable>
         <returnvalue><replaceable>entier</replaceable></returnvalue>
        </para>
        <para>
         Décalage binaire vers la gauche
        </para>
        <para>
         <literal>1 &lt;&lt; 2</literal>
         <returnvalue>4</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>entier</replaceable> <literal>&gt;&gt;</literal> <replaceable>entier</replaceable>
         <returnvalue><replaceable>entier</replaceable></returnvalue>
        </para>
        <para>
         Décalage binaire vers la droite
        </para>
        <para>
         <literal>8 &gt;&gt; 2</literal>
         <returnvalue>2</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>+</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>nombre</replaceable></returnvalue>
        </para>
        <para>
         Addition
        </para>
        <para>
         <literal>5 + 4</literal>
         <returnvalue>9</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>-</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>nombre</replaceable></returnvalue>
        </para>
        <para>
         Soustraction
        </para>
        <para>
         <literal>3 - 2.0</literal>
         <returnvalue>1.0</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>*</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>nombre</replaceable></returnvalue>
        </para>
        <para>
         Multiplication
        </para>
        <para>
         <literal>5 * 4</literal>
         <returnvalue>20</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>/</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>nombre</replaceable></returnvalue>
        </para>
        <para>
         Division (tronque le résultat vers zéro si les deux paramètres d'entrée sont des entiers)
        </para>
        <para>
         <literal>5 / 3</literal>
         <returnvalue>1</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>entier</replaceable> <literal>%</literal> <replaceable>entier</replaceable>
         <returnvalue><replaceable>entier</replaceable></returnvalue>
        </para>
        <para>
         Modulo (reste)
        </para>
        <para>
         <literal>3 % 2</literal>
         <returnvalue>1</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <literal>-</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>nombre</replaceable></returnvalue>
        </para>
        <para>
         Opposé
        </para>
        <para>
         <literal>- 2.0</literal>
         <returnvalue>-2.0</returnvalue>
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </refsect2>

  <refsect2 id="pgbench-builtin-functions">
   <title>Fonctions internes</title>

   <para>
    Les fonctions listées dans <xref linkend="pgbench-functions"/> sont
    internes à <application>pgbench</application> et peuvent être
    utilisées dans des expressions apparaissant dans
    <link linkend="pgbench-metacommand-set"><literal>\set</literal></link>.
   </para>

   <!-- list pgbench functions in alphabetical order -->
   <table id="pgbench-functions">
    <title>pgbench Functions</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
         Fonction
        </para>
        <para>
         Description
        </para>
        <para>
         Exemple(s)
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>abs</function> ( <replaceable>nombre</replaceable> )
         <returnvalue></returnvalue> même que l'entrée
        </para>
        <para>
         Valeur absolue
        </para>
        <para>
         <literal>abs(-17)</literal>
         <returnvalue>17</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>debug</function> ( <replaceable>nombre</replaceable> )
         <returnvalue></returnvalue> même que l'entrée
        </para>
        <para>
         Affiche l'argument dans <systemitem>stderr</systemitem>,
         puis le retourne.
        </para>
        <para>
         <literal>debug(5432.1)</literal>
         <returnvalue>5432.1</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>double</function> ( <replaceable>nombre</replaceable> )
         <returnvalue>double</returnvalue>
        </para>
        <para>
         Convertit en double précision.
        </para>
        <para>
         <literal>double(5432)</literal>
         <returnvalue>5432.0</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>exp</function> ( <replaceable>nombre</replaceable> )
         <returnvalue>double</returnvalue>
        </para>
        <para>
         Exponentielle (<literal>e</literal> à la puissance indiquée)
        </para>
        <para>
         <literal>exp(1.0)</literal>
         <returnvalue>2.718281828459045</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>greatest</function> ( <replaceable>nombre</replaceable> <optional>, <literal>...</literal> </optional> )
         <returnvalue></returnvalue> <type>double</type> si un argument est un double, sinon <type>entier</type>
        </para>
        <para>
         Sélectionne la plus grande valeur parmi les arguments.
        </para>
        <para>
         <literal>greatest(5, 4, 3, 2)</literal>
         <returnvalue>5</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>hash</function> ( <parameter>valeur</parameter> <optional>, <parameter>graine</parameter> </optional> )
         <returnvalue>entier</returnvalue>
        </para>
        <para>
         Alias pour <function>hash_murmur2</function>.
        </para>
        <para>
         <literal>hash(10, 5432)</literal>
         <returnvalue>-5817877081768721676</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>hash_fnv1a</function> ( <parameter>valeur</parameter> <optional>, <parameter>graine</parameter> </optional> )
         <returnvalue>entier</returnvalue>
        </para>
        <para>
         Calcule le <ulink url="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">
          hash FNV-1a</ulink>. <!-- NB : pas de version française de cette page sur Wikipédia -->
        </para>
        <para>
         <literal>hash_fnv1a(10, 5432)</literal>
         <returnvalue>-7793829335365542153</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>hash_murmur2</function> ( <parameter>valeur</parameter> <optional>, <parameter>graine</parameter> </optional> )
         <returnvalue>entier</returnvalue>
        </para>
        <para>
         Computes <ulink url="https://en.wikipedia.org/wiki/MurmurHash">MurmurHash2 hash</ulink>.
         <!-- NB : pas de version française de cette page sur Wikipédia -->
        </para>
        <para>
         <literal>hash_murmur2(10, 5432)</literal>
         <returnvalue>-5817877081768721676</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>int</function> ( <replaceable>nombre</replaceable> )
         <returnvalue>entier</returnvalue>
        </para>
        <para>
         Convertit en entier.
        </para>
        <para>
         <literal>int(5.4 + 3.8)</literal>
         <returnvalue>9</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>least</function> ( <replaceable>nombre</replaceable> <optional>, <literal>...</literal> </optional> )
         <returnvalue></returnvalue> <type>double</type> si un argument est un double, sinon <type>entier</type>
        </para>
        <para>
         Choisit la plus petite valeur parmi les arguments.
        </para>
        <para>
         <literal>least(5, 4, 3, 2.1)</literal>
         <returnvalue>2.1</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>ln</function> ( <replaceable>nombre</replaceable> )
         <returnvalue>double</returnvalue>
        </para>
        <para>
         Logarithme naturel
        </para>
        <para>
         <literal>ln(2.718281828459045)</literal>
         <returnvalue>1.0</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>mod</function> ( <replaceable>entier</replaceable>, <replaceable>entier</replaceable> )
         <returnvalue>entier</returnvalue>
        </para>
        <para>
         Modulo (reste)
        </para>
        <para>
         <literal>mod(54, 32)</literal>
         <returnvalue>22</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>permute</function> ( <parameter>i</parameter>, <parameter>taille</parameter> [, <parameter>graine</parameter> ] )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Valeur permutée de <parameter>i</parameter>, dans la tranche
        <literal>[0, taille)</literal>,
        soit la nouvelle position de <parameter>i</parameter>
        (modulo <parameter>taille</parameter>) dans une permutation
        pseudo-aléatoire des entiers <literal>0...taille-1</literal>,
        paramétrée par la <parameter>graine</parameter> (voir plus bas).
       </para>
       <para>
        <literal>permute(0, 4)</literal>
        <returnvalue>un entier entre 0 and 3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>pi</function> ()
         <returnvalue>double</returnvalue>
        </para>
        <para>
         Valeur approximative de <phrase role="symbol_font">&pi;</phrase>
        </para>
        <para>
         <literal>pi()</literal>
         <returnvalue>3.14159265358979323846</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>pow</function> ( <parameter>x</parameter>, <parameter>y</parameter> )
         <returnvalue>double</returnvalue>
        </para>
        <para role="func_signature">
         <function>power</function> ( <parameter>x</parameter>, <parameter>y</parameter> )
         <returnvalue>double</returnvalue>
        </para>
        <para>
         <parameter>x</parameter> à la puissance <parameter>y</parameter>
        </para>
        <para>
         <literal>pow(2.0, 10)</literal>
         <returnvalue>1024.0</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>random</function> ( <parameter>lb</parameter>, <parameter>ub</parameter> )
         <returnvalue>entier</returnvalue>
        </para>
        <para>
         Calcule un entier aléatoire uniformément distribué dans
         <literal>[lb, ub]</literal>.
        </para>
        <para>
         <literal>random(1, 10)</literal>
         <returnvalue>un entier entre 1 and 10</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>random_exponential</function> ( <parameter>lb</parameter>, <parameter>ub</parameter>, <parameter>paramètre</parameter> )
         <returnvalue>entier</returnvalue>
        </para>
        <para>
         Calcule un entier aléatoire distribué exponentiellement dans
         <literal>[lb, ub]</literal>&nbsp;;voir plus bas.
        </para>
        <para>
         <literal>random_exponential(1, 10, 3.0)</literal>
         <returnvalue>un entier entre 1 and 10</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>random_gaussian</function> ( <parameter>lb</parameter>, <parameter>ub</parameter>, <parameter>paramètre</parameter> )
         <returnvalue>entier</returnvalue>
        </para>
        <para>
         Calcule un entier aléatoire distribué de manière gaussienne dans
         <literal>[lb, ub]</literal>&nbsp;;voir plus bas.
        </para>
        <para>
         <literal>random_gaussian(1, 10, 2.5)</literal>
         <returnvalue>un entier entre 1 and 10</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>random_zipfian</function> ( <parameter>lb</parameter>, <parameter>ub</parameter>, <parameter>paramètre</parameter> )
         <returnvalue>entier</returnvalue>
        </para>
        <para>
         Calcule un entier aléatoire distribué selon la loi de Zipf dans
         <literal>[lb, ub]</literal>&nbsp;;voir plus bas.
        </para>
        <para>
         <literal>random_zipfian(1, 10, 1.5)</literal>
         <returnvalue>une valeur entre 1 and 10</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>sqrt</function> ( <replaceable>nombre</replaceable> )
         <returnvalue>double</returnvalue>
        </para>
        <para>
         Racine carrée
        </para>
        <para>
         <literal>sqrt(2.0)</literal>
         <returnvalue>1.414213562</returnvalue>
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    La fonction <literal>random</literal> génère des valeurs en utilisant une
    distribution uniforme&nbsp;; autrement dit toutes les valeurs sont dans
    l'intervalle spécifiée avec une probabilité identique. Les fonctions
    <literal>random_exponential</literal>, <literal>random_gaussian</literal>
    et <literal>random_zipfian</literal> requièrent un paramètre
    supplémentaire de type double qui détermine le contour précis de cette
    distribution.
   </para>

   <itemizedlist>
    <listitem>
     <para>
      Pour une distribution exponentielle,
      <replaceable>paramètre</replaceable> contrôle la distribution en
      tronquant une distribution exponentielle en décroissance rapide à
      <replaceable>paramètre</replaceable>, puis en projetant le résultant sur
      des entiers entre les limites. Pour être précis&nbsp;:
      <literallayout>
       f(x) = exp(-paramètre * (x - min) / (max - min + 1)) / (1 - exp(-paramètre))
      </literallayout>
      Puis la valeur <replaceable>i</replaceable> entre les valeurs
      <replaceable>min</replaceable> et <replaceable>max</replaceable>, en les
      incluant, est récupérée avec la probabilité&nbsp;:
      <literal>f(i) - f(i + 1)</literal>.
     </para>

     <para>
      Intuitivement, plus <replaceable>paramètre</replaceable> est grand, plus
      les valeurs fréquentes proches de <replaceable>min</replaceable> sont
      accédées et moins les valeurs fréquentes proches de
      <replaceable>max</replaceable> sont accédées. Plus
      <replaceable>paramètre</replaceable> est proche de 0, plus la
      distribution d'accès sera plate (uniforme). Une approximation grossière de
      la distribution est que 1% des valeurs les plus fréquentes de
      l'intervalle, proches de <replaceable>min</replaceable>, sont tirées
      <replaceable>paramètre</replaceable>% du temps. La valeur de
      <replaceable>paramètre</replaceable> doit être strictement positive.
     </para>
    </listitem>

    <listitem>
     <para>
      Pour une distribution gaussienne, l'intervalle correspond à une
      distribution normale standard (la courbe gaussienne classique en forme
      de cloche) tronquée à <literal>-paramètre</literal> à gauche et à
      <literal>+paramètre</literal> à droite.
      Les valeurs au milieu de l'intervalle sont plus
      susceptibles d'être sélectionnées. Pour être précis, si
      <literal>PHI(x)</literal> est la fonction de distribution cumulative de
      la distribution normale standard, avec une moyenne <literal>mu</literal>
      définie comme <literal>(max + min) / 2.0</literal>, avec
      <literallayout>
       f(x) = PHI(2.0 * paramètre * (x - mu) / (max - min + 1)) /
       (2.0 * PHI(paramètre) - 1)
      </literallayout>
      alors la valeur <replaceable>i</replaceable> entre
      <replaceable>min</replaceable> et <replaceable>max</replaceable>
      (inclus) est sélectionnée avec une probabilité&nbsp;:
      <literal>f(i + 0.5) - f(i - 0.5)</literal>. Intuitivement, plus
      <replaceable>paramètre</replaceable> est grand, et plus les valeurs
      fréquentes proches du centre de l'intervalle sont sélectionnées, et
      moins les valeurs fréquentes proches des bornes
      <replaceable>min</replaceable> et <replaceable>max</replaceable>.
      Environ 67% des valeurs sont sélectionnées à partir du centre
      <literal>1.0 / paramètre</literal>, soit
      <literal>0.5 / paramètre</literal> autour de la moyenne, et 95% dans le
      centre <literal>2.0 / paramètre</literal>, soit
      <literal>1.0 / paramètre</literal> autour de la moyenne&nbsp;; par
      exemple, si <replaceable>paramètre</replaceable> vaut 4.0, 67% des
      valeurs sont sélectionnées depuis le quart du milieu (1.0 / 4.0) de
      l'intervalle (ou à partir de <literal>3.0 / 8.0</literal> jusqu'à
      <literal>5.0 / 8.0</literal>) et 95% depuis la moitié du milieu
      (<literal>2.0 / 4.0</literal>) de l'intervalle (deuxième et troisième
      quartiles). La valeur minimale autorisée pour <replaceable>paramètre</replaceable>
      est 2.0.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>random_zipfian</literal> génère une distribution bornée
      selon la loi de Zipf.
      <replaceable>paramètre</replaceable>
      définit à quel point la distribution est biaisée. Plus
      <replaceable>paramètre</replaceable> est grand, plus fréquemment les
      valeurs du début de l'intervalle seront tirées.
      La distribution est telle que, en supposant que l'intervalle commence à
      1, le ratio de probabilité d'un jet <replaceable>k</replaceable> contre
      un jet <replaceable>k+1</replaceable> est
      <literal>((<replaceable>k</replaceable>+1)/<replaceable>k</replaceable>)**<replaceable>parameter</replaceable></literal>.
      Par exemple, <literal>random_zipfian(1, ..., 2.5)</literal> produit
      la valeur <literal>1</literal> à peu près <literal>(2/1)**2.5 =
       5.66</literal> fois plus fréquemment que <literal>2</literal>, qui
      lui-même est produit <literal>(3/2)**2.5 = 2.76</literal> fois plus
      fréquemment que <literal>3</literal>, et ainsi de suite.
     </para>
     <para>
      L'implémentation de <application>pgbench</application> est basée sur
      «&nbsp;Non-Uniform Random Variate Generation&nbsp;», Luc Devroye, p. 550-551,
      Springer 1986. À cause des limitations de cet algorithme, la valeur
      <replaceable>paramètre</replaceable> est restreinte à l'intervalle
      [1.001, 1000].
     </para>
    </listitem>
   </itemizedlist>

   <note>
    <para>
      Lors de la conception d'un benchmark qui sélectionne des lignes de
      manière non uniforme, soyez conscient que les lignes choisies peuvent
      être corrélées avec d'autres données, comme les ID d'une séquence ou
      l'ordre physique des lignes, ce qui peut biaiser les mesures de
      performance.
    </para>
    <para>
      Pour éviter cela, pensez à la fonction <function>permute</function>,
      ou toute autre opération avec le même effet, pour mélanger les lignes
      sélectionnées et détruire ces corrélations.
    </para>
   </note>

   <para>
    Les fonctions de hachage <literal>hash</literal>,
    <literal>hash_murmur2</literal> et <literal>hash_fnv1a</literal> acceptent
    une valeur d'entrée et une graine optionnelle. Si la graine n'est pas
    fournie, la valeur de <literal>:default_seed</literal> est utilisée,
    initialisée de façon aléatoire si elle n'est pas définie par l'option de
    ligne de commande <literal>-D</literal>..
   </para>

   <para>
     <literal>permute</literal> accepte en entrée une valeur, une taille,
     et une graine optionnelle. Elle génère une permutation
     pseudo-aléatoire des entiers dans la tranche <literal>[0, taille)</literal>,
     et retourne l'index de la valeur d'entrée dans les valeurs permutées.
     La permutation choisie est paramétrée par la graine, soit par défaut
     <literal>:default_seed</literal> si elle n'est pas fournie.
     Au contraire des fonctions de hachage, <literal>permute</literal>
     garantit qu'il n'y aura ni collision ni trou dans les valeurs retournées.
     Les valeurs d'entrée hors de l'intervalle sont interprétées modulo
     la taille. La fonction lève une erreur si la taille n'est pas positive.
     <function>permute</function> peut être utilisée pour disperser
     la distribution de fonctions aléatoires non uniformes comme
     <literal>random_zipfian</literal> ou <literal>random_exponential</literal>,
     afin que les valeurs les plus couramment tirées ne soient pas corrélées
     de manière triviale. Par exemple, le script <application>pgbench</application>
     suivant simule une charge réaliste typique des médias sociaux et
     des plateformes de blogs, où quelques comptes génèrent une charge
     excessive&nbsp;:
    <programlisting>
\set size 1000000
\set r random_zipfian(1, :size, 1.07)
\set k 1 + permute(:r, :size)
    </programlisting>

    Dans certains cas, plusieurs distributions distinctes non corrélées
    entre elles sont nécessaires, et c'est là que le paramètre
    graine optionnel est pratique&nbsp;:

    <programlisting>
\set k1 1 + permute(:r, :size, :default_seed + 123)
\set k2 1 + permute(:r, :size, :default_seed + 321)
    </programlisting>

    Un comportement similaire peut être approché avec <function>hash</function>&nbsp;:

<programlisting>
\set size 1000000
\set r random_zipfian(1, 100 * :size, 1.07)
\set k 1 + abs(hash(:r)) % :size
</programlisting>

    Cependant, comme <function>hash</function> génère des collisions,
    certaines valeurs ne sont pas atteignables, et d'autres seront plus fréquentes
    qu'attendues par rapport à la distribution originale.
   </para>

   <para>
    À titre d'exemple, la définition complète de la transaction style TPC-B
    intégrée est&nbsp;:

    <programlisting>
   \set aid random(1, 100000 * :scale)
   \set bid random(1, 1 * :scale)
   \set tid random(1, 10 * :scale)
   \set delta random(-5000, 5000)
   BEGIN;
   UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
   SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
   UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
   UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
   INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
   END;
    </programlisting>
    Ce script autorise chaque itération de la transaction à référencer
    des lignes différentes, sélectionnées aléatoirement.
    (Cet exemple montre aussi pourquoi il est important que chaque session
    cliente ait ses propres variables &mdash; sinon elles n'affecteront
    pas les différentes lignes de façon indépendante.
   </para>

  </refsect2>

  <refsect2>
   <title>Journaux par transaction</title>

   <para>
    Avec l'option <option>-l</option> (mais sans l'option
    <option>--aggregate-interval</option>),
    <application>pgbench</application> va écrire des informations sur
    chaque transaction dans un fichier journal. Il sera nommé
    <filename><replaceable>prefix</replaceable>.<replaceable>nnn</replaceable></filename>,
    où <replaceable>prefix</replaceable> vaut par défaut
    <literal>pgbench_log</literal>, et <replaceable>nnn</replaceable> est le PID
    du processus <application>pgbench</application>.
    Le préfixe peut être changé avec l'option <option>--log-prefix</option>.
    Si l'option <option>-j</option> est positionnée à 2 ou plus,
    créant plusieurs processus de travail (<foreignphrase>worker</foreignphrase>),
    chacun aura son propre fichier journal.
    Le premier worker utilisera le même nom pour son fichier journal
    que dans le cas d'un seul processus.
    Les fichiers journaux supplémentaires s'appelleront
    <filename><replaceable>prefix</replaceable>.<replaceable>nnn</replaceable>.<replaceable>mmm</replaceable></filename>,
    où <replaceable>mmm</replaceable> est un numéro de séquence,
    identifiant chaque worker, commençant à 1.
   </para>

   <para>
    Le format du journal est le suivant&nbsp;:

    <synopsis>
<replaceable>id_client</replaceable> <replaceable>no_transaction</replaceable> <replaceable>temps</replaceable> <replaceable>no_script</replaceable> <replaceable>time_epoch</replaceable> <replaceable>time_us</replaceable> <optional> <replaceable>schedule_lag</replaceable> </optional>
    </synopsis>

    où
    <replaceable>client_id</replaceable> indique la session client qui a exécuté
    la transaction, <replaceable>transaction_no</replaceable> compte le nombre
    de transactions exécutées par cette session,
    <replaceable>temps</replaceable> est la durée totale de la
    transaction en microsecondes, <replaceable>no_script</replaceable>
    indique quel fichier script a été utilisé (très utile lorsqu'on
    utilise plusieurs scripts avec l'option <option>-f</option> ou
    <option>-b</option>), et
    <replaceable>time_epoch</replaceable>/<replaceable>time_us</replaceable>
    est un horodatage Unix avec un décalage en microsecondes (utilisable pour
    créer un horodatage ISO 8601 avec des secondes fractionnées) indiquant
    à quel moment la transaction s'est terminée.

    Le champ <replaceable>schedule_lag</replaceable> est la différence
    entre la date de début planifiée de la transaction et sa date de
    début réelle, en micro secondes.
    Il est présent uniquement lorsque l'option <option>--rate</option> est
    utilisée.
    Quand les options <option>--rate</option> et <option>--latency-limit</option>
    sont utilisées en même temps, le champ <replaceable>time</replaceable> pour
    une transaction ignorée sera rapportée en tant que <literal>skipped</literal>.
   </para>

   <para>
    Ci-dessous un extrait du fichier journal généré avec un seul client&nbsp;:
    <screen>
0 199 2241 0 1175850568 995598
0 200 2465 0 1175850568 998079
0 201 2513 0 1175850569 608
0 202 2038 0 1175850569 2663
    </screen>

    Autre exemple avec les options <literal>--rate=100</literal> et
    <literal>--latency-limit=5</literal> (notez
    la colonne supplémentaire <replaceable>schedule_lag</replaceable>)&nbsp;:
    <screen>
0 81 4621 0 1412881037 912698 3005
0 82 6173 0 1412881037 914578 4304
0 83 skipped 0 1412881037 914578 5217
0 83 skipped 0 1412881037 914578 5099
0 83 4722 0 1412881037 916203 3108
0 84 4142 0 1412881037 918023 2333
0 85 2465 0 1412881037 919759 740
    </screen>
    Dans cet exemple, la transaction 82 a été en retard, elle affiche une
    latence (6,173&nbsp;ms) supérieure à la limite de 5&nbsp;ms.
    Les deux transactions suivantes ont été ignorées, car elles avaient
    déjà en retard avant même d'avoir commencé.
   </para>

   <para>
    Dans le cas d'un test long sur du matériel qui peut
    supporter un grand nombre de transactions, les journaux
    peuvent devenir très volumineux.
    L'option <option>--sampling-rate</option> peut être utilisée pour
    journaliser seulement un extrait aléatoire des transactions
    effectuées.
   </para>
  </refsect2>

  <refsect2>
   <title>Agrégation de la journalisation</title>

   <para>
    Avec l'option <option>--aggregate-interval</option>, les fichiers
    journaux utilisent un format quelque peu différent&nbsp;:

    <synopsis>
<replaceable>début_intervalle</replaceable> <replaceable>nombre_de_transactions</replaceable>&zwsp; <replaceable>somme_latence</replaceable> <replaceable>somme_latence_2</replaceable> <replaceable>latence_minimum</replaceable> <replaceable>latence_maximum</replaceable>&zwsp; <optional> <replaceable>somme_retard</replaceable> <replaceable>somme_retard_2</replaceable> <replaceable>retard_min</replaceable> <replaceable>retard_max</replaceable> <optional> <replaceable>transactions_ignorées</replaceable> </optional> </optional>
    </synopsis>

    où <replaceable>début_intervalle</replaceable> est le début de
    l'intervalle (au format epoch Unix),
    <replaceable>nombre_de_transactions</replaceable> est le nombre de
    transactions dans l'intervalle,
    <replaceable>somme_latence</replaceable> est le cumul des latences dans
    l'intervalle,
    <replaceable>somme_latence_2</replaceable> est la somme des carrés des
    latences dans l'intervalle,
    <replaceable>latence_minimum</replaceable> est la latence minimum dans
    l'intervalle,
    et <replaceable>latence_maximum</replaceable> est la latence maximum dans
    l'intervalle.
    Les derniers champs <replaceable>somme_retard</replaceable>,
    <replaceable>somme_retard_2</replaceable>,
    <replaceable>retard_min</replaceable>,
    et <replaceable>retard_max</replaceable> sont présents uniquement si
    l'option <option>--rate</option> a été spécifiée.
    Ils fournissent des statistiques sur le temps que chaque transaction a eu à
    attendre la fin de la précédente, c'est-à-dire la différence entre la
    date de départ prévue et la date de départ réelle de chaque transaction.
    Le tout dernier champ,
    <replaceable>transactions_ignorées</replaceable>, n'est présent
    que si l'option <option>--latency-limit</option> est utilisée.
    Chaque transaction est comptabilisée dans l'intervalle où elle a committé.
   </para>

   <para>
    Voici un exemple de sortie&nbsp;:
    <screen>
1345828501 5601 1542744 483552416 61 2573
1345828503 7884 1979812 565806736 60 1479
1345828505 7208 1979422 567277552 59 1391
1345828507 7685 1980268 569784714 60 1398
1345828509 7073 1979779 573489941 236 1411
    </screen></para>

   <para>
    Notez que tandis que le fichier journal brut (c'est-à-dire non
    agrégé) contient une référence à quel script a été utilisé pour chaque
    transaction, le journal agrégé n'en contient pas. De ce fait, si vous
    avez besoin des données par script, vous devrez agréger ces
    données vous-même.
   </para>

  </refsect2>

  <refsect2>
   <title>Latences par requête</title>

   <para>
    Avec l'option <option>-r</option>, <application>pgbench</application>
    collecte le temps de transaction écoulé pour chaque requête
    exécutée par chaque client.
    Une fois le test de performance terminé, il affiche une
    moyenne de ces valeurs, désignée comme latence de chaque requête.
   </para>

   <para>
    Pour le script par défaut, le résultat aura la forme suivante&nbsp;:
    <screen>
starting vacuum...end.
transaction type: &lt;builtin: TPC-B (sort of)&gt;
 scaling factor: 1
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
latency average = 10.870 ms
latency stddev = 7.341 ms
initial connection time = 30.954 ms
tps = 907.949122 (without initial connection time)
statement latencies in milliseconds:
    0.001  \set aid random(1, 100000 * :scale)
    0.001  \set bid random(1, 1 * :scale)
    0.001  \set tid random(1, 10 * :scale)
    0.000  \set delta random(-5000, 5000)
    0.046  BEGIN;
    0.151  UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
    0.107  SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
    4.241  UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
    5.245  UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
    0.102  INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
    0.974  END;
    </screen>
   </para>

   <para>
    Les moyennes sont rapportées séparément si plusieurs scripts sont spécifiés.
   </para>

   <para>
    Notez que collecter des informations de chronométrage supplémentaires
    nécessaires pour calculer la latence par requête rajoute une certaine charge.
    Cela va réduire la vitesse moyenne calculée pour l'exécution
    des transactions et réduire le taux calculé des TPS.
    Le ralentissement varie de manière significative selon la
    plateforme et le matériel.
    Comparer la moyenne des valeurs de TPS avec et sans intégration
    de la latence est une bonne manière de se rendre compte
    si la surcharge induite par le chronométrage est importante ou pas.
   </para>
  </refsect2>

  <refsect2>
   <title>Bonnes pratiques</title>

   <para>
    Il est facile d'utiliser <application>pgbench</application> pour produire
    des résultats complètement dénués de sens&nbsp;!
    Voici quelques conseils pour vous aider à obtenir des résultats
    pertinents.
   </para>

   <para>
    Tout d'abord, ne croyez <emphasis>jamais</emphasis> en un test qui ne
    dure que quelques secondes.
    Utilisez l'option <option>-t</option> ou <option>-T</option>
    pour que le test dure au moins quelques minutes, de
    façon à lisser le bruit.
    Dans certains cas, il vous faudra des heures pour récupérer des
    valeurs reproductibles.
    C'est une bonne idée de lancer plusieurs fois le test pour voir si vos
    chiffres sont ou pas reproductibles.
   </para>

   <para>
    Pour le scénario de test par défaut typé TPC-B, le facteur d'échelle
    d'initialisation (<option>-s</option>) devrait être au moins
    aussi grand que le nombre maximum de clients que vous avez
    l'intention de tester (<option>-c</option>)&nbsp;; sinon vous allez
    principalement tester la contention induite par les mises à jour.
    il n'y a que <option>-s</option> lignes dans la table
    <structname>pgbench_branches</structname>, et chaque transaction
    veut mettre à jour l'une de ces lignes, donc si la valeur de
    <option>-c</option> est supérieure à la valeur de <option>-s</option>,
    il en résultera sûrement de nombreuses transactions bloquées
    en attente de la fin d'autres transactions.
   </para>

   <para>
    Le scénario par défaut est aussi assez sensible au temps écoulé depuis
    l'initialisation des tables : l'accumulation
    des lignes et espaces morts dans les tables change les résultats.
    Pour comprendre ces résultats, vous devez garder une trace du
    nombre total de mises à jour et du moment du vacuum.
    Si l'autovacuum est actif, il peut en
    résulter des variations imprévisibles dans les performances mesurées.
   </para>

   <para>
    Une limitation de <application>pgbench</application> est qu'il peut
    lui-même devenir le goulet d'étranglement lorsqu'on essaie de tester avec
    un grand nombre de sessions clientes.
    Cela peut être atténué en utilisant <application>pgbench</application>
    depuis une machine différente du serveur de base
    de données, bien qu'une faible latence sur le réseau soit dans ce cas
    essentielle.
    Il peut même être utile de lancer plusieurs instances parallèles de
    <application>pgbench</application>, depuis
    plusieurs machines clientes vers le même serveur de base de données.
   </para>
  </refsect2>

  <refsect2>
   <title>Securité</title>

   <para>
    Si des utilisateurs non dignes de confiance ont accès à une base de
    données qui n'a pas adopté une <link linkend="ddl-schemas-patterns">méthode
     sécurisée d'utilisation des schémas</link>, il ne faut pas exécuter
    <application>pgbench</application> dans cette base.
    <application>pgbench</application> utilise des noms non qualifiés et ne
    modifie le chemin de recherche.
   </para>
  </refsect2>
 </refsect1>
</refentry>
