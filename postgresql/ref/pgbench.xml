<?xml version="1.0" encoding="UTF-8"?>
<!-- doc/src/sgml/ref/pgbench.sgml -->

<refentry id="pgbench">
 <indexterm zone="pgbench">
  <primary>pgbench</primary>
 </indexterm>

 <refmeta>
  <refentrytitle><application>pgbench</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>pgbench</refname>
  <refpurpose>Réalise un test de benchmark pour
  <productname>PostgreSQL</productname></refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <cmdsynopsis>
   <command>pgbench</command>
   <arg choice="plain"><option>-i</option></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>nom_base</replaceable></arg>
  </cmdsynopsis>
  <cmdsynopsis>
   <command>pgbench</command>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>nom_base</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
 <para>
  <application>pgbench</application> est un programme pour réaliser des
  tests de performances (<foreignphrase>benchmark</foreignphrase> en anglais)
  sur <productname>PostgreSQL</productname>.  Il
  exécute la même séquence de commandes SQL en continu, potentiellement
  avec plusieurs sessions concurrentes et ensuite il calcule le taux de
  transactions moyen (en transactions par secondes).
  Par défaut, <application>pgbench</application> teste un scénario
  vaguement basé sur TPC-B, impliquant cinq commandes <command>SELECT</command>,
  <command>UPDATE</command> et <command>INSERT</command> par
  transaction.
  Toutefois, il est facile de tester d'autres scénarios en écrivant
  ses propres scripts de transactions.
 </para>

 <para>
  Une sortie classique de <application>pgbench</application> ressemble
  à ceci&nbsp;:

<screen>
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 85.184871 (including connections establishing)
tps = 85.296346 (excluding connections establishing)
</screen>

  Les six premières lignes rapportent quelques-uns des paramètres
  les plus importants qui ont été définis.
  La ligne suivante remonte le nombre de transactions réalisées et
  prévues. (La seconde rapporte juste le ratio entre le nombre de
  clients et le nombre de transactions par client).
  Ils seront équivalents à moins que l'exécution ait échoué avant la fin.
  (Avec le mode <option>-T</option>, seul le nombre réel de transactions
  est affiché.)
  Les deux dernières lignes remontent le nombre de transactions par
  secondes incluant ou pas le temps utilisé à démarrer une session.
 </para>

  <para>
   Les transactions tests, par défaut TPC-B, nécessitent d'avoir défini
   des tables spécfiques au préalable.
   <application>pgbench</application> devrait être utilisé avec l'option
   <option>-i</option> (initialisation) pour créer et peupler ces tables.
   (Si vous testez un script personnalisé, vous n'aurez pas besoin de
   cette étape, mais vous aurez besoin de mettre en place tout ce dont
   votre script aura besoin pour réaliser ces tests).
   Une initialisation ressemble à ça&nbsp;:

<programlisting>
pgbench -i <optional> <replaceable>autres-options</replaceable>
</optional> <replaceable>nom_base</replaceable>
</programlisting>

   Où <replaceable>nom_base</replaceable> est le nom de la base de données
   existante sur laquelle on conduit les tests. (Vous aurez aussi
   probablement besoin des options <option>-h</option>,
   <option>-p</option> et/ou <option>-U</option> qui spécifient comment
   se connecter à l'instance de base de données.)
  </para>

  <caution>
   <para>
    <literal>pgbench -i</literal> cré quatre tables nommées
    <structname>pgbench_accounts</structname>,
    <structname>pgbench_branches</structname>,
    <structname>pgbench_history</structname> et
    <structname>pgbench_tellers</structname>,
    détruisant toute table qui porterait l'un de ces noms.
    Attention à utiliser une autre base de données si vous avez
    des tables qui portent ces noms&nbsp;!
   </para>
  </caution>

  <para>
   Par défaut, avec un facteur d'échelle de 1, les tables contiennent
   intialement le nombre de lignes suivant&nbsp;:
<screen>
table                   # de lignes
---------------------------------
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0
</screen>
   Vous pouvez (et, dans la plupart des cas, devriez) augmenter le nombre de
   lignes en utilisant l'option <option>-s</option>. Le facteur de remplissage
   <option>-F</option> peut aussi être utilisée à cet effet.
  </para>

  <para>
   Une fois les installations préliminaires réalisées, vous pouvez
   lancer vos benchmarks avec les options qui conviennent et ne plus
   utiliser l'option <option>-i</option>&nbsp;:

<programlisting>
pgbench <optional> <replaceable>options</replaceable> </optional>
<replaceable>nom_base</replaceable>
</programlisting>

   Dans presque tous les cas, vous allez avoir besoin de certaines
   options pour rendre vos tests plus pertinents.
   Les options les plus importantes sont celles qui concernent&nbsp;:
   le nombre de clients (<option>-c</option>),
   le nombre de transactions (<option>-t</option>),
   l'intervalle de temps (<option>-T</option>)  et
   le script à lancer (<option>-f</option>).
   Vous trouverez ci-dessous toutes les options disponibles.
  </para>
 </refsect1>

 <refsect1>
  <title>Options</title>

  <para>
   La partie suivante est divisée en trois sous-parties&nbsp;: Les
   options utiles à la phase d'initialisation sont différentes
   des options utilisées pendant les test de performances, et certaines
   options sont utiles dans les deux cas.
  </para>

 <refsect2 id="pgbench-init-options">
  <title>Options d'initialisation</title>

   <para>
    Pour réaliser l'initialisation, <application>pgbench</application>
    accepte les arguments suivants en ligne de commande&nbsp;:

    <variablelist>

     <varlistentry>
      <term><option>-i</option></term>
      <term><option>--initialize</option></term>
      <listitem>
       <para>
        Nécessaire pour être en mode initialisation.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-F</option>
      <replaceable>fillfactor</replaceable></term>
      <term><option>--fillfactor=
      </option><replaceable>fillfactor</replaceable></term>
      <listitem>
       <para>
        Crée les tables <structname>pgbench_accounts</structname>,
        <structname>pgbench_tellers</structname> et
        <structname>pgbench_branches</structname> avec le facteur de
        remplissage (fillfactor) spécifié.
        La valeur par défaut est 100.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>--no-vacuum</option></term>
      <listitem>
       <para>
        Ne réalise pas d'opération de VACUUM après l'initialisation.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-q</option></term>
      <term><option>--quiet</option></term>
      <listitem>
       <para>
		Passe du mode verbeux au mode silencieux, en affichant seulement
		un message toutes les cinq secondes.
		Par défaut, on affiche un message toutes les 100000 lignes, ce
		qui engendre souvent la génération de plusieurs lignes de journal
		toutes les secondes (particulierement sur du bon matériel)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option>
      <replaceable>scale_factor</replaceable></term>
      <term><option>--scale=</option>
      <replaceable>scale_factor</replaceable></term>
      <listitem>
       <para>
        Multiplie le nombre de lignes générées par le facteur d'échelle (scale
        factor) Par exemple, <literal>-s 100</literal> va créer 10 millions de
        lignes dans la table <structname>pgbench_accounts</structname>. La
        valeur par défaut est 1. Lorsque l'échelle dépasse 20&nbsp;000, les
        colonnes utilisées pour contenir les identifiants de compte (colonnes
        <structfield>aid</structfield>) vont être converties en grands entiers
        (<type>bigint</type>), de manière à être suffisament grandes pour
        contenir un grand intervalle d'identifiants de compte.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--foreign-keys</option></term>
      <listitem>
       <para>
        Crée une contrainte de type clé étrangère entre les tables standards.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--index-tablespace=<replaceable>index_tablespace</replaceable>
      </option></term>
      <listitem>
       <para>
        Crée un index sur le tablespace spécifié, plutôt que sur le
        tablespace par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--tablespace=<replaceable>tablespace</replaceable>
      </option></term>
      <listitem>
       <para>
        Crée une table sur le tablespace spécifié, plutôt que sur le
        tablespace par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--unlogged-tables</option></term>
      <listitem>
       <para>
        Crée toutes les tables en tant que tables non journalisées,
        plutôt qu'en tant que des tables permanentes.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </refsect2>

 <refsect2 id="pgbench-run-options">
  <title>Options Benchmark</title>

   <para>
    Pour réaliser un benchmark <application>pgbench</application>
    accepte les arguments suivants en ligne de commande&nbsp;:

    <variablelist>

     <varlistentry>
      <term><option>-b</option> <replaceable>scriptname[@weight]</replaceable></term>
      <term><option>--builtin</option>=<replaceable>scriptname[@weight]</replaceable></term>
      <listitem>
       <para>
        Add the specified builtin script to the list of executed scripts.
        An optional integer weight after <literal>@</literal> allows to adjust the
        probability of drawing the script.  If not specified, it is set to 1.
        Available builtin scripts are: <literal>tpcb-like</literal>,
        <literal>simple-update</literal> and <literal>select-only</literal>.
        Unambiguous prefixes of builtin names are accepted.
        With special name <literal>list</literal>, show the list of builtin scripts
        and exit immediately.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-c</option> <replaceable>clients</replaceable></term>
      <term><option>--client=
      </option><replaceable>clients</replaceable></term>
      <listitem>
       <para>
        Nombre de clients simulés, c'est-à-dire le nombre
        de sessions concurentes sur la base de données.
        La valeur par défaut est à 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-C</option></term>
      <term><option>--connect</option></term>
      <listitem>
       <para>
		Établit une nouvelle connexion pour chaque transaction, plutôt
		que de ne le faire qu'une seule fois par session cliente.
		C'est une option très utile pour mesurer la surcharge engendrée
		par la connexion.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-d</option></term>
      <term><option>--debug</option></term>
      <listitem>
       <para>
        Affiche les informations de debug.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-D</option> <replaceable>variable</replaceable>
      <literal>=</literal><replaceable>value</replaceable></term>
      <term><option>--define=</option><replaceable>variable</replaceable>
      <literal>=</literal><replaceable>value</replaceable></term>
      <listitem>
       <para>
        Définit une variable à utiliser pour un script personnalisé
        Voir ci-dessous pour plus de détails.
        Il est possible d'utiliser plusieurs fois l'option <option>-D</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-f</option> <replaceable>filename[@weight]</replaceable></term>
      <term><option>--file=</option><replaceable>filename[@weight]</replaceable></term>
      <listitem>
       <para>
        Add a transaction script read from <replaceable>filename</replaceable> to
        the list of executed scripts.
        An optional integer weight after <literal>@</literal> allows to adjust the
        probability of drawing the test.
         See below for details.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-j</option> <replaceable>threads</replaceable></term>
      <term><option>--jobs=</option>
      <replaceable>threads</replaceable></term>
      <listitem>
       <para>
        Nombre de processus utilisés dans
        <application>pgbench</application>.
        Utiliser plus d'un thread peut être utile sur des machines
        possédant plusieurs cœurs.
        Clients are distributed as evenly as possible among available threads.
        La valeur par défaut est 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-l</option></term>
      <term><option>--log</option></term>
      <listitem>
       <para>
        Rapporte le temps utilisé par chaque transaction dans le fichier
        journal.
        Voir ci-dessous pour plus de détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-L</option> <replaceable>limite</replaceable></term>
      <term><option>--latency-limit=</option><replaceable>limite</replaceable></term>
      <listitem>
       <para>
        Chaque transaction dont la durée est supérieure à la limite
        définie par <replaceable>limite</replaceable> (en milliseconde)
        est comptabilisée et rapportée séparement en tant que
        <firstterm>late</firstterm>.
       </para>
       <para>
        Lorsqu'un bridage est spécifié(<option>--rate=... </option>),
        les transactions, qui ont en terme de
        planification un retard supérieur à
        <replaceable>limite</replaceable> (en milliseconde) et celles
        qui n'ont pas la possibilité de rattraper la limite de latence,
        ne sont simplement pas envoyées à l'instance.
        Elles sont comptabilisées et rapportées séparément en tant que
        <firstterm>skipped</firstterm> (ignorées).
       </para>
       </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-M</option>
      <replaceable>querymode</replaceable></term>
      <term><option>--protocol=</option>
      <replaceable>querymode</replaceable></term>
      <listitem>
       <para>
		Protocole à utiliser pour soumettre des requêtes au serveur:
          <itemizedlist>
           <listitem>
            <para><literal>simple</literal>&nbsp;: utilisation du protocole
            de requêtes standards.</para>
           </listitem>
           <listitem>
            <para><literal>extended</literal>&nbsp;: utilisation du protocole
            de requêtes étendues.</para>
           </listitem>
           <listitem>
            <para><literal>prepared</literal>&nbsp;: utilisation du protocole
            de requêtes étendues avec instructions préparées.</para>
           </listitem>
          </itemizedlist>
        Par défaut, le protocole de requêtes standards est utilisé
        (voir <xref linkend="protocol"/> pour plus d'informations).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>--no-vacuum</option></term>
      <listitem>
       <para>
		Ne réalise pas l'opération de maintenance VACUUM avant de lancer
		le test.
		Cette option est <emphasis>nécessaire</emphasis> si vous lancez
		un scénario de test personnalisé qui n'utilise pas les tables
		standards <structname>pgbench_accounts</structname>,
        <structname>pgbench_branches</structname>, <structname>
	    pgbench_history</structname> et <structname>pgbench_tellers
	    </structname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-N</option></term>
      <term><option>--skip-some-updates</option></term>
      <listitem>
       <para>
        Run builtin simple-update script.
        Shorthand for <option>-b simple-update</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-P</option> <replaceable>sec</replaceable></term>
      <term><option>--progress=</option>
      <replaceable>sec</replaceable></term>
      <listitem>
       <para>
        Affiche le rapport de progression toutes les <literal>sec
        </literal> secondes.
        Ce rapport inclut la durée du test, le nombre de
        transactions par seconde depuis le dernier rapport, et la
        latence moyenne sur les transactions ainsi que la déviation
        depuis le dernier rapport.
        Avec le bridage, la latence est calculée en fonction de la date
        de démarrage planifiée de la transaction
        (option <option>-R</option>). Elle y inclut aussi la latence
        moyenne du temps de planification.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--progress-timestamp</option></term>
      <listitem>
       <para>
        When showing progress (option <option>-P</option>), use a timestamp
        (Unix epoch) instead of the number of seconds since the
        beginning of the run.  The unit is in seconds, with millisecond
        precision after the dot.
        This helps compare logs generated by various tools.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-r</option></term>
      <term><option>--report-latencies</option></term>
      <listitem>
       <para>
        Rapporte la latence moyenne par instruction (temps d'exécution
        du point de vue du client) de chaque commande après la fin du
        benchmark.
        Voir ci-dessous pour plus de détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-R</option> <replaceable>rate</replaceable></term>
      <term><option>--rate=</option><replaceable>rate</replaceable></term>
      <listitem>
       <para>
		Plutôt que d'aller le plus vite possible, l'exécution des
		transactions vise à atteindre le ratio spécifié (fonctionnement
		par défaut). Le taux est donné en transactions par seconde.
		Si le ratio visé est supérieur au ratio maximum possible, la
		limite de ratio n'aura aucune influence sur le résultat.
       </para>
       <para>
		Ce ratio est visé en appliquant une loi de poisson sur le temps
		pour ordonnançer les transactions.
		La date de démarrage prévue est avancée au moment où le client a
		démarré sa transaction et pas sur le moment où la dernière
		transaction s'est arrêtée.
		Cette manière de procéder signifie que, si une transaction
		dépasse sa date de fin prévue, un rattrapage est encore possible
		pour les suivantes.
       </para>
       <para>
		Lorsque le bridage est actif, à la fin de l'exécution, on
		calcule, à partir de la date de démarrage, la latence de la
		transaction, c'est-à-dire que l'on calcule le temps d'attente
		pour chaque transaction que la précédente se soit terminée.
		Ce temps d'attente est appelé temps de latence d'ordonnancement,
		et ses valeurs moyenne et maximum sont rapportées séparément.
		Le temps de latence d'ordonnancement respecte la date réelle de
		démarrage. Par exemple, le temps d'exécution d'une transaction
		dans la base peut être récupéré en soustrayant le temps de
		latence d'ordonnancement à la latence précisée dans le rapport.
       </para>

       <para>
        Si l'option <option>--latency-limit</option> est utilisée avec
        l'option  <option>--rate</option>, une transaction peut avoir
        une telle latence qu'elle serait déja supérieure à limite de
        latence lorsque la transaction précédente se termine, car la
        latence est calculée au moment de la date de démarrage planifiée.
        Les transactions concernées ne sont pas envoyées à l'instance,
        elles sont complètement ignorées et comptabilisées séparément.
       </para>

       <para>
		Une latence de planification élevée est un indicateur sur le
		fait que le système ne peut pas traiter les transactions du
		ratio (nombre de processus - nombres de clients) spécifié.
		Lorsque le temps moyen d'exécution est plus important que
		l'intervalle planifié prévu entre chaque transaction, chaque
		transaction successive va prendre du retard, et la latence de
		planification va continuer de croître tout le long de la durée
		du test.
		Si cela se produit, vous devez réduire le taux de transaction
		que vous avez spécifié.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>scale_factor</replaceable></term>
      <term><option>--scale=</option><replaceable>scale_factor</replaceable></term>
      <listitem>
       <para>
		    Rapporte le facteur d'échelle dans la sortie de <application>pgbench</application>.
        Avec des tests encastrés, ce n'est pas nécessaire&nbsp;; le facteur
        d'échelle approprié sera détecté en comptant le nombre de lignes
        dans la table <structname>pgbench_branches</structname>.
        Toutefois, lors de l'utilisation d'un benchmark avec un scénario
        personnalisé (option <option>-f</option>), le facteur
        d'échelle sera ramené à 1 à moins que cette option ne soit utilisée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-S</option></term>
      <term><option>--select-only</option></term>
      <listitem>
       <para>
        Run built-in select-only script.
        Shorthand for <option>-b select-only</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-t</option>
      <replaceable>transactions</replaceable></term>
      <term><option>--transactions=</option>
      <replaceable>transactions</replaceable></term>
      <listitem>
       <para>
		Nombre de transactions lancées par chaque client.
		La valeur par défaut est 10.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-T</option> <replaceable>seconds</replaceable></term>
      <term><option>--time=</option><replaceable>seconds</replaceable></term>
      <listitem>
       <para>
        Lance le test pour la durée spécifiée en secondes, plutôt que
        pour un nombre fixe de transactions par client.
        Les options <option>-t</option> et <option>-T</option> ne sont
        pas compatibles.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <term><option>--vacuum-all</option></term>
      <listitem>
       <para>
        Réalise l'opération de VACUUM sur les quatre tables standards avant de
        lancer le test. Sans l'option <option>-n</option> ou
        <option>-v</option>, <application>pgbench</application> fera un VACUUM
        sur les tables <structname>pgbench_tellers</structname> et
        <structname>pgbench_branches</structname>, puis tronquera
        <structname>pgbench_history</structname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--aggregate-interval=
      <replaceable>secondes</replaceable></option></term>
      <listitem>
       <para>
        Taille de l'intervalle d'agrégation (en secondes). Cett option peut
        uniquement être utilisée avec <application>-l</application>.
        Avec cette option, le journal contiendra des résumés par
        intervalle (nombre de transactions, latence min/max, et deux champs
        additionnels utiles à l'estimation de la variance).
       </para>
       <para>
        Cette option n'est pour l'instant pas supportée sur les
        systèmes d'exploitation Windows.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--sampling-rate=
      <replaceable>rate</replaceable></option></term>
      <listitem>
       <para>
        Le taux d'échantillonnage, est utilisé lors de l'écriture des
        données dans les journaux, afin de réduire la quantité de
        journaux générés.
		Si cette option est utilisée, il n'y a qu'une portion des
		transactions qui sont journalisées, suivant la proportion spécifiée.
		1.0 signifie que toutes les transactions sont journalisées,
		0.05 signifie que 5% de toutes les transactions sont
		journalisées.
       </para>
       <para>
		Pensez à prendre le taux d'échantillonnage en compte lorsque vous
		allez consulter le journal.
		Par exemple, lorsque vous évaluez les TPS, vous devrez multiplier
		les nombres en concordance. (Exemple, avec un taux
		d'échantillonage de 0.01, vous n'obtiendrez que 1/100 des TPS
		réelles).
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </refsect2>

 <refsect2 id="pgbench-common-options">
  <title>Options habituelles</title>

   <para>
    <application>pgbench</application> accepte les arguments suivants en
    ligne de commande&nbsp;:

    <variablelist>

     <varlistentry>
      <term><option>-h</option>
      <replaceable>hostname</replaceable></term>
      <term><option>--host=</option>
      <replaceable>hostname</replaceable></term>
      <listitem>
       <para>
        Le nom du serveur de base de données.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-p</option>
      <replaceable>port</replaceable></term>
      <term><option>--port=</option>
      <replaceable>port</replaceable></term>
      <listitem>
       <para>
        Le port d'écoute de l'instance sur le serveur de base de données.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-U</option>
      <replaceable>login</replaceable></term>
      <term><option>--username=</option>
      <replaceable>login</replaceable></term>
      <listitem>
       <para>
        Le nom de l'utilisateur avec lequel on se connecte à l'instance.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-V</option></term>
      <term><option>--version</option></term>
      <listitem>
       <para>
        Affiche la version de <application>pgbench</application>
        puis quitte.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-?</option></term>
      <term><option>--help</option></term>
      <listitem>
       <para>
         Affiche l'aide sur les arguments en ligne de commande de
		<application>pgbench</application> puis quitte.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

 </refsect2>
 </refsect1>

 <refsect1>
  <title>Notes</title>

 <refsect2>
  <title>Quelles sont les <quote>transactions</quote> réellement exécutées
  dans <application>pgbench</application>&nbsp;?</title>

  <para>
   <application>pgbench</application> executes test scripts chosen randomly
   from a specified list.
   They include built-in scripts with <option>-b</option> and
   user-provided custom scripts with <option>-f</option>.
   Each script may be given a relative weight specified after a
   <literal>@</literal> so as to change its drawing probability.
   The default weight is <literal>1</literal>.
   Scripts with a weight of <literal>0</literal> are ignored.
 </para>

  <para>
   The default builtin transaction script (also invoked with <option>-b tpcb-like</option>)
   issues seven commands per transaction over randomly chosen <literal>aid</literal>,
   <literal>tid</literal>, <literal>bid</literal> and <literal>balance</literal>.
   The scenario is inspired by the TPC-B benchmark, but is not actually TPC-B,
   hence the name.
  </para>

  <orderedlist>
   <listitem><para><literal>BEGIN;</literal></para></listitem>
   <listitem><para><literal>
   UPDATE pgbench_accounts SET abalance = abalance + :delta
   WHERE aid = :aid;</literal></para></listitem>
   <listitem><para><literal>SELECT abalance FROM pgbench_accounts
   WHERE aid = :aid;</literal></para></listitem>
   <listitem><para><literal>UPDATE pgbench_tellers
   SET tbalance = tbalance + :delta
   WHERE tid = :tid;</literal></para></listitem>
   <listitem><para><literal>UPDATE pgbench_branches
   SET bbalance = bbalance + :delta
   WHERE bid = :bid;</literal></para></listitem>
   <listitem><para><literal>INSERT
   INTO pgbench_history (tid, bid, aid, delta, mtime)
   VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
   </literal></para></listitem>
   <listitem><para><literal>END;</literal></para></listitem>
  </orderedlist>

  <para>
   If you select the <literal>simple-update</literal> builtin (also <option>-N</option>),
   steps 4 and 5 aren't included in the transaction.
   This will avoid update contention on these tables, but
   it makes the test case even less like TPC-B.
  </para>

  <para>
   If you select the <literal>select-only</literal> builtin (also <option>-S</option>),
   only the <command>SELECT</command> is issued.
  </para>
 </refsect2>

 <refsect2>
  <title>Scripts personnalisés</title>

  <para>
   <application>pgbench</application> est capable d'utiliser des
   scénarios de test de performances personnalisés qui remplacent le
   script de transactions par défaut (décrit ci-dessus) par un script de
   transactions lu depuis le fichier spécifié avec l'option
   (<option>-f</option>).
   Dans ce cas, une <quote>transaction</quote> est comptabilisée comme
   une exécution d'un fichier script.
  </para>

  <para>
   A script file contains one or more SQL commands terminated by
   semicolons.  Empty lines and lines beginning with
   <literal>--</literal> are ignored.  Script files can also contain
   des <quote>méta-commandes</quote>, qui seront interprétées par
   <application>pgbench</application> comme décrit dans la partie
   suivante.
  </para>

  <note>
   <para>
    Before <productname>PostgreSQL</productname> 9.6, SQL commands in script files
    were terminated by newlines, and so they could not be continued across
    lines.  Now a semicolon is <emphasis>required</emphasis> to separate consecutive
    SQL commands (though a SQL command does not need one if it is followed
    by a meta command).  If you need to create a script file that works with
    both old and new versions of <application>pgbench</application>, be sure to write
    each SQL command on a single line ending with a semicolon.
   </para>
  </note>

  <para>
   Il est possible simplement de substituer les variables dans les
   fichiers scripts.
   Les variables peuvent être instanciées via la ligne de commande avec
   l'option <option>-D</option> comme décrit ci-dessus ou grâce aux
   méta-commandes décrites ci-dessous.
   En plus des commandes pré-définies par l'option de la ligne de
   commande <option>-D</option>, il y a quelques variables qui sont
   automatiquement prédéfinies, listées sous
   <xref linkend="pgbench-automatic-variables"/>.
    Si une valeur pour l'une de ces variables a été définie via la
    ligne de commande avec l'option <option>-D</option>, elle sera prise
    en compte en priorité par rapport à la valeur définie
    automatiquement. Une fois définie, la valeur d'une variable peut
    être insérée dans les commandes SQL en écrivant <literal>:</literal>
    <replaceable>nom_variable</replaceable>.
    S'il y a plus d'une session par client, chaque session possède son
    propre jeu de variables.
  </para>

   <table id="pgbench-automatic-variables">
    <title>Variables automatiques</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Variable</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>scale</literal></entry>
       <entry>facteur d'echelle courant</entry>
      </row>

      <row>
       <entry><literal>client_id</literal></entry>
       <entry>nombre unique permettant d'identifier la session client
       (commence à zero)</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   Dans les fichiers de scripts, les méta-commandes commencent avec un
   anti-slash (<literal>\</literal>) and
   extend to the end of the line.
   Les arguments d'une méta-commande sont séparés par des espaces vides.
   Les méta-commmandes suivantes sont supportées&nbsp;:
  </para>

  <variablelist>
   <varlistentry id='pgbench-metacommand-set'>
    <term>
     <literal>\set <replaceable>nom_variable</replaceable>
     <replaceable>expression</replaceable></literal>
    </term>

    <listitem>
     <para>
	  Définit la variable <replaceable>nom_variable</replaceable> à une
	  valeur définie par <replaceable>expression</replaceable>.
      L'expression peut contenir un entier fixé comme
      <literal>5432</literal>, double constants such as <literal>3.14159</literal>, référencer des variables
      <literal>:</literal><replaceable>nom_variable</replaceable>,
      unary operators (<literal>+</literal>, <literal>-</literal>) and binary operators
      (<literal>+</literal>, <literal>-</literal>, <literal>*</literal>, <literal>/</literal>,
      <literal>%</literal>) with their usual precedence and associativity,
      <link linkend="pgbench-builtin-functions">function calls</link>, and
      parentheses.
     </para>

     <para>
      Exemples&nbsp;:
<programlisting>
\set ntellers 10 * :scale
\set aid (1021 * random(1, 100000 * :scale)) % (100000 * :scale) + 1
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\sleep
     <replaceable>number</replaceable> [ us | ms | s ]</literal>
    </term>

    <listitem>
     <para>
	  Entraîne la suspension de l'exécution du script pendant la durée
	  spécifiée en microsecondes (<literal>us</literal>), millisecondes
	  (<literal>ms</literal>) ou secondes (<literal>s</literal>).
	  Si l'unité n'est pas définie, l'unité par défaut est la seconde.
	  Il peut être soit un entier constant, soit une référence
	  <literal>:</literal><replaceable>nom_variable</replaceable> vers
	  une variable retournant un entier.
     </para>

     <para>
      Exemple&nbsp;:
<programlisting>
\sleep 10 ms
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\setshell <replaceable>nom_variable</replaceable>
     <replaceable>commande</replaceable> [
     <replaceable>argument</replaceable> ... ]</literal>
    </term>

    <listitem>
     <para>
      Définit la variable <replaceable>nom_variable</replaceable> comme
      le résultat d'une commande shell
      <replaceable>commande</replaceable> with the given <replaceable>argument</replaceable>(s).
      La commande doit retourner un entier sur la sortie standard.
     </para>

     <para>
      <replaceable>command</replaceable> and each <replaceable>argument</replaceable> can be either
      a text constant or a <literal>:</literal><replaceable>variablename</replaceable> reference
      to a variable. If you want to use an <replaceable>argument</replaceable> starting
      with a colon, write an additional colon at the beginning of
       <replaceable>argument</replaceable>.
     </para>

     <para>
      Example:
<programlisting>
\setshell variable_à_utiliser commande argument_litéral :variable
::literal_commencant_avec_deux_points
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\shell <replaceable>commande
     </replaceable> [ <replaceable>argument</replaceable> ... ]
     </literal>
    </term>

    <listitem>
     <para>
      Identique à <literal>\setshell</literal>, mais le résultat de la
      commande sera ignoré.
     </para>

     <para>
      Exemple&nbsp;:
<programlisting>
\shell command literal_argument :variable ::literal_starting_with_colon
</programlisting></para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect2>

 <refsect2 id="pgbench-builtin-functions">
  <title>Built-In Functions</title>

   <para>
     The following functions are built into <application>pgbench</application> and
     may be used in expressions appearing in
     <link linkend="pgbench-metacommand-set"><literal>\set</literal></link>.
   </para>

   <!-- list pgbench functions in alphabetical order -->
   <table>
    <title>pgbench Functions</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal><function>abs(<replaceable>a</replaceable>)</function></literal></entry>
       <entry>same as <replaceable>a</replaceable></entry>
       <entry>absolute value</entry>
       <entry><literal>abs(-17)</literal></entry>
       <entry><literal>17</literal></entry>
      </row>
      <row>
       <entry><literal><function>debug(<replaceable>a</replaceable>)</function></literal></entry>
       <entry>same as <replaceable>a</replaceable> </entry>
       <entry>print <replaceable>a</replaceable> to <systemitem>stderr</systemitem>,
        and return <replaceable>a</replaceable></entry>
       <entry><literal>debug(5432.1)</literal></entry>
       <entry><literal>5432.1</literal></entry>
      </row>
      <row>
       <entry><literal><function>double(<replaceable>i</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>cast to double</entry>
       <entry><literal>double(5432)</literal></entry>
       <entry><literal>5432.0</literal></entry>
      </row>
      <row>
       <entry><literal><function>greatest(<replaceable>a</replaceable> [, <replaceable>...</replaceable> ] )</function></literal></entry>
       <entry>double if any <replaceable>a</replaceable> is double, else integer</entry>
       <entry>largest value among arguments</entry>
       <entry><literal>greatest(5, 4, 3, 2)</literal></entry>
       <entry><literal>5</literal></entry>
      </row>
      <row>
       <entry><literal><function>int(<replaceable>x</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>cast to int</entry>
       <entry><literal>int(5.4 + 3.8)</literal></entry>
       <entry><literal>9</literal></entry>
      </row>
      <row>
       <entry><literal><function>least(<replaceable>a</replaceable> [, <replaceable>...</replaceable> ] )</function></literal></entry>
       <entry>double if any <replaceable>a</replaceable> is double, else integer</entry>
       <entry>smallest value among arguments</entry>
       <entry><literal>least(5, 4, 3, 2.1)</literal></entry>
       <entry><literal>2.1</literal></entry>
      </row>
      <row>
       <entry><literal><function>pi()</function></literal></entry>
       <entry>double</entry>
       <entry>value of the constant PI</entry>
       <entry><literal>pi()</literal></entry>
       <entry><literal>3.14159265358979323846</literal></entry>
      </row>
      <row>
       <entry><literal><function>random(<replaceable>lb</replaceable>, <replaceable>ub</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>uniformly-distributed random integer in <literal>[lb, ub]</literal></entry>
       <entry><literal>random(1, 10)</literal></entry>
       <entry>an integer between <literal>1</literal> and <literal>10</literal></entry>
      </row>
      <row>
       <entry><literal><function>random_exponential (<replaceable>lb</replaceable>, <replaceable>ub</replaceable>, <replaceable>parameter</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>exponentially-distributed random integer in <literal>[lb, ub]</literal>,
              see below</entry>
       <entry><literal>random_exponential(1, 10, 3.0)</literal></entry>
       <entry>an integer between <literal>1</literal> and <literal>10</literal></entry>
      </row>
      <row>
       <entry><literal><function>random_gaussian (<replaceable>lb</replaceable>, <replaceable>ub</replaceable>, <replaceable>parameter</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>gaussian-distributed random integer in <literal>[lb, ub]</literal>,
              see below</entry>
       <entry><literal>random_gaussian(1, 10, 2.5)</literal></entry>
       <entry>an integer between <literal>1</literal> and <literal>10</literal></entry>
      </row>
      <row>
       <entry><literal><function>sqrt(<replaceable>x</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>square root</entry>
       <entry><literal>sqrt(2.0)</literal></entry>
       <entry><literal>1.414213562</literal></entry>
      </row>
     </tbody>
     </tgroup>
   </table>

   <para>
    The <literal>random</literal> function generates values using a uniform
    distribution, that is all the values are drawn within the specified
    range with equal probability. The <literal>random_exponential</literal> and
    <literal>random_gaussian</literal> functions require an additional double
    parameter which determines the precise shape of the distribution.
   </para>

   <itemizedlist>
    <listitem>
     <para>
      For an exponential distribution, <replaceable>parameter</replaceable>
      controls the distribution by truncating a quickly-decreasing
      exponential distribution at <replaceable>parameter</replaceable>, and then
      projecting onto integers between the bounds.
      To be precise, with
<literallayout>
f(x) = exp(-parameter * (x - min) / (max - min + 1)) / (1 - exp(-parameter))
</literallayout>
      Then value <replaceable>i</replaceable> between <replaceable>min</replaceable> and
      <replaceable>max</replaceable> inclusive is drawn with probability:
      <literal>f(x) - f(x + 1)</literal>.
     </para>

     <para>
      Intuitively, the larger the <replaceable>parameter</replaceable>, the more
      frequently values close to <replaceable>min</replaceable> are accessed, and the
      less frequently values close to <replaceable>max</replaceable> are accessed.
      The closer to 0 <replaceable>parameter</replaceable> is, the flatter (more
      uniform) the access distribution.
      A crude approximation of the distribution is that the most frequent 1%
      values in the range, close to <replaceable>min</replaceable>, are drawn
      <replaceable>parameter</replaceable>% of the time.
      The <replaceable>parameter</replaceable> value must be strictly positive.
     </para>
    </listitem>

    <listitem>
     <para>
      For a Gaussian distribution, the interval is mapped onto a standard
      normal distribution (the classical bell-shaped Gaussian curve) truncated
      at <literal>-parameter</literal> on the left and <literal>+parameter</literal>
      on the right.
      Values in the middle of the interval are more likely to be drawn.
      To be precise, if <literal>PHI(x)</literal> is the cumulative distribution
      function of the standard normal distribution, with mean <literal>mu</literal>
      defined as <literal>(max + min) / 2.0</literal>, with
<literallayout>
 f(x) = PHI(2.0 * parameter * (x - mu) / (max - min + 1)) /
        (2.0 * PHI(parameter) - 1)
</literallayout>
      then value <replaceable>i</replaceable> between <replaceable>min</replaceable> and
      <replaceable>max</replaceable> inclusive is drawn with probability:
      <literal>f(i + 0.5) - f(i - 0.5)</literal>.
      Intuitively, the larger the <replaceable>parameter</replaceable>, the more
      frequently values close to the middle of the interval are drawn, and the
      less frequently values close to the <replaceable>min</replaceable> and
      <replaceable>max</replaceable> bounds. About 67% of values are drawn from the
      middle <literal>1.0 / parameter</literal>, that is a relative
      <literal>0.5 / parameter</literal> around the mean, and 95% in the middle
      <literal>2.0 / parameter</literal>, that is a relative
      <literal>1.0 / parameter</literal> around the mean; for instance, if
      <replaceable>parameter</replaceable> is 4.0, 67% of values are drawn from the
      middle quarter (1.0 / 4.0) of the interval (i.e. from
      <literal>3.0 / 8.0</literal> to <literal>5.0 / 8.0</literal>) and 95% from
      the middle half (<literal>2.0 / 4.0</literal>) of the interval (second and third
      quartiles). The minimum <replaceable>parameter</replaceable> is 2.0 for performance
      of the Box-Muller transform.
     </para>
    </listitem>
   </itemizedlist>

   <para>
   En tant qu'exemple, la définition complète de la construction
   de la transaction style TPC-B est&nbsp;:

<programlisting>
\set aid random(1, 100000 * :scale)
\set bid random(1, 1 * :scale)
\set tid random(1, 10 * :scale)
\set delta random(-5000, 5000)
BEGIN;
UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
END;
</programlisting>
   Ce script autorise chaque itération de la transaction à référencer
   des lignes différentes, sélectionnées aléatoirement.
   (Cet exemple montre aussi pourquoi il est important que chaque session
   cliente ait ses propres variables &mdash; sinon elles n'affecteront
   pas les différentes lignes de façon indépendantes.
  </para>

 </refsect2>

 <refsect2>
  <title>Connexion par transaction</title>

  <para>
   Avec l'option <option>-l</option> mais sans l'option
   <option>--aggregate-interval</option>,
   <application>pgbench</application> va écrire le temps utilisé par
   chaque transaction dans un fichier journal.
   Ce fichier journal s'appellera
   <filename>pgbench_log.<replaceable>nnn</replaceable></filename> où
   <replaceable>nnn</replaceable> est le PID du processus
   <application>pgbench</application>.
   Si l'option <option>-j</option> est positionnée à 2 ou plus,
   créant plusieurs processus de travail (<foreignphrase>worker</foreignphrase>),
   chacun aura son propre fichier journal.
   Le premier worker utilisera le même nom pour son fichier journal
   que dans le cas d'un seul processus.
   Les fichiers journaux supplémentaires s'appelleront
   <filename>pgbench_log.<replaceable>nnn</replaceable>.<replaceable>mmm</replaceable></filename>,
   où <replaceable>mmm</replaceable> est un numéro de séquence,
   identifiant chaque worker supplémentaire, en commençant à 1.
  </para>

  <para>
   Le format du journal est le suivant&nbsp;:

<synopsis>
<replaceable>id_client</replaceable> <replaceable>no_transaction</replaceable> <replaceable>temps</replaceable> <replaceable>no_script</replaceable> <replaceable>time_epoch</replaceable> <replaceable>time_us</replaceable> <optional><replaceable>schedule_lag</replaceable></optional>
</synopsis>

   Où <replaceable>temps</replaceable> est la durée totale de la
   transaction en micro secondes, <replaceable>no_script</replaceable>
   identifie quel fichier script est utilisé (très utile lorsqu'on
   utilise plusieurs scripts avec l'option <option>-f</option> ou
   <option>-b</option>), et
   <replaceable>time_epoch</replaceable>/<replaceable>time_us</replaceable>
   et un horodatage unix avec un décalage en micro secondes (utilisable pour
   créer un horodatage ISO 8601 avec des secondes fractionnées) qui montre
   à quel moment la transaction s'est terminée.

   Le champ <replaceable>schedule_lag</replaceable> est la différence
   entre la date de début planifiée de la transaction et la date de
   début effective de la transaction, en micro secondes.
   Il est présent uniquement lorsque l'option <option>--rate</option> est
   utilisée.
   Quand les options <option>--rate</option> et <option>--latency-limit</option>
   sont utilisées en même temp, le champ <replaceable>time</replaceable> pour
   une transaction ignorée sera rapportée en tant que <literal>skipped</literal>.

   Le dernier champ <replaceable>skipped_transactions</replaceable>
   rapporte le nombre de transactions ignorées car elles avaient trop de
   retard par rapport à la planification.
   Il est uniquement présent lorsque les deux options
   <option>--rate</option> et <option>--latency-limit</option>
   sont utilisées.
  </para>

  <para>
   Ci-dessous un extrait du fichier journal généré&nbsp;:
<screen>
 0 199 2241 0 1175850568 995598
 0 200 2465 0 1175850568 998079
 0 201 2513 0 1175850569 608
 0 202 2038 0 1175850569 2663
</screen>

   Un autre exemple avec les options <literal>--rate=100</literal> et
   <literal>--latency-limit=5</literal> (vous noterez
   la colonne supplémentaire <replaceable>schedule_lag</replaceable> )&nbsp;:
<screen>
 0 81 4621 0 1412881037 912698 3005
 0 82 6173 0 1412881037 914578 4304
 0 83 skipped 0 1412881037 914578 5217
 0 83 skipped 0 1412881037 914578 5099
 0 83 4722 0 1412881037 916203 3108
 0 84 4142 0 1412881037 918023 2333
 0 85 2465 0 1412881037 919759 740
</screen>
   Dans cet exemple, la transaction 82 est en retard, elle affiche une
   latence (6,173 ms) supérieure à la limite de 5 ms.
   Les deux transactions suivantes ont été ignorées car elles avaient
   déjà du retard avant même le début de la transaction.
  </para>

  <para>
   Dans le cas où on lance un test long, sur du matériel qui peut
   supporter un grand nombre de transactions, le fichier journal
   peut devenir très volumineux.
   L'option <option>--sampling-rate</option> peut être utilisée pour
   journaliser seulement un extrait aléatoire des transactions
   effectuées.
  </para>
 </refsect2>

 <refsect2>
  <title>Agrégation de la journalisation</title>

  <para>
   Avec l'option <option>--aggregate-interval</option>, les fichiers
   journaux utilisent un format quelque peu différent&nbsp;:

<synopsis>
<replaceable>début_intervalle</replaceable>
<replaceable>nombre_de_transations</replaceable>
<replaceable>somme_latence</replaceable>
<replaceable>somme latence_2</replaceable>
<replaceable>latence_minimum</replaceable>
<replaceable>latence_maximum</replaceable>
<optional><replaceable>somme_retard</replaceable>
<replaceable>somme_retard_2</replaceable>
<replaceable>retard_min</replaceable>
<replaceable>retard_max</replaceable>
<optional><replaceable>transactions_ignorées</replaceable>
</optional></optional>
</synopsis>

   Où <replaceable>début_intervalle</replaceable> est le début de
   l'intervalle (au format horodatage unix),
   <replaceable>nombre_de_transations</replaceable>  est le nombre de
   transactions dans l'intervalle,
   <replaceable>somme_latence</replaceable> est le cumul des latences
   (ce qui vous permet de déduire facilement la latence moyenne).
   Les deux champs suivants sont très utiles pour calculer la variance.
   En effet, <replaceable>somme_latence</replaceable> est la somme des
   latences, alors que <replaceable>somme_latence_2</replaceable> est la
   somme des latences au carré. Les deux derniers champs sont
   <replaceable>latence_min</replaceable>, la latence minimum dans
   l'intervalle, et <replaceable>latence_max</replaceable>, la latence
   maximum dans l'intervalle. Une transaction est comptée dans un
   intervalle à partir du moment où elle a été validée.
   Les derniers champs <replaceable>somme_retard</replaceable>,
   <replaceable>somme_retard_2</replaceable>,
   <replaceable>retard_min</replaceable>,
   et <replaceable>retard_max</replaceable> sont présents uniquement si
   l'option <option>--rate</option> a été spécifiée.
   Le tout dernier champ,
   <replaceable>transactions_ignorées</replaceable>, est présent
   uniquement si l'option <option>--latency-limit</option> a aussi été
   utilisée.
   Ils sont calculés sur le delta entre le moment où la transaction a
   pu commencer par rapport au moment la dernière s'est terminée,
   précisément la différence pour chaque transaction entre le moment où
   il était prévu qu'elle commence et le moment où elle a effectivement
   pu commencer.
  </para>

  <para>
   Voici un exemple de sortie&nbsp;:
<screen>
1345828501 5601 1542744 483552416 61 2573
1345828503 7884 1979812 565806736 60 1479
1345828505 7208 1979422 567277552 59 1391
1345828507 7685 1980268 569784714 60 1398
1345828509 7073 1979779 573489941 236 1411
</screen></para>

  <para>
   Notez que, tant que le fichier journal est brut (c'est-à-dire non
   agrégé), il contient une référence des fichiers scripts personnalisés
   que le fichier journal agrégé ne contient pas. De ce fait, si vous
   avez besoin des données de vos scripts, vous devrez agréger ces
   données vous-même.
  </para>

 </refsect2>

 <refsect2>
  <title>Latences par requête</title>

  <para>
   Avec l'option <option>-r</option>, <application>pgbench</application>
   collecte le temps de transaction écoulé pour chaque requête,
   exécutée par chaque client.
   Une fois que le test de performance est terminé, il rapporte une
   moyenne de ces valeurs, référencée comme la latence de chaque requête.
  </para>

  <para>
   Pour le script par défaut, le résultat aura la forme suivante&nbsp;:
<screen>
starting vacuum...end.
transaction type: &lt;builtin: TPC-B (sort of)&gt;
 scaling factor: 1
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
latency average = 15.844 ms
latency stddev = 2.715 ms
tps = 618.764555 (including connections establishing)
tps = 622.977698 (excluding connections establishing)
script statistics:
 - statement latencies in milliseconds:
        0.002  \set aid random(1, 100000 * :scale)
        0.005  \set bid random(1, 1 * :scale)
        0.002  \set tid random(1, 10 * :scale)
        0.001  \set delta random(-5000, 5000)
        0.326  BEGIN;
        0.603  UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
        0.454  SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
        5.528  UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
        7.335  UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
        0.371  INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
        1.212  END;
</screen>
  </para>

  <para>
   Les moyennes seront rapportées séparément si plusieurs scripts ont
   été spécifiés.
  </para>

  <para>
   Notez que la collecte supplémentaire des informations de
   chronométrage nécessaires pour la récupération de la latence par
   transaction induit une certaine surcharge.
   En effet, cela va réduire la vitesse moyenne calculée pour l'exécution
   des transactions et réduire le taux calculé des TPS.
   Le ralentissement varie de manière significative selon la
   plateforme et le matériel qui est utilisé pour le test.
   Comparer la moyenne des valeurs de TPS avec et sans l'intégration
   de la latence dans le test est une bonne manière de se rendre compte
   si la surcharge induite par le chronométrage est importante ou pas.
  </para>
 </refsect2>

 <refsect2>
  <title>Bonnes pratiques</title>

  <para>
   Il facile de se retrouver à utiliser
   <application>pgbench</application> et ne produire finalement que
   des résultats complètement insignifiants&nbsp;!
   Voici quelques conseils pour vous aider à récupérer des résultats
   pertinents.
  </para>

  <para>
   Tout d'abord, ne pensez <emphasis>jamais</emphasis> qu'un test ne
   peut durer que quelques secondes.
   Utilisez l'option <option>-t</option> ou <option>-T</option>
   pour vous assurer que le test dure au moins quelques minutes, de
   façon à lisser le bruit.
   Dans certains cas, il vous faudra des heures pour récupérer des
   valeurs reproductibles.
   Une bonne idée, lancez plusieurs fois votre test, de manière à vous
   rendre compte si les chiffres que vous obtenez sont ou pas
   reproductibles.
  </para>

  <para>
   Pour le scénario de test par défaut typé TPC-B, l'initialisation
   du facteur d'échelle (<option>-s</option>) devrait être au moins
   aussi grand que le nombre maximum de clients que vous avez
   l'intention de tester (<option>-c</option>)&nbsp;; sinon vous allez
   principalement tester la contention induite par les mises à jour.
   il n'y a que <option>-s</option> lignes dans la table
   <structname>pgbench_branches</structname>, et chaque transaction
   veut mettre à jour l'une de ces lignes, donc si la valeur de
   <option>-c</option> est supérieure à la valeur de <option>-s</option>,
   indubitablement, il en résultera de nombreuses transactions bloquées
   en attente de la fin d'autres transactions.
  </para>

  <para>
   Le moment où les tables ont été créées va sensiblement influencer le
   résultat du scénario de test par défaut, compte tenu de l'accumulation
   des lignes et espaces morts dans les tables lors du test.
   Pour comprendre les résultats, vous devriez garder une trace du
   nombre total de mises à jour ainsi que le moment où l'opération
   de VACUUM a lieu. Si la tâche autovacuum est active, il peut en
   résulter des variations imprévisibles dans les performances mesurées.
  </para>

  <para>
   Une limitation de <application>pgbench</application> est qu'il peut
   lui-même devenir le goulet d'étranglement lorsqu'il essaye de tester
   un grand nombre de sessions clientes.
   Cela peut être attenué en utilisant <application>pgbench</application>
   depuis une machine différente de la machine où se trouve la base
   de données, bien qu'une faible latence sur le réseau soit dans ce cas
   essentielle.
   Il peut même être utile de lancer plusieurs fois
   <application>pgbench</application> de manière concurrente, depuis
   plusieurs machines clientes vers le même serveur de base de données.
  </para>
 </refsect2>
 </refsect1>
</refentry>
