<?xml version="1.0" encoding="UTF-8"?>
<!-- doc/src/sgml/ref/pgbench.sgml -->

<refentry id="pgbench">
 <indexterm zone="pgbench">
  <primary>pgbench</primary>
 </indexterm>

 <refmeta>
  <refentrytitle><application>pgbench</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>pgbench</refname>
  <refpurpose>Réalise un test de benchmark pour
  <productname>PostgreSQL</productname></refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <cmdsynopsis>
   <command>pgbench</command>
   <arg choice="plain"><option>-i</option></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>nom_base</replaceable></arg>
  </cmdsynopsis>
  <cmdsynopsis>
   <command>pgbench</command>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>nom_base</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
 <para>
  <application>pgbench</application> est un programme pour réaliser simplement des
  tests de performance (<foreignphrase>benchmark</foreignphrase>)
  sur <productname>PostgreSQL</productname>.  Il
  exécute la même séquence de commandes SQL en continu, potentiellement
  avec plusieurs sessions concurrentes puis calcule le taux de
  transactions moyen (en transactions par secondes).
  Par défaut, <application>pgbench</application> teste un scénario
  vaguement basé sur TPC-B, impliquant cinq commandes <command>SELECT</command>,
  <command>UPDATE</command> et <command>INSERT</command> par
  transaction.
  Toutefois, il est facile de tester d'autres scénarios en écrivant
  vos propres scripts de transactions.
 </para>

 <para>
  Une sortie classique de <application>pgbench</application> ressemble
  à ceci&nbsp;:

<screen>
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 85.184871 (including connections establishing)
tps = 85.296346 (excluding connections establishing)
</screen>

  Les six premières lignes rapportent quelques-uns des paramètres
  les plus importants qui ont été définis.
  La ligne suivante remonte le nombre de transactions réalisées et
  prévues. (La seconde rapporte juste le ratio entre le nombre de
  clients et le nombre de transactions par client).
  Ils seront équivalents à moins que l'exécution ait échoué avant la fin.
  (Avec le mode <option>-T</option>, seul le nombre réel de transactions
  est affiché.)
  Les deux dernières lignes remontent le nombre de transactions par
  secondes incluant ou pas le temps utilisé à démarrer une session.
 </para>

  <para>
   Les transactions de ce test, proche de TPC-B, nécessitent d'avoir défini
   au préalable quelques tables spécifiques.
   <application>pgbench</application> devrait être utilisé avec l'option
   <option>-i</option> (initialisation) pour créer et remplir ces tables.
   (Si vous testez un script personnalisé, vous n'aurez pas besoin de
   cette étape, mais vous aurez besoin de mettre en place tout ce dont
   votre script aura besoin).
   Une initialisation ressemble à cela&nbsp;:

<programlisting>
pgbench -i <optional> <replaceable>autres-options</replaceable>
</optional> <replaceable>nom_base</replaceable>
</programlisting>

   où <replaceable>nom_base</replaceable> est le nom de la base de données
   pré-existante sur laquelle on conduit les tests. (Vous aurez aussi
   probablement besoin des options <option>-h</option>,
   <option>-p</option> et/ou <option>-U</option> pour spécifier comment
   se connecter au serveur de base de données.)
  </para>

  <caution>
   <para>
    <literal>pgbench -i</literal> crée quatre tables nommées
    <structname>pgbench_accounts</structname>,
    <structname>pgbench_branches</structname>,
    <structname>pgbench_history</structname> et
    <structname>pgbench_tellers</structname>,
    détruisant toute table qui porterait l'un de ces noms.
    Attention à utiliser une autre base de données si vous avez
    des tables qui portent ces noms&nbsp;!
   </para>
  </caution>

  <para>
   Par défaut, avec un facteur d'échelle de 1, les tables contiennent
   initialement les nombres de lignes suivants&nbsp;:
<screen>
table                   # de lignes
---------------------------------
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0
</screen>
   Vous pouvez (et, dans la plupart des cas, devriez) augmenter le nombre de
   lignes en utilisant l'option <option>-s</option>. Le facteur de remplissage
   <option>-F</option> peut aussi être utilisée à cet effet.
  </para>

  <para>
   Une fois la mise en place terminée, vous pouvez
   lancer vos benchmarks sans inclure l'option <option>-i</option>,
   c'est-à-dire&nbsp;:

<programlisting>
pgbench <optional> <replaceable>options</replaceable> </optional>
<replaceable>nom_base</replaceable>
</programlisting>

   Dans presque tous les cas, vous allez avoir besoin de certaines
   options pour rendre vos tests plus pertinents.
   Les options les plus importantes sont&nbsp;:
   <option>-c</option> (le nombre de clients),
   <option>-t</option> (le nombre de transactions),
   <option>-T</option> (l'intervalle de temps)
   et <option>-f</option> (le script à lancer).
   Vous trouverez ci-dessous toutes les options disponibles.
  </para>
 </refsect1>

 <refsect1>
  <title>Options</title>

  <para>
   La partie suivante est divisée en trois sous-parties&nbsp;: des options
   différentes sont utilisées pendant l'initialisation et pendant les tests ;
   certaines options sont utiles dans les deux cas.
  </para>

 <refsect2 id="pgbench-init-options">
  <title>Options d'initialisation</title>

   <para>
    Pour réaliser l'initialisation, <application>pgbench</application>
    accepte les arguments suivants en ligne de commande&nbsp;:

    <variablelist>

     <varlistentry>
      <term><option>-i</option></term>
      <term><option>--initialize</option></term>
      <listitem>
       <para>
        Nécessaire pour passer en mode initialisation.
       </para>
      </listitem>
     </varlistentry>

      <varlistentry>
      <term><option>-I <replaceable>init_steps</replaceable></option></term>
      <term><option>--init-steps=<replaceable>init_steps</replaceable></option></term>
       <listitem>
        <para>
        N'effectue qu'une partie des étapes d'initialisation habituelles.
        <replaceable>init_steps</replaceable> spécifie les étapes
        d'initialisation à exécuter, à raison d'un caractère par étape.
        Chaque étape est appelée dans l'ordre indiqué.
        La valeur par défaut est <literal>dtgvp</literal>. Voici la liste
        des différentes étapes disponibles&nbsp;:

        <variablelist>
         <varlistentry>
          <term><literal>d</literal> (Détruit)</term>
          <listitem>
           <para>
            Supprime toutes les tables <application>pgbench</application>
            déjà présentes.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>t</literal> (crée Tables)</term>
          <listitem>
           <para>
            Crée les tables utilisées par le scénario
            <application>pgbench</application> standard, à savoir
            <structname>pgbench_accounts</structname>,
            <structname>pgbench_branches</structname>,
            <structname>pgbench_history</structname> et
            <structname>pgbench_tellers</structname>.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>g</literal> (Génère les données)</term>
          <listitem>
           <para>
            Génère des données et les charge dans les tables standards,
            remplaçant toutes les données déjà présentes.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>v</literal> (Vacuum)</term>
          <listitem>
           <para>
            Appelle <command>VACUUM</command> sur les tables standards.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>p</literal> (clés Primaires)</term>
          <listitem>
           <para>
            Crée les clés primaires sur les tables standards.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
         <term><literal>f</literal> (<foreignphrase>Foreign keys
                                     </foreignphrase>)</term>
          <listitem>
           <para>
            Crée les contraintes de clés étrangères entre les
            différentes tables standards.
            (Notez que cette étape n'est pas exécutée par défaut.)
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-F</option>
      <replaceable>fillfactor</replaceable></term>
      <term><option>--fillfactor=
      </option><replaceable>fillfactor</replaceable></term>
      <listitem>
       <para>
        Crée les tables <structname>pgbench_accounts</structname>,
        <structname>pgbench_tellers</structname> et
        <structname>pgbench_branches</structname> avec le facteur de
        remplissage (<foreignphrase>fillfactor</foreignphrase>) spécifié.
        La valeur par défaut est 100.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>--no-vacuum</option></term>
      <listitem>
       <para>
        Ne réalise pas de VACUUM après l'initialisation.
        (Cette option supprime l'étape d'initialisation <literal>v</literal>,
        même si elle était précisée dans <option>-I</option>.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-q</option></term>
      <term><option>--quiet</option></term>
      <listitem>
       <para>
		Passe du mode verbeux au mode silencieux, en n'affichant
		qu'un message toutes les 5 secondes.
		Par défaut, on affiche un message toutes les 100&nbsp;000 lignes, ce
		qui engendre souvent plusieurs lignes
		toutes les secondes (particulièrement sur du bon matériel)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option>
      <replaceable>scale_factor</replaceable></term>
      <term><option>--scale=</option>
      <replaceable>scale_factor</replaceable></term>
      <listitem>
       <para>
        Multiplie le nombre de lignes générées par le facteur d'échelle
        (<foreignphrase>scale factor</foreignphrase>). Par exemple,
        <literal>-s 100</literal> va créer 10 millions de
        lignes dans la table <structname>pgbench_accounts</structname>. La
        valeur par défaut est 1. Lorsque l'échelle dépasse 20&nbsp;000, les
        colonnes utilisées pour contenir les identifiants de compte (colonnes
        <structfield>aid</structfield>) vont être converties en grands entiers
        (<type>bigint</type>), de manière à être suffisamment grandes pour
        contenir l'espace des identifiants de compte.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--foreign-keys</option></term>
      <listitem>
       <para>
        Crée des contraintes de type clé étrangère entre les tables standards.
        (Cette option ajoute l'étape d'initialisation <literal>f</literal>,
        si elle n'est pas déjà présente.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--index-tablespace=<replaceable>index_tablespace</replaceable>
      </option></term>
      <listitem>
       <para>
        Crée un index dans le tablespace spécifié plutôt que dans le
        tablespace par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--tablespace=<replaceable>tablespace</replaceable>
      </option></term>
      <listitem>
       <para>
        Crée une table dans le tablespace spécifié plutôt que dans le
        tablespace par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--unlogged-tables</option></term>
      <listitem>
       <para>
        Crée toutes les tables en tant que tables non journalisées
        (<foreignphrase>unlogged tables</foreignphrase>)
        plutôt qu'en tant que tables permanentes.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </refsect2>

 <refsect2 id="pgbench-run-options">
  <title>Options des benchmarks</title>

   <para>
    Pour réaliser un benchmark <application>pgbench</application>
    accepte les arguments suivants en ligne de commande&nbsp;:

    <variablelist>

     <varlistentry>
      <term><option>-b</option> <replaceable>nom_script[@poids]</replaceable></term>
      <term><option>--builtin</option>=<replaceable>nom_script[@poids]</replaceable></term>
      <listitem>
       <para>
        Ajoute le script interne spécifié à la liste des scripts exécutés.
        Le poids, un entier optionnel saisi après un <literal>@</literal>,
        permet d'ajuster la probabilité d'exécution
        du script. S'il n'est pas indiqué, le poids vaut 1. Les scripts
        internes disponibles sont <literal>tpcb-like</literal>,
        <literal>simple-update</literal> et <literal>select-only</literal>.
        Les préfixes non ambigus des noms de scripts internes
        sont acceptés. Avec le nom spécial <literal>list</literal>, la
        commande affiche la liste des scripts internes et quitte
        immédiatement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-c</option> <replaceable>clients</replaceable></term>
      <term><option>--client=
      </option><replaceable>clients</replaceable></term>
      <listitem>
       <para>
        Nombre de clients simulés, c'est-à-dire le nombre
        de sessions concurrentes sur la base de données.
        La valeur par défaut est à 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-C</option></term>
      <term><option>--connect</option></term>
      <listitem>
       <para>
		Établit une nouvelle connexion pour chaque transaction, plutôt
		que de ne le faire qu'une seule fois par session cliente.
		C'est une option très utile pour mesurer la surcharge engendrée
		par la connexion.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-d</option></term>
      <term><option>--debug</option></term>
      <listitem>
       <para>
        Affiche les informations de debug.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-D</option> <replaceable>variable</replaceable>
      <literal>=</literal><replaceable>value</replaceable></term>
      <term><option>--define=</option><replaceable>variable</replaceable>
      <literal>=</literal><replaceable>value</replaceable></term>
      <listitem>
       <para>
        Définit une variable à utiliser pour un script personnalisé
        Voir ci-dessous pour plus de détails.
        Il est possible d'utiliser plusieurs fois l'option <option>-D</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-f</option> <replaceable>nom_fichier[@poids]</replaceable></term>
      <term><option>--file=</option><replaceable>nom_fichier[@poids]</replaceable></term>
      <listitem>
       <para>
        Ajoute un script de transactions nommé
        <replaceable>nom_fichier</replaceable> à la liste des scripts
        exécutés. Un poids, sous la forme d'un
        entier optionnel après un <literal>@</literal>,
        permet d'ajuster la probabilité d'exécuter le test. Voir ci-dessous
        pour les détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-j</option> <replaceable>threads</replaceable></term>
      <term><option>--jobs=</option>
      <replaceable>threads</replaceable></term>
      <listitem>
       <para>
        Nombre de processus utilisés dans
        <application>pgbench</application>.
        Utiliser plus d'un thread peut être utile sur des machines
        possédant plusieurs cœurs.
        Les clients sont distribués de la manière la plus uniforme possible
        parmi les threads.
        La valeur par défaut est 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-l</option></term>
      <term><option>--log</option></term>
      <listitem>
       <para>
        Rapporte les informations sur chaque transaction dans un fichier
        journal.
        Voir ci-dessous pour plus de détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-L</option> <replaceable>limite</replaceable></term>
      <term><option>--latency-limit=</option><replaceable>limite</replaceable></term>
      <listitem>
       <para>
        Les transactions durant plus de <replaceable>limite</replaceable> millisecondes
        sont comptabilisée et rapportées séparément en tant que
        <firstterm>late</firstterm>.
       </para>
       <para>
        Lorsqu'un bridage est spécifié(<option>--rate=... </option>),
        les transactions qui accusent un retard sur la planification supérieur à
        <replaceable>limite</replaceable> millisecondes, et celles
        qui n'ont aucune chance de respecter la limite de latence
        ne sont pas du tout envoyées au serveur.
        Elles sont comptabilisées et rapportées séparément en tant que
        <firstterm>skipped</firstterm> (ignorées).
       </para>
       </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-M</option>
      <replaceable>querymode</replaceable></term>
      <term><option>--protocol=</option>
      <replaceable>querymode</replaceable></term>
      <listitem>
       <para>
		Protocole à utiliser pour soumettre des requêtes au serveur&nbsp;:
          <itemizedlist>
           <listitem>
            <para><literal>simple</literal>&nbsp;: utilisation du protocole
            de requêtes standards.</para>
           </listitem>
           <listitem>
            <para><literal>extended</literal>&nbsp;: utilisation du protocole
            de requête étendu.</para>
           </listitem>
           <listitem>
            <para><literal>prepared</literal>&nbsp;: utilisation du protocole
            de requête étendu avec instructions préparées.</para>
           </listitem>
          </itemizedlist>

        Because in "prepared" mode <application>pgbench</application> reuses
        the parse analysis result for the second and subsequent query
        iteration, <application>pgbench</application> runs faster in the
        prepared mode than in other modes.
       </para>
       <para>
        Par défaut, le protocole de requête standard est utilisé
        (voir <xref linkend="protocol"/> pour plus d'informations).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>--no-vacuum</option></term>
      <listitem>
       <para>
		Ne réalise pas de VACUUM avant de lancer le test.
		Cette option est <emphasis>nécessaire</emphasis> si vous lancez
		un scénario de test personnalisé qui n'utilise pas les tables
		standards <structname>pgbench_accounts</structname>,
        <structname>pgbench_branches</structname>, <structname>
	    pgbench_history</structname> et <structname>pgbench_tellers
	    </structname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-N</option></term>
      <term><option>--skip-some-updates</option></term>
      <listitem>
       <para>
        Exécute le script interne simple-update. Raccourci pour
        <option>-b simple-update</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-P</option> <replaceable>sec</replaceable></term>
      <term><option>--progress=</option>
      <replaceable>sec</replaceable></term>
      <listitem>
       <para>
        Affiche un rapport de progression toutes les
        <replaceable>sec</replaceable> secondes.
        Ce rapport inclut la durée du test, le nombre de
        transactions par seconde depuis le dernier rapport et la
        latence moyenne des transactions, ainsi que la déviation
        depuis le dernier rapport.
        Avec le bridage (option <option>-R</option>), la latence est calculée
        en fonction de la date de démarrage ordonnancée de la transaction et non
        de son temps de démarrage réel, donc elle inclut aussi la latence
        moyenne du temps d'ordonnancement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-r</option></term>
      <term><option>--report-latencies</option></term>
      <listitem>
       <para>
        Rapporte la latence moyenne par instruction (temps d'exécution
        du point de vue du client) de chaque commande après la fin du
        benchmark.
        Voir ci-dessous pour plus de détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-R</option> <replaceable>rate</replaceable></term>
      <term><option>--rate=</option><replaceable>rate</replaceable></term>
      <listitem>
       <para>
		Exécute les transactions en visant le débit spécifié,
        au lieu d'aller le plus vite possible (le défaut).
        Le débit est donné en transactions par seconde.
		Si le débit visé est supérieur au maximum possible, la
		limite de débit n'aura aucune influence sur le résultat.
       </para>
       <para>
		Pour atteindre ce débit, les transactions sont ordonnancées avec
        une distribution suivant une loi de Poisson.
		La date de démarrage prévue se calcule depuis le moment où le client a
		démarré et pas depuis le moment où la dernière transaction s'est achevée.
		Cette approche signifie que, si une transaction
		dépasse sa date de fin prévue, un rattrapage est encore possible
		pour les suivantes.
       </para>
       <para>
		Lorsque le bridage est actif, la latence de la transaction rapportée en
        fin de test est calculée à partir des dates de démarrage ordonnancées,
        c'est-à-dire qu'elle inclut le temps où chaque transaction attend
        que la précédente se termine.
		Le temps d'attente est appelé temps de latence d'ordonnancement,
		et ses valeurs moyenne et maximum sont rapportées séparément.
        La latence de transaction par rapport au temps de démarrage réel,
        c'est-à-dire le temps d'exécution de la transaction
		dans la base, peut être récupérée en soustrayant le temps de
		latence d'ordonnancement à la latence précisée dans les journaux.
       </para>

       <para>
        Si l'option <option>--latency-limit</option> est utilisée avec
        l'option  <option>--rate</option>, une transaction peut avoir
        une telle latence qu'elle serait déjà supérieure à limite de
        latence lorsque la transaction précédente se termine, car la
        latence est calculée au moment de la date de démarrage planifiée.
        Les transactions concernées ne sont pas envoyées à l'instance,
        elles sont complètement ignorées et comptabilisées séparément.
       </para>

       <para>
		Une latence de planification élevée est une indication
		que le système n'arrive pas à traiter les transactions à la vitesse
        demandée, avec les nombres de clients et threads indiqués.
		Lorsque le temps moyen d'exécution est plus important que
		l'intervalle prévu entre chaque transaction, les transactions
        vont prendre du retard une-à-une, et la latence de
		planification va continuer de croître tout le long de la durée
		du test.
		Si cela se produit, vous devrez réduire le taux de transaction
		que vous avez spécifié.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>scale_factor</replaceable></term>
      <term><option>--scale=</option><replaceable>scale_factor</replaceable></term>
      <listitem>
       <para>
		Affiche le facteur d'échelle dans la sortie de <application>pgbench</application>.
        Avec les tests internes, ce n'est pas nécessaire&nbsp;; le facteur
        d'échelle approprié sera détecté en comptant le nombre de lignes
        dans la table <structname>pgbench_branches</structname>.
        Toutefois, lors de l'utilisation d'un benchmark avec un scénario
        personnalisé (option <option>-f</option>), le facteur
        d'échelle sera affiché à 1 à moins que cette option soit utilisée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-S</option></term>
      <term><option>--select-only</option></term>
      <listitem>
       <para>
        Exécute le script interne select-only. Raccourci pour
        <option>-b select-only</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-t</option>
      <replaceable>transactions</replaceable></term>
      <term><option>--transactions=</option>
      <replaceable>transactions</replaceable></term>
      <listitem>
       <para>
		Nombre de transactions lancées par chaque client.
		La valeur par défaut est 10.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-T</option> <replaceable>seconds</replaceable></term>
      <term><option>--time=</option><replaceable>seconds</replaceable></term>
      <listitem>
       <para>
        Lance le test pour la durée spécifiée en secondes, plutôt que
        pour un nombre fixe de transactions par client.
        Les options <option>-t</option> et <option>-T</option> ne sont
        pas compatibles.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <term><option>--vacuum-all</option></term>
      <listitem>
       <para>
        Réalise un VACUUM sur les quatre tables standards avant de
        lancer le test. Sans l'option <option>-n</option> ou
        <option>-v</option>, <application>pgbench</application> lancera un VACUUM
        sur les tables <structname>pgbench_tellers</structname> et
        <structname>pgbench_branches</structname>, puis tronquera
        <structname>pgbench_history</structname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--aggregate-interval=
      <replaceable>secondes</replaceable></option></term>
      <listitem>
       <para>
        Taille de l'intervalle d'agrégation (en secondes). Ne peut
        être utilisée qu'avec l'option <application>-l</application>.
        Avec cette option, le journal contiendra des résumés par
        intervalle, comme décrit ci-dessous.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--log-prefix=<replaceable>prefix</replaceable></option></term>
      <listitem>
       <para>
        Définit le préfixe des fichiers logs créés par <option>--log</option>.
        Le défaut est <literal>pgbench_log</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--progress-timestamp</option></term>
      <listitem>
       <para>
        Lorsque la progression est affichée (option <option>-P</option>),
        utilise un horodatage de type timestamp (epoch Unix) au lieu d'un
        nombre de secondes depuis le début de l'exécution. L'unité est la
        seconde avec une précision en millisecondes après le point. Ceci
        aide à comparer les traces générées par différents outils.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--random-seed=</option><replaceable>SEED</replaceable></term>
      <listitem>
       <para>
        Fournit la graine du générateur de nombres aléatoires, qui produira
        alors une séquence d'états initiaux du générateur, un pour chaque
        thread.
        Les valeurs pour <replaceable>SEED</replaceable> peuvent être&nbsp;
        <literal>time</literal> (par défaut, la graine est basée sur l'heure en
        cours), <literal>rand</literal> (utilise une source fortement aléatoire,
        et tombe en échec si aucune n'est disponible), ou une valeur entière
        non signée.
        Le générateur aléatoire est appelé depuis un script
        pgbench explicitement (fonctions <literal>random...</literal>) ou
        implicitement (par exemple l'option <option>--rate</option> l'utilise
        pour planifier les transactions).
        Si elle est mise en place explicitement, la valeur utilisée comme
        graine est affichée sur le terminal.
        N'importe quelle valeur autorisée pour <replaceable>SEED</replaceable>
        peut aussi être fournie par la variable d'environnement
        <literal>PGBENCH_RANDOM_SEED</literal>.
        Pour garantir que la graine fournie couvre tous les cas d'usage
        possibles, mettez cette fonction en premier ou utilisez la variable
        d'environnement.
      </para>
      <para>
        Placer cette variable explicitement permet de reproduire un run
        <command>pgbench</command> exactement identique, du moins en ce qui
        concerne les nombres aléatoires.
        Comme l'état du générateur aléatoire est géré par thread,
        <command>pgbench</command> s'exécutera à l'identique s'il y a un client
        par thread et pas de dépendance externe ou par rapport aux données.
        D'un point de vue statistique, reproduire des runs est une mauvaise
        idée, car cela peut masquer la variabilité des performances ou
        améliorer les performances excessivement, par exemple en appelant les
        mêmes pages qu'un run précédent.
        Cependant, ce peut être d'une grande aide pour déboguer, par exemple
        pour reproduire un cas tordu provoquant une erreur. À utiliser
        judicieusement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--sampling-rate=
      <replaceable>rate</replaceable></option></term>
      <listitem>
       <para>
        Taux d'échantillonnage utilisé lors de l'écriture des
        données dans les journaux, afin d'en réduire la quantité.
		Si cette option est utilisée, n'y sera écrite que la proportion
        indiquée des transactions.
		1.0 signifie que toutes les transactions seront journalisées,
		0.05 signifie que 5% de toutes les transactions le seront.
       </para>
       <para>
		Pensez à prendre le taux d'échantillonnage en compte en consultant
        le journal.
		Par exemple, lorsque vous évaluez le nombre de transactions par seconde,
        vous devrez multiplier les nombres en conséquence. (Par exemple,
        avec un taux d'échantillonnage de 0,01, vous n'obtiendrez que 1/100 du
        tps réel).
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </refsect2>

 <refsect2 id="pgbench-common-options">
  <title>Options courantes</title>

   <para>
    <application>pgbench</application> accepte les arguments suivants en
    ligne de commande&nbsp;:

    <variablelist>

     <varlistentry>
      <term><option>-h</option>
      <replaceable>hostname</replaceable></term>
      <term><option>--host=</option>
      <replaceable>hostname</replaceable></term>
      <listitem>
       <para>
        Le nom du serveur de base de données
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-p</option>
      <replaceable>port</replaceable></term>
      <term><option>--port=</option>
      <replaceable>port</replaceable></term>
      <listitem>
       <para>
        Le port d'écoute de l'instance sur le serveur de base de données
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-U</option>
      <replaceable>login</replaceable></term>
      <term><option>--username=</option>
      <replaceable>login</replaceable></term>
      <listitem>
       <para>
        Le nom de l'utilisateur avec lequel on se connecte
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-V</option></term>
      <term><option>--version</option></term>
      <listitem>
       <para>
        Affiche la version de <application>pgbench</application>
        puis quitte.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-?</option></term>
      <term><option>--help</option></term>
      <listitem>
       <para>
         Affiche l'aide sur les arguments en ligne de commande de
		<application>pgbench</application> puis quitte.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

 </refsect2>
 </refsect1>

 <refsect1>
  <title>Exit Status</title>

  <para>
   A successful run will exit with status 0.  Exit status 1 indicates static
   problems such as invalid command-line options.  Errors during the run such
   as database errors or problems in the script will result in exit status 2.
   In the latter case, <application>pgbench</application> will print partial
   results.
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

 <refsect2>
  <title>Quelles sont les <quote>transactions</quote> réellement exécutées
  dans <application>pgbench</application>&nbsp;?</title>

  <para>
   <application>pgbench</application> exécute des scripts de tests choisis de
   façon aléatoire à partir d'une liste. Cela inclut des scripts internes
   avec l'option <option>-b</option> et des scripts fournis par
   l'utilisateur avec l'option <option>-f</option>. Chaque script peut se
   voir associer un poids relatif, indiqué après un <literal>@</literal>,
   pour changer sa probabilité d'exécution. Le poids par défaut est
   <literal>1</literal>. Les scripts avec un poids de <literal>0</literal>
   sont ignorés.
  </para>

  <para>
   Le script interne par défaut (aussi appelé avec <option>-b tpcb-like</option>)
   exécute sept commandes par transaction choisies de
   façon aléatoire parmi <literal>aid</literal>, <literal>tid</literal>,
   <literal>bid</literal> et <literal>balance</literal>. Le scénario s'inspire
   du jeu de tests de performance TPC-B benchmark mais il ne s'agit pas
   réellement de TPC-B, d'où son nom.
  </para>

  <orderedlist>
   <listitem><para><literal>BEGIN;</literal></para></listitem>
   <listitem><para><literal>
   UPDATE pgbench_accounts SET abalance = abalance + :delta
   WHERE aid = :aid;</literal></para></listitem>
   <listitem><para><literal>SELECT abalance FROM pgbench_accounts
   WHERE aid = :aid;</literal></para></listitem>
   <listitem><para><literal>UPDATE pgbench_tellers
   SET tbalance = tbalance + :delta
   WHERE tid = :tid;</literal></para></listitem>
   <listitem><para><literal>UPDATE pgbench_branches
   SET bbalance = bbalance + :delta
   WHERE bid = :bid;</literal></para></listitem>
   <listitem><para><literal>INSERT
   INTO pgbench_history (tid, bid, aid, delta, mtime)
   VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
   </literal></para></listitem>
   <listitem><para><literal>END;</literal></para></listitem>
  </orderedlist>

  <para>
   Si vous sélectionnez le script interne <literal>simple-update</literal> (ou
   <option>-N</option>), les étapes 4 et 5 ne sont pas incluses dans la
   transaction. Ceci évitera des contentions au niveau des mises à jour sur
   ces tables, mais le test ressemblera encore moins à TPC-B.
  </para>

  <para>
   Si vous sélectionnez le script interne <literal>select-only</literal> (ou
   <option>-S</option>), alors seul le <command>SELECT</command> est exécuté.
  </para>
 </refsect2>

 <refsect2>
  <title>Scripts personnalisés</title>

  <para>
   <application>pgbench</application> est capable d'utiliser des
   scénarios de test de performance personnalisés, en remplaçant le
   script de transactions par défaut (décrit ci-dessus) par un script de
   transactions lu depuis un fichier spécifié avec l'option
   (<option>-f</option>).
   Dans ce cas, une <quote>transaction</quote> est comptabilisée comme
   une exécution du fichier script.
  </para>

  <para>
   Un fichier script contient une ou plusieurs commandes SQL terminées par des
   points-virgules. Les lignes vides et les lignes commençant par
   <literal>--</literal> sont ignorées. Les fichiers scripts peuvent aussi
   contenir des <quote>méta-commandes</quote>, qui seront interprétées par
   <application>pgbench</application> comme indiqué plus bas.
  </para>

  <note>
   <para>
    Avant <productname>PostgreSQL</productname> 9.6, les commandes SQL comprises
    dans les fichiers scripts étaient terminées par un retour à la ligne.
    Elles ne pouvaient donc pas être écrites sur plusieurs lignes. Maintenant,
    un point-virgule est <emphasis>requis</emphasis> pour séparer des
    commandes SQL consécutives (bien qu'une commande SQL n'en a pas besoin si
    elle est suivie par une méta-commande). Si vous avez besoin de créer un
    fichier script qui fonctionne avec les anciennes et nouvelles versions de
    <application>pgbench</application>, assurez-vous d'écrire chaque commande
    SQL sur une seule ligne et en terminant avec un point-virgule.
   </para>
  </note>

  <para>
   Il est possible de procéder facilement à de la substitution de variables
   dans les fichiers scripts.
   Les noms de variables doivent consister en lettres (y compris des caractères
   non-Latin), chiffres et soulignés (<literal>_</literal>).
   Les variables peuvent être instanciées via
   l'option <option>-D</option> de la ligne de commande comme décrit ci-dessus,
   ou grâce aux méta-commandes décrites ci-dessous.
   En plus des commandes pré-définies par l'option de la ligne de
   commande <option>-D</option>, quelques variables sont
   automatiquement prédéfinies, listées sous
   <xref linkend="pgbench-automatic-variables"/>.
    Une valeur de ces variables définie via l'option <option>-D</option>
    aura priorité sur la valeur définie
    automatiquement. Une fois définie, la valeur d'une variable peut
    être insérée dans les commandes SQL en écrivant <literal>:</literal>
    <replaceable>nom_variable</replaceable>.
    S'il y a plus d'une session par client, chaque session possède son
    propre jeu de variables.
   <application>pgbench</application> supports up to 255 variable uses in one
   statement.
  </para>

   <table id="pgbench-automatic-variables">
    <title>Variables automatiques</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Variable</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>client_id</literal></entry>
       <entry>nombre unique permettant d'identifier la session client
       (commence à zéro)</entry>
      </row>

      <row>
       <entry> <literal>default_seed</literal> </entry>
       <entry>graine utilisée par défaut dans les fonctions de hachage</entry>
      </row>

      <row>
       <entry> <literal>random_seed</literal> </entry>
       <entry>graine du générateur aléatoire (si pas remplacée avec
               <option>-D</option>)</entry>
      </row>

      <row>
       <entry><literal>scale</literal></entry>
       <entry>facteur d'échelle courant</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   Dans les fichiers de scripts, les méta-commandes commencent avec un
   anti-slash (<literal>\</literal>) et s'étendent jusqu'à la fin de la ligne,
   même si elles peuvent s'étendre sur plusieurs lignes en écrivant anti-slash
   puis un retour chariot. Les
   arguments d'une méta-commande sont séparés par des espaces vides. Les
   méta-commmandes suivantes sont supportées&nbsp;:
  </para>

  <variablelist>
   <varlistentry id='pgbench-metacommand-gset'>
    <term>
     <literal>\gset [<replaceable>prefix</replaceable>]</literal>
    </term>

    <listitem>
     <para>
      This command may be used to end SQL queries, taking the place of the
      terminating semicolon (<literal>;</literal>).
     </para>

     <para>
      When this command is used, the preceding SQL query is expected to
      return one row, the columns of which are stored into variables named after
      column names, and prefixed with <replaceable>prefix</replaceable> if provided.
     </para>

     <para>
      The following example puts the final account balance from the first query
      into variable <replaceable>abalance</replaceable>, and fills variables
      <replaceable>p_two</replaceable> and <replaceable>p_three</replaceable>
      with integers from the third query.
      The result of the second query is discarded.
<programlisting>
UPDATE pgbench_accounts
  SET abalance = abalance + :delta
  WHERE aid = :aid
  RETURNING abalance \gset
-- compound of two queries
SELECT 1 \;
SELECT 2 AS two, 3 AS three \gset p_
</programlisting>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>\if</literal> <replaceable class="parameter">expression</replaceable></term>
    <term><literal>\elif</literal> <replaceable class="parameter">expression</replaceable></term>
    <term><literal>\else</literal></term>
    <term><literal>\endif</literal></term>
    <listitem>
     <para>
      Ce groupe de commandes implémente des blocs conditionnels imbriquables,
      de manière similaire au <xref linkend="psql-metacommand-if"/> de
      <literal>psql</literal>.
      Les expressions conditionnelles sont identiques à celles avec
      <literal>\set</literal>, les valeurs autres que zéro valant
      <literal>true</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id='pgbench-metacommand-set'>
    <term>
     <literal>\set <replaceable>nom_variable</replaceable>
     <replaceable>expression</replaceable></literal>
    </term>

    <listitem>
     <para>
      Définit la variable <replaceable>nom_variable</replaceable> à une valeur
      définie par <replaceable>expression</replaceable>.

      L'expression peut contenir la constante <literal>NULL</literal>,
      les constantes booléennes <literal>TRUE</literal> et
      <literal>FALSE</literal>, des constantes entières comme
      <literal>5432</literal>, des constantes double précision comme
      <literal>3.14159</literal>, des références à des variables
      <literal>:</literal><replaceable>nomvariable</replaceable>,
      des <link linkend="pgbench-builtin-operators">opérateurs</link> avec leur
      priorité et leur associativité habituelles en SQL,
      <link linkend="pgbench-builtin-functions">des appels de fonction</link>,
      des
      <link linkend="functions-case">expressions conditionnelles génériques SQL
      avec <token>CASE</token></link> et des parenthèses.
     </para>

     <para>
      Les fonctions et la plupart des opérateurs retournent
      <literal>NULL</literal> en cas d'entrée à <literal>NULL</literal>.
     </para>

     <para>
      En ce qui concerne les conditions, les valeurs numériques différentes de
      zéro valent <literal>TRUE</literal>, les valeurs numériques à zéro et
      <literal>NULL</literal> sont <literal>FALSE</literal>.
     </para>

     <para>
      Too large or small integer and double constants, as well as
      integer arithmetic operators (<literal>+</literal>,
      <literal>-</literal>, <literal>*</literal> and <literal>/</literal>)
      raise errors on overflows.
     </para>

     <para>
      Quand aucune clause finale <token>ELSE</token> n'est fournie à un
      <token>CASE</token>, la valeur par défaut est <literal>NULL</literal>.
     </para>

     <para>
      Exemples&nbsp;:
<programlisting>
\set ntellers 10 * :scale
\set aid (1021 * random(1, 100000 * :scale)) % \
           (100000 * :scale) + 1
\set divx CASE WHEN :x &lt;&gt; 0 THEN :y/:x ELSE NULL END
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\sleep
     <replaceable>nombre</replaceable> [ us | ms | s ]</literal>
    </term>

    <listitem>
     <para>
	  Entraîne la suspension de l'exécution du script pendant la durée
	  spécifiée en microsecondes (<literal>us</literal>), millisecondes
	  (<literal>ms</literal>) ou secondes (<literal>s</literal>).
	  Si l'unité n'est pas définie, l'unité par défaut est la seconde.
	  Ce peut être soit un entier constant, soit une référence
	  <literal>:</literal><replaceable>nom_variable</replaceable> vers
	  une variable retournant un entier.
     </para>

     <para>
      Exemple&nbsp;:
<programlisting>
\sleep 10 ms
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\setshell <replaceable>nom_variable</replaceable>
     <replaceable>commande</replaceable> [
     <replaceable>argument</replaceable> ... ]</literal>
    </term>

    <listitem>
     <para>
      Définit la variable <replaceable>nom_variable</replaceable> comme le
      résultat d'une commande shell nommée <replaceable>commande</replaceable>
      aves le(s) <replaceable>argument</replaceable>(s) donné(s). La commande
      doit retourner un entier sur la sortie standard.
     </para>

     <para>
      <replaceable>commande</replaceable> et chaque
      <replaceable>argument</replaceable> peuvent être soit une constante de
      type text, soit une référence
      <literal>:</literal><replaceable>nom_variable</replaceable> à une variable.
      Si vous voulez utiliser un <replaceable>argument</replaceable> commençant
      avec un symbole deux-points, écrivez un deux-points supplémentaire au
      début de l'<replaceable>argument</replaceable>.
     </para>

     <para>
      Exemple&nbsp;:
<programlisting>
\setshell variable_à_utiliser commande argument_litéral :variable
::literal_commencant_avec_deux_points
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\shell <replaceable>commande
     </replaceable> [ <replaceable>argument</replaceable> ... ]
     </literal>
    </term>

    <listitem>
     <para>
      Identique à <literal>\setshell</literal>, mais le résultat de la
      commande sera ignoré.
     </para>

     <para>
      Exemple&nbsp;:
<programlisting>
\shell command literal_argument :variable ::literal_starting_with_colon
</programlisting></para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect2>

 <refsect2 id="pgbench-builtin-operators">
  <title>Opérateurs intégrés</title>

  <para>
   Les opérateurs arithmétiques, de manipulation de bits, de comparaison et
   logiques listés dans <xref linkend="pgbench-operators"/> sont intégrés
   dans <application>pgbench</application> et peuvent être utilisés dans des
   expressions apparaissant dans <link linkend="pgbench-metacommand-set">
   <literal>\set</literal></link>.
  </para>

  <table id="pgbench-operators">
   <title>Opérateurs pgbench par priorité croissante</title>
   <tgroup cols="4">
    <thead>
     <row>
      <entry>Opérateur</entry>
      <entry>Description</entry>
      <entry>Exemple</entry>
      <entry>Résultat</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>OR</literal></entry>
      <entry>ou logique</entry>
      <entry><literal>5 or 0</literal></entry>
      <entry><literal>TRUE</literal></entry>
     </row>
     <row>
      <entry><literal>AND</literal></entry>
      <entry>et logique</entry>
      <entry><literal>3 and 0</literal></entry>
      <entry><literal>FALSE</literal></entry>
     </row>
     <row>
      <entry><literal>NOT</literal></entry>
      <entry>non logique</entry>
      <entry><literal>not false</literal></entry>
      <entry><literal>TRUE</literal></entry>
     </row>
     <row>
      <entry><literal>IS [NOT] (NULL|TRUE|FALSE)</literal></entry>
      <entry>tests de valeurs</entry>
      <entry><literal>1 is null</literal></entry>
      <entry><literal>FALSE</literal></entry>
     </row>
     <row>
      <entry><literal>ISNULL|NOTNULL</literal></entry>
      <entry>tests sur NULL</entry>
      <entry><literal>1 notnull</literal></entry>
      <entry><literal>TRUE</literal></entry>
     </row>
     <row>
      <entry><literal>=</literal></entry>
      <entry>est égal</entry>
      <entry><literal>5 = 4</literal></entry>
      <entry><literal>FALSE</literal></entry>
     </row>
     <row>
      <entry><literal>&lt;&gt;</literal></entry>
      <entry>n'est pas égal</entry>
      <entry><literal>5 &lt;&gt; 4</literal></entry>
      <entry><literal>TRUE</literal></entry>
     </row>
     <row>
      <entry><literal>!=</literal></entry>
      <entry>n'est pas égal</entry>
      <entry><literal>5 != 5</literal></entry>
      <entry><literal>FALSE</literal></entry>
     </row>
     <row>
      <entry><literal>&lt;</literal></entry>
      <entry>inférieur à</entry>
      <entry><literal>5 &lt; 4</literal></entry>
      <entry><literal>FALSE</literal></entry>
     </row>
     <row>
      <entry><literal>&lt;=</literal></entry>
      <entry>inférieur ou égal</entry>
      <entry><literal>5 &lt;= 4</literal></entry>
      <entry><literal>FALSE</literal></entry>
     </row>
     <row>
      <entry><literal>&gt;</literal></entry>
      <entry>plus grand que</entry>
      <entry><literal>5 &gt; 4</literal></entry>
      <entry><literal>TRUE</literal></entry>
     </row>
     <row>
      <entry><literal>&gt;=</literal></entry>
      <entry>plus grand ou égal</entry>
      <entry><literal>5 &gt;= 4</literal></entry>
      <entry><literal>TRUE</literal></entry>
     </row>
     <row>
      <entry><literal>|</literal></entry>
      <entry>OU binaire sur entier</entry>
      <entry><literal>1 | 2</literal></entry>
      <entry><literal>3</literal></entry>
     </row>
     <row>
      <entry><literal>#</literal></entry>
      <entry>XOR binaire sur entier</entry>
      <entry><literal>1 # 3</literal></entry>
      <entry><literal>2</literal></entry>
     </row>
     <row>
      <entry><literal>&amp;</literal></entry>
      <entry>ET binaire sur entier</entry>
      <entry><literal>1 &amp; 3</literal></entry>
      <entry><literal>1</literal></entry>
     </row>
     <row>
      <entry><literal>~</literal></entry>
      <entry>NON binaire sur entier</entry>
      <entry><literal>~ 1</literal></entry>
      <entry><literal>-2</literal></entry>
     </row>
     <row>
      <entry><literal>&lt;&lt;</literal></entry>
      <entry>décalage binaire vers la gauche d'entier</entry>
      <entry><literal>1 &lt;&lt; 2</literal></entry>
      <entry><literal>4</literal></entry>
     </row>
     <row>
      <entry><literal>&gt;&gt;</literal></entry>
      <entry>décalage binaire vers la droite d'entier</entry>
      <entry><literal>8 &gt;&gt; 2</literal></entry>
      <entry><literal>2</literal></entry>
     </row>
     <row>
      <entry><literal>+</literal></entry>
      <entry>addition</entry>
      <entry><literal>5 + 4</literal></entry>
      <entry><literal>9</literal></entry>
     </row>
     <row>
      <entry><literal>-</literal></entry>
      <entry>soustraction</entry>
      <entry><literal>3 - 2.0</literal></entry>
      <entry><literal>1.0</literal></entry>
     </row>
     <row>
      <entry><literal>*</literal></entry>
      <entry>multiplication</entry>
      <entry><literal>5 * 4</literal></entry>
      <entry><literal>20</literal></entry>
     </row>
     <row>
      <entry><literal>/</literal></entry>
      <entry>division (sur des entiers, tronque le résultat)</entry>
      <entry><literal>5 / 3</literal></entry>
      <entry><literal>1</literal></entry>
     </row>
     <row>
      <entry><literal>%</literal></entry>
      <entry>modulo</entry>
      <entry><literal>3 % 2</literal></entry>
      <entry><literal>1</literal></entry>
     </row>
     <row>
      <entry><literal>-</literal></entry>
      <entry>opposé</entry>
      <entry><literal>- 2.0</literal></entry>
      <entry><literal>-2.0</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </refsect2>

 <refsect2 id="pgbench-builtin-functions">
  <title>Fonctions internes</title>

  <para>
   Les fonctions listées dans <xref linkend="pgbench-functions"/> sont
   internes à <application>pgbench</application> et peuvent être
   utilisées dans des expressions apparaissant dans
   <link linkend="pgbench-metacommand-set"><literal>\set</literal></link>.
  </para>

   <!-- list pgbench functions in alphabetical order -->
   <table id="pgbench-functions">
    <title>Fonctions pgbench</title>
    <tgroup cols="5">
     <colspec colnum="1" colwidth="1.0*"/>
     <colspec colnum="2" colwidth="0.5*"/>
     <colspec colnum="3" colwidth="3.0*"/>
     <colspec colnum="4" colwidth="1.0*"/>
     <colspec colnum="5" colwidth="1.0*"/>
     <thead>
      <row>
       <entry>Fonction</entry>
       <entry>Type de retour</entry>
       <entry>Description</entry>
       <entry>Exemple</entry>
       <entry>Résultat</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal><function>abs(<replaceable>a</replaceable>)</function></literal></entry>
       <entry>identique à <replaceable>a</replaceable></entry>
       <entry>valeur absolue</entry>
       <entry><literal>abs(-17)</literal></entry>
       <entry><literal>17</literal></entry>
      </row>
      <row>
       <entry><literal><function>debug(<replaceable>a</replaceable>)</function></literal></entry>
       <entry>identique à <replaceable>a</replaceable> </entry>
       <entry>affiche <replaceable>a</replaceable> dans <systemitem>stderr</systemitem>,
        et retourne <replaceable>a</replaceable></entry>
       <entry><literal>debug(5432.1)</literal></entry>
       <entry><literal>5432.1</literal></entry>
      </row>
      <row>
       <entry><literal><function>double(<replaceable>i</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>convertit en double précision</entry>
       <entry><literal>double(5432)</literal></entry>
       <entry><literal>5432.0</literal></entry>
      </row>
      <row>
       <entry><literal><function>exp(<replaceable>x</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>exponentielle</entry>
       <entry><literal>exp(1.0)</literal></entry>
       <entry><literal>2.718281828459045</literal></entry>
      </row>
      <row>
       <entry><literal><function>greatest(<replaceable>a</replaceable> [, <replaceable>...</replaceable> ] )</function></literal></entry>
       <entry>double si <replaceable>a</replaceable> est double, sinon entier </entry>
       <entry>la plus grande valeur parmi les arguments</entry>
       <entry><literal>greatest(5, 4, 3, 2)</literal></entry>
       <entry><literal>5</literal></entry>
      </row>
      <row>
       <entry><literal><function>hash(<replaceable>a</replaceable> [, <replaceable>seed</replaceable> ] )</function></literal></entry>
       <entry>integer</entry>
       <entry>alias pour <literal>hash_murmur2()</literal></entry>
       <entry><literal>hash(10, 5432)</literal></entry>
       <entry><literal>-5817877081768721676</literal></entry>
      </row>
      <row>
       <entry><literal><function>hash_fnv1a(<replaceable>a</replaceable> [, <replaceable>seed</replaceable> ] )</function></literal></entry>
       <entry>integer</entry>
       <entry><ulink url="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">FNV-1a hash</ulink></entry>
       <entry><literal>hash_fnv1a(10, 5432)</literal></entry>
       <entry><literal>-7793829335365542153</literal></entry>
      </row>
      <row>
       <entry><literal><function>hash_murmur2(<replaceable>a</replaceable> [, <replaceable>seed</replaceable> ] )</function></literal></entry>
       <entry>integer</entry>
       <entry><ulink url="https://en.wikipedia.org/wiki/MurmurHash">MurmurHash2 hash</ulink></entry>
       <entry><literal>hash_murmur2(10, 5432)</literal></entry>
       <entry><literal>-5817877081768721676</literal></entry>
      </row>
      <row>
       <entry><literal><function>int(<replaceable>x</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>convertit en entier</entry>
       <entry><literal>int(5.4 + 3.8)</literal></entry>
       <entry><literal>9</literal></entry>
      </row>
      <row>
       <entry><literal><function>least(<replaceable>a</replaceable> [, <replaceable>...</replaceable> ] )</function></literal></entry>
       <entry>double si <replaceable>a</replaceable> est double, sinon entier</entry>
       <entry>plus petite valeur parmi les arguments</entry>
       <entry><literal>least(5, 4, 3, 2.1)</literal></entry>
       <entry><literal>2.1</literal></entry>
      </row>
      <row>
       <entry><literal><function>ln(<replaceable>x</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>logarithme naturel</entry>
       <entry><literal>ln(2.718281828459045)</literal></entry>
       <entry><literal>1.0</literal></entry>
      </row>
      <row>
       <entry><literal><function>mod(<replaceable>i</replaceable>, <replaceable>j</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>modulo</entry>
       <entry><literal>mod(54, 32)</literal></entry>
       <entry><literal>22</literal></entry>
      </row>
      <row>
       <entry><literal><function>pi()</function></literal></entry>
       <entry>double</entry>
       <entry>constante PI</entry>
       <entry><literal>pi()</literal></entry>
       <entry><literal>3.14159265358979323846</literal></entry>
      </row>
      <row>
       <entry><literal><function>pow(<replaceable>x</replaceable>, <replaceable>y</replaceable>)</function>, <function>power(<replaceable>x</replaceable>, <replaceable>y</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>exponentielle</entry>
       <entry><literal>pow(2.0, 10)</literal>, <literal>power(2.0, 10)</literal></entry>
       <entry><literal>1024.0</literal></entry>
      </row>
      <row>
       <entry><literal><function>random(<replaceable>lb</replaceable>, <replaceable>ub</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>entier aléatoire uniformément distribué dans <literal>[lb, ub]</literal></entry>
       <entry><literal>random(1, 10)</literal></entry>
       <entry>un entier entre <literal>1</literal> et <literal>10</literal></entry>
      </row>
      <row>
       <entry><literal><function>random_exponential(<replaceable>lb</replaceable>, <replaceable>ub</replaceable>, <replaceable>parameter</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>entier aléatoire distribué exponentiellement dans  <literal>[lb, ub]</literal>,
              voir plus bas</entry>
       <entry><literal>random_exponential(1, 10, 3.0)</literal></entry>
       <entry>un entier entre <literal>1</literal> et <literal>10</literal></entry>
      </row>
      <row>
       <entry><literal><function>random_gaussian(<replaceable>lb</replaceable>, <replaceable>ub</replaceable>, <replaceable>parameter</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>entier aléatoire distribué de façon gaussienne dans <literal>[lb, ub]</literal>,
              voir plus bas</entry>
       <entry><literal>random_gaussian(1, 10, 2.5)</literal></entry>
       <entry>un entier entre <literal>1</literal> et <literal>10</literal></entry>
      </row>
      <row>
       <entry><literal><function>random_zipfian (<replaceable>lb</replaceable>, <replaceable>ub</replaceable>, <replaceable>parameter</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>entier aléatoire distribué selon la loi de Zipf dans <literal>[lb, ub]</literal>,
              voir plus bas</entry>
       <entry><literal>random_zipfian(1, 10, 1.5)</literal></entry>
       <entry>un entier entre <literal>1</literal> et <literal>10</literal></entry>
      </row>
      <row>
       <entry><literal><function>sqrt(<replaceable>x</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>racine carrée</entry>
       <entry><literal>sqrt(2.0)</literal></entry>
       <entry><literal>1.414213562</literal></entry>
      </row>
     </tbody>
     </tgroup>
   </table>

   <para>
    La fonction <literal>random</literal> génère des valeurs en utilisant une
    distribution uniforme&nbsp;; autrement dit toutes les valeurs sont dans
    l'intervalle spécifiée avec une probabilité identique. Les fonctions
    <literal>random_exponential</literal>, <literal>random_gaussian</literal>
    et <literal>random_zipfian</literal> requièrent un paramètre
    supplémentaire de type double qui détermine le contour précis de cette
    distribution.
   </para>

   <itemizedlist>
    <listitem>
     <para>
      Pour une distribution exponentielle,
      <replaceable>parameter</replaceable> contrôle la distribution en
      tronquant une distribution exponentielle en décroissance rapide à
      <replaceable>parameter</replaceable>, puis en projetant le résultant sur
      des entiers entre les limites. Pour être précis&nbsp;:
<literallayout>
f(x) = exp(-parameter * (x - min) / (max - min + 1)) / (1 - exp(-parameter))
</literallayout>
      Puis la valeur <replaceable>i</replaceable> entre les valeurs
      <replaceable>min</replaceable> et <replaceable>max</replaceable>, en les
      incluant, est récupérée avec la probabilité&nbsp;:
      <literal>f(i) - f(i + 1)</literal>.
     </para>

     <para>
      Intuitivement, plus <replaceable>parameter</replaceable> est grand, plus
      les valeurs fréquentes proches de <replaceable>min</replaceable> sont
      accédées et moins les valeurs fréquentes proches de
      <replaceable>max</replaceable> sont accédées. Plus
      <replaceable>parameter</replaceable> est proche de 0, plus la
      distribution d'accès sera plate (uniforme). Une approximation grossière de
      la distribution est que 1% des valeurs les plus fréquentes de
      l'intervalle, proches de <replaceable>min</replaceable>, sont tirées
      <replaceable>parameter</replaceable>% du temps. La valeur de
      <replaceable>parameter</replaceable> doit être strictement positive.
     </para>
    </listitem>

    <listitem>
     <para>
      Pour une distribution gaussienne, l'intervalle correspond à une
      distribution normale standard (la courbe gaussienne classique en forme
      de cloche) tronquée à <literal>-parameter</literal> à gauche et à
      <literal>+parameter</literal> à droite.
      Les valeurs au milieu de l'intervalle sont plus
      susceptibles d'être sélectionnées. Pour être précis, si
      <literal>PHI(x)</literal> est la fonction de distribution cumulative de
      la distribution normale standard, avec une moyenne <literal>mu</literal>
      définie comme <literal>(max + min) / 2.0</literal>, avec
<literallayout>
f(x) = PHI(2.0 * parameter * (x - mu) / (max - min + 1)) /
       (2.0 * PHI(parameter) - 1)
</literallayout>
      alors la valeur <replaceable>i</replaceable> entre
      <replaceable>min</replaceable> et <replaceable>max</replaceable>
      (inclus) est sélectionnée avec une probabilité&nbsp;:
      <literal>f(i + 0.5) - f(i - 0.5)</literal>. Intuitivement, plus
      <replaceable>parameter</replaceable> est grand, et plus les valeurs
      fréquentes proches du centre de l'intervalle sont sélectionnées, et
      moins les valeurs fréquentes proches des bornes
      <replaceable>min</replaceable> et <replaceable>max</replaceable>.
      Environ 67% des valeurs sont sélectionnées à partir du centre
      <literal>1.0 / parameter</literal>, soit
      <literal>0.5 / parameter</literal> autour de la moyenne, et 95% dans le
      centre <literal>2.0 / parameter</literal>, soit
      <literal>1.0 / parameter</literal> autour de la moyenne&nbsp;; par
      exemple, si <replaceable>parameter</replaceable> vaut 4.0, 67% des
      valeurs sont sélectionnées depuis le quart du milieu (1.0 / 4.0) de
      l'intervalle (ou à partir de <literal>3.0 / 8.0</literal> jusqu'à
      <literal>5.0 / 8.0</literal>) et 95% depuis la moitié du milieu
      (<literal>2.0 / 4.0</literal>) de l'intervalle (deuxième et troisième
      quartiles). La valeur minimale autorisée pour <replaceable>parameter</replaceable>
      est 2.0.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>random_zipfian</literal> generates a bounded Zipfian
      distribution.
      <replaceable>parameter</replaceable>
      définit à quel point la distribution est biaisée. Plus
      <replaceable>parameter</replaceable> est grand, plus fréquemment les
      valeurs du début de l'intervalle seront tirées.
      La distribution est telle que, en supposant que l'intervalle commence à
      1, le ratio de probabilité d'un jet <replaceable>k</replaceable> contre
      un jet <replaceable>k+1</replaceable> est
      <literal>((<replaceable>k</replaceable>+1)/<replaceable>k</replaceable>)**<replaceable>parameter</replaceable></literal>.
      Par exemple, <literal>random_zipfian(1, ..., 2.5)</literal> produit
      la valeur <literal>1</literal> à peu près <literal>(2/1)**2.5 =
      5.66</literal> fois plus fréquemment que <literal>2</literal>, qui
      lui-même est produit <literal>(3/2)**2.5 = 2.76</literal> fois plus
      fréquemment que <literal>3</literal>, et ainsi de suite.
     </para>
     <para>
      <application>pgbench</application>'s implementation is based on
      "Non-Uniform Random Variate Generation", Luc Devroye, p. 550-551,
      Springer 1986.  Due to limitations of that algorithm,
      the <replaceable>parameter</replaceable> value is restricted to
      the range [1.001, 1000].
     </para>
    </listitem>
   </itemizedlist>

  <para>
    Les fonctions de hachage <literal>hash</literal>,
    <literal>hash_murmur2</literal> et <literal>hash_fnv1a</literal> acceptent
    une valeur d'entrée et une graine optionnelle. Au cas où la graine n'est pas
    fournie la valeur de <literal>:default_seed</literal> est utilisée,
    initialisée de façon aléatoire si elle n'est pas définie par l'option de
    ligne de commande <literal>-D</literal>. Les fonctions de hachage peuvent
    être utilisées pour éparpiller la distribution des fonctions aléatoires
    comme  <literal>random_zipfian</literal> ou
    <literal>random_exponential</literal>. Par exemple, le script pgbench
    suivant simule une charge possible typique du monde réel pour des médias
    sociaux et des plateformes de blog, où peu de comptes génèrent une charge
    excessive&nbsp;:
<programlisting>
\set r random_zipfian(0, 100000000, 1.07)
\set k abs(hash(:r)) % 1000000
</programlisting>

    Dans certains cas, plusieurs distributions distinctes qui ne se corrèlent pas
    les unes avec les autres sont nécessaires, et c'est là que le paramètre
    graine est pratique&nbsp;:

<programlisting>
\set k1 abs(hash(:r, :default_seed + 123)) % 1000000
\set k2 abs(hash(:r, :default_seed + 321)) % 1000000
</programlisting>
  </para>

   <para>
   En tant qu'exemple, la définition complète de la construction
   de la transaction style TPC-B est&nbsp;:

   <programlisting>
   \set aid random(1, 100000 * :scale)
   \set bid random(1, 1 * :scale)
   \set tid random(1, 10 * :scale)
   \set delta random(-5000, 5000)
   BEGIN;
   UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
   SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
   UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
   UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
   INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
   END;
   </programlisting>
   Ce script autorise chaque itération de la transaction à référencer
   des lignes différentes, sélectionnées aléatoirement.
   (Cet exemple montre aussi pourquoi il est important que chaque session
   cliente ait ses propres variables &mdash; sinon elles n'affecteront
   pas les différentes lignes de façon indépendante.
  </para>

 </refsect2>

 <refsect2>
  <title>Journaux par transaction</title>

  <para>
   Avec l'option <option>-l</option> (mais sans l'option
   <option>--aggregate-interval</option>),
   <application>pgbench</application> va écrire des informations sur
   chaque transaction dans un fichier journal. Il sera nommé
   <filename><replaceable>prefix</replaceable>.<replaceable>nnn</replaceable></filename>,
   où <replaceable>prefix</replaceable> vaut par défaut
   <literal>pgbench_log</literal>, et <replaceable>nnn</replaceable> est le PID
   du processus <application>pgbench</application>.
   Le préfixe peut être changé avec l'option <option>--log-prefix</option>.
   Si l'option <option>-j</option> est positionnée à 2 ou plus,
   créant plusieurs processus de travail (<foreignphrase>worker</foreignphrase>),
   chacun aura son propre fichier journal.
   Le premier worker utilisera le même nom pour son fichier journal
   que dans le cas d'un seul processus.
   Les fichiers journaux supplémentaires s'appelleront
   <filename><replaceable>prefix</replaceable>.<replaceable>nnn</replaceable>.<replaceable>mmm</replaceable></filename>,
   où <replaceable>mmm</replaceable> est un numéro de séquence,
   identifiant chaque worker, commençant à 1.
  </para>

  <para>
   Le format du journal est le suivant&nbsp;:

<synopsis>
<replaceable>id_client</replaceable> <replaceable>no_transaction</replaceable> <replaceable>temps</replaceable> <replaceable>no_script</replaceable> <replaceable>time_epoch</replaceable> <replaceable>time_us</replaceable> <optional> <replaceable>schedule_lag</replaceable> </optional>
</synopsis>

   où
   <replaceable>client_id</replaceable> indique la session client qui a exécuté
   la transaction, <replaceable>transaction_no</replaceable> compte le nombre
   de transactions exécutées par cette session,
   <replaceable>temps</replaceable> est la durée totale de la
   transaction en microsecondes, <replaceable>no_script</replaceable>
   indique quel fichier script a été utilisé (très utile lorsqu'on
   utilise plusieurs scripts avec l'option <option>-f</option> ou
   <option>-b</option>), et
   <replaceable>time_epoch</replaceable>/<replaceable>time_us</replaceable>
   est un horodatage Unix avec un décalage en microsecondes (utilisable pour
   créer un horodatage ISO 8601 avec des secondes fractionnées) indiquant
   à quel moment la transaction s'est terminée.

   Le champ <replaceable>schedule_lag</replaceable> est la différence
   entre la date de début planifiée de la transaction et sa date de
   début réelle, en micro secondes.
   Il est présent uniquement lorsque l'option <option>--rate</option> est
   utilisée.
   Quand les options <option>--rate</option> et <option>--latency-limit</option>
   sont utilisées en même temps, le champ <replaceable>time</replaceable> pour
   une transaction ignorée sera rapportée en tant que <literal>skipped</literal>.
  </para>

  <para>
   Ci-dessous un extrait du fichier journal généré avec un seul client&nbsp;:
<screen>
0 199 2241 0 1175850568 995598
0 200 2465 0 1175850568 998079
0 201 2513 0 1175850569 608
0 202 2038 0 1175850569 2663
</screen>

   Autre exemple avec les options <literal>--rate=100</literal> et
   <literal>--latency-limit=5</literal> (notez
   la colonne supplémentaire <replaceable>schedule_lag</replaceable>)&nbsp;:
<screen>
0 81 4621 0 1412881037 912698 3005
0 82 6173 0 1412881037 914578 4304
0 83 skipped 0 1412881037 914578 5217
0 83 skipped 0 1412881037 914578 5099
0 83 4722 0 1412881037 916203 3108
0 84 4142 0 1412881037 918023 2333
0 85 2465 0 1412881037 919759 740
</screen>
   Dans cet exemple, la transaction 82 a été en retard, elle affiche une
   latence (6,173&nbsp;ms) supérieure à la limite de 5&nbsp;ms.
   Les deux transactions suivantes ont été ignorées, car elles avaient
   déjà en retard avant même d'avoir commencé.
  </para>

  <para>
   Dans le cas d'un test long sur du matériel qui peut
   supporter un grand nombre de transactions, les journaux
   peuvent devenir très volumineux.
   L'option <option>--sampling-rate</option> peut être utilisée pour
   journaliser seulement un extrait aléatoire des transactions
   effectuées.
  </para>
 </refsect2>

 <refsect2>
  <title>Agrégation de la journalisation</title>

  <para>
   Avec l'option <option>--aggregate-interval</option>, les fichiers
   journaux utilisent un format quelque peu différent&nbsp;:

<synopsis>
<replaceable>début_intervalle</replaceable> <replaceable>nombre_de_transations</replaceable> <replaceable>somme_latence</replaceable> <replaceable>somme_latence_2</replaceable> <replaceable>latence_minimum</replaceable> <replaceable>latence_maximum</replaceable> <optional> <replaceable>somme_retard</replaceable> <replaceable>somme_retard_2</replaceable> <replaceable>retard_min</replaceable> <replaceable>retard_max</replaceable> <optional> <replaceable>transactions_ignorées</replaceable> </optional> </optional>
</synopsis>

   où <replaceable>début_intervalle</replaceable> est le début de
   l'intervalle (au format epoch Unix),
   <replaceable>nombre_de_transations</replaceable> est le nombre de
   transactions dans l'intervalle,
   <replaceable>somme_latence</replaceable> est le cumul des latences dans
   l'intervalle,
   <replaceable>somme_latence_2</replaceable> est la somme des carrés des
   latences dans l'intervalle,
   <replaceable>latence_minimum</replaceable> est la latence minimum dans
   l'intervalle,
   et <replaceable>latence_maximum</replaceable> est la latence maximum dans
   l'intervalle.
   Les derniers champs <replaceable>somme_retard</replaceable>,
   <replaceable>somme_retard_2</replaceable>,
   <replaceable>retard_min</replaceable>,
   et <replaceable>retard_max</replaceable> sont présents uniquement si
   l'option <option>--rate</option> a été spécifiée.
   Ils fournissent des statistiques sur le temps que chaque transaction a eu à
   attendre la fin de la précédente, c'est-à-dire la différence entre la
   date de départ prévue et la date de départ réelle de chaque transaction.
   Le tout dernier champ,
   <replaceable>transactions_ignorées</replaceable>, n'est présent
   que si l'option <option>--latency-limit</option> est utilisée.
   Chaque transaction est comptabilisée dans l'intervalle où elle a committé.
  </para>

  <para>
   Voici un exemple de sortie&nbsp;:
<screen>
1345828501 5601 1542744 483552416 61 2573
1345828503 7884 1979812 565806736 60 1479
1345828505 7208 1979422 567277552 59 1391
1345828507 7685 1980268 569784714 60 1398
1345828509 7073 1979779 573489941 236 1411
</screen></para>

  <para>
   Notez que tandis que le fichier journal brut (c'est-à-dire non
   agrégé) contient une référence à quel script a été utilisé pour chaque
   transaction, le journal agrégé n'en contient pas. De ce fait, si vous
   avez besoin des données par script, vous devrez agréger ces
   données vous-même.
  </para>

 </refsect2>

 <refsect2>
  <title>Latences par requête</title>

  <para>
   Avec l'option <option>-r</option>, <application>pgbench</application>
   collecte le temps de transaction écoulé pour chaque requête
   exécutée par chaque client.
   Une fois le test de performance terminé, il affiche une
   moyenne de ces valeurs, désignée comme latence de chaque requête.
  </para>

  <para>
   Pour le script par défaut, le résultat aura la forme suivante&nbsp;:
<screen>
starting vacuum...end.
transaction type: &lt;builtin: TPC-B (sort of)&gt;
 scaling factor: 1
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
latency average = 15.844 ms
latency stddev = 2.715 ms
tps = 618.764555 (including connections establishing)
tps = 622.977698 (excluding connections establishing)
 - statement latencies in milliseconds:
        0.002  \set aid random(1, 100000 * :scale)
        0.005  \set bid random(1, 1 * :scale)
        0.002  \set tid random(1, 10 * :scale)
        0.001  \set delta random(-5000, 5000)
        0.326  BEGIN;
        0.603  UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
        0.454  SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
        5.528  UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
        7.335  UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
        0.371  INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
        1.212  END;
</screen>
  </para>

  <para>
   Les moyennes sont rapportées séparément si plusieurs scripts sont spécifiés.
  </para>

  <para>
   Notez que collecter des informations de chronométrage supplémentaires
   nécessaires pour calculer la latence par requête rajoute une certaine charge.
   Cela va réduire la vitesse moyenne calculée pour l'exécution
   des transactions et réduire le taux calculé des TPS.
   Le ralentissement varie de manière significative selon la
   plateforme et le matériel.
   Comparer la moyenne des valeurs de TPS avec et sans intégration
   de la latence est une bonne manière de se rendre compte
   si la surcharge induite par le chronométrage est importante ou pas.
  </para>
 </refsect2>

 <refsect2>
  <title>Bonnes pratiques</title>

  <para>
   Il est facile d'utiliser <application>pgbench</application> pour produire
   des résultats complètement dénués de sens&nbsp;!
   Voici quelques conseils pour vous aider à obtenir des résultats
   pertinents.
  </para>

  <para>
   Tout d'abord, ne croyez <emphasis>jamais</emphasis> en un test qui ne
   dure que quelques secondes.
   Utilisez l'option <option>-t</option> ou <option>-T</option>
   pour que le test dure au moins quelques minutes, de
   façon à lisser le bruit.
   Dans certains cas, il vous faudra des heures pour récupérer des
   valeurs reproductibles.
   C'est une bonne idée de lancer plusieurs fois le test pour voir si vos
   chiffres sont ou pas reproductibles.
  </para>

  <para>
   Pour le scénario de test par défaut typé TPC-B, le facteur d'échelle
   d'initialisation (<option>-s</option>) devrait être au moins
   aussi grand que le nombre maximum de clients que vous avez
   l'intention de tester (<option>-c</option>)&nbsp;; sinon vous allez
   principalement tester la contention induite par les mises à jour.
   il n'y a que <option>-s</option> lignes dans la table
   <structname>pgbench_branches</structname>, et chaque transaction
   veut mettre à jour l'une de ces lignes, donc si la valeur de
   <option>-c</option> est supérieure à la valeur de <option>-s</option>,
   il en résultera sûrement de nombreuses transactions bloquées
   en attente de la fin d'autres transactions.
  </para>

  <para>
   Le scénario par défaut est aussi assez sensible au temps écoulé depuis
   l'initialisation des tables : l'accumulation
   des lignes et espaces morts dans les tables change les résultats.
   Pour comprendre ces résultats, vous devez garder une trace du
   nombre total de mises à jour et du moment du vacuum.
   Si l'autovacuum est actif, il peut en
   résulter des variations imprévisibles dans les performances mesurées.
  </para>

  <para>
   Une limitation de <application>pgbench</application> est qu'il peut
   lui-même devenir le goulet d'étranglement lorsqu'on essaye de tester avec
   un grand nombre de sessions clientes.
   Cela peut être atténué en utilisant <application>pgbench</application>
   depuis une machine différente du serveur de base
   de données, bien qu'une faible latence sur le réseau soit dans ce cas
   essentielle.
   Il peut même être utile de lancer plusieurs instances parallèles de
   <application>pgbench</application>, depuis
   plusieurs machines clientes vers le même serveur de base de données.
  </para>
 </refsect2>

 <refsect2>
  <title>Securité</title>

  <para>
    Si des utilisateurs non dignes de confiance ont accès à une base de
    données qui n'a pas adopté une <link linkend="ddl-schemas-patterns">méthode
    sécurisée d'utilisation des schémas</link>, il ne faut pas exécuter
    <application>pgbench</application> dans cette base.
    <application>pgbench</application> utilise des noms non qualifiés et ne
    modifie le chemin de recherche.
  </para>
 </refsect2>
 </refsect1>
</refentry>
