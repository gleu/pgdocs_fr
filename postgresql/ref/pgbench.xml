<?xml version="1.0" encoding="UTF-8"?>
<refentry id="pgbench">
 <indexterm zone="pgbench">
  <primary>pgbench</primary>
 </indexterm>

 <refmeta>
  <refentrytitle><application>pgbench</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>pgbench</refname>
  <refpurpose>Réalise un test de benchmark pour
   <productname>PostgreSQL</productname></refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <cmdsynopsis>
   <command>pgbench</command>
   <arg choice="plain"><option>-i</option></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>nom_base</replaceable></arg>
  </cmdsynopsis>
  <cmdsynopsis>
   <command>pgbench</command>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>nom_base</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <para>
   <application>pgbench</application> est un programme pour réaliser simplement des
   tests de performance (<foreignphrase>benchmark</foreignphrase>)
   sur <productname>PostgreSQL</productname>.  Il
   exécute la même séquence de commandes SQL en continu, potentiellement
   avec plusieurs sessions concurrentes puis calcule le taux de
   transactions moyen (en transactions par secondes).
   Par défaut, <application>pgbench</application> teste un scénario
   vaguement basé sur TPC-B, impliquant cinq commandes <command>SELECT</command>,
   <command>UPDATE</command> et <command>INSERT</command> par
   transaction.
   Toutefois, il est facile de tester d'autres scénarios en écrivant
   vos propres scripts de transactions.
  </para>

  <para>
   Une sortie classique de <application>pgbench</application> ressemble
   à ceci&nbsp;:

   <screen>
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
maximum number of tries: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
number of failed transactions: 0 (0.000%)
latency average = 11.013 ms
latency stddev = 7.351 ms
initial connection time = 45.758 ms
tps = 896.967014 (without initial connection time)
   </screen>

   Les sept premières lignes rapportent certains des plus importants paramètres.
   La sixième ligne affiche le nombre maximum d'essais pour les transactions
   avec des erreurs de sérialisation ou des deadlocks (pour plus
   d'informations, voir <xref linkend="failures-and-retries"/>).
   La huitième ligne remonte les nombres de transactions réalisées et
   prévues (ce dernier étant juste le produit du nombre de
   clients et du nombre de transactions par client)&nbsp;;
   ils seront égaux à moins que l'exécution échoue avant la fin
   ou que des commandes SQL échouent.
   (Avec le mode <option>-T</option>, seul le nombre réel de transactions est affiché.)
   La ligne suivante affiche le nombre de transactions échouées
   à cause d'erreurs de sérialisation ou de deadlock (pour plus
   d'informations, voir <xref linkend="failures-and-retries"/>).
   La dernière ligne indique le nombre de transactions par seconde.
  </para>

  <para>
   Les transactions de ce test, proche de TPC-B, nécessitent d'avoir défini
   au préalable quelques tables spécifiques.
   Il faut utiliser l'option <option>-i</option> (initialisation)
   de <application>pgbench</application> pour créer et remplir ces tables.
   (Si vous faites vos tests avec un script personnalisé,
   vous n'aurez pas besoin de cette étape, mais devrez mettre en place
   tout ce dont votre script aura besoin.)
   Une initialisation ressemble à cela&nbsp;:

   <programlisting>
pgbench -i <optional> <replaceable>autres-options</replaceable>
</optional> <replaceable>nom_base</replaceable>
   </programlisting>

   où <replaceable>nom_base</replaceable> est le nom de la base de données
   pré-existante sur laquelle on conduit les tests. (Vous aurez aussi
   probablement besoin des options <option>-h</option>,
   <option>-p</option> et/ou <option>-U</option> pour spécifier comment
   se connecter au serveur de base de données.)
  </para>

  <caution>
   <para>
    <literal>pgbench -i</literal> crée quatre tables nommées
    <structname>pgbench_accounts</structname>,
    <structname>pgbench_branches</structname>,
    <structname>pgbench_history</structname> et
    <structname>pgbench_tellers</structname>,
    détruisant toute table qui porterait l'un de ces noms.
    Attention à utiliser une autre base de données si vous avez
    des tables qui portent ces noms&nbsp;!
   </para>
  </caution>

  <para>
   Par défaut, avec un facteur d'échelle de 1, les tables contiennent
   initialement les nombres de lignes suivants&nbsp;:
   <screen>
table                   # de lignes
---------------------------------
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0
   </screen>
   Vous pouvez (et, dans la plupart des cas, devriez) augmenter le nombre de
   lignes en utilisant l'option <option>-s</option>. Le facteur de remplissage
   <option>-F</option> peut aussi être utilisée à cet effet.
  </para>

  <para>
   Une fois la mise en place terminée, vous pouvez
   lancer vos benchmarks sans inclure l'option <option>-i</option>,
   c'est-à-dire&nbsp;:

   <programlisting>
pgbench <optional> <replaceable>options</replaceable> </optional>
<replaceable>nom_base</replaceable>
   </programlisting>

   Dans presque tous les cas, vous allez avoir besoin de certaines
   options pour rendre vos tests plus pertinents.
   Les options les plus importantes sont&nbsp;:
   <option>-c</option> (le nombre de clients),
   <option>-t</option> (le nombre de transactions),
   <option>-T</option> (l'intervalle de temps)
   et <option>-f</option> (le script à lancer).
   Vous trouverez ci-dessous toutes les options disponibles.
  </para>
 </refsect1>

 <refsect1>
  <title>Options</title>

  <para>
   La partie suivante est divisée en trois sous-parties&nbsp;: des options
   différentes sont utilisées pendant l'initialisation et pendant les tests ;
   certaines options sont utiles dans les deux cas.
  </para>

  <refsect2 id="pgbench-init-options">
   <title>Options d'initialisation</title>

   <para>
    Pour réaliser l'initialisation, <application>pgbench</application>
    accepte les arguments suivants en ligne de commande&nbsp;:

    <variablelist>

     <varlistentry>
      <term><replaceable class="parameter">dbname</replaceable></term>
      <listitem>
       <para>
        Indique le nom de la base à tester. Si elle n'est pas spécifier, la
        variable d'environnement <envar>PGDATABASE</envar> est utilisée. Si
        elle n'est pas configurée, le nom d'utilisateur indiqué pour la
        connexion est utilisé.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-i</option></term>
      <term><option>--initialize</option></term>
      <listitem>
       <para>
        Nécessaire pour passer en mode initialisation.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-I <replaceable>init_steps</replaceable></option></term>
      <term><option>--init-steps=<replaceable>init_steps</replaceable></option></term>
      <listitem>
       <para>
        N'effectue qu'une partie des étapes d'initialisation habituelles.
        <replaceable>init_steps</replaceable> spécifie les étapes
        d'initialisation à exécuter, à raison d'un caractère par étape.
        Chaque étape est appelée dans l'ordre indiqué.
        La valeur par défaut est <literal>dtgvp</literal>. Voici la liste
        des différentes étapes disponibles&nbsp;:

        <variablelist>
         <varlistentry>
          <term><literal>d</literal> (Détruit)</term>
          <listitem>
           <para>
            Supprime toutes les tables <application>pgbench</application>
            déjà présentes.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>t</literal> (crée Tables)</term>
          <listitem>
           <para>
            Crée les tables utilisées par le scénario
            <application>pgbench</application> standard, à savoir
            <structname>pgbench_accounts</structname>,
            <structname>pgbench_branches</structname>,
            <structname>pgbench_history</structname> et
            <structname>pgbench_tellers</structname>.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>g</literal> ou <literal>G</literal> (génère des données, côté client ou côté serveur)</term>
          <listitem>
           <para>
            Génère des données et les charge dans les tables standards,
            remplaçant toutes les données déjà présentes.
           </para>
           <para>
            Avec <literal>g</literal> (génération de données côté client),
            les données sont générées dans le client <command>pgbench</command>,
            puis envoyées au serveur. Cela utilise une commande <command>COPY</command>
            et consomme beaucoup de bande passante entre le client et le serveur.
            En version 14 ou supérieure, <command>pgbench</command> utilise l'option
            FREEZE de <productname>PostgreSQL</productname> pour
            accélérer les <command>VACUUM</command> suivantes,
            sauf en cas d'utilisation des partitions.
            Avec <literal>g</literal>, la trace affiche un message toutes les
            100&nbsp;000 lignes lors de la génération de <structname>pgbench_accounts</structname>.
           </para>
           <para>
            Avec <literal>G</literal> (génération côté serveur), seules de petites
            requêtes sont envoyées depuis le client <command>pgbench</command>,
            et les données sont ensuite générées sur le serveur.
            Aucune bande passante significative n'est nécessaire dans cette variante,
            mais le serveur travaillera plus.
            Avec <literal>G</literal>, la trace n'affichera aucun message de
            progression pendant la génération des données.
           </para>
           <para>
            Par défaut, l'initialisation utilise la génération des données
            côté client (soit <literal>g</literal>).
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>v</literal> (Vacuum)</term>
          <listitem>
           <para>
            Appelle <command>VACUUM</command> sur les tables standards.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>p</literal> (clés Primaires)</term>
          <listitem>
           <para>
            Crée les clés primaires sur les tables standards.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>f</literal> (<foreignphrase>Foreign keys
           </foreignphrase>)</term>
          <listitem>
           <para>
            Crée les contraintes de clés étrangères entre les
            différentes tables standards.
            (Notez que cette étape n'est pas exécutée par défaut.)
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-F</option>
       <replaceable>fillfactor</replaceable></term>
      <term><option>--fillfactor=
       </option><replaceable>fillfactor</replaceable></term>
      <listitem>
       <para>
        Crée les tables <structname>pgbench_accounts</structname>,
        <structname>pgbench_tellers</structname> et
        <structname>pgbench_branches</structname> avec le facteur de
        remplissage (<foreignphrase>fillfactor</foreignphrase>) spécifié.
        La valeur par défaut est 100.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>--no-vacuum</option></term>
      <listitem>
       <para>
        Ne réalise pas de VACUUM après l'initialisation.
        (Cette option supprime l'étape d'initialisation <literal>v</literal>,
        même si elle était précisée dans <option>-I</option>.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-q</option></term>
      <term><option>--quiet</option></term>
      <listitem>
       <para>
        Passe du mode verbeux au mode silencieux, en n'affichant qu'un message
        toutes les 5 secondes. Par défaut, on affiche un message toutes les
        100&nbsp;000 lignes, ce qui engendre souvent plusieurs lignes toutes
        les secondes (particulièrement sur du bon matériel)
       </para>
       <para>
        Ce paramètre n'a pas d'effet si <literal>G</literal> est spécifié
        dans l'option <option>-I</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option>
       <replaceable>scale_factor</replaceable></term>
      <term><option>--scale=</option>
       <replaceable>scale_factor</replaceable></term>
      <listitem>
       <para>
        Multiplie le nombre de lignes générées par le facteur d'échelle
        (<foreignphrase>scale factor</foreignphrase>). Par exemple,
        <literal>-s 100</literal> va créer 10 millions de
        lignes dans la table <structname>pgbench_accounts</structname>. La
        valeur par défaut est 1. Lorsque l'échelle dépasse 20&nbsp;000, les
        colonnes utilisées pour contenir les identifiants de compte (colonnes
        <structfield>aid</structfield>) vont être converties en grands entiers
        (<type>bigint</type>), de manière à être suffisamment grandes pour
        contenir l'espace des identifiants de compte.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--foreign-keys</option></term>
      <listitem>
       <para>
        Crée des contraintes de type clé étrangère entre les tables standards.
        (Cette option ajoute l'étape d'initialisation <literal>f</literal>,
        si elle n'est pas déjà présente.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--index-tablespace=<replaceable>index_tablespace</replaceable>
       </option></term>
      <listitem>
       <para>
        Crée un index dans le tablespace spécifié plutôt que dans le
        tablespace par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--partition-method=<replaceable>NOM</replaceable></option></term>
      <listitem>
       <para>
        Crée une table partitionnée <literal>pgbench_accounts</literal>
        par la méthode <replaceable>NOM</replaceable>.
        Les valeurs attendues sont <literal>range</literal> ou <literal>hash</literal>.
        Cette option nécessite que <option>--partitions</option> soit différente
        de zéro. Sans précision, le défaut est <literal>range</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--partitions=<replaceable>NUM</replaceable></option></term>
      <listitem>
       <para>
        Crée une table partitionnée <literal>pgbench_accounts</literal>
        avec <replaceable>NUM</replaceable> partitions de taille à peu près
        égale pour le nombre de clients indiqué par l'échelle.
        Le défaut est <literal>0</literal>, ce qui signifie qu'il n'y a pas de partitionnement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--tablespace=<replaceable>tablespace</replaceable>
       </option></term>
      <listitem>
       <para>
        Crée une table dans le tablespace spécifié plutôt que dans le
        tablespace par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--unlogged-tables</option></term>
      <listitem>
       <para>
        Crée toutes les tables en tant que tables non journalisées
        (<foreignphrase>unlogged tables</foreignphrase>)
        plutôt qu'en tant que tables permanentes.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

  </refsect2>

  <refsect2 id="pgbench-run-options">
   <title>Options des benchmarks</title>

   <para>
    Pour réaliser un benchmark <application>pgbench</application>
    accepte les arguments suivants en ligne de commande&nbsp;:

    <variablelist>

     <varlistentry>
      <term><option>-b</option> <replaceable>nom_script[@poids]</replaceable></term>
      <term><option>--builtin</option>=<replaceable>nom_script[@poids]</replaceable></term>
      <listitem>
       <para>
        Ajoute le script interne spécifié à la liste des scripts à exécuter.
        Les scripts internes disponibles sont <literal>tpcb-like</literal>,
        <literal>simple-update</literal> et <literal>select-only</literal>.
        L'utilisation des préfixes non ambigus des noms de scripts internes
        est acceptée. En utilisant le nom spécial <literal>list</literal>, la
        commande affiche la liste des scripts internes, puis quitte
        immédiatement.
       </para>
       <para>
        En option, il est possible d'écrire un poids en entier après
        <literal>@</literal> pour ajuster la probabilité de sélectionner ce
        script plutôt que les autres. Le poids par défaut est de 1. Voir
        ci-dessous pour les détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-c</option> <replaceable>clients</replaceable></term>
      <term><option>--client=
       </option><replaceable>clients</replaceable></term>
      <listitem>
       <para>
        Nombre de clients simulés, c'est-à-dire le nombre
        de sessions concurrentes sur la base de données.
        La valeur par défaut est à 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-C</option></term>
      <term><option>--connect</option></term>
      <listitem>
       <para>
        Établit une nouvelle connexion pour chaque transaction, plutôt
        que de ne le faire qu'une seule fois par session cliente.
        C'est une option très utile pour mesurer la surcharge engendrée
        par la connexion.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-d</option></term>
      <term><option>--debug</option></term>
      <listitem>
       <para>
        Affiche les informations de debug.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-D</option> <replaceable>variable</replaceable>
       <literal>=</literal><replaceable>value</replaceable></term>
      <term><option>--define=</option><replaceable>variable</replaceable>
       <literal>=</literal><replaceable>value</replaceable></term>
      <listitem>
       <para>
        Définit une variable à utiliser pour un script personnalisé
        Voir ci-dessous pour plus de détails.
        Il est possible d'utiliser plusieurs fois l'option <option>-D</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-f</option> <replaceable>nom_fichier[@poids]</replaceable></term>
      <term><option>--file=</option><replaceable>nom_fichier[@poids]</replaceable></term>
      <listitem>
       <para>
        Ajoute un script de transactions nommé
        <replaceable>nom_fichier</replaceable> à la liste des scripts à
        exécuter.
       </para>
       <para>
        En option, il est possible d'écrire un poids sous la forme d'un entier
        après le symbole <literal>@</literal> pour ajuster la probabilité de
        sélectionner ce script plutôt qu'unautre. Le poids par défaut est de
        1. (Pour utiliser un nom de fichier incluant un caractère
        <literal>@</literal>, ajoutez un poids pour qu'il n'y ait pas
        d'ambiguité, par exemple <literal>filen@me@1</literal>.) Voir
        ci-dessous pour les détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-j</option> <replaceable>threads</replaceable></term>
      <term><option>--jobs=</option>
       <replaceable>threads</replaceable></term>
      <listitem>
       <para>
        Nombre de processus utilisés dans
        <application>pgbench</application>.
        Utiliser plus d'un thread peut être utile sur des machines
        possédant plusieurs cœurs.
        Les clients sont distribués de la manière la plus uniforme possible
        parmi les threads.
        La valeur par défaut est 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-l</option></term>
      <term><option>--log</option></term>
      <listitem>
       <para>
        Rapporte les informations sur chaque transaction dans un fichier
        journal.
        Voir ci-dessous pour plus de détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-L</option> <replaceable>limite</replaceable></term>
      <term><option>--latency-limit=</option><replaceable>limite</replaceable></term>
      <listitem>
       <para>
        Les transactions durant plus de <replaceable>limite</replaceable> millisecondes
        sont comptabilisée et rapportées séparément en tant que
        <firstterm>late</firstterm>.
       </para>
       <para>
        Lorsqu'un bridage est spécifié (<option>--rate=... </option>),
        les transactions accusant un retard sur la planification supérieur à
        <replaceable>limite</replaceable> millisecondes, et donc sans aucune
        chance de respecter la limite de latence,
        ne sont pas du tout envoyées au serveur.
        Elles sont comptabilisées et rapportées séparément en tant que
        <firstterm>skipped</firstterm> (ignorées).
       </para>
       <para>
        Avec l'option <option>--max-tries</option>, une transaction
        échouée à cause d'une anomalie de sérialisation ou d'un deadlock
        ne sera pas retentée si le temps cumulé de ses tentatives dépasse
        <replaceable>limit</replaceable>&nbsp;ms.
        Pour ne limiter que la durée des tentatives et non leur nombre,
        utiliser <literal>--max-tries=0</literal>.
        Par défaut, <literal>--max-tries</literal> vaut 1, et les transactions
        en erreur à cause de la sérialisation ou d'un deadlock
        ne sont pas retentées.
        Voir  <xref linkend="failures-and-retries"/>  pour plus de détails
        sur comment retenter de telles transactions.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-M</option>
       <replaceable>querymode</replaceable></term>
      <term><option>--protocol=</option>
       <replaceable>querymode</replaceable></term>
      <listitem>
       <para>
        Protocole à utiliser pour soumettre des requêtes au serveur&nbsp;:
        <itemizedlist>
         <listitem>
          <para><literal>simple</literal>&nbsp;: utilisation du protocole
           de requêtes standards.</para>
         </listitem>
         <listitem>
          <para><literal>extended</literal>&nbsp;: utilisation du protocole
           de requête étendu.</para>
         </listitem>
         <listitem>
          <para><literal>prepared</literal>&nbsp;: utilisation du protocole
           de requête étendu avec instructions préparées.</para>
         </listitem>
        </itemizedlist>

        Comme dans le mode <literal>prepared</literal>,
        <application>pgbench</application> réutilise le résultat de l'analyse
        pour la deuxième itération et les suivantes,
        <application>pgbench</application> s'exécute plus rapidement dans le
        mode <literal>prepared</literal> que dans les autres modes.
       </para>
       <para>
        Par défaut, le protocole de requête standard est utilisé
        (voir <xref linkend="protocol"/> pour plus d'informations).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>--no-vacuum</option></term>
      <listitem>
       <para>
        Ne réalise pas de VACUUM avant de lancer le test.
        Cette option est <emphasis>nécessaire</emphasis> si vous lancez
        un scénario de test personnalisé qui n'utilise pas les tables
        standards <structname>pgbench_accounts</structname>,
        <structname>pgbench_branches</structname>, <structname>
         pgbench_history</structname> et <structname>pgbench_tellers
        </structname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-N</option></term>
      <term><option>--skip-some-updates</option></term>
      <listitem>
       <para>
        Exécute le script interne simple-update. Raccourci pour
        <option>-b simple-update</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-P</option> <replaceable>sec</replaceable></term>
      <term><option>--progress=</option>
       <replaceable>sec</replaceable></term>
      <listitem>
       <para>
        Affiche un rapport de progression toutes les
        <replaceable>sec</replaceable> secondes.
        Ce rapport inclut la durée du test, le nombre de
        transactions par seconde depuis le dernier rapport et la
        latence moyenne des transactions, ainsi que la déviation
        et le nombre de transactions échouées
        depuis le dernier rapport.
        Avec le bridage (option <option>-R</option>), la latence est calculée
        en fonction de la date de démarrage ordonnancée de la transaction et non
        de son temps de démarrage réel, donc elle inclut aussi la latence
        moyenne du temps d'ordonnancement.
        Si <option>--max-tries</option> est utilisée pour autoriser de nouvelles
        tentatives après des erreurs de sérialisation ou des deadlocks,
        le rapport inclut le nombre de transactions retentées et la somme
        de tous les nouveaux essais.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-r</option></term>
      <term><option>--report-per-command</option></term>
      <listitem>
       <para>
        Affiche les statistiques suivantes pour chaque commande après la fin
        du benchmark&nbsp;: latence moyenne par requête (temps
        d'exécution du point de vue du client), nombre d'échecs après des
        erreurs de sérialisation ou des deadlocks, et le nombre de nouvelles
        tentatives après cela.
        Le rapport affiche les statistiques sur les nouveaux essais uniquement
        si <option>--max-tries</option> n'est pas égal à 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-R</option> <replaceable>rate</replaceable></term>
      <term><option>--rate=</option><replaceable>rate</replaceable></term>
      <listitem>
       <para>
        Exécute les transactions en visant le débit spécifié,
        au lieu d'aller le plus vite possible (le défaut).
        Le débit est donné en transactions par seconde.
        Si le débit visé est supérieur au maximum possible, la
        limite de débit n'aura aucune influence sur le résultat.
       </para>
       <para>
        Pour atteindre ce débit, les transactions sont ordonnancées avec
        une distribution suivant une loi de Poisson.
        La date de démarrage prévue se calcule depuis le moment où le client a
        démarré et pas depuis le moment où la dernière transaction s'est achevée.
        Cette approche signifie que, si une transaction
        dépasse sa date de fin prévue, un rattrapage est encore possible
        pour les suivantes.
       </para>
       <para>
        Lorsque le bridage est actif, la latence de la transaction rapportée en
        fin de test est calculée à partir des dates de démarrage ordonnancées,
        c'est-à-dire qu'elle inclut le temps où chaque transaction attend
        que la précédente se termine.
        Le temps d'attente est appelé temps de latence d'ordonnancement,
        et ses valeurs moyenne et maximum sont rapportées séparément.
        La latence de transaction par rapport au temps de démarrage réel,
        c'est-à-dire le temps d'exécution de la transaction
        dans la base, peut être récupérée en soustrayant le temps de
        latence d'ordonnancement à la latence précisée dans les journaux.
       </para>

       <para>
        Si l'option <option>--latency-limit</option> est utilisée avec
        l'option  <option>--rate</option>, une transaction peut avoir
        une telle latence qu'elle serait déjà supérieure à limite de
        latence lorsque la transaction précédente se termine, car la
        latence est calculée au moment de la date de démarrage planifiée.
        Les transactions concernées ne sont pas envoyées à l'instance,
        elles sont complètement ignorées et comptabilisées séparément.
       </para>

       <para>
        Une latence de planification élevée est une indication
        que le système n'arrive pas à traiter les transactions à la vitesse
        demandée, avec les nombres de clients et threads indiqués.
        Lorsque le temps moyen d'exécution est plus important que
        l'intervalle prévu entre chaque transaction, les transactions
        vont prendre du retard une-à-une, et la latence de
        planification va continuer de croître tout le long de la durée
        du test.
        Si cela se produit, vous devrez réduire le taux de transaction
        que vous avez spécifié.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>scale_factor</replaceable></term>
      <term><option>--scale=</option><replaceable>scale_factor</replaceable></term>
      <listitem>
       <para>
        Affiche le facteur d'échelle dans la sortie de <application>pgbench</application>.
        Avec les tests internes, ce n'est pas nécessaire&nbsp;; le facteur
        d'échelle approprié sera détecté en comptant le nombre de lignes
        dans la table <structname>pgbench_branches</structname>.
        Toutefois, lors de l'utilisation d'un benchmark avec un scénario
        personnalisé (option <option>-f</option>), le facteur
        d'échelle sera affiché à 1 à moins que cette option soit utilisée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-S</option></term>
      <term><option>--select-only</option></term>
      <listitem>
       <para>
        Exécute le script interne select-only. Raccourci pour
        <option>-b select-only</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-t</option>
       <replaceable>transactions</replaceable></term>
      <term><option>--transactions=</option>
       <replaceable>transactions</replaceable></term>
      <listitem>
       <para>
        Nombre de transactions lancées par chaque client.
        La valeur par défaut est 10.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-T</option> <replaceable>seconds</replaceable></term>
      <term><option>--time=</option><replaceable>seconds</replaceable></term>
      <listitem>
       <para>
        Lance le test pour la durée spécifiée en secondes, plutôt que
        pour un nombre fixe de transactions par client.
        Les options <option>-t</option> et <option>-T</option> ne sont
        pas compatibles.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <term><option>--vacuum-all</option></term>
      <listitem>
       <para>
        Réalise un VACUUM sur les quatre tables standards avant de
        lancer le test. Sans l'option <option>-n</option> ou
        <option>-v</option>, <application>pgbench</application> lancera un VACUUM
        sur les tables <structname>pgbench_tellers</structname> et
        <structname>pgbench_branches</structname>, puis tronquera
        <structname>pgbench_history</structname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--aggregate-interval=
        <replaceable>secondes</replaceable></option></term>
      <listitem>
       <para>
        Taille de l'intervalle d'agrégation (en secondes). Ne peut
        être utilisée qu'avec l'option <application>-l</application>.
        Avec cette option, le journal contiendra des résumés par
        intervalle, comme décrit ci-dessous.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--failures-detailed</option></term>
      <listitem>
       <para>
        Dans les traces, par transaction et agrégées, et les rapports
        manuels et par script, affiche les erreurs regroupées selon les
        types suivants&nbsp;:
        <itemizedlist>
         <listitem>
          <para>erreurs de sérialisation&nbsp;;</para>
         </listitem>
         <listitem>
          <para>deadlocks&nbsp;;</para>
         </listitem>
        </itemizedlist>
        Voir <xref linkend="failures-and-retries"/> pour plus d'informations.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--log-prefix=<replaceable>prefix</replaceable></option></term>
      <listitem>
       <para>
        Définit le préfixe des fichiers logs créés par <option>--log</option>.
        Le défaut est <literal>pgbench_log</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--max-tries=<replaceable>number_of_tries</replaceable></option></term>
      <listitem>
       <para>
        Autorise de nouvelles tentatives dans les transactions avec des erreurs
        de sérialisation ou de verrous mortels, et définit le nombre maximum
        de ces tentatives.
        Cette option peut être combinée avec <option>--latency-limit</option>,
        qui limite le temps total de toutes les tentatives de transactions&nbsp;;
        cependant vous ne pouvez définir un nombre illimité de tentatives
        (<literal>--max-tries=0</literal>) sans définir
        <option>--latency-limit</option> ou <option>--time</option>.
        La valeur par défaut est 1, et les transactions avec des erreurs de
        sérialisation ou des deadlocks ne sont donc pas retentées.
        Voir <xref linkend="failures-and-retries"/>
        pour plus de détails sur les nouvelles tentatives sur de telles
        transactions.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--progress-timestamp</option></term>
      <listitem>
       <para>
        Lorsque la progression est affichée (option <option>-P</option>),
        utilise un horodatage de type timestamp (epoch Unix) au lieu d'un
        nombre de secondes depuis le début de l'exécution. L'unité est la
        seconde avec une précision en millisecondes après le point. Ceci
        aide à comparer les traces générées par différents outils.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--random-seed=</option><replaceable>graine</replaceable></term>
      <listitem>
       <para>
        Fournit la graine du générateur de nombres aléatoires, qui produira
        alors une séquence d'états initiaux du générateur, un pour chaque
        thread.
        Les valeurs pour <replaceable>graine</replaceable> peuvent être
        <literal>time</literal> (par défaut, la graine est basée sur l'heure en
        cours), <literal>rand</literal> (utilise une source fortement aléatoire,
        et tombe en échec si aucune n'est disponible), ou une valeur entière
        non signée.
        Le générateur aléatoire est appelé depuis un script
        pgbench explicitement (fonctions <literal>random...</literal>) ou
        implicitement (par exemple l'option <option>--rate</option> l'utilise
        pour planifier les transactions).
        Si elle est mise en place explicitement, la valeur utilisée comme
        graine est affichée sur le terminal.
        N'importe quelle valeur autorisée pour <replaceable>graine</replaceable>
        peut aussi être fournie par la variable d'environnement
        <literal>PGBENCH_RANDOM_SEED</literal>.
        Pour garantir que la graine fournie couvre tous les cas d'usage
        possibles, mettez cette fonction en premier ou utilisez la variable
        d'environnement.
       </para>
       <para>
        Placer cette variable explicitement permet de reproduire un run
        <command>pgbench</command> exactement identique, du moins en ce qui
        concerne les nombres aléatoires.
        Comme l'état du générateur aléatoire est géré par thread,
        <command>pgbench</command> s'exécutera à l'identique s'il y a un client
        par thread et pas de dépendance externe ou par rapport aux données.
        D'un point de vue statistique, reproduire des runs est une mauvaise
        idée, car cela peut masquer la variabilité des performances ou
        améliorer les performances excessivement, par exemple en appelant les
        mêmes pages qu'un run précédent.
        Cependant, ce peut être d'une grande aide pour déboguer, par exemple
        pour reproduire un cas tordu provoquant une erreur. À utiliser
        judicieusement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--sampling-rate=
        <replaceable>rate</replaceable></option></term>
      <listitem>
       <para>
        Taux d'échantillonnage utilisé lors de l'écriture des
        données dans les journaux, afin d'en réduire la quantité.
        Si cette option est utilisée, n'y sera écrite que la proportion
        indiquée des transactions.
        1.0 signifie que toutes les transactions seront journalisées,
        0.05 signifie que 5&nbsp;% de toutes les transactions le seront.
       </para>
       <para>
        Pensez à prendre le taux d'échantillonnage en compte en consultant
        le journal.
        Par exemple, lorsque vous évaluez le nombre de transactions par seconde,
        vous devrez multiplier les nombres en conséquence. (Par exemple,
        avec un taux d'échantillonnage de 0,01, vous n'obtiendrez que 1/100è du
        débit réel).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--show-script</option><replaceable>scriptname</replaceable></term>
      <listitem>
       <para>
        Affiche le code réel du script intégré <replaceable>scriptname
        </replaceable> sur stderr, et quitte immédiatement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--verbose-errors</option></term>
      <listitem>
       <para>
        Affiche des messages sur toutes les erreurs et échecs (les erreurs
        sans nouvelles tentatives), et mentionne quelle limite a été
        dépassée, et de combien, pour
        les échecs lors d'erreurs de sérialisation ou des deadlocks.
        (Notez que dans ce cas le débit peut être significativement amélioré.)
        Voir <xref linkend="failures-and-retries"/> pour plus d'informations.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

  </refsect2>

  <refsect2 id="pgbench-common-options">
   <title>Options courantes</title>

   <para>
    <application>pgbench</application> accepte aussi les arguments suivants en
    ligne de commande pour les paramètres de connexion&nbsp;:

    <variablelist>

     <varlistentry>
      <term><option>-h</option>
       <replaceable>hostname</replaceable></term>
      <term><option>--host=</option>
       <replaceable>hostname</replaceable></term>
      <listitem>
       <para>
        Le nom du serveur de base de données
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-p</option>
       <replaceable>port</replaceable></term>
      <term><option>--port=</option>
       <replaceable>port</replaceable></term>
      <listitem>
       <para>
        Le port d'écoute de l'instance sur le serveur de base de données
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-U</option>
       <replaceable>login</replaceable></term>
      <term><option>--username=</option>
       <replaceable>login</replaceable></term>
      <listitem>
       <para>
        Le nom de l'utilisateur avec lequel on se connecte
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-V</option></term>
      <term><option>--version</option></term>
      <listitem>
       <para>
        Affiche la version de <application>pgbench</application>
        puis quitte.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-?</option></term>
      <term><option>--help</option></term>
      <listitem>
       <para>
        Affiche l'aide sur les arguments en ligne de commande de
        <application>pgbench</application> puis quitte.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

  </refsect2>
 </refsect1>

 <refsect1>
  <title>Code de sortie</title>

  <para>
   Une exécution réussie se terminera avec un code d'erreur 0.
   Une valeur 1 indique des problèmes comme des options de ligne de commande
   invalides ou des erreurs internes supposée ne jamais arriver.
   Des erreurs dès le démarrage du benchmark, comme des échecs aux premières
   tentatives de connexion, échouent aussi avec le statut 1.
   Des erreurs pendant l'exécution, comme des erreurs de base de données ou des
   problèmes dans le script, provoquent une erreur de code 2.
   Dans ce dernier cas, pgbench affichera des résultats partiels.
  </para>
 </refsect1>

 <refsect1>
  <title>Environnement</title>

  <variablelist>
   <varlistentry>
    <term><envar>PGDATABASE</envar></term>
    <term><envar>PGHOST</envar></term>
    <term><envar>PGPORT</envar></term>
    <term><envar>PGUSER</envar></term>

    <listitem>
     <para>
      Paramètres de connexion par défaut.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Cet outil, comme la plupart des autres outils
   <productname>PostgreSQL</productname>, utilise les variables
   d'environnement supportées par la <application>libpq</application> (voir
   <xref linkend="libpq-envars"/>).
  </para>

  <para>
   La variable d'environnement <envar>PG_COLOR</envar> précise si l'on
   doit utiliser la couleur dans les messages de diagnostic.
   Les valeurs possibles sont
   <literal>always</literal>, <literal>auto</literal> et
   <literal>never</literal>.
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <refsect2 id="transactions-and-scripts" xreflabel="What Is the &quot;Transaction&quot; Actually Performed in pgbench?">
   <title>Qu'est-ce qu'une <quote>Transaction</quote>
    réellement exécutée par <application>pgbench</application>&nbsp;?</title>

   <para>
    <application>pgbench</application> exécute des scripts de tests choisis de
    façon aléatoire à partir d'une sélection. Les scripts peuvent inclure
    des scripts internes, indiqués avec l'option <option>-b</option>, et des
    scripts fournis par l'utilisateur, indiqués avec l'option
    <option>-f</option>. Chaque script peut se voir affecter un poids
    relatif, à préciser après un caractère <literal>@</literal>, pour modifier sa
    probabilité de sélection. Le poids par défaut est de <literal>1</literal>.
    Les scripts avec un poids de <literal>0</literal> sont ignorés.
   </para>

   <para>
    Le script interne par défaut (aussi appelé avec <option>-b tpcb-like</option>)
    exécute sept commandes par transaction choisies de
    façon aléatoire parmi <literal>aid</literal>, <literal>tid</literal>,
    <literal>bid</literal> et <literal>delta</literal>. Le scénario s'inspire
    du benchmark TPC-B, mais il ne s'agit pas réellement de TPC-B, d'où son nom.
   </para>

   <orderedlist>
    <listitem><para><literal>BEGIN;</literal></para></listitem>
    <listitem><para><literal>
       UPDATE pgbench_accounts SET abalance = abalance + :delta
       WHERE aid = :aid;</literal></para></listitem>
    <listitem><para><literal>SELECT abalance FROM pgbench_accounts
       WHERE aid = :aid;</literal></para></listitem>
    <listitem><para><literal>UPDATE pgbench_tellers
       SET tbalance = tbalance + :delta
       WHERE tid = :tid;</literal></para></listitem>
    <listitem><para><literal>UPDATE pgbench_branches
       SET bbalance = bbalance + :delta
       WHERE bid = :bid;</literal></para></listitem>
    <listitem><para><literal>INSERT
       INTO pgbench_history (tid, bid, aid, delta, mtime)
       VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
      </literal></para></listitem>
    <listitem><para><literal>END;</literal></para></listitem>
   </orderedlist>

   <para>
    Si vous sélectionnez le script interne <literal>simple-update</literal> (ou
    <option>-N</option>), les étapes 4 et 5 ne sont pas incluses dans la
    transaction. Cela évitera des contentions au niveau des mises à jour sur
    ces tables, mais le test ressemblera encore moins à TPC-B.
   </para>

   <para>
    Si vous sélectionnez le script interne <literal>select-only</literal> (ou
    <option>-S</option>), alors seul le <command>SELECT</command> est exécuté.
   </para>
  </refsect2>

  <refsect2>
   <title>Scripts personnalisés</title>

   <para>
    <application>pgbench</application> est capable d'utiliser des
    scénarios de test de performance personnalisés, en remplaçant le
    script de transactions par défaut (décrit ci-dessus) par un script de
    transactions lu depuis un fichier spécifié avec l'option
    (<option>-f</option>).
    Dans ce cas, une <quote>transaction</quote> est comptabilisée comme
    une exécution du fichier script.
   </para>

   <para>
    Un fichier script contient une ou plusieurs commandes SQL terminées par des
    points-virgules. Les lignes vides et les lignes commençant par
    <literal>--</literal> sont ignorées. Les fichiers scripts peuvent aussi
    contenir des <quote>méta-commandes</quote>, qui seront interprétées par
    <application>pgbench</application> comme indiqué plus bas.
   </para>

   <note>
    <para>
     Avant <productname>PostgreSQL</productname> 9.6, les commandes SQL comprises
     dans les fichiers scripts étaient terminées par un retour à la ligne.
     Elles ne pouvaient donc pas être écrites sur plusieurs lignes. Maintenant,
     un point-virgule est <emphasis>requis</emphasis> pour séparer des
     commandes SQL consécutives (bien qu'une commande SQL n'en a pas besoin si
     elle est suivie par une méta-commande). Si vous avez besoin de créer un
     fichier script qui fonctionne avec les anciennes et nouvelles versions de
     <application>pgbench</application>, assurez-vous d'écrire chaque commande
     SQL sur une seule ligne et en terminant avec un point-virgule.
    </para>
    <para>
     On part du principe que les scripts pgbench ne contiennent pas de
     blocs incomplets de transactions SQL. Si à l'exécution le client atteint
     la fin du script sans terminer le dernier bloc de transaction,
     il sera arrêté.
    </para>
   </note>

   <para>
    Il est possible de procéder facilement à de la substitution de variables
    dans les fichiers scripts.
    Les noms de variables doivent consister en lettres (y compris des caractères
    non latins), chiffres et soulignés (<literal>_</literal>), mais le premier
    caractère ne doit pas être un chiffre.
    Les variables peuvent être instanciées via
    l'option <option>-D</option> de la ligne de commande comme décrit ci-dessus,
    ou grâce aux méta-commandes décrites ci-dessous.
    En plus des commandes pré-définies par l'option de la ligne de
    commande <option>-D</option>, quelques variables sont
    automatiquement prédéfinies, listées sous
    <xref linkend="pgbench-automatic-variables"/>.
    Une valeur de ces variables définie via l'option <option>-D</option>
    aura priorité sur la valeur définie
    automatiquement. Une fois définie, la valeur d'une variable peut
    être insérée dans les commandes SQL en écrivant <literal>:</literal>
    <replaceable>nom_variable</replaceable>.
    S'il y a plus d'une session par client, chaque session possède son
    propre jeu de variables.
    <application>pgbench</application> supports up to 255 variable uses in one
    statement.
   </para>

   <table id="pgbench-automatic-variables">
    <title>Variables automatiques de pgbench</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="2*"/>
     <thead>
      <row>
       <entry>Variable</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>client_id</literal></entry>
       <entry>nombre unique permettant d'identifier la session client
        (commence à zéro)</entry>
      </row>

      <row>
       <entry> <literal>default_seed</literal> </entry>
       <entry>graine utilisée par défaut dans les fonctions de hachage
        et de permutation pseudo-aléatoire</entry>
      </row>

      <row>
       <entry> <literal>random_seed</literal> </entry>
       <entry>graine du générateur aléatoire (si pas remplacée avec
        <option>-D</option>)</entry>
      </row>

      <row>
       <entry><literal>scale</literal></entry>
       <entry>facteur d'échelle courant</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Dans les fichiers de scripts, les méta-commandes commencent avec un
    anti-slash (<literal>\</literal>) et s'étendent jusqu'à la fin de la ligne,
    même si elles peuvent s'étendre sur plusieurs lignes en écrivant anti-slash
    puis un retour chariot. Les
    arguments d'une méta-commande sont séparés par des espaces vides. Les
    méta-commandes suivantes sont supportées&nbsp;:
   </para>

   <variablelist>
    <varlistentry id='pgbench-metacommand-gset'>
     <term>
      <literal>\gset [<replaceable>prefix</replaceable>]</literal>
      <literal>\aset [<replaceable>prefix</replaceable>]</literal>
     </term>

     <listitem>
      <para>
       Cette commande peut être utilisée pour marquer la fin de requêtes SQL,
       prenant ainsi la place du point-virgule final (<literal>;</literal>).
      </para>

      <para>
       Quand la commande <literal>\gset</literal> est utilisée,
       la requête SQL précédente doit renvoyer une ligne.
       Les valeurs de ses colonnes sont enregistrées dans
       des variables nommées d'après les noms de colonnes, préfixées avec
       <replaceable>prefix</replaceable>, si ce dernier est fourni.
      </para>

      <para>
       Quand la commande <literal>\aset</literal> est utilisée, toutes les requêtes
       (séparées par <literal>\;</literal>) voient leurs colonnes stockées dans
       des variables nommées d'après elles, préfixées de <replaceable>prefix</replaceable>
       s'il est fourni.
       Si une requête ne retourne aucune ligne, aucune affectation n'est faite.
       On peut tester l'existence de la variable pour détecter ce cas.
       Si une requête retourne plus d'une ligne, la dernière valeur est conservée.
      </para>

      <para>
       <literal>\gset</literal> et <literal>\aset</literal> ne peuvent être
       utilisées en mode pipeline, puisque les résultats des requêtes ne sont pas
       encore disponibles au moment où la commande en a besoin.
      </para>

      <para>
       L'exemple suivant place la balance finale du compte provenant de la
       première requête dans la variable <replaceable>abalance</replaceable>,
       et remplit les variables <replaceable>p_two</replaceable> et
       <replaceable>p_three</replaceable> avec les entiers provenant de la
       troisième requête. Le résultat de la deuxième requête est ignoré.
       Les résultats des deux dernières requêtes combinées sont stockés dans
       les variables
       <replaceable>four</replaceable> et <replaceable>five</replaceable>.
       <programlisting>
UPDATE pgbench_accounts
  SET abalance = abalance + :delta
  WHERE aid = :aid
  RETURNING abalance \gset
-- compound of two queries
SELECT 1 \;
SELECT 2 AS two, 3 AS three \gset p_
SELECT 4 AS four \; SELECT 5 AS five \aset
       </programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>\if</literal> <replaceable class="parameter">expression</replaceable></term>
     <term><literal>\elif</literal> <replaceable class="parameter">expression</replaceable></term>
     <term><literal>\else</literal></term>
     <term><literal>\endif</literal></term>
     <listitem>
      <para>
       Ce groupe de commandes implémente des blocs conditionnels imbriquables,
       de manière similaire au <xref linkend="psql-metacommand-if"/> de
       <literal>psql</literal>.
       Les expressions conditionnelles sont identiques à celles avec
       <literal>\set</literal>, les valeurs autres que zéro valant
       <literal>true</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id='pgbench-metacommand-set'>
     <term>
      <literal>\set <replaceable>nom_variable</replaceable>
       <replaceable>expression</replaceable></literal>
     </term>

     <listitem>
      <para>
       Définit la variable <replaceable>nom_variable</replaceable> à une valeur
       définie par <replaceable>expression</replaceable>.

       L'expression peut contenir la constante <literal>NULL</literal>,
       les constantes booléennes <literal>TRUE</literal> et
       <literal>FALSE</literal>, des constantes entières comme
       <literal>5432</literal>, des constantes double précision comme
       <literal>3.14159</literal>, des références à des variables
       <literal>:</literal><replaceable>nomvariable</replaceable>,
       des <link linkend="pgbench-builtin-operators">opérateurs</link> avec leur
       priorité et leur associativité habituelles en SQL,
       <link linkend="pgbench-builtin-functions">des appels de fonction</link>,
       des
       <link linkend="functions-case">expressions conditionnelles génériques SQL
        avec <token>CASE</token></link> et des parenthèses.
      </para>

      <para>
       Les fonctions et la plupart des opérateurs retournent
       <literal>NULL</literal> en cas d'entrée à <literal>NULL</literal>.
      </para>

      <para>
       En ce qui concerne les conditions, les valeurs numériques différentes de
       zéro valent <literal>TRUE</literal>, les valeurs numériques à zéro et
       <literal>NULL</literal> sont <literal>FALSE</literal>.
      </para>

      <para>
       Des constantes entières ou à virgule flottante ainsi que des opérateurs
       arithmétiques entiers (<literal>+</literal>, <literal>-</literal>,
       <literal>*</literal> et <literal>/</literal>), trop larges ou trop
       petites, renvoient des erreurs de dépassement.
      </para>

      <para>
       Quand aucune clause finale <token>ELSE</token> n'est fournie à un
       <token>CASE</token>, la valeur par défaut est <literal>NULL</literal>.
      </para>

      <para>
       Exemples&nbsp;:
       <programlisting>
\set ntellers 10 * :scale
\set aid (1021 * random(1, 100000 * :scale)) % \
           (100000 * :scale) + 1
\set divx CASE WHEN :x &lt;&gt; 0 THEN :y/:x ELSE NULL END
       </programlisting></para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal>\sleep
       <replaceable>nombre</replaceable> [ us | ms | s ]</literal>
     </term>

     <listitem>
      <para>
       Entraîne la suspension de l'exécution du script pendant la durée
       spécifiée en microsecondes (<literal>us</literal>), millisecondes
       (<literal>ms</literal>) ou secondes (<literal>s</literal>).
       Si l'unité n'est pas définie, l'unité par défaut est la seconde.
       Ce peut être soit un entier constant, soit une référence
       <literal>:</literal><replaceable>nom_variable</replaceable> vers
       une variable retournant un entier.
      </para>

      <para>
       Exemple&nbsp;:
       <programlisting>
\sleep 10 ms
       </programlisting></para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal>\setshell <replaceable>nom_variable</replaceable>
       <replaceable>commande</replaceable> [
       <replaceable>argument</replaceable> ... ]</literal>
     </term>

     <listitem>
      <para>
       Définit la variable <replaceable>nom_variable</replaceable> comme le
       résultat d'une commande shell nommée <replaceable>commande</replaceable>
       aves le(s) <replaceable>argument</replaceable>(s) donné(s). La commande
       doit retourner un entier sur la sortie standard.
      </para>

      <para>
       <replaceable>commande</replaceable> et chaque
       <replaceable>argument</replaceable> peuvent être soit une constante de
       type text, soit une référence
       <literal>:</literal><replaceable>nom_variable</replaceable> à une variable.
       Si vous voulez utiliser un <replaceable>argument</replaceable> commençant
       avec un symbole deux-points, écrivez un deux-points supplémentaire au
       début de l'<replaceable>argument</replaceable>.
      </para>

      <para>
       Exemple&nbsp;:
       <programlisting>
\setshell variable_à_utiliser commande argument_litéral :variable
::literal_commencant_avec_deux_points
       </programlisting></para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal>\shell <replaceable>commande
       </replaceable> [ <replaceable>argument</replaceable> ... ]
      </literal>
     </term>

     <listitem>
      <para>
       Identique à <literal>\setshell</literal>, mais le résultat de la
       commande sera ignoré.
      </para>

      <para>
       Exemple&nbsp;:
       <programlisting>
\shell command literal_argument :variable ::literal_starting_with_colon
       </programlisting></para>
     </listitem>
    </varlistentry>

    <varlistentry id='pgbench-metacommand-pipeline'>
     <term><literal>\startpipeline</literal></term>
     <term><literal>\endpipeline</literal></term>

     <listitem>
       <para>
         Ces commandes définissent le début et la fin de requêtes SQL.
         En mode pipeline, celles-ci sont envoyées au serveur sans attendre le
         résultat des requêtes précédentes.
         Voir <xref linkend="libpq-pipeline-mode"/> pour plus de détails.
         Le mode pipeline impose l'utilisation du protocole de requête étendu.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect2>

  <refsect2 id="pgbench-builtin-operators">
   <title>Opérateurs intégrés</title>

   <para>
    Les opérateurs arithmétiques, de manipulation de bits, de comparaison et
    logiques listés dans <xref linkend="pgbench-operators"/> sont intégrés
    dans <application>pgbench</application> et peuvent être utilisés dans des
    expressions apparaissant dans <link linkend="pgbench-metacommand-set">
     <literal>\set</literal></link>.
    Les opérateurs sont listés par priorité croissante.
    Sauf indication contraire, les opérateurs prenant deux paramètres
    en entrée produiront un nombre en double précision, si une des entrées
    est en double précision, sinon le résultat produit sera entier.
   </para>

   <table id="pgbench-operators">
    <title>Opérateurs pgbench</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
         Opérateur
        </para>
        <para>
         Description
        </para>
        <para>
         Exemple(s)
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>booléen</replaceable> <literal>OR</literal> <replaceable>booléen</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         OU logique
        </para>
        <para>
         <literal>5 or 0</literal>
         <returnvalue>TRUE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>booléen</replaceable> <literal>AND</literal> <replaceable>booléen</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         ET logique
        </para>
        <para>
         <literal>3 and 0</literal>
         <returnvalue>FALSE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <literal>NOT</literal> <replaceable>booléen</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         NON logique
        </para>
        <para>
         <literal>not false</literal>
         <returnvalue>TRUE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>booléen</replaceable> <literal>IS [NOT] (NULL|TRUE|FALSE)</literal>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         Tests de valeur booléenne
        </para>
        <para>
         <literal>1 is null</literal>
         <returnvalue>FALSE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>valeur</replaceable> <literal>ISNULL|NOTNULL</literal>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         Tests de nullité
        </para>
        <para>
         <literal>1 notnull</literal>
         <returnvalue>TRUE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>=</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         Est égal
        </para>
        <para>
         <literal>5 = 4</literal>
         <returnvalue>FALSE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>&lt;&gt;</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         N'est pas égal
        </para>
        <para>
         <literal>5 &lt;&gt; 4</literal>
         <returnvalue>TRUE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>!=</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         N'est pas égal
        </para>
        <para>
         <literal>5 != 5</literal>
         <returnvalue>FALSE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>&lt;</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         Inférieur à
        </para>
        <para>
         <literal>5 &lt; 4</literal>
         <returnvalue>FALSE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>&lt;=</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         Inférieur ou égal à
        </para>
        <para>
         <literal>5 &lt;= 4</literal>
         <returnvalue>FALSE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>&gt;</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         Plus grand que
        </para>
        <para>
         <literal>5 &gt; 4</literal>
         <returnvalue>TRUE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>&gt;=</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>booléen</replaceable></returnvalue>
        </para>
        <para>
         Plus grand ou égal à
        </para>
        <para>
         <literal>5 &gt;= 4</literal>
         <returnvalue>TRUE</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>entier</replaceable> <literal>|</literal> <replaceable>entier</replaceable>
         <returnvalue><replaceable>entier</replaceable></returnvalue>
        </para>
        <para>
         OU binaire
        </para>
        <para>
         <literal>1 | 2</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>entier</replaceable> <literal>#</literal> <replaceable>entier</replaceable>
         <returnvalue><replaceable>entier</replaceable></returnvalue>
        </para>
        <para>
         XOR binaire
        </para>
        <para>
         <literal>1 # 3</literal>
         <returnvalue>2</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>entier</replaceable> <literal>&amp;</literal> <replaceable>entier</replaceable>
         <returnvalue><replaceable>entier</replaceable></returnvalue>
        </para>
        <para>
         ET binaire
        </para>
        <para>
         <literal>1 &amp; 3</literal>
         <returnvalue>1</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <literal>~</literal> <replaceable>entier</replaceable>
         <returnvalue><replaceable>entier</replaceable></returnvalue>
        </para>
        <para>
         NON binaire
        </para>
        <para>
         <literal>~ 1</literal>
         <returnvalue>-2</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>entier</replaceable> <literal>&lt;&lt;</literal> <replaceable>entier</replaceable>
         <returnvalue><replaceable>entier</replaceable></returnvalue>
        </para>
        <para>
         Décalage binaire vers la gauche
        </para>
        <para>
         <literal>1 &lt;&lt; 2</literal>
         <returnvalue>4</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>entier</replaceable> <literal>&gt;&gt;</literal> <replaceable>entier</replaceable>
         <returnvalue><replaceable>entier</replaceable></returnvalue>
        </para>
        <para>
         Décalage binaire vers la droite
        </para>
        <para>
         <literal>8 &gt;&gt; 2</literal>
         <returnvalue>2</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>+</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>nombre</replaceable></returnvalue>
        </para>
        <para>
         Addition
        </para>
        <para>
         <literal>5 + 4</literal>
         <returnvalue>9</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>-</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>nombre</replaceable></returnvalue>
        </para>
        <para>
         Soustraction
        </para>
        <para>
         <literal>3 - 2.0</literal>
         <returnvalue>1.0</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>*</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>nombre</replaceable></returnvalue>
        </para>
        <para>
         Multiplication
        </para>
        <para>
         <literal>5 * 4</literal>
         <returnvalue>20</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>nombre</replaceable> <literal>/</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>nombre</replaceable></returnvalue>
        </para>
        <para>
         Division (tronque le résultat vers zéro si les deux paramètres d'entrée sont des entiers)
        </para>
        <para>
         <literal>5 / 3</literal>
         <returnvalue>1</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <replaceable>entier</replaceable> <literal>%</literal> <replaceable>entier</replaceable>
         <returnvalue><replaceable>entier</replaceable></returnvalue>
        </para>
        <para>
         Modulo (reste)
        </para>
        <para>
         <literal>3 % 2</literal>
         <returnvalue>1</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <literal>-</literal> <replaceable>nombre</replaceable>
         <returnvalue><replaceable>nombre</replaceable></returnvalue>
        </para>
        <para>
         Opposé
        </para>
        <para>
         <literal>- 2.0</literal>
         <returnvalue>-2.0</returnvalue>
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </refsect2>

  <refsect2 id="pgbench-builtin-functions">
   <title>Fonctions internes</title>

   <para>
    Les fonctions listées dans <xref linkend="pgbench-functions"/> sont
    internes à <application>pgbench</application> et peuvent être
    utilisées dans des expressions apparaissant dans
    <link linkend="pgbench-metacommand-set"><literal>\set</literal></link>.
   </para>

   <!-- list pgbench functions in alphabetical order -->
   <table id="pgbench-functions">
    <title>pgbench Functions</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
         Fonction
        </para>
        <para>
         Description
        </para>
        <para>
         Exemple(s)
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>abs</function> ( <replaceable>nombre</replaceable> )
         <returnvalue></returnvalue> même que l'entrée
        </para>
        <para>
         Valeur absolue
        </para>
        <para>
         <literal>abs(-17)</literal>
         <returnvalue>17</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>debug</function> ( <replaceable>nombre</replaceable> )
         <returnvalue></returnvalue> même que l'entrée
        </para>
        <para>
         Affiche l'argument dans <systemitem>stderr</systemitem>,
         puis le retourne.
        </para>
        <para>
         <literal>debug(5432.1)</literal>
         <returnvalue>5432.1</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>double</function> ( <replaceable>nombre</replaceable> )
         <returnvalue>double</returnvalue>
        </para>
        <para>
         Convertit en double précision.
        </para>
        <para>
         <literal>double(5432)</literal>
         <returnvalue>5432.0</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>exp</function> ( <replaceable>nombre</replaceable> )
         <returnvalue>double</returnvalue>
        </para>
        <para>
         Exponentielle (<literal>e</literal> à la puissance indiquée)
        </para>
        <para>
         <literal>exp(1.0)</literal>
         <returnvalue>2.718281828459045</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>greatest</function> ( <replaceable>nombre</replaceable> <optional>, <literal>...</literal> </optional> )
         <returnvalue></returnvalue> <type>double</type> si un argument est un double, sinon <type>entier</type>
        </para>
        <para>
         Sélectionne la plus grande valeur parmi les arguments.
        </para>
        <para>
         <literal>greatest(5, 4, 3, 2)</literal>
         <returnvalue>5</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>hash</function> ( <parameter>valeur</parameter> <optional>, <parameter>graine</parameter> </optional> )
         <returnvalue>entier</returnvalue>
        </para>
        <para>
         Alias pour <function>hash_murmur2</function>.
        </para>
        <para>
         <literal>hash(10, 5432)</literal>
         <returnvalue>-5817877081768721676</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>hash_fnv1a</function> ( <parameter>valeur</parameter> <optional>, <parameter>graine</parameter> </optional> )
         <returnvalue>entier</returnvalue>
        </para>
        <para>
         Calcule le <ulink url="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">
          hash FNV-1a</ulink>. <!-- NB : pas de version française de cette page sur Wikipédia -->
        </para>
        <para>
         <literal>hash_fnv1a(10, 5432)</literal>
         <returnvalue>-7793829335365542153</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>hash_murmur2</function> ( <parameter>valeur</parameter> <optional>, <parameter>graine</parameter> </optional> )
         <returnvalue>entier</returnvalue>
        </para>
        <para>
         Computes <ulink url="https://en.wikipedia.org/wiki/MurmurHash">MurmurHash2 hash</ulink>.
         <!-- NB : pas de version française de cette page sur Wikipédia -->
        </para>
        <para>
         <literal>hash_murmur2(10, 5432)</literal>
         <returnvalue>-5817877081768721676</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>int</function> ( <replaceable>nombre</replaceable> )
         <returnvalue>entier</returnvalue>
        </para>
        <para>
         Convertit en entier.
        </para>
        <para>
         <literal>int(5.4 + 3.8)</literal>
         <returnvalue>9</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>least</function> ( <replaceable>nombre</replaceable> <optional>, <literal>...</literal> </optional> )
         <returnvalue></returnvalue> <type>double</type> si un argument est un double, sinon <type>entier</type>
        </para>
        <para>
         Choisit la plus petite valeur parmi les arguments.
        </para>
        <para>
         <literal>least(5, 4, 3, 2.1)</literal>
         <returnvalue>2.1</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>ln</function> ( <replaceable>nombre</replaceable> )
         <returnvalue>double</returnvalue>
        </para>
        <para>
         Logarithme naturel
        </para>
        <para>
         <literal>ln(2.718281828459045)</literal>
         <returnvalue>1.0</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>mod</function> ( <replaceable>entier</replaceable>, <replaceable>entier</replaceable> )
         <returnvalue>entier</returnvalue>
        </para>
        <para>
         Modulo (reste)
        </para>
        <para>
         <literal>mod(54, 32)</literal>
         <returnvalue>22</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>permute</function> ( <parameter>i</parameter>, <parameter>taille</parameter> [, <parameter>graine</parameter> ] )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Valeur permutée de <parameter>i</parameter>, dans la tranche
        <literal>[0, taille)</literal>,
        soit la nouvelle position de <parameter>i</parameter>
        (modulo <parameter>taille</parameter>) dans une permutation
        pseudo-aléatoire des entiers <literal>0...taille-1</literal>,
        paramétrée par la <parameter>graine</parameter> (voir plus bas).
       </para>
       <para>
        <literal>permute(0, 4)</literal>
        <returnvalue>un entier entre 0 and 3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>pi</function> ()
         <returnvalue>double</returnvalue>
        </para>
        <para>
         Valeur approximative de <phrase role="symbol_font">&pi;</phrase>
        </para>
        <para>
         <literal>pi()</literal>
         <returnvalue>3.14159265358979323846</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>pow</function> ( <parameter>x</parameter>, <parameter>y</parameter> )
         <returnvalue>double</returnvalue>
        </para>
        <para role="func_signature">
         <function>power</function> ( <parameter>x</parameter>, <parameter>y</parameter> )
         <returnvalue>double</returnvalue>
        </para>
        <para>
         <parameter>x</parameter> à la puissance <parameter>y</parameter>
        </para>
        <para>
         <literal>pow(2.0, 10)</literal>
         <returnvalue>1024.0</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>random</function> ( <parameter>lb</parameter>, <parameter>ub</parameter> )
         <returnvalue>entier</returnvalue>
        </para>
        <para>
         Calcule un entier aléatoire uniformément distribué dans
         <literal>[lb, ub]</literal>.
        </para>
        <para>
         <literal>random(1, 10)</literal>
         <returnvalue>un entier entre 1 and 10</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>random_exponential</function> ( <parameter>lb</parameter>, <parameter>ub</parameter>, <parameter>paramètre</parameter> )
         <returnvalue>entier</returnvalue>
        </para>
        <para>
         Calcule un entier aléatoire distribué exponentiellement dans
         <literal>[lb, ub]</literal>&nbsp;;voir plus bas.
        </para>
        <para>
         <literal>random_exponential(1, 10, 3.0)</literal>
         <returnvalue>un entier entre 1 and 10</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>random_gaussian</function> ( <parameter>lb</parameter>, <parameter>ub</parameter>, <parameter>paramètre</parameter> )
         <returnvalue>entier</returnvalue>
        </para>
        <para>
         Calcule un entier aléatoire distribué de manière gaussienne dans
         <literal>[lb, ub]</literal>&nbsp;;voir plus bas.
        </para>
        <para>
         <literal>random_gaussian(1, 10, 2.5)</literal>
         <returnvalue>un entier entre 1 and 10</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>random_zipfian</function> ( <parameter>lb</parameter>, <parameter>ub</parameter>, <parameter>paramètre</parameter> )
         <returnvalue>entier</returnvalue>
        </para>
        <para>
         Calcule un entier aléatoire distribué selon la loi de Zipf dans
         <literal>[lb, ub]</literal>&nbsp;;voir plus bas.
        </para>
        <para>
         <literal>random_zipfian(1, 10, 1.5)</literal>
         <returnvalue>une valeur entre 1 and 10</returnvalue>
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <function>sqrt</function> ( <replaceable>nombre</replaceable> )
         <returnvalue>double</returnvalue>
        </para>
        <para>
         Racine carrée
        </para>
        <para>
         <literal>sqrt(2.0)</literal>
         <returnvalue>1.414213562</returnvalue>
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    La fonction <literal>random</literal> génère des valeurs en utilisant une
    distribution uniforme&nbsp;; autrement dit toutes les valeurs sont dans
    l'intervalle spécifiée avec une probabilité identique. Les fonctions
    <literal>random_exponential</literal>, <literal>random_gaussian</literal>
    et <literal>random_zipfian</literal> requièrent un paramètre
    supplémentaire de type double qui détermine le contour précis de cette
    distribution.
   </para>

   <itemizedlist>
    <listitem>
     <para>
      Pour une distribution exponentielle,
      <replaceable>paramètre</replaceable> contrôle la distribution en
      tronquant une distribution exponentielle en décroissance rapide à
      <replaceable>paramètre</replaceable>, puis en projetant le résultant sur
      des entiers entre les limites. Pour être précis&nbsp;:
      <literallayout>
       f(x) = exp(-paramètre * (x - min) / (max - min + 1)) / (1 - exp(-paramètre))
      </literallayout>
      Puis la valeur <replaceable>i</replaceable> entre les valeurs
      <replaceable>min</replaceable> et <replaceable>max</replaceable>, en les
      incluant, est récupérée avec la probabilité&nbsp;:
      <literal>f(i) - f(i + 1)</literal>.
     </para>

     <para>
      Intuitivement, plus <replaceable>paramètre</replaceable> est grand, plus
      les valeurs fréquentes proches de <replaceable>min</replaceable> sont
      accédées et moins les valeurs fréquentes proches de
      <replaceable>max</replaceable> sont accédées. Plus
      <replaceable>paramètre</replaceable> est proche de 0, plus la
      distribution d'accès sera plate (uniforme). Une approximation grossière de
      la distribution est que 1&nbsp;% des valeurs les plus fréquentes de
      l'intervalle, proches de <replaceable>min</replaceable>, sont tirées
      <replaceable>paramètre</replaceable>% du temps. La valeur de
      <replaceable>paramètre</replaceable> doit être strictement positive.
     </para>
    </listitem>

    <listitem>
     <para>
      Pour une distribution gaussienne, l'intervalle correspond à une
      distribution normale standard (la courbe gaussienne classique en forme
      de cloche) tronquée à <literal>-paramètre</literal> à gauche et à
      <literal>+paramètre</literal> à droite.
      Les valeurs au milieu de l'intervalle sont plus
      susceptibles d'être sélectionnées. Pour être précis, si
      <literal>PHI(x)</literal> est la fonction de distribution cumulative de
      la distribution normale standard, avec une moyenne <literal>mu</literal>
      définie comme <literal>(max + min) / 2.0</literal>, avec
      <literallayout>
       f(x) = PHI(2.0 * paramètre * (x - mu) / (max - min + 1)) /
       (2.0 * PHI(paramètre) - 1)
      </literallayout>
      alors la valeur <replaceable>i</replaceable> entre
      <replaceable>min</replaceable> et <replaceable>max</replaceable>
      (inclus) est sélectionnée avec une probabilité&nbsp;:
      <literal>f(i + 0.5) - f(i - 0.5)</literal>. Intuitivement, plus
      <replaceable>paramètre</replaceable> est grand, et plus les valeurs
      fréquentes proches du centre de l'intervalle sont sélectionnées, et
      moins les valeurs fréquentes proches des bornes
      <replaceable>min</replaceable> et <replaceable>max</replaceable>.
      Environ 67&nbsp;% des valeurs sont sélectionnées à partir du centre
      <literal>1.0 / paramètre</literal>, soit
      <literal>0.5 / paramètre</literal> autour de la moyenne, et 95&nbsp;% dans le
      centre <literal>2.0 / paramètre</literal>, soit
      <literal>1.0 / paramètre</literal> autour de la moyenne&nbsp;; par
      exemple, si <replaceable>paramètre</replaceable> vaut 4.0, 67&nbsp;% des
      valeurs sont sélectionnées depuis le quart du milieu (1.0 / 4.0) de
      l'intervalle (ou à partir de <literal>3.0 / 8.0</literal> jusqu'à
      <literal>5.0 / 8.0</literal>) et 95&nbsp;% depuis la moitié du milieu
      (<literal>2.0 / 4.0</literal>) de l'intervalle (deuxième et troisième
      quartiles). La valeur minimale autorisée pour <replaceable>paramètre</replaceable>
      est 2.0.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>random_zipfian</literal> génère une distribution bornée
      selon la loi de Zipf.
      <replaceable>paramètre</replaceable>
      définit à quel point la distribution est biaisée. Plus
      <replaceable>paramètre</replaceable> est grand, plus fréquemment les
      valeurs du début de l'intervalle seront tirées.
      La distribution est telle que, en supposant que l'intervalle commence à
      1, le ratio de probabilité d'un jet <replaceable>k</replaceable> contre
      un jet <replaceable>k+1</replaceable> est
      <literal>((<replaceable>k</replaceable>+1)/<replaceable>k</replaceable>)**<replaceable>parameter</replaceable></literal>.
      Par exemple, <literal>random_zipfian(1, ..., 2.5)</literal> produit
      la valeur <literal>1</literal> à peu près <literal>(2/1)**2.5 =
       5.66</literal> fois plus fréquemment que <literal>2</literal>, qui
      lui-même est produit <literal>(3/2)**2.5 = 2.76</literal> fois plus
      fréquemment que <literal>3</literal>, et ainsi de suite.
     </para>
     <para>
      L'implémentation de <application>pgbench</application> est basée sur
      «&nbsp;Non-Uniform Random Variate Generation&nbsp;», Luc Devroye, p. 550-551,
      Springer 1986. À cause des limitations de cet algorithme, la valeur
      <replaceable>paramètre</replaceable> est restreinte à l'intervalle
      [1.001, 1000].
     </para>
    </listitem>
   </itemizedlist>

   <note>
    <para>
      Lors de la conception d'un benchmark qui sélectionne des lignes de
      manière non uniforme, soyez conscient que les lignes choisies peuvent
      être corrélées avec d'autres données, comme les ID d'une séquence ou
      l'ordre physique des lignes, ce qui peut biaiser les mesures de
      performance.
    </para>
    <para>
      Pour éviter cela, pensez à la fonction <function>permute</function>,
      ou toute autre opération avec le même effet, pour mélanger les lignes
      sélectionnées et détruire ces corrélations.
    </para>
   </note>

   <para>
    Les fonctions de hachage <literal>hash</literal>,
    <literal>hash_murmur2</literal> et <literal>hash_fnv1a</literal> acceptent
    une valeur d'entrée et une graine optionnelle. Si la graine n'est pas
    fournie, la valeur de <literal>:default_seed</literal> est utilisée,
    initialisée de façon aléatoire si elle n'est pas définie par l'option de
    ligne de commande <literal>-D</literal>..
   </para>

   <para>
     <literal>permute</literal> accepte en entrée une valeur, une taille,
     et une graine optionnelle. Elle génère une permutation
     pseudo-aléatoire des entiers dans la tranche <literal>[0, taille)</literal>,
     et retourne l'index de la valeur d'entrée dans les valeurs permutées.
     La permutation choisie est paramétrée par la graine, soit par défaut
     <literal>:default_seed</literal> si elle n'est pas fournie.
     Au contraire des fonctions de hachage, <literal>permute</literal>
     garantit qu'il n'y aura ni collision ni trou dans les valeurs retournées.
     Les valeurs d'entrée hors de l'intervalle sont interprétées modulo
     la taille. La fonction lève une erreur si la taille n'est pas positive.
     <function>permute</function> peut être utilisée pour disperser
     la distribution de fonctions aléatoires non uniformes comme
     <literal>random_zipfian</literal> ou <literal>random_exponential</literal>,
     afin que les valeurs les plus couramment tirées ne soient pas corrélées
     de manière triviale. Par exemple, le script <application>pgbench</application>
     suivant simule une charge réaliste typique des médias sociaux et
     des plateformes de blogs, où quelques comptes génèrent une charge
     excessive&nbsp;:
    <programlisting>
\set size 1000000
\set r random_zipfian(1, :size, 1.07)
\set k 1 + permute(:r, :size)
    </programlisting>

    Dans certains cas, plusieurs distributions distinctes non corrélées
    entre elles sont nécessaires, et c'est là que le paramètre
    graine optionnel est pratique&nbsp;:

    <programlisting>
\set k1 1 + permute(:r, :size, :default_seed + 123)
\set k2 1 + permute(:r, :size, :default_seed + 321)
    </programlisting>

    Un comportement similaire peut être approché avec <function>hash</function>&nbsp;:

<programlisting>
\set size 1000000
\set r random_zipfian(1, 100 * :size, 1.07)
\set k 1 + abs(hash(:r)) % :size
</programlisting>

    Cependant, comme <function>hash</function> génère des collisions,
    certaines valeurs ne sont pas atteignables, et d'autres seront plus fréquentes
    qu'attendues par rapport à la distribution originale.
   </para>

   <para>
    À titre d'exemple, la définition complète de la transaction style TPC-B
    intégrée est&nbsp;:

    <programlisting>
   \set aid random(1, 100000 * :scale)
   \set bid random(1, 1 * :scale)
   \set tid random(1, 10 * :scale)
   \set delta random(-5000, 5000)
   BEGIN;
   UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
   SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
   UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
   UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
   INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
   END;
    </programlisting>
    Ce script autorise chaque itération de la transaction à référencer
    des lignes différentes, sélectionnées aléatoirement.
    (Cet exemple montre aussi pourquoi il est important que chaque session
    cliente ait ses propres variables &mdash; sinon elles n'affecteront
    pas les différentes lignes de façon indépendante.
   </para>

  </refsect2>

  <refsect2>
   <title>Journaux par transaction</title>

   <para>
    Avec l'option <option>-l</option> (mais sans l'option
    <option>--aggregate-interval</option>),
    <application>pgbench</application> va écrire des informations sur
    chaque transaction dans un fichier journal. Il sera nommé
    <filename><replaceable>prefix</replaceable>.<replaceable>nnn</replaceable></filename>,
    où <replaceable>prefix</replaceable> vaut par défaut
    <literal>pgbench_log</literal>, et <replaceable>nnn</replaceable> est le PID
    du processus <application>pgbench</application>.
    Le préfixe peut être changé avec l'option <option>--log-prefix</option>.
    Si l'option <option>-j</option> est positionnée à 2 ou plus,
    créant plusieurs processus de travail (<foreignphrase>worker</foreignphrase>),
    chacun aura son propre fichier journal.
    Le premier worker utilisera le même nom pour son fichier journal
    que dans le cas d'un seul processus.
    Les fichiers journaux supplémentaires s'appelleront
    <filename><replaceable>prefix</replaceable>.<replaceable>nnn</replaceable>.<replaceable>mmm</replaceable></filename>,
    où <replaceable>mmm</replaceable> est un numéro de séquence,
    identifiant chaque worker, commençant à 1.
   </para>

   <para>
    Dans un fichier journal, chaque ligne décrit une transaction.
    Elle contient les champs suivants, séparés par des espaces&nbsp;:

    <variablelist>
     <varlistentry>
      <term><replaceable>client_id</replaceable></term>
      <listitem>
       <para>
        identifie la session client qui a exécuté la transaction
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>transaction_no</replaceable></term>
      <listitem>
       <para>
        décompte les transactions exécutées par cette session
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>time</replaceable></term>
      <listitem>
       <para>
        temps déroulé pour la transaction, en microsecondes
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>script_no</replaceable></term>
      <listitem>
       <para>
        identifie le fichier script utilisé par la transaction
        (utile quand plusieurs scripts ont été fournis
        avec <option>-f</option> ou <option>-b</option>)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>time_epoch</replaceable></term>
      <listitem>
       <para>
        horodatage de la fin de la transaction (époque Unix)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>time_us</replaceable></term>
      <listitem>
       <para>
        fraction de seconde de la durée de la transaction,
        en microsecondes
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>schedule_lag</replaceable></term>
      <listitem>
       <para>
        délai au démarrage de de la transaction, c'est-à-dire la différence
        entre le moment prévu du démarrage et le moment où elle a
        réellement démarré, en microsecondes
        (n'est présent que si <option>--rate</option> est précisé)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>retries</replaceable></term>
      <listitem>
       <para>
        nombre des nouvelles tentatives après des erreurs de sérialisation
        et des deadlocks pendant la transaction
         (n'est présent que si <option>--max-tries</option> n'est pas à 1)
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Quand les options <option>--rate</option> et <option>--latency-limit</option>
    sont utilisées en même temps, le champ <replaceable>time</replaceable> pour
    une transaction ignorée sera rapporté en tant que <literal>skipped</literal>.
    Si la transaction se termine par une erreur, son
    <replaceable>time</replaceable> sera rapporté comme
    <literal>failed</literal>.
    Avec l'option <option>--failures-detailed</option>, le
    <replaceable>time</replaceable> de la transaction échouée
    sera attribué à la <literal>serialization</literal> ou à un
    <literal>deadlock</literal> en fonction du type d'erreur (voir
    <xref linkend="failures-and-retries"/> pour plus d'information).
   </para>

   <para>
    Ci-dessous un extrait du fichier journal généré avec un seul client&nbsp;:
    <screen>
0 199 2241 0 1175850568 995598
0 200 2465 0 1175850568 998079
0 201 2513 0 1175850569 608
0 202 2038 0 1175850569 2663
    </screen>

    Autre exemple avec les options <literal>--rate=100</literal> et
    <literal>--latency-limit=5</literal> (notez
    la colonne supplémentaire <replaceable>schedule_lag</replaceable>)&nbsp;:
    <screen>
0 81 4621 0 1412881037 912698 3005
0 82 6173 0 1412881037 914578 4304
0 83 skipped 0 1412881037 914578 5217
0 83 skipped 0 1412881037 914578 5099
0 83 4722 0 1412881037 916203 3108
0 84 4142 0 1412881037 918023 2333
0 85 2465 0 1412881037 919759 740
    </screen>
    Dans cet exemple, la transaction 82 a été en retard, elle affiche une
    latence (6,173&nbsp;ms) supérieure à la limite de 5&nbsp;ms.
    Les deux transactions suivantes ont été ignorées, car elles avaient
    déjà en retard avant même d'avoir commencé.
   </para>

   <para>
    L'exemple suivant montre un extrait d'un journal avec des erreurs
    et de nouvelles tentatives, avec un nombre maximum d'essais à 10
    (notez la colonne supplémentaire <replaceable>retries</replaceable>&nbsp;:
 <screen>
 3 0 47423 0 1499414498 34501 3
 3 1 8333 0 1499414498 42848 0
 3 2 8358 0 1499414498 51219 0
 4 0 72345 0 1499414498 59433 6
 1 3 41718 0 1499414498 67879 4
 1 4 8416 0 1499414498 76311 0
 3 3 33235 0 1499414498 84469 3
 0 0 failed 0 1499414498 84905 9
 2 0 failed 0 1499414498 86248 9
 3 4 8307 0 1499414498 92788 0
 </screen>
   </para>

   <para>
    Avec l'option <option>--failures-detailed</option>, le type d'erreur
    est rapporté dans le <replaceable>time</replaceable> ainsi&nbsp;:
 <screen>
 3 0 47423 0 1499414498 34501 3
 3 1 8333 0 1499414498 42848 0
 3 2 8358 0 1499414498 51219 0
 4 0 72345 0 1499414498 59433 6
 1 3 41718 0 1499414498 67879 4
 1 4 8416 0 1499414498 76311 0
 3 3 33235 0 1499414498 84469 3
 0 0 serialization 0 1499414498 84905 9
 2 0 serialization 0 1499414498 86248 9
 3 4 8307 0 1499414498 92788 0
 </screen>
   </para>

   <para>
    Dans le cas d'un test long sur du matériel qui peut
    supporter un grand nombre de transactions, les journaux
    peuvent devenir très volumineux.
    L'option <option>--sampling-rate</option> peut être utilisée pour
    journaliser seulement un extrait aléatoire des transactions
    effectuées.
   </para>
  </refsect2>

  <refsect2>
   <title>Agrégation de la journalisation</title>

   <para>
    Avec l'option <option>--aggregate-interval</option>, les fichiers
    journaux utilisent un format quelque peu différent.
    Chaque ligne décrit un intervalle d'agrégation.
    Elle contient les champs suivants séparés par des espaces&nbsp;:

    <variablelist>
     <varlistentry>
      <term><replaceable>interval_start</replaceable></term>
      <listitem>
       <para>
        horodatage du démarrage de l'intervalle (époque Unix)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>num_transactions</replaceable></term>
      <listitem>
       <para>
        nombre de transactions au sein de l'intervalle
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>sum_latency</replaceable></term>
      <listitem>
       <para>
        somme des latences de transaction
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>sum_latency_2</replaceable></term>
      <listitem>
       <para>
        somme des carrés des latences de transaction
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>min_latency</replaceable></term>
      <listitem>
       <para>
        minimum des latences de transaction
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>max_latency</replaceable></term>
      <listitem>
       <para>
        maximum des latences de transaction
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>sum_lag</replaceable></term>
      <listitem>
       <para>
        somme des délais de démarrage des transactions
        (zéro, à moins que <option>--rate</option> soit renseigné)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>sum_lag_2</replaceable></term>
      <listitem>
       <para>
        somme des carrés des délais de démarrage des transactions
        (zéro, à moins que <option>--rate</option> soit renseigné)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>min_lag</replaceable></term>
      <listitem>
       <para>
        minimum des délais de démarrage des transactions
        (zéro, à moins que <option>--rate</option> soit renseigné)
        </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>max_lag</replaceable></term>
      <listitem>
       <para>
        maximum des délais de démarrage des transactions
        (zéro, à moins que <option>--rate</option> soit renseigné)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>skipped</replaceable></term>
      <listitem>
       <para>
        nombre de transactions passées car elles auraient démarré trop tard
        (zéro, à moins que <option>--rate</option> et
        <option>--latency-limit</option> soient renseignés)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>retried</replaceable></term>
      <listitem>
       <para>
        nombre de transactions retentées
        (zéro, à moins que <option>--max-tries</option> soit différent de 1)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>retries</replaceable></term>
      <listitem>
       <para>
        nombre de transactions retentées après des erreurs de
        sérialisation ou des deadlocks
        (zéro, à moins que <option>--max-tries</option> soit différent de 1)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>serialization_failures</replaceable></term>
      <listitem>
       <para>
        nombre de transactions ayant obtenu une erreur de sérialisation
        et non retentées ensuite
        (zéro, à moins que <option>--failures-detailed</option> soit précisé)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>deadlock_failures</replaceable></term>
      <listitem>
       <para>
        nombre de transactions ayant obtenu une erreur à cause d'un deadlock
        et non retentées ensuite
        (zéro, à moins que <option>--failures-detailed</option> soit précisé)
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Voici un exemple de sortie générée avec ces options&nbsp;:
    <screen>
<userinput>pgbench --aggregate-interval=10 --time=20 --client=10 --log --rate=1000 --latency-limit=10 --failures-detailed --max-tries=10 test</userinput>

1650260552 5178 26171317 177284491527 1136 44462 2647617 7321113867 0 9866 64 7564 28340 4148 0
1650260562 4808 25573984 220121792172 1171 62083 3037380 9666800914 0 9998 598 7392 26621 4527 0
</screen>
  </para>

   <para>
    Notez que si le journal proprement dit (non agrégé) montre le script
    utilisé pour chaque transaction, le format agrégé ne l'affiche pas.
    De ce fait, si vous avez besoin des valeurs pour chaque script,
    vous devrez agréger ces données vous-même.
   </para>

  </refsect2>

  <refsect2>
   <title>Rapport par requête</title>

   <para>
    Avec l'option <option>-r</option>, <application>pgbench</application>
    collecte les statistiques suivantes pour chaque requête&nbsp;:
    <itemizedlist>
      <listitem>
        <para>
          <literal>latency</literal> &mdash; partie du temps de transaction
          pour chaque requête. <application>pgbench</application> renvoie une
          valeur moyenne de toutes les exécutions de l'ordre.
        </para>
      </listitem>
      <listitem>
        <para>
          Le nombre d'échecs de la requête. Voir
          <xref linkend="failures-and-retries"/> pour plus d'informations.
        </para>
      </listitem>
      <listitem>
        <para>
          Le nombre de nouvelles tentatives après une erreur de
          sérialisation ou un deadlock dans cette requête.
          Voir <xref linkend="failures-and-retries"/> pour plus d'informations.
        </para>
      </listitem>
    </itemizedlist>
   </para>

   <para>
    Le rapport n'affiche les statistiques des nouvelles tentatives
    que si l'option <option>--max-tries</option> ne vaut pas 1.
   </para>

   <para>
    Toutes les valeurs sont calculées pour chaque requête exécutée
    par chaque client et sont affichées après la fin du benchmark.
   </para>

   <para>
    Pour le script par défaut, le résultat aura la forme suivante&nbsp;:
    <screen>
starting vacuum...end.
transaction type: &lt;builtin: TPC-B (sort of)&gt;
 scaling factor: 1
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
maximum number of tries: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
number of failed transactions: 0 (0.000%)
number of transactions above the 50.0 ms latency limit: 1311/10000 (13.110 %)
latency average = 28.488 ms
latency stddev = 21.009 ms
initial connection time = 69.068 ms
tps = 346.224794 (without initial connection time)
statement latencies in milliseconds and failures:
   0.012  0  \set aid random(1, 100000 * :scale)
   0.002  0  \set bid random(1, 1 * :scale)
   0.002  0  \set tid random(1, 10 * :scale)
   0.002  0  \set delta random(-5000, 5000)
   0.319  0  BEGIN;
   0.834  0  UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
   0.641  0  SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
  11.126  0  UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
  12.961  0  UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
   0.634  0  INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
   1.957  0  END;
    </screen>

   Autre exemple de sortie pour le script par défaut, en utilisant
   le mode de transaction sérialisable (<command>PGOPTIONS='-c
   default_transaction_isolation=serializable' pgbench ...</command>)&nbsp;:
<screen>
starting vacuum...end.
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
maximum number of tries: 10
number of transactions per client: 1000
number of transactions actually processed: 6317/10000
number of failed transactions: 3683 (36.830%)
number of transactions retried: 7667 (76.670%)
total number of retries: 45339
number of transactions above the 50.0 ms latency limit: 106/6317 (1.678 %)
latency average = 17.016 ms
latency stddev = 13.283 ms
initial connection time = 45.017 ms
tps = 186.792667 (without initial connection time)
statement latencies in milliseconds, failures and retries:
  0.006     0      0  \set aid random(1, 100000 * :scale)
  0.001     0      0  \set bid random(1, 1 * :scale)
  0.001     0      0  \set tid random(1, 10 * :scale)
  0.001     0      0  \set delta random(-5000, 5000)
  0.385     0      0  BEGIN;
  0.773     0      1  UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
  0.624     0      0  SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
  1.098   320   3762  UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
  0.582  3363  41576  UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
  0.465     0      0  INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
  1.933     0      0  END;
</screen></para>

   <para>
    Toutes les statistiques sont rapportées séparément si plusieurs scripts
    sont spécifiés.
   </para>

   <para>
    Notez que la collecte des informations de chronométrage supplémentaires
    nécessaires pour calculer la latence par requête ajoute une certaine charge.
    Cela va réduire la vitesse moyenne calculée pour l'exécution
    des transactions et réduire le débit de transactions calculé.
    Le ralentissement varie de manière significative selon la
    plateforme et le matériel.
    Comparer la moyenne des valeurs de TPS avec et sans intégration
    de la latence est une bonne manière de voir
    si la surcharge induite par le chronométrage est importante ou pas.
   </para>
  </refsect2>

  <refsect2 id="failures-and-retries" xreflabel="Failures and Serialization/Deadlock Retries">
   <title>Nouvelles tentatives suite à des erreurs de sérialisation ou des deadlocks</title>

   <para>
    À l'exécution de <application>pgbench</application>, il y a trois
    principaux types d'erreurs, qui comprennent&nbsp;:
    <itemizedlist>
      <listitem>
        <para>
          Les erreurs du programme principal. Ce sont les plus sérieuses,
          et elles entraînent toujours une sortie immédiate de pgbench avec le
          message d'erreur correspondant. Elles incluent&nbsp;:
          <itemizedlist>
            <listitem>
              <para>
                les erreurs au lancement de <application>pgbench</application>
                (par exemple une valeur d'option invalide)&nbsp;;
              </para>
            </listitem>
            <listitem>
              <para>
                les erreurs dans la phase d'initialisation
                (par exemple quand échoue la requête de création des tables pour les scripts inclus)
              </para>
            </listitem>
            <listitem>
              <para>
                les erreurs avant le démarrage des threads (par exemple
                l'impossibilité à se connecter au serveur de bases de données,
                une erreur de syntaxe dans la métacommande, une erreur à la
                création du thread)&nbsp;;
              </para>
            </listitem>
            <listitem>
              <para>
                les erreurs internes de <application>pgbench</application>
                (supposées ne jamais se produire...).
              </para>
            </listitem>
          </itemizedlist></para>
      </listitem>
      <listitem>
        <para>
          Les erreurs quand le thread gère ses clients (par exemple
          si le client ne peut démarrer une connexion au serveur /
          si la socket pour connecter le client au serveur est devenu invalide).
          Dans ces cas, tous les clients du thread s'arrêtent pendant que
          les autres continuent de fonctionner.
        </para>
      </listitem>
      <listitem>
        <para>
          Les erreurs directes du client. Elles mènent à un arrêt immédiat de
          <application>pgbench</application>, avec le message d'erreur
          correspondant, uniquement dans le cas d'une erreur interne de
          pgbench (supposées ne jamais se produire...).
          Sinon, dans le pire des cas, ces erreurs n'entraînent que l'arrêt
          du client en échec, pendant que les autres continuent leur travail
          (mais certaines erreurs des clients sont gérées sans arrêter
          le client et sont rapportées séparément, voir plus bas).
          Dans la suite de cette section, on suppose que les erreurs
          évoquées ne sont que des erreurs du client et non des
          erreurs internes de pgbench.
        </para>
      </listitem>
    </itemizedlist>
   </para>

   <para>
    L'exécution d'un client n'est interrompue que dans le cas d'une erreur
    sérieuse&nbsp;: par exemple, la connexion au serveur a été perdue,
    ou la fin du script a été atteinte sans avoir terminé la dernière
    transaction. De plus, si l'exécution d'une commande SQL ou d'une
    métacommande échoue, le client est arrêté, sauf pour une erreur de
    sérialisation ou un deadlock.
    Dans ce dernier cas, la transaction courante est annulée, ce qui comprend
    la restauration des variables à leurs valeurs d'avant l'exécution de la
    transaction (on suppose qu'un script de transaction ne contient qu'une
    transaction&nbsp;; voir
    <xref linkend="transactions-and-scripts"/> pour plus d'informations).
    Les transactions avec des erreurs de sérialisation ou des deadlocks
    sont répétées après le rollback, jusqu'à ce qu'elles se terminent avec
    succès, ou qu'elles atteignent le nombre maximum de tentatives
    (indiqué avec <option>--max-tries</option>) / le délai maximal
    pour les tentatives (indiqué avec <option>--latency-limit</option>)
    / la fin du benchmark (indiqué avec <option>--time</option>).
    Si la dernière tentative d'exécution échoue, la transaction sera
    comptabilisée comme échouée, mais le client n'est pas arrếté et
    continue de fonctionner.
   </para>

   <note>
    <para>
     Sans définition de <option>--max-tries</option>, une transaction ne
     sera jamais retentée après une erreur de sérialisation ou un
     deadlock, car la valeur par défaut de l'option est 1.
     Pour limiter uniquement la durée totale des tentatives,
     utilisez l'option <option>--latency-limit</option>
     en indiquant un nombre illimité de tentatives
     (<literal>--max-tries=0</literal>).
     Vous pouvez aussi utiliser <option>--time</option> pour limiter la
     durée du benchmark alors que le nombre de tentatives est illimité.
    </para>
    <para>
     Faites attention lors de la répétition de scripts avec de
     multiples transactions&nbsp;: le script est toujours intégralement
     réexécuté, et les transactions réussies peuvent donc être exécutées
     plusieurs fois.
    </para>
    <para>
     Faites aussi attention lors de la répétition de scripts avec des
     commandes shell. Leur résultat n'est pas annulé, contrairement
     à ce qui passe avec des commandes SQL, à part pour une valeur assignée
     avec la commande <command>\setshell</command>.
    </para>
   </note>

   <para>
    La latence d'une transaction réussie inclut la durée entière de
    l'exécution, y compris les rollbacks et les diverses tentatives.
    La latence n'est mesurée que pour les transactions et commandes réussies,
    mais pas pour celles en échec.
   </para>

   <para>
    Le rapport principal contient le nombre de transactions échouées. Si
    <option>--max-tries</option> n'est pas égal à 1, il contiendra aussi
    des statistiques sur les tentatives&nbsp;: le nombre total de
    transactions tentées plusieurs fois, et le nombre total de
    nouvelles tentatives.
    Le rapport par script hérite de tous ces champs. Le rapport par
    requête n'affiche les statistiques sur les tentatives que si
    <option>--max-tries</option> n'est pas égal à 1.
   </para>

   <para>
    Si vous voulez regrouper les échecs par types dans les journaux
    par transaction et les journaux agrégés, utilisez l'option
    <option>--failures-detailed</option>.
    Si vous voulez aussi distinguer toutes les erreurs et les échecs
    (c'est-à-dire les erreurs sans nouvelle tentative), en incluant
    quelles limites sur les tentatives ont été dépassées, et de combien,
    pour les échecs de sérialisation ou sur deadlock,
    utilisez <option>--verbose-errors</option>.
   </para>
  </refsect2>

  <refsect2>
   <title>Bonnes pratiques</title>

   <para>
    Il est facile d'utiliser <application>pgbench</application> pour produire
    des résultats complètement dénués de sens&nbsp;!
    Voici quelques conseils pour vous aider à obtenir des résultats
    pertinents.
   </para>

   <para>
    Tout d'abord, ne croyez <emphasis>jamais</emphasis> en un test qui ne
    dure que quelques secondes.
    Utilisez l'option <option>-t</option> ou <option>-T</option>
    pour que le test dure au moins quelques minutes, de
    façon à lisser le bruit.
    Dans certains cas, il vous faudra des heures pour récupérer des
    valeurs reproductibles.
    C'est une bonne idée de lancer plusieurs fois le test pour voir si vos
    chiffres sont ou pas reproductibles.
   </para>

   <para>
    Pour le scénario de test par défaut typé TPC-B, le facteur d'échelle
    d'initialisation (<option>-s</option>) doit être au moins
    aussi grand que le nombre maximum de clients que vous avez
    l'intention de tester (<option>-c</option>)&nbsp;; sinon vous
    testez surtout la contention induite par les mises à jour.
    Il n'y a que <option>-s</option> lignes dans la table
    <structname>pgbench_branches</structname>, et chaque transaction
    veut mettre à jour l'une de ces lignes, donc si la valeur de
    <option>-c</option> est supérieure à la valeur de <option>-s</option>,
    il en résultera sûrement de nombreuses transactions bloquées
    en attente de la fin d'autres transactions.
   </para>

   <para>
    Le scénario par défaut est aussi assez sensible au temps écoulé depuis
    l'initialisation des tables : l'accumulation
    des lignes et espaces morts dans les tables change les résultats.
    Pour comprendre ces résultats, vous devez garder une trace du
    nombre total de mises à jour et du moment du vacuum.
    Si l'autovacuum est actif, il peut en
    résulter des variations imprévisibles dans les performances mesurées.
   </para>

   <para>
    Une limitation de <application>pgbench</application> est qu'il peut
    lui-même devenir le goulet d'étranglement lorsqu'on essaie de tester avec
    un grand nombre de sessions clientes.
    Cela peut être atténué en utilisant <application>pgbench</application>
    depuis une machine différente du serveur de base
    de données, bien qu'une faible latence sur le réseau soit dans ce cas
    essentielle.
    Il peut même être utile de lancer plusieurs instances parallèles de
    <application>pgbench</application>, depuis
    plusieurs machines clientes vers le même serveur de base de données.
   </para>
  </refsect2>

  <refsect2>
   <title>Securité</title>

   <para>
    Si des utilisateurs non dignes de confiance ont accès à une base de
    données qui n'a pas adopté une <link linkend="ddl-schemas-patterns">méthode
     sécurisée d'utilisation des schémas</link>, il ne faut pas exécuter
    <application>pgbench</application> dans cette base.
    <application>pgbench</application> utilise des noms non qualifiés et ne
    modifie pas le chemin de recherche.
   </para>
  </refsect2>
 </refsect1>
</refentry>
