<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<refentry id="sql-altertable">
 <indexterm zone="sql-altertable">
  <primary>ALTER TABLE</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>ALTER TABLE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Commandes du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>ALTER TABLE</refname>
  <refpurpose>Modifier la définition d'une table</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <synopsis>ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">nom</replaceable> [ * ]
    <replaceable class="parameter">action</replaceable> [, ... ]
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">nom</replaceable> [ * ]
    RENAME [ COLUMN ] <replaceable class="parameter">nom_colonne</replaceable> TO <replaceable class="parameter">nouveau_nom_colonne</replaceable>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">nom</replaceable> [ * ]
    RENAME CONSTRAINT <replaceable class="parameter">nom_contrainte</replaceable> TO <replaceable class="parameter">nouveau_nom_contrainte</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">nom</replaceable>
    RENAME TO <replaceable class="parameter">nouveau_nom</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">nom</replaceable>
    SET SCHEMA <replaceable class="parameter">nouveau_schéma</replaceable>
ALTER TABLE ALL IN TABLESPACE <replaceable class="parameter">nom</replaceable> [ OWNED BY <replaceable class="parameter">nom_rôle</replaceable> [, ... ] ]
    SET TABLESPACE <replaceable class="parameter">nouveau_tablespace</replaceable> [ NOWAIT ]
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">nom</replaceable>
    ATTACH PARTITION <replaceable class="parameter">nouveau_partition</replaceable> { FOR VALUES <replaceable class="parameter">spec_limite_partition</replaceable> | DEFAULT }
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">nom</replaceable>
    DETACH PARTITION <replaceable class="parameter">nouveau_partition</replaceable>

<phrase>où <replaceable class="parameter">action</replaceable> fait partie de&nbsp;:</phrase>

    ADD [ COLUMN ] [ IF NOT EXISTS ] <replaceable class="parameter">nom_colonne</replaceable> <replaceable class="parameter">type_donnée</replaceable> [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">contrainte_colonne</replaceable> [ ... ] ]
    DROP [ COLUMN ] [ IF EXISTS ] <replaceable class="parameter">nom_colonne</replaceable> [ RESTRICT | CASCADE ]
    ALTER [ COLUMN ] <replaceable class="parameter">nom_colonne</replaceable> [ SET DATA ] TYPE <replaceable class="parameter">type_donnée</replaceable> [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ USING <replaceable class="parameter">expression</replaceable> ]
    ALTER [ COLUMN ] <replaceable class="parameter">nom_colonne</replaceable> SET DEFAULT <replaceable class="parameter">expression</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">nom_colonne</replaceable> DROP DEFAULT
    ALTER [ COLUMN ] <replaceable class="parameter">nom_colonne</replaceable> { SET | DROP } NOT NULL
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> DROP EXPRESSION [ IF EXISTS ]
    ALTER [ COLUMN ] <replaceable class="parameter">nom_colonne</replaceable> ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>options_séquence</replaceable> ) ]
    ALTER [ COLUMN ] <replaceable class="parameter">nom_colonne</replaceable> { SET GENERATED { ALWAYS | BY DEFAULT } | SET <replaceable>option_séquence</replaceable> | RESTART [ [ WITH ] <replaceable class="parameter">valeur_redémarrage</replaceable> ] } [...]
    ALTER [ COLUMN ] <replaceable class="parameter">nom_colonne</replaceable> DROP IDENTITY [ IF EXISTS ]
    ALTER [ COLUMN ] <replaceable class="parameter">nom_colonne</replaceable> SET STATISTICS <replaceable class="parameter">integer</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">nom_colonne</replaceable> SET ( <replaceable class="parameter">option_attribut</replaceable> = <replaceable class="parameter">valeur</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="parameter">nom_colonne</replaceable> RESET ( <replaceable class="parameter">option_attribut</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="parameter">nom_colonne</replaceable> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
    ADD <replaceable class="parameter">contrainte_table</replaceable> [ NOT VALID ]
    ADD <replaceable class="parameter">contrainte_table_utilisant_index</replaceable>
    ALTER CONSTRAINT <replaceable class="parameter">nom_contrainte</replaceable> [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
    VALIDATE CONSTRAINT <replaceable class="parameter">nom_contrainte</replaceable>
    DROP CONSTRAINT [ IF EXISTS ]  <replaceable class="parameter">nom_contrainte</replaceable> [ RESTRICT | CASCADE ]
    DISABLE TRIGGER [ <replaceable class="parameter">nom_trigger</replaceable> | ALL | USER ]
    ENABLE TRIGGER [ <replaceable class="parameter">nom_trigger</replaceable> | ALL | USER ]
    ENABLE REPLICA TRIGGER <replaceable class="parameter">nom_trigger</replaceable>
    ENABLE ALWAYS TRIGGER <replaceable class="parameter">nom_trigger</replaceable>
    DISABLE RULE <replaceable class="parameter">nom_règle_réécriture</replaceable>
    ENABLE RULE <replaceable class="parameter">nom_règle_réécriture</replaceable>
    ENABLE REPLICA RULE <replaceable class="parameter">nom_règle_réécriture</replaceable>
    ENABLE ALWAYS RULE <replaceable class="parameter">nom_règle_réécriture</replaceable>
    DISABLE ROW LEVEL SECURITY
    ENABLE ROW LEVEL SECURITY
    FORCE ROW LEVEL SECURITY
    NO FORCE ROW LEVEL SECURITY
    CLUSTER ON <replaceable class="parameter">nom_index</replaceable>
    SET WITHOUT CLUSTER
    SET WITHOUT OIDS
    SET TABLESPACE <replaceable class="parameter">nouveau_tablespace</replaceable>
    SET { LOGGED | UNLOGGED }
    SET ( <replaceable class="parameter">paramètre_stockage</replaceable> [= <replaceable class="parameter">valeur</replaceable>] [, ... ] )
    RESET ( <replaceable class="parameter">paramètre_stockage</replaceable> [, ... ] )
    INHERIT <replaceable class="parameter">table_parent</replaceable>
    NO INHERIT <replaceable class="parameter">table_parent</replaceable>
    OF <replaceable class="parameter">nom_type</replaceable>
    NOT OF
    OWNER TO { <replaceable class="parameter">nouveau_propriétaire</replaceable> | CURRENT_USER | SESSION_USER }
    REPLICA IDENTITY { DEFAULT | USING INDEX <replaceable class="parameter">nom_index</replaceable> | FULL | NOTHING }

<phrase>et <replaceable class="parameter">spec_limite_partition</replaceable> vaut&nbsp;:</phrase>

IN ( <replaceable class="parameter">expr_limite_partition</replaceable> [, ...] ) |
FROM ( { <replaceable class="parameter">expr_limite_partition</replaceable> | MINVALUE | MAXVALUE } [, ...] )
  TO ( { <replaceable class="parameter">expr_limite_partition</replaceable> | MINVALUE | MAXVALUE } [, ...] ) |
WITH ( MODULUS <replaceable class="parameter">litéral_numérique</replaceable>, REMAINDER <replaceable class="parameter">litéral_numérique</replaceable> )

<phrase>et <replaceable class="parameter">contrainte_colonne</replaceable> vaut&nbsp;:</phrase>

[ CONSTRAINT <replaceable class="parameter">nom_contrainte</replaceable> ]
{ NOT NULL |
  NULL |
  CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  DEFAULT <replaceable>expression_par_défaut</replaceable> |
  GENERATED ALWAYS AS ( <replaceable>generation_expr</replaceable> ) STORED |
  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>options_séquence</replaceable> ) ] |
  UNIQUE <replaceable class="parameter">paramètres_index</replaceable> |
  PRIMARY KEY <replaceable class="parameter">paramètres_index</replaceable> |
  REFERENCES <replaceable class="parameter">table_référencée</replaceable> [ ( <replaceable class="parameter">colonne_référencée</replaceable> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <replaceable class="parameter">action_referentielle</replaceable> ] [ ON UPDATE <replaceable class="parameter">action_referentielle</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>et <replaceable class="parameter">contrainte_table</replaceable> vaut&nbsp;:</phrase>

[ CONSTRAINT <replaceable class="parameter">nom_contrainte</replaceable> ]
{ CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  UNIQUE ( <replaceable class="parameter">nom_colonne</replaceable> [, ... ] ) <replaceable class="parameter">paramètres_index</replaceable> |
  PRIMARY KEY ( <replaceable class="parameter">nom_colonne</replaceable> [, ... ] ) <replaceable class="parameter">paramètres_index</replaceable> |
  EXCLUDE [ USING <replaceable class="parameter">méthode_index</replaceable> ] ( <replaceable class="parameter">élément_exclus</replaceable> WITH <replaceable class="parameter">opérateur</replaceable> [, ... ] ) <replaceable class="parameter">paramètres_index</replaceable> [ WHERE ( <replaceable class="parameter">prédicat</replaceable> ) ] |
  FOREIGN KEY ( <replaceable class="parameter">nom_colonne</replaceable> [, ... ] ) REFERENCES <replaceable class="parameter">table_référencée</replaceable> [ ( <replaceable class="parameter">colonne_référencée</replaceable> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <replaceable class="parameter">action_referentielle</replaceable> ] [ ON UPDATE <replaceable class="parameter">action_referentielle</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>et <replaceable class="parameter">contrainte_table_utilisant_index</replaceable> vaut&nbsp;:</phrase>

    [ CONSTRAINT <replaceable class="parameter">nom_contrainte</replaceable> ]
    { UNIQUE | PRIMARY KEY } USING INDEX <replaceable class="parameter">nom_index</replaceable>
    [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase><replaceable class="parameter">paramètres_index</replaceable> dans les contraintes <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal> et <literal>EXCLUDE</literal> valent&nbsp;:</phrase>

[ INCLUDE ( <replaceable class="parameter">nom_colonne</replaceable> [, ... ] ) ]
[ WITH ( <replaceable class="parameter">paramètre_stockage</replaceable> [= <replaceable class="parameter">valeur</replaceable>] [, ... ] ) ]
[ USING INDEX TABLESPACE <replaceable class="parameter">nom_tablespace</replaceable> ]

<phrase><replaceable class="parameter">élément_exclus</replaceable> dans une contrainte <literal>EXCLUDE</literal> vaut&nbsp;:</phrase>

{ <replaceable class="parameter">nom_colonne</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">opclass</replaceable> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]
  </synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>ALTER TABLE</command> modifie la définition d'une table existante.
   Il existe plusieurs variantes décrites après.  Il est à noter que le niveau
   de verrouillage requis peut changer pour chaque variante. Un verrou
   <literal>ACCESS EXCLUSIVE</literal> est utilisé à moins que le verrou ne soit
   explicitement noté.  Quand de multiples sous-commandes sont listées, le
   verrou utilisé sera celui le plus strict requis pour l'ensemble des
   sous-commandes.

   <variablelist>
    <varlistentry>
     <term><literal>ADD COLUMN [ IF NOT EXISTS ]</literal></term>
     <listitem>
      <para>
       Ajoute une nouvelle colonne à la table en utilisant une syntaxe identique
       à celle de <xref linkend="sql-createtable"/>. Si <literal>IF NOT
       EXISTS</literal> est précisée et qu'une colonne existe déjà avec ce nom,
       aucune erreur n'est renvoyée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>DROP COLUMN [ IF EXISTS ]</literal></term>
     <listitem>
      <para>
       Supprime une colonne de la table. Les index et les
       contraintes de table référençant cette colonne sont automatiquement supprimés.
       Les statistiques multivarées référençant les colonnes supprimées seront
       également supprimées si la suppressino de la colonne avait pour effet de
       réduire le nombre de colonne dans la statistique à 1.
       L'option <literal>CASCADE</literal> doit être utilisée lorsque des objets en dehors
       de la table dépendent de cette colonne, comme par exemple des références
       de clés étrangères ou des vues.
       Si <literal>IF EXISTS</literal> est indiqué et que la colonne n'existe
       pas, aucune erreur n'est renvoyée. Dans ce cas, un message d'avertissement
       est envoyé à la place.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>SET DATA TYPE</literal></term>
     <listitem>
      <para>
       Change le type d'une colonne de la table. Les index et
       les contraintes simples de table qui impliquent la colonne sont
       automatiquement convertis pour utiliser le nouveau type de la colonne en
       ré-analysant l'expression d'origine. La clause optionnelle <literal>COLLATE</literal>
       spécifie une collation pour la nouvelle colonne. Si elle est omise, la collation utilisée est la collation par défaut pour le nouveau type de la colonne. La clause
       optionnelle <literal>USING</literal> précise comment calculer la nouvelle
       valeur de la colonne à partir de l'ancienne&nbsp;; en cas d'omission, la
       conversion par défaut est identique à une affectation de transtypage de l'ancien type
       vers le nouveau. Une clause <literal>USING</literal> doit être fournie
       s'il n'existe pas de conversion implicite ou d'assignement entre les deux types.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>SET</literal>/<literal>DROP DEFAULT</literal></term>
     <listitem>
      <para>
       Ajoute ou supprime les valeurs par défaut d'une colonne (où la
	   suppression est équivalente à ajouter une valeur par défaut à NULL).
	   La nouvelle valeur par défaut s'appliquera uniquement aux prochaines
	   requêtes <command>INSERT</command> ou <command>UPDATE</command>. Cela
	   ne concerne donc pas les lignes déjà présentes dans la table.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>SET</literal>/<literal>DROP NOT NULL</literal></term>
     <listitem>
      <para>
       Modifie l'autorisation de valeurs NULL. 
     </para>

     <para>
      <literal>SET NOT NULL</literal> ne peut être utilisé que sur une colonne
      ne comportant aucune valeur <literal>NULL</literal>. Normalement, cela entraîne une
      vérification par un parcours complet de la table&nbsp;; cependant, si une contrainte
      <literal>CHECK</literal> valide est trouvée prouvant l'impossibilité d'avoir
      de donnée <literal>NULL</literal> dans cette colonne, alors le parcours
      de table n'est pas effectué.
     </para>

     <para>
      Si cette table est une partition, il n'est pas possible d'effectuer de
      <literal>DROP NOT NULL</literal> sur une colonne qui est marquée
      <literal>NOT NULL</literal> dans la table parente.  Pour supprimer la
      contrainte <literal>NOT NULL</literal> de toutes les partitions,
      effectuez un <literal>DROP NOT NULL</literal> sur la table parente.  Même
      s'il n'y a pas de contrainte <literal>NOT NULL</literal> sur la table
      parente, une telle contrainte peut quand même être ajoutée à des
      partitions individuelles, si l'on veut; ainsi, les enfants peuvent
      refuser les valeurs nulles même si le parent les autorise, mais l'inverse
      n'est pas possible.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP EXPRESSION [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
      Transforme une colonne générée stockée en une colonne de base. Les données
	  existantes dans la colonne sont conservées mais les modifications futures
	  n'appliqueront plus l'expression de génération.
     </para>

     <para>
      Si <literal>DROP EXPRESSION IF EXISTS</literal> est spécifié et que la
	  colonne n'est pas une colonne générée stockée, aucune erreur ne sera
	  remontée. Dans ce cas, un message de notification sera émis à la place.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY</literal></term>
    <term><literal>SET GENERATED { ALWAYS | BY DEFAULT }</literal></term>
    <term><literal>DROP IDENTITY [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
      Modifier une colonne en colonne d'identité ou changer les attributs de
      génération d'ue colonne d'identité existante.  Voir <xref
      linkend="sql-createtable"/> pour plus de détails.
      Comme pour le <literal>SET DEFAULT</literal>, cette modification
	  s'appliquera uniquement aux prochaines requêtes <command>INSERT</command>
      et <command>UPDATE</command>. Cela ne concerne donc pas les lignes déjà
	  présentes dans la table.
     </para>

     <para>
      Si <literal>DROP IDENTITY IF EXISTS</literal> est spécifié et que la
      colonne n'est pas une colonne d'identité, aucune erreur n'est remontée.
      Dans ce cas une note est affichée à la place.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET <replaceable>option_sequence</replaceable></literal></term>
    <term><literal>valeur_redémarrage</literal></term>
    <listitem>
     <para>
      Modifie la séquence associée à une colonne d'identité existante.
      <replaceable>option_sequence</replaceable> est une options supportée par
      <xref linkend="sql-altersequence"/> tout comme <literal>INCREMENT
          BY</literal>.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>SET STATISTICS</literal></term>
     <listitem>
      <para>
       Permet de modifier l'objectif de collecte de statistiques
       par colonne pour les opérations d'analyse
       (<xref linkend="sql-analyze"/>) ultérieures.
       L'objectif prend une valeur entre 0 et 10000. il est positionné à -1 pour utiliser
       l'objectif de statistiques par défaut du système
       (<xref linkend="guc-default-statistics-target"/>). Pour plus d'informations sur
       l'utilisation des statistiques par le planificateur de requêtes de
       <productname>PostgreSQL</productname>, voir <xref linkend="planner-stats"/>.
      </para>
      <para>
       <literal>SET STATISTICS</literal> acquiert un verrou <literal>SHARE UPDATE EXCLUSIVE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>SET ( <replaceable class="parameter">option_attribut</replaceable> = <replaceable class="parameter">valeur</replaceable> [, ... ] )</literal></term>
     <term><literal>RESET ( <replaceable class="parameter">option_attribut</replaceable> [, ... ] )</literal></term>
     <listitem>
      <para>
       Cette syntaxe permet de configurer ou de réinitialiser des propriétés.
       Actuellement, les seules propriétés acceptées sont
       <literal>n_distinct</literal> et <literal>n_distinct_inherited</literal>,
       qui surchargent l'estimation du nombre de valeurs distinctes calculée par
       <xref linkend="sql-analyze"/>
       <literal>n_distinct</literal> affecte les statistiques de la table
       elle-même alors que <literal>n_distinct_inherited</literal> affecte les
       statistiques récupérées pour la table et les tables en héritant. Si
       configuré à une valeur positive, <command>ANALYZE</command> supposera
       que la colonne contient exactement le nombre spécifié de valeurs
       distinctes non NULL. Si configuré à une valeur négative qui doit être
       supérieur ou égale à -1, <command>ANALYZE</command> supposera que le
       nombre de valeurs distinctes non NULL dans la colonne est linéaire par
       rapport à la taille de la table&nbsp;; le nombre total est à calculer
       en multipliant la taille estimée de la table par la valeur absolue de
       ce nombre. Par exemple, une valeur de -1 implique que toutes les valeurs
       dans la colonne sont distinctes alors qu'une valeur de -0,5 implique
       que chaque valeur apparaît deux fois en moyenne. Ceci peut être utile
       quand la taille de la table change dans le temps, car la multiplication
       par le nombre de lignes dans la table n'est pas réalisée avant la
       planification. Spécifiez une valeur de 0 pour retourner aux estimations
       standards du nombre de valeurs distinctes. Pour plus d'informations sur
       l'utilisation des statistiques par le planificateur de requêtes
       <productname>PostgreSQL</productname>, référez vous à <xref
       linkend="planner-stats"/>.
      </para>
      <para>
       Changer les options d'une propriété nécessite un verrou
       <literal>SHARE UPDATE EXCLUSIVE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>SET STORAGE</literal></term>
     <term>
      <literal>SET STORAGE</literal>
      <indexterm>
       <primary>TOAST</primary>
       <secondary>réglages de stockage par colonne</secondary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Modifie le mode de stockage pour une colonne. Cela permet de contrôler si
       cette colonne est conservée en ligne ou dans une deuxième table, appelée
       table TOAST, et si les données sont ou non compressées.
       <literal>PLAIN</literal>, en ligne, non compressé, est utilisé pour les
       valeurs de longueur fixe, comme les <type>integer</type>.
       <literal>MAIN</literal> convient pour les données en ligne, compressibles.
       <literal>EXTERNAL</literal> est fait pour les données externes non
       compressées, <literal>EXTENDED</literal> pour les données externes
       compressées. <literal>EXTENDED</literal> est la valeur par défaut pour la
       plupart des types qui supportent les stockages différents de
       <literal>PLAIN</literal>. L'utilisation d'<literal>EXTERNAL</literal>
       permet d'accélérer les opérations d'extraction de sous-chaînes sur les
       très grosses valeurs de types <type>text</type> et <type>bytea</type> mais
       utilise plus d'espace de stockage. <literal>SET STORAGE</literal> ne
       modifie rien dans la table, il configure la stratégie à poursuivre lors
       des mises à jour de tables suivantes. Voir <xref linkend="storage-toast"/>
       pour plus d'informations.
      </para>

      <para>
       Bien que la plupart des formes de <literal>ADD <replaceable
       class="parameter">contrainte_table</replaceable></literal> nécessite un
       verrou <literal>ACCESS EXCLUSIVE</literal>, <literal>ADD FOREIGN
       KEY</literal> nécessite seulement un verrou <literal>SHARE ROW
       EXCLUSIVE</literal>. Notez que <literal>ADD FOREIGN KEY</literal>
       nécessite aussi un verrou <literal>SHARE ROW EXCLUSIVE</literal> sur la
       table référencée, en plus du verrou sur la table où la contrainte est
       déclarée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ADD <replaceable class="parameter">contrainte_table</replaceable>
       [ NOT VALID ]</literal></term>
     <listitem>
      <para>
       Ajoute une nouvelle contrainte à une table en utilisant une
       syntaxe identique à <xref linkend="sql-createtable"/>, plus
       l'option <literal>NOT VALID</literal>, qui est actuellement
       seulement autorisée pour les contraintes de type clé étrangère et les
       contraintes CHECK.
      </para>

      <para>
       Normalement, cette clause entraîne un parcours complet de la table pour vérifier
       que les lignes pré-existantes satisfont la nouvelle contrainte. Mais si
       l'option <literal>NOT VALID</literal> est utilisée, cette opération
       potentiellement longue n'est pas effectuée. Cette contrainte sera néanmoins
       toujours vérifiée pour les nouvelles insertions ou modifications de données
       (c'est-à-dire que ces ordres échoueront s'il n'y a pas de ligne
       correspondante dans la table de référence pour une clé étrangère ou si la
       nouvelle ligne ne satisfait pas la condition d'une contrainte check).
       La base de données ne considèrera pas la contrainte comme entièrement
       vérifiée pour toutes les lignes tant qu'une validation effectuée par
       l'ordre <literal>VALIDATE CONSTRAINT</literal> n'aura pas été effectuée.
       Voir <xref linkend="sql-altertable-notes"/> ci-dessous pour plus d'informations
       sur l'utilisation de l'option <literal>NOT VALID</literal>.
      </para>

      <para>
       L'ajout d'une contrainte de clé étrangère requiert un verrou
       <literal>SHARE ROW EXCLUSIVE</literal> sur la table référencée,
       en plus du verrou sur la table bénéficiant de la nouvelle contrainte.
      </para>

      <para>
       Des restrictions supplémentaires s'appliquent quand des contraintes
       uniques ou des clés primaires sont ajoutées à des tables partitionnées.
       Voir <xref linkend="sql-createtable" />.
       De plus, les contraintes de clés étrangères sur les tables partitionnées
       ne peuvent bénéficier de l'option <literal>NOT VALID</literal>, pour
       l'instant.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ADD <replaceable class="parameter">contrainte_table_utilisant_index</replaceable></literal></term>
     <listitem>
      <para>
       Cette forme ajoute une nouvelle contrainte <literal>PRIMARY KEY</literal> ou <literal>UNIQUE</literal> sur une table,
       basée sur un index unique existant auparavant. Toutes
       les colonnes de l'index sont incluses dans la contrainte.
      </para>
      <para>
       Cet index ne peut pas être un index partiel, ni être sur des expressions de colonnes.
       De plus, il doit être un index b-tree avec un ordre de tri par défaut.
       Ces restrictions assurent que cet index soit équivalent à un index qui aurait été
       créé par une commande standard <literal>ADD PRIMARY KEY</literal> ou <literal>ADD UNIQUE</literal>.
      </para>

      <para>
       Si vous précisez <literal>PRIMARY KEY</literal>, et que les colonnes de l'index
       ne sont pas déjà spécifiées comme <literal>NOT NULL</literal>, alors la commande
       va tenter d'appliquer la commande <literal>ALTER COLUMN SET NOT NULL</literal> sur chacune
       de ces colonnes. Cela nécessite un parcours complet de la table pour vérifier que la
       ou les colonne(s) ne contiennent pas de null. Dans tous les autres cas, c'est une opération rapide.
      </para>

      <para>
       Si un nom de contrainte est fourni, alors l'index sera renommé afin
       de correspondre au nom de la contrainte. Sinon la contrainte sera nommée
       comme l'index.
      </para>

      <para>
       Une fois que la commande est exécutée, l'index est <quote>possédé</quote>
       par la contrainte, comme si l'index avait été construit par une commande
       <literal>ADD PRIMARY KEY</literal> ou <literal>ADD UNIQUE</literal> ordinaire.
       En particulier, supprimer la contrainte fait également disparaître l'index.
      </para>

      <para>
       Cette syntaxe n'est actuellement pas supportée sur les tables
       partitionnées.
      </para>

      <note>
       <para>
        Ajouter une contrainte en utilisant un index existant peut être utile
        dans les situations où il faut ajouter une nouvelle contrainte, sans bloquer
        les mises à jour de table trop longtemps. Pour faire cela, créez l'index avec
        <command>CREATE INDEX CONCURRENTLY</command>, puis installez-la en tant que contrainte
        officielle en utilisant cette syntaxe. Voir l'exemple ci-dessous.
       </para>
      </note>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ALTER CONSTRAINT</literal></term>
     <listitem>
      <para>
       Cette forme modifie les propriétés d'une contrainte précédemment créée.
       Pour le moment, seules les contraintes de clés étrangères peuvent être
       modifiées.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>VALIDATE CONSTRAINT</literal></term>
     <listitem>
      <para>
       Cette forme valide une contrainte de type clé étrangère ou une
       contrainte CHECK qui a été
       précédemment créée avec la clause <literal>NOT VALID</literal>.
       Elle le fait en parcourant la table pour s'assurer qu'il n'existe
       aucune ligne pour laquelle la contrainte n'est pas satisfaite. Si
       la contrainte est déjà marquée valide, cette clause ne fait rien.
       (Voir <xref linkend="sql-altertable-notes"/> ci-dessous pour une explication
       sur l'utilisation de cette commande.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>DROP CONSTRAINT [ IF EXISTS ]</literal></term>
     <listitem>
      <para>
       Supprime la contrainte de table précisée, ainsi que tout index sous-jacent de
       la contrainte.
       Si <literal>IF EXISTS</literal> est précisé et que la contrainte n'existe
       pas, aucune erreur n'est renvoyée. Par contre, un message d'avertissement
       est lancé.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] TRIGGER</literal></term>
     <listitem>
      <para>
       Configure l'exécution des déclencheurs définis sur la
       table. Un déclencheur désactivé est toujours connu par le système mais
       n'est plus exécuté lorsque l'événement déclencheur survient. Pour un
       déclencheur retardé, le statut d'activité est vérifié au moment où survient l'événement,
       et non quand la fonction du déclencheur est réellement exécutée.
       Il est possible de désactiver ou d'activer un déclencheur spécifique (précisé par son nom),
       tous les déclencheurs d'une table ou seulement les déclencheurs utilisateur
       de cette table (cette option exclut les déclencheurs générés en interne
       pour gérer les contraintes comme ceux utilisés pour implanter les
       contraintes de clés étrangères ou les contraintes déferrés uniques ou
       d'exclusion). Désactiver ou activer les déclencheurs implicites de
       contraintes requiert des droits de
       superutilisateur&nbsp;; cela doit se faire avec précaution car
       l'intégrité de la contrainte ne peut pas être garantie si les
       déclencheurs ne sont pas exécutés.
      </para>

      <para>
       Le mécanisme de déclenchement des triggers est aussi affecté par la
       variable de configuration <xref linkend="guc-session-replication-role"/>.
       Les triggers activés (<literal>ENABLE</literal>, par défaut) se déclencheront quand
       le rôle de réplication est <quote>origin</quote> (la valeur par défaut)
       ou <quote>local</quote>. Les triggers configurés <literal>ENABLE
        REPLICA</literal> se déclencheront seulement si la session est en mode
       <quote>replica</quote> et les triggers <literal>ENABLE ALWAYS</literal>
       se déclencheront à chaque fois, quelque soit le rôle de réplication.
      </para>

      <para>
       L'effet de ce mécanisme est que, dans la configuration par défaut, les
       triggers ne se déclenchent pas sur les replicas. Ceci est utile parce
       que si un trigger est utilisé sur l'origine pour propager des données
       entre des tables, alors le système de réplication va aussi répliquer
       les données propagées, et le trigger ne devrait pas être exécuter une
       deuxième fois sur le serveur secondaire car cela amènerait à une
       duplication. Néanmoins, si un trigger est utilisé pour une autre raison
       comme la création d'alertes externes, il pourrait être approprié de le
       configurer à <literal>ENABLE ALWAYS</literal> pour qu'il puisse être
       exécuté sur les serveurs secondaires.
      </para>

      <para>
       Cette commande acquiert un verrou <literal>SHARE ROW
       EXCLUSIVE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] RULE</literal></term>
     <listitem>
      <para>
       Ces formes configurent le déclenchement des règles de réécriture
       appartenant à la table. Une règle désactivée est toujours connue par le
       système mais non appliquée lors de la réécriture de la requête. La
       sémantique est identique celles des triggers activés/désactivés. Cette
       configuration est ignorée pour les règles <literal>ON SELECT</literal>
       qui sont toujours appliqués pour conserver le bon fonctionnement des
       vues même si la session actuelle n'est pas dans le rôle de réplication
       par défaut.
      </para>

      <para>
       Le mécanisme d'exécution d'une règle est aussi affecté par la variable
       de configuration <xref linkend="guc-session-replication-role"/>, de
       façon identique aux triggers comme décrit ci-dessus.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE ROW LEVEL SECURITY</literal></term>
    <listitem>
     <para>
      Ces clauses contrôlent l'application des politiques de sécurité de
      lignes appartenant à la table. Si activé et qu'aucune politique n'existe
      pour la table, alors une politique de refus est appliqué par défaut.
      Notez que les politiques peuvent exister pour une table même si la
      sécurité niveau ligne est désactivé. Dans ce cas, les politiques ne
      seront <emphasis>pas</emphasis> appliquées, elles seront ignorées. Voir aussi <xref
      linkend="sql-createpolicy"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NO FORCE</literal>/<literal>FORCE ROW LEVEL SECURITY</literal></term>
    <listitem>
     <para>
      Ces clauses contrôlent l'application des politiques de sécurité niveau
      ligne appartenant à la table quand l'utilisateur est le propriétaire de
      la table. Si activé, les politiques de sécurité au niveau ligne seront
      appliquées quand l'utilisateur est le propriétaire de la table. S'il est
      désactivé (ce qui est la configuration par défaut), alors la sécurité
      niveau ligne ne sera pas appliquée quand l'utilisateur est le
      propriétaire de la table. Voir aussi <xref linkend="sql-createpolicy"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
     <term><literal>CLUSTER ON</literal></term>
     <listitem>
      <para>
       Sélectionne l'index par défaut pour les prochaines
       opérations <xref linkend="sql-cluster"/>.
       La table n'est pas réorganisée.
      </para>
      <para>
       Changer les options de cluster nécessite un verrou <literal>SHARE UPDATE EXCLUSIVE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>SET WITHOUT CLUSTER</literal></term>
     <listitem>
      <para>
       Supprime de la table la spécification d'index
       <xref linkend="sql-cluster"/> la plus récemment
       utilisée. Cela agit sur les opérations de réorganisation suivantes qui ne spécifient pas d'index.
      </para>
      <para>
       Changer les options de cluster nécessite un verrou <literal>SHARE UPDATE EXCLUSIVE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>SET WITHOUT OIDS</literal></term>
     <listitem>
      <para>
       Cette syntaxe permet de supprimer les colonnes système <literal>oid</literal>.
       Comme les colonnes système <literal>oid</literal> ne peuvent plus être ajoutées,
       cette clause n'a aucun effet.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
    <term><literal>SET TABLESPACE</literal></term>
    <listitem>
     <para>
      Cette clause remplace le tablespace de la table par le tablespace
      indiqué, et déplace les fichiers de données associés à la table vers le
      nouveau tablespace. Les index de la table, s'il y en a, ne sont pas
      déplacés mais ils peuvent l'être avec des commandes <literal>SET
      TABLESPACE</literal> séparées.
      Quand cette clause est appliquée à une table partitionnée, aucune
      partition pré-existante n'est déplacée. Cependant, toute partition
      créée ensuite avec l'ordre <command>CREATE TABLE PARTITION OF</command>
      utilisera ce tablespace, à moins qu'une autre clause <literal>TABLESPACE</literal>
      ne soit utilisée pour la remplacer.
     </para>

     <para>
      Toutes les tables de la base de donnée
      d'un tablespace peuvent être déplacées en utilisant la clause
      <literal>ALL IN TABLESPACE</literal>, ce qui verrouillera toutes les
      tables pour les déplacer une par une. Cette clause supporte aussi
      <literal>OWNED BY</literal>, qui déplacera seulement les tables
      appartenant aux rôles spécifiées. Si l'option <literal>NOWAIT</literal>
      est précisée, alors la commande échouera si elle est incapable
      d'acquérir tous les verrous requis immédiatement. Notez que les
      catalogues systèmes ne sont pas déplacés par cette commande, donc
      utilisez <command>ALTER DATABASE</command> ou des appels explicites à
      <command>ALTER TABLE</command> si désiré. Les tables du schéma
      <literal>information_schema</literal> ne sont pas considérées comme
      faisant partie des catalogues systèmes et seront donc déplacées. Voir
      aussi <xref linkend="sql-createtablespace"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET { LOGGED | UNLOGGED }</literal></term>
    <listitem>
     <para>
      Cette clause modifie le statut journalisé/non journalisé d'une table
      (voir <xref linkend="sql-createtable-unlogged"/>). Cela ne peut pas
      s'appliquer à une table temporaire.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
     <term><literal>SET ( <replaceable class="parameter">paramètre_stockage</replaceable> [= <replaceable class="parameter">valeur</replaceable>] [, ... ] )</literal></term>
     <listitem>
      <para>
       Cette forme modifie un ou plusieurs paramètres de stockage pour la table.
       Voir <xref linkend="sql-createtable-storage-parameters" /> in the
       <xref linkend="sql-createtable"/> documentation
       pour les détails sur les paramètres disponibles. Le contenu de
       la table ne sera pas modifié immédiatement par cette commande&nbsp;;
       en fonction du paramètre, il pourra s'avérer nécessaire de réécrire la table pour
       obtenir les effets désirés. Ceci peut se faire avec <link linkend="sql-vacuum">VACUUM
        FULL</link>, <xref
       linkend="sql-cluster"/> ou une des formes
       d'<command>ALTER TABLE</command> qui force une réécriture de la table.
       Pour les paramètres liés à l'optimiseur, les changement prendront effet
       à partir de la prochaine fois que la table est verrouillée, donc les
       requêtes en cours d'exécution ne seront pas affectées.
      </para>
 
      <para>
       Un verrou de type <literal>SHARE UPDATE EXCLUSIVE</literal> sera acquis
       pour les paramètre de stockage fillfactor, toast et autovacuum, ainsi
       que les que le paramètre lié à l'optimiseur
       <varname>parallel_workers</varname>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>RESET ( <replaceable class="parameter">paramètre_stockage</replaceable> [, ... ] )</literal></term>
     <listitem>
      <para>
       Cette forme réinitialise un ou plusieurs paramètres de stockage à leur
       valeurs par défaut. Comme avec <literal>SET</literal>, une réécriture de
       table pourrait être nécessaire pour mettre à jour entièrement la table.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>INHERIT <replaceable class="parameter">table_parent</replaceable></literal></term>
     <listitem>
      <para>
       Cette forme ajoute la table cible comme nouvel enfant à la table parent
       indiquée. En conséquence, les requêtes concernant le parent ajouteront
       les enregistrements de la table cible. Pour être ajoutée en tant
       qu'enfant, la table cible doit déjà contenir toutes les colonnes de la
       table parent (elle peut avoir des colonnes supplémentaires). Les colonnes
       doivent avoir des types qui correspondent, et s'il y a des contraintes
       <literal>NOT NULL</literal> défini pour le parent, alors elles doivent
       aussi avoir les contraintes <literal>NOT NULL</literal> pour l'enfant.
      </para>

      <para>
       Il doit y avoir aussi une correspondance des contraintes de tables enfants
       pour toutes les contraintes <literal>CHECK</literal>, sauf pour celles
       qui ont été définies comme non-héritables (c'est-à-dire créées avec l'option <literal>ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT</literal>)
       par la table parente, qui sont donc ignorées. Les contraintes des tables filles en correspondance avec
       celles de la table parente ne doivent pas être définies comme non-héritables. Actuellement, les
       contraintes <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>
       et <literal>FOREIGN KEY</literal> ne sont pas prises en compte mais ceci
       pourrait changer dans le futur.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>NO INHERIT <replaceable class="parameter">table_parent</replaceable></literal></term>
     <listitem>
      <para>
       Cette forme supprime une table cible de la liste des enfants de la table
       parent indiquée.
       Les requêtes envers la table parent n'incluront plus les enregistrements
       de la table cible.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>OF <replaceable class="parameter">nom_type</replaceable></literal></term>
     <listitem>
      <para>
       Cette forme lie la table à un type composite comme si la commande
       <command>CREATE TABLE OF</command> l'avait créée. la liste des noms de colonnes et leurs types
       doit correspondre précisément à ceux du type composite.
       La table ne doit pas hériter d'une autre table. Ces restrictions garantissent que la commande
       <command>CREATE TABLE OF</command> pourrait permettre la définition d'une table équivalente.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>NOT OF</literal></term>
     <listitem>
      <para>
       Cette forme dissocie une table typée de son type.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>OWNER</literal></term>
     <listitem>
      <para>
       Change le propriétaire d'une table, d'une séquence, d'une vue, d'une vue
       matérialisée ou d'une table distante. Le nouveau propriétaire est celui
       passé en paramètre.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="sql-createtable-replica-identity">
     <term><literal>REPLICA IDENTITY</literal></term>
     <listitem>
      <para>
       Cette forme change l'information écrite dans les journaux de transactions
       permettant d'identifier les lignes qui sont mises à jour ou supprimées.
       Cette option n'a pas d'effet si la réplication logique n'est pas
       utilisée.  <literal>DEFAULT</literal> (la valeur par défaut pour les
       tables non systèmes) enregistre les anciennes valeurs des colonnes de la
       clé primaire, s'il y en a une.  <literal>USING INDEX</literal> enregistre
       les anciennes valeurs des colonnes couvertes par l'index, qui doit être
       de type unique, non partiel, non différée, et inclut uniquement les
       colonnes marquées <literal>NOT NULL</literal>.  <literal>FULL</literal>
       enregistre les anciennes valeurs de toutes les colonnes de la ligne.
       <literal>NOTHING</literal> n'enregistre aucune information sur l'ancienne
       ligne. (Il s'agit de la valeur par défaut pour les tables systèmes).
       Dans tous les cas, aucune ancienne valeur ne sera enregistrée sauf si au
       moins une des colonnes qui aurait du être enregistrée présente des
       différences entre les anciennes et les nouvelles versions de la ligne.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>RENAME</literal></term>
     <listitem>
      <para>
       Change le nom d'une table (ou d'un index, d'une séquence, d'une vue,
       d'une vue matérialisée ou d'une table distante) ou le nom d'une colonne
       individuelle de la table ou le nom d'une contrainte de la table. Lors
       du renommage d'une constrainte qui dispose d'un index sous-jacent,
       l'index est aussi renommé. Cela n'a aucun effet sur la donnée stockée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>SET SCHEMA</literal></term>
     <listitem>
      <para>
       Déplace la table dans un autre schéma. Les index, les contraintes et les
       séquences utilisées dans les colonnes de table sont également déplacés.
      </para>
     </listitem>
    </varlistentry>

   <varlistentry id="sql-altertable-attach-partition">
    <term><literal>ATTACH PARTITION <replaceable class="parameter">nom_partition</replaceable> { FOR VALUES <replaceable class="parameter">spec_limite_partition</replaceable> | DEFAULT }</literal></term>
    <listitem>
     <para>
      Attache une table existante (qui peut elle-même être partitionnée) comme
      une partition de la table cible. La table peut être attachée comme
      partition pour des valeurs spécifiques en utilisant <literal>FOR
      VALUES</literal> ou comme partition par défaut en utilisant
      <literal>DEFAULT</literal>. Pour chaque index de la table cible, un
      index correspondant sera créé dans la table attachée. Si un index
      équivalent existe déjà, il sera attaché à l'index de la table cible,
      tout comme si <command>ALTER INDEX ATTACH PARTITION</command> avait été
      executé. Notez que si la table existante est une table distante, il
      n'est actuellement pas autorisé d'attacher la table comme partition de
      la table cible s'il existe des index <literal>UNIQUE</literal> sur la
      table cible (voir aussi <xref linkend="sql-createforeigntable"/>). Pour
      chaque trigger de niveau ligne défini par l'utilisateur existant dans la
      table cible, un trigger correspondant est créé dans la table attachée.
     </para>

     <para>
      Une partition utilisant <literal>FOR VALUES</literal> utilise la même
      syntaxe pour <replaceable
      class="parameter">spec_limite_partition</replaceable> que <xref
      linkend="sql-createtable"/>. La spécification de limite de
      partition doit correspondre à la stratégie de partitionnement et à la clé
      de partition de la table cible.  La table qui doit être attachée doit
      avoir la totalité des colonnes identiques à la table cible et ne dois pas
      en avoir plus; de plus, les types de colonnes doivent également
      correspondre.  De plus, elle doit avoir toutes les contraintes
      <literal>NOT NULL</literal> et <literal>CHECK</literal> de la table
      cible.  Pour le moment, les contraintes <literal>FOREIGN KEY</literal> ne sont
      pas considérées. Les contraintes <literal>UNIQUE</literal> and
      <literal>PRIMARY KEY</literal> de la table parent seront créées dans la
      partition si elles n'existent pas déjà. Si une seule des contraintes
      <literal>CHECK</literal> de la table étant attachée est marquée comme
      <literal>NO INHERIT</literal>, la commande échouera&nbsp;; de telles
      contraintes doivent être recréées sans la clause <literal>NO
      INHERIT</literal>.
     </para>

     <para>
      Si la nouvelle partition est une table standard, un parcours complet de
      la table est effectué pour vérifier que les lignes existantes ne
      violent pas la contrainte de partition.  Il est possible d'éviter ce parcours
      en ajoutant une contrainte <literal>CHECK</literal> valide à la table qui
      n'autoriserait que les lignes satisfaisant la contrainte de partition
      désirée avant de lancer cette commande.  La contrainte <literal>CHECK</literal>
      sera utilisée pour déterminer si le parcours de la table est nécessaire pour valider la
      contrainte de partition.  Cependant, cela ne fonctionne pas si l'une des
      clés de la partition est une expression et que la partition n'accepte pas
      de valeurs <literal>NULL</literal>.  Si une partition de type liste qui
      n'accepte pas de valeurs <literal>NULL</literal> est attachée, ajoutez
      également une contrainte <literal>NOT NULL</literal> à la colonne de la
      clé de partition, à moins qu'il s'agisse d'une expression.
     </para>

     <para>
      Si la nouvelle partition est une table étrangère,  rien ne sera fait pour
      vérifier que toutes les lignes de la table étrangères obéissent à la
      contrainte de partition.  (Voir la discussion dans <xref
          linkend="sql-createforeigntable"/> sur les contraintes sur les tables
      étrangères.)
     </para>

     <para>
      Quand une table a une partition par défaut, définir une nouvelle
      partition modifie la contrainte de la partition par défaut. Cette
      dernière ne peut pas contenir de lignes qui devraient être déplacées
      dans la nouvelle partition. Ce cas sera vérifié. Ce parcours, tout comme
      le parcours de la nouvelle partition, peut être évité si une contrainte
      <literal>CHECK</literal> appropriée est présente. De plus, comme pour le
      parcours de la nouvelle partition, c'est toujours ignoré quand la
      partition par défaut est une table distante.
     </para>

     <para>
      Attacher une partition nécessite l'acquisition d'un verrou
      <literal>SHARE UPDATE EXCLUSIVE</literal> sur la table parent, en plus
      des verrous <literal>ACCESS EXCLUSIVE</literal> sur la table à attacher
      et sur la partition par défaut (s'il y en a une).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DETACH PARTITION</literal> <replaceable class="parameter">nom_partition</replaceable></term>
    <listitem>
     <para>
      Cette syntaxe détache la partition spécifiée de la table cible. La
      partition détachée continue d'exister comme une table standard, mais n'a
      plus aucun lien avec la table dont elle vient d'être détachée. Tout
      index attaché aux index de la table cible est détaché. Tous les triggers
      créés comme clones de ceux disponibles dans la table cible sont
      supprimés.
     </para>
    </listitem>
   </varlistentry>

   </variablelist>
  </para>

  <para>
   Toutes les formes d'ALTER TABLE qui agissent sur une seule table, à
   l'exception de <literal>RENAME</literal>, <literal>SET SCHEMA</literal>,
   <literal>ATTACH PARTITION</literal>, et <literal>DETACH PARTITION</literal>
   peuvent être combinées dans une liste de plusieurs altérations à appliquer
   en parallèle.  Par exemple, il est possible d'ajouter plusieurs colonnes
   et/ou de modifier le type de plusieurs colonnes en une seule commande. Ceci
   est particulièrement utile avec les grosses tables car une seule passe sur
   la table est alors nécessaire.
  </para>

  <para>
   Il faut être propriétaire de la table pour utiliser <command>ALTER
       TABLE</command>.  Pour modifier le schéma ou le tablespace d'une table,
   le droit <literal>CREATE</literal> sur le nouveau schéma est requis.  Pour
   ajouter la table en tant que nouvel enfant d'une table parent, vous devez
   aussi être propriétaire de la table parent. De plus, pour attacher une table
   en tant que nouvelle partition de la table, vous devez être le propriétaire
   de la table qui est attachée.  Pour modifier le propriétaire, il est
   nécessaire d'être un membre direct ou indirect du nouveau rôle et ce dernier
   doit avoir le droit <literal>CREATE</literal> sur le schéma de la table.
   (Ces restrictions assurent que la modification du propriétaire ne diffère en
   rien de ce qu'il est possible de faire par la suppression et le recréation
   de la table.  Néanmoins, un superutilisateur peut modifier le propriétaire
   de n'importe quelle table.) Pour ajouter une colonne ou modifier un type de
   colonne ou utiliser la clause <literal>OF</literal>, vous devez avoir le
   droit <literal>USAGE</literal> sur le type de la donnée.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>

   <varlistentry>
      <term><literal>IF EXISTS</literal></term>
      <listitem>
       <para>
        Ne renvoie pas une erreur si la table n'existe pas. Un message
        d'attention est renvoyé dans ce cas.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
      Le nom (éventuellement qualifié du nom du schéma) de la table à modifier.
      Si <literal>ONLY</literal> est indiqué avant le nom de la table, seule
      cette table est modifiée. Dans le cas contraire, la table et toutes ses
      tables filles (s'il y en a) sont modifiées. En option,
      <literal>*</literal> peut être ajouté après le nom de la table pour
      indiquer explicitement que les tables filles doivent être inclues.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_colonne</replaceable></term>
    <listitem>
     <para>
      Le nom d'une colonne, existante ou nouvelle.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable
     class="parameter">nouveau_nom_colonne</replaceable></term>
    <listitem>
     <para>
      Le nouveau nom d'une colonne existante.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nouveau_nom</replaceable></term>
    <listitem>
     <para>
      Le nouveau nom de la table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_données</replaceable></term>
    <listitem>
     <para>
      Le type de données de la nouvelle colonne, ou le nouveau type de données d'une
      colonne existante.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">contraintedetable</replaceable></term>
    <listitem>
     <para>
      Une nouvelle contrainte de table pour la table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nomdecontrainte</replaceable></term>
    <listitem>
     <para>
      Le nom d'une nouvelle contrainte ou d'une contrainte existante à supprimer.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CASCADE</literal></term>
    <listitem>
     <para>
      Les objets qui dépendent de la colonne ou de la contrainte supprimée
      sont automatiquement supprimés (par exemple, les vues référençant la
      colonne), ainsi que tous les objets dépendants de ces objets (voir <xref
      linkend="ddl-depend"/>).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RESTRICT</literal></term>
    <listitem>
     <para>
      La colonne ou la contrainte n'est pas supprimée si des objets en
      dépendent. C'est le comportement par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_declencheur</replaceable></term>
    <listitem>
     <para>
      Le nom d'un déclencheur isolé à désactiver ou activer.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ALL</literal></term>
    <listitem>
     <para>
      Désactiver ou activer tous les déclencheurs appartenant à la table.
      (Les droits de superutilisateur sont nécessaires si l'un des déclencheurs
      est un déclencheur interne pour la gestion d'une contrainte comme
      ceux utilisés pour implanter les contraintes de type clés étrangères
      ou les contraintes déferrables comme les contraintes uniques et
      d'exclusion.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>USER</literal></term>
    <listitem>
     <para>
      Désactiver ou activer tous les déclencheurs appartenant à la table
      sauf les déclencheurs systèmes permettant de gérer en interne certaines
      contraintes, comme celles utilisées pour implanter les contraintes de
      type clés étrangères ou les contraintes déferrables comme les
      contraintes uniques et d'exclusion.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nomindex</replaceable></term>
    <listitem>
     <para>
      Le nom d'un index existant.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">paramètre_stockage</replaceable></term>
    <listitem>
     <para>
      Le nom d'un paramètre de stockage de la table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">valeur</replaceable></term>
    <listitem>
     <para>
      La nouvelle valeur d'un paramètre de stockage de la table. Cela peut
      être un nombre ou un mot suivant le paramètre.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">table_parent</replaceable></term>
    <listitem>
     <para>
      Une table parent à associer ou dissocier de cette table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable
     class="parameter">nouveau_propriétaire</replaceable></term>
    <listitem>
     <para>
      Le nom du nouveau propriétaire de la table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable
     class="parameter">nouvel_espacelogique</replaceable></term>
    <listitem>
     <para>
      Le nom du tablespace où déplacer la table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable
     class="parameter">nouveau_schema</replaceable></term>
    <listitem>
     <para>
      Le nom du schéma où déplacer la table.
     </para>
    </listitem>
   </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nom_partition</replaceable></term>
      <listitem>
       <para>
        Le nom de la table à attacher comme nouvelle partition ou à détacher de
        cette table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">spec_limite_partition</replaceable></term>
      <listitem>
       <para>
        La spécification de limite de partition pour une nouvelle partition.
        Se référer à <xref linkend="sql-createtable"/> pour plus de détails sur
        la syntaxe.
       </para>
      </listitem>
     </varlistentry>

  </variablelist>
 </refsect1>

 <refsect1 id="sql-altertable-notes" xreflabel="Notes">
  <title>Notes</title>

  <para>
   Le mot clé <literal>COLUMN</literal> n'est pas nécessaire. Il peut
   être omis.
  </para>

  <para>
   Quand une colonne est ajoutée avec <literal>ADD COLUMN</literal> et qu'un
   <literal>DEFAULT</literal> non volatile est spécifié, la valeur par défaut
   est évaluée au moment de la requête et le résultat stocké dans les
   méta-données de la table. Cette valeur sera utilisée pour la colonne sur
   toutes les lignes existantes. Si aucune valeur par défaut
   (<literal>DEFAULT</literal>) n'est indiquée, NULL est utilisé. Une
   réécriture de la table n'est jamais requise.
  </para>

  <para>
   Ajouter une colonne avec un <literal>DEFAULT</literal> volatile ou changer
   le type d'une colonne existante requiert une réécriture complète de la
   table et de ses index. Il existe une exception lors du changement du type
   de données d'une colonne existante si la clause <literal>USING</literal> ne
   change pas le contenu de la colonne, et que l'ancien type est compatible
   binairement avec le nouveau type ou vers le domaine non contraint sur le
   nouveau type. Dans ces cas, la réécriture de la table n'est pas nécessaire
   mais tous les index sur les colonnes affectées doivent être reconstruits.
   Les reconstructions de table et/ou
   index peuvent prendre beaucoup de temps pour une grosse table. De plus,
   cela nécessitera au plus deux fois l'espace disque.
  </para>

  <para>
   Ajouter une contrainte <literal>CHECK</literal> ou <literal>NOT NULL</literal> requiert
   de parcourir la table pour vérifier que les lignes existantes respectent
   cette contrainte, mais ne requiert par une ré-écriture de la table.
  </para>

  <para>
    Pareillement, quand une nouvelle partition est attachée elle pourrait être
    parcourue pour vérifier que les lignes existantes vérifient la contrainte
    de partition.
   </para>

   <para>
   La raison principale de la possibilité de spécifier des changements multiples
   à l'aide d'une seule commande <command>ALTER TABLE</command> est la combinaison
   en une seule passe sur la table de plusieurs parcours et réécritures.
  </para>

   <para>
    Le parcours d'une grosse table pour vérifier une nouvelle contrainte de clé
    étrangère ou une nouvelle contrainte de vérification peut prendre beaucoup
    de temps, et toute modification de données est bloquée tant que la
    commande <command>ALTER TABLE ADD CONSTRAINT</command> n'est pas validée.
    Le but principal de l'option <literal>NOT VALID</literal> est de réduire
    l'impact de l'ajout d'une nouvelle contrainte sur les demandes de modifications
    concurrentes. Avec la clause <literal>NOT VALID</literal>, la commande
    <command>ADD CONSTRAINT</command> n'effectue pas de parcours complet de la table
    et peut donc être validée instantanément. Ensuite, une commande
    <literal>VALIDATE CONSTRAINT</literal> peut être lancée pour vérifier
    que les lignes existantes satisfont la contrainte. L'étape de validation ne
    nécessite pas de verrou empêchant les modifications concurrentes car la
    contrainte sera vérifiée pour les lignes insérées ou modifiées&nbsp;; seules les
    lignes antérieures à l'ajout de la contrainte doivent être vérifiées. Ainsi,
    la validation ne nécessite qu'un verrou <literal>SHARE UPDATE EXCLUSIVE</literal>
    sur la table indiquée. (Si la contrainte est une contrainte de clé étrangère,
    alors un verrou <literal>ROW SHARE</literal> est aussi nécessaire sur la
    table référencée par la contrainte.) En plus d'améliorer la gestion de la
    concurrence des accès, on peut utilsier la clause <literal>NOT VALID</literal>
    suivie d'un <literal>VALIDATE CONSTRAINT</literal> dans le cas où des
    violations de cette contrainte sont connues. Une fois que la contrainte
    est en place, aucune nouvelle violation ne pourra avoir lieu et le problème
    préexistant pourra être géré plus tard pour qu'enfin une commande <literal>VALIDATE
    CONSTRAINT</literal> puisse finalement aboutir.
   </para>

  <para>
   La forme <literal>DROP COLUMN</literal> ne supprime pas physiquement la
   colonne, mais la rend simplement invisible aux opérations SQL.
   Par la suite, les ordres d'insertion et de mise à jour sur cette table
   stockent une valeur NULL pour la colonne.
   Ainsi, supprimer une colonne ne réduit pas immédiatement la taille de la
   table sur disque car l'espace occupé par la colonne n'est pas
   récupéré. Cet espace est récupéré au fur et à mesure des
   mises à jour des lignes de la table.
  </para>

  <para>
   Pour forcer une réécriture immédiate de la table, vous pouvez utiliser
   <link linkend="sql-vacuum">VACUUM FULL</link>, <xref linkend="sql-cluster"/>
   ou bien une des formes de la commande ALTER TABLE qui force une réécriture. Ceci ne cause pas de
   modifications visibles dans la table, mais élimine des données qui ne sont plus utiles.
  </para>

  <para>
   Les formes d'<command>ALTER TABLE</command> qui ré-écrivent la table ne
   sont pas sûres au niveau MVCC. Après une ré-écriture de la table, elle
   apparaitra vide pour les transactions concurrentes si elles ont utilisé
   une image de la base prise avant la ré-écriture de la table. Voir <xref
   linkend="mvcc-caveats"/> pour plus de détails.
  </para>

  <para>
   L'option <literal>USING</literal> de <literal>SET DATA TYPE</literal> peut en fait
   utiliser une expression qui implique d'anciennes valeurs de la
   ligne&nbsp;; c'est-à-dire qu'il peut être fait référence aussi bien aux autres colonnes
   qu'à celle en cours de conversion. Cela permet d'effectuer des conversions très
   générales à l'aide de la syntaxe <literal>SET DATA TYPE</literal>. À cause de cette
   flexibilité, l'expression <literal>USING</literal> n'est pas appliquée à la
   valeur par défaut de la colonne (s'il y en a une)&nbsp;: le résultat pourrait
   ne pas être une expression constante requise pour une valeur par défaut.
   Lorsqu'il n'existe pas de transtypage, implicite ou
   d'affectation, entre les deux types, <literal>SET DATA TYPE</literal> peut
   échouer à convertir la valeur par défaut alors même que la clause
   <literal>USING</literal> est spécifiée. Dans de ce cas, il convient de supprimer
   valeur par défaut avec <literal>DROP DEFAULT</literal>, d'exécuter
   <literal>ALTER TYPE</literal> et enfin d'utiliser <literal>SET DEFAULT</literal>
   pour ajouter une valeur par défaut appropriée. Des considérations similaires s'appliquent aux
   index et contraintes qui impliquent la colonne.
  </para>

  <para>
    Si une table a des tables descendantes, il n'est pas permis d'ajouter,
    renommer ou changer le type d'une colonne dans la table parente sans faire
    la même chose sur tous les descendants.  Cela permet de s'assurer que les
    descendants ont toujours des colonnes qui correspondent au parent.  De la
    même façon, une contrainte <literal>CHECK</literal> ne peut pas être
    renommée dans la table parente sans également la renommer dans tous les
    descendant, afin que toutes les contraintes <literal>CHECK</literal>
    soient également en correspondance avec celles du parents et de ses
    descendants. (Néanmoins, cette restriction ne s'applique pas aux
    contraintes basées sur des index.) De plus, puisque la sélection de ligne
    de la table parente sélectionne également des lignes de ses descendants,
    une contrainte sur le parent ne peut pas être marquée comme valide à moins
    qu'elle ne le soit également sur tous les descendants. Dans tous ces cas,
    <command>ALTER TABLE ONLY</command> sera rejeté.
  </para>

  <para>
   Un appel récursif à <literal>DROP COLUMN</literal> supprime la colonne d'une
   table descendante si et seulement si cette table n'hérite pas cette colonne
   d'une autre table et que la colonne n'y a pas été définie indépendamment de
   tout héritage.  Une suppression non récursive de colonne (<command>ALTER
       TABLE ONLY ... DROP COLUMN</command>) ne supprime jamais les colonnes
   descendantes&nbsp;; elles sont marquées comme définies de manière
   indépendante, plutôt qu'héritées. Une commande <literal>DROP
       COLUMN</literal> non récursive échouera pour une table partitionnée,
   puisque toutes les partitions d'une table doivent avoir les même colonnes
   que la racine de partitionnement.
  </para>

  <para>
   Les actions pour les colonnes d'identité (<literal>ADD GENERATED</literal>,
   <literal>SET</literal> etc., <literal>DROP IDENTITY</literal>), ainsi que
   les actions <literal>TRIGGER</literal>, <literal>CLUSTER</literal>,
   <literal>OWNER</literal>, et <literal>TABLESPACE</literal> ne sont jamais
   appelées récursivement sur les tables descendantes; c'est-à-dire qu'elles
   agissent comme si <literal>ONLY</literal> est spécifié.  Seules les
   contraintes <literal>CHECK</literal> sont propagées, et uniquement si elles
   ne sont pas marquées <literal>NO INHERIT</literal>.
  </para>

  <para>
   Tout changement sur une table du catalogue système est interdit.
  </para>

  <para>
   Voir la commande <xref linkend="sql-createtable"/> pour avoir une
   description plus complète des paramètres valides.
   <xref linkend="ddl"/> fournit de plus amples informations sur l'héritage.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Ajouter une colonne de type <type>varchar</type> à une table&nbsp;:
   <programlisting>ALTER TABLE distributeurs ADD COLUMN adresse varchar(30);
   </programlisting>
   Cette requête entraînera le remplissage par des valeurs NULL de toutes les
   lignes existantes de la table pour cette nouvelle colonne.
  </para>

  <para>
   Pour ajouter une colonne avec une valeur par défaut non NULL&nbsp;:
<programlisting>
ALTER TABLE measurements
  ADD COLUMN mtime timestamp with time zone DEFAULT now();
</programlisting>
   Les lignes existantes seront remplies avec la date actuelle comme valeur
   de la nouvelle colonne, puis les nouvelles lignes recevront l'heure de leur
   insertion.
  </para>

  <para>
   Pour ajouter une colonne avec une valeur par défaut différente entre les
   anciennes lignes et les nouvelles&nbsp;:
<programlisting>
ALTER TABLE transactions
  ADD COLUMN status varchar(30) DEFAULT 'ancien',
  ALTER COLUMN status SET default 'nouveau';
</programlisting>
   Les lignes existantes seront remplies avec la valeur
   <literal>ancien</literal>, mais ensuite la valeur par défaut pour les
   requêtes suivantes sera <literal>nouveau</literal>. L'effet est le même
   que si deux sous-commandes avaient été émises par des requêtes
   <command>ALTER TABLE</command> séparées.
  </para>

  <para>
   Supprimer une colonne de table&nbsp;:
   <programlisting>ALTER TABLE distributeurs DROP COLUMN adresse RESTRICT;
   </programlisting>
  </para>

  <para>
   Changer les types de deux colonnes en une seule opération&nbsp;:
   <programlisting>ALTER TABLE distributeurs
    ALTER COLUMN adresse TYPE varchar(80),
    ALTER COLUMN nom TYPE varchar(100);
   </programlisting>
  </para>

  <para>
   Convertir une colonne de type integer (entier) contenant une estampille
   temporelle UNIX en <type>timestamp with time zone</type> à l'aide d'une clause
   <literal>USING</literal>&nbsp;:
   <programlisting>ALTER TABLE truc
    ALTER COLUMN truc_timestamp SET DATA TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + truc_timestamp * interval '1 second';
   </programlisting>
  </para>

  <para>
   La même, quand la colonne a une expression par défaut qui ne sera pas
   convertie automatiquement vers le nouveau type de données&nbsp;:
   <programlisting>ALTER TABLE truc
    ALTER COLUMN truc_timestamp DROP DEFAULT,
    ALTER COLUMN truc_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + truc_timestamp * interval '1 second',
    ALTER COLUMN truc_timestamp SET DEFAULT now();
   </programlisting>
  </para>

  <para>
   Renommer une colonne existante&nbsp;:
   <programlisting>ALTER TABLE distributeurs RENAME COLUMN adresse TO ville;
   </programlisting>
  </para>

  <para>
   Renommer une table existante&nbsp;:
   <programlisting>ALTER TABLE distributeurs RENAME TO fournisseurs;
   </programlisting>
  </para>

  <para>
   Pour renommer une contrainte existante&nbsp;:
   <programlisting>
ALTER TABLE distributeurs RENAME CONSTRAINT verif_cp TO verif_code_postal;
   </programlisting>
  </para>

  <para>
   Ajouter une contrainte NOT NULL à une colonne&nbsp;:
   <programlisting>ALTER TABLE distributeurs ALTER COLUMN rue SET NOT NULL;
   </programlisting>
   Supprimer la contrainte NOT NULL d'une colonne&nbsp;:
   <programlisting>ALTER TABLE distributeurs ALTER COLUMN rue DROP NOT NULL;
   </programlisting>
  </para>

  <para>
   Ajouter une contrainte de vérification sur une table et tous ses
   enfants&nbsp;:
   <programlisting>ALTER TABLE distributeurs ADD CONSTRAINT verif_cp CHECK (char_length(code_postal) = 5);
   </programlisting>
  </para>

  <para>
   Pour ajouter une contrainte <literal>CHECK</literal> à une table, mais pas à ses filles&nbsp;:
   <programlisting>
ALTER TABLE distributeurs ADD CONSTRAINT verif_cp CHECK (char_length(code_postal) = 5) NO INHERIT;
   </programlisting>
   (La contrainte de vérification ne sera également pas héritée par les futures
   filles.)
  </para>

  <para>
   Supprimer une contrainte de vérification d'une table et de toutes ses
   tables filles&nbsp;:
   <programlisting>ALTER TABLE distributeurs DROP CONSTRAINT verif_cp;
   </programlisting>
  </para>

  <para>
   Pour enlever une contrainte check d'une table seule (pas sur ses enfants)
   <programlisting>
ALTER TABLE ONLY distributeurs DROP CONSTRAINT verif_cp;
   </programlisting>
   (La contrainte check reste en place pour toutes les tables filles).
  </para>

  <para>
   Ajouter une contrainte de clé étrangère à une table&nbsp;:
   <programlisting>ALTER TABLE distributeurs ADD CONSTRAINT dist_fk FOREIGN KEY (adresse) REFERENCES adresses (adresse);
   </programlisting>
  </para>

  <para>
   Pour ajouter une contrainte de clé étrangère à une table avec le moins
   d'impact sur le reste de l'activité&nbsp;
   <programlisting>
ALTER TABLE distributeurs ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES adresses (adresse) NOT VALID;
ALTER TABLE distributeurs VALIDATE CONSTRAINT distfk;
   </programlisting>
  </para>

  <para>
   Ajouter une contrainte unique (multicolonnes) à une table&nbsp;:
   <programlisting>ALTER TABLE distributeurs ADD CONSTRAINT dist_id_codepostal_key UNIQUE (dist_id, code_postal);
   </programlisting>
  </para>

  <para>
   Ajouter une clé primaire nommée automatiquement à une table.
   Une table ne peut jamais avoir qu'une seule clé primaire.
   <programlisting>ALTER TABLE distributeurs ADD PRIMARY KEY (dist_id);
   </programlisting>
  </para>

  <para>
   Déplacer une table dans un tablespace différent&nbsp;:
   <programlisting>ALTER TABLE distributeurs SET TABLESPACE tablespacerapide;
   </programlisting>
  </para>

  <para>
   Déplacer une table dans un schéma différent&nbsp;:
   <programlisting>ALTER TABLE mon_schema.distributeurs SET SCHEMA votre_schema;
   </programlisting>
  </para>

  <para>
   Recréer une contrainte de clé primaire sans bloquer les mises à jour
   pendant la reconstruction de l'index&nbsp;:
   <programlisting>
CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributeurs (dist_id);
ALTER TABLE distributeurs DROP CONSTRAINT distributeurs_pkey,
    ADD CONSTRAINT distributeurs_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;
   </programlisting>
  </para>

  <para>
   Pour attacher une partition à une table partitionnée par intervalles :
<programlisting>
ALTER TABLE measurement
    ATTACH PARTITION measurement_y2016m07 FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
</programlisting></para>

  <para>
   Pour attacher une partition à une table partitionnée par liste :
<programlisting>
ALTER TABLE cities
    ATTACH PARTITION cities_ab FOR VALUES IN ('a', 'b');
</programlisting></para>

  <para>
   Pour attacher une partition à une table partitionnée par hachage&nbsp;:
<programlisting>
ALTER TABLE orders
    ATTACH PARTITION orders_p4 FOR VALUES WITH (MODULUS 4, REMAINDER 3);
</programlisting></para>

  <para>
   Pour attacher une partition par défaut à une table partitionnée&nbsp;:
<programlisting>
ALTER TABLE cities
    ATTACH PARTITION cities_partdef DEFAULT;
</programlisting></para>

  <para>
   Pour détacher une partition d'une table partitionnée :
<programlisting>
ALTER TABLE measurement
    DETACH PARTITION measurement_y2015m12;
</programlisting></para>

 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Les formes <literal>ADD</literal> (sans <literal>USING INDEX</literal>),
   <literal>DROP [COLUMN]</literal>, <literal>DROP IDENTITY</literal>, <literal>valeur_redémarrage</literal>,
   <literal>SET DEFAULT</literal>, <literal>SET DATA TYPE</literal> (sans <literal>USING</literal>),
   <literal>SET GENERATED</literal>, et <literal>SET <replaceable>option_sequence</replaceable></literal>
   se conforment au standard SQL. Les autres formes sont des extensions
   <productname>PostgreSQL</productname>, tout comme la possibilité de
   spécifier plusieurs manipulations en une seule commande <command>ALTER
       TABLE</command>.
  </para>

  <para>
   <command>ALTER TABLE DROP COLUMN</command> peut être utilisé pour supprimer
   la seule colonne d'une table, laissant une table dépourvue de colonne.
   C'est une extension au SQL, qui n'autorise pas les tables sans colonne.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createtable"/></member>
  </simplelist>
 </refsect1>
</refentry>
