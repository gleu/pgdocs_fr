<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<refentry id="sql-altertable">
 <refmeta>
  <refentrytitle>ALTER TABLE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Commandes du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>ALTER TABLE</refname>
  <refpurpose>Modifier la définition d'une table</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">nom</replaceable> [ * ]
    <replaceable class="parameter">action</replaceable> [, ... ]
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">nom</replaceable> [ * ]
    RENAME [ COLUMN ] <replaceable class="parameter">nom_colonne</replaceable> TO <replaceable class="parameter">nouveau_nom_colonne</replaceable>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="PARAMETER">nom</replaceable> [ * ]
    RENAME CONSTRAINT <replaceable class="PARAMETER">nom_contrainte</replaceable> TO <replaceable class="PARAMETER">nouveau_nom_contrainte</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">nom</replaceable>
    RENAME TO <replaceable class="parameter">nouveau_nom</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">nom</replaceable>
    SET SCHEMA <replaceable class="parameter">nouveau_schema</replaceable>

<phrase>où <replaceable class="parameter">action</replaceable> peut être&nbsp;:</phrase>

    ADD [ COLUMN ] <replaceable class="PARAMETER">nom_colonne</replaceable> <replaceable class="PARAMETER">type</replaceable> [ COLLATE <replaceable class="PARAMETER">collation</replaceable> ] [ <replaceable class="PARAMETER">contrainte_colonne</replaceable> [ ... ] ]
    DROP [ COLUMN ] [ IF EXISTS ] <replaceable class="parameter">nom_colonne</replaceable> [ RESTRICT | CASCADE ]
    ALTER [ COLUMN ] <replaceable class="PARAMETER">nom_colonne</replaceable> [ SET DATA ] TYPE <replaceable class="PARAMETER">type</replaceable> [ COLLATE <replaceable class="PARAMETER">collation</replaceable> ] [ USING <replaceable class="PARAMETER">expression</replaceable> ]
    ALTER [ COLUMN ] <replaceable class="parameter">nom_colonne</replaceable> SET DEFAULT <replaceable class="parameter">expression</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">nom_colonne</replaceable> DROP DEFAULT
    ALTER [ COLUMN ] <replaceable class="parameter">nom_colonne</replaceable> { SET | DROP } NOT NULL
    ALTER [ COLUMN ] <replaceable class="parameter">nom_colonne</replaceable> SET STATISTICS <replaceable class="parameter">entier</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">nom_column</replaceable> SET ( <replaceable class="parameter">option_attribut</replaceable> = <replaceable class="parameter">valeur</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="parameter">nom_column</replaceable> RESET ( <replaceable class="parameter">option_attribut</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="parameter">nom_colonne</replaceable> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
    ADD <replaceable class="PARAMETER">contrainte_table</replaceable> [ NOT VALID ]
    ADD <replaceable class="PARAMETER">contrainte_table_utilisant_index</replaceable>
    VALIDATE CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable>
    DROP CONSTRAINT [ IF EXISTS ] <replaceable class="parameter">nom_contrainte</replaceable> [ RESTRICT | CASCADE ]
    DISABLE TRIGGER [ <replaceable class="parameter">nom_declencheur</replaceable> | ALL | USER ]
    ENABLE TRIGGER [ <replaceable class="parameter">nom_declencheur</replaceable> | ALL | USER ]
    ENABLE REPLICA TRIGGER <replaceable class="parameter">nom_trigger</replaceable>
    ENABLE ALWAYS TRIGGER <replaceable class="parameter">nom_trigger</replaceable>
    DISABLE RULE <replaceable class="parameter">nom_regle_reecriture</replaceable>
    ENABLE RULE <replaceable class="parameter">nom_regle_reecriture</replaceable>
    ENABLE REPLICA RULE <replaceable class="parameter">nom_regle_reecriture</replaceable>
    ENABLE ALWAYS RULE <replaceable class="parameter">nom_regle_reecriture</replaceable>
    CLUSTER ON <replaceable class="parameter">nom_index</replaceable>
    SET WITHOUT CLUSTER
    SET WITH OIDS
    SET WITHOUT OIDS
    SET ( <replaceable class="parameter">paramètre_stockage</replaceable> = <replaceable class="parameter">valeur</replaceable> [, ... ] )
    RESET ( <replaceable class="parameter">paramètre_stockage</replaceable> [, ... ] )
    INHERIT <replaceable class="parameter">table_parent</replaceable>
    NO INHERIT <replaceable class="parameter">table_parent</replaceable>
    OF <replaceable class="PARAMETER">nom_type</replaceable>
    NOT OF
    OWNER TO <replaceable class="parameter">nouveau_proprietaire</replaceable>
    SET TABLESPACE <replaceable class="parameter">nouvel_espacelogique</replaceable>

<phrase>et <replaceable class="PARAMETER">table_constraint_using_index</replaceable> est:</phrase>

    [ CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable> ]
    { UNIQUE | PRIMARY KEY } USING INDEX <replaceable class="PARAMETER">index_name</replaceable>
    [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-altertable">
   <primary>ALTER TABLE</primary>
  </indexterm>

  <para>
   <command>ALTER TABLE</command> modifie la définition d'une table existante.
   Il existe plusieurs variantes&nbsp;:

  <variablelist>
   <varlistentry>
    <term><literal>ADD COLUMN</literal></term>
    <listitem>
     <para>
      Ajoute une nouvelle colonne à la table en utilisant une syntaxe identique à celle de
       <xref linkend="sql-createtable"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP COLUMN [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
      Supprime une colonne de la table. Les index et les 
      contraintes de table référençant cette colonne sont automatiquement supprimés.
      L'option <literal>CASCADE</literal> doit être utilisée lorsque des objets en dehors
      de la table dépendent de cette colonne, comme par exemple des références
      de clés étrangères ou des vues.
      Si <literal>IF EXISTS</literal> est indiqué et que la colonne n'existe
      pas, aucune erreur n'est renvoyée. Dans ce cas, un message d'avertissement
      est envoyé à la place.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>IF EXISTS</literal></term>
    <listitem>
     <para>
	  Ne retourne pas d'erreur si la table n'existe pas. Seul un message d'avertissement
	  est retourné dans ce cas.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET DATA TYPE</literal></term>
    <listitem>
     <para>
      Change le type d'une colonne de la table. Les index et
      les contraintes simples de table qui impliquent la colonne sont
      automatiquement convertis pour utiliser le nouveau type de la colonne en
      ré-analysant l'expression d'origine. La clause optionnelle <literal>COLLATE</literal>
      spécifie une collation pour la nouvelle colonne. Si elle est omise, la collation utilisée est la collation par défaut pour le nouveau type de la colonne. La clause
      optionnelle <literal>USING</literal> précise comment calculer la nouvelle
      valeur de la colonne à partir de l'ancienne&nbsp;; en cas d'omission, la
      conversion par défaut est identique à une affectation de transtypage de l'ancien type
      vers le nouveau. Une clause <literal>USING</literal> doit être fournie
      s'il n'existe pas de conversion implicite ou d'assignement entre les deux types.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP DEFAULT</literal></term>
    <listitem>
     <para>
      Ajoute ou supprime les valeurs par défaut d'une colonne.
      Les valeurs par défaut ne s'appliquent qu'aux commandes
      <command>INSERT</command> ultérieures. Elles ne modifient pas les lignes déjà 
      présentes dans la table. Des valeurs par défaut peuvent aussi être créées
      pour les vues. Dans ce cas, elles sont ajoutées aux commandes 
      <command>INSERT</command> de la vue avant que la règle 
      <literal>ON INSERT</literal> de la vue ne soit appliquée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP NOT NULL</literal></term>
    <listitem>
     <para>
      Modifie l'autorisation de
      valeurs NULL. <literal>SET NOT NULL</literal> ne peut être utilisé que
      si la colonne ne contient pas de valeurs NULL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET STATISTICS</literal></term>
    <listitem>
     <para>
      Permet de modifier l'objectif de collecte de statistiques
      par colonne pour les opérations d'analyse 
      (<xref linkend="sql-analyze"/>) ultérieures.
      L'objectif prend une valeur entre 0 et 10000. il est positionné à -1 pour utiliser
      l'objectif de statistiques par défaut du système
      (<xref linkend="guc-default-statistics-target"/>). Pour plus d'informations sur
      l'utilisation des statistiques par le planificateur de requêtes de
      <productname>PostgreSQL</productname>, voir <xref linkend="planner-stats"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET ( <replaceable class="PARAMETER">attribute_option</replaceable> = <replaceable class="PARAMETER">value</replaceable> [, ... ] )</literal></term>
    <term><literal>RESET ( <replaceable class="PARAMETER">attribute_option</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
      Cette syntaxe permet de configurer ou de réinitialiser des propriétés.
      Actuellement, les seules propriétés acceptées sont
      <literal>n_distinct</literal> et <literal>n_distinct_inherited</literal>,
      qui surchargent l'estimation du nombre de valeurs distinctes calculée par
      <xref linkend="sql-analyze"/>
      <literal>n_distinct</literal> affecte les statistiques de la table
      elle-même alors que <literal>n_distinct_inherited</literal> affecte les
      statistiques récupérées pour la table et les tables en héritant. Si
      configuré à une valeur positive, <command>ANALYZE</command> supposera
      que la colonne contient exactement le nombre spécifié de valeurs
      distinctes non NULL. Si configuré à une valeur négative qui doit être
      supérieur ou égale à -1, <command>ANALYZE</command> supposera que le
      nombre de valeurs distinctes non NULL dans la colonne est linéaire par
      rapport à la taille de la table&nbsp;; le nombre total est à calculer
      en multipliant la taille estimée de la table par la valeur absolue de
      ce nombre. Par exemple, une valeur de -1 implique que toutes les valeurs
      dans la colonne sont distinctes alors qu'une valeur de -0,5 implique
      que chaque valeur apparaît deux fois en moyenne. Ceci peut être utile
      quand la taille de la table change dans le temps, car la multiplication
      par le nombre de lignes dans la table n'est pas réalisée avant la
      planification. Spécifiez une valeur de 0 pour retourner aux estimations
      standards du nombre de valeurs distinctes. Pour plus d'informations sur
      l'utilisation des statistiques par le planificateur de requêtes
      <productname>PostgreSQL</productname>, référez vous à <xref
      linkend="planner-stats"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET STORAGE</literal></term>
    <listitem>
    <indexterm>
     <primary>TOAST</primary>
     <secondary>configuration de stockage par colonne</secondary>
    </indexterm>

     <para>
      Modifie le mode de stockage pour une colonne. Cela permet de contrôler si
      cette colonne est conservée en ligne ou dans une deuxième table, appelée
      table TOAST, et si les données sont ou non compressées. 
      <literal>PLAIN</literal>, en ligne, non compressé, est utilisé pour les
      valeurs de longueur fixe, comme les <type>integer</type>.
      <literal>MAIN</literal> convient pour les données en ligne, compressibles.
      <literal>EXTERNAL</literal> est fait pour les données externes non
      compressées, <literal>EXTENDED</literal> pour les données externes 
      compressées. <literal>EXTENDED</literal> est la valeur par défaut pour la
      plupart des types qui supportent les stockages différents de
      <literal>PLAIN</literal>. L'utilisation d'<literal>EXTERNAL</literal> 
      permet d'accélérer les opérations d'extraction de sous-chaînes sur les
      très grosses valeurs de types <type>text</type> et <type>bytea</type> mais
      utilise plus d'espace de stockage. <literal>SET STORAGE</literal> ne
      modifie rien dans la table, il configure la stratégie à poursuivre lors
      des mises à jour de tables suivantes. Voir <xref linkend="storage-toast"/>
      pour plus d'informations.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD <replaceable class="parameter">contrainte_table</replaceable>
          [ NOT VALID ]</literal></term>
    <listitem>
     <para>
      Ajoute une nouvelle contrainte à une table en utilisant une
      syntaxe identique à <xref linkend="sql-createtable"/>, plus
      l'option <literal>NOT VALID</literal>, qui est actuellement
      seulement autorisée pour les contraintes de type clé étrangère et les
      contraintes CHECK. Si
      la contrainte est marquée <literal>NOT VALID</literal>, la
      vérification initiale, potentiellement lente, permettant de
      s'assurer que toutes les lignes de la table satisfont la contrainte,
      est ignorée. La contrainte sera toujours assurée pour les insertions
      et mises à jour suivantes (autrement dit, elles échoueront sauf
      s'il existe une ligne correspondante dans la table référencée
	  par
	  la clé étrangère, ou elles échoueront sauf si la nouvelle ligne correspond aux
	  contraintes de vérification spécifiées)
      Par contre, la base de données ne supposera pas que la contrainte
      est valable pour toutes les lignes dans la table, tant que la
      contrainte n'a pas été validée en utilisant l'option <literal>VALIDATE
      CONSTRAINT</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD <replaceable class="PARAMETER">table_constraint_using_index</replaceable></literal></term>
    <listitem>
     <para>
       Cette forme ajoute une nouvelle contrainte <literal>PRIMARY KEY</literal> ou <literal>UNIQUE</literal> sur une table, 
       basée sur un index unique existant auparavant. Toutes
       les colonnes de l'index sont incluses dans la contrainte.
      </para>
     <para>
       Cet index ne peut pas être un index partiel, ni être sur des expressions de colonnes.
       De plus, il doit être un index b-tree avec un ordre de tri par défaut.
       Ces restrictions assurent que cet index soit équivalent à un index qui aurait été
       créé par une commande standard <literal>ADD PRIMARY KEY</literal> ou <literal>ADD UNIQUE</literal>.
     </para>

     <para>
       Si vous précisez <literal>PRIMARY KEY</literal>, et que les colonnes de l'index
       ne sont pas déjà spécifiées comme <literal>NOT NULL</literal>, alors la commande
       va tenter d'appliquer la commande <literal>ALTER COLUMN SET NOT NULL</literal> sur chacune 
       de ces colonnes. Cela nécessite un parcours complet de la table pour vérifier que la
       ou les colonne(s) ne contiennent pas de null. Dans tous les autres cas, c'est une opération rapide.
     </para>

     <para>
       Si un nom de contrainte est fourni, alors l'index sera renommé afin 
       de correspondre au nom de la contrainte. Sinon la contrainte sera nommée 
       comme l'index.
     </para>

     <para>
       Une fois que la commande est exécutée, l'index est <quote>possédé</quote>
       par la contrainte, comme si l'index avait été construit par une commande
       <literal>ADD PRIMARY KEY</literal> ou <literal>ADD UNIQUE</literal> ordinaire.
       En particulier, supprimer la contrainte fait également disparaître l'index.
     </para>

     <note>
      <para>
	Ajouter une contrainte en utilisant un index existant peut être utile
	dans les situations où il faut ajouter une nouvelle contrainte, sans bloquer
	les mises à jour de table trop longtemps. Pour faire cela, créez l'index avec 
	<command>CREATE INDEX CONCURRENTLY</command>, puis installez-la en tant que contrainte 
	officielle en utilisant cette syntaxe. Voir l'exemple ci-dessous.
      </para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>VALIDATE CONSTRAINT</literal></term>
    <listitem>
     <para>
      Cette forme valide une contrainte de type clé étrangère ou une
      contrainte CHECK qui a été
      précédemment créée avec la clause <literal>NOT VALID</literal>.
      Elle le fait en parcourant la table pour s'assurer qu'il n'existe
      aucune ligne pour laquelle la contrainte n'est pas satisfaite. Si
      la contrainte est déjà marquée valide, cette clause ne fait rien.
      L'intérêt de la séparation de la validation est qu'une vérification
      seule nécessite un verrou plus léger sur la table que ce qui
      est nécessaire pour une création standard de cette contrainte.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP CONSTRAINT [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
      Supprime la contrainte de table précisée.
      Si <literal>IF EXISTS</literal> est précisé et que la contrainte n'existe
      pas, aucune erreur n'est renvoyée. Par contre, un message d'avertissement
      est lancé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] TRIGGER</literal></term>
    <listitem>
     <para>
      Configure l'exécution des déclencheurs définis sur la
      table. Un déclencheur désactivé est toujours connu par le système mais
      n'est plus exécuté lorsque l'événement déclencheur survient. Pour un
      déclencheur retardé, le statut d'activité est vérifié au moment où survient l'événement,
      et non quand la fonction du déclencheur est réellement exécutée.
      Il est possible de désactiver ou d'activer un déclencheur spécifique (précisé par son nom),
	  tous les déclencheurs d'une table ou seulement les déclencheurs utilisateur
      de cette table (cette option exclut les déclencheurs générés en interne
      pour gérer les contraintes comme ceux utilisés pour implanter les
      contraintes de clés étrangères ou les contraintes déferrés uniques ou
      d'exclusion). Désactiver ou activer les déclencheurs implicites de
      contraintes requiert des droits de
      superutilisateur&nbsp;; cela doit se faire avec précaution car
      l'intégrité de la contrainte ne peut pas être garantie si les
      déclencheurs ne sont pas exécutés.
      Le mécanisme de déclenchement des triggers est aussi affecté par la
      variable de configuration <xref linkend="guc-session-replication-role"/>.
      Les triggers activés (<literal>ENABLE</literal>) se déclencheront quand
      le rôle de réplication est <quote>origin</quote> (la valeur par défaut)
      ou <quote>local</quote>. Les triggers configurés <literal>ENABLE
      REPLICA</literal> se déclencheront seulement si la session est en mode
      <quote>replica</quote> et les triggers <literal>ENABLE ALWAYS</literal>
      se déclencheront à chaque fois, quelque soit le mode de réplication.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] RULE</literal></term>
    <listitem>
     <para>
      Ces formes configurent le déclenchement des règles de réécriture
      appartenant à la table. Une règle désactivée est toujours connue par le
      système mais non appliquée lors de la réécriture de la requête. La
      sémantique est identique celles des triggers activés/désactivés. Cette
      configuration est ignorée pour les règles <literal>ON SELECT</literal>
      qui sont toujours appliqués pour conserver le bon fonctionnement des
      vues même si la session actuelle n'est pas dans le rôle de réplication
      par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CLUSTER ON</literal></term>
    <listitem>
     <para>
      Sélectionne l'index par défaut pour les prochaines
      opérations <xref linkend="sql-cluster"/>.
      La table n'est pas réorganisée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT CLUSTER</literal></term>
    <listitem>
     <para>
      Supprime de la table la spécification d'index
	  <xref linkend="sql-cluster"/> la plus récemment
      utilisée. Cela agit sur les opérations de réorganisation suivantes qui ne spécifient pas d'index.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITH OIDS</literal></term>
    <listitem>
     <para>
      Cette forme ajoute une colonne système <literal>oid</literal> à la table
      (voir <xref linkend="ddl-system-columns"/>).
      Elle ne fait rien si la table a déjà des OID.
      </para>

     <para>
      Ce n'est pas équivalent à <literal>ADD COLUMN oid oid</literal>. Cette
      dernière ajouterait une colonne normale nommée <literal>oid</literal>,
      qui n'est pas une colonne système.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT OIDS</literal></term>
    <listitem>
     <para>
      Supprime la colonne système <literal>oid</literal> de la
      table. Cela est strictement équivalent à <literal>DROP COLUMN oid RESTRICT</literal>,
      à ceci près qu'aucun avertissement n'est émis si la colonne <literal>oid</literal> n'existe plus.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET ( <replaceable class="parameter">paramètre_stockage</replaceable> = <replaceable class="parameter">valeur</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
      Cette forme modifie un ou plusieurs paramètres de stockage pour la table.
      Voir <xref linkend="sql-createtable-storage-parameters" />
      pour les détails sur les paramètres disponibles. Le contenu de
      la table ne sera pas modifié immédiatement par cette commande&nbsp;;
      en fonction du paramètre, il pourra s'avérer nécessaire de réécrire la table pour
      obtenir les effets désirés. Ceci peut se faire avec <link linkend="sql-vacuum">VACUUM
      FULL</link>, <xref
      linkend="sql-cluster"/> ou une des formes
      d'<command>ALTER TABLE</command> qui force une réécriture de la table.
     </para>

     <note>
      <para>
       Bien que <command>CREATE TABLE</command> autorise la spécification de
       <literal>OIDS</literal> avec la syntaxe <literal>WITH (<replaceable
       class="parameter">paramètre_stockage</replaceable>)</literal>,
       <command>ALTER TABLE</command> ne traite pas les <literal>OIDS</literal>
       comme un paramètre de stockage. À la place, utiliser les formes
       <literal>SET WITH OIDS</literal> et <literal>SET WITHOUT OIDS</literal>
       pour changer le statut des OID sur la table.
      </para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RESET ( <replaceable class="parameter">paramètre_stockage</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
      Cette forme réinitialise un ou plusieurs paramètres de stockage à leur
      valeurs par défaut. Comme avec <literal>SET</literal>, une réécriture de
      table pourrait être nécessaire pour mettre à jour entièrement la table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INHERIT <replaceable class="parameter">table_parent</replaceable></literal></term>
    <listitem>
     <para>
      Cette forme ajoute la table cible comme nouvel enfant à la table parent
      indiquée. En conséquence, les requêtes concernant le parent ajouteront
      les enregistrements de la table cible. Pour être ajoutée en tant
      qu'enfant, la table cible doit déjà contenir toutes les colonnes de la
      table parent (elle peut avoir des colonnes supplémentaires). Les colonnes
      doivent avoir des types qui correspondent, et s'il y a des contraintes
      <literal>NOT NULL</literal> défini pour le parent, alors elles doivent
      aussi avoir les contraintes <literal>NOT NULL</literal> pour l'enfant.
     </para>

     <para>
      Il doit y avoir aussi une correspondance des contraintes de tables enfants
      pour toutes les contraintes <literal>CHECK</literal>, sauf pour celles
	  qui ont été définies comme non-héritables (c'est-à-dire créées avec l'option <literal>ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT</literal>)
	  par la table parente, qui sont donc ignorées. Les contraintes des tables filles en correspondance avec
	  celles de la table parente ne doivent pas être définies comme non-héritables. Actuellement, les
      contraintes <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>
      et <literal>FOREIGN KEY</literal> ne sont pas prises en compte mais ceci
      pourrait changer dans le futur.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NO INHERIT <replaceable class="parameter">table_parent</replaceable></literal></term>
    <listitem>
     <para>
      Cette forme supprime une table cible de la liste des enfants de la table
      parent indiquée.
      Les requêtes envers la table parent n'incluront plus les enregistrements
      de la table cible.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OF <replaceable class="PARAMETER">nom_type</replaceable></literal></term>
    <listitem>
     <para>
       Cette forme lie la table à un type composite comme si la commande 
       <command>CREATE TABLE OF</command> l'avait créée. la liste des noms de colonnes et leurs types
       doit correspondre précisément à ceux du type composite&nbsp;; il est permis de différer la présence d'une colonne 
       système
       <literal>oid</literal>.
       . La table ne doit pas hériter d'une autre table. Ces restrictions garantissent que la commande 
       <command>CREATE TABLE OF</command> pourrait permettre la définition d'une table équivalente.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NOT OF</literal></term>
    <listitem>
     <para>
       Cette forme dissocie une table typée de son type.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OWNER</literal></term>
    <listitem>
     <para>
      Change le propriétaire d'une table, d'une
      séquence ou d'une vue. Le nouveau propriétaire est celui passé 
      en paramètre.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET TABLESPACE</literal></term>
    <listitem>
     <para>
      Remplace le tablespace de la table par le tablespace
      spécifié et déplace le(s) fichier(s) de données associé(s) à la table
      vers le nouveau tablespace. Les index de la table, s'il y en a, ne
      sont pas déplacés&nbsp;; mais ils peuvent l'être séparément à l'aide
      de commandes <literal>SET TABLESPACE</literal> supplémentaires. Voir aussi
      <xref linkend="sql-createtablespace"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RENAME</literal></term>
    <listitem>
     <para>
      Change le nom d'une table (d'un index, d'une séquence ou d'une vue) ou
      le nom d'une colonne individuelle de la table ou le nom d'une contrainte
      de la table. Cela n'a aucun effet sur la donnée stockée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET SCHEMA</literal></term>
    <listitem>
     <para>
      Déplace la table dans un autre schéma. Les index, les contraintes et les
      séquences utilisées dans les colonnes de table sont également déplacés.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
  </para>

  <para>
   Toutes les actions à l'exception de <literal>RENAME</literal> et
   <literal>SET SCHEMA</literal> peuvent être
   combinées dans une liste d'altérations à appliquer en parallèle.
   Par exemple, il est possible d'ajouter plusieurs colonnes et/ou de modifier le
   type de plusieurs colonnes en une seule commande. Ceci est particulièrement
   utile avec les grosses tables car une seule passe sur la table est alors
   nécessaire.
  </para>

  <para>
   Il faut être propriétaire de la table pour utiliser <command>ALTER TABLE</command>.
   Pour modifier le schéma d'une table, le droit <literal>CREATE</literal> sur
   le nouveau schéma est requis.
   Pour ajouter la table en tant que nouvel enfant d'une table parent, vous devez
   aussi être propriétaire de la table parent.
   Pour modifier le propriétaire, il est nécessaire d'être un membre direct ou
   indirect du nouveau rôle et ce dernier doit avoir le droit
   <literal>CREATE</literal> sur le schéma de la table. (Ces restrictions
   assurent que la modification du propriétaire ne diffère en rien de ce qu'il
   est possible de faire par la suppression et le recréation de la table.
   Néanmoins, un superutilisateur peut modifier le propriétaire de n'importe
   quelle table.)
   Pour ajouter une colonne ou modifier un type de colonne ou utiliser la clause <literal>OF</literal>,
   vous devez avoir le droit <literal>USAGE</literal> sur le type de la donnée.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

    <variablelist>

     <varlistentry>
      <term><replaceable class="parameter">nom</replaceable></term>
      <listitem>
       <para>
        Le nom (éventuellement qualifié du nom du schéma) de la table à modifier.
        Si <literal>ONLY</literal> est indiqué avant le nom de la table, seule
        cette table est modifiée. Dans le cas contraire, la table et toutes ses
        tables filles (s'il y en a) sont modifiées. En option,
        <literal>*</literal> peut être ajouté après le nom de la table pour
        indiquer explicitement que les tables filles doivent être inclues.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nom_colonne</replaceable></term>
      <listitem>
       <para>
        Le nom d'une colonne, existante ou nouvelle.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable
        class="parameter">nouveau_nom_colonne</replaceable></term>
      <listitem>
       <para>
        Le nouveau nom d'une colonne existante.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nouveau_nom</replaceable></term>
      <listitem>
       <para>
        Le nouveau nom de la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">type</replaceable></term>
      <listitem>
       <para>
        Le type de données de la nouvelle colonne, ou le nouveau type de données d'une
        colonne existante.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">contraintedetable</replaceable></term>
      <listitem>
       <para>
        Une nouvelle contrainte de table pour la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nomdecontrainte</replaceable></term>
      <listitem>
       <para>
        Le nom d'une contrainte existante à supprimer.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CASCADE</literal></term>
      <listitem>
       <para>
        Les objets qui dépendent de la colonne ou
        de la contrainte supprimée sont automatiquement supprimés
		(par exemple, les vues référençant la colonne).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RESTRICT</literal></term>
      <listitem>
       <para>
        La colonne ou la contrainte n'est pas supprimée si des objets en
        dépendent. C'est le comportement par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nom_declencheur</replaceable></term>
      <listitem>
       <para>
        Le nom d'un déclencheur isolé à désactiver ou activer.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ALL</literal></term>
      <listitem>
       <para>
        Désactiver ou activer tous les déclencheurs appartenant à la table.
        (Les droits de superutilisateur sont nécessaires si l'un des déclencheurs
        est un déclencheur interne pour la gestion d'une contrainte comme
        ceux utilisés pour implanter les contraintes de type clés étrangères
        ou les contraintes déferrables comme les contraintes uniques et
        d'exclusion.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>USER</literal></term>
      <listitem>
       <para>
        Désactiver ou activer tous les déclencheurs appartenant à la table
        sauf les déclencheurs systèmes permettant de gérer en interne certaines
        contraintes, comme celles utilisées pour implanter les contraintes de
        type clés étrangères ou les contraintes déferrables comme les
        contraintes uniques et d'exclusion.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nomindex</replaceable></term>
      <listitem>
       <para>
        Le nom de l'index sur lequel la table doit être réorganisée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">paramètre_stockage</replaceable></term>
      <listitem>
       <para>
        Le nom d'un paramètre de stockage de la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">valeur</replaceable></term>
      <listitem>
       <para>
        La nouvelle valeur d'un paramètre de stockage de la table. Cela peut
        être un nombre ou un mot suivant le paramètre.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">table_parent</replaceable></term>
      <listitem>
       <para>
        Une table parent à associer ou dissocier de cette table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable
	class="parameter">nouveau_propriétaire</replaceable></term>
      <listitem>
       <para>
        Le nom du nouveau propriétaire de la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable
	class="parameter">nouvel_espacelogique</replaceable></term>
      <listitem>
       <para>
        Le nom du tablespace où déplacer la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable
	class="parameter">nouveau_schema</replaceable></term>
      <listitem>
       <para>
        Le nom du schéma où déplacer la table.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

   <para>
    Le mot clé <literal>COLUMN</literal> n'est pas nécessaire. Il peut
    être omis.
   </para>

   <para>
    Quand une colonne est ajoutée avec <literal>ADD COLUMN</literal>, toutes
    les lignes existantes de cette table sont initialisées avec la valeur par
    défaut de la colonne (NULL si aucune clause <literal>DEFAULT</literal> n'a été
    définie).
   </para>

   <para>
    Ajouter une colonne avec une valeur par défaut différente de NULL ou
    modifier le type d'une colonne existante requiert que la table entière et
    les index soient réécrits.
    Il existe une exception : si la clause  <literal>USING</literal> ne change pas le
    contenu de la colonne et que l'ancien type est soit transformable de façon binaire 
    dans le nouveau type, ou bien un domaine sans contrainte reposant sur le nouveau type, alors
    il n'est pas nécessaire de réécrire la table, mais tous les index sur les colonnes affectées
    doivent quand même être reconstruits. Le fait d'ajouter ou de supprimer une colonne système 
    <literal>oid</literal> nécessite également une réécriture complète de la table. Les reconstructions 
    de table et/ou d'index peuvent prendre un temps significatif pour une grosse table, et peuvent nécessiter
    temporairement de doubler l'espace disque utilisé.
   </para>

   <para>
    Ajouter une contrainte <literal>CHECK</literal> ou <literal>NOT NULL</literal> requiert
    de parcourir la table pour vérifier que les lignes existantes respectent
    cette contrainte.
   </para>

   <para>
    La raison principale de la possibilité de spécifier des changements multiples
    à l'aide d'une seule commande <command>ALTER TABLE</command> est la combinaison
    en une seule passe sur la table de plusieurs parcours et réécritures.
   </para>

   <para>
    La forme <literal>DROP COLUMN</literal> ne supprime pas physiquement la 
    colonne, mais la rend simplement invisible aux opérations SQL.
    Par la suite, les ordres d'insertion et de mise à jour sur cette table 
    stockent une valeur NULL pour la colonne.
    Ainsi, supprimer une colonne ne réduit pas immédiatement la taille de la
    table sur disque car l'espace occupé par la colonne n'est pas 
    récupéré. Cet espace est récupéré au fur et à mesure des 
    mises à jour des lignes de la table. (Ceci n'est pas vrai quand on supprime
    la colonne système <literal>oid</literal>&nbsp;; ceci est fait avec une réécriture
    immédiate de la table.)
   </para>
    
   <para>
     Pour forcer une réécriture immédiate de la table, vous pouvez utiliser
    <link linkend="sql-vacuum">VACUUM FULL</link>, <xref linkend="sql-cluster"/>
    ou bien une des formes de la commande ALTER TABLE qui force une réécriture. Ceci ne cause pas de
    modifications visibles dans la table, mais élimine des données qui ne sont plus utiles.
   </para>

   <para>
    L'option <literal>USING</literal> de <literal>SET DATA TYPE</literal> peut en fait
    utiliser une expression qui implique d'anciennes valeurs de la
    ligne&nbsp;; c'est-à-dire qu'il peut être fait référence aussi bien aux autres colonnes 
    qu'à celle en cours de conversion. Cela permet d'effectuer des conversions très
    générales à l'aide de la syntaxe <literal>SET DATA TYPE</literal>. À cause de cette
    flexibilité, l'expression <literal>USING</literal> n'est pas appliquée à la
    valeur par défaut de la colonne (s'il y en a une)&nbsp;: le résultat pourrait
    ne pas être une expression constante requise pour une valeur par défaut.
    Lorsqu'il n'existe pas de transtypage, implicite ou
    d'affectation, entre les deux types, <literal>SET DATA TYPE</literal> peut
    échouer à convertir la valeur par défaut alors même que la clause
    <literal>USING</literal> est spécifiée. Dans de ce cas, il convient de supprimer
    valeur par défaut avec <literal>DROP DEFAULT</literal>, d'exécuter
    <literal>ALTER TYPE</literal> et enfin d'utiliser <literal>SET DEFAULT</literal>
    pour ajouter une valeur par défaut appropriée. Des considérations similaires s'appliquent aux
    index et contraintes qui impliquent la colonne.
   </para>

   <para>
    Si une table est héritée, il n'est pas possible d'ajouter, de renommer ou
    de modifier le type d'une colonne ou de renommer une contrainte héritée
    dans la table parent sans le faire aussi pour ses descendantes. De ce fait,
    la commande <command>ALTER TABLE ONLY</command> est rejetée. Cela assure
    que les colonnes des tables descendantes correspondent toujours à celles de
    la table parent.
   </para>

   <para>
    Un appel récursif à <literal>DROP COLUMN</literal> supprime la colonne
    d'une table descendante si et seulement si cette table n'hérite 
    pas cette colonne d'une autre table et que la colonne n'y a pas été
    définie indépendamment de tout héritage.
    Une suppression non récursive de colonne
    (<command>ALTER TABLE ONLY ... DROP COLUMN</command>) ne supprime
    jamais les colonnes descendantes&nbsp;; elles sont marquées comme définies 
    de manière indépendante, plutôt qu'héritées.
   </para>

   <para>
    Les actions <literal>TRIGGER</literal>, <literal>CLUSTER</literal>, <literal>OWNER</literal>,
    et <literal>TABLESPACE</literal> ne sont jamais propagées aux tables
    descendantes&nbsp;; c'est-à-dire qu'elles agissent comme si
    <literal>ONLY</literal> est spécifié.
	Seules les contraintes <literal>CHECK</literal> sont propagées,
	et uniquement si elles ne sont pas marquées <literal>NO INHERIT</literal>.
   </para>

   <para>
    Tout changement sur une table du catalogue système est interdit.
   </para>

   <para>
    Voir la commande <xref linkend="sql-createtable"/> pour avoir une 
    description plus complète des paramètres valides.
    <xref linkend="ddl"/> fournit de plus amples informations sur l'héritage.
   </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Ajouter une colonne de type <type>varchar</type> à une table&nbsp;:
<programlisting>ALTER TABLE distributeurs ADD COLUMN adresse varchar(30);
</programlisting>
  </para>

  <para>
   Supprimer une colonne de table&nbsp;:
<programlisting>ALTER TABLE distributeurs DROP COLUMN adresse RESTRICT;
</programlisting>
  </para>

  <para>
   Changer les types de deux colonnes en une seule opération&nbsp;:
<programlisting>ALTER TABLE distributeurs
    ALTER COLUMN adresse TYPE varchar(80),
    ALTER COLUMN nom TYPE varchar(100);
</programlisting>
  </para>

  <para>
   Convertir une colonne de type integer (entier) contenant une estampille
   temporelle UNIX en <type>timestamp with time zone</type> à l'aide d'une clause
   <literal>USING</literal>&nbsp;:
<programlisting>ALTER TABLE truc
    ALTER COLUMN truc_timestamp SET DATA TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + truc_timestamp * interval '1 second';
</programlisting>
  </para>

  <para>
   La même, quand la colonne a une expression par défaut qui ne sera pas
   convertie automatiquement vers le nouveau type de données&nbsp;:
<programlisting>ALTER TABLE truc
    ALTER COLUMN truc_timestamp DROP DEFAULT,
    ALTER COLUMN truc_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + truc_timestamp * interval '1 second',
    ALTER COLUMN truc_timestamp SET DEFAULT now();
</programlisting>
  </para>

  <para>
   Renommer une colonne existante&nbsp;:
<programlisting>ALTER TABLE distributeurs RENAME COLUMN adresse TO ville;
</programlisting>
  </para>

  <para>
   Renommer une table existante&nbsp;:
<programlisting>ALTER TABLE distributeurs RENAME TO fournisseurs;
</programlisting>
  </para>

  <para>
   Pour renommer une contrainte existante&nbsp;:
<programlisting>
ALTER TABLE distributeurs RENAME CONSTRAINT verif_cp TO verif_code_postal;
</programlisting>
  </para>

  <para>
   Ajouter une contrainte NOT NULL à une colonne&nbsp;:
<programlisting>ALTER TABLE distributeurs ALTER COLUMN rue SET NOT NULL;
</programlisting>
   Supprimer la contrainte NOT NULL d'une colonne&nbsp;:
<programlisting>ALTER TABLE distributeurs ALTER COLUMN rue DROP NOT NULL;
</programlisting>
  </para>

  <para> 
   Ajouter une contrainte de vérification sur une table et tous ses
   enfants&nbsp;:
<programlisting>ALTER TABLE distributeurs ADD CONSTRAINT verif_cp CHECK (char_length(code_postal) = 5);
</programlisting>
  </para>

  <para>
   Pour ajouter une contrainte <literal>CHECK</literal> à une table, mais pas à ses filles&nbsp;:
<programlisting>
ALTER TABLE distributeurs ADD CONSTRAINT verif_cp CHECK (char_length(code_postal) = 5) NO INHERIT;
</programlisting>
   (The check constraint will not be inherited by future children, either.)
  </para>

  <para>
   Supprimer une contrainte de vérification d'une table et de toutes ses
   tables filles&nbsp;:
<programlisting>ALTER TABLE distributeurs DROP CONSTRAINT verif_cp;
</programlisting>
  </para>

  <para>
   Pour enlever une contrainte check d'une table seule (pas sur ses enfants)
<programlisting>
ALTER TABLE ONLY distributeurs DROP CONSTRAINT verif_cp;
</programlisting>
   (La contrainte check reste en place pour toutes les tables filles).
  </para>

  <para> 
   Ajouter une contrainte de clé étrangère à une table&nbsp;:
<programlisting>ALTER TABLE distributeurs ADD CONSTRAINT dist_fk FOREIGN KEY (adresse) REFERENCES adresses (adresse);
</programlisting>
  </para>

  <para> 
   Ajouter une contrainte unique (multicolonnes) à une table&nbsp;:
<programlisting>ALTER TABLE distributeurs ADD CONSTRAINT dist_id_codepostal_key UNIQUE (dist_id, code_postal);
</programlisting>
  </para>

  <para> 
   Ajouter une clé primaire nommée automatiquement à une table.
   Une table ne peut jamais avoir qu'une seule clé primaire.
<programlisting>ALTER TABLE distributeurs ADD PRIMARY KEY (dist_id);
</programlisting>
  </para>
  
  <para> 
   Déplacer une table dans un tablespace différent&nbsp;:
<programlisting>ALTER TABLE distributeurs SET TABLESPACE tablespacerapide;
</programlisting>
  </para>

  <para> 
   Déplacer une table dans un schéma différent&nbsp;:
<programlisting>ALTER TABLE mon_schema.distributeurs SET SCHEMA votre_schema;
</programlisting>
  </para>

  <para>
    Recréer une contrainte de clé primaire sans bloquer les mises à jour 
    pendant la reconstruction de l'index&nbsp;:
<programlisting>
CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributeurs (dist_id);
ALTER TABLE distributeurs DROP CONSTRAINT distributeurs_pkey,
    ADD CONSTRAINT distributeurs_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;
</programlisting>
  </para>

 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Les formes <literal>ADD</literal> (without <literal>USING INDEX</literal>), <literal>DROP</literal>,
   <literal>SET DEFAULT</literal> et <literal>SET DATA TYPE</literal>
   (sans <literal>USING</literal>) se conforment au standard SQL. Les autres
   formes sont des
   extensions <productname>PostgreSQL</productname>, tout comme
   la possibilité de spécifier plusieurs manipulations en une seule commande
   <command>ALTER TABLE</command>.
  </para>

  <para>
   <command>ALTER TABLE DROP COLUMN</command> peut être utilisé pour supprimer
   la seule colonne d'une table, laissant une table dépourvue de colonne.
   C'est une extension au SQL, qui n'autorise pas les tables sans colonne.
  </para>
 </refsect1>

 <refsect1>
  <title>See Also</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createtable"/></member>
  </simplelist>
 </refsect1>
</refentry>
