<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060619 -->

<refentry id="sql-explain">
 <refmeta>
  <refentrytitle>EXPLAIN</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>EXPLAIN</refname>
  <refpurpose>Afficher le plan d'exécution d'une instruction</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>EXPLAIN [ ( <replaceable class="parameter">option</replaceable> [, ...] ) ] <replaceable class="parameter">instruction</replaceable>
EXPLAIN [ ANALYZE ] [ VERBOSE ] <replaceable class="parameter">instruction</replaceable>

<phrase>où <replaceable class="parameter">option</replaceable> est&nbsp;:</phrase>

    ANALYZE [ <replaceable class="parameter">boolean</replaceable> ]
    VERBOSE [ <replaceable class="parameter">boolean</replaceable> ]
    COSTS [ <replaceable class="parameter">boolean</replaceable> ]
    BUFFERS [ <replaceable class="parameter">boolean</replaceable> ]
    TIMING [ <replaceable class="parameter">boolean</replaceable> ]
    FORMAT { TEXT | XML | JSON | YAML }

</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-explain">
   <primary>EXPLAIN</primary>
  </indexterm>

  <indexterm zone="sql-explain">
   <primary>instructions préparées</primary>
   <secondary>afficher le plan de requête</secondary>
  </indexterm>

  <indexterm zone="sql-explain">
   <primary>curseur</primary>
   <secondary>afficher le plan de requête</secondary>
  </indexterm>

  <para>
   Cette commande affiche le plan d'exécution que l'optimiseur
   de <productname>PostgreSQL</productname> engendre pour l'instruction fournie. 
   Le plan d'exécution décrit le parcours de la (des) table(s) utilisée(s) dans
   la requête &mdash; parcours séquentiel, parcours d'index, etc. &mdash;.
   Si plusieurs tables sont référencées, il présente également les algorithmes
   de jointures utilisés pour rassembler les lignes issues des différentes
   tables.
  </para>

  <para>
   La partie la plus importante de l'affichage concerne l'affichage des coûts 
   estimés d'exécution. Ils représentent l'estimation faite par le planificateur
   des temps d'exécution de la requête (mesuré en une unité de coût arbitraire bien
   que conventionnellement ce sont des lectures de page disque).
   Deux nombres sont affichés&nbsp;: le coût de démarrage, écoulé avant que la première
   ligne soit renvoyée, et le coût d'exécution total, nécessaire au renvoi
   de toutes les lignes.
   Pour la plupart des requêtes, le coût qui importe est celui d'exécution totale. 
   Mais dans certains cas, tel que pour une sous-requête dans la clause
   <literal>EXISTS</literal>, le planificateur choisira le coût de démarrage le 
   plus court, et non celui d'exécution totale (car, de toute façon, l'exécuteur
   s'arrête après la récupération d'une ligne).
   De même, lors de la limitation des résultats à retourner par une
   clause <literal>LIMIT</literal>, la planificateur effectue une interpolation
   entre les deux coûts limites pour choisir le plan réellement le moins coûteux.
  </para>

  <para>
   L'option <literal>ANALYZE</literal> impose l'exécution de la requête en plus de 
   sa planification. De ce fait, les statistiques d'exécution réelle sont ajoutées
   à l'affichage, en incluant le temps total écoulé à chaque nœud du plan (en
   millisecondes) et le nombre total de lignes renvoyées.
   C'est utile pour vérifier la véracité des informations fournies par le planificateur.
  </para>

  <important>
   <para>
    Il ne faut pas oublier que l'instruction est réellement exécutée avec l'option
    <literal>ANALYZE</literal>. 
    Bien qu'<command>EXPLAIN</command> inhibe l'affichage des retours d'une
    commande <command>SELECT</command>, les autres effets 
    de l'instruction sont présents. Si <command>EXPLAIN ANALYZE</command> 
    doit être utilisé sur une instruction
    <command>INSERT</command>, <command>UPDATE</command>,
    <command>DELETE</command> <command>CREATE TABLE AS</command> ou
    <command>EXECUTE</command> sans que la commande
    n'affecte les données, l'approche suivante peut être envisagée&nbsp;:
<programlisting>BEGIN;
EXPLAIN ANALYZE ...;
ROLLBACK;
</programlisting>
   </para>

  <para>
   Seules les options <literal>ANALYZE</literal> et <literal>VERBOSE</literal>
   peuvent être utilisées et dans cet ordre seulement si la liste d'options
   entre parenthèses n'est pas utilisé. Avant
   <productname>PostgreSQL</productname> 9.0, la seule syntaxe supportée était
   celle sans parenthèses. Les nouvelles options ne seront supportées que par
   la nouvelle syntaxe, celle avec les parenthèses.
  </para>
  </important>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><literal>ANALYZE</literal></term>
    <listitem>
     <para>
      Exécute la commande et affiche les temps d'exécution réels et d'autres
      statistiques. Ce paramètre est par défaut à <literal>FALSE</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>VERBOSE</literal></term>
    <listitem>
     <para>
      Affiche des informations supplémentaires sur le plan. Cela inclut la
      liste des colonnes en sortie pour chaque n&oelig;ud du plan, les noms
      des tables et fonctions avec le nom du schéma, les labels des variables
      dans les expressions avec des alias de tables et le nom de chaque trigger
      pour lesquels les statistiques sont affichées. Ce paramètre est par
      défaut à <literal>FALSE</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>COSTS</literal></term>
    <listitem>
     <para>
      Inclut des informations sur le coût estimé au démarrage et au total de
      chaque n&oelig;ud du plan, ainsi que le nombre estimé de lignes et la
      largeur estimée de chaque ligne. Ce paramètre est par défaut à
      <literal>TRUE</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>BUFFERS</literal></term>
    <listitem>
     <para>
       Inclut des informations sur l'utilisation des tampons. Spécifiquement,
       inclut le nombre de blocs partagés lus dans la cache, lus en dehors du
       cache, modifiés et écrits, le nombre de blocs locaux lus dans le cache,
       lus en dehors du cache, modifiés, et écrits, et le nombre de blocs
       temporaires lus et écrits.
       Le terme <emphasis>hit</emphasis> signifie que la lecture a été évitée
       car le bloc se trouvait déjà dans le cache. Les blocs partagés contiennent
       les données de tables et index standards&nbsp;; les blocs locaux
       contiennent les tables et index temporaires&nbsp;; les blocs temporaires
       contiennent les données de travail à court terme, comme les tris, les
       hachages, les nœuds Materialize, et des cas similaires. Le nombre de blocs
       modifiés (<emphasis>dirtied</emphasis>) indique le nombre de blocs
       précédemment propres qui ont été modifiés par cette requeête&nbsp;; le
       nombre de blocs écrits (<emphasis>written</emphasis>) indique le nombre
       de blocs déjà modifiés qui a été enlevé du cache pour être écrit sur disque
       lors de l'exécution de cette requête. Le nombre de blocs affichés pour un
       nœud de niveau supérieur inclut ceux utilisés par tous ses enfants. Dans
       le format texte, seules les valeurs différentes de zéro sont affichées.
       Ce paramètre peut seulement être utilisé si <literal>ANALYZE</literal>
       est aussi activé. Sa valeur par défaut est <literal>FALSE</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TIMING</literal></term>
    <listitem>
     <para>
      Inclut le temps réel de démarrage et le temps réel passé dans le nœud en
      sortie. La surcharge de la lecture répétée de l'horloge système peut
      ralentir la requête de façon significative sur certains systèmes, et donc
      il est utile de pouvoir configurer ce paramètre à <literal>FALSE</literal>
      quand seuls le décompte réel des lignes est nécessaire. Ce paramètre
      peut seulement être utilisé quand l'option <literal>ANALYZE</literal> est
      aussi activée. La valeur par défaut est <literal>TRUE</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORMAT</literal></term>
    <listitem>
     <para>
      Indique le format de sortie. Il peut valoir TEXT, XML, JSON ou YAML.
      Toutes les sorties contiennent les mêmes informations, mais les
      programmes pourront plus facilement traiter les sorties autres que TEXT.
      Ce paramètre est par défaut à <literal>TEXT</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">boolean</replaceable></term>
    <listitem>
     <para>
      Spécifie si l'option sélectionnée doit être activée ou désactivée. Vous
      pouvez écrire <literal>TRUE</literal>, <literal>ON</literal> ou
      <literal>1</literal> pour activer l'option, et <literal>FALSE</literal>,
      <literal>OFF</literal> ou <literal>0</literal> pour la désactiver. La
      valeur de type <replaceable class="parameter">boolean</replaceable> peut
      aussi être omise, auquel cas la valeur sera <literal>TRUE</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">instruction</replaceable></term>
    <listitem>
     <para>
      Toute instruction <command>SELECT</command>, <command>INSERT</command>,
      <command>UPDATE</command>, <command>DELETE</command>, <command>VALUES</command>
      <command>EXECUTE</command>, <command>DECLARE</command> ou
      <command>CREATE TABLE AS</command> dont le plan
      d'exécution est souhaité.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Sorties</title>
 
   <para>
    La sortie de la commande est une description textuelle du plan
    sélectionné pour la <replaceable class="parameter">requête</replaceable>,
    annotée en option des statistiques d'exécution.
    <xref linkend="using-explain"/> décrit les informations fournies.
   </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>
 
   <para>
    Pour permettre au planificateur de requêtes de
    <productname>PostgreSQL</productname> de prendre des décisions en
    étant raisonnablement informé pour l'optimisation des requêtes, les
    données du catalogue <link
    linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link>
    doivent être à jour pour toutes les tables utilisées dans la requête.
    Habituellement, le <link linkend="autovacuum">démon autovacuum</link>
    s'en chargera automatiquement. Mais si une table a eu récemment des
    changements importants dans son contenu, vous pourriez avoir besoin de
    lanver un <xref linkend="sql-analyze"/> manuel plutôt que d'attendre
    que l'autovacuum s'occupe des modifications.
   </para>
 
   <para>
    Pour mesurer le coût d'exécution de chaque nœud dans le plan d'exécution,
    l'implémentation actuelle de la commande <command>EXPLAIN
    ANALYZE</command> ajoute une surcharge de profilage à l'exécution de la
    requête. En résultat, exécuter <command>EXPLAIN ANALYZE</command> sur une
    requête peut parfois prendre un temps significativement plus long que
    l'exécution de la requête. La durée supplémentaire dépend de la nature
    de la requête ainsi que de la plateforme utilisée. Le pire des cas survient
    pour les nœuds du plan nécessitant en eux-même peu de durée d'exécution par
    exécution et sur les machines disposant d'appels systèmes relativement
    lents pour obtenir l'heure du jour.
   </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Afficher le plan d'une requête simple sur une table d'une seule
   colonne de type <type>integer</type> et 10000 lignes&nbsp;:

<programlisting>EXPLAIN SELECT * FROM foo;

                       QUERY PLAN
---------------------------------------------------------
 Seq Scan on foo  (cost=0.00..155.00 rows=10000 width=4)
(1 row)
</programlisting>
  </para>

  <para>
   Voici le même plan, mais formaté avec JSON&nbsp;:
<programlisting>EXPLAIN (FORMAT JSON) SELECT * FROM foo;
           QUERY PLAN           
--------------------------------
 [                             +
   {                           +
     "Plan": {                 +
       "Node Type": "Seq Scan",+
       "Relation Name": "foo", +
       "Alias": "foo",         +
       "Startup Cost": 0.00,   +
       "Total Cost": 155.00,   +
       "Plan Rows": 10000,     +
       "Plan Width": 4         +
     }                         +
   }                           +
 ]
(1 row)
</programlisting>
  </para>

  <para>
   S'il existe un index et que la requête contient une condition
   <literal>WHERE</literal> indexable, <command>EXPLAIN</command> peut
   afficher un plan différent&nbsp;:

<programlisting>EXPLAIN SELECT * FROM foo WHERE i = 4;

                         QUERY PLAN
--------------------------------------------------------------
 Index Scan using fi on foo  (cost=0.00..5.98 rows=1 width=4)
   Index Cond: (i = 4)
(2 rows)
</programlisting>
  </para>

  <para>
   Voici le même plan, mais formaté avec YAML&nbsp;:
<programlisting>
EXPLAIN (FORMAT YAML) SELECT * FROM foo WHERE i='4';
          QUERY PLAN           
-------------------------------
 - Plan:                      +
     Node Type: "Index Scan"  +
     Scan Direction: "Forward"+
     Index Name: "fi"         +
     Relation Name: "foo"     +
     Alias: "foo"             +
     Startup Cost: 0.00       +
     Total Cost: 5.98         +
     Plan Rows: 1             +
     Plan Width: 4            +
     Index Cond: "(i = 4)"
(1 row)
</programlisting>

    L'obtention du format XML est laissé en exercice au lecteur.
  </para>
  <para>
   Voici le même plan avec les coûts supprimés&nbsp;:

<programlisting>
EXPLAIN (COSTS FALSE) SELECT * FROM foo WHERE i = 4;

        QUERY PLAN
----------------------------
 Index Scan using fi on foo
   Index Cond: (i = 4)
(2 rows)
</programlisting>
  </para>

  <para>
   Exemple de plan de requête pour une requête utilisant une
   fonction d'agrégat&nbsp;:

<programlisting>EXPLAIN SELECT sum(i) FROM foo WHERE i &lt; 10;

                             QUERY PLAN
---------------------------------------------------------------------
 Aggregate  (cost=23.93..23.93 rows=1 width=4)
   -&gt;  Index Scan using fi on foo  (cost=0.00..23.92 rows=6 width=4)
         Index Cond: (i &lt; 10)
(3 rows)
</programlisting>
  </para>

  <para>
   Exemple d'utilisation de <command>EXPLAIN EXECUTE</command> pour
   afficher le plan d'exécution d'une requête préparée&nbsp;:

<programlisting>PREPARE query(int, int) AS SELECT sum(bar) FROM test
    WHERE id &gt; $1 AND id &lt; $2
    GROUP BY foo;

EXPLAIN ANALYZE EXECUTE query(100, 200);

                                                       QUERY PLAN
-------------------------------------------------------------------------------------
 HashAggregate  (cost=39.53..39.53 rows=1 width=8) (actual time=0.661..0.672 rows=7 loops=1)
   -&gt;  Index Scan using test_pkey on test  (cost=0.00..32.97 rows=1311 width=8) (actual time=0.050..0.395 rows=99 loops=1)
         Index Cond: ((id &gt; $1) AND (id &lt; $2))
 Total runtime: 0.851 ms
(4 rows)
</programlisting>
  </para>
  <para>
   Il est évident que les nombres présentés ici dépendent du contenu
   effectif des tables impliquées. 
   De plus, les nombres, et la stratégie sélectionnée elle-même,
   peuvent différer en fonction de la version de <productname>PostgreSQL</productname>
   du fait des améliorations apportées au planificateur.
   Il faut également savoir que la commande <command>ANALYZE</command> calcule les statistiques
   des données à partir d'extraits aléatoires&nbsp;; il est de ce fait
   possible que les coûts estimés soient modifiés après l'exécution
   de cette commande, alors même la distribution réelle des données
   dans la table n'a pas changé.
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   L'instruction <command>EXPLAIN</command> n'est pas définie dans le
   standard SQL.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-analyze"/></member>
  </simplelist>
 </refsect1>
</refentry>
