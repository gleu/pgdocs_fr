<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060619 -->

<refentry id="sql-declare">
 <refmeta>
  <refentrytitle id="sql-declare-title">DECLARE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>DECLARE</refname>
  <refpurpose>Définir un curseur</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>DECLARE <replaceable class="parameter">nom</replaceable> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ]
    CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="parameter">requête</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-declare">
   <primary>DECLARE</primary>
  </indexterm>

  <indexterm zone="sql-declare">
   <primary>curseur</primary>
   <secondary>DECLARE</secondary>
  </indexterm>

  <para>
   <command>DECLARE</command> permet à un utilisateur de créer des curseurs.
   Ils peuvent être utilisés pour récupérer un petit nombre de lignes à la
   fois à partir d'une requête plus importante.
   Après la création du curseur, les lignes sont récupérées en utilisant
   <xref linkend="sql-fetch" endterm="sql-fetch-title"/>.
  </para>

  <note>
   <para>
    Cette page décrit l'utilisation des curseurs au niveau de la commande SQL.
    Si vous voulez utiliser des curseurs dans une fonction
    <application>PL/pgSQL</application>, les règles sont différentes &mdash;
    voir <xref linkend="plpgsql-cursors"/>.
   </para>
  </note>

 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
      Le nom du curseur à créer.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>BINARY</literal></term>
    <listitem>
     <para>
      Le curseur retourne les données au format binaire.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INSENSITIVE</literal></term>
    <listitem>
     <para>
      Les données récupérées à partir du curseur ne doivent pas
      être affectées par les mises à jour des tables concernées par le curseur
      qui surviennent une fois que ce dernier est créé. Dans
      <productname>PostgreSQL</productname>, c'est le comportement par
      défaut&nbsp;; ce mot-clé n'a aucun effet. Il est seulement accepté pour
      des raisons de compatibilité avec le standard SQL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SCROLL</literal></term>
    <term><literal>NO SCROLL</literal></term>
    <listitem>
     <para>
      <literal>SCROLL</literal> indique une utilisation possible du curseur
      pour récupérer des lignes de façon non séquentielle (c'est-à-dire en remontant
      la liste). En fonction de la complexité du plan d'exécution de la requête,
      <literal>SCROLL</literal> peut induire des pertes de
      performance sur le temps d'exécution de la requête.
	  <literal>NO SCROLL</literal> indique que le curseur ne peut pas être utilisé pour
      récupérer des lignes de façon non séquentielle. La valeur par
      défaut autorise la non-séquentialité du curseur dans certains cas&nbsp;; ce n'est pas la
      même chose que de spécifier <literal>SCROLL</literal>.
	  Voir <xref linkend="sql-declare-notes" endterm="sql-declare-notes-title"/> pour les
      détails.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH HOLD</literal></term>
    <term><literal>WITHOUT HOLD</literal></term>
    <listitem>
     <para>
      <literal>WITH HOLD</literal> (NDT&nbsp;: persistant) indique une utilisation possible
	  du curseur après la validation de la transaction qui l'a créé. 
      <literal>WITHOUT HOLD</literal> (NDT&nbsp;: volatil) interdit l'utilisation du curseur
      en dehors de la transaction qui l'a créé. 
      <literal>WITHOUT HOLD</literal> est la valeur par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">requête</replaceable></term>
    <listitem>
     <para>
      A <xref linkend="sql-select" endterm="sql-select-title"/> or
      <xref linkend="sql-values" endterm="sql-values-title"/> command
      which will provide the rows to be returned by the cursor.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Les mots clés <literal>BINARY</literal>, <literal>INSENSITIVE</literal> et
   <literal>SCROLL</literal> peuvent apparaître dans n'importe quel ordre.
  </para>
 </refsect1>

 <refsect1 id="sql-declare-notes">
  <title id="sql-declare-notes-title">Notes</title>

  <para>
   Les curseurs normaux renvoient les données au format texte, le même que
   produirait un <command>SELECT</command>. L'option <literal>BINARY</literal>
   spécifie que le curseur doit renvoyer les données au format binaire. Ceci
   réduit les efforts de conversion pour le serveur et le client, au coût d'un
   effort particulier de développement pour la gestion des formats de données
   binaires dépendants des plateformes. Comme exemple, si une requête
   renvoie une valeur de un dans une colonne de type integer, vous obtiendrez
   une chaîne <literal>1</literal> avec un curseur par défaut. Avec un curseur
   binaire, vous obtiendrez un champ sur quatre octet contenant la
   représentation interne de la valeur (dans l'ordre big-endian).
  </para>

  <para>
   Les curseurs binaires doivent être utilisés en faisant très attention.
   Beaucoup d'applications, incluant <application>psql</application>, ne sont
   pas préparées à gérer des curseurs binaires et s'attendent à ce que les
   données reviennent dans le format texte.
  </para>

  <note>
   <para>
    Quand l'application cliente utilise le protocole des <quote>requêtes
    étendues</quote> pour exécuter la commande <command>FETCH</command>, le
    message Bind du protocole spécifie si les données sont à récupérer au
    format texte ou binaire. Ce choix surcharge la façon dont le curseur est
    défini. Le concept de curseur binaire est donc obsolète lors de l'utilisation
    du protocole des requêtes étendues &mdash; tout curseur peut être traité soit
    en texte soit en binaire.
   </para>
  </note>

   <para>
    Si la clause <literal>WITH HOLD</literal> n'est pas précisée, le curseur créé par
    cette commande ne peut être utilisé qu'à l'intérieur d'une transaction.
    Ainsi, <command>DECLARE</command> sans <literal>WITH HOLD</literal> est inutile à
    l'extérieur d'un bloc de transaction&nbsp;: le curseur survivrait seulement
    jusqu'à la fin de l'instruction. <productname>PostgreSQL</productname> 
    rapporte donc une erreur si cette commande 
    est utilisée en dehors d'un bloc de transactions.
	On utilise <xref linkend="sql-begin" endterm="sql-begin-title"/> et
	<xref linkend="sql-commit" endterm="sql-commit-title"/> (ou
	<xref linkend="sql-rollback" endterm="sql-rollback-title"/>) pour définir un bloc de transaction.
   </para>
   <para>
    Si la clause <literal>WITH HOLD</literal> est précisée, et que la 
    transaction qui a créé le curseur est validée, ce dernier reste
    accessible par les transactions ultérieures de la session. 
    Au contraire, si la transaction initiale est annulée, le curseur est supprimé.
    Un curseur créé avec la clause <literal>WITH HOLD</literal> est fermé
    soit par un appel explicite à la commande <command>CLOSE</command>, soit
    par la fin de la session.
    Dans l'implantation actuelle, les lignes représentées par un
    curseur persistant (<literal>WITH HOLD</literal>) sont copiées dans un fichier 
    temporaire ou en mémoire afin de garantir leur disponibilité pour les transactions
    suivantes.
   </para>

   <para>
    <literal>WITH HOLD</literal> n'est pas utilisable quand la requête contient
    déjà <literal>FOR UPDATE</literal> ou <literal>FOR SHARE</literal>.
   </para>

   <para>
    L'option <literal>SCROLL</literal> est nécessaire à la définition de 
    curseurs utilisés en récupération remontante (retour dans la 
    liste des résultats, backward fetch), comme précisé par le
    standard SQL. Néanmoins, pour des raisons de compatibilité 
    avec les versions antérieures, <productname>PostgreSQL</productname> 
    autorise les récupérations remontantes sans que l'option
    <literal>SCROLL</literal> ne soit précisé, sous réserve que le plan
    d'exécution du curseur soit suffisamment simple pour être géré
    sans surcharge. Toutefois, il est fortement conseillé aux développeurs
    d'application ne pas utiliser les récupérations remontantes avec
    des curseurs qui n'ont pas été créés avec l'option <literal>SCROLL</literal>.
    Si <literal>NO SCROLL</literal> est spécifié, les récupérations remontantes
    sont toujours dévalidées.
   </para>

   <para>
    Les parcours inverses sont aussi interdits lorsque la requête inclut les
    clauses <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal>&nbsp;;
    donc <literal>SCROLL</literal> peut ne pas être indiqué dans ce cas.
   </para>

   <caution>
    <para>
     Les curseurs scrollables et avec l'option <literal>WITH HOLD</literal>
     pourraient donner des résultats inattendues s'ils font appel à des
     fonctions volatiles (voir <xref linkend="xfunc-volatility"/>). Quand
     une ligne précédemment récupérée est de nouveau récupérée, la fonction
     pourrait être ré-exécutée, amenant peut-être des résultats différentes
     de la première exécution. Un contournement est de déclarer le curseur
     <literal>WITH HOLD</literal> et de valider la transaction avant de lire
     toute ligne de ce curseur. Cela forcera la sortie entière du cuseur à
     être matérialisée dans un stockage temporaire, pour que les fonctions
     volatiles soient exécutées exactement une fois pour chaque ligne.
    </para>
   </caution>

   <para>
    Si la requête du curseur inclut les clauses <literal>FOR UPDATE</literal>
    ou <literal>FOR SHARE</literal>, alors les lignes renvoyées sont verrouillées
    au moment où elles sont récupérées, de la même façon qu'une commande
    <xref linkend="sql-select" endterm="sql-select-title"/> standard avec ces
    options.
    De plus, les lignes renvoyées seront les versions les plus à jour&nbsp;; du
    coup, ces options fournissent l'équivalent de ce que le standard SQL appelle
    un <quote>curseur sensible</quote>. (Indiquer <literal>INSENSITIVE</literal>
    avec soit <literal>FOR UPDATE</literal> soit <literal>FOR SHARE</literal>
    est une erreur.)
   </para>

   <caution>
    <para>
     Il est généralement recommandé d'utiliser <literal>FOR UPDATE</literal> si
     le curseur doit être utilisé avec  <command>UPDATE ... WHERE CURRENT
     OF</command> ou <command>DELETE ... WHERE CURRENT OF</command>. Utiliser
     <literal>FOR UPDATE</literal> empêche les autres sessions de modifier les
     lignes entre le moment où elles sont récupérées et celui où elles sont
     modifiées. Sans <literal>FOR UPDATE</literal>, une commande <literal>WHERE
     CURRENT OF</literal> suivante n'aura pas d'effet si la ligne a été modifiée
     depuis la création du curseur.
    </para>

    <para>
     Une autre raison d'utiliser <literal>FOR UPDATE</literal> est que, sans ce
     dernier, un appel suivant à <literal>WHERE CURRENT OF</literal> pourrait
     échouer si la requête curseur ne répond pas aux règles du standard SQL
     d'être <quote>mise à jour simplement</quote> (en particulier, le curseur
     doit référencer une seule table et ne pas utiliser de regroupement ou
     de tri comme <literal>ORDER BY</literal>). Les curseurs qui ne peuvent pas
     être mis à jour pourraient fonctionner, ou pas, suivant les détails du plan
     choisi&nbsp;; dans le pire des cas, une application pourrait fonctionner
     lors des tests puis échouer en production.
    </para>

    <para>
     La principale raison de ne pas utiliser <literal>FOR UPDATE</literal> avec
     <literal>WHERE CURRENT OF</literal> est si vous avez besoin que le curseur
     soit déplaçable ou qu'il soit insensible aux mises à jour suivantes
     (c'est-à-dire qu'il continue à afficher les anciennes données). Si c'est
     un prérequis, faites très attention aux problèmes expliqués ci-dessus.
    </para>
   </caution>

   <para>
    Le standard SQL ne mentionne les curseurs que pour le
    <acronym>SQL</acronym> embarqué. <productname>PostgreSQL</productname>
    n'implante pas l'instruction
    <command>OPEN</command> pour les curseurs&nbsp;; un curseur est considéré
    ouvert à sa déclaration. Néanmoins, <application>ECPG</application>, le
    préprocesseur de SQL embarqué pour <productname>PostgreSQL</productname>,
    supporte les conventions du standard SQL relatives aux curseurs, dont celles
    utilisant les instructions <command>DECLARE</command> et
    <command>OPEN</command>.
   </para>

   <para>
    Vous pouvez voir tous les curseurs disponibles en exécutant une requête sur
    la vue système <link
    linkend="view-pg-cursors"><structname>pg_cursors</structname></link>.
   </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Déclarer un curseur&nbsp;:
<programlisting>DECLARE liahona CURSOR FOR SELECT * FROM films;
</programlisting>
   Voir <xref linkend="sql-fetch" endterm="sql-fetch-title"/> pour plus
   d'exemples sur l'utilisation des curseurs.
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Le standard SQL indique que la sensibilité des curseurs aux mises à jour en
   parallèle des données récupérées est dépendante de l'implantation par défaut.
   Dans <productname>PostgreSQL</productname>, les curseurs n'ont pas ce
   comportement par défaut, mais peuvent le devenir en ajoutant <literal>FOR
   UPDATE</literal>. D'autres produits peuvent gérer cela différement.
  </para>

  <para>
   Le standard SQL n'autorise les curseurs que dans le
   <acronym>SQL</acronym> embarqué et dans les modules.
   <productname>PostgreSQL</productname> permet une utilisation 
   interactive des curseurs.
  </para>

  <para>
   Le standard SQL autorise les curseurs à mettre à jour les données d'une
   table. Tous les curseurs <productname>PostgreSQL</productname> sont en lecture seule.
  </para>

  <para>
   Les curseurs binaires sont une extension
   <productname>PostgreSQL</productname>.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-close" endterm="sql-close-title"/></member>
   <member><xref linkend="sql-fetch" endterm="sql-fetch-title"/></member>
   <member><xref linkend="sql-move" endterm="sql-move-title"/></member>
  </simplelist>
 </refsect1>
</refentry>
