<?xml version="1.0" encoding="UTF-8"?>
<!--
doc/src/sgml/ref/create_procedure.sgml
-->

<refentry id="sql-createprocedure">
 <indexterm zone="sql-createprocedure">
  <primary>CREATE PROCEDURE</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE PROCEDURE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Commandes du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE PROCEDURE</refname>
  <refpurpose>définit une nouvelle procédure stockée</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
CREATE [ OR REPLACE ] PROCEDURE
    <replaceable class="parameter">nom</replaceable> ( [ [ <replaceable class="parameter">mode_argument</replaceable> ] [ <replaceable class="parameter">nom_argument</replaceable> ] <replaceable class="parameter">type_argument</replaceable> [ { DEFAULT | = } <replaceable class="parameter">expr_defaut</replaceable> ] [, ...] ] )
  { LANGUAGE <replaceable class="parameter">nom_langage</replaceable>
    | TRANSFORM { FOR TYPE <replaceable class="parameter">nom_type</replaceable> } [, ... ]
    | [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
    | SET <replaceable class="parameter">parametre_configuration</replaceable> { TO <replaceable class="parameter">valeur</replaceable> | = <replaceable class="parameter">valeur</replaceable> | FROM CURRENT }
    | AS '<replaceable class="parameter">definition</replaceable>'
    | AS '<replaceable class="parameter">fichier_objet</replaceable>', '<replaceable class="parameter">symbole_lien</replaceable>'
  } ...
</synopsis>
 </refsynopsisdiv>

 <refsect1 id="sql-createprocedure-description">
  <title>Description</title>

  <para>
   <command>CREATE PROCEDURE</command> définit une nouvelle procédure.
   <command>CREATE OR REPLACE PROCEDURE</command> va définir une nouvelle
   procédure, ou remplacer une définition existante.
   Pour pouvoir définir une procédure, l'utilisateur doit avoir le privilège
   <literal>USAGE</literal> sur le langage.
  </para>

  <para>
   Si le nom du schéma est inclus, alors la procédure est créée dans le
   schéma spécifié. Sinon elle est créée dans le schéma courant.
   Le nom de la nouvelle procédure ne doit correspondre à aucune procédure
   ou fonction existante possédant les mêmes types d'arguments dans le même
   schéma. Cependant, des procédures et fonctions avec des arguments de types
   différents peuvent partager le même nom (on appelle cela
   <firstterm>surcharge</firstterm> ou
   <foreignphrase><firstterm>overloading</firstterm></foreignphrase>).
  </para>

  <para>
   Pour remplacer la définition en cours d'une procédure existante, utilisez
   <command>CREATE OR REPLACE PROCEDURE</command>. Il n'est pas possible de
   changer le nom ou les types d'arguments d'une procédure avec cette méthode
   (si vous le faites, vous créez en fait une nouvelle procédure distincte).
  </para>

  <para>
   Si <command>CREATE OR REPLACE PROCEDURE</command> est utilisé pour
   remplacer une procédure existante, le propriétaire et les permissions sur
   la procédure ne changent pas. Toutes les autres propriétés de la
   procédure se voient assignées les valeurs spécifiées dans la commande.
   Vous devez être propriétaire de la procédure pour la remplacer (cela
   fonctionne aussi si vous êtes membre du rôle propriétaire).
  </para>

  <para>
   L'utilisateur qui crée la procédure devient son propriétaire.
  </para>

  <para>
   Pour pouvoir créer une procédure, vous devez avoir le
   privilège <literal>USAGE</literal> sur les types des arguments.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

   <variablelist>
    <varlistentry>
     <term><replaceable class="parameter">nom</replaceable></term>

     <listitem>
      <para>
	   Le nom (éventuellement qualifié par un schéma) de la procédure à
	   créer.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">mode_argument</replaceable></term>

     <listitem>
      <para>
       Le mode d'un argument&nbsp;: <literal>IN</literal>,
       <literal>INOUT</literal> ou <literal>VARIADIC</literal>. Sans précision,
       le défaut est <literal>IN</literal>. (Les arguments
	   <literal>OUT</literal> ne sont actuellement pas supportés pour les
	   procédures. Utilisez à la place <literal>INOUT</literal>.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nom_argument</replaceable></term>

     <listitem>
      <para>
	   Le nom d'un argument.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">type_argument</replaceable></term>

     <listitem>
      <para>
	   Le(s) type(s) des arguments de la procédure (éventuellement
	   qualifiés par un schéma), s'il y en a. Ils peuvent être les types de
	   base, des types composites, des domaines, ou des références à un
	   type d'une colonne d'une table.
      </para>
      <para>
	   Selon le langage d'implémentation, il peut être permis de spécifier
	   des <quote>pseudo-types</quote> comme <type>cstring</type>.
	   Les pseudo-types indiquent le type d'argument que est soit incomplètement
	   spécifié, soit en dehors des types de données ordinaires.
      </para>
      <para>
	   On fait référence au type d'une colonne en écrivant
       <literal><replaceable
       class="parameter">table_name</replaceable>.<replaceable
       class="parameter">column_name</replaceable>%TYPE</literal>.
	   Cette fonctionnalité permet parfois de rendre une procédure
	   indépendante des changements de définition d'une table.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">expr_defaut</replaceable></term>

     <listitem>
      <para>
	   Une expression à utiliser comme valeur par défaut si le paramètre
	   n'est pas spécifié. L'expression doit respecter le type d'argument
	   du paramètre.
	   Tous les paramètres en entrée suivant un paramètre avec une valeur
	   par défaut doivent en avoir une également.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nom_langage</replaceable></term>

     <listitem>
      <para>
       Le nom du langage dans lequel la procédure est implémentée.
	   Ce peut être <literal>sql</literal>, <literal>c</literal>,
       <literal>internal</literal> ou le nom d'un langage procédural défini
       par l'utilisateur, par exemple <literal>plpgsql</literal>. Mettre le nom
       entre  guillemets simples est obsolète et exige une casse identique.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TRANSFORM { FOR TYPE <replaceable class="parameter">nom_type</replaceable> } [, ... ] }</literal></term>

     <listitem>
      <para>
       Liste les transformations qu'un appel à la procédure devrait appliquer.
       Les transformations opèrent des conversions entre les types SQL et les
       types de données spécifiques au langage&nbsp;;
       voir <xref linkend="sql-createtransform"/>. D'habitude les implémentations
       des langages procéduraux connaissent d'entrée les types internes,
       ces derniers n'ont donc pas besoin d'être listés ici. Si une
       implémentation d'un langage procédural ne sait pas traiter un type et
       qu'aucune transformation n'est fournie, elle se rabattra sur un
       comportement par défaut pour convertir les données, mais cela dépend
       de l'implémentation.
      </para>
     </listitem>
    </varlistentry>

   <varlistentry>
    <term><literal><optional>EXTERNAL</optional> SECURITY INVOKER</literal></term>
    <term><literal><optional>EXTERNAL</optional> SECURITY DEFINER</literal></term>

    <listitem>
     <para><literal>SECURITY INVOKER</literal> indique que la procédure doit
      être exécutée avec les privilèges de l'utilisateur qui l'appelle. C'est
      le défaut. <literal>SECURITY DEFINER</literal> spécifie que la procédure
      doit être exécutée avec les privilèges de l'utilisateur qui la possède.
     </para>

     <para>
      Le mot clé <literal>EXTERNAL</literal> est permis pour la conformité
      envers le standard SQL, mais il est optionnel puisque, contrairement au SQL,
      cette fonctionnalité concerne toutes les procédures, et pas seulement les
      externes.
     </para>

     <para>
      Une procédure <literal>SECURITY DEFINER</literal> ne peut exécuter des
      commandes de contrôle de transaction (par exemple <command>COMMIT</command>
      et <command>ROLLBACK</command>, selon le langage).
     </para>
    </listitem>
   </varlistentry>

    <varlistentry>
     <term><replaceable>parametre_configuration</replaceable></term>
     <term><replaceable>valeur</replaceable></term>
     <listitem>
      <para>
       Avec la clause <literal>SET</literal>, le paramètre de configuration
       indiqué sera positionné à la valeur spécifiée à l'entrée dans la
       procédure, puis restauré à la valeur précédente à la sortie.
       <literal>SET FROM CURRENT</literal> mémorise la valeur du paramètre en
       cours au moment où <command>CREATE PROCEDURE</command> a été exécuté
       comme la valeur à appliquer à l'entrée dans la procédure.
      </para>

      <para>
       Si une clause <literal>SET</literal> est attachée à une procédure, alors
       les effets d'une commande <command>SET LOCAL</command> exécutée au sein
       de la procédure pour la même variable sont restreints à cette
       procédure&nbsp;: l'ancienne valeur du paramètre est toujours restaurée à
       la sortie de la procédure.

       Cependant, une commande <command>SET</command> ordinaire (sans
       <literal>LOCAL</literal>) a priorité sur la clause
       <literal>SET</literal>, tout comme elle le ferait sur un ordre
       <command>SET LOCAL</command> précédent&nbsp;: les effets d'une telle
       commande persisteront après la sortie de la procédure, à moins que la
       transaction en cours ne soit annulée.
      </para>

      <para>
       Si une clause <literal>SET</literal> est attachée à une procédure, alors
       cette procédure ne peut exécuter d'ordres de contrôle de transaction
       (comme <command>COMMIT</command>et <command>ROLLBACK</command>,
       selon le langage).
      </para>

      <para>
       Voir <xref linkend="sql-set"/> et <xref linkend="runtime-config"/>
       pour plus d'informations sur les noms et valeurs de paramètres
       autorisés.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">definition</replaceable></term>

     <listitem>
      <para>
       Une chaîne de caractères constante définissant la procédure&nbsp;; sa
       signification dépend du langage. Ce peut être un nom de procédure interne,
       le chemin d'un fichier objet, un ordre SQL, ou du texte dans un langage
       procédural.
      </para>

      <para>
       Le <foreignphrase>dollar quoting</foreignphrase> (voir <xref
       linkend="sql-syntax-dollar-quoting"/>) est souvent utile pour écrire
       la chaîne de définition de la fonction, plutôt que la syntaxe normale à
       simple guillemet. Sans <foreignphrase>dollar quoting</foreignphrase>,
       le moindre guillemet ou  <foreignphrase>backslash</foreignphrase> dans
       la définition de la procédure doit être échappé et donc doublé.
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal><replaceable class="parameter">fichier_objet</replaceable>, <replaceable class="parameter">symbole_lien</replaceable></literal></term>

     <listitem>
      <para>
       Cette forme de la clause <literal>AS</literal> est utilisée pour les
       procédures en C chargées dynamiquement, quand le nom de la procédure dans
       le code source en C n'est pas le même que le nom de la procédure SQL. La
       chaîne <replaceable class="parameter">fichier_objet</replaceable> est
       le nom de la bibliothèque partagée contenant la procédure C compilée, et est
       interprétée comme dans la commande <xref linkend="sql-load"/>. La chaîne
       <replaceable class="parameter">symbole_lien</replaceable> est le symbole
       de lien de la procédure, c'est-à-dire le nom de la procédure dans le code
       source en C. Si le symbole de lien est absent, on suppose qu'il est le
       même que le nom de la procédure en train d'être définie.
      </para>

      <para>
       Quand des commandes <command>CREATE PROCEDURE</command> répétées se
       réfèrent au même fichier objet, celui-ci n'est chargé d'une fois par
       session. Pour décharger et recharger le fichier (peut-être pendant le
       développement), démarrez une nouvelle session.
      </para>

     </listitem>
    </varlistentry>
   </variablelist>
 </refsect1>

 <refsect1 id="sql-createprocedure-notes">
  <title>Notes</title>

  <para>
   voir <xref linkend="sql-createfunction"/> pour plus de détails sur la
   création de fonctions, qui s'appliquent aussi aux procédures.
  </para>

  <para>
   Utilisez <xref linkend="sql-call"/> pour exécuter une procédure.
  </para>
 </refsect1>

 <refsect1 id="sql-createprocedure-examples">
  <title>Exemples</title>

<programlisting>
CREATE PROCEDURE insert_data(a integer, b integer)
LANGUAGE SQL
AS $$
INSERT INTO tbl VALUES (a);
INSERT INTO tbl VALUES (b);
$$;

CALL insert_data(1, 2);
</programlisting>
 </refsect1>

 <refsect1 id="sql-createprocedure-compat">
  <title>Compatibilité</title>

  <para>
   Une commande <command>CREATE PROCEDURE</command> est définie dans le standard
   SQL. La version de <productname>PostgreSQL</productname> est similaire mais
   pas complètement compatible. Pour plus de détails, voir aussi
   <xref linkend="sql-createfunction"/>.
  </para>
 </refsect1>


 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterprocedure"/></member>
   <member><xref linkend="sql-dropprocedure"/></member>
   <member><xref linkend="sql-call"/></member>
   <member><xref linkend="sql-createfunction"/></member>
  </simplelist>
 </refsect1>

</refentry>
