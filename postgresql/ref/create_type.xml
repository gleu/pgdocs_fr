<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060618 -->

<refentry id="sql-createtype">
 <indexterm zone="sql-createtype">
  <primary>CREATE TYPE</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE TYPE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TYPE</refname>
  <refpurpose>Définir un nouveau type de données</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <synopsis>CREATE TYPE <replaceable class="parameter">nom</replaceable> AS
    ( <replaceable class="parameter">nom_attribut</replaceable> <replaceable class="parameter">type_donnée</replaceable> [ COLLATE <replaceable>collation</replaceable> ] [, ... ] )

CREATE TYPE <replaceable class="parameter">nom</replaceable> AS ENUM
    ( [ '<replaceable class="parameter">label</replaceable>' [, ... ] ] )

CREATE TYPE <replaceable class="parameter">name</replaceable> AS RANGE (
    SUBTYPE = <replaceable class="parameter">sous_type</replaceable>
    [ , SUBTYPE_OPCLASS = <replaceable class="parameter">classe_operateur_sous_type</replaceable> ]
    [ , COLLATION = <replaceable class="parameter">collationnement</replaceable> ]
    [ , CANONICAL = <replaceable class="parameter">fonction_canonique</replaceable> ]
    [ , SUBTYPE_DIFF = <replaceable class="parameter">fonction_diff_sous_type</replaceable> ]
)

CREATE TYPE <replaceable class="parameter">nom</replaceable> (
    INPUT = <replaceable class="parameter">fonction_entrée</replaceable>,
    OUTPUT = <replaceable class="parameter">fonction_sortie</replaceable>
    [ , RECEIVE = <replaceable class="parameter">fonction_réception</replaceable> ]
    [ , SEND = <replaceable class="parameter">fonction_envoi</replaceable> ]
    [ , TYPMOD_IN = <replaceable class="parameter">type_modifier_input_function</replaceable> ]
    [ , TYPMOD_OUT = <replaceable class="parameter">type_modifier_output_function</replaceable> ]
    [ , ANALYZE = <replaceable class="parameter">fonction_analyse</replaceable> ]
    [ , INTERNALLENGTH = { <replaceable class="parameter">longueurinterne</replaceable> | VARIABLE } ]
    [ , PASSEDBYVALUE ]
    [ , ALIGNMENT = <replaceable class="parameter">alignement</replaceable> ]
    [ , STORAGE = <replaceable class="parameter">stockage</replaceable> ]
    [ , LIKE = <replaceable class="parameter">type_like</replaceable> ]
    [ , CATEGORY = <replaceable class="parameter">catégorie</replaceable> ]
    [ , PREFERRED = <replaceable class="parameter">préféré</replaceable> ]
    [ , DEFAULT = <replaceable class="parameter">défaut</replaceable> ]
    [ , ELEMENT = <replaceable class="parameter">élément</replaceable> ]
    [ , DELIMITER = <replaceable class="parameter">délimiteur</replaceable> ]
    [ , COLLATABLE = <replaceable class="parameter">collatable</replaceable> ]
)

CREATE TYPE <replaceable class="parameter">nom</replaceable>
  </synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>CREATE TYPE</command> enregistre un nouveau type de données
   utilisable dans la base courante. L'utilisateur qui définit un type
   en devient le propriétaire.
  </para>

  <para>
   Si un nom de schéma est précisé, le type est créé dans ce schéma.
   Sinon, il est créé dans le schéma courant. Le nom du type doit être
   distinct du nom de tout type ou domaine existant dans le même schéma.
   Les tables possèdent des types de données associés. Il est donc nécessaire
   que le nom du type soit également distinct du nom de toute table existant dans le même schéma.
  </para>

  <para>
   Il existe cinq formes de <command>CREATE TYPE</command>, comme indiqué dans
   la syntaxe ci-dessus. Elles créent respectivement un <firstterm>type
    composite</firstterm>, un <firstterm>type enum</firstterm>, un <firstterm>type
    range (intervalle)</firstterm>, un <firstterm>type de base</firstterm> ou un
   <firstterm>type shell</firstterm>. Les autre premiers sont discutés dans
   l'ordre ci-dessous. Un type shell est un simple conteneur de type qui sera
   défini ultérieurement. Il est créé en lançant <command>CREATE
    TYPE</command> sans paramètre en dehors de son nom. Les types shell sont
   nécessaires comme référence lors de la création de types intervalles et de types
   de base, comme indiqué dans ces sections.
  </para>

  <refsect2>
   <title>Types composites</title>

   <para>
    La première forme de <command>CREATE TYPE</command> crée un type composite. Le
    type composite est défini par une liste de noms d'attributs et de types de
    données. Un collationnement d'attribute peut aussi être spécifié si son
    type de données est collationnable. Un type composite est essentiellement
    le même que le type ligne (NDT&nbsp;: <foreignphrase>row
     type</foreignphrase> en anglais) d'une table, mais l'utilisation de
    <command>CREATE TYPE</command> permet d'éviter la création d'une table
    réelle quand seule la définition d'un type est voulue. Un type composite
    autonome est utile, par exemple, comme type d'argument ou de retour d'une
    fonction.
   </para>

   <para>
    Pour pouvoir créer un type composite, vous devez avoir le droit
    <literal>USAGE</literal> sur les types de tous les attributs.
   </para>
  </refsect2>

  <refsect2 id="sql-createtype-enum">
   <title>Types énumérés</title>

   <para>
    La seconde forme de <command>CREATE TYPE</command> crée un type énuméré
    (enum), comme décrit dans <xref linkend="datatype-enum"/>. Les types enum
    prennent une liste de plusieurs labels entre guillemets, chacun devant
    faire moins de <symbol>NAMEDATALEN</symbol> octets (64 octets dans une
    installation <productname>PostgreSQL</productname> standard). (Il est
    possible de créer un type énuméré avec zéro label, mais un tel type ne
    peut pas être utilisé pour contenir des valeurs avant qu'au moins un label
    soit ajouté en utilisant <xref linkend="sql-altertype"/>.)
   </para>
  </refsect2>

  <refsect2 id="sql-createtype-range">
   <title>Types intervalles</title>

   <para>
    La troisième forme de <command>CREATE TYPE</command> crée un type intervalle,
    comme décrit dans <xref linkend="rangetypes"/>.
   </para>

   <para>
    Le <replaceable class="parameter">sous-type</replaceable> du type intervalle
    peut être de tout type qui soit associé avec une classe d'opérateur B-tree
    (pour déterminer l'ordre des valeurs pour le type intervalle). Habituellement,
    la classe d'opérateur par défaut du sous-type est utilisée pour déterminer
    l'ordre. Pour utiliser un opérateur de classe autre que celle par défaut,
    indiquez son nom avec <replaceable
    class="parameter">classe_operateur_sous_type</replaceable>. Si le sous-type
    est collationnable et que vous voulez utiliser un collationnement autre que
    celui par défaut dans l'ordre de l'intervalle, indiquez le collationnement
    souhaité avec l'option <replaceable
    class="parameter">collationnement</replaceable>.
   </para>

   <para>
    La fonction optionnelle <replaceable class="parameter">canonique</replaceable>
    prend un argument du type intervalle défini, et renvoie une valeur du même
    type. C'est utilisé pour convertir les valeurs intervalles en leur forme
    canonique, lorsque c'est applicable. Voir <xref
    linkend="rangetypes-defining"/> pour plus d'informations. Créer une fonction
    <replaceable class="parameter">canonique</replaceable> peut être un peu
    compliqué car il doit être défini avant que le type intervalle ne soit défini.
    Pour cela, vous devez tout d'abord créer un type shell, qui est un coquille
    vide qui n'a aucune propriété en dehors de son nom et propriétaire. Cela
    se crée en exécutant la commande <literal>CREATE TYPE
     <replaceable>nom</replaceable></literal>, sans paramètre supplémentaire.
    Ensuite, la fonction peut être déclarée en utilisant le type shell comme
    argument et résultat. Enfin, le type intervalle peut être déclaré en utilisant
    le même nom. Ceci remplace automatiquement l'entrée du type shell avec
    un type intervalle valide.
   </para>

   <para>
    La fonction optionnelle <replaceable class="parameter">diff_sous_type</replaceable>
    doit prendre deux valeurs du type <replaceable
    class="parameter">sous-type</replaceable> comme arguments, et renvoie une
    valeur de type <type>double precision</type> représentant la différence
    entre les deux valeurs données. Bien que cela soit optionnel, la fournir
    autorise une plus grande efficacité des index GiST sur les colonnes du type
    intervalle. Voir <xref linkend="rangetypes-defining"/> pour plus
    d'informations.
   </para>
  </refsect2>

  <refsect2>
   <title>Types de base</title>

   <para>
    La quatrième forme de <command>CREATE TYPE</command> crée un nouveau type de base
    (type scalaire). Pour créer un nouveau type de base, il faut être superutilisateur.
    (Cette restriction est imposée parce qu'une définition de type erronée pourrait
    embrouiller voire arrêter brutalement le serveur.)
   </para>

   <para>
    L'ordre des paramètres, dont la plupart sont optionnels, n'a aucune
    d'importance. Avant de définir le type, il est nécessaire de définir au moins
    deux fonctions (à l'aide de la commande <command>CREATE FUNCTION</command>).
    Les fonctions de support <replaceable class="parameter">fonction_entrée</replaceable>
    et <replaceable class="parameter">fonction_sortie</replaceable> sont obligatoires. Les
    fonctions <replaceable class="parameter">fonction_réception</replaceable>,
    <replaceable class="parameter">fonction_envoi</replaceable>,
    <replaceable class="parameter">type_modifier_input_function</replaceable>,
    <replaceable class="parameter">type_modifier_output_function</replaceable>
    et
    <replaceable class="parameter">fonction_analyse</replaceable> sont
    optionnelles. Généralement, ces fonctions sont codées en C ou dans un
    autre langage de bas niveau.
   </para>

   <para>
    La <replaceable class="parameter">fonction_entrée</replaceable> convertit la
    représentation textuelle externe du type en représentation interne
    utilisée par les opérateurs et fonctions définis pour le type.
    La <replaceable class="parameter">fonction_sortie</replaceable> réalise la transformation
    inverse. La fonction entrée peut être déclarée avec un
    argument de type <type>cstring</type> ou trois arguments de
    types <type>cstring</type>, <type>oid</type>, <type>integer</type>. Le
    premier argument est le texte en entrée sous la forme d'une chaîne C, le second
    argument est l'OID du type (sauf dans le cas des types tableau où il
    s'agit de l'OID du type de l'élément) et le troisième est le <literal>typmod</literal>
    de la colonne destination, s'il est connu (-1 sinon). La fonction entrée
    doit renvoyer une valeur du nouveau type de données.
    Habituellement, une fonction d'entrée devrait être déclarée comme STRICT&nbsp;
    si ce n'est pas le cas, elle sera appelée avec un premier paramètre NULL à
    la lecture d'une valeur NULL en entrée. La fonction doit toujours envoyer
    NULL dans ce cas, sauf si une erreur est rapportée.
    (Ce cas a pour but de supporter les fonctions d'entrée des domaines qui ont
    besoin de rejeter les entrées NULL.)
    La fonction sortie doit prendre un argument du nouveau type de données, et
    retourner le type <type>cstring</type>. Les fonctions sortie ne sont pas
    appelées pour des valeurs NULL.
   </para>

   <para>
    La <replaceable class="parameter">fonction_réception</replaceable>,
    optionnelle, convertit la représentation binaire externe du type en
    représentation interne.
    <!-- participate in binary input -->
    Si cette fonction n'est pas fournie, le type n'accepte pas
    d'entrée binaire. La représentation binaire est choisie de telle sorte
    que sa conversion en forme interne soit peu coûteuse, tout en restant
    portable. (Par exemple, les types de données
    standard entiers utilisent l'ordre réseau des octets comme représentation
    binaire externe alors que la représentation interne est dans l'ordre natif
    des octets de la machine.) La fonction de réception réalise les
    vérifications adéquates pour s'assurer que la valeur est valide. Elle
    peut être déclarée avec un argument de type
    <type>internal</type> ou trois arguments de types
    <type>internal</type>, <type>integer</type> et <type>oid</type>. Le premier
    argument est un pointeur vers un tampon <type>StringInfo</type>
    qui contient la chaîne d'octets reçue&nbsp;; les arguments optionnels sont les
    mêmes que pour la fonction entrée de type texte. La fonction de réception
    retourne une valeur du type de données.
    Habituellement, une fonction de réception devrait être déclarée comme STRICT&nbsp;
    si ce n'est pas le cas, elle sera appelée avec un premier paramètre NULL à
    la lecture d'une valeur NULL en entrée. La fonction doit toujours envoyer
    NULL dans ce cas, sauf si une erreur est rapportée.
    (Ce cas a pour but de supporter les fonctions de réception des domaines qui ont
    besoin de rejeter les entrées NULL.)
    De façon similaire, la
    <replaceable class="parameter">fonction_envoi</replaceable>, optionnelle,
    convertit la représentation interne en représentation
    binaire externe. Si cette fonction n'est pas fournie, le type
    <!-- participate in binary output -->
    n'accepte pas de sortie binaire. La fonction d'envoi doit être déclarée
    avec un argument du nouveau type de données et retourner le type <type>bytea</type>.
    Les fonctions réception ne sont pas appelées pour des valeurs NULL.
   </para>

   <para>
    À ce moment-là, vous pouvez vous demander comment les fonctions d'entrée et
    de sortie peuvent être déclarées avoir un résultat ou un argument du nouveau
    type alors qu'elles sont à créer avant que le nouveau type ne soit créé. La
    réponse est que le type sera tout d'abord défini en tant que
    <firstterm>type squelette</firstterm> (<foreignphrase>shell type</foreignphrase>),
    une ébauche de type sans propriété à part un nom et un propriétaire. Ceci se
    fait en exécutant la commande <literal>CREATE TYPE <replaceable>nom</replaceable></literal>
    sans paramètres supplémentaires. Ensuite, les fonctions d'entrée/sortie C
    peuvent être définies en référençant le squelette. Enfin, le
    <command>CREATE TYPE</command> avec une définition complète remplace le
    squelette avec une définition complète et valide du type, après quoi le
    nouveau type peut être utilisé normalement.
   </para>

   <para>
    Les fonctions optionnelles
    <replaceable class="parameter">type_modifier_input_function</replaceable>
    et <replaceable class="parameter">type_modifier_output_function</replaceable>
    sont nécessaires si le type supporte des modificateurs, c'est-à-dire des
    contraintes optionnelles attachées à une déclaration de type comme
    <literal>char(5)</literal> ou <literal>numeric(30,2)</literal>.
    <productname>PostgreSQL</productname> autorise les types définis par
    l'utilisateur à prendre une ou plusieurs constantes ou identifiants comme
    modifieurs&nbsp;; néanmoins, cette information doit être capable d'être
    englobée dans une seule valeur entière positive pour son stockage dans les
    catalogues système.
    <replaceable class="parameter">type_modifier_input_function</replaceable>
    se voit fournir le modifieur déclaré de la forme d'un tableau de
    <type>cstring</type>. Il doit vérifier la validité des valeurs et renvoyer une
    erreur si elles sont invalides. Dans le cas contraire, il renvoie une valeur
    entière postive qui sera stockée dans la colonne <quote>typmod</quote>. Les
    modifieurs de type seront rejetés si le type n'a pas de
    <replaceable class="parameter">type_modifier_input_function</replaceable>.
    <replaceable class="parameter">type_modifier_output_function</replaceable>
    convertit la valeur typmod integer en une forme correcte pour l'affichage.
    Il doit renvoyer une valeur de type <type>cstring</type> qui est la chaîne
    exacte à ajouter au nom du type&nbsp;; par exemple la fonction de
    <type>numeric</type> pourrait renvoyer <literal>(30,2)</literal>. Il est
    permis d'omettre le
    <replaceable class="parameter">type_modifier_output_function</replaceable>,
    auquel cas le format d'affichage par défaut est simplement la valeur typmod
    stockée entre parenthèses.
   </para>

   <para>
    La <replaceable class="parameter">fonction_analyse</replaceable>, optionnelle,
    calcule des statistiques spécifiques au type de données pour les
    colonnes de ce type. Par défaut, <command>ANALYZE</command> tente de
    récupérer des statistiques à l'aide des opérateurs d'<quote>égalité</quote> et
    d'<quote>infériorité</quote> du type, s'il existe une classe d'opérateur B-tree
    par défaut pour le type. Ce comportement est inadapté aux types non-scalaires&nbsp;;
    il peut être surchargé à l'aide d'une fonction
    d'analyse personnalisée. La fonction d'analyse doit être déclarée avec
    un seul argument de type <type>internal</type> et un résultat de type
    <type>boolean</type>. L'API détaillée des fonctions d'analyses est présentée dans
    <filename>src/include/commands/vacuum.h</filename>.
   </para>

   <para>
    Alors que les détails de la représentation interne du nouveau type ne sont
    connus que des fonctions d'entrées/sorties et des fonctions utilisateurs
    d'interaction avec le type, plusieurs propriétés de
    la représentation interne doivent être déclarées à
    <productname>PostgreSQL</productname>. La première est
    <replaceable class="parameter">longueurinterne</replaceable>. Les types de
    données basiques peuvent être de longueur fixe (dans ce cas,
    <replaceable class="parameter">longueurinterne</replaceable> est un entier positif)
    ou de longueur variable (indiquée par le positionnement de
    <replaceable class="parameter">longueurinterne</replaceable> à
    <literal>VARIABLE</literal>&nbsp;; en interne, cela est représenté en initialisant
    <literal>typlen</literal> à -1). La représentation interne de tous les types de
    longueur variable doit commencer par un entier de quatre octets indiquant la
    longueur totale de cette valeur. (Notez que le champ length est souvent
    encodé, comme décrit dans <xref linkend="storage-toast"/>&nbsp;; il n'est
    pas conseillé d'y accéder directement.)
   </para>

   <para>
    Le drapeau optionnel <literal>PASSEDBYVALUE</literal> indique que les
    valeurs de ce type de données sont passées par valeur plutôt que par
    référence. Les types dont la représentation interne est plus grande que la
    taille du type <type>Datum</type> (quatre octets sur la plupart des
    machines, huit sur quelques-unes) ne doivent pas être passés par valeur.
    Les types passés par valeur doivent avoir une longueur fixe et leur
    représentation interne ne peut pas être plus large que la taille du type
    <type>Datum</type> (4 octets sur certaines machines, 8 octets sur
    d'autres).
   </para>

   <para>
    Le paramètre <replaceable class="parameter">alignement</replaceable>
    spécifie l'alignement de stockage requis pour le type de données. Les
    valeurs permises sont des alignements sur 1, 2, 4 ou 8 octets.
    Les types de longueurs variables ont un alignement d'au
    moins quatre octets car leur premier composant est nécessairement un <type>int4</type>.
   </para>

   <para>
    Le paramètre <replaceable class="parameter">stockage</replaceable> permet de
    choisir une stratégie de stockage pour les types de données de longueur
    variable. (Seul <literal>plain</literal> est autorisé pour les types de
    longueur fixe.) <literal>plain</literal> indique des données
    stockées en ligne et non compressées.
    Dans le cas d'<literal>extended</literal> le système essaie tout d'abord de
    compresser une valeur longue et déplace la valeur hors de
    la ligne de la table principale si elle est toujours trop longue.
    <literal>external</literal> permet à la valeur d'être déplacée hors de la
    table principale mais le système ne tente pas de la compresser.
    <literal>main</literal> autorise la compression mais ne déplace
    la valeur hors de la table principale qu'en dernier recours.
    (Ils seront déplacés s'il n'est pas possible de placer la ligne
    dans la table principale, mais
    sont préférentiellement conservés dans la table principale, contrairement aux éléments
    <literal>extended</literal> et <literal>external</literal>.)
   </para>

   <para>
    Toutes les valeurs <replaceable class="parameter">storage</replaceable>
    autres que <literal>plain</literal> impliquent que les fonctions du type
    de données peuvent gérer les valeurs placées en
    <firstterm>TOAST</firstterm>, comme décrit dans <xref
    linkend="storage-toast"/> et <xref linkend="xtypes-toast"/>. L'aure valeur
    spécifique détermine la stratégie de stockage par défaut pour les colonnes
    d'un type de données externalisable&nbsp;; les utilisateurs peuvent
    sélectionner les autres stratégies pour les colonnes individuelles en
    utilisant <literal>ALTER TABLE SET STORAGE</literal>.
   </para>

   <para>
    Le paramètre <replaceable class="parameter">type_like</replaceable> fournit
    une méthode alternative pour spécifier les propriétés de représentation de
    base d'un type de données&nbsp;: les copier depuis un type existant. Les valeurs
    de <replaceable class="parameter">longueurinterne</replaceable>,
    <replaceable class="parameter">passedbyvalue</replaceable>,
    <replaceable class="parameter">alignement</replaceable> et
    <replaceable class="parameter">stockage</replaceable> sont copiées du type
    indiqué. (C'est possible, mais habituellement non souhaité, d'écraser
    certaines de ces valeurs en les spécifiant en même temps que la clause
    <literal>LIKE</literal>.)  Spécifier la représentation de cette façon est
    particulièrement pratique quand l'implémentation de bas niveau du nouveau type
    emprunte celle d'un type existant d'une façon ou d'une autre.
   </para>

   <para>
    Les paramètres <replaceable class="parameter">catégorie</replaceable> et
    <replaceable class="parameter">préféré</replaceable> peuvent être utilisés pour
    aider à contrôler la conversion implicite appliquée en cas d'ambiguïté.
    Chaque type de données appartient à une catégorie identifiée par un seul
    caractère ASCII, et chaque type est <quote>préféré</quote> ou pas de sa
    catégorie. L'analyseur préfèrera convertir vers des types préférés (mais
    seulement à partir d'autres types dans la même catégorie) quand cette règle
    peut servir à résoudre des fonctions ou opérateurs surchargés. Pour plus de
    détails, voir <xref linkend="typeconv"/>. Pour les types qui n'ont pas de
    conversion implicite de ou vers d'autres types, on peut se contenter de laisser
    ces paramètres aux valeurs par défaut. Par contre, pour un groupe de types
    liés entre eux qui ont des conversions implicites, il est souvent pratique
    de les marquer tous comme faisant partie d'une même catégorie, et de choisir
    un ou deux des types les <quote>plus généraux</quote> comme étant les types
    préférés de la catégorie.
    Le paramètre <replaceable class="parameter">catégorie</replaceable> est
    particulièrement utile quand on ajoute un type défini par l'utilisateur à un
    type interne, comme un type numérique ou chaîne. Toutefois, c'est aussi tout
    à fait possible de créer des catégories de types entièrement nouvelles.
    Choisissez un caractère ASCII autre qu'une lettre en majuscule pour donner
    un nom à une catégorie de ce genre.
   </para>

   <para>
    Une valeur par défaut peut être spécifiée dans le cas où l'utilisateur
    souhaite que cette valeur soit différente de NULL pour les colonnes de ce type.
    La valeur par défaut est précisée à l'aide du mot clé
    <literal>DEFAULT</literal>. (Une telle valeur par défaut peut être surchargée
    par une clause <literal>DEFAULT</literal> explicite attachée à une colonne
    particulière.)
   </para>

   <para>
    Pour indiquer qu'un type est un tableau, le type des éléments du
    tableau est précisé par le mot clé <literal>ELEMENT</literal>. Par exemple, pour
    définir un tableau d'entiers de quatre octets (<type>int4</type>),
    <literal>ELEMENT = int4</literal> est utilisé. Plus de détails sur les types
    tableau apparaissent ci-dessous.
   </para>

   <para>
    Pour préciser le délimiteur de valeurs utilisé dans la
    représentation externe des tableaux de ce type,
    <replaceable class="parameter">délimiteur</replaceable> peut être positionné à un
    caractère particulier. Le délimiteur par défaut est la virgule
    (<literal>,</literal>). Le délimiteur est associé avec le type
    élément de tableau, pas avec le type tableau.
   </para>

   <para>
    Si le paramètre booléen optionnel <replaceable
    class="parameter">collatable</replaceable> vaut true, les définitions et
    expressions de colonnes du type peuvent embarquer une information de
    collationnement via la clause <literal>COLLATE</literal>. C'est aux
    implémentations des fonctions du type de faire bon usage de cette
    information. Cela n'arrive pas automatiquement en marquant le type
    collationnable.
   </para>
  </refsect2>

  <refsect2>
   <title>Types tableau</title>

   <para>
    À chaque fois qu'un type défini par un utilisateur est créé,
    <productname>PostgreSQL</productname> crée automatiquement un type tableau
    associé dont le nom est composé à partir du type de base préfixé d'un
    tiret bas et tronqué si nécessaire pour que le nom généré fasse moins de
    <symbol>NAMEDATALEN</symbol> octets. (Si le nom généré est en conflit avec
    un autre nom, le traitement est répété jusqu'à ce qu'un nom sans conflit
    soit trouvé.)
    Ce type tableau créé implicitement est de longueur variable et utilise les
    fonctions d'entrée et sortie <literal>array_in</literal> et
    <literal>array_out</literal>. Le type tableau trace tout changement dans
    du type de base pour le propriétaire et le schéma. Il est aussi supprimé
    quand le type de base l'est.
   </para>

   <para>
    Pourquoi existe-t-il une option
    <option>ELEMENT</option> si le système fabrique automatiquement le bon type
    tableau ?
    La seule utilité d'<option>ELEMENT</option> est la création d'un type de longueur
    fixe représenté en interne par un tableau d'éléments identiques auxquels on souhaite
    accéder directement par leurs indices (en plus de toute autre opération
    effectuée sur le type dans sa globalité). Par exemple, le type
    <type>point</type> est représenté par deux nombres à virgule flottante,
    qui sont accessibles par <literal>point[0]</literal> et
    <literal>point[1]</literal>. Cette
    fonctionnalité n'est possible qu'avec les types de longueur fixe dont la
    forme interne est strictement une séquence de champs de longueur fixée.
    Un type de longueur variable est accessible par ses indices
    si sa représentation interne
    généralisée est celle utilisée par <literal>array_in</literal> et <literal>array_out</literal>.
    Pour des raisons historiques (c'est-à-dire pour de mauvaises raisons, mais
    il est trop tard pour changer) les indices des tableaux de types de longueur
    fixe commencent à zéro et non à un comme c'est le cas pour les tableaux de
    longueur variable.
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
      Le nom (éventuellement qualifié du nom du schéma) du type à créer.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_attribut</replaceable></term>
    <listitem>
     <para>
      Le nom d'un attribut (colonne) du type composite.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_données</replaceable></term>
    <listitem>
     <para>
      Le nom d'un type de données existant utilisé comme colonne du type
      composite.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">collationnement</replaceable></term>
    <listitem>
     <para>
      Le nom d'un collationnement existant à associer avec une colonne d'un type
      composite ou avec un type intervalle.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">label</replaceable></term>
    <listitem>
     <para>
      Une chaîne représentant le label associé à une valeur du type enum.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">sous_type</replaceable></term>
    <listitem>
     <para>
      Le nom du type élément dont le type intervalle va représenter des intervalles.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">classe_operateur_sous_type</replaceable></term>
    <listitem>
     <para>
      Le nom d'une classe d'opérateur B-tree pour le sous-type.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_canonique</replaceable></term>
    <listitem>
     <para>
      Le nom de la fonction canonique pour le type intervalle.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_diff_sous_type</replaceable></term>
    <listitem>
     <para>
      Le nom de la fonction de différence pour le sous-type.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_entrée</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction de conversion des données de la forme
      textuelle externe du type en forme interne.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_sortie</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction de conversion des données de la forme
      interne du type en forme textuelle externe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_réception</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction de conversion des données de la forme binaire externe du type en
      forme interne.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_envoi</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction de conversion des données de la forme
      interne du type en forme binaire externe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_modifier_input_function</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction qui convertit un tableau de modifieurs pour le
      type vers sa forme interne.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_modifier_output_function</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction qui convertit la forme interne des modifieurs du
      type vers leur forme textuelle externe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">analyze_function</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction d'analyses statistiques pour le type
      de données.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">longueurinterne</replaceable></term>
    <listitem>
     <para>
      Une constante numérique qui précise la longueur en octets de la
      représentation interne du nouveau type. Supposée variable par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">alignement</replaceable></term>
    <listitem>
     <para>
      La spécification d'alignement du stockage du type de données. Peut être
      <literal>char</literal>, <literal>int2</literal>,
      <literal>int4</literal> ou <literal>double</literal>&nbsp;;
      <literal>int4</literal> par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">stockage</replaceable></term>
    <listitem>
     <para>
      La stratégie de stockage du type de données. Peut être <literal>plain</literal>,
      <literal>external</literal>,
      <literal>extended</literal> ou <literal>main</literal>&nbsp;;
      <literal>plain</literal> par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_like</replaceable></term>
    <listitem>
     <para>
      Le nom d'un type de données existant dont le nouveau type partagera la
      représentation. Les valeurs de
      <replaceable class="parameter">longueurinterne</replaceable>,
      <replaceable class="parameter">passedbyvalue</replaceable>,
      <replaceable class="parameter">alignement</replaceable> et
      <replaceable class="parameter">stockage</replaceable> sont recopiées à
      partir de ce type, sauf si elles sont écrasées explicitement ailleurs
      dans la même commande <command>CREATE TYPE</command>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">catégorie</replaceable></term>
    <listitem>
     <para>
      Le code de catégorie (un unique caractère ASCII) pour ce type.
      La valeur par défaut est <literal>U</literal> pour
      <quote>user-defined type</quote> (type défini par l'utilisateur).
      Les autres codes standard de catégorie peuvent être trouvés dans
      <xref linkend="catalog-typcategory-table"/>. Vous pouvez aussi choisir
      d'autres caractères ASCII pour créer vos propres catégories personnalisées.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">préféré</replaceable></term>
    <listitem>
     <para>
      True si ce type est un type préféré dans sa catégorie de types, sinon
      false. La valeur par défaut est false. Faites très attention en créant un
      nouveau type préféré à l'intérieur d'une catégorie existante car cela
      pourrait créer des modifications surprenantes de comportement.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">défaut</replaceable></term>
    <listitem>
     <para>
      La valeur par défaut du type de données. Omise, elle est NULL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">élément</replaceable></term>
    <listitem>
     <para>
      Type des éléments du type tableau créé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">délimiteur</replaceable></term>
    <listitem>
     <para>
      Le caractère délimiteur des valeurs des tableaux de ce type.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">collatable</replaceable></term>
    <listitem>
     <para>
      Vrai si les opérations de ce type peuvent utiliser les informations de
      collationnement. Par défaut, à faux.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1 id="sql-createtype-notes">
  <title>Notes</title>

  <para>
   Comme il n'y a pas de restrictions à l'utilisation d'un type de données
   une fois qu'il a été créé, créer un type de base ou un type range est équivalent à donner les
   droits d'exécution sur les fonctions mentionnées dans la définition du
   type. Ce
   n'est pas un problème habituellement pour le genre de fonctions utiles
   dans la définition d'un type mais réfléchissez bien avant de concevoir
   un type d'une façon qui nécessiterait que des informations
   <quote>secrètes</quote> soient utilisées lors de sa convertion vers ou à
   partir d'une forme externe.
  </para>

  <para>
   Avant <productname>PostgreSQL</productname> version 8.3, le nom d'un type
   tableau généré était toujours exactement le nom du type élément avec un
   caractère tiret bas (<literal>_</literal>) en préfixe. (Les noms des types
   étaient du coup limités en longueur à un caractère de moins que les autres
   noms.) Bien que cela soit toujours le cas, le nom d'un type tableau peut
   varier entre ceci dans le cas des noms de taille maximum et les collisions
   avec des noms de type utilisateur qui commencent avec un tiret bas. Écrire
   du code qui dépend de cette convention est du coup obsolète. À la place,
   utilisez <structname>pg_type</structname>.<structfield>typarray</structfield>
   pour situer le type tableau associé avec un type donné.
  </para>

  <para>
   Il est conseillé d'éviter d'utiliser des noms de table et de type qui
   commencent avec un tiret bas. Alors que le serveur changera les noms des
   types tableau générés pour éviter les collisions avec les noms donnés par
   un utilisateur, il reste toujours un risque de confusion, particulièrement
   avec les anciens logiciels clients qui pourraient supposer que les noms
   de type commençant avec un tiret bas représentent toujours des tableaux.
  </para>

  <para>
   Avant <productname>PostgreSQL</productname> version 8.2, la syntaxe de
   création d'un type shell
   <literal>CREATE TYPE <replaceable>nom</replaceable></literal> n'existait pas.
   La façon de créer un nouveau type de base était de créer en premier les
   fonctions paramètres. Dans cette optique,
   <productname>PostgreSQL</productname> verra tout d'abord le nom d'un nouveau
   type de données comme type de retour de la fonction en entrée. Le type shell
   est créé implicitement dans ce cas et il est ensuite référencé dans le reste
   des fonctions d'entrée/sortie. Cette approche fonctionne toujours mais
   est obsolète et pourrait être interdite dans une version future. De plus,
   pour éviter de faire grossir les catalogues de façon accidentelle avec des
   squelettes de type erronés, un squelette sera seulement créé quand la fonction
   en entrée est écrit en C.
  </para>

  <para>
   Dans les versions de <productname>PostgreSQL</productname> antérieures à la
   7.3, la création d'un type coquille était habituellement évitée en remplaçant
   les références des fonctions au nom du type par le pseudotype <type>opaque</type>.
   Les arguments <type>cstring</type> et les résultats étaient également déclarés
   <type>opaque</type>. Pour supporter le chargement d'anciens
   fichiers de sauvegarde, <command>CREATE TYPE</command> accepte les fonctions
   d'entrées/sorties déclarées avec le pseudotype <type>opaque</type> mais un
   message d'avertissement est affiché. La déclaration de la fonction est
   également modifiée pour utiliser les bons types.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Créer un type composite utilisé dans la définition d'une
   fonction&nbsp;:
   <programlisting>CREATE TYPE compfoo AS (f1 int, f2 text);

CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$
SELECT fooid, fooname FROM foo
$$ LANGUAGE SQL;
   </programlisting>
  </para>

  <para>
   Cet exemple crée un type énuméré et l'utilise dans la création d'une
   table&nbsp;:
   <programlisting>
CREATE TYPE statut_bogue AS ENUM ('nouveau', 'ouvert', 'fermé');

CREATE TABLE bogue (
    id serial,
    description text,
    status statut_bogue
);
   </programlisting>
  </para>

  <para>
   Cet exemple crée un type intervalle&nbsp;:
   <programlisting>
CREATE TYPE float8_range AS RANGE (subtype = float8, subtype_diff = float8mi);
   </programlisting>
  </para>

  <para>
   Créer le type de données basique <type>box</type> utilisé dans
   la définition d'une table&nbsp;:
   <programlisting>CREATE TYPE box;

CREATE FUNCTION ma_fonction_entree_box(cstring) RETURNS box AS ... ;
CREATE FUNCTION ma_fonction_sortie_box(box) RETURNS cstring AS ... ;

CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = ma_fonction_entree_box,
    OUTPUT = ma_fonction_sortie_box
);

CREATE TABLE myboxes (
    id integer,
    description box
);
   </programlisting>
  </para>

  <para>
   Si la structure interne de <type>box</type> est un tableau de quatre
   éléments <type>float4</type>, on peut écrire&nbsp;:
   <programlisting>CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = ma_fonction_entree_box,
    OUTPUT = ma_fonction_sortie_box,
    ELEMENT = float4
);
   </programlisting>
   ce qui permet d'accéder aux nombres composant la valeur d'une boîte par
   les indices. Le comportement du type n'est pas modifié.
  </para>

  <para>
   Créer un objet large utilisé dans la définition d'une table&nbsp;:
   <programlisting>CREATE TYPE bigobj (
    INPUT = lo_filein, OUTPUT = lo_fileout,
    INTERNALLENGTH = VARIABLE
);
CREATE TABLE big_objs (
    id integer,
    obj bigobj
);
   </programlisting>
  </para>

  <para>
   D'autres exemples, intégrant des fonctions utiles
   d'entrée et de sortie, peuvent être consultés dans <xref linkend="xtypes"/>.
  </para>
 </refsect1>

 <refsect1 id="sql-createtype-compatibility">
  <title>Compatibilité</title>

  <para>
   La première forme de la commande <command>CREATE TYPE</command>, qui crée
   un type composite, est conforme au standard <acronym>SQL</acronym>. Les
   autres formes sont des extensions de <productname>PostgreSQL</productname>.
   L'instruction <command>CREATE TYPE</command> du standard
   <acronym>SQL</acronym> définit aussi d'autres formes qui ne sont pas
   implémentées dans <productname>PostgreSQL</productname>.
  </para>

  <para>
   La possibilité de créer un type composite sans attributs est une différence
   spécifique de <productname>PostgreSQL</productname> que le standard ne
   propose pas (de façon analogue au <command>CREATE TABLE</command>).
  </para>
 </refsect1>

 <refsect1 id="sql-createtype-see-also">
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-altertype"/></member>
   <member><xref linkend="sql-createdomain"/></member>
   <member><xref linkend="sql-createfunction"/></member>
   <member><xref linkend="sql-droptype"/></member>
  </simplelist>
 </refsect1>

</refentry>
