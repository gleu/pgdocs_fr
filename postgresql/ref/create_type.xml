<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060618 -->

<refentry id="sql-createtype">
 <refmeta>
  <refentrytitle>CREATE TYPE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TYPE</refname>
  <refpurpose>Définir un nouveau type de données</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE TYPE <replaceable class="parameter">nom</replaceable> AS
    ( <replaceable class="parameter">nom_attribut</replaceable> <replaceable class="parameter">type_donnée</replaceable> [ COLLATE <replaceable>collation</replaceable> ] [, ... ] )

CREATE TYPE <replaceable class="parameter">nom</replaceable> AS ENUM
    ( [ '<replaceable class="parameter">label</replaceable>' [, ... ] ] )

CREATE TYPE <replaceable class="parameter">name</replaceable> AS RANGE (
    SUBTYPE = <replaceable class="parameter">sous_type</replaceable>
    [ , SUBTYPE_OPCLASS = <replaceable class="parameter">classe_operateur_sous_type</replaceable> ]
    [ , COLLATION = <replaceable class="parameter">collationnement</replaceable> ]
    [ , CANONICAL = <replaceable class="parameter">fonction_canonique</replaceable> ]
    [ , SUBTYPE_DIFF = <replaceable class="parameter">fonction_diff_sous_type</replaceable> ]
)

CREATE TYPE <replaceable class="parameter">nom</replaceable> (
    INPUT = <replaceable class="parameter">fonction_entrée</replaceable>,
    OUTPUT = <replaceable class="parameter">fonction_sortie</replaceable>
    [ , RECEIVE = <replaceable class="parameter">fonction_réception</replaceable> ]
    [ , SEND = <replaceable class="parameter">fonction_envoi</replaceable> ]
    [ , TYPMOD_IN = <replaceable class="parameter">type_modifier_input_function</replaceable> ]
    [ , TYPMOD_OUT = <replaceable class="parameter">type_modifier_output_function</replaceable> ]
    [ , ANALYZE = <replaceable class="parameter">fonction_analyse</replaceable> ]
    [ , INTERNALLENGTH = { <replaceable class="parameter">longueurinterne</replaceable> | VARIABLE } ]
    [ , PASSEDBYVALUE ]
    [ , ALIGNMENT = <replaceable class="parameter">alignement</replaceable> ]
    [ , STORAGE = <replaceable class="parameter">stockage</replaceable> ]
    [ , LIKE = <replaceable class="parameter">type_like</replaceable> ]
    [ , CATEGORY = <replaceable class="parameter">catégorie</replaceable> ]
    [ , PREFERRED = <replaceable class="parameter">préféré</replaceable> ]
    [ , DEFAULT = <replaceable class="parameter">défaut</replaceable> ]
    [ , ELEMENT = <replaceable class="parameter">élément</replaceable> ]
    [ , DELIMITER = <replaceable class="parameter">délimiteur</replaceable> ]
    [ , COLLATABLE = <replaceable class="parameter">collatable</replaceable> ]
)

CREATE TYPE <replaceable class="parameter">nom</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-createtype">
   <primary>CREATE TYPE</primary>
  </indexterm>

  <para>
   <command>CREATE TYPE</command> enregistre un nouveau type de données 
   utilisable dans la base courante. L'utilisateur qui définit un type
   en devient le propriétaire.
  </para>

  <para>
   Si un nom de schéma est précisé, le type est créé dans ce schéma.
   Sinon, il est créé dans le schéma courant. Le nom du type doit être
   distinct du nom de tout type ou domaine existant dans le même schéma. 
   Les tables possèdent des types de données associés. Il est donc nécessaire
   que le nom du type soit également distinct du nom de toute table existant dans le même schéma.
  </para>

  <para>
   Il existe cinq formes de <command>CREATE TYPE</command>, comme indiqué dans
   la syntaxe ci-dessus. Elles créent respectivement un <firstterm>type
   composite</firstterm>, un <firstterm>type enum</firstterm>, un <firstterm>type
   range (intervalle)</firstterm>, un <firstterm>type de base</firstterm> ou un
   <firstterm>type shell</firstterm>. Les autre premiers sont discutés dans
   l'ordre ci-dessous. Un type shell est un simple conteneur de type qui sera
   défini ultérieurement. Il est créé en lançant <command>CREATE
   TYPE</command> sans paramètre en dehors de son nom. Les types shell sont
   nécessaires comme référence lors de la création de types intervalles et de types
   de base, comme indiqué dans ces sections.
  </para>

  <refsect2>
   <title>Types composites</title>

  <para>
   La première forme de <command>CREATE TYPE</command> crée un type composite. Le
   type composite est défini par une liste de noms d'attributs et de types de
   données. Un collationnement d'attribute peut aussi être spécifié si son
   type de données est collationnable. Un type composite est essentiellement
   le même que le type ligne (NDT&nbsp;: <foreignphrase>row
   type</foreignphrase> en anglais) d'une table, mais l'utilisation de
   <command>CREATE TYPE</command> permet d'éviter la création d'une table
   réelle quand seule la définition d'un type est voulue. Un type composite
   autonome est utile, par exemple, comme type d'argument ou de retour d'une
   fonction.
  </para>

  <para>
   Pour pouvoir créer un type composite, vous devez avoir le droit
   <literal>USAGE</literal> sur les types de tous les attributs.
  </para>
  </refsect2>

  <refsect2 id="sql-createtype-enum">
   <title>Types énumérés</title>

   <para>
    La seconde forme de <command>CREATE TYPE</command> crée un type énuméré
    (enum), comme décrit dans <xref linkend="datatype-enum"/>.
    Les types enum prennent une liste de un à plusieurs labels entre guillemets,
    chacun devant faire moins de <symbol>NAMEDATALEN</symbol> octets (64 octets dans
    une installation <productname>PostgreSQL</productname> standard).
   </para>
  </refsect2>

  <refsect2 id="sql-createtype-range">
   <title>Types intervalles</title>

   <para>
    La troisième forme de <command>CREATE TYPE</command> crée un type intervalle,
    comme décrit dans <xref linkend="rangetypes"/>.
   </para>

   <para>
    Le <replaceable class="parameter">sous-type</replaceable> du type intervalle
    peut être de tout type qui soit associé avec une classe d'opérateur B-tree
    (pour déterminer l'ordre des valeurs pour le type intervalle). Habituellement,
    la classe d'opérateur par défaut du sous-type est utilisée pour déterminer
    l'ordre. Pour utiliser un opérateur de classe autre que celle par défaut,
    indiquez son nom avec <replaceable
    class="parameter">classe_operateur_sous_type</replaceable>. Si le sous-type
    est collationnable et que vous voulez utiliser un collationnement autre que
    celui par défaut dans l'ordre de l'intervalle, indiquez le collationnement
    souhaité avec l'option <replaceable
    class="parameter">collationnement</replaceable>.
   </para>

   <para>
    La fonction optionnelle <replaceable class="parameter">canonique</replaceable>
    prend un argument du type intervalle défini, et renvoie une valeur du même
    type. C'est utilisé pour convertir les valeurs intervalles en leur forme
    canonique, lorsque c'est applicable. Voir <xref
    linkend="rangetypes-defining"/> pour plus d'informations. Créer une fonction
    <replaceable class="parameter">canonique</replaceable> peut être un peu
    compliqué car il doit être défini avant que le type intervalle ne soit défini.
    Pour cela, vous devez tout d'abord créer un type shell, qui est un coquille
    vide qui n'a aucune propriété en dehors de son nom et propriétaire. Cela
    se crée en exécutant la commande <literal>CREATE TYPE
    <replaceable>nom</replaceable></literal>, sans paramètre supplémentaire.
    Ensuite, la fonction peut être déclarée en utilisant le type shell comme
    argument et résultat. Enfin, le type intervalle peut être déclaré en utilisant
    le même nom. Ceci remplace automatiquement l'entrée du type shell avec
    un type intervalle valide.
   </para>

   <para>
    La fonction optionnelle <replaceable class="parameter">diff_sous_type</replaceable>
    doit prendre deux valeurs du type <replaceable
    class="parameter">sous-type</replaceable> comme arguments, et renvoie une
    valeur de type <type>double precision</type> représentant la différence
    entre les deux valeurs données. Bien que cela soit optionnel, la fournir
    autorise une plus grande efficacité des index GiST sur les colonnes du type
    intervalle. Voir <xref linkend="rangetypes-defining"/> pour plus
    d'informations.
   </para>
  </refsect2>

  <refsect2>
   <title>Types de base</title>

  <para>
   La quatrième forme de <command>CREATE TYPE</command> crée un nouveau type de base
   (type scalaire). Pour créer un nouveau type de base, il faut être superutilisateur.
   (Cette restriction est imposée parce qu'une définition de type erronée pourrait
   embrouiller voire arrêter brutalement le serveur.)
  </para>

  <para>
   L'ordre des paramètres, dont la plupart sont optionnels, n'a aucune
   d'importance. Avant de définir le type, il est nécessaire de définir au moins
   deux fonctions (à l'aide de la commande <command>CREATE FUNCTION</command>).
   Les fonctions de support <replaceable class="parameter">fonction_entrée</replaceable>
   et <replaceable class="parameter">fonction_sortie</replaceable> sont obligatoires. Les
   fonctions <replaceable class="parameter">fonction_réception</replaceable>,
   <replaceable class="parameter">fonction_envoi</replaceable>,
   <replaceable class="parameter">type_modifier_input_function</replaceable>,
   <replaceable class="parameter">type_modifier_output_function</replaceable>
   et
   <replaceable class="parameter">fonction_analyse</replaceable> sont
   optionnelles. Généralement, ces fonctions sont codées en C ou dans un
   autre langage de bas niveau.
  </para>

  <para>
   La <replaceable class="parameter">fonction_entrée</replaceable> convertit la
   représentation textuelle externe du type en représentation interne
   utilisée par les opérateurs et fonctions définis pour le type.
   La <replaceable class="parameter">fonction_sortie</replaceable> réalise la transformation
   inverse. La fonction entrée peut être déclarée avec un
   argument de type <type>cstring</type> ou trois arguments de
   types <type>cstring</type>, <type>oid</type>, <type>integer</type>. Le
   premier argument est le texte en entrée sous la forme d'une chaîne C, le second
   argument est l'OID du type (sauf dans le cas des types tableau où il
   s'agit de l'OID du type de l'élément) et le troisième est le <literal>typmod</literal>
   de la colonne destination, s'il est connu (-1 sinon). La fonction entrée
   doit renvoyer une valeur du nouveau type de données.
   Habituellement, une fonction d'entrée devrait être déclarée comme STRICT&nbsp;
   si ce n'est pas le cas, elle sera appelée avec un premier paramètre NULL à
   la lecture d'une valeur NULL en entrée. La fonction doit toujours envoyer
   NULL dans ce cas, sauf si une erreur est rapportée.
   (Ce cas a pour but de supporter les fonctions d'entrée des domaines qui ont
   besoin de rejeter les entrées NULL.)
   La fonction sortie doit prendre un argument du nouveau type de données, et
   retourner le type <type>cstring</type>. Les fonctions sortie ne sont pas
   appelées pour des valeurs NULL.
  </para>

  <para>
   La <replaceable class="parameter">fonction_réception</replaceable>,
   optionnelle, convertit la représentation binaire externe du type en
   représentation interne.
   <!-- participate in binary input -->
   Si cette fonction n'est pas fournie, le type n'accepte pas
   d'entrée binaire. La représentation binaire est choisie de telle sorte
   que sa conversion en forme interne soit peu coûteuse, tout en restant
   portable. (Par exemple, les types de données
   standard entiers utilisent l'ordre réseau des octets comme représentation
   binaire externe alors que la représentation interne est dans l'ordre natif
   des octets de la machine.) La fonction de réception réalise les
   vérifications adéquates pour s'assurer que la valeur est valide. Elle
   peut être déclarée avec un argument de type
   <type>internal</type> ou trois arguments de types
   <type>internal</type>, <type>integer</type> et <type>oid</type>. Le premier
   argument est un pointeur vers un tampon <type>StringInfo</type>
   qui contient la chaîne d'octets reçue&nbsp;; les arguments optionnels sont les
   mêmes que pour la fonction entrée de type texte. La fonction de réception
   retourne une valeur du type de données.
   Habituellement, une fonction de réception devrait être déclarée comme STRICT&nbsp;
   si ce n'est pas le cas, elle sera appelée avec un premier paramètre NULL à
   la lecture d'une valeur NULL en entrée. La fonction doit toujours envoyer
   NULL dans ce cas, sauf si une erreur est rapportée.
   (Ce cas a pour but de supporter les fonctions de réception des domaines qui ont
   besoin de rejeter les entrées NULL.)
   De façon similaire, la
   <replaceable class="parameter">fonction_envoi</replaceable>, optionnelle,
   convertit la représentation interne en représentation
   binaire externe. Si cette fonction n'est pas fournie, le type
   <!-- participate in binary output -->
   n'accepte pas de sortie binaire. La fonction d'envoi doit être déclarée
   avec un argument du nouveau type de données et retourner le type <type>bytea</type>.
   Les fonctions réception ne sont pas appelées pour des valeurs NULL.
  </para>

  <para>
   À ce moment-là, vous pouvez vous demander comment les fonctions d'entrée et
   de sortie peuvent être déclarées avoir un résultat ou un argument du nouveau
   type alors qu'elles sont à créer avant que le nouveau type ne soit créé. La
   réponse est que le type sera tout d'abord défini en tant que
   <firstterm>type squelette</firstterm> (<foreignphrase>shell type</foreignphrase>),
   une ébauche de type sans propriété à part un nom et un propriétaire. Ceci se
   fait en exécutant la commande <literal>CREATE TYPE <replaceable>nom</replaceable></literal>
   sans paramètres supplémentaires. Ensuite, les fonctions d'entrée/sortie
   peuvent être définies en référençant le squelette. Enfin, le
   <command>CREATE TYPE</command> avec une définition complète remplace le
   squelette avec une définition complète et valide du type, après quoi le
   nouveau type peut être utilisé normalement.
  </para>

  <para>
   Les fonctions optionnelles
   <replaceable class="parameter">type_modifier_input_function</replaceable>
   et <replaceable class="parameter">type_modifier_output_function</replaceable>
   sont nécessaires si le type supporte des modificateurs, c'est-à-dire des
   contraintes optionnelles attachées à une déclaration de type comme
   <literal>char(5)</literal> ou <literal>numeric(30,2)</literal>.
   <productname>PostgreSQL</productname> autorise les types définis par
   l'utilisateur à prendre une ou plusieurs constantes ou identifiants comme
   modifieurs&nbsp;; néanmoins, cette information doit être capable d'être
   englobée dans une seule valeur entière positive pour son stockage dans les
   catalogues système.
   <replaceable class="parameter">type_modifier_input_function</replaceable>
   se voit fourni le modifieur déclaré de la forme d'un tableau de
   <type>cstring</type>. Il doit vérifier la validité des valeurs et renvoyer une
   erreur si elles sont invalides. Dans le cas contraire, il renvoie une valeur
   entière postivequi sera stockée dans la colonne <quote>typmod</quote>. Les
   modifieurs de type seront rejetés si le type n'a pas de
   <replaceable class="parameter">type_modifier_input_function</replaceable>.
   <replaceable class="parameter">type_modifier_output_function</replaceable>
   convertit la valeur typmod integer en une forme correcte pour l'affichage.
   Il doit renvoyer une valeur de type <type>cstring</type> qui est la chaîne
   exacte à ajouter au nom du type&nbsp;; par exemple la fonction de
   <type>numeric</type> pourrait renvoyer <literal>(30,2)</literal>. Il est
   permis d'omettre le
   <replaceable class="parameter">type_modifier_output_function</replaceable>,
   auquel cas le format d'affichage par défaut est simplement la valeur typmod
   stockée entre parenthèses.
  </para>

  <para>
   La <replaceable class="parameter">fonction_analyse</replaceable>, optionnelle,
   calcule des statistiques spécifiques au type de données pour les
   colonnes de ce type. Par défaut, <command>ANALYZE</command> tente de
   récupérer des statistiques à l'aide des opérateurs d'<quote>égalité</quote> et
   d'<quote>infériorité</quote> du type, s'il existe une classe d'opérateur B-tree
   par défaut pour le type. Ce comportement est inadapté aux types non-scalaires&nbsp;;
   il peut être surchargé à l'aide d'une fonction
   d'analyse personnalisée. La fonction d'analyse doit être déclarée avec
   un seul argument de type <type>internal</type> et un résultat de type
   <type>boolean</type>. L'API détaillée des fonctions d'analyses est présentée dans
   <filename>src/include/commands/vacuum.h</filename>.
  </para>

  <para>
   Alors que les détails de la représentation interne du nouveau type ne sont
   connus que des fonctions d'entrées/sorties et des fonctions utilisateurs
   d'interaction avec le type, plusieurs propriétés de
   la représentation interne doivent être déclarées à
   <productname>PostgreSQL</productname>. La première est
   <replaceable class="parameter">longueurinterne</replaceable>. Les types de
   données basiques peuvent être de longueur fixe (dans ce cas, 
   <replaceable class="parameter">longueurinterne</replaceable> est un entier positif)
   ou de longueur variable (indiquée par le positionnement de 
   <replaceable class="parameter">longueurinterne</replaceable> à
   <literal>VARIABLE</literal>&nbsp;; en interne, cela est représenté en initialisant
   <literal>typlen</literal> à -1). La représentation interne de tous les types de
   longueur variable doit commencer par un entier de quatre octets indiquant la
   longueur totale de cette valeur.
  </para>

  <para>
   Le drapeau optionnel <literal>PASSEDBYVALUE</literal> indique que les
   valeurs de ce type de données sont passées par valeur plutôt que par
   référence. Les types dont la
   représentation interne est plus grande que la taille du type
   <type>Datum</type> (quatre octets sur la plupart des machines, huit sur
   quelques-unes) ne doivent pas être passés par valeur.
  </para>

  <para>
   Le paramètre <replaceable class="parameter">alignement</replaceable>
   spécifie l'alignement de stockage requis pour le type de données. Les
   valeurs permises sont des alignements sur 1, 2, 4 ou 8 octets.
   Les types de longueurs variables ont un alignement d'au
   moins quatre octets car leur premier composant est nécessairement un <type>int4</type>.
  </para>

  <para>
   Le paramètre <replaceable class="parameter">stockage</replaceable> permet de
   choisir une stratégie de stockage pour les types de données de longueur
   variable. (Seul <literal>plain</literal> est autorisé pour les types de
   longueur fixe.) <literal>plain</literal> indique des données
   stockées en ligne et non compressées.
   Dans le cas d'<literal>extended</literal> le système essaie tout d'abord de
   compresser une valeur longue et déplace la valeur hors de
   la ligne de la table principale si elle est toujours trop longue.
   <literal>external</literal> permet à la valeur d'être déplacée hors de la
   table principale mais le système ne tente pas de la compresser.
   <literal>main</literal> autorise la compression mais ne déplace
   la valeur hors de la table principale qu'en dernier recours.
   (Ils seront déplacés s'il n'est pas possible de placer la ligne 
   dans la table principale, mais
   sont préférentiellement conservés dans la table principale, contrairement aux éléments
   <literal>extended</literal> et <literal>external</literal>.)
  </para>

  <para>
   Le paramètre <replaceable class="parameter">type_like</replaceable> fournit
   une méthode alternative pour spécifier les propriétés de représentation de
   base d'un type de données&nbsp;: les copier depuis un type existant. Les valeurs
   de <replaceable class="parameter">longueurinterne</replaceable>,
   <replaceable class="parameter">passedbyvalue</replaceable>,
   <replaceable class="parameter">alignement</replaceable> et
   <replaceable class="parameter">stockage</replaceable> sont copiées du type
   indiqué. (C'est possible, mais habituellement non souhaité, d'écraser
   certaines de ces valeurs en les spécifiant en même temps que la clause
   <literal>LIKE</literal>.)  Spécifier la représentation de cette façon est
   particulièrement pratique quand l'implémentation de bas niveau du nouveau type
   emprunte celle d'un type existant d'une façon ou d'une autre.
  </para>

  <para>
   Les paramètres <replaceable class="parameter">catégorie</replaceable> et
   <replaceable class="parameter">préféré</replaceable> peuvent être utilisés pour
   aider à contrôler la conversion implicite appliquée en cas d'ambiguïté.
   Chaque type de données appartient à une catégorie identifiée par un seul
   caractère ASCII, et chaque type est <quote>préféré</quote> ou pas de sa
   catégorie. L'analyseur préfèrera convertir vers des types préférés (mais
   seulement à partir d'autres types dans la même catégorie) quand cette règle
   peut servir à résoudre des fonctions ou opérateurs surchargés. Pour plus de
   détails, voir <xref linkend="typeconv"/>. Pour les types qui n'ont pas de
   conversion implicite de ou vers d'autres types, on peut se contenter de laisser
   ces paramètres aux valeurs par défaut. Par contre, pour un groupe de types
   liés entre eux qui ont des conversions implicites, il est souvent pratique
   de les marquer tous comme faisant partie d'une même catégorie, et de choisir
   un ou deux des types les <quote>plus généraux</quote> comme étant les types
   préférés de la catégorie.
   Le paramètre <replaceable class="parameter">catégorie</replaceable> est
   particulièrement utile quand on ajoute un type défini par l'utilisateur à un
   type interne, comme un type numérique ou chaîne. Toutefois, c'est aussi tout
   à fait possible de créer des catégories de types entièrement nouvelles.
   Choisissez un caractère ASCII autre qu'une lettre en majuscule pour donner
   un nom à une catégorie de ce genre.
  </para>

  <para>
   Une valeur par défaut peut être spécifiée dans le cas où l'utilisateur
   souhaite que cette valeur soit différente de NULL pour les colonnes de ce type.
   La valeur par défaut est précisée à l'aide du mot clé
   <literal>DEFAULT</literal>. (Une telle valeur par défaut peut être surchargée
   par une clause <literal>DEFAULT</literal> explicite attachée à une colonne
   particulière.)
  </para>

  <para>
   Pour indiquer qu'un type est un tableau, le type des éléments du
   tableau est précisé par le mot clé <literal>ELEMENT</literal>. Par exemple, pour
   définir un tableau d'entiers de quatre octets (<type>int4</type>),
   <literal>ELEMENT = int4</literal> est utilisé. Plus de détails sur les types
   tableau apparaissent ci-dessous.
  </para>

  <para>
   Pour préciser le délimiteur de valeurs utilisé dans la
   représentation externe des tableaux de ce type,
   <replaceable class="parameter">délimiteur</replaceable> peut être positionné à un
   caractère particulier. Le délimiteur par défaut est la virgule
   (<literal>,</literal>). Le délimiteur est associé avec le type
   élément de tableau, pas avec le type tableau.
  </para>

  <para>
   Si le paramètre booléen optionnel <replaceable
   class="parameter">collatable</replaceable> vaut true, les définitions et
   expressions de colonnes du type peuvent embarquer une information de
   collationnement via la clause <literal>COLLATE</literal>. C'est aux
   implémentations des fonctions du type de faire bon usage de cette
   information. Cela n'arrive pas automatiquement en marquant le type
   collationnable.
  </para>
  </refsect2>

  <refsect2>
   <title>Types tableau</title>

   <para>
    À chaque fois qu'un type défini par un utilisateur est créé,
    <productname>PostgreSQL</productname> crée automatiquement un type tableau
    associé dont le nom est composé à partir du type de base préfixé d'un
    tiret bas et tronqué si nécessaire pour que le nom généré fasse moins de
    <symbol>NAMEDATALEN</symbol> octets. (Si le nom généré est en conflit avec
    un autre nom, le traitement est répété jusqu'à ce qu'un nom sans conflit
    soit trouvé.)
    Ce type tableau créé implicitement est de longueur variable et utilise les
    fonctions d'entrée et sortie <literal>array_in</literal> et
    <literal>array_out</literal>. Le type tableau trace tout changement dans
    du type de base pour le propriétaire et le schéma. Il est aussi supprimé
    quand le type de base l'est.
   </para>

   <para>
    Pourquoi existe-t-il une option
    <option>ELEMENT</option> si le système fabrique automatiquement le bon type
    tableau ? 
    La seule utilité d'<option>ELEMENT</option> est la création d'un type de longueur
    fixe représenté en interne par un tableau d'éléments identiques auxquels on souhaite 
    accéder directement par leurs indices (en plus de toute autre opération 
    effectuée sur le type dans sa globalité). Par exemple, le type
    <type>point</type> est représenté par deux nombres à virgule flottante,
    qui sont accessibles par <literal>point[0]</literal> et
    <literal>point[1]</literal>. Cette
    fonctionnalité n'est possible qu'avec les types de longueur fixe dont la
    forme interne est strictement une séquence de champs de longueur fixée.
    Un type de longueur variable est accessible par ses indices
    si sa représentation interne 
    généralisée est celle utilisée par <literal>array_in</literal> et <literal>array_out</literal>.
    Pour des raisons historiques (c'est-à-dire pour de mauvaises raisons, mais
    il est trop tard pour changer) les indices des tableaux de types de longueur
    fixe commencent à zéro et non à un comme c'est le cas pour les tableaux de
    longueur variable.
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
     Le nom (éventuellement qualifié du nom du schéma) du type à créer.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_attribut</replaceable></term>
    <listitem>
     <para>
      Le nom d'un attribut (colonne) du type composite.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_données</replaceable></term>
    <listitem>
     <para>
      Le nom d'un type de données existant utilisé comme colonne du type
      composite.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">collationnement</replaceable></term>
    <listitem>
     <para>
      Le nom d'un collationnement existant à associer avec une colonne d'un type
      composite ou avec un type intervalle.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">label</replaceable></term>
    <listitem>
     <para>
      Une chaîne représentant le label associé à une valeur du type enum.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">sous_type</replaceable></term>
    <listitem>
     <para>
      Le nom du type élément dont le type intervalle va représenter des intervalles.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">classe_operateur_sous_type</replaceable></term>
    <listitem>
     <para>
      Le nom d'une classe d'opérateur B-tree pour le sous-type.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_canonique</replaceable></term>
    <listitem>
     <para>
      Le nom de la fonction canonique pour le type intervalle.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_diff_sous_type</replaceable></term>
    <listitem>
     <para>
      Le nom de la fonction de différence pour le sous-type.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_entrée</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction de conversion des données de la forme
      textuelle externe du type en forme interne.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_sortie</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction de conversion des données de la forme
      interne du type en forme textuelle externe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_réception</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction de conversion des données de la forme binaire externe du type en
      forme interne.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_envoi</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction de conversion des données de la forme
      interne du type en forme binaire externe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_modifier_input_function</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction qui convertit un tableau de modifieurs pour le
      type vers sa forme interne.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_modifier_output_function</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction qui convertit la forme interne des modifieurs du
      type vers leur forme textuelle externe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">analyze_function</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction d'analyses statistiques pour le type
      de données.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">longueurinterne</replaceable></term>
    <listitem>
     <para>
      Une constante numérique qui précise la longueur en octets de la
      représentation interne du nouveau type. Supposée variable par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">alignement</replaceable></term>
    <listitem>
     <para>
      La spécification d'alignement du stockage du type de données. Peut être
      <literal>char</literal>, <literal>int2</literal>,
      <literal>int4</literal> ou <literal>double</literal>&nbsp;;
      <literal>int4</literal> par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">stockage</replaceable></term>
    <listitem>
     <para>
      La stratégie de stockage du type de données. Peut être <literal>plain</literal>,
      <literal>external</literal>,
      <literal>extended</literal> ou <literal>main</literal>&nbsp;;
      <literal>plain</literal> par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_like</replaceable></term>
    <listitem>
     <para>
      Le nom d'un type de données existant dont le nouveau type partagera la
      représentation. Les valeurs de
      <replaceable class="parameter">longueurinterne</replaceable>,
      <replaceable class="parameter">passedbyvalue</replaceable>,
      <replaceable class="parameter">alignement</replaceable> et
      <replaceable class="parameter">stockage</replaceable> sont recopiées à
      partir de ce type, sauf si elles sont écrasées explicitement ailleurs
      dans la même commande <command>CREATE TYPE</command>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">catégorie</replaceable></term>
    <listitem>
     <para>
      Le code de catégorie (un unique caractère ASCII) pour ce type.
      La valeur par défaut est <literal>U</literal> pour 
      <quote>user-defined type</quote> (type défini par l'utilisateur).
      Les autres codes standard de catégorie peuvent être trouvés dans
      <xref linkend="catalog-typcategory-table"/>. Vous pouvez aussi choisir
      d'autres caractères ASCII pour créer vos propres catégories personnalisées.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">préféré</replaceable></term>
    <listitem>
     <para>
      True si ce type est un type préféré dans sa catégorie de types, sinon
      false. La valeur par défaut est false. Faites très attention en créant un
      nouveau type préféré à l'intérieur d'une catégorie existante car cela
      pourrait créer des modifications surprenantes de comportement.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">défaut</replaceable></term>
    <listitem>
     <para>
      La valeur par défaut du type de données. Omise, elle est NULL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">élément</replaceable></term>
    <listitem>
     <para>
      Type des éléments du type tableau créé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">délimiteur</replaceable></term>
    <listitem>
     <para>
      Le caractère délimiteur des valeurs des tableaux de ce type.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">collatable</replaceable></term>
    <listitem>
     <para>
      Vrai si les opérations de ce type peuvent utiliser les informations de
      collationnement. Par défaut, à faux.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1 id="sql-createtype-notes">
  <title>Notes</title>

  <para>
   Comme il n'y a pas de restrictions à l'utilisation d'un type de données
   une fois qu'il a été créé, créer un type de base ou un type range est équivalent à donner les
   droits d'exécution sur les fonctions mentionnées dans la définition du
   type. Ce
   n'est pas un problème habituellement pour le genre de fonctions utiles
   dans la définition d'un type mais réfléchissez bien avant de concevoir
   un type d'une façon qui nécessiterait que des informations
   <quote>secrètes</quote> soient utilisées lors de sa convertion vers ou à
   partir d'une forme externe.
  </para>

  <para>
   Avant <productname>PostgreSQL</productname> version 8.3, le nom d'un type
   tableau généré était toujours exactement le nom du type élément avec un
   caractère tiret bas (<literal>_</literal>) en préfixe. (Les noms des types
   étaient du coup limités en longueur à un caractère de moins que les autres
   noms.) Bien que cela soit toujours le cas, le nom d'un type tableau peut
   varier entre ceci dans le cas des noms de taille maximum et les collisions
   avec des noms de type utilisateur qui commencent avec un tiret bas. Écrire
   du code qui dépend de cette convention est du coup obsolète. À la place,
   utilisez <structname>pg_type</structname>.<structfield>typarray</structfield>
   pour situer le type tableau associé avec un type donné.
  </para>

  <para>
   Il est conseillé d'éviter d'utiliser des noms de table et de type qui
   commencent avec un tiret bas. Alors que le serveur changera les noms des
   types tableau générés pour éviter les collisions avec les noms donnés par
   un utilisateur, il reste toujours un risque de confusion, particulièrement
   avec les anciens logiciels clients qui pourraient supposer que les noms
   de type commençant avec un tiret bas représentent toujours des tableaux.
  </para>

  <para>
   Avant <productname>PostgreSQL</productname> version 8.2, la syntaxe de
   création d'un type shell
   <literal>CREATE TYPE <replaceable>nom</replaceable></literal> n'existait pas.
   La façon de créer un nouveau type de base était de créer en premier les
   fonctions paramètres. Dans cette optique,
   <productname>PostgreSQL</productname> verra tout d'abord le nom d'un nouveau
   type de données comme type de retour de la fonction en entrée. Le type shell
   est créé implicitement dans ce cas et il est ensuite référencé dans le reste
   des fonctions d'entrée/sortie. Cette approche fonctionne toujours mais
   est obsolète et pourrait être interdite dans une version future. De plus,
   pour éviter de faire grossir les catalogues de façon accidentelle avec des
   squelettes de type erronés, un squelette sera seulement créé quand la fonction
   en entrée est écrit en C.
  </para>

  <para>
   Dans les versions de <productname>PostgreSQL</productname> antérieures à la
   7.3, la création d'un type coquille était habituellement évitée en remplaçant
   les références des fonctions au nom du type par le pseudotype <type>opaque</type>.
   Les arguments <type>cstring</type> et les résultats étaient également déclarés
   <type>opaque</type>. Pour supporter le chargement d'anciens
   fichiers de sauvegarde, <command>CREATE TYPE</command> accepte les fonctions
   d'entrées/sorties déclarées avec le pseudotype <type>opaque</type> mais un
   message d'avertissement est affiché. La déclaration de la fonction est
   également modifiée pour utiliser les bons types.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Créer un type composite utilisé dans la définition d'une
   fonction&nbsp;:
<programlisting>CREATE TYPE compfoo AS (f1 int, f2 text);

CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$
SELECT fooid, fooname FROM foo
$$ LANGUAGE SQL;
</programlisting>
  </para>

  <para>
   Cet exemple crée un type énuméré et l'utilise dans la création d'une
   table&nbsp;:
<programlisting>
CREATE TYPE statut_bogue AS ENUM ('nouveau', 'ouvert', 'fermé');

CREATE TABLE bogue (
    id serial,
    description text,
    status statut_bogue
);
</programlisting>
  </para>

  <para>
   Cet exemple crée un type intervalle&nbsp;:
<programlisting>
CREATE TYPE float8_range AS RANGE (subtype = float8, subtype_diff = float8mi);
</programlisting>
  </para>

  <para>
   Créer le type de données basique <type>box</type> utilisé dans
   la définition d'une table&nbsp;:
<programlisting>CREATE TYPE box;

CREATE FUNCTION ma_fonction_entree_box(cstring) RETURNS box AS ... ;
CREATE FUNCTION ma_fonction_sortie_box(box) RETURNS cstring AS ... ;

CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = ma_fonction_entree_box,
    OUTPUT = ma_fonction_sortie_box
);

CREATE TABLE myboxes (
    id integer,
    description box
);
</programlisting>
  </para>

  <para>
   Si la structure interne de <type>box</type> est un tableau de quatre
   éléments <type>float4</type>, on peut écrire&nbsp;:
<programlisting>CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = ma_fonction_entree_box,
    OUTPUT = ma_fonction_sortie_box,
    ELEMENT = float4
);
</programlisting>
   ce qui permet d'accéder aux nombres composant la valeur d'une boîte par
   les indices. Le comportement du type n'est pas modifié.
  </para>

  <para>
   Créer un objet large utilisé dans la définition d'une table&nbsp;:
<programlisting>CREATE TYPE bigobj (
    INPUT = lo_filein, OUTPUT = lo_fileout,
    INTERNALLENGTH = VARIABLE
);
CREATE TABLE big_objs (
    id integer,
    obj bigobj
);
</programlisting>
  </para>

  <para>
   D'autres exemples, intégrant des fonctions utiles 
   d'entrée et de sortie, peuvent être consultés dans <xref linkend="xtypes"/>.
  </para>
 </refsect1>

 <refsect1 id="sql-createtype-compatibility">
  <title>Compatibilité</title>

  <para>
   La première forme de la commande <command>CREATE TYPE</command>, qui crée
   un type composite, est conforme au standard <acronym>SQL</acronym>. Les
   autres formes sont des extensions de <productname>PostgreSQL</productname>.
   L'instruction <command>CREATE TYPE</command> du standard
   <acronym>SQL</acronym> définit aussi d'autres formes qui ne sont pas
   implémentées dans <productname>PostgreSQL</productname>.
  </para>

  <para>
   La possibilité de créer un type composite sans attributs est une différence
   spécifique de <productname>PostgreSQL</productname> que le standard ne
   propose pas (de façon analogue au <command>CREATE TABLE</command>).
  </para>
 </refsect1>

 <refsect1 id="sql-createtype-see-also">
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-altertype"/></member>
   <member><xref linkend="sql-createdomain"/></member>
   <member><xref linkend="sql-createfunction"/></member>
   <member><xref linkend="sql-droptype"/></member>
  </simplelist>
 </refsect1>

</refentry>
