<?xml version="1.0" encoding="UTF-8"?>
<refentry id="pgupgrade">
 <indexterm zone="pgupgrade">
  <primary>pg_upgrade</primary>
 </indexterm>

 <refmeta>
  <refentrytitle><application>pg_upgrade</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>pg_upgrade</refname>
  <refpurpose>met à jour une instance du serveur <productname>PostgreSQL</productname></refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <cmdsynopsis>
   <command>pg_upgrade</command>
   <arg choice="plain"><option>-b</option></arg>
   <arg choice="plain"><replaceable>ancien_repertoire_executables</replaceable></arg>
   <arg choice="opt"><option>-B</option> <replaceable>nouveau_repertoire_executables</replaceable></arg>
   <arg choice="plain"><option>-d</option></arg>
   <arg choice="plain"><replaceable>ancien_repertoire_configuration</replaceable></arg>
   <arg choice="plain"><option>-D</option></arg>
   <arg choice="plain"><replaceable>nouveau_repertoire_configuration</replaceable></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <application>pg_upgrade</application> (antérieurement connu
   sous le nom <application>pg_migrator</application>) permet
   de mettre à jour les fichiers de données vers une version
   plus récente de <productname>PostgreSQL</productname> sans la
   sauvegarde et le rechargement de données typiquement requis
   pour les mises à jour d'une version majeure vers une autre,
   par exemple d'une version 12.14 à une version 13.10 ou à partir de 14.9
   vers 15.5. Il n'est pas nécessaire pour les mises à jour de versions
   mineures, par exemple de 12.7 à 12.8 ou de 14.1 à 14.5.
  </para>

  <para>
   Les sorties de version majeures de PostgreSQL ajoutent
   régulièrement de nouvelles fonctionnalités qui changent souvent
   la structure des tables système, mais le format interne des données
   stockées change rarement. <application>pg_upgrade</application>
   utilise ce fait pour effectuer des mises à jour rapides en créant
   de nouvelles tables systèmes et en réutilisant les anciens fichiers
   de données. Si jamais une future version majeure devait modifier le format
   d'enregistrement des données de telle sorte que l'ancien format
   des données soit illisible, <application>pg_upgrade</application>
   ne pourrait pas être utilisé pour ces mises à jour. (La communauté
   essaiera d'éviter de telles situations.)
  </para>

  <para>
   <application>pg_upgrade</application> fait de son mieux pour être
   sûr que la nouvelle et l'ancienne instances soient compatibles au niveau
   binaire, par exemple en vérifiant que les options de compilation
   sont compatibles, y compris le format 32/64 bits des binaires. Il
   est également important que les modules externes soient aussi
   compatibles au plan binaire, bien que ceci ne puisse être
   vérifié par <application>pg_upgrade</application>.
  </para>

  <para>
   pg_upgrade supporte les mises à jour à partir de la version
   9.2.X et suivantes jusqu'à la version majeure courante de
   <productname>PostgreSQL</productname>, y compris les images et
   versions beta.
  </para>
 </refsect1>

 <refsect1>
  <title>Options</title>

  <para>
   <application>pg_upgrade</application> accepte les arguments de ligne de
   commande suivants&nbsp;:

   <variablelist>

    <varlistentry>
     <term><option>-b</option> <replaceable>repertoire_executables</replaceable></term>
     <term><option>--old-bindir=</option><replaceable>repertoire_executables</replaceable></term>
     <listitem><para>l'ancien répertoire des exécutables PostgreSQL&nbsp;;
       variable d'environnement <envar>PGBINOLD</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-B</option> <replaceable>repertoire_executables</replaceable></term>
     <term><option>--new-bindir=</option><replaceable>repertoire_executables</replaceable></term>
     <listitem><para>le nouveau répertoire des exécutables PostgreSQL&nbsp;;
       la valeur par défaut est le répertoire d'installation de
       <application>pg_upgrade</application>&nbsp;; variable d'environnement
       <envar>PGBINNEW</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-c</option></term>
     <term><option>--check</option></term>
     <listitem><para>uniquement la vérification des instances, ne
       modifie aucune donnée</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-d</option> <replaceable>repertoire_configuration</replaceable></term>
     <term><option>--old-datadir=</option><replaceable>repertoire_configuration</replaceable></term>
     <listitem><para>répertoire de configuration de l'ancienne instance&nbsp;;
       variable d'environnement<envar>PGDATAOLD</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-D</option> <replaceable>repertoire_configuration</replaceable></term>
     <term><option>--new-datadir=</option><replaceable>repertoire_configuration</replaceable></term>
     <listitem><para>répertoire de configuration de la nouvelle instance&nbsp;;
       variable d'environnement <envar>PGDATANEW</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-j <replaceable class="parameter">njobs</replaceable></option></term>
     <term><option>--jobs=<replaceable class="parameter">njobs</replaceable></option></term>
     <listitem><para>nombres de processus ou threads simultanés à utiliser
      </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-k</option></term>
     <term><option>--link</option></term>
     <listitem><para>utiliser des liens physiques au lieu de copier les
       fichiers vers la nouvelle instance</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-N</option></term>
     <term><option>--no-sync</option></term>
     <listitem>
      <para>
       Par défaut, <command>pg_upgrade</command> attendra que tous les fichiers
       de l'instance mise à jour soient écrits sur disque. Cette option fait
       que <command>pg_upgrade</command> quitte sans attendre, ce qui est plus
       rapide mais signifie qu'un crash ultérieur du système d'exploitation peut
       laisser le répertoire de données corrompu. Généralement, cette option est
       utile dans le cas de tests mais elle ne devrait pas être utilisée pour
       une installation en production.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-o</option> <replaceable class="parameter">options</replaceable></term>
     <term><option>--old-options</option> <replaceable class="parameter">options</replaceable></term>
     <listitem><para>options à passer directement à l'ancienne commande
       <command>postgres</command>&nbsp;; les invocations multiples de cette
       option sont cumulées</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-O</option> <replaceable class="parameter">options</replaceable></term>
     <term><option>--new-options</option> <replaceable class="parameter">options</replaceable></term>
     <listitem><para>options à passer directement à la nouvelle
       commande <command>postgres</command>&nbsp;; les invocations multiples
       de cette commande sont cumulées</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-p</option> <replaceable>port</replaceable></term>
     <term><option>--old-port=</option><replaceable>port</replaceable></term>
     <listitem><para>le numéro de port de l'ancienne instance&nbsp;; variable
       d'environnement<envar>PGPORTOLD</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-P</option> <replaceable>port</replaceable></term>
     <term><option>--new-port=</option><replaceable>port</replaceable></term>
     <listitem><para>le numéro de port de la nouvelle instance&nbsp;; variable
       d'environnement<envar>PGPORTNEW</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-r</option></term>
     <term><option>--retain</option></term>
     <listitem><para>conserver les fichiers SQL et de traces y compris
       après avoir terminé avec succès</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-s</option> <replaceable>dir</replaceable></term>
     <term><option>--socketdir=</option><replaceable>dir</replaceable></term>
     <listitem><para>répertoire utilisé pour stocker les sockets lors de la
       mise à jour&nbsp;; la valeur par défaut est le répertoire courant&nbsp;;
       la variable d'environnement est <envar>PGSOCKETDIR</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-U</option> <replaceable>username</replaceable></term>
     <term><option>--username=</option><replaceable>username</replaceable></term>
     <listitem><para>nom d'utilisateur de l'instance d'installation&nbsp;;
       variable d'environnement<envar>PGUSER</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-v</option></term>
     <term><option>--verbose</option></term>
     <listitem><para>activer la trace interne verbeuse</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-V</option></term>
     <term><option>--version</option></term>
     <listitem><para>afficher les informations de version, puis quitter</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>--clone</option></term>
     <listitem>
      <para>
       Utilise le clonage efficace de fichiers (connu aussi sous le nom de
       <quote>reflinks</quote> sur certains systèmes) au lieu de copier les
       fichiers vers la nouvelle instance. Ceci peut résulter en une copie
       pratiquement instantanée des fichiers de données, donnant l'avantage
       en vitesse de l'option <option>-k</option>/<option>--link</option>
       tout en laissant l'ancienne instance non modifiée.
      </para>

      <para>
       Le clonage de fichiers est seulement supporté sur certains systèmes
       d'exploitation et systèmes de fichiers. Si cette option est
       sélectionnée alors qu'elle n'est pas supportée, l'exécution de
       <application>pg_upgrade</application> renverra une erreur.
       Actuellement, cette option est supportée sous Linux (à partir du noyau
       4.5) avec Btrfs et XFS (pour les systèmes de fichiers créés avec le
       support de reflink), et sur macOS avec APFS.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><option>--copy</option></term>
     <listitem>
      <para>
       Copie les fichiers sur la nouvelle instance. Cette option est activée
       par défaut. (Voir aussi
       <option>--link</option> et <option>--clone</option>.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><option>--copy-file-range</option></term>
     <listitem>
      <para>
       Utiliser l'appel système <function>copy_file_range</function> pour un clonage
       efficace. Sur certains systèmes de fichiers, cela donne des résultats similaires à
       <option>--clone</option> en partageant les blocs physiques du disque, tandis que sur d'autres,
       cet appel pourrait copier les blocs mais en le faisant de manière optimisée. Actuellement,
       ceci est supporté sur Linux et FreeBSD.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><option>--sync-method=</option><replaceable>méthode</replaceable></term>
     <listitem>
      <para>
       Quand positionné à <literal>fsync</literal>, ce qui est la valeur par défaut,
       <command>pg_upgrade</command> va ouvrir récursivement et synchroniser sur disque tous
       les fichiers présents dans le répertoire de données de l'instance mise à jour. La recherche des fichiers
       suivra les liens symboliques pour le répertoire des journaux de transactions et chaque tablespace
       configuré.
      </para>
      <para>
       Sous Linux, <literal>syncfs</literal> peut être utilisé à la place pour demander au
       système d'exploitation de synchroniser l'ensemble du système de fichiers contenant le
       répertoire de données de l'instance mise à jour, ses journaux de transactions et chaque tablespace.
       Consulter <xref linkend="guc-recovery-init-sync-method"/> pour obtenir des informations sur
       les mises en garde à prendre en compte lors de l'utilisation de <literal>syncfs</literal>.
      </para>
      <para>
       Cette option n'a pas d'effet quand <option>--no-sync</option> est utilisé.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-?</option></term>
     <term><option>--help</option></term>
     <listitem><para>afficher l'aide, puis quitter</para></listitem>
    </varlistentry>
   </variablelist>
  </para>

 </refsect1>

 <refsect1>
  <title>Usage</title>

  <para>
   Ci-dessous les étapes pour effectuer une mise à jour avec
   <application>pg_upgrade</application>&nbsp;:
  </para>

  <procedure>
   <step performance="optional">
    <title>Si nécessaire, déplacez l'ancienne instance</title>

    <para>
     Si vous utilisez un répertoire d'installation spécifique par
     version, exemple <filename>/opt/PostgreSQL/&majorversion;</filename>, vous
     n'avez pas besoin de déplacer l'ancienne instance. Les installateurs
     graphiques utilisent tous des répertoires d'installation
     spécifiques par version.
    </para>

    <para>
     Si votre répertoire d'installation n'est pas spécifique par
     version, par exemple <filename>/usr/local/pgsql</filename>, il est
     nécessaire de déplacer le répertoire d'installation courant de
     PostgreSQL de telle manière à ce qu'il n'interfère pas avec la nouvelle
     installation de <productname>PostgreSQL</productname>. Une fois
     que le serveur courant <productname>PostgreSQL</productname>
     est éteint, il est sans danger de renommer le répertoire
     d'installation de PostgreSQL&nbsp;; en supposant que l'ancien
     répertoire est <filename>/usr/local/pgsql</filename>, vous
     pouvez faire&nbsp;:

     <programlisting>mv /usr/local/pgsql /usr/local/pgsql.old</programlisting>

     pour renommer le répertoire.
    </para>
   </step>

   <step>
    <title>Pour les installations à partir des sources, construisez la
    nouvelle version</title>

    <para>
     Construisez la nouvelle version de PostgreSQL à partir des
     sources avec des options de <command>configure</command>
     qui sont compatibles avec l'ancienne instance.
     <application>pg_upgrade</application> utilisera
     <command>pg_controldata</command> pour s'assurer que l'ensemble
     des configurations sont compatibles avant de commencer la mise
     à jour.
    </para>
   </step>

   <step>
    <title>Installez les nouveaux binaires PostgreSQL</title>

    <para>
     Installez les binaires du nouveau serveur et les fichiers
     associés. Par défaut, <application>pg_upgrade</application> est
     inclus dans une installation.
    </para>

    <para>
     Pour les installations à partir des sources, si vous souhaitez
     installer le nouveau serveur dans un répertoire personnalisé, utilisez
     la variable <literal>prefix</literal>&nbsp;:

<programlisting>
make prefix=/usr/local/pgsql.new install
     </programlisting></para>
   </step>

   <step>
    <title>Initialisez la nouvelle instance PostgreSQL</title>

    <para>
     Initialisez la nouvelle instance en utilisant la commande
     <command>initdb</command>. À nouveau, utilisez des options de
     la commande <command>initdb</command> compatibles avec l'ancienne
     instance. Beaucoup d'installateurs pré-construits effectuent cette
     étape automatiquement. Il n'est pas nécessaire de démarrer
     la nouvelle instance.
    </para>
   </step>

   <step>
    <title>Installez les fichiers objets partagés d'extension</title>

    <para>
     Beaucoup d'extensions et de modules personnalisés, qu'ils viennent de
     <filename>contrib</filename> ou d'une autre source, utilisent les
     fichiers d'objets partagés (ou DLL), par exemple
     <filename>pgcrypto.so</filename>. Si l'ancienne instance les utilisait,
     les fichiers d'objets partagés correspondant aux binaires du nouveau
     serveur doivent être installés dans la nouvelle instance, habituellement
     avec les commandes du système d'exploitation. Ne chargez pas les
     définitions de schéma, par exemple <command>CREATE EXTENSION
     pgcrypto</command>, parce qu'elles seront dupliquées à partir de
     l'ancienne instance. Si des mises à jour d'extensions sont disponibles,
     <application>pg_upgrade</application> l'indiquera et créera un script à
     exécuter plus tard pour les mettre à jour.
    </para>
   </step>

   <step>
    <title>Copiez les fichiers personnalisés de recherche plein texte</title>

    <para>
     Copiez tous les fichiers personnalisés de recherche plein texte
     (dictionnaire, synonymes, thésaurus, mots d'arrêt) de l'ancienne
     instance vers la nouvelle.
    </para>
   </step>

   <step>
    <title>Ajustez l'authentification</title>

    <para>
     <command>pg_upgrade</command> se connectera à l'ancien et au
     nouveau serveur plusieurs fois, aussi vous pourriez avoir besoin
     de positionner l'authentification sur <literal>peer</literal>
     ou d'utiliser un fichier <filename>~/.pgpass</filename> (voir
     <xref linkend="libpq-pgpass"/>).
    </para>
   </step>

   <step>
    <title>Préparez la mise à jour des publieurs</title>

    <para>
     <application>pg_upgrade</application> essaie de migrer les slots de réplication
     logique. Cela évite de devoir manuellement définir les mêmes
     slots logiques sur le nouveau publieur. La migration des slots logiques est
     seulement supportée lorsque l'ancienne instance à migrer est en version 17.0 ou plus récente.
     Les slots logiques des instances antérieures à la version 17.0 seront ignorés
     silencieusement.
    </para>

    <para>
     Avant de démarrer la mise à jour des publieurs de l'instance, assurez-vous que
     l'abonnement correspondant est temporairement désactivé, en exécutant
     <link linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>.
     Réactiver l'abonnement après la mise à jour.
    </para>

    <para>
     Il y a certains prérequis pour que <application>pg_upgrade</application>
     puisse mettre à jour les slots de réplication logique. Si ceux-ci ne sont pas rencontrés,
     une erreur sera rapportée.
    </para>

    <itemizedlist>
     <listitem>
      <para>
       La nouvelle instance doit avoir
       <link linkend="guc-wal-level"><varname>wal_level</varname></link> à
       <literal>logical</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       La nouvelle instance doit avoir
       <link linkend="guc-max-replication-slots"><varname>max_replication_slots</varname></link>
       configuré à une valeur plus grande ou égale au nombre de slots
       présents dans l'ancienne instance.
      </para>
     </listitem>
     <listitem>
      <para>
       Les plugins de sortie référencés par les slots de l'ancienne instance doivent être
       installés dans le nouveau répertoire des exécutables PostgreSQL.
      </para>
     </listitem>
     <listitem>
      <para>
       L'ancienne instance a répliqué toutes les transactions et messages de décodage
       logique vers les abonnés.
      </para>
     </listitem>
     <listitem>
      <para>
       Tous les slots de l'ancienne instance doivent être utilisables, par exemple, il n'y a pas de slots
       dont
       <link linkend="view-pg-replication-slots">pg_replication_slots</link>.<structfield>conflicting</structfield>
       soit <literal>true</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       La nouvelle instance ne doit pas avoir de slots logique permanents, par exemple,
       il ne doit pas y avoir de slots où
       <link linkend="view-pg-replication-slots">pg_replication_slots</link>.<structfield>temporary</structfield>
       soit <literal>false</literal>.
      </para>
     </listitem>
    </itemizedlist>

   </step>

   <step>
    <title>Préparez la mise à jour des abonnés</title>

    <para>
     Mettre en place les <link linkend="logical-replication-config-subscriber">
     configurations des abonnés</link> sur le nouvel abonné.
     <application>pg_upgrade</application> tente de migrer les dépendances
     de l'abonnement, ce qui inclut les informations des tables de l'abonnement présentes dans
     le catalogue système <link linkend="catalog-pg-subscription-rel">pg_subscription_rel</link>
     ainsi que l'origine de réplication de l'abonnement. Cela permet
     à la réplication logique sur le nouvel abonné de reprendre là où
     l'ancien abonné s'était arrêté. La migration des dépendances de l'abonnement n'est
     prise en charge que lorsque l'ancienne instance est en version 17.0 ou ultérieure. Les dépendances
     des abonnements des instances antérieures à la version 17.0 seront ignorées silencieusement.
    </para>

    <para>
     Il y a certains prérequis pour que <application>pg_upgrade</application>
     puisse mettre à jour les abonnements. Si ceux-ci ne sont pas rencontrés, une erreur
     sera rapportée.
    </para>

    <itemizedlist>
     <listitem>
      <para>
       Toutes les tables de l'abonnement dans l'ancienne instance doivent être dans l'état
       <literal>i</literal> (initialize) ou <literal>r</literal> (ready). Cela
       peut se vérifier via <link linkend="catalog-pg-subscription-rel">pg_subscription_rel</link>.<structfield>srsubstate</structfield>.
      </para>
     </listitem>
     <listitem>
      <para>
       L'entrée d'origine de réplication correspondante à chacun des abonnements
       doit exister dans l'ancien cluster. Cela peut être vérifié en consultant
       les tables système
       <link linkend="catalog-pg-subscription">pg_subscription</link> et
       <link linkend="catalog-pg-replication-origin">pg_replication_origin</link>.
      </para>
     </listitem>
     <listitem>
      <para>
       La nouvelle instance doit avoir
       <link linkend="guc-max-replication-slots"><varname>max_replication_slots</varname></link>
       configuré à une valeur plus grande ou égale au nombre
       d'abonnements présents dans l'ancienne instance.
      </para>
     </listitem>
    </itemizedlist>
   </step>

   <step>
    <title>Arrêtez les deux serveurs</title>

    <para>
     Assurez vous que les deux serveurs sont arrêtés en utilisant,
     sur Unix par exemple&nbsp;:

     <programlisting>
pg_ctl -D /opt/PostgreSQL/12 stop
pg_ctl -D /opt/PostgreSQL/&majorversion; stop
     </programlisting>

     ou sur Windows, en utilisant les noms de services corrects&nbsp;:

     <programlisting>
NET STOP postgresql-12
NET STOP postgresql-&majorversion;
     </programlisting>
    </para>

    <para>
     Les serveurs standby par réplication en flux et par copie
     des journaux doivent être en cours d'exécution jusqu'à une étape
     ultérieure.
    </para>
   </step>

   <step>
    <title>Préparez la mise à jour d'un serveur standby</title>

    <para>
     Si vous êtes en train de mettre à jour des serveurs standby
     en suivant la description de la section <xref
     linkend="pgupgrade-step-replicas"/>, vérifiez
     en utilisant <application>pg_controldata</application> sur
     les anciennes instances primaires et standby que les anciens
     serveurs standby sont à jour. Vérifiez que les valeurs de
     <quote>Latest checkpoint location</quote> correspondent dans
     toutes les instances.
     De plus, assurez-vous que le paramètre <varname>wal_level</varname> ne
     soit pas configuré avec la valeur <literal>minimal</literal> dans le
     fichier de configuration <filename>postgresql.conf</filename> sur la
     nouvelle instance primaire.
    </para>
   </step>

   <step>
    <title>Lancez <application>pg_upgrade</application></title>

    <para>
     Lancez toujours le binaire <application>pg_upgrade</application>
     du nouveau serveur, pas celui de
     l'ancien. <application>pg_upgrade</application> exige la
     spécification des anciens et des nouveaux répertoires de
     données et des exécutables (<filename>bin</filename>). Vous
     pouvez aussi indiquer des valeurs pour les utilisateurs et les
     ports, et si vous voulez que les fichiers de données soient liées ou clonées
     plutôt que copiées (par défaut ce dernier).
    </para>

    <para>
     Si vous utilisez le mode lien, la mise à jour sera beaucoup plus rapide
     (pas de copie de fichiers) et utilisera moins d'espace disque, mais vous
     ne serez plus en mesure d'accéder à votre ancienne instance une fois que
     la nouvelle instance sera démarrée après la mise à jour. Le mode lien
     exige également que le répertoire de données de l'ancienne et de la
     nouvelle instance soient dans le même système de fichiers. (Les
     tablespaces et <filename>pg_wal</filename> peuvent être sur des systèmes
     de fichiers différents.) Le mode de clonage fournit les mêmes avantages
     au niveau vitesse et espace disque mais ne rend pas l'ancienne instance
     inutilisable une fois que la nouvelle instance a été démarrée. Le mode de
     clonage requiert aussi que les répertoires de données de l'ancienne et la
     nouvelle instances soient dans le même système de fichiers. Ce mode est
     seulement disponible sur certains systèmes d'exploitation et certains
     systèmes de fichiers.
    </para>

    <para>
     L'option <option>--jobs</option> permet l'utilisation de plusieurs
     cœurs CPU pour copier ou lier des fichiers, et pour sauvegarder
     et recharger les schémas des bases de données en parallèle&nbsp;;
     un bon chiffre pour commencer est le maximum du nombre de cœurs
     CPU et des tablespaces. Cette option peut réduire drastiquement
     le temps pour mettre à jour un serveur avec plusieurs bases de
     données s'exécutant sur une machine multiprocesseur.
    </para>

    <para>
     Pour les utilisateurs Windows, vous devez être connecté avec
     un compte administrateur, puis lancez
     <application>pg_upgrade</application> avec les
     répertoires entre guillemets, par exemple&nbsp;:

     <programlisting>
pg_upgrade.exe
        --old-datadir "C:/Program Files/PostgreSQL/12/data"
        --new-datadir "C:/Program Files/PostgreSQL/&majorversion;/data"
        --old-bindir "C:/Program Files/PostgreSQL/12/bin"
        --new-bindir "C:/Program Files/PostgreSQL/&majorversion;/bin"
     </programlisting>

     Une fois démarré, <command>pg_upgrade</command> vérifiera que les deux
     instances sont compatibles avant d'effectuer la mise à jour. Vous pouvez
     utiliser <command>pg_upgrade --check</command> pour effectuer uniquement
     la vérification, y compris si l'ancien serveur est actuellement en
     fonctionnement. <command>pg_upgrade --check</command> mettra également
     en évidence les ajustements manuels nécessaires que vous aurez besoin de
     faire après la mise à jour. Si vous désirez utiliser le mode lien ou le mode clone,
     vous devriez indiquer l'option <option>--link</option> ou <option>--clone</option> avec l'option
     <option>--check</option> pour activer les vérifications spécifiques
     au mode lien. <command>pg_upgrade</command> doit avoir le droit
     d'écrire dans le répertoire courant.
    </para>

    <para>
     Évidemment, personne ne doit accéder aux instances pendant
     la mise à jour. <application>pg_upgrade</application> lance par
     défaut les serveurs sur le port 50432 pour éviter les connexions
     non désirées de clients. Vous pouvez utilisez le même numéro de
     port pour les deux instances lors d'une mise à jour car l'ancienne et
     la nouvelle instance ne fonctionneront pas en même temps. Cependant,
     lors de la vérification d'un ancien serveur en fonctionnement,
     l'ancien et le nouveau numéros de port doivent être différents.
    </para>

    <para>
     Si une erreur survient lors de la restauration du schéma de la
     base de données, <command>pg_upgrade</command> quittera et vous
     devrez revenir à l'ancienne instance comme décrit ci-dessous
     (<xref linkend="pgupgrade-step-revert"/>). Pour réessayer
     <command>pg_upgrade</command>, vous aurez besoin de modifier
     l'ancienne instance de telle manière que la restauration du
     schéma par pg_upgrade réussisse. Si le problème est un module
     <filename>contrib</filename>, vous pourriez avoir besoin de
     désinstaller le module <filename>contrib</filename> de l'ancienne
     instance et le réinstaller dans la nouvelle instance après la
     mise à jour, en supposant que le module n'est pas utilisé pour
     stocker des données utilisateur.
    </para>
   </step>

   <step id="pgupgrade-step-replicas">
    <title>Mettez à jour les serveurs standby par réplication en flux
     ou par copie de journaux de transactions</title>

    <para>
     Si vous utilisez le mode lien et avez des serveurs standby par
     réplication continue (voir <xref linkend="streaming-replication"/>) ou
     par copie des journaux de transactions (voir <xref
     linkend="warm-standby"/>), vous pouvez suivre les étapes ci-dessous pour
     les mettre à jour rapidement. Vous ne lancerez pas
     <application>pg_upgrade</application> sur les serveurs standby, mais
     plutôt <application>rsync</application> sur le primaire. Ne démarrez
     encore aucun serveur.
    </para>

    <para>
     Si vous n'utilisez <emphasis>pas</emphasis> le mode lien, n'avez pas ou
     ne voulez pas utiliser <application>rsync</application>, ou si vous
     voulez une solution plus simple, ignorez les instructions de cette
     section et recréez simplement les serveurs standbys une fois que
     <application>pg_upgrade</application> a terminé et que le nouveau
     primaire fonctionne de nouveau.
    </para>

    <procedure>

     <step>
      <title>Installez les nouveaux binaires PostgreSQL sur les serveurs standby</title>

      <para>
       Assurez-vous que les nouveaux binaires et fichiers de support
       sont installés sur tous les serveurs standby.
      </para>
     </step>

     <step>
      <title>Assurez vous que les nouveaux répertoires de données sur
       les serveurs standby n'existent <emphasis>pas</emphasis></title>

      <para>
       Assurez vous que les nouveaux répertoires de données sur les serveurs
       standby n'existent <emphasis>pas</emphasis> ou sont vides. Si
       <application>initdb</application> a été lancé, détruisez les nouveaux
       répertoires de données des serveurs standby.
      </para>
     </step>

     <step>
      <title>Installez les fichiers objets partagés d'extension</title>

      <para>
       Installez les mêmes fichiers objets partagés d'extension
       sur les nouveaux serveurs standby que vous avez installé sur la
       nouvelle instance primaire.
      </para>
     </step>

     <step>
      <title>Arrêtez les serveurs standby</title>

      <para>
       Si les serveurs standby sont encore lancés, arrêtez les
       maintenant en utilisant les instructions ci-dessus.
      </para>
     </step>

     <step>
      <title>Sauvegardez les fichiers de configuration</title>

      <para>
       Sauvegardez tous les fichiers de configuration des anciens serveurs
       standby que vous avez besoin de conserver, par exemple
       <filename>postgresql.conf</filename> (et tout fichier qu'il inclut),
       <filename>postgresql.auto.conf</filename>,
       <literal>pg_hba.conf</literal>, dans la mesure où ceux-ci seront
       réécrits ou supprimés dans l'étape suivante.
      </para>
     </step>

     <step>
      <title>Lancez <application>rsync</application></title>

      <para>
       Lors de l'utilisation du mode lien, les serveurs standbys peuvent être
       rapidement mis à jour en utilisant <application>rsync</application>.
       Pour cela, à partir d'un répertoire du serveur primaire situé au-dessus
       des répertoires de l'ancienne et de la nouvelle instance de bases de
       données, exécutez cette commande sur le <emphasis>primaire</emphasis>
       pour chaque serveur standby&nbsp;:

       <programlisting>
rsync --archive --delete --hard-links --size-only --no-inc-recursive ancien_rep_config nouveau_rep_config repertoire_distant
       </programlisting>

       où <option>ancien_rep_config</option> et <option>nouveau_rep_config</option>
       sont relatifs au répertoire courant du serveur primaire, et
       <option>repertoire_distant</option> est <emphasis>au-dessus</emphasis>
       des ancien et nouveau répertoires des instances sur le serveur standby.
       La structure des répertoires sous les répertoires spécifiés du primaire
       et des secondaires doit correspondre. Consultez les pages du manuel de
       <application>rsync</application> pour des détails sur la manière de
       spécifier le répertoire distant, par exemple&nbsp;:

       <programlisting>
rsync --archive --delete --hard-links --size-only --no-inc-recursive /opt/PostgreSQL/12 \
      /opt/PostgreSQL/&majorversion; standby.example.com:/opt/PostgreSQL
       </programlisting>

       Vous pouvez vérifier ce que la commande va faire en utilisant l'option
       <option>--dry-run</option> de <application>rsync</application>. Alors
       que <application>rsync</application> doit être exécuté sur le primaire
       pour au moins un serveur standby, il est possible d'exécuter
       <application>rsync</application> sur un standby mis à jour pour mettre
       à jour les autres standbys tant que le standby mis à jour n'est pas
       démarré.
      </para>

      <para>
       Cela enregistre les liens créés par le mode lien de
       <application>pg_upgrade</application> qui connecte les fichiers dans
       les ancienne et nouvelle instances du serveur primaire. Puis, il trouve
       les fichiers correspondant dans l'ancienne instance du standby et crée
       les liens pour eux dans la nouvelle instance du serveur standby. Les
       fichiers qui n'ont pas été liés sur le primaire sont copiés sur à
       partir du serveur primaire vers le serveur secondaire. (Ils sont
       généralement petits.) Ceci fournit des mises à jour rapides des
       serveurs secondaires. Malheureusement, <application>rsync</application>
       copie sans raison les fichiers associés aux tables temporaires et non
       journalisées parce que ces fichiers n'existent normalement pas sur les
       serveurs secondaires.
      </para>

      <para>
       Si vous avez des tablespaces, vous aurez besoin de lancer
       une commande <application>rsync</application> similaire pour
       chaque répertoire de tablespace, par exemple&nbsp;:

       <programlisting>
rsync --archive --delete --hard-links --size-only --no-inc-recursive /vol1/pg_tblsp/PG_12_201909212 \
      /vol1/pg_tblsp/PG_&majorversion;_202307071 standby.example.com:/vol1/pg_tblsp
       </programlisting>

       Si vous avez déplacé
       <filename>pg_wal</filename> en dehors des répertoires de
       données, <application>rsync</application> doit être lancé
       aussi sur ces répertoires.
      </para>
     </step>

     <step>
      <title>Configurez les serveurs standby par réplication en flux ou par copie de journaux de transactions</title>

      <para>
       Configurez les serveurs pour les copies des journaux
       de transactions. (Vous n'avez pas besoin d'exécuter
       les fonctions <function>pg_backup_start()</function> et
       <function>pg_backup_stop()</function> ou d'effectuer une sauvegarde
       des fichiers car les secondaires sont toujours synchronisés avec
       le primaire.) Si l'ancien primaire est en version antérieure à la 17.0, alors
       aucun slot de réplication du primaire ne sera copié vers le nouveau standby, ainsi tous les slots sur
       l'ancien standby doivent être recréés manuellement. Si l'ancien primaire est
       en version 17.0 ou ultérieure, alors seulement les slots logiques du primaire seront copiés
       vers le nouveau standby, mais les autres slots de l'ancien standby ne seront pas copiés
       et devront donc être recréés manuellement.
      </para>
     </step>

    </procedure>

   </step>

   <step>
    <title>Restaurez <filename>pg_hba.conf</filename></title>

    <para>
     Si vous avez modifié <filename>pg_hba.conf</filename>,
     restaurez cette configuration d'origine. Il peut être aussi
     nécessaire d'ajuster d'autres fichiers de configuration dans la
     nouvelle instance pour correspondre à l'ancienne instance, par exemple
     <filename>postgresql.conf</filename> (et tout fichier qu'il inclut),
     <filename>postgresql.auto.conf</filename>.
    </para>
   </step>

   <step>
    <title>Démarrez le nouveau serveur</title>

    <para>
     Le nouveau serveur peut maintenant être démarré en toute
     sécurité, puis les autres serveurs standby synchronisés avec
     <application>rsync</application>.
    </para>
   </step>

   <step>
    <title>Traitements après mise à jour</title>

    <para>
     Si des traitements après mise à jour sont nécessaires,
     pg_upgrade affichera des avertissements lors de son travail. Il
     générera également des scripts qui devront être lancés par
     l'administrateur. Les scripts se connecteront à chaque base de
     données qui ont besoin de traitements après mise à jour. Chaque
     script devrait être lancé comme suit&nbsp;:

     <programlisting>
psql --username=postgres --file=script.sql postgres
     </programlisting>

     Les scripts peuvent être lancés dans n'importe quel ordre et
     détruits une fois terminés.
    </para>

    <caution>
     <para>
      Généralement, il n'est pas sûr d'accéder à des tables référencées
      dans les scripts de reconstruction avant la fin de leurs traitements&nbsp;;
      le faire pourrait entraîner des résultats incorrects ou de
      médiocres performances. Les tables non référencées dans les
      scripts de reconstruction peuvent être accédées immédiatement.
     </para>
    </caution>
   </step>

   <step>
    <title>Statistiques</title>

    <para>
     Parce que les statistiques de l'optimiseur ne sont pas transférées
     par <command>pg_upgrade</command>, vous serez invités à lancer
     une commande pour regénérer les statistiques à la fin de la mise
     à jour. Vous pourriez avoir besoin de positionner les paramètres
     de connexion pour qu'ils correspondent à votre nouvelle instance.
    </para>

    <para>
     Utiliser <command>vacuumdb --all --analyze-only</command> peut efficacement
     générer de tels statistiques, et l'utilisation de <option>--jobs</option>
     peut l'accélérer. L'option <option>--analyze-in-stages</option>
     peut être utilisée pour générer des statistiques minimales rapidement.
     Si <varname>vacuum_cost_delay</varname> est positionné à une valeur différente
     de zéro, cela peut être outrepassé pour accélérer la génération des statistiques
     en utilisant <envar>PGOPTIONS</envar>, par exemple, <literal>PGOPTIONS='-c
     vacuum_cost_delay=0' vacuumdb ...</literal>.
    </para>
   </step>

   <step>
    <title>Détruire les anciennes instances</title>

    <para>
     Une fois que vous êtes satisfait de la mise à jour, vous pouvez
     détruire les répertoires de données des anciennes instances en
     lançant le script indiqué par <command>pg_upgrade</command>
     à la fin de son traitement. (La destruction automatique n'est
     pas possible si vous avez défini des tablespaces personnalisés
     dans l'ancien répertoire de données.) Vous pouvez également
     supprimer les anciens répertoires d'installation (par exemple
     <filename>bin</filename>, <filename>share</filename>).
    </para>
   </step>

   <step id="pgupgrade-step-revert" performance="optional">
    <title>Revenir à l'ancienne instance</title>

    <para>
     Si, après avoir lancé <command>pg_upgrade</command>, vous désirez
     revenir à l'ancienne instance, il y a plusieurs options&nbsp;:

     <itemizedlist>
      <listitem>
       <para>
        Si l'option <option>--check</option> a été utilisée, l'ancienne
        instance n'a pas été modifiée, elle peut être redémarrée.
       </para>
      </listitem>

      <listitem>
       <para>
        Si l'option <option>--link</option> n'a <emphasis>pas</emphasis> été
        utilisée, l'ancienne instance n'a pas été modifiée, elle peut être
        redémarrée.
       </para>
      </listitem>

      <listitem>
       <para>
        Si l'option <option>--link</option> a été utilisée, les fichiers de
        données pourraient être partagés entre l'ancienne instance et la
        nouvelle&nbsp;:
        <itemizedlist>
         <listitem>
          <para>
           Si <command>pg_upgrade</command> a annulé avant de réaliser les
           liens, l'ancienne instance n'a pas été modifiée, elle peut être
           redémarrée.
          </para>
         </listitem>

         <listitem>
          <para>
           Si vous n'avez <emphasis>pas</emphasis> démarré la nouvelle
           instance, l'ancienne instance n'a pas été modifiée sauf, quand les
           liens ont commencé, un suffixe <literal>.old</literal> a été ajouté
           au fichier <filename>$PGDATA/global/pg_control</filename>. Pour
           utiliser de nouveau l'ancienne instance, supprimez le suffixe
           <filename>.old</filename> du fichier
           <filename>$PGDATA/global/pg_control</filename>&nbsp;; vous pouvez
           alors redémarrer l'ancienne instance.
          </para>
         </listitem>

         <listitem>
          <para>
           Si vous avez démarré la nouvelle instance, elle a écrit dans des
           fichiers partagés et il est dangereux d'utiliser l'ancienne
           instance. Cette dernière doit être restaurée d'une sauvegarde dans
           ce cas.
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </step>
  </procedure>
 </refsect1>

 <refsect1>
  <title>Environnement</title>

  <para>
   Certaines variables d'environnement peuvent être utilisées pour fournir des valeurs par défaut aux options en ligne de commande :

   <variablelist>
    <varlistentry>
     <term><envar>PGBINOLD</envar></term>

     <listitem>
      <para>
       L'ancien répertoire des exécutables PostgreSQL; option
       <option>-b</option>/<option>--old-bindir</option>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><envar>PGBINNEW</envar></term>

     <listitem>
      <para>
       Le nouveau répertoire des exécutables PostgreSQL; option
       <option>-B</option>/<option>--new-bindir</option>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><envar>PGDATAOLD</envar></term>

     <listitem>
      <para>
       Le répertoire de configuration de l'ancienne instance; option
       <option>-d</option>/<option>--old-datadir</option>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><envar>PGDATANEW</envar></term>

     <listitem>
      <para>
       Le répertoire de configuration de la nouvelle instance; option
       <option>-D</option>/<option>--new-datadir</option>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><envar>PGPORTOLD</envar></term>

     <listitem>
      <para>
       Le numéro de port de l'ancienne instance; option
       <option>-p</option>/<option>--old-port</option>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><envar>PGPORTNEW</envar></term>

     <listitem>
      <para>
       Le numéro de port de la nouvelle instance; option
       <option>-P</option>/<option>--new-port</option>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><envar>PGSOCKETDIR</envar></term>

     <listitem>
      <para>
       Le répertoire à utiliser pour les sockets du processus postmaster pendant la mise à jour; option
       <option>-s</option>/<option>--socketdir</option>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><envar>PGUSER</envar></term>

     <listitem>
      <para>
       Nom d'utilisateur de l'instance d'installation; option
       <option>-U</option>/<option>--username</option>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   <application>pg_upgrade</application> crée différents fichiers de travail,
   tel que des sauvegardes de schémas, enregistré dans le sous-répertoire
   <filename>pg_upgrade_output.d</filename> du répertoire principal de la nouvelle
   instance. Chaque exécution crée un sous-répertoire nommé avec un horodatage
   formaté d'après ISO 8601 (<literal>%Y%m%dT%H%M%S</literal>), où tous ses
   fichiers générés sont stockés.
   <filename>pg_upgrade_output.d</filename> et ses fichiers seront supprimés
   automatiquement si <application>pg_upgrade</application> se termine
   avec succès&nbsp;; en cas de problème, ses fichiers pourraient fournir
   des informations de debug très utiles.
  </para>

  <para>
   <application>pg_upgrade</application> lance brièvement les serveurs dans
   les ancien et nouveau répertoires de données. Les fichiers temporaires des
   sockets Unix pour communiquer avec ces serveurs sont, par défaut, créés
   dans le répertoire courant. Dans certaines situations, le nom du chemin
   pour le répertoire courant pourrait être trop long pour être un nom de
   socket valide. Dans ce cas, vous pouvez utiliser l'option
   <option>-s</option> pour placer les fichiers socket dans un autre
   répertoire dont le nom du chemin est plus court. Pour des raisons de
   sécurité, assurez-vous que le répertoire n'est ni lisible ni modifiable par
   les autres utilisateurs. (Ceci n'est pas applicable à Windows.)
  </para>

  <para>
   Tous les échecs, reconstructions et réindexations seront
   reportés par <application>pg_upgrade</application> s'ils
   affectent votre installation&nbsp;; les scripts d'après mise à
   jour pour reconstruire les tables et index seront générés
   automatiquement. Si vous essayez d'automatiser la mise à jour de
   plusieurs instances, vous devriez constater que les instances avec
   des schémas de bases de données identiques ont besoin des mêmes
   étapes après mise à jour&nbsp;; car les étapes après mise à jour
   sont basées sur les schémas des bases de données, et pas sur
   les données utilisateurs.
  </para>

  <para>
   Pour les déploiements de tests, créez uniquement une copie du
   schéma de l'ancienne instance, insérez des données de tests, et faites
   la mise à jour.
  </para>

  <para>
   <application>pg_upgrade</application> ne supporte pas la mise à jour de
   bases de données contenant des colonnes de table utilisant les types de
   données systèmes référençant les OID, nommés <type>reg*</type>&nbsp;:
   <simplelist>
    <member><type>regcollation</type></member>
    <member><type>regconfig</type></member>
    <member><type>regdictionary</type></member>
    <member><type>regnamespace</type></member>
    <member><type>regoper</type></member>
    <member><type>regoperator</type></member>
    <member><type>regproc</type></member>
    <member><type>regprocedure</type></member>
   </simplelist>
   (<type>regclass</type>, <type>regrole</type> et <type>regtype</type> peuvent
   être mis à jour.)
  </para>

  <para>
   Si vous souhaitez utiliser le mode lien et ne voulez pas que
   votre ancienne instance ne soit modifiée lorsque la nouvelle instance est
   démarrée, considérez l'utilisation du mode clone. Si ce n'est pas possible,
   faites une copie de l'ancienne instance et faites la mise
   à jour à partir de cette copie. Pour faire une copie valide de
   l'ancienne instance, utilisez <command>rsync</command> pour effectuer une
   copie grossière de l'ancienne instance lancée, puis arrêtez l'ancien
   serveur et lancez <command>rsync --checksum</command> à nouveau
   pour mettre à jour la copie dans un état cohérent avec tous les
   changements. (L'option <option>--checksum</option> est nécessaire
   car <command>rsync</command> n'a une granularité sur les dates de
   modification de fichiers que d'une seconde.) Vous pourriez souhaiter
   exclure certains fichiers, par exemple <filename>postmaster.pid</filename>,
   comme documenté à <xref linkend="backup-lowlevel-base-backup"/>. Si
   votre système de fichiers supporte les images de système de fichiers
   ou la fonctionnalité Copy-On-Write, vous pouvez utiliser ces
   fonctionnalités pour faire une sauvegarde de l'ancienne instance et
   des tablespaces, bien que l'image et les copies doivent être créées
   simultanément ou lorsque le serveur de bases de données est éteint.
  </para>

 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="app-initdb"/></member>
   <member><xref linkend="app-pg-ctl"/></member>
   <member><xref linkend="app-pgdump"/></member>
   <member><xref linkend="app-postgres"/></member>
  </simplelist>
 </refsect1>
</refentry>
