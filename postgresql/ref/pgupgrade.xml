<?xml version="1.0" encoding="UTF-8"?>
<refentry id="pgupgrade">
 <indexterm zone="pgupgrade">
  <primary>pg_upgrade</primary>
 </indexterm>

 <refmeta>
  <refentrytitle><application>pg_upgrade</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>pg_upgrade</refname>
  <refpurpose>met à jour une instance du serveur <productname>PostgreSQL</productname></refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <cmdsynopsis>
   <command>pg_upgrade</command>
   <arg choice="plain"><option>-b</option></arg>
   <arg choice="plain"><replaceable>ancien_repertoire_executables</replaceable></arg>
   <arg choice="opt"><option>-B</option> <replaceable>nouveau_repertoire_executables</replaceable></arg>
   <arg choice="plain"><option>-d</option></arg>
   <arg choice="plain"><replaceable>ancien_repertoire_configuration</replaceable></arg>
   <arg choice="plain"><option>-D</option></arg>
   <arg choice="plain"><replaceable>nouveau_repertoire_configuration</replaceable></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <application>pg_upgrade</application> (antérieurement connu
   sous le nom <application>pg_migrator</application>) permet
   de mettre à jour les fichiers de données vers une version
   plus récente de <productname>PostgreSQL</productname> sans la
   sauvegarde et le rechargement de données typiquement requis
   pour les mises à jour d'une version majeure vers une autre,
   par exemple d'une version 12.14 à une version 13.10 ou à partir de 14.9
   vers 15.5. Il n'est pas nécessaire pour les mises à jour de versions
   mineures, par exemple de 12.7 à 12.8 ou de 14.1 à 14.5.
  </para>

  <para>
   Les sorties de version majeures de PostgreSQL ajoutent
   régulièrement de nouvelles fonctionnalités qui changent souvent
   la structure des tables système, mais le format interne des données
   stockées change rarement. <application>pg_upgrade</application>
   utilise ce fait pour effectuer des mises à jour rapides en créant
   de nouvelles tables systèmes et en réutilisant les anciens fichiers
   de données. Si jamais une future version majeure devait modifier le format
   d'enregistrement des données de telle sorte que l'ancien format
   des données soit illisible, <application>pg_upgrade</application>
   ne pourrait pas être utilisé pour ces mises à jour. (La communauté
   essaiera d'éviter de telles situations.)
  </para>

  <para>
   <application>pg_upgrade</application> fait de son mieux pour être
   sûr que la nouvelle et l'ancienne instances soient compatibles au niveau
   binaire, par exemple en vérifiant que les options de compilation
   sont compatibles, y compris le format 32/64 bits des binaires. Il
   est également important que les modules externes soient aussi
   compatibles au plan binaire, bien que ceci ne puisse être
   vérifié par <application>pg_upgrade</application>.
  </para>

  <para>
   pg_upgrade supporte les mises à jour à partir de la version
   9.2.X et suivantes jusqu'à la version majeure courante de
   <productname>PostgreSQL</productname>, y compris les images et
   versions beta.
  </para>
 </refsect1>

 <refsect1>
  <title>Options</title>

  <para>
   <application>pg_upgrade</application> accepte les arguments de ligne de
   commande suivants&nbsp;:

   <variablelist>

    <varlistentry>
     <term><option>-b</option> <replaceable>repertoire_executables</replaceable></term>
     <term><option>--old-bindir=</option><replaceable>repertoire_executables</replaceable></term>
     <listitem><para>l'ancien répertoire des exécutables PostgreSQL&nbsp;;
       variable d'environnement <envar>PGBINOLD</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-B</option> <replaceable>repertoire_executables</replaceable></term>
     <term><option>--new-bindir=</option><replaceable>repertoire_executables</replaceable></term>
     <listitem><para>le nouveau répertoire des exécutables PostgreSQL&nbsp;;
       la valeur par défaut est le répertoire d'installation de
       <application>pg_upgrade</application>&nbsp;; variable d'environnement
       <envar>PGBINNEW</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-c</option></term>
     <term><option>--check</option></term>
     <listitem><para>uniquement la vérification des instances, ne
       modifie aucune donnée</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-d</option> <replaceable>repertoire_configuration</replaceable></term>
     <term><option>--old-datadir=</option><replaceable>repertoire_configuration</replaceable></term>
     <listitem><para>répertoire de configuration de l'ancienne instance&nbsp;;
       variable d'environnement<envar>PGDATAOLD</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-D</option> <replaceable>repertoire_configuration</replaceable></term>
     <term><option>--new-datadir=</option><replaceable>repertoire_configuration</replaceable></term>
     <listitem><para>répertoire de configuration de la nouvelle instance&nbsp;;
       variable d'environnement <envar>PGDATANEW</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-j <replaceable class="parameter">njobs</replaceable></option></term>
     <term><option>--jobs=<replaceable class="parameter">njobs</replaceable></option></term>
     <listitem><para>nombres de connexions et processus simultanés à utiliser
      </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-k</option></term>
     <term><option>--link</option></term>
     <listitem><para>utiliser des liens physiques au lieu de copier les
       fichiers vers la nouvelle instance</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-N</option></term>
     <term><option>--no-sync</option></term>
     <listitem>
      <para>
       Par défaut, <command>pg_upgrade</command> attendra que tous les fichiers
       de l'instance mise à jour soient écrits sur disque. Cette option fait
       que <command>pg_upgrade</command> quitte sans attendre, ce qui est plus
       rapide mais signifie qu'un crash ultérieur du système d'exploitation peut
       laisser le répertoire de données corrompu. Généralement, cette option est
       utile dans le cas de tests mais elle ne devrait pas être utilisée pour
       une installation en production.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><option>--no-statistics</option></term>
     <listitem>
      <para>
       Ne restaure pas les statistiques de l’ancien cluster dans le nouveau cluster.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-o</option> <replaceable class="parameter">options</replaceable></term>
     <term><option>--old-options</option> <replaceable class="parameter">options</replaceable></term>
     <listitem><para>options à passer directement à l'ancienne commande
       <command>postgres</command>&nbsp;; les invocations multiples de cette
       option sont cumulées</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-O</option> <replaceable class="parameter">options</replaceable></term>
     <term><option>--new-options</option> <replaceable class="parameter">options</replaceable></term>
     <listitem><para>options à passer directement à la nouvelle
       commande <command>postgres</command>&nbsp;; les invocations multiples
       de cette commande sont cumulées</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-p</option> <replaceable>port</replaceable></term>
     <term><option>--old-port=</option><replaceable>port</replaceable></term>
     <listitem><para>le numéro de port de l'ancienne instance&nbsp;; variable
       d'environnement<envar>PGPORTOLD</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-P</option> <replaceable>port</replaceable></term>
     <term><option>--new-port=</option><replaceable>port</replaceable></term>
     <listitem><para>le numéro de port de la nouvelle instance&nbsp;; variable
       d'environnement<envar>PGPORTNEW</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-r</option></term>
     <term><option>--retain</option></term>
     <listitem><para>conserver les fichiers SQL et de traces y compris
       après avoir terminé avec succès</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-s</option> <replaceable>dir</replaceable></term>
     <term><option>--socketdir=</option><replaceable>dir</replaceable></term>
     <listitem><para>répertoire utilisé pour stocker les sockets lors de la
       mise à jour&nbsp;; la valeur par défaut est le répertoire courant&nbsp;;
       la variable d'environnement est <envar>PGSOCKETDIR</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-U</option> <replaceable>username</replaceable></term>
     <term><option>--username=</option><replaceable>username</replaceable></term>
     <listitem><para>nom d'utilisateur de l'instance d'installation&nbsp;;
       variable d'environnement<envar>PGUSER</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-v</option></term>
     <term><option>--verbose</option></term>
     <listitem><para>activer la trace interne verbeuse</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-V</option></term>
     <term><option>--version</option></term>
     <listitem><para>afficher les informations de version, puis quitter</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>--clone</option></term>
     <listitem>
      <para>
       Utilise le clonage efficace de fichiers (connu aussi sous le nom de
       <quote>reflinks</quote> sur certains systèmes) au lieu de copier les
       fichiers vers la nouvelle instance. Ceci peut résulter en une copie
       pratiquement instantanée des fichiers de données, donnant l'avantage
       en vitesse de l'option <option>-k</option>/<option>--link</option>
       tout en laissant l'ancienne instance non modifiée.
      </para>

      <para>
       Le clonage de fichiers est seulement supporté sur certains systèmes
       d'exploitation et systèmes de fichiers. Si cette option est
       sélectionnée alors qu'elle n'est pas supportée, l'exécution de
       <application>pg_upgrade</application> renverra une erreur.
       Actuellement, cette option est supportée sous Linux (à partir du noyau
       4.5) avec Btrfs et XFS (pour les systèmes de fichiers créés avec le
       support de reflink), et sur macOS avec APFS.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><option>--copy</option></term>
     <listitem>
      <para>
       Copie les fichiers sur la nouvelle instance. Cette option est activée
       par défaut. (Voir aussi
       <option>--link</option>, <option>--clone</option>,
       <option>--copy-file-range</option> et <option>--swap</option>.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><option>--copy-file-range</option></term>
     <listitem>
      <para>
       Utiliser l'appel système <function>copy_file_range</function> pour un clonage
       efficace. Sur certains systèmes de fichiers, cela donne des résultats similaires à
       <option>--clone</option> en partageant les blocs physiques du disque, tandis que sur d'autres,
       cet appel pourrait copier les blocs mais en le faisant de manière optimisée. Actuellement,
       ceci est supporté sur Linux et FreeBSD.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><option>--swap</option></term>
     <listitem>
      <para>
       Déplacez les répertoires de données de l'ancien cluster vers le nouveau.
       Ensuite, remplacez les fichiers catalogue par ceux générés pour le nouveau
       cluster. Ce mode peut surpasser <option>--link</option>,
       <option>--clone</option>, <option>--copy</option> et
       <option>--copy-file-range</option>, en particulier sur les clusters comportant de nombreuses
       relations.
      </para>
      <para>
       Cependant, ce mode crée de nombreux fichiers inutiles dans l'ancien cluster, ce
       qui peut prolonger la synchronisation des fichiers si
       <option>--sync-method=syncfs</option> est utilisé. Il est donc
       recommandé d'utiliser <option>--sync-method=fsync</option> avec
       <option>--swap</option>.
      </para>
      <para>
       De plus, une fois l'étape de transfert de fichiers commencée, l'ancien cluster
       sera modifié de manière destructive et ne pourra donc plus être démarré en toute
       sécurité. Voir <xref linkend="pgupgrade-step-revert"/> pour plus de détails.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><option>--sync-method=</option><replaceable>méthode</replaceable></term>
     <listitem>
      <para>
       Quand positionné à <literal>fsync</literal>, ce qui est la valeur par défaut,
       <command>pg_upgrade</command> va ouvrir récursivement et synchroniser sur disque tous
       les fichiers présents dans le répertoire de données de l'instance mise à jour. La recherche des fichiers
       suivra les liens symboliques pour le répertoire des journaux de transactions et chaque tablespace
       configuré.
      </para>
      <para>
       Sous Linux, <literal>syncfs</literal> peut être utilisé à la place pour demander au
       système d'exploitation de synchroniser l'ensemble du système de fichiers contenant le
       répertoire de données de l'instance mise à jour, ses journaux de transactions et chaque tablespace.
       Consulter <xref linkend="guc-recovery-init-sync-method"/> pour obtenir des informations sur
       les mises en garde à prendre en compte lors de l'utilisation de <literal>syncfs</literal>.
      </para>
      <para>
       Cette option n'a pas d'effet quand <option>--no-sync</option> est utilisé.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><option>--set-char-signedness=</option><replaceable>option</replaceable></term>
     <listitem>
      <para>
       Définissez manuellement la signature par défaut des nouveaux clusters. Les valeurs possibles
       sont <literal>signed</literal> et <literal>unsigned</literal>.
      </para>
      <para>
       En langage C, la signature par défaut du type <type>char</type>
       (lorsqu'elle n'est pas explicitement spécifiée) varie selon les plateformes. Par exemple,
       <type>char</type> est par défaut <type>signed char</type> sur les processeurs x86, mais
       <type>unsigned char</type> sur les processeurs ARM.
      </para>
      <para>
       À partir de <productname>PostgreSQL</productname> 18, les clusters de bases de données
       conservent leur propre paramètre de signature de caractères par défaut, qui peut être utilisé pour
       garantir un comportement cohérent sur les plateformes ayant des signatures de caractères
       par défaut différentes. Par défaut, <application>pg_upgrade</application> conserve
       le paramètre de signature de caractères lors de la mise à niveau depuis un cluster existant.
       Cependant, lors de la mise à niveau depuis <productname>PostgreSQL</productname> 17 ou
       une version antérieure, <application>pg_upgrade</application> adopte la signature de caractères
       de la plateforme sur laquelle il a été construit.
      </para>
      <para>
       Cette option vous permet de définir explicitement la signature des caractères par défaut du
       nouveau cluster, remplaçant ainsi les valeurs héritées. Cette option est pertinente
       dans deux cas spécifiques :
       <itemizedlist>
        <listitem>
         <para>
          Si vous prévoyez de migrer vers une autre plateforme après la mise à niveau,
          vous ne devez pas utiliser cette option.
          Le comportement par défaut est correct dans ce cas.
          Effectuez plutôt la mise à niveau sur la plateforme d'origine sans cette option,
          puis migrez le cluster. Il s'agit de l'approche recommandée et la plus
          sûre.
         </para>
        </listitem>
        <listitem>
         <para>
          Si vous avez déjà migré le cluster vers une plateforme avec une signature
          de caractères différente (par exemple, d'un système x86 vers un système
          ARM), vous devez utiliser cette option pour spécifier une signature correspondant
          à la signature de caractères par défaut de la plateforme d'origine. De plus, il est
          essentiel de ne modifier aucun fichier de données entre la migration et
          l'exécution de <command>pg_upgrade</command>. <command>pg_upgrade</command>
          doit être la première opération de démarrage du cluster sur la nouvelle plateforme.
         </para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-?</option></term>
     <term><option>--help</option></term>
     <listitem><para>afficher l'aide, puis quitter</para></listitem>
    </varlistentry>
   </variablelist>
  </para>

 </refsect1>

 <refsect1>
  <title>Usage</title>

  <para>
   Ci-dessous les étapes pour effectuer une mise à jour avec
   <application>pg_upgrade</application>&nbsp;:
  </para>

  <note>
   <para>
    Les étapes de mise à niveau des <glossterm linkend="glossary-logical-replication-cluster">clusters de réplication logique</glossterm>
    ne sont pas abordées ici ;
    consultez <xref linkend="logical-replication-upgrade"/> pour plus de détails. 
   </para>
  </note>

  <procedure>
   <step performance="optional">
    <title>Si nécessaire, déplacez l'ancienne instance</title>

    <para>
     Si vous utilisez un répertoire d'installation spécifique par
     version, exemple <filename>/opt/PostgreSQL/&majorversion;</filename>, vous
     n'avez pas besoin de déplacer l'ancienne instance. Les installateurs
     graphiques utilisent tous des répertoires d'installation
     spécifiques par version.
    </para>

    <para>
     Si votre répertoire d'installation n'est pas spécifique par
     version, par exemple <filename>/usr/local/pgsql</filename>, il est
     nécessaire de déplacer le répertoire d'installation courant de
     PostgreSQL de telle manière à ce qu'il n'interfère pas avec la nouvelle
     installation de <productname>PostgreSQL</productname>. Une fois
     que le serveur courant <productname>PostgreSQL</productname>
     est éteint, il est sans danger de renommer le répertoire
     d'installation de PostgreSQL&nbsp;; en supposant que l'ancien
     répertoire est <filename>/usr/local/pgsql</filename>, vous
     pouvez faire&nbsp;:

     <programlisting>mv /usr/local/pgsql /usr/local/pgsql.old</programlisting>

     pour renommer le répertoire.
    </para>
   </step>

   <step>
    <title>Pour les installations à partir des sources, construisez la
    nouvelle version</title>

    <para>
     Construisez la nouvelle version de PostgreSQL à partir des
     sources avec des options de <command>configure</command>
     qui sont compatibles avec l'ancienne instance.
     <application>pg_upgrade</application> utilisera
     <command>pg_controldata</command> pour s'assurer que l'ensemble
     des configurations sont compatibles avant de commencer la mise
     à jour.
    </para>
   </step>

   <step>
    <title>Installez les nouveaux binaires PostgreSQL</title>

    <para>
     Installez les binaires du nouveau serveur et les fichiers
     associés. Par défaut, <application>pg_upgrade</application> est
     inclus dans une installation.
    </para>

    <para>
     Pour les installations à partir des sources, si vous souhaitez
     installer le nouveau serveur dans un répertoire personnalisé, utilisez
     la variable <literal>prefix</literal>&nbsp;:

<programlisting>
make prefix=/usr/local/pgsql.new install
     </programlisting></para>
   </step>

   <step>
    <title>Initialisez la nouvelle instance PostgreSQL</title>

    <para>
     Initialisez la nouvelle instance en utilisant la commande
     <command>initdb</command>. À nouveau, utilisez des options de
     la commande <command>initdb</command> compatibles avec l'ancienne
     instance. Beaucoup d'installateurs pré-construits effectuent cette
     étape automatiquement. Il n'est pas nécessaire de démarrer
     la nouvelle instance.
    </para>
   </step>

   <step>
    <title>Installez les fichiers objets partagés d'extension</title>

    <para>
     Beaucoup d'extensions et de modules personnalisés, qu'ils viennent de
     <filename>contrib</filename> ou d'une autre source, utilisent les
     fichiers d'objets partagés (ou DLL), par exemple
     <filename>pgcrypto.so</filename>. Si l'ancienne instance les utilisait,
     les fichiers d'objets partagés correspondant aux binaires du nouveau
     serveur doivent être installés dans la nouvelle instance, habituellement
     avec les commandes du système d'exploitation. Ne chargez pas les
     définitions de schéma, par exemple <command>CREATE EXTENSION
     pgcrypto</command>, parce qu'elles seront dupliquées à partir de
     l'ancienne instance. Si des mises à jour d'extensions sont disponibles,
     <application>pg_upgrade</application> l'indiquera et créera un script à
     exécuter plus tard pour les mettre à jour.
    </para>
   </step>

   <step>
    <title>Copiez les fichiers personnalisés de recherche plein texte</title>

    <para>
     Copiez tous les fichiers personnalisés de recherche plein texte
     (dictionnaire, synonymes, thésaurus, mots d'arrêt) de l'ancienne
     instance vers la nouvelle.
    </para>
   </step>

   <step>
    <title>Ajustez l'authentification</title>

    <para>
     <command>pg_upgrade</command> se connectera à l'ancien et au
     nouveau serveur plusieurs fois, aussi vous pourriez avoir besoin
     de positionner l'authentification sur <literal>peer</literal>
     ou d'utiliser un fichier <filename>~/.pgpass</filename> (voir
     <xref linkend="libpq-pgpass"/>).
    </para>
   </step>

   <step>
    <title>Arrêtez les deux serveurs</title>

    <para>
     Assurez vous que les deux serveurs sont arrêtés en utilisant,
     sur Unix par exemple&nbsp;:

     <programlisting>
pg_ctl -D /opt/PostgreSQL/12 stop
pg_ctl -D /opt/PostgreSQL/&majorversion; stop
     </programlisting>

     ou sur Windows, en utilisant les noms de services corrects&nbsp;:

     <programlisting>
NET STOP postgresql-12
NET STOP postgresql-&majorversion;
     </programlisting>
    </para>

    <para>
     Les serveurs secondaires par réplication en flux et par copie
     des journaux doivent être en cours d'exécution jusqu'à une étape
     ultérieure.
    </para>
   </step>

   <step>
    <title>Préparez la mise à jour d'un serveur secondaire</title>

    <para>
     Si vous êtes en train de mettre à jour des serveurs secondaires
     en suivant la description de la section <xref
     linkend="pgupgrade-step-replicas"/>, vérifiez
     en utilisant <application>pg_controldata</application> sur
     les anciennes instances primaire et secondaire que les anciens
     serveurs secondaires sont à jour. Vérifiez que les valeurs de
     <quote>Latest checkpoint location</quote> correspondent dans
     toutes les instances.
     De plus, assurez-vous que le paramètre <varname>wal_level</varname> ne
     soit pas configuré avec la valeur <literal>minimal</literal> dans le
     fichier de configuration <filename>postgresql.conf</filename> sur la
     nouvelle instance primaire.
    </para>
   </step>

   <step>
    <title>Lancez <application>pg_upgrade</application></title>

    <para>
     Lancez toujours le binaire <application>pg_upgrade</application>
     du nouveau serveur, pas celui de
     l'ancien. <application>pg_upgrade</application> exige la
     spécification des anciens et des nouveaux répertoires de
     données et des exécutables (<filename>bin</filename>). Vous
     pouvez aussi indiquer des valeurs pour les utilisateurs et les
     ports, et si vous voulez que les fichiers de données soient liées, clonées
     ou échangées plutôt que copiées (comportement par défaut).
    </para>

    <para>
     Si vous utilisez le mode lien, la mise à jour sera beaucoup plus rapide
     (pas de copie de fichiers) et utilisera moins d'espace disque, mais vous
     ne serez plus en mesure d'accéder à votre ancienne instance une fois que
     la nouvelle instance sera démarrée après la mise à jour. Le mode lien
     exige également que le répertoire de données de l'ancienne et de la
     nouvelle instance soient dans le même système de fichiers. (Les
     tablespaces et <filename>pg_wal</filename> peuvent être sur des systèmes
     de fichiers différents.) Le mode de clonage fournit les mêmes avantages
     au niveau vitesse et espace disque mais ne rend pas l'ancienne instance
     inutilisable une fois que la nouvelle instance a été démarrée. Le mode de
     clonage requiert aussi que les répertoires de données de l'ancienne et la
     nouvelle instances soient dans le même système de fichiers. Ce mode est
     seulement disponible sur certains systèmes d'exploitation et certains
     systèmes de fichiers.
     Le mode swap peut être le plus rapide s'il existe de nombreuses relations, mais vous ne
     pourrez pas accéder à votre ancien cluster une fois le transfert de fichiers lancé.
     Le mode swap nécessite également que les répertoires de données de l'ancien et du nouveau cluster se trouvent
     dans le même système de fichiers.
    </para>

    <para>
     Définir <option>--jobs</option> sur 2 ou plus permet à pg_upgrade de
     traiter plusieurs bases de données et tablespaces en parallèle. Un bon point de départ
     est le nombre de cœurs de processeur de la machine. Cette option peut
     réduire considérablement le temps de mise à niveau pour les serveurs multi-bases de données et
     multi-tablespaces.
    </para>

    <para>
     Pour les utilisateurs Windows, vous devez être connecté avec
     un compte administrateur, puis lancez
     <application>pg_upgrade</application> avec les
     répertoires entre guillemets, par exemple&nbsp;:

     <programlisting>
pg_upgrade.exe
        --old-datadir "C:/Program Files/PostgreSQL/12/data"
        --new-datadir "C:/Program Files/PostgreSQL/&majorversion;/data"
        --old-bindir "C:/Program Files/PostgreSQL/12/bin"
        --new-bindir "C:/Program Files/PostgreSQL/&majorversion;/bin"
     </programlisting>

     Une fois démarré, <command>pg_upgrade</command> vérifiera que les deux
     instances sont compatibles avant d'effectuer la mise à jour. Vous pouvez
     utiliser <command>pg_upgrade --check</command> pour effectuer uniquement
     la vérification, y compris si l'ancien serveur est actuellement en
     fonctionnement. <command>pg_upgrade --check</command> mettra également
     en évidence les ajustements manuels nécessaires que vous aurez besoin de
     faire après la mise à jour. Si vous désirez utiliser le mode lien, le mode
     clone, le mode « copy-file-range » ou le mode échange,
     vous devriez indiquer l'option <option>--link</option>,
     <option>--clone</option>, <option>--copy-file-range</option> ou
     <option>--swap</option> avec l'option
     <option>--check</option> pour activer les vérifications spécifiques
     au mode lien. <command>pg_upgrade</command> doit avoir le droit
     d'écrire dans le répertoire courant.
    </para>

    <para>
     Évidemment, personne ne doit accéder aux instances pendant
     la mise à jour. <application>pg_upgrade</application> lance par
     défaut les serveurs sur le port 50432 pour éviter les connexions
     non désirées de clients. Vous pouvez utilisez le même numéro de
     port pour les deux instances lors d'une mise à jour car l'ancienne et
     la nouvelle instance ne fonctionneront pas en même temps. Cependant,
     lors de la vérification d'un ancien serveur en fonctionnement,
     l'ancien et le nouveau numéros de port doivent être différents.
    </para>

    <para>
     Si une erreur survient lors de la restauration du schéma de la
     base de données, <command>pg_upgrade</command> quittera et vous
     devrez revenir à l'ancienne instance comme décrit ci-dessous
     (<xref linkend="pgupgrade-step-revert"/>). Pour réessayer
     <command>pg_upgrade</command>, vous aurez besoin de modifier
     l'ancienne instance de telle manière que la restauration du
     schéma par pg_upgrade réussisse. Si le problème est un module
     <filename>contrib</filename>, vous pourriez avoir besoin de
     désinstaller le module <filename>contrib</filename> de l'ancienne
     instance et le réinstaller dans la nouvelle instance après la
     mise à jour, en supposant que le module n'est pas utilisé pour
     stocker des données utilisateur.
    </para>
   </step>

   <step id="pgupgrade-step-replicas">
    <title>Mettez à jour les serveurs secondaires par réplication en flux
     ou par copie de journaux de transactions</title>

    <para>
     Si vous utilisez le mode lien et avez des serveurs secondaires par
     réplication continue (voir <xref linkend="streaming-replication"/>) ou
     par copie des journaux de transactions (voir <xref
     linkend="warm-standby"/>), vous pouvez suivre les étapes ci-dessous pour
     les mettre à jour rapidement. Vous ne lancerez pas
     <application>pg_upgrade</application> sur les serveurs secondaires, mais
     plutôt <application>rsync</application> sur le primaire. Ne démarrez
     encore aucun serveur.
    </para>

    <para>
     Si vous n'utilisez <emphasis>pas</emphasis> le mode lien, n'avez pas ou
     ne voulez pas utiliser <application>rsync</application>, ou si vous
     voulez une solution plus simple, ignorez les instructions de cette
     section et recréez simplement les serveurs secondaires une fois que
     <application>pg_upgrade</application> a terminé et que le nouveau
     primaire fonctionne de nouveau.
    </para>

    <procedure>

     <step>
      <title>Installez les nouveaux binaires PostgreSQL sur les serveurs secondaires</title>

      <para>
       Assurez-vous que les nouveaux binaires et fichiers de support
       sont installés sur tous les serveurs secondaires.
      </para>
     </step>

     <step>
      <title>Assurez vous que les nouveaux répertoires de données sur
       les serveurs secondaires n'existent <emphasis>pas</emphasis></title>

      <para>
       Assurez vous que les nouveaux répertoires de données sur les serveurs
       secondaires n'existent <emphasis>pas</emphasis> ou sont vides. Si
       <application>initdb</application> a été lancé, détruisez les nouveaux
       répertoires de données des serveurs secondaires.
      </para>
     </step>

     <step>
      <title>Installez les fichiers objets partagés d'extension</title>

      <para>
       Installez les mêmes fichiers objets partagés d'extension
       sur les nouveaux serveurs secondaires que vous avez installé sur la
       nouvelle instance primaire.
      </para>
     </step>

     <step>
      <title>Arrêtez les serveurs secondaires</title>

      <para>
       Si les serveurs secondaires sont encore lancés, arrêtez les
       maintenant en utilisant les instructions ci-dessus.
      </para>
     </step>

     <step>
      <title>Sauvegardez les fichiers de configuration</title>

      <para>
       Sauvegardez tous les fichiers de configuration des anciens serveurs
       secondaires que vous avez besoin de conserver, par exemple
       <filename>postgresql.conf</filename> (et tout fichier qu'il inclut),
       <filename>postgresql.auto.conf</filename>,
       <literal>pg_hba.conf</literal>, dans la mesure où ceux-ci seront
       réécrits ou supprimés dans l'étape suivante.
      </para>
     </step>

     <step>
      <title>Lancez <application>rsync</application></title>

      <para>
       Lors de l'utilisation du mode lien, les serveurs secondaires peuvent être
       rapidement mis à jour en utilisant <application>rsync</application>.
       Pour cela, à partir d'un répertoire du serveur primaire situé au-dessus
       des répertoires de l'ancienne et de la nouvelle instance de bases de
       données, exécutez cette commande sur le <emphasis>primaire</emphasis>
       pour chaque serveur secondaire&nbsp;:

       <programlisting>
rsync --archive --delete --hard-links --size-only --no-inc-recursive ancien_rep_config nouveau_rep_config repertoire_distant
       </programlisting>

       où <option>ancien_rep_config</option> et <option>nouveau_rep_config</option>
       sont relatifs au répertoire courant du serveur primaire, et
       <option>repertoire_distant</option> est <emphasis>au-dessus</emphasis>
       des ancien et nouveau répertoires des instances sur le serveur secondaire.
       La structure des répertoires sous les répertoires spécifiés du primaire
       et des secondaires doit correspondre. Consultez les pages du manuel de
       <application>rsync</application> pour des détails sur la manière de
       spécifier le répertoire distant, par exemple&nbsp;:

       <programlisting>
rsync --archive --delete --hard-links --size-only --no-inc-recursive /opt/PostgreSQL/12 \
      /opt/PostgreSQL/&majorversion; standby.example.com:/opt/PostgreSQL
       </programlisting>

       Vous pouvez vérifier ce que la commande va faire en utilisant l'option
       <option>--dry-run</option> de <application>rsync</application>. Alors
       que <application>rsync</application> doit être exécuté sur le primaire
       pour au moins un serveur secondaire, il est possible d'exécuter
       <application>rsync</application> sur un secondaire mis à jour pour mettre
       à jour les autres secondaires tant que le secondaire mis à jour n'est pas
       démarré.
      </para>

      <para>
       Cela enregistre les liens créés par le mode lien de
       <application>pg_upgrade</application> qui connecte les fichiers dans
       les ancienne et nouvelle instances du serveur primaire. Puis, il trouve
       les fichiers correspondant dans l'ancienne instance du secondaire et crée
       les liens pour eux dans la nouvelle instance du serveur secondaire. Les
       fichiers qui n'ont pas été liés sur le primaire sont copiés sur à
       partir du serveur primaire vers le serveur secondaire. (Ils sont
       généralement petits.) Ceci fournit des mises à jour rapides des
       serveurs secondaires. Malheureusement, <application>rsync</application>
       copie sans raison les fichiers associés aux tables temporaires et non
       journalisées parce que ces fichiers n'existent normalement pas sur les
       serveurs secondaires.
      </para>

      <para>
       Si vous avez des tablespaces, vous aurez besoin de lancer
       une commande <application>rsync</application> similaire pour
       chaque répertoire de tablespace, par exemple&nbsp;:

       <programlisting>
rsync --archive --delete --hard-links --size-only --no-inc-recursive /vol1/pg_tblsp/PG_12_201909212 \
      /vol1/pg_tblsp/PG_&majorversion;_202307071 standby.example.com:/vol1/pg_tblsp
       </programlisting>

       Si vous avez déplacé
       <filename>pg_wal</filename> en dehors des répertoires de
       données, <application>rsync</application> doit être lancé
       aussi sur ces répertoires.
      </para>
     </step>

     <step>
      <title>Configurez les serveurs secondaires par réplication en flux ou par copie de journaux de transactions</title>

      <para>
       Configurez les serveurs pour les copies des journaux
       de transactions. (Vous n'avez pas besoin d'exécuter
       les fonctions <function>pg_backup_start()</function> et
       <function>pg_backup_stop()</function> ou d'effectuer une sauvegarde
       des fichiers car les secondaires sont toujours synchronisés avec
       le primaire.) Si l'ancien primaire est en version antérieure à la 17.0, alors
       aucun slot de réplication du primaire ne sera copié vers le nouveau secondaire, ainsi tous les slots sur
       l'ancien secondaire doivent être recréés manuellement. Si l'ancien primaire est
       en version 17.0 ou ultérieure, alors seulement les slots logiques du primaire seront copiés
       vers le nouveau secondaire, mais les autres slots de l'ancien secondaire ne seront pas copiés
       et devront donc être recréés manuellement.
      </para>
     </step>

    </procedure>

   </step>

   <step>
    <title>Restaurez <filename>pg_hba.conf</filename></title>

    <para>
     Si vous avez modifié <filename>pg_hba.conf</filename>,
     restaurez cette configuration d'origine. Il peut être aussi
     nécessaire d'ajuster d'autres fichiers de configuration dans la
     nouvelle instance pour correspondre à l'ancienne instance, par exemple
     <filename>postgresql.conf</filename> (et tout fichier qu'il inclut),
     <filename>postgresql.auto.conf</filename>.
    </para>
   </step>

   <step>
    <title>Démarrez le nouveau serveur</title>

    <para>
     Le nouveau serveur peut maintenant être démarré en toute
     sécurité, puis les autres serveurs secondaires synchronisés avec
     <application>rsync</application>.
    </para>
   </step>

   <step>
    <title>Traitements après mise à jour</title>

    <para>
     Si des traitements après mise à jour sont nécessaires,
     pg_upgrade affichera des avertissements lors de son travail. Il
     générera également des scripts qui devront être lancés par
     l'administrateur. Les scripts se connecteront à chaque base de
     données qui ont besoin de traitements après mise à jour. Chaque
     script devrait être lancé comme suit&nbsp;:

     <programlisting>
psql --username=postgres --file=script.sql postgres
     </programlisting>

     Les scripts peuvent être lancés dans n'importe quel ordre et
     détruits une fois terminés.
    </para>

    <caution>
     <para>
      Généralement, il n'est pas sûr d'accéder à des tables référencées
      dans les scripts de reconstruction avant la fin de leurs traitements&nbsp;;
      le faire pourrait entraîner des résultats incorrects ou de
      médiocres performances. Les tables non référencées dans les
      scripts de reconstruction peuvent être accédées immédiatement.
     </para>
    </caution>
   </step>

   <step>
    <title>Statistiques</title>

    <para>
     Sauf si l'option <option>--no-statistics</option> est spécifiée,
     <command>pg_upgrade</command> transfère la plupart des statistiques d'optimisation
     de l'ancien cluster vers le nouveau. Cependant, certaines statistiques peuvent
     ne pas être transférées, comme celles créées explicitement avec
     <xref linkend="sql-createstatistics"/> ou les statistiques personnalisées ajoutées par une
     extension.

    <para>
     Étant donné que toutes les statistiques ne sont pas transférées par
     <command>pg_upgrade</command>, vous serez invité à exécuter des commandes pour
     régénérer ces informations à la fin de la mise à niveau. Vous devrez peut-être
     définir les paramètres de connexion pour qu'ils correspondent à votre nouveau cluster.
    </para>

    <para>
     Tout d'abord, utilisez
     <command>vacuumdb --all --analyze-in-stages --missing-stats-only</command>
     pour générer rapidement des statistiques d'optimisation minimales pour les relations qui n'en ont
     pas. Ensuite, utilisez <command>vacuumdb --all --analyze-only</command> pour vous assurer
     que toutes les relations disposent de statistiques cumulatives à jour pour le déclenchement du vacuum et
     de l'analyse. Pour les deux commandes, l'utilisation de <option>--jobs</option> peut accélérer
     le processus.
     Si <varname>vacuum_cost_delay</varname> est positionné à une valeur différente
     de zéro, cela peut être outrepassé pour accélérer la génération des statistiques
     en utilisant <envar>PGOPTIONS</envar>, par exemple, <literal>PGOPTIONS='-c
     vacuum_cost_delay=0' vacuumdb ...</literal>.
    </para>
   </step>

   <step>
    <title>Détruire les anciennes instances</title>

    <para>
     Une fois que vous êtes satisfait de la mise à jour, vous pouvez
     détruire les répertoires de données des anciennes instances en
     lançant le script indiqué par <command>pg_upgrade</command>
     à la fin de son traitement. (La destruction automatique n'est
     pas possible si vous avez défini des tablespaces personnalisés
     dans l'ancien répertoire de données.) Vous pouvez également
     supprimer les anciens répertoires d'installation (par exemple
     <filename>bin</filename>, <filename>share</filename>).
    </para>
   </step>

   <step id="pgupgrade-step-revert" performance="optional">
    <title>Revenir à l'ancienne instance</title>

    <para>
     Si, après avoir lancé <command>pg_upgrade</command>, vous désirez
     revenir à l'ancienne instance, il y a plusieurs options&nbsp;:

     <itemizedlist>
      <listitem>
       <para>
        Si l'option <option>--check</option> a été utilisée, l'ancienne
        instance n'a pas été modifiée, elle peut être redémarrée.
       </para>
      </listitem>

      <listitem>
       <para>
        Si l'option <option>--link</option> et l'option <option>--swap</option>
        ne sont <emphasis>pas</emphasis>
        utilisée, l'ancienne instance n'a pas été modifiée, elle peut être
        redémarrée.
       </para>
      </listitem>

      <listitem>
       <para>
        Si l'option <option>--link</option> a été utilisée, les fichiers de
        données pourraient être partagés entre l'ancienne instance et la
        nouvelle&nbsp;:
        <itemizedlist>
         <listitem>
          <para>
           Si <command>pg_upgrade</command> a annulé avant de réaliser les
           liens, l'ancienne instance n'a pas été modifiée, elle peut être
           redémarrée.
          </para>
         </listitem>

         <listitem>
          <para>
           Si vous n'avez <emphasis>pas</emphasis> démarré la nouvelle
           instance, l'ancienne instance n'a pas été modifiée sauf, quand les
           liens ont commencé, un suffixe <literal>.old</literal> a été ajouté
           au fichier <filename>$PGDATA/global/pg_control</filename>. Pour
           utiliser de nouveau l'ancienne instance, supprimez le suffixe
           <filename>.old</filename> du fichier
           <filename>$PGDATA/global/pg_control</filename>&nbsp;; vous pouvez
           alors redémarrer l'ancienne instance.
          </para>
         </listitem>

         <listitem>
          <para>
           Si vous avez démarré la nouvelle instance, elle a écrit dans des
           fichiers partagés et il est dangereux d'utiliser l'ancienne
           instance. Cette dernière doit être restaurée d'une sauvegarde dans
           ce cas.
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>

      <listitem>
       <para>
        Si l'option <option>--swap</option> était utilisée, l'ancien cluster pourrait
        être modifié de manière destructive :
        
        <itemizedlist>
         <listitem>
          <para>
           Si <command>pg_upgrade</command> s'arrête avant de signaler que l'ancien
           cluster ne peut plus être démarré en toute sécurité, l'ancien cluster n'a
           pas été modifié ; il peut être redémarré.
          </para>
         </listitem>

         <listitem>
          <para>
           Si <command>pg_upgrade</command> signale que l'ancien cluster
           ne peut plus être démarré en toute sécurité, cela signifie qu'il a subi une modification
           destructive. Dans ce cas, il devra être restauré à partir
           d'une sauvegarde.
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </step>
  </procedure>
 </refsect1>

 <refsect1>
  <title>Environnement</title>

  <para>
   Certaines variables d'environnement peuvent être utilisées pour fournir des valeurs par défaut aux options en ligne de commande&nbsp;:

   <variablelist>
    <varlistentry>
     <term><envar>PGBINOLD</envar></term>

     <listitem>
      <para>
       L'ancien répertoire des exécutables PostgreSQL&nbsp;; option
       <option>-b</option>/<option>--old-bindir</option>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><envar>PGBINNEW</envar></term>

     <listitem>
      <para>
       Le nouveau répertoire des exécutables PostgreSQL&nbsp;; option
       <option>-B</option>/<option>--new-bindir</option>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><envar>PGDATAOLD</envar></term>

     <listitem>
      <para>
       Le répertoire de configuration de l'ancienne instance&nbsp;; option
       <option>-d</option>/<option>--old-datadir</option>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><envar>PGDATANEW</envar></term>

     <listitem>
      <para>
       Le répertoire de configuration de la nouvelle instance&nbsp;; option
       <option>-D</option>/<option>--new-datadir</option>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><envar>PGPORTOLD</envar></term>

     <listitem>
      <para>
       Le numéro de port de l'ancienne instance&nbsp;; option
       <option>-p</option>/<option>--old-port</option>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><envar>PGPORTNEW</envar></term>

     <listitem>
      <para>
       Le numéro de port de la nouvelle instance&nbsp;; option
       <option>-P</option>/<option>--new-port</option>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><envar>PGSOCKETDIR</envar></term>

     <listitem>
      <para>
       Le répertoire à utiliser pour les sockets du processus postmaster pendant la mise à jour&nbsp;; option
       <option>-s</option>/<option>--socketdir</option>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><envar>PGUSER</envar></term>

     <listitem>
      <para>
       Nom d'utilisateur de l'instance d'installation&nbsp;; option
       <option>-U</option>/<option>--username</option>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   <application>pg_upgrade</application> crée différents fichiers de travail,
   tel que des sauvegardes de schémas, enregistré dans le sous-répertoire
   <filename>pg_upgrade_output.d</filename> du répertoire principal de la nouvelle
   instance. Chaque exécution crée un sous-répertoire nommé avec un horodatage
   formaté d'après ISO 8601 (<literal>%Y%m%dT%H%M%S</literal>), où tous ses
   fichiers générés sont stockés.
   <filename>pg_upgrade_output.d</filename> et ses fichiers seront supprimés
   automatiquement si <application>pg_upgrade</application> se termine
   avec succès&nbsp;; en cas de problème, ses fichiers pourraient fournir
   des informations de debug très utiles.
  </para>

  <para>
   <application>pg_upgrade</application> lance brièvement les serveurs dans
   les ancien et nouveau répertoires de données. Les fichiers temporaires des
   sockets Unix pour communiquer avec ces serveurs sont, par défaut, créés
   dans le répertoire courant. Dans certaines situations, le nom du chemin
   pour le répertoire courant pourrait être trop long pour être un nom de
   socket valide. Dans ce cas, vous pouvez utiliser l'option
   <option>-s</option> pour placer les fichiers socket dans un autre
   répertoire dont le nom du chemin est plus court. Pour des raisons de
   sécurité, assurez-vous que le répertoire n'est ni lisible ni modifiable par
   les autres utilisateurs. (Ceci n'est pas applicable à Windows.)
  </para>

  <para>
   Tous les échecs, reconstructions et réindexations seront
   reportés par <application>pg_upgrade</application> s'ils
   affectent votre installation&nbsp;; les scripts d'après mise à
   jour pour reconstruire les tables et index seront générés
   automatiquement. Si vous essayez d'automatiser la mise à jour de
   plusieurs instances, vous devriez constater que les instances avec
   des schémas de bases de données identiques ont besoin des mêmes
   étapes après mise à jour&nbsp;; car les étapes après mise à jour
   sont basées sur les schémas des bases de données, et pas sur
   les données utilisateurs.
  </para>

  <para>
   Pour les déploiements de tests, créez uniquement une copie du
   schéma de l'ancienne instance, insérez des données de tests, et faites
   la mise à jour.
  </para>

  <para>
   <application>pg_upgrade</application> ne supporte pas la mise à jour de
   bases de données contenant des colonnes de table utilisant les types de
   données systèmes référençant les OID, nommés <type>reg*</type>&nbsp;:
   <simplelist>
    <member><type>regcollation</type></member>
    <member><type>regconfig</type></member>
    <member><type>regdictionary</type></member>
    <member><type>regnamespace</type></member>
    <member><type>regoper</type></member>
    <member><type>regoperator</type></member>
    <member><type>regproc</type></member>
    <member><type>regprocedure</type></member>
   </simplelist>
   (<type>regclass</type>, <type>regrole</type> et <type>regtype</type> peuvent
   être mis à jour.)
  </para>

  <para>
   Si vous souhaitez utiliser le mode lien et ne voulez pas que
   votre ancienne instance ne soit modifiée lorsque la nouvelle instance est
   démarrée, considérez l'utilisation du mode clone. Si ce n'est pas possible,
   faites une copie de l'ancienne instance et faites la mise
   à jour à partir de cette copie. Pour faire une copie valide de
   l'ancienne instance, utilisez <command>rsync</command> pour effectuer une
   copie grossière de l'ancienne instance lancée, puis arrêtez l'ancien
   serveur et lancez <command>rsync --checksum</command> à nouveau
   pour mettre à jour la copie dans un état cohérent avec tous les
   changements. (L'option <option>--checksum</option> est nécessaire
   car <command>rsync</command> n'a une granularité sur les dates de
   modification de fichiers que d'une seconde.) Vous pourriez souhaiter
   exclure certains fichiers, par exemple <filename>postmaster.pid</filename>,
   comme documenté à <xref linkend="backup-lowlevel-base-backup"/>. Si
   votre système de fichiers supporte les images de système de fichiers
   ou la fonctionnalité Copy-On-Write, vous pouvez utiliser ces
   fonctionnalités pour faire une sauvegarde de l'ancienne instance et
   des tablespaces, bien que l'image et les copies doivent être créées
   simultanément ou lorsque le serveur de bases de données est éteint.
  </para>

 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="app-initdb"/></member>
   <member><xref linkend="app-pg-ctl"/></member>
   <member><xref linkend="app-pgdump"/></member>
   <member><xref linkend="app-postgres"/></member>
  </simplelist>
 </refsect1>
</refentry>
