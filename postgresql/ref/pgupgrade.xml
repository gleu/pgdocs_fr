<?xml version="1.0" encoding="UTF-8"?>
<refentry id="pgupgrade">
 <indexterm zone="pgupgrade">
  <primary>pg_upgrade</primary>
 </indexterm>

 <refmeta>
  <refentrytitle><application>pg_upgrade</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>pg_upgrade</refname>
  <refpurpose>met à jour une instance du serveur <productname>PostgreSQL</productname></refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <cmdsynopsis>
   <command>pg_upgrade</command>
   <arg choice="plain"><option>-b</option></arg>
   <arg choice="plain"><replaceable>ancien_repertoire_executables</replaceable></arg>
   <arg choice="plain"><option>-B</option></arg>
   <arg choice="plain"><replaceable>nouveau_repertoire_executables</replaceable></arg>
   <arg choice="plain"><option>-d</option></arg>
   <arg choice="plain"><replaceable>ancien_repertoire_configuration</replaceable></arg>
   <arg choice="plain"><option>-D</option></arg>
   <arg choice="plain"><replaceable>nouveau_repertoire_configuration</replaceable></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <application>pg_upgrade</application> (antérieurement connu
   sous le nom <application>pg_migrator</application>) permet
   de mettre à jour les fichiers de données vers une version
   plus récente de <productname>PostgreSQL</productname> sans la
   sauvegarde et le rechargement de données typiquement requis
   pour les mises à jour d'une version majeure vers une autre,
   par exemple d'une version 9.5.8 à une version 9.6.4 ou à partir de 10.7
   vers 11.2. Il n'est pas nécessaire pour les mises à jour de versions
   mineures, par exemple de 9.6.2 à 9.6.3 ou de 10.1 à 10.2.
  </para>

  <para>
   Les sorties de version majeures de PostgreSQL ajoutent
   régulièrement de nouvelles fonctionnalités qui changent souvent
   la structure des tables système, mais le format interne des données
   stockées change rarement. <application>pg_upgrade</application>
   utilise ce fait pour effectuer des mises à jour rapides en créant
   de nouvelles tables systèmes et en réutilisant les anciens fichiers
   de données. Si jamais une future version majeure devait modifier le format
   d'enregistrement des données de telle sorte que l'ancien format
   des données soit illisible, <application>pg_upgrade</application>
   ne pourrait pas être utilisé pour ces mises à jour. (La communauté
   essaiera d'éviter de telles situations.)
  </para>

  <para>
   <application>pg_upgrade</application> fait de son mieux pour être
   sûr que la nouvelle et l'ancienne instances soient compatibles au niveau
   binaire, par exemple en vérifiant que les options de compilation
   sont compatibles, y compris le format 32/64 bits des binaires. Il
   est également important que les modules externes soient aussi
   compatibles au plan binaire, bien que ceci ne puisse être
   vérifié par <application>pg_upgrade</application>.
  </para>

  <para>
   pg_upgrade supporte les mises à jour à partir de la version
   8.4.X et suivantes jusqu'à la version majeure courante de
   <productname>PostgreSQL</productname>, y compris les images et
   versions beta.
  </para>
 </refsect1>

 <refsect1>
  <title>Options</title>

  <para>
   <application>pg_upgrade</application> accepte les arguments de ligne de
   commande suivants&nbsp;:

   <variablelist>

    <varlistentry>
     <term><option>-b</option> <replaceable>repertoire_executables</replaceable></term>
     <term><option>--old-bindir=</option><replaceable>repertoire_executables</replaceable></term>
     <listitem><para>l'ancien répertoire des exécutables PostgreSQL&nbsp;;
       variable d'environnement <envar>PGBINOLD</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-B</option> <replaceable>repertoire_executables</replaceable></term>
     <term><option>--new-bindir=</option><replaceable>repertoire_executables</replaceable></term>
     <listitem><para>le nouveau répertoire des exécutables PostgreSQL&nbsp;;
       la valeur par défaut est le répertoire d'installation de
       <application>pg_upgrade</application>&nbsp;; variable d'environnement
       <envar>PGBINNEW</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-c</option></term>
     <term><option>--check</option></term>
     <listitem><para>uniquement la vérification des instances, ne
       modifie aucune donnée</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-d</option> <replaceable>repertoire_configuration</replaceable></term>
     <term><option>--old-datadir=</option><replaceable>repertoire_configuration</replaceable></term>
     <listitem><para>répertoire de configuration de l'ancienne instance&nbsp;;
       variable d'environnement<envar>PGDATAOLD</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-D</option> <replaceable>repertoire_configuration</replaceable></term>
     <term><option>--new-datadir=</option><replaceable>repertoire_configuration</replaceable></term>
     <listitem><para>répertoire de configuration de la nouvelle instance&nbsp;;
       variable d'environnement <envar>PGDATANEW</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-j <replaceable class="parameter">njobs</replaceable></option></term>
     <term><option>--jobs=<replaceable class="parameter">njobs</replaceable></option></term>
     <listitem><para>nombres de processus ou threads simultanés à utiliser
      </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-k</option></term>
     <term><option>--link</option></term>
     <listitem><para>utiliser des liens physiques au lieu de copier les
       fichiers vers la nouvelle instance</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-o</option> <replaceable class="parameter">options</replaceable></term>
     <term><option>--old-options</option> <replaceable class="parameter">options</replaceable></term>
     <listitem><para>options à passer directement à l'ancienne commande
       <command>postgres</command>&nbsp;; les invocations multiples de cette
       option sont cumulées</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-O</option> <replaceable class="parameter">options</replaceable></term>
     <term><option>--new-options</option> <replaceable class="parameter">options</replaceable></term>
     <listitem><para>options à passer directement à la nouvelle
       commande <command>postgres</command>&nbsp;; les invocations multiples
       de cette commande sont cumulées</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-p</option> <replaceable>port</replaceable></term>
     <term><option>--old-port=</option><replaceable>port</replaceable></term>
     <listitem><para>le numéro de port de l'ancienne instance&nbsp;; variable
       d'environnement<envar>PGPORTOLD</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-P</option> <replaceable>port</replaceable></term>
     <term><option>--new-port=</option><replaceable>port</replaceable></term>
     <listitem><para>le numéro de port de la nouvelle instance&nbsp;; variable
       d'environnement<envar>PGPORTNEW</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-r</option></term>
     <term><option>--retain</option></term>
     <listitem><para>conserver les fichiers SQL et de traces y compris
       après avoir terminé avec succès</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-s</option> <replaceable>dir</replaceable></term>
     <term><option>--socketdir=</option><replaceable>dir</replaceable></term>
     <listitem><para>répertoire utilisé pour stocker les sockets lors de la
       mise à jour&nbsp;; la valeur par défaut est le répertoire courant&nbsp;;
       la variable d'environnement est <envar>PGSOCKETDIR</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-U</option> <replaceable>username</replaceable></term>
     <term><option>--username=</option><replaceable>username</replaceable></term>
     <listitem><para>nom d'utilisateur de l'instance d'installation&nbsp;;
       variable d'environnement<envar>PGUSER</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-v</option></term>
     <term><option>--verbose</option></term>
     <listitem><para>activer la trace interne verbeuse</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-V</option></term>
     <term><option>--version</option></term>
     <listitem><para>afficher les informations de version, puis quitter</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>--clone</option></term>
     <listitem>
      <para>
       Utilise le clonage efficace de fichiers (connu aussi sous le nom de
       <quote>reflinks</quote> sur certains systèmes) au lieu de copier les
       fichiers vers la nouvelle instance. Ceci peut résulter en une copie
       pratiquement instantanée des fichiers de données, donnant l'avantage
       en vitesse de l'option <option>-k</option>/<option>--link</option>
       tout en laissant l'ancienne instance non modifiée.
      </para>

      <para>
       Le clonage de fichiers est seulement supporté sur certains systèmes
       d'exploitation et systèmes de fichiers. Si cette option est
       sélectionnée alors qu'elle n'est pas supportée, l'exécution de
       <application>pg_upgrade</application> renverra une erreur.
       Actuellement, cette option est supportée sous Linux (à partir du noyau
       4.5) avec Btrfs et XFS (pour les systèmes de fichiers créés avec le
       support de reflink), et sur macOS avec APFS.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-?</option></term>
     <term><option>--help</option></term>
     <listitem><para>afficher l'aide, puis quitter</para></listitem>
    </varlistentry>

   </variablelist>
  </para>

 </refsect1>

 <refsect1>
  <title>Usage</title>

  <para>
   Ci-dessous les étapes pour effectuer une mise à jour avec
   <application>pg_upgrade</application>&nbsp;:
  </para>

  <procedure>
   <step performance="optional">
    <title>Si nécessaire, déplacez l'ancienne instance</title>

    <para>
     Si vous utilisez un répertoire d'installation spécifique par
     version, exemple <filename>/opt/PostgreSQL/&majorversion;</filename>, vous
     n'avez pas besoin de déplacer l'ancienne instance. Les installateurs
     graphiques utilisent tous des répertoires d'installation
     spécifiques par version.
    </para>

    <para>
     Si votre répertoire d'installation n'est pas spécifique par
     version, par exemple <filename>/usr/local/pgsql</filename>, il est
     nécessaire de déplacer le répertoire d'installation courant de
     PostgreSQL de telle manière à ce qu'il n'interfère pas avec la nouvelle
     installation de <productname>PostgreSQL</productname>. Une fois
     que le serveur courant <productname>PostgreSQL</productname>
     est éteint, il est sans danger de renommer le répertoire
     d'installation de PostgreSQL&nbsp;; en supposant que l'ancien
     répertoire est <filename>/usr/local/pgsql</filename>, vous
     pouvez faire&nbsp;:

     <programlisting>mv /usr/local/pgsql /usr/local/pgsql.old</programlisting>

     pour renommer le répertoire.
    </para>
   </step>

   <step>
    <title>Pour les installations à partir des sources, construisez la
    nouvelle version</title>

    <para>
     Construisez la nouvelle version de PostgreSQL à partir des
     sources avec des options de <command>configure</command>
     qui sont compatibles avec l'ancienne instance.
     <application>pg_upgrade</application> utilisera
     <command>pg_controldata</command> pour s'assurer que l'ensemble
     des configurations sont compatibles avant de commencer la mise
     à jour.
    </para>
   </step>

   <step>
    <title>Installez les nouveaux binaires PostgreSQL</title>

    <para>
     Installez les binaires du nouveau serveur et les fichiers
     associés. Par défaut, <application>pg_upgrade</application> est
     inclus dans une installation.
    </para>

    <para>
     Pour les installations à partir des sources, si vous souhaitez
     installer le nouveau serveur dans un répertoire personnalisé, utilisez
     la variable <literal>prefix</literal>&nbsp;:

<programlisting>
make prefix=/usr/local/pgsql.new install
     </programlisting></para>
   </step>

   <step>
    <title>Initialisez la nouvelle instance PostgreSQL</title>

    <para>
     Initialisez la nouvelle instance en utilisant la commande
     <command>initdb</command>. À nouveau, utilisez des options de
     la commande <command>initdb</command> compatibles avec l'ancienne
     instance. Beaucoup d'installateurs pré-construits effectuent cette
     étape automatiquement. Il n'est pas nécessaire de démarrer
     la nouvelle instance.
    </para>
   </step>

   <step>
    <title>Installez les fichiers objets partagés d'extension</title>

    <para>
     Beaucoup d'extensions et de modules personnalisés, qu'ils viennent de
     <filename>contrib</filename> ou d'une autre source, utilisent les
     fichiers d'objets partagés (ou DLL), par exemple
     <filename>pgcrypto.so</filename>. Si l'ancienne instance les utilisait,
     les fichiers d'objets partagés correspondant aux binaires du nouveau
     serveur doivent être installés dans la nouvelle instance, habituellement
     avec les commandes du système d'exploitation. Ne chargez pas les
     définitions de schéma, par exemple <command>CREATE EXTENSION
     pgcrypto</command>, parce qu'elles seront dupliquées à partir de
     l'ancienne instance. Si des mises à jour d'extensions sont disponibles,
     <application>pg_upgrade</application> l'indiquera et créera un script à
     exécuter plus tard pour les mettre à jour.
    </para>
   </step>

   <step>
    <title>Copier les fichiers personnalisés de recherche plein texte</title>

    <para>
     Copiez tous les fichiers personnalisés de recherche plein texte
     (dictionnaire, synonymes, thésaurus, mots d'arrêt) de l'ancienne
     instance vers la nouvelle.
    </para>
   </step>

   <step>
    <title>Ajuster l'authentification</title>

    <para>
     <command>pg_upgrade</command> se connectera à l'ancien et au
     nouveau serveur plusieurs fois, aussi vous pourriez avoir besoin
     de positionner l'authentification sur <literal>peer</literal>
     ou d'utiliser un fichier <filename>~/.pgpass</filename> (voir
     <xref linkend="libpq-pgpass"/>).
    </para>
   </step>

   <step>
    <title>Arrêtez les deux serveurs</title>

    <para>
     Assurez vous que les deux serveurs sont arrêtés en utilisant,
     sur Unix par exemple&nbsp;:

     <programlisting>
pg_ctl -D /opt/PostgreSQL/9.6 stop
pg_ctl -D /opt/PostgreSQL/&majorversion; stop
     </programlisting>

     ou sur Windows, en utilisant les noms de services corrects&nbsp;:

     <programlisting>
NET STOP postgresql-9.6
NET STOP postgresql-&majorversion;
     </programlisting>
    </para>

    <para>
     Les serveurs standby par réplication en flux et par copie
     des journaux peuvent rester en fonctionnement jusqu'à une étape
     ultérieure.
    </para>
   </step>

   <step>
    <title>Préparez la mise à jour d'un serveur standby</title>

    <para>
     Si vous êtes en train de mettre à jour des serveurs standby
     en suivant la description de la section <xref
     linkend="pgupgrade-step-replicas"/>, vérifiez
     en utilisant <application>pg_controldata</application> sur
     les anciennes instances primaires et standby que les anciens
     serveurs standby sont à jour. Vérifiez que les valeurs de
     <quote>Latest checkpoint location</quote> correspondent dans
     toutes les instances. (Il n'y aura pas correspondance si les anciens
     serveurs standby sont éteints avant l'ancien serveur primaire ou si les
     anciens serveurs secondaires sont toujours en cours d'exécution.)
     De plus, assurez-vous que le paramètre <varname>wal_level</varname> ne
     soit pas configuré avec la valeur <literal>minimal</literal> dans le
     fichier de configuration <filename>postgresql.conf</filename> sur la
     nouvelle instance primaire.
    </para>
   </step>

   <step>
    <title>Lancez <application>pg_upgrade</application></title>

    <para>
     Lancez toujours le binaire <application>pg_upgrade</application>
     du nouveau serveur, pas celui de
     l'ancien. <application>pg_upgrade</application> exige la
     spécification des anciens et des nouveaux répertoires de
     données et des exécutables (<filename>bin</filename>). Vous
     pouvez aussi indiquer des valeurs pour les utilisateurs et les
     ports, et si vous voulez que les fichiers de données soient liées ou clonées
     plutôt que copiées (par défaut ce dernier).
    </para>

    <para>
     Si vous utilisez le mode lien, la mise à jour sera beaucoup plus rapide
     (pas de copie de fichiers) et utilisera moins d'espace disque, mais vous
     ne serez plus en mesure d'accèder à votre ancienne instance une fois que
     la nouvelle instance sera démarrée après la mise à jour. Le mode lien
     exige également que le répertoire de données de l'ancienne et de la
     nouvelle instance soient dans le même système de fichiers. (Les
     tablespaces et <filename>pg_wal</filename> peuvent être sur des systèmes
     de fichiers différents.) Le mode de clonage fournit les mêmes avantages
     au niveau vitesse et espace disque mais ne rend pas l'ancienne instance
     inutilisable une fois que la nouvelle instance a été démarrée. Le mode de
     clonage requiert aussi que les répertoires de données de l'ancienne et la
     nouvelle instances soient dans le même système de fichiers. Ce mode est
     seulement disponible sur certains systèmes d'exploitation et certains
     systèmes de fichiers.
    </para>

    <para>
     L'option <option>--jobs</option> permet l'utilisation de plusieurs
     cœurs CPU pour copier ou lier des fichiers, et pour sauvegarder
     et recharger les schémas des bases de données en parallèle&nbsp;;
     un bon chiffre pour commencer est le maximum du nombre de cœurs
     CPU et des tablespaces. Cette option peut réduire dramatiquement
     le temps pour mettre à jour un serveur avec plusieurs bases de
     données s'exécutant sur une machine multiprocesseur.
    </para>

    <para>
     Pour les utilisateurs Windows, vous devez être connecté avec
     un compte administrateur, et lancer un shell sous l'utilisateur
     <literal>postgres</literal> en positionnant le chemin correct&nbsp;:

     <programlisting>
RUNAS /USER:postgres "CMD.EXE"
SET PATH=%PATH%;C:\Program Files\PostgreSQL\&majorversion;\bin;
     </programlisting>

     puis lancez <application>pg_upgrade</application> avec les
     répertoires entre guillemets, par exemple&nbsp;:

     <programlisting>
pg_upgrade.exe
        --old-datadir "C:/Program Files/PostgreSQL/9.6/data"
        --new-datadir "C:/Program Files/PostgreSQL/&majorversion;/data"
        --old-bindir "C:/Program Files/PostgreSQL/9.6/bin"
        --new-bindir "C:/Program Files/PostgreSQL/&majorversion;/bin"
     </programlisting>

     Une fois démarré, <command>pg_upgrade</command> vérifiera que les deux
     instances sont compatibles avant d'effectuer la mise à jour. Vous pouvez
     utiliser <command>pg_upgrade --check</command> pour effectuer uniquement
     la vérification, y compris si l'ancien serveur est actuellement en
     fonctionnement. <command>pg_upgrade --check</command> mettra également
     en évidence les ajustements manuels nécessaires que vous aurez besoin de
     faire après la mise à jour. Si vous désirez utiliser le mode lien ou le mode clone,
     vous devriez indiquer l'option <option>--link</option> ou <option>--clone</option> avec l'option
     <option>--check</option> pour activer les vérifications spécifiques
     au mode lien. <command>pg_upgrade</command> doit avoir le droit
     d'écrire dans le répertoire courant.
    </para>

    <para>
     Évidemment, personne ne doit accèder aux instances pendant
     la mise à jour. <application>pg_upgrade</application> lance par
     défaut les serveurs sur le port 50432 pour éviter les connexions
     non désirées de clients. Vous pouvez utilisez le même  numéro de
     port pour les deux instances lors d'une mise à jour car l'ancienne et
     la nouvelle instance ne fonctionneront pas en même temps. Cependant,
     lors de la vérification d'un ancien serveur en fonctionnement,
     l'ancien et le nouveau numéros de port doivent être différents.
    </para>

    <para>
     Si une erreur survient lors de la restauration du schéma de la
     base de données, <command>pg_upgrade</command> quittera et vous
     devrez revenir à l'ancienne instance comme décrit ci-dessous
     (<xref linkend="pgupgrade-step-revert"/>). Pour réessayer
     <command>pg_upgrade</command>, vous aurez besoin de modifier
     l'ancienne instance de telle manière que la restauration du
     schéma par pg_upgrade réussisse. Si le problème est un module
     <filename>contrib</filename>, vous pourriez avoir besoin de
     désinstaller le module <filename>contrib</filename> de l'ancienne
     instance et le réinstaller dans la nouvelle instance après la
     mise à jour, en supposant que le module n'est pas utilisé pour
     stocker des données utilisateur.
    </para>
   </step>

   <step id="pgupgrade-step-replicas">
    <title>Mettez à jour les serveurs standby par réplication en flux
     et copie de journaux</title>

    <para>
     Si vous utilisez le mode lien et avez des serveurs standby par
     réplication continue (voir <xref linkend="streaming-replication"/>) ou
     par copie des journaux de transactions (voir <xref
     linkend="warm-standby"/>), vous pouvez suivre les étapes ci-dessous pour
     les mettre à jour rapidement. Vous ne lancerez pas
     <application>pg_upgrade</application> sur les serveurs standby, mais
     plutôt <application>rsync</application> sur le primaire. Ne démarrez
     encore aucun serveurs.
    </para>

    <para>
     Si vous n'utilisez <emphasis>pas</emphasis> le mode lien, n'avez pas ou
     ne voulez pas utiliser <application>rsync</application>, ou si vous
     voulez une solution plus simple, ignorez les instructions de cette
     section et recréez simplement les serveurs standbys une fois que
     <application>pg_upgrade</application> a terminé et que le nouveau
     primaire fonctionne de nouveau.
    </para>

    <substeps>

     <step>
      <title>Installez les nouveaux binaires PostgreSQL sur les serveurs standy</title>

      <para>
       Assurez-vous que les nouveaux binaires et fichiers de support
       sont installés sur tous les serveurs standby.
      </para>
     </step>

     <step>
      <title>Assurez vous que les nouveaux répertoires de données sur
       les serveurs standby n'existent <emphasis>pas</emphasis></title>

      <para>
       Assurez vous que les nouveaux répertoires de données sur les serveurs
       standby n'existent <emphasis>pas</emphasis> ou sont vides. Si
       <application>initdb</application> a été lancé, détruisez les nouveaux
       répertoires de données des serveurs standby.
      </para>
     </step>

     <step>
      <title>Installez les fichiers objets partagés d'extension</title>

      <para>
       Installez les mêmes fichiers objets partagés d'extension
       sur les nouveaux serveurs standby que vous avez installé sur la
       nouvelle instance maître.
      </para>
     </step>

     <step>
      <title>Arrêtez les serveurs standby</title>

      <para>
       Si les serveurs standby sont encore lancés, arrêtez les
       maintenant en utilisant les instructions ci-dessus.
      </para>
     </step>

     <step>
      <title>Sauvegardez les fichiers de configuration</title>

      <para>
       Sauvegardez tous les fichiers de configuration des anciens serveurs
       standby que vous avez besoin de conserver, par exemple
       <filename>postgresql.conf</filename> (et tout fichier qu'il inclut),
       <filename>postgresql.auto.conf</filename>,
       <literal>pg_hba.conf</literal>, dans la mesure où ceux-ci seront
       réécrits ou supprimés dans l'étape suivante.
      </para>
     </step>

     <step>
      <title>Lancez <application>rsync</application></title>

      <para>
       Lors de l'utilisation du mode lien, les serveurs standbys peuvent être
       rapidement mis à jour en utilisant <application>rsync</application>.
       Pour cela, à partir d'un répertoire du serveur primaire situé au-dessus
       des répertoires de l'ancienne et de la nouvelle instance de bases de
       données, exécutez cette commande sur le <emphasis>primaire</emphasis>
       pour chaque serveur standby&nbsp;:

       <programlisting>
rsync --archive --delete --hard-links --size-only --no-inc-recursive ancien_rep_config nouveau_rep_config repertoire_distant
       </programlisting>

       où <option>ancien_rep_config</option> et <option>nouveau_rep_config</option>
       sont relatifs au répertoire courant du serveur primaire, et
       <option>repertoire_distant</option> est <emphasis>au-dessus</emphasis>
       des ancien et nouveau répertoires des instances sur le serveur standby.
       La structure des répertoires sous les répertoires spécifiés du primaire
       et des secondaires doit correspondre. Consultez les pages du manuel de
       <application>rsync</application> pour des détails sur la manière de
       spécifier le répertoire distant, par exemple&nbsp;:

       <programlisting>
rsync --archive --delete --hard-links --size-only --no-inc-recursive /opt/PostgreSQL/9.5 \
      /opt/PostgreSQL/9.6 standby.example.com:/opt/PostgreSQL
       </programlisting>

       Vous pouvez vérifier ce que la commande va faire en utilisant l'option
       <option>--dry-run</option> de <application>rsync</application>. Alors
       que <application>rsync</application> doit être exécuté sur le primaire
       pour au moins un serveur standby, il est possible d'exécuter
       <application>rsync</application> sur un standby mis à jour pour mettre
       à jour les autres standbys tant que le standby mis à jour n'est pas
       démarré.
      </para>

      <para>
       Cela enregistre les liens créés par le mode lien de
       <application>pg_upgrade</application> qui connecte les fichiers dans
       les ancienne et nouvelle instances du serveur primaire. Puis, il trouve
       les fichiers correspondant dans l'ancienne instance du standby et crée
       les liens pour eux dans la nouvelle instance du serveur standby. Les
       fichiers qui n'ont pas été liés sur le primaire sont copiés sur à
       partir du serveur primaire vers le serveur secondaire. (Ils sont
       généralement petits.) Ceci fournit des mises à jour rapides des
       serveurs secondaires. Malheureusement, <application>rsync</application>
       copie sans raison les fichiers associés aux tables temporaires et non
       journalisées parce que ces fichiers n'existent normalement pas sur les
       serveurs secondaires.
      </para>

      <para>
       Si vous avez des tablespaces, vous aurez besoin de lancer
       une commande <application>rsync</application> similaire pour
       chaque répertoire de tablespace, par exemple&nbsp;:

       <programlisting>
rsync --archive --delete --hard-links --size-only --no-inc-recursive /vol1/pg_tblsp/PG_9.5_201510051 \
      /vol1/pg_tblsp/PG_9.6_201608131 standby.example.com:/vol1/pg_tblsp
       </programlisting>

       Si vous avez déplacé
       <filename>pg_wal</filename> en dehors des répertoires de
       données, <application>rsync</application> doit être lancé
       aussi sur ces répertoires.
      </para>
     </step>

     <step>
      <title>Configurez les serveurs standby par réplication en flux et par copie de fichiers</title>

      <para>
       Configurez les serveurs pour les copies des fichiers
       de transactions. (Vous n'avez pas besoin d'exécuter
       les fonctions <function>pg_start_backup()</function> et
       <function>pg_stop_backup()</function> ou effectuer une sauvegarde
       des fichiers car les esclaves sont toujours synchronisés avec
       le maître.)
      </para>
     </step>

    </substeps>

   </step>

   <step>
    <title>Restaurez <filename>pg_hba.conf</filename></title>

    <para>
     Si vous avez modifié <filename>pg_hba.conf</filename>,
     restaurez cette configuration d'origine. Il peut être aussi
     nécessaire d'ajuster d'autres fichiers de configuration dans la
     nouvelle instance pour correspondre à l'ancienne instance, par exemple
     <filename>postgresql.conf</filename> (et tout fichier qu'il inclut),
     <filename>postgresql.auto.conf</filename>.
    </para>
   </step>

   <step>
    <title>Démarrez le nouveau serveur</title>

    <para>
     Le nouveau serveur peut maintenant être démarré en toute
     sécurité, puis les autres serveurs standby synchronisés avec
     <application>rsync</application>.
    </para>
   </step>

   <step>
    <title>Traitements après mise à jour</title>

    <para>
     Si des traitements après mise à jour sont nécessaires,
     pg_upgrade affichera des avertissements lors de son travail. Il
     générera également des scripts qui devront être lancés par
     l'administrateur. Les scripts se connecteront à chaque base de
     données qui ont besoin de traitements après mise à jour. Chaque
     script devrait être lancé comme suit&nbsp;:

     <programlisting>
psql --username=postgres --file=script.sql postgres
     </programlisting>

     Les scripts peuvvent être lancés dans n'importe quel ordre et
     détruits une fois terminés.
    </para>

    <caution>
     <para>
      Généralement, il n'est pas sûr d'accèder des tables référencées
      dans les scripts de reconstruction avant la fin de leurs traitements&nbsp;;
      le faire pourrait entraîner des résultats incorrects ou de
      médiocres performances. Les tables non référencées dans les
      scripts de reconstruction peuvent être accédées immédiatement.
     </para>
    </caution>
   </step>

   <step>
    <title>Statistiques</title>

    <para>
     Parce que les statistiques de l'optimiseur ne sont pas transférées
     par <command>pg_upgrade</command>, vous serez invités à lancer
     une commande pour regénérer les statistiques à la fin de la mise
     à jour. Vous pourriez avoir besoin de positionner les paramètres
     de connexion pour qu'ils correspondent à votre nouvelle instance.
    </para>
   </step>

   <step>
    <title>Détruire les anciennes instances</title>

    <para>
     Une fois que vous êtes satisfait de la mise à jour, vous pouvez
     détruire les répertoires de données des anciennes instances en
     lançant le script indiqué par <command>pg_upgrade</command>
     à la fin de son traitement. (La destruction automatique n'est
     pas possible si vous avez défini des tablespaces personnalisés
     dans l'ancien répertoire de données.) Vous pouvez également
     supprimer les anciens répertoires d'installation (par exemple
     <filename>bin</filename>, <filename>share</filename>).
    </para>
   </step>

   <step id="pgupgrade-step-revert" performance="optional">
    <title>Revenir à l'ancienne instance</title>

    <para>
     Si, après avoir lancé <command>pg_upgrade</command>, vous désirez
     revenir à l'ancienne instance, il y a plusieurs options&nbsp;:

     <itemizedlist>
      <listitem>
       <para>
        Si l'option <option>--check</option> a été utilisée, l'ancienne
        instance n'a pas été modifiée, elle peut être redémarrée.
       </para>
      </listitem>

      <listitem>
       <para>
        Si l'option <option>--link</option> n'a <emphasis>pas</emphasis> été
        utilisée, l'ancienne instance n'a pas été modifiée, elle peut être
        redémarrée.
       </para>
      </listitem>

      <listitem>
       <para>
        Si l'option <option>--link</option> a été utilisée, les fichiers de
        données pourraient être partagés entre l'ancienne instance et la
        nouvelle&nbsp;:
        <itemizedlist>
         <listitem>
          <para>
           Si <command>pg_upgrade</command> a annulé avant de réaliser les
           liens, l'ancienne instance n'a pas été modifiée, elle peut être
           redémarrée.
          </para>
         </listitem>

         <listitem>
          <para>
           Si vous n'avez <emphasis>pas</emphasis> démarré la nouvelle
           instance, l'ancienne instance n'a pas été modifiée sauf, quand les
           liens ont commencé, un suffixe <literal>.old</literal> a été ajouté
           au fichier <filename>$PGDATA/global/pg_control</filename>. Pour
           utiliser de nouveau l'ancienne instance, supprimez le suffixe
           <filename>.old</filename> du fichier
           <filename>$PGDATA/global/pg_control</filename>&nbsp;; vous pouvez
           alors redémarrer l'ancienne instance.
          </para>
         </listitem>

         <listitem>
          <para>
           Si vous avez démarré la nouvelle instance, elle a écrit dans des
           fichiers partagés et il est dangereux d'utiliser l'ancienne
           instance. Cette dernière doit être restaurée d'une sauvegarde dans
           ce cas.
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </step>
  </procedure>

 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   <application>pg_upgrade</application> crée plusieurs fichiers de travail,
   par exemple un fichier de sauvegarde du schéma, dans le répertoire courant.
   Pour des raisons de sécurité, assurez-vous que le répertoire n'est ni
   lisible ni modifiable par les autres utilisateurs.
  </para>

  <para>
   <application>pg_upgrade</application> lance brièvement les serveurs dans
   les ancien et nouveau répertoires de données. Les fichiers temporaires des
   sockets Unix pour communiquer avec ces serveurs sont, par défaut, créés
   dans le répertoire courant. Dans certaines situations, le nom du chemin
   pour le répertoire courant pourrait être trop long pour être un nom de
   socket valide. Dans ce cas, vous pouvez utiliser l'option
   <option>-s</option> pour placer les fichiers socket dans un autre
   répertoire dont le nom du chemin est plus court. Pour des raisons de
   sécurité, assurez-vous que le répertoire n'est ni lisible ni modifiable par
   les autres utilisateurs. (Ceci n'est pas applicable à Windows.)
  </para>

  <para>
   Tous les échecs, reconstructions et réindexations seront
   reportés par <application>pg_upgrade</application> s'ils
   affectent votre installation&nbsp;; les scripts d'après mise à
   jour pour reconstruire les tables et index seront générés
   automatiquement. Si vous essayez d'automatiser la mise à jour de
   plusieurs instances, vous devriez constater que les instances avec
   des schémas de bases de données identiques ont besoin des mêmes
   étapes après mise à jour&nbsp;; car les étapes après mise à jour
   sont basées sur les schémas des bases de données, et pas sur
   les données utilisateurs.
  </para>

  <para>
   Pour les déploiements de tests, créez uniquement une copie du
   schéma de l'ancienne instance, insérez des données de tests, et faites
   la mise à jour.
  </para>

  <para>
   <application>pg_upgrade</application> ne supporte pas la mise à jour de
   bases de données contenant des colonnes de table utilisant les types de
   données systèmes référençant les OID, nommés <type>reg*</type>&nbsp;:
   <simplelist>
    <member><type>regcollation</type></member>
    <member><type>regconfig</type></member>
    <member><type>regdictionary</type></member>
    <member><type>regnamespace</type></member>
    <member><type>regoper</type></member>
    <member><type>regoperator</type></member>
    <member><type>regproc</type></member>
    <member><type>regprocedure</type></member>
   </simplelist>
   (<type>regclass</type>, <type>regrole</type> et <type>regtype</type> peuvent
   être mis à jour.)
  </para>

  <para>
   Si vous effectuez la mise à jour d'une instance
   <productname>PostgreSQL</productname> avant la version 9.2 qui utilise
   un répertoire contenant uniquement un fichier de configuration,
   vous devez indiquer l'emplacement réel du répertoire de données
   à <application>pg_upgrade</application>, et indiquer l'emplacement
   du répertoire de configuration du serveur, exemple <literal>-d
    /repertoire_donnees_reel -o '-D /repertoire_configuration'</literal>.
  </para>

  <para>
   Si vous utilisez un ancien serveur avec une version antérieure
   à la 9.1 qui utilise un répertoire de socket unix qui n'est pas
   celui par défaut ou un emplacement par défaut qui est différent
   de celui de la nouvelle instance, positionnez <envar>PGHOST</envar>
   pour qu'il pointe sur la socket de l'ancien serveur. (Ceci n'est
   pas applicable sous Windows.)
  </para>

  <para>
   Si vous souhaitez utiliser le mode lien et ne voulez pas que
   votre ancienne instance ne soit modifiée lorsque la nouvelle instance est
   démarré, considérez l'utilisation du mode clone. Si ce n'est pas possible,
   faites une copie de l'ancienne instance et faites la mise
   à jour à partir de cette copie. Pour faire une copie valide de
   l'ancienne instance, utilisez <command>rsync</command> pour effectuer une
   copie grossière de l'ancienne instance lancée, puis arrêtez l'ancien
   serveur et lancez <command>rsync --checksum</command> à nouveau
   pour mettre à jour la copie dans un état cohérent avec tous les
   changements. (L'option <option>--checksum</option> est nécessaire
   car <command>rsync</command> n'a une granularité sur les dates de
   modification de fichiers que d'une seconde.) Vous pourriez souhaiter
   exclure certains fichiers, par exemple <filename>postmaster.pid</filename>,
   comme documenté à <xref linkend="backup-lowlevel-base-backup"/>. Si
   votre système de fichiers supporte les images de système de fichiers
   ou la fonctionnalité Copy-On-Write, vous pouvez utiliser ces
   fonctionnalités pour faire une sauvegarde de l'ancienne instance et
   des tablespaces, bien que l'image et les copies doivent être créées
   simultanément ou lorsque le serveur de bases de données est éteint.
  </para>

 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="app-initdb"/></member>
   <member><xref linkend="app-pg-ctl"/></member>
   <member><xref linkend="app-pgdump"/></member>
   <member><xref linkend="app-postgres"/></member>
  </simplelist>
 </refsect1>
</refentry>
