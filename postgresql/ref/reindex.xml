<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<refentry id="sql-reindex">
 <indexterm zone="sql-reindex">
  <primary>REINDEX</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>REINDEX</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>REINDEX</refname>
  <refpurpose>reconstruit les index</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <synopsis>REINDEX [ ( VERBOSE ) ] { INDEX | TABLE | SCHEMA | DATABASE | SYSTEM } [ CONCURRENTLY ] <replaceable class="parameter">nom</replaceable></synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>REINDEX</command> reconstruit un index en utilisant les données
   stockées dans la table, remplaçant l'ancienne copie de l'index. Il y a
   plusieurs raisons pour utiliser <command>REINDEX</command>&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Un index a été corrompu et ne contient plus de données valides. Bien
      qu'en théorie, ceci ne devrait jamais arriver, en pratique, les index
      peuvent se corrompre à cause de bogues dans le logiciel ou d'échecs
      matériels. <command>REINDEX</command> fournit une méthode de récupération.
     </para>
    </listitem>

    <listitem>
     <para>
      L'index en question a <quote>explosé</quote>, c'est-à-dire qu'il contient
      beaucoup de pages d'index mortes ou presque mortes. Ceci peut arriver
      avec des index B-tree dans <productname>PostgreSQL</productname> sous
      certains modèles d'accès inhabituels.
      <command>REINDEX</command> fournit un moyen de réduire la consommation
      d'espace de l'index en écrivant une nouvelle version de l'index sans les
      pages mortes. Voir <xref linkend="routine-reindex"/> pour plus
      d'informations.
     </para>
    </listitem>

    <listitem>
     <para>
      Vous avez modifié un paramètre de stockage (par exemple, fillfactor) pour
      un index et vous souhaitez vous assurer que la modification a été prise en
      compte.
     </para>
    </listitem>

    <listitem>
     <para>
      Si la création d'un index échoue avec l'option <literal>CONCURRENTLY</literal>,
      cet index est laissé comme <quote>invalide</quote>. De tels index sont
      inutilisables mais il peut être pratique d'utiliser alors
      <command>REINDEX</command> pour les reconstruire. Il est à noter que seul
      <command>REINDEX INDEX</command> peut reconstruire un index invalide en
      parallèle.
     </para>
    </listitem>

   </itemizedlist>
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><literal>INDEX</literal></term>
    <listitem>
     <para>
      Recrée l'index spécifié.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TABLE</literal></term>
    <listitem>
     <para>
      Recrée tous les index de la table spécifiée. Si la table a une seconde
      table <quote>TOAST</quote>, elle est aussi ré-indexée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SCHEMA</literal></term>
    <listitem>
     <para>
      Recrée tous les index du schéma spécifié. Si une table de ce schéma a
      une table secondaire (<quote>TOAST</quote>), elle est aussi ré-indexée.
      Les index sur les catalogues systèmes partagés sont aussi traités.
      Cette forme de <command>REINDEX</command> ne peut pas être exécutée dans
      un bloc de transaction.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DATABASE</literal></term>
    <listitem>
     <para>
      Recrée tous les index de la base de données en cours. Les index sur
      les catalogues système partagés sont aussi traités. Cette forme de
      <command>REINDEX</command>
      ne peut pas être exécutée à l'intérieur d'un bloc de transaction.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SYSTEM</literal></term>
    <listitem>
     <para>
      Recrée tous les index des catalogues système à l'intérieur de la base de
      données en cours. Les index sur les catalogues système partagés sont aussi
      inclus. Les index des tables utilisateur ne sont pas traités. Cette forme
      de <command>REINDEX</command> ne peut pas être exécutée à l'intérieur d'un
      bloc de transaction.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
      Le nom de l'index, de la table ou de la base de données spécifique à
      ré-indexer. Les noms de table et d'index peuvent être qualifiés du nom du
      schéma. Actuellement, <command>REINDEX DATABASE</command> et
      <command>REINDEX SYSTEM</command> ne peuvent ré-indexer que la base de
      données en cours, donc ce paramètre doit correspondre au nom de la
      base de données en cours.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CONCURRENTLY</literal></term>
    <listitem>
     <para>
      Lorsque cette option est utilisée, <productname>PostgreSQL</productname>
      va reconstruire l'index sans prendre de verrou pouvant empêcher les
      insertions, mises à jour et suppressions en parallèle sur la table&nbsp;;
      alors qu'une réindexation standard empêche les écritures (mais pas les
      lectures) sur la table jusqu'à ce qu'elle soit terminée. Certaines mises
      en garde sont à prendre en compte lors de l'utilisation de cette option
      &mdash; voir <xref linkend="sql-reindex-concurrently"
      endterm="sql-reindex-concurrently-title"/>.
     </para>
     <para>
      Pour les tables temporaires, <command>REINDEX</command> est toujours non
      concurrent car aucune autre session ne peut y accéder, et qu'une
      réindexation non concurrente est moins coûteuse.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>VERBOSE</literal></term>
    <listitem>
     <para>
      Affiche un message de progression à chaque index traité.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   Si vous suspectez la corruption d'un index sur une table utilisateur, vous
   pouvez simplement reconstruire cet index, ou tous les index de la table, en
   utilisant <command>REINDEX INDEX</command> ou <command>REINDEX
    TABLE</command>.
  </para>

  <para>
   Les choses sont plus difficiles si vous avez besoin de récupérer la
   corruption d'un index sur une table système. Dans ce cas, il est important
   pour le système de ne pas avoir utilisé lui-même un des index suspects. (En
   fait, dans ce type de scénario, vous pourriez constater que les processus
   serveur s'arrêtent brutalement au lancement du service, mettant en cause l'utilisation
   des index corrompus.) Pour récupérer proprement, le serveur doit être lancé
   avec l'option <option>-P</option>, qui inhibe l'utilisation des index pour
   les recherches dans les catalogues système.
  </para>

  <para>
   Une autre façon est d'arrêter le serveur et de relancer le serveur
   <productname>PostgreSQL</productname> en mode simple utilisateur avec l'option
   <option>-P</option> placée sur la ligne de commande. Ensuite,
   <command>REINDEX DATABASE</command>, <command>REINDEX SYSTEM</command>,
   <command>REINDEX TABLE</command> ou <command>REINDEX INDEX</command> peuvent être lancés
   suivant ce que vous souhaitez reconstruire. En
   cas de doute, utilisez la commande <command>REINDEX SYSTEM</command> pour activer la
   reconstruction de tous les index système de la base de données. Enfin,
   quittez la session simple utilisateur du serveur et relancez le serveur en mode normal. Voir
   la page de référence de <xref linkend="app-postgres"/> pour plus
   d'informations sur l'interaction avec l'interface du serveur en mode simple utilisateur.
  </para>

  <para>
   Une session standard du serveur peut aussi être lancée avec
   <option>-P</option> dans les options de la ligne de commande. La
   méthode pour ce faire varie entre les clients mais dans tous les clients
   basés sur <application>libpq</application>, il est possible de configurer la variable
   d'environnement <envar>PGOPTIONS</envar> à <literal>-P</literal> avant de lancer le
   client. Notez que, bien que cette méthode ne verrouille
   pas les autres clients, il est conseillé d'empêcher les autres
   utilisateurs de se connecter à la base de données endommagée jusqu'à la fin
   des réparations.
  </para>

  <para>
   <command>REINDEX</command> est similaire à une suppression et à une nouvelle
   création de l'index. Dans les faits, le contenu de l'index est complètement
   recréé. Néanmoins, les considérations de verrouillage sont assez
   différentes. <command>REINDEX</command> verrouille les écritures mais pas les
   lectures de la table mère de l'index. Il positionne également un verrou exclusif sur
   l'index en cours de traitement, ce qui bloque les lectures qui tentent
   de l'utiliser. Au contraire, <command>DROP INDEX</command> crée temporairement
   un verrou exclusif sur la table parent, bloquant ainsi écritures et lectures.
   Le <command>CREATE INDEX</command> qui suit verrouille les écritures mais pas les
   lectures&nbsp;; comme l'index n'existe pas, aucune lecture ne peut être
   tentée, signifiant qu'il n'y a aucun blocage et que les lectures sont
   probablement forcées de réaliser des parcours séquentiels complets.
  </para>

  <para>
   Ré-indexer un seul index ou une seule table requiert d'être le propriétaire
   de cet index ou de cette table. Ré-indexer un schéma ou une base de données
   requiert d'être le propriétaire du schéma ou de la base de données. Notez
   que, du coup, il est parfois possible pour des utilisateurs standards de
   reconstruire les index de tables dont ils ne sont pas propriétaires
   Néanmoins, il existe une exception spéciale, quand la commande <command>REINDEX
   DATABASE</command>, <command>REINDEX SCHEMA</command> ou <command>REINDEX
   SYSTEM</command> est exécutée par un utilisateur standard, les index sur les
   catalogues partagés seront ignorés sauf si l'utilisateur possède le
   catalogue (ce qui ne sera généralement pas le cas). Bien sûr, les
   super-utilisateurs peuvent toujours tout ré-indexer.
  </para>

  <para>
   Ré-indexer les tables partitionnées ou les index partitionnés n'est pas
   supporté. Par contre, chaque partition individuelle peut être ré-indexée
   séparément.
  </para>

  <refsect2 id="sql-reindex-concurrently">
   <title id="sql-reindex-concurrently-title">Reconstruire des index en parallèle</title>

   <indexterm zone="sql-reindex-concurrently">
    <primary>index</primary>
    <secondary>reconstruction en parallèle</secondary>
   </indexterm>

   <para>
    Recréer un index peut interférer avec les opérations normales d'une base de
    données. Habituellement, <productname>PostgreSQL</productname> verrouille
    la table dont dépend l'index à reconstruire pour la protéger des écritures
    et reconstruit l'index complet avec un seul parcours de la table. Les autres
    transactions peuvent toujours lire la table mais si elles essaient d'insérer,
    mettre à jour ou supprimer des lignes dans la table, elles seront bloquées
    jusqu'à la fin de la reconstruction de l'index. Ceci peut avoir un effet
    sérieux si le système est une base en production. Les très grosses tables
    peuvent demander plusieurs heures pour être indexées. Même pour les petites
    tables, une reconstruction d'index peut bloquer les processus qui
    voudraient écrire dans la table pendant des périodes longues inacceptables
    sur un système de production.
   </para>

   <para>
    <productname>PostgreSQL</productname> supporte la reconstruction des index
    sans verrouillage des écritures. Cette méthode est appelée en précisant
    l'option <literal>CONCURRENTLY</literal> de <command>REINDEX</command>.
    Quand cette option est utilisée, <productname>PostgreSQL</productname>
    doit réaliser deux parcours de table pour chaque index à reconstruire et
    doit attendre la fin de toutes les transactions existantes qui
    peuvent utiliser cet index. Du coup, cette méthode requiert
    plus de travail qu'une reconstruction standard de l'index et est bien plus
    longue à se terminer puisqu'elle doit également attendre la fin des
    transactions en cours qui pourraient modifier cet index. Néanmoins, comme
    cela autorise la poursuite des opérations pendant la reconstruction de
    l'index, cette méthode est utile pour reconstruire des index dans un
    environnement en production. Bien sûr, la charge CPU et I/O supplémentaire
    imposée par la recréation de l'index peut ralentir les autres opérations.
   </para>

   <para>
    Les étapes suivantes interviennent dans la ré-indexation en parallèle.
    Chaque étape se déroule dans une transaction séparée. Si plusieurs index
    doivent être reconstruits, alors chaque étape itérera sur l'ensemble des
    index avant de passer à l'étape suivante.

    <orderedlist>
     <listitem>
      <para>
       Une nouvelle définition temporaire de l'index est ajoutée au catalogue
       <literal>pg_index</literal>. Cette définition sera utilisée pour
       remplacer celle de l'ancien index. Un verrou
       <literal>SHARE UPDATE EXCLUSIVE</literal> est posé au niveau de la
       session sur les index reconstruits ainsi que sur les tables qui leurs
       sont associées pour éviter toute modification de structure pendant le
       processus.
      </para>
     </listitem>

     <listitem>
      <para>
       Une première itération de construction de l'index est réalisée pour
       chaque nouvel index. Dès que l'index est construit, son marqueur
       <literal>pg_index.indisready</literal> est positionné à
       <quote>true</quote> pour le rendre disponible aux insertions et visible
       aux autres transactions dès que la session ayant procédé à la
       construction est terminée. Cette étape est réalisée dans une transaction
       séparée pour chaque index.
      </para>
     </listitem>

     <listitem>
      <para>
       Ensuite, une seconde itération est réalisée pour ajouter les
       enregistrements qui ont été créés pendant que la première itération
       était exécutée. Cette étape est également réalisée dans une transaction
       séparée pour chaque index.
      </para>
     </listitem>

     <listitem>
      <para>
       Toutes les contraintes qui font référence à l'index reconstruit sont
       changées pour pointer sur la nouvelle définition d'index, et le nom
       des index sont également changés. À ce stade,
       <literal>pg_index.indisvalid</literal> est positionné à <quote>true</quote>
       pour le nouvel index et à <quote>false</quote> pour l'ancien. Une
       invalidation de cache est alors demandée entraînant l'annulation de
       toutes les sessions référençant l'ancien index.
      </para>
     </listitem>

     <listitem>
      <para>
       Les anciens index voient leurs marqueurs
       <literal>pg_index.indisready</literal> positionnés à <quote>false</quote>
       pour y empêcher tout nouvel ajout d'enregistrement, après avoir attendu
       que les requêtes en cours qui pourraient faire référence à ces index se
       terminent.
      </para>
     </listitem>

     <listitem>
      <para>
       Les anciens index sont supprimés. Les verrous de session <literal>SHARE
       UPDATE EXCLUSIVE</literal> pour les index et leurs tables sont relâchés.
      </para>
     </listitem>
    </orderedlist>
   </para>

   <para>
    Si un problème survient pendant la recréation des index, comme une
    violation d'unicité dans un index unique par exemple, la commande
    <command>REINDEX</command> va échouer mais laisser le nouvel index
    <quote>invalide</quote> en plus de celui qui existait déjà. L'index sera
    ignoré par les requêtes car il pourrait être incomplet&nbsp;; cependant, il
    entraînera encore un surcoût lors des mises à jour. La commande
    <application>psql</application> <command>\d</command> rapportera un tel
    index comme <literal>INVALID</literal>&nbsp;:

<programlisting>
postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Modifiers
--------+---------+-----------
 col    | integer |
Indexes:
    "idx" btree (col)
    "idx_ccnew" btree (col) INVALID
</programlisting>

    La méthode de récupération recommandée dans de tels cas est de supprimer les index
    invalides et de réessayer d'exécuter <command>REINDEX CONCURRENTLY</command>.
    L'index créé par cette méthode a un nom se terminant par
    <literal>ccnew</literal>, ou  <literal>ccold</literal> si il s'agit de la
    définition d'un ancien index qui n'a pas pu être supprimé. Les index
    invalides peuvent être supprimés à l'aide de <literal>DROP INDEX</literal>,
    incluant les index <acronym>TOAST</acronym> invalides.
   </para>

   <para>
    La construction normale d'index permet d'autres constructions d'index sur
    la même table simultanément, mais uniquement une seule création d'index en
    parallèle peut être réalisée sur une table à la fois. Dans les deux cas,
    il n'est pas permis de procéder à une modification de structure de la table
    pendant l'opération. Une autre différence est que les commandes
    <command>REINDEX TABLE</command> ou <command>REINDEX INDEX</command>
    classiques peuvent être exécutées à l'intérieur d'un bloc de transaction,
    alors que ce n'est pas le cas avec <command>REINDEX CONCURRENTLY</command>.
   </para>

   <para>
    <command>REINDEX SYSTEM</command> ne supporte pas
    <command>CONCURRENTLY</command> puisque les catalogues systèmes ne peuvent
    pas être re-indexés en parallèle.
   </para>

   <para>
    En outre, les index des contraintes d'exclusion ne peuvent pas être
    reconstruits en parallèle. Si un tel index est appelé directement dans
    cette commande, une erreur est soulevée. Si une table ou base de données
    avec des index de contraintes d'exclusion est ré-indexée en parallèle, ces
    index seront ignorés. (Il est toutefois possible de reconstruire de tels
    index sans l'option <command>CONCURRENTLY</command>.)
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Reconstruit un index simple&nbsp;:

   <programlisting>REINDEX INDEX my_index;
   </programlisting>
  </para>

  <para>
   Recrée les index sur la table <literal>ma_table</literal>&nbsp;:

   <programlisting>REINDEX TABLE ma_table;
   </programlisting>
  </para>

  <para>
   Reconstruit tous les index d'une base de données particulière sans
   faire confiance à la validité des index système&nbsp;:

   <programlisting>$ <userinput>export PGOPTIONS="-P"</userinput>
$ <userinput>psql broken_db</userinput>
...
broken_db=&gt; REINDEX DATABASE broken_db;
broken_db=&gt; \q
</programlisting></para>

  <para>
   Reconstruit les index d'une table tout en ne bloquant pas les opérations de
   lectures et d'écriture sur les relations impliquées lors de la
   réindexation&nbsp;:

<programlisting>
REINDEX TABLE CONCURRENTLY my_broken_table;
   </programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Il n'existe pas de commande <command>REINDEX</command> dans le standard SQL.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createindex"/></member>
   <member><xref linkend="sql-dropindex"/></member>
   <member><xref linkend="app-reindexdb"/></member>
  </simplelist>
 </refsect1>
</refentry>
