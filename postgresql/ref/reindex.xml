<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<refentry id="sql-reindex">
 <indexterm zone="sql-reindex">
  <primary>REINDEX</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>REINDEX</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>REINDEX</refname>
  <refpurpose>reconstruit les index</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <synopsis>REINDEX [ ( VERBOSE ) ] { INDEX | TABLE | SCHEMA | DATABASE | SYSTEM } [ CONCURRENTLY ] <replaceable class="PARAMETER">nom</replaceable></synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>REINDEX</command> reconstruit un index en utilisant les données
   stockées dans la table, remplaçant l'ancienne copie de l'index. Il y a
   plusieurs raisons pour utiliser <command>REINDEX</command>&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Un index a été corrompu et ne contient plus de données valides. Bien
      qu'en théorie, ceci ne devrait jamais arriver, en pratique, les index
      peuvent se corrompre à cause de bogues dans le logiciel ou d'échecs
      matériels. <command>REINDEX</command> fournit une méthode de récupération.
     </para>
    </listitem>

    <listitem>
     <para>
      L'index en question a <quote>explosé</quote>, c'est-à-dire qu'il contient
      beaucoup de pages d'index mortes ou presque mortes. Ceci peut arriver
      avec des index B-tree dans <productname>PostgreSQL</productname> sous
      certains modèles d'accès inhabituels.
      <command>REINDEX</command> fournit un moyen de réduire la consommation
      d'espace de l'index en écrivant une nouvelle version de l'index sans les
      pages mortes. Voir <xref linkend="routine-reindex"/> pour plus
      d'informations.
     </para>
    </listitem>

    <listitem>
     <para>
      Vous avez modifié un paramètre de stockage (par exemple, fillfactor) pour
      un index et vous souhaitez vous assurer que la modification a été prise en
      compte.
     </para>
    </listitem>

    <listitem>
     <para>
      If an index build fails with the <literal>CONCURRENTLY</literal> option,
      this index is left as <quote>invalid</quote>. Such indexes are useless
      but it can be convenient to use <command>REINDEX</command> to rebuild
      them. Note that only <command>REINDEX INDEX</command> is able
      to perform a concurrent build on an invalid index.
     </para>
    </listitem>

   </itemizedlist>
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><literal>INDEX</literal></term>
    <listitem>
     <para>
      Recrée l'index spécifié.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TABLE</literal></term>
    <listitem>
     <para>
      Recrée tous les index de la table spécifiée. Si la table a une seconde
      table <quote>TOAST</quote>, elle est aussi réindexée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SCHEMA</literal></term>
    <listitem>
     <para>
      Recrée tous les index du schéma spécifié. Si une table de ce schéma a
      une table secondaire (<quote>TOAST</quote>), elle est aussi réindexée.
      Les index sur les catalogues systèmes partagées sont aussi traités.
      Cette forme de <command>REINDEX</command> ne peut pas être exécutée dans
      un bloc de transaction.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DATABASE</literal></term>
    <listitem>
     <para>
      Recrée tous les index de la base de données en cours. Les index sur
      les catalogues système partagés sont aussi traités. Cette forme de
      <command>REINDEX</command>
      ne peut pas être exécutée à l'intérieur d'un bloc de transaction.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SYSTEM</literal></term>
    <listitem>
     <para>
      Recrée tous les index des catalogues système à l'intérieur de la base de
      données en cours. Les index sur les catalogues système partagés sont aussi
      inclus. Les index des tables utilisateur ne sont pas traités. Cette forme
      de <command>REINDEX</command> ne peut pas être exécutée à l'intérieur d'un
      bloc de transaction.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
      Le nom de l'index, de la table ou de la base de données spécifique à
      réindexer. Les noms de table et d'index peuvent être qualifiés du nom du
      schéma. Actuellement, <command>REINDEX DATABASE</command> et
      <command>REINDEX SYSTEM</command> ne peuvent réindexer que la base de
      données en cours, donc ce paramètre doit correspondre au nom de la
      base de données en cours.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CONCURRENTLY</literal></term>
    <listitem>
     <para>
      When this option is used, <productname>PostgreSQL</productname> will rebuild the
      index without taking any locks that prevent concurrent inserts,
      updates, or deletes on the table; whereas a standard reindex build
      locks out writes (but not reads) on the table until it's done.
      There are several caveats to be aware of when using this option
      &mdash; see <xref linkend="sql-reindex-concurrently"
      endterm="sql-reindex-concurrently-title"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>VERBOSE</literal></term>
    <listitem>
     <para>
      Affiche un message de progression à chaque index traité.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   Si vous suspectez la corruption d'un index sur une table utilisateur, vous
   pouvez simplement reconstruire cet index, ou tous les index de la table, en
   utilisant <command>REINDEX INDEX</command> ou <command>REINDEX
    TABLE</command>.
  </para>

  <para>
   Les choses sont plus difficiles si vous avez besoin de récupérer la
   corruption d'un index sur une table système. Dans ce cas, il est important
   pour le système de ne pas avoir utilisé lui-même un des index suspects. (En
   fait, dans ce type de scénario, vous pourriez constater que les processus
   serveur s'arrêtent brutalement au lancement du service, en cause l'utilisation
   des index corrompus.) Pour récupérer proprement, le serveur doit être lancé
   avec l'option <option>-P</option>, qui inhibe l'utilisation des index pour
   les recherches dans les catalogues système.
  </para>

  <para>
   Une autre façon est d'arrêter le serveur et de relancer le serveur
   <productname>PostgreSQL</productname> en mode simple utilisateur avec l'option
   <option>-P</option> placée sur la ligne de commande. Ensuite,
   <command>REINDEX DATABASE</command>, <command>REINDEX SYSTEM</command>,
   <command>REINDEX TABLE</command> ou <command>REINDEX INDEX</command> peuvent être lancés
   suivant ce que vous souhaitez reconstruire. En
   cas de doute, utilisez la commande <command>REINDEX SYSTEM</command> pour activer la
   reconstruction de tous les index système de la base de données. Enfin,
   quittez la session simple utilisateur du serveur et relancez le serveur en mode normal. Voir
   la page de référence de <xref linkend="app-postgres"/> pour plus
   d'informations sur l'interaction avec l'interface du serveur en mode simple utilisateur.
  </para>

  <para>
   Une session standard du serveur peut aussi être lancée avec
   <option>-P</option> dans les options de la ligne de commande. La
   méthode pour ce faire varie entre les clients mais dans tous les clients
   basés sur <application>libpq</application>, il est possible de configurer la variable
   d'environnement <envar>PGOPTIONS</envar> à <literal>-P</literal> avant de lancer le
   client. Notez que, bien que cette méthode ne verrouille
   pas les autres clients, il est conseillé d'empêcher les autres
   utilisateurs de se connecter à la base de données endommagée jusqu'à la fin
   des réparations.
  </para>

  <para>
   <command>REINDEX</command> est similaire à une suppression et à une nouvelle
   création de l'index, dans les fait le contenu de l'index est complètement
   recréé. Néanmoins, les considérations de verrouillage sont assez
   différentes. <command>REINDEX</command> verrouille les écritures mais pas les
   lectures de la table mère de l'index. Il positionne également un verrou exclusif sur
   l'index en cours de traitement, ce qui bloque les lectures qui tentent
   de l'utiliser. Au contraire, <command>DROP INDEX</command> crée temporairement
   un verrou exclusif sur la table parent, bloquant ainsi écritures et lectures.
   Le <command>CREATE INDEX</command> qui suit verrouille les écritures mais pas les
   lectures&nbsp;; comme l'index n'existe pas, aucune lecture ne peut être
   tentée, signifiant qu'il n'y a aucun blocage et que les lectures sont
   probablement forcées de réaliser des parcours séquentiels complets.
  </para>

  <para>
   Ré-indexer un seul index ou une seule table requiert d'être le propriétaire
   de cet index ou de cette table. Ré-indexer un schéma ou une base de données
   requiert d'être le propriétaire du schéma ou de la base de données. Notez
   que, du coup, il est parfois possible pour des utilisateurs standards de
   reconstruire les index de tables dont ils ne sont pas propriétaires
   Néanmoins, il existe une exception spéciale, quand <command>REINDEX
   DATABASE</command>, <command>REINDEX SCHEMA</command> ou <command>REINDEX
   SYSTEM</command> est exécuté par un utilisateur standard, les index sur les
   catalogues partagés seront ignorés sauf si l'utilisateur possède le
   catalogue (ce qui ne sera généralement pas le cas). Bien sûr, les
   superutilisateurs peuvent toujours tout ré-indexer.
  </para>

  <para>
   Ré-indexer les tables partitionnées ou les index partitionnés n'est pas
   supporté. Par contre, chaque partition individuelle peut être ré-indexée
   séparément.
  </para>

  <refsect2 id="sql-reindex-concurrently">
   <title id="sql-reindex-concurrently-title">Rebuilding Indexes Concurrently</title>

   <indexterm zone="sql-reindex-concurrently">
    <primary>index</primary>
    <secondary>rebuilding concurrently</secondary>
   </indexterm>

   <para>
    Rebuilding an index can interfere with regular operation of a database.
    Normally <productname>PostgreSQL</productname> locks the table whose index is rebuilt
    against writes and performs the entire index build with a single scan of the
    table. Other transactions can still read the table, but if they try to
    insert, update, or delete rows in the table they will block until the
    index rebuild is finished. This could have a severe effect if the system is
    a live production database. Very large tables can take many hours to be
    indexed, and even for smaller tables, an index rebuild can lock out writers
    for periods that are unacceptably long for a production system.
   </para>

   <para>
    <productname>PostgreSQL</productname> supports rebuilding indexes with minimum locking
    of writes.  This method is invoked by specifying the
    <literal>CONCURRENTLY</literal> option of <command>REINDEX</command>. When this option
    is used, <productname>PostgreSQL</productname> must perform two scans of the table
    for each index that needs to be rebuild and in addition it must wait for
    all existing transactions that could potentially use the index to
    terminate. This method requires more total work than a standard index
    rebuild and takes significantly longer to complete as it needs to wait
    for unfinished transactions that might modify the index. However, since
    it allows normal operations to continue while the index is rebuilt, this
    method is useful for rebuilding indexes in a production environment. Of
    course, the extra CPU, memory and I/O load imposed by the index rebuild
    may slow down other operations.
   </para>

   <para>
    The following steps occur in a concurrent reindex.  Each step is run in a
    separate transaction.  If there are multiple indexes to be rebuilt, then
    each step loops through all the indexes before moving to the next step.

    <orderedlist>
     <listitem>
      <para>
       A new temporary index definition is added to the catalog
       <literal>pg_index</literal>.  This definition will be used to replace
       the old index.  A <literal>SHARE UPDATE EXCLUSIVE</literal> lock at
       session level is taken on the indexes being reindexed as well as their
       associated tables to prevent any schema modification while processing.
      </para>
     </listitem>

     <listitem>
      <para>
       A first pass to build the index is done for each new index.  Once the
       index is built, its flag <literal>pg_index.indisready</literal> is
       switched to <quote>true</quote> to make it ready for inserts, making it
       visible to other sessions once the transaction that performed the build
       is finished.  This step is done in a separate transaction for each
       index.
      </para>
     </listitem>

     <listitem>
      <para>
       Then a second pass is performed to add tuples that were added while the
       first pass was running.  This step is also done in a separate
       transaction for each index.
      </para>
     </listitem>

     <listitem>
      <para>
       All the constraints that refer to the index are changed to refer to the
       new index definition, and the names of the indexes are changed.  At
       this point, <literal>pg_index.indisvalid</literal> is switched to
       <quote>true</quote> for the new index and to <quote>false</quote> for
       the old, and a cache invalidation is done causing all sessions that
       referenced the old index to be invalidated.
      </para>
     </listitem>

     <listitem>
      <para>
       The old indexes have <literal>pg_index.indisready</literal> switched to
       <quote>false</quote> to prevent any new tuple insertions, after waiting
       for running queries that might reference the old index to complete.
      </para>
     </listitem>

     <listitem>
      <para>
       The old indexes are dropped.  The <literal>SHARE UPDATE
       EXCLUSIVE</literal> session locks for the indexes and the table are
       released.
      </para>
     </listitem>
    </orderedlist>
   </para>

   <para>
    If a problem arises while rebuilding the indexes, such as a
    uniqueness violation in a unique index, the <command>REINDEX</command>
    command will fail but leave behind an <quote>invalid</quote> new index in addition to
    the pre-existing one. This index will be ignored for querying purposes
    because it might be incomplete; however it will still consume update
    overhead. The <application>psql</application> <command>\d</command> command will report
    such an index as <literal>INVALID</literal>:

<programlisting>
postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Modifiers
--------+---------+-----------
 col    | integer |
Indexes:
    "idx" btree (col)
    "idx_ccnew" btree (col) INVALID
</programlisting>

    The recommended recovery method in such cases is to drop the invalid index
    and try again to perform <command>REINDEX CONCURRENTLY</command>.  The
    concurrent index created during the processing has a name ending in the
    suffix <literal>ccnew</literal>, or <literal>ccold</literal> if it is an
    old index definition which we failed to drop. Invalid indexes can be
    dropped using <literal>DROP INDEX</literal>, including invalid toast
    indexes.
   </para>

   <para>
    Regular index builds permit other regular index builds on the same table
    to occur simultaneously, but only one concurrent index build can occur on a
    table at a time. In both cases, no other types of schema modification on
    the table are allowed meanwhile.  Another difference is that a regular
    <command>REINDEX TABLE</command> or <command>REINDEX INDEX</command>
    command can be performed within a transaction block, but <command>REINDEX
    CONCURRENTLY</command> cannot.
   </para>

   <para>
    <command>REINDEX SYSTEM</command> does not support
    <command>CONCURRENTLY</command> since system catalogs cannot be reindexed
    concurrently.
   </para>

   <para>
    Furthermore, indexes for exclusion constraints cannot be reindexed
    concurrently.  If such an index is named directly in this command, an
    error is raised.  If a table or database with exclusion constraint indexes
    is reindexed concurrently, those indexes will be skipped.  (It is possible
    to reindex such indexes without the <command>CONCURRENTLY</command> option.)
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Reconstruit un index simple&nbsp;:

   <programlisting>REINDEX INDEX my_index;
   </programlisting>
  </para>

  <para>
   Recrée les index sur la table <literal>ma_table</literal>&nbsp;:

   <programlisting>REINDEX TABLE ma_table;
   </programlisting>
  </para>

  <para>
   Reconstruit tous les index d'une base de données particulière sans
   faire confiance à la validité des index système&nbsp;:

   <programlisting>$ <userinput>export PGOPTIONS="-P"</userinput>
$ <userinput>psql broken_db</userinput>
...
broken_db=&gt; REINDEX DATABASE broken_db;
broken_db=&gt; \q
</programlisting></para>

  <para>
   Rebuild a table while authorizing read and write operations on involved
   relations when performed:

<programlisting>
REINDEX TABLE CONCURRENTLY my_broken_table;
   </programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Il n'existe pas de commande <command>REINDEX</command> dans le standard SQL.
  </para>
 </refsect1>

 <refsect1>
  <title>See Also</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createindex"/></member>
   <member><xref linkend="sql-dropindex"/></member>
   <member><xref linkend="app-reindexdb"/></member>
  </simplelist>
 </refsect1>
</refentry>
