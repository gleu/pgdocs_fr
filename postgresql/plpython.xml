<?xml version="1.0" encoding="UTF-8"?>
<chapter id="plpython">
 <title>PL/Python &mdash; Langage de procédures Python</title>

 <indexterm zone="plpython"><primary>PL/Python</primary></indexterm>
 <indexterm zone="plpython"><primary>Python</primary></indexterm>

 <para>
  Le langage de procédures <application>PL/Python</application> permet
  l'écriture de fonctions et de procédures <productname>PostgreSQL</productname> avec le
  <ulink url="https://www.python.org">langage Python</ulink> (mais voir aussi
  <xref linkend="plpython-python23"/>).
 </para>

 <para>
  Pour installer PL/Python dans une base de données particulières, utilisez
  <literal>CREATE EXTENSION plpythonu</literal>.
 </para>

 <tip>
  <para>
   Si un langage est installé dans <literal>template1</literal>, toutes les bases
   nouvellement créées se verront installées ce langage automatiquement.
  </para>
 </tip>

 <para>
  PL/Python est seulement disponible en tant que langage <quote>sans
   confiance</quote>, ceci signifiant qu'il n'offre aucun moyen de restreindre
  ce que les utilisateurs en font). Il a donc été renommé en
  <literal>plpythonu</literal>. La variante de confiance
  <literal>plpython</literal> pourrait être de nouveau disponible dans le futur, si un
  nouveau mécanisme sécurisé d'exécution est développé dans Python. Le codeur
  d'une fonction dans PL/Python sans confiance doit faire attention à ce que
  cette fonction ne puisse pas être utilisée pour réaliser quelque chose qui
  n'est pas prévue car il sera possible de faire tout ce que peut faire un
  utilisateur connecté en tant qu'administrateur de la base de données. Seuls
  les super-utilisateurs peuvent créer des fonctions dans des langages sans
  confiance comme <literal>plpythonu</literal>.
 </para>

 <note>
  <para>
   Les utilisateurs des paquets sources doivent activer spécifiquement la
   construction de PL/Python lors des étapes d'installation (référez-vous aux
   instructions d'installation pour plus d'informations). Les utilisateurs de
   paquets binaires pourront trouver PL/Python dans un paquet séparé.
  </para>
 </note>

 <sect1 id="plpython-python23">
  <title>Python 2 et Python 3</title>

  <para>
   PL/Python accepte à la fois les versions 2 et 3 de Python. (Les instructions
   d'installation de PostgreSQL peuvent contenir des informations plus précises
   sur les versions mineures précisément supportées de Python.) Comme les
   variantes Python 2 et Python 3 sont incompatibles pour certaines parties
   très importantes, le schéma de nommage et de transition suivant est utilisé
   par PL/Python pour éviter de les mixer&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Le langage PostgreSQL nommé <literal>plpython2u</literal> implémente
      PL/Python sur la variante Python 2 du langage.
     </para>
    </listitem>

    <listitem>
     <para>
      Le langage PostgreSQL nommé <literal>plpython3u</literal> implémente
      PL/Python sur la variante Python 3 du langage.
     </para>
    </listitem>

    <listitem>
     <para>
      Le langage nommé <literal>plpythonu</literal> implémente PL/Python
      suivant la variante par défaut du langage Python, qui est actuellement
      Python 2. (Cette valeur par défaut est indépendante de ce que toute
      installation locale de Python qui pourrait être considérée comme la valeur
      par <quote>défaut</quote>, par exemple ce que pourrait être
      <filename>/usr/bin/python</filename>.) La valeur par défaut sera
      probablement changée avec Python 3 dans une prochaine version de
      PostgreSQL, suivant les progrès de la migration à Python 3 dans la
      communauté Python.
     </para>
    </listitem>
   </itemizedlist>

   Cela est analogue aux recommendations de <ulink
   url="https://www.python.org/dev/peps/pep-0394/">PEP 394</ulink> au
   regard des nommages et transitions des commandes <command>python</command>.
  </para>

  <para>
   Cela dépend de la configuration lors de la compilation ou des paquets
   installés si PL/Python pour Python 2 ou Python 3 ou les deux sont
   disponibles.
  </para>

  <tip>
   <para>
    La variante construite dépend de la version de Python trouvée pendant
    l'installation ou de la version sélectionnée explicitement en configurant
    la variable d'environnement <envar>PYTHON</envar>&nbsp;; voir <xref
    linkend="install-procedure"/>. Pour que les deux variantes de PL/Python
    soient disponibles sur une installation, le répertoire des sources doit
    être configuré et construit deux fois.
   </para>
  </tip>

  <para>
   Ceci a pour résultat la stratégie suivante d'utilisation et de
   migration&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Les utilisateurs existants et ceux qui ne sont pas actuellement
      intéressés par Python 3 utilisent le nom <literal>plpythonu</literal>
      et n'ont rien à changer pour l'instant. Il est recommandé de
      <quote>s'assurer</quote> graduellement de migrer le code vers
      Python 2.6/2.7 pour simplifier une migration éventuelle vers Python 3.
     </para>

     <para>
      En pratique, beaucoup de fonctions PL/Python seront migrées à Python 3
      avec peu, voire par du tout, de modifications.
     </para>
    </listitem>

    <listitem>
     <para>
      Les utilisateurs sachant d'avance qu'ils ont du code reposant massivement
      sur Python 2 et ne planifient pas de changer peuvent utiliser le nom
      <literal>plpython2u</literal>. Cela continuera de fonctionner, y compris
      dans un futur lointain, jusqu'à ce que le support de Python 2 soit
      complètement supprimée de PostgreSQL.
     </para>
    </listitem>

    <listitem>
     <para>
      Les utilisateurs qui veulent utiliser Python 3 peuvent utiliser le nom
      <literal>plpython3u</literal>, qui continuera à fonctionner en permanence
      avec les standards actuels. Dans le futur, quand Python 3 deviendra la
      version par défaut du langage, ils pourront supprimer le chiffre
      <quote>3</quote>, principalement pour des raisons esthétiques.
     </para>
    </listitem>

    <listitem>
     <para>
      Les intrépides qui veulent construire un système d'exploitation
      utilisant seulement Python-3, peuvent modifier le contenu du fichier
      contrôle et des scripts de l'extension <literal>plpythonu</literal> pour
      rendre <literal>plpythonu</literal> équivalent à
      <literal>plpython3u</literal>, en gardant en tête que cela rend leur
      installation incompatible avec la majorité de ce qui existe dans ce
      monde.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Voir aussi le document <ulink
   url="https://docs.python.org/3/whatsnew/3.0.html">What's New In Python
    3.0</ulink> pour plus d'informations sur le portage vers Python 3.
  </para>

  <para>
   Il n'est pas permis d'utiliser PL/Python basé sur Python 2 et PL/Python
   basé sur Python 3 dans la même session car les symbôles dans les modules
   dynamiques entreraient en conflit, ce qui pourrait résulter en des arrêts
   brutaux du processus serveur PostgreSQL. Une vérification est ajoutée pour
   empêcher ce mélange de versions majeures Python dans une même session. Cette
   vérification aura pour effet d'annuler la session si une différence est
   détectée. Néanmoins, il est possible d'utiliser les deux variantes de
   PL/Python dans une même base de données à condition que ce soit dans des
   sessions séparées.
  </para>
 </sect1>

 <sect1 id="plpython-funcs">
  <title>Fonctions PL/Python</title>

  <para>
   Les fonctions PL/Python sont déclarées via la syntaxe standard <xref
   linkend="sql-createfunction"/>&nbsp;:
   <programlisting>CREATE FUNCTION <replaceable>nom_fonction</replaceable> (<replaceable>liste-arguments</replaceable>)
  RETURNS <replaceable>return-type</replaceable>
AS $$
  # corps de la fonction PL/Python
$$ LANGUAGE plpythonu;
   </programlisting>
  </para>

  <para>
   Le corps d'une fonction est tout simplement un script Python. Quand la
   fonction est appelée, ses arguments sont passés au script Python comme des
   éléments de la liste <varname>args</varname>&nbsp;; les arguments nommés
   sont en plus passés comme des variables ordinaires. L'utilisation des
   arguments nommés est beaucoup plus lisible.  Le résultat est renvoyé
   par le code Python de la façon habituelle, avec <literal>return</literal> ou
   <literal>yield</literal> (dans le cas d'une instruction avec un ensemble
   de résultats). Si vous ne fournissez pas une valeur de retour, Python
   renvoie la valeur par défaut <symbol>None</symbol>.
   <application>PL/Python</application> traduit la valeur <symbol>None</symbol>
   de Python comme une valeur NULL SQL. Dans une procédure, le résultat d'un
   code Python doit être <symbol>None</symbol> (typiquement réalisé en
   terminant la procédure sans instruction <literal>return</literal> ou en
   utilisant une instruction <literal>return</literal> sans argument)&nbsp;;
   sinon une erreur sera levée.
  </para>

  <para>
   Par exemple, une fonction renvoyant le plus grand de deux entiers peut
   être définie ainsi&nbsp;:

   <programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
   </programlisting>

   Le code Python donné comme corps de la définition de fonction est transformé
   en fonction Python. Par exemple, le code ci-dessus devient&nbsp;:

   <programlisting>def __plpython_procedure_pymax_23456():
  if a &gt; b:
    return a
  return b</programlisting>

   en supposant que 23456 est l'OID affecté à la fonction par
   <productname>PostgreSQL</productname>.
  </para>

  <para>
   Les arguments sont définis comme des variables globales. Conséquence subtile
   des règles sur la portée de variables dans Python, il n'est pas possible de
   réaffecter une variable à l'intérieur d'une fonction en conservant son nom,
   sauf si elle est préalablement déclarée comme globale à l'intérieur du bloc.
   Ainsi, l'exemple suivant ne fonctionnera pas&nbsp;:
<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  x = x.strip()  # error
  return x
$$ LANGUAGE plpythonu;
   </programlisting>
   car affecter la variable <varname>x</varname> la transforme en variable
   locale pour ce bloc et que, par conséquent, la variable <varname>x</varname>
   de l'expression de droite fait référence à une variable locale
   <varname>x</varname> non encore définie, et non pas au paramètre de la
   fonction PL/Python. L'utilisation du mot-clé <literal>global</literal> permet
   de résoudre le problème&nbsp;:
   <programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  global x
  x = x.strip()  # ok now
  return x
$$ LANGUAGE plpythonu;
   </programlisting>
   Cependant, il vaut mieux ne pas trop s'appuyer sur ce détail d'implémentation
   de PL/Python. Il est préférable de traiter les paramètres de fonction
   comme étant en lecture seule.
  </para>
 </sect1>

 <sect1 id="plpython-data">
  <title>Valeur des données avec PL/Python</title>
  <para>De manière générale, le but de PL/Python est de fournir une relation
   <quote>naturelle</quote> entre PostgreSQL et le monde Python. Ces règles
   relationelles sont décrites ci-dessous.
  </para>

  <sect2>
   <title>Type de données</title>
   <para>
    Quand une procédure stockée PL/python est appelée, les paramètres de la
    fonction sont convertis de leur type de données PostgreSQL vers un type
    correspondant en Python&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       Le type <type>boolean</type> PostgreSQL est converti en
       <type>bool</type> Python.
      </para>
     </listitem>

     <listitem>
      <para>
       Les types <type>smallint</type> et <type>int</type> de PostgreSQL sont
       convertis en <type>int</type> Python.
       Les types <type>bigint</type> et <type>oid</type> PostgreSQL sont
       convertis en <type>long</type> pour  Python 2 et en <type>int</type> pour
       Python 3.
      </para>
     </listitem>

     <listitem>
      <para>
       Les types PostgreSQL <type>real</type> et <type>double</type> sont
       convertis vers le type Python <type>float</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       Le type PostgreSQL <type>numeric</type> est converti vers le type
       Python <type>Decimal</type>. Ce type est importé à partir du paquet
       <literal>cdecimal</literal> s'il est disponible. Dans le cas contraire,
       <literal>decimal.Decimal</literal> est utilisé à partir de la bibliothèque
       standard. <literal>cdecimal</literal> est bien plus performant que
       <literal>decimal</literal>. Néanmoins, avec Python 3.3 et les versions ultérieures,
       <literal>cdecimal</literal> a été intégré dans la bibliothèque standard
       sous le nom de <literal>decimal</literal>, donc la différence n'est plus
       valide.
      </para>
     </listitem>

     <listitem>
      <para>
       Le <type>bytea</type> PostgreSQL est converti en <type>str</type>
       pour Python 2 et en <type>bytes</type> pour Python 3. Avec Python 2, la
       chaîne devrait être traitée comme une séquence d'octets sans encodage.
      </para>
     </listitem>

     <listitem>
      <para>
       Tous les autres types de données, y compris les chaînes de caractères
       PostgreSQL, sont convertis en <type>str</type> Python. En Python 2, ces
       chaînes auront le même encodage de caractères que le serveur. En
       Python 3, ce seront des chaînes Unicode comme les autres.
      </para>
     </listitem>

     <listitem>
      <para>
       Pour les données non scalaires, voir ci-dessous.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Quand une fonction PL/python renvoie des données, la valeur de retour est
    convertie en type de données PostgreSQL comme suit:
    <itemizedlist>
     <listitem>
      <para>
       Quand le type de la valeur PostgreSQL renvoyée est <type>boolean</type>,
       la valeur de retour sera évaluée en fonction des règles
       <emphasis>Python</emphasis>. Ainsi, les 0 et les chaines vides sont
       fausses, mais la valeur <literal>'f'</literal> est vraie.
      </para>
     </listitem>

     <listitem>
      <para>
       Quand le type de la valeur PostgreSQL renvoyée est <type>bytea</type>, la
       valeur de retour sera convertie en chaine de caractères (Python 2) ou en
       octets (Python 3) en utilisant les mécanismes Python correspondants, le
       résultat étant ensuite converti en <type>bytea</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       Pour tous les autres types de données renvoyées, la valeur de retour est
       convertie en une chaîne de caractère en utilisant la fonction Python interne
       <literal>str</literal>, et le résultat est passé à la fonction d'entrée du
       type de données PostgreSQL. (si la valeur Python est un flottant, il est
       converti en utilisant la fonction interne <literal>repr</literal> au lieu de
       <literal>str</literal>, pour éviter la perte de précision.)
      </para>

      <para>
       Les chaines de caractères en Python 2 doivent être transmises dans le
       même encodage que celui du serveur PostgreSQL. Les chaines invalides dans
       l'encodage du serveur entraineront la levée d'une erreur, mais toutes les
       erreurs d'encodage ne sont pas détectées, ce qui peut aboutir à une
       corruption des données lorsque ces règles ne sont pas respectées. Les
       chaines  Unicode sont automatiquement converties dans le bon encodage,
       il est donc plus prudent de les utiliser. Dans Python 3, toutes les
       chaines sont en Unicode.
      </para>
     </listitem>

     <listitem>
      <para>
       Pour les données non scalaires, voire ci dessous.
      </para>
     </listitem>
    </itemizedlist>

    Notez que les erreurs logiques entre le type de retour déclaré dans
    PostgreSQL et le type de l'objet Python renvoyé ne sont pas détectées. La
    valeur sera convertie dans tous les cas.
   </para>
  </sect2>

  <sect2>
   <title>Null, None</title>

   <para>
    Si une valeur SQL NULL<indexterm><primary>valeur NULL</primary><secondary
     sortas="PL/Python">en PL/Python</secondary></indexterm> est passée à une fonction,
    la valeur de l'argument apparaîtra comme <symbol>None</symbol> au niveau de
    Python. Par exemple, la définition de la fonction <function>pymax</function>
    indiquée dans <xref linkend="plpython-funcs"/> renverra la mauvaise réponse
    pour des entrées NULL. Nous pouvons jouer <literal>STRICT</literal> à la
    définition de la fonction pour faire en sorte que
    <productname>PostgreSQL</productname> fasse quelque-chose de plus
    raisonnable&nbsp;: si une valeur NULL est passée, la fonction ne sera pas
    appelée du tout mais renverra juste un résultat NULL automatiquement.
    Sinon, vous pouver vérifier les entrées NULL dans le corps de la
    fonction&nbsp;:

    <programlisting>CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if (a is None) or (b is None):
    return None
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
    </programlisting>

    Comme montré ci-dessus, pour renvoyer une valeur SQL NULL à partir d'une
    fonction PL/Python, renvoyez la valeur <symbol>None</symbol>. Ceci peut
    se faire que la fonction soit stricte ou non.
   </para>

  </sect2>

  <sect2 id="plpython-arrays">
   <title>Tableaux, Listes</title>
   <para>
    Les valeurs de type tableaux SQL sont passées via PL/Python comme des listes
    Python. Pour renvoyer une valeur de type tableau SQL par une fonction
    PL/Python, renvoyez une liste Python&nbsp;:

    <programlisting>
CREATE FUNCTION return_arr()
  RETURNS int[]
AS $$
return [1, 2, 3, 4, 5]
$$ LANGUAGE plpythonu;

SELECT return_arr();
 return_arr
-------------
 {1,2,3,4,5}
(1 row)
    </programlisting>

    Les tableaux multi-dimensionnels sont passé dans PL/Python en tant que
    listes Python imbriquées.  Un tableau à 2 dimensions est une liste de
    liste, par exemple.  Quand une fonction PL/Python renvoie un tableau SQL
    multi-dimensionnel, les listes internes doivent avoir la même taille à
    chaque niveau.  Par exemple :

    <programlisting>
CREATE FUNCTION test_type_conversion_array_int4(x int4[]) RETURNS int4[] AS $$
plpy.info(x, type(x))
return x
$$ LANGUAGE plpythonu;

SELECT * FROM test_type_conversion_array_int4(ARRAY[[1,2,3],[4,5,6]]);
INFO:  ([[1, 2, 3], [4, 5, 6]], &lt;type 'list'&gt;)
 test_type_conversion_array_int4
---------------------------------
 {{1,2,3},{4,5,6}}
(1 row)
    </programlisting>

    Les autres séquences Python, comme les tuples, sont également acceptées
    pour compatibilité descendante avec les versions 9.6 et inférieures de
    PostgreSQL, quand les tableaux multi-dimensionnels n'étaient pas supportés.
    Cependant, ils sont toujours traités comme des tableaux à une dimension,
    car ils sont ambigus avec les types composites.  Pour la même raison, quand
    un type composite est utilisé dans un tableau multi-dimensionnel, il doit
    être représenté par un tuple, plutôt que par une liste.
   </para>

   <para>
    Notez que, avec Python, les chaînes sont des séquences, ce qui peut avoir
    des effets indésirables qui peuvent être familiers aux codeurs Python&nbsp;:

    <programlisting>
CREATE FUNCTION return_str_arr()
  RETURNS varchar[]
AS $$
return "hello"
$$ LANGUAGE plpythonu;

SELECT return_str_arr();
 return_str_arr
----------------
 {h,e,l,l,o}
(1 row)
    </programlisting>
   </para>
  </sect2>

  <sect2>
   <title>Types composites</title>
   <para>
    Les arguments de type composite sont passés à la fonction via une
    correspondance Python. Les noms d'élément de la correspondance sont les noms
    d'attribut du type composite. Si un attribut a une valeur NULL dans la ligne
    traitée; il a la valeur NULL dans sa correspondance. Voici un exemple&nbsp;:

    <programlisting>CREATE TABLE employe (
  nom text,
  salaire integer,
  age integer
);

CREATE FUNCTION trop_paye (e employe)
  RETURNS boolean
AS $$
  if e["salaire"] &gt; 200000:
    return True
  if (e["age"] &lt; 30) and (e["salaire"] &gt; 100000):
    return True
  return False
$$ LANGUAGE plpythonu;
    </programlisting>
   </para>

   <para>
    Il existe plusieurs façon de renvoyer une ligne ou des types composites à
    partir d'une fonction Python. Les exemples suivants supposent que nous
    avons&nbsp;:

    <programlisting>CREATE TABLE valeur_nommee (
  nom   text,
  valeur  integer
);
    </programlisting>
    ou
    <programlisting>CREATE TYPE valeur_nommee AS (
  nom   text,
  valeur  integer
);
    </programlisting>

    Une valeur composite peut être renvoyé comme&nbsp;:
    <variablelist>
     <varlistentry>
      <term>Un type séquence (ligne ou liste), mais pas
       un ensemble parce que ce n'est pas indexable</term>
      <listitem>
       <para>
        Les objets séquences renvoyés doivent avoir le même nombre d'éléments que
        le type composite a de champs. L'élément d'index 0 est affecté au
        premier champ du type composite, 1 au second et ainsi de suite. Par
        exemple&nbsp;:

        <programlisting>CREATE FUNCTION cree_paire (nom text, valeur integer)
  RETURNS valeur_nommee
AS $$
  return ( nom, valeur )
  # ou autrement, en tant que liste : return [ nom, valeur ]
$$ LANGUAGE plpythonu;
        </programlisting>

        Pour renvoyer NULL dans une colonne, insérez <symbol>None</symbol> à la
        position correspondante.
       </para>
       <para>
        Quand un tableau de types composites est retourné, il ne peut pas être
        retourné comme une liste, car il est ambigu de savoir si la liste
        Python représente un type composite ou une autre dimension de tableau.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Correspondance (dictionnaire)</term>
      <listitem>
       <para>
        La valeur de chaque colonne du type résultat est récupérée à partir de la
        correspondance avec le nom de colonne comme clé. Exemple&nbsp;:

        <programlisting>CREATE FUNCTION cree_paire (nom text, valeur integer)
  RETURNS valeur_nommee
AS $$
  return { "nom": nom, "valeur": valeur }
$$ LANGUAGE plpythonu;
        </programlisting>

        Des paires clés/valeurs supplémentaires du dictionnaire sont ignorées.
        Les clés manquantes sont traitées comme des erreurs.
        Pour renvoyer NULL comme une colonne, insérez <symbol>None</symbol>
        avec le nom de la colonne correspondante comme clé.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Objet (tout objet fournissant la méthode <literal>__getattr__</literal>)</term>
      <listitem>
       <para>
        Ceci fonctionne de la même façon qu'une correspondance.
        Exemple&nbsp;:

        <programlisting>CREATE FUNCTION cree_paire (nom text, valeur integer)
  RETURNS valeur_nommee
AS $$
  class valeur_nommee:
    def __init__ (self, n, v):
      self.nom = n
      self.valeur = v
  return valeur_nommee(nom, valeur)

  # ou simplement
  class nv: pass
  nv.nom = nom
  nv.valeur = valeur
  return nv
$$ LANGUAGE plpythonu;
        </programlisting>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Les fonctions ayant des paramètres <literal>OUT</literal> sont
    aussi supportées. Par exemple&nbsp;:
    <programlisting>
CREATE FUNCTION multiout_simple(OUT i integer, OUT j integer) AS $$
return (1, 2)
$$ LANGUAGE plpythonu;

SELECT * FROM multiout_simple();
    </programlisting>
   </para>

   <para>
    Les paramètres en sortie de procédures sont renvoyés de la même façon. Par
    exemple&nbsp;:
    <programlisting>
CREATE PROCEDURE python_triple(INOUT a integer, INOUT b integer) AS $$
return (a * 3, b * 3)
$$ LANGUAGE plpythonu;

CALL python_triple(5, 10);
    </programlisting>
   </para>

  </sect2>

  <sect2>
   <title>Fonctions renvoyant des ensembles</title>

   <para>
    Une fonction <application>PL/Python</application> peut aussi renvoyer des
    ensembles scalaires ou des types composites. Il existe plusieurs façon de
    faire ceci parce que l'objet renvoyé est transformé en interne en itérateur.
    Les exemples suivants supposent que nous avons le type composite&nbsp;:

    <programlisting>CREATE TYPE greeting AS (
  how text,
  who text
);
    </programlisting>

    Un résultat ensemble peut être renvoyé à partir de&nbsp;:
    <variablelist>
     <varlistentry>
      <term>Un type séquence (ligne, liste, ensemble)</term>
      <listitem>
       <para>
        <programlisting>CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  # renvoie la ligne contenant les listes en tant que types composites
  # toutes les autres combinaisons fonctionnent aussi
  return ( [ how, "World" ], [ how, "PostgreSQL" ], [ how, "PL/Python" ] )
$$ LANGUAGE plpythonu;
        </programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>L'itérateur (tout objet fournissant les méthodes <symbol>__iter__</symbol>
       et <symbol>next</symbol>)</term>
      <listitem>
       <para>
        <programlisting>CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  class producer:
    def __init__ (self, how, who):
      self.how = how
      self.who = who
      self.ndx = -1

    def __iter__ (self):
      return self

    def next (self):
      self.ndx += 1
      if self.ndx == len(self.who):
        raise StopIteration
      return ( self.how, self.who[self.ndx] )

  return producer(how, [ "World", "PostgreSQL", "PL/Python" ])
$$ LANGUAGE plpythonu;
        </programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Le générateur (<literal>yield</literal>)</term>
      <listitem>
       <para>
        <programlisting>CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  for who in [ "World", "PostgreSQL", "PL/Python" ]:
    yield ( how, who )
$$ LANGUAGE plpythonu;
        </programlisting>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Les fonctions renvoyant des ensembles et ayant des paramètres
    <literal>OUT</literal>  (en utilisant <literal>RETURNS SETOF
     record</literal>) sont aussi supportées. Par exemple&nbsp;:
    <programlisting>
CREATE FUNCTION multiout_simple_setof(n integer, OUT integer, OUT integer) RETURNS SETOF record AS $$
return [(1, 2)] * n
$$ LANGUAGE plpythonu;

SELECT * FROM multiout_simple_setof(3);
    </programlisting>
   </para>

  </sect2>
 </sect1>

 <sect1 id="plpython-sharing">
  <title>Sharing Data</title>

  <para>
   Le dictionnaire global <varname>SD</varname> est disponible pour stocker
   des données privées entre les appels répétées à la même fonction. Cette
   variable est une donnée statique privée. Le dictionnaire global
   <varname>GD</varname> est une donnée publique disponible pour toutes les
   fonctions Python à l'intérieur d'une session. À utiliser avec
   précaution.<indexterm><primary>données globales</primary><secondary>en
     PL/Python</secondary></indexterm>
  </para>

  <para>
   Chaque fonction obtient son propre environnement d'exécution dans
   l'interpréteur Python, de façon à ce que les données globales et les
   arguments de fonction provenant de <function>ma_fonction</function> ne soient
   pas disponibles depuis <function>ma_fonction2</function>. L'exception
   concerne les données du dictionnaire <varname>GD</varname> comme indiqué
   ci-dessus.
  </para>
 </sect1>

 <sect1 id="plpython-do">
  <title>Blocs de code anonymes</title>

  <para>
   PL/Python accepte aussi les blocs de code anonymes appelés avec
   l'instruction <xref linkend="sql-do"/>&nbsp;:

   <programlisting>
DO $$
    # Code PL/Python
$$ LANGUAGE plpythonu;
   </programlisting>

   Un bloc de code anonyme ne reçoit aucun argument et, quelque soit la valeur
   renvoyée, elle est ignorée. Sinon, ce bloc se comporte exactement comme
   n'importe quelle fonction.
  </para>
 </sect1>

 <sect1 id="plpython-trigger">
  <title>Fonctions de déclencheurs</title>

  <indexterm zone="plpython-trigger">
   <primary>déclencheur</primary>
   <secondary>en PL/Python</secondary>
  </indexterm>

  <para>
   Quand une fonction est utilisée par un trigger, le dictionnaire
   <literal>TD</literal> contient les valeurs relatives au trigger&nbsp;:
   <variablelist>
    <varlistentry>
     <term><literal>TD["event"]</literal></term>
     <listitem>
      <para>
       contient l'événement sous la forme d'une chaîne&nbsp;:
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["when"]</literal></term>
     <listitem>
      <para>
       contient une chaîne valant soit <literal>BEFORE</literal>, soit
       <literal>AFTER</literal> soit <literal>INSTEAD OF</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["level"]</literal></term>
     <listitem>
      <para>
       contient une chaîne valant soit <literal>ROW</literal> soit
       <literal>STATEMENT</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["new"]</literal></term>
     <term><literal>TD["old"]</literal></term>
     <listitem>
      <para>
       pour un trigger au niveau ligne, ces champs contiennent les lignes
       du trigger, l'ancienne version et la nouvelle version&nbsp;; les deux
       champs ne sont pas forcément disponibles, ceci dépendant de l'événement
       qui a déclenché le trigger
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["name"]</literal></term>
     <listitem>
      <para>
       contient le nom du trigger.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_name"]</literal></term>
     <listitem>
      <para>
       contient le nom de la table sur laquelle le trigger a été déclenché
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_schema"]</literal></term>
     <listitem>
      <para>
       contient le schéma de la table sur laquelle le trigger a été déclenché
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["relid"]</literal></term>
     <listitem>
      <para>
       contient l'OID de la table sur laquelle le trigger a été déclenché
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["args"]</literal></term>
     <listitem>
      <para>
       si la commande <command>CREATE TRIGGER</command> comprend des arguments,
       ils sont disponibles dans les variables allant de
       <literal>TD["args"][0]</literal> à
       <literal>TD["args"][<replaceable>n</replaceable>-1]</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Si <literal>TD["when"]</literal> vaut <literal>BEFORE</literal> ou
   <literal>INSTEAD OF</literal> et si
   <literal>TD["level"]</literal> vaut <literal>ROW</literal>, vous pourriez
   renvoyer <literal>None</literal> ou <literal>"OK"</literal> à partir de la
   fonction Python pour indiquer que la ligne n'est pas modifiée,
   <literal>"SKIP"</literal> pour annuler l'événement ou si <literal>TD["event"]</literal>
   vaut <command>INSERT</command> ou <command>UPDATE</command>, vous
   pouvez renvoyer <literal>"MODIFY"</literal> pour indiquer que vous
   avez modifié la ligne. Sinon la valeur de retour est ignorée.
  </para>
 </sect1>

 <sect1 id="plpython-database">
  <title>Accès à la base de données</title>

  <para>
   Le module du langage PL/Python importe automatiquement un module Python
   appelé <literal>plpy</literal>. Les fonctions et constantes de ce module
   vous sont accessibles dans le code Python via
   <literal>plpy.<replaceable>foo</replaceable></literal>.
  </para>

  <sect2>
   <title>Fonctions d'accès à la base de données</title>

   <para>
    Le module <literal>plpy</literal> fournit plusieurs fonctions pour exécuter
    des commandes sur la base de données&nbsp;:
   </para>

   <variablelist>
    <varlistentry>
     <term><literal>plpy.<function>execute</function>(<replaceable>query</replaceable> [, <replaceable>max-rows</replaceable>])</literal></term>
     <listitem>
      <para>
       L'appel à <function>plpy.execute</function> avec une chaîne pour la requête
       et une limite de ligne optionnelle permet d'exécuter la requête et de
       retourner le résultat dans un objet résultant.
      </para>

      <para>
       L'objet résultant émule une liste ou un objet dictionnaire. L'objet
       résultant peut être accédé par le numéro de ligne et le nom de colonne.
       Par exemple&nbsp;:
       <programlisting>
 rv = plpy.execute("SELECT * FROM my_table", 5)
       </programlisting>
       retourne jusqu'à 5 lignes de <literal>my_table</literal>.
       Si <literal>my_table</literal> possède une colonne <literal>my_column</literal>,
       elle pourra être accédée ainsi&nbsp;:
       <programlisting>
 foo = rv[i]["my_column"]
       </programlisting>
       Le nombre de lignes retournées peut être obtenu en utilisant la
       fonction intégrée <function>len</function>.
      </para>

      <para>
       L'objet résultant contient ces méthodes additionnelles&nbsp;:
       <variablelist>
        <varlistentry>
         <term><literal><function>nrows</function>()</literal></term>
         <listitem>
          <para>
           Retourne le nombre de lignes traitées par cette commande. Notez que
           cela n'est pas nécessairement identique au nombre de lignes retournées.
           Par exemple, une commande <command>UPDATE</command> fixera cette valeur
           mais ne retournera aucune ligne (sauf si <literal>RETURNING</literal>
           est utilisé).
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal><function>status</function>()</literal></term>
         <listitem>
          <para>
           La valeur retournée par <function>SPI_execute()</function>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal><function>colnames</function>()</literal></term>
         <term><literal><function>coltypes</function>()</literal></term>
         <term><literal><function>coltypmods</function>()</literal></term>
         <listitem>
          <para>
           Retourne respectivement une liste de noms de colonne, une liste de type OID
           de colonne et une liste de type de modifieurs spécifiques à un type
           pour les colonnes.
          </para>

          <para>
           Ces méthodes lèvent une exception quand elles sont appelées sur un
           objet résultant d'une commande n'ayant pas produit d'ensemble de
           résultat, par ex,
           <command>UPDATE</command> sans <literal>RETURNING</literal>, ou
           <command>DROP TABLE</command>. Il est cependant normal d'utiliser
           ces méthodes sur un ensemble de résultat ne contenant aucune ligne.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal><function>__str__</function>()</literal></term>
         <listitem>
          <para>
           La méthode standard <literal>__str__</literal> est définie pour qu'il
           soit possible de débugger les résultats de l'exécution d'une requête
           en utilisant <literal>plpy.debug(rv)</literal>.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>

      <para>
       L'objet résultant peut être modifié.
      </para>

      <para>
       Notez que l'appel à <literal>plpy.execute</literal> provoquera la lecture
       de tout l'ensemble de résultat en mémoire. N'utilisez cette fonction que
       lorsque vous êtes surs que l'ensemble de résultat sera relativement petit.
       Si vous ne voulez pas risquer une utilisation excessive de mémoire pour
       récupérer de gros ensembles, préférez <literal>plpy.cursor</literal> à
       <literal>plpy.execute</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>plpy.<function>prepare</function>(<replaceable>query</replaceable> [, <replaceable>argtypes</replaceable>])</literal></term>
     <term><literal>plpy.<function>execute</function>(<replaceable>plan</replaceable> [, <replaceable>arguments</replaceable> [, <replaceable>max-rows</replaceable>]])</literal></term>
     <listitem>
      <para>
       <indexterm><primary>Préparer une requête</primary><secondary>en PL/Python</secondary></indexterm>
       <function>plpy.prepare</function> prépare le plan d'exécution pour une requête.
       Il faut l'appeler avec une chaîne contenant la requête et une liste de types
       de paramètres, si vous avez des références à des paramètres dans cette requête.
       Par exemple&nbsp;:
       <programlisting>
plan = plpy.prepare("SELECT last_name FROM my_users WHERE first_name = $1", ["text"])
       </programlisting>
       <literal>text</literal> est le type de variable qui sera passé à
       <literal>$1</literal>.  Le second paramètre est optionel si vous
       ne voulez pas fournir de paramètre à la requête.
      </para>
      <para>
       Après avoir préparé une requête, il faut utiliser une variante
       de la fonction <function>plpy.execute</function> pour l'exécuter&nbsp;:
       <programlisting>
rv = plpy.execute(plan, ["name"], 5)
       </programlisting>
       Il faut fournir le plan comme premier argument (à la place de la chaîne),
       et une liste de valeurs à substituer dans la requête comme second argument.
       Le deuxième argument est optionnel si la requête n'attend pas de paramètre.
       Le troisième argument est la limite de ligne optionnelle comme auparavant.
      </para>

      <para>
       De manière alternative, vous pouvez appeler la méthode
       <function>execute</function> sur l'objet plan :
       <programlisting>
rv = plan.execute(["name"], 5)
       </programlisting>
      </para>

      <para>
       Les paramètres de requête ainsi que les champs des lignes de résultat
       sont converties entre les types de données de PostgreSQL et de Python
       comme décrit dans  <xref linkend="plpython-data"/>.
      </para>

      <para>
       Quand un plan est préparé en utilisant le module PL/Python, il est
       automatiquement sauvegardé. Voir la documentation de SPI (<xref linkend="spi"/>)
       pour une description de ce que cela signifie. Afin d'utiliser efficacement
       ces appels de fonction, il faut utiliser un des dictionnaires de stockage
       persistant <literal>SD</literal> ou <literal>GD</literal> (voir
       <xref linkend="plpython-sharing"/>). Par exemple&nbsp;:
       <programlisting>
 CREATE FUNCTION usesavedplan() RETURNS trigger AS $$
    if "plan" in SD:
        plan = SD["plan"]
    else:
        plan = plpy.prepare("SELECT 1")
        SD["plan"] = plan
     # reste de la fonction
 $$ LANGUAGE plpythonu;
       </programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>plpy.<function>cursor</function>(<replaceable>query</replaceable>)</literal></term>
     <term><literal>plpy.<function>cursor</function>(<replaceable>plan</replaceable> [, <replaceable>arguments</replaceable>])</literal></term>
     <listitem>
      <para>
       La fonction <literal>plpy.cursor</literal> accepte les mêmes arguments
       que <literal>plpy.execute</literal> (à l'exception de la limite de lignes)
       et retourne un objet curseur, qui permet de traiter de gros ensembles de
       résultats en plus petits morceaux. Comme avec  <literal>plpy.execute</literal>,
       une chaîne de caractère ou un objet plan accompagné d'une liste d'arguments
       peuvent être utilisés, ou la fonction <function>cursor</function> peut
       être appelée comme une méthode de l'objet plan.
      </para>

      <para>
       L'objet curseur fournit une méthode <literal>fetch</literal> qui requiert
       en entrée un paramètre entier et retourne un objet résultat. À chaque appel
       de <literal>fetch</literal>, l'objet retourné contiendra la prochaine
       série de lignes, mais jamais plus que la valeur passée en paramètre.
       Une fois que toutes les lignes ont été épuisées, <literal>fetch</literal>
       se met à retourner des objets résultat vides. Les objets curseurs
       fournissent également une <ulink url="https://docs.python.org/library/stdtypes.html#iterator-types">
        interface d'itérateur</ulink>, fournissant les lignes une par une jusqu'à épuisement.
       Les données récupérées de cette façon ne sont pas retournées dans des objets
       résultat, mais plutôt dans des dictionnaires, chacun correspondant à une unique
       ligne de résultat.
      </para>

      <para>
       Un exemple montrant deux façons de traiter des données dans une large table est:
       <programlisting>
CREATE FUNCTION count_odd_iterator() RETURNS integer AS $$
odd = 0
for row in plpy.cursor("select num from largetable"):
    if row['num'] % 2:
         odd += 1
return odd
$$ LANGUAGE plpythonu;

CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS $$
odd = 0
cursor = plpy.cursor("select num from largetable")
while True:
    rows = cursor.fetch(batch_size)
    if not rows:
        break
    for row in rows:
        if row['num'] % 2:
            odd += 1
return odd
$$ LANGUAGE plpythonu;

CREATE FUNCTION count_odd_prepared() RETURNS integer AS $$
odd = 0
plan = plpy.prepare("select num from largetable where num % $1 &lt;&gt; 0", ["integer"])
rows = list(plpy.cursor(plan, [2]))  # or: = list(plan.cursor([2]))

return len(rows)
$$ LANGUAGE plpythonu;
       </programlisting>
      </para>

      <para>
       Les curseurs sont automatiquement libérés. Mais si vous voulez
       libérer explicitement toutes les ressources retenues par un curseur,
       il faut utiliser la méthode <literal>close</literal>.
       Une fois fermé, un curseur ne peut plus être utilisé pour retourner
       des lignes.
      </para>

      <tip>
       <para>
        Il ne faut pas confondre les objets créés par <literal>plpy.cursor</literal>
        avec les curseurs DB-API comme définis par <ulink url="https://www.python.org/dev/peps/pep-0249/">
         la spécification Python Database API</ulink>. Ils n'ont rien en commun si
        ce n'est le nom.
       </para>
      </tip>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="plpython-trapping">
   <title>Récupérer les erreurs</title>

   <para>
    Les fonctions accédant à la base de données peuvent rencontrer des
    erreurs, qui forceront leur annulation et lèveront une exception.
    <function>plpy.execute</function> et
    <function>plpy.prepare</function> peuvent lancer une instance d'une
    sous-classe de <literal>plpy.SPIError</literal>, qui terminera par
    défaut la fonction. Cette erreur peut être gérée comme toutes les
    autres exceptions Python, en utilisant la construction
    <literal>try/except</literal>. Par exemple&nbsp;:
    <programlisting>
CREATE FUNCTION essaie_ajout_joe() RETURNS text AS $$
    try:
        plpy.execute("INSERT INTO utilisateurs(nom) VALUES ('joe')")
    except plpy.SPIError:
        return "quelque chose de mal est arrivé"
    else:
        return "Joe ajouté"
$$ LANGUAGE plpythonu;
    </programlisting>
   </para>

   <para>
    La classe réelle de l'exception levée correspond à la condition
    spécifique qui a causé l'erreur. Référez-vous à <xref
    linkend="errcodes-table"/> pour une liste des conditions possibles.
    Le module <literal>plpy.spiexceptions</literal> définit une classe
    d'exception pour chaque condition
    <productname>PostgreSQL</productname>, dérivant leur noms du nom de
    la condition. Par exemple, <literal>division_by_zero</literal>
    devient <literal>DivisionByZero</literal>, <literal>unique_violation</literal>
    devient <literal>UniqueViolation</literal>, <literal>fdw_error</literal>
    devient <literal>FdwError</literal>, et ainsi de suite. Chacune de
    ces classes d'exception hérite de <literal>SPIError</literal>. Cette
    séparation rend plus simple la gestion des erreurs spécifiques. Par
    exemple&nbsp;:
    <programlisting>
CREATE FUNCTION insere_fraction(numerateur int, denominateur int) RETURNS text AS $$
from plpy import spiexceptions
try:
    plan = plpy.prepare("INSERT INTO fractions (frac) VALUES ($1 / $2)", ["int", "int"])
    plpy.execute(plan, [numerateur, denominateur])
except spiexceptions.DivisionByZero:
    return "denominateur doit être différent de zéro"
except spiexceptions.UniqueViolation:
    return "a déjà cette fraction"
except plpy.SPIError as e:
    return "autre erreur, SQLSTATE %s" % e.sqlstate
else:
    return "fraction insérée"
$$ LANGUAGE plpythonu;
    </programlisting>
    Notez que, comme toutes les exceptions du module
    <literal>plpy.spiexceptions</literal> héritent de
    <literal>SPIError</literal>, une clause <literal>except</literal>
    la gérant récupèrera toutes les erreurs d'accès aux bases.
   </para>

   <para>
    Comme alternative à la gestion des différentes conditions d'erreur,
    vous pouvez récupérer l'exception <literal>SPIError</literal> et
    déterminer la condition d'erreur spécifique dans le bloc
    <literal>except</literal> en recherchant l'attribut
    <literal>sqlstate</literal> de l'objet exception. Cet attribut est
    une chaîne contenant le code d'erreur <quote>SQLSTATE</quote>. Cette
    approche fournit approximativement la même fonctionnalité.
   </para>
  </sect2>
 </sect1>

 <sect1 id="plpython-subtransaction">
  <title>Sous-transactions explicites</title>

  <para>
   La récupération d'erreurs causées par l'accès à la base de données,
   comme décrite dans <xref linkend="plpython-trapping"/>, peut amener
   à une situation indésirable où certaines opérations réussissent
   avant qu'une d'entre elles échoue et, après récupération de cette
   erreur, les données sont laissées dans un état incohérent. PL/Python
   propose une solution à ce problème sous la forme de sous-transactions
   explicites.
  </para>

  <sect2>
   <title>Gestionnaires de contexte de sous-transaction</title>

   <para>
    Prenez en considération une fonction qui implémente un transfert
    entre deux comptes&nbsp;:
    <programlisting>
CREATE FUNCTION transfert_fonds() RETURNS void AS $$
try:
    plpy.execute("UPDATE comptes SET balance = balance - 100 WHERE nom = 'joe'")
    plpy.execute("UPDATE comptes SET balance = balance + 100 WHERE nom = 'mary'")
except plpy.SPIError as e:
    result = "erreur lors du transfert de fond : %s" % e.args
else:
    result = "fonds transféré correctement"
plan = plpy.prepare("INSERT INTO operations (resultat) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpythonu;
    </programlisting>
    Si la deuxième instruction <literal>UPDATE</literal> se termine avec
    la levée d'une exception, cette fonction renverra l'erreur mais le
    résultat du premier <literal>UPDATE</literal> sera validé malgré
    tout. Autrement dit, les fonds auront été débités du compte de Joe
    mais ils n'auront pas été crédités sur le compte de Mary.
   </para>

   <para>
    Pour éviter ce type de problèmes, vous pouvez intégrer vos appels à
    <literal>plpy.execute</literal> dans une sous-transaction explicite.
    Le module <literal>plpy</literal> fournit un objet d'aide à la gestion
    des sous-transactions explicites qui sont créées avec la fonction
    <literal>plpy.subtransaction()</literal>. Les objets créés par cette
    fonction implémentent l'<ulink url="https://docs.python.org/library/stdtypes.html#context-manager-types">
     interface de gestion du contexte</ulink>. Nous pouvons réécrire notre
    fonction en utilisant les sous-transactions explicites&nbsp;:
    <programlisting>
CREATE FUNCTION transfert_fonds2() RETURNS void AS $$
try:
    with plpy.subtransaction():
        plpy.execute("UPDATE comptes SET balance = balance - 100 WHERE nom = 'joe'")
        plpy.execute("UPDATE comptes SET balance = balance + 100 WHERE nom = 'mary'")
except plpy.SPIError as e:
    result = "erreur lors du transfert de fond : %s" % e.args
else:
    result = "fonds transféré correctement"
plan = plpy.prepare("INSERT INTO operations (resultat) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpythonu;
    </programlisting>
    Notez que l'utilisation de <literal>try/catch</literal> est toujours
    requis. Sinon, l'exception se propagerait en haut de la pile Python
    et causerait l'annulation de la fonction entière avec une erreur
    <productname>PostgreSQL</productname>, pour que la table
    <literal>operations</literal> ne contienne aucune des lignes insérées.
    Le gestionnaire de contexte des sous-transactions ne récupère pas les
    erreurs, il assure seulement que toutes les opérations de bases de
    données exécutées dans son cadre seront validées ou annulées de
    façon atomique. Une annulation d'un bloc de sous-transaction survient
    à la sortie de tout type d'exception, pas seulement celles causées
    par des erreurs venant de l'accès à la base de données. Une exception
    standard Python levée dans un bloc de sous-transaction explicite
    causerait aussi l'annulation de la sous-transaction.
   </para>
  </sect2>

  <sect2>
   <title>Anciennes versions de Python</title>

   <para>
    Pour les gestionnaires de contexte, la syntaxe utilisant le mot clé
    <literal>with</literal>, est disponible par défaut avec Python 2.6. Pour
    la compatibilité avec les anciennes versions de Python, vous pouvez
    appeler les fonctions <literal>__enter__</literal> et
    <literal>__exit__</literal> des gestionnaires de sous-transactions en
    utilisant les alias <literal>enter</literal> et <literal>exit</literal>.
    La fonction exemple de transfert des fonds pourrait être écrite
    ainsi&nbsp;:
    <programlisting>
CREATE FUNCTION transfert_fonds_ancien() RETURNS void AS $$
try:
    subxact = plpy.subtransaction()
    subxact.enter()
    try:
        plpy.execute("UPDATE comptes SET balance = balance - 100 WHERE nom = 'joe'")
        plpy.execute("UPDATE comptes SET balance = balance + 100 WHERE nom = 'mary'")
    except:
        import sys
        subxact.exit(*sys.exc_info())
        raise
    else:
        subxact.exit(None, None, None)
except plpy.SPIError as e:
    result = "erreur lors du transfert de fond : %s" % e.args
else:
    result = "fonds transféré correctement"

plan = plpy.prepare("INSERT INTO operations (resultat) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpythonu;
    </programlisting>
   </para>
  </sect2>
 </sect1>

 <sect1 id="plpython-transactions">
  <title>Gestion des transactions</title>

  <para>
   Dans une procédure ou dans un bloc de code anonyme (commande
   <command>DO</command>), appelé directement, il est possible de contrôler
   les transactions. Pour valider la transaction en cours, appelez
   <literal>plpy.commit()</literal>. Pour annuler la transaction en cours,
   appelez <literal>plpy.rollback()</literal>. (Notez qu'il n'est pas possible
   d'exécuter les commandes SQL <command>COMMIT</command> ou
   <command>ROLLBACK</command> via <function>plpy.execute</function> ou une
   fonction similaire. Cela doit se faire en utilisant ces fonctions.) Après
   la fin d'une transaction, une nouvelle transaction est démarrée
   automatiquement, donc il n'y a pas de fonction séparée pour cela.
  </para>

  <para>
   Voici un exemple&nbsp;:
   <programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE plpythonu
AS $$
for i in range(0, 10):
    plpy.execute("INSERT INTO test1 (a) VALUES (%d)" % i)
    if i % 2 == 0:
        plpy.commit()
    else:
        plpy.rollback()
$$;

CALL transaction_test1();
   </programlisting>
  </para>

  <para>
   Les transactions ne peuvent être terminées quand une sous-transaction
   explicite est active.
  </para>
 </sect1>

 <sect1 id="plpython-util">
  <title>Fonctions outils</title>
  <para>
   Le module <literal>plpy</literal> fournit aussi les fonctions
   <simplelist>
    <member><literal>plpy.debug(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.log(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.info(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.notice(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.warning(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.error(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.fatal(<replaceable>msg, **kwargs</replaceable>)</literal></member>
   </simplelist>
   <indexterm><primary>elog</primary><secondary>dans PL/Python</secondary></indexterm>
   <function>plpy.error</function> et <function>plpy.fatal</function>
   lèvent une exception Python qui, si non attrapée, se propage à la requête
   appelante causant l'annulation de la transaction ou sous-transaction en
   cours. <literal>raise plpy.Error(<replaceable>msg</replaceable>)</literal>
   et <literal>raise plpy.Fatal(<replaceable>msg</replaceable>)</literal> sont
   équivalent à appeler, respectivement,
   <literal>plpy.error(<replaceable>msg</replaceable>)</literal> et
   <literal>plpy.fatal(<replaceable>msg</replaceable>)</literal>, mais la forme
   <literal>raise</literal> n'autorise pas de passer des arguments par mot clé.
   Les autres fonctions génèrent uniquement des messages de
   niveaux de priorité différents. Que les messages d'une priorité particulière
   soient reportés au client, écrit dans les journaux du serveur ou les deux,
   cette configuration est contrôlée par les variables <xref
   linkend="guc-log-min-messages"/> et <xref linkend="guc-client-min-messages"/>.
   Voir le <xref linkend="runtime-config"/> pour plus d'informations.
  </para>

  <para>
   L'argument <replaceable>msg</replaceable> est donné en tant qu'argument de
   position. Pour des raisons de compatibilité descendante, plus d'un argument
   de position doit être donné. Dans ce cas, la représentation en chaîne de
   caractères de la ligne des arguments de position devient le message
   rapporté au client.
  </para>

  <para>
   Les arguments suivant par mot clé seulement sont
   acceptés&nbsp;:
   <simplelist>
    <member><literal>detail</literal></member>
    <member><literal>hint</literal></member>
    <member><literal>sqlstate</literal></member>
    <member><literal>schema_name</literal></member>
    <member><literal>table_name</literal></member>
    <member><literal>column_name</literal></member>
    <member><literal>datatype_name</literal></member>
    <member><literal>constraint_name</literal></member>
   </simplelist>
   La représentation en chaine des objets passés en argument par mot clé
   seulement est utilisé pour enrichir les messages rapportés au client.
   Par exemple&nbsp;:

   <programlisting>
CREATE FUNCTION raise_custom_exception() RETURNS void AS $$
plpy.error("custom exception message",
           detail="some info about exception",
           hint="hint for users")
$$ LANGUAGE plpythonu;

=# SELECT raise_custom_exception();
ERROR:  plpy.Error: custom exception message
DETAIL:  some info about exception
HINT:  hint for users
CONTEXT:  Traceback (most recent call last):
 PL/Python function "raise_custom_exception", line 4, in &lt;module&gt;
   hint="hint for users")
 PL/Python function "raise_custom_exception"
   </programlisting>
  </para>

  <para>
   Voici un autre ensemble de fonctions outils&nbsp;:
   <literal>plpy.quote_literal(<replaceable>string</replaceable>)</literal>,
   <literal>plpy.quote_nullable(<replaceable>string</replaceable>)</literal> et
   <literal>plpy.quote_ident(<replaceable>string</replaceable>)</literal>.
   Elles sont équivalentes aux fonctions internes de mise entre
   guillemets décrites dans <xref linkend="functions-string"/>. Elles
   sont utiles lors de la construction de requêtes. Un équivalent
   PL/Python d'une requête SQL dynamique pour <xref
   linkend="plpgsql-quote-literal-example"/> serait&nbsp;:
   <programlisting>
plpy.execute("UPDATE tbl SET %s = %s WHERE key = %s" % (
    plpy.quote_ident(colname),
    plpy.quote_nullable(newvalue),
    plpy.quote_literal(keyvalue)))
   </programlisting>
  </para>
 </sect1>


 <sect1 id="plpython-envar">
  <title>Variables d'environnement</title>

  <para>
   Certaines des variables d'environnement qui sont acceptées par
   l'interpréteur Python peuvent aussi être utilisées pour modifier le
   comportement de PL/Python. Elles doivent être configurées dans
   l'environnement du processus serveur PostgreSQL principal, par exemple dans
   le script de démarrage. Les variables d'environnement disponibles dépendent
   de la version de Python&nbsp;; voir la documentation de Python pour les
   détails. Au moment de l'écriture de ce chapitre, les variables
   d'environnement suivantes avaient un comportement sur PL/Python, à
   condition d'utiliser une version adéquate de Python&nbsp;:
   <itemizedlist>
    <listitem>
     <para><envar>PYTHONHOME</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONPATH</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONY2K</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONOPTIMIZE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONDEBUG</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONVERBOSE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONCASEOK</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONDONTWRITEBYTECODE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONIOENCODING</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONUSERBASE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONHASHSEED</envar></para>
    </listitem>
   </itemizedlist>

   (Cela semble être un détail d'implémentation de Python, en dehors du
   contrôle de PL/Python, qui fait que certaines variables d'environnement
   listées dans la page man de <command>python</command> sont seulement
   utilisables avec l'interpréteur en ligne de commande et non avec
   un interpréteur Python embarqué.)
  </para>
 </sect1>
</chapter>
