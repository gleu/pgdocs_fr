<?xml version="1.0" encoding="UTF-8"?>
<!-- doc/src/sgml/logicaldecoding.sgml -->
 <chapter id="logicaldecoding">
  <title>Décodage logique (Logical Decoding)</title>
  <indexterm zone="logicaldecoding">
   <primary>Logical Decoding</primary>
  </indexterm>
  <para>
   PostgreSQL fournit une infrastructure pour envoyer par flux les modifications
   effectuées en SQL à des consommateurs externes. Cette fonctionnalité peut
   être utilisée dans plusieurs buts, y compris pour des solutions de
   réplication ou d'audit.
  </para>

  <para>
   Les changemennts sont envoyés dans des flux identifiés par des slots de
   réplication logiques. Chacun de ces slots envoie chaque changement
   une seule et unique fois.
  </para>

  <para>
   Le format dans lequels ces changements sont envoyés est déterminné par
   le plugin de sortie utilisé.  Un plugin d'exemple est fourni, et des
   plugins additionnels peuvent être écrits pour étendre le choix de format
   de sortie disponible sans modifier une seule ligne de code du moteur.
   Chaque plugin de sortie a accès a chaque nouvelle ligne individuelle
   produite par <command>INSERT</command> ainsi que les nouvelles versions
   de lignes créées  par <command>UPDATE</command>.  La disponibilité des
   anciennes version de ligne dépend du
   <link linkend="sql-createtable-replica-identity"><literal>REPLICA
   IDENTITY</literal></link> configuré.
  </para>

  <para>
   Les changements peuvent être consommés soit en utilisant le proctole
   de réplication par flux (voir <xref linkend="protocol-replication"/>
   et <xref linkend="logicaldecoding-walsender"/>),ou par l'appel de
   fonctions en SQL (voir <xref linkend="logicaldecoding-sql"/>).  Il est
   également possible d'écrire de nouvelles méthodes de consommation de
   sortie d'un slot de réplication sans modifier une seule ligne de
   code du moteur
   (voir <xref linkend="logicaldecoding-writer"/>).
  </para>

  <sect1 id="logicaldecoding-example">
   <title>Exemple de décodage logique</title>
   <para>
    L'exemple suivant explique l'interface SQL.
   </para>
   <para>
    Avant de pouvoir utiliser le décodage logique, il est nécessaire
    de positionner <xref linkend="guc-wal-level"/> à <literal>logical</literal>
    et <xref linkend="guc-max-replication-slots"/> à au moins 1.
    Il sera alors possible de se connecter à la base de donénes cible (dans
    l'exemple suivant, <literal>postgres</literal>) en tant que super utilisateur.
   </para>
<programlisting>
postgres=# -- Créé un slot nommé 'regression_slot' utilisant le plugin de sortie 'test_decoding'
postgres=# SELECT * FROM pg_create_logical_replication_slot('regression_slot', 'test_decoding');
    slot_name    | xlog_position
-----------------+---------------
 regression_slot | 0/16B1970
(1 row)

postgres=# SELECT * FROM pg_replication_slots;
    slot_name    |    plugin     | slot_type | datoid | database | active |  xmin  | catalog_xmin | restart_lsn
-----------------+---------------+-----------+--------+----------+--------+--------+--------------+-------------
 regression_slot | test_decoding | logical   |  12052 | postgres | f      |        |          684 | 0/16A4408
(1 row)

postgres=# -- Il n'y a pas encore de changement à voir
postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
 location | xid | data
----------+-----+------
(0 rows)

postgres=# CREATE TABLE data(id serial primary key, data text);
CREATE TABLE

postgres=# -- le DDL n'est pas répliqué, donc seule la transaction est visible
postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
 location  | xid |    data
-----------+-----+------------
 0/16D5D48 | 688 | BEGIN 688
 0/16E0380 | 688 | COMMIT 688
(2 rows)

postgres=# -- Une fois les changements lus, ils sont consommés et ne seront pas renvoyés
postgres=# -- dans un appel ultérieur&nbsp;:
postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
 location | xid | data
----------+-----+------
(0 rows)

postgres=# BEGIN;
postgres=# INSERT INTO data(data) VALUES('1');
postgres=# INSERT INTO data(data) VALUES('2');
postgres=# COMMIT;

postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
 location  | xid |                     data
-----------+-----+-----------------------------------------------
 0/16E0478 | 689 | BEGIN 689
 0/16E0478 | 689 | table public.data: INSERT: id[integer]:1 data[text]:'1'
 0/16E0580 | 689 | table public.data: INSERT: id[integer]:2 data[text]:'2'
 0/16E0650 | 689 | COMMIT 689
(4 rows)

postgres=# INSERT INTO data(data) VALUES('3');

postgres=# -- Il est également possible de prévisualiser le flux de changement sans le consommer
postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL);
 location  | xid |                     data
-----------+-----+-----------------------------------------------
 0/16E09C0 | 690 | BEGIN 690
 0/16E09C0 | 690 | table public.data: INSERT: id[integer]:3 data[text]:'3'
 0/16E0B90 | 690 | COMMIT 690
(3 rows)

postgres=# -- Il est également possible de prévisualiser le flux de changement sans le consommer
postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL);
 location  | xid |                     data
-----------+-----+-----------------------------------------------
 0/16E09C0 | 690 | BEGIN 690
 0/16E09C0 | 690 | table public.data: INSERT: id[integer]:3 data[text]:'3'
 0/16E0B90 | 690 | COMMIT 690
(3 rows)

postgres=# -- des options peuvent être fournies au plugin de sortir pour influer sur le formatage
postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'include-timestamp', 'on');
 location  | xid |                     data
-----------+-----+-----------------------------------------------
 0/16E09C0 | 690 | BEGIN 690
 0/16E09C0 | 690 | table public.data: INSERT: id[integer]:3 data[text]:'3'
 0/16E0B90 | 690 | COMMIT 690 (at 2014-02-27 16:41:51.863092+01)
(3 rows)

postgres=# -- Il ne faut pas oublier de détruire un slot une fois qu'on n'en a plus besoin
postgres=# -- afin qu'il ne consomme plus de ressources sur le serveur&nbsp;:
postgres=# SELECT pg_drop_replication_slot('regression_slot');
 pg_drop_replication_slot
-----------------------

(1 row)
</programlisting>
   <para>
    L'exemple suivant montre l'utilisation de l'interface walsender en utilisant
    la commande shell
    <link linkend="app-pgrecvlogical"><command>pg_recvlogical</command></link>.
    Cela nécessite d'avoir configuré les autorisations de réplication
    (voir <xref linkend="streaming-replication-authentication"/>) et que
    <varname>max_wal_senders</varname> soit positionné suffisamment haut pour
    permettre une nouvelle connexion.
   </para>
<programlisting>
# pg_recvlogical -d postgres --slot test --create
# pg_recvlogical -d postgres --slot test --start -f -
CTRL-Z
# psql -d postgres -c "INSERT INTO data(data) VALUES('4');"
# fg
BEGIN 693
table public.data: INSERT: id[integer]:4 data[text]:'4'
COMMIT 693
CTRL-C
# pg_recvlogical -d postgres --slot test --drop
</programlisting>
  </sect1>
  <sect1 id="logicaldecoding-explanation">
   <title>Concepts de décodage logique</title>
   <sect2>
    <title>Décodage logique</title>
    <indexterm>
     <primary>Logical Decoding</primary>
    </indexterm>
    <para>
     Le décodage logique correspond au processus d'extractions de tous les
     changements persistants sur une table d'une base de données dans un
     format cohérent et simple à comprendre, qui peut être interprêté sans
     une connaissance détaillée de l'état interne de la base de données.
    </para>
    <para>
     Dans <productname>PostgreSQL</productname>, le décodage logique est
     implémenté en décodant le contenu des <link linkend="wal">journaux de
     transaction (WAL)</link>, qui décrivent les changement au niveau
     stockage, dans un format spécifique tel que le flux de lignes ou des
     ordres SQL.
    </para>
   </sect2>

   <sect2>
    <title>Slots de réplication</title>
    <indexterm>
     <primary>replication slot</primary>
     <secondary>logical replication</secondary>
    </indexterm>
    <para>
     Dans le contexte de la réplication logique, un slot représent un flux
     de changements qui peut être rejoué par un client, dans l'ordre dans
     ils ont été effectués sur le serveur d'origine.  Chaque slot envoie dans
     ce flux une séquence de changements d'une unique base en envoyant chaque
     changement une seule et unique fois (sauf utilisation de la
     prévisualisation dans le flux).
    </para>
    <note>
     <para><productname>PostgreSQL</productname> possède également des slots
     de réplication (voir <xref linkend="streaming-replication"/>), mais
     ceux-ci sont utilisés de manière un peu différente ici.
     </para>
    </note>
    <para>
     Les slots de réplication ont un identifiant qui est unique à travers
     toutes les bases d'une instance <productname>PostgreSQL</productname>.
     Les slots persistent indépendamment de la connexion les utilisant et sont
     résistants à un arrêt brutal.
    </para>
    <para>
     De nombreux slots indépendants peuvent exister pour une même base.
     Chacun possède sont propre état, autorisant différents consommateurs
     à recevoir des changements depuis différents points dans le flux de
     changement de la base.  Pour la plupart des utilisations, un slot séparé
     sera requis pour chaque consommateur.
    </para>
    <para>
     Un slot de réplication logique ne sait rien sur l'état du ou des
     destinataire(s).  Il est même possible d'avoir plusieurs destinataires
     différents utilisant un même slot à des moments différents; ils ne
     recevront que les changements à partir de là où le dernier destinataire
     a arrêté de les consommer.  Un seul destinataire peut consommer les
     changements d'un slot à un instant donné.
    </para>
    <note>
     <para>
      Les slots de réplications persistent après un arrêt brutal et ne
      connaissent rien de l'état de leur(s) consommateur(s).  Ils empêcheront
      la suppression automatique des ressources nécessaires même si aucune
      connexion ne les utilise.  Cela consomme de l'espace car aucun des
      journaux de transaction et aucune des lignes des catalogues système requis
      ne  peuvent être supprimés par VACUUM tant qu'ils sont requis par un slot
      de réplication.  Par conséquent, si un slot n'est plus nécessaire il
      devrait être supprimé.
     </para>
    </note>
   </sect2>
   <sect2>
    <title>Plugins de sortie</title>
    <para>
     Les plugins de sortie transforment les données depuis la représentation
     interne dans les journaux de transaction (WAL) vers le format dont le
     consommateur d'un slot de réplication a besoin.
    </para>
   </sect2>
   <sect2>
    <title>Instantanés exportés</title>
    <para>
     Quand un nouveau slot de réplication est créé avec l'interface
     walsender, un instantané est exporté (voir
     <xref linkend="functions-snapshot-synchronization"/>), qui montrera
     exactement l'état de la base de données après lequel tous les
     changements seront inclus dans le flux de changement.  Cela peut être
     utilisé pour créer un nouveau réplicat en utilisant
     <link linkend="sql-set-transaction"><literal>SET TRANSACTION SNAPSHOT
     </literal></link> pour lire l'état de la base au moment où le slot a
     été créé.  Cette transaction peut alors être utilisée pour exporter
     l'état de la base à ce point dans le temps, lequel peut ensuite être
     mis à jour en utilisant le contenu des slots sans perdre le moindre
     changement.
    </para>
   </sect2>
  </sect1>
  <sect1 id="logicaldecoding-walsender">
   <title>Interface du protocole de réplication par flux</title>
   <para>
    Les commandes <literal>CREATE_REPLICATION_SLOT nom_slot LOGICAL
    options</literal>, <literal>DROP_REPLICATION_SLOT nom_slot</literal>
    et <literal>START_REPLICATION SLOT nom_slot LOGICAL options</literal>
    peuvent être utilisées pour créer, supprimer et envoyer par flux les
    changements respectivement depuis un slot de réplications.  Ces commandes
    sont uniquement disponibles au travers d'une connexion de réplication, et
    ne peuvent être utilisée via des commandes SQL.
    Voir <xref linkend="protocol-replication"/>.
   </para>
   <para>
    La commande  <command>pg_recvlogical</command>
    (voir <xref linkend="app-pgrecvlogical"/>) peut être utilisée pour
    contrôler le décodage logique au travers d'une connexion walsender.
   </para>
  </sect1>
  <sect1 id="logicaldecoding-sql">
   <title>Interface <acronym>SQL</acronym> de décodage logique</title>
   <para>
     Voir <xref linkend="functions-replication"/> pour une documentation
     détaillée sur l'API de niveau SQL afin d'intéragir avec le décodage
     logique.
   </para>
   <para>
    La réplication synchrone (voir<xref linkend="synchronous-replication"/>)
    est uniquement supportée sur des slots de réplication utilisés au travers
    de l'interface walsender.  L'interface de fonction et autres interfaces
    additionnelles ne faisant pas partie du moteur ne gèrent pas la
    réplication synchrone.
   </para>
  </sect1>
  <sect1 id="logicaldecoding-catalogs">
   <title>Catalogues systèmes liés au décodage logique</title>
   <para>
    Les vues <link linkend="catalog-pg-replication-slots"><structname>
    pg_replication_slots</structname></link> et
    <link linkend="monitoring-stats-views-table"><structname>pg_stat_replication</structname></link>
    fournissent respectivement des informations sur l'état courant des slots de
    réplication et des connexions walsender.  Ces vues s'appliquent à la fois
    à la réplication physique et logique.
   </para>
  </sect1>
  <sect1 id="logicaldecoding-output-plugin">
   <title>Plugins de sortie de décodage logique</title>
   <para>
    Un exemple de plugin de sortie peut être trouvé dans le sous répertoire
    <link linkend="test-decoding">
     <filename>contrib/test_decoding</filename>
    </link>
    de l'arboresence du code source de PostgreSQL.
   </para>
   <sect2 id="logicaldecoding-output-init">
    <title>Fonction d'initialisation</title>
    <indexterm zone="logicaldecoding">
     <primary>_PG_output_plugin_init</primary>
    </indexterm>
    <para>
     Un plugin de sortie est chargé en chargeant dynamiquement une
     bibliothèque partagée avec comme nom de base le nom du plugin de sortie.
     Le chemin de recherche de bibliothèque habituel est utilisé pour
     localiser cette bibliothèque.  Pour fournir les callbacks de plugins de
     sortie requis et pour indiquer que la bibliothèque est effectivement un
     plugin de sortie, elle doit fournir une fonction nommée <function>
     _PG_output_plugin_init</function>.  Une structure est passée à cette
     fonction qui doit la remplir avec les pointeurs des fonctions de callback
     pour chaque action individuelle.
<programlisting>
typedef struct OutputPluginCallbacks
{
    LogicalDecodeStartupCB startup_cb;
    LogicalDecodeBeginCB begin_cb;
    LogicalDecodeChangeCB change_cb;
    LogicalDecodeCommitCB commit_cb;
    LogicalDecodeShutdownCB shutdown_cb;
} OutputPluginCallbacks;

typedef void (*LogicalOutputPluginInit)(struct OutputPluginCallbacks *cb);
</programlisting>
     Les callbacks <function>begin_cb</function>, <function>change_cb</function>
     et <function>commit_cb</function> sont obligatoires,
     alors que <function>startup_cb</function>
     et <function>shutdown_cb</function> sont facultatifs.
    </para>
   </sect2>

   <sect2 id="logicaldecoding-capabilities">
    <title>Capacités</title>
    <para>
     Pour décoder, formatter et sortir les changements, les plugins de sortie
     peuvent utiliser une grande partie de l'infrastructure habituelle des
     processus clients, y compris l'appels aux fonctions de sortie.  Les accès
     en lecture seule aux relations est permis du moment que les relations
     accédées ont soit été créées par <command>initdb</command> dans le schéma
     <literal>pg_catalog</literal>, ou ont été marqués comme tables du
     catalogue pour l'utilisateur en utilisant
<programlisting>
ALTER TABLE table_catalogue_utilisateur SET (user_catalog_table = true);
CREATE TABLE autre_table_catalogue(data text) WITH (user_catalog_table = true);
</programlisting>
     Toute action amenant à un assignement de d'identifiant de transaction est
     interdit.  Cela inclue, entre autre, l'écriture dans des tables,
     effectuer des changement DDL et appeler <literal>txid_current()</literal>.
    </para>
   </sect2>

   <sect2 id="logicaldecoding-output-plugin-callbacks">
    <title>Callbacks de plugin de sortie</title>
    <para>
     Un plugin de sortie est notifié des changements arrivant au traviers de
     différents callbacks qu'il doit fournir.
    </para>
    <para>
     Les transactions concurrentes sont décodées dans l'ordre dans lequel
     elles sont validées, et seuls les changements appartenent à une
     transaction spécifique sont décodés entre les callbacks
     <literal>begin</literal> et <literal>commit</literal>.  Les transactions
     quit onnt été explicitement ou implicitement annulées ne sont jamais
     décodées.  Les <link linkend="sql-savepoint">SAVEPOINTs</link> validés
     sont inclus dans la transaction les contenant, dans l'ordre dans lequel
     ils ont été effectués dans la transaction.
    </para>
    <note>
     <para>
      Seules les transactions qui ont été synchronisées sur disque de manière
      sûre seront décodées.  Cela peut amener à ce qu'un COMMIT ne soit pas
      immédiatement décodé lors d'un appel à
      <literal>pg_logical_slot_get_changes()</literal> juste après celui-ci
      quand <varname>synchronous_commit</varname> est positionné à
      <literal>off</literal>.
     </para>
    </note>
    <sect3 id="logicaldecoding-output-plugin-startup">
     <title>Callback de démarrage</title>
     <para>
      Le callback facultatif <function>startup_cb</function> est appelé chaque
      fois qu'un slot de réplication est créé ou qu'on lui de fournir les flux
      de changement,indépendamment du nombre de changements qui sont prêt à
      être fournis.
<programlisting>
typedef void (*LogicalDecodeStartupCB) (
    struct LogicalDecodingContext *ctx,
    OutputPluginOptions *options,
    bool is_init
);
</programlisting>
      Le paramètre  <literal>is_init</literal> sera positioné à true quand le
      slot de réplication est créé, et à false sinon.
      <parameter>options</parameter> pointe vers une structure d'options
      que le plugin de sortie peut mositionner&nbsp;:
<programlisting>
typedef struct OutputPluginOptions
{
    OutputPluginOutputType output_type;
} OutputPluginOptions;
</programlisting>
      <literal>output_type</literal> doit être positionné soit à
      <literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal>
      ou à <literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal>.
     </para>
     <para>
      Le callback de démarrage devrait valider les options présentes dans
      <literal>ctx-&gt;output_plugin_options</literal>.  Si le plugin de
      sortie a besoin d'avoir un état, il peut utiliser
      <literal>ctx-&gt;output_plugin_private</literal> pour le stocker.
     </para>
    </sect3>
    <sect3 id="logicaldecoding-output-plugin-shutdown">
     <title>Callback d'arrêt</title>
     <para>
      Me callback facultatif <function>shutdown_cb</function> est appelé
      chaque fois qu'un slot de réplication anciennement actif n'est plus
      utilisé et peut être utilisé pour désallouer privées du plugin de
      sortie.  Le slot n'est pas nécessairement supprimé, le flux est juste
      arrêté.
<programlisting>
typedef void (*LogicalDecodeShutdownCB) (
    struct LogicalDecodingContext *ctx
);
</programlisting>
     </para>
   </sect3>
    <sect3 id="logicaldecoding-output-plugin-begin">
     <title>Callback de début de transaction</title>
     <para>
      Le callback obligatoire <function>begin_cb</function> est appelé chaque
      fois que le début d'une transaction validée n'a pas été décodé.  Les
      transactions annulées et leur contenu ne sont pas décodés.
<programlisting>
typedef void (*LogicalDecodeBeginCB) (
    struct LogicalDecodingContext *,
    ReorderBufferTXN *txn
);
</programlisting>
      Le paramètre <parameter>txn</parameter> contient des métadonnées sur la
      transaction, come l'heure à laquelle elle a été validée et son XID.
     </para>
   </sect3>
    <sect3 id="logicaldecoding-output-plugin-commit">
     <title>Callback de fin de transaction</title>
     <para>
      Le callback obligatoire <function>commit_cb</function> est appelé chaque
      fois qu'une transaction validée a été décodée.  Le callback
      <function>change_cb</function> aura été appelé avant cela pour chacune
      des lignes modifiées, s'il y en a eu.
<programlisting>
typedef void (*LogicalDecodeCommitCB) (
    struct LogicalDecodingContext *,
    ReorderBufferTXN *txn
);
</programlisting>
     </para>
    </sect3>
    <sect3 id="logicaldecoding-output-plugin-change">
     <title>Callback appelé pour chaque changement individuel
      dans une transaction</title>
     <para>
      Le callback obligatoire <function>change_cb</function> est appelé pour
      chacune des modifications de ligne au sein d'une transaction, qu'il
      s'agisse d'un <command>INSERT</command>, <command>UPDATE</command>
      ou <command>DELETE</command>.  Même si la commande d'origine a modifié
      plusieurs ligne en une seule instruction, le callback sera appelé
      pour chaque ligne individuellement.
<programlisting>
typedef void (*LogicalDecodeChangeCB) (
    struct LogicalDecodingContext *ctx,
    ReorderBufferTXN *txn,
    Relation relation,
    ReorderBufferChange *change
);
</programlisting>
      Les paramètres <parameter>ctx</parameter> et <parameter>txn</parameter>
      ont le même contenu que pour les callbacks <function>begin_cb</function>
      et <function>commit_cb</function>, mais en plus le descripteur de relation
      <parameter>relation</parameter> pointe vers la relation à laquelle
      apaprtient la ligne et une structure <parameter>change</parameter>
      décrivant les modifications de lignes y est passée.
     </para>
     <note>
      <para>
       Seules les changement dans les tables définies par les utilisateurs qui
       sont et journalisées (voir <xref linkend="sql-createtable-unlogged"/>)
       et ne sont pas temporaires
       (voir <xref linkend="sql-createtable-temporary"/>) peuvent être extraite
       avec le décodage logique.
      </para>
     </note>
    </sect3>
   </sect2>
   <sect2 id="logicaldecoding-output-plugin-output">
    <title>Fonction pour produire une sortie dans un plugin de sortie</title>
    <para>
     Pour effectivement pouvoir produire une sortie, les plugins de sortie
     peuvent écrire des données dans le tampon de sortie <literal>StringInfo
     </literal> dans <literal>ctx-&gt;out</literal> dans les callbacks
     <function>begin_cb</function>, <function>commit_cb</function>
     ou <function>change_cb</function>.  Avant d'écrire dans le tampon de
     sortie, <function>OutputPluginWrite(ctx, last_write)</function> doit avoir
     été appelé pour effectuer l'écriture.  <parameter>last_write</parameter>
     indique si une écriture particuli_re était la dernière écriture du
     callback.
    </para>
    <para>
     L'exemple suivant montre comment sortir des données pour le consommateur
     d'un plugin de sortie&nbsp;:
<programlisting>
OutputPluginPrepareWrite(ctx, true);
appendStringInfo(ctx->out, "BEGIN %u", txn->xid);
OutputPluginWrite(ctx, true);
</programlisting>
    </para>
   </sect2>
  </sect1>
  <sect1 id="logicaldecoding-writer">
   <title>Écrivains de sortie de décodage logique</title>
   <para>
    Il est possible d'ajouter d'autres méthodes de sortie pour le décodage
    logique. Pour plus de détail, voir
    <filename>src/backend/replication/logical/logicalfuncs.c</filename>.
    Principalement, trois fonctions doivent être fournies&nbsp;: une pour lire
    les journaux de transaction, une pour préparer l'écriture de sortie et une
    pour préparer la sortie
    (voir <xref linkend="logicaldecoding-output-plugin-output"/>).
   </para>
  </sect1>
  <sect1 id="logicaldecoding-synchronous">
   <title>Support de la réplicationp synchrone pour le décoage logique</title>
   <para>
    Le décodage logique peut être utiliser pour construire des solution de
    <link linkend="synchronous-replication">réplication synchrone</link> avec
    la même interface utilisateur que la réplication synchrone de la
    <link linkend="streaming-replication">réplication par flux</link>.  Pour
    cela, l'interface walsender
    (voir <xref linkend="logicaldecoding-walsender"/>) doit être utilisée pour
    renvoyer par flux les données.  Les clients doivent envoyer des messages
    <literal>Standby status update (F)</literal>
    (voir <xref linkend="protocol-replication"/>), tout comme le font les
    clients de réplication par flux.
   </para>
   <note>
    <para>
     Un réplicat synchrone recevant des changement grâce au décodage logique
     fonctionnera dans le cadre d'une seule base de données.  Puisque,
     à l'opposé de cela, <parameter>synchronous_standby_names</parameter> est
     actuellement commun à toute l'instance, cela signifie que cette technique
     ne marchera pas convenablement si plus d'une base de l'instance est
     utilisée activement.
     </para>
   </note>
  </sect1>
 </chapter>
