<?xml version="1.0" encoding="UTF-8"?>
<chapter id="logicaldecoding">
 <title>Décodage logique (Logical Decoding)</title>

 <indexterm zone="logicaldecoding">
  <primary>Logical Decoding</primary>
 </indexterm>

 <para>
  PostgreSQL fournit une infrastructure pour envoyer par flux les
  modifications effectuées en SQL à des consommateurs externes. Cette
  fonctionnalité peut être utilisée dans plusieurs buts, y compris pour des
  solutions de réplication ou d'audit.
 </para>

 <para>
  Les changements sont envoyés dans des flux identifiés par des slots de
  réplication logique.
 </para>

 <para>
  Le format dans lequel ces changements sont envoyés est déterminé par le
  plugin de sortie utilisé. Un plugin d'exemple est fourni dans la
  distribution de PostgreSQL, et des plugins additionnels peuvent être écrits
  pour étendre le choix de format de sortie disponible sans modifier une
  seule ligne de code du moteur. Chaque plugin de sortie a accès à chaque
  nouvelle ligne individuelle produite par les commandes
  <command>INSERT</command>, ainsi que les nouvelles versions de lignes
  créées par les commandes <command>UPDATE</command>. La disponibilité des
  anciennes version de ligne dépend de l'identité de réplicat configurée
  (voir <xref linkend="sql-altertable-replica-identity"/>).
 </para>

 <para>
  Les changements peuvent être consommés soit en utilisant le protocole de
  réplication par flux (voir <xref linkend="protocol-replication"/> et <xref
  linkend="logicaldecoding-walsender"/>), soit par l'appel de fonctions en
  SQL(voir <xref linkend="logicaldecoding-sql"/>). Il est également possible
  d'écrire de nouvelles méthodes de consommation de sortie d'un slot de
  réplication sans modifier une seule ligne de code du moteur (voir <xref
  linkend="logicaldecoding-writer"/>).
 </para>

 <sect1 id="logicaldecoding-example">
  <title>Exemples de décodage logique</title>

  <para>
   L'exemple suivant explique le contrôle du décodage logique en utilisant
   l'interface SQL.
  </para>

  <para>
   Avant de pouvoir utiliser le décodage logique, il est nécessaire de
   positionner le paramètre <xref linkend="guc-wal-level"/> à la valeur
   <literal>logical</literal> et le paramètre <xref
   linkend="guc-max-replication-slots"/> à la valeur 1 ou supérieur. Il sera
   alors possible de se connecter à la base de données cible (dans l'exemple
   suivant, <literal>postgres</literal>) en tant que superutilisateur.
  </para>

  <programlisting>postgres=# -- Créer un slot nommé 'regression_slot' utilisant le plugin de sortie 'test_decoding'
postgres=# SELECT * FROM pg_create_logical_replication_slot('regression_slot', 'test_decoding', false, true);
    slot_name    |    lsn
-----------------+---------------
 regression_slot | 0/16B1970
(1 row)

postgres=# SELECT slot_name, plugin, slot_type, database, active, restart_lsn, confirmed_flush_lsn FROM pg_replication_slots;
    slot_name    |    plugin     | slot_type | database | active | restart_lsn | confirmed_flush_lsn
-----------------+---------------+-----------+----------+--------+-------------+-----------------
 regression_slot | test_decoding | logical   | postgres | f      | 0/16A4408   | 0/16A4440
(1 row)

postgres=# -- Il n'y a pas encore de changement à voir
postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
 lsn | xid | data
-----+-----+------
(0 rows)

postgres=# CREATE TABLE data(id serial primary key, data text);
CREATE TABLE

postgres=# -- le DDL n'est pas répliqué, donc seule la transaction est visible
postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    |  xid  |     data
-----------+-------+--------------
 0/BA2DA58 | 10297 | BEGIN 10297
 0/BA5A5A0 | 10297 | COMMIT 10297
(2 rows)

postgres=# -- Une fois les changements lus, ils sont consommés et ne seront pas renvoyés
postgres=# -- dans un appel ultérieur&nbsp;:
postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
 lsn | xid | data
-----+-----+------
(0 rows)

postgres=# BEGIN;
postgres=*# INSERT INTO data(data) VALUES('1');
postgres=*# INSERT INTO data(data) VALUES('2');
postgres=*# COMMIT;

postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    |  xid  |                          data
-----------+-------+---------------------------------------------------------
 0/BA5A688 | 10298 | BEGIN 10298
 0/BA5A6F0 | 10298 | table public.data: INSERT: id[integer]:1 data[text]:'1'
 0/BA5A7F8 | 10298 | table public.data: INSERT: id[integer]:2 data[text]:'2'
 0/BA5A8A8 | 10298 | COMMIT 10298
(4 rows)

postgres=# INSERT INTO data(data) VALUES('3');

postgres=# -- Le prochain appel à pg_logical_slot_peek_changes() envoie de nouveau les mêmes modifications
postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL);
    lsn    |  xid  |                          data
-----------+-------+---------------------------------------------------------
 0/BA5A8E0 | 10299 | BEGIN 10299
 0/BA5A8E0 | 10299 | table public.data: INSERT: id[integer]:3 data[text]:'3'
 0/BA5A990 | 10299 | COMMIT 10299
(3 rows)

postgres=# -- Il est également possible de prévisualiser le flux de changement sans le consommer
postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL);
    lsn    |  xid  |                          data
-----------+-------+---------------------------------------------------------
 0/BA5A8E0 | 10299 | BEGIN 10299
 0/BA5A8E0 | 10299 | table public.data: INSERT: id[integer]:3 data[text]:'3'
 0/BA5A990 | 10299 | COMMIT 10299
(3 rows)

postgres=# -- des options peuvent être fournies au plugin de sortir pour influer sur le formatage
postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'include-timestamp', 'on');
    lsn    |  xid  |                          data
-----------+-------+---------------------------------------------------------
 0/BA5A8E0 | 10299 | BEGIN 10299
 0/BA5A8E0 | 10299 | table public.data: INSERT: id[integer]:3 data[text]:'3'
 0/BA5A990 | 10299 | COMMIT 10299 (at 2017-05-10 12:07:21.272494-04)
(3 rows)

postgres=# -- Il ne faut pas oublier de détruire un slot une fois qu'on n'en a plus besoin
postgres=# -- afin qu'il ne consomme plus de ressources sur le serveur&nbsp;:
postgres=# SELECT pg_drop_replication_slot('regression_slot');
 pg_drop_replication_slot
-----------------------

(1 row)</programlisting>

  <para>
   Les exemples suivants montrent comment le décodage logique est contrôlé avec
   le protocole de réplication en flux, en utilisant l'outil <xref
   linkend="app-pgrecvlogical"/> fourni avec la distribution PostgreSQL. Il
   requiert que l'authentification du client soit configuré pour autoriser une
   connexion de réplication (voir <xref
   linkend="streaming-replication-authentication"/>) et que le paramètre
   <varname>max_wal_senders</varname> soit configuré suffisamment haut pour
   qu'une nouvelle connexion soit acceptée. Le deuxième exemple montre comment
   envoyer en flux les transactions en deux phases. Avant d'utiliser des
   commandes à deux phases, vous devez configurer le paramètre <xref
   linkend="guc-max-prepared-transactions"/> à au moins 1.
  </para>

  <programlisting>Exemple 1 :
$ pg_recvlogical -d postgres --slot=test --create-slot
$ pg_recvlogical -d postgres --slot=test --start -f -
<keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo>
$ psql -d postgres -c "INSERT INTO data(data) VALUES('4');"
$ fg
 BEGIN 693
 table public.data: INSERT: id[integer]:4 data[text]:'4'
 COMMIT 693
<keycombo action="simul"><keycap>Control</keycap><keycap>C</keycap></keycombo>
$ pg_recvlogical -d postgres --slot=test --drop-slot

Exemple 2 :
$ pg_recvlogical -d postgres --slot=test --create-slot --two-phase
$ pg_recvlogical -d postgres --slot=test --start -f -
<keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo>
$ psql -d postgres -c "BEGIN;INSERT INTO data(data) VALUES('5');PREPARE TRANSACTION 'test';"
$ fg
BEGIN 694
table public.data: INSERT: id[integer]:5 data[text]:'5'
PREPARE TRANSACTION 'test', txid 694
<keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo>
$ psql -d postgres -c "COMMIT PREPARED 'test';"
$ fg
COMMIT PREPARED 'test', txid 694
<keycombo action="simul"><keycap>Control</keycap><keycap>C</keycap></keycombo>
$ pg_recvlogical -d postgres --slot=test --drop-slot</programlisting>

  <para>
   L'exemple suivant montre l'interface SQL pouvant être utilisée pour décoder
   les transactions préparées. Avant d'utiliser les commandes du Two-Phase
   Commit, vous devez configurer le paramètre
   <varname>max_prepared_transactions</varname> à la valeur 1 au minimum.
   Vous devez aussi avoir configuré le paramètre two-phase à la valeur true
   lors de la création du slot en utilisant
   <function>pg_create_logical_replication_slot</function>. Notez que la
   transaction entière sera envoyée dans le flux après la validation de la
   transaction si elle n'est pas déjà décodée.
  </para>

  <programlisting>postgres=# BEGIN;
postgres=*# INSERT INTO data(data) VALUES('5');
postgres=*# PREPARE TRANSACTION 'test_prepared1';

postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    | xid |                          data
-----------+-----+---------------------------------------------------------
 0/1689DC0 | 529 | BEGIN 529
 0/1689DC0 | 529 | table public.data: INSERT: id[integer]:3 data[text]:'5'
 0/1689FC0 | 529 | PREPARE TRANSACTION 'test_prepared1', txid 529
(3 rows)

postgres=# COMMIT PREPARED 'test_prepared1';
postgres=# select * from pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    | xid |                    data
-----------+-----+--------------------------------------------
 0/168A060 | 529 | COMMIT PREPARED 'test_prepared1', txid 529
(4 row)

postgres=#-- On peut aussi faire un rollback de la transaction préparée
postgres=# BEGIN;
postgres=*# INSERT INTO data(data) VALUES('6');
postgres=*# PREPARE TRANSACTION 'test_prepared2';
postgres=# select * from pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    | xid |                          data
-----------+-----+---------------------------------------------------------
 0/168A180 | 530 | BEGIN 530
 0/168A1E8 | 530 | table public.data: INSERT: id[integer]:4 data[text]:'6'
 0/168A430 | 530 | PREPARE TRANSACTION 'test_prepared2', txid 530
(3 rows)

postgres=# ROLLBACK PREPARED 'test_prepared2';
postgres=# select * from pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    | xid |                     data
-----------+-----+----------------------------------------------
 0/168A4B8 | 530 | ROLLBACK PREPARED 'test_prepared2', txid 530
(1 row)</programlisting>
 </sect1>

 <sect1 id="logicaldecoding-explanation">
  <title>Concepts de décodage logique</title>

  <sect2>
   <title>Décodage logique</title>

   <indexterm>
    <primary>Décodage logique</primary>
   </indexterm>

   <para>
    Le décodage logique correspond au processus d'extraction de tous les
    changements persistants sur une table d'une base de données dans un
    format cohérent et simple à comprendre, qui peut être interprété sans une
    connaissance détaillée de l'état interne de la base de données.
   </para>

   <para>
    Dans <productname>PostgreSQL</productname>, le décodage logique est
    implémenté en décodant le contenu des <link linkend="wal">journaux de
    transaction (WAL)</link>, qui décrivent les changements au niveau
    stockage, dans un format spécifique tel que le flux de lignes ou des
    ordres SQL.
   </para>
  </sect2>

  <sect2 id="logicaldecoding-replication-slots">
   <title>Slots de réplication</title>

   <indexterm>
    <primary>slot de réplication</primary>
    <secondary>réplication logique</secondary>
   </indexterm>

   <para>
    Dans le contexte de la réplication logique, un slot représente un flux de
    changements qui peut être rejoué par un client, dans l'ordre dans lequel
    ils ont été effectués sur le serveur d'origine. Chaque slot envoie dans
    ce flux une séquence de changements d'une unique base.
   </para>

   <note>
    <para>
     <productname>PostgreSQL</productname> possède également des slots de
     réplication (voir <xref linkend="streaming-replication"/>), mais ceux-ci
     sont utilisés de manière un peu différente ici.
    </para>
   </note>

   <para>
    Les slots de réplication ont un identifiant qui est unique à travers
    toutes les bases d'une instance <productname>PostgreSQL</productname>.
    Les slots persistent indépendamment de la connexion les utilisant et sont
    résistants à un arrêt brutal.
   </para>

   <para>
    Un slot logique émettra chaque modification une fois en temps normal. La
    position actuelle de chaque slot est enregistrée seulement lors d'un
    checkpoint, donc dans le cas d'un crash, le slot pourrait revenir à un
    ancien LSN, qui sera la cause d'un renvoi des changements récents au
    redémarrage du serveur. Les clients de décodage logique sont responsables
    de la bonne gestion de ce fait et doivent éviter les mauvais effets dûs à
    la gestion du même message plusieurs fois. Les clients peuvent souhaiter
    enregistrer le dernier LSN qu'ils ont vu lors du décodage pour ignorer
    toute donnée répétée ou (lors de l'utilisation du protocole de
    réplication) demander que le décodage commence à partir de ce LSN plutôt
    que de laisser le serveur déterminer le point de démarrage. La
    fonctionnalité <foreignphrase>Replication Progress
    Tracking</foreignphrase> est conçue dans ce but, voir les <link
    linkend="replication-origins">origines de réplication</link>.
   </para>

   <para>
    De nombreux slots indépendants peuvent exister pour une même base. Chaque
    slot possède son propre état, autorisant différents consommateurs à
    recevoir des changements depuis différents points dans le flux de
    changement de la base. Pour la plupart des utilisations, un slot séparé
    sera requis pour chaque consommateur.
   </para>

   <para>
    Un slot de réplication logique ne sait rien sur l'état du ou des
    destinataire(s). Il est même possible d'avoir plusieurs destinataires
    différents utilisant un même slot à des moments différents&nbsp;; ils ne
    recevront que les changements à partir du moment où le dernier
    destinataire a arrêté de les consommer. Un seul destinataire peut
    consommer les changements d'un slot à un instant donné.
   </para>

   <caution>
    <para>
     Les slots de réplications persistent après un arrêt brutal et ne
     connaissent rien de l'état de leur(s) consommateur(s). Ils empêcheront
     la suppression automatique des ressources nécessaires même si aucune
     connexion ne les utilise. Cela consomme de l'espace car aucun des
     journaux de transactions et aucune des lignes des catalogues systèmes
     requis ne peuvent être supprimés par <command>VACUUM</command> tant
     qu'ils sont requis par un slot de réplication. Dans les cas extrêmes,
     cela pourrait causer l'arrêt de la base pour empêcher une réutilisation
     des identifiants de transactions (voir <xref
     linkend="vacuum-for-wraparound"/>). Par conséquent, si un slot n'est
     plus nécessaire, il devrait être supprimé.
    </para>
   </caution>
  </sect2>

  <sect2>
   <title>Plugins de sortie</title>

   <para>
    Les plugins de sortie transforment les données depuis la représentation
    interne dans les journaux de transactions (WAL) vers le format dont le
    consommateur d'un slot de réplication a besoin.
   </para>
  </sect2>

  <sect2>
   <title>Instantanés exportés</title>

   <para>
    Quand un nouveau slot de réplication est créé avec l'interface de la
    réplication en flux (voir <xref
    linkend="protocol-replication-create-replication-slot"/>), un instantané est exporté
    (voir <xref linkend="functions-snapshot-synchronization"/>), qui montrera
    exactement l'état de la base de données après lequel tous les changements
    seront inclus dans le flux de changement. Cela peut être utilisé pour
    créer un nouveau réplicat en utilisant <link
    linkend="sql-set-transaction"><literal>SET TRANSACTION
    SNAPSHOT</literal></link> pour lire l'état de la base au moment où le
    slot a été créé. Cette transaction peut alors être utilisée pour
    exporter l'état de la base à ce point dans le temps, lequel peut ensuite
    être mis à jour en utilisant le contenu des slots sans perdre le moindre
    changement.
   </para>

   <para>
    La création d'un instantané n'est pas toujours possible. En particulier,
    cela échouera quand cela est fait à partir d'un serveur secondaire en
    lecture seule. Les applications qui ne nécessitent pas d'instantané
    exporté peuvent les supprimer avec l'option
    <literal>NOEXPORT_SNAPSHOT</literal>.
   </para>
  </sect2>
 </sect1>

 <sect1 id="logicaldecoding-walsender">
  <title>Interface du protocole de réplication par flux</title>

  <para>
   Les commandes

   <itemizedlist>
    <listitem>
     <para><literal>CREATE_REPLICATION_SLOT <replaceable>nom_slot</replaceable> LOGICAL <replaceable>plugin_sortie</replaceable></literal></para>
    </listitem>

    <listitem>
     <para><literal>DROP_REPLICATION_SLOT <replaceable>nom_slot</replaceable></literal> <optional> <literal>WAIT</literal></optional></para>
    </listitem>

    <listitem>
     <para><literal>START_REPLICATION SLOT <replaceable>nom_slot</replaceable> LOGICAL ...</literal></para>
    </listitem>
   </itemizedlist>

   sont utilisées pour, respectivement, créer, supprimer et envoyer les
   modifications à partir d'un slot de réplication. Ces commandes sont
   seulement disponibles à partir d'une connexion de réplication&nbsp;; elles
   ne peuvent pas être utilisées sur une connexion standard, qui n'accepte
   que les commandes SQL. Voir <xref linkend="protocol-replication"/> pour
   les détails sur ces commandes.
  </para>

  <para>
   L'outil <xref linkend="app-pgrecvlogical"/> peut être utilisé pour
   commander le décodage logique sur une connexion de réplication en flux.
   (Il utilise ces commandes en interne.)
  </para>
 </sect1>

 <sect1 id="logicaldecoding-sql">
  <title>Interface <acronym>SQL</acronym> de décodage logique</title>

  <para>
   Voir <xref linkend="functions-replication"/> pour une documentation
   détaillée sur l'API de niveau SQL afin d'interagir avec le décodage
   logique.
  </para>

  <para>
   La réplication synchrone (voir <xref linkend="synchronous-replication"/>)
   est uniquement supportée sur des slots de réplication utilisés au travers
   de l'interface de réplication en flux. L'interface de fonction et autres
   interfaces additionnelles ne faisant pas partie du moteur, ils ne gèrent
   pas la réplication synchrone.
  </para>
 </sect1>

 <sect1 id="logicaldecoding-catalogs">
  <title>Catalogues systèmes liés au décodage logique</title>

  <para>
   Les vues <link linkend="view-pg-replication-slots"><structname>
   pg_replication_slots</structname></link> et <link
   linkend="monitoring-pg-stat-replication-view">
   <structname>pg_stat_replication</structname></link> fournissent
   respectivement des informations sur l'état courant des slots de
   réplication et des connexions de réplication en flux. Ces vues
   s'appliquent à la fois à la réplication physique et logique. La vue <link
   linkend="monitoring-pg-stat-replication-slots-view">
   <structname>pg_stat_replication_slots</structname></link> fournit des
   statistiques sur les slots de réplication logiques.
  </para>
 </sect1>

 <sect1 id="logicaldecoding-output-plugin">
  <title>Plugins de sortie de décodage logique</title>

  <para>
   Un exemple de plugin de sortie peut être trouvé dans le sous-répertoire
   <link
   linkend="test-decoding"><filename>contrib/test_decoding</filename></link>
   de l'arborescence du code source de PostgreSQL.
  </para>

  <sect2 id="logicaldecoding-output-init">
   <title>Fonction d'initialisation</title>

   <indexterm zone="logicaldecoding-output-init">
    <primary>_PG_output_plugin_init</primary>
   </indexterm>

   <para>
    Un plugin de sortie est initialisé en chargeant dynamiquement une bibliothèque
    partagée avec comme nom de base le nom du plugin de sortie. Le chemin de
    recherche de bibliothèque habituel est utilisé pour localiser cette
    bibliothèque. Pour fournir les callbacks de plugins de sortie requis et
    pour indiquer que la bibliothèque est effectivement un plugin de sortie,
    elle doit fournir une fonction nommée
    <function>_PG_output_plugin_init</function>. Une structure est passée à
    cette fonction qui doit la remplir avec les pointeurs des fonctions de
    callback pour chaque action individuelle.

    <programlisting>typedef struct OutputPluginCallbacks
{
    LogicalDecodeStartupCB startup_cb;
    LogicalDecodeBeginCB begin_cb;
    LogicalDecodeChangeCB change_cb;
    LogicalDecodeTruncateCB truncate_cb;
    LogicalDecodeCommitCB commit_cb;
    LogicalDecodeMessageCB message_cb;
    LogicalDecodeFilterByOriginCB filter_by_origin_cb;
    LogicalDecodeShutdownCB shutdown_cb;
    LogicalDecodeFilterPrepareCB filter_prepare_cb;
    LogicalDecodeBeginPrepareCB begin_prepare_cb;
    LogicalDecodePrepareCB prepare_cb;
    LogicalDecodeCommitPreparedCB commit_prepared_cb;
    LogicalDecodeRollbackPreparedCB rollback_prepared_cb;
    LogicalDecodeStreamStartCB stream_start_cb;
    LogicalDecodeStreamStopCB stream_stop_cb;
    LogicalDecodeStreamAbortCB stream_abort_cb;
    LogicalDecodeStreamPrepareCB stream_prepare_cb;
    LogicalDecodeStreamCommitCB stream_commit_cb;
    LogicalDecodeStreamChangeCB stream_change_cb;
    LogicalDecodeStreamMessageCB stream_message_cb;
    LogicalDecodeStreamTruncateCB stream_truncate_cb;
} OutputPluginCallbacks;

typedef void (*LogicalOutputPluginInit) (struct OutputPluginCallbacks *cb);</programlisting>

    Les callbacks <function>begin_cb</function>,
    <function>change_cb</function> et <function>commit_cb</function> sont
    obligatoires, alors que <function>startup_cb</function>,
    <function>filter_by_origin_cb</function>,
    <function>truncate_cb</function> et <function>shutdown_cb</function> sont
    facultatifs. Si <function>truncate_cb</function> n'est pas configuré mais
    que <command>TRUNCATE</command> doit être décodé, l'action sera ignorée.
   </para>

   <para>
    Un plugin de sortie peut aussi définir les fonctions pour accepter le flux
    de grosses transactions en cours. Les callbacks
    <function>stream_start_cb</function>,
    <function>stream_stop_cb</function>,
    <function>stream_abort_cb</function>,
    <function>stream_commit_cb</function>,
    <function>stream_change_cb</function> et
    <function>stream_prepare_cb</function> sont obligatoires, alors que
    <function>stream_message_cb</function> et
    <function>stream_truncate_cb</function> sont facultatifs.
    De plus, si l'envoi en flux des commandes à deux phases doit être
    supporté, alors des fonctions de support supplémentaires doivent être
    fournies. (Voir <xref linkend="logicaldecoding-two-phase-commits"/>
    pour les détails).
   </para>

   <para>
    Un plugin de sortie peut aussi définir les fonctions pour accepter les
    validations en deux phases, ce qui permet de décoder un <command>PREPARE
    TRANSACTION</command>. Les callbacks
    <function>begin_prepare_cb</function>, <function>prepare_cb</function>,
    <function>stream_prepare_cb</function>,
    <function>commit_prepared_cb</function> et
    <function>rollback_prepared_cb</function> sont obligatoires, alors que
    <function>filter_prepare_cb</function> est facultatif.
   </para>
  </sect2>

  <sect2 id="logicaldecoding-capabilities">
   <title>Capacités</title>

   <para>
    Pour décoder, formater et afficher les changements, les plugins de sortie
    peuvent utiliser une grande partie de l'infrastructure habituelle des
    processus clients, y compris l'appel aux fonctions de sortie. Les accès
    en lecture seule aux relations est permis du moment que les relations
    accédées ont été créées par <command>initdb</command> dans le schéma
    <literal>pg_catalog</literal>, ou ont été marquées comme tables du
    catalogue pour l'utilisateur en utilisant&nbsp;:

    <programlisting>ALTER TABLE table_catalogue_utilisateur SET (user_catalog_table = true);
CREATE TABLE autre_table_catalogue(data text) WITH (user_catalog_table = true);</programlisting>

    Notez que l'accès aux tables utilisateurs ou aux tables systèmes dans le
    plugin de sortie doit se faire uniquement via les API de parcours
    <literal>systable_*</literal>. L'accès via les API de parcours
    <literal>heap_*</literal> renverra une erreur. De plus, toute action
    amenant à l'affectation d'un identifiant de transaction est prohibée.
    Ceci, parmi d'autres choses, inclut l'écriture dans les tables, la réalisation
    de modifications DDL, et l'appel à <literal>pg_current_xact_id()</literal>.
   </para>
  </sect2>

  <sect2 id="logicaldecoding-output-mode">
   <title>Modes de sortie</title>

   <para>
    Les fonctions callbacks des plugins en sortie peuvent renvoyer des données
    au consommateur dans des formats pratiquement arbitraires. Pour certains
    cas d'utilisation, comme la visualisation des changements en SQL, le
    renvoi des données dans un type de données qui peut contenir des données
    arbitraires (par exemple du <type>bytea</type>) est complexe. Si le
    plugin en sortie renvoit seulement les données au format texte dans
    l'encodage du serveur, il peut déclarer cela en configurant
    <literal>OutputPluginOptions.output_type</literal> à
    <literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal> au lieu de
    <literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal> dans la <link
    linkend="logicaldecoding-output-plugin-startup"> fonction callback de
    démarrage</link>. Dans ce cas, toutes les données doivent être dans
    l'encodage du serveur pour qu'un champ de type <type>text</type> puisse
    les contenir. Ceci est vérifié dans les constructions comprenant les
    assertions.
   </para>
  </sect2>

  <sect2 id="logicaldecoding-output-plugin-callbacks">
   <title>Callbacks de plugin de sortie</title>

   <para>
    Un plugin de sortie est notifié des changements arrivant au travers de
    différents callbacks qu'il doit fournir.
   </para>

   <para>
    Les transactions concurrentes sont décodées dans l'ordre dans lequel elles
    sont validées, et seuls les changements appartenant à une transaction
    spécifique sont décodés entre les callbacks <literal>begin</literal> et
    <literal>commit</literal>. Les transactions qui ont été explicitement ou
    implicitement annulées ne sont jamais décodées. Les savepoints validés
    sont inclus dans la transaction les contenant, dans l'ordre dans lequel
    ils ont été effectués dans la transaction. Une transaction qui est
    préparée pour une validation en deux phases avec <command>PREPARE
    TRANSACTION</command> sera aussi décodée si les callbacks du plugin de
    sortie nécessaires sont fournies pour le décodage. Il est possible que la
    transaction préparée courante en cours de décodage soit annulée en
    parallèle via une commande <command>ROLLBACK PREPARED</command>. Dans ce
    cas, le décodage logique de cette transaction sera lui-aussi annulé. Tous
    les changements d'une telle transaction seront ignorés une fois que
    l'annulation est détectée et que la fonction callback
    <function>prepare_cb</function> est appelée. De ce fait, même dans le cas
    d'une annulation en parallèle, suffisamment d'informations sont fournies
    au plugin de sortie pour gérer correctement un <command>ROLLBACK
    PREPARED</command> une fois qu'il est décodé.
   </para>

   <note>
    <para>
     Seules les transactions qui ont été synchronisées sur disque de manière
     sûre seront décodées. Cela peut amener à ce qu'un
     <command>COMMIT</command> ne soit pas immédiatement décodé lors d'un
     appel à <literal>pg_logical_slot_get_changes()</literal> juste après
     celui-ci quand <varname>synchronous_commit</varname> est positionné à
     <literal>off</literal>.
    </para>
   </note>

   <sect3 id="logicaldecoding-output-plugin-startup">
    <title>Callback de démarrage</title>

    <para>
     Le callback facultatif <function>startup_cb</function> est appelé chaque
     fois qu'un slot de réplication est créé ou qu'on lui demande de fournir
     les flux de changement, indépendamment du nombre de changements qui sont
     prêt à être fournis.

     <programlisting>typedef void (*LogicalDecodeStartupCB) (struct LogicalDecodingContext *ctx,
                                        OutputPluginOptions *options,
                                        bool is_init);</programlisting>

     Le paramètre <literal>is_init</literal> sera positioné à true quand le
     slot de réplication est créé, et à false sinon.
     <parameter>options</parameter> pointe vers une structure d'options que
     le plugin de sortie peut positionner&nbsp;:

     <programlisting>typedef struct OutputPluginOptions
{
    OutputPluginOutputType output_type;
    bool        receive_rewrites;
} OutputPluginOptions;</programlisting>

     <literal>output_type</literal> doit être positionné soit à
     <literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal> ou à
     <literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal>. Voir aussi <xref
     linkend="logicaldecoding-output-mode"/>. Si
     <literal>receive_rewrites</literal> vaut true, le plugin de sortie sera
     aussi appelé pour les modifications réalisées par des réécritures du
     fichier HEAP lors de certaines opérations DDL. Ceci est intéressant pour
     les plugins qui gèrent la réplication DDL mais ils nécessitent une
     gestion particulière.
    </para>

    <para>
     Le callback de démarrage devrait valider les options présentes dans
     <literal>ctx-&gt;output_plugin_options</literal>. Si le plugin de sortie
     a besoin d'avoir un état, il peut utiliser
     <literal>ctx-&gt;output_plugin_private</literal> pour le stocker.
    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-shutdown">
    <title>Callback d'arrêt</title>

    <para>
     Le callback facultatif <function>shutdown_cb</function> est appelé chaque
     fois qu'un slot de réplication anciennement actif n'est plus utilisé et
     peut être utilisé pour désallouer les ressources privées du plugin de
     sortie. Le slot n'est pas nécessairement supprimé, le flux est juste
     arrêté.

     <programlisting>typedef void (*LogicalDecodeShutdownCB) (struct LogicalDecodingContext *ctx);</programlisting>

    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-begin">
    <title>Callback de début de transaction</title>

    <para>
     Le callback obligatoire <function>begin_cb</function> est appelé chaque
     fois que le début d'une transaction validée a été décodé. Les
     transactions annulées et leur contenu ne sont pas décodés.

     <programlisting>typedef void (*LogicalDecodeBeginCB) (struct LogicalDecodingContext *ctx, ReorderBufferTXN *txn);</programlisting>

     Le paramètre <parameter>txn</parameter> contient des métadonnées sur la
     transaction, comme l'heure à laquelle elle a été validée et son XID.
    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-commit">
    <title>Callback de fin de transaction</title>

    <para>
     Le callback obligatoire <function>commit_cb</function> est appelé chaque
     fois qu'une transaction validée a été décodée. Le callback
     <function>change_cb</function> aura été appelé avant cela pour chacune
     des lignes modifiées, s'il y en a eu.

     <programlisting>typedef void (*LogicalDecodeCommitCB) (struct LogicalDecodingContext *ctx,
                                       ReorderBufferTXN *txn,
                                       XLogRecPtr commit_lsn);</programlisting>
    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-change">
    <title>Callback de modification</title>

    <para>
     Le callback obligatoire <function>change_cb</function> est appelé pour
     chacune des modifications de ligne au sein d'une transaction, qu'il
     s'agisse d'un <command>INSERT</command>, <command>UPDATE</command> ou
     <command>DELETE</command>. Même si la commande d'origine a modifié
     plusieurs ligne en une seule instruction, le callback sera appelé pour
     chaque ligne individuellement. Le callback
     <function>change_cb</function> pourrait accéder aux tables systèmes et
     utilisateurs pour aider au traitement en sortie des détails de
     modification de la ligne. Dans le cas du décodage d'une transaction
     préparée (mais pas encore validée) ou du décodage d'une transaction non
     validée, ce callback de modification pourrait aussi renvoyer une erreur
     à cause de l'annulation simultanée de cette même transaction. Dans ce
     cas, le décodage logique de cette transaction annulée est arrêté
     proprement.

     <programlisting>typedef void (*LogicalDecodeChangeCB) (struct LogicalDecodingContext *ctx,
                                       ReorderBufferTXN *txn,
                                       Relation relation,
                                       ReorderBufferChange *change);</programlisting>

     Les paramètres <parameter>ctx</parameter> et <parameter>txn</parameter>
     ont le même contenu que pour les callbacks <function>begin_cb</function>
     et <function>commit_cb</function>, mais en plus le descripteur de
     relation <parameter>relation</parameter> pointe vers la relation à
     laquelle appartient la ligne et une structure
     <parameter>change</parameter> décrivant les modifications de la ligne y est
     passée.
    </para>

    <note>
     <para>
      Seuls les changements dans les tables définies par les utilisateurs qui
      sont journalisées (voir <xref linkend="sql-createtable-unlogged"/>) et
      non temporaires (voir <xref linkend="sql-createtable-temporary"/>)
      peuvent être extraits avec le décodage logique.
     </para>
    </note>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-truncate">
    <title>Callback Truncate</title>

    <para>

     La fonction callback <function>truncate_cb</function> est appelée pour la
     commande <command>TRUNCATE</command>.

     <programlisting>typedef void (*LogicalDecodeTruncateCB) (struct LogicalDecodingContext *ctx,
                                         ReorderBufferTXN *txn,
                                         int nrelations,
                                         Relation relations[],
                                         ReorderBufferChange *change);</programlisting>

     Les paramètres sont identiques à ceux du callback
     <function>change_cb</function>. Néanmoins, comme les actions du
     <command>TRUNCATE</command> sur les tables liées par clés étrangères
     doivent être exécutées ensemble, ce callback reçoit un tableau de
     relations au lieu d'une seule relation. Voir la description de
     l'instruction <xref linkend="sql-truncate"/> pour les détails.
    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-filter-origin">
    <title>Fonction de filtre sur l'origine</title>

    <para>
     La fonction optionnelle <function>filter_by_origin_cb</function> est
     appelée pour déterminer si les données rejouées à partir de
     <parameter>origin_id</parameter> ont un intérêt pour le plugin de
     sortie.

     <programlisting>typedef bool (*LogicalDecodeFilterByOriginCB) (
    struct LogicalDecodingContext *ctx,
    RepNodeId origin_id
);</programlisting>

     Le paramètre <parameter>ctx</parameter> a le même contenu que pour les
     autres fonctions. Aucune information n'est disponible à part l'origine. Pour
     signaler que les changements provenant du nœud sont hors de propos, elle
     renvoie true, ce qui permet de les filtrer. Elle renvoie false dans les
     autres cas. Les autres fonctions ne seront pas appelées pour les
     transactions et changements qui ont été filtrés.
    </para>

    <para>
     Ceci est utile pour implémenter des solutions de réplication en cascade
     ou des solutions de réplication multi-directionnelles. Filtrer par
     rapport à l'origine perment d'empêcher la réplication dans les deux
     sens des mêmes modifications dans ce type de configuration. Quand les
     transactions et les modifications contiennent aussi des informations sur
     l'origine, le filtre via cette fonction est beaucoup plus efficace.
    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-message">
    <title>Fonctions personnalisées de message générique</title>

    <para>
     La fonction (callback) <function>message_cb</function> est appelée quand
     un message de décodage logique a été décodé.

     <programlisting>typedef void (*LogicalDecodeMessageCB) (
    struct LogicalDecodingContext *,
    ReorderBufferTXN *txn,
    XLogRecPtr message_lsn,
    bool transactional,
    const char *prefix,
    Size message_size,
    const char *message
);</programlisting>

     Le paramètre <parameter>txn</parameter> contient des méta-informations
     sur la transaction, comme l'horodatage de la validation de la transaction
     et son identifiant (XID). Notez néanmoins qu'il peut être NULL
     quand le message n'est pas transactionnel et que le XID n'a pas encore
     été affecté dans la transaction qui a tracé le message. Le
     <parameter>lsn</parameter> a la position du message dans les WAL. Le
     paramètre <parameter>transactional</parameter> indique si le message a
     été envoyé de façon transactionnelle ou non. De façon similaire au
     callback de changement, dans le cas du décodage d'une transaction
     préparée (mais pas encore validée) ou du décodage d'une transaction non
     validée, ce callback de message pourrait renvoyer une erreur en cas
     d'annulation simultanée de cette même transaction. Dans ce cas, le
     décodage logique de cette transaction annulée est stoppé proprement. Le
     paramètre <parameter>prefix</parameter> est un préfixe arbitraire
     terminé par un caractère nul qui peut être utilisé pour identifier les
     messages intéressants pour le plugin courant. Et enfin, le paramètre
     <parameter>message</parameter> contient le message réel de taille
     <parameter>message_size</parameter>.
    </para>

    <para>
     Une attention particulière doit être portée à l'unicité du préfixe que le
     plugin de sortie trouve intéressant. Utiliser le nom de l'extension ou
     du plugin de sortie est souvent un bon choix.
    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-filter-prepare">
    <title>Fonction de filtre du PREPARE</title>

    <para>
     La fonction callback facultative <function>filter_prepare_cb</function>
     est appelée pour déterminer si les données qui font partie de la
     transaction de validation en deux phases en cours doivent être
     considérées pour le décoage à cette étape préparatoire ou plus tard
     comme une transaction standard en une phase au moment du <command>COMMIT
     PREPARED</command>. Pour signaler que le décodage doit être ignoré,
     renvoyez <literal>true</literal>&nbsp;; <literal>false</literal> dans le
     cas contraire. Quand la fonction callback est définie,
     <literal>false</literal> est supposé (autrement dit, il n'y a pas de
     filtrage et toutes les transactions utilisant la validation en deux phases
     sont décodées aussi en deux phases).

     <programlisting>typedef bool (*LogicalDecodeFilterPrepareCB) (struct LogicalDecodingContext *ctx,
                                              TransactionId xid,
                                              const char *gid);</programlisting>

     Le paramètre <parameter>ctx</parameter> a le même contenu que pour les
     autres fonctions callbacks. Les paramètres <parameter>xid</parameter> et
     <parameter>gid</parameter> fournissent deux façons différentes
     d'identifier la transaction. La commande <command>COMMIT
     PREPARED</command> ou <command>ROLLBACK PREPARED</command> ultérieure
     intègre les identifiants, autorisant au plugin de sortie le choix de
     celui à utiliser.
    </para>

    <para>
     La fonction callback pourrait être appelée plusieurs fois par transaction
     pour décoder, et doit fournir la même réponse statique pour une paire
     donnée de <parameter>xid</parameter> et de <parameter>gid</parameter> à
     chaque fois qu'elle est appelée.
    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-begin-prepare">
    <title>Fonction de préparation de début de la transaction</title>

    <para>
     La fonction callback requise <function>begin_prepare_cb</function> est
     appelée à chaque fois que le début d'une transaction préparée a été
     décodée. Le champ <parameter>gid</parameter>, qui fait partie du
     paramètre <parameter>txn</parameter>, peut être utilisé dans cette
     fonction callback pour vérifier si le plugin a déjà reçu cette commande
     <command>PREPARE</command>, auquel cas elle peut renvoyer une erreur ou
     ignorer les changements restants de la transaction.

     <programlisting>typedef void (*LogicalDecodeBeginPrepareCB) (struct LogicalDecodingContext *ctx,
                                             ReorderBufferTXN *txn);</programlisting>
    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-prepare">
    <title>Fonction de transaction préparée</title>

    <para>
     La fonction callback requise <function>prepare_cb</function> est appelée
     à chaque fois qu'une transaction préparée pour une validation en deux
     pahses a été décodée. La fonction callback
     <function>change_cb</function> sera appelée avant celle-ci pour toutes
     les lignes modifiées, à condition que des lignes aient été modifiées. Le
     champ <parameter>gid</parameter>, qui fait partie du paramètre
     <parameter>txn</parameter>, peut être utilisé dans cette fonction
     callback.

     <programlisting>typedef void (*LogicalDecodePrepareCB) (struct LogicalDecodingContext *ctx,
                                        ReorderBufferTXN *txn,
                                        XLogRecPtr prepare_lsn);</programlisting>
    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-commit-prepared">
    <title>Fonction pour le COMMIT PREPARED d'une transaction</title>

    <para>
     La fonction callback requise <function>commit_prepared_cb</function> est
     appelée quand une commande <command>COMMIT PREPARED</command> d'une
     transaction a été décodée. Le champ <parameter>gid</parameter>, qui fait
     partie du paramètre <parameter>txn</parameter>, peut être utilisé dans
     cette fonction callback.

     <programlisting>typedef void (*LogicalDecodeCommitPreparedCB) (struct LogicalDecodingContext *ctx,
                                               ReorderBufferTXN *txn,
                                               XLogRecPtr commit_lsn);</programlisting>
    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-rollback-prepared">
    <title>Fonction d'annulation de transaction préparée</title>

    <para>
     La fonction callback requise <function>rollback_prepared_cb</function>
     est appelée à chaque fois qu'une transaction <command>ROLLBACK
     PREPARED</command> a été décodée. Le champ <parameter>gid</parameter>,
     qui fait partie du paramètre <parameter>txn</parameter>, peut être
     utilisé dans cette fonction callback. Les paramètres
     <parameter>prepare_end_lsn</parameter> et
     <parameter>prepare_time</parameter> peuvent être utilisés pour vérifier
     si le plugin a reça la commande <command>PREPARE TRANSACTION</command>
     auquel cas il peut appliquer l'annulation. Sinon, il peut ignorer
     l'opération d'annulation. Le paramètre <parameter>gid</parameter> seul
     n'est pas suffisant parce que le nœud en amont peut avoir une
     transaction préparée avec le même identifiant.

     <programlisting>typedef void (*LogicalDecodeRollbackPreparedCB) (struct LogicalDecodingContext *ctx,
                                                 ReorderBufferTXN *txn,
                                                 XLogRecPtr prepare_end_lsn,
                                                 TimestampTz prepare_time);</programlisting>
    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-stream-start">
    <title>Fonction de début de flux</title>

    <para>
     La fonction callback <function>stream_start_cb</function> est appelée à
     l'ouverture d'un bloc de changements en flux à partir d'une transaction
     en cours.

     <programlisting>typedef void (*LogicalDecodeStreamStartCB) (struct LogicalDecodingContext *ctx,
                                            ReorderBufferTXN *txn);</programlisting>
    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-stream-stop">
    <title>Fonction d'arrêt de flux</title>

    <para>
     La fonction callback <function>stream_stop_cb</function> est appelée lors
     de la fermeture d'un bloc de changements en flux provenant d'une
     transaction en cours.

     <programlisting>typedef void (*LogicalDecodeStreamStopCB) (struct LogicalDecodingContext *ctx,
                                           ReorderBufferTXN *txn);</programlisting>
    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-stream-abort">
    <title>Fonction d'annulation du flux</title>

    <para>
     La fonction callback <function>stream_abort_cb</function> est appelée lors
     de l'annulation d'une transaction en flux précédente.

     <programlisting>typedef void (*LogicalDecodeStreamAbortCB) (struct LogicalDecodingContext *ctx,
                                            ReorderBufferTXN *txn,
                                            XLogRecPtr abort_lsn);</programlisting>
    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-stream-prepare">
    <title>Fonction de préparation du flux</title>

    <para>
     La fonction callback <function>stream_prepare_cb</function> est appelée
     pour préparer une transaction en flux précédente pour faire partie d'une
     validation en deux phases.

     <programlisting>typedef void (*LogicalDecodeStreamPrepareCB) (struct LogicalDecodingContext *ctx,
                                              ReorderBufferTXN *txn,
                                              XLogRecPtr prepare_lsn);</programlisting>
    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-stream-commit">
    <title>Fonction de validation d'un flux</title>

    <para>
     La fonction callback <function>stream_commit_cb</function> est appelée
     pour valider une transaction en flux précédente.

     <programlisting>typedef void (*LogicalDecodeStreamCommitCB) (struct LogicalDecodingContext *ctx,
                                             ReorderBufferTXN *txn,
                                             XLogRecPtr commit_lsn);</programlisting>
    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-stream-change">
    <title>Fonction de changement du flux</title>

    <para>
     La fonction callback <function>stream_change_cb</function> est appelée
     pour un changement dans un bloc de changements de flux (démarqué par des
     appels à <function>stream_start_cb</function> et
     <function>stream_stop_cb</function>). Les modifications réelles ne sont
     pas affichées car la transaction peut annuler plus tard et que nous ne
     décodons par les changements pour les transactions annulées.

     <programlisting>typedef void (*LogicalDecodeStreamChangeCB) (struct LogicalDecodingContext *ctx,
                                             ReorderBufferTXN *txn,
                                             Relation relation,
                                             ReorderBufferChange *change);</programlisting>
    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-stream-message">
    <title>Fonction de message du flux</title>

    <para>
     La fonction callback <function>stream_message_cb</function> est appelée
     lors de l'envoi d'un message générique dans un bloc de changements en
     flux (démarqué par des appels à <function>stream_start_cb</function> et
     <function>stream_stop_cb</function>). Le contenu du message pour des
     messages transactionnels n'est pas affiché car la transaction peut
     s'annuler plus tard et que nous ne décodons pas les changements pour les
     transactions annulées.

     <programlisting>typedef void (*LogicalDecodeStreamMessageCB) (struct LogicalDecodingContext *ctx,
                                              ReorderBufferTXN *txn,
                                              XLogRecPtr message_lsn,
                                              bool transactional,
                                              const char *prefix,
                                              Size message_size,
                                              const char *message);</programlisting>
    </para>
   </sect3>

   <sect3 id="logicaldecoding-output-plugin-stream-truncate">
    <title>Fonction troncage du flux</title>

    <para>
     La fonction callback <function>stream_truncate_cb</function> est appelée pour une
     commande
     <command>TRUNCATE</command> dans un bloc de changements en flux
     (démarqué par des appels à <function>stream_start_cb</function> et
     <function>stream_stop_cb</function>).

     <programlisting>typedef void (*LogicalDecodeStreamTruncateCB) (struct LogicalDecodingContext *ctx,
                                               ReorderBufferTXN *txn,
                                               int nrelations,
                                               Relation relations[],
                                               ReorderBufferChange *change);</programlisting>

     Les paramètres sont analogues à ceux de la fonction callback
     <function>stream_change_cb</function>. Néanmoins, comme les actions de
     la commande <command>TRUNCATE</command> sur des tables connectées par
     des clés étrangères doivent s'exécuter ensemble, cette fonction callback
     reçoit un tableau de relations au lieu d'une seule relation. Voir la
     description de l'instruction <xref linkend="sql-truncate"/> pour les
     détails.
    </para>
   </sect3>
  </sect2>

  <sect2 id="logicaldecoding-output-plugin-output">
   <title>Fonction pour produire une sortie</title>

   <para>
    Pour pouvoir produire une sortie, les plugins de sortie peuvent écrire des
    données dans le tampon de sortie <literal>StringInfo</literal> dans
    <literal>ctx-&gt;out</literal> dans les callbacks
    <function>begin_cb</function>, <function>commit_cb</function> ou
    <function>change_cb</function>. Avant d'écrire dans le tampon de sortie,
    <function>OutputPluginWrite(ctx, last_write)</function> doit avoir été
    appelé pour effectuer l'écriture. <parameter>last_write</parameter>
    indique si une écriture particulière était la dernière écriture du
    callback.
   </para>

   <para>
    L'exemple suivant montre comment sortir des données pour le consommateur
    d'un plugin de sortie&nbsp;:

    <programlisting>OutputPluginPrepareWrite(ctx, true);
appendStringInfo(ctx->out, "BEGIN %u", txn->xid);
OutputPluginWrite(ctx, true);</programlisting>
   </para>
  </sect2>
 </sect1>

 <sect1 id="logicaldecoding-writer">
  <title>Écrivains de sortie de décodage logique</title>

  <para>
   Il est possible d'ajouter d'autres méthodes de sortie pour le décodage
   logique. Pour plus de détails, voir
   <filename>src/backend/replication/logical/logicalfuncs.c</filename>.
   Principalement, trois fonctions doivent être fournies&nbsp;: une pour lire
   les journaux de transactions, une pour préparer l'écriture de sortie et
   une pour préparer la sortie (voir <xref
   linkend="logicaldecoding-output-plugin-output"/>).
  </para>
 </sect1>

 <sect1 id="logicaldecoding-synchronous">
  <title>Support de la réplication synchrone pour le décodage logique</title>

  <sect2>
   <title>Overview</title>

   <para>
    Le décodage logique peut être utilisé pour construire des solutions de
    <link linkend="synchronous-replication">réplication synchrone</link> avec
    la même interface utilisateur que la réplication synchrone de la <link
    linkend="streaming-replication">réplication par flux</link>. Pour cela,
    l'interface de réplication en flux (voir <xref
    linkend="logicaldecoding-walsender"/>) doit être utilisée pour renvoyer
    par flux les données. Les clients doivent envoyer des messages
    <literal>Standby status update (F)</literal> (voir <xref
    linkend="protocol-replication"/>), tout comme le font les clients de
    réplication par flux.
   </para>

   <note>
    <para>
     Un réplicat synchrone recevant des changements grâce au décodage logique
     fonctionnera dans le cadre d'une seule base de données. Puisque, à
     l'opposé de cela, <parameter>synchronous_standby_names</parameter> est
     actuellement commun à toutes les instances, cela signifie que cette
     technique ne marchera pas convenablement si plus d'une base de
     l'instance est utilisée activement.
    </para>
   </note>
  </sect2>

  <sect2 id="logicaldecoding-synchronous-caveats">
   <title>Mises en garde</title>

   <para>
    Dans une configuration de réplication synchrone, un verrou deadlock peut
    survenir si la transaction a verrouillé les tables du catalogue de façon
    exclusive. Voir <xref linkend="logicaldecoding-capabilities"/> pour des
    informations sur les tables du catalogue utilisateur catalog tables. Ceci
    survient parce que le décodage logique des transactions peut verrouiller
    les tables du catalogue pour y accéder. Pour éviter ceci, les
    utilisateurs doivent s'empêcher de prendre un verrou exclusif sur les
    tables du catalogue. Ceci peut arriver dans les cas suivants&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       Lancer une commande <command>LOCK</command> exclusive sur
       <structname>pg_class</structname> dans une transaction&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       Exécuter une commande <command>CLUSTER</command> sur
       <structname>pg_class</structname> dans une transaction&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       <command>PREPARE TRANSACTION</command> après une commande
       <command>LOCK</command> sur <structname>pg_class</structname> et
       autoriser le décodage logiques des transactions en deux phases&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       <command>PREPARE TRANSACTION</command> après une commande
       <command>CLUSTER</command> sur <structname>pg_trigger</structname> et
       autoriser le décodage logiques des transactions en deux phases. Ceci
       amènera un deadlock seulement quand la table publiée a un trigger&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       Exécuter une commande <command>TRUNCATE</command> sur une table du
       catalogue dans une transaction.
      </para>
     </listitem>
    </itemizedlist>

    Notez que ces commandes pouvant causer des deadlocks s'appliquent non
    seulement aux tables du catalogue système indiquées explicitement mais
    aussi aux autres tables du catalogue utilisateur.
   </para>
  </sect2>
 </sect1>

 <sect1 id="logicaldecoding-streaming">
  <title>Envoi en flux de grosses transactions pour le décodage logique</title>

  <para>
   Les fonctions callbacks simples pour le plugin de sortie
   (soit <function>begin_cb</function>, <function>change_cb</function>,
   <function>commit_cb</function> et <function>message_cb</function>) sont
   uniquement appelées quand la transaction se termine avec un COMMIT. Les
   changements sont toujours décodés à partir des journaux de transactions,
   mais sont seulement passés au plugin de sortie à la validation de la
   transaction (et ignorés si la transaction est annulée).
  </para>

  <para>
   Ceci signifie que, bien que le décodage survient de façon incrémental et
   pourrait déborder sur disque pour que l'utilisation de la mémoire reste
   sous contrôle, tous les changements décodés seront transmis au moment de
   la validation de la transaction (ou plus précisément quand le COMMIT sera
   décodé du journal de transaction). Suivant la taille de la transaction et
   la bande passante du réseau, le temps de transfert pourrait augmenter de
   façon significative le délai du rejeu.
  </para>

  <para>
   Pour réduire le délai de rejeu causé par les grosses transactions, un
   plugin de sortie peut fournir des fonctions callback supplémentaires pour
   accepter un flux incrémental de transactions en cours. Il existe plusieurs
   fonctions callback requises pour un flux
   (<function>stream_start_cb</function>,
   <function>stream_stop_cb</function>, <function>stream_abort_cb</function>,
   <function>stream_commit_cb</function> et
   <function>stream_change_cb</function>) et deux fonctions callback
   optionnelles (<function>stream_message_cb</function> et
   <function>stream_truncate_cb</function>).
  </para>

  <para>
   Lors du flux d'une transaction en cours, les changements (et les messages)
   sont envoyés en blocs démarqués par les fonctions
   <function>stream_start_cb</function> et
   <function>stream_stop_cb</function>. Une fois que tous les changements
   décodés ont été transmis, la transaction peut être validée en utilisant la
   fonction callback <function>stream_commit_cb</function>(ou possiblement
   annulée en utilisant la fonction callback
   <function>stream_abort_cb</function>). Si les validations en deux phases
   sont supportées, la transaction peut être préparée en utilisant la
   fonction callback <function>stream_prepare_cb</function>, la commande de
   validation <command>COMMIT PREPARED</command> en utilisant la fonction
   callback <function>commit_prepared_cb</function>, et la commande
   d'annulation en utilisant la fonction callback
   <function>rollback_prepared_cb</function>.
  </para>

  <para>
   Une séquence d'exemple d'appels de callbacks pour un flux sur une transaction
   pourrait ressembler à ceci&nbsp;:

   <programlisting>stream_start_cb(...);   &lt;-- début du premier bloc de changements
  stream_change_cb(...);
  stream_change_cb(...);
  stream_message_cb(...);
  stream_change_cb(...);
  ...
  stream_change_cb(...);
stream_stop_cb(...);    &lt;-- fin du premier bloc de changements

stream_start_cb(...);   &lt;-- début du deuxième bloc de changements
  stream_change_cb(...);
  stream_change_cb(...);
  stream_change_cb(...);
  ...
  stream_message_cb(...);
  stream_change_cb(...);
stream_stop_cb(...);    &lt;-- fin du deuxième bloc de changements


[a. when using normal commit]
stream_commit_cb(...);  &lt;-- validation de la transaction en flux

[b. when using two-phase commit]
stream_prepare_cb(...);   &lt;-- prépare la transaction en flux
commit_prepared_cb(...);  &lt;-- commit de la transaction préparée</programlisting>
  </para>

  <para>
   La séquence réelle d'appels de fonctions callback pourrait être plus
   compliquée bien sûr. Il pourrait y avoir des blocs pour plusieurs
   transactions en flux, certaines des transactions pourraient être annulées,
   etc.
  </para>

  <para>
   De façon similaire au comportement de débordement sur disque, le flux est
   déclenché quand la quantité totale de changements décodés du WAL
   (pour toutes les transactions en cours) dépasse la limite définie par le
   paramètre <varname>logical_decoding_work_mem</varname>. À ce moment-là, la
   transaction de haut niveau la plus large (mesuré par la quantité de
   mémoire actuellement utilisée pour les changements décodés) est
   sélectionnée et envoyée en flux. Néanmoins, dans certains cas, nous avons
   encore besoin de déborder sur disque même si le flux est activé parce que
   nous dépassons la limite de mémoire, mais nous n'avons pas encore décodé
   la ligne complète, par exemple seulement le décodage de l'insertion d'un
   TOAST, mais pas celle de la table principale.
  </para>

  <para>
   Même lors de flux de grosses transactions, les changements sont toujours
   appliqués dans l'ordre des validations, préservant les mêmes garanties que
   le mode sans flux.
  </para>
 </sect1>

 <sect1 id="logicaldecoding-two-phase-commits">
  <title>Support du Two-phase commit pour le décodage logique</title>

  <para>
   Avec les fonctions callbacks simples pour le plugin de sortie
   (donc <function>begin_cb</function>, <function>change_cb</function>,
   <function>commit_cb</function> et <function>message_cb</function>), les
   commandes du two-phase commit comme <command>PREPARE
   TRANSACTION</command>, <command>COMMIT PREPARED</command> et
   <command>ROLLBACK PREPARED</command> ne sont pas décodées. Alors que
   <command>PREPARE TRANSACTION</command> est ignoré, <command>COMMIT
   PREPARED</command> est décodé comme un <command>COMMIT</command> et
   <command>ROLLBACK PREPARED</command> est décodé comme un
   <command>ROLLBACK</command>.
  </para>

  <para>
   Pour accepter le flux des commandes de la validation en deux phases, un
   plugin de sortie doit fournir des fonctions callbacks supplémentaires. Il
   existe plusieurs fonctions callbacks requises pour le two-phase commit
   (<function>begin_prepare_cb</function>, <function>prepare_cb</function>,
   <function>commit_prepared_cb</function>,
   <function>rollback_prepared_cb</function> et
   <function>stream_prepare_cb</function>) et une fonction callback
   facultative(<function>filter_prepare_cb</function>).
  </para>

  <para>
   Si les fonctions callbacks du plugin de sortie sont fournies pour le
   décodage des commandes de validation en deux phases, alors, sur un
   <command>PREPARE TRANSACTION</command>, les changements de cette
   transaction sont décodés, passés au plugin de sortie, et la fonction
   callback <function>prepare_cb</function> est appelée. Ceci change de la
   configuration basique de décodage où les changements sont seulement passés
   au plugin de sortie quand une transaction est validée. Le début d'une
   transaction préparée est indiqué par la fonction callback
   <function>begin_prepare_cb</function>.
  </para>

  <para>
   Quand une transaction préparée est annulée en utilisant <command>ROLLBACK
   PREPARED</command>, alors la fonction callback
   <function>rollback_prepared_cb</function> est appelée, et quand la
   transaction préparée est validée en utilisant <command>COMMIT
   PREPARED</command>, alors la fonction callback
   <function>commit_prepared_cb</function> est appelée.
  </para>

  <para>
   En option, le plugin de sortie peut définir des règles de filtres via
   <function>filter_prepare_cb</function> pour décoder uniquement les
   transactions en deux phases. Ceci peut se faire avec la correspondance de
   motif sur <parameter>gid</parameter> ou via des recherches en utilisant
   <parameter>xid</parameter>.
  </para>

  <para>
   Les utilisateurs qui veulent décoder les transactions préparées doivent
   faire attention aux points mentionnés ci-dessous&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Si la transaction préparée a verrouillé des tables systèmes en mode
      exclusif, alors le décodage de la préparation peut bloquer jusqu'à la
      validation de la transaction principale.
     </para>
    </listitem>

    <listitem>
     <para>
      La solution de réplication logique qui construit une validation en deux
      phases distribuée en utilisant cette fonctionnalité peut provoquer un
      deadlock si la transaction préparée a verrouillé en exclusif des tables
      systèmes. Pour éviter ceci, les utilisateurs doivent éviter d'avoir des
      verrous sur des tables systèmes (comme une commande
      <command>LOCK</command> explicite) dans de telles transactions.
      Voir <xref linkend="logicaldecoding-synchronous-caveats"/> pour les
      détails.
     </para>
    </listitem>
   </itemizedlist>
  </para>
 </sect1>
</chapter>
