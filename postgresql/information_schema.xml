<?xml version="1.0" encoding="UTF-8"?>
<chapter id="information-schema">
 <title>Schéma d'information</title>

 <indexterm zone="information-schema">
  <primary>schéma d'information</primary>
 </indexterm>

 <para>
  Le schéma d'information consiste en un ensemble de vues contenant des
  informations sur les objets définis dans la base de données courante. Le
  schéma d'information est défini dans le standard SQL et, donc
  supposé portable et stable &mdash; contrairement aux catalogues système qui
  sont spécifiques à <productname>PostgreSQL</productname> et modelés suivant
  l'implantation. Néanmoins, les vues du schéma d'information ne contiennent
  pas d'informations sur les fonctionnalités spécifiques à
  <productname>PostgreSQL</productname>&nbsp;; pour cela, on utilise
  catalogues système et autres vues spécifiques à
  <productname>PostgreSQL</productname>.
 </para>

 <note>
  <para>
   En demandant des informations sur les contraintes dans la base de
   données, il est possible qu'une requête conforme au standard
   s'attendant à ne récupérer qu'une ligne en récupère en fait plusieurs.
   Ceci est dû au fait que le standard SQL requiert que les noms des
   contraintes soient uniques dans un même schéma mais
   <productname>PostgreSQL</productname> ne force pas cette
   restriction. Les noms de contraintes créés automatiquement par
   <productname>PostgreSQL</productname> évitent les doublons dans le
   le même schéma mais les utilisateurs peuvent spécifier explicitement
   des noms existant déjà.
  </para>

  <para>
   Ce problème peut apparaître lors de la consultation de vues du
   schéma d'informations, comme par exemple
   <literal>check_constraint_routine_usage</literal>,
   <literal>check_constraints</literal>,
   <literal>domain_constraints</literal> et
   <literal>referential_constraints</literal>. Certaines autres
   vues ont des problèmes similaires mais contiennent le nom de la table
   pour aider à distinguer les lignes dupliquées, par exemple
   <literal>constraint_column_usage</literal>,
   <literal>constraint_table_usage</literal>,
   <literal>table_constraints</literal>.
  </para>
 </note>


 <sect1 id="infoschema-schema">
  <title>Le schéma</title>

  <para>
   Le schéma d'information est lui-même un schéma nommé
   <literal>information_schema</literal>. Ce schéma existe automatiquement dans
   toutes les bases de données. Le propriétaire de ce schéma est l'utilisateur
   initial du cluster. Il a naturellement
   tous les droits sur ce schéma, dont la possibilité de le supprimer
   (mais l'espace gagné ainsi sera minuscule).
  </para>

  <para>
   Par défaut, le schéma d'information n'est pas dans le chemin de recherche
   des schémas. Il est donc nécessaire d'accéder à tous les objets qu'il contient
   via des noms qualifiés. Comme les noms de certains objets du schéma
   d'information sont des noms génériques pouvant survenir dans les applications
   utilisateur, il convient d'être prudent avant de placer le schéma
   d'information dans le chemin.
  </para>
 </sect1>

 <sect1 id="infoschema-datatypes">
  <title>Types de données</title>

  <para>
   Les colonnes des vues du schéma d'information utilisent des types de
   données spéciaux, définis dans le schéma d'information. Ils sont définis
   comme des domaines simples sur des types internes. Vous ne devriez pas
   utiliser ces types en dehors du schéma d'information,
   mais les applications doivent pouvoir les utiliser si des sélections sont
   faites dans le schéma d'information.
  </para>

  <para>
   Ces types sont&nbsp;:

   <variablelist>
    <varlistentry>
     <term><type>cardinal_number</type></term>
     <listitem>
      <para>
       Un entier non négatif.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>character_data</type></term>
     <listitem>
      <para>
       Une chaîne de caractères (sans longueur maximale indiquée).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>sql_identifier</type></term>
     <listitem>
      <para>
       Une chaîne de caractères. Elle est utilisée pour les identifiants SQL,
       le type de données <type>character_data</type> est utilisé pour tout
       autre type de données texte.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>time_stamp</type></term>
     <listitem>
      <para>
       Un domaine au-dessus du type <type>timestamp with time zone</type>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>yes_or_no</type></term>
     <listitem>
      <para>
       Un domaine dont le type correspond à une chaîne de caractères, qui
       contient soit <literal>YES</literal> soit <literal>NO</literal>. C'est
       utilisé pour représenter des données booléennes (true/false) dans le
       schéma d'informations. (Le schéma d'informations était inventé avant
       l'ajout du type <type>boolean</type> dans le standard SQL, donc cette
       convention est nécessaire pour conserver la compatibilité avec le
       schéma d'informations.)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Chaque colonne du schéma d'information est de l'un des ces cinq types.
  </para>
 </sect1>

 <sect1 id="infoschema-information-schema-catalog-name">
  <title><literal>information_schema_catalog_name</literal></title>

  <para>
   <literal>information_schema_catalog_name</literal> est une table qui
   contient en permanence une ligne et une colonne contenant le nom de la base
   de données courante (catalogue courant dans la terminologie SQL).
  </para>

  <table>
   <title>Colonnes de <structname>information_schema_catalog_name</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>catalog_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant ce schéma d'informations
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-administrable-role-authorizations">
  <title><literal>administrable_role_authorizations</literal></title>

  <para>
   La vue <literal>administrable_role_authorizations</literal>
   identifie tous les rôles pour lesquelles l'utilisateur courant possède l'option
   ADMIN.
  </para>

  <table>
   <title>Colonnes de <structname>administrable_role_authorizations</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantee</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle pour lequel cette appartenance de rôle a été donnée
        (peut être l'utilisateur courant ou un rôle différent dans le cas
        d'appartenances de rôles imbriquées).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>role_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom d'un rôle
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>role_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Toujours <literal>YES</literal>
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-applicable-roles">
  <title><literal>applicable_roles</literal></title>

  <para>
   La vue <literal>applicable_roles</literal> identifie tous les rôles dont
   l'utilisateur courant peut utiliser les droits. Cela signifie qu'il y a
   certaines chaînes de donnation des droits de l'utilisateur courant au
   rôle en question. L'utilisateur lui-même est un rôle applicable.
   L'ensemble de rôles applicables est habituellement utilisé pour la
   vérification des droits.
   <indexterm><primary>applicable role</primary></indexterm>
   <indexterm><primary>role</primary><secondary>applicable</secondary></indexterm>
  </para>

  <table>
   <title>Colonnes de <structname>applicable_roles</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantee</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle à qui cette appartenance a été donnée (peut être
        l'utilisateur courant ou un rôle différent dans le cas d'appartenances
        de rôles imbriquées)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>role_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom d'un rôle
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_grantable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si le bénéficiaire a l'option ADMIN sur le rôle,
        <literal>NO</literal> dans le cas contraire
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-attributes">
  <title><literal>attributes</literal></title>

  <para>
   La vue <literal>attributes</literal> contient des informations sur les
   attributs des types de données composites définis dans la base.
   (La vue ne donne pas d'informations sur les colonnes de table,
   qui sont quelque fois appelées attributs dans le contexte de PostgreSQL.)
   Seuls ces attributs sont affichés plutôt que ceux auxquels l'utilisateur
   courant a accès (s'il est le propriétaire ou a des droits sur le type).
  </para>

  <table>
   <title>Colonnes de <structname>attributes</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base contenant le type de données (toujours la base
        courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant le type de données
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du type de données
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attribute_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de l'attribut
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ordinal_position</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Position de l'attribut dans le type de données (le décompte commence
        à 1)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attribute_default</structfield> <type>character_data</type>
       </para>
       <para>
        Expression par défaut de l'attribut
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_nullable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si l'attribut peut être NULL,
        <literal>NO</literal> dans le cas contraire.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>data_type</structfield> <type>character_data</type>
       </para>
       <para>
        Type de données de l'attribut s'il s'agit d'un type interne ou
        <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas, voir
        la vue <literal>element_types</literal>), sinon
        <literal>USER-DEFINED</literal> (dans ce cas, le type est identifié
        dans <literal>attribute_udt_name</literal> et les colonnes associées).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_maximum_length</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Si <literal>data_type</literal> identifie un caractère ou une chaîne
        de bits, la longueur maximale déclarée&nbsp;; NULL pour tous les autres
        types de données ou si aucune longueur maximale n'a été déclarée.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_octet_length</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Si <literal>data_type</literal> identifie un type caractère,
        la longueur maximale en octets (bytes) d'un datum&nbsp;; NULL pour tous
        les autres types de données. La longueur maximale en octets dépend de
        la longueur maximum déclarée en caractères (voir ci-dessus) et
        l'encodage du serveur.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible avec
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible avec
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible avec
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base contenant le collationnement de l'attribut
        (toujours la base de données courante), NULL s'il s'agit du
        collationnement par défaut ou si le type de données de l'attribut
        ne peut pas avoir de collationnement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant le collationnement de l'attribut, NULL s'il s'agit du
        collationnement par défaut ou si le type de données de l'attribut
        ne peut pas avoir de collationnement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du collationnement de l'attribut, NULL s'il s'agit du
        collationnement par défaut ou si le type de données de l'attribut
        ne peut pas avoir de collationnement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Si <literal>data_type</literal> identifie un type numérique, cette colonne
        contient la précision (déclarée ou implicite) du type pour cet attribut.
        La précision indique le nombre de chiffres significatifs. Elle peut être
        exprimée en décimal (base 10) ou en binaire (base 2) comme le précise la
        colonne <literal>numeric_precision_radix</literal>. Pour tous les autres
        types de données, cette colonne vaut NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_precision_radix</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Si <literal>data_type</literal> identifie un type numérique, cette colonne
        indique la base d'expression des colonnes <literal>numeric_precision</literal>
        et <literal>numeric_scale</literal>. La valeur est soit 2 soit 10. Pour
        tous les autres types de données, cette colonne est NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_scale</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Si <literal>data_type</literal> identifie un type numérique exact,
        cette colonne contient l'échelle (déclarée ou implicite) du type pour cet
        attribut. L'échelle indique le nombre de chiffres significatifs à droite
        du point décimal. Elle peut être exprimée en décimal (base 10) ou en
        binaire (base 2) comme le précise la colonne
        <literal>numeric_precision_radix</literal>. Pour tous les autres types
        de données, cette colonne est NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datetime_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Si <literal>data_type</literal> identifie une date, une heure, un
        horodatage ou un interval, cette colonne contient la précision en
        secondes (déclarée ou implicite) pour cet attribut, c'est-à-dire le
        nombre de chiffres décimaux suivant le point décimal de la valeur
        en secondes. Pour tous les autres types de données, cette colonne
        est NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>interval_type</structfield> <type>character_data</type>
       </para>
       <para>
        Si <literal>data_type</literal> identifie un type d'intervalle,
        cette colonne contient la spécification des champs que les intervalles
        incluent pour cet attribut, par exemple <literal>YEAR TO
         MONTH</literal>, <literal>DAY TO SECOND</literal>, etc. Si aucune
        restriction de champs n'est spécifiée (autrement dit, l'intervalle
        accepte tous les champs) et pour tous les autres types de données,
        ce champ est NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>interval_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname> (voir
        <literal>datetime_precision</literal> pour la précision en fraction
        des secondes des attributs du type d'intervalle)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attribute_udt_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base dans laquelle le type de données de l'attribut est défini (toujours
        la base courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attribute_udt_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma dans lequel le type de données de l'attribut est défini
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attribute_udt_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du type de données de l'attribut
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>scope_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>scope_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>scope_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>maximum_cardinality</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car les tableaux ont toujours une cardinalité maximale
        dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>dtd_identifier</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Un identifiant du descripteur du type de données de la colonne, unique
        parmi les descripteurs de types de données de la table. Ceci est
        principalement utile pour des jointures avec d'autres instances de tels
        identifiants. (Le format spécifique de l'identifiant n'est pas défini
        et il n'est pas garanti qu'il reste identique dans les versions futures.)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_derived_reference_attribute</structfield> <type>yes_or_no</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Voir aussi dans <xref linkend="infoschema-columns"/>, une vue structurée de
   façon similaire, pour plus d'informations sur certaines colonnes.
  </para>
 </sect1>

 <sect1 id="infoschema-character-sets">
  <title><literal>character_sets</literal></title>

  <para>
   La vue <literal>character_sets</literal> identifie les jeux de
   caractères disponibles pour la base de données courante. Comme
   PostgreSQL ne supporte pas plusieurs jeux de caractères dans une
   base de données, cette vue n'en affiche qu'une, celle qui correspond
   à l'encodage de la base de données.
  </para>

  <para>
   Les termes suivants sont utilisés dans le standard SQL&nbsp;:
   <variablelist>
    <varlistentry>
     <term>répertoire de caractères (<foreignphrase>character repertoire</foreignphrase></term>
     <listitem>
      <para>
       Un ensemble abstrait de caractères, par exemple
       <literal>UNICODE</literal>, <literal>UCS</literal> ou
       <literal>LATIN1</literal>. Non exposé en tant qu'objet SQL mais
       visible dans cette vue.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>forme d'encodage de caractères (<foreignphrase>character encoding form</foreignphrase>)</term>
     <listitem>
      <para>
       Un encodage d'un certain répertoire de caractères. La plupart
       des anciens répertoires de caractères utilisent seulement un
       encodage. Du coup, il n'y a pas de noms séparés pour eux (par
       exemple <literal>LATIN1</literal> est une forme d'encodage
       applicable au répertoire <literal>LATIN1</literal>). Par contre,
       Unicode dispose des formats d'encodage <literal>UTF8</literal>,
       <literal>UTF16</literal>, etc. (ils ne sont pas tous supportés
       par PostgreSQL). Les formes d'encodage ne sont pas exposés comme
       un objet SQL mais ils sont visibles dans cette vue.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>jeu de caractères (<foreignphrase>character set</foreignphrase>)</term>
     <listitem>
      <para>
       Un objet SQL nommé qui identifie un répertoire de caractères, un
       encodage de caractères et un collationnement par défaut. Un jeu
       de caractères prédéfini aura généralement le même nom qu'une
       forme d'encodage mais les utilisateurs peuvent définir d'autres
       noms. Par exemple, le jeu de caractères <literal>UTF8</literal>
       identifiera typiquement le répertoire des caractères
       <literal>UCS</literal>, la forme d'encodage <literal>UTF8</literal>
       et un collationnement par défaut.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Dans PostgreSQL, un <quote>encodage</quote> peut être vu comme un
   jeu de caractères ou une forme d'encodage des caractères. Ils auront
   le même nom et il n'y en a qu'un dans une base de données.
  </para>

  <table>
   <title>Colonnes de <structname>character_sets</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Les jeux de caractères ne sont pas actuellement implémentés
        comme des objets du schéma, donc cette colonne est NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Les jeux de caractères ne sont pas actuellement implémentés
        comme des objets du schéma, donc cette colonne est NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du jeu de caractères, mais affiche actuellement le nom
        de l'encodage de la base de données
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_repertoire</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Répertoire des caractères, affichant <literal>UCS</literal>
        si l'encodage est <literal>UTF8</literal>, et le nom de
        l'encodage sinon
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>form_of_use</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Forme d'encodage des caractères, identique à l'encodage de
        la base de données
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>default_collate_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant le collationnement par
        défaut (toujours la base de données courante si un collationnement
        est identifié)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>default_collate_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant le collationnement par défaut
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>default_collate_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du collationnement par défaut. Il est identifié comme le
        collationnement qui correspond aux paramètres
        <literal>COLLATE</literal> et <literal>CTYPE</literal> pour la
        base de données courante. S'il n'y a pas de collationnement, cette
        colonne, le schéma associé et les colonnes du catalogue sont NULL.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-check-constraint-routine-usage">
  <title><literal>check_constraint_routine_usage</literal></title>

  <para>
   La vue <literal>check_constraint_routine_usage</literal> identifie les
   routines (fonctions et procédures) utilisées par une contrainte de
   vérification. Seules sont présentées les routines qui appartiennent à un rôle
   couramment actif.
  </para>

  <table>
   <title>Colonnes de <structname>check_constraint_routine_usage</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base contenant la contrainte (toujours la base courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base contenant la fonction (toujours la base courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la fonction
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Le <quote>nom spécifique</quote> de la fonction. Voir <xref
        linkend="infoschema-routines"/> pour plus d'informations.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-check-constraints">
  <title><literal>check_constraints</literal></title>

  <para>
   La vue <literal>check_constraints</literal> contient toutes les contraintes
   de vérification définies sur une table ou un domaine, possédées
   par un rôle couramment actif (le propriétaire d'une table ou d'un domaine est
   le propriétaire de la contrainte).
  </para>

  <table>
   <title>Colonnes de <structname>check_constraints</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant la contrainte (toujours la base
        de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        L'expression de vérification de la contrainte
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-collations">
  <title><literal>collations</literal></title>

  <para>
   La vue <literal>collations</literal> contient les collationnements
   disponibles dans la base de données courante.
  </para>

  <table>
   <title>Colonnes de <structname>collations</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant le collationnement
        (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant le collationnement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du collationnement par défaut
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>pad_attribute</structfield> <type>character_data</type>
       </para>
       <para>
        Toujours <literal>NO PAD</literal> (l'alternative <literal>PAD
         SPACE</literal> n'est pas supportée par PostgreSQL.)
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-collation-character-set-applicab">
  <title><literal>collation_character_set_applicability</literal></title>

  <para>
   La vue <literal>collation_character_set_applicability</literal>
   identifie les jeux de caractères applicables aux collationnements
   disponibles. Avec PostgreSQL, il n'existe qu'un jeu de caractères
   par base de données (voir les explications dans <xref
   linkend="infoschema-character-sets"/>), donc cette vue ne fournit
   pas beaucoup d'informations utiles.
  </para>

  <table>
   <title>Colonnes de <structname>collation_character_set_applicability</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant le collationnement
        (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant le collationnement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du collationnement par défaut
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Les jeux de caractères ne sont pas actuellement implémentés
        comme des objets du schéma, donc cette colonne est NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Les jeux de caractères ne sont pas actuellement implémentés
        comme des objets du schéma, donc cette colonne est NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du jeu de caractères
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-column-usage">
  <title><literal>column_column_usage</literal></title>

  <para>
   La vue <literal>column_column_usage</literal> identifie toutes les colonnes
   générées qui dépendant d'une autre colonne de base dans la même table.
   Seuls les tables possédées par le rôle actuel sont incluses.

  </para>

  <table>
   <title>Colonnes de <structname>column_column_usage</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base contenant la table (toujours la base actuelle)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la table
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>column_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la colonne de base dont la colonne générée dépend
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>dependent_column</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la colonne générée
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-domain-usage">
  <title><literal>column_domain_usage</literal></title>

  <para>
   La vue <literal>column_domain_usage</literal> identifie toutes les colonnes
   (d'une table ou d'une vue) utilisant un domaine défini dans la base de
   données courante et possédé par un rôle couramment actif.
  </para>

  <table>
   <title>Colonnes de <structname>column_domain_usage</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>domain_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant le domaine (toujours la base de
        données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>domain_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant le domaine
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>domain_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du domaine
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant la table (toujours la base de
        données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la table
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>column_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la colonne
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-options">
  <title><literal>column_options</literal></title>

  <para>
   La vue <literal>column_options</literal> contient toutes les options
   définies pour les colonnes des tables étrangères de la base de données
   courante. Seules sont montrées les tables étrangères auxquelles l'utilisateur
   courant a accès (soit parce qu'il en est le propriétaire soit parce qu'il
   dispose de certains droits dessus)
  </para>

  <table>
   <title>Colonnes de <structname>column_options</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base contenant la table distante (toujours la base de
        données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la table distante
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table distante
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>column_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la colonne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>option_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de l'option
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>option_value</structfield> <type>character_data</type>
       </para>
       <para>
        Valeur de l'option
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-privileges">
  <title><literal>column_privileges</literal></title>

  <para>
   La vue <literal>column_privileges</literal> identifie tous les droits
   octroyés sur les colonnes à un rôle couramment actif ou par un rôle
   couramment actif. Il existe une ligne pour chaque combinaison colonne,
   donneur (<foreignphrase>grantor</foreignphrase>) et receveur
   (<foreignphrase>grantee</foreignphrase>).
  </para>

  <para>
   Si un droit a été donné sur une table entière, il s'affichera dans cette vue
   comme un droit sur chaque colonne, mais seulement pour les types de droits
   où la granularité par colonne est possible&nbsp;:
   <literal>SELECT</literal>, <literal>INSERT</literal>,
   <literal>UPDATE</literal>, <literal>REFERENCES</literal>.
  </para>

  <table>
   <title>Colonnes de <structname>column_privileges</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantor</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle ayant accordé le privilège
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantee</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle receveur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la table qui contient la
        colonne (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la table qui contient la colonne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table qui contient la colonne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>column_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la colonne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>privilege_type</structfield> <type>character_data</type>
       </para>
       <para>
        Type de privilège&nbsp;: <literal>SELECT</literal>,
        <literal>INSERT</literal>, <literal>UPDATE</literal> ou
        <literal>REFERENCES</literal>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_grantable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si le droit peut être accordé,
        <literal>NO</literal> sinon
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="infoschema-column-udt-usage">
  <title><literal>column_udt_usage</literal></title>

  <para>
   La vue <literal>column_udt_usage</literal> identifie toutes les colonnes
   qui utilisent les types de données possédés par un rôle actif.
   Avec <productname>PostgreSQL</productname>, les types de données
   internes se comportent comme des types utilisateur, ils apparaissent
   aussi ici. Voir aussi la <xref linkend="infoschema-columns"/>
   pour plus de détails.
  </para>

  <table>
   <title>Colonnes de <structname>column_udt_usage</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données dans laquelle le type de donnée de la colonne (le type
        sous-jacent du domaine, si applicable) est défini (toujours la base de
        données courante).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma dans lequel le type de donnée de la colonne (le type
        sous-jacent du domaine, si applicable) est défini.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du type de données de la colonne (le type sous-jacent du domaine,
        si applicable).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant la table (toujours la base de
        données courante).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la table.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>column_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la colonne.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-columns">
  <title><literal>columns</literal></title>

  <para>
   La vue <literal>columns</literal> contient des informations sur toutes les
   colonnes de table (et colonnes de vue) de la base. Les colonnes
   système (<literal>ctid</literal>, etc.) ne sont pas incluses. Seules les colonnes
   auxquelles l'utilisateur a accès (par propriété ou par
   privilèges) sont affichées.
  </para>

  <table>
   <title>Colonnes de <structname>columns</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant la table (toujours la base de
        données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la table
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>column_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la colonne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ordinal_position</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Position de la colonne dans la table (la numérotation commençant à
        1)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>column_default</structfield> <type>character_data</type>
       </para>
       <para>
        Expression par défaut de la colonne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_nullable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si la colonne est
        <foreignphrase>NULLable</foreignphrase> (elle admet une absence de
        valeur),
        <literal>NO</literal> dans le cas contraire. La contrainte NOT NULL n'est
        pas la seule façon de définir qu'une colonne n'est pas
        <foreignphrase>NULLable</foreignphrase>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>data_type</structfield> <type>character_data</type>
       </para>
       <para>
        Le type de données de la colonne, s'il s'agit d'un type interne ou
        <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas,
        voir la vue <literal>element_types</literal>),
        <literal>USER-DEFINED</literal> dans les autres cas (le type est alors identifié
        dans <literal>udt_name</literal> et colonnes associées). Si la
        colonne est fondée sur un domaine, cette colonne est une référence au type
        sous-jacent du domaine (et le domaine est identifié dans
        <literal>domain_name</literal> et colonnes associées).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_maximum_length</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Si <literal>data_type</literal> identifie un type chaîne de caractères
        ou chaîne de bits, la longueur maximale déclarée&nbsp;; NULL pour tous les
        autres types de données ou si aucune longueur maximale n'a été déclarée.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_octet_length</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Si <literal>data_type</literal> identifie un type caractère, la longueur
        maximale en octets (bytes) d'un datum&nbsp;; NULL pour tous
        les autres types de données. La longueur maximale en octets dépend de
        la longueur maximum déclarée en caractères (voir ci-dessus) et
        l'encodage du serveur.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Si <literal>data_type</literal> identifie un type numérique, cette
        colonne contient la précision (déclarée ou implicite) du type pour ce
        domaine. La précision indique le nombre de chiffres significatifs.
        Elle peut être exprimée en décimal (base 10) ou en binaire (base 2)
        comme indiqué dans la colonne
        <literal>numeric_precision_radix</literal>. Pour tous les autres types de
        données, la colonne est NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_precision_radix</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Si <literal>data_type</literal> identifie un type numérique, cette
        colonne indique dans quelle base les valeurs des colonnes
        <literal>numeric_precision</literal> et
        <literal>numeric_scale</literal> sont exprimées. La valeur est 2
        ou 10. Pour tous les autres types de données, cette colonne est NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_scale</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Si <literal>data_type</literal> identifie un type numeric exact,
        cette colonne contient l'échelle (déclarée ou implicite) du type pour ce
        domaine. L'échelle indique le nombre de chiffres significatifs à la
        droite du point décimal. Elle peut être exprimée en décimal (base 10)
        ou en binaire (base 2), comme indiqué dans la colonne
        <literal>numeric_precision_radix</literal>. Pour tous les autres types de
        données, cette colonne est NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datetime_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Si <literal>data_type</literal> identifie une date, une heure, un
        horodatage ou un interval, cette colonne contient la précision en
        secondes (déclarée ou implicite) pour cet attribut, c'est-à-dire le
        nombre de chiffres décimaux suivant le point décimal de la valeur
        en secondes. Pour tous les autres types de données, cette colonne
        est NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>interval_type</structfield> <type>character_data</type>
       </para>
       <para>
        Si <literal>data_type</literal> identifie un type d'intervalle,
        cette colonne contient la spécification des champs que les intervalles
        incluent pour cette colonne, par exemple <literal>YEAR TO
         MONTH</literal>, <literal>DAY TO SECOND</literal>, etc. Si aucune
        restriction de champs n'est spécifiée (autrement dit, l'intervalle
        accepte tous les champs) et pour tous les autres types de données,
        ce champ est NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>interval_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname> (voir
        <literal>datetime_precision</literal> pour la précision en fraction
        des secondes des attributs du type d'intervalle)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base contenant le collationnement de l'attribut
        (toujours la base de données courante), NULL s'il s'agit du
        collationnement par défaut ou si le type de données de l'attribut
        ne peut pas avoir de collationnement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant le collationnement de l'attribut, NULL s'il s'agit du
        collationnement par défaut ou si le type de données de l'attribut
        ne peut pas avoir de collationnement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du collationnement de l'attribut, NULL s'il s'agit du
        collationnement par défaut ou si le type de données de l'attribut
        ne peut pas avoir de collationnement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>domain_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Si la colonne a un type domaine, le nom de la base de données où le type
        est défini (toujours la base de données courante), sinon NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>domain_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Si la colonne a un type domaine, le nom du schéma où le domaine est
        défini, sinon NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>domain_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Si la colonne a un type de domaine, le nom du domaine, sinon
        NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données où le type de données de la colonne (le type
        sous-jacent du domaine, si applicable) est défini (toujours la base de
        données courante).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma où le type de données de la colonne (le type sous-jacent
        du domaine, si applicable) est défini.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du type de données de la colonne (le type sous-jacent du domaine,
        si applicable).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>scope_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>scope_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>scope_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>maximum_cardinality</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car les tableaux ont toujours une cardinalité
        maximale illimitée avec <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>dtd_identifier</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Un identifiant du descripteur du type de données de la colonne, unique
        parmi les descripteurs de type de données contenus dans la table. Ceci
        est principalement utile pour joindre d'autres instances de ces
        identifiants. (Le format spécifique de l'identifiant n'est pas défini et
        rien ne permet d'assurer qu'il restera inchangé dans les versions
        futures.)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_self_referencing</structfield> <type>yes_or_no</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_identity</structfield> <type>yes_or_no</type>
       </para>
       <para>
        Si la colonne est une colonne d'identité, alors <literal>YES</literal>,
        sinon <literal>NO</literal>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>identity_generation</structfield> <type>character_data</type>
       </para>
       <para>
        Si la colonne est une colonne d'identité, alors <literal>ALWAYS</literal>
        sinon <literal>BY DEFAULT</literal>, reflétant la définition de la
        colonne.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>identity_start</structfield> <type>character_data</type>
       </para>
       <para>
        Si la colonne est une colonne identité, alors la valeur de
        démarrage de la séquence interne, sinon NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>identity_increment</structfield> <type>character_data</type>
       </para>
       <para>
        Si la colonne est une colonne identité, alors l'incrément de la
        séquence interne, sinon NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>identity_maximum</structfield> <type>character_data</type>
       </para>
       <para>
        Si la colonne est une colonne identité, alors la valeur maximale de la
        séquence interne, sinon NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>identity_minimum</structfield> <type>character_data</type>
       </para>
       <para>
        Si la colonne est une colonne identité, alors la valeur minimale de la
        séquence interne, sinon NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>identity_cycle</structfield> <type>yes_or_no</type>
       </para>
       <para>
        Si la colonne est une colonne identité, alors <literal>YES</literal> si
        la séquence interne fait un cycle et <literal>NO</literal> dans le cas
        contraire&nbsp;; sinon NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_generated</structfield> <type>character_data</type>
       </para>
       <para>
        Si la colonne est une colonne générée, alors <literal>ALWAYS</literal>,
        sinon <literal>NEVER</literal>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>generation_expression</structfield> <type>character_data</type>
       </para>
       <para>
        Si la colonne est une colonne générée, alors l'expression générée,
        sinon null.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_updatable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si la colonne est actualisable,
        <literal>NO</literal> dans le cas contraire (les colonnes des tables
        sont toujours modifiables, les colonnes des vues ne le sont pas
        nécessairement).
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Puisqu'en SQL les possibilités de définir les types de données sont
   nombreuses, et que <productname>PostgreSQL</productname> offre des
   possibilités supplémentaires, leur représentation dans le schéma
   d'information peut s'avérer complexe.
  </para>

  <para>
   La colonne <literal>data_type</literal> est supposée identifier le type de
   données interne sous-jacent de la colonne. Avec
   <productname>PostgreSQL</productname>, cela signifie que le type est défini
   dans le schéma du catalogue système <literal>pg_catalog</literal>. Cette
   colonne est utile si l'application sait gérer les
   types internes (par exemple, formater les types numériques différemment
   ou utiliser les données dans les colonnes de précision). Les colonnes
   <literal>udt_name</literal>, <literal>udt_schema</literal> et
   <literal>udt_catalog</literal> identifient toujours le type de données
   sous-jacent de la colonne même si la colonne est basée sur un domaine.
  </para>

  <para>
   Puisque <productname>PostgreSQL</productname> traite les types internes comme des
   types utilisateur, les types internes apparaissent aussi ici.
   Il s'agit d'une extension du standard SQL.
  </para>

  <para>
   Toute application conçue pour traiter les données en fonction du type peut
   utiliser ces colonnes, car, dans ce cas, il importe peu de savoir si la
   colonne est effectivement fondée sur un domaine.
   Si la colonne est fondée sur un domaine, l'identité du domaine est
   stockée dans les colonnes <literal>domain_name</literal>,
   <literal>domain_schema</literal> et <literal>domain_catalog</literal>. Pour
   assembler les colonnes avec leurs types de données associés et
   traiter les domaines comme des types séparés, on peut écrire
   <literal>coalesce(domain_name, udt_name)</literal>, etc.
  </para>
 </sect1>

 <sect1 id="infoschema-constraint-column-usage">
  <title><literal>constraint_column_usage</literal></title>

  <para>
   La vue <literal>constraint_column_usage</literal> identifie toutes les
   colonnes de la base de données courante utilisées par des contraintes.
   Seules sont affichées les colonnes contenues dans une table possédée par
   un rôle connecté. Pour une contrainte de vérification, cette vue
   identifie les colonnes utilisées dans l'expression de la vérification. Pour
   une contrainte de clé étrangère, cette vue identifie les colonnes que la clé
   étrangère référence. Pour une contrainte d'unicité ou de clé primaire, cette vue
   identifie les colonnes contraintes.
  </para>

  <table>
   <title>Colonnes de <structname>constraint_column_usage</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant la table contenant la colonne
        utilisée par certaines contraintes (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la table contenant la colonne utilisée par
        certaines contraintes
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table contenant la colonne utilisée par certaines contraintes
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>column_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la colonne utilisée par certaines contraintes
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant la contrainte (toujours la
        base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la contrainte
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-constraint-table-usage">
  <title><literal>constraint_table_usage</literal></title>

  <para>
   La vue <literal>constraint_table_usage</literal> identifie toutes les
   tables de la base de données courante utilisées par des contraintes et
   possédées par un rôle actuellement activé. (Cela diffère de la vue
   <literal>table_constraints</literal> qui identifie toutes les contraintes
   et la table où elles sont définies.) Pour une contrainte de clé étrangère,
   cette vue identifie la table que la clé étrangère référence. Pour une
   contrainte d'unicité ou de clé primaire, cette vue identifie simplement la table
   à laquelle appartient la contrainte. Les contraintes de vérification et les
   contraintes de non nullité (NOT NULL) ne sont pas incluses dans cette vue.
  </para>

  <table>
   <title>Colonnes de <structname>constraint_table_usage</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant la table utilisée par quelques
        contraintes (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la table utilisée par quelque contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table utilisée par quelque contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant la contrainte
        (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la contrainte
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-data-type-privileges">
  <title><literal>data_type_privileges</literal></title>

  <para>
   La vue <literal>data_type_privileges</literal> identifie tous les
   descripteurs de type de données auxquels l'utilisateur a accès, parce qu'il en
   est le propriétaire ou parce qu'il dispose de quelque droit sur le
   descripteur. Un descripteur de type de données est créé lorsqu'un type de
   données est utilisé dans la définition d'une colonne de table, d'un domaine ou
   d'une fonction (en tant que paramètre ou code de retour). Il stocke alors quelques
   informations sur l'utilisation du type de données (par exemple la
   longueur maximale déclarée, si applicable). Chaque descripteur de type de
   données se voit affecter un identifiant unique parmi les descripteurs de type de
   données affectés à un objet (table, domaine, fonction). Cette vue n'est
   probablement pas utile pour les applications, mais elle est utilisée pour définir
   d'autres vues dans le schéma d'information.
  </para>

  <table>
   <title>Colonnes de <structname>data_type_privileges</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>object_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant l'objet décrit (toujours la
        base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>object_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant l'objet décrit
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>object_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de l'objet décrit
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>object_type</structfield> <type>character_data</type>
       </para>
       <para>
        Le type d'objet décrit&nbsp;: fait partie de
        <literal>TABLE</literal> (le descripteur de type de données concerne une
        colonne de cette table), <literal>DOMAIN</literal> (le descripteur
        concerne ce domaine), <literal>ROUTINE</literal> (le descripteur est lié
        à un type de paramètre ou de code de retour de cette fonction).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>dtd_identifier</structfield> <type>sql_identifier</type>
       </para>
       <para>
        L'identifiant du descripteur de type de données, unique parmi les
        descripteurs de type de données pour le même objet.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domain-constraints">
  <title><literal>domain_constraints</literal></title>

  <para>
   La vue <literal>domain_constraints</literal> contient toutes les contraintes
   appartenant à des domaines définis dans la base de données courante. Seuls
   sont affichés les contraintes auxquelles l'utilisateur a accès (soit parce qu'il
   en est le propriétaire, soit parce qu'il possède certains droits dessus).
  </para>

  <table>
   <title>Colonnes de <structname>domain_constraints</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant la contrainte (toujours la
        base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>domain_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant le domaine (toujours la base de
        données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>domain_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant le domaine
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>domain_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du domaine
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_deferrable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si la vérification de la contrainte
        peut être différée,
        <literal>NO</literal> sinon
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>initially_deferred</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si la vérification de la contrainte, qui peut
        être différée, est initialement différée, <literal>NO</literal> sinon
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domain-udt-usage">
  <title><literal>domain_udt_usage</literal></title>

  <para>
   La vue <literal>domain_udt_usage</literal> identifie tous les domaines
   utilisant les types de données possédés par un rôle actif.
   Sous <productname>PostgreSQL</productname>, les types de données internes
   se comportent comme des types utilisateur. Ils sont donc inclus ici.
  </para>

  <table>
   <title>Colonnes de <structname>domain_udt_usage</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données de définition du type de données domaine
        (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma de définition du type de données domaine
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du type de données domaine
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>domain_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant le domaine (toujours
        la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>domain_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant le domaine
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>domain_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du domaine
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domains">
  <title><literal>domains</literal></title>

  <para>
   La vue <literal>domains</literal> contient tous les domaines définis dans la
   base de données courante. Seuls sont affichés les domaines auxquels
   l'utilisateur a accès (soit parce qu'il en est le propriétaire, soit parce
   qu'il possède certains droits dessus).
  </para>

  <table>
   <title>Colonnes de <structname>domains</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>domain_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant le domaine (toujours la base de
        données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>domain_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant le domaine
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>domain_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du domaine
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>data_type</structfield> <type>character_data</type>
       </para>
       <para>
        Type de données du domaine s'il s'agit d'un type interne, ou
        <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas, voir la
        vue <literal>element_types</literal>), sinon
        <literal>USER-DEFINED</literal> (dans ce cas, le type est
        identifié dans <literal>udt_name</literal> et comprend des colonnes
        associées).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_maximum_length</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Si le domaine a un type caractère ou chaîne de bits, la longueur
        maximale déclarée&nbsp;; NULL pour tous les autres types de données ou
        si aucune longueur maximale n'a été déclarée.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_octet_length</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Si le domaine a un type caractère, la longueur maximale en octets (bytes)
        d'un datum&nbsp;; NULL pour tous
        les autres types de données. La longueur maximale en octets dépend de
        la longueur maximum déclarée en caractères (voir ci-dessus) et
        l'encodage du serveur.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base contenant le collationnement du domaine
        (toujours la base de données courante), NULL s'il s'agit du
        collationnement par défaut ou si le type de données de l'attribut
        ne peut pas avoir de collationnement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant le collationnement du domaine, NULL s'il s'agit du
        collationnement par défaut ou si le type de données du domaine
        ne peut pas avoir de collationnement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du collationnement de la domaine, NULL s'il s'agit du
        collationnement par défaut ou si le type de données du domaine
        ne peut pas avoir de collationnement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Si le domaine a un type numérique, cette colonne contient la précision
        (déclarée ou implicite) du type de cette colonne. Cette précision
        indique le nombre de chiffres significatifs. Elle peut être exprimée en
        décimal (base 10) ou en binaire (base 2), comme indiqué dans la colonne
        <literal>numeric_precision_radix</literal>. Pour les autres types de
        données, cette colonne est NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_precision_radix</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Si le domaine a un type numérique, cette colonne indique la base des
        valeurs des colonnes <literal>numeric_precision</literal> et
        <literal>numeric_scale</literal>. La valeur est soit 2 soit 10. Pour tous
        les autres types de données, cette colonne est NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_scale</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Si le domaine contient un type numeric, cette colonne contient l'échelle
        (déclarée ou implicite) du type pour cette colonne. L'échelle indique le
        nombre de chiffres significatifs à droite du point décimal. Elle peut
        être exprimée en décimal (base 10) ou en binaire (base 2), comme indiqué
        dans la colonne <literal>numeric_precision_radix</literal>. Pour tous les
        autres types de données, cette colonne est NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datetime_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Si le domaine contient un type date, heure ou intervalle, la précision
        déclarée&nbsp;; NULL pour les autres types de données ou si la précision
        n'a pas été déclarée.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>interval_type</structfield> <type>character_data</type>
       </para>
       <para>
        Si <literal>data_type</literal> identifie un type d'intervalle,
        cette colonne contient la spécification des champs que les intervalles
        incluent pour ce domaine, par exemple <literal>YEAR TO
         MONTH</literal>, <literal>DAY TO SECOND</literal>, etc. Si aucune
        restriction de champs n'est spécifiée (autrement dit, l'intervalle
        accepte tous les champs) et pour tous les autres types de données,
        ce champ est NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>interval_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname> (voir
        <literal>datetime_precision</literal> pour la précision en fraction
        des secondes des domaines de type d'intervalle)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>domain_default</structfield> <type>character_data</type>
       </para>
       <para>
        Expression par défaut du domaine
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données dans laquelle est défini le type de
        données domaine (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma où le type de données domaine est défini
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du type de données domaine
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>scope_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>scope_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>scope_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>maximum_cardinality</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car les tableaux n'ont pas de limite maximale de cardinalité
        dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>dtd_identifier</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Un identifiant du descripteur de type de données du domaine, unique
        parmi les descripteurs de type de données restant dans le domaine (ce qui
        est trivial car un domaine contient seulement un descripteur de type de
        données). Ceci est principalement utile pour joindre d'autres instances
        de tels identifiants (le format spécifique de l'identifiant n'est pas
        défini et il n'est pas garanti qu'il restera identique dans les versions
        futures).
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-element-types">
  <title><literal>element_types</literal></title>

  <para>
   La vue <literal>element_types</literal> contient les descripteurs de type
   de données des éléments de tableaux. Lorsqu'une colonne de table, un
   attribut de type composite, un domaine, un paramètre de fonction ou un
   code de retour de fonction est définie comme un
   type tableau, la vue respective du schéma d'information contient seulement
   <literal>ARRAY</literal> dans la colonne <literal>data_type</literal>. Pour
   obtenir des informations sur le type d'élément du tableau, il est possible
   de joindre la vue respective avec cette vue. Par exemple, pour afficher les
   colonnes d'une table avec les types de données et les types d'élément de
   tableau, si applicable, on peut écrire&nbsp;:
   <programlisting>SELECT c.column_name, c.data_type, e.data_type AS element_type
FROM information_schema.columns c LEFT JOIN information_schema.element_types e
     ON ((c.table_catalog, c.table_schema, c.table_name, 'TABLE', c.dtd_identifier)
       = (e.object_catalog, e.object_schema, e.object_name, e.object_type, e.collection_type_identifier))
WHERE c.table_schema = '...' AND c.table_name = '...'
ORDER BY c.ordinal_position;
   </programlisting>
   Cette vue n'inclut que les objets auxquels l'utilisateur courant a
   accès, parce que propriétaire ou disposant de quelque privilège.
  </para>

  <table>
   <title>Colonnes de <structname>element_types</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>object_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant l'objet qui utilise le tableau
        décrit (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>object_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant l'objet utilisant le tableau décrit
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>object_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de l'objet utilisant le tableau décrit
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>object_type</structfield> <type>character_data</type>
       </para>
       <para>
        Le type de l'objet utilisant le tableau décrit&nbsp;:
        il fait partie de <literal>TABLE</literal> (le tableau est utilisé par
        une colonne de cette table), <literal>USER-DEFINED TYPE</literal> (le
        tableau est utilisé par un attribut de ce type composite),
        <literal>DOMAIN</literal> (le tableau est
        utilisé par ce domaine), <literal>ROUTINE</literal> (le tableau est
        utilisé par un paramètre ou le type du code de retour de cette fonction).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collection_type_identifier</structfield> <type>sql_identifier</type>
       </para>
       <para>
        L'identifiant du descripteur de type de données du tableau décrit.
        Utilisez cette colonne pour faire une jointure avec les colonnes
        <literal>dtd_identifier</literal> des autres vues du schéma
        d'informations.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>data_type</structfield> <type>character_data</type>
       </para>
       <para>
        Le type de données des éléments du tableau s'il s'agit d'un type
        interne, sinon <literal>USER-DEFINED</literal> (dans ce cas, le type est
        identifié comme <literal>udt_name</literal> et dispose de colonnes
        associées).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_maximum_length</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux types
        de données d'éléments de tableau dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_octet_length</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux types
        de données d'éléments de tableau dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base contenant le collationnement du type de l'élément
        (toujours la base de données courante), NULL s'il s'agit du
        collationnement par défaut ou si le type de données de l'élément
        ne peut pas avoir de collationnement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant le collationnement du type de l'élément,
        NULL s'il s'agit du collationnement par défaut ou si le type de
        données de l'élément ne peut pas avoir de collationnement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du collationnement du type de l'élément, NULL s'il s'agit du
        collationnement par défaut ou si le type de données de l'élément
        ne peut pas avoir de collationnement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux types
        de données d'éléments de tableau dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_precision_radix</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux types
        de données d'éléments de tableau dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_scale</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux types
        de données d'éléments de tableau dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datetime_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux types
        de données d'éléments de tableau dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>interval_type</structfield> <type>character_data</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux types
        de données d'éléments de tableau dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>interval_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux types
        de données d'éléments de tableau dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>domain_default</structfield> <type>character_data</type>
       </para>
       <para>
        Pas encore implanté
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données pour lequel le type de données est défini
        (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma dans lequel est défini le type de données des éléments
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du type de données des éléments
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>scope_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>scope_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>scope_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>maximum_cardinality</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car les tableaux n'ont pas de limite maximale de
        cardinalité dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>dtd_identifier</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Un identifiant du descripteur de type de données pour cet élément.
        Ceci n'est actuellement pas utile.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-enabled-roles">
  <title><literal>enabled_roles</literal></title>

  <para>
   La vue <literal>enabled_roles</literal> identifie les <quote>rôles
    actuellement actifs</quote>. Les rôles actifs sont définis
   récursivement comme l'utilisateur courant avec tous les rôles qui ont été
   donnés aux rôles activés avec l'héritage automatique. En d'autres termes,
   ce sont les rôles dont l'utilisateur courant est automatiquement membre,
   par héritage direct ou indirect.
   <indexterm><primary>enabled role</primary></indexterm>
   <indexterm><primary>role</primary><secondary>enabled</secondary></indexterm>
  </para>

  <para>
   Pour la vérification des permissions, l'ensemble des <quote>rôles applicables</quote>
   est appliqué, ce qui peut être plus large que l'ensemble des rôles
   actifs. Il est, de ce fait, généralement préférable d'utiliser la vue
   <literal>applicable_roles</literal> à la place de celle-ci&nbsp;; Voir
   <xref linkend="infoschema-applicable-roles"/> pour des détails sur la vue
   <literal>applicable_roles</literal>.
  </para>

  <table>
   <title>Colonnes de <structname>enabled_roles</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>role_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom d'un rôle
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-data-wrapper-options">
  <title><literal>foreign_data_wrapper_options</literal></title>

  <para>
   La vue <literal>foreign_data_wrapper_options</literal> contient toutes
   les options définies par les wrappers de données distantes dans la base de
   données en cours. Seuls les wrappers accessibles par l'utilisateur connecté
   sont affichés (qu'il soit propriétaire ou qu'il ait des droits dessus).
  </para>

  <table>
   <title>Colonnes de <structname>foreign_data_wrapper_options</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_data_wrapper_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données dans laquelle est défini le wrapper
        de données distantes (toujours la base de connexion)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_data_wrapper_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du wrapper
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>option_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom d'une option
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>option_value</structfield> <type>character_data</type>
       </para>
       <para>
        Valeur de l'option
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-data-wrappers">
  <title><literal>foreign_data_wrappers</literal></title>

  <para>
   La vue <literal>foreign_data_wrappers</literal> contient tous les wrappers
   de données distantes définis dans le base de données en cours. Seuls sont
   affichés les wrappers pour lesquels l'utilisateur connecté a accès
   (qu'il soit propriétaire ou qu'il ait des droits dessus).
  </para>

  <table>
   <title>Colonnes de <structname>foreign_data_wrappers</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_data_wrapper_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant le wrapper de données
        distantes (toujours la base de données en cours)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_data_wrapper_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du wrapper
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>authorization_identifier</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du propriétaire du serveur distant
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>library_name</structfield> <type>character_data</type>
       </para>
       <para>
        Nom du fichier de la bibliothèque implémentant ce wrapper
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_data_wrapper_language</structfield> <type>character_data</type>
       </para>
       <para>
        Langage utilisé pour implémenter ce wrapper
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-server-options">
  <title><literal>foreign_server_options</literal></title>

  <para>
   La vue <literal>foreign_server_options</literal> contient toutes les options
   définies pour les serveurs distants de la base de données en cours. Ne sont
   affichés que les serveurs distants pour lesquels l'utilisateur connecté a
   des droits (qu'il soit propriétaire ou qu'il ait quelques droits dessus).
  </para>

  <table>
   <title>Colonnes de <structname>foreign_server_options</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_server_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant le serveur
        distant (toujours la base de données en cours)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_server_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du serveur distant
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>option_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom d'une option
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>option_value</structfield> <type>character_data</type>
       </para>
       <para>
        Valeur de l'option
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-servers">
  <title><literal>foreign_servers</literal></title>

  <para>
   La vue <literal>foreign_servers</literal> contient tous les serveurs
   distants définis dans la base en cours. Ne sont
   affichés que les serveurs distants pour lesquels l'utilisateur connecté a
   des droits (qu'il soit propriétaire ou qu'il ait quelques droits dessus).
  </para>

  <table>
   <title>Colonnes de <structname>foreign_servers</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_server_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données dans laquelle ce serveur distant est
        défini (toujours la base de données en cours)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_server_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du serveur distant
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_data_wrapper_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient le wrapper de données
        distantes utilisé par le serveur distant (toujours la base de données
        en cours)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_data_wrapper_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du wrapper de données distantes utilisé par le serveur
        distant
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_server_type</structfield> <type>character_data</type>
       </para>
       <para>
        Information sur le type de serveur distant, si indiqué lors de la
        création
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_server_version</structfield> <type>character_data</type>
       </para>
       <para>
        Information sur la version de serveur distant, si indiqué lors de
        la création
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>authorization_identifier</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du propriétaire du serveur distant
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-table-options">
  <title><literal>foreign_table_options</literal></title>

  <para>
   La vue <literal>foreign_table_options</literal> contient toutes les
   options définies pour les tables distantes de la base de données
   courante. Seules sont affichées les tables distantes accessibles par
   l'utilisateur courant (soit parce qu'il en est le propriétaire soit
   parce qu'il dispose de droits particuliers).
  </para>

  <table>
   <title>Colonnes de <structname>foreign_table_options</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la table distante
        (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la table distante
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table distante
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>option_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom d'une option
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>option_value</structfield> <type>character_data</type>
       </para>
       <para>
        Valeur de l'option
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-tables">
  <title><literal>foreign_tables</literal></title>

  <para>
   La vue <literal>foreign_tables</literal> contient toutes les tables
   distantes définies dans la base de données courantes. Seules sont
   affichées les tables distantes accessibles par l'utilisateur courant
   (soit parce qu'il en est le propriétaire soit parce qu'il dispose de
   droits particuliers).
  </para>

  <table>
   <title>Colonnes de <structname>foreign_tables</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la table distante
        (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la table distante
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table distante
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_server_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données où le serveur distant est
        défini (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_server_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du serveur distant
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-key-column-usage">
  <title><literal>key_column_usage</literal></title>

  <para>
   La vue <literal>key_column_usage</literal> identifie toutes les colonnes de
   la base de données courante restreintes par une contrainte unique, clé primaire
   ou clé étrangère. Les contraintes de vérification ne sont pas incluses dans
   cette vue. Seules sont affichées les colonnes auxquelles l'utilisateur a accès,
   parce qu'il est le propriétaire de la table ou qu'il dispose de
   quelque privilège.
  </para>

  <table>
   <title>Colonnes de <structname>key_column_usage</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant la contrainte (toujours la base
        de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant la table contenant la colonne
        contrainte (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la table contenant la colonne contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table contenant la colonne contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>column_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la colonne contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ordinal_position</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Position ordinale de la colonne dans la clé de contrainte (la numérotation
        commence à 1)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>position_in_unique_constraint</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Pour une contrainte de type clé étrangère, la position ordinale de la
        colonne référencée dans sa contrainte d'unicité (la numérotation commence à
        1)&nbsp;; sinon null
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-parameters">
  <title><literal>parameters</literal></title>

  <para>
   La vue <literal>parameters</literal> contient des informations sur les
   paramètres (arguments) de toutes les fonctions de la base de données
   courante. Seules sont affichées les fonctions auxquelles l'utilisateur
   courant a accès, parce qu'il en est le propriétaire ou qu'il
   dispose de quelque privilège.
  </para>

  <table>
   <title>Colonnes de <structname>parameters</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant la fonction (toujours
        la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la fonction
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Le <quote>nom spécifique</quote> de la fonction. Voir la <xref
        linkend="infoschema-routines"/> pour plus d'informations.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ordinal_position</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Position ordinale du paramètre dans la liste des arguments de la fonction
        (la numérotation commence à 1)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>parameter_mode</structfield> <type>character_data</type>
       </para>
       <para>
        <literal>IN</literal> pour les paramètres en entrée,
        <literal>OUT</literal> pour les paramètres en sortie ou
        <literal>INOUT</literal> pour les paramètres en entrée/sortie.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_result</structfield> <type>yes_or_no</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>as_locator</structfield> <type>yes_or_no</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>parameter_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du paramètre ou NULL si le paramètre n'a pas de nom
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>data_type</structfield> <type>character_data</type>
       </para>
       <para>
        Type de données du paramètre s'il s'agit d'un type interne, ou
        <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas, voir la
        vue <literal>element_types</literal>), sinon
        <literal>USER-DEFINED</literal> (dans ce cas, le type est identifié dans
        <literal>udt_name</literal> et dispose de colonnes associées).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_maximum_length</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux types
        de données dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_octet_length</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux types
        de données dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée
        pour configurer les types de données dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée
        pour configurer les types de données dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée
        pour configurer les types de données dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux types
        de données dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_precision_radix</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux types
        de données dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_scale</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux types
        de données dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datetime_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux types
        de données dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>interval_type</structfield> <type>character_data</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux types
        de données dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>interval_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux types
        de données dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données sur laquelle est défini le paramètre (toujours la base
        de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma dans lequel est défini le type de données du paramètre
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du type de données du paramètre
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>scope_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>scope_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>scope_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>maximum_cardinality</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux types
        de données dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>dtd_identifier</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Un identifiant du descripteur de type de données du paramètre, unique
        parmi les descripteurs de type de données restant dans la fonction. Ceci
        est principalement utile pour réaliser une jointure avec les autres
        instances de tels identifiants (le format spécifique de l'identifiant
        n'est pas défini et il n'est pas garanti qu'il reste identique dans les
        prochaines versions).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>parameter_default</structfield> <type>character_data</type>
       </para>
       <para>
        L'expression par défaut du paramètre, ou NULL si aucune ou si la
        fonction n'a pas pour propriétaire un des rôles actuellement activés.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-referential-constraints">
  <title><literal>referential_constraints</literal></title>

  <para>
   La vue <literal>referential_constraints</literal> contient toutes les
   contraintes référentielles (clés étrangères) au sein de la base de données
   courante.
   Seuls sont affichés les contraintes pour lesquelles l'utilisateur connecté
   a accès en écriture sur la table référençante (parce qu'il est le
   propriétaire ou qu'il a d'autres droits que <literal>SELECT</literal>).
  </para>

  <table>
   <title>Colonnes de <structname>referential_constraints</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant la contrainte
        (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>unique_constraint_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant la contrainte d'unicité ou de clé
        primaire que la contrainte de clé étrangère référence (toujours la base
        de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>unique_constraint_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la contrainte d'unicité ou de clé primaire que
        la contrainte de clé étrangère référence
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>unique_constraint_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la contrainte d'unicité ou de clé primaire que la contrainte de clé
        étrangère référence
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>match_option</structfield> <type>character_data</type>
       </para>
       <para>
        Correspondances de la contrainte de clé étrangère&nbsp;:
        <literal>FULL</literal>, <literal>PARTIAL</literal> ou
        <literal>NONE</literal>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>update_rule</structfield> <type>character_data</type>
       </para>
       <para>
        Règle de mise à jour associée à la contrainte de clé étrangère&nbsp;:
        <literal>CASCADE</literal>, <literal>SET NULL</literal>,
        <literal>SET DEFAULT</literal>, <literal>RESTRICT</literal> ou
        <literal>NO ACTION</literal>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>delete_rule</structfield> <type>character_data</type>
       </para>
       <para>
        Règle de suppression associée à la contrainte de clé étrangère&nbsp;:
        <literal>CASCADE</literal>, <literal>SET NULL</literal>,
        <literal>SET DEFAULT</literal>, <literal>RESTRICT</literal> ou
        <literal>NO ACTION</literal>.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-column-grants">
  <title><literal>role_column_grants</literal></title>

  <para>
   La vue <literal>role_column_grants</literal> identifie tous les privilèges
   de colonne octroyés pour lesquels le donneur ou le
   bénéficiaire est un rôle actuellement actif. Plus d'informations sous
   <literal>column_privileges</literal>. La seule différence réelle entre
   cette vue et <literal>column_privileges</literal> est que cette vue omet
   les colonnes qui ont été rendues accessibles à l'utilisateur actuel en
   utilisant la commande GRANT pour <literal>PUBLIC</literal>.
  </para>

  <table>
   <title>Colonnes de <structname>role_column_grants</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantor</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle qui a octroyé le privilège
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantee</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle bénéficiaire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la table qui contient la
        colonne (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la table qui contient la colonne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table qui contient la colonne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>column_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la colonne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>privilege_type</structfield> <type>character_data</type>
       </para>
       <para>
        Type de privilège&nbsp;: <literal>SELECT</literal>,
        <literal>INSERT</literal>, <literal>UPDATE</literal>,
        <literal>DELETE</literal>, <literal>TRUNCATE</literal>,
        <literal>REFERENCES</literal> ou <literal>TRIGGER</literal>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_grantable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si le droit peut être transmis,
        <literal>NO</literal> sinon
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-routine-grants">
  <title><literal>role_routine_grants</literal></title>

  <para>
   La vue <literal>role_routine_grants</literal> identifie tous les privilèges
   de routine octriyés lorsque le donneur ou le bénéficiaire est un rôle actif.
   Plus d'informations sous <literal>routine_privileges</literal>. La seule
   différence réelle entre cette vue et <literal>routine_privileges</literal>
   est que cette vue omet les colonnes qui ont été rendues accessibles à
   l'utilisateur actuel en utilisant la commande GRANT pour <literal>PUBLIC</literal>.
  </para>

  <table>
   <title>Colonnes de <structname>role_routine_grants</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantor</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle qui a octroyé le privilège
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantee</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle bénéficiaire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la fonction (toujours
        la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la fonction
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Le <quote>nom spécifique</quote> de la fonction. Voir la <xref
        linkend="infoschema-routines"/> pour plus d'informations.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>routine_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la fonction (toujours la base
        de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>routine_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la fonction
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>routine_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la fonction (peut être dupliqué en cas de
        surcharge)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>privilege_type</structfield> <type>character_data</type>
       </para>
       <para>
        Toujours <literal>EXECUTE</literal> (seul type de privilège sur
        les fonctions)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_grantable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si le droit peut être transmis,
        <literal>NO</literal> sinon
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-table-grants">
  <title><literal>role_table_grants</literal></title>

  <para>
   La vue <literal>role_table_grants</literal> identifie tous les privilèges de
   tables octroyés lorsque le donneur ou le bénéficiaire est un rôle actif.
   Plus d'informations sous <literal>table_privileges</literal>. La seule
   différence réelle entre
   cette vue et <literal>table_privileges</literal> est que cette vue omet
   les colonnes qui ont été rendues accessibles à l'utilisateur actuel en
   utilisant la commande GRANT pour <literal>PUBLIC</literal>.
  </para>

  <table>
   <title>Colonnes de <structname>role_table_grants</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantor</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle qui a octroyé le privilège
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantee</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle bénéficiaire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la table (toujours la base de
        données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la table
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>privilege_type</structfield> <type>character_data</type>
       </para>
       <para>
        Type du privilège&nbsp;: <literal>SELECT</literal>,
        <literal>DELETE</literal>, <literal>INSERT</literal>,
        <literal>UPDATE</literal>, <literal>REFERENCES</literal>
        ou <literal>TRIGGER</literal>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_grantable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si le droit peut être transmis,
        <literal>NO</literal> sinon
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>with_hierarchy</structfield> <type>yes_or_no</type>
       </para>
       <para>
        Dans le standard SQL, <literal>WITH HIERARCHY OPTION</literal>
        est un (sous-)droit séparé autorisant certaines opérations sur
        la hiérarchie de l'héritage des tables. Dans PostgreSQL, ceci est
        inclus dans le droit <literal>SELECT</literal>, donc cette
        colonne affiche <literal>YES</literal> si le droit est
        <literal>SELECT</literal>, et <literal>NO</literal> sinon.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-udt-grants">
  <title><literal>role_udt_grants</literal></title>

  <para>
   La vue <literal>role_udt_grants</literal> a pour but d'identifier les
   droits <literal>USAGE</literal> donnés pour des types définis par l'utilisateur
   pour lesquels celui qui donne le droit et celui qui le reçoit sont des rôles
   actuellement activés. Plus d'informations sont disponibles dans
   <literal>udt_privileges</literal>. La seule réelle différence entre cette vue
   et <literal>udt_privileges</literal> est que cette vue omet les objets qui
   ont été rendus accessibles à l'utilisateur courant par le biais du
   pseudo-rôle <literal>PUBLIC</literal>. Comme les types de données n'ont pas
   vraiment de droits dans PostgreSQL, et disposent seulement d'un droit implicite
   à <literal>PUBLIC</literal>, cette vue est vide.
  </para>

  <table>
   <title>Colonnes de <structname>role_udt_grants</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Column Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantor</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Le nom du rôle qui a donné le droit
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantee</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Le nom du rôle à qui le droit a été donné
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base contenant le type (toujours la base de données
        courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant le type
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du type
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>privilege_type</structfield> <type>character_data</type>
       </para>
       <para>
        Toujours <literal>TYPE USAGE</literal>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_grantable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si le droit peut être donné,
        <literal>NO</literal> sinon
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-usage-grants">
  <title><literal>role_usage_grants</literal></title>

  <para>
   La vue <literal>role_usage_grants</literal> identifie
   les privilèges d'<literal>USAGE</literal> sur différents types d'objets
   où le donneur ou le receveur des droits est un rôle actuellement activé.
   Plus d'informations sous <literal>usage_privileges</literal>.
   Dans le futur, cette vue pourrait contenir des informations plus utiles.
   La seule différence réelle entre
   cette vue et <literal>usage_privileges</literal> est que cette vue omet
   les colonnes qui ont été rendues accessibles à l'utilisateur actuel en
   utilisant la commande GRANT pour <literal>PUBLIC</literal>.
  </para>

  <table>
   <title>Colonnes de <structname>role_usage_grants</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantor</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle qui a octroyé le privilège
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantee</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle bénéficiaire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>object_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient l'objet (toujours la base
        de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>object_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient l'objet, if applicable,
        sinon une chaîne vide
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>object_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de l'objet
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>object_type</structfield> <type>character_data</type>
       </para>
       <para>
        <literal>COLLATION</literal>, <literal>DOMAIN</literal>,
        <literal>FOREIGN DATA WRAPPER</literal>, <literal>FOREIGN
         SERVER</literal> ou <literal>SEQUENCE</literal>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>privilege_type</structfield> <type>character_data</type>
       </para>
       <para>
        Toujours <literal>USAGE</literal>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_grantable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si le droit peut être transmis,
        <literal>NO</literal> sinon
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routine-column-usage">
  <title><literal>routine_column_usage</literal></title>

  <para>
   La vue <literal>routine_column_usage</literal> a pour but d'identifier
   toutes les colonnes utilisées par une fonction ou procédure. Actuellement,
   cette information n'est pas tracée par
   <productname>PostgreSQL</productname>.
  </para>

  <table>
   <title>Colonnes de <literal>routine_column_usage</literal></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Type de colonne
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom de la base de données contenant la fonction (toujours la base
       courante)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom du schéma contenant la fonction
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Le <quote>nom spécifique</quote> de la fonction. Voir <xref
       linkend="infoschema-routines"/> pour plus d'informations.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom de la base de données contenant la fonction (toujours la base
       courante)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom du schéma contenant la fonction
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom de la fonction (peut être dupliqué en cas de surcharge)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom de la base de données qui contient la table qui est utilisée par la
       fonction (toujours la base courante)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom du schéma qui contient la table qui est utilisée par la fonction
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom de la table utilisée par la fonction
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>column_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom de la colonne utilisée par la fonction
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routine-privileges">
  <title><literal>routine_privileges</literal></title>

  <para>
   La vue <literal>routine_privileges</literal> identifie tous les droits
   sur les fonctions à un rôle actuellement activé ou par un rôle actuellement
   activé.
   Il existe une ligne pour chaque combinaison fonction, donneur, bénéficiaire.
  </para>

  <table>
   <title>Colonnes de <structname>routine_privileges</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantor</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle qui a accordé le privilège
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantee</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle bénéficiaire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la fonction (toujours la base
        de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la fonction
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Le <quote>nom spécifique</quote> de la fonction. Voir la <xref
        linkend="infoschema-routines"/> pour plus d'informations.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>routine_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la fonction (toujours la base
        de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>routine_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la fonction
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>routine_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la fonction (peut être dupliqué en cas de
        surcharge)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>privilege_type</structfield> <type>character_data</type>
       </para>
       <para>
        Toujours <literal>EXECUTE</literal> (seul priilège de fonctions)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_grantable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si le droit peut être transmis,
        <literal>NO</literal> sinon
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="infoschema-routine-routine-usage">
  <title><literal>routine_routine_usage</literal></title>

  <para>
   La vue <literal>routine_routine_usage</literal> a pour but d'identifier
   toutes les fonctions ou procédure utilisées par une autre (ou la même)
   fonction ou procédure, soit dans le corps ou dans les expressions par
   défaut de paramètre. Actuellement, seules les fonctions utilisées dans les
   expression par défaut des paramètres sont tracées. Une entrée est incluse
   ici seulement si la fonction utilisée appartient à un rôle actif
   maintenant. (Il n'y a aucune restriction sur la fonction appelante.)
  </para>

  <para>
   Notez que les entrées pour les deux fonctions dans la vue référencent le
   nom <quote>spécifique</quote> de la routine, même si les noms de colonnes
   sont utilisées d'une manière incohérente avec les autres vues du schéma
   d'information liées aux routines. Ceci vient du standard SQL, même si cela
   est une conception discutable. Voir <xref linkend="infoschema-routines"/>
   pour plus d'information au sujet des noms spécifiques.
  </para>

  <table>
   <title>Colonnes de <literal>routine_routine_usage</literal></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Type de la colonne
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom de la base de données qui contient la fonction utilisée (toujours la base courante)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom du schéma contenant la fonction utilisée
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Le <quote>nom spécifique</quote> de la fonction utilisée
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom de la base de données qui contient la fonction utilisée par la
       première fonction (toujours la base courante)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom du schéma qui contient la fonction utilisée par la première fonction
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Le <quote>nom spécifique</quote> de la fonction utilisée par la
       première fonction.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routine-sequence-usage">
  <title><literal>routine_sequence_usage</literal></title>

  <para>
   La vue <literal>routine_sequence_usage</literal> a pour but d'identifier
   toutes les séquences qui sont utilisées par une fonction ou une procédure,
   soit dans le corps soit en paramètre par défaut des expressions.
   Actuellement, seules les séquences utilisées dans les paramètres par
   défaut des expressions sont tracées. Une séquence est seulement incluse si
   la séquence est la propriété d'un rôle actuellement actif.
  </para>

  <table>
   <title>Colonnes de <literal>routine_sequence_usage</literal></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Type de la colonne
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom de la base de données contenant la fonction (toujours la base courante)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom du schéma contenant la fonction
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Le <quote>nom spécifique</quote> de la fonction. Voir <xref
       linkend="infoschema-routines"/> pour plus d'information
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom de la base de données contenant la fonction (toujours la base
       courante)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom du schéma contenant la fonction
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom de la fonction (peut être dupliqué en cas de surcharge)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schema_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom de la base de données qui contient la séquence utilisée par la
       fonction (toujours la base courante)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sequence_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom du schéma qui contient la séquence utilisée par la fonction
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sequence_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom de la séquence utilisée par la fonction
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routine-table-usage">
  <title><literal>routine_table_usage</literal></title>

  <para>
   La vue <literal>routine_table_usage</literal> a pour but d'identifier
   toutes les tables utilisées dans une fonction ou procédure. Cette
   information n'est actuellement pas tracée par
   <productname>PostgreSQL</productname>.
  </para>

  <table>
   <title>Colonnes de <literal>routine_table_usage</literal></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Type de la colonne
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom de la base de données contenant la fonction (toujours la base
       courante)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom du schéma contenant la fonction
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Le <quote>nom spécifique</quote> de la fonction. Voir <xref
       linkend="infoschema-routines"/> pour plus d'information
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom de la base de données contenant la fonction (toujours la base
       courante)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom du schéma contenant la fonction
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom de la fonction (peut être dupliquée en cas de surcharge)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom de la base de données qui contient la table utilisée par la
       fonction (toujours la base courante)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom du schéma qui contient la table utilisée par la fonction
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Nom de la table utilisée par la fonction
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routines">
  <title><literal>routines</literal></title>

  <para>
   La vue <literal>routines</literal> contient toutes les fonctions de la base
   de données courante. Seules sont affichées les fonctions auxquelles
   l'utilisateur courant a accès (qu'il en soit le propriétaire ou dispose de
   de privilèges).
  </para>

  <table>
   <title>Colonnes de <structname>routines</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la fonction (toujours la base
        de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la fonction
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Le <quote>nom spécifique</quote> de la fonction. Ce nom identifie de
        façon unique la fonction dans le schéma, même si le nom réel de la
        fonction est surchargé. Le format du nom spécifique n'est pas défini, il
        ne devrait être utilisé que dans un but de comparaison avec d'autres instances de
        noms spécifiques de routines.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>routine_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la fonction (toujours la base
        de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>routine_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la fonction
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>routine_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la fonction (peut être dupliqué en cas de
        surcharge)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>routine_type</structfield> <type>character_data</type>
       </para>
       <para>
        <literal>FUNCTION</literal> pour une fonction,
        <literal>PROCEDURE</literal> pour une procédure
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>module_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>module_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>module_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>data_type</structfield> <type>character_data</type>
       </para>
       <para>
        Type de données de retour de la fonction s'il est interne,
        <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas, voir la
        vue <literal>element_types</literal>), sinon
        <literal>USER-DEFINED</literal> (dans ce cas, le type est identifié
        dans <literal>type_udt_name</literal> et dispose de colonnes associées).
        NULL pour une procédure.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_maximum_length</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux
        types de données renvoyées sous <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_octet_length</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux
        types de données renvoyées sous <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée
        pour configurer les types de données dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée
        pour configurer les types de données dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée
        pour configurer les types de données dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux
        types de données renvoyées sous <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_precision_radix</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux
        types de données renvoyées sous <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_scale</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux
        types de données renvoyées sous <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datetime_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux
        types de données renvoyées sous <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>interval_type</structfield> <type>character_data</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux
        types de données renvoyées sous <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>interval_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car cette information n'est pas appliquée aux
        types de données renvoyées sous <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>type_udt_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données dans laquelle est défini le type de données
        de retour de la fonction (toujours la base de données courante). NULL
        pour une procédure.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>type_udt_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma dans lequel est défini le type de données de retour de la
        fonction. NULL pour une procédure.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>type_udt_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du type de données de retour de la fonction. NULL pour une
        procédure.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>scope_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>scope_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>scope_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>maximum_cardinality</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Toujours NULL car il n'y a pas de limite maximale à la
        cardinalité des tableaux dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>dtd_identifier</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Un identifiant du descripteur de type de données du type de données
        retour, unique parmi les descripteurs de type de données de la
        fonction. Ceci est principalement utile pour la jointure avec d'autres
        instances de tels identifiants (le format spécifique de l'identifiant
        n'est pas défini et il n'est pas certain qu'il restera identique dans les
        versions futures).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>routine_body</structfield> <type>character_data</type>
       </para>
       <para>
        Si la fonction est une fonction SQL, alors
        <literal>SQL</literal>, sinon <literal>EXTERNAL</literal>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>routine_definition</structfield> <type>character_data</type>
       </para>
       <para>
        Le texte source de la fonction (NULL si la fonction n'appartient pas à
        un rôle actif). (Le standard SQL précise que cette colonne n'est
        applicable que si <literal>routine_body</literal> est
        <literal>SQL</literal>, mais sous <productname>PostgreSQL</productname>
        ce champ contient tout texte source précisé à la création de la
        fonction.)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>external_name</structfield> <type>character_data</type>
       </para>
       <para>
        Si la fonction est une fonction C, le nom externe (link
        symbol) de la fonction&nbsp;; sinon NULL. (Il s'agit de la
        même valeur que celle affichée dans
        <literal>routine_definition</literal>).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>external_language</structfield> <type>character_data</type>
       </para>
       <para>
        Le langage d'écriture de la fonction
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>parameter_style</structfield> <type>character_data</type>
       </para>
       <para>
        Toujours <literal>GENERAL</literal> (le standard SQL définit d'autres
        styles de paramètres qui ne sont pas disponibles avec
        <productname>PostgreSQL</productname>).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_deterministic</structfield> <type>yes_or_no</type>
       </para>
       <para>
        Si la fonction est déclarée immuable (déterministe dans le
        standard SQL), alors <literal>YES</literal>, sinon
        <literal>NO</literal>. (Les autres
        niveaux de volatilité disponibles dans
        <productname>PostgreSQL</productname> ne peuvent être récupérés via le schéma
        d'informations).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>sql_data_access</structfield> <type>character_data</type>
       </para>
       <para>
        Toujours <literal>MODIFIES</literal>, ce qui signifie que la fonction peut
        modifier les données SQL. Cette information n'est pas utile sous
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_null_call</structfield> <type>yes_or_no</type>
       </para>
       <para>
        Si la fonction renvoie automatiquement NULL si un de ces arguments est
        NULL, alors <literal>YES</literal>, sinon <literal>NO</literal>. NULL
        pour une procédure.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>sql_path</structfield> <type>character_data</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>schema_level_routine</structfield> <type>yes_or_no</type>
       </para>
       <para>
        Toujours <literal>YES</literal>. (L'opposé serait une méthode d'un type
        utilisateur, fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>max_dynamic_result_sets</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_user_defined_cast</structfield> <type>yes_or_no</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_implicitly_invocable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>security_type</structfield> <type>character_data</type>
       </para>
       <para>
        Si la fonction est exécutée avec les droits de l'utilisateur courant,
        alors <literal>INVOKER</literal>. Si la fonction est exécutée avec les
        droits de l'utilisateur l'ayant définie, alors <literal>DEFINER</literal>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>to_sql_specific_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>to_sql_specific_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>to_sql_specific_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>as_locator</structfield> <type>yes_or_no</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>created</structfield> <type>time_stamp</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>last_altered</structfield> <type>time_stamp</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>new_savepoint_level</structfield> <type>yes_or_no</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_udt_dependent</structfield> <type>yes_or_no</type>
       </para>
       <para>
        Actuellement toujours <literal>NO</literal>.
        <literal>YES</literal> s'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_from_data_type</structfield> <type>character_data</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_as_locator</structfield> <type>yes_or_no</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_char_max_length</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_char_octet_length</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_char_set_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_char_set_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_char_set_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_collation_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_collation_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_collation_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_numeric_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_numeric_precision_radix</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_numeric_scale</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_datetime_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_interval_type</structfield> <type>character_data</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_interval_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_type_udt_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_type_udt_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_type_udt_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_scope_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_scope_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_scope_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_maximum_cardinality</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>result_cast_dtd_identifier</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-schemata">
  <title><literal>schemata</literal></title>

  <para>
   La vue <literal>schemata</literal> contient tous les schémas de la base de
   données courante auxquels l'utilisateur courant a accès (soit en étant le
   propriétaire soit en ayant des privilèges).
  </para>

  <table>
   <title>Colonnes de <structname>schemata</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>catalog_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données dans laquelle se trouve le schéma (toujours
        la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>schema_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>schema_owner</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du propriétaire du schéma
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>default_character_set_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>default_character_set_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>default_character_set_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>sql_path</structfield> <type>character_data</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sequences">
  <title><literal>sequences</literal></title>

  <para>
   La vue <literal>sequences</literal> contient toutes les séquences définies
   dans la base courante. Seules sont affichées les séquences auxquelles
   l'utilisateur courant a accès (qu'il en soit le propriétaire ou dispose de
   privilèges).
  </para>

  <table>
   <title>Colonnes de <structname>sequences</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>sequence_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base qui contient la séquence (toujours la base en cours)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>sequence_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la séquence
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>sequence_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la séquence
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>data_type</structfield> <type>character_data</type>
       </para>
       <para>
        Type de données de la séquence.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Cette colonne contient la précision (déclarée ou implicite) du type de
        données de la séquence (voir ci-dessus). La précision indique le
        nombre de chiffres significatifs. Elle peut être exprimée en décimal
        (base 10) ou en binaire (base 2), suivant ce qui est indiqué dans la
        colonne <literal>numeric_precision_radix</literal>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_precision_radix</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Cette colonne indique dans quelle base les valeurs de la colonne
        <literal>numeric_precision</literal> et <literal>numeric_scale</literal>
        sont exprimées, 2 ou 10.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_scale</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Cette colonne contient l'échelle (déclarée ou implicite) du type de
        données de la séquence (voir ci-dessus). L'échelle indique le nombre
        de chiffres significatifs à droite du point décimale. Elle peut être
        exprimée en décimal (base 10) ou en binaire (base 2), suivant ce qui
        est indiqué dans la
        colonne <literal>numeric_precision_radix</literal>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>start_value</structfield> <type>character_data</type>
       </para>
       <para>
        La valeur de démarrage de la séquence
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>minimum_value</structfield> <type>character_data</type>
       </para>
       <para>
        La valeur minimale de la séquence
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>maximum_value</structfield> <type>character_data</type>
       </para>
       <para>
        La valeur maximale de la séquence
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>increment</structfield> <type>character_data</type>
       </para>
       <para>
        L'incrément de la séquence
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>cycle_option</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si la séquence est cyclique,
        <literal>NO</literal> dans le cas contraire
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Notez qu'en accord avec le standard SQL, les valeurs de démarrage,
   minimale, maximale et d'incrément sont renvoyées en tant que chaînes
   de caractères.
  </para>
 </sect1>

 <sect1 id="infoschema-sql-features">
  <title><literal>sql_features</literal></title>

  <para>
   La table <literal>sql_features</literal> contient des informations sur les
   fonctionnalités officielles définies dans le standard SQL et supportées par
   <productname>PostgreSQL</productname>. Ce sont les mêmes informations que
   celles présentées dans l'<xref linkend="features"/>. D'autres informations
   de fond y sont disponibles.
  </para>

  <table>
   <title>Colonnes de <structname>sql_features</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>feature_id</structfield> <type>character_data</type>
       </para>
       <para>
        Chaîne identifiant la fonctionnalité
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>feature_name</structfield> <type>character_data</type>
       </para>
       <para>
        Nom descriptif de la fonctionnalité
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>sub_feature_id</structfield> <type>character_data</type>
       </para>
       <para>
        Chaîne identifiant la sous-fonctionnalité ou chaîne de
        longueur NULL s'il ne s'agit pas d'une sous-fonctionnalité
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>sub_feature_name</structfield> <type>character_data</type>
       </para>
       <para>
        Nom descriptif de la sous-fonctionnalité ou chaîne de
        longueur NULL s'il ne s'agit pas d'une sous-fonctionnalité
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_supported</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si la fonctionnalité est complètement supportée
        par la version actuelle de <productname>PostgreSQL</productname>, <literal>NO</literal> sinon
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_verified_by</structfield> <type>character_data</type>
       </para>
       <para>
        Toujours NULL car le groupe de développement
        <productname>PostgreSQL</productname> ne réalise pas de tests formels
        sur la conformité des fonctionnalités
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>comments</structfield> <type>character_data</type>
       </para>
       <para>
        Un commentaire éventuel sur le statut du support de la
        fonctionnalité
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-implementation-info">
  <title><literal>sql_implementation_info</literal></title>

  <para>
   La table <literal>sql_inplementation_info</literal> contient des
   informations sur différents aspects que le standard SQL laisse à la
   discrétion de l'implantation. Ces informations n'ont de réel intérêt que dans
   le contexte de l'interface ODBC&nbsp;; les utilisateurs
   des autres interfaces leur trouveront certainement peu d'utilité.
   Pour cette raison, les éléments décrivant l'implantation
   ne sont pas décrits ici&nbsp;; ils se trouvent dans la
   description de l'interface ODBC.
  </para>

  <table>
   <title>Colonnes de <structname>sql_implementation_info</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>implementation_info_id</structfield> <type>character_data</type>
       </para>
       <para>
        Chaîne identifiant l'élément d'information d'implantation
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>implementation_info_name</structfield> <type>character_data</type>
       </para>
       <para>
        Nom descriptif de l'élément d'information d'implantation
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>integer_value</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Valeur de l'élément d'information d'implantation, ou NULL si la valeur
        est contenue dans la colonne <literal>character_value</literal>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_value</structfield> <type>character_data</type>
       </para>
       <para>
        Valeur de l'élément d'information d'implantation, ou NULL si la valeur
        est contenue dans la colonne
        <literal>integer_value</literal>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>comments</structfield> <type>character_data</type>
       </para>
       <para>
        Un commentaire éventuel de l'élément d'information
        d'implantation
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-parts">
  <title><literal>sql_parts</literal></title>

  <para>
   La table <literal>sql_parts</literal> contient des informations sur les
   parties du standard SQL supportées par <productname>PostgreSQL</productname>.
  </para>

  <table>
   <title>Colonnes de <structname>sql_parts</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>feature_id</structfield> <type>character_data</type>
       </para>
       <para>
        Une chaîne d'identification contenant le numéro de la partie
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>feature_name</structfield> <type>character_data</type>
       </para>
       <para>
        Nom descriptif de la partie
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_supported</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si cette partie est complètement supportée par la
        version actuelle de <productname>PostgreSQL</productname>,
        <literal>NO</literal> dans le cas contraire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_verified_by</structfield> <type>character_data</type>
       </para>
       <para>
        Toujours NULL, car les développeurs <productname>PostgreSQL</productname>
        ne testent pas officiellement la conformité des fonctionnalités
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>comments</structfield> <type>character_data</type>
       </para>
       <para>
        Commentaires sur le statut du support de la partie
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-sizing">
  <title><literal>sql_sizing</literal></title>

  <para>
   La table <literal>sql_sizing</literal> contient des informations sur les
   différentes limites de tailles et valeurs maximales dans
   <productname>PostgreSQL</productname>. Ces informations ont pour contexte
   principal l'interface ODBC&nbsp;; les utilisateurs
   des autres interfaces leur trouveront probablement peu d'utilité.
   Pour cette raison, les éléments de taille individuels ne sont
   pas décrits ici&nbsp;; ils se trouvent dans la description de l'interface
   ODBC.
  </para>

  <table>
   <title>Colonnes de <structname>sql_sizing</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>sizing_id</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Identifiant de l'élément de taille
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>sizing_name</structfield> <type>character_data</type>
       </para>
       <para>
        Nom descriptif de l'élément de taille
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>supported_value</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Valeur de l'élément de taille, ou 0 si la taille est illimitée ou ne
        peut pas être déterminée, ou NULL si les fonctionnalités pour lesquelles
        l'élément de taille est applicable ne sont pas supportées
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>comments</structfield> <type>character_data</type>
       </para>
       <para>
        Un commentaire éventuel de l'élément de taille
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-table-constraints">
  <title><literal>table_constraints</literal></title>

  <para>
   La vue <literal>table_constraints</literal> contient toutes les contraintes
   appartenant aux tables possédées par l'utilisateur courant ou pour lesquelles
   l'utilisateur courant dispose de certains droits différents de SELECT.
  </para>

  <table>
   <title>Colonnes de <structname>table_constraints</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la contrainte (toujours la
        base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la contrainte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la table (toujours la base de
        données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la table
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>constraint_type</structfield> <type>character_data</type>
       </para>
       <para>
        Type de contrainte&nbsp;: <literal>CHECK</literal>,
        <literal>FOREIGN KEY</literal>, <literal>PRIMARY KEY</literal>
        ou <literal>UNIQUE</literal>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_deferrable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si la contrainte peut être différée,
        <literal>NO</literal> sinon
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>initially_deferred</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si la contrainte, qui peut être différée,
        est initialement différée, <literal>NO</literal> sinon
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>enforced</structfield> <type>yes_or_no</type>
       </para>
       <para>
        S'applique à une fonctionnalite non disponible dans
        <productname>PostgreSQL</productname> (actuellement, toujours à
        <literal>YES</literal>)
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-table-privileges">
  <title><literal>table_privileges</literal></title>

  <para>
   La vue <literal>table_privileges</literal> identifie tous les privilèges
   accordés, à un rôle actif ou par une rôle actif, sur des tables ou vues.
   Il y a une ligne par combinaison table, donneur, bénéficiaire.
  </para>

  <table>
   <title>Colonnes de <structname>table_privileges</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantor</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle qui a accordé le privilège
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantee</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle bénéficiaire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la table (toujours la base de
        données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la table
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>privilege_type</structfield> <type>character_data</type>
       </para>
       <para>
        Type de privilège&nbsp;: <literal>SELECT</literal>,
        <literal>INSERT</literal>, <literal>UPDATE</literal>,
        <literal>DELETE</literal>, <literal>TRUNCATE</literal>,
        <literal>REFERENCES</literal> ou <literal>TRIGGER</literal>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_grantable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si le droit peut être transmis,
        <literal>NO</literal> sinon
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>with_hierarchy</structfield> <type>yes_or_no</type>
       </para>
       <para>
        Dans le standard SQL, <literal>WITH HIERARCHY OPTION</literal>
        est un (sous-)droit séparé autorisant certaines opérations sur
        la hiérarchie de l'héritage des tables. Dans PostgreSQL, ceci est
        inclus dans le droit <literal>SELECT</literal>, donc cette
        colonne affiche <literal>YES</literal> si le droit est
        <literal>SELECT</literal>, et <literal>NO</literal> sinon.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="infoschema-tables">
  <title><literal>tables</literal></title>

  <para>
   La vue <literal>tables</literal> contient toutes les tables et vues définies
   dans la base de données courantes. Seules sont affichées les tables et vues
   auxquelles l'utilisateur courant a accès (parce qu'il en est le
   propriétaire ou qu'il possède certains privilèges).
  </para>

  <table>
   <title>Colonnes de <structname>tables</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la table (toujours la base de
        données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la table
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_type</structfield> <type>character_data</type>
       </para>
       <para>
        Type de table&nbsp;: <literal>BASE TABLE</literal> pour une table de
        base persistante (le type de table normal), <literal>VIEW</literal> pour
        une vue, <literal>FOREIGN</literal> pour une table distante
        ou <literal>LOCAL TEMPORARY</literal> pour une table temporaire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>self_referencing_column_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>reference_generation</structfield> <type>character_data</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>user_defined_type_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Si la table est une table typée, le nom de la base de données qui
        contient le type de données sous-jacent (toujours la base de données
        actuel), sinon NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>user_defined_type_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Si la table est une table typée, le nom du schéma qui contient le type
        de données sous-jacent, sinon NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>user_defined_type_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Si la table est une table typée, le nom du type de données sous-jacent,
        sinon NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_insertable_into</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> s'il est possible d'insérer des données dans la
        table, <literal>NO</literal> dans le cas contraire. (Il est toujours
        possible d'insérer des données dans une table de base, pas forcément
        dans les vues.)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_typed</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si la table est une table typée,
        <literal>NO</literal> dans le cas contraire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>commit_action</structfield> <type>character_data</type>
       </para>
       <para>
        Pas encore implémenté
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-transforms">
  <title><literal>transforms</literal></title>

  <para>
   La vue <literal>transforms</literal> contient des informations sur les
   transformations définies dans la base de données courante. Plus
   précisément, il contient une ligne pour chaque fonction contenue dans une
   transformation (la fonction <quote>from SQL</quote> ou <quote>to
    SQL</quote>).
  </para>

  <table>
   <title>Colonnes de <structname>transforms</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant le type ciblé par la transformation
        (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant le type ciblé par la transformation
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du type ciblé par la transformation
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données contenant la fonction (toujours la base de
        données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant la fonction
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Le <quote>nom spécifique</quote> de la fonction. Voir <xref
        linkend="infoschema-routines"/> pour plus d'informations.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>group_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Le standard SQL autorise la définition de transformations en
        <quote>groupes</quote>, et la sélection d'un groupe à l'exécution.
        PostgreSQL ne supporte pas cela. À la place, les transformations sont
        spécifiques à un langage. Comme compromis, ce champ contient le langage
        concernant cette transformation.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>transform_type</structfield> <type>character_data</type>
       </para>
       <para>
        <literal>FROM SQL</literal> ou <literal>TO SQL</literal>
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-triggered-update-columns">
  <title><literal>triggered_update_columns</literal></title>

  <para>
   Pour les triggers de la base de données actuelle qui spécifient une liste
   de colonnes (comme <literal>UPDATE OF colonne1, colonne2</literal>), la
   vue <literal>triggered_update_columns</literal> identifie ces colonnes.
   Les triggers qui ne spécifient pas une liste de colonnes ne sont pas
   inclus dans cette vue. Seules sont affichées les colonnes que l'utilisateur
   actuel possède ou que l'utilisateur a des droits autre que <literal>SELECT</literal>.
  </para>

  <table>
   <title>Colonnes de <structname>triggered_update_columns</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>trigger_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient le déclencheur (toujours la
        base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>trigger_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient le déclencheur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>trigger_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du déclencheur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>event_object_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la table sur laquelle est défini le déclencheur
        (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>event_object_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la table sur laquelle est défini le
        déclencheur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>event_object_table</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table sur laquelle est défini le déclencheur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>event_object_column</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la colonne sur laquelle est défini le déclencheur
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-triggers">
  <title><literal>triggers</literal></title>

  <para>
   La vue <literal>triggers</literal> contient tous les triggers définis dans
   la base de données actuelles sur les tables et vues que l'utilisateur actuel
   possède ou sur lesquels il a d'autres droits que le <literal>SELECT</literal>.
  </para>

  <table>
   <title>Colonnes de <structname>triggers</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>trigger_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base contenant le trigger (toujours la base de
        données actuelle)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>trigger_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant le trigger
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>trigger_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du trigger
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>event_manipulation</structfield> <type>character_data</type>
       </para>
       <para>
        Événement qui déclenche le trigger (<literal>INSERT</literal>,
        <literal>UPDATE</literal> ou <literal>DELETE</literal>)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>event_object_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base contenant la table où le trigger est défini (toujours
        la base de données actuelle)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>event_object_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la table où le trigger est défini
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>event_object_table</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table où le trigger est défini
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>action_order</structfield> <type>cardinal_number</type>
       </para>
       <para>
        Déclencher parmi les triggers sur la même table qui ont les mêmes
        <literal>event_manipulation</literal>, <literal>action_timing</literal>
        et <literal>action_orientation</literal>. Dans
        <productname>PostgreSQL</productname>, les triggers sont déclenchés
        dans l'ordre des noms, et cette colonne reflète cela.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>action_condition</structfield> <type>character_data</type>
       </para>
       <para>
        La condition <literal>WHEN</literal> du trigger, NULL si aucun
        (NULL aussi si la table n'appartient pas à un rôle actuellement activé)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>action_statement</structfield> <type>character_data</type>
       </para>
       <para>
        Instruction exécutée par le déclencheur (actuellement toujours
        <literal>EXECUTE FUNCTION
         <replaceable>fonction</replaceable>(...)</literal>)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>action_orientation</structfield> <type>character_data</type>
       </para>
       <para>
        Indique si le déclencheur est exécuté une fois par ligne
        traitée ou une fois par instruction (<literal>ROW</literal> ou
        <literal>STATEMENT</literal>)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>action_timing</structfield> <type>character_data</type>
       </para>
       <para>
        Moment où le trigger se déclenche (<literal>BEFORE</literal>,
        <literal>AFTER</literal> ou <literal>INSTEAD OF</literal>)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>action_reference_old_table</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table de transition <quote>old</quote>, ou NULL sinon
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>action_reference_new_table</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table de transition <quote>new</quote>, ou NULL sinon
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>action_reference_old_row</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>action_reference_new_row</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>created</structfield> <type>time_stamp</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les déclencheurs dans <productname>PostgreSQL</productname> ont deux
   incompatibilités avec le standard SQL qui affectent leur représentation dans le
   schéma d'information.
  </para>

  <para>
   Premièrement, les noms des déclencheurs sont locaux à chaque
   table sous <productname>PostgreSQL</productname>, et ne sont pas des objets
   du schéma indépendants. De ce fait, il peut exister des déclencheurs de même
   noms au sein d'un schéma, pour peu qu'ils s'occupent de tables différentes.
   (<literal>trigger_catalog</literal> et <literal>trigger_schema</literal> sont
   les champs qui décrivent effectivement la table sur laquelle est défini le
   déclencheur.)
  </para>

  <para>
   Deuxièmement, les déclencheurs peuvent être définis pour
   s'exécuter sur plusieurs événements sous
   <productname>PostgreSQL</productname> (c'est-à-dire <literal>ON INSERT OR
    UPDATE</literal>) alors que le standard SQL n'en autorise qu'un. Si un
   déclencheur est défini pour s'exécuter sur plusieurs événements, il est
   représenté sur plusieurs lignes dans le schéma d'information, une pour chaque
   type d'événement.
  </para>

  <para>
   En conséquence, la clé primaire de la vue <literal>triggers</literal> est en fait
   <literal>(trigger_catalog, trigger_schema, event_object_table,
    trigger_name, event_manipulation)</literal> et non <literal>(trigger_catalog,
    trigger_schema, trigger_name)</literal> comme le spécifie le standard SQL.
   Néanmoins, si les déclencheurs sont définis de manière conforme au
   standard SQL (des noms de déclencheurs uniques dans le schéma et un seul
   type d'événement par déclencheur), il n'y a pas lieu de se préoccuper de ces
   deux incompatibilités.
  </para>

  <note>
   <para>
    Avant <productname>PostgreSQL</productname> 9.1, les colonnes
    <structfield>action_timing</structfield>,
    <structfield>action_reference_old_table</structfield>,
    <structfield>action_reference_new_table</structfield>,
    <structfield>action_reference_old_row</structfield> et
    <structfield>action_reference_new_row</structfield> de cette vue
    étaient nommées respectivement
    <structfield>condition_timing</structfield>,
    <structfield>condition_reference_old_table</structfield>,
    <structfield>condition_reference_new_table</structfield>,
    <structfield>condition_reference_old_row</structfield> et
    <structfield>condition_reference_new_row</structfield>. Cela
    reflétaient leur nommage dans le standard SQL:1999. Le nouveau
    nommage est conforme à SQL:2003 et les versions ultérieures.
   </para>
  </note>
 </sect1>

 <sect1 id="infoschema-udt-privileges">
  <title><literal>udt_privileges</literal></title>

  <para>
   La vue view <literal>udt_privileges</literal> identifie les
   droits <literal>USAGE</literal> donnés pour des types définis par l'utilisateur
   pour lesquels celui qui donne le droit et celui qui le reçoit sont des rôles
   actuellement activés. Il existe une ligne par chaque combinaison de colonne,
   rôle récupérant le droit, rôle donnant le droit. Cette vue affiche seulement les
   types composites (pour comprendre pourquoi, voir <xref
   linkend="infoschema-user-defined-types"/>&nbsp;; voir <xref
   linkend="infoschema-usage-privileges"/> pour les droits sur les domaines.
  </para>

  <table>
   <title>Colonnes de <structname>udt_privileges</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantor</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle donnant le droit
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantee</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle recevant le droit
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base contenant le type (actuellement toujours la base de
        données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant le type
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>udt_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du type
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>privilege_type</structfield> <type>character_data</type>
       </para>
       <para>
        Toujours <literal>TYPE USAGE</literal>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_grantable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> s'il est possible de donner le droit,
        <literal>NO</literal> sinon
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-usage-privileges">
  <title><literal>usage_privileges</literal></title>

  <para>
   La vue <literal>usage_privileges</literal> identifie les
   privilèges d'<literal>USAGE</literal> accordés sur différents objets à un rôle
   actif ou par un rôle actif. Sous <productname>PostgreSQL</productname>,
   cela s'applique aux domaines. Puisqu'il n'y a pas de réels
   privilèges sur les domaines sous <productname>PostgreSQL</productname>,
   cette vue est affiche les privilèges <literal>USAGE</literal> implicitement
   octroyés à <literal>PUBLIC</literal> pour tous les collationnements, domaines, wrappers de
   données distantes, serveurs distants et séquences. Il y a une ligne pour chaque
   combinaison d'objet, de donneur et de receveur.
  </para>

  <para>
   Comme les collationnements n'ont pas de vrais droits dans
   <productname>PostgreSQL</productname>, cette vue affiche des droits
   <literal>USAGE</literal> implicites, non donnables à d'autres, et
   donnés par le propriétaire à <literal>PUBLIC</literal> pour tous les
   collationnements. Les autres types d'objets affichent néanmoins de vrais droits.
  </para>

  <para>
   Dans PostgreSQL, les séquences supportent aussi les droits
   <literal>SELECT</literal> et <literal>UPDATE</literal> en plus du droit
   <literal>USAGE</literal>. Ils ne sont pas dans le standard et du coup ils
   ne sont pas visibles dans le schéma d'informations.
  </para>

  <table>
   <title>Colonnes de <structname>usage_privileges</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantor</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle qui a donné ce droit
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantee</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du rôle auquel ce droit a été donné
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>object_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient l'objet (toujours la base
        de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>object_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient l'objet, si applicable,
        sinon une chaîne vide
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>object_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de l'objet
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>object_type</structfield> <type>character_data</type>
       </para>
       <para>
        <literal>COLLATION</literal>, <literal>DOMAIN</literal>,
        <literal>FOREIGN DATA WRAPPER</literal> <literal>FOREIGN
         SERVER</literal> ou <literal>SEQUENCE</literal>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>privilege_type</structfield> <type>character_data</type>
       </para>
       <para>
        Toujours <literal>USAGE</literal>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_grantable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si le droit peut être donné,
        <literal>NO</literal> dans le cas contraire
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-user-defined-types">
  <title><literal>user_defined_types</literal></title>

  <para>
   La vue <literal>user_defined_types</literal> contient actuellement tous
   les types composites définis dans la base de données courante. Seuls
   sont montrés les types auxquels l'utilisateur courant a accès
   (parce qu'il en est le propriétaire soit parce qu'il dispose de
   certains droits).
  </para>

  <para>
   SQL connaît deux genres de types définis par les utilisateurs&nbsp;: les
   types structurés (aussi connu sous le nom de types composites dans
   <productname>PostgreSQL</productname>) et les types distincts (non
   implémentés dans <productname>PostgreSQL</productname>). Pour être prêt,
   utilisez la colonne <literal>user_defined_type_category</literal> pour
   les différencier. Les autres types définis par l'utilisateur comme les
   types de base et les énumérations, qui sont des extensions
   <productname>PostgreSQL</productname>, ne sont pas affichés ici. Pour les
   domaines, voir <xref linkend="infoschema-domains"/>.
  </para>

  <table>
   <title>Colonnes de <structname>user_defined_types</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>user_defined_type_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient ce type (toujours la base
        de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>user_defined_type_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma contenant ce type
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>user_defined_type_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du type
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>user_defined_type_category</structfield> <type>character_data</type>
       </para>
       <para>
        Actuellement, toujours <literal>STRUCTURED</literal>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_instantiable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_final</structfield> <type>yes_or_no</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ordering_form</structfield> <type>character_data</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ordering_category</structfield> <type>character_data</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ordering_routine_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ordering_routine_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ordering_routine_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>reference_type</structfield> <type>character_data</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>data_type</structfield> <type>character_data</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_maximum_length</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_octet_length</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>character_set_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collation_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_precision_radix</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>numeric_scale</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datetime_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>interval_type</structfield> <type>character_data</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>interval_precision</structfield> <type>cardinal_number</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>source_dtd_identifier</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ref_dtd_identifier</structfield> <type>sql_identifier</type>
       </para>
       <para>
        S'applique à une fonctionnalité non disponible dans
        <productname>PostgreSQL</productname>
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-user-mapping-options">
  <title><literal>user_mapping_options</literal></title>

  <para>
   La vue <literal>user_mapping_options</literal> contient toutes les options
   définies pour les correspondances d'utilisateur définies dans la base de
   données en cours. Seules sont affichées les correspondances pour lesquelles
   le serveur distant correspondant peut être accédé par l'utilisateur
   connecté (qu'il en soit le propriétaire ou qu'il ait quelques droits dessus).
  </para>

  <table>
   <title>Colonnes de <structname>user_mapping_options</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>authorization_identifier</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de l'utilisateur,
        ou <literal>PUBLIC</literal> si la correspondance est publique
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_server_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données dans laquelle est défini le serveur
        distant correspondant (toujours la base de données en cours)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_server_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du serveur distant utilisé par cette correspondance
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>option_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom d'une option
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>option_value</structfield> <type>character_data</type>
       </para>
       <para>
        Valeur de l'option. Cette colonne s'affichera comme NULL sauf si
        l'utilisateur connecté est l'utilisateur en cours de correspondance ou
        si la correspondance est pour <literal>PUBLIC</literal> et que l'utilisateur
        connecté est le propriétaire de la base de données ou un super-utilisateur.
        Le but est de protéger les informations de mot de passe stockées comme
        option.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-user-mappings">
  <title><literal>user_mappings</literal></title>

  <para>
   La vue <literal>user_mappings</literal> contient toutes les correspondances
   utilisateurs définies dans la base de données en cours. Seules sont affichées
   les correspondances pour lesquelles le serveur distant correspondant peut
   être accédé par l'utilisateur connecté (qu'il en soit le propriétaire ou
   qu'il ait quelques droits dessus).
  </para>

  <table>
   <title>Colonnes de <structname>user_mappings</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>authorization_identifier</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de l'utilisateur en cours de correspondance ou
        <literal>PUBLIC</literal> si la correspondance est publique
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_server_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données dans laquelle est défini le serveur
        distant correspondant (toujours la base de données en cours)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>foreign_server_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du serveur distant utilisé par cette correspondance
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-column-usage">
  <title><literal>view_column_usage</literal></title>

  <para>
   La vue <literal>view_column_usage</literal> identifie toutes les colonnes
   utilisées dans l'expression de la requête d'une vue (l'instruction
   <command>SELECT</command> définissant la vue). Une colonne n'est incluse que
   si la table contenant la colonne appartient à un rôle actif.
  </para>

  <note>
   <para>
    Les colonnes des tables système ne sont pas incluses. Cela sera
    probablement corrigé un jour.
   </para>
  </note>

  <table>
   <title>Colonnes de <structname>view_column_usage</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>view_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la vue (toujours la
        base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>view_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la vue
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>view_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la vue
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la table qui contient la colonne
        utilisée par la vue (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la table qui contient la colonne utilisée par la vue
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table qui contient la colonne utilisée par la vue
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>column_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la colonne utilisée par la vue
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-routine-usage">
  <title><literal>view_routine_usage</literal></title>

  <para>
   La vue <literal>view_routine_usage</literal> identifie toutes les
   routines (fonctions et procédures) utilisées dans la requête d'une
   vue (l'instruction <command>SELECT</command> qui définit la vue). Une routine
   n'est incluse que si la routine appartient à un rôle actif.
  </para>

  <table>
   <title>Colonnes de <structname>view_routine_usage</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base qui contient la vue (toujours la base en cours)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la vue
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la vue
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base qui contient la fonction (toujours la base en cours)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la fonction
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>specific_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Le <quote>nom spécifique</quote> de la fonction. Voir <xref
        linkend="infoschema-routines"/> pour plus d'informations.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-table-usage">
  <title><literal>view_table_usage</literal></title>

  <para>
   La vue <literal>view_table_usage</literal> identifie toutes les tables
   utilisées dans l'expression de la requête d'une vue (l'instruction
   <command>SELECT</command> définissant la vue). Une table n'est incluse que
   son propriétaire est un rôle actif.
  </para>

  <note>
   <para>
    Les tables système ne sont pas incluses. Cela sera probablement corrigé un
    jour.
   </para>
  </note>

  <table>
   <title>Colonnes de <structname>view_table_usage</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>view_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la vue (toujours la base
        de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>view_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la vue
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>view_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la vue
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la table utilisée par la vue
        (toujours la base de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la table utilisée par la vue
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la table utilisée par la vue
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-views">
  <title><literal>views</literal></title>

  <para>
   La vue <literal>views</literal> contient toutes les vues définies dans la
   base de données courantes. Seules sont affichées les vues auxquelles
   l'utilisateur a accès (parce qu'il en est le propriétaire ou qu'il dispose
   de privilèges).
  </para>

  <table>
   <title>Colonnes de <structname>views</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_catalog</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la base de données qui contient la vue (toujours la base
        de données courante)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_schema</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom du schéma qui contient la vue
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>table_name</structfield> <type>sql_identifier</type>
       </para>
       <para>
        Nom de la vue
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>view_definition</structfield> <type>character_data</type>
       </para>
       <para>
        Expression de la requête définissant la vue (NULL si la vue n'appartient
        pas à un rôle actif)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>check_option</structfield> <type>character_data</type>
       </para>
       <para>
        <literal>CASCADED</literal> ou <literal>LOCAL</literal> si la vue est
        définie avec l'option <literal>CHECK OPTION</literal>,
        <literal>NONE</literal> dans le cas contraire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_updatable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si la vue est actualisable (autorise
        <command>UPDATE</command> et <command>DELETE</command>),
        <literal>NO</literal> dans le cas contraire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_insertable_into</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> s'il est possible d'insérer des données dans la
        vue (autorise <command>INSERT</command>), <literal>NO</literal> dans le
        cas contraire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_trigger_updatable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si la vue dispose d'un trigger
        <literal>INSTEAD OF</literal> pour l'opération
        <command>UPDATE</command>, <literal>NO</literal> dans le cas
        contraire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_trigger_deletable</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si la vue dispose d'un trigger
        <literal>INSTEAD OF</literal> pour l'opération
        <command>DELETE</command>, <literal>NO</literal> dans le cas
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_trigger_insertable_into</structfield> <type>yes_or_no</type>
       </para>
       <para>
        <literal>YES</literal> si la vue dispose d'un trigger
        <literal>INSTEAD OF</literal> pour l'opération
        <command>INSERT</command>, <literal>NO</literal> dans le cas
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

</chapter>
