<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="information-schema">
 <title>Schéma d'information</title>

 <indexterm zone="information-schema">
  <primary>schéma d'information</primary>
 </indexterm>

 <para>
  Le schéma d'information consiste en un ensemble de vues contenant des
  informations sur les objets définis dans la base de données courante. Le
  schéma d'information est défini dans le standard SQL et, donc
  supposé portable et stable &mdash; contrairement aux catalogues système qui
  sont spécifiques à <productname>PostgreSQL</productname> et modelés suivant
  l'implantation. Néanmoins, les vues du schéma d'information ne contiennent
  pas d'informations sur les fonctionnalités spécifiques à
  <productname>PostgreSQL</productname>&nbsp;; pour cela, on utilise
  catalogues système et autres vues spécifiques à
  <productname>PostgreSQL</productname>.
 </para>

 <note>
  <para>
   En demandant des informations sur les contraintes dans la base de
   données, il est possible qu'une requête conforme au standard
   s'attendant à ne récupérer qu'une ligne en récupère en fait plusieurs.
   Ceci est dû au fait que le standard SQL requiert que les noms des
   contraintes soient uniques dans un même schéma mais
   <productname>PostgreSQL</productname> ne force pas cette
   restriction. Les noms de contraintes créés automatiquement par
   <productname>PostgreSQL</productname> évitent les doublons dans le
   le même schéma mais les utilisateurs peuvent spécifier explicitement
   des noms existant déjà.
  </para>

  <para>
   Ce problème peut apparaître lors de la consultation de vues du
   schéma d'informations, comme par exemple
   <literal>check_constraint_routine_usage</literal>,
   <literal>check_constraints</literal>,
   <literal>domain_constraints</literal> et
   <literal>referential_constraints</literal>. Certaines autres
   vues ont des problèmes similaires mais contiennent le nom de la table
   pour aider à distinguer les lignes dupliquées, par exemple
   <literal>constraint_column_usage</literal>,
   <literal>constraint_table_usage</literal>,
   <literal>table_constraints</literal>.
  </para>
 </note>


 <sect1 id="infoschema-schema">
  <title>Le schéma</title>

  <para>
   Le schéma d'information est lui-même un schéma nommé 
   <literal>information_schema</literal>. Ce schéma existe automatiquement dans
   toutes les bases de données. Le propriétaire de ce schéma est l'utilisateur
   initial du cluster. Il a naturellement
   tous les droits sur ce schéma, dont la possibilité de le supprimer
   (mais l'espace gagné ainsi sera minuscule).
  </para>

  <para>
   Par défaut, le schéma d'information n'est pas dans le chemin de recherche
   des schémas. Il est donc nécessaire d'accéder à tous les objets qu'il contient
   via des noms qualifiés. Comme les noms de certains objets du schéma
   d'information sont des noms génériques pouvant survenir dans les applications
   utilisateur, il convient d'être prudent avant de placer le schéma
   d'information dans le chemin.
  </para>
 </sect1>

 <sect1 id="infoschema-datatypes">
  <title>Types de données</title>

  <para>
   Les colonnes des vues du schéma d'information utilisent des types de 
   données spéciaux, définis dans le schéma d'information. Ils sont définis
   comme des domaines simples sur des types internes. Vous  normal, il est
   préférable de ne pas utiliser ces types en dehors du schéma d'information, 
   mais les applications doivent pouvoir les utiliser si des sélections sont
   faites dans le schéma d'information.
  </para>

  <para>
   Ces types sont&nbsp;:

   <variablelist>
    <varlistentry>
     <term><type>cardinal_number</type></term>
     <listitem>
      <para>
       Un entier non négatif.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>character_data</type></term>
     <listitem>
      <para>
       Une chaîne de caractères (sans longueur maximale indiquée).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>sql_identifier</type></term>
     <listitem>
      <para>
       Une chaîne de caractères. Elle est utilisée pour les identifiants SQL,
       le type de données <type>character_data</type> est utilisé pour tout
       autre type de données texte.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>time_stamp</type></term>
     <listitem>
      <para>
       Un domaine au-dessus du type <type>timestamp with time zone</type>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>yes_or_no</type></term>
     <listitem>
      <para>
       Un domaine dont le type correspond à une chaîne de caractères, qui
       contient soit <literal>YES</literal> soit <literal>NO</literal>. C'est
       utilisé pour représenter des données booléennes (true/false) dans le
       schéma d'informations. (Le schéma d'informations était inventé avant
       l'ajout du type <type>boolean</type> dans le standard SQL, donc cette
       convention est nécessaire pour conserver la compatibilité avec le
       schéma d'informations.)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Chaque colonne du schéma d'information est de l'un des ces cinq types.
  </para>
 </sect1>

 <sect1 id="infoschema-information-schema-catalog-name">
  <title><literal>information_schema_catalog_name</literal></title>

  <para>
   <literal>information_schema_catalog_name</literal> est une table qui
   contient en permanence une ligne et une colonne contenant le nom de la base
   de données courante (catalogue courant dans la terminologie SQL).
  </para>

  <table>
   <title>Colonnes de <literal>information_schema_catalog_name</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>catalog_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant ce schéma
        d'informations</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-administrable-role-authorizations">
  <title><literal>administrable_role_authorizations</literal></title>

  <para>
   La vue <literal>administrable_role_authorizations</literal>
   identifie tous les rôles pour lesquelles l'utilisateur courant possède l'option
   ADMIN.
  </para>

  <table>
   <title>Colonnes de <literal>administrable_role_authorizations</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du rôle pour lequel cette appartenance de rôle a été donnée
       (peut être l'utilisateur courant ou un rôle différent dans le cas
       d'appartenances de rôles imbriquées).
      </entry>
     </row>

     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom d'un rôle</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>Toujours <literal>YES</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-applicable-roles">
  <title><literal>applicable_roles</literal></title>

  <para>
   La vue <literal>applicable_roles</literal> identifie tous les rôles dont
   l'utilisateur courant peut utiliser les droits. Cela signifie qu'il y a
   certaines chaînes de donnation des droits de l'utilisateur courant au
   rôle en question. L'utilisateur lui-même est un rôle applicable.
   L'ensemble de rôles applicables est habituellement utilisé pour la
   vérification des droits.
   <indexterm><primary>applicable role</primary></indexterm>
   <indexterm><primary>role</primary><secondary>applicable</secondary></indexterm>
  </para>

  <table>
   <title>Colonnes de <literal>applicable_roles</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.4*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du rôle à qui cette appartenance a été donnée (peut être
       l'utilisateur courant ou un rôle différent dans le cas d'appartenances
       de rôles imbriquées)
      </entry>
     </row>

     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom d'un rôle</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> si le bénéficiaire a l'option ADMIN sur le rôle,
       <literal>NO</literal> dans le cas contraire
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-attributes">
  <title><literal>attributes</literal></title>

  <para>
   La vue <literal>attributes</literal> contient des informations sur les
   attributs des types de données composites définis dans la base.
   (La vue ne donne pas d'informations sur les colonnes de table,
   qui sont quelque fois appelées attributs dans le contexte de PostgreSQL.)
   Seuls ces attributs sont affichés plutôt que ceux auxquels l'utilisateur
   courant a accès (s'il est le propriétaire ou a des droits sur le type).
  </para>

  <table>
   <title>Colonnes de <literal>attributes</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base contenant le type de données (toujours la base
       courante)</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le type de données</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du type de données</entry>
     </row>

     <row>
      <entry><literal>attribute_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de l'attribut</entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Position de l'attribut dans le type de données (le décompte commence
       à 1)</entry>
     </row>

     <row>
      <entry><literal>attribute_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Expression par défaut de l'attribut</entry>
     </row>

     <row>
      <entry><literal>is_nullable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> si l'attribut peut être NULL,
       <literal>NO</literal> dans le cas contraire.
      </entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de données de l'attribut s'il s'agit d'un type interne ou
       <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas, voir
       la vue <literal>element_types</literal>), sinon
       <literal>USER-DEFINED</literal> (dans ce cas, le type est identifié
       dans <literal>attribute_udt_name</literal> et les colonnes associées).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un caractère ou une chaîne
       de bits, la longueur maximale déclarée&nbsp;; NULL pour tous les autres
       types de données ou si aucune longueur maximale n'a été déclarée.
      </entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type caractère,
       la longueur maximale en octets (bytes) d'un datum&nbsp;; NULL pour tous
       les autres types de données. La longueur maximale en octets dépend de
       la longueur maximum déclarée en caractères (voir ci-dessus) et
       l'encodage du serveur.
      </entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible avec
       <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible avec
       <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible avec
       <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base contenant le collationnement de l'attribut
       (toujours la base de données courante), NULL s'il s'agit du
       collationnement par défaut ou si le type de données de l'attribut
       ne peut pas avoir de collationnement
      </entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma contenant le collationnement de l'attribut, NULL s'il s'agit du
       collationnement par défaut ou si le type de données de l'attribut
       ne peut pas avoir de collationnement
      </entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du collationnement de l'attribut, NULL s'il s'agit du
       collationnement par défaut ou si le type de données de l'attribut
       ne peut pas avoir de collationnement
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type numérique, cette colonne
       contient la précision (déclarée ou implicite) du type pour cet attribut.
       La précision indique le nombre de chiffres significatifs. Elle peut être
       exprimée en décimal (base 10) ou en binaire (base 2) comme le précise la
       colonne <literal>numeric_precision_radix</literal>. Pour tous les autres
       types de données, cette colonne vaut NULL.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type numérique, cette colonne
       indique la base d'expression des colonnes <literal>numeric_precision</literal>
       et <literal>numeric_scale</literal>. La valeur est soit 2 soit 10. Pour
       tous les autres types de données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type numérique exact,
       cette colonne contient l'échelle (déclarée ou implicite) du type pour cet
       attribut. L'échelle indique le nombre de chiffres significatifs à droite
       du point décimal. Elle peut être exprimée en décimal (base 10) ou en
       binaire (base 2) comme le précise la colonne
       <literal>numeric_precision_radix</literal>. Pour tous les autres types
       de données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie une date, une heure, un
       horodatage ou un interval, cette colonne contient la précision en
       secondes (déclarée ou implicite) pour cet attribut, c'est-à-dire le
       nombre de chiffres décimaux suivant le point décimal de la valeur
       en secondes. Pour tous les autres types de données, cette colonne
       est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type d'intervalle,
       cette colonne contient la spécification des champs que les intervalles
       incluent pour cet attribut, par exemple <literal>YEAR TO
       MONTH</literal>, <literal>DAY TO SECOND</literal>, etc. Si aucune
       restriction de champs n'est spécifiée (autrement dit, l'intervalle
       accepte tous les champs) et pour tous les autres types de données,
       ce champ est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname> (voir
       <literal>datetime_precision</literal> pour la précision en fraction
       des secondes des attributs du type d'intervalle)
      </entry>
     </row>

     <row>
      <entry><literal>attribute_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base dans laquelle le type de données de l'attribut est défini (toujours
       la base courante)
      </entry>
     </row>

     <row>
      <entry><literal>attribute_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma dans lequel le type de données de l'attribut est défini
      </entry>
     </row>

     <row>
      <entry><literal>attribute_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du type de données de l'attribut
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car les tableaux ont toujours une cardinalité maximale
       dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Un identifiant du descripteur du type de données de la colonne, unique
       parmi les descripteurs de types de données de la table. Ceci est
       principalement utile pour des jointures avec d'autres instances de tels
       identifiants. (Le format spécifique de l'identifiant n'est pas défini
       et il n'est pas garanti qu'il reste identique dans les versions futures.)
      </entry>
     </row>

     <row>
      <entry><literal>is_derived_reference_attribute</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Voir aussi dans <xref linkend="infoschema-columns"/>, une vue structurée de
   façon similaire, pour plus d'informations sur certaines colonnes.
  </para>
 </sect1>

 <sect1 id="infoschema-character-sets">
  <title><literal>character_sets</literal></title>

  <para>
   La vue <literal>character_sets</literal> identifie les jeux de
   caractères disponibles pour la base de données courante. Comme
   PostgreSQL ne supporte pas plusieurs jeux de caractères dans une
   base de données, cette vue n'en affiche qu'une, celle qui correspond
   à l'encodage de la base de données.
  </para>

  <para>
   Les termes suivants sont utilisés dans le standard SQL&nbsp;:
   <variablelist>
    <varlistentry>
     <term>répertoire de caractères (<foreignphrase>character repertoire</foreignphrase></term>
     <listitem>
      <para>
       Un ensemble abstrait de caractères, par exemple
       <literal>UNICODE</literal>, <literal>UCS</literal> ou
       <literal>LATIN1</literal>. Non exposé en tant qu'objet SQL mais
       visible dans cette vue.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>forme d'encodage de caractères (<foreignphrase>character encoding form</foreignphrase>)</term>
     <listitem>
      <para>
       Un encodage d'un certain répertoire de caractères. La plupart
       des anciens répertoires de caractères utilisent seulement un
       encodage. Du coup, il n'y a pas de noms séparés pour eux (par
       exemple <literal>LATIN1</literal> est une forme d'encodage
       applicable au répertoire <literal>LATIN1</literal>). Par contre,
       Unicode dispose des formats d'encodage <literal>UTF8</literal>,
       <literal>UTF16</literal>, etc. (ils ne sont pas tous supportés
       par PostgreSQL). Les formes d'encodage ne sont pas exposés comme
       un objet SQL mais ils sont visibles dans cette vue.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>jeu de caractères (<foreignphrase>character set</foreignphrase>)</term>
     <listitem>
      <para>
       Un objet SQL nommé qui identifie un répertoire de caractères, un
       encodage de caractères et un collationnement par défaut. Un jeu
       de caractères prédéfini aura généralement le même nom qu'une
       forme d'endodage mais les utilisateurs peuvent définir d'autres
       noms. Par exemple, le jeu de caractères <literal>UTF8</literal>
       identifiera typiquement le répertoire des caractères
       <literal>UCS</literal>, la forme d'encodage <literal>UTF8</literal>
       et un collationnement par défaut.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Dans PostgreSQL, un <quote>encodage</quote> peut être vu comme un
   jeu de caractères ou une forme d'encodage des caractères. Ils auront
   le même nom et il n'y en a qu'un dans une base de données.
  </para>

  <table>
   <title>Colonnes de <literal>character_sets</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Les jeux de caractères ne sont pas actuellement implémentés
       comme des objets du schéma, donc cette colonne est NULL.</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Les jeux de caractères ne sont pas actuellement implémentés
       comme des objets du schéma, donc cette colonne est NULL.</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du jeu de caractères, mais affiche actuellement le nom
       de l'encodage de la base de données</entry>
     </row>

     <row>
      <entry><literal>character_repertoire</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Répertoire des caractères, affichant <literal>UCS</literal>
       si l'encodage est <literal>UTF8</literal>, et le nom de
       l'encodage sinon</entry>
     </row>

     <row>
      <entry><literal>form_of_use</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Forme d'encodage des caractères, identique à l'encodage de
       la base de données</entry>
     </row>

     <row>
      <entry><literal>default_collate_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base de données contenant le collationnement par
       défaut (toujours la base de données courante si un collationnement
       est identifié)</entry>
     </row>

     <row>
      <entry><literal>default_collate_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma contenant le collationnement par défaut</entry>
     </row>

     <row>
      <entry><literal>default_collate_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Nom du collationnement par défaut. Il est identifié comme le
       collationnement qui correspond aux paramètres
       <literal>COLLATE</literal> et <literal>CTYPE</literal> pour la
       base de données courante. S'il n'y a pas de collationnement, cette
       colonne, le schéma associé et les colonnes du catalogue sont NULL.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-check-constraint-routine-usage">
  <title><literal>check_constraint_routine_usage</literal></title>

  <para>
   La vue <literal>check_constraint_routine_usage</literal> identifie les
   routines (fonctions et procédures) utilisées par une contrainte de
   vérification. Seules sont présentées les routines qui appartiennent à un rôle
   couramment actif.
  </para>

  <table>
   <title>Colonnes de <literal>check_constraint_routine_usage</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base contenant la contrainte (toujours la base courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la contrainte</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base contenant la fonction (toujours la base courante)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma contenant la fonction</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Le <quote>nom spécifique</quote> de la fonction. Voir <xref
       linkend="infoschema-routines"/> pour plus d'informations.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-check-constraints">
  <title><literal>check_constraints</literal></title>

  <para>
   La vue <literal>check_constraints</literal> contient toutes les contraintes
   de vérification définies sur une table ou un domaine, possédées
   par un rôle couramment actif (le propriétaire d'une table ou d'un domaine est
   le propriétaire de la contrainte).
  </para>

  <table>
   <title>Colonnes de <literal>check_constraints</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base de données contenant la contrainte (toujours la base
        de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la contrainte</entry>
     </row>

     <row>
      <entry><literal>check_clause</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>L'expression de vérification de la contrainte</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-collations">
  <title><literal>collations</literal></title>

  <para>
   La vue <literal>collations</literal> contient les collationnements
   disponibles dans la base de données courante.
  </para>

  <table>
   <title>Colonnes de <literal>collations</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base de données contenant le collationnement
       (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma contenant le collationnement</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du collationnement par défaut</entry>
     </row>

     <row>
      <entry><literal>pad_attribute</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       Toujours <literal>NO PAD</literal> (l'alternative <literal>PAD
       SPACE</literal> n'est pas supportée par PostgreSQL.)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-collation-character-set-applicab">
  <title><literal>collation_character_set_applicability</literal></title>

  <para>
   La vue <literal>collation_character_set_applicability</literal>
   identifie les jeux de caractères applicables aux collationnements
   disponibles. Avec PostgreSQL, il n'existe qu'un jeu de caractères
   par base de données (voir les explications dans <xref
   linkend="infoschema-character-sets"/>), donc cette vue ne fournit
   pas beaucoup d'informations utiles.
  </para>

  <table>
   <title>Colonnes de <literal>collation_character_set_applicability</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base de données contenant le collationnement
       (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma contenant le collationnement</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du collationnement par défaut</entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Les jeux de caractères ne sont pas actuellement implémentés
       comme des objets du schéma, donc cette colonne est NULL.</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Les jeux de caractères ne sont pas actuellement implémentés
       comme des objets du schéma, donc cette colonne est NULL.</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du jeu de caractères</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-domain-usage">
  <title><literal>column_domain_usage</literal></title>

  <para>
   La vue <literal>column_domain_usage</literal> identifie toutes les colonnes
   (d'une table ou d'une vue) utilisant un domaine défini dans la base de
   données courante et possédé par un rôle couramment actif.
  </para>

  <table>
   <title>Colonnes de <literal>column_domain_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant le domaine (toujours la base de
        données courante)</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le domaine</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du domaine</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la table (toujours la base de
        données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-options">
  <title><literal>column_options</literal></title>

  <para>
   La vue <literal>column_options</literal> contient toutes les options
   définies pour les colonnes des tables étrangères de la base de données
   courante. Seules sont montrées les tables étrangères auxquelles l'utilisateur
   courant a accès (soit parce qu'il en est le propriétaire soit parce qu'il
   dispose de certains droits dessus)
  </para>

  <table>
   <title>Colonnes de <literal>column_options</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base contenant la table distance (toujours las base de
        données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table distance</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table distante</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne</entry>
     </row>

     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de l'option</entry>
     </row>

     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Valeur de l'option</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-privileges">
  <title><literal>column_privileges</literal></title>

  <para>
   La vue <literal>column_privileges</literal> identifie tous les droits
   octroyés sur les colonnes à un rôle couramment actif ou par un rôle
   couramment actif. Il existe une ligne pour chaque combinaison colonne,
   donneur (<foreignphrase>grantor</foreignphrase>) et receveur
   (<foreignphrase>grantee</foreignphrase>).
  </para>

  <para>
   Si un droit a été donné sur une table entière, il s'affichera dans cette vue
   comme un droit sur chaque colonne, mais seulement pour les types de droits
   où la granularité par colonne est possible&nbsp;:
   <literal>SELECT</literal>, <literal>INSERT</literal>,
   <literal>UPDATE</literal>, <literal>REFERENCES</literal>.
  </para>

  <table>
   <title>Colonnes de <literal>column_privileges</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle ayant accordé le privilège</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle receveur</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la table qui contient la
      colonne (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la table qui contient la colonne</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table qui contient la colonne</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de privilège&nbsp;: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal> ou
       <literal>REFERENCES</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> si le droit peut être accordé,
<literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="infoschema-column-udt-usage">
  <title><literal>column_udt_usage</literal></title>

  <para>
   La vue <literal>column_udt_usage</literal> identifie toutes les colonnes
   qui utilisent les types de données possédés par un rôle actif.
   Avec <productname>PostgreSQL</productname>, les types de données
   internes se comportent comme des types utilisateur, ils apparaissent
   aussi ici. Voir aussi la <xref linkend="infoschema-columns"/>
   pour plus de détails.
  </para>

  <table>
   <title>Colonnes de <literal>column_udt_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données dans laquelle le type de donnée de la colonne (le type
       sous-jacent du domaine, si applicable) est défini (toujours la base de
       données courante).
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma dans lequel le type de donnée de la colonne (le type
       sous-jacent du domaine, si applicable) est défini.
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du type de données de la colonne (le type sous-jacent du domaine,
       si applicable).
      </entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la table (toujours la base de
       données courante).</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table.</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table.</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-columns">
  <title><literal>columns</literal></title>

  <para>
   La vue <literal>columns</literal> contient des informations sur toutes les
   colonnes de table (et colonnes de vue) de la base. Les colonnes
   système (<literal>oid</literal>, etc.) ne sont pas incluses. Seules les colonnes
   auxquelles l'utilisateur a accès (par propriété ou par
   privilèges) sont affichées.
  </para>

  <table>
   <title>Colonnes de <literal>columns</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la table (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne</entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Position de la colonne dans la table (la numérotation commençant à
       1)</entry>
     </row>

     <row>
      <entry><literal>column_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Expression par défaut de la colonne</entry>
     </row>

     <row>
      <entry><literal>is_nullable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> si la colonne est
       <foreignphrase>NULLable</foreignphrase> (elle admet une absence de
       valeur),
       <literal>NO</literal> dans le cas contraire. La contrainte NOT NULL n'est
       pas la seule façon de définir qu'une colonne n'est pas
       <foreignphrase>NULLable</foreignphrase>.
      </entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le type de données de la colonne, s'il s'agit d'un type interne ou
       <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas,
       voir la vue <literal>element_types</literal>),
       <literal>USER-DEFINED</literal> dans les autres cas (le type est alors identifié
       dans <literal>udt_name</literal> et colonnes associées). Si la
       colonne est fondée sur un domaine, cette colonne est une référence au type
       sous-jacent du domaine (et le domaine est identifié dans
       <literal>domain_name</literal> et colonnes associées).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type chaîne de caractères 
       ou chaîne de bits, la longueur maximale déclarée&nbsp;; NULL pour tous les
       autres types de données ou si aucune longueur maximale n'a été déclarée.
      </entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type caractère, la longueur
       maximale en octets (bytes) d'un datum&nbsp;; NULL pour tous
       les autres types de données. La longueur maximale en octets dépend de
       la longueur maximum déclarée en caractères (voir ci-dessus) et
       l'encodage du serveur.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type numérique, cette
       colonne contient la précision (déclarée ou implicite) du type pour ce
       domaine. La précision indique le nombre de chiffres significatifs.
       Elle peut être exprimée en décimal (base 10) ou en binaire (base 2)
       comme indiqué dans la colonne
       <literal>numeric_precision_radix</literal>. Pour tous les autres types de
       données, la colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type numérique, cette
       colonne indique dans quelle base les valeurs des colonnes
       <literal>numeric_precision</literal> et      
       <literal>numeric_scale</literal> sont exprimées. La valeur est 2
       ou 10. Pour tous les autres types de données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type numeric exact,
       cette colonne contient l'échelle (déclarée ou implicite) du type pour ce
       domaine. L'échelle indique le nombre de chiffres significatifs à la
       droite du point décimal. Elle peut être exprimée en décimal (base 10)
       ou en binaire (base 2), comme indiqué dans la colonne
       <literal>numeric_precision_radix</literal>. Pour tous les autres types de
       données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie une date, une heure, un
       horodatage ou un interval, cette colonne contient la précision en
       secondes (déclarée ou implicite) pour cet attribut, c'est-à-dire le
       nombre de chiffres décimaux suivant le point décimal de la valeur
       en secondes. Pour tous les autres types de données, cette colonne
       est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type d'intervalle,
       cette colonne contient la spécification des champs que les intervalles
       incluent pour cette colonne, par exemple <literal>YEAR TO
       MONTH</literal>, <literal>DAY TO SECOND</literal>, etc. Si aucune
       restriction de champs n'est spécifiée (autrement dit, l'intervalle
       accepte tous les champs) et pour tous les autres types de données,
       ce champ est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname> (voir
       <literal>datetime_precision</literal> pour la précision en fraction
       des secondes des attributs du type d'intervalle)
      </entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base contenant le collationnement de l'attribut
       (toujours la base de données courante), NULL s'il s'agit du
       collationnement par défaut ou si le type de données de l'attribut
       ne peut pas avoir de collationnement
      </entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma contenant le collationnement de l'attribut, NULL s'il s'agit du
       collationnement par défaut ou si le type de données de l'attribut
       ne peut pas avoir de collationnement
      </entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du collationnement de l'attribut, NULL s'il s'agit du
       collationnement par défaut ou si le type de données de l'attribut
       ne peut pas avoir de collationnement
      </entry>
     </row>

     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Si la colonne a un type domaine, le nom de la base de données où le type
       est défini (toujours la base de données courante), sinon NULL.
      </entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Si la colonne a un type domaine, le nom du schéma où le domaine est
       défini, sinon NULL.
      </entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Si la colonne a un type de domaine, le nom du domaine, sinon
       NULL.</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données où le type de données de la colonne (le type
       sous-jacent du domaine, si applicable) est défini (toujours la base de
       données courante).
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma où le type de données de la colonne (le type sous-jacent
       du domaine, si applicable) est défini.
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du type de données de la colonne (le type sous-jacent du domaine,
       si applicable).
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car les tableaux ont toujours une cardinalité 
       maximale illimitée avec <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Un identifiant du descripteur du type de données de la colonne, unique
       parmi les descripteurs de type de données contenus dans la table. Ceci 
       est principalement utile pour joindre d'autres instances de ces
       identifiants. (Le format spécifique de l'identifiant n'est pas défini et
       rien ne permet d'assurer qu'il restera inchangé dans les versions
       futures.)
      </entry>
     </row>

     <row>
      <entry><literal>is_self_referencing</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>is_identity</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
      <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>identity_generation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
      <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>identity_start</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
      <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>identity_increment</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
      <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>identity_maximum</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
      <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>identity_minimum</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
      <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>identity_cycle</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
      <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>is_generated</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
      <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>generation_expression</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
      <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>is_updatable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> si la colonne est actualisable,
       <literal>NO</literal> dans le cas contraire (les colonnes des tables
       sont toujours modifiables, les colonnes des vues ne le sont pas
       nécessairement).
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Puisqu'en SQL les possibilités de définir les types de données sont
   nombreuses, et que <productname>PostgreSQL</productname> offre des
   possibilités supplémentaires, leur représentation dans le schéma
   d'information peut s'avérer complexe. 
  </para>

  <para>
   La colonne <literal>data_type</literal> est supposée identifier le type de
   données interne sous-jacent de la colonne. Avec
   <productname>PostgreSQL</productname>, cela signifie que le type est défini
   dans le schéma du catalogue système <literal>pg_catalog</literal>. Cette
   colonne est utile si l'application sait gérer les
   types internes (par exemple, formater les types numériques différemment
   ou utiliser les données dans les colonnes de précision). Les colonnes
   <literal>udt_name</literal>, <literal>udt_schema</literal> et
   <literal>udt_catalog</literal> identifient toujours le type de données
   sous-jacent de la colonne même si la colonne est basée sur un domaine.
  </para>

  <para>
   Puisque <productname>PostgreSQL</productname> traite les types internes comme des
   types utilisateur, les types internes apparaissent aussi ici.
   Il s'agit d'une extension du standard SQL.
  </para>
  
  <para>
   Toute application conçue pour traiter les données en fonction du type peut
   utiliser ces colonnes, car, dans ce cas, il importe peu de savoir si la
   colonne est effectivement fondée sur un domaine.
   Si la colonne est fondée sur un domaine, l'identité du domaine est
   stockée dans les colonnes <literal>domain_name</literal>,
   <literal>domain_schema</literal> et <literal>domain_catalog</literal>. Pour
   assembler les colonnes avec leurs types de données associés et
   traiter les domaines comme des types séparés, on peut écrire
   <literal>coalesce(domain_name, udt_name)</literal>, etc.
  </para>
 </sect1>

 <sect1 id="infoschema-constraint-column-usage">
  <title><literal>constraint_column_usage</literal></title>

  <para>
   La vue <literal>constraint_column_usage</literal> identifie toutes les
   colonnes de la base de données courante utilisées par des contraintes.
   Seules sont affichées les colonnes contenues dans une table possédée par
   un rôle connecté. Pour une contrainte de vérification, cette vue
   identifie les colonnes utilisées dans l'expression de la vérification. Pour
   une contrainte de clé étrangère, cette vue identifie les colonnes que la clé
   étrangère référence. Pour une contrainte d'unicité ou de clé primaire, cette vue
   identifie les colonnes contraintes.
  </para>

  <table>
   <title>Colonnes de <literal>constraint_column_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données contenant la table contenant la colonne
       utilisée par certaines contraintes (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma contenant la table contenant la colonne utilisée par
       certaines contraintes
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la table contenant la colonne utilisée par certaines contraintes
      </entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la colonne utilisée par certaines contraintes
      </entry>
     </row>

     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la contrainte (toujours la
       base de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la contrainte</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-constraint-table-usage">
  <title><literal>constraint_table_usage</literal></title>

  <para>
   La vue <literal>constraint_table_usage</literal> identifie toutes les
   tables de la base de données courante utilisées par des contraintes et
   possédées par un rôle actuellement activé. (Cela diffère de la vue
   <literal>table_constraints</literal> qui identifie toutes les contraintes
   et la table où elles sont définies.) Pour une contrainte de clé étrangère,
   cette vue identifie la table que la clé étrangère référence. Pour une
   contrainte d'unicité ou de clé primaire, cette vue identifie simplement la table
   à laquelle appartient la contrainte. Les contraintes de vérification et les
   contraintes de non nullité (NOT NULL) ne sont pas incluses dans cette vue.
  </para>

  <table>
   <title>Colonnes de <literal>constraint_table_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données contenant la table utilisée par quelques
       contraintes (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma contenant la table utilisée par quelque contrainte
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table utilisée par quelque contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la contrainte
       (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la contrainte</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-data-type-privileges">
  <title><literal>data_type_privileges</literal></title>

  <para>
   La vue <literal>data_type_privileges</literal> identifie tous les
   descripteurs de type de données auxquels l'utilisateur a accès, parce qu'il en
   est le propriétaire ou parce qu'il dispose de quelque droit sur le
   descripteur. Un descripteur de type de données est créé lorsqu'un type de
   données est utilisé dans la définition d'une colonne de table, d'un domaine ou
   d'une fonction (en tant que paramètre ou code de retour). Il stocke alors quelques
   informations sur l'utilisation du type de données (par exemple la
   longueur maximale déclarée, si applicable). Chaque descripteur de type de
   données se voit affecter un identifiant unique parmi les descripteurs de type de
   données affectés à un objet (table, domaine, fonction). Cette vue n'est
   probablement pas utile pour les applications, mais elle est utilisée pour définir
   d'autres vues dans le schéma d'information.
  </para>

  <table>
   <title>Colonnes de <literal>data_type_privileges</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant l'objet décrit (toujours la
       base de données courante)</entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant l'objet décrit</entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de l'objet décrit</entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le type d'objet décrit&nbsp;: fait partie de
       <literal>TABLE</literal> (le descripteur de type de données concerne une
       colonne de cette table), <literal>DOMAIN</literal> (le descripteur
       concerne ce domaine), <literal>ROUTINE</literal> (le descripteur est lié
       à un type de paramètre ou de code de retour de cette fonction).
      </entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       L'identifiant du descripteur de type de données, unique parmi les
       descripteurs de type de données pour le même objet.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domain-constraints">
  <title><literal>domain_constraints</literal></title>

  <para>
   La vue <literal>domain_constraints</literal> contient toutes les contraintes
   appartenant à des domaines définis dans la base de données courante. Seuls
   sont affichés les contraintes auxquelles l'utilisateur a accès (soit parce qu'il
   en est le propriétaire, soit parce qu'il possède certains droits dessus).
  </para>

  <table>
   <title>Colonnes de <literal>domain_constraints</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la contrainte (toujours la
       base de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la contrainte</entry>
     </row>

     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant le domaine (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le domaine</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du domaine</entry>
     </row>

     <row>
      <entry><literal>is_deferrable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> si la vérification de la contrainte
      peut être différée,
       <literal>NO</literal> sinon</entry>
     </row>

     <row>
      <entry><literal>initially_deferred</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> si la vérification de la contrainte, qui peut
      être différée, est initialement différée, <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domain-udt-usage">
  <title><literal>domain_udt_usage</literal></title>

  <para>
   La vue <literal>domain_udt_usage</literal> identifie tous les domaines
   utilisant les types de données possédés par un rôle actif. 
   Sous <productname>PostgreSQL</productname>, les types de données internes
   se comportent comme des types utilisateur. Ils sont donc inclus ici.
  </para>

  <table>
   <title>Colonnes de <literal>domain_udt_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données de définition du type de données domaine
       (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma de définition du type de données domaine</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du type de données domaine</entry>
     </row>

     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant le domaine (toujours
       la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le domaine</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du domaine</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domains">
  <title><literal>domains</literal></title>

  <para>
   La vue <literal>domains</literal> contient tous les domaines définis dans la
   base de données courante. Seuls sont affichés les domaines auxquels
   l'utilisateur a accès (soit parce qu'il en est le propriétaire, soit parce
   qu'il possède certains droits dessus).
  </para>

  <table>
   <title>Colonnes de <literal>domains</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant le domaine (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le domaine</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du domaine</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de données du domaine s'il s'agit d'un type interne, ou
       <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas, voir la
       vue <literal>element_types</literal>), sinon
       <literal>USER-DEFINED</literal> (dans ce cas, le type est
       identifié dans <literal>udt_name</literal> et comprend des colonnes
       associées).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si le domaine a un type caractère ou chaîne de bits, la longueur
       maximale déclarée&nbsp;; NULL pour tous les autres types de données ou
       si aucune longueur maximale n'a été déclarée.
      </entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si le domaine a un type caractère, la longueur maximale en octets (bytes)
       d'un datum&nbsp;; NULL pour tous
       les autres types de données. La longueur maximale en octets dépend de
       la longueur maximum déclarée en caractères (voir ci-dessus) et
       l'encodage du serveur.
      </entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base contenant le collationnement du domaine
       (toujours la base de données courante), NULL s'il s'agit du
       collationnement par défaut ou si le type de données de l'attribut
       ne peut pas avoir de collationnement
      </entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma contenant le collationnement du domaine, NULL s'il s'agit du
       collationnement par défaut ou si le type de données du domaine
       ne peut pas avoir de collationnement
      </entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du collationnement de la domaine, NULL s'il s'agit du
       collationnement par défaut ou si le type de données du domaine
       ne peut pas avoir de collationnement
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si le domaine a un type numérique, cette colonne contient la précision
       (déclarée ou implicite) du type de cette colonne. Cette précision
       indique le nombre de chiffres significatifs. Elle peut être exprimée en
       décimal (base 10) ou en binaire (base 2), comme indiqué dans la colonne
       <literal>numeric_precision_radix</literal>. Pour les autres types de
       données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si le domaine a un type numérique, cette colonne indique la base des
       valeurs des colonnes <literal>numeric_precision</literal> et
       <literal>numeric_scale</literal>. La valeur est soit 2 soit 10. Pour tous
       les autres types de données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si le domaine contient un type numeric, cette colonne contient l'échelle
       (déclarée ou implicite) du type pour cette colonne. L'échelle indique le
       nombre de chiffres significatifs à droite du point décimal. Elle peut
       être exprimée en décimal (base 10) ou en binaire (base 2), comme indiqué
       dans la colonne <literal>numeric_precision_radix</literal>. Pour tous les
       autres types de données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si le domaine contient un type date, heure ou intervalle, la précision
       déclarée&nbsp;; NULL pour les autres types de données ou si la précision
       n'a pas été déclarée.
      </entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       If <literal>data_type</literal> identifies an interval type,
       this column contains the specification which fields the
       intervals include for this domain, e.g., <literal>YEAR TO
       MONTH</literal>, <literal>DAY TO SECOND</literal>, etc.  If no
       field restrictions were specified (that is, the interval
       accepts all fields), and for all other data types, this field
       is null.
       Si <literal>data_type</literal> identifie un type d'intervalle,
       cette colonne contient la spécification des champs que les intervalles
       incluent pour ce domaine, par exemple <literal>YEAR TO
       MONTH</literal>, <literal>DAY TO SECOND</literal>, etc. Si aucune
       restriction de champs n'est spécifiée (autrement dit, l'intervalle
       accepte tous les champs) et pour tous les autres types de données,
       ce champ est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname> (voir
       <literal>datetime_precision</literal> pour la précision en fraction
       des secondes des domaines de type d'intervalle)
      </entry>
     </row>

     <row>
      <entry><literal>domain_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Expression par défaut du domaine</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données dans laquelle est défini le type de
       données domaine (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma où le type de données domaine est défini</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du type de données domaine</entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car les tableaux n'ont pas de limite maximale de cardinalité 
       dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Un identifiant du descripteur de type de données du domaine, unique
       parmi les descripteurs de type de données restant dans le domaine (ce qui
       est trivial car un domaine contient seulement un descripteur de type de
       données). Ceci est principalement utile pour joindre d'autres instances
       de tels identifiants (le format spécifique de l'identifiant n'est pas
       défini et il n'est pas garanti qu'il restera identique dans les versions
       futures).
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-element-types">
  <title><literal>element_types</literal></title>

  <para>
   La vue <literal>element_types</literal> contient les descripteurs de type 
   de données des éléments de tableaux. Lorsqu'une colonne de table, un
   attribut de type composite, un domaine, un paramètre de fonction ou un
   code de retour de fonction est définie comme un
   type tableau, la vue respective du schéma d'information contient seulement
   <literal>ARRAY</literal> dans la colonne <literal>data_type</literal>. Pour
   obtenir des informations sur le type d'élément du tableau, il est possible
   de joindre la vue respective avec cette vue. Par exemple, pour afficher les
   colonnes d'une table avec les types de données et les types d'élément de
   tableau, si applicable, on peut écrire&nbsp;:
<programlisting>SELECT c.column_name, c.data_type, e.data_type AS element_type
FROM information_schema.columns c LEFT JOIN information_schema.element_types e
     ON ((c.table_catalog, c.table_schema, c.table_name, 'TABLE', c.dtd_identifier)
       = (e.object_catalog, e.object_schema, e.object_name, e.object_type, e.collection_type_identifier))
WHERE c.table_schema = '...' AND c.table_name = '...'
ORDER BY c.ordinal_position;
</programlisting>
   Cette vue n'inclut que les objets auxquels l'utilisateur courant a
   accès, parce que propriétaire ou disposant de quelque privilège.
  </para>

  <table>
   <title>Colonnes de <literal>element_types</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données contenant l'objet qui utilise le tableau
       décrit (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma contenant l'objet utilisant le tableau décrit
      </entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de l'objet utilisant le tableau décrit
      </entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le type de l'objet utilisant le tableau décrit&nbsp;:
       il fait partie de <literal>TABLE</literal> (le tableau est utilisé par
       une colonne de cette table), <literal>USER-DEFINED TYPE</literal> (le
       tableau est utilisé par un attribut de ce type composite),
       <literal>DOMAIN</literal> (le tableau est
       utilisé par ce domaine), <literal>ROUTINE</literal> (le tableau est
       utilisé par un paramètre ou le type du code de retour de cette fonction).
      </entry>
     </row>

     <row>
      <entry><literal>collection_type_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       L'identifiant du descripteur de type de données du tableau décrit.
       Utilisez cette colonne pour faire une jointure avec les colonnes
       <literal>dtd_identifier</literal> des autres vues du schéma
       d'informations.
      </entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le type de données des éléments du tableau s'il s'agit d'un type
       interne, sinon <literal>USER-DEFINED</literal> (dans ce cas, le type est
       identifié comme <literal>udt_name</literal> et dispose de colonnes
       associées).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base contenant le collationnement du type de l'élément
       (toujours la base de données courante), NULL s'il s'agit du
       collationnement par défaut ou si le type de données de l'élément
       ne peut pas avoir de collationnement
      </entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma contenant le collationnement du type de l'élément,
       NULL s'il s'agit du collationnement par défaut ou si le type de
       données de l'élément ne peut pas avoir de collationnement
      </entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du collationnement du type de l'élément, NULL s'il s'agit du
       collationnement par défaut ou si le type de données de l'élément
       ne peut pas avoir de collationnement
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>domain_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Pas encore implanté</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données pour lequel le type de données est défini
       (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma dans lequel est défini le type de données des éléments
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du type de données des éléments
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car les tableaux n'ont pas de limite maximale de
       cardinalité dans <productname>PostgreSQL</productname></entry>
     </row>
 
     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Un identifiant du descripteur de type de données pour cet élément.
       Ceci n'est actuellement pas utile.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-enabled-roles">
  <title><literal>enabled_roles</literal></title>

  <para>
   La vue <literal>enabled_roles</literal> identifie les <quote>rôles
   actuellement actifs</quote>. Les rôles actifs sont définis
   récursivement comme l'utilisateur courant avec tous les rôles qui ont été
   donnés aux rôles activés avec l'héritage automatique. En d'autres termes,
   ce sont les rôles dont l'utilisateur courant est automatiquement membre,
   par héritage direct ou indirect.
   <indexterm><primary>enabled role</primary></indexterm>
   <indexterm><primary>role</primary><secondary>enabled</secondary></indexterm>
  </para>

  <para>
   Pour la vérification des permissions, l'ensemble des <quote>rôles applicables</quote>
   est appliqué, ce qui peut être plus large que l'ensemble des rôles
   actifs. Il est, de ce fait, généralement préférable d'utiliser la vue
   <literal>applicable_roles</literal> à la place de celle-ci&nbsp;; voir aussi
   là.
  </para>

  <table>
   <title>Colonnes de <literal>enabled_roles</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom d'un rôle</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-data-wrapper-options">
  <title><literal>foreign_data_wrapper_options</literal></title>

  <para>
   La vue <literal>foreign_data_wrapper_options</literal> contient toutes
   les options définies par les wrappers de données distantes dans la base de
   données en cours. Seuls les wrappers accessibles par l'utilisateur connecté
   sont affichés (qu'il soit propriétaire ou qu'il ait des droits dessus).
  </para>

  <table>
   <title>Colonnes de <literal>foreign_data_wrapper_options</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_data_wrapper_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données dans laquelle est défini le wrapper
       de données distantes (toujours la base de connexion)</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du wrapper</entry>
     </row>

     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom d'une option</entry>
     </row>

     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Valeur de l'option</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-data-wrappers">
  <title><literal>foreign_data_wrappers</literal></title>

  <para>
   La vue <literal>foreign_data_wrappers</literal> contient tous les wrappers
   de données distantes définis dans le base de données en cours. Seuls sont
   affichés les wrappers pour lesquels l'utilisateur connecté a accès
   (qu'il soit propriétaire ou qu'il ait des droits dessus).
  </para>

  <table>
   <title>Colonnes de <literal>foreign_data_wrappers</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_data_wrapper_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant le wrapper de données
       distantes (toujours la base de données en cours)</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du wrapper</entry>
     </row>

     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du propriétaire du serveur distant</entry>
     </row>

     <row>
      <entry><literal>library_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom du fichier de la bibliothèque implémentant ce wrapper</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Langage utilisé pour implémenter ce wrapper</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-server-options">
  <title><literal>foreign_server_options</literal></title>

  <para>
   La vue <literal>foreign_server_options</literal> contient toutes les options
   définies pour les serveurs distants de la base de données en cours. Ne sont
   affichés que les serveurs distants pour lesquels l'utilisateur connecté a
   des droits (qu'il soit propriétaire ou qu'il ait quelques droits dessus).
  </para>

  <table>
   <title>Colonnes de <literal>foreign_server_options</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant le serveur
       distant (toujours la base de données en cours)</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du serveur distant</entry>
     </row>

     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom d'une option</entry>
     </row>

     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Valeur de l'option</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-servers">
  <title><literal>foreign_servers</literal></title>

  <para>
   La vue <literal>foreign_servers</literal> contient tous les serveurs
   distants définis dans la base en cours. Ne sont
   affichés que les serveurs distants pour lesquels l'utilisateur connecté a
   des droits (qu'il soit propriétaire ou qu'il ait quelques droits dessus).
  </para>

  <table>
   <title>Colonnes de <literal>foreign_servers</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données dans laquelle ce serveur distant est
       défini (toujours la base de données en cours)</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du serveur distant</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient le wrapper de données
       distantes utilisé par le serveur distant (toujours la base de données
       en cours)</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du wrapper de données distantes utilisé par le serveur
       distant</entry>
     </row>

     <row>
      <entry><literal>foreign_server_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Information sur le type de serveur distant, si indiqué lors de la
       création</entry>
     </row>

     <row>
      <entry><literal>foreign_server_version</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Information sur la version de serveur distant, si indiqué lors de
       la création</entry>
     </row>

     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du propriétaire du serveur distant</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-table-options">
  <title><literal>foreign_table_options</literal></title>

  <para>
   La vue <literal>foreign_table_options</literal> contient toutes les
   options définies pour les tables distantes de la base de données
   courante. Seules sont affichées les tables distantes accessibles par
   l'utilisateur courant (soit parce qu'il en est le propriétaire soit
   parce qu'il dispose de droits particuliers).
  </para>

  <table>
   <title>Colonnes de <literal>foreign_table_options</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la table distante
       (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>foreign_table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table distante</entry>
     </row>

     <row>
      <entry><literal>foreign_table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table distante</entry>
     </row>

     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données où le serveur distant est
       défini (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du serveur distant</entry>
     </row>

     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom d'une option</entry>
     </row>

     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Valeur de l'option</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-tables">
  <title><literal>foreign_tables</literal></title>

  <para>
   La vue <literal>foreign_tables</literal> contient toutes les tables
   distantes définies dans la base de données courantes. Seules sont
   affichées les tables distantes accessibles par l'utilisateur courant
   (soit parce qu'il en est le propriétaire soit parce qu'il dispose de
   droits particuliers).
  </para>

  <table>
   <title>Colonnes de <literal>foreign_tables</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la table distante
       (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>foreign_table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table distante</entry>
     </row>

     <row>
      <entry><literal>foreign_table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table distante</entry>
     </row>

     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données où le serveur distant est
       défini (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du serveur distant</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-key-column-usage">
  <title><literal>key_column_usage</literal></title>

  <para>
   La vue <literal>key_column_usage</literal> identifie toutes les colonnes de
   la base de données courante restreintes par une contrainte unique, clé primaire
   ou clé étrangère. Les contraintes de vérification ne sont pas incluses dans
   cette vue. Seules sont affichées les colonnes auxquelles l'utilisateur a accès,
   parce qu'il est le propriétaire de la table ou qu'il dispose de
   quelque privilège.
  </para>

  <table>
   <title>Colonnes de <literal>key_column_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la contrainte (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la contrainte</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données contenant la table contenant la colonne
       contrainte (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma contenant la table contenant la colonne contrainte
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la table contenant la colonne contrainte
      </entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la colonne contrainte
      </entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Position ordinale de la colonne dans la clé de contrainte (la numérotation
       commence à 1)
      </entry>
     </row>

     <row>
      <entry><literal>position_in_unique_constraint</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Pour une contrainte de type clé étrangère, la position ordinale de la
       colonne référencée dans sa contrainte d'unicité (la numérotation commence à
       1)&nbsp;; sinon null
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-parameters">
  <title><literal>parameters</literal></title>

  <para>
   La vue <literal>parameters</literal> contient des informations sur les
   paramètres (arguments) de toutes les fonctions de la base de données
   courante. Seules sont affichées les fonctions auxquelles l'utilisateur
   courant a accès, parce qu'il en est le propriétaire ou qu'il
   dispose de quelque privilège.
  </para>

  <table>
   <title>Colonnes de <literal>parameters</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la fonction (toujours
       la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la fonction</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Le <quote>nom spécifique</quote> de la fonction. Voir la <xref
       linkend="infoschema-routines"/> pour plus d'informations.
      </entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Position ordinale du paramètre dans la liste des arguments de la fonction
       (la numérotation commence à 1)
      </entry>
     </row>

     <row>
      <entry><literal>parameter_mode</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>IN</literal> pour les paramètres en entrée,
       <literal>OUT</literal> pour les paramètres en sortie ou
       <literal>INOUT</literal> pour les paramètres en entrée/sortie.
      </entry>
     </row>

     <row>
      <entry><literal>is_result</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>as_locator</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>parameter_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du paramètre ou NULL si le paramètre n'a pas de nom</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de données du paramètre s'il s'agit d'un type interne, ou
       <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas, voir la
       vue <literal>element_types</literal>), sinon
       <literal>USER-DEFINED</literal> (dans ce cas, le type est identifié dans
       <literal>udt_name</literal> et dispose de colonnes associées).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée
       pour configurer les types de données dans
       <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée
       pour configurer les types de données dans
       <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée
       pour configurer les types de données dans
       <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données sur laquelle est défini le paramètre (toujours la base
       de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma dans lequel est défini le type de données du paramètre
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du type de données du paramètre
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Un identifiant du descripteur de type de données du paramètre, unique
       parmi les descripteurs de type de données restant dans la fonction. Ceci
       est principalement utile pour réaliser une jointure avec les autres
       instances de tels identifiants (le format spécifique de l'identifiant
       n'est pas défini et il n'est pas garanti qu'il reste identique dans les
       prochaines versions).
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-referential-constraints">
  <title><literal>referential_constraints</literal></title>

  <para>
   La vue <literal>referential_constraints</literal> contient toutes les
   contraintes référentielles (clés étrangères) au sein de la base de données
   courante.
   Seuls sont affichés les contraintes pour lesquelles l'utilisateur connecté
   a accès en écriture sur la table référençante (parce qu'il est le
   propriétaire ou qu'il a d'autres droits que <literal>SELECT</literal>).
  </para>

  <table>
   <title>Colonnes de <literal>referential_constraints</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base de données contenant la contrainte
       (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la contrainte</entry>
     </row>

     <row>
      <entry><literal>unique_constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Nom de la base de données contenant la contrainte d'unicité ou de clé
       primaire que la contrainte de clé étrangère référence (toujours la base
       de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>unique_constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Nom du schéma contenant la contrainte d'unicité ou de clé primaire que
       la contrainte de clé étrangère référence
      </entry>
     </row>

     <row>
      <entry><literal>unique_constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Nom de la contrainte d'unicité ou de clé primaire que la contrainte de clé
       étrangère référence
      </entry>
     </row>

     <row>
      <entry><literal>match_option</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       Correspondances de la contrainte de clé étrangère&nbsp;:
       <literal>FULL</literal>, <literal>PARTIAL</literal> ou
       <literal>NONE</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>update_rule</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       Règle de mise à jour associée à la contrainte de clé étrangère&nbsp;:
       <literal>CASCADE</literal>, <literal>SET NULL</literal>,
       <literal>SET DEFAULT</literal>, <literal>RESTRICT</literal> ou
       <literal>NO ACTION</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>delete_rule</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       Règle de suppression associée à la contrainte de clé étrangère&nbsp;:
       <literal>CASCADE</literal>, <literal>SET NULL</literal>,
       <literal>SET DEFAULT</literal>, <literal>RESTRICT</literal> ou
       <literal>NO ACTION</literal>.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-column-grants">
  <title><literal>role_column_grants</literal></title>

  <para>
   La vue <literal>role_column_grants</literal> identifie tous les privilèges
   de colonne octroyés pour lesquels le donneur ou le
   bénéficiaire est un rôle actuellement actif. Plus d'informations sous
   <literal>column_privileges</literal>. La seule différence réelle entre
   cette vue et <literal>column_privileges</literal> est que cette vue omet
   les colonnes qui ont été rendues accessibles à l'utilisateur actuel en
   utilisant la commande GRANT pour <literal>PUBLIC</literal>.
  </para>

  <table>
   <title>Colonnes de <literal>role_column_grants</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a octroyé le privilège</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle bénéficiaire</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la table qui contient la
       colonne (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la table qui contient la colonne</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table qui contient la colonne</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de privilège&nbsp;: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>,
       <literal>REFERENCES</literal> ou <literal>TRIGGER</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> si le droit peut être transmis,
       <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-routine-grants">
  <title><literal>role_routine_grants</literal></title>

  <para>
   La vue <literal>role_routine_grants</literal> identifie tous les privilèges
   de routine octriyés lorsque le donneur ou le bénéficiaire est un rôle actif.
   Plus d'informations sous <literal>routine_privileges</literal>. La seule
   différence réelle entre cette vue et <literal>routine_privileges</literal>
   est que cette vue omet les colonnes qui ont été rendues accessibles à
   l'utilisateur actuel en utilisant la commande GRANT pour <literal>PUBLIC</literal>.
  </para>

  <table>
   <title>Colonnes de <literal>role_routine_grants</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a octroyé le privilège</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle bénéficiaire</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la fonction (toujours
       la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la fonction</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Le <quote>nom spécifique</quote> de la fonction. Voir la <xref
       linkend="infoschema-routines"/> pour plus d'informations.
      </entry>
     </row>

     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la fonction (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la fonction</entry>
     </row>

     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la fonction (peut être dupliqué en cas de
       surcharge)</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours <literal>EXECUTE</literal> (seul type de privilège sur
       les fonctions)</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> si le droit peut être transmis,
       <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-table-grants">
  <title><literal>role_table_grants</literal></title>

  <para>
   La vue <literal>role_table_grants</literal> identifie tous les privilèges de
   tables octroyés lorsque le donneur ou le bénéficiaire est un rôle actif.
   Plus d'informations sous <literal>table_privileges</literal>. La seule
   différence réelle entre
   cette vue et <literal>table_privileges</literal> est que cette vue omet
   les colonnes qui ont été rendues accessibles à l'utilisateur actuel en
   utilisant la commande GRANT pour <literal>PUBLIC</literal>.
  </para>

  <table>
   <title>Colonnes de <literal>role_table_grants</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a octroyé le privilège</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle bénéficiaire</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la table (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type du privilège&nbsp;: <literal>SELECT</literal>,
       <literal>DELETE</literal>, <literal>INSERT</literal>,
       <literal>UPDATE</literal>, <literal>REFERENCES</literal>
       ou <literal>TRIGGER</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> si le droit peut être transmis,
<literal>NO</literal> sinon</entry>
     </row>

     <row>
      <entry><literal>with_hierarchy</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       Dans le standard SQL, <literal>WITH HIERARCHY OPTION</literal>
       est un (sous-)droit séparé autorisant certaines opérations sur
       la hiérarchie de l'héritage des tables. Dans PostgreSQL, ceci est
       inclus dans le droit <literal>SELECT</literal>, donc cette
       colonne affiche <literal>YES</literal> si le droit est
       <literal>SELECT</literal>, et <literal>NO</literal> sinon.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-udt-grants">
  <title><literal>role_udt_grants</literal></title>

  <para>
   La vue view <literal>role_udt_grants</literal> a pour but d'identifier les
   droits <literal>USAGE</literal> donnés pour des types définis par l'utilisateur
   pour lesquels celui qui donne le droit et celui qui le reçoit sont des rôles
   actuellement activés. Plus d'informations sont disponibles dans
   <literal>udt_privileges</literal>. La seule réelle différence entre cette vue
   et <literal>udt_privileges</literal> est que cette vue omet les objets qui
   ont été rendus accessibles à l'utilisateur courant par le biais du
   pseudo-rôle <literal>PUBLIC</literal>. Comme les types de données n'ont pas
   vraiment de droits dans PostgreSQL, et dispose seulement d'un droit implicite
   à <literal>PUBLIC</literal>, cette vue est vide.
  </para>

  <table>
   <title>Colonnes de <literal>role_udt_grants</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Le nom du rôle qui a donné le droit</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Le nom du rôle à qui le droit a été donné</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base contenant le type (toujours la base de données
        courante)</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le type</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du type</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours <literal>TYPE USAGE</literal></entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> si le droit peut être donné, <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-usage-grants">
  <title><literal>role_usage_grants</literal></title>

  <para>
   La vue <literal>role_usage_grants</literal> identifie
   les privilèges d'<literal>USAGE</literal> sur différents types d'objets
   où le donneur ou le receveur des droits est un rôle actuellement activé.
   Plus d'informations sous <literal>usage_privileges</literal>.
   Dans le futur, cette vue pourrait contenir des informations plus utiles.
   La seule différence réelle entre
   cette vue et <literal>usage_privileges</literal> est que cette vue omet
   les colonnes qui ont été rendues accessibles à l'utilisateur actuel en
   utilisant la commande GRANT pour <literal>PUBLIC</literal>.
  </para>

  <table>
   <title>Colonnes de <literal>role_usage_grants</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a octroyé le privilège</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle bénéficiaire</entry>
     </row>

     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient l'objet (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient l'objet, if applicable,
       sinon une chaîne vide</entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de l'objet</entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>COLLATION</literal>, <literal>DOMAIN</literal>, <literal>FOREIGN DATA WRAPPER</literal>,
       <literal>FOREIGN SERVER</literal> ou <literal>SEQUENCE</literal></entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours <literal>USAGE</literal></entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> si le droit peut être transmis,
       <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routine-privileges">
  <title><literal>routine_privileges</literal></title>

  <para>
   La vue <literal>routine_privileges</literal> identifie tous les droits
   sur les fontions à un rôle actuellement activé ou par un rôle actuellement
   activé.
   Il existe une ligne pour chaque combinaison fonction, donneur, bénéficiaire.
  </para>

  <table>
   <title>Colonnes de <literal>routine_privileges</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a accordé le privilège</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle bénéficiaire</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la fonction (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la fonction</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Le <quote>nom spécifique</quote> de la fonction. Voir la <xref
       linkend="infoschema-routines"/> pour plus d'informations.
      </entry>
     </row>

     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la fonction (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la fonction</entry>
     </row>

     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la fonction (peut être dupliqué en cas de
       surcharge)</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours <literal>EXECUTE</literal> (seul priilège de fonctions)</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> si le droit peut être transmis,
       <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="infoschema-routines">
  <title><literal>routines</literal></title>

  <para>
   La vue <literal>routines</literal> contient toutes les fonctions de la base
   de données courante. Seules sont affichées les fonctions auxquelles
   l'utilisateur courant a accès (qu'il en soit le propriétaire ou dispose de
   de privilèges).
  </para>

  <table>
   <title>Colonnes de <literal>routines</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la fonction (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la fonction</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Le <quote>nom spécifique</quote> de la fonction. Ce nom identifie de
       façon unique la fonction dans le schéma, même si le nom réel de la
       fonction est surchargé. Le format du nom spécifique n'est pas défini, il
       ne devrait être utilisé que dans un but de comparaison avec d'autres instances de
       noms spécifiques de routines.
      </entry>
     </row>

     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la fonction (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la fonction</entry>
     </row>

     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la fonction (peut être dupliqué en cas de
       surcharge)</entry>
     </row>

     <row>
      <entry><literal>routine_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours <literal>FUNCTION</literal> (dans le futur, il pourrait y avoir
       d'autres types de routines)
      </entry>
     </row>

     <row>
      <entry><literal>module_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>module_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>module_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de données de retour de la fonction s'il est interne,
       <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas, voir la
       vue <literal>element_types</literal>), sinon
       <literal>USER-DEFINED</literal> (dans ce cas, le type est identifié
       dans <literal>type_udt_name</literal> et dispose de colonnes associées).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées sous <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées sous <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée
       pour configurer les types de données dans
       <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée
       pour configurer les types de données dans
       <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée
       pour configurer les types de données dans
       <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées sous <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées sous <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées sous <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées sous <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées sous <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées sous <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>type_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données dans laquelle est défini le type de données de retour
       de la fonction (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>type_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma dans lequel est défini le type de données de retour
       de la fonction
      </entry>
     </row>

     <row>
      <entry><literal>type_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du type de données de retour de la fonction
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car il n'y a pas de limite maximale à la
      cardinalité des tableaux dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Un identifiant du descripteur de type de données du type de données
       retour, unique parmi les descripteurs de type de données de la
       fonction. Ceci est principalement utile pour la jointure avec d'autres
       instances de tels identifiants (le format spécifique de l'identifiant
       n'est pas défini et il n'est pas certain qu'il restera identique dans les
       versions futures).
      </entry>
     </row>

     <row>
      <entry><literal>routine_body</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Si la fonction est une fonction SQL, alors
       <literal>SQL</literal>, sinon <literal>EXTERNAL</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>routine_definition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le texte source de la fonction (NULL si la fonction n'appartient pas à
       un rôle actif). (Le standard SQL précise que cette colonne n'est 
       applicable que si <literal>routine_body</literal> est
       <literal>SQL</literal>, mais sous <productname>PostgreSQL</productname>
       ce champ contient tout texte source précisé à la création de la
       fonction.)
      </entry>
     </row>

     <row>
      <entry><literal>external_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Si la fonction est une fonction C, le nom externe (link
       symbol) de la fonction&nbsp;; sinon NULL. (Il s'agit de la 
       même valeur que celle affichée dans
       <literal>routine_definition</literal>).
      </entry>
     </row>

     <row>
      <entry><literal>external_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Le langage d'écriture de la fonction</entry>
     </row>

     <row>
      <entry><literal>parameter_style</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours <literal>GENERAL</literal> (le standard SQL définit d'autres
       styles de paramètres qui ne sont pas disponibles avec
       <productname>PostgreSQL</productname>).
      </entry>
     </row>

     <row>
      <entry><literal>is_deterministic</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       Si la fonction est déclarée immuable (déterministe dans le
       standard SQL), alors <literal>YES</literal>, sinon
       <literal>NO</literal>. (Les autres
       niveaux de volatilité disponibles dans
       <productname>PostgreSQL</productname> ne peuvent être récupérés via le schéma
       d'informations).
      </entry>
     </row>

     <row>
      <entry><literal>sql_data_access</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours <literal>MODIFIES</literal>, ce qui signifie que la fonction peut
       modifier les données SQL. Cette information n'est pas utile sous
       <productname>PostgreSQL</productname>.
      </entry>
     </row>

     <row>
      <entry><literal>is_null_call</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       Si la fonction renvoie automatiquement NULL si un de ces arguments est
       NULL, alors <literal>YES</literal>, sinon <literal>NO</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>sql_path</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>schema_level_routine</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       Toujours <literal>YES</literal>. (L'opposé serait une méthode d'un type
       utilisateur, fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>).
      </entry>
     </row>

     <row>
      <entry><literal>max_dynamic_result_sets</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>is_user_defined_cast</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>is_implicitly_invocable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>security_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Si la fonction est exécutée avec les droits de l'utilisateur courant,
       alors <literal>INVOKER</literal>. Si la fonction est exécutée avec les
       droits de l'utilisateur l'ayant définie, alors <literal>DEFINER</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>to_sql_specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>to_sql_specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>to_sql_specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>as_locator</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>created</literal></entry>
      <entry><type>time_stamp</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>last_altered</literal></entry>
      <entry><type>time_stamp</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>new_savepoint_level</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>is_udt_dependent</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       Actuellement toujours <literal>NO</literal>.
       <literal>YES</literal> s'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.
      </entry>
     </row>

     <row>
      <entry><literal>result_cast_from_data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_as_locator</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_char_max_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_char_octet_length</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_char_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_char_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_char_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_datetime_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_type_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_type_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_type_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-schemata">
  <title><literal>schemata</literal></title>

  <para>
   La vue <literal>schemata</literal> contient tous les schémas de la base de
   données courante dont un rôle actif est propriétaire.
  </para>

  <table>
   <title>Colonnes de <literal>schemata</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>catalog_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données dans laquelle se trouve le schéma (toujours
       la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>schema_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma</entry>
     </row>

     <row>
      <entry><literal>schema_owner</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du propriétaire du schéma</entry>
     </row>

     <row>
      <entry><literal>default_character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>default_character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>default_character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>sql_path</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sequences">
  <title><literal>sequences</literal></title>

  <para>
   La vue <literal>sequences</literal> contient toutes les séquences définies
   dans la base courante. Seules sont affichées les séquences auxquelles
   l'utilisateur courant a accès (qu'il en soit le propriétaire ou dispose de
   privilèges).
  </para>

  <table>
   <title>Colonnes de <literal>sequences</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sequence_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base qui contient la séquence (toujours la base en cours)</entry>
     </row>

     <row>
      <entry><literal>sequence_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la séquence</entry>
     </row>

     <row>
      <entry><literal>sequence_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la séquence</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de données de la séquence. Dans
       <productname>PostgreSQL</productname>, c'est toujours
       <literal>bigint</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Cette colonne contient la précision (déclarée ou implicite) du type de
       données de la séquence (voir ci-dessus). La précision indique le
       nombre de chiffres significatifs. Elle peut être exprimée en décimal
       (base 10) ou en binaire (base 2), suivant ce qui est indiqué dans la
       colonne <literal>numeric_precision_radix</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Cette colonne indique dans quelle base les valeurs de la colonne
       <literal>numeric_precision</literal> et <literal>numeric_scale</literal>
       sont exprimées, 2 ou 10.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Cette colonne contient l'échelle (déclarée ou implicite) du type de
       données de la séquence (voir ci-dessus). L'échelle indique le nombre
       de chiffres significatifs à droite du point décimale. Elle peut être
       exprimée en décimal (base 10) ou en binaire (base 2), suivant ce qui
       est indiqué dans la
       colonne <literal>numeric_precision_radix</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>start_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>La valeur de démarrage de la séquence</entry>
      </row>
 
      <row>
       <entry><literal>minimum_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>la valeur minimale de la séquence</entry>
     </row>

     <row>
      <entry><literal>maximum_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>La valeur maximale de la séquence</entry>
      </row>
 
      <row>
       <entry><literal>increment</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>L'incrément de la séquence</entry>
      </row>
 
      <row>
       <entry><literal>cycle_option</literal></entry>
       <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> si la séquence est cyclique,
       <literal>NO</literal> dans le cas contraire</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Notez qu'en accord avec le standard SQL, les valeurs de démarrage,
   minimale, maximale et d'incrément sont renvoyées en tant que chaînes
   de caractères.
  </para>
 </sect1>

 <sect1 id="infoschema-sql-features">
  <title><literal>sql_features</literal></title>

  <para>
   La table <literal>sql_features</literal> contient des informations sur les
   fonctionnalités officielles définies dans le standard SQL et supportées par
   <productname>PostgreSQL</productname>. Ce sont les mêmes informations que
   celles présentées dans l'<xref linkend="features"/>. D'autres informations 
   de fond y sont disponibles.
  </para>

  <table>
   <title>Colonnes de <literal>sql_features</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Chaîne identifiant la fonctionnalité</entry>
     </row>

     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif de la fonctionnalité</entry>
     </row>

     <row>
      <entry><literal>sub_feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Chaîne identifiant la sous-fonctionnalité ou chaîne de
       longueur NULL s'il ne s'agit pas d'une sous-fonctionnalité</entry>
     </row>

     <row>
      <entry><literal>sub_feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif de la sous-fonctionnalité ou chaîne de
       longueur NULL s'il ne s'agit pas d'une sous-fonctionnalité</entry>
     </row>

     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> si la fonctionnalité est complètement supportée
       par la version actuelle de <productname>PostgreSQL</productname>, <literal>NO</literal> sinon
      </entry>
     </row>

     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours NULL car le groupe de développement <productname>PostgreSQL</productname> ne réalise pas
       de tests formels sur la conformité des fonctionnalités
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Un commentaire éventuel sur le statut du support de la
       fonctionnalité</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-implementation-info">
  <title><literal>sql_implementation_info</literal></title>

  <para>
   La table <literal>sql_inplementation_info</literal> contient des
   informations sur différents aspects que le standard SQL laisse à la
   discrétion de l'implantation. Ces informations n'ont de réel intérêt que dans
   le contexte de l'interface ODBC&nbsp;; les utilisateurs
   des autres interfaces leur trouveront certainement peu d'utilité.
   Pour cette raison, les éléments décrivant l'implantation
   ne sont pas décrits ici&nbsp;; ils se trouvent dans la
   description de l'interface ODBC.
  </para>

  <table>
   <title>Colonnes de <literal>sql_implementation_info</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>implementation_info_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Chaîne identifiant l'élément d'information
       d'implantation</entry>
     </row>

     <row>
      <entry><literal>implementation_info_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif de l'élément d'information
       d'implantation</entry>
     </row>

     <row>
      <entry><literal>integer_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Valeur de l'élément d'information d'implantation, ou NULL si la valeur
       est contenue dans la colonne <literal>character_value</literal>
      </entry>
     </row>

     <row>
      <entry><literal>character_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Valeur de l'élément d'information d'implantation, ou NULL si la valeur
       est contenue dans la colonne
       <literal>integer_value</literal>
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Un commentaire éventuel de l'élément d'information
       d'implantation</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-languages">
  <title><literal>sql_languages</literal></title>

  <para>
   La table <literal>sql_languages</literal> contient une ligne par
   langage lié au SQL supporté par <productname>PostgreSQL</productname>.
   <productname>PostgreSQL</productname> supporte le SQL direct et le SQL
   intégré dans le C&nbsp;; cette table ne contient pas d'autre information.
  </para>

  <para>
   Cette table a été supprimée du standard SQL dans SQL:2008, donc il
   n'y a pas d'enregistrements faisant référence aux standards ultérieurs
   à SQL:2003.
  </para>

  <table>
   <title>Colonnes de <literal>sql_languages</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.4*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sql_language_source</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le nom de la source de définition du langage&nbsp;; toujours
       <literal>ISO 9075</literal>, c'est-à-dire le standard SQL
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_year</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       L'année de l'approbation du standard dans
       <literal>sql_language_source</literal>
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_conformance</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le niveau de conformité au standard pour le langage. Pour ISO 9075:2003,
       c'est toujours <literal>CORE</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_integrity</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL (cette valeur n'a d'intérêt que pour les versions
       précédentes du standard SQL).</entry>
     </row>

     <row>
      <entry><literal>sql_language_implementation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL</entry>
     </row>

     <row>
      <entry><literal>sql_language_binding_style</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le style de lien du langage, soit <literal>DIRECT</literal> soit
       <literal>EMBEDDED</literal>
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_programming_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le langage de programmation si le style de lien est
       <literal>EMBEDDED</literal>, sinon NULL.
       <productname>PostgreSQL</productname> ne supporte que
       le langage C.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-packages">
  <title><literal>sql_packages</literal></title>

  <para>
   La table <literal>sql_packages</literal> contient des informations sur les
   paquets de fonctionnalités définis dans le standard SQL supportés par
   <productname>PostgreSQL</productname>. On se référera à l'<xref
   linkend="features"/> pour des informations de base sur les paquets de
   fonctionnalités.
  </para>

  <table>
   <title>Colonnes de <literal>sql_packages</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Chaîne identifiant le paquet</entry>
     </row>

     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif du paquet</entry>
     </row>

     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> si le paquet est complètement supporté par la
       version actuelle, <literal>NO</literal> sinon
      </entry>
     </row>

     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours NULL car le groupe de développement de <productname>PostgreSQL</productname> ne réalise
       pas de tests formels pour la conformité des fonctionnalités
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Un commentaire éventuel sur l'état de support du paquet</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-parts">
  <title><literal>sql_parts</literal></title>

  <para>
   La table <literal>sql_parts</literal> contient des informations sur les
   parties du standard SQL supportées par <productname>PostgreSQL</productname>.
  </para>

  <table>
   <title>Colonnes de <literal>sql_parts</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Une chaîne d'identification contenant le numéro de la partie</entry>
     </row>

     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif de la partie</entry>
     </row>

     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> si cette partie est complètement supportée par la
       version actuelle de <productname>PostgreSQL</productname>,
       <literal>NO</literal> dans le cas contraire
      </entry>
     </row>

     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours NULL, car les développeurs <productname>PostgreSQL</productname>
       ne testent pas officiellement la conformité des fonctionnalités
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Commentaires sur le statut du support de la partie</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-sizing">
  <title><literal>sql_sizing</literal></title>

  <para>
   La table <literal>sql_sizing</literal> contient des informations sur les
   différentes limites de tailles et valeurs maximales dans
   <productname>PostgreSQL</productname>. Ces informations ont pour contexte
   principal l'interface ODBC&nbsp;; les utilisateurs
   des autres interfaces leur trouveront probablement peu d'utilité.
   Pour cette raison, les éléments de taille individuels ne sont
   pas décrits ici&nbsp;; ils se trouvent dans la description de l'interface
   ODBC.
  </para>

  <table>
   <title>Colonnes de <literal>sql_sizing</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sizing_id</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Identifiant de l'élément de taille</entry>
     </row>

     <row>
      <entry><literal>sizing_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif de l'élément de taille</entry>
     </row>

     <row>
      <entry><literal>supported_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Valeur de l'élément de taille, ou 0 si la taille est illimitée ou ne
       peut pas être déterminée, ou NULL si les fonctionnalités pour lesquelles
       l'élément de taille est applicable ne sont pas supportées
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Un commentaire éventuel de l'élément de taille</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-sizing-profiles">
  <title><literal>sql_sizing_profiles</literal></title>

  <para>
   La table <literal>sql_sizing_profiles</literal> contient des informations
   sur les valeurs <literal>sql_sizing</literal> requises par différents profils
   du standard SQL. <productname>PostgreSQL</productname> ne garde pas trace des profils SQL, donc la
   table est vide.
  </para>

  <table>
   <title>Colonnes de <literal>sql_sizing_profiles</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sizing_id</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Identifiant de l'élément de taille</entry>
     </row>

     <row>
      <entry><literal>sizing_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif de l'élément de taille</entry>
     </row>

     <row>
      <entry><literal>profile_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Chaîne identifiant un profil</entry>
     </row>

     <row>
      <entry><literal>required_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       La valeur requise par le profil SQL pour l'élément de taille, ou 0 si
       le profil ne place aucune limite sur l'élément de taille, ou NULL si le
       profil ne requiert aucune fonctionnalité pour laquelle l'élément de
       style est applicable
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Un commentaire éventuel sur l'élément de taille 
       au sein du profil</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-table-constraints">
  <title><literal>table_constraints</literal></title>

  <para>
   La vue <literal>table_constraints</literal> contient toutes les contraintes
   appartenant aux tables possédées par l'utilisateur courant ou pour lesquelles
   l'utilisateur courant dispose de certains droits différents de SELECT.
  </para>

  <table>
   <title>Colonnes de <literal>table_constraints</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la contrainte (toujours la
       base de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la contrainte</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la table (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>constraint_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de contrainte&nbsp;: <literal>CHECK</literal>,
       <literal>FOREIGN KEY</literal>, <literal>PRIMARY KEY</literal>
       ou <literal>UNIQUE</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_deferrable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> si la contrainte peut être différée,
       <literal>NO</literal> sinon</entry>
     </row>

     <row>
      <entry><literal>initially_deferred</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> si la contrainte, qui peut être différée,
       est initialement différée, <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-table-privileges">
  <title><literal>table_privileges</literal></title>

  <para>
   La vue <literal>table_privileges</literal> identifie tous les privilèges
   accordés, à un rôle actif ou par une rôle actif, sur des tables ou vues.
   Il y a une ligne par combinaison table, donneur, bénéficiaire.
  </para>

  <table>
   <title>Colonnes de <literal>table_privileges</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a accordé le privilège</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle bénéficiaire</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la table (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de privilège&nbsp;: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>,
       <literal>REFERENCES</literal> ou <literal>TRIGGER</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> si le droit peut être transmis,
       <literal>NO</literal> sinon</entry>
     </row>

     <row>
      <entry><literal>with_hierarchy</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       Dans le standard SQL, <literal>WITH HIERARCHY OPTION</literal>
       est un (sous-)droit séparé autorisant certaines opérations sur
       la hiérarchie de l'héritage des tables. Dans PostgreSQL, ceci est
       inclus dans le droit <literal>SELECT</literal>, donc cette
       colonne affiche <literal>YES</literal> si le droit est
       <literal>SELECT</literal>, et <literal>NO</literal> sinon.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="infoschema-tables">
  <title><literal>tables</literal></title>

  <para>
   La vue <literal>tables</literal> contient toutes les tables et vues définies
   dans la base de données courantes. Seules sont affichées les tables et vues
   auxquelles l'utilisateur courant a accès (parce qu'il en est le
   propriétaire ou qu'il possède certains privilèges).
  </para>

  <table>
   <title>Colonnes de <literal>tables</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la table (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>table_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de table&nbsp;: <literal>BASE TABLE</literal> pour une table de
       base persistante (le type de table normal), <literal>VIEW</literal> pour
       une vue, <literal>FOREIGN TABLE</literal> pour une table distante
       ou <literal>LOCAL TEMPORARY</literal> pour une table temporaire
      </entry>
     </row>

     <row>
      <entry><literal>self_referencing_column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>reference_generation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Si la table est une table typée, le nom de la base de données qui
       contient le type de données sous-jacent (toujours la base de données
       actuel), sinon NULL.
      </entry>
     </row>

     <row>
      <entry><literal>user_defined_type_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Si la table est une table typée, le nom du schéma qui contient le type
       de données sous-jacent, sinon NULL.
      </entry>
     </row>

     <row>
      <entry><literal>user_defined_type_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Si la table est une table typée, le nom du type de données sous-jacent,
       sinon NULL.
      </entry>
     </row>

     <row>
      <entry><literal>is_insertable_into</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> s'il est possible d'insérer des données dans la
       table, <literal>NO</literal> dans le cas contraire. (Il est toujours
       possible d'insérer des données dans une table de base, pas forcément
       dans les vues.)
      </entry>
     </row>

     <row>
      <entry><literal>is_typed</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> si la table est une table typée,
        <literal>NO</literal> dans le cas contraire</entry>
     </row>

     <row>
      <entry><literal>commit_action</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Pas encore implémenté</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-triggered-update-columns">
  <title><literal>triggered_update_columns</literal></title>

  <para>
   Pour les triggers de la base de données actuelle qui spécifient une liste
   de colonnes (comme <literal>UPDATE OF colonne1, colonne2</literal>), la
   vue <literal>triggered_update_columns</literal> identifie ces colonnes.
   Les triggers qui ne spécifient pas une liste de colonnes ne sont pas
   inclus dans cette vue. Seules sont affichées les colonnes que l'utilisateur
   actuel possède ou que l'utilisateur a des droits autre que <literal>SELECT</literal>.
  </para>

  <table>
   <title>Colonnes de <literal>triggered_update_columns</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>trigger_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient le déclencheur (toujours la
       base de données courante)</entry>
     </row>

     <row>
      <entry><literal>trigger_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient le déclencheur</entry>
     </row>

     <row>
      <entry><literal>trigger_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du déclencheur</entry>
     </row>

     <row>
      <entry><literal>event_object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données qui contient la table sur laquelle est défini le déclencheur
       (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>event_object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la table sur laquelle est défini le
       déclencheur</entry>
     </row>

     <row>
      <entry><literal>event_object_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table sur laquelle est défini le déclencheur</entry>
     </row>

     <row>
      <entry><literal>event_object_column</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the column that the trigger is defined on</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-triggers">
  <title><literal>triggers</literal></title>

  <para>
   La vue <literal>triggers</literal> contient tous les triggers définis dans
   la base de données actuelles sur les tables et vues que l'utilisateur actuel
   possède ou sur lesquels il a d'autres droits que le <literal>SELECT</literal>.
  </para>

  <table>
   <title>Colonnes de <literal>triggers</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>trigger_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base contenant le trigger (toujours la base de
        données actuelle)</entry>
     </row>

     <row>
      <entry><literal>trigger_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le trigger</entry>
     </row>

     <row>
      <entry><literal>trigger_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du trigger</entry>
     </row>

     <row>
      <entry><literal>event_manipulation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Événement qui déclenche le trigger (<literal>INSERT</literal>,
       <literal>UPDATE</literal> ou <literal>DELETE</literal>)
      </entry>
     </row>

     <row>
      <entry><literal>event_object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base contenant la table où le trigger est défini (toujours
       la base de données actuelle)
      </entry>
     </row>

     <row>
      <entry><literal>event_object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la table où le trigger est défini</entry>
     </row>

     <row>
      <entry><literal>event_object_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table où le trigger est défini</entry>
     </row>

     <row>
      <entry><literal>action_order</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Pas encore implanté</entry>
     </row>

     <row>
      <entry><literal>action_condition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       La condition <literal>WHEN</literal> du trigger, NULL si aucun
       (NULL aussi si la table n'appartient pas à un rôle actuellement activé)
      </entry>
     </row>

     <row>
      <entry><literal>action_statement</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Instruction exécutée par le déclencheur (actuellement toujours
       <literal>EXECUTE PROCEDURE
       <replaceable>function</replaceable>(...)</literal>)
      </entry>
     </row>

     <row>
      <entry><literal>action_orientation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Indique si le déclencheur est exécuté une fois par ligne
       traitée ou une fois par instruction (<literal>ROW</literal> ou
       <literal>STATEMENT</literal>)
      </entry>
     </row>

     <row>
      <entry><literal>action_timing</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Moment où le trigger se déclenche (<literal>BEFORE</literal>,
       <literal>AFTER</literal> ou <literal>INSTEAD OF</literal>)
      </entry>
     </row>

     <row>
      <entry><literal>action_reference_old_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>action_reference_new_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>action_reference_old_row</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>action_reference_new_row</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>created</literal></entry>
      <entry><type>time_stamp</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les déclencheurs dans <productname>PostgreSQL</productname> ont deux
   incompatibilités avec le standard SQL qui affectent leur représentation dans le
   schéma d'information.
  </para>
  
  <para>
   Premièrement, les noms des déclencheurs sont locaux à chaque
   table sous <productname>PostgreSQL</productname>, et ne sont pas des objets
   du schéma indépendants. De ce fait, il peut exister des déclencheurs de même
   noms au sein d'un schéma, pour peu qu'ils s'occupent de tables différentes.
   (<literal>trigger_catalog</literal> et <literal>trigger_schema</literal> sont
   les champs qui décrivent effectivement la table sur laquelle est défini le
   déclencheur.)
  </para>
  
  <para>
   Deuxièmement, les déclencheurs peuvent être définis pour
   s'exécuter sur plusieurs événements sous
   <productname>PostgreSQL</productname> (c'est-à-dire <literal>ON INSERT OR
   UPDATE</literal>) alors que le standard SQL n'en autorise qu'un. Si un
   déclencheur est défini pour s'exécuter sur plusieurs événements, il est
   représenté sur plusieurs lignes dans le schéma d'information, une pour chaque
   type d'événement.
  </para>
  
  <para>
   En conséquence, la clé primaire de la vue <literal>triggers</literal> est en fait
   <literal>(trigger_catalog, trigger_schema, event_object_table,
   trigger_name, event_manipulation)</literal> et non <literal>(trigger_catalog,
   trigger_schema, trigger_name)</literal> comme le spécifie le standard SQL.
   Néanmoins, si les déclencheurs sont définis de manière conforme au
   standard SQL (des noms de déclencheurs uniques dans le schéma et un seul
   type d'événement par déclencheur), il n'y a pas lieu de se préoccuper de ces
   deux incompatibilités.
  </para>

  <note>
   <para>
    Avant <productname>PostgreSQL</productname> 9.1, les colonnes
    <structfield>action_timing</structfield>,
    <structfield>action_reference_old_table</structfield>,
    <structfield>action_reference_new_table</structfield>,
    <structfield>action_reference_old_row</structfield> et
    <structfield>action_reference_new_row</structfield> de cette vue
    étaient nommées respectivement
    <structfield>condition_timing</structfield>,
    <structfield>condition_reference_old_table</structfield>,
    <structfield>condition_reference_new_table</structfield>,
    <structfield>condition_reference_old_row</structfield> et
    <structfield>condition_reference_new_row</structfield>. Cela
    reflétaient leur nommage dans le standard SQL:1999. Le nouveau
    nommage est conforme à SQL:2003 et les versions ultérieures.
   </para>
  </note>
 </sect1>

 <sect1 id="infoschema-udt-privileges">
  <title><literal>udt_privileges</literal></title>

  <para>
   La vue view <literal>udt_privileges</literal> identifie les
   droits <literal>USAGE</literal> donnés pour des types définis par l'utilisateur
   pour lesquels celui qui donne le droit et celui qui le reçoit sont des rôles
   actuellement activés. Il existe une ligne par chaque combinaison de colonne,
   rôle récupérant le droit, rôle donnant le droit. Cette vue affiche seulement les
   types composites (pour comprendre pourquoi, voir <xref
   linkend="infoschema-user-defined-types"/>&nbsp;; voir <xref
   linkend="infoschema-usage-privileges"/> pour les droits sur les domaines.
  </para>

  <table>
   <title>Colonnes de <literal>udt_privileges</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle donnant le droit</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle recevant le droit</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base contenant le type (actuellement toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le type</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du type</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours <literal>TYPE USAGE</literal></entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> s'il est possible de donner le droit, <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-usage-privileges">
  <title><literal>usage_privileges</literal></title>

  <para>
   La vue <literal>usage_privileges</literal> identifie les
   privilèges d'<literal>USAGE</literal> accordés sur différents objets à un rôle
   actif ou par un rôle actif. Sous <productname>PostgreSQL</productname>,
   cela s'applique aux domaines. Puisqu'il n'y a pas de réels
   privilèges sur les domaines sous <productname>PostgreSQL</productname>,
   cette vue est affiche les privilèges <literal>USAGE</literal> implicitement
   octroyés à <literal>PUBLIC</literal> pour tous les collationnements, domaines, wrappers de
   données distantes, serveurs distants et séquences. Il y a une ligne pour chaque
   combinaison d'objet, de donneur et de receveur.
  </para>

  <para>
   Comme les collationnements n'ont pas de vrais droits dans
   <productname>PostgreSQL</productname>, cette vue affiche des droits
   <literal>USAGE</literal> implicites, non donnables à d'autres, et
   donnés par le propriétaire à <literal>PUBLIC</literal> pour tous les
   collationnements. Les autres types d'objets affichent néanmoins de vrais droits.
  </para>

  <para>
   Dans PostgreSQL, les séquences supportent aussi les droits
   <literal>SELECT</literal> et <literal>UPDATE</literal> en plus du droit
   <literal>USAGE</literal>. Ils ne sont pas dans le standard et du coup ils
   ne sont pas visibles dans le schéma d'informations.
  </para>

  <table>
   <title>Colonnes de <literal>usage_privileges</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a donné ce droit</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the role that the privilege was granted to</entry>
     </row>

     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient l'objet (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient l'objet, if applicable,
       sinon une chaîne vide</entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de l'objet</entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>COLLATION</literal>, <literal>DOMAIN</literal>, <literal>FOREIGN DATA WRAPPER</literal>
       <literal>FOREIGN SERVER</literal> ou <literal>SEQUENCE</literal></entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours <literal>USAGE</literal></entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> si le droit peut être donné,
       <literal>NO</literal> dans le cas contraire</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>
 
 <sect1 id="infoschema-user-defined-types">
  <title><literal>user_defined_types</literal></title>

  <para>
   La vue <literal>user_defined_types</literal> contient actuellement tous
   les types composites définis dans la base de données courante. Seuls
   sont montrés les types auxquels l'utilisateur courant a accès
   (parce qu'il en est le propriétaire soit parce qu'il dispose de
   certains droits).
  </para>

  <para>
   SQL connaît deux genres de types définis par les utilisateursénbsp;: les
   types structurés (aussi connu sous le nom de types composites dans
   <productname>PostgreSQL</productname>) et les types distincts (non
   implémentés dans <productname>PostgreSQL</productname>). Pour être prêt,
   utilisez la colonne <literal>user_defined_type_category</literal> pour
   les différencier. Les autres types définis par l'utilisateur comme les
   types de base et les énumérations, qui sont des extensions
   <productname>PostgreSQL</productname>, ne sont pas affichés ici. Pour les
   domaines, voir <xref linkend="infoschema-domains"/>.
  </para>

  <table>
   <title>Colonnes de <literal>user_defined_types</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>user_defined_type_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient ce type (toujours la base
        de données courante)</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant ce type</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du type</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_category</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Actuellement, toujours <literal>STRUCTURED</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_instantiable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>is_final</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>ordering_form</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>ordering_category</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>ordering_routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>ordering_routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>ordering_routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>reference_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>source_dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>ref_dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-user-mapping-options">
  <title><literal>user_mapping_options</literal></title>

  <para>
   La vue <literal>user_mapping_options</literal> contient toutes les options
   définies pour les correspondances d'utilisateur définies dans la base de
   données en cours. Seules sont affichées les correspondances pour lesquelles
   le serveur distant correspondant peut être accédé par l'utilisateur
   connecté (qu'il en soit le propriétaire ou qu'il ait quelques droits dessus).
  </para>

  <table>
   <title>Colonnes de <literal>user_mapping_options</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de l'utilisateur,
       ou <literal>PUBLIC</literal> si la correspondance est publique</entry>
     </row>

     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données dans laquelle est défini le serveur
        distant correspondant (toujours la base de données en cours)</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du serveur distant utilisé par cette correspondance</entry>
     </row>

     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom d'une option</entry>
     </row>

     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Valeur de l'option. Cette colonne s'affichera comme NULL sauf si
      l'utilisateur connecté est l'utilisateur en cours de correspondance ou
      si la correspondance est pour <literal>PUBLIC</literal> et que l'utilisateur
      connecté est le propriétaire de la base de données ou un superutilisateur.
      Le but est de protéger les informations de mot de passe stockées comme
      option.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-user-mappings">
  <title><literal>user_mappings</literal></title>

  <para>
   La vue <literal>user_mappings</literal> contient toutes les correspondances
   utilisateurs définies dans la base de données en cours. Seules sont affichées
   les correspondances pour lesquelles le serveur distant correspondant peut
   être accédé par l'utilisateur connecté (qu'il en soit le propriétaire ou
   qu'il ait quelques droits dessus).
  </para>

  <table>
   <title>Colonnes de <literal>user_mappings</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de l'utilisateur en cours de correspondance ou
       <literal>PUBLIC</literal> si la correspondance est publique</entry>
     </row>

     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données dans laquelle est défini le serveur
        distant correspondant (toujours la base de données en cours)</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du serveur distant utilisé par cette correspondance</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-column-usage">
  <title><literal>view_column_usage</literal></title>

  <para>
   La vue <literal>view_column_usage</literal> identifie toutes les colonnes
   utilisées dans l'expression de la requête d'une vue (l'instruction
   <command>SELECT</command> définissant la vue). Une colonne n'est incluse que
   si la table contenant la colonne appartient à un rôle actif.
  </para>

  <note>
   <para>
    Les colonnes des tables système ne sont pas incluses. Cela sera
    probablement corrigé un jour.
   </para>
  </note>

  <table>
   <title>Colonnes de <literal>view_column_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>view_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la vue (toujours la
       base de données courante)</entry>
     </row>

     <row>
      <entry><literal>view_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la vue</entry>
     </row>

     <row>
      <entry><literal>view_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la vue</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données qui contient la table qui contient la colonne
       utilisée par la vue (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma qui contient la table qui contient la colonne utilisée par la vue
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la table qui contient la colonne utilisée par la vue
      </entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne utilisée par la vue</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-routine-usage">
  <title><literal>view_routine_usage</literal></title>

  <para>
   La vue <literal>view_routine_usage</literal> identifie toutes les
   routines (fonctions et procédures) utilisées dans la requête d'une
   vue (l'instruction <command>SELECT</command> qui définit la vue). Une routine
   n'est incluse que si la routine appartient à un rôle actif.
  </para>

  <table>
   <title>Colonnes de <literal>view_routine_usage</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base qui contient la vue (toujours la base en cours)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma qui contient la vue</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la vue</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base qui contient la fonction (toujours la base en cours)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma qui contient la fonction</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Le <quote>nom spécifique</quote> de la fonction. Voir <xref
       linkend="infoschema-routines"/> pour plus d'informations.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-table-usage">
  <title><literal>view_table_usage</literal></title>

  <para>
   La vue <literal>view_table_usage</literal> identifie toutes les tables
   utilisées dans l'expression de la requête d'une vue (l'instruction
   <command>SELECT</command> définissant la vue). Une table n'est incluse que
   son propriétaire est un rôle actif.
  </para>

  <note>
   <para>
    Les tables système ne sont pas incluses. Cela sera probablement corrigé un
    jour.
   </para>
  </note>

  <table>
   <title>Colonnes de <literal>view_table_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>view_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la vue (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>view_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la vue</entry>
     </row>

     <row>
      <entry><literal>view_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la vue</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données qui contient la table utilisée par la vue
       (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma qui contient la table utilisée par la vue
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la table utilisée par la vue
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-views">
  <title><literal>views</literal></title>

  <para>
   La vue <literal>views</literal> contient toutes les vues définies dans la
   base de données courantes. Seules sont affichées les vues auxquelles
   l'utilisateur a accès (parce qu'il en est le propriétaire ou qu'il dispose
   de privilèges).
  </para>

  <table>
   <title>Colonnes de <literal>views</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la vue (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la vue</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la vue</entry>
     </row>

     <row>
      <entry><literal>view definition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Expression de la requête définissant la vue (NULL si la vue n'appartient
       pas à un rôle actif)
      </entry>
     </row>

     <row>
      <entry><literal>check_option</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>is_updatable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> si la vue est actualisable (autorise
       <command>UPDATE</command> et <command>DELETE</command>),
       <literal>NO</literal> dans le cas contraire
      </entry>
     </row>

     <row>
      <entry><literal>is_insertable_into</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> s'il est possible d'insérer des données dans la
       vue (autorise <command>INSERT</command>), <literal>NO</literal> dans le
       cas contraire
      </entry>
     </row>

     <row>
      <entry><literal>is_trigger_updatable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> si la vue dispose d'un trigger
       <literal>INSTEAD OF</literal> pour l'opération
       <command>UPDATE</command>, <literal>NO</literal> dans le cas
       contraire
      </entry>
     </row>

     <row>
      <entry><literal>is_trigger_deletable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> si la vue dispose d'un trigger
       <literal>INSTEAD OF</literal> pour l'opération
       <command>DELETE</command>, <literal>NO</literal> dans le cas
      </entry>
     </row>

     <row>
      <entry><literal>is_trigger_insertable_into</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> si la vue dispose d'un trigger
       <literal>INSTEAD OF</literal> pour l'opération
       <command>INSERT</command>, <literal>NO</literal> dans le cas
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

</chapter>
