<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date: 2010-05-30 19:31:13 +0200 (dim. 30 mai 2010) $
     par      $Author: gleu $
     révision $Revision: 1515 $ -->

<chapter id="plpgsql">
 <title><application>PL/pgSQL</application> - Langage de procédures <acronym>SQL</acronym></title>

 <indexterm zone="plpgsql">
  <primary>PL/pgSQL</primary>
 </indexterm>

 <sect1 id="plpgsql-overview">
  <title>Aperçu</title>

  <para>
   <application>PL/pgSQL</application> est un langage de procédures chargeable
   pour le système de bases de données <productname>PostgreSQL</productname>.
   Les objectifs de la conception de <application>PL/pgSQL</application> ont été de
   créer un langage de procédures chargeable qui

   <itemizedlist>
    <listitem>
     <para>
      est utilisé pour créer des fonctions standards et triggers,
     </para>
    </listitem>
    <listitem>
     <para>
      ajoute des structures de contrôle au langage <acronym>SQL</acronym>,
     </para>
    </listitem>
    <listitem>
     <para>
      permet d'effectuer des traitements complexes,
     </para>
    </listitem>
    <listitem>
     <para>
      hérite de tous les types, fonctions et opérateurs définis par les
      utilisateurs,
     </para>
    </listitem>
    <listitem>
     <para>
      est défini comme digne de confiance par le serveur,
     </para>
    </listitem>
    <listitem>
     <para>
      est facile à utiliser.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Les fonctions <application>PL/pgSQL</application> acceptent un nombre
   variable d'arguments en utilisant le marqueur <literal>VARIADIC</literal>.
   Cela fonctionne exactement de la même façon pour les fonctions SQL, comme
   indiqué dans <xref linkend="xfunc-sql-variadic-functions"/>.
  </para>

  <para>
   Les fonctions écrites en <application>PL/pgSQL</application> peuvent être
   utilisées partout où une fonction intégrée peut l'être.
   Par exemple, il est possible de créer des fonctions complexes de traitement
   conditionnel et, par la suite, de les utiliser pour définir des opérateurs
   ou de les utiliser dans des expressions d'index.
  </para>

  <para>
   À partir de la version 9.0 de <productname>PostgreSQL</productname>,
   <application>PL/pgSQL</application> est installé par défaut.
   Il reste toutefois un module chargeable et les administrateurs craignant
   pour la sécurité de leur instance pourront le retirer.
  </para>

  <sect2 id="plpgsql-advantages">
   <title>Avantages de l'utilisation de <application>PL/pgSQL</application></title>

   <para>
    <acronym>SQL</acronym> est le langage que <productname>PostgreSQL</productname>
    et la plupart des autres bases de données relationnelles utilisent comme
    langage de requête. Il est portable et facile à apprendre, mais chaque
    expression <acronym>SQL</acronym> doit être exécutée individuellement
    par le serveur de bases de données.
   </para>

   <para>
    Cela signifie que votre application client doit envoyer chaque requête
    au serveur de bases de données, attendre que celui-ci la traite, recevoir
    et traiter les résultats, faire quelques calculs, et enfin envoyer d'autres requêtes
    au serveur. Tout ceci induit des communications interprocessus et induit aussi
    une surcharge du réseau si votre client est sur une machine différente
    du serveur de bases de données.
   </para>

   <para>
    Grâce à <application>PL/pgSQL</application> vous pouvez grouper un bloc
    de traitement et une série de requêtes <emphasis>au sein</emphasis> du
    serveur de bases de données, et bénéficier ainsi de la puissance d'un
    langage de procédures, mais avec de gros gains en terme de communication
    client/serveur.
   </para>

   <itemizedlist>

    <listitem><para>Les allers/retours entre le
      client et le serveur sont éliminés</para></listitem>

    <listitem><para>Il n'est pas nécessaire de traiter ou transférer entre le
      client et le serveur les résultats intermédiaires dont le client n'a pas
      besoin</para></listitem>

    <listitem><para>Les va-et-vient des analyses de requêtes peuvent être
      évités</para></listitem>

   </itemizedlist>

   <para>
    Ceci a pour résultat une augmentation considérable des performances
    en comparaison à une application qui n'utilise pas les procédures stockées.
   </para>

   <para>
    Ainsi, avec <application>PL/pgSQL</application> vous pouvez utiliser tous les
    types de données, opérateurs et fonctions du SQL.
   </para>
  </sect2>

  <sect2 id="plpgsql-args-results">
   <title>Arguments supportés et types de données résultats</title>

   <para>
    Les fonctions écrites en <application>PL/pgSQL</application> peuvent accepter
    en argument n'importe quel type de données supporté par le serveur, et
    peuvent renvoyer un résultat de n'importe lequel de ces types. Elles peuvent
    aussi accepter ou renvoyer n'importe quel type composite (type ligne) spécifié
    par nom. Il est aussi possible de déclarer une fonction
    <application>PL/pgSQL</application> renvoyant un type <type>record</type>,
    signifiant que le résultat est un type ligne dont les colonnes sont déterminées
    par spécification dans la requête appelante (voir la
    <xref linkend="queries-tablefunctions"/>).
   </para>

   <para>
    Les fonctions <application>PL/pgSQL</application> acceptent en entrée et
    en sortie les types polymorphes <type>anyelement</type>,
    <type>anyarray</type>, <type>anynonarray</type>, <type>anyenum</type>
    et <type>anyrange</type>.
    Le type de données réel géré par une fonction polymorphe peut varier
    d'appel en appel (voir la <xref linkend="extend-types-polymorphic"/>).
    Voir l'exemple de la <xref linkend="plpgsql-declaration-parameters"/>.
   </para>

   <para>
    Les fonctions <application>PL/pgSQL</application> peuvent aussi renvoyer
    un ensemble de lignes (ou une table) de n'importe lequel des type de
    données dont les fonctions peuvent renvoyer une instance unique. Ces
    fonctions génèrent leur sortie en exécutant <literal>RETURN NEXT</literal>
    pour chaque élément désiré de l'ensemble résultat ou en utilisant
    <command>RETURN QUERY</command> pour afficher le résultat de l'évaluation
    d'une requête.
   </para>

   <para>
    Enfin, une fonction <application>PL/pgSQL</application> peut être déclarée comme renvoyant
    <type>void</type> si elle n'a pas de valeur de retour utile.
   </para>

   <para>
    Les fonctions <application>PL/pgSQL</application> peuvent aussi être déclarées
    avec des paramètres en sortie à la place de la spécification explicite
    du code de retour. Ceci n'ajoute pas de fonctionnalité fondamentale au
    langage mais c'est un moyen agréable principalement pour renvoyer
    plusieurs valeurs.
    La notation <literal>RETURNS TABLE</literal> peut aussi être utilisé à la
    place de <literal>RETURNS SETOF</literal>.
   </para>

   <para>
    Des exemples spécifiques apparaissent dans la
    <xref linkend="plpgsql-declaration-parameters"/> et la
    <xref linkend="plpgsql-statements-returning"/>.
   </para>
  </sect2>
 </sect1>

 <sect1 id="plpgsql-structure">
  <title>Structure de <application>PL/pgSQL</application></title>

  <para>
   <application>PL/pgSQL</application> est un langage structuré en blocs.
   Le texte complet de la définition d'une fonction doit être un
   <firstterm>bloc</firstterm>. Un bloc est défini comme&nbsp;:

   <synopsis><optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>déclarations</replaceable> </optional>
BEGIN
    <replaceable>instructions</replaceable>
END <optional> <replaceable>label</replaceable> </optional>;
   </synopsis>
  </para>

  <para>
   Chaque déclaration et chaque expression au sein du bloc est terminé par un
   point-virgule. Un bloc qui apparaît à l'intérieur d'un autre bloc doit avoir
   un point-virgule après <literal>END</literal> (voir l'exemple ci-dessus)&nbsp;;
   néanmoins, le <literal>END</literal> final qui conclut le corps d'une fonction
   n'a pas besoin de point-virgule.
  </para>

  <tip>
   <para>
    Une erreur habituelle est d'écrire un point-virgule immédiatement
    après <literal>BEGIN</literal>. C'est incorrect et a comme résultat
    une erreur de syntaxe.
   </para>
  </tip>

  <para>
   Un <replaceable>label</replaceable> est seulement nécessaire si vous voulez
   identifier le bloc à utiliser dans une instruction <literal>EXIT</literal>
   ou pour qualifier les noms de variable déclarées dans le bloc. Si un label
   est écrit après <literal>END</literal>, il doit correspondre au label donné
   au début du bloc.
  </para>

  <para>
   Tous les mots clés sont insensibles à la casse. Les identifiants sont
   convertis implicitement en minuscule sauf dans le cas de l'utilisation
   de guillemets doubles. Le comportement est donc identique à celui des
   commandes SQL habituelles.
  </para>

  <para>
   Les commentaires fonctionnent de la même manière tant dans du
   <application>PL/pgSQL</application> que dans le code SQL. Un double tiret
   (<literal>--</literal>) commence un commentaire et celui-ci continue jusqu'à
   la fin de la ligne. Un <literal>/*</literal> commence un bloc de
   commentaire qui continue jusqu'au <literal>*/</literal> correspondant. Les
   blocs de commentaires peuvent imbriquer les uns dans les autres.
  </para>

  <para>
   Chaque expression de la section expression d'un bloc peut être un
   <firstterm>sous-bloc</firstterm>.  Les sous-blocs peuvent être utilisés pour
   des groupements logiques ou pour situer des variables locales dans un petit groupe
   d'instructions. Les variables déclarées dans un sous-bloc masquent toute
   variable nommée de façon similaire dans les blocs externes pendant toute la durée du
   sous-bloc. Cependant, vous pouvez accéder aux variables externes si vous
   qualifiez leur nom du label de leur bloc. Par exemple&nbsp;:
   <programlisting>CREATE FUNCTION une_fonction() RETURNS integer AS $$
&lt;&lt; blocexterne &gt;&gt;
DECLARE
    quantite integer := 30;
BEGIN
    RAISE NOTICE 'quantité vaut ici %', quantite;  -- affiche 30
    quantite := 50;
    --
    -- Crée un sous-bloc
    --
    DECLARE
        quantite integer := 80;
    BEGIN
        RAISE NOTICE 'quantite vaut ici %', quantite;  -- affiche 80
	RAISE NOTICE 'la quantité externe vaut ici %', blocexterne.quantite;  -- affiche 50
    END;

    RAISE NOTICE 'quantité vaut ici %', quantite;  -- affiche 50

    RETURN quantite;
END;
$$ LANGUAGE plpgsql;
   </programlisting>
  </para>

  <note>
   <para>
    Il existe un bloc externe caché entourant le corps de
    toute fonction <application>PL/pgSQL</application>. Ce bloc fournit la
    déclaration des paramètres de la fonction ainsi que quelques variables
    spéciales comme <literal>FOUND</literal> (voir la
    <xref linkend="plpgsql-statements-diagnostics"/>). Le bloc externe a pour
    label le nom de la fonction. Cela a pour conséquence que les paramètres et les
    variables spéciales peuvent être qualifiés du nom de la fonction.
   </para>
  </note>

  <para>
   Il est important de ne pas confondre l'utilisation de
   <command>BEGIN</command>/<command>END</command> pour grouper les instructions dans
   <application>PL/pgSQL</application> avec les commandes pour le
   contrôle des transactions. Les <command>BEGIN</command>/<command>END</command> de
   <application>PL/pgSQL</application> ne servent qu'au groupement&nbsp;; ils ne débutent
   ni ne terminent une transaction. Les fonctions standards et les fonctions triggers
   sont toujours exécutées à l'intérieur d'une transaction établie par une
   requête extérieure &mdash; ils ne peuvent pas être utilisés pour commencer
   ou valider une transaction car ils n'auraient pas de contexte pour s'exécuter.
   Néanmoins, un bloc contenant une clause <literal>EXCEPTION</literal> forme réellement
   une sous-transaction qui peut être annulée sans affecter la transaction
   externe. Pour plus d'informations sur ce point, voir la <xref
   linkend="plpgsql-error-trapping"/>.
  </para>
 </sect1>

 <sect1 id="plpgsql-declarations">
  <title>Déclarations</title>

  <para>
   Toutes les variables utilisées dans un bloc doivent être déclarées dans la
   section déclaration du bloc. Les seules exceptions sont que la variable de
   boucle d'une boucle <literal>FOR</literal> effectuant une itération sur
   des valeurs entières est automatiquement déclarée comme variable entière
   (type integer), et de la même façon une variable de boucle
   <literal>FOR</literal> effectuant une itération sur le résultat d'un
   curseur est automatiquement déclarée comme variable de type
   record.
  </para>

  <para>
   Les variables <application>PL/pgSQL</application> peuvent être de n'importe quel type de données
   tels que <type>integer</type>, <type>varchar</type> et
   <type>char</type>.
  </para>

  <para>
   Quelques exemples de déclaration de variables&nbsp;:
   <programlisting>id_utilisateur integer;
quantité numeric(5);
url varchar;
ma_ligne nom_table%ROWTYPE;
mon_champ nom_table.nom_colonne%TYPE;
une_ligne RECORD;
   </programlisting>
  </para>

  <para>
   La syntaxe générale d'une déclaration de variable est&nbsp;:
   <synopsis><replaceable>nom</replaceable> <optional> CONSTANT </optional> <replaceable>type</replaceable> <optional> COLLATE <replaceable>nom_collationnement</replaceable> </optional> <optional> NOT NULL </optional> <optional> { DEFAULT | := | = } <replaceable>expression</replaceable> </optional>;
   </synopsis>
   La clause <literal>DEFAULT</literal>, si indiquée, spécifie la valeur
   initiale affectée à la variable quand on entre dans le bloc.
   Si la clause <literal>DEFAULT</literal> n'est pas indiquée, la variable
   est initialisée à la valeur <acronym>SQL</acronym> NULL.
   L'option <literal>CONSTANT</literal> empêche la modification de la
   variable après initialisation, de sorte que sa valeur reste constante pour la durée du bloc.
   L'option <literal>COLLATE</literal> indique le collationnement à
   utiliser pour la variable (voir <xref
   linkend="plpgsql-declaration-collation"/>).
   Si <literal>NOT NULL</literal> est spécifié, l'affectation d'une valeur
   NULL aboutira à une erreur d'exécution. Les valeurs par défaut de toutes
   les variables déclarées <literal>NOT NULL</literal> doivent être
   précisées, donc non NULL.
   Le signe d'égalité (<literal>=</literal>) peut être utilisé à la place de
   <literal>:=</literal>, qui lui est conforme au PL/SQL.
  </para>

  <para>
   La valeur par défaut d'une variable est évaluée et affectée à la variable
   à chaque entrée du bloc (pas seulement une fois lors de l'appel de la
   fonction). Ainsi, par exemple, l'affectation de <literal>now()</literal>
   à une variable de type  <type>timestamp</type> donnera à la variable
   l'heure de l'appel de la fonction courante, et non l'heure au moment où
   la fonction a été précompilée.
  </para>

  <para>
   Exemples&nbsp;:
   <programlisting>quantité integer DEFAULT 32;
url varchar := 'http://mysite.com';
id_utilisateur CONSTANT integer := 10;
   </programlisting>
  </para>

  <sect2 id="plpgsql-declaration-parameters">
   <title>Déclarer des paramètres de fonctions</title>

   <para>
    Les paramètres passés aux fonctions sont nommés par les identifiants
    <literal>$1</literal>, <literal>$2</literal>,
    etc.  Éventuellement, des alias peuvent être déclarés pour les noms de paramètres
    de type <literal>$<replaceable>n</replaceable></literal> afin d'améliorer la
    lisibilité. L'alias ou l'identifiant numérique peuvent être utilisés indifféremment
    pour se référer à la valeur du paramètre.
   </para>

   <para>
    Il existe deux façons de créer un alias. La façon préférée est de donner
    un nom au paramètre dans la commande <command>CREATE FUNCTION</command>,
    par exemple&nbsp;:

    <programlisting>CREATE FUNCTION taxe_ventes(sous_total real) RETURNS real AS $$
BEGIN
    RETURN sous_total * 0.06;
END;
$$ LANGUAGE plpgsql;
    </programlisting>
    L'autre façon est de déclarer explicitement un alias en utilisant la
    syntaxe de déclaration&nbsp;:

    <synopsis><replaceable>nom</replaceable> ALIAS FOR $<replaceable>n</replaceable>;
    </synopsis>

    Le même exemple dans ce style ressemble à ceci&nbsp;:
    <programlisting>CREATE FUNCTION taxe_ventes(real) RETURNS real AS $$
DECLARE
    sous_total ALIAS FOR $1;
BEGIN
    RETURN sous_total * 0.06;
END;
$$ LANGUAGE plpgsql;
    </programlisting>
   </para>

   <note>
    <para>
     Ces deux exemples ne sont pas complètement identiques. Dans le premier cas,
     <literal>sous_total</literal> peut être référencé comme
     <literal>taxe_ventes.sous_total</literal>, alors que ce n'est pas possible
     dans le second cas. (Si nous avions attaché un label au bloc interne,
     <literal>sous_total</literal> aurait pu utiliser ce label à la place.)
    </para>
   </note>

   <para>
    Quelques exemples de plus&nbsp;:
    <programlisting>CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$
DECLARE
    v_string ALIAS FOR $1;
    index ALIAS FOR $2;
BEGIN
    -- quelques traitements utilisant ici v_string et index
END;
$$ LANGUAGE plpgsql;


CREATE FUNCTION concat_champs_selectionnes(in_t un_nom_de_table) RETURNS text AS $$
BEGIN
    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
END;
$$ LANGUAGE plpgsql;
    </programlisting>
   </para>

   <para>
    Quand une fonction <application>PL/pgSQL</application> est déclarée avec
    des paramètres en sortie, ces derniers se voient attribués les noms
    <literal>$<replaceable>n</replaceable></literal> et des alias optionnels
    de la même façon que les paramètres en entrée. Un paramètre en sortie est
    une variable qui commence avec la valeur NULL&nbsp;; il
    devrait se voir attribuer une valeur lors de l'exécution de la fonction.
    La valeur finale du paramètre est ce qui est renvoyée. Par exemple,
    l'exemple taxe_ventes peut s'écrire de cette façon&nbsp;:

    <programlisting>CREATE FUNCTION taxe_ventes(sous_total real, OUT taxe real) AS $$
BEGIN
    taxe := sous_total * 0.06;
END;
$$ LANGUAGE plpgsql;
    </programlisting>

    Notez que nous avons omis <literal>RETURNS real</literal>. Nous aurions
    pu l'inclure mais cela aurait été redondant.
   </para>

   <para>
    Les paramètres en sortie sont encore plus utiles lors du retour de
    plusieurs valeurs. Un exemple trivial est&nbsp;:

    <programlisting>CREATE FUNCTION somme_n_produits(x int, y int, OUT somme int, OUT produit int) AS $$
BEGIN
    somme := x + y;
    produit := x * y;
END;
$$ LANGUAGE plpgsql;
    </programlisting>

    D'après ce qui a été vu dans la <xref linkend="xfunc-output-parameters"/>,
    ceci crée réellement un type d'enregistrement anonyme pour les résultats
    de la fonction. Si une clause <literal>RETURNS</literal> est donnée, elle doit
    spécifier <literal>RETURNS record</literal>.
   </para>

   <para>
    Voici une autre façon de déclarer une fonction
    <application>PL/pgSQL</application>, cette fois avec <literal>RETURNS
     TABLE</literal>&nbsp;:

    <programlisting>
CREATE FUNCTION extended_sales(p_itemno int)
RETURNS TABLE(quantity int, total numeric) AS $$
BEGIN
    RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales AS s
                 WHERE s.itemno = p_itemno;
END;
$$ LANGUAGE plpgsql;
    </programlisting>

    C'est exactement équivalent à déclarer un ou plusieurs paramètres
    <literal>OUT</literal> et à spécifier <literal>RETURNS SETOF
     <replaceable>un_type</replaceable></literal>.
   </para>

   <para>
    Lorsque le type de retour d'une fonction <application>PL/pgSQL</application>
    est déclaré comme type polymorphe (<type>anyelement</type>,
    <type>anyarray</type>, <type>anynonarray</type>, <type>anyenum</type> et <type>anyrange</type>), un
    paramètre spécial <literal>$0</literal> est créé.
    Son type de donnée est le type effectif de retour de la fonction, déduit d'après
    les types en entrée (voir la <xref linkend="extend-types-polymorphic"/>).
    Ceci permet à la fonction d'accéder à son type de retour réel comme on le voit ici
    avec la <xref linkend="plpgsql-declaration-type"/>.
    <literal>$0</literal> est initialisé à NULL et peut être modifié par la fonction,
    de sorte qu'il peut être utilisé pour contenir la variable de retour si besoin est,
    bien que cela ne soit pas requis. On peut aussi donner un alias à
    <literal>$0</literal>. Par exemple, cette fonction s'exécute comme un
    opérateur <literal>+</literal> pour n'importe quel type de données&nbsp;:
    <programlisting>CREATE FUNCTION ajoute_trois_valeurs(v1 anyelement, v2 anyelement, v3 anyelement)
RETURNS anyelement AS $$
DECLARE
    resultat ALIAS FOR $0;
BEGIN
    resultat := v1 + v2 + v3;
    RETURN resultat;
END;
$$ LANGUAGE plpgsql;
    </programlisting>
   </para>

   <para>
    Le même effet peut être obtenu en déclarant un ou plusieurs paramètres
    polymorphes en sortie de types. Dans ce
    cas, le paramètre spécial <literal>$0</literal> n'est pas utilisé&nbsp;;
    les paramètres en sortie servent ce même but. Par exemple&nbsp;:

    <programlisting>CREATE FUNCTION ajoute_trois_valeurs(v1 anyelement, v2 anyelement, v3 anyelement,
                                 OUT somme anyelement)
AS $$
BEGIN
    somme := v1 + v2 + v3;
END;
$$ LANGUAGE plpgsql;
    </programlisting>
   </para>
  </sect2>

  <sect2 id="plpgsql-declaration-alias">
   <title><literal>ALIAS</literal></title>

   <synopsis>
<replaceable>nouveaunom</replaceable> ALIAS FOR <replaceable>anciennom</replaceable>;
   </synopsis>

   <para>
    La syntaxe <literal>ALIAS</literal> est plus générale que la section
    précédente pourrait faire croire&nbsp;: vous pouvez déclarer un alias pour
    n'importe quelle variable et pas seulement des paramètres de fonction.
    L'utilisation principale de cette instruction est l'attribution d'un
    autre nom aux variables aux noms prédéterminés, telles que <varname>NEW</varname>
    ou <varname>OLD</varname> au sein d'une procédure trigger.
   </para>

   <para>
    Exemples:
    <programlisting>
DECLARE
  anterieur ALIAS FOR old;
  misajour ALIAS FOR new;
    </programlisting>
   </para>

   <para>
    <literal>ALIAS</literal> créant deux manières différentes de nommer
    le même objet, son utilisation à outrance peut préter à confusion. Il vaut
    mieux ne l'utiliser uniquement pour se passer des noms prédéterminés.
   </para>
  </sect2>

  <sect2 id="plpgsql-declaration-type">
   <title>Copie de types</title>

   <synopsis><replaceable>variable</replaceable>%TYPE
   </synopsis>

   <para>
    <literal>%TYPE</literal> fournit le type de données d'une variable ou d'une
    colonne de table. Vous pouvez l'utiliser pour déclarer des variables qui
    contiendront des valeurs de base de données. Par exemple, disons que vous
    avez une colonne nommée <literal>id_utilisateur</literal> dans votre table
    <literal>utilisateurs</literal>. Pour déclarer une variable du même type de
    données que <literal>utilisateurs.id_utilisateur</literal>, vous pouvez
    écrire&nbsp;:
    <programlisting>id_utilisateur utilisateurs.id_utilisateur%TYPE;
    </programlisting>
   </para>

   <para>
    En utilisant <literal>%TYPE</literal> vous n'avez pas besoin de connaître
    le type de données de la structure à laquelle vous faites référence et, plus
    important, si le type de données de l'objet référencé change dans le futur (par
    exemple&nbsp;: vous changez le type de <literal>id_utilisateur</literal> de
    <type>integer</type> à <type>real</type>), vous pouvez ne pas avoir besoin de
    changer votre définition de fonction.
   </para>

   <para>
    <literal>%TYPE</literal> est particulièrement utile dans le cas de fonctions
    polymorphes puisque les types de données nécessaires aux variables internes
    peuvent changer d'un appel à l'autre. Des variables appropriées peuvent être
    créées en appliquant <literal>%TYPE</literal> aux arguments de la fonction ou à
    la variable fictive de résultat.
   </para>

  </sect2>

  <sect2 id="plpgsql-declaration-rowtypes">
   <title>Types ligne</title>

   <synopsis><replaceable>nom</replaceable> <replaceable>nom_table</replaceable><literal>%ROWTYPE</literal>;
<replaceable>nom</replaceable> <replaceable>nom_type_composite</replaceable>;
   </synopsis>

   <para>
    Une variable de type composite est appelée variable <firstterm>ligne</firstterm> (ou
    variable <firstterm>row-type</firstterm>). Une telle variable peut contenir une ligne entière
    de résultat de requête <command>SELECT</command> ou <command>FOR</command>, du moment
    que l'ensemble de colonnes de la requête correspond au type déclaré de la variable.
    Les champs individuels de la valeur row sont accessibles en utilisant la notation
    pointée, par exemple <literal>varligne.champ</literal>.
   </para>

   <para>
    Une variable ligne peut être déclarée de façon à avoir le même type que les lignes
    d'une table ou d'une vue existante, en utilisant la notation
    <replaceable>nom_table</replaceable><literal>%ROWTYPE</literal>.
    Elle peut aussi être déclarée en donnant un nom de type composite. Chaque table
    ayant un type de données associé du même nom, il importe peu dans
    <productname>PostgreSQL</productname> que vous écriviez <literal>%ROWTYPE</literal> ou pas.
    Cependant, la forme utilisant <literal>%ROWTYPE</literal> est plus portable.
   </para>

   <para>
    Les paramètres d'une fonction peuvent être des types composites
    (lignes complètes de tables). Dans ce cas, l'identifiant correspondant
    <literal>$<replaceable>n</replaceable></literal> sera une variable ligne à partir de laquelle
    les champs peuvent être sélectionnés avec la notation pointée, par exemple <literal>$1.id_utilisateur</literal>.
   </para>

   <para>
    Seules les colonnes définies par l'utilisateur sont accessibles
    dans une variable de type ligne, et non l'OID ou d'autres colonnes systèmes (parce que
    la ligne pourrait être issue d'une vue). Les champs du type ligne héritent des tailles
    des champs de la table ou de leur précision pour les types de données tels que
    <type>char(<replaceable>n</replaceable>)</type>.
   </para>

   <para>
    Voici un exemple d'utilisation des types composites. <structname>table1</structname>
    et <structname>table2</structname> sont des tables ayant au moins les champs
    mentionnés&nbsp;:

    <programlisting>CREATE FUNCTION assemble_champs(t_ligne table1) RETURNS text AS $$
DECLARE
    t2_ligne table2%ROWTYPE;
BEGIN
    SELECT * INTO t2_ligne FROM table2 WHERE ... ;
    RETURN t_ligne.f1 || t2_ligne.f3 || t_ligne.f5 || t2_ligne.f7;
END;
$$ LANGUAGE plpgsql;

SELECT assemble_champs(t.*) FROM table1 t WHERE ... ;
    </programlisting>
   </para>
  </sect2>

  <sect2 id="plpgsql-declaration-records">
   <title>Types record</title>

   <para>
    <synopsis><replaceable>nom</replaceable> RECORD;
    </synopsis>
   </para>

   <para>
    Les variables record sont similaires aux variables de type ligne mais n'ont
    pas de structure prédéfinie. Elles empruntent la structure effective de
    type ligne de la ligne à laquelle elles sont affectées durant une commande
    <command>SELECT</command> ou <command>FOR</command>. La sous-structure d'une
    variable record peut changer à chaque fois qu'on l'affecte. Une conséquence
    de cela est qu'elle n'a pas de sous-structure jusqu'à ce qu'elle ait été
    affectée, et toutes les tentatives pour accéder à un de ses champs
    entraînent une erreur d'exécution.
   </para>

   <para>
    Notez que <literal>RECORD</literal> n'est pas un vrai type de données mais seulement un
    paramètre fictif (placeholder). Il faut aussi réaliser que lorsqu'une fonction
    <application>PL/pgSQL</application> est déclarée renvoyer un type <type>record</type>,
    il ne s'agit pas tout à fait du même concept qu'une variable record, même si
    une telle fonction peut aussi utiliser une variable record pour contenir son
    résultat. Dans les deux cas, la structure réelle de la ligne n'est pas connue quand
    la fonction est écrite mais, dans le cas d'une fonction renvoyant un type
    <type>record</type>, la structure réelle est déterminée quand la requête appelante est
    analysée, alors qu'une variable record peut changer sa structure de ligne à la volée.
   </para>
  </sect2>

  <sect2 id="plpgsql-declaration-collation">
   <title>Collationnement des variables <application>PL/pgSQL</application></title>

   <indexterm>
    <primary>collationnement</primary>
    <secondary>dans PL/pgSQL</secondary>
   </indexterm>

   <para>
    Quand une fonction <application>PL/pgSQL</application> a un ou
    plusieurs paramètres dont le type de données est collationnable, un
    collationnement est identifié pour chaque appel de fonction
    dépendant des collationnements affectés aux arguments réels, comme
    décrit dans <xref linkend="collation"/>. Si un collationnement est
    identifié avec succès (autrement dit, qu'il n'y a pas de conflit de
    collationnements implicites parmi les arguments), alors tous les
    paramètres collationnables sont traités comme ayant un
    collationnement implicite. Ceci affectera le comportement des
    opérations sensibles au collationnement dans la fonction. Par exemple,
    avec cette fonction

    <programlisting>
CREATE FUNCTION plus_petit_que(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b;
END;
$$ LANGUAGE plpgsql;

SELECT plus_petit_que(champ_text_1, champ_text_2) FROM table1;
SELECT plus_petit_que(champ_text_1, champ_text_2 COLLATE "C") FROM table1;
    </programlisting>

    La première utilisation de <function>less_than</function> utilisera
    le collationnement par défaut de <structfield>champ_text_1</structfield>
    et de <structfield>champ_text_2</structfield> pour la comparaison
    alors que la seconde utilisation prendra le collationnement
    <literal>C</literal>.
   </para>

   <para>
    De plus, le collationnement identifié est aussi considéré comme le
    collationnement de toute variable locale de type collationnable. Du
    coup, cette procédure stockée ne fonctionnera pas différemment de
    celle-ci&nbsp;:

    <programlisting>
CREATE FUNCTION plus_petit_que(a text, b text) RETURNS boolean AS $$
DECLARE
    local_a text := a;
    local_b text := b;
BEGIN
    RETURN local_a &lt; local_b;
END;
$$ LANGUAGE plpgsql;
    </programlisting>
   </para>

   <para>
    S'il n'y a pas de paramètres pour les types de données collationnables
    ou qu'aucun collationnement commun ne peut être identifié pour eux,
    alors les paramètres et les variables locales utilisent le
    collationnement par défaut de leur type de données (qui est
    habituellement le collationnement par défaut de la base de données
    mais qui pourrait être différent pour les variables des types
    domaines).
   </para>

   <para>
    Une variable locale d'un type de données collationnable peut avoir
    un collationnement différent qui lui est associé en incluant l'option
    <literal>COLLATE</literal> dans sa déclaration, par exemple

    <programlisting>
DECLARE
    local_a text COLLATE "en_US";
    </programlisting>

    Cette option surcharge le collationnement qui serait normalement
    donné à la variable d'après les règles ci-dessus.
   </para>

   <para>
    De plus, les clauses <literal>COLLATE</literal> explicites peuvent
    être écrites à l'intérieur d'une fonction si forcer l'utilisation
    d'un collationnement particulier est souhaité pour une opération
    particulière. Par exemple,

    <programlisting>
CREATE FUNCTION plus_petit_que_c(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b COLLATE "C";
END;
$$ LANGUAGE plpgsql;
    </programlisting>

    Ceci surcharge les collationnements associés avec les colonnes de la
    table, les paramètres ou la variables locales utilisées dans
    l'expression, comme cela arriverait dans une commande SQL simple.
   </para>
  </sect2>
 </sect1>

 <sect1 id="plpgsql-expressions">
  <title>Expressions</title>

  <para>
   Toutes les expressions utilisées dans les instructions
   <application>PL/pgSQL</application> sont traitées par l'exécuteur
   <acronym>SQL</acronym> classique du serveur. En effet, une requête
   comme
   <synopsis>SELECT <replaceable>expression</replaceable>
   </synopsis>
   est traité par le moteur SQL principal. Bien qu'utilisant la commande
   <command>SELECT</command>, tout nom de variable
   <application>PL/pgSQL</application> est remplacé par des paramètres
   (ceci est expliqué en détail dans la <xref linkend="plpgsql-var-subst"/>).
   Cela permet au plan de requête du <command>SELECT</command> d'être
   préparé une seule fois, puis d'être réutilisé pour les évaluations
   suivantes avec différentes valeurs des variables. Du coup, ce qui arrive
   réellement à la première utilisation d'une expression est simplement
   une commande <command>PREPARE</command>. Par exemple, si nous déclarons
   deux variables de type integer, <literal>x</literal> et
   <literal>y</literal>, et que nous écrivons&nbsp;:
   <programlisting>
IF x &lt; y THEN ...
   </programlisting>
   ce qui se passe en arrière plan est équivalent à&nbsp;:
   <programlisting>
PREPARE <replaceable>nom_instruction</replaceable>(integer, integer) AS SELECT $1 &lt; $2;
   </programlisting>
   puis cette instruction préparée est exécutée (via <command>EXECUTE</command>)
   pour chaque exécution de l'instruction <command>IF</command>, avec les
   valeurs actuelles des variables <application>PL/pgSQL</application> fournies
   en tant que valeurs des paramètres. Généralement, ces détails
   ne sont pas importants pour un utilisateur de
   <application>PL/pgSQL</application>, mais ils sont utiles à connaître
   pour diagnostiquer un problème.
   Vous trouverez plus d'informations dans <xref linkend="plpgsql-plan-caching"/>.
  </para>
 </sect1>

 <sect1 id="plpgsql-statements">
  <title>Instructions de base</title>

  <para>
   Dans cette section ainsi que les suivantes, nous décrirons tous les types
   d'instructions explicitement compris par
   <application>PL/pgSQL</application>.
   Tout ce qui n'est pas reconnu comme l'un de ces types d'instruction est présumé
   être une commande SQL et est envoyé au moteur principal de bases de données pour
   être exécutée comme décrit dans la <xref linkend="plpgsql-statements-sql-noresult"/>
   et dans la <xref linkend="plpgsql-statements-sql-onerow"/>.

  </para>

  <sect2 id="plpgsql-statements-assignment">
   <title>Affectation</title>

   <para>
    L'affectation d'une valeur à une variable <application>PL/pgSQL</application>
    s'écrit ainsi&nbsp;:
    <synopsis><replaceable>variable</replaceable> { := | = } <replaceable>expression</replaceable>;
    </synopsis>
    Comme expliqué précédemment, l'expression dans cette instruction est évaluée au
    moyen de la commande SQL <command>SELECT</command> envoyée au moteur principal de
    bases de données. L'expression ne doit manier qu'une seule valeur (éventuellement
    une valeur de rangée, si cette variable est une variable de rangée ou
    d'enrengistrement). La variable cible peut être une simple varible
    (éventuellement qualifiée avec un nom de bloc), un champ d'une rangée
    ou variable d'enrengistrement ou un élément de tableau qui se trouve
    être une simple variable ou champ. Le signe d'égalité (<literal>=</literal>)
    peut être utilisé à la place de <literal>:=</literal>, qui lui est conforme
    au PL/SQL.
   </para>

   <para> Si le type de données du résultat de l'expression ne
    correspond pas au type de donnée de la variable, la valeur sera
    convertie via une conversion d'affectation (cf <xref
        linkend="typeconv-query" />. Si aucune conversion
    d'affectation n'est connue pour les 2 types de données concernée,
    l'interpréteur <application>PL/pgSQL</application> tentera de
    convertir le résultat textuellement, c'est à dire en appliquant
    successivement la fonction de sortie du type résultat puis la
    fonction d'entrée du type de la variable. Notez que la fonction
    d'entrée peut générer des erreurs d'exécution si la chaîne passée
    en paramètre n'est pas acceptable pour le type de la variable.
   </para>

   <para>
    Exemples&nbsp;:
    <programlisting>taxe := sous_total * 0.06;
mon_enregistrement.id_utilisateur := 20;
    </programlisting>
   </para>
  </sect2>

  <sect2 id="plpgsql-statements-sql-noresult">
   <title>Exécuter une commande sans résultats</title>

   <para>
    Pour toute commande SQL qui ne renvoie pas de lignes, par exemple
    <command>INSERT</command> sans clause <literal>RETURNING</literal>, vous
    pouvez exécuter la commande à l'intérieur d'une fonction
    <application>PL/pgSQL</application> rien qu'en écrivant la commande.
   </para>

   <para>
    Tout nom de variable <application>PL/pgSQL</application> apparaissant
    dans le texte de la commande est traité comme un paramètre,
    puis la valeur actuelle de la variable est fournie comme valeur du
    paramètre à l'exécution. C'est le traitement exact décrit précédemment pour
    les expressions. Pour les détails, voir la <xref
    linkend="plpgsql-var-subst"/>.
   </para>

   <para>
    Lors de l'exécution d'une commande SQL de cette façon,
    <application>PL/pgSQL</application> peut placer le plan en cache et le
    réutiliser plus tard, comme indiqué dans <xref
    linkend="plpgsql-plan-caching"/>.
   </para>

   <para>
    Parfois, il est utile d'évaluer une expression ou une requête
    <command>SELECT</command> mais sans récupérer le résultat, par
    exemple lors de l'appel d'une fonction qui a des effets de bord
    mais dont la valeur du résultat n'est pas utile. Pour faire cela
    en <application>PL/pgSQL</application>, utilisez l'instruction
    <command>PERFORM</command>&nbsp;:

    <synopsis>PERFORM <replaceable>requête</replaceable>;
    </synopsis>

    Ceci exécute la <replaceable>requête</replaceable> et ne tient pas compte
    du résultat. Écrivez la <replaceable>requête</replaceable> de la même
    façon que vous écririez une commande <command>SELECT</command> mais
    remplacez le mot clé initial <command>SELECT</command> avec
    <command>PERFORM</command>.
    Pour les requêtes <command>WITH</command>, utilisez
    <command>PERFORM</command> puis placez la requête entre parenthèses.
    (De cette façon, la requête peut seulement renvoyer une ligne.)
    Les variables <application>PL/pgSQL</application> seront substituées dans
    la requête comme pour les commandes qui ne renvoient pas de résultat. Le
    plan est mis en cache de la même façon. La variable spéciale
    <literal>FOUND</literal> est configurée à true si la requête a produit
    au moins une ligne, false dans le cas contraire (voir la
    <xref linkend="plpgsql-statements-diagnostics"/>).
   </para>

   <note>
    <para>
     Vous pourriez vous attendre à ce que l'utilisation directe de
     <command>SELECT</command> aboutisse au même résultat mais, actuellement,
     la seule façon acceptée de le faire est d'utiliser
     <command>PERFORM</command>. Une commande SQL qui peut renvoyer des lignes
     comme <command>SELECT</command> sera rejetée comme une erreur si elle
     n'a pas de clause <literal>INTO</literal>, ce qui est discuté dans la
     section suivante.
    </para>
   </note>

   <para>
    Un exemple&nbsp;:
    <programlisting>PERFORM creer_vuemat('cs_session_page_requests_mv', ma_requete);
    </programlisting>
   </para>
  </sect2>

  <sect2 id="plpgsql-statements-sql-onerow">
   <title>Exécuter une requête avec une seule ligne de résultats</title>

   <indexterm zone="plpgsql-statements-sql-onerow">
    <primary>SELECT INTO</primary>
    <secondary>en PL/pgSQL</secondary>
   </indexterm>

   <indexterm zone="plpgsql-statements-sql-onerow">
    <primary>RETURNING INTO</primary>
    <secondary>en PL/pgSQL</secondary>
   </indexterm>

   <para>
    Le résultat d'une commande SQL ne ramenant qu'une seule ligne (mais avec une
    ou plusieurs colonnes) peut être affecté à une variable de type record, row ou
    à une liste de variables scalaires. Ceci se fait en écrivant la commande SQL
    de base et en ajoutant une clause <literal>INTO</literal>. Par exemple,

    <synopsis>SELECT <replaceable>expressions_select</replaceable> INTO <optional>STRICT</optional> <replaceable>cible</replaceable> FROM ...;
INSERT ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>cible</replaceable>;
UPDATE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>cible</replaceable>;
DELETE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>cible</replaceable>;
    </synopsis>

    où <replaceable>cible</replaceable> peut être une variable de type record,
    row ou une liste de variables ou de champs record/row séparées par
    des virgules. Les variables <application>PL/pgSQL</application> seront
    substituées dans le reste de la requête, et le plan est mis en cache
    comme décrit ci-dessus pour les commandes qui ne renvoient pas de lignes.
    Ceci fonctionne pour <command>SELECT</command>,
    <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>
    avec <literal>RETURNING</literal>, et les commandes utilitaires qui renvoient
    des résultats de type rowset (comme <command>EXPLAIN</command>).
    Sauf pour la clause <literal>INTO</literal>, la commande SQL est identique
    à celle qui aurait été écrite en dehors de <application>PL/pgSQL</application>.
   </para>

   <tip>
    <para>
     Notez que cette interprétation de <command>SELECT</command> avec <literal>INTO</literal>
     est assez différente de la commande habituelle <command>SELECT INTO</command> où la
     cible <literal>INTO</literal> est une table nouvellement créée. Si vous
     voulez créer une table à partir du résultat d'un
     <command>SELECT</command> à l'intérieur d'une fonction
     <application>PL/pgSQL</application>, utilisez la syntaxe
     <command>CREATE TABLE ... AS SELECT</command>.
    </para>
   </tip>

   <para>
    Si une ligne ou une liste de variables est utilisée comme cible, les
    colonnes du résultat de la requête doivent correspondre exactement à
    la structure de la cible (nombre de champs et types de données).
    Dans le cas contraire, une erreur sera rapportée à l'exécution.
    Quand une variable record est la cible, elle se configure
    automatiquement avec le type row des colonnes du résultat de la
    requête.
   </para>

   <para>
    La clause <literal>INTO</literal> peut apparaître pratiquement partout
    dans la commande SQL. Elle est écrite soit juste avant soit juste après
    la liste d'<replaceable>expressions_select</replaceable> dans une commande
    <command>SELECT</command>, ou à la fin de la commande pour d'autres types
    de commande. Il est recommandé de suivre cette convention au cas où
    l'analyseur <application>PL/pgSQL</application> devient plus strict dans
    les versions futures.
   </para>

   <para>
    Si <literal>STRICT</literal> n'est pas spécifié dans la clause
    <literal>INTO</literal>, alors
    <replaceable>cible</replaceable> sera configuré avec la première ligne
    renvoyée par la requête ou à NULL si la requête n'a renvoyé aucune ligne.
    (Notez que <quote>la première ligne</quote> n'est bien définie que
    si vous avez utilisé <literal>ORDER BY</literal>.) Toute ligne résultat
    après la première ligne est annulée. Vous pouvez vérifier la valeur de la
    variable spéciale <literal>FOUND</literal> (voir la
    <xref linkend="plpgsql-statements-diagnostics"/>) pour déterminer si une
    ligne a été renvoyée&nbsp;:

    <programlisting>SELECT * INTO monrec FROM emp WHERE nom = mon_nom;
IF NOT FOUND THEN
    RAISE EXCEPTION 'employé % introuvable', mon_nom;
END IF;
    </programlisting>

    Si l'option <literal>STRICT</literal> est indiquée, la requête doit
    renvoyer exactement une ligne. Dans le cas contraire, une erreur sera rapportée à
    l'exécution, soit <literal>NO_DATA_FOUND</literal> (aucune ligne) soit
    <literal>TOO_MANY_ROWS</literal> (plus d'une ligne). Vous pouvez utiliser
    un bloc d'exception si vous souhaitez récupérer l'erreur, par exemple&nbsp;:

    <programlisting>BEGIN
    SELECT * INTO STRICT monrec FROM emp WHERE nom = mon_nom;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'employé % introuvable', mon_nom;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'employé % non unique', mon_nom;
END;
    </programlisting>
    Une exécution réussie de la commande avec <literal>STRICT</literal> renvoie
    toujours true pour <literal>FOUND</literal>.
   </para>

   <para>
    Pour les commandes <command>INSERT</command> /
    <command>UPDATE</command> / <command>DELETE</command> utilisées avec la
    clause <literal>RETURNING</literal>, <application>PL/pgSQL</application>
    renvoie une erreur si plus d'une ligne est renvoyée, même si la clause
    <literal>STRICT</literal> n'est pas indiquée. Ceci est dû au fait qu'il
    n'existe pas d'option <literal>ORDER BY</literal> qui permettrait de
    déterminer la ligne affectée à renvoyer.
   </para>

   <para>
    Si <literal>print_strict_params</literal> est activé pour cette fonction,
    alors, quand une erreur est renvoyée parce que les conditions de
    <literal>STRICT</literal> ne sont pas rencontrées, la partie
    <literal>DETAIL</literal> du message d'erreur incluera les informations
    sur les paramètres passés à la requête. Vous pouvez modifier la
    configuration de <literal>print_strict_params</literal> pour toutes les
    fonctions en configurant <varname>plpgsql.print_strict_params</varname>,
    bien que seules les compilations suivantes des fonctions seront affectées.
    Vous pouvez aussi l'activer fonction par fonction en utilisant une option
    du compilateur, par exemple&nbsp;:
    <programlisting>
CREATE FUNCTION get_userid(username text) RETURNS int
AS $$
#print_strict_params on
DECLARE
userid int;
BEGIN
    SELECT users.userid INTO STRICT userid
        FROM users WHERE users.username = get_userid.username;
    RETURN userid;
END
$$ LANGUAGE plpgsql;
    </programlisting>
    En cas d'échec, cette fonction pourrait renvoyer un message d'erreur tel
    que&nbsp;:
    <programlisting>
ERROR:  query returned no rows
DETAIL:  parameters: $1 = 'nosuchuser'
CONTEXT:  PL/pgSQL function get_userid(text) line 6 at SQL statement
    </programlisting>
   </para>

   <note>
    <para>
     L'option <literal>STRICT</literal> correspond au comportement du
     <command>SELECT INTO</command> d'Oracle PL/SQL et des instructions
     relatives.
    </para>
   </note>

   <para>
    Pour gérer les cas où vous avez besoin de traiter plusieurs lignes de
    résultat à partir d'une requête SQL, voir la <xref linkend="plpgsql-records-iterating"/>.
   </para>

  </sect2>

  <sect2 id="plpgsql-statements-executing-dyn">
   <title>Exécuter des commandes dynamiques</title>

   <para>
    Créer dynamique des requêtes SQL est un besoin habituel dans les fonctions
    <application>PL/pgSQL</application>, par exemple des requêtes
    qui impliquent différentes tables ou différents types de données à chaque
    fois qu'elles sont exécutées. Les tentatives normales de
    <application>PL/pgSQL</application> pour garder en cache les planifications
    des commandes (voir la <xref linkend="plpgsql-plan-caching"/>) ne
    fonctionneront pas dans de tels scénarios. Pour gérer ce type
    de problème, l'instruction <command>EXECUTE</command> est proposée&nbsp;:

    <synopsis>EXECUTE <replaceable class="command">command-string</replaceable> <optional> INTO <optional>STRICT</optional> <replaceable>target</replaceable> </optional> <optional> USING <replaceable>expression</replaceable> <optional>, ...</optional> </optional>;
    </synopsis>

    où <replaceable>chaîne-commande</replaceable> est une expression manipulant
    une chaîne (de type <type>text</type>) contenant la commande à exécuter.
    La <replaceable>cible</replaceable> optionnelle est une variable record ou ligne ou
    même une liste de variables simples ou de champs de lignes/enregistrements
    séparées par des virgules, dans lesquels les résultats de la commande seront
    enregistrés. Les expressions <literal>USING</literal> optionnelles fournissent
    des valeurs à insérer dans la commande.
   </para>

   <para>
    Aucune substitution des variables <application>PL/pgSQL</application> ne
    se fait dans la chaîne de commande calculée. Toutes les valeurs des
    variables requises doivent être insérées dans la chaîne de commande au
    moment de sa construction&nbsp;; ou vous pouvez utiliser des paramètres
    comme décrits ci-dessous.
   </para>

   <para>
    De plus, il n'y a pas mise en cache des commandes exécutées via
    <command>EXECUTE</command>. À la
    place, la commande est planifiée à chaque fois que l'instruction est lancée.
    La chaîne commande peut être créée dynamiquement à l'intérieur de la
    fonction pour agir sur des tables ou colonnes différentes.
   </para>

   <para>
    La clause <literal>INTO</literal> spécifie où devraient être affectés les
    résultats d'une commande SQL renvoyant des lignes. Si une ligne ou une
    liste de variable est fournie, elle doit correspondre exactement à la
    structure des résultats de la requête (quand
    une variable de type record est utilisée, elle sera automatiquement typée
    pour correspondre à la structure du résultat). Si plusieurs lignes sont
    renvoyées, alors seule la première sera assignée à la variable
    <literal>INTO</literal>. Si aucune ligne n'est renvoyée, NULL est affectée
    à la variable <literal>INTO</literal>. Si aucune clause
    <literal>INTO</literal> n'est spécifiée, les résultats de la requête sont
    ignorés.
   </para>

   <para>
    Si l'option <literal>STRICT</literal> est indiquée, une erreur est
    rapportée sauf si la requête produit exactement une ligne.
   </para>

   <para>
    La chaîne de commande peut utiliser des valeurs de paramètres, référencées
    dans la commande avec <literal>$1</literal>, <literal>$2</literal>, etc.
    Ces symboles font référence aux valeurs fournies dans la clause
    <literal>USING</literal>. Cette méthode est souvent préférable à
    l'insertion des valeurs en texte dans une chaîne de commande&nbsp;: cela
    évite la surcharge à l'exécution pour la conversion des valeurs en texte
    et vice-versa. C'est aussi moins sensible aux attaques par injection SQL
    car il n'est pas nécessaire de mettre entre guillemets ou d'échapper les
    valeurs. Voici un exemple&nbsp;:
    <programlisting>
EXECUTE 'SELECT count(*) FROM matable WHERE insere_par = $1 AND insere &lt;= $2'
   INTO c
   USING utilisateur_verifie, date_verifiee;
    </programlisting>
   </para>

   <para>
    Notez que les symboles de paramètres peuvent seulement être utilisés pour
    des valeurs de données &mdash; si vous voulez utiliser des noms de tables
    et/ou colonnes déterminés dynamiquement, vous devez les insérer dans la
    chaîne de commande en texte. Par exemple, si la requête précédente devait
    se faire avec une table sélectionnée dynamiquement, vous devriez faire
    ceci&nbsp;:
    <programlisting>
EXECUTE 'SELECT count(*) FROM '
    || quote_ident(tabname)
    || ' WHERE insere_par = $1 AND insere &lt;= $2'
   INTO c
   USING utilisateur_verifie, date_verifiee;
    </programlisting>
     Une meilleure solution est d'utiliser la spécification de formatage
     <literal>%I</literal> de la fonction <function>format()</function>
     pour les noms de tables ou de colonnes (les chaînes de caractères
     séparées par un retour à la ligne sont concaténées):
     <programlisting>
         EXECUTE format('SELECT count(*) FROM %I '
            'WHERE insere_par = $1 AND insere &lt;= $2', matable) 
            INTO c
            USING utilisateur_verifie, date_verifiee;
     </programlisting>
     Une autre restriction sur les symboles de paramètres est qu'ils ne
     fonctionnent que dans les commandes <command>SELECT</command>,
     <command>INSERT</command>, <command>UPDATE</command> et
     <command>DELETE</command>. Dans les autres types d'instructions
     (appellés de manière générique commandes utilitaires), vous devez
     insérer les valeurs sous forme de texte même si ce ne sont que des
     données.
    </para>

   <para>
    Un <command>EXECUTE</command> avec une chaîne de commande constante et des
    paramètres <literal>USING</literal>, comme dans le premier exemple
    ci-dessus, est équivalent fonctionnellement à l'écriture simple d'une
    commande directement dans <application>PL/pgSQL</application> et permet
    le remplacement automatique des variables <application>PL/pgSQL</application>.
    La différence importante est que <command>EXECUTE</command> va planifier de
    nouveau la commande pour chaque exécution, générant un plan qui est
    spécifique aux valeurs actuelles des paramètres&nbsp;; alors que
    <application>PL/pgSQL</application> pourrait sinon créer un plan générique
    et le stocke pour le réutiliser. Dans des situations où le meilleur plan
    dépend fortement des valeurs des paramètres, cela peut être utile d'utiliser
    <command>EXECUTE</command> pour s'assurer qu'un plan générique n'est pas
    sélectionné.
   </para>

   <para>
    <command>SELECT INTO</command> n'est actuellement pas supporté à
    l'intérieur de <command>EXECUTE</command>&nbsp;; à la place, exécutez une
    commande <command>SELECT</command> et spécifiez <literal>INTO</literal>
    comme faisant parti lui-même d'<command>EXECUTE</command>.
   </para>

   <note>
    <para>
     L'instruction <command>EXECUTE</command> de
     <application>PL/pgSQL</application> n'a pas de relation avec l'instruction
     SQL <xref linkend="sql-execute"/> supportée
     par le serveur <productname>PostgreSQL</productname>. L'instruction
     <command>EXECUTE</command> du serveur ne peut pas être utilisée directement
     dans les fonctions <application>PL/pgSQL</application>. En fait, elle n'est pas
     nécessaire.
    </para>
   </note>

   <example id="plpgsql-quote-literal-example">
    <title>Mettre entre guillemets des valeurs dans des requêtes dynamiques</title>

    <indexterm>
     <primary>quote_ident</primary>
     <secondary>utilisation dans PL/PgSQL</secondary>
    </indexterm>

    <indexterm>
     <primary>quote_literal</primary>
     <secondary>utilisation dans PL/PgSQL</secondary>
    </indexterm>

    <indexterm>
     <primary>quote_nullable</primary>
     <secondary>utilisation dans PL/PgSQL</secondary>
    </indexterm>

    <indexterm>
     <primary>format</primary>
     <secondary>utilisation avec PL/pgSQL</secondary>
    </indexterm>

    <para>
     En travaillant avec des commandes dynamiques, vous aurez souvent à gérer
     des échappements de guillemets simples. La méthode recommandée pour
     mettre entre guillemets un texte fixe dans le corps de votre fonction
     est d'utiliser les guillemets dollar (si votre code n'utilise pas les
     guillemets dollar, référez-vous à l'aperçu dans la <xref
     linkend="plpgsql-quote-tips"/>, ce qui peut vous faire gagner des efforts
     lors du passage de ce code à un schéma plus raisonnable).
    </para>

    <para>
     Les valeurs dynamiques qui sont à insérer dans la requête
     construite requièrent une attention spéciale car elles pourraient
     elles-même contenir des guillemets. Un exemple utilisant la fonction
     <function>format()</function> (ceci suppose que vous utilisiez les
     guillemets dollar pour la fonction dans sa globalité, dans ce cas
     les guillemets n'ont pas besoin d'être doublés)&nbsp;:
    <programlisting>
EXECUTE format('UPDATE table SET %I = $1 '
   'WHERE clef = $2', nom_colonne) USING nouvelle_valeur, valeur_clef;
    </programlisting>
     Il est également possible d'appeler explicitement les fonctions
     d'échappement:
     <programlisting>EXECUTE 'UPDATE tbl SET '
    || quote_ident(nom_colonne)
    || ' = '
    || quote_literal(nouvelle_valeur)
    || ' WHERE cle = '
    || quote_literal(valeur_cle);</programlisting>
    </para>

    <para>
     Cet exemple démontre l'utilisation des fonctions
     <function>quote_ident</function> et <function>quote_literal</function> (voir <xref
     linkend="functions-string"/>).
     Pour plus de sûreté, les expressions contenant
     les identifiants des colonnes et des tables doivent être passées à la
     fonction <function>quote_ident</function> avant l'insertion dans une requête
     dynamique. Les expressions contenant des
     valeurs de type chaîne de caractères doivent être
     passées à <function>quote_literal</function>. Ce sont les étapes
     appropriées pour renvoyer le texte en entrée entouré par des guillemets
     doubles ou simples respectivement, en échappant tout caractère spécial.
    </para>

    <para>
     Comme <function>quote_literal</function> est labelisé
     <literal>STRICT</literal>, elle renverra toujours NULL lorsqu'elle est
     appelée avec un argument NULL. Dans l'exemple ci-dessus, si
     <literal>nouvelle_valeur</literal> ou <literal>valeur_clé</literal>
     étaient NULL, la requête dynamique entière deviendrait NULL, amenant une
     erreur à partir du <command>EXECUTE</command>. Vous pouvez éviter ce
     problème en utilisant la fonction <function>quote_nullable</function> qui
     fonctionne de façon identique à <function>quote_literal</function> sauf
     si elle est appelée avec un argument NULL, elle renvoie la chaîne
     <literal>NULL</literal>.
     Par exemple,
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(nom_colonne)
        || ' = '
        || quote_nullable(nouvelle_valeur)
        || ' WHERE key = '
        || quote_nullable(valeur_clé);
     </programlisting>
     Si vous travaillez avez des valeurs qui peuvent être NULL, vous devez
     utiliser <function>quote_nullable</function> à la place de
     <function>quote_literal</function>.
    </para>

    <para>
     Comme toujours, il faut s'assurer que les valeurs NULL d'une requête ne
     ramènent pas des valeurs inattendues. Par exemple, la clause
     <literal>WHERE</literal>
     <programlisting>
     'WHERE key = ' || quote_nullable(valeur_clé)
     </programlisting>
     ne sera jamais vrai si <literal>valeur_clé</literal> est NULL car le résultat
     de l'opérateur d'égalité, <literal>=</literal>, avec au moins un des opérandes
     NULL est toujours NULL. Si vous souhaitez que NULL fonctionne comme toute
     autre valeur de clé ordinaire, vous devez ré-écrire la clause ci-dessus de
     cette façon&nbsp;:
     <programlisting>
     'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)
     </programlisting>
     (Actuellement, <literal>IS NOT DISTINCT FROM</literal> est géré moins
     efficacement que <literal>=</literal>, donc ne l'utilisez pas sauf en cas
     d'extrême nécessité. Voir <xref linkend="functions-comparison"/> pour plus
     d'informations sur les NULL et <literal>IS DISTINCT</literal>.)
    </para>

    <para>
     Notez que les guillemets dollar sont souvent utiles pour placer un texte
     fixe entre guillemets. Ce serait une très mauvaise idée d'écrire l'exemple
     ci-dessus de cette façon&nbsp;:
     <programlisting>    EXECUTE 'UPDATE tbl SET '
    || quote_ident(nom_colonne)
    || ' = $$'
    || nouvelle_valeur
    || '$$ WHERE cle = '
    || quote_literal(valeur_cle);</programlisting>
     car cela casserait si le contenu de <literal>nouvelle_valeur</literal> pouvait contenir
     <literal>$$</literal>. La même objection s'applique à tout délimiteur dollar
     que vous pourriez choisir. Donc, pour mettre un texte inconnu entre
     guillemets de façon sûr, vous <emphasis>devez</emphasis> utiliser
     <function>quote_literal</function>,
     <function>quote_nullable</function> ou <function>quote_ident</function>,
     comme approprié.

    <para>
     Les requêtes SQL dynamiques peuvent aussi être construites en toute
     sécurité en utilisant la fonction <function>format</function> (voir
     <xref linkend="functions-string"/>). Par exemple&nbsp;:
<programlisting>
EXECUTE format('UPDATE matable SET %I = %L '
   'WHERE clef = %L', nom_colonne, nouvelle_valeur, valeur_clef);
</programlisting>
     <literal>%I</literal> est équivalent à <function>quote_ident</function>, et
     <literal>%L</literal> est équivalent à <function>quote_nullable</function>.
     La fonction <function>format</function> peut être utilisée avec la
     clause <literal>USING</literal>&nbsp;:
     <programlisting>
EXECUTE format('UPDATE tbl SET %I = $1 WHERE cle = $2', nom_colonne)
   USING nouvellevaleur, clevaleur;
     </programlisting>
     Cette forme est meilleure car les variables sont traitées
     dans le format natif à leur type plutôt que de les convertir
     inconditionnellement en texte et de les échapper via le spécifieur
     de format <literal>%L</literal>. C'est également plus performant.
    </para>

   </para>
  </example>

  <para>
   Un exemple bien plus important d'une commande dynamique et
   d'<command>EXECUTE</command> est disponible dans l'<xref
   linkend="plpgsql-porting-ex2"/>, qui construit et exécute une commande
   <command>CREATE FUNCTION</command> pour définir une nouvelle fonction.
  </para>
 </sect2>

 <sect2 id="plpgsql-statements-diagnostics">
  <title>Obtention du statut du résultat</title>

  <para>
   Il y a plusieurs moyens pour déterminer l'effet d'une commande. La première méthode
   est d'utiliser <command>GET DIAGNOSTICS</command>&nbsp;:

   <synopsis>GET <optional> CURRENT </optional> DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>élément</replaceable> <optional> , ... </optional>;

   </synopsis>

   Cette commande permet la récupération des indicateurs d'état du système. Chaque
   <replaceable>élément</replaceable> est un mot clé identifiant une valeur d'état devant
   être affectée à la variable indiquée (qui doit être du bon type de donnée
   pour que l'affectation puisse se faire sans erreur.) Les éléments d'état actuellement disponibles sont
   <varname>ROW_COUNT</varname>, le nombre de lignes traitées par la dernière commande
   <acronym>SQL</acronym> envoyée au moteur <acronym>SQL</acronym>, et
   <varname>RESULT_OID</varname>, l'OID de la dernière ligne insérée par la commande
   <acronym>SQL</acronym> la plus récente.  Notez que <varname>RESULT_OID</varname>
   n'est utile qu'après une commande <command>INSERT</command> dans une table
   contenant des OID.
   Le signe deux-points suivi du signe d'égalité (<literal>:=</literal>) peut
   être utilisé à la place de <literal>=</literal>, pour la conformité au SQL,
   lors de l'utilisation de <command>GET DIAGNOSTICS</command>.
  </para>

  <para>
   Exemple&nbsp;:
   <programlisting>GET DIAGNOSTICS var_entier = ROW_COUNT;
   </programlisting>
  </para>

  <para>
   La seconde méthode permettant de déterminer les effets d'une commande est la variable
   spéciale nommée <literal>FOUND</literal>  de type <type>boolean</type>.
   La variable <literal>FOUND</literal> est initialisée à false au début de chaque fonction
   <application>PL/pgSQL</application>. Elle est positionnée par chacun des types
   d'instructions suivants&nbsp;:
   <itemizedlist>
    <listitem>
     <para>
      Une instruction <command>SELECT INTO</command> positionne
      <literal>FOUND</literal> à true si une ligne est affectée, false
      si aucune ligne n'est renvoyée.
     </para>
    </listitem>
    <listitem>
     <para>
      Une instruction <command>PERFORM</command> positionne <literal>FOUND</literal>
      à true si elle renvoie une ou plusieurs lignes, false si aucune ligne n'est
      produite.
     </para>
    </listitem>
    <listitem>
     <para>
      Les instructions <command>UPDATE</command>, <command>INSERT</command>, et
      <command>DELETE</command> positionnent  <literal>FOUND</literal> à true
      si au moins une ligne est affectée, false si aucune ligne n'est affectée.
     </para>
    </listitem>
    <listitem>
     <para>
      Une instruction <command>FETCH</command> positionne <literal>FOUND</literal>
      à true si elle renvoie une ligne, false si aucune ligne n'est renvoyée.
     </para>
    </listitem>
    <listitem>
     <para>
      Une instruction <command>MOVE</command> initialise
      <literal>FOUND</literal> à true si elle repositionne le curseur
      avec succès. Dans le cas contraire, elle le positionne à false.
     </para>
    </listitem>
    <listitem>
     <para>
      Une instruction <command>FOR</command> ou
      <command>FOREACH</command> initialise
      <literal>FOUND</literal> à la valeur true s'il itère une ou
      plusieurs fois, et à false dans les autres cas.
      <literal>FOUND</literal> est initialisé de cette façon quand
      la boucle se termine&nbsp;: pendant l'exécution de la
      boucle, <literal>FOUND</literal> n'est pas modifié par la
      boucle, bien qu'il pourrait être modifié par l'exécution
      d'autres requêtes dans le corps de la boucle.
     </para>
    </listitem>
    <listitem>
     <para>
      Les instructions <command>RETURN QUERY</command> et <command>RETURN
       QUERY EXECUTE</command> mettent à jour la variable <literal>FOUND</literal>
      à true si la requête renvoie au moins une ligne, et false si aucune
      ligne n'est renvoyée.
     </para>
    </listitem>
   </itemizedlist>


   Les autres instructions <application>PL/pgSQL</application> ne changent
   pas l'état de <literal>FOUND</literal>. Notez que la commande
   <command>EXECUTE</command> modifie la sortie de
   <command>GET DIAGNOSTICS</command> mais ne change pas
   <literal>FOUND</literal>.
  </para>

  <para>
   <literal>FOUND</literal> est une variable locale à l'intérieur de chaque
   fonction <application>PL/pgSQL</application>&nbsp;; chaque changement qui
   y est fait n'affecte que la fonction en cours.
  </para>

 </sect2>

 <sect2 id="plpgsql-statements-null">
  <title>Ne rien faire du tout</title>

  <para>
   Quelque fois, une instruction qui ne fait rien est utile. Par exemple,
   elle indique qu'une partie de la chaîne <command>IF</command>/<command>THEN</command>/<command>ELSE</command> est délibérément
   vide. Pour cela, utilisez l'instruction&nbsp;:

   <synopsis>NULL;</synopsis>
     </para>

     <para>
       Par exemple, les deux fragments de code suivants sont équivalents&nbsp;:
       <programlisting>BEGIN
  y := x / 0;
  EXCEPTION
  WHEN division_by_zero THEN
    NULL;  -- ignore l'erreur
  END;</programlisting>

       <programlisting>BEGIN
  y := x / 0;
  EXCEPTION
  WHEN division_by_zero THEN  -- ignore l'erreur
  END;</programlisting>
       Ce qui est préférable est une question de goût.
     </para>

     <note>
       <para>
         Dans le PL/SQL d'Oracle, les listes d'instructions vides ne sont pas
	 autorisées et, du coup, les instructions <command>NULL</command> sont
	 <emphasis>requises</emphasis> dans les situations telles que celles-ci.
	<application>PL/pgSQL</application> vous permet d'écrire simplement
	rien.
   </para>
   </note>

   </sect2>
  </sect1>
  <sect1 id="plpgsql-control-structures">
   <title>Structures de contrôle</title>

   <para>
    Les structures de contrôle sont probablement la partie la plus utile (et importante)
    de <application>PL/pgSQL</application>. Grâce aux structures de contrôle de
    <application>PL/pgSQL</application>, vous pouvez manipuler les données
    <productname>PostgreSQL</productname> de façon très flexible et puissante.
   </para>

   <sect2 id="plpgsql-statements-returning">
    <title>Retour d'une fonction</title>

    <para>
     Il y a deux commandes disponibles qui vous permettent de renvoyer des données
     d'une fonction&nbsp;: <command>RETURN</command> et <command>RETURN
     NEXT</command>.
    </para>

    <sect3>
     <title><command>RETURN</command></title>

<synopsis>RETURN <replaceable>expression</replaceable>;
   </synopsis>

   <para>
    <command>RETURN</command> accompagné d'une expression termine la fonction et
    renvoie le valeur de l'<replaceable>expression</replaceable> à l'appelant.
    Cette forme doit être utilisée avec des fonctions <application>PL/pgSQL</application>
    qui ne renvoient pas d'ensemble de valeurs.
   </para>

   <para>
    Dans une fonction qui renvoie un type scalaire, le résultat de
    l'expression sera automatiquement convertie dans le type que la fonction
    renvoie. Mais pour renvoyer une valeur composite (ligne), vous devez
    écrire une expression renvoyant exactement l'ensemble de colonnes souhaité.
    Ceci peut demander l'utilisation de conversion explicite.
   </para>

   <para>
    Si vous déclarez la fonction avec des paramètres en sortie, écrivez
    seulement <command>RETURN</command> sans expression. Les valeurs
    courantes des paramètres en sortie seront renvoyées.
   </para>

   <para>
    Si vous déclarez que la fonction renvoie <type>void</type>, une
    instruction <command>RETURN</command> peut être utilisée pour quitter
    rapidement la fonction&nbsp;; mais n'écrivez pas d'expression après
    <command>RETURN</command>.
   </para>

   <para>
    La valeur de retour d'une fonction ne peut pas être laissée indéfinie.
    Si le contrôle atteint la fin du bloc de haut niveau de la fonction,
    sans parvenir à une instruction <command>RETURN</command>, une erreur
    d'exécution survient. Néanmoins, cette restriction ne s'applique pas
    aux fonctions sans paramètre de sortie et aux fonctions renvoyant
    <type>void</type>. Dans ces cas, une instruction
    <command>RETURN</command> est automatiquement exécutée si le bloc de
    haut niveau est terminé.
   </para>

   <para>
    Quelques exemples&nbsp;:

    <programlisting>
-- fonctions renvoyant un type scalaire
RETURN 1 + 2;
RETURN scalar_var;

-- fonctions renvoyant un type composite
RETURN composite_type_var;
RETURN (1, 2, 'three'::text);  -- must cast columns to correct types
    </programlisting>
   </para>
  </sect3>

  <sect3>
   <title><command>RETURN NEXT</command> et <command>RETURN QUERY</command></title>
   <indexterm>
    <primary>RETURN NEXT</primary>
    <secondary>dans PL/PgSQL</secondary>
   </indexterm>
   <indexterm>
    <primary>RETURN QUERY</primary>
    <secondary>dans PL/PgSQL</secondary>
   </indexterm>

   <synopsis>
RETURN NEXT <replaceable>expression</replaceable>;
RETURN QUERY <replaceable>requete</replaceable>;
RETURN QUERY EXECUTE <replaceable class="command">command-string</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ...</optional> </optional>;
   </synopsis>

   <para>
    Quand une fonction <application>PL/pgSQL</application> déclare renvoyer
    <literal>SETOF <replaceable>un_certain_type</replaceable></literal>, la
    procédure à suivre est un peu différente. Dans ce cas, les éléments
    individuels à renvoyer sont spécifiés par une séquence de commandes
    <command>RETURN NEXT</command> ou <command>RETURN QUERY</command>, suivies
    de la commande finale <command>RETURN</command> sans argument qui est
    utilisée pour indiquer la fin de l'exécution de la fonction.
    <command>RETURN NEXT</command> peut être utilisé avec des types de données
    scalaires comme composites&nbsp;; avec un type de résultat composite, une
    <quote>table</quote> entière de résultats sera renvoyée.
    <command>RETURN QUERY</command> ajoute les résultats de l'exécution d'une
    requête à l'ensemble des résultats de la fonction. <command>RETURN
     NEXT</command> et <command>RETURN QUERY</command> peuvent être
    utilisés dans la même fonction, auquel cas leurs résultats seront
    concaténées.
   </para>

   <para>
    <command>RETURN NEXT</command> et <command>RETURN
     QUERY</command> ne quittent pas réellement la fonction &mdash; elles
    ajoutent simplement zéro ou plusieurs lignes à l'ensemble de résultats
    de la fonction. L'exécution continue ensuite avec l'instruction
    suivante de la fonction <application>PL/pgSQL</application>. Quand
    plusieurs commandes <command>RETURN NEXT</command> et/ou <command>RETURN
     QUERY</command> successives sont exécutées, l'ensemble de résultats
    augmente. Un <command>RETURN</command>, sans argument, permet
    de quitter la fonction mais vous pouvez aussi continuer jusqu'à la fin
    de la fonction.
   </para>

   <para>
    <command>RETURN QUERY</command> dispose d'une variante
    <command>RETURN QUERY EXECUTE</command>, qui spécifie la requête à exécuter
    dynamiquement. Les expressions de paramètres peuvent être insérées dans
    la chaîne calculée via <literal>USING</literal>, de la même façon que le
    fait la commande <command>EXECUTE</command>.
   </para>

   <para>
    Si vous déclarez la fonction avec des paramètres en sortie, écrivez
    <command>RETURN NEXT</command> sans expression. À chaque exécution,
    les valeurs actuelles des variables paramètres en sortie seront
    sauvegardées pour un renvoi éventuel en tant que résultat en sortie.
    Notez que vous devez déclarer la fonction en tant que
    <literal>SETOF record</literal> quand il y a plusieurs paramètres en
    sortie, ou <literal>SETOF <replaceable>un_certain_type</replaceable></literal>
    quand il y a un seul paramètre en sortie, et de type
    <replaceable>un_certain_type</replaceable>, pour créer une fonction SRF
    avec des paramètres en sortie.
   </para>

   <para>
    Voici un exemple d'une fonction utilisant <command>RETURN
     NEXT</command>&nbsp;:

    <programlisting>
CREATE TABLE truc (id_truc INT, sousid_truc INT, nom_truc TEXT);
INSERT INTO truc VALUES (1, 2, 'trois');
INSERT INTO truc VALUES (4, 5, 'six');

CREATE OR REPLACE FUNCTION obtenir_tous_les_trucs() RETURNS SETOF foo AS
$BODY$
DECLARE
    r truc%rowtype;
BEGIN
    FOR r IN
        SELECT * FROM truc WHERE id_truc &gt; 0
    LOOP
        -- quelques traitements
        RETURN NEXT r; -- renvoie la ligne courante du SELECT
    END LOOP;
    RETURN;
END
$BODY$
LANGUAGE plpgsql;

SELECT * FROM obtenir_tous_les_trucs();
    </programlisting>
   </para>

   <para>
    Voici un exemple de fonction utilisant <command>RETURN
     QUERY</command>&nbsp;:

    <programlisting>
CREATE FUNCTION obtient_idvol_disponibles(date) RETURNS SETOF integer AS
$BODY$
BEGIN
    RETURN QUERY SELECT idvol
                   FROM vol
                  WHERE datevol &gt;= $1
                    AND datevol &lt; ($1 + 1);

    -- Comme l'exécution n'est pas terminée, nous vérifions si les lignes
    -- ont été renvoyées et levons une exception dans le cas contraire.
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Aucun vol à %.', $1;
    END IF;

    RETURN;
 END
$BODY$
LANGUAGE plpgsql;

-- Renvoie les vols disponibles ou lève une exception si aucun vol
-- n'est disponible.
SELECT * FROM obtient_idvol_disponibles(CURRENT_DATE);
    </programlisting>
   </para>

   <note>
    <para>
     L'implémentation actuelle de <command>RETURN NEXT</command> et de
     <command>RETURN QUERY</command> pour
     <application>PL/pgSQL</application> récupère la totalité de l'ensemble des
     résultats avant
     d'effectuer le retour de la fonction, comme vu plus haut. Cela signifie que
     si une fonction <application>PL/pgSQL</application> produit une structure résultat
     très grande, les performances peuvent être faibles&nbsp;: les données seront
     écrites sur le disque pour éviter un épuisement de la mémoire mais la fonction
     en elle-même ne renverra rien jusqu'à ce que l'ensemble complet des résultats
     soit généré. Une version future de  <application>PL/pgSQL</application>
     permettra aux utilisateurs de définir des fonctions renvoyant des ensembles qui
     n'auront pas cette limitation. Actuellement, le point auquel les données commencent
     à être écrites sur le disque est contrôlé par la variable de configuration
     <xref linkend="guc-work-mem"/>. Les administrateurs
     ayant une mémoire suffisante pour enregistrer des ensembles de résultats
     plus importants en mémoire doivent envisager l'augmentation de ce
     paramètre.
    </para>
   </note>
  </sect3>
 </sect2>

 <sect2 id="plpgsql-conditionals">
  <title>Contrôles conditionnels</title>

  <para>
   Les instructions <command>IF</command> et <command>CASE</command> vous permettent d'exécuter des commandes
   basées sur certaines conditions. <application>PL/pgSQL</application> a trois formes de
   <literal>IF</literal>&nbsp;:
   <itemizedlist>
    <listitem>
     <para><literal>IF ... THEN</literal></para>
    </listitem>
    <listitem>
     <para><literal>IF ... THEN ... ELSE</literal></para>
    </listitem>
    <listitem>
     <para><literal>IF ... THEN ... ELSIF ... THEN ... ELSE</literal></para>
    </listitem>
   </itemizedlist>

   et deux formes de <command>CASE</command>&nbsp;:
   <itemizedlist>
    <listitem>
     <para><literal>CASE ... WHEN ... THEN ... ELSE ... END CASE</literal></para>
    </listitem>
    <listitem>
     <para><literal>CASE WHEN ... THEN ... ELSE ... END CASE</literal></para>
    </listitem>
   </itemizedlist>
  </para>

  <sect3>
   <title><literal>IF-THEN</literal></title>

   <synopsis>IF <replaceable>expression-booleenne</replaceable> THEN
    <replaceable>instructions</replaceable>
END IF;
   </synopsis>

   <para>
    Les instructions <literal>IF-THEN</literal> sont la forme la plus simple de
    <literal>IF</literal>. Les instructions entre <literal>THEN</literal> et
    <literal>END IF</literal> seront exécutées si la condition est vraie. Autrement,
    elles seront ignorées.
   </para>

   <para>
    Exemple&nbsp;:
    <programlisting>IF v_id_utilisateur &lt;&gt; 0 THEN
    UPDATE utilisateurs SET email = v_email WHERE id_utilisateur = v_id_utilisateur;
END IF;
    </programlisting>
   </para>
  </sect3>

  <sect3>
   <title><literal>IF-THEN-ELSE</literal></title>

   <synopsis>IF <replaceable>expression-booleenne</replaceable> THEN
    <replaceable>instructions</replaceable>
ELSE
    <replaceable>instructions</replaceable>
END IF;
   </synopsis>

   <para>
    Les instructions <literal>IF-THEN-ELSE</literal> s'ajoutent au
    <literal>IF-THEN</literal> en vous permettant de spécifier un autre ensemble
    d'instructions à exécuter si la condition n'est pas vraie (notez que ceci
    inclut le cas où la condition s'évalue à NULL.).
   </para>

   <para>
    Exemples&nbsp;:
    <programlisting>IF id_parent IS NULL OR id_parent = ''
THEN
    RETURN nom_complet;
ELSE
    RETURN hp_true_filename(id_parent) || '/' || nom_complet;
END IF;
    </programlisting>

    <programlisting>IF v_nombre &gt; 0 THEN
    INSERT INTO nombre_utilisateurs (nombre) VALUES (v_nombre);
    RETURN 't';
ELSE
    RETURN 'f';
END IF;
    </programlisting>
   </para>
  </sect3>

  <sect3>
   <title><literal>IF-THEN-ELSIF</literal></title>

   <synopsis>IF <replaceable>expression-booleenne</replaceable> THEN
    <replaceable>instructions</replaceable>
<optional> ELSIF <replaceable>expression-booleenne</replaceable> THEN
    <replaceable>instructions</replaceable>
<optional> ELSIF <replaceable>expression-booleenne</replaceable> THEN
    <replaceable>instructions</replaceable>
    ...
</optional>
</optional>
<optional> ELSE
    <replaceable>instructions</replaceable> </optional>
END IF;
   </synopsis>

   <para>
    Quelques fois, il existe plus de deux alternatives.
    <literal>IF-THEN-ELSIF</literal> fournit une méthode agréable pour
    vérifier différentes alternatives. Les conditions
    <literal>IF</literal> sont testées successivement jusqu'à trouver la
    bonne. Alors les instructions associées sont exécutées, puis le
    contrôle est passé à la prochaine instruction après <literal>END
     IF</literal>. (Toute autre condition <literal>IF</literal> n'est
    <emphasis>pas</emphasis> testée.) Si aucune des conditions
    <literal>IF</literal> n'est vraie, alors le bloc
    <literal>ELSE</literal> (s'il y en a un) est exécuté.
   </para>

   <para>
    Voici un exemple&nbsp;:

    <programlisting>IF nombre = 0 THEN
    resultat := 'zero';
ELSIF nombre &gt; 0 THEN
    resultat := 'positif';
ELSIF nombre &lt; 0 THEN
    resultat := 'negatif';
ELSE
    -- hmm, la seule possibilité est que le nombre soit NULL
    resultat := 'NULL';
END IF;
    </programlisting>
   </para>

   <para>
    Le mot clé <literal>ELSIF</literal> peut aussi s'écrire
    <literal>ELSEIF</literal>.
   </para>

   <para>
    Une façon alternative d'accomplir la même tâche est d'intégrer les
    instructions <literal>IF-THEN-ELSE</literal>, comme dans l'exemple
    suivant&nbsp;:

    <programlisting>
IF demo_row.sex = 'm' THEN
    pretty_sex := 'man';
ELSE
    IF demo_row.sex = 'f' THEN
        pretty_sex := 'woman';
    END IF;
END IF;
    </programlisting>
   </para>

   <para>
    Néanmoins, cette méthode requiert d'écrire un <literal>END
     IF</literal> pour chaque <literal>IF</literal>, donc c'est un peu plus
    compliqué que d'utiliser <literal>ELSIF</literal> quand il y a beaucoup
    d'autres alternatives.
   </para>
  </sect3>

  <sect3>
   <title><literal>CASE</literal> simple</title>

   <synopsis>
CASE <replaceable>expression_recherche</replaceable>
    WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>instructions</replaceable>
  <optional> WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>instructions</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>instructions</replaceable> </optional>
END CASE;
   </synopsis>

   <para>
    La forme simple de <command>CASE</command> fournit une exécution
    conditionnelle basée sur l'égalité des opérandes.
    L'<replaceable>expression-recherche</replaceable> est évaluée (une fois)
    puis comparée successivement à chaque <replaceable>expression</replaceable>
    dans les clauses <literal>WHEN</literal>. Si une correspondance est
    trouvée, alors les <replaceable>instructions</replaceable> correspondantes
    sont exécutées, puis le contrôle est passé à la prochaine instruction
    après <literal>END CASE</literal>. (Les autres expressions
    <literal>WHEN</literal> ne sont pas testées.) Si aucune correspondance
    n'est trouvée, les <replaceable>instructions</replaceable> du bloc
    <literal>ELSE</literal> sont exécutées&nbsp;; s'il n'y a pas de bloc
    <literal>ELSE</literal>, une exception <literal>CASE_NOT_FOUND</literal>
    est levée.
   </para>

   <para>
    Voici un exemple simple&nbsp;:

    <programlisting>
CASE x
    WHEN 1, 2 THEN
        msg := 'un ou deux';
    ELSE
        msg := 'autre valeur que un ou deux';
END CASE;
    </programlisting>
   </para>
  </sect3>

  <sect3>
   <title><literal>CASE</literal> recherché</title>

   <synopsis>
CASE
    WHEN <replaceable>expression_booléenne</replaceable> THEN
      <replaceable>instructions</replaceable>
  <optional> WHEN <replaceable>expression_booléenne</replaceable> THEN
      <replaceable>instructions</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>instructions</replaceable> </optional>
END CASE;
   </synopsis>

   <para>
    La forme recherché de <command>CASE</command> fournit une exécution
    conditionnelle basée sur la vérification d'expressions booléennes.
    Chaque <replaceable>expression-booléenne</replaceable> de la clause
    <literal>WHEN</literal> est évaluée à son tour jusqu'à en trouver
    une qui est validée (<literal>true</literal>). Les
    <replaceable>instructions</replaceable> correspondantes sont exécutées,
    puis le contrôle est passé à la prochaine instruction après <literal>END
     CASE</literal>. (Les expressions <literal>WHEN</literal> suivantes ne
    sont pas testées.) Si aucun résultat vrai n'est trouvé, les
    <replaceable>instructions</replaceable> du bloc <literal>ELSE</literal>
    sont exécutées. Si aucun bloc <literal>ELSE</literal> n'est présent, une
    exception <literal>CASE_NOT_FOUND</literal> est levée.
   </para>

   <para>
    Voici un exemple&nbsp;:

    <programlisting>
CASE
    WHEN x BETWEEN 0 AND 10 THEN
        msg := 'valeur entre zéro et dix';
    WHEN x BETWEEN 11 AND 20 THEN
        msg := 'valeur entre onze et vingt';
END CASE;
    </programlisting>
   </para>

   <para>
    Cette forme de <command>CASE</command> est entièrement équivalente à
    <literal>IF-THEN-ELSIF</literal>, sauf pour la règle qui dit qu'atteindre
    une clause <literal>ELSE</literal> omise résulte dans une erreur plutôt
    que ne rien faire.
   </para>

  </sect3>
 </sect2>

 <sect2 id="plpgsql-control-structures-loops">
  <title>Boucles simples</title>

  <indexterm zone="plpgsql-control-structures-loops">
   <primary>boucle</primary>
   <secondary>en PL/pgSQL</secondary>
  </indexterm>

  <para>
   Grâce aux instructions <literal>LOOP</literal>, <literal>EXIT</literal>,
   <literal>CONTINUE</literal>, <literal>WHILE</literal>
   <literal>FOR</literal> et <literal>FOREACH</literal>, vous pouvez faire en sorte que vos fonctions
   <application>PL/pgSQL</application> répètent une série de commandes.
  </para>

  <sect3>
   <title><literal>LOOP</literal></title>

   <synopsis><optional>&lt;&lt;<replaceable>label</replaceable>&gt;&gt;</optional>
LOOP
    <replaceable>instructions</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
   </synopsis>

   <para>
    <literal>LOOP</literal> définit une boucle inconditionnelle répétée indéfiniment
    jusqu'à ce qu'elle soit terminée par une instruction <literal>EXIT</literal> ou
    <command>RETURN</command>.  Le <replaceable>label</replaceable> optionnel
    peut être utilisé par les instructions <literal>EXIT</literal> et
    <literal>CONTINUE</literal> dans le cas de boucles imbriquées pour définir la
    boucle impliquée.
   </para>
  </sect3>

  <sect3>
   <title><literal>EXIT</literal></title>

   <indexterm>
    <primary>EXIT</primary>
    <secondary>en PL/pgSQL</secondary>
   </indexterm>

   <synopsis>EXIT <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>expression-booléenne</replaceable> </optional>;
   </synopsis>

   <para>
    Si aucun <replaceable>label</replaceable> n'est donné, la boucle la plus
    imbriquée se termine et l'instruction suivant <literal>END LOOP</literal> est
    exécutée.
    Si un <replaceable>label</replaceable> est donné, ce doit être
    le label de la boucle, du bloc courant ou d'un niveau moins imbriqué.
    La boucle ou le bloc nommé se termine alors et le contrôle continue
    avec l'instruction située après le <literal>END</literal> de la boucle ou du bloc
    correspondant.
   </para>

   <para>
    Si <literal>WHEN</literal> est spécifié, la sortie de boucle ne s'effectue que
    si <replaceable>expression-booléenne</replaceable> est vraie. Sinon, le contrôle passe à
    l'instruction suivant le <literal>EXIT</literal>.
   </para>

   <para>
    <literal>EXIT</literal> peut être utilisé pour tous les types de
    boucles&nbsp;; il n'est pas limité aux boucles non conditionnelles.
   </para>

   <para>
    Lorsqu'il est utilisé avec un bloc <literal>BEGIN</literal>,
    <literal>EXIT</literal> passe le contrôle à la prochaine instruction
    après la fin du bloc. Notez qu'un label doit être utilisé pour
    cela&nbsp;; un <literal>EXIT</literal> sans label n'est jamais pris
    en compte pour correspondre à un bloc <literal>BEGIN</literal>.
    (Ceci est un changement de la version 8.4 de
    <productname>PostgreSQL</productname>. Auparavant, il était permis
    de faire correspondre un <literal>EXIT</literal> sans label avec un
    bloc <literal>BEGIN</literal>.)
   </para>

   <para>
    Exemples&nbsp;:
    <programlisting>LOOP
    -- quelques traitements
    IF nombre > 0 THEN
        EXIT;  -- sortie de boucle
    END IF;
END LOOP;

LOOP
    -- quelques traitements
    EXIT WHEN nombre > 0;
END LOOP;

&lt;&lt;un_bloc&gt;&gt;
BEGIN
    -- quelques traitements
    IF stocks > 100000 THEN
        EXIT un_bloc;  -- cause la sortie (EXIT) du bloc BEGIN
    END IF;
    -- les traitements ici seront ignorés quand stocks &gt; 100000
END;
    </programlisting>
   </para>
  </sect3>

  <sect3>
   <title><literal>CONTINUE</literal></title>

   <indexterm>
    <primary>CONTINUE</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>

   <synopsis>CONTINUE <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>expression-booléenne</replaceable> </optional>;
   </synopsis>

   <para>
    Si aucun <replaceable>label</replaceable> n'est donné, la prochaine
    itération de la boucle interne est commencée. C'est-à-dire que toutes
    les instructions restantes dans le corps de la boucle sont ignorées et
    le contrôle revient à l'expression de contrôle de la boucle pour
    déterminer si une autre itération de boucle est nécessaire.
    Si le <replaceable>label</replaceable> est présent, il spécifie le label
    de la boucle dont l'exécution va être continuée.
   </para>

   <para>
    Si <literal>WHEN</literal> est spécifié, la prochaine itération de la boucle
    est commencée seulement si l'<replaceable>expression-booléenne</replaceable> est vraie.
    Sinon, le contrôle est passé à l'instruction après
    <literal>CONTINUE</literal>.
   </para>

   <para>
    <literal>CONTINUE</literal> peut être utilisé avec tous les types de
    boucles&nbsp;; il n'est pas limité à l'utilisation des boucles
    inconditionnelles.
   </para>

   <para>
    Exemples&nbsp;:
    <programlisting>LOOP
    -- quelques traitements
    EXIT WHEN nombre &gt; 100;
    CONTINUE WHEN nombre &lt; 50;
    -- quelques traitements pour nombre IN [50 .. 100]
END LOOP;
    </programlisting>
   </para>
  </sect3>


  <sect3>
   <title><literal>WHILE</literal></title>

   <indexterm>
    <primary>WHILE</primary>
    <secondary>en PL/pgSQL</secondary>
   </indexterm>

   <synopsis><optional>&lt;&lt;<replaceable>label</replaceable>&gt;&gt;</optional>
WHILE <replaceable>expression-booléenne</replaceable> LOOP
    <replaceable>instructions</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
   </synopsis>

   <para>
    L'instruction <literal>WHILE</literal> répète une séquence d'instructions aussi longtemps
    que <replaceable>expression-booléenne</replaceable> est évaluée à vrai. L'expression est vérifiée juste
    avant chaque entrée dans le corps de la boucle.
   </para>

   <para>
    Par exemple&nbsp;:
    <programlisting>WHILE montant_possede > 0 AND balance_cadeau > 0 LOOP
    -- quelques traitements ici
END LOOP;

WHILE NOT termine LOOP
    -- quelques traitements ici
END LOOP;
    </programlisting>
   </para>
  </sect3>

  <sect3 id="plpgsql-integer-for">
   <title><literal>FOR</literal> (variante avec entier)</title>

   <synopsis><optional>&lt;&lt;<replaceable>label</replaceable>&gt;&gt;</optional>
FOR <replaceable>nom</replaceable> IN <optional> REVERSE </optional> <replaceable>expression</replaceable> .. <replaceable>expression</replaceable> <optional> BY <replaceable>expression</replaceable> </optional> LOOP
    <replaceable>instruction</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
   </synopsis>

   <para>
    Cette forme de <literal>FOR</literal> crée une boucle qui effectue une itération
    sur une plage de valeurs entières. La variable <replaceable>nom</replaceable>
    est automatiquement définie comme un type <type>integer</type> et n'existe
    que dans la boucle (toute définition de la variable est ignorée à l'intérieur
    de la boucle). Les deux expressions donnant les limites inférieures et
    supérieures de la plage sont évaluées une fois en entrant dans la boucle.
    Si la clause <literal>BY</literal> n'est pas spécifiée, l'étape
    d'itération est de 1, sinon elle est de la valeur spécifiée dans la
    clause <literal>BY</literal>, qui est évaluée encore une fois à l'entrée
    de la boucle. Si <literal>REVERSE</literal> est indiquée,
    alors la valeur de l'étape est soustraite, plutôt qu'ajoutée, après chaque
    itération.
   </para>

   <para>
    Quelques exemples de boucles <literal>FOR</literal> avec entiers&nbsp;:
    <programlisting>FOR i IN 1..10 LOOP
    -- prend les valeurs 1,2,3,4,5,6,7,8,9,10 dans la boucle
END LOOP;

FOR i IN REVERSE 10..1 LOOP
    -- prend les valeurs 10,9,8,7,6,5,4,3,2,1 dans la boucle
END LOOP;

FOR i IN REVERSE 10..1 BY 2 LOOP
    -- prend les valeurs 10,8,6,4,2 dans la boucle
END LOOP;

    </programlisting>
   </para>

   <para>
    Si la limite basse est plus grande que la limite haute (ou moins grande
    dans le cas du <literal>REVERSE</literal>), le corps de la boucle
    n'est pas exécuté du tout. Aucune erreur n'est renvoyée.
   </para>


   <para>
    Si un <replaceable>label</replaceable> est attaché à la boucle
    <literal>FOR</literal>, alors la variable entière de boucle peut être
    référencée avec un nom qualifié en utilisant ce
    <replaceable>label</replaceable>.
   </para>
  </sect3>
 </sect2>

 <sect2 id="plpgsql-records-iterating">
  <title>Boucler dans les résultats de requêtes</title>

  <para>
   En utilisant un type de <literal>FOR</literal> différent, vous pouvez itérer au travers
   des résultats d'une requête et par là-même manipuler ces données. La
   syntaxe est la suivante&nbsp;:
   <synopsis><optional>&lt;&lt;<replaceable>label</replaceable>&gt;&gt;</optional>
FOR <replaceable>cible</replaceable> IN <replaceable>requête</replaceable> LOOP
    <replaceable>instructions</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
   </synopsis>
   La <replaceable>cible</replaceable> est une variable de type record, row
   ou une liste de variables scalaires séparées par une virgule. La
   <replaceable>cible</replaceable> est affectée successivement à chaque ligne
   résultant de la <replaceable>requête</replaceable> et le corps de la boucle
   est exécuté pour chaque ligne. Voici un exemple&nbsp;:
   <programlisting>CREATE FUNCTION cs_rafraichir_vuemat() RETURNS integer AS $$
DECLARE
    vues_mat RECORD;
BEGIN
    RAISE NOTICE 'Rafraichissement des vues matérialisées...';

    FOR vues_mat IN SELECT * FROM cs_vues_materialisees ORDER BY cle_tri LOOP

        -- À présent vues_mat contient un enregistrement de cs_vues_materialisees

	  RAISE NOTICE 'Rafraichissement de la vue matérialisée %s ...', quote_ident(mviews.mv_name);
      EXECUTE format('TRUNCATE TABLE %I', vues_mat.vm_nom);
      EXECUTE format('INSERT INTO %I %s', vues_mat.vm_nom, vues_mat.vm_nom);
    END LOOP;

    RAISE NOTICE 'Fin du rafraichissement des vues matérialisées.';
    RETURN 1;
END;
$$ LANGUAGE plpgsql;
   </programlisting>

   Si la boucle est terminée par une instruction <literal>EXIT</literal>, la dernière valeur
   ligne affectée est toujours accessible après la boucle.
  </para>

  <para>
   La <replaceable>requête</replaceable> utilisée dans ce type d'instruction
   <literal>FOR</literal> peut être toute commande SQL qui renvoie des lignes
   à l'appelant&nbsp;: <command>SELECT</command> est le cas le plus commun
   mais vous pouvez aussi utiliser <command>INSERT</command>, <command>UPDATE</command>
   ou <command>DELETE</command> avec une clause <literal>RETURNING</literal>.
   Certaines commandes comme <command>EXPLAIN</command> fonctionnent aussi.
  </para>

  <para>
   Les variables <application>PL/pgSQL</application> sont substituées dans le
   texte de la requête et le plan de requête est mis en cache pour une
   réutilisation possible. C'est couvert en détail dans la
   <xref linkend="plpgsql-var-subst"/> et dans la
   <xref linkend="plpgsql-plan-caching"/>.
  </para>

  <para>
   L'instruction <literal>FOR-IN-EXECUTE</literal> est un moyen d'itérer sur des
   lignes&nbsp;:
   <synopsis><optional>&lt;&lt;<replaceable>label</replaceable>&gt;&gt;</optional>
FOR <replaceable>target</replaceable> IN EXECUTE <replaceable>text_expression</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ...</optional> </optional> LOOP
    <replaceable>instructions</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
   </synopsis>
   Ceci est identique à la forme précédente, à ceci près que l'expression
   de la requête source est spécifiée comme une expression chaîne,
   évaluée et replanifiée à chaque entrée dans la boucle <literal>FOR</literal>. Ceci
   permet au développeur de choisir entre la vitesse d'une requête préplanifiée et la
   flexibilité d'une requête dynamique, uniquement avec l'instruction
   <command>EXECUTE</command>.
   Comme avec <command>EXECUTE</command>, les valeurs de paramètres peuvent
   être insérées dans la commande dynamique via <literal>USING</literal>.
  </para>

  <para>
   Une autre façon de spécifier la requête dont les résultats devront être
   itérés est de la déclarer comme un curseur. Ceci est décrit dans
   <xref linkend="plpgsql-cursor-for-loop"/>.
  </para>
 </sect2>

 <sect2 id="plpgsql-foreach-array">
  <title>Boucler dans des tableaux</title>

  <para>
   La boucle <literal>FOREACH</literal> ressemble beaucoup à une
   boucle <literal>FOR</literal> mais, au lieu d'itérer sur les lignes
   renvoyées par une requêtes SQL, elle itère sur les éléments d'une
   valeur de type tableau. (En général, <literal>FOREACH</literal>
   est fait pour boucler sur les composants d'une expression
   composite&nbsp;; les variantes pour boucler sur des composites en
   plus des tableaux pourraient être ajoutées dans le futur.)
   L'instruction <literal>FOREACH</literal> pour boucler sur un
   tableau est&nbsp;:

   <synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOREACH <replaceable>target</replaceable> <optional> SLICE <replaceable>nombre</replaceable> </optional> IN ARRAY <replaceable>expression</replaceable> LOOP
    <replaceable>instructions</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
   </synopsis>
  </para>

  <para>
   Sans <literal>SLICE</literal> ou si <literal>SLICE 0</literal> est
   indiqué, la boucle itère au niveau des éléments individuels du
   tableau produit par l'évaluation de
   l'<replaceable>expression</replaceable>. La variable
   <replaceable>cible</replaceable> se voit affectée chaque valeur
   d'élément en séquence, et le corps de la boucle est exécuté pour
   chaque élément. Voici un exemple de boucle sur les éléments d'un
   tableau d'entiers&nbsp;:

   <programlisting>
CREATE FUNCTION somme(int[]) RETURNS int8 AS $$
DECLARE
  s int8 := 0;
  x int;
BEGIN
  FOREACH x IN ARRAY $1
  LOOP
    s := s + x;
  END LOOP;
  RETURN s;
END;
$$ LANGUAGE plpgsql;
   </programlisting>

   Les éléments sont parcourus dans l'ordre de leur stockage, quelque
   soit le nombre de dimensions du tableau. Bien que la
   <replaceable>cible</replaceable> est habituellement une simple
   variable, elle peut être une liste de variables lors d'une boucle
   dans un tableau de valeurs composites (des enregistrements). Dans
   ce cas, pour chaque élément du tableau, les variables se voient
   affectées les colonnes de la valeur composite.
  </para>

  <para>
   Avec une valeur <literal>SLICE</literal> positive,
   <literal>FOREACH</literal> itère au travers des morceaux du tableau
   plutôt que des éléments seuls. La valeur de <literal>SLICE</literal>
   doit être un entier constant, moins large que le nombre de
   dimensions du tableau. La variable <replaceable>cible</replaceable>
   doit être un tableau et elle reçoit les morceaux successifs de la
   valeur du tableau, où chaque morceau est le nombre de dimensions
   indiquées par <literal>SLICE</literal>. Voici un exemple d'itération
   sur des morceaux à une dimension&nbsp;:

   <programlisting>
CREATE FUNCTION parcourt_lignes(int[]) RETURNS void AS $$
DECLARE
  x int[];
BEGIN
  FOREACH x SLICE 1 IN ARRAY $1
  LOOP
    RAISE NOTICE 'ligne = %', x;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT parcourt_lignes(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]);

NOTICE:  ligne = {1,2,3}
NOTICE:  ligne = {4,5,6}
NOTICE:  ligne = {7,8,9}
NOTICE:  ligne = {10,11,12}
   </programlisting>
  </para>
 </sect2>

 <sect2 id="plpgsql-error-trapping">
  <title>Récupérer les erreurs</title>

  <indexterm>
   <primary>exceptions</primary>
   <secondary>en PL/PgSQL</secondary>
  </indexterm>

  <para>
   Par défaut, toute erreur survenant dans une fonction
   <application>PL/pgSQL</application> annule l'exécution de la fonction mais
   aussi de la transaction qui l'entoure. Vous pouvez récupérer les erreurs
   en utilisant un bloc <command>BEGIN</command> avec une clause
   <literal>EXCEPTION</literal>. La syntaxe est une extension de la syntaxe
   habituelle pour un bloc <command>BEGIN</command>&nbsp;:

   <synopsis>  <optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
  <optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
  BEGIN
  <replaceable>instructions</replaceable>
  EXCEPTION
  WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
  <replaceable>instructions_gestion_erreurs</replaceable>
  <optional> WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
    <replaceable>instructions_gestion_erreurs</replaceable>
    ... </optional>
  END;
   </synopsis>
  </para>

  <para>
   Si aucune erreur ne survient, cette forme de bloc exécute simplement
   toutes les <replaceable>instructions</replaceable> puis passe le
   contrôle à l'instruction suivant <literal>END</literal>. Mais si une erreur
   survient à l'intérieur des <replaceable>instructions</replaceable>,
   le traitement en cours des <replaceable>instructions</replaceable> est
   abandonné et le contrôle est passé à la liste d'<literal>EXCEPTION</literal>.
   Une recherche est effectuée sur la liste pour la première
   <replaceable>condition</replaceable> correspondant à l'erreur survenue.
   Si une correspondance est trouvée, les
   <replaceable>instructions_gestion_erreurs</replaceable> correspondantes
   sont exécutées puis le contrôle est passé à l'instruction suivant le
   <literal>END</literal>. Si aucune correspondance n'est trouvée, l'erreur se
   propage comme si la clause <literal>EXCEPTION</literal> n'existait pas du
   tout&nbsp;: l'erreur peut être récupérée par un bloc l'enfermant avec
   <literal>EXCEPTION</literal> ou, s'il n'existe pas, elle annule le traitement de
   la fonction.
  </para>

  <para>
   Les noms des <replaceable>condition</replaceable> sont indiquées dans
   l'<xref linkend="errcodes-appendix"/>. Un nom de catégorie correspond à toute
   erreur contenue dans cette catégorie. Le nom de condition spéciale
   <literal>OTHERS</literal> correspond à tout type d'erreur sauf
   <literal>QUERY_CANCELED</literal> et <literal>ASSERT_FAILURE</literal> (il
   est possible, mais pas recommandé, de
   récupérer ces deux types d'erreur par leur nom). Les noms des
   conditions ne sont pas sensibles à la casse. De plus, une condition d'erreur
   peut être indiquée par un code <literal>SQLSTATE</literal>&nbsp;; par exemple,
   ces deux cas sont équivalents&nbsp;:
   <programlisting>
        WHEN division_by_zero THEN ...
        WHEN SQLSTATE '22012' THEN ...
   </programlisting>
  </para>

  <para>
   Si une nouvelle erreur survient à l'intérieur des
   <replaceable>instructions_gestion_erreurs</replaceable> sélectionnées, elle
   ne peut pas être récupérée par cette clause <literal>EXCEPTION</literal> mais
   est propagée en dehors. Une clause <literal>EXCEPTION</literal> l'englobant
   pourrait la récupérer.
  </para>

  <para>
   Quand une erreur est récupérée par une clause <literal>EXCEPTION</literal>, les
   variables locales de la fonction <application>PL/pgSQL</application> restent
   dans le même état qu'au moment où l'erreur est survenue mais toutes les
   modifications à l'état persistant de la base de données à l'intérieur
   du bloc sont annulées. Comme exemple, considérez ce fragment&nbsp;:

   <programlisting>INSERT INTO mon_tableau(prenom, nom) VALUES('Tom', 'Jones');
BEGIN
  UPDATE mon_tableau SET prenom = 'Joe' WHERE nom = 'Jones';
  x := x + 1;
  y := x / 0;
  EXCEPTION
    WHEN division_by_zero THEN
      RAISE NOTICE 'récupération de l''erreur division_by_zero';
RETURN x;
END;
   </programlisting>

   Quand le contrôle parvient à l'affectation de <literal>y</literal>, il échouera
   avec une erreur <literal>division_by_zero</literal>. Elle sera récupérée par la
   clause <literal>EXCEPTION</literal>. La valeur renvoyée par l'instruction
   <command>RETURN</command> sera la valeur incrémentée de <literal>x</literal> mais
   les effets de la commande <command>UPDATE</command> auront été annulés. La
   commande <command>INSERT</command> précédant le bloc ne sera pas annulée, du
   coup le résultat final est que la base de données contient
   <literal>Tom Jones</literal> et non pas <literal>Joe Jones</literal>.
  </para>

  <tip>
   <para>
    Un bloc contenant une clause <literal>EXCEPTION</literal> est
    significativement plus coûteuse en entrée et en sortie qu'un bloc
    sans. Du coup, n'utilisez pas <literal>EXCEPTION</literal> sans besoin.
   </para>
  </tip>

  <example id="plpgsql-upsert-example">
   <title>Exceptions avec <command>UPDATE</command>/<command>INSERT</command></title>
   <para>
    Cet exemple utilise un gestionnaire d'exceptions pour réaliser soit un
    <command>UPDATE</command> soit un <command>INSERT</command>, comme approprié.
    Il est recommandé d'utiliser la commande <command>INSERT<command>
    avec la clause <literal>ON CONFLICT DO UPDATE</literal> plutôt
    que cette logique. Cet exemple ne sert qu'à illustrer l'usage des
    structures de contrôle de <application>PL/pgSQL</application>&nbsp;:

    <programlisting>CREATE TABLE base (a INT PRIMARY KEY, b TEXT);

CREATE FUNCTION fusionne_base(cle INT, donnee TEXT) RETURNS VOID AS
$$
BEGIN
    LOOP
        -- commençons par tenter la mise à jour de la clé
        UPDATE base SET b = donnee WHERE a = cle;
        IF found THEN
            RETURN;
        END IF;

        -- si elle n'est pas dispo, tentons l'insertion de la clé
        -- si quelqu'un essaie d'insérer la même clé en même temps,
        -- il y aura une erreur pour violation de clé unique
        BEGIN
            INSERT INTO base(a,b) VALUES (cle, donnee);
            RETURN;
        EXCEPTION WHEN unique_violation THEN
            -- ne rien faire, et tente de nouveau la mise à jour
        END;
    END LOOP;
END;
$$
LANGUAGE plpgsql;

SELECT fusionne_base(1, 'david');
SELECT fusionne_base(1, 'dennis');
    </programlisting>

    Ce code suppose que l'erreur <literal>unique_violation</literal> est causée
    par la commande <command>INSERT</command>, et pas par un
    <command>INSERT</command> dans une fonction trigger sur la table. Cela
    pourrait avoir un mauvais comportement s'il y a plus d'un index unique sur
    la table car il ré-essaiera l'opération quelque soit l'index qui a causé
    l'erreur. On pourrait avoir plus de sécurité en utilisant la fonctionnalité
    discuté ci-après pour vérifier que l'erreur récupérée était celle attendue.
   </para>
  </example>

  <sect3 id="plpgsql-exception-diagnostics">
   <title>Obtenir des informations sur une erreur</title>

   <para>
    Les gestionnaires d'exception ont fréquemment besoin d'identifier l'erreur
    spécifique qui est survenue. Il existe deux façons d'obtenir l'information
    sur l'exception en cours dans <application>PL/pgSQL</application>&nbsp;:
    des variables spéciales et la commande <command>GET STACKED
     DIAGNOSTICS</command>.
   </para>

   <para>
    Avec un gestionnaire d'exceptions, la variable spéciale
    <varname>SQLSTATE</varname> contient le code d'erreur qui correspond à
    l'exception qui a été levée (voir <xref linkend="errcodes-table"/> pour la
    liste de codes d'erreur possibles). La variable spéciale
    <varname>SQLERRM</varname> contient le message d'erreur associé à
    l'exception. Ces variables ne sont pas définies en dehors des gestionnaires
    d'exception.
   </para>

   <para>
    Dans le gestionnaire d'exceptions, il est possible de récupérer des
    informations sur l'exception en cours en utilisant la commande
    <command>GET STACKED DIAGNOSTICS</command> qui a la forme&nbsp;:

    <synopsis>
GET STACKED DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>élément</replaceable> <optional> , ... </optional>;
    </synopsis>

    Chaque <replaceable>élément</replaceable> est un mot clé identifiant une
    valeur de statut à assigner à la variable spécifiée (qui doit être du bon
    type de données). Les éléments de statut actuellement disponibles sont
    indiqués dans <xref linkend="plpgsql-exception-diagnostics-values"/>.
   </para>

   <table id="plpgsql-exception-diagnostics-values">
    <title>Diagnostiques et erreurs</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Type</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>RETURNED_SQLSTATE</literal></entry>
       <entry>text</entry>
       <entry>le code d'erreur SQLSTATE de l'exception</entry>
      </row>
      <row>
       <entry><literal>COLUMN_NAME</literal></entry>
       <entry>text</entry>
       <entry>le nom de la colonne en relation avec l'exception</entry>
      </row>
      <row>
       <entry><literal>CONSTRAINT_NAME</literal></entry>
       <entry>text</entry>
       <entry>le nom de la contrainte en relation avec l'exception</entry>
      </row>
      <row>
       <entry><literal>PG_DATATYPE_NAME</literal></entry>
       <entry>text</entry>
       <entry>le nom du type de données en relation avec l'exception</entry>
      </row>
      <row>
       <entry><literal>MESSAGE_TEXT</literal></entry>
       <entry>text</entry>
       <entry>le texte du message principal de l'exception</entry>
      </row>
      <row>
       <entry><literal>TABLE_NAME</literal></entry>
       <entry>text</entry>
       <entry>le nom de la table en relation avec l'exception</entry>
      </row>
      <row>
       <entry><literal>SCHEMA_NAME</literal></entry>
       <entry>text</entry>
       <entry>le nom du schéma en relation avec l'exception</entry>
      </row>
      <row>
       <entry><literal>PG_EXCEPTION_DETAIL</literal></entry>
       <entry>text</entry>
       <entry>le texte du message détaillée de l'exception, si disponible</entry>
      </row>
      <row>
       <entry><literal>PG_EXCEPTION_HINT</literal></entry>
       <entry>text</entry>
       <entry>le texte du message d'astuce de l'exception, si disponible</entry>
      </row>
      <row>
       <entry><literal>PG_EXCEPTION_CONTEXT</literal></entry>
       <entry>text</entry>
       <entry>ligne(s) de texte décrivant la pile d'appel</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Si l'exception n'a pas configuré une valeur pour un élément, une chaîne
    vide sera renvoyée.
   </para>

   <para>
    Voici un exemple&nbsp;:
    <programlisting>
DECLARE
  text_var1 text;
  text_var2 text;
  text_var3 text;
BEGIN
  -- un traitement qui cause une exception
  ...
EXCEPTION WHEN OTHERS THEN
  GET STACKED DIAGNOSTICS text_var1 = MESSAGE_TEXT,
                          text_var2 = PG_EXCEPTION_DETAIL,
                          text_var3 = PG_EXCEPTION_HINT;
END;
    </programlisting>
   </para>
  </sect3>
 </sect2>

 <sect2 id="plpgsql-get-diagnostics-context">
  <title>Obtenir des informations sur l'exécution en cours</title>

  <para>
   La commande <command>GET <optional> CURRENT </optional> DIAGNOSTICS</command>
   récupère des informations sur l'état d'exécution actuel (alors que la
   commande <command>GET STACKED DIAGNOSTICS</command> discuté ci-dessus
   renvoie des informations sur l'état d'exécution depuis la dernière erreur).
   Cette commande a la forme&nbsp;:
  </para>

  <synopsis>
GET <optional> CURRENT </optional> DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>élément</replaceable> <optional> , ... </optional>;
  </synopsis>


  <para>
   Actuellement seul un élément d'information est accepté. L'élément de
   statut <literal>PG_CONTEXT</literal> renverra une chaîne de texte avec
   une ou plusieurs lignes décrivant la pile d'appel. La première ligne fait
   référence à la fonction actuelle et à la commande <command>GET
    DIAGNOSTICS</command> en cours d'exécution. La seconde ligne et toutes les
   lignes suivantes font référence aux fonctions appelantes dans la pile
   d'appel. Par exemple&nbsp;:

   <programlisting>
CREATE OR REPLACE FUNCTION fonction_externe() RETURNS integer AS $$BEGIN
  RETURN fonction_interne();
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION fonction_interne() RETURNS integer AS $$
DECLARE
  stack text;
BEGIN
  GET DIAGNOSTICS stack = PG_CONTEXT;
  RAISE NOTICE E'--- Pile d''appel ---\n%', stack;
  RETURN 1;
END;
$$ LANGUAGE plpgsql;

SELECT fonction_externe();

NOTICE:  --- Call Stack ---
PL/pgSQL function fonction_interne() line 5 at GET DIAGNOSTICS
PL/pgSQL function fonction_externe() line 3 at RETURN
CONTEXT:  PL/pgSQL function fonction_externe() line 3 at RETURN
 fonction_externe
 -----------------
                1
(1 row)
   </programlisting>

  </para>
 </sect2>
</sect1>

<sect1 id="plpgsql-cursors">
 <title>Curseurs</title>

 <indexterm zone="plpgsql-cursors">
  <primary>curseur</primary>
  <secondary>en PL/pgSQL</secondary>
 </indexterm>

 <para>
  Plutôt que d'exécuter la totalité d'une requête à la fois, il est possible de
  créer un <firstterm>curseur</firstterm> qui encapsule la requête, puis en lit le résultat
  quelques lignes à la fois. Une des raisons pour faire de la sorte est d'éviter les
  surcharges de mémoire quand le résultat contient un grand nombre de lignes (cependant,
  les utilisateurs <application>PL/pgSQL</application> n'ont généralement pas besoin de se
  préoccuper de cela puisque les boucles <literal>FOR</literal> utilisent automatiquement un
  curseur en interne pour éviter les problèmes de mémoire). Un usage plus intéressant est
  de renvoyer une référence à un curseur qu'une fonction a créé, permettant à l'appelant de
  lire les lignes. C'est un moyen efficace de renvoyer de grands ensembles de
  lignes à partir des fonctions.
 </para>

 <sect2 id="plpgsql-cursor-declarations">
  <title>Déclaration de variables curseur</title>

  <para>
   Tous les accès aux curseurs dans <application>PL/pgSQL</application> se font par les variables
   curseur, qui sont toujours du type de données spécial <type>refcursor</type>. Un des
   moyens de créer une variable curseur est de simplement la déclarer comme une variable
   de type <type>refcursor</type>. Un autre moyen est d'utiliser la syntaxe de déclaration
   de curseur qui est en général&nbsp;:

   <synopsis><replaceable>nom</replaceable> <optional> <optional> NO </optional> SCROLL </optional> CURSOR <optional> ( <replaceable>arguments</replaceable> ) </optional> FOR <replaceable>requête</replaceable>;
   </synopsis>
   (<literal>FOR</literal> peut être remplacé par <literal>IS</literal> pour la compatibilité avec
   <productname>Oracle</productname>).
   Si <literal>SCROLL</literal> est spécifié, le curseur sera capable d'aller
   en sens inverse&nbsp;; si <literal>NO SCROLL</literal> est indiqué, les
   récupérations en sens inverses seront rejetées&nbsp;; si rien n'est
   indiqué, cela dépend de la requête.
   <replaceable>arguments</replaceable> est une liste de paires de
   <literal><replaceable>nom</replaceable> <replaceable>type-de-donnée</replaceable></literal>
   qui définit les noms devant être remplacés par les valeurs des paramètres dans la requête donnée.
   La valeur effective à substituer pour ces noms sera indiquée plus tard lors de
   l'ouverture du curseur.
  </para>
  <para>
   Quelques exemples&nbsp;:
   <programlisting>DECLARE
    curs1 refcursor;
    curs2 CURSOR FOR SELECT * FROM tenk1;
    curs3 CURSOR (cle integer) FOR SELECT * FROM tenk1 WHERE unique1 = cle;
   </programlisting>
   Ces variables sont toutes trois du type de données <type>refcursor</type>
   mais la première peut être utilisée avec n'importe quelle requête alors que
   la seconde a une requête complètement spécifiée qui lui est déjà
   <firstterm>liée</firstterm>, et la dernière est liée à une requête paramétrée
   (<literal>cle</literal> sera remplacée par un paramètre de valeur entière lors de
   l'ouverture du curseur).
   La variable <literal>curs1</literal> est dite <firstterm>non liée</firstterm> puisqu'elle
   n'est pas liée à une requête particulière.
  </para>
 </sect2>

 <sect2 id="plpgsql-cursor-opening">
  <title>Ouverture de curseurs</title>

  <para>
   Avant qu'un curseur puisse être utilisé pour rapatrier des lignes, il doit être
   <firstterm>ouvert</firstterm> (c'est l'action équivalente de la commande SQL
   <command>DECLARE CURSOR</command>). <application>PL/pgSQL</application>
   dispose de trois formes pour
   l'instruction <command>OPEN</command>, dont deux utilisent des variables curseur non liées
   et la dernière une variable curseur liée.
  </para>

  <note>
   <para>
    Les variables des curseurs liés peuvent aussi être utilisés sans les ouvrir
    explicitement, via l'instruction <command>FOR</command> décrite dans
    <xref linkend="plpgsql-cursor-for-loop"/>.
   </para>
  </note>

  <sect3>
   <title><command>OPEN FOR</command> <replaceable>requête</replaceable></title>

   <synopsis>OPEN <replaceable>var_curseur_nonlie</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR <replaceable>requete</replaceable>;
   </synopsis>

   <para>
    La variable curseur est ouverte et reçoit la requête spécifiée à
    exécuter. Le curseur ne peut pas être déjà ouvert, et il doit avoir
    été déclaré comme une variable de curseur non lié (c'est-à-dire comme
    une simple variable <type>refcursor</type>). La requête doit être un
    <command>SELECT</command> ou quelque chose d'autre qui renvoie des
    lignes (comme <command>EXPLAIN</command>). La requête est traitée de la même
    façon que les autres commandes SQL dans <application>PL/pgSQL</application>&nbsp;:
    les noms de variables <application>PL/pgSQL</application> sont substitués et
    le plan de requête est mis en cache pour une possible ré-utilisation.
    Quand une variable <application>PL/pgSQL</application> est substituée
    dans une requête de type curseur, la valeur qui est substituée est celle
    qu'elle avait au moment du <command>OPEN</command>&nbsp;; les modifications
    ultérieures n'auront pas affectées le comportement du curseur.
    Les options <literal>SCROLL</literal> et <literal>NO SCROLL</literal>
    ont la même signification que pour un curseur lié.
   </para>

   <para>
    Exemple&nbsp;:
    <programlisting>OPEN curs1 FOR SELECT * FROM foo WHERE cle = ma_cle;
    </programlisting>
   </para>
  </sect3>

  <sect3>
   <title><command>OPEN FOR EXECUTE</command></title>

   <synopsis>OPEN <replaceable>var_curseur_nonlie</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR EXECUTE <replaceable class="command">requete</replaceable>
                                     <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
   </synopsis>

   <para>
    La variable curseur est ouverte et reçoit la requête spécifiée à exécuter.
    Le curseur ne peut pas être déjà ouvert et il doit avoir été déclaré comme
    une variable de
    curseur non lié (c'est-à-dire comme une simple variable <type>refcursor</type>).
    La requête est spécifiée comme une expression chaîne de la même façon que
    dans une commande <command>EXECUTE</command>. Comme d'habitude, ceci donne
    assez de flexibilité pour que le plan de la requête puisse changer d'une
    exécution à l'autre (voir la <xref linkend="plpgsql-plan-caching"/>),
    et cela signifie aussi que la substitution de variable n'est pas faite
    sur la chaîne de commande. Comme avec la commande <command>EXECUTE</command>,
    les valeurs de paramètre peuvent être insérées dans la commande dynamique avec
    <literal>format()</literal> ou <literal>USING</literal>. Les options <literal>SCROLL</literal> et
    <literal>NO SCROLL</literal> ont la même signification que pour un
    curseur lié.
   </para>

   <para>
    Exemple&nbsp;:
    <programlisting>OPEN curs1 FOR EXECUTE format('SELECT * FROM %I WHERE nom_colonne = $1', ma_table) USING valeur_clef;
    </programlisting>
    Dans cet exemple, le nom de la table est inséré dans la requête
    via la fonction <function>format()</format>. La valeur de la colonne
    <literal>nom_colonne</literal> utilisée pour la comparaison est
    insérée via le paramètre <literal>USING</literal>, c'est la raison
    pour laquelle elle n'a pas besoin d'être échappée.
   </para>
  </sect3>

  <sect3 id="plpgsql-open-bound-cursor">
   <title>Ouverture d'un curseur lié</title>

   <synopsis>OPEN <replaceable>var_curseur_lié</replaceable> <optional> ( <optional> <replaceable>nom_argument</replaceable> := </optional> <replaceable>valeur_argument</replaceable> <optional>, ...</optional> ) </optional>;
   </synopsis>

   <para>
    Cette forme d'<command>OPEN</command> est utilisée pour ouvrir une variable
    curseur à laquelle la requête est liée au moment de la déclaration.
    Le curseur ne peut pas être déjà ouvert. Une liste des expressions arguments
    doit apparaître si et seulement si le curseur a été déclaré comme acceptant
    des arguments. Ces valeurs seront remplacées dans la requête.
   </para>

   <para>
    Le plan de
    requête pour un curseur lié est toujours considéré comme pouvant être mis
    en cache&nbsp;; il n'y a pas d'équivalent de la commande
    <command>EXECUTE</command> dans ce cas. Notez que
    <literal>SCROLL</literal> et <literal>NO SCROLL</literal> ne peuvent
    pas être indiqués dans <command>OPEN</command> car le comportement du curseur était déjà déterminé.
   </para>

   <para>
    Les valeurs des arguments peuvent être passées en utilisant soit la
    notation <firstterm>en position</firstterm> soit la notation
    <firstterm>nommée</firstterm>. Dans la première, tous les arguments sont
    indiqués dans l'ordre. Dans la seconde, chaque nom d'argument est
    indiqué en utilisant <literal>:=</literal> pour la séparer de
    l'expression de l'argument. De façon similaire à l'appel de fonctions,
    décrit dans <xref linkend="sql-syntax-calling-funcs"/>, il est aussi
    autorisé de mixer notation en position et notation nommée.
   </para>

   <para>
    Voici quelques exemples (ils utilisent les exemples de déclaration
    de curseur ci-dessus)&nbsp;:
    <programlisting>
OPEN curs2;
OPEN curs3(42);
OPEN curs3(key := 42);
    </programlisting>
   </para>

   <para>
    Comme la substitution de variable est faite sur la requête d'un curseur
    lié, il existe en fait deux façons de passer les valeurs au curseur&nbsp;:
    soit avec un argument explicite pour <command>OPEN</command> soit en
    référençant implicitement une variable <application>PL/pgSQL</application>
    dans la requête. Néanmoins, seules les variables déclarées avant que
    le curseur lié ne soit déclaré lui seront substituées. Dans tous les
    cas, la valeur passée est déterminée au moment de l'exécution de la
    commande <command>OPEN</command>. Par exemple, une autre façon d'obtenir
    le même effet que l'exemple <literal>curs3</literal> ci-dessus est la
    suivante&nbsp;:
    <programlisting>
DECLARE
    key integer;
    curs4 CURSOR FOR SELECT * FROM tenk1 WHERE unique1 = key;
BEGIN
    key := 42;
    OPEN curs4;
    </programlisting>
   </para>
  </sect3>
 </sect2>

 <sect2 id="plpgsql-cursor-using">
  <title>Utilisation des curseurs</title>

  <para>
   Une fois qu'un curseur a été ouvert, il peut être manipulé grâce aux instructions
   décrites ci-dessous.
  </para>

  <para>
   Ces manipulations n'ont pas besoin de se dérouler dans la même fonction que celle
   qui a ouvert le curseur. Vous pouvez renvoyer une valeur <type>refcursor</type>
   à partir d'une fonction et laisser l'appelant opérer sur le curseur
   (d'un point de vue interne, une valeur <type>refcursor</type> est simplement
   la chaîne de caractères du nom d'un portail contenant la requête active
   pour le curseur. Ce nom peut être passé à d'autres, affecté à d'autres variables
   <type>refcursor</type> et ainsi de suite, sans déranger le portail).
  </para>

  <para>
   Tous les portails sont implicitement fermés à la fin de la transaction. C'est pourquoi
   une valeur <type>refcursor</type> est utilisable pour référencer un curseur ouvert
   seulement jusqu'à la fin de la transaction.
  </para>

  <sect3>
   <title><literal>FETCH</literal></title>

   <synopsis>FETCH <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>curseur</replaceable> INTO <replaceable>cible</replaceable>;
   </synopsis>

   <para>
    <command>FETCH</command> récupère la prochaine ligne à partir d'un curseur
    et la place dans une cible, qui peut être une variable ligne, une variable
    record ou une liste de variables simples séparées par des virgules,
    comme dans un <command>SELECT INTO</command>. S'il n'y a pas de ligne
    suivante, la cible est mise à NULL. Comme avec <command>SELECT
     INTO</command>, la variable spéciale <literal>FOUND</literal> peut
    être lue pour voir si une ligne a été récupérée.
   </para>

   <para>
    La clause <replaceable>direction</replaceable> peut être une des
    variantes suivantes autorisées pour la commande SQL <xref
    linkend="sql-fetch"/> sauf celles qui peuvent récupérer plus
    d'une ligne&nbsp;; nommément, cela peut être
    <literal>NEXT</literal>,
    <literal>PRIOR</literal>,
    <literal>FIRST</literal>,
    <literal>LAST</literal>,
    <literal>ABSOLUTE</literal> <replaceable>nombre</replaceable>,
    <literal>RELATIVE</literal> <replaceable>nombre</replaceable>,
    <literal>FORWARD</literal> ou
    <literal>BACKWARD</literal>.
    Omettre <replaceable>direction</replaceable> est identique à spécifier
    <literal>NEXT</literal>. Les valeurs <replaceable>direction</replaceable>
    qui nécessitent d'aller en sens inverse risquent d'échouer sauf si le
    curseur a été déclaré ou ouvert avec l'option <literal>SCROLL</literal>.
   </para>

   <para>
    <replaceable>curseur</replaceable> doit être le nom d'une variable
    <type>refcursor</type> qui référence un portail de curseur ouvert.
   </para>

   <para>
    Exemples&nbsp;:
    <programlisting>
FETCH curs1 INTO rowvar;
FETCH curs2 INTO foo, bar, baz;
FETCH LAST FROM curs3 INTO x, y;
FETCH RELATIVE -2 FROM curs4 INTO x;
    </programlisting>
   </para>
  </sect3>

  <sect3>
   <title><literal>MOVE</literal></title>

   <synopsis>
MOVE <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>curseur</replaceable>;
   </synopsis>

   <para>
    <command>MOVE</command> repositionne un curseur sans récupérer de données.
    <command>MOVE</command> fonctionne exactement comme la commande
    <command>FETCH</command> sauf qu'elle ne fait que repositionner le curseur
    et ne renvoie donc pas les lignes du déplacement. Comme avec <command>SELECT
     INTO</command>, la variable spéciale <literal>FOUND</literal> peut être
    lue pour vérifier s'il y avait bien les lignes correspondant au déplacement.
   </para>

   <para>
    La clause de <replaceable>direction</replaceable> peut être l'une des
    variantes autorisées dna sla commande SQL <xref linkend="sql-fetch"/>,
    nommément
    <literal>NEXT</literal>,
    <literal>PRIOR</literal>,
    <literal>FIRST</literal>,
    <literal>LAST</literal>,
    <literal>ABSOLUTE</literal> <replaceable>nombre</replaceable>,
    <literal>RELATIVE</literal> <replaceable>nombre</replaceable>,
    <literal>ALL</literal>,
    <literal>FORWARD</literal> <optional> <replaceable>nombre</replaceable> | <literal>ALL</literal> </optional>, ou
    <literal>BACKWARD</literal> <optional> <replaceable>nombre</replaceable> | <literal>ALL</literal> </optional>.
    Omettre <replaceable>direction</replaceable> est identique à spécifier
    <literal>NEXT</literal>.
    Les valeurs <replaceable>direction</replaceable> qui nécessitent de se
    déplacer en arrière risquent d'échouer sauf si le curseur a été déclaré ou
    ouvert avec l'option <literal>SCROLL</literal>.
   </para>

   <para>
    Exemples&nbsp;:
    <programlisting>
MOVE curs1;
MOVE LAST FROM curs3;
MOVE RELATIVE -2 FROM curs4;
MOVE FORWARD 2 FROM curs4;
    </programlisting>
   </para>
  </sect3>

  <sect3>
   <title><literal>UPDATE/DELETE WHERE CURRENT OF</literal></title>

   <synopsis>
UPDATE <replaceable>table</replaceable> SET ... WHERE CURRENT OF <replaceable>curseur</replaceable>;
DELETE FROM <replaceable>table</replaceable> WHERE CURRENT OF <replaceable>curseur</replaceable>;
   </synopsis>

   <para>
    Quand un curseur est positionné sur une ligne d'une table, cette ligne
    peut être mise à jour ou supprimée en utilisant le curseur qui identifie
    la ligne. Il existe des restrictions sur ce que peut être la requête
    du curseur (en particulier, pas de regroupement) et il est mieux
    d'utiliser <literal>FOR UPDATE</literal> dans le curseur. Pour des
    informations supplémentaires, voir la page de référence <xref
    linkend="sql-declare"/>.
   </para>

   <para>
    Un exemple&nbsp;:
    <programlisting>
UPDATE foo SET valdonnee = mavaleur WHERE CURRENT OF curs1;
    </programlisting>
   </para>
  </sect3>

  <sect3>
   <title><literal>CLOSE</literal></title>

   <synopsis>CLOSE <replaceable>curseur</replaceable>;
   </synopsis>

   <para>
    <command>CLOSE</command> ferme le portail sous-tendant un curseur ouvert. Ceci peut
    être utilisé pour libérer des ressources avant la fin de la transaction ou pour
    libérer la variable curseur pour pouvoir la réouvrir.
   </para>

   <para>
    Exemple&nbsp;:
    <programlisting>CLOSE curs1;
    </programlisting>
   </para>
  </sect3>

  <sect3>
   <title>Renvoi de curseurs</title>

   <para>
    Les fonctions <application>PL/pgSQL</application> peuvent renvoyer des curseurs
    à l'appelant. Ceci est utile pour renvoyer plusieurs lignes ou
    colonnes, spécialement avec des ensembles de résultats très grands.
    Pour cela, la fonction ouvre le curseur et renvoie le nom du curseur
    à l'appelant (ou simplement ouvre le curseur en utilisant un nom de
    portail spécifié par ou autrement connu par l'appelant). L'appelant
    peut alors récupérer les lignes à partir du curseur. Le curseur
    peut être fermé par l'appelant ou il sera fermé automatiquement à la
    fin de la transaction.
   </para>

   <para>
    Le nom du portail utilisé pour un curseur peut être spécifié par le
    développeur ou peut être généré automatiquement. Pour spécifier un
    nom de portail, affectez simplement une chaîne à la variable
    <type>refcursor</type> avant de l'ouvrir. La valeur de la
    variable <type>refcursor</type> sera utilisée par <command>OPEN</command> comme
    nom du portail sous-jacent. Néanmoins, si la variable
    <type>refcursor</type> est NULL, <command>OPEN</command> génère automatiquement
    un nom qui n'entre pas en conflit avec tout portail existant et
    l'affecte à la variable <type>refcursor</type>.
   </para>

   <note>
    <para>
     Une variable curseur avec limites est initialisée avec la valeur de
     la chaîne représentant son nom, de façon à ce que le nom du portail
     soit identique au nom de la variable curseur, sauf si le développeur
     le surcharge par affectation avant d'ouvrir le curseur. Mais, une
     variable curseur sans limite aura par défaut la valeur NULL, dont il
     reçoit un nom unique généré automatiquement sauf s'il est surchargé.
    </para>
   </note>

   <para>
    L'exemple suivant montre une façon de fournir un nom de curseur par
    l'appelant&nbsp;:

    <programlisting>CREATE TABLE test (col text);
INSERT INTO test VALUES ('123');

CREATE FUNCTION fonction_reference(refcursor) RETURNS refcursor AS $$
BEGIN
    OPEN $1 FOR SELECT col FROM test;
    RETURN $1;
END;
$$ LANGUAGE plpgsql;

BEGIN;
SELECT fonction_reference('curseur_fonction');
FETCH ALL IN curseur_fonction;
COMMIT;
    </programlisting>
   </para>

   <para>
    L'exemple suivant utilise la génération automatique du nom du
    curseur&nbsp;:

    <programlisting>CREATE FUNCTION fonction_reference2() RETURNS refcursor AS $$
DECLARE
    ref refcursor;
BEGIN
    OPEN ref FOR SELECT col FROM test;
    RETURN ref;
END;
$$ LANGUAGE plpgsql;

-- Il faut être dans une transaction pour utiliser les curseurs.
BEGIN;
SELECT fonction_reference2();

   fonction_reference2
--------------------------
 &lt;unnamed cursor 1&gt;
(1 row)

FETCH ALL IN "&lt;unnamed cursor 1&gt;";
COMMIT;
    </programlisting>
   </para>

   <para>
    L'exemple suivant montre une façon de renvoyer plusieurs curseurs à une
    seule fonction&nbsp;:

    <programlisting>CREATE FUNCTION ma_fonction(refcursor, refcursor) RETURNS SETOF refcursor AS $$
BEGIN
    OPEN $1 FOR SELECT * FROM table_1;
    RETURN NEXT $1;
    OPEN $2 FOR SELECT * FROM table_2;
    RETURN NEXT $2;
END;
$$ LANGUAGE plpgsql;

-- doit être dans une transaction pour utiliser les curseurs.
BEGIN;

SELECT * FROM ma_fonction('a', 'b');

FETCH ALL FROM a;
FETCH ALL FROM b;
COMMIT;
    </programlisting>
   </para>
  </sect3>
 </sect2>

 <sect2 id="plpgsql-cursor-for-loop">
  <title>Boucler dans les résultats d'un curseur</title>

  <para>
   C'est une variante de l'instruction <command>FOR</command> qui permet
   l'itération sur les lignes renvoyées par un curseur. La syntaxe est&nbsp;:

   <synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>var_record</replaceable> IN <replaceable>var_curseur_lié</replaceable> <optional> ( <optional> <replaceable>nom_argument</replaceable> := </optional> <replaceable>valeur_argument</replaceable> <optional>, ...</optional> ) </optional> LOOP
    <replaceable>instructions</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
   </synopsis>

   La variable curseur doit avoir été liée à une requête lors de sa déclaration
   et il <emphasis>ne peut pas</emphasis> être déjà ouvert. L'instruction
   <command>FOR</command> ouvre automatiquement le curseur, et il ferme
   le curseur en sortie de la boucle. Une liste des expressions de valeurs
   des arguments doit apparaître si et seulement si le curseur a été déclaré
   prendre des arguments. Ces valeurs seront substitutées dans la requête,
   de la même façon que lors d'un <command>OPEN</command> (voir <xref
   linkend="plpgsql-open-bound-cursor"/>).
  </para>

  <para>
   La variable
   variable <replaceable>var_record</replaceable> est définie automatiquement
   avec le type <type>record</type> et existe seulement dans la boucle (toute
   définition existante d'un nom de variable est ignorée dans la boucle).
   Chaque ligne renvoyée par le curseur est successivement affectée à la variable
   d'enregistrement et le corps de la boucle est exécuté.
  </para>
 </sect2>

</sect1>

<sect1 id="plpgsql-errors-and-messages">
 <title>Erreurs et messages</title>

  <sect2 id="plpgsql-statements-raise">
   <title>Rapporter des erreurs et messages</title>

 <indexterm>
  <primary>RAISE</primary>
    <secondary>en PL/pgSQL</secondary>
 </indexterm>

 <indexterm>
  <primary>rapporter des erreurs</primary>
  <secondary>en PL/PgSQL</secondary>
 </indexterm>

 <para>
  Utilisez l'instruction <command>RAISE</command> pour rapporter des messages et
  lever des erreurs.

  <synopsis>RAISE <optional> <replaceable class="parameter">niveau</replaceable> </optional> '<replaceable class="parameter">format</replaceable>' <optional>, <replaceable class="parameter">expression</replaceable> <optional>, ...</optional></optional> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">niveau</replaceable> </optional> <replaceable class="parameter">nom_condition</replaceable> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">niveau</replaceable> </optional> SQLSTATE '<replaceable class="parameter">état_sql</replaceable>' <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">niveau</replaceable> </optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional>;
RAISE ;
  </synopsis>

  L'option <replaceable class="parameter">niveau</replaceable> indique la
  sévérité de l'erreur. Les niveaux autorisés sont <literal>DEBUG</literal>,
  <literal>LOG</literal>, <literal>INFO</literal>, <literal>NOTICE</literal>,
  <literal>WARNING</literal> et <literal>EXCEPTION</literal>, ce dernier étant
  la valeur par défaut.
  <literal>EXCEPTION</literal> lève une erreur (ce qui annule habituellement
  la transaction en cours). Les autres niveaux ne font que générer des messages aux
  différents niveaux de priorité.
  Les variables de configuration <xref linkend="guc-log-min-messages"/> et
  <xref linkend="guc-client-min-messages"/> contrôlent l'envoi de messages
  dans les traces, au client ou aux deux. Voir le
  <xref linkend="runtime-config"/> pour plus d'informations.
 </para>

 <para>
  Après <replaceable class="parameter">niveau</replaceable>, vous pouvez
  écrire un <replaceable class="parameter">format</replaceable>
  (qui doit être une chaîne litérale, pas une expression). La chaîne format
  indique le texte du message d'erreur à rapporter. Elle peut être suivie
  par des expressions optionnelles à insérer dans le message. Dans la chaîne,
  <literal>%</literal> est remplacé par la représentation de la valeur du
  prochain argument. Écrivez <literal>%%</literal> pour saisir un
  <literal>%</literal> litéral.
  Le nombre des arguments doit correspondre au nombre de
  <literal>%</literal> dans la chaîne format, sinon une erreur est
  levée durant la compilation de la fonction.
 </para>

 <para>
  Dans cet exemple, la valeur de <literal>v_job_id</literal> remplace le <literal>%</literal>
  dans la chaîne.
  <programlisting>RAISE NOTICE 'Appel de cs_creer_job(%)', v_job_id;
  </programlisting>
 </para>

 <para>
  Vous pouvez attacher des informations supplémentaires au rapport d'erreur
  en écrivant <literal>USING</literal> suivi par des éléments <replaceable
  class="parameter">option</replaceable> = <replaceable
  class="parameter">expression</replaceable>. Chaque
  <replaceable class="parameter">expression</replaceable> peut valoir n'importe
  quel expression sous forme de chaîne. Les mots clés autorisés <replaceable
  class="parameter">option</replaceable> sont&nbsp;:

  <variablelist id="raise-using-options">
   <varlistentry>
    <term><literal>MESSAGE</literal></term>
    <listitem>
     <para>Configure le texte du message d'erreur. Cette option ne peut pas
      être utilisée dans la forme d'un <command>RAISE</command> qui inclut
      une chaîne de format avec <literal>USING</literal>.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DETAIL</literal></term>
    <listitem>
     <para>Fournit un message de détail sur l'erreur.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>HINT</literal></term>
    <listitem>
     <para>Fournit un message de conseil sur l'erreur.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ERRCODE</literal></term>
    <listitem>
     <para>Spécifie le code d'erreur (SQLSTATE) à rapporter, soit par son nom
      de condition comme indiqué dans <xref linkend="errcodes-appendix"/>, soit
      directement sous la forme d'un code SQLSTATE sur cinq caractères.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>COLUMN</literal></term>
    <term><literal>CONSTRAINT</literal></term>
    <term><literal>DATATYPE</literal></term>
    <term><literal>TABLE</literal></term>
    <term><literal>SCHEMA</literal></term>
    <listitem>
     <para>Fournit le nom de l'objet.</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </para>

 <para>
  Cet exemple annulera la transaction avec le message d'erreur et l'astuce
  donnés&nbsp;:
  <programlisting>
RAISE EXCEPTION 'Nonexistent ID --> %', user_id
 USING HINT = 'Please check your user id';
 </programlisting>
</para>

<para>
 Ces deux exemples affichent des façons équivalents pour initialiser
 SQLSTATE&nbsp;:
 <programlisting>
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = 'unique_violation';
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = '23505';
 </programlisting>
</para>

<para>
 Il existe une deuxième syntaxe <command>RAISE</command> pour laquelle
 l'argument principale est le nom de la condition ou le SQLSTATE à rapporter,
 par exemple&nbsp;:
 <programlisting>
RAISE division_by_zero;
RAISE SQLSTATE '22012';
 </programlisting>
 Dans cette syntaxe, <literal>USING</literal> peut être utilisé pour fournir
 un message d'erreur, un détail ou une astuce personnalisé. Voici une autre
 façon de faire l'exemple précédent&nbsp;:
 <programlisting>
RAISE unique_violation USING MESSAGE = 'Duplicate user ID: ' || user_id;
 </programlisting>
</para>

<para>
 Une autre variante est d'écrire <literal>RAISE USING</literal> ou <literal>RAISE
  <replaceable class="parameter">niveau</replaceable> USING</literal> et de placer
 tout le reste dans la liste <literal>USING</literal>.
</para>

<para>
 La dernière variante de <command>RAISE</command> n'a aucun paramètre. Cette
 forme peut seulement être utilisée dans un bloc <literal>BEGIN</literal>
 d'une clause <literal>EXCEPTION</literal>&nbsp;; cela fait que l'erreur est
 renvoyée.
</para>

<note>
 <para>
  Avant <productname>PostgreSQL</productname> 9.1,
  <command>RAISE</command> sans paramètres était interprété comme
  un renvoi de l'erreur à partir du bloc contenant le gestionnaire
  actif d'exceptions. Du coup, une clause <literal>EXCEPTION</literal>
  imbriquée dans ce gestionnaire ne la récupérerait pas, même si le
  <command>RAISE</command> était intégrée dans le bloc de la clause
  <literal>EXCEPTION</literal>. C'était très surprenant et
  incompatible avec PL/SQL d'Oracle.
 </para>
</note>

<para>
 Si aucun nom de condition ou SQLSTATE n'est indiqué dans une commande
 <command>RAISE EXCEPTION</command>, la valeur par défaut est d'utiliser
 <literal>RAISE_EXCEPTION</literal> (<literal>P0001</literal>). Si aucun
 message texte n'est indiqué, la valeur par défaut est d'utiliser le nom
 de la condition ou le SQLSTATE comme texte de message.
</para>

<note>
 <para>
  Lors de la spécification du code d'erreur par un code SQLSTATE, vous n'êtes
  pas limité aux codes d'erreur prédéfinis, mais pouvez sélectionner tout
  code d'erreur consistant en cinq chiffres et/ou des lettres ASCII
  majuscules, autre que <literal>00000</literal>. Il est recommandé d'éviter
  d'envoyer des codes d'erreur qui se terminent avec trois zéros car il y a
  des codes de catégorie, et peuvent seulement être récupérés en filtrant
  la catégorie complète.
 </para>
</note>
  </sect2>

  <sect2 id="plpgsql-statements-assert">
   <title>Vérification d'assertions</title>

   <indexterm>
    <primary>ASSERT</primary>
    <secondary>en PL/pgSQL</secondary>
   </indexterm>

   <indexterm>
    <primary>assertions</primary>
    <secondary>en PL/pgSQL</secondary>
   </indexterm>

   <indexterm>
    <primary><varname>plpgsql.check_asserts</varname> paramètre de configuration</primary>
   </indexterm>

   <para>
    L'instruction <command>ASSERT</command> est un moyen pratique
    d'insérer dans les fonctions <application>PL/pgSQL</application>
    des vérifications d'assertions.

<synopsis>
ASSERT <replaceable class="parameter">condition</replaceable> <optional> , <replaceable class="parameter">message</replaceable> </optional>;
</synopsis>

    La <replaceable class="parameter">condition</replaceable>
    est une expression booléenne qui est censée être toujours
    vraie. Si c'est le cas l'instruction <command>ASSERT</command>
    ne fait rien. Si le résultat est faux ou nul, alors une
    exception <literal>ASSERT_FAILURE</literal> est levée (si
    une erreur survient lors de l'évaluation de la <replaceable
    class="parameter">condition</replaceable>, elle est rapportée
    normalement).
   </para>

   <para>
    Si le <replaceable class="parameter">message</replaceable>
    optionnel est fourni, cela doit être une expression dont
    le résultat (si non nul) remplacera le message d'erreur par
    défaut <quote>assertion failed</quote>, si la <replaceable
    class="parameter">condition</replaceable> est fausse. L'expression
    <replaceable class="parameter">message</replaceable> n'est pas
    évaluée dans le cas normal où l'assertion est vraie.
   </para>

   <para>
    La vérification des assertions peut être activée
    ou désactivée via le paramètre de configuration
    <literal>plpgsql.check_asserts</literal> qui prend une valeur
    booléenne, par défaut à <literal>on</literal>. Si ce
    paramètre est à <literal>off</literal> alors l'instruction
    <command>ASSERT</command> ne fait rien.
   </para>

   <para>
    Notez que l'instruction <command>ASSERT</command> sert à
    détecter des erreurs de programmation, pas à rapporter des
    erreurs ordinaires. Pour cela veuillez utiliser l'instruction
    <command>RAISE</command> décrite ci-dessus.
   </para>

  </sect2>

</sect1>

<sect1 id="plpgsql-trigger">
<title>Procédures trigger</title>

<indexterm zone="plpgsql-trigger">
 <primary>déclencheur (trigger)</primary>
 <secondary>en PL/pgSQL</secondary>
</indexterm>

<sect2 id="plpgsql-dml-trigger">
 <title>Triggers sur les modifications de données data changes</title>

 <para>
  <application>PL/pgSQL</application> peut être utilisé pour définir des
  procédures trigger. Une procédure trigger est créée grâce à la commande
  <command>CREATE FUNCTION</command> utilisée comme fonction sans arguments
  ayant un type de retour <type>trigger</type>.  Notez que la fonction
  doit être déclarée avec aucun argument même si elle s'attend à recevoir
  les arguments spécifiés dans <command>CREATE TRIGGER</command> &mdash;
  les arguments trigger sont passés via <varname>TG_ARGV</varname>, comme décrit plus
  loin.
 </para>

 <para>
  Quand une fonction <application>PL/pgSQL</application> est appelée en tant que
  trigger, plusieurs variables spéciales sont créées automatiquement dans le bloc de
  plus haut niveau. Ce sont&nbsp;:

  <variablelist>
   <varlistentry>
    <term><varname>NEW</varname></term>
    <listitem>
     <para>
      Type de données <type>RECORD</type>&nbsp;; variable contenant la nouvelle
      ligne de base de données pour les opérations <command>INSERT</command> /
      <command>UPDATE</command> dans les triggers de niveau ligne. Cette
      variable est non initialisée dans un trigger de niveau instruction et
      pour les opérations <command>DELETE</command>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>OLD</varname></term>
    <listitem>
     <para>
      Type de données <type>RECORD</type>&nbsp;; variable contenant l'ancienne ligne de
      base de données pour les opérations <command>UPDATE</command>/<command>DELETE</command>
      dans les triggers de niveau ligne. Cette variable est non initialisée
      dans les triggers de niveau instruction et pour les opérations
      <command>INSERT</command>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>TG_NAME</varname></term>
    <listitem>
     <para>
      Type de données <type>name</type>&nbsp;; variable qui contient le nom du trigger réellement
      lancé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>TG_WHEN</varname></term>
    <listitem>
     <para>
      Type de données <type>text</type>&nbsp;; une chaîne, soit  <literal>BEFORE</literal>
      soit <literal>AFTER</literal>, soit <literal>INSTEAD OF</literal> selon la définition du trigger.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>TG_LEVEL</varname></term>
    <listitem>
     <para>
      Type de données <type>text</type>&nbsp;; une chaîne, soit <literal>ROW</literal> soit
      <literal>STATEMENT</literal>, selon la définition du trigger.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>TG_OP</varname></term>
    <listitem>
     <para>
      Type de données <type>text</type>&nbsp;; une chaîne, <literal>INSERT</literal>,
      <literal>UPDATE</literal>, <literal>DELETE</literal> ou
      <literal>TRUNCATE</literal>
      indiquant pour quelle opération le trigger a été lancé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>TG_RELID</varname></term>
    <listitem>
     <para>
      Type de données <type>oid</type>&nbsp;; l'ID de l'objet de la table qui a causé
      le déclenchement du trigger.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>TG_RELNAME</varname></term>
    <listitem>
     <para>
      Type de données <type>name</type>&nbsp;; le nom de la table qui a causé
      le déclenchement. C'est obsolète et pourrait disparaître dans une
      prochaine version. À la place, utilisez <literal>TG_TABLE_NAME</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>TG_TABLE_NAME</varname></term>
    <listitem>
     <para>
      Type de données <type>name</type>&nbsp;; le nom de la table qui a
      déclenché le trigger.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>TG_TABLE_SCHEMA</varname></term>
    <listitem>
     <para>
      Type de données <type>name</type>&nbsp;; le nom du schéma de la table qui
      a appelé le trigger.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>TG_NARGS</varname></term>
    <listitem>
     <para>
      Type de données <type>integer</type>&nbsp;; le nombre d'arguments donnés à la procédure
      trigger dans l'instruction <command>CREATE TRIGGER</command>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>TG_ARGV[]</varname></term>
    <listitem>
     <para>
      Type de donnée <type>text</type>&nbsp;; les arguments de l'instruction
      <command>CREATE TRIGGER</command>.
      L'index débute à 0. Les indices invalides (inférieurs à 0 ou supérieurs ou égaux
      à <varname>tg_nargs</varname>) auront une valeur NULL.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </para>

 <para>
  Une fonction trigger doit renvoyer soit <symbol>NULL</symbol> soit une
  valeur record ayant
  exactement la structure de la table pour laquelle le trigger a été lancé.
 </para>

 <para>
  Les triggers de niveau ligne lancés <literal>BEFORE</literal> peuvent renvoyer NULL
  pour indiquer au gestionnaire de trigger de sauter le reste de l'opération pour
  cette ligne (les triggers suivants ne sont pas lancés, et les
  <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> ne se font pas pour cette
  ligne). Si une valeur non NULL est renvoyée alors l'opération se déroule avec cette
  valeur ligne. Renvoyer une valeur ligne différente de la valeur originale de
  <varname>NEW</varname> modifie la ligne qui sera insérée ou mise à jour.
  De ce fait, si la fonction de trigger veut que l'action réussise sans modifier la
  valeur de rangée, <varname>NEW</varname> (ou une valeur égale) doit être
  renvoyée. Pour modifier la rangée à être stockée, il est possible de
  remplacer les valeurs directement dans <varname>NEW</varname> et renvoyer le
  <varname>NEW</varname> modifié ou de générer un nouvel enregistrement à
  renvoyer. Dans le cas d'un before-trigger sur une commande
  <command>DELETE</command>, la valeur renvoyée n'a aucun effet
  direct mais doit être non-nulle pour permettre à l'action trigger de
  continuer. Notez que <varname>NEW</varname> est nul dans le cadre des
  triggers <command>DELETE</command> et que renvoyer ceci n'est pas recommandé
  dans les cas courants. Une pratique utile dans des triggers <command>DELETE</command>
  serait de renvoyer <varname>OLD</varname>.
 </para>

 <para>
  Les triggers <literal>INSTEAD OF</literal> (qui sont toujours des
  triggers au niveau ligne et peuvent seulement être utilisés sur des
  vues) peuvent renvoyer NULL pour signaler qu'ils n'ont fait aucune
  modification et que le reste de l'opération pour cette ligne doit
  être ignoré (autrement dit, les triggers suivants ne sont pas
  déclenchés et la ligne n'est pas comptée dans le statut des lignes
  affectées pour la requête
  <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>).
  Une valeur différente de NULL doit être renvoyée pour indiquer que
  le trigger a traité l'opération demandée. Pour les opérations
  <command>INSERT</command> et <command>UPDATE</command>, la valeur
  de retour doit être <varname>NEW</varname>, que la fonction trigger
  peut modifier pour supporter une clause <command>RETURNING</command>
  d'une requête <command>INSERT</command> ou <command>UPDATE</command>
    (this will also affect the row value passed to any subsequent triggers,
    or passed to a special <varname>EXCLUDED</varname> alias reference within
    an <command>INSERT</command> statement with an <literal>ON CONFLICT DO
    UPDATE</literal> clause).  For <command>DELETE</command> operations, the return
    value should be <varname>OLD</varname>.
 </para>

 <para>
  La valeur de retour d'un trigger de niveau rangée
  déclenché <literal>AFTER</literal> ou un trigger de niveau instruction
  déclenché <literal>BEFORE</literal> ou <literal>AFTER</literal> est
  toujours ignoré&nbsp;; il pourrait aussi bien être NULL. Néanmoins, tous les
  types de triggers peuvent toujours annuler l'opération complète en
  envoyant une erreur.
 </para>

 <para>
  L'<xref linkend="plpgsql-trigger-example"/> montre un exemple d'une procédure
  trigger dans <application>PL/pgSQL</application>.
 </para>

 <example id="plpgsql-trigger-example">
  <title>Une procédure trigger <application>PL/pgSQL</application> </title>

  <para>
   Cet exemple de trigger assure qu'à chaque moment où une ligne est insérée ou
   mise à jour dans la table, le nom de l'utilisateur courant et l'heure sont estampillés
   dans la ligne. Et cela vous assure qu'un nom d'employé est donné et que le salaire
   est une valeur positive.
  </para>

  <programlisting>CREATE TABLE emp (
    nom_employe text,
    salaire integer,
    date_dermodif timestamp,
    utilisateur_dermodif text
);

CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$
    BEGIN
        -- Verifie que nom_employe et salary sont donnés
        IF NEW.nom_employe IS NULL THEN
            RAISE EXCEPTION 'nom_employe ne peut pas être NULL';
        END IF;
        IF NEW.salaire IS NULL THEN
            RAISE EXCEPTION '% ne peut pas avoir un salaire', NEW.nom_employe;
        END IF;

        -- Qui travaille pour nous si la personne doit payer pour cela ?
        IF NEW.salaire &lt; 0 THEN
            RAISE EXCEPTION '% ne peut pas avoir un salaire négatif', NEW.nom_employe;
        END IF;

        -- Rappelons-nous qui a changé le salaire et quand
        NEW.date_dermodif := current_timestamp;
        NEW.utilisateur_dermodif := current_user;
        RETURN NEW;
    END;
$emp_stamp$ LANGUAGE plpgsql;

CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp
    FOR EACH ROW EXECUTE PROCEDURE emp_stamp();
  </programlisting>
 </example>

 <para>
  Une autre façon de tracer les modifications sur une table implique la
  création d'une nouvelle table qui contient une ligne pour chaque
  insertion, mise à jour ou suppression qui survient. Cette approche peut
  être vue comme un audit des modifications sur une table.
  L'<xref linkend="plpgsql-trigger-audit-example"/> montre un exemple d'une
  procédure d'audit par trigger en <application>PL/pgSQL</application>.
 </para>

 <example id="plpgsql-trigger-audit-example">
  <title>Une procédure d'audit par trigger en
   <application>PL/pgSQL</application></title>

  <para>
   Cet exemple de trigger nous assure que toute insertion,
   modification ou suppression d'une ligne dans la table
   <literal>emp</literal> est enregistrée dans la
   table <literal>emp_audit</literal>. L'heure et le nom de l'utilisateur
   sont conservées dans la ligne avec le type d'opération réalisé.
  </para>

  <programlisting>CREATE TABLE emp (
    nom_employe       text NOT NULL,
    salaire           integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    tampon            timestamp NOT NULL,
    id_utilisateur    text      NOT NULL,
    nom_employe       text      NOT NULL,
    salaire           integer
);

CREATE OR REPLACE FUNCTION audit_employe() RETURNS TRIGGER AS $emp_audit$
BEGIN
    --
    -- Ajoute une ligne dans emp_audit pour refléter l'opération réalisée
    -- sur emp,
    -- utilise la variable spéciale TG_OP pour cette opération.
    --
    IF (TG_OP = 'DELETE') THEN
        INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;
        RETURN OLD;
    ELSIF (TG_OP = 'UPDATE') THEN
        INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;
        RETURN NEW;
    ELSIF (TG_OP = 'INSERT') THEN
        INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;
        RETURN NEW;
    END IF;
    RETURN NULL; -- le résultat est ignoré car il s'agit d'un trigger AFTER
END;
$emp_audit$ language plpgsql;

CREATE TRIGGER emp_audit
    AFTER INSERT OR UPDATE OR DELETE ON emp
    FOR EACH ROW EXECUTE PROCEDURE audit_employe();
  </programlisting>
 </example>

 <para>
  Une variation de l'exemple précédent utilise une vue joignant la
  table principale et la table d'audit pour montrer les derniers
  enregistrements modifiés. Cette approche enregistre toujours toutes
  les modifications sur la table mais présente aussi une vue simple
  de l'audit, n'affichant que le date et heure de la dernière
  modification pour chaque enregistrement. <xref
  linkend="plpgsql-view-trigger-audit-example"/> montre un exemple
  d'un trigger d'audit sur une vue avec
  <application>PL/pgSQL</application>.
 </para>

 <example id="plpgsql-view-trigger-audit-example">
  <title>Une fonction trigger en <application>PL/pgSQL</application>
   surune vue pour un audit</title>

  <para>
   Cet exemple utilise un trigger sur une vue pour la rendre
   modifiable, et s'assure que toute insertion, mise à jour ou
   suppression d'une ligne dans la vue est enregistrée (pour l'audit)
   dans la table <literal>emp_audit</literal>. La date et l'heure courante ainsi que le
   nom de l'utilisateur sont enregistrés, avec le type d'opération
   réalisé pour que la vue affiche la date et l'heure de la dernière
   modification de chaque ligne.
  </para>

  <programlisting>CREATE TABLE emp (
    nom_employe       text PRIMARY KEY,
    salaire           integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    id_utilisateur    text      NOT NULL,
    nom_employe       text      NOT NULL,
    salaire           integer,
    dmodif            timestamp NOT NULL
);

CREATE VIEW emp_vue AS
    SELECT e.nom_employe,
           e.salaire,
           max(ea.dmodif) AS derniere_modification
      FROM emp e
      LEFT JOIN emp_audit ea ON ea.nom_employe = e.nom_employe
     GROUP BY 1, 2;

CREATE OR REPLACE FUNCTION miseajour_emp_vue() RETURNS TRIGGER AS $$
    BEGIN
        --
        -- Perform the required operation on emp, and create a row in emp_audit
        -- to reflect the change made to emp.
        --
        IF (TG_OP = 'DELETE') THEN
            DELETE FROM emp WHERE nom_employe = OLD.nom_employe;
            IF NOT FOUND THEN RETURN NULL; END IF;

            OLD.derniere_modification = now();
            INSERT INTO emp_audit VALUES('D', user, OLD.*);
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            UPDATE emp SET salary = NEW.salary WHERE nom_employe = OLD.nom_employe;
            IF NOT FOUND THEN RETURN NULL; END IF;

            NEW.derniere_modification = now();
            INSERT INTO emp_audit VALUES('U', user, NEW.*);
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp VALUES(NEW.nom_employe, NEW.salaire);

            NEW.derniere_modification = now();
            INSERT INTO emp_audit VALUES('I', user, NEW.*);
            RETURN NEW;
        END IF;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
INSTEAD OF INSERT OR UPDATE OR DELETE ON emp_vue
    FOR EACH ROW EXECUTE PROCEDURE miseajour_emp_vue();
  </programlisting>
 </example>

 <para>
  Une utilisation des triggers est le maintien d'une table résumée
  d'une autre table. Le résumé résultant peut être utilisé à la place de
  la table originale pour certaines requêtes &mdash; souvent avec des
  temps d'exécution bien réduits. Cette technique est souvent utilisée
  pour les statistiques de données où les tables de données mesurées ou
  observées (appelées des tables de faits) peuvent être extrêmement
  grandes. L'<xref linkend="plpgsql-trigger-summary-example"/> montre un
  exemple d'une procédure trigger en
  <application>PL/pgSQL</application> maintenant une table résumée pour
  une table de faits dans un système de données (data warehouse).
 </para>


 <example id="plpgsql-trigger-summary-example">
  <title>Une procédure trigger <application>PL/pgSQL</application>
   pour maintenir une table résumée</title>

  <para>
   Le schéma détaillé ici est partiellement basé sur l'exemple du
   <emphasis>Grocery Store</emphasis> provenant de <emphasis>The Data
    Warehouse Toolkit</emphasis> par Ralph Kimball.
  </para>

  <programlisting>--
-- Tables principales - dimension du temps de ventes.
--
CREATE TABLE time_dimension (
  time_key                    integer NOT NULL,
  day_of_week                 integer NOT NULL,
  day_of_month                integer NOT NULL,
  month                       integer NOT NULL,
  quarter                     integer NOT NULL,
  year                        integer NOT NULL
);
CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);

CREATE TABLE sales_fact (
  time_key                    integer NOT NULL,
  product_key                 integer NOT NULL,
  store_key                   integer NOT NULL,
  amount_sold                 numeric(12,2) NOT NULL,
  units_sold                  integer NOT NULL,
  amount_cost                 numeric(12,2) NOT NULL
);
CREATE INDEX sales_fact_time ON sales_fact(time_key);

--
-- Table résumé - ventes sur le temps.
--
CREATE TABLE sales_summary_bytime (
  time_key                    integer NOT NULL,
  amount_sold                 numeric(15,2) NOT NULL,
  units_sold                  numeric(12) NOT NULL,
  amount_cost                 numeric(15,2) NOT NULL
);
CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);

--
-- Fonction et trigger pour amender les colonnes résumées
-- pour un UPDATE, INSERT, DELETE.
--
CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER
AS $maint_sales_summary_bytime$
DECLARE
  delta_time_key          integer;
  delta_amount_sold       numeric(15,2);
  delta_units_sold        numeric(12);
  delta_amount_cost       numeric(15,2);
BEGIN

  -- Travaille sur l'ajout/la suppression de montant(s).
  IF (TG_OP = 'DELETE') THEN

    delta_time_key = OLD.time_key;
    delta_amount_sold = -1 * OLD.amount_sold;
    delta_units_sold = -1 * OLD.units_sold;
    delta_amount_cost = -1 * OLD.amount_cost;

  ELSIF (TG_OP = 'UPDATE') THEN

    -- interdit les mises à jour qui modifient time_key -
    -- (probablement pas trop cher, car DELETE + INSERT est la façon la plus
    -- probable de réaliser les modifications).
    IF ( OLD.time_key != NEW.time_key) THEN
      RAISE EXCEPTION 'Update of time_key : % -&gt; % not allowed',
                      OLD.time_key, NEW.time_key;
    END IF;

    delta_time_key = OLD.time_key;
    delta_amount_sold = NEW.amount_sold - OLD.amount_sold;
    delta_units_sold = NEW.units_sold - OLD.units_sold;
    delta_amount_cost = NEW.amount_cost - OLD.amount_cost;

  ELSIF (TG_OP = 'INSERT') THEN

    delta_time_key = NEW.time_key;
    delta_amount_sold = NEW.amount_sold;
    delta_units_sold = NEW.units_sold;
    delta_amount_cost = NEW.amount_cost;

  END IF;


  -- Insertion ou mise à jour de la ligne de résumé avec les nouvelles valeurs.
  &lt;&lt;insert_update&gt;&gt;
  LOOP
  UPDATE sales_summary_bytime
  SET amount_sold = amount_sold + delta_amount_sold,
    units_sold = units_sold + delta_units_sold,
    amount_cost = amount_cost + delta_amount_cost
    WHERE time_key = delta_time_key;

    EXIT insert_update WHEN found;

    BEGIN
      INSERT INTO sales_summary_bytime (
        time_key,
        amount_sold,
        units_sold,
        amount_cost)
        VALUES (
        delta_time_key,
        delta_amount_sold,
        delta_units_sold,
        delta_amount_cost
        );
      EXIT insert_update;

      EXCEPTION
      WHEN UNIQUE_VIOLATION THEN
      -- do nothing
      END;
      END LOOP insert_update;

  RETURN NULL;

END;
$maint_sales_summary_bytime$ LANGUAGE plpgsql;

CREATE TRIGGER maint_sales_summary_bytime
  AFTER INSERT OR UPDATE OR DELETE ON sales_fact
  FOR EACH ROW EXECUTE PROCEDURE maint_sales_summary_bytime();

INSERT INTO sales_fact VALUES(1,1,1,10,3,15);
INSERT INTO sales_fact VALUES(1,2,1,20,5,35);
INSERT INTO sales_fact VALUES(2,2,1,40,15,135);
INSERT INTO sales_fact VALUES(2,3,1,10,1,13);
SELECT * FROM sales_summary_bytime;
DELETE FROM sales_fact WHERE product_key = 1;
SELECT * FROM sales_summary_bytime;
UPDATE sales_fact SET units_sold = units_sold * 2;
SELECT * FROM sales_summary_bytime;
  </programlisting>
 </example>

</sect2>

<sect2 id="plpgsql-event-trigger">
 <title>Triggers sur des événements</title>

 <para>
  <application>PL/pgSQL</application> peut être utilisé pour définir des
  triggers sur des événements. <productname>PostgreSQL</productname> requiert
  qu'une procédure qui doit appelée en tant que trigger d'événement soit
  déclarée sans argument et avec un type <literal>event_trigger</literal> en
  retour.
 </para>

 <para>
  Quand une fonction <application>PL/pgSQL</application> est appelée en tant
  que trigger d'événement, plusieurs variables spéciales sont créées
  automatiquement dans son bloc de niveau haut. Les voici&nbsp;:

  <variablelist>
   <varlistentry>
    <term><varname>TG_EVENT</varname></term>
    <listitem>
     <para>
      Type de données <type>text</type>&nbsp;; une chaîne représentant
      l'événement pour lequel le trigger est déclenché.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>TG_TAG</varname></term>
    <listitem>
     <para>
      Type de données <type>text</type>&nbsp;; variable contenant la balise
      commande pour laquelle le trigger a été déclenché.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </para>

 <para>
  <xref linkend="plpgsql-event-trigger-example"/> montre un exemple d'une
  procédure pour un trigger d'événement écrit en
  <application>PL/pgSQL</application>.
 </para>

 <example id="plpgsql-event-trigger-example">
  <title>Une procédure <application>PL/pgSQL</application> pour un trigger
   d'événement</title>

  <para>
   Cet exemple de trigger lève simplement un message <literal>NOTICE</literal>
   à chaque fois qu'une commande supportée est exécutée.
  </para>

  <programlisting>
CREATE OR REPLACE FUNCTION rapporte() RETURNS event_trigger AS $$
BEGIN
    RAISE NOTICE 'rapporte: % %', tg_event, tg_tag;
END;
$$ LANGUAGE plpgsql;

CREATE EVENT TRIGGER rapporte ON ddl_command_start EXECUTE PROCEDURE rapporte();
  </programlisting>
 </example>
</sect2>
</sect1>

<sect1 id="plpgsql-implementation">
<title>Les dessous de <application>PL/pgSQL</application></title>

<para>
 Cette section discute des détails d'implémentation les plus importants
 à connaître pour les utilisateurs de <application>PL/pgSQL</application>.
</para>

<sect2 id="plpgsql-var-subst">
 <title>Substitution de variables</title>

 <para>
  Les instructions et expressions SQL au sein d'une fonction <application>PL/pgSQL</application>
  peuvent faire appel aux variables et paramètres d'une fonction. En coulisses,
  <application>PL/pgSQL</application> remplace les paramètres de requêtes par des références.
  Les paramètres ne seront remplacés qu'aux endroits où un paramètre ou
  une référence de colonne sont autorisés par la syntaxe. Pour un cas extrême, considerez
  cet exemple de mauvaise programmation&nbsp;:
  <programlisting>
        INSERT INTO foo (foo) VALUES (foo);
  </programlisting>
  La première occurrence de <literal>foo</literal> doit être un nom de table, d'après
  la syntaxe et ne sera donc pas remplacée, même si la fonction a une variable
  nommée <literal>foo</literal>. La deuxième occurrence doit être le nom d'une
  colonne de la table et ne sera donc pas remplacée non plus. Seule la
  troisième occurrence peuvent être une référence à la variable de la
  fonction.
 </para>

 <note>
  <para>
   Les versions de <productname>PostgreSQL</productname> avant la 9.0 remplaçaient
   la variable dans les trois cas, donnant lieu à des erreurs de syntaxe.
  </para>
 </note>

 <para>
  Les noms de variables n'étant pas différents des noms de colonnes,
  d'après la syntaxe, il peut y avoir ambuiguité dans les instructions qui font
  référence aux deux&nbsp;: un nom donné fait-il référence à un nom de colonne
  ou à une variable&nbsp;?
  Modifions l'exemple précédent.
  <programlisting>
        INSERT INTO dest (col) SELECT foo + bar FROM src;
  </programlisting>
  Ici, <literal>dest</literal> et <literal>src</literal> doivent être des noms de table et
  <literal>col</literal> doit être une colonne de <literal>dest</literal> mais <literal>foo</literal>
  et <literal>bar</literal> peuvent être aussi bien des variables de la fonction
  que des colonnes de <literal>src</literal>.
 </para>

 <para>
  Par défait, <application>PL/pgSQL</application> signalera une erreur si un nom
  dans une requête SQL peut faire référence à la fois à une variable et à une colonne.
  Vous pouvez corriger ce problème en renommant la variable ou colonne,
  en qualifiant la référence ambigüe ou en précisant à
  <application>PL/pgSQL</application> quelle est l'interpretation à privilégier.
 </para>

 <para>
  Le choix le plus simple est de renommer la variable ou colonne.
  Une règle de codage récurrente est d'utiliser une
  convention de nommage différente pour les variables de
  <application>PL/pgSQL</application> que pour les noms de colonne. Par exemple,
  si vous utilisez toujours des variables de fonctions en
  <literal>v_<replaceable>quelquechose</replaceable></literal> tout en vous
  assurant qu'aucun nom de colonne ne commence par <literal>v_</literal>,
  aucun conflit ne sera possible.
 </para>

 <para>
  Autrement, vous pouvez qualifier les références ambigües pour les rendre plus claires.
  Dans l'exemple ci-dessus, <literal>src.foo</literal> serait une référence sans amigüité
  à une colonne de table. Pour créer une référence sans amigüité à une variable,
  déclarez-la dans un bloc nommé et utilisez le nom du bloc
  (voir <xref linkend="plpgsql-structure"/>). Par exemple,
  <programlisting>
    &lt;&lt;bloc&gt;&gt;
    DECLARE
        foo int;
    BEGIN
        foo := ...;
        INSERT INTO dest (col) SELECT bloc.foo + bar FROM src;
  </programlisting>
  Ici, <literal>bloc.foo</literal> désigne la variable même s'il existe une colonne
  <literal>foo</literal> dans la base <literal>src</literal>. Les paramètres de fonction, ainsi que
  les variables spéciales tel que <literal>FOUND</literal>, peuvent être qualifiés par le
  nom de la fonction, parce qu'ils sont implicitement déclarés dans un bloc exterieur
  portant le nom de la fonction.
 </para>

 <para>
  Quelque fois, il n'est pas envisageable de lever toutes les ambigüités dans une
  grande quantité de code <application>PL/pgSQL</application>. Dans ces cas-ci, vous pouvez
  spécifier à <application>PL/pgSQL</application> qu'il doit traiter les références ambigües
  comme étant une variable (ce qui est compatible avec le comportement de
  <application>PL/pgSQL</application> avant <productname>PostgreSQL</productname> 9.0) ou comme étant
  la colonne d'une table (ce qui est compatible avec d'autres systèmes tels que
  <productname>Oracle</productname>).
 </para>

 <indexterm>
  <primary><varname>plpgsql.variable_conflict</varname> paramètre de configuration</primary>
 </indexterm>

 <para>
  Pour modifier ce comportement dans toute l'instance, mettez le paramètre de
  configuration <literal>plpgsql.variable_conflict</literal> à l'un de
  <literal>error</literal>, <literal>use_variable</literal> ou
  <literal>use_column</literal> (où <literal>error</literal> est la valeur par défaut).
  Ce paramètre agit sur les compilations posterieures
  d'instructions dans les fonctions <application>PL/pgSQL</application> mais pas les instructions
  déjà compilées dans la session en cours. Cette modification pouvant
  affecter de manière inattendue le comportement des fonctions <application>PL/pgSQL</application>,
  elle ne peut être faïte que par un administrateur.
 </para>

 <para>
  Vous pouvez modifier ce comportement fonction par fonction, en
  insérant l'une de ces commandes spéciales au début de la fonction&nbsp;:
  <programlisting>
#variable_conflict error
#variable_conflict use_variable
#variable_conflict use_column
  </programlisting>
  Ces commandes n'agissent que sur les fonctions qui les contient et surchargent
  la valeur de <literal>plpgsql.variable_conflict</literal>. Un exemple est
  <programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    #variable_conflict use_variable
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = curtime, comment = comment
          WHERE users.id = id;
    END;
$$ LANGUAGE plpgsql;
  </programlisting>
  Dans la commande <literal>UPDATE</literal>, <literal>curtime</literal>, <literal>comment</literal>,
  et <literal>id</literal> font référence aux variables et paramètres de la fonction,
  que la table <literal>users</literal> ait ou non des colonnes portant ces noms. Notez
  qu'il a fallu qualifier la référence à <literal>users.id</literal> dans la
  clause <literal>WHERE</literal> pour qu'elle fasse référence à la colonne.
  Mais nous ne qualifions pas la référence à <literal>comment</literal>
  comme cible dans la liste <literal>UPDATE</literal> car, d'après la syntaxe,
  elle doit être une colonne de <literal>users</literal>. Nous pourrions écrire la même
  fonction sans dépendre de la valeur de <literal>variable_conflict</literal>
  de cette manière&nbsp;:
  <programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    &lt;&lt;fn&gt;&gt;
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment
          WHERE users.id = stamp_user.id;
    END;
$$ LANGUAGE plpgsql;
  </programlisting>
 </para>

 <para>
  La substitution de variable n'arrive pas dans la chaîne de commande donnée
  à <command>EXECUTE</command> ou une de ces variantes. Si vous avez
  besoin d'insérer une valeur dans une telle commande, faites-le lors de la
  construction d'une valeur de chaîne, illustrée dans la
  <xref linkend="plpgsql-statements-executing-dyn"/>, ou utilisez <literal>USING</literal>.
 </para>

 <para>
  La substitution de variable fonctionne seulement dans les commandes
  <command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>
  et <command>DELETE</command> parce que le moteur SQL principal autorise
  les paramètres de la requête seulement dans ces commandes. Pour utiliser un
  nom variable ou une valeur dans les autres types d'instructions (généralement
  appelées des instructions utilitaires), vous devez construire l'instruction
  en question comme une chaîne et l'exécuter via <command>EXECUTE</command>.
 </para>

</sect2>

<sect2 id="plpgsql-plan-caching">
 <title>Mise en cache du plan</title>

 <para>
  L'interpréteur <application>PL/pgSQL</application> analyse le source d'une
  fonction et produit un arbre binaire interne d'instructions la première fois
  que la fonction est appelée (à l'intérieur de chaque session). L'arbre des
  instructions se traduit complètement par la structure d'instructions
  <application>PL/pgSQL</application> mais les expressions et les commandes
  <acronym>SQL</acronym> individuelles utilisées dans la fonction ne sont
  pas traduites immédiatement.
 </para>

 <para>
  <indexterm>
   <primary>préparer une requête</primary>
   <secondary>en PL/pgSQL</secondary>
  </indexterm>
  Au moment où chaque expression et commande <acronym>SQL</acronym> est
  exécutée en premier lieu dans la fonction, l'interpréteur
  <application>PL/pgSQL</application> lit et analyse la commande pour
  créer une instruction préparée en
  utilisant la fonction <function>SPI_prepare</function> du gestionnaire
  <acronym>SPI</acronym>.
  Les appels suivants à cette expression ou commande réutilisent le plan
  préparé. Donc, une fonction avec des chemins de code conditionnel peu
  fréquemment exécutés n'auront jamais la surcharge de l'analyse de ces
  commandes qui ne sont jamais exécutées à l'intérieur de la session en
  cours. Un inconvénient
  est que les erreurs dans une expression ou commande spécifique ne peuvent
  pas être détectées avant que la fonction a atteint son exécution. (Les
  erreurs de syntaxe triviales seront détectées à la première passe d'analyse
  mais quelque chose de plus complexe ne sera pas détecté avant son
  exécution.)
 </para>

 <para>
  <application>PL/pgSQL</application> (ou plus exactement le gestionnaire SPI)
  peut tenter de mettre en cache le plan d'exécution associé à toute requête
  préparée. Si un plan en cache n'est pas utilisé, alors un nouveau plan
  d'exécution est généré pour chaque appel de la requête, et les valeurs
  actuelles du paramètre (autrement dit les valeurs de la variable
  <application>PL/pgSQL</application>) peuvent être utilisées pour optimiser
  le plan sélectionné. Si la requête n'a pas de paramètres ou est exécuté
  plusieurs fois, le gestionnaire SPI considérera la création d'un plan
  <firstterm>générique</firstterm> qui n'est pas dépendant des valeurs du
  paramètre et placera ce plan en cache pour le réutiliser. Habituellement,
  ceci survient seulement si le plan d'exécution n'est pas très sensible
  aux valeurs des variables <application>PL/pgSQL</application> référencées.
  Si ce n'est pas le cas, générer un nouveau plan à chaque fois est un gain
  net. Voir <xref linkend="sql-prepare"/> pour plus d'informations sur le
  comportement des requêtes préparées.
 </para>

 <para>
  Comme <application>PL/pgSQL</application> sauvegarde des instructions
  préparées et quelques fois des plans d'exécition
  de cette façon, les commandes SQL qui apparaissent directement dans une
  fonction <application>PL/pgSQL</application> doivent faire référence aux
  même tables et aux mêmes colonnes à chaque exécution&nbsp;; c'est-à-dire
  que vous ne pouvez pas utiliser un paramètre comme le nom d'une table ou
  d'une colonne dans une commande SQL. Pour contourner cette restriction,
  vous pouvez construire des commandes dynamiques en utilisant l'instruction
  <command>EXECUTE</command> de <application>PL/pgSQL</application>
  &mdash; au prix d'une nouvelle analyse du plan et de la construction d'un
  nouveau plan d'exécution sur chaque exécution.
 </para>

 <para>
  La nature muable des variables de type record présente un autre problème
  dans cette connexion. Quand les champs d'une variable record sont utilisés
  dans les expressions ou instructions, les types de données des champs
  ne doivent pas modifier d'un appel de la fonction à un autre car chaque
  expression sera analysée en utilisant le type de données qui est présent
  quand l'expression est atteinte en premier. <command>EXECUTE</command> peut
  être utilisé pour contourner ce problème si nécessaire.
 </para>

 <para>
  Si la même fonction est utilisée comme trigger pour plus d'une table,
  <application>PL/pgSQL</application> prépare et met en cache les instructions
  indépendament pour chacune de ses tables &mdash; c'est-à-dire qu'il y a
  un cache pour chaque combinaison fonction trigger/table, pas
  uniquement pour chaque fonction. Ceci diminue certains des problèmes avec
  les types de données variables&nbsp;; par exemple, une fonction trigger
  pourra fonctionner correctement avec une colonne nommée
  <literal>cle</literal> même si cette colonne a différents types dans
  différentes tables.
 </para>

 <para>
  De la même façon, les fonctions ayant des types polymorphiques pour les
  arguments ont un cache séparé des instructions pour chaque combinaison des types
  d'argument réels avec lesquels elles ont été appelées, donc les différences
  de type de données ne causent pas d'échecs inattendus.
 </para>

 <para>
  La mise en cache des instructions peut parfois avoir des effets surprenants sur
  l'interprétation des valeurs sensibles à l'heure. Par exemple, il y a une
  différence entre ce que font ces deux fonctions&nbsp;:

  <programlisting>
CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$
    BEGIN
        INSERT INTO logtable VALUES (logtxt, 'now');
    END;
$$ LANGUAGE plpgsql;
  </programlisting>

  et&nbsp;:

  <programlisting>
CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$
    DECLARE
        curtime timestamp;
    BEGIN
        curtime := 'now';
        INSERT INTO logtable VALUES (logtxt, curtime);
    END;
$$ LANGUAGE plpgsql;
  </programlisting>
 </para>

 <para>
  Dans le cas de <function>logfunc1</function>, l'analyseur principal de
  <productname>PostgreSQL</productname> sait lors de l'analyser du
  <command>INSERT</command> que la chaîne <literal>'now'</literal>
  devrait être interprétée comme un <type>timestamp</type> car la
  colonne cible de <classname>logtable</classname> est de ce type. Du coup,
  <literal>'now'</literal> sera converti en une constante
  <type>timestamp</type> quand <command>INSERT</command> est analysé, puis
  utilisé dans tous les appels de <function>logfunc1</function> tout au
  long de la vie de la session. Il est inutile de dire que ce n'est pas ce
  que voulait le développeur. Une meilleure idée reviendrait à utiliser la
  fonction <literal>now()</literal> ou <literal>current_timestamp</literal>.
 </para>

 <para>
  Dans le cas de <function>logfunc2</function>, l'analyseur principal de
  <productname>PostgreSQL</productname> ne connaît pas le type que deviendra
  <literal>'now'</literal> et, du coup, il renvoie une valeur de type
  <type>text</type> contenant la chaîne <literal>now</literal>. Lors de
  l'affectation à la variable <varname>curtime</varname> locale, l'interpréteur
  <application>PL/pgSQL</application> convertie cette chaîne dans le type
  <type>timestamp</type> en appelant les fonctions <function>text_out</function>
  et <function>timestamp_in</function> pour la conversion. Du coup, l'heure
  calculée est mise à jour à chaque exécution comme le suppose le développeur.
  Même s'il arrive que ça fonctionne ainsi, ce n'est pas très efficace, donc
  l'utilisation de la fonction <literal>now()</literal> sera encore une fois
  une meilleur idée.
 </para>

</sect2>

</sect1>

<sect1 id="plpgsql-development-tips">
<title>Astuces pour développer en <application>PL/pgSQL</application></title>

<para>
 Un bon moyen de développer en <application>PL/pgSQL</application> est d'utiliser
 l'éditeur de texte de votre choix pour créer vos fonctions, et d'utiliser
 <application>psql</application> dans une autre fenêtre pour charger et tester
 ces fonctions. Si vous procédez ainsi, une bonne idée est d'écrire la fonction
 en utilisant <command>CREATE OR REPLACE FUNCTION</command>. De cette façon vous pouvez simplement
 recharger le fichier pour mettre à jour la définition de la fonction.
 Par exemple&nbsp;:
 <programlisting>CREATE OR REPLACE FUNCTION fonction_test(integer) RETURNS integer AS $$
	  ....
$$ LANGUAGE plpgsql;
 </programlisting>
</para>

<para>
 Pendant que <application>psql</application> s'exécute, vous pouvez charger
 ou recharger des définitions de fonction avec&nbsp;:
 <programlisting>\i nom_fichier.sql
 </programlisting>
 puis immédiatement soumettre des commandes SQL pour tester la fonction.
</para>

<para>
 Un autre bon moyen de développer en <application>PL/pgSQL</application> est d'utiliser
 un outil d'accès à la base de données muni d'une interface graphique qui facilite le
 développement dans un langage de procédures. Un exemple d'un tel outil est
 <application>pgAdmin</application>, bien que d'autres existent. Ces outils fournissent
 souvent des fonctionnalités pratiques telles que la détection des guillemets ouverts
 et facilitent la re-création et le débogage des fonctions.
</para>

<sect2 id="plpgsql-quote-tips">
 <title>Utilisation des guillemets simples (quotes)</title>

 <para>
  Le code d'une fonction <application>PL/pgSQL</application> est spécifié dans la commande
  <command>CREATE FUNCTION</command> comme une chaîne de caractères.
  Si vous écrivez la chaîne littérale de la façon ordinaire en l'entourant
  de guillemets simples, alors tout guillemet simple dans le corps de la
  fonction doit être doublé&nbsp;; de la même façon, les antislashs doivent
  être doublés (en supposant que la syntaxe d'échappement de chaînes est
  utilisée). Doubler les guillemets devient rapidement difficile et, dans
  la plupart des cas compliqués, le code peut devenir rapidement
  incompréhensible parce que vous pouvez facilement vous trouver avec
  une douzaine, voire plus, de guillemets adjacents. À la place, il est
  recommandé d'écrire le corps de la fonction en tant qu'une chaîne littérale
  <quote>avec guillemets dollar</quote> (voir la <xref
  linkend="sql-syntax-dollar-quoting"/>). Dans cette approche, vous ne doublez
  jamais les marques de guillemets mais vous devez faire attention à
  choisir un délimiteur dollar différent pour chaque niveau d'imbrication
  dont vous avez besoin. Par exemple, vous pouvez écrire la commande
  <command>CREATE FUNCTION</command> en tant que&nbsp;:
  <programlisting>CREATE OR REPLACE FUNCTION fonction_test(integer) RETURNS integer AS $PROC$
   ....
$PROC$ LANGUAGE plpgsql;
  </programlisting>
  À l'intérieur de ceci, vous pouvez utiliser des guillemets pour les
  chaînes littérales simples dans les commandes SQL et <literal>$$</literal> pour
  délimiter les fragments de commandes SQL que vous assemblez comme des
  chaînes. Si vous avez besoin de mettre entre guillemets du texte qui inclut
  <literal>$$</literal>, vous pouvez utiliser <literal>$Q$</literal>, et ainsi de suite.
 </para>

 <para>
  Le graphe suivant montre ce que vous devez faire lors de l'écriture de
  guillemets simples sans guillemets dollar. Cela pourrait être utile lors
  de la traduction de code avec guillemets simples en quelque chose de
  plus compréhensible.
 </para>

 <variablelist>
  <varlistentry>
   <term>1 guillemet simple</term>
   <listitem>
    <para>
     Pour commencer et terminer le corps de la fonction, par exemple&nbsp;:
     <programlisting>CREATE FUNCTION foo() RETURNS integer AS '
	.....
' LANGUAGE plpgsql;
     </programlisting>
     Partout au sein du corps de la fonction entouré de guillemets simples,
     les guillemets simples <emphasis>doivent</emphasis> aller par paires.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>2 guillemets simples</term>
   <listitem>
    <para>
     Pour les chaînes de caractères à l'intérieur du corps de la fonction, par
     exemple&nbsp;:
     <programlisting>une_sortie := ''Blah'';
SELECT * FROM utilisateurs WHERE f_nom=''foobar'';
     </programlisting>
     Dans l'approche du guillemet dollar, vous devriez juste écrire&nbsp;:
     <programlisting>une_sortie := 'Blah';
SELECT * FROM utilisateurs WHERE f_nom='foobar';
     </programlisting>
     ce qui serait exactement ce que l'analyseur <application>PL/pgSQL</application> verrait dans les
     deux cas.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>4 guillemets simples</term>
   <listitem>
    <para>
     Quand vous avez besoin d'un guillemet simple dans une chaîne constante
     à l'intérieur du corps de la fonction, par exemple&nbsp;:
     <programlisting>une_sortie := une_sortie || '' AND nom LIKE ''''foobar'''' AND xyz''
     </programlisting>
     La valeur effectivement concaténée à <literal>une_sortie</literal>
     est&nbsp;:
     <literal> AND nom LIKE 'foobar' AND xyz</literal>.
    </para>
    <para>
     Dans l'approche du guillemet dollar, vous auriez écrit&nbsp;:
     <programlisting>une_sortie := une_sortie || $$ AND nom LIKE 'foobar' AND xyz$$
     </programlisting>
     Faites attention que chaque délimiteur en guillemet dollar ne soient pas
     simplement <literal>$$</literal>.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>6 guillemets simples</term>
   <listitem>
    <para>
     Quand un simple guillemet dans une chaîne à l'intérieur du corps d'une fonction
     est adjacent à la fin de cette chaîne constante, par exemple&nbsp;:
     <programlisting>une_sortie := une_sortie || '' AND nom LIKE ''''foobar''''''
     </programlisting>
     La valeur effectivement concaténée à <literal>une_sortie</literal> est
     alors&nbsp;:
     <literal> AND nom LIKE 'foobar'</literal>.
    </para>
    <para>
     Dans l'approche guillemet dollar, ceci devient&nbsp;:
     <programlisting>une_sortie := une_sortie || $$ AND nom LIKE 'foobar'$$
     </programlisting>
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>10 guillemets simples</term>
   <listitem>
    <para>
     Lorsque vous voulez deux guillemets simples dans une chaîne constante (qui
     compte pour huit guillemets simples) et qu'elle est adjacente à la fin de
     cette chaîne constante (deux de plus). Vous n'aurez probablement besoin de
     ceci que si vous écrivez une fonction qui génère d'autres fonctions comme
     dans l'<xref linkend="plpgsql-porting-ex2"/>. Par exemple&nbsp;:
     <programlisting>une_sortie := une_sortie || '' if v_'' ||
    referrer_keys.kind || '' like ''''''''''
    || referrer_keys.key_string || ''''''''''
    then return ''''''  || referrer_keys.referrer_type
    || ''''''; end if;'';
     </programlisting>
     La valeur de <literal>une_sortie</literal> sera alors&nbsp;:
     <programlisting>if v_... like ''...'' then return ''...''; end if;
     </programlisting>
    </para>
    <para>
     Dans l'approche du guillemet dollar, ceci devient&nbsp;:
     <programlisting>une_sortie := une_sortie || $$ if v_$$ || referrer_keys.kind || $$ like '$$
|| referrer_keys.key_string || $$'
then return '$$  || referrer_keys.referrer_type
|| $$'; end if;$$;
     </programlisting>
     où nous supposons que nous avons seulement besoin de placer des marques
     de guillemets simples dans <literal>une_sortie</literal> parce que les
     guillemets seront recalculés avant utilisation.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</sect2>

<sect2 id="plpgsql-extra-checks">
 <title>Vérifications supplémentaires à la compilation</title>

 <para>
  Pour aider l'utilisateur à trouver les problèmes simples mais fréquents
  avant qu'ils ne posent de vrais problèmes, <application>PL/PgSQL</application>
  fournit des <replaceable>vérifications</replaceable> supplémentaires.
  Une fois activées, suivant la configuration, elles peuvent être utilisées
  pour émettre soit un <literal>WARNING</literal> soit un <literal>ERROR</literal>
  pendant la compilation d'une fonction. Une fonction qui a reçu un
  <literal>WARNING</literal> peut être exécutée sans produire d'autres messages,
  mais vous êtes averti de la tester dans un environnement de développement
  séparé.
 </para>

 <para>
  Ces vérifications supplémentaires sont activées via les variables de
  configuration <varname>plpgsql.extra_warnings</varname> pour les messages
  d'avertissement et <varname>plpgsql.extra_errors</varname> pour les erreurs.
  Les deux peuvent être configurés soit avec une liste de vérifications séparées
  par des virgules, soit pour aucune (<literal>"none"</literal>), soit pour
  toutes (<literal>"all"</literal>). La valeur par défaut est
  <literal>"none"</literal>. La liste actuelle des vérifications disponibles ne
  contient qu'un membre&nbsp;:
  <variablelist>
   <varlistentry>
    <term><varname>shadowed_variables</varname></term>
    <listitem>
     <para>
      Vérifie si une déclaration cache une variable définie précédemment.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  L'exemple suivant montre l'effet de <varname>plpgsql.extra_warnings</varname>
  configuré à <varname>shadowed_variables</varname>&nbsp;:
  <programlisting>
SET plpgsql.extra_warnings TO 'shadowed_variables';

CREATE FUNCTION foo(f1 int) RETURNS int AS $$
DECLARE
f1 int;
BEGIN
RETURN f1;
END
$$ LANGUAGE plpgsql;
WARNING:  variable "f1" shadows a previously defined variable
LINE 3: f1 int;
        ^
CREATE FUNCTION
  </programlisting>
 </para>
</sect2>
</sect1>

<!-- **** Porting from Oracle PL/SQL **** -->

<sect1 id="plpgsql-porting">
<title>Portage d'<productname>Oracle</productname> PL/SQL</title>

<indexterm zone="plpgsql-porting">
 <primary>Oracle</primary>
 <secondary>porter de PL/SQL vers PL/pgSQL</secondary>
</indexterm>

<indexterm zone="plpgsql-porting">
 <primary>PL/SQL</primary>
 <secondary>porter vers PL/pgSQL</secondary>
</indexterm>

<para>
 Cette section explicite les différences entre le <application>PL/pgSQL</application>
 de <productname>PostgreSQL</productname> et le langage <application>PL/SQL</application>
 d'Oracle, afin d'aider les développeurs qui portent des applications d'<trademark
 class="registered">Oracle</trademark> vers <productname>PostgreSQL</productname>.
</para>

<para>
 <application>PL/pgSQL</application> est similaire à PL/SQL sur de nombreux aspects.
 C'est un langage itératif structuré en blocs et toutes les variables doivent
 être déclarées. Les affectations, boucles, conditionnelles sont similaires. Les
 principales différences que vous devez garder à l'esprit quand vous portez de
 <application>PL/SQL</application> vers <application>PL/pgSQL</application> sont:

 <itemizedlist>
  <listitem>
   <para>
    Si un nom utilisé dans une commande SQL peut être soit un nom de colonne
    d'une table soit une référence à une variable de la fonction,
    <application>PL/SQL</application> le traite comme un nom de commande.
    Cela correspond au comportement de <application>PL/pgSQL</application> lorsque
    <literal>plpgsql.variable_conflict</literal> = <literal>use_column</literal>,
    ce qui n'est pas la valeur par défaut,
    comme expliqué dans <xref linkend="plpgsql-var-subst"/>.
    Il est préféreable d'éviter de tels ambigüités des le début
    mais si vous devez migrer une grande quantité de code qui dépend de
    ce comportement, paramétrer <literal>variable_conflict</literal> peut s'avérer être la
    meilleure solution.
   </para>
  </listitem>

  <listitem>
   <para>
    Dans <productname>PostgreSQL</productname>, le corps de la fonction doit être
    écrit comme une chaîne litérale. Du coup, vous avez besoin d'utiliser
    les guillemets dollar ou l'échappement des simples guillemets dans le
    corps de la fonction. Voir la <xref linkend="plpgsql-quote-tips"/>.
   </para>
  </listitem>

  <listitem>
   <para>
    À la place des paquetages, utilisez des schémas pour organiser vos fonctions en
    groupes.
   </para>
  </listitem>

  <listitem>
   <para>
    Comme il n'y a pas de paquetages, il n'y a pas non plus de variables
    au niveau paquetage. Ceci est un peu ennuyant. Vous pourriez être capable
    de conserver un état par session dans les tables temporaires à la place.
   </para>
  </listitem>

  <listitem>
   <para>
    Les boucles <command>FOR</command> d'entiers en ordre inverse
    (<literal>REVERSE</literal>) fonctionnent différemment&nbsp;;
    <application>PL/SQL</application> compte du second numéro jusqu'au
    premier alors que <application>PL/pgSQL</application> compte du
    premier jusqu'au second, ceci réclamant que les limites de la
    boucle soient échangées lors du portage. Cette incompatibilité
    est malheureuse mais a peu de chance d'être changée. (Voir <xref
    linkend="plpgsql-integer-for"/>.)
   </para>
  </listitem>

  <listitem>
   <para>
    Les boucles <command>FOR</command> sur des requêtes (autres que des
    curseurs) fonctionnent aussi différemment&nbsp;: la variable cible doit
    avoir été déclarée alors que <application>PL/SQL</application> les déclare
    toujours implicitement. Un avantage de ceci est que les valeurs des
    variables sont toujours accessibles à la sortie de la boucle.
   </para>
  </listitem>

  <listitem>
   <para>
    Il existe plusieurs différences de notation pour l'utilisation des
    variables curseurs.
   </para>
  </listitem>

 </itemizedlist>
</para>

<sect2>
 <title>Exemples de portages</title>

 <para>
  L'<xref linkend="pgsql-porting-ex1"/> montre comment porter une simple fonction
  de <application>PL/SQL</application> vers <application>PL/pgSQL</application>.
 </para>

 <example id="pgsql-porting-ex1">
  <title>Portage d'une fonction simple de <application>PL/SQL</application> vers <application>PL/pgSQL</application></title>

  <para>
   Voici une fonction en <application>PL/SQL</application>
   <productname>Oracle</productname>&nbsp;:
   <programlisting>CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar, v_version varchar)
RETURN varchar IS
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
/
show errors;
   </programlisting>
  </para>

  <para>
   Parcourons cette fonction et voyons les différences avec
   <application>PL/pgSQL</application>&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Le mot clé <literal>RETURN</literal> dans le prototype de la fonction (pas dans
      le corps de la fonction) devient <literal>RETURNS</literal> dans PostgreSQL.
      De plus, <literal>IS</literal> devient <literal>AS</literal> et vous avez besoin d'ajouter
      une clause <literal>LANGUAGE</literal> parce que <application>PL/pgSQL</application> n'est pas
      le seul langage de procédures disponible.
     </para>
    </listitem>

    <listitem>
     <para>
      Dans <productname>PostgreSQL</productname>, le corps de la fonction est
      considéré comme une chaîne littérale, donc vous avez besoin d'utiliser
      les guillemets simples ou les guillemets dollar tout autour. Ceci se
      substitue au <literal>/</literal> de fin dans l'approche d'Oracle.
     </para>
    </listitem>

    <listitem>
     <para>
      La commande <literal>show errors</literal> n'existe pas dans
      <productname>PostgreSQL</productname> et n'est pas nécessaire car les erreurs
      sont rapportées automatiquement.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Voici de quoi aurait l'air cette fonction portée sous
   <productname>PostgreSQL</productname>&nbsp;:

   <programlisting>CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar, v_version varchar)
RETURNS varchar AS $$
BEGIN
    IF v_version IS NULL THEN
        return v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
$$ LANGUAGE plpgsql;
   </programlisting>
  </para>
 </example>

 <para>
  L'<xref linkend="plpgsql-porting-ex2"/> montre comment porter une fonction qui crée une
  autre fonction et comment gérer les problèmes de guillemets résultants.
 </para>

 <example id="plpgsql-porting-ex2">
  <title>Portage d'une fonction qui crée une autre fonction de <application>PL/SQL</application> vers <application>PL/pgSQL</application></title>

  <para>
   La procédure suivante récupère des lignes d'une instruction <command>SELECT</command>
   et construit une grande fonction dont les résultats sont dans une instruction
   <literal>IF</literal> pour favoriser l'efficacité.
  </para>

  <para>
   Voici la version Oracle&nbsp;:
   <programlisting>CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc IS
    referrer_keys CURSOR IS
        SELECT * FROM cs_referrer_keys
	ORDER BY try_order;

    func_cmd VARCHAR(4000);
BEGIN
    func_cmd := 'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host IN VARCHAR,
        v_domain IN VARCHAR, v_url IN VARCHAR) RETURN VARCHAR IS BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_cmd := func_cmd ||
        ' IF v_' || referrer_key.kind
	|| ' LIKE ''' || referrer_key.key_string
	|| ''' THEN RETURN ''' || referrer_key.referrer_type
	|| '''; END IF;';
    END LOOP;

    func_cmd := func_cmd || ' RETURN NULL; END;';

    EXECUTE IMMEDIATE func_cmd;
END;
/
show errors;
   </programlisting>
  </para>

  <para>
   Voici comment la fonction serait dans <productname>PostgreSQL</productname>&nbsp;:

   <programlisting>CREATE OR REPLACE FUNCTION cs_update_referrer_type_proc() RETURNS void AS $func$
DECLARE
    CURSOR referrer_keys IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_body text;
    func_cmd text;
BEGIN
    func_body := 'BEGIN' ;

    FOR referrer_key IN SELECT * FROM cs_referrer_keys ORDER BY try_order LOOP
	func_body := func_body ||
	' IF v_' || referrer_key.kind
	|| ' LIKE ' || quote_literal(referrer_key.key_string)
	|| ' THEN RETURN ' || quote_literal(referrer_key.referrer_type)
	|| '; END IF;' ;
    END LOOP;

    func_body := func_body || ' RETURN NULL; END;';

    func_cmd :=
	'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,
	v_domain varchar,
	v_url varchar)
	RETURNS varchar AS '
	|| quote_literal(func_body)
	|| ' LANGUAGE plpgsql;' ;

	EXECUTE func_cmd;
END;
$func$ LANGUAGE plpgsql;
   </programlisting>
   Notez comment le corps de la fonction est construit séparément et est passé
   au travers de <literal>quote_literal</literal> pour doubler tout symbole
   guillemet qu'il peut contenir. Cette technique est nécessaire parce que
   nous ne pouvons pas utiliser à coup sûr les guillemets dollar pour
   définir la nouvelle fonction&nbsp;: nous ne sommes pas sûr de savoir
   quelle chaîne sera interpolée à partir du champ
   <structfield>referrer_key.key_string</structfield> (nous supposons ici que ce
   <structfield>referrer_key.kind</structfield> vaut à coup sûr <literal>host</literal>,
   <literal>domain</literal> ou <literal>url</literal> mais
   <structfield>referrer_key.key_string</structfield> pourrait valoir autre chose, il
   pourrait contenir en particulier des signes dollar). Cette fonction est
   en fait une amélioration de l'original Oracle parce qu'il ne
   génèrera pas de code cassé quand <structfield>referrer_key.key_string</structfield>
   ou <structfield>referrer_key.referrer_type</structfield> contient des guillemets.
  </para>
 </example>

 <para>
  L'<xref linkend="plpgsql-porting-ex3"/> montre comment porter une fonction
  ayant des paramètres <literal>OUT</literal> et effectuant des manipulations de
  chaînes.
  <productname>PostgreSQL</productname> n'a pas de fonction <function>instr</function>
  intégrée mais vous pouvez en créer une en utilisant une combinaison
  d'autres fonctions. Dans la <xref linkend="plpgsql-porting-appendix"/>, il
  y a une implémentation <application>PL/pgSQL</application>
  d'<function>instr</function> que vous pouvez utiliser pour faciliter votre
  portage.
 </para>

 <example id="plpgsql-porting-ex3">
  <title>Portage d'une procédure avec manipulation de chaînes et paramètres
   <literal>OUT</literal> de <application>PL/SQL</application> vers
   <application>PL/pgSQL</application></title>

  <para>
   La procédure <productname>Oracle</productname> suivante est utilisée pour
   analyser une URL et renvoyer plusieurs éléments (hôte, chemin et requête).
   Les fonctions <application>PL/pgSQL</application> ne peuvent renvoyer
   qu'une seule valeur.
  </para>

  <para>
   Voici la version Oracle&nbsp;:
   <programlisting>CREATE OR REPLACE PROCEDURE cs_parse_url(
    v_url IN VARCHAR,
    v_host OUT VARCHAR,  -- Celle-ci sera passée en retour
    v_path OUT VARCHAR,  -- Celle-là aussi
    v_query OUT VARCHAR) -- Et celle-là
IS
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
/
show errors;
   </programlisting>
  </para>

  <para>
   Voici une traduction possible en <application>PL/pgSQL</application>&nbsp;:
   <programlisting>CREATE OR REPLACE FUNCTION cs_parse_url(
    v_url IN VARCHAR,
    v_host OUT VARCHAR,  -- This will be passed back
    v_path OUT VARCHAR,  -- This one too
    v_query OUT VARCHAR) -- And this one
AS $$
DECLARE
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
$$ LANGUAGE plpgsql;
   </programlisting>

   Cette fonction pourrait être utilisée ainsi&nbsp;:
   <programlisting>SELECT * FROM cs_parse_url('http://foobar.com/query.cgi?baz');</programlisting>
    </para>
   </example>

   <para>
    L'<xref linkend="plpgsql-porting-ex4"/> montre comment porter une procédure qui utilise
    de nombreuses fonctionnalités spécifiques à Oracle.
   </para>

   <example id="plpgsql-porting-ex4">
    <title>Portage d'une procédure de <application>PL/SQL</application> vers <application>PL/pgSQL</application></title>

    <para>
     La version Oracle&nbsp;:

<programlisting>CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS
    a_running_job_count INTEGER;
    PRAGMA AUTONOMOUS_TRANSACTION;<co id="co.plpgsql-porting-pragma"/>
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;<co id="co.plpgsql-porting-locktable"/>

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        COMMIT; -- free lock<co id="co.plpgsql-porting-commit"/>
        raise_application_error(-20000, 'Unable to create a new job: a job is currently running.');
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, sysdate);
        EXCEPTION
	  WHEN dup_val_on_index THEN NULL; -- ne vous inquietez pas si cela existe déjà
    END;
    COMMIT;
END;
/
show errors
   </programlisting>
  </para>

  <para>
   Les procédures comme celles-ci peuvent être aisément converties en
   fonctions <productname>PostgreSQL</productname> renvoyant un <type>void</type>. Cette
   procédure en particulier est intéressante parce qu'elle peut nous apprendre diverses
   choses&nbsp;:

   <calloutlist>
    <callout arearefs="co.plpgsql-porting-pragma">
     <para>
      Il n'y a pas d'instruction <literal>PRAGMA</literal> dans <productname>PostgreSQL</productname>.
     </para>
    </callout>

    <callout arearefs="co.plpgsql-porting-locktable">
     <para>
      Si vous faites un <command>LOCK TABLE</command> dans <application>PL/pgSQL</application>,
      le verrou ne sera pas libéré jusqu'à ce que la transaction appelante soit
      terminée.
     </para>
    </callout>

    <callout arearefs="co.plpgsql-porting-commit">
     <para>
      Vous ne pouvez pas lancer un <command>COMMIT</command> dans une fonction
      <application>PL/pgSQL</application>. La fonction est lancée à
      l'intérieur d'une transaction externe et, du coup, un
      <command>COMMIT</command> impliquerait simplement la fin de l'exécution de
      la fonction. Néanmoins, dans ce cas particulier, ce n'est de toute
      façon pas nécessaire parce que le verrou obtenu par <command>LOCK
       TABLE</command> sera libéré lors de la levée de l'erreur.
     </para>
    </callout>
   </calloutlist>
  </para>

  <para>
   Voici comment nous pourrions porter cette procédure vers
   <application>PL/pgSQL</application>&nbsp;:

   <programlisting>CREATE OR REPLACE FUNCTION cs_create_job(v_job_id integer) RETURNS void AS $$
DECLARE
  a_running_job_count integer;
BEGIN
  LOCK TABLE cs_jobs IN EXCLUSIVE MODE;

  SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

  IF a_running_job_count &gt; 0 THEN
    RAISE EXCEPTION 'Unable to create a new job: a job is currently running';<co id="co.plpgsql-porting-raise"/>
  END IF;

  DELETE FROM cs_active_job;
  INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

  BEGIN
    INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());
  EXCEPTION
    WHEN unique_violation THEN <co id="co.plpgsql-porting-exception"/>
    -- ne vous inquietez pas si cela existe déjà
  END;
END;
$$ LANGUAGE plpgsql;
   </programlisting>

   <calloutlist>
    <callout arearefs="co.plpgsql-porting-raise">
     <para>
      La syntaxe de <literal>RAISE</literal> est considérablement différente de
      l'instruction Oracle similaire, bien que le cas basique du
      <literal>RAISE</literal>
      <replaceable class="parameter">nom_exception</replaceable> fonctionne de
      façon similaire.
     </para>
    </callout>

    <callout arearefs="co.plpgsql-porting-exception">
     <para>
      Les noms d'exceptions supportées par <application>PL/pgSQL</application> sont
      différents de ceux d'Oracle. L'ensemble de noms d'exceptions intégré
      est plus important (voir l'<xref linkend="errcodes-appendix"/>).
      Il n'existe actuellement pas de façon de déclarer des noms
      d'exceptions définis par l'utilisateur,
      bien que vous puissiez aussi ignorer les valeurs SQLSTATE choisies par l'utilisateur.
     </para>
    </callout>
   </calloutlist>

   La principale différence fonctionnelle entre cette procédure et
   l'équivalent Oracle est que le verrou exclusif sur la table
   <literal>cs_jobs</literal> sera détenu jusqu'à la fin de la transaction
   appelante. De plus, si l'appelant annule plus tard (par exemple à cause
   d'une erreur), les effets de cette procédure seront annulés.
  </para>
 </example>
</sect2>

<sect2 id="plpgsql-porting-other">
 <title>Autres choses à surveiller</title>

 <para>
  Cette section explique quelques autres choses à surveiller quand on effectue
  un portage de fonctions <application>PL/SQL</application> Oracle vers PostgreSQL.
 </para>

 <sect3 id="plpgsql-porting-exceptions">
  <title>Annulation implicite après une exception</title>

  <para>
   Dans <application>PL/pgSQL</application>, quand une exception est récupérée par une
   clause <literal>EXCEPTION</literal>, toutes les modifications de la base de
   données depuis le bloc <literal>BEGIN</literal> sont automatiquement annulées.
   C'est-à-dire que le comportement est identique à celui obtenu à partir
   d'Oracle avec&nbsp;:

   <programlisting>BEGIN
SAVEPOINT s1;
... code ici ...
EXCEPTION
WHEN ... THEN
ROLLBACK TO s1;
... code ici ...
WHEN ... THEN
ROLLBACK TO s1;
... code ici ...
END;</programlisting>

      Si vous traduisez une procédure d'Oracle qui utilise
      <command>SAVEPOINT</command> et <command>ROLLBACK TO</command> dans ce style, votre
      tâche est facile&nbsp;: omettez <command>SAVEPOINT</command> et
      <command>ROLLBACK TO</command>. Si vous avez une procédure qui utilise
      <command>SAVEPOINT</command> et <command>ROLLBACK TO</command> d'une façon différente,
      alors un peu de réflexion supplémentaire sera nécessaire.
     </para>
   </sect3>

   <sect3>
    <title><command>EXECUTE</command></title>

    <para>
     La version <application>PL/pgSQL</application> d'<command>EXECUTE</command> fonctionne de façon
     similaire à la version <application>PL/SQL</application> mais vous devez vous rappeler
     d'utiliser <function>quote_literal</function> et
     <function>quote_ident</function> comme décrit dans la <xref
     linkend="plpgsql-statements-executing-dyn"/>.  Les constructions de type
     <literal>EXECUTE 'SELECT * FROM $1';</literal> ne fonctionneront pas de
     façon fiable à moins d'utiliser ces fonctions.
    </para>
   </sect3>

   <sect3 id="plpgsql-porting-optimization">
    <title>Optimisation des fonctions <application>PL/pgSQL</application></title>

    <para>
     <productname>PostgreSQL</productname> vous donne deux modificateurs de création de
     fonctions pour optimiser l'exécution&nbsp;: la <quote>volatilité</quote>
     (la fonction renvoie toujours le même
     résultat quand on lui donne les mêmes arguments) et la <quote>rigueur</quote> (une
     fonction renvoie NULL si tous ses arguments sont NULL).  Consultez la
     page de référence de <xref linkend="sql-createfunction"/> pour les détails.
    </para>

    <para>
     Pour faire usage de ces attributs d'optimisation, votre instruction
     <command>CREATE FUNCTION</command> devrait ressembler à ceci&nbsp;:

<programlisting>CREATE FUNCTION foo(...) RETURNS integer AS $$
...
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
   </programlisting>
  </para>
 </sect3>
</sect2>

<sect2 id="plpgsql-porting-appendix">
 <title>Annexe</title>

 <para>
  Cette section contient le code d'un ensemble de fonctions <function>instr</function>
  compatible Oracle que vous pouvez utiliser pour simplifier vos efforts de portage.
 </para>

   <indexterm>
    <primary><function>instr</function> function</primary>
   </indexterm>

 <programlisting>--
-- fonctions instr qui reproduisent la contrepartie Oracle
-- Syntaxe: instr(string1, string2, [n], [m]) où [] signifie paramètre optionnel.
--
-- Cherche string1 en commençant par le  n-ième caractère pour la m-ième occurrence
-- de string2.  Si n est négatif, cherche en sens inverse. Si m n'est pas fourni
-- suppose 1 (la recherche commence au premier caractère).
--

CREATE FUNCTION instr(varchar, varchar) RETURNS integer AS $$
DECLARE
    pos integer;
BEGIN
    pos:= instr($1, $2, 1);
    RETURN pos;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search varchar, beg_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index &gt; 0 THEN
        temp_str := substring(string FROM beg_index);
        pos := position(string_to_search IN temp_str);

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN pos + beg_index - 1;
        END IF;
    ELSIF beg_index &lt; 0 THEN
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg &gt; 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos &gt; 0 THEN
                RETURN beg;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search varchar,
                      beg_index integer, occur_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    occur_number integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    i integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index &gt; 0 THEN
        beg := beg_index;
        temp_str := substring(string FROM beg_index);

        FOR i IN 1..occur_index LOOP
            pos := position(string_to_search IN temp_str);

            IF i = 1 THEN
                beg := beg + pos - 1;
            ELSE
                beg := beg + pos;
            END IF;

            temp_str := substring(string FROM beg + 1);
        END LOOP;

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN beg;
        END IF;
    ELSIF beg_index &lt; 0 THEN
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg &gt; 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos &gt; 0 THEN
                occur_number := occur_number + 1;

                IF occur_number = occur_index THEN
                    RETURN beg;
                END IF;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
 </programlisting>
</sect2>

</sect1>

</chapter>
