<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="monitoring">
 <title>Surveiller l'activité de la base de données</title>

 <indexterm zone="monitoring">
  <primary>surveiller</primary>
  <secondary>activité de la base de données</secondary>
 </indexterm>

 <indexterm zone="monitoring">
  <primary>activité de la base de données</primary>
  <secondary>suveiller</secondary>
 </indexterm>

 <para>
  Un administrateur de bases de données se demande fréquemment&nbsp;: <quote>Que
   fait le système en ce moment&nbsp;?</quote> Ce chapitre explique la façon
  de le savoir.
 </para>

 <para>
  Plusieurs outils sont disponibles pour surveiller l'activité de la base de
  données et pour analyser les performances. Une grande partie de ce chapitre
  concerne la description du récupérateur de statistiques de
  <productname>PostgreSQL</productname> mais personne ne devrait négliger les
  programmes de surveillance Unix standards tels que <command>ps</command>,
  <command>top</command>, <command>iostat</command> et <command>vmstat</command>. De plus, une fois
  qu'une requête peu performante a été identifiée, des investigations
  supplémentaires pourraient être nécessaires en utilisant la commande <xref
  linkend="sql-explain"/> de
  <productname>PostgreSQL</productname>. La <xref linkend="using-explain"/>
  discute de <command>EXPLAIN</command> et des autres méthodes pour comprendre le
  comportement d'une seule requête.
 </para>

 <sect1 id="monitoring-ps">
  <title>Outils Unix standard</title>

  <indexterm zone="monitoring-ps">
   <primary>ps</primary>
   <secondary>pour surveiller l'activité</secondary>
  </indexterm>

  <para>
   Sur la plupart des plateformes Unix, <productname>PostgreSQL</productname> modifie
   son titre de commande reporté par <command>ps</command> de façon à ce que les
   processus serveur individuels puissent être rapidement identifiés. Voici un
   affichage d'exemple&nbsp;:

   <screen>$ ps auxww | grep ^postgres
postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -i
postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: background writer
postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: checkpointer
postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: walwriter
postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: autovacuum launcher
postgres  15558  0.0  0.0  17512  1068 ?        Ss   18:02   0:00 postgres: stats collector
postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: joe runbug 127.0.0.1 idle
postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: tgl regression [local] SELECT waiting
postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: tgl regression [local] idle in transaction
   </screen>

   (L'appel approprié de <command>ps</command> varie suivant les différentes
   plateformes, de même que les détails affichés. Cet exemple est
   tiré d'un système Linux récent.) Le premier processus affiché ici est le
   processus serveur maître. Les arguments
   affichés pour cette commande sont les mêmes qu'à son lancement. Les cinq
   processus suivants sont des processus en tâche de fond lancés
   automatiquement par le processus maître (le processus
   <quote>stats collector</quote> n'est pas présent si
   vous avez configuré le système pour qu'il ne lance pas le récupérateur de
   statistiques&nbsp;; de même que le processus <quote>autovacuum launcher</quote> peut être
   désactivé). Chacun des autres processus est un processus serveur gérant
   une connexion cliente. Tous ces processus restants initialisent l'affichage de
   la ligne de commande sous la forme&nbsp;:

   <screen>postgres: <replaceable>utilisateur</replaceable> <replaceable>base_de_données</replaceable> <replaceable>hôte</replaceable> <replaceable>activité</replaceable></screen>

  L'utilisateur, la base de données et les éléments de l'hôte (client)
  restent identiques pendant toute la vie de connexion du client mais,
  l'indicateur d'activité change. L'activité pourrait être <literal>idle</literal>
  (c'est-à-dire en attente d'une commande du client), <literal>idle in
  transaction</literal> (en attente du client à l'intérieur d'un bloc de
  <command>BEGIN</command>/<command>COMMIT</command>) ou un nom de commande du type
  <literal>SELECT</literal>. De plus, <literal>waiting</literal> est ajouté si le processus
  serveur est en attente d'un verrou détenu par une autre session.
  Dans l'exemple ci-dessus, nous pouvons supposer que le processus 15606 attend
  que le processus 15610 finisse sa transaction, et par conséquent libère un
  verrou (le processus 15610 doit être celui qui bloque car il n'y a aucune
  autre session active. Dans des cas plus compliqués, il serait nécessaire de
  regarder dans la vue système <link
  linkend="view-pg-locks"><structname>pg_locks</structname></link> pour
  déterminer qui est en train de bloquer qui.)
  </para>

  <para>
   Si <xref linkend="guc-cluster-name"/> a été configuré, le nom de l'instance
   figurera également dans la sortie&nbsp;:
<screen>
$ psql -c 'SHOW cluster_name'
 cluster_name
--------------
 server1
(1 row)

$ ps aux|grep server1
postgres   27093  0.0  0.0  30096  2752 ?        Ss   11:34   0:00 postgres: server1: background writer
...
</screen>
  </para>

  <para>
   Si vous avez désactivé <xref linkend="guc-update-process-title"/>, alors
   l'indicateur d'activité n'est pas mis à jour&nbsp;; le titre du processus
   est configuré une seule fois quand un nouveau processus est lancé. Sur
   certaines plateformes, ceci permet d'économiser du temps. Sur d'autres,
   cette économie est insignifiante.
  </para>

  <tip>
   <para>
    <productname>Solaris</productname> requiert une gestion particulière. Vous
    devez utiliser <command>/usr/ucb/ps</command> plutôt que
    <command>/bin/ps</command>. Vous devez aussi utiliser deux options
    <option>w</option> et non pas seulement une. En plus, votre appel original de
    la commande <command>postgres</command> doit avoir un affichage de statut
    dans <command>ps</command> plus petit que celui fourni par les autres
    processus serveur. Vous devez donc faire ces trois opérations sinon l'affichage de
    <command>ps</command> pour chaque processus serveur sera la ligne de commande
    originale de <command>postgres</command>.
   </para>
  </tip>
 </sect1>

 <sect1 id="monitoring-stats">
  <title>Le récupérateur de statistiques</title>

  <indexterm zone="monitoring-stats">
   <primary>statistiques</primary>
  </indexterm>

  <para>
   Le <firstterm>récupérateur de statistiques</firstterm> de
   <productname>PostgreSQL</productname> est un sous-système qui prend en charge la
   récupération et les rapports d'informations sur l'activité du serveur.
   Actuellement, le récupérateur peut compter les accès aux tables et index à la
   fois en termes de blocs disque et de lignes individuelles. Il conserve aussi
   la trace du nombre total de lignes dans chaque table ainsi que des informations
   sur les VACUUM et les ANALYZE pour chaque table.
   Il peut aussi compter le nombre d'appels aux fonctions définies par
   l'utilisateur ainsi que le temps total dépensé par chacune d'elles.
  </para>

  <para>
   <productname>PostgreSQL</productname> est également capable de
   renvoyer des informations dynamiques en temps réel sur ce qu'il se passe exactement
   dans le système, comme la commande exacte en cours
   d'exécution par d'autres processus serveur et les autres
   connexions qui existent dans le système. Cette fonctionnalité est indépendante
   du processus de récupération de données statistiques.
  </para>

 <sect2 id="monitoring-stats-setup">
  <title>Configuration de la récupération de statistiques</title>

  <para>
   Comme la récupération de statistiques ajoute un temps supplémentaire à
   l'exécution de la requête, le système peut être configuré pour récupérer ou
   non des informations. Ceci est contrôlé par les paramètres de configuration
   qui sont normalement initialisés dans <filename>postgresql.conf</filename> (voir
   <xref linkend="runtime-config"/> pour plus de détails sur leur
   initialisation).
  </para>

  <para>
   Le paramètre <xref linkend="guc-track-activities"/> active la collecte
   d'informations sur la commande en cours d'exécution pour n'importe quel
   processus serveur.
  </para>

  <para>
   Le paramètre <xref linkend="guc-track-counts"/> contrôle si les statistiques
   sont récupérées pour les accès aux tables et index.
  </para>

  <para>
   Le paramètre <xref linkend="guc-track-functions"/> active le calcul de
   statistiques sur l'utilisation des fonctions définies par l'utilisateur.
  </para>

  <para>
   Le paramètre <xref linkend="guc-track-io-timing"/> active la collecte
   des temps de lecture et d'écriture de blocs.
  </para>

  <para>
   Normalement, ces paramètres sont configurés dans
   <filename>postgresql.conf</filename> de façon à ce qu'ils s'appliquent à tous les
   processus serveur, mais il est possible de les activer/désactiver sur des
   sessions individuelles en utilisant la commande <xref
   linkend="sql-set"/> (pour empêcher les utilisateurs
   ordinaires de cacher leur activité à l'administrateur, seuls les
   superutilisateurs sont autorisés à modifier ces paramètres avec
   <command>SET</command>).
  </para>

  <para>
   Le collecteur de statistiques transmet l'information récupérée
   aux autres processus <productname>PostgreSQL</productname> à travers
   des fichiers temporaires. Ces fichiers sont stockés dans le répertoire
   défini par le paramètre <xref linkend="guc-stats-temp-directory"/>,
   par défaut <filename>pg_stat_tmp</filename>.
   Pour de meilleures performances, <varname>stats_temp_directory</varname>
   peut pointer vers un disque en RAM, diminuant ainsi les besoins en
   entrées/sorties physiques. Quand le serveur s'arrête proprement, une copie
   permanente des données statistiques est stockée dans le sous-répertoire
   <filename>pg_stat</filename>, pour que les statistiques puissent être
   conservées puis réutilisées au redémarrage du serveur. Lorsqu'au démarrage du
   serveur, la restauration est réalisée (par exemple, après un arrêt
   immédiat, un crash du serveur ou encore après une restauration PITR), tous
   les compteurs statistiques sont réinitialisés.
  </para>

  <para>
   Une transaction peut aussi voir des statistiques propres à son
   activité (qui ne sont pas encore transmises au collecteur) dans les
   vues <structname>pg_stat_xact_all_tables</structname>,
   <structname>pg_stat_xact_sys_tables</structname>,
   <structname>pg_stat_xact_user_tables</structname> et
   <structname>pg_stat_xact_user_functions</structname>.
   Ces informations se mettent à jour
   en continu pendant l'exécution de la transaction.
  </para>

 </sect2>

 <sect2 id="monitoring-stats-views">
  <title>Visualiser les statistiques</title>

  <para>
   Plusieurs vues prédéfinies, listées à <xref
   linkend="monitoring-stats-dynamic-views-table"/>, sont disponibles pour
   montrer l'état courant du système. Il existe aussi plusieurs autres
   vues, listées à <xref linkend="monitoring-stats-views-table"/>,
   qui montrent les résultats des statistiques
   récupérées. De manière alternative, il est possible de
   créer des vues personnalisées qui utilisent les
   fonctions statistiques sous-jacentes, comme discuté à <xref
   linkend="monitoring-stats-functions"/>.
  </para>

  <para>
   En utilisant les statistiques pour surveiller l'activité en cours, il est
   important de réaliser que l'information n'est pas mise à jour instantanément.
   Chaque processus serveur individuel transmet les nouvelles statistiques au
   récupérateur juste avant l'attente d'une
   nouvelle commande du client&nbsp;; donc une requête toujours en cours
   n'affecte pas les totaux affichés. De plus, le récupérateur lui-même émet un
   nouveau rapport une fois par <varname>PGSTAT_STAT_INTERVAL</varname>
   millisecondes (soit 500 millisecondes, sauf si cette valeur a été modifiée lors de la
   construction du serveur). Donc, les totaux affichés sont bien derrière
   l'activité réelle. Néanmoins, l'information sur la requête en cours récupérée
   par <varname>track_activities</varname> est toujours à jour.
  </para>

  <para>
   Un autre point important est que, lorsqu'un processus serveur se voit
   demander d'afficher une des statistiques, il récupère tout d'abord le rapport
   le plus récent émis par le processus de récupération, puis continue
   d'utiliser cette image de toutes les vues et fonctions statistiques jusqu'à
   la fin de sa transaction en cours. De façon similaire, les informations sur
   les requêtes en cours, quel que soit le processus, sont récupérées quand une
   telle information est demandée dans une transaction, et cette même information
   sera affichée lors de la transaction. Donc, les statistiques afficheront des
   informations statiques tant que vous restez dans la même transaction. Ceci est une
   fonctionnalité, et non pas un bogue, car il vous permet de traiter plusieurs
   requêtes sur les statistiques et de corréler les résultats sans vous
   inquiéter que les nombres aient pu changer. Mais si vous voulez voir les
   nouveaux résultats pour chaque requête, assurez-vous de lancer les requêtes
   en dehors de tout bloc de transaction. Autrement, vous pouvez appeler
   <function>pg_stat_clear_snapshot</function>(), qui annulera l'image statistique
   de la transaction en cours. L'utilisation suivante des informations
   statistiques causera la récupération d'une nouvelle image.
  </para>

  <para>
   Certaines des informations des vues statistiques dynamiques montrées dans
   <xref linkend="monitoring-stats-dynamic-views-table"/> sont à accès
   restreint. Les utilisateurs ordinaires peuvent seulement voir toutes les
   informations sur leur propres sessions (les sessions appartenant à un rôle
   dont ils sont membres). Les lignes des autres sessions auront de nombreuses
   colonnes à NULL. Notez néanmoins que l'existence d'une session et ses
   propriétés générales, tel que l'utilisateur et la base de données, sont
   visibles à tous les utilisateurs. Les superutilisateurs et les membres du
   rôle interne <literal>pg_read_all_stats</literal> (voir aussi <xref
   linkend="default-roles"/>) peuvent accéder à toutes les informations sur
   les sessions.
  </para>

  <table id="monitoring-stats-dynamic-views-table">
   <title>Vues statistiques dynamiques</title>

   <tgroup cols="2">
    <colspec colnum="1" colwidth="0.4*"/>
    <colspec colnum="2" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom de la vue</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <structname>pg_stat_activity</structname>
       <indexterm><primary>pg_stat_activity</primary></indexterm>
      </entry>
      <entry>
       Une ligne par processus serveur, montrant les informations
       liées à l'activité courante du processus, comme l'état et la
       requête en cours. Voir <xref linkend="pg-stat-activity-view"/>
       pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_replication</structname><indexterm><primary>pg_stat_replication</primary></indexterm></entry>
      <entry>Une ligne par processus d'envoi de WAL, montrant les
       statistiques sur la réplication vers le serveur standby connecté
       au processus.
       Voir <xref linkend="pg-stat-replication-view"/> pour les détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_wal_receiver</structname><indexterm><primary>pg_stat_wal_receiver</primary></indexterm></entry>
      <entry>Seulement une ligne, affichant des statistiques sur le récepteur
       WAL à partir du serveur ayant ce récepteur. Voir <xref
       linkend="pg-stat-wal-receiver-view"/> pour les détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_subscription</structname><indexterm><primary>pg_stat_subscription</primary></indexterm></entry>
      <entry>Au moins une ligne par souscription, affichant des informations
       sur les processus workers de souscription. Voir <xref
       linkend="pg-stat-subscription"/> pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_ssl</structname><indexterm><primary>pg_stat_ssl</primary></indexterm></entry>
      <entry>Une ligne par connexion (régulière et de réplication),
       montrant des informations sur le chiffrement SSL utilisé pour
       ces connexions.
       Voir <xref linkend="pg-stat-ssl-view"/> pour les détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_gssapi</structname><indexterm><primary>pg_stat_gssapi</primary></indexterm></entry>
      <entry>Une ligne par connexion (standard et réplication), montrant des
       informations sur l'authentification et le chiffrement GSSAPI utilisés
       sur cette connexion. Voir <xref linkend="pg-stat-gssapi-view"/> pour
       les détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_progress_analyze</structname><indexterm><primary>pg_stat_progress_analyze</primary></indexterm></entry>
      <entry>One row for each backend (including autovacuum worker processes) running
       <command>ANALYZE</command>, showing current progress.
       See <xref linkend='analyze-progress-reporting'/>.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_progress_create_index</structname><indexterm><primary>pg_stat_progress_create_index</primary></indexterm></entry>
      <entry>Une ligne pour chaque processus serveur exécutant un <command>CREATE
       INDEX</command> ou un <command>REINDEX</command>, affichant la
       progression actuelle. Voir
       <xref linkend='create-index-progress-reporting'/>.
     </entry>
     </row>

     <row>
      <entry><structname>pg_stat_progress_vacuum</structname><indexterm><primary>pg_stat_progress_vacuum</primary></indexterm></entry>
      <entry>Une ligne pour chaque processus (incluant les processus
       autovacuum worker) exécutant un <command>VACUUM</command>, affichant le
       progrès en cours. Voir <xref
       linkend='vacuum-progress-reporting'/>.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_progress_cluster</structname><indexterm><primary>pg_stat_progress_cluster</primary></indexterm></entry>
      <entry>Une ligne pour chaque processus serveur exécutant
       <command>CLUSTER</command> ou <command>VACUUM FULL</command>, affichant
       le progrès en cours.
       Voir <xref linkend='cluster-progress-reporting'/>.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_progress_basebackup</structname><indexterm><primary>pg_stat_progress_basebackup</primary></indexterm></entry>
      <entry>One row for each WAL sender process streaming a base backup,
       showing current progress.
       See <xref linkend='basebackup-progress-reporting'/>.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <table id="monitoring-stats-views-table">
   <title>Vues sur les statistiques récupérées</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>Nom de la vue</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structname>pg_stat_archiver</structname><indexterm><primary>pg_stat_archiver</primary></indexterm></entry>
      <entry>Une seule ligne, montrant les statistiques sur l'activité du
        processus d'archivage des journaux de transactions. Voir <xref
        linkend="pg-stat-archiver-view"/> pour les détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_bgwriter</structname><indexterm><primary>pg_stat_bgwriter</primary></indexterm></entry>
      <entry>Une seule ligne, montrant les statistiques
       d'activité du processus d'écriture d'arrière-plan.
       Voir <xref linkend="pg-stat-bgwriter-view"/> pour plus de détails.
     </entry>
     </row>

     <row>
      <entry><structname>pg_stat_database</structname><indexterm><primary>pg_stat_database</primary></indexterm></entry>
      <entry>Une ligne par base de données, montrant les statistiques
       globales des bases. Voir <xref linkend="pg-stat-database-view"/>
       pour plus de détails.
      </entry>
     </row>
     </tbody>

     <row>
      <entry><structname>pg_stat_database_conflicts</structname><indexterm><primary>pg_stat_database_conflicts</primary></indexterm></entry>
      <entry>
       Une ligne par base de données, montrant les statistiques au
       niveau de la base concernant les requêtes annulées à cause de
       conflits avec les serveurs standby en restauration.
       Voir <xref linkend="pg-stat-database-conflicts-view"/> pour les détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_tables</structname><indexterm><primary>pg_stat_all_tables</primary></indexterm></entry>
      <entry>
       Une ligne par table de la base de données courante, montrant les
       statistiques d'accès de chaque table spécifiquement. Voir
       <xref linkend="pg-stat-all-tables-view"/> pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_tables</structname><indexterm><primary>pg_stat_sys_tables</primary></indexterm></entry>
      <entry>Identique à <structname>pg_stat_all_tables</structname>, sauf que seules les
      tables systèmes sont affichées</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_tables</structname><indexterm><primary>pg_stat_user_tables</primary></indexterm></entry>
      <entry>Identique à <structname>pg_stat_all_tables</structname>, sauf que seules les
      tables utilisateurs sont affichées</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_all_tables</structname><indexterm><primary>pg_stat_xact_all_tables</primary></indexterm></entry>
      <entry>Similaire à <structname>pg_stat_all_tables</structname>, mais
      décompte les actions prises dans la transaction en cours (qui ne
      sont <emphasis>pas</emphasis> encore pris en compte dans la vue
      <structname>pg_stat_all_tables</structname> et les vues du même
      type). Les colonnes correspondant au nombre de lignes vivantes et
      mortes, ainsi que celles pour les actions du VACUUM et de l'ANALYZE
      ne sont pas présentes dans cette vue</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_sys_tables</structname><indexterm><primary>pg_stat_xact_sys_tables</primary></indexterm></entry>
      <entry>Identique à <structname>pg_stat_xact_all_tables</structname>,
      sauf que seules les tables systèmes sont affichées</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_user_tables</structname><indexterm><primary>pg_stat_xact_user_tables</primary></indexterm></entry>
      <entry>Identique à <structname>pg_stat_xact_all_tables</structname>, sauf que seules les
      tables utilisateurs sont affichées</entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_indexes</structname><indexterm><primary>pg_stat_all_indexes</primary></indexterm></entry>
      <entry>
       Une ligne par index de la base de données courante, montrant les
       statistiques d'accès de chaque index spécifiquement. Voir
       <xref linkend="pg-stat-all-indexes-view"/> pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_indexes</structname><indexterm><primary>pg_stat_sys_indexes</primary></indexterm></entry>
      <entry>Identique à <structname>pg_stat_all_indexes</structname>, sauf que seules les
      tables systèmes sont affichées</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_indexes</structname><indexterm><primary>pg_stat_user_indexes</primary></indexterm></entry>
      <entry>Identique à <structname>pg_stat_all_indexes</structname>, sauf que seules
      les tables utilisateurs sont affichées</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_tables</structname><indexterm><primary>pg_statio_all_tables</primary></indexterm></entry>
      <entry>
       Une ligne par table de la base de données courante, montrant les
       statistiques d'entrées/sorties de chaque table spécifiquement. Voir
       <xref linkend="pg-statio-all-tables-view"/> pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_tables</structname><indexterm><primary>pg_statio_sys_tables</primary></indexterm></entry>
      <entry>Identique à <structname>pg_statio_all_tables</structname>, sauf que seules
      les tables systèmes sont affichées</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_tables</structname><indexterm><primary>pg_statio_user_tables</primary></indexterm></entry>
      <entry>Identique à <structname>pg_statio_all_tables</structname>, sauf que seules
      les tables utilisateur sont affichées</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_indexes</structname><indexterm><primary>pg_statio_all_indexes</primary></indexterm></entry>
      <entry>
       Une ligne par index de la base de données courante, montrant les
       les statistiques d'entrées/sorties de chaque index spécifiquement. Voir
       <xref linkend="pg-statio-all-indexes-view"/> pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_indexes</structname><indexterm><primary>pg_statio_sys_indexes</primary></indexterm></entry>
      <entry>Identique à <structname>pg_statio_all_indexes</structname>, sauf que seuls
      les index systèmes sont affichés</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_indexes</structname><indexterm><primary>pg_statio_user_indexes</primary></indexterm></entry>
      <entry>Identique à <structname>pg_statio_all_indexes</structname>, sauf que seuls
      les index utilisateur sont affichés</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_sequences</structname><indexterm><primary>pg_statio_all_sequences</primary></indexterm></entry>
     <entry>
       Une ligne par séquence de la base de données courante, montrant les
       statistiques d'entrées/sorties de chaque séquence spécifiquement. Voir
       <xref linkend="pg-statio-all-sequences-view"/> pour plus de détails.
     </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_sequences</structname><indexterm><primary>pg_statio_sys_sequences</primary></indexterm></entry>
      <entry>Identique à <structname>pg_statio_all_sequences</structname>, sauf que
      seules les séquences système sont affichées (actuellement, aucune
      séquence système n'est définie, donc cette vue est toujours vide)</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_sequences</structname><indexterm><primary>pg_statio_user_sequences</primary></indexterm></entry>
      <entry>Identique à <structname>pg_statio_all_sequences</structname>, sauf que
      seules les séquences utilisateur sont affichées</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_functions</structname><indexterm><primary>pg_stat_user_functions</primary></indexterm></entry>
      <entry>
       Une ligne par fonction suivie, montrant les statistiques
       d'exécution de cette fonction. Voir
       <xref linkend="pg-stat-user-functions-view"/> pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_user_functions</structname><indexterm><primary>pg_stat_xact_user_functions</primary></indexterm></entry>
      <entry>Similaire à <structname>pg_stat_user_functions</structname>,
      mais compte seulement les appels pendant la transaction en cours
      (qui ne sont <emphasis>pas</emphasis> encore inclus dans
      <structname>pg_stat_user_functions</structname>)</entry>
     </row>

     <row>
      <entry><structname>pg_stat_slru</structname><indexterm><primary>pg_stat_slru</primary></indexterm></entry>
      <entry>One row per SLRU, showing statistics of operations. See
       <xref linkend="pg-stat-slru-view"/> for details.
      </entry>
     </row>

    </tgroup>
   </table>
  </sect2>

  <para>
   Les statistiques par index sont particulièrement utiles pour déterminer
   les index utilisés et leur efficacité.
  </para>

  <para>
   Les vues <structname>pg_statio_</structname> sont principalement utiles pour
   déterminer l'efficacité du cache tampon. Quand le nombre de lectures disques
   réelles est plus petit que le nombre de récupérations valides par le tampon,
   alors le cache satisfait la plupart des demandes de lecture sans faire appel
   au noyau. Néanmoins, ces statistiques ne nous donnent pas l'histoire
   complète&nbsp;: à cause de la façon dont <productname>PostgreSQL</productname> gère les
   entrées/sorties disque, les données qui ne sont pas dans le tampon de
   <productname>PostgreSQL</productname> pourraient toujours résider dans le tampon
   d'entrées/sorties du noyau et pourraient, du coup, être toujours récupérées
   sans nécessiter une lecture physique. Les utilisateurs intéressés pour
   obtenir des informations plus détaillées sur le comportement des
   entrées/sorties dans <productname>PostgreSQL</productname> sont invités à utiliser le
   récupérateur de statistiques de <productname>PostgreSQL</productname> avec les outils du
   système d'exploitation permettant une vue de la gestion des
   entrées/sorties par le noyau.
  </para>

  <table id="pg-stat-activity-view" xreflabel="pg_stat_activity">
   <title>Vue <structname>pg_stat_activity</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>datid</structfield> <type>oid</type>
     </para>
     <para>
      OID de la base de données auquel ce processus serveur est connecté
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>datname</structfield> <type>name</type>
     </para>
     <para>
      Nom de la base de données auquel ce processus serveur est connecté
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>pid</structfield> <type>integer</type>
     </para>
     <para>
      Identifiant du processus serveur
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>leader_pid</structfield> <type>integer</type>
     </para>
     <para>
      Process ID of the parallel group leader if this process is or
      has been involved in parallel query, or null. This field is set
      when a process wants to cooperate with parallel workers, and
      remains set as long as the process exists. For a parallel group leader,
      this field is set to its own process ID. For a parallel worker,
      this field is set to the process ID of the parallel group leader.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>usesysid</structfield> <type>oid</type>
     </para>
     <para>
      OID de l'utilisateur connecté à ce processus serveur
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>usename</structfield> <type>name</type>
     </para>
     <para>
      Nom de l'utilisateur connecté à ce processus serveur
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>application_name</structfield> <type>text</type>
     </para>
     <para>
      Nom de l'application connectée à ce processus serveur
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>client_addr</structfield> <type>inet</type>
     </para>
     <para>
      Adresse IP du client pour ce processus serveur.
      Si ce champ est vide, cela indique soit que le client est
      connecté via un socket Unix sur la machine serveur soit qu'il
      s'agit d'un processus interne tel qu'autovacuum.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>client_hostname</structfield> <type>text</type>
     </para>
     <para>
      Nom d'hôte du client connecté, comme reporté par une recherche DNS
      inverse sur <structfield>client_addr</structfield>. Ce champ ne sera rempli que
      pour les connexions IP, et seulement quand <xref
      linkend="guc-log-hostname"/> est activé.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>client_port</structfield> <type>integer</type>
     </para>
     <para>
      Numéro de port TCP que le client utilise pour communiquer
      avec le processus serveur,
      ou <literal>-1</literal> si un socket Unix est utilisé.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>backend_start</structfield> <type>timestamp with time zone</type>
     </para>
     <para>
      Heure de démarrage du processus.  Pour les processus backends,
      c'est l'heure où le client s'est connecté au serveur.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>xact_start</structfield> <type>timestamp with time zone</type>
     </para>
     <para>
      Heure de démarrage de la transaction courante du
      processus, ou NULL si aucune transaction n'est active. Si la
      requête courante est la première de sa transaction, cette
      colonne a la même valeur que la colonne
      <structfield>query_start</structfield>.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>query_start</structfield> <type>timestamp with time zone</type>
     </para>
     <para>
      Heure à laquelle la requête active a été démarrée, ou
      si <structfield>state</structfield> ne vaut pas
      <literal>active</literal>, quand la dernière requête
      a été lancée.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>state_change</structfield> <type>timestamp with time zone</type>
     </para>
     <para>
      Heure à laquelle l'état (<structfield>state</structfield>) a été modifié en dernier
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>wait_event_type</structfield> <type>text</type>
     </para>
     <para>
      Type de l'événement pour lequel le processus est en attente&nbsp;
      sinon NULL. See <xref linkend="wait-event-table"/>.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>wait_event</structfield> <type>text</type>
     </para>
     <para>
      Nom de l'événement d'attente si le processus est en attente, NULL
      dans le cas contraire. See <xref linkend="wait-event-activity-table"/> through
      <xref linkend="wait-event-timeout-table"/>.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>state</structfield> <type>text</type>
     </para>
     <para>
      État général du processus serveur.
      Les valeurs possibles sont&nbsp;:
       <itemizedlist>
         <listitem>
          <para>
           <literal>active</literal>&nbsp;: le processus serveur exécute une
           requête.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle</literal>&nbsp;: le processus serveur est en attente
           d'une commande par le client.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle in transaction</literal>&nbsp;: le processus serveur
           est en transaction, mais n'est pas en train d'exécuter une requête.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle in transaction (aborted)</literal>&nbsp;: l'état est
           similaire à <literal>idle in transaction</literal>, à la différence
           qu'une des instructions de la transaction a généré une erreur.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>fastpath function call</literal>&nbsp;: le processus serveur
           exécute une fonction fast-path.
          </para>
         </listitem>
         <listitem>
           <para>
           <literal>disabled</literal>&nbsp;: cet état est affiché si <xref
           linkend="guc-track-activities"/> est désactivé pour ce processus
           serveur.
          </para>
         </listitem>
       </itemizedlist>
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>backend_xid</structfield> <type>xid</type>
     </para>
     <para>
      Identifiant de transaction de haut niveau de ce processus, si
      disponible.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>backend_xmin</structfield> <type>xid</type>
     </para>
     <para>
      L'horizon <literal>xmin</literal> de ce processus.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>query</structfield> <type>text</type>
     </para>
     <para>
      Texte de la requête la plus récente pour ce processus serveur. Si
      <structfield>state</structfield> vaut <literal>active</literal>, alors
      ce champ affiche la requête en cours d'exécution. Dans tous les autres
      cas, il affichera la dernière requête à avoir été exécutée. Par défaut,
      le texte de la requête est tronqué à 1024 caractères. Cette valeur peut
      être modifiée avec le paramètre
      <xref linkend="guc-track-activity-query-size"/>.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>backend_type</structfield> <type>text</type>
     </para>
     <para>
      Type du processus actuel. Les types possibles sont
      <literal>autovacuum launcher</literal>, <literal>autovacuum worker</literal>,
      <literal>logical replication launcher</literal>,
      <literal>logical replication worker</literal>,
      <literal>parallel worker</literal>, <literal>background writer</literal>,
      <literal>client backend</literal>, <literal>checkpointer</literal>,
      <literal>startup</literal>, <literal>walreceiver</literal>,
      <literal>walsender</literal> et <literal>walwriter</literal>.
      De plus, les background workers enregistrés par les extensions pourraient
      avoir des types supplémentaires.
     </para></entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_activity</structname> aura une ligne par processus
   serveur, montrant des informations liées à l'activité courante de ce processus.
  </para>

  <note>
   <para>
    Les colonnes <structfield>wait_event</structfield> et
    <structfield>state</structfield> sont indépendantes. Si un processus
    serveur est dans l'état <literal>active</literal>, il pourrait, ou non,
    être en attente (<literal>waiting</literal>) d'un événement. Si l'état est
    <literal>active</literal> et si <structfield>wait_event</structfield> est
    différent de NULL, cela signifie qu'une requête est en cours d'exécution,
    mais que cette exécution est bloquée quelque part dans le système.
   </para>
  </note>

  <table id="wait-event-table">
   <title>Wait Event Types</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Wait Event Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>Activity</literal></entry>
      <entry>The server process is idle.  This event type indicates a process
       waiting for activity in its main processing loop.
       <literal>wait_event</literal> will identify the specific wait point;
       see <xref linkend="wait-event-activity-table"/>.
      </entry>
     </row>
     <row>
      <entry><literal>BufferPin</literal></entry>
      <entry>The server process is waiting for exclusive access to
       a data buffer.  Buffer pin waits can be protracted if
       another process holds an open cursor that last read data from the
       buffer in question. See <xref linkend="wait-event-bufferpin-table"/>.
      </entry>
     </row>
     <row>
      <entry><literal>Client</literal></entry>
      <entry>The server process is waiting for activity on a socket
       connected to a user application.  Thus, the server expects something
       to happen that is independent of its internal processes.
       <literal>wait_event</literal> will identify the specific wait point;
       see <xref linkend="wait-event-client-table"/>.
      </entry>
     </row>
     <row>
      <entry><literal>Extension</literal></entry>
      <entry>The server process is waiting for some condition defined by an
       extension module.
       See <xref linkend="wait-event-extension-table"/>.
      </entry>
     </row>
     <row>
      <entry><literal>IO</literal></entry>
      <entry>The server process is waiting for an I/O operation to complete.
       <literal>wait_event</literal> will identify the specific wait point;
       see <xref linkend="wait-event-io-table"/>.
      </entry>
     </row>
     <row>
      <entry><literal>IPC</literal></entry>
      <entry>The server process is waiting for some interaction with
       another server process.  <literal>wait_event</literal> will
       identify the specific wait point;
       see <xref linkend="wait-event-ipc-table"/>.
      </entry>
     </row>
     <row>
      <entry><literal>Lock</literal></entry>
      <entry>The server process is waiting for a heavyweight lock.
       Heavyweight locks, also known as lock manager locks or simply locks,
       primarily protect SQL-visible objects such as tables.  However,
       they are also used to ensure mutual exclusion for certain internal
       operations such as relation extension.  <literal>wait_event</literal>
       will identify the type of lock awaited;
       see <xref linkend="wait-event-lock-table"/>.
      </entry>
     </row>
     <row>
      <entry><literal>LWLock</literal></entry>
      <entry> The server process is waiting for a lightweight lock.
       Most such locks protect a particular data structure in shared memory.
       <literal>wait_event</literal> will contain a name identifying the purpose
       of the lightweight lock.  (Some locks have specific names; others
       are part of a group of locks each with a similar purpose.)
       See <xref linkend="wait-event-lwlock-table"/>.
      </entry>
     </row>
     <row>
      <entry><literal>Timeout</literal></entry>
      <entry>The server process is waiting for a timeout
       to expire.  <literal>wait_event</literal> will identify the specific wait
       point; see <xref linkend="wait-event-timeout-table"/>.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-activity-table">
   <title>Wait Events of Type <literal>Activity</literal></title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry><literal>Activity</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>ArchiverMain</literal></entry>
      <entry>Waiting in main loop of archiver process.</entry>
     </row>
     <row>
      <entry><literal>AutoVacuumMain</literal></entry>
      <entry>Waiting in main loop of autovacuum launcher process.</entry>
     </row>
     <row>
      <entry><literal>BgWriterHibernate</literal></entry>
      <entry>Waiting in background writer process, hibernating.</entry>
     </row>
     <row>
      <entry><literal>BgWriterMain</literal></entry>
      <entry>Waiting in main loop of background writer process.</entry>
     </row>
     <row>
      <entry><literal>CheckpointerMain</literal></entry>
      <entry>Waiting in main loop of checkpointer process.</entry>
     </row>
     <row>
      <entry><literal>LogicalApplyMain</literal></entry>
      <entry>Waiting in main loop of logical replication apply process.</entry>
     </row>
     <row>
      <entry><literal>LogicalLauncherMain</literal></entry>
      <entry>Waiting in main loop of logical replication launcher process.</entry>
     </row>
     <row>
      <entry><literal>PgStatMain</literal></entry>
      <entry>Waiting in main loop of statistics collector process.</entry>
     </row>
     <row>
      <entry><literal>RecoveryWalStream</literal></entry>
      <entry>Waiting in main loop of startup process for WAL to arrive, during
       streaming recovery.</entry>
     </row>
     <row>
      <entry><literal>SysLoggerMain</literal></entry>
      <entry>Waiting in main loop of syslogger process.</entry>
     </row>
     <row>
      <entry><literal>WalReceiverMain</literal></entry>
      <entry>Waiting in main loop of WAL receiver process.</entry>
     </row>
     <row>
      <entry><literal>WalSenderMain</literal></entry>
      <entry>Waiting in main loop of WAL sender process.</entry>
     </row>
     <row>
      <entry><literal>WalWriterMain</literal></entry>
      <entry>Waiting in main loop of WAL writer process.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-bufferpin-table">
   <title>Wait Events of Type <literal>BufferPin</literal></title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry><literal>BufferPin</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>BufferPin</literal></entry>
      <entry>Waiting to acquire an exclusive pin on a buffer.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-client-table">
   <title>Wait Events of Type <literal>Client</literal></title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry><literal>Client</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>ClientRead</literal></entry>
      <entry>Waiting to read data from the client.</entry>
     </row>
     <row>
      <entry><literal>ClientWrite</literal></entry>
      <entry>Waiting to write data to the client.</entry>
     </row>
     <row>
      <entry><literal>GSSOpenServer</literal></entry>
      <entry>Waiting to read data from the client while establishing a GSSAPI
       session.</entry>
     </row>
     <row>
      <entry><literal>LibPQWalReceiverConnect</literal></entry>
      <entry>Waiting in WAL receiver to establish connection to remote
       server.</entry>
     </row>
     <row>
      <entry><literal>LibPQWalReceiverReceive</literal></entry>
      <entry>Waiting in WAL receiver to receive data from remote server.</entry>
     </row>
     <row>
      <entry><literal>SSLOpenServer</literal></entry>
      <entry>Waiting for SSL while attempting connection.</entry>
     </row>
     <row>
      <entry><literal>WalReceiverWaitStart</literal></entry>
      <entry>Waiting for startup process to send initial data for streaming
       replication.</entry>
     </row>
     <row>
      <entry><literal>WalSenderWaitForWAL</literal></entry>
      <entry>Waiting for WAL to be flushed in WAL sender process.</entry>
     </row>
     <row>
      <entry><literal>WalSenderWriteData</literal></entry>
      <entry>Waiting for any activity when processing replies from WAL
       receiver in WAL sender process.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-extension-table">
   <title>Wait Events of Type <literal>Extension</literal></title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry><literal>Extension</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>Extension</literal></entry>
      <entry>Waiting in an extension.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-io-table">
   <title>Wait Events of Type <literal>IO</literal></title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry><literal>IO</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>BufFileRead</literal></entry>
      <entry>Waiting for a read from a buffered file.</entry>
     </row>
     <row>
      <entry><literal>BufFileWrite</literal></entry>
      <entry>Waiting for a write to a buffered file.</entry>
     </row>
     <row>
      <entry><literal>ControlFileRead</literal></entry>
      <entry>Waiting for a read from the <filename>pg_control</filename>
       file.</entry>
     </row>
     <row>
      <entry><literal>ControlFileSync</literal></entry>
      <entry>Waiting for the <filename>pg_control</filename> file to reach
       stable storage.</entry>
     </row>
     <row>
      <entry><literal>ControlFileSyncUpdate</literal></entry>
      <entry>Waiting for an update to the <filename>pg_control</filename> file
       to reach stable storage.</entry>
     </row>
     <row>
      <entry><literal>ControlFileWrite</literal></entry>
      <entry>Waiting for a write to the <filename>pg_control</filename>
       file.</entry>
     </row>
     <row>
      <entry><literal>ControlFileWriteUpdate</literal></entry>
      <entry>Waiting for a write to update the <filename>pg_control</filename>
       file.</entry>
     </row>
     <row>
      <entry><literal>CopyFileRead</literal></entry>
      <entry>Waiting for a read during a file copy operation.</entry>
     </row>
     <row>
      <entry><literal>CopyFileWrite</literal></entry>
      <entry>Waiting for a write during a file copy operation.</entry>
     </row>
     <row>
      <entry><literal>DSMFillZeroWrite</literal></entry>
      <entry>Waiting to fill a dynamic shared memory backing file with
       zeroes.</entry>
     </row>
     <row>
      <entry><literal>DataFileExtend</literal></entry>
      <entry>Waiting for a relation data file to be extended.</entry>
     </row>
     <row>
      <entry><literal>DataFileFlush</literal></entry>
      <entry>Waiting for a relation data file to reach stable storage.</entry>
     </row>
     <row>
      <entry><literal>DataFileImmediateSync</literal></entry>
      <entry>Waiting for an immediate synchronization of a relation data file to
       stable storage.</entry>
     </row>
     <row>
      <entry><literal>DataFilePrefetch</literal></entry>
      <entry>Waiting for an asynchronous prefetch from a relation data
       file.</entry>
     </row>
     <row>
      <entry><literal>DataFileRead</literal></entry>
      <entry>Waiting for a read from a relation data file.</entry>
     </row>
     <row>
      <entry><literal>DataFileSync</literal></entry>
      <entry>Waiting for changes to a relation data file to reach stable storage.</entry>
     </row>
     <row>
      <entry><literal>DataFileTruncate</literal></entry>
      <entry>Waiting for a relation data file to be truncated.</entry>
     </row>
     <row>
      <entry><literal>DataFileWrite</literal></entry>
      <entry>Waiting for a write to a relation data file.</entry>
     </row>
     <row>
      <entry><literal>LockFileAddToDataDirRead</literal></entry>
      <entry>Waiting for a read while adding a line to the data directory lock
       file.</entry>
     </row>
     <row>
      <entry><literal>LockFileAddToDataDirSync</literal></entry>
      <entry>Waiting for data to reach stable storage while adding a line to the
       data directory lock file.</entry>
     </row>
     <row>
      <entry><literal>LockFileAddToDataDirWrite</literal></entry>
      <entry>Waiting for a write while adding a line to the data directory
       lock file.</entry>
     </row>
     <row>
      <entry><literal>LockFileCreateRead</literal></entry>
      <entry>Waiting to read while creating the data directory lock
       file.</entry>
     </row>
     <row>
      <entry><literal>LockFileCreateSync</literal></entry>
      <entry>Waiting for data to reach stable storage while creating the data
       directory lock file.</entry>
     </row>
     <row>
      <entry><literal>LockFileCreateWrite</literal></entry>
      <entry>Waiting for a write while creating the data directory lock
       file.</entry>
     </row>
     <row>
      <entry><literal>LockFileReCheckDataDirRead</literal></entry>
      <entry>Waiting for a read during recheck of the data directory lock
       file.</entry>
     </row>
     <row>
      <entry><literal>LogicalRewriteCheckpointSync</literal></entry>
      <entry>Waiting for logical rewrite mappings to reach stable storage
       during a checkpoint.</entry>
     </row>
     <row>
      <entry><literal>LogicalRewriteMappingSync</literal></entry>
      <entry>Waiting for mapping data to reach stable storage during a logical
       rewrite.</entry>
     </row>
     <row>
      <entry><literal>LogicalRewriteMappingWrite</literal></entry>
      <entry>Waiting for a write of mapping data during a logical
       rewrite.</entry>
     </row>
     <row>
      <entry><literal>LogicalRewriteSync</literal></entry>
      <entry>Waiting for logical rewrite mappings to reach stable
       storage.</entry>
     </row>
     <row>
      <entry><literal>LogicalRewriteTruncate</literal></entry>
      <entry>Waiting for truncate of mapping data during a logical
       rewrite.</entry>
     </row>
     <row>
      <entry><literal>LogicalRewriteWrite</literal></entry>
      <entry>Waiting for a write of logical rewrite mappings.</entry>
     </row>
     <row>
      <entry><literal>RelationMapRead</literal></entry>
      <entry>Waiting for a read of the relation map file.</entry>
     </row>
     <row>
      <entry><literal>RelationMapSync</literal></entry>
      <entry>Waiting for the relation map file to reach stable storage.</entry>
     </row>
     <row>
      <entry><literal>RelationMapWrite</literal></entry>
      <entry>Waiting for a write to the relation map file.</entry>
     </row>
     <row>
      <entry><literal>ReorderBufferRead</literal></entry>
      <entry>Waiting for a read during reorder buffer management.</entry>
     </row>
     <row>
      <entry><literal>ReorderBufferWrite</literal></entry>
      <entry>Waiting for a write during reorder buffer management.</entry>
     </row>
     <row>
      <entry><literal>ReorderLogicalMappingRead</literal></entry>
      <entry>Waiting for a read of a logical mapping during reorder buffer
       management.</entry>
     </row>
     <row>
      <entry><literal>ReplicationSlotRead</literal></entry>
      <entry>Waiting for a read from a replication slot control file.</entry>
     </row>
     <row>
      <entry><literal>ReplicationSlotRestoreSync</literal></entry>
      <entry>Waiting for a replication slot control file to reach stable storage
       while restoring it to memory.</entry>
     </row>
     <row>
      <entry><literal>ReplicationSlotSync</literal></entry>
      <entry>Waiting for a replication slot control file to reach stable
       storage.</entry>
     </row>
     <row>
      <entry><literal>ReplicationSlotWrite</literal></entry>
      <entry>Waiting for a write to a replication slot control file.</entry>
     </row>
     <row>
      <entry><literal>SLRUFlushSync</literal></entry>
      <entry>Waiting for SLRU data to reach stable storage during a checkpoint
       or database shutdown.</entry>
     </row>
     <row>
      <entry><literal>SLRURead</literal></entry>
      <entry>Waiting for a read of an SLRU page.</entry>
     </row>
     <row>
      <entry><literal>SLRUSync</literal></entry>
      <entry>Waiting for SLRU data to reach stable storage following a page
       write.</entry>
     </row>
     <row>
      <entry><literal>SLRUWrite</literal></entry>
      <entry>Waiting for a write of an SLRU page.</entry>
     </row>
     <row>
      <entry><literal>SnapbuildRead</literal></entry>
      <entry>Waiting for a read of a serialized historical catalog
       snapshot.</entry>
     </row>
     <row>
      <entry><literal>SnapbuildSync</literal></entry>
      <entry>Waiting for a serialized historical catalog snapshot to reach
       stable storage.</entry>
     </row>
     <row>
      <entry><literal>SnapbuildWrite</literal></entry>
      <entry>Waiting for a write of a serialized historical catalog
       snapshot.</entry>
     </row>
     <row>
      <entry><literal>TimelineHistoryFileSync</literal></entry>
      <entry>Waiting for a timeline history file received via streaming
       replication to reach stable storage.</entry>
     </row>
     <row>
      <entry><literal>TimelineHistoryFileWrite</literal></entry>
      <entry>Waiting for a write of a timeline history file received via
       streaming replication.</entry>
     </row>
     <row>
      <entry><literal>TimelineHistoryRead</literal></entry>
      <entry>Waiting for a read of a timeline history file.</entry>
     </row>
     <row>
      <entry><literal>TimelineHistorySync</literal></entry>
      <entry>Waiting for a newly created timeline history file to reach stable
       storage.</entry>
     </row>
     <row>
      <entry><literal>TimelineHistoryWrite</literal></entry>
      <entry>Waiting for a write of a newly created timeline history
       file.</entry>
     </row>
     <row>
      <entry><literal>TwophaseFileRead</literal></entry>
      <entry>Waiting for a read of a two phase state file.</entry>
     </row>
     <row>
      <entry><literal>TwophaseFileSync</literal></entry>
      <entry>Waiting for a two phase state file to reach stable storage.</entry>
     </row>
     <row>
      <entry><literal>TwophaseFileWrite</literal></entry>
      <entry>Waiting for a write of a two phase state file.</entry>
     </row>
     <row>
      <entry><literal>WALBootstrapSync</literal></entry>
      <entry>Waiting for WAL to reach stable storage during
       bootstrapping.</entry>
     </row>
     <row>
      <entry><literal>WALBootstrapWrite</literal></entry>
      <entry>Waiting for a write of a WAL page during bootstrapping.</entry>
     </row>
     <row>
      <entry><literal>WALCopyRead</literal></entry>
      <entry>Waiting for a read when creating a new WAL segment by copying an
       existing one.</entry>
     </row>
     <row>
      <entry><literal>WALCopySync</literal></entry>
      <entry>Waiting for a new WAL segment created by copying an existing one to
       reach stable storage.</entry>
     </row>
     <row>
      <entry><literal>WALCopyWrite</literal></entry>
      <entry>Waiting for a write when creating a new WAL segment by copying an
       existing one.</entry>
     </row>
     <row>
      <entry><literal>WALInitSync</literal></entry>
      <entry>Waiting for a newly initialized WAL file to reach stable
       storage.</entry>
     </row>
     <row>
      <entry><literal>WALInitWrite</literal></entry>
      <entry>Waiting for a write while initializing a new WAL file.</entry>
     </row>
     <row>
      <entry><literal>WALRead</literal></entry>
      <entry>Waiting for a read from a WAL file.</entry>
     </row>
     <row>
      <entry><literal>WALSenderTimelineHistoryRead</literal></entry>
      <entry>Waiting for a read from a timeline history file during a walsender
       timeline command.</entry>
     </row>
     <row>
      <entry><literal>WALSync</literal></entry>
      <entry>Waiting for a WAL file to reach stable storage.</entry>
     </row>
     <row>
      <entry><literal>WALSyncMethodAssign</literal></entry>
      <entry>Waiting for data to reach stable storage while assigning a new
       WAL sync method.</entry>
     </row>
     <row>
      <entry><literal>WALWrite</literal></entry>
      <entry>Waiting for a write to a WAL file.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-ipc-table">
   <title>Wait Events of Type <literal>IPC</literal></title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry><literal>IPC</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>BackupWaitWalArchive</literal></entry>
      <entry>Waiting for WAL files required for a backup to be successfully
       archived.</entry>
     </row>
     <row>
      <entry><literal>BgWorkerShutdown</literal></entry>
      <entry>Waiting for background worker to shut down.</entry>
     </row>
     <row>
      <entry><literal>BgWorkerStartup</literal></entry>
      <entry>Waiting for background worker to start up.</entry>
     </row>
     <row>
      <entry><literal>BtreePage</literal></entry>
      <entry>Waiting for the page number needed to continue a parallel B-tree
       scan to become available.</entry>
     </row>
     <row>
      <entry><literal>CheckpointDone</literal></entry>
      <entry>Waiting for a checkpoint to complete.</entry>
     </row>
     <row>
      <entry><literal>CheckpointStart</literal></entry>
      <entry>Waiting for a checkpoint to start.</entry>
     </row>
     <row>
      <entry><literal>ExecuteGather</literal></entry>
      <entry>Waiting for activity from a child process while
       executing a <literal>Gather</literal> plan node.</entry>
     </row>
     <row>
      <entry><literal>HashBatchAllocate</literal></entry>
      <entry>Waiting for an elected Parallel Hash participant to allocate a hash
       table.</entry>
     </row>
     <row>
      <entry><literal>HashBatchElect</literal></entry>
      <entry>Waiting to elect a Parallel Hash participant to allocate a hash
       table.</entry>
     </row>
     <row>
      <entry><literal>HashBatchLoad</literal></entry>
      <entry>Waiting for other Parallel Hash participants to finish loading a
       hash table.</entry>
     </row>
     <row>
      <entry><literal>HashBuildAllocate</literal></entry>
      <entry>Waiting for an elected Parallel Hash participant to allocate the
       initial hash table.</entry>
     </row>
     <row>
      <entry><literal>HashBuildElect</literal></entry>
      <entry>Waiting to elect a Parallel Hash participant to allocate the
       initial hash table.</entry>
     </row>
     <row>
      <entry><literal>HashBuildHashInner</literal></entry>
      <entry>Waiting for other Parallel Hash participants to finish hashing the
       inner relation.</entry>
     </row>
     <row>
      <entry><literal>HashBuildHashOuter</literal></entry>
      <entry>Waiting for other Parallel Hash participants to finish partitioning
       the outer relation.</entry>
     </row>
     <row>
      <entry><literal>HashGrowBatchesAllocate</literal></entry>
      <entry>Waiting for an elected Parallel Hash participant to allocate more
       batches.</entry>
     </row>
     <row>
      <entry><literal>HashGrowBatchesDecide</literal></entry>
      <entry>Waiting to elect a Parallel Hash participant to decide on future
       batch growth.</entry>
     </row>
     <row>
      <entry><literal>HashGrowBatchesElect</literal></entry>
      <entry>Waiting to elect a Parallel Hash participant to allocate more
       batches.</entry>
     </row>
     <row>
      <entry><literal>HashGrowBatchesFinish</literal></entry>
      <entry>Waiting for an elected Parallel Hash participant to decide on
       future batch growth.</entry>
     </row>
     <row>
      <entry><literal>HashGrowBatchesRepartition</literal></entry>
      <entry>Waiting for other Parallel Hash participants to finish
       repartitioning.</entry>
     </row>
     <row>
      <entry><literal>HashGrowBucketsAllocate</literal></entry>
      <entry>Waiting for an elected Parallel Hash participant to finish
       allocating more buckets.</entry>
     </row>
     <row>
      <entry><literal>HashGrowBucketsElect</literal></entry>
      <entry>Waiting to elect a Parallel Hash participant to allocate more
       buckets.</entry>
     </row>
     <row>
      <entry><literal>HashGrowBucketsReinsert</literal></entry>
      <entry>Waiting for other Parallel Hash participants to finish inserting
       tuples into new buckets.</entry>
     </row>
     <row>
      <entry><literal>LogicalSyncData</literal></entry>
      <entry>Waiting for a logical replication remote server to send data for
       initial table synchronization.</entry>
     </row>
     <row>
      <entry><literal>LogicalSyncStateChange</literal></entry>
      <entry>Waiting for a logical replication remote server to change
       state.</entry>
     </row>
     <row>
      <entry><literal>MessageQueueInternal</literal></entry>
      <entry>Waiting for another process to be attached to a shared message
       queue.</entry>
     </row>
     <row>
      <entry><literal>MessageQueuePutMessage</literal></entry>
      <entry>Waiting to write a protocol message to a shared message queue.</entry>
     </row>
     <row>
      <entry><literal>MessageQueueReceive</literal></entry>
      <entry>Waiting to receive bytes from a shared message queue.</entry>
     </row>
     <row>
      <entry><literal>MessageQueueSend</literal></entry>
      <entry>Waiting to send bytes to a shared message queue.</entry>
     </row>
     <row>
      <entry><literal>ParallelBitmapScan</literal></entry>
      <entry>Waiting for parallel bitmap scan to become initialized.</entry>
     </row>
     <row>
      <entry><literal>ParallelCreateIndexScan</literal></entry>
      <entry>Waiting for parallel <command>CREATE INDEX</command> workers to
       finish heap scan.</entry>
     </row>
     <row>
      <entry><literal>ParallelFinish</literal></entry>
      <entry>Waiting for parallel workers to finish computing.</entry>
     </row>
     <row>
      <entry><literal>ProcArrayGroupUpdate</literal></entry>
      <entry>Waiting for the group leader to clear the transaction ID at
       end of a parallel operation.</entry>
     </row>
     <row>
      <entry><literal>ProcSignalBarrier</literal></entry>
      <entry>Waiting for a barrier event to be processed by all
       backends.</entry>
     </row>
     <row>
      <entry><literal>Promote</literal></entry>
      <entry>Waiting for standby promotion.</entry>
     </row>
     <row>
      <entry><literal>RecoveryConflictSnapshot</literal></entry>
      <entry>Waiting for recovery conflict resolution for a vacuum
       cleanup.</entry>
     </row>
     <row>
      <entry><literal>RecoveryConflictTablespace</literal></entry>
      <entry>Waiting for recovery conflict resolution for dropping a
       tablespace.</entry>
     </row>
     <row>
      <entry><literal>RecoveryPause</literal></entry>
      <entry>Waiting for recovery to be resumed.</entry>
     </row>
     <row>
      <entry><literal>ReplicationOriginDrop</literal></entry>
      <entry>Waiting for a replication origin to become inactive so it can be
       dropped.</entry>
     </row>
     <row>
      <entry><literal>ReplicationSlotDrop</literal></entry>
      <entry>Waiting for a replication slot to become inactive so it can be
       dropped.</entry>
     </row>
     <row>
      <entry><literal>SafeSnapshot</literal></entry>
      <entry>Waiting to obtain a valid snapshot for a <literal>READ ONLY
       DEFERRABLE</literal> transaction.</entry>
     </row>
     <row>
      <entry><literal>SyncRep</literal></entry>
      <entry>Waiting for confirmation from a remote server during synchronous
       replication.</entry>
     </row>
     <row>
      <entry><literal>XactGroupUpdate</literal></entry>
      <entry>Waiting for the group leader to update transaction status at
       end of a parallel operation.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-lock-table">
   <title>Wait Events of Type <literal>Lock</literal></title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry><literal>Lock</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>advisory</literal></entry>
      <entry>Waiting to acquire an advisory user lock.</entry>
     </row>
     <row>
      <entry><literal>extend</literal></entry>
      <entry>Waiting to extend a relation.</entry>
     </row>
     <row>
      <entry><literal>object</literal></entry>
      <entry>Waiting to acquire a lock on a non-relation database object.</entry>
     </row>
     <row>
      <entry><literal>page</literal></entry>
      <entry>Waiting to acquire a lock on a page of a relation.</entry>
     </row>
     <row>
      <entry><literal>relation</literal></entry>
      <entry>Waiting to acquire a lock on a relation.</entry>
     </row>
     <row>
      <entry><literal>spectoken</literal></entry>
      <entry>Waiting to acquire a speculative insertion lock.</entry>
     </row>
     <row>
      <entry><literal>transactionid</literal></entry>
      <entry>Waiting for a transaction to finish.</entry>
     </row>
     <row>
      <entry><literal>tuple</literal></entry>
      <entry>Waiting to acquire a lock on a tuple.</entry>
     </row>
     <row>
      <entry><literal>userlock</literal></entry>
      <entry>Waiting to acquire a user lock.</entry>
     </row>
     <row>
      <entry><literal>virtualxid</literal></entry>
      <entry>Waiting to acquire a virtual transaction ID lock.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-lwlock-table">
   <title>Wait Events of Type <literal>LWLock</literal></title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry><literal>LWLock</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>AddinShmemInit</literal></entry>
      <entry>Waiting to manage an extension's space allocation in shared
       memory.</entry>
     </row>
     <row>
      <entry><literal>AutoFile</literal></entry>
      <entry>Waiting to update the <filename>postgresql.auto.conf</filename>
       file.</entry>
     </row>
     <row>
      <entry><literal>Autovacuum</literal></entry>
      <entry>Waiting to read or update the current state of autovacuum
       workers.</entry>
     </row>
     <row>
      <entry><literal>AutovacuumSchedule</literal></entry>
      <entry>Waiting to ensure that a table selected for autovacuum
       still needs vacuuming.</entry>
     </row>
     <row>
      <entry><literal>BackgroundWorker</literal></entry>
      <entry>Waiting to read or update background worker state.</entry>
     </row>
     <row>
      <entry><literal>BtreeVacuum</literal></entry>
      <entry>Waiting to read or update vacuum-related information for a
       B-tree index.</entry>
     </row>
     <row>
      <entry><literal>BufferContent</literal></entry>
      <entry>Waiting to access a data page in memory.</entry>
     </row>
     <row>
      <entry><literal>BufferIO</literal></entry>
      <entry>Waiting for I/O on a data page.</entry>
     </row>
     <row>
      <entry><literal>BufferMapping</literal></entry>
      <entry>Waiting to associate a data block with a buffer in the buffer
       pool.</entry>
     </row>
     <row>
      <entry><literal>Checkpoint</literal></entry>
      <entry>Waiting to begin a checkpoint.</entry>
     </row>
     <row>
      <entry><literal>CheckpointerComm</literal></entry>
      <entry>Waiting to manage fsync requests.</entry>
     </row>
     <row>
      <entry><literal>CommitTs</literal></entry>
      <entry>Waiting to read or update the last value set for a
       transaction commit timestamp.</entry>
     </row>
     <row>
      <entry><literal>CommitTsBuffer</literal></entry>
      <entry>Waiting for I/O on a commit timestamp SLRU buffer.</entry>
     </row>
     <row>
      <entry><literal>CommitTsSLRU</literal></entry>
      <entry>Waiting to access the commit timestamp SLRU cache.</entry>
     </row>
     <row>
      <entry><literal>ControlFile</literal></entry>
      <entry>Waiting to read or update the <filename>pg_control</filename>
       file or create a new WAL file.</entry>
     </row>
     <row>
      <entry><literal>DynamicSharedMemoryControl</literal></entry>
      <entry>Waiting to read or update dynamic shared memory allocation
       information.</entry>
     </row>
     <row>
      <entry><literal>LockFastPath</literal></entry>
      <entry>Waiting to read or update a process' fast-path lock
       information.</entry>
     </row>
     <row>
      <entry><literal>LockManager</literal></entry>
      <entry>Waiting to read or update information
       about <quote>heavyweight</quote> locks.</entry>
     </row>
     <row>
      <entry><literal>LogicalRepWorker</literal></entry>
      <entry>Waiting to read or update the state of logical replication
       workers.</entry>
     </row>
     <row>
      <entry><literal>MultiXactGen</literal></entry>
      <entry>Waiting to read or update shared multixact state.</entry>
     </row>
     <row>
      <entry><literal>MultiXactMemberBuffer</literal></entry>
      <entry>Waiting for I/O on a multixact member SLRU buffer.</entry>
     </row>
     <row>
      <entry><literal>MultiXactMemberSLRU</literal></entry>
      <entry>Waiting to access the multixact member SLRU cache.</entry>
     </row>
     <row>
      <entry><literal>MultiXactOffsetBuffer</literal></entry>
      <entry>Waiting for I/O on a multixact offset SLRU buffer.</entry>
     </row>
     <row>
      <entry><literal>MultiXactOffsetSLRU</literal></entry>
      <entry>Waiting to access the multixact offset SLRU cache.</entry>
     </row>
     <row>
      <entry><literal>MultiXactTruncation</literal></entry>
      <entry>Waiting to read or truncate multixact information.</entry>
     </row>
     <row>
      <entry><literal>NotifyBuffer</literal></entry>
      <entry>Waiting for I/O on a <command>NOTIFY</command> message SLRU
       buffer.</entry>
     </row>
     <row>
      <entry><literal>NotifyQueue</literal></entry>
      <entry>Waiting to read or update <command>NOTIFY</command> messages.</entry>
     </row>
     <row>
      <entry><literal>NotifySLRU</literal></entry>
      <entry>Waiting to access the <command>NOTIFY</command> message SLRU
       cache.</entry>
     </row>
     <row>
      <entry><literal>OidGen</literal></entry>
      <entry>Waiting to allocate a new OID.</entry>
     </row>
     <row>
      <entry><literal>OldSnapshotTimeMap</literal></entry>
      <entry>Waiting to read or update old snapshot control information.</entry>
     </row>
     <row>
      <entry><literal>ParallelAppend</literal></entry>
      <entry>Waiting to choose the next subplan during Parallel Append plan
       execution.</entry>
     </row>
     <row>
      <entry><literal>ParallelHashJoin</literal></entry>
      <entry>Waiting to synchronize workers during Parallel Hash Join plan
       execution.</entry>
     </row>
     <row>
      <entry><literal>ParallelQueryDSA</literal></entry>
      <entry>Waiting for parallel query dynamic shared memory allocation.</entry>
     </row>
     <row>
      <entry><literal>PerSessionDSA</literal></entry>
      <entry>Waiting for parallel query dynamic shared memory allocation.</entry>
     </row>
     <row>
      <entry><literal>PerSessionRecordType</literal></entry>
      <entry>Waiting to access a parallel query's information about composite
       types.</entry>
     </row>
     <row>
      <entry><literal>PerSessionRecordTypmod</literal></entry>
      <entry>Waiting to access a parallel query's information about type
       modifiers that identify anonymous record types.</entry>
     </row>
     <row>
      <entry><literal>PerXactPredicateList</literal></entry>
      <entry>Waiting to access the list of predicate locks held by the current
       serializable transaction during a parallel query.</entry>
     </row>
     <row>
      <entry><literal>PredicateLockManager</literal></entry>
      <entry>Waiting to access predicate lock information used by
       serializable transactions.</entry>
     </row>
     <row>
      <entry><literal>ProcArray</literal></entry>
      <entry>Waiting to access the shared per-process data structures
       (typically, to get a snapshot or report a session's transaction
       ID).</entry>
     </row>
     <row>
      <entry><literal>RelationMapping</literal></entry>
      <entry>Waiting to read or update
       a <filename>pg_filenode.map</filename> file (used to track the
       filenode assignments of certain system catalogs).</entry>
     </row>
     <row>
      <entry><literal>RelCacheInit</literal></entry>
      <entry>Waiting to read or update a <filename>pg_internal.init</filename>
       relation cache initialization file.</entry>
     </row>
     <row>
      <entry><literal>ReplicationOrigin</literal></entry>
      <entry>Waiting to create, drop or use a replication origin.</entry>
     </row>
     <row>
      <entry><literal>ReplicationOriginState</literal></entry>
      <entry>Waiting to read or update the progress of one replication
       origin.</entry>
     </row>
     <row>
      <entry><literal>ReplicationSlotAllocation</literal></entry>
      <entry>Waiting to allocate or free a replication slot.</entry>
     </row>
     <row>
      <entry><literal>ReplicationSlotControl</literal></entry>
      <entry>Waiting to read or update replication slot state.</entry>
     </row>
     <row>
      <entry><literal>ReplicationSlotIO</literal></entry>
      <entry>Waiting for I/O on a replication slot.</entry>
     </row>
     <row>
      <entry><literal>SerialBuffer</literal></entry>
      <entry>Waiting for I/O on a serializable transaction conflict SLRU
       buffer.</entry>
     </row>
     <row>
      <entry><literal>SerializableFinishedList</literal></entry>
      <entry>Waiting to access the list of finished serializable
       transactions.</entry>
     </row>
     <row>
      <entry><literal>SerializablePredicateList</literal></entry>
      <entry>Waiting to access the list of predicate locks held by
       serializable transactions.</entry>
     </row>
     <row>
      <entry><literal>SerializableXactHash</literal></entry>
      <entry>Waiting to read or update information about serializable
       transactions.</entry>
     </row>
     <row>
      <entry><literal>SerialSLRU</literal></entry>
      <entry>Waiting to access the serializable transaction conflict SLRU
       cache.</entry>
     </row>
     <row>
      <entry><literal>SharedTidBitmap</literal></entry>
      <entry>Waiting to access a shared TID bitmap during a parallel bitmap
       index scan.</entry>
     </row>
     <row>
      <entry><literal>SharedTupleStore</literal></entry>
      <entry>Waiting to access a shared tuple store during parallel
       query.</entry>
     </row>
     <row>
      <entry><literal>ShmemIndex</literal></entry>
      <entry>Waiting to find or allocate space in shared memory.</entry>
     </row>
     <row>
      <entry><literal>SInvalRead</literal></entry>
      <entry>Waiting to retrieve messages from the shared catalog invalidation
       queue.</entry>
     </row>
     <row>
      <entry><literal>SInvalWrite</literal></entry>
      <entry>Waiting to add a message to the shared catalog invalidation
      queue.</entry>
     </row>
     <row>
      <entry><literal>SubtransBuffer</literal></entry>
      <entry>Waiting for I/O on a sub-transaction SLRU buffer.</entry>
     </row>
     <row>
      <entry><literal>SubtransSLRU</literal></entry>
      <entry>Waiting to access the sub-transaction SLRU cache.</entry>
     </row>
     <row>
      <entry><literal>SyncRep</literal></entry>
      <entry>Waiting to read or update information about the state of
       synchronous replication.</entry>
     </row>
     <row>
      <entry><literal>SyncScan</literal></entry>
      <entry>Waiting to select the starting location of a synchronized table
       scan.</entry>
     </row>
     <row>
      <entry><literal>TablespaceCreate</literal></entry>
      <entry>Waiting to create or drop a tablespace.</entry>
     </row>
     <row>
      <entry><literal>TwoPhaseState</literal></entry>
      <entry>Waiting to read or update the state of prepared transactions.</entry>
     </row>
     <row>
      <entry><literal>WALBufMapping</literal></entry>
      <entry>Waiting to replace a page in WAL buffers.</entry>
     </row>
     <row>
      <entry><literal>WALInsert</literal></entry>
      <entry>Waiting to insert WAL data into a memory buffer.</entry>
     </row>
     <row>
      <entry><literal>WALWrite</literal></entry>
      <entry>Waiting for WAL buffers to be written to disk.</entry>
     </row>
     <row>
      <entry><literal>XactBuffer</literal></entry>
      <entry>Waiting for I/O on a transaction status SLRU buffer.</entry>
     </row>
     <row>
      <entry><literal>XactSLRU</literal></entry>
      <entry>Waiting to access the transaction status SLRU cache.</entry>
     </row>
     <row>
      <entry><literal>XactTruncation</literal></entry>
      <entry>Waiting to execute <function>pg_xact_status</function> or update
       the oldest transaction ID available to it.</entry>
     </row>
     <row>
      <entry><literal>XidGen</literal></entry>
      <entry>Waiting to allocate a new transaction ID.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

   <note>
    <para>
     Extensions can add <literal>LWLock</literal> types to the list shown in
     <xref linkend="wait-event-lwlock-table"/>.  In some cases, the name
     assigned by an extension will not be available in all server processes;
     so an <literal>LWLock</literal> wait event might be reported as
     just <quote><literal>extension</literal></quote> rather than the
     extension-assigned name.
    </para>
   </note>

  <table id="wait-event-timeout-table">
   <title>Wait Events of Type <literal>Timeout</literal></title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry><literal>Timeout</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>BaseBackupThrottle</literal></entry>
      <entry>Waiting during base backup when throttling activity.</entry>
     </row>
     <row>
      <entry><literal>PgSleep</literal></entry>
      <entry>Waiting due to a call to <function>pg_sleep</function> or
       a sibling function.</entry>
     </row>
     <row>
      <entry><literal>RecoveryApplyDelay</literal></entry>
      <entry>Waiting to apply WAL during recovery because of a delay
       setting.</entry>
     </row>
     <row>
      <entry><literal>RecoveryRetrieveRetryInterval</literal></entry>
      <entry>Waiting during recovery when WAL data is not available from any
       source (<filename>pg_wal</filename>, archive or stream).</entry>
     </row>
     <row>
      <entry><literal>VacuumDelay</literal></entry>
      <entry>Waiting in a cost-based vacuum delay point.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

   <para>
     Here is an example of how wait events can be viewed:

<programlisting>
SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;
 pid  | wait_event_type | wait_event
------+-----------------+------------
 2540 | Lock            | relation
 6644 | LWLock          | ProcArray
(2 rows)
</programlisting>
   </para>

  <table id="pg-stat-replication-view" xreflabel="pg_stat_replication">
   <title>Vue <structname>pg_stat_replication</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>pid</structfield> <type>integer</type>
     </para>
     <para>
      Identifiant du processus d'envoi des WAL
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>usesysid</structfield> <type>oid</type>
     </para>
     <para>
      OID de l'utilisateur connecté à ce processus
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>usename</structfield> <type>name</type>
     </para>
     <para>
      Nom de l'utilisateur connecté à ce processus
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>application_name</structfield> <type>text</type>
     </para>
     <para>
      Nom de l'application qui est connectée à ce processus
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>client_addr</structfield> <type>inet</type>
     </para>
     <para>
      Adresse IP du client connecté à ce processus. Si ce champ est
      NULL, ceci signifie que le client est connecté via un socket Unix sur
      la machine serveur.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>client_hostname</structfield> <type>text</type>
     </para>
     <para>
      Nom de l'hôte du client connecté, comme renvoyé par une
      recherche DNS inverse sur <structfield>client_addr</structfield>. Ce
      champ sera uniquement non NULL pour les connexions IP, et seulement
      si <xref linkend="guc-log-hostname"/> est activé.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>client_port</structfield> <type>integer</type>
     </para>
     <para>
      Numéro du port TCP que le client utilise pour la
      communication avec ce processus, ou <literal>-1</literal> si un socket
      Unix est utilisée.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>backend_start</structfield> <type>timestamp with time zone</type>
     </para>
     <para>
      Heure à laquelle ce processus a été démarré, exemple,
      lorsque le client s'est connecté à ce processus expéditeur
      de WALs.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>backend_xmin</structfield> <type>xid</type>
     </para>
     <para>
      L'horizon <literal>xmin</literal> de ce serveur standby
      renvoyé par <xref linkend="guc-hot-standby-feedback"/>.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>state</structfield> <type>text</type>
     </para>
     <para>
      État courant du processus walsender.
       Les valeurs possibles sont&nbsp;:
       <itemizedlist>
         <listitem>
          <para>
           <literal>startup</literal>&nbsp;: Le processus walsender est en
           cours de démarrage.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>catchup</literal>&nbsp;: Le secondaire connecté au
           processus walsender est en cours de rattrapage du primaire.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>streaming</literal>&nbsp;: Ce processus walsender envoie
           les modifications au serveur secondaire connecté depuis que ce
           dernier a rattrapé le primaire.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>backup</literal>&nbsp;: Ce processus walsender est en
           train d'envoyer une sauvegarde.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>stopping</literal>&nbsp;: Ce processus walsender est en
           cours d'arrêt.
          </para>
         </listitem>
       </itemizedlist>
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>sent_lsn</structfield> <type>pg_lsn</type>
     </para>
     <para>
      La position de la dernière transaction envoyée sur cette
      connexion
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>write_lsn</structfield> <type>pg_lsn</type>
     </para>
     <para>
      La position de la dernière transaction écrite sur disque
      par ce serveur standby
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>flush_lsn</structfield> <type>pg_lsn</type>
     </para>
     <para>
      La position de la dernière transaction vidée sur disque
      par ce serveur standby
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>replay_lsn</structfield> <type>pg_lsn</type>
     </para>
     <para>
      La position de la dernière transaction rejouée dans la
      base de données par ce serveur standby
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>write_lag</structfield> <type>interval</type>
     </para>
     <para>
      Durée passée entre le vidage local des WAL récents et la réception
      de notification que ce serveur secondaire les a bien écrites (mais pas
      encore vidées ou appliquées). Ceci peut être utilisé pour mesurer le
      délai que le niveau <literal>remote_write</literal> de
      <literal>synchronous_commit</literal> coûterait lors de la validation si
      ce serveur était configuré comme un serveur secondaire
      synchrone.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>flush_lag</structfield> <type>interval</type>
     </para>
     <para>
      Durée passée entre le vidage local des WAL récents et la réception
      de notification que ce serveur secondaire les a bien écrites et vidées
      sur disque (mais pas encore appliquées). Ceci peut être utilisé pour
      mesurer le délai que le niveau <literal>on</literal> de
      <literal>synchronous_commit</literal> coûterait lors de la validation si
      ce serveur était configuré comme un serveur secondaire
      synchrone.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>replay_lag</structfield> <type>interval</type>
     </para>
     <para>
      Durée passée entre le vidage local des WAL récents et la réception
      de notification que ce serveur secondaire les a bien écrites, vidées
      sur disque et appliquées. Ceci peut être utilisé pour
      mesurer le délai que le niveau <literal>remote_apply</literal> de
      <literal>synchronous_commit</literal> coûterait lors de la validation si
      ce serveur était configuré comme un serveur secondaire
      synchrone.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>sync_priority</structfield> <type>integer</type>
     </para>
     <para>
      Priorité de ce serveur standby pour être choisi comme le serveur
      <literal>standby</literal> synchrone dans une réplication synchrone basée
      sur la priorité. Ceci n'a pas d'effet sur une réplication synchrone basée
      sur un quorum.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>sync_state</structfield> <type>text</type>
     </para>
     <para>
      État synchrone de ce serveur standby.
      Les valeurs possibles sont&nbsp;:
      <itemizedlist>
       <listitem>
        <para>
         <literal>async</literal>&nbsp;: Ce serveur standby est asynchrone.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>potential</literal>&nbsp;: Ce serveur standby est maintenant
         asynchrone, mais peut potentiellement devenir synchrone si un des
         synchrones échoue.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>sync</literal>&nbsp;: Ce serveur standby est synchrone.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>quorum</literal>&nbsp;: Ce serveur standby est considéré
         comme un candidat dans les standbys avec quorum.
        </para>
       </listitem>
      </itemizedlist>
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>reply_time</structfield> <type>timestamp with time zone</type>
     </para>
     <para>
      Horodatage d'envoi du dernier message de réponse reçu par le
      standby
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>spill_txns</structfield> <type>bigint</type>
     </para>
     <para>
      Number of transactions spilled to disk after the memory used by
      logical decoding exceeds <literal>logical_decoding_work_mem</literal>. The
      counter gets incremented both for toplevel transactions and
      subtransactions.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>spill_count</structfield> <type>bigint</type>
     </para>
     <para>
      Number of times transactions were spilled to disk. Transactions
      may get spilled repeatedly, and this counter gets incremented on every
      such invocation.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>spill_bytes</structfield> <type>bigint</type>
     </para>
     <para>
      Amount of decoded transaction data spilled to disk.
     </para></entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_replication</structname> contiendra une
   ligne par processus d'envoi de WAL, montrant des statistiques sur
   la réplication avec le serveur standby connecté au processus. Seuls
   les serveurs standby directement connectés sont listés&nbsp;; aucune
   information n'est disponible concernant les serveurs standby en aval.
  </para>

  <para>
   Les délais rapportés dans la vue
   <structname>pg_stat_replication</structname> sont des mesures de temps
   prises pour l'écriture, le vidage sur disque et le rejeu des données
   récentes des WAL et pour que le serveur d'envoi soit mis au courant. Ces
   durées représentent le délai de validation qui a été (ou aurait été)
   introduit par chaque niveau de validation synchrone si le serveur distant
   était configuré comme un standby synchrone. Pour un standby asynchrone, la
   colonne <structfield>replay_lag</structfield> renvoie une approximation du
   délai avant que les transactions récentes deviennent visibles aux requêtes.
   Si le serveur standby a complètement rattrapé le serveur d'envoi et qu'il
   n'y a plus d'activité en écriture (donc plus de nouveaux enregistrements
   dans les journaux de transactions), les délais mesurés le plus récemment
   continueront à être affichés pendant un court instant, puis seront mis à
   NULL.
  </para>

  <para>
   Les délais fonctionnent automatiquement pour la réplication physique. Les
   plugins de décodage logique pourraient émettre des messages de trace. S'ils
   ne le font pas, le mécanisme de trace affichera simplement une valeur NULL.
  </para>

  <note>
   <para>
    Les délais rapportés ne sont pas des prédictions du temps pris par le
    serveur standby pour rattraper le serveur d'envoi en constatant le taux
    actuel de rejeu. Un tel système afficherait des temps similaires alors que
    de nouveaux journaux de transactions seraient générés, mais différeraient
    lorsque le serveur deviendrait inactif. En particulier, quand le serveur
    standby a complètement rattrapé le serveur d'envoi,
    <structname>pg_stat_replication</structname> affiche le temps pris pour
    écrire, vider sur disque et rejouer l'emplacement de l'enregistrement le
    plus récemment rapporté plutôt que zéro comme certains utilisateurs
    pourraient s'y attendre. Ceci est cohérent avec le but de mesurer les
    délais de la validation synchrone et de la visibilité des transactions
    pour les transactions récentes en écriture. Pour réduire la confusion pour
    les utilisateurs s'attendant à un autre modèle de retard, les colonnes de
    retard sont réinitialisées à NULL après un court moment sur un système
    entièrement à jour et complètement inactif. Les systèmes de supervision
    devraient choisir s'ils souhaitent représenter ces colonnes comme des
    données manquantes, des données à zéro, ou continuer à afficher la
    dernière valeur connue.
   </para>
  </note>

  <table id="pg-stat-wal-receiver-view" xreflabel="pg_stat_wal_receiver">
   <title>Vue <structname>pg_stat_wal_receiver</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>pid</structfield> <type>integer</type>
     </para>
     <para>
      Identifiant du processus de réception des enregistrements de
      transaction
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>status</structfield> <type>text</type>
     </para>
     <para>
      Statut d'activité du processus walreceiver
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>receive_start_lsn</structfield> <type>pg_lsn</type>
     </para>
     <para>
      Première position dans le journal de transaction utilisée
      quand walreceiver a été démarré
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>receive_start_tli</structfield> <type>integer</type>
     </para>
     <para>
      Première ligne de temps utilisée quand walreceiver a été démarré
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>written_lsn</structfield> <type>pg_lsn</type>
     </para>
     <para>
      Last write-ahead log location already received and written to disk,
      but not flushed. This should not be used for data integrity checks.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>flushed_lsn</structfield> <type>pg_lsn</type>
     </para>
     <para>
      Last write-ahead log location already received and flushed to
      disk, the initial value of this field being the first log location used
      when WAL receiver is started
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>received_tli</structfield> <type>integer</type>
     </para>
     <para>
      Numéro de la ligne de temps de la dernière position des journaux
      de transactions, déjà reçue et écrite sur disque, la valeur initiale de
      ce champ étant la ligne de temps de la première position dans les
      journaux de transactions utilisée lors du démarrage du
      walreceiver
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>last_msg_send_time</structfield> <type>timestamp with time zone</type>
     </para>
     <para>
      Horodatage d'envoi du dernier message reçu à partir du walsender
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>last_msg_receipt_time</structfield> <type>timestamp with time zone</type>
     </para>
     <para>
      Horodatage de la réception du dernier message à partir du walsender
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>latest_end_lsn</structfield> <type>pg_lsn</type>
     </para>
     <para>
      Dernière position de transaction reportée par le walsender associé
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>latest_end_time</structfield> <type>timestamp with time zone</type>
     </para>
     <para>
      Horodatage de la dernière position de transaction reportée par le
      walsender associé
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>slot_name</structfield> <type>text</type>
     </para>
     <para>
      Nom du slot de réplication utilisé par ce walreceiver
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>sender_host</structfield> <type>text</type>
     </para>
     <para>
      Hôte de l'instance <productname>PostgreSQL</productname> auquel ce processus
      <quote>wal receiver</quote> est connecté. Il peut s'agir d'un nom d'hôte,
      d'une adresse <literal>IP</literal> ou d'un chemin d'accès à un répertoire
      si la connexion se fait via un socket Unix (dans ce dernier cas, il est facile
      de le distinguer car il s'agira toujours d'un chemin absolu débutant
      par le caractère (<literal>/</literal>).)
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>sender_port</structfield> <type>integer</type>
     </para>
     <para>
      Numéro de port de l'instance <productname>PostgreSQL</productname> auquel
      wal receiver est connecté.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>conninfo</structfield> <type>text</type>
     </para>
     <para>
      Chaîne de connexion utilisée par ce wal receiver, les informations sensibles
      au niveau sécurité sont cachés.
     </para></entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_wal_receiver</structname> contiendra seulement
   une ligne, affichant les statistiques du walreceiver du serveur de
   connexion.
  </para>

  <table id="pg-stat-subscription" xreflabel="pg_stat_subscription">
   <title>Vue <structname>pg_stat_subscription</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>subid</structfield> <type>oid</type>
     </para>
     <para>
      OID de la souscription
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>subname</structfield> <type>name</type>
     </para>
     <para>
      Nom de la souscription
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>pid</structfield> <type>integer</type>
     </para>
     <para>
      Identifiant du processus worker de la souscription
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>relid</structfield> <type>oid</type>
     </para>
     <para>
      OID de la relation que le processus worker synchronise&nbsp;;
      NULL pour le processus worker apply principal
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>received_lsn</structfield> <type>pg_lsn</type>
     </para>
     <para>
      Dernier emplacement de journal de transactions reçu, la valeur
      initiale de ce champ étant 0
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>last_msg_send_time</structfield> <type>timestamp with time zone</type>
     </para>
     <para>
      Horodatage d'envoi du dernier message reçu à partir du walsender
      original
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>last_msg_receipt_time</structfield> <type>timestamp with time zone</type>
     </para>
     <para>
      Horodatage de réception du dernier message reçu du walsender
      original
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>latest_end_lsn</structfield> <type>pg_lsn</type>
     </para>
     <para>
      Dernier emplacement des journaux de transactions rapporté par le
      walsender original
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>latest_end_time</structfield> <type>timestamp with time zone</type>
     </para>
     <para>
      Horodatage du dernier emplacement de journal de transactions
      rapporté par le walsender original
     </para></entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_subscription</structname> contiendra une ligne
   par souscription du worker principal (avec le PID NULL si le processus
   worker n'est pas en cours d'exécution), et des lignes supplémentaires pour
   les workers gérant la copie initiale de données des tables souscrites.
  </para>

  <table id="pg-stat-ssl-view" xreflabel="pg_stat_ssl">
  <title>Vue <structname>pg_stat_ssl</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>pid</structfield> <type>integer</type>
     </para>
     <para>
      ID du processus backend ou du processus d'envoi de WAL
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>ssl</structfield> <type>boolean</type>
     </para>
     <para>
      True si SSL est utilisé dans cette connexion
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>version</structfield> <type>text</type>
     </para>
     <para>
      Version de SSL utilisée, ou NULL si SSL n'est pas utilisé
      pour cette connexion
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>cipher</structfield> <type>text</type>
     </para>
     <para>
      Nom du chiffrement SSL utilisé, ou NULL si SSL n'est pas
      utilisé pour cette connexion
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>bits</structfield> <type>integer</type>
     </para>
     <para>
      Nombre de bits dans l'algorithme de chiffrement utilisé,
      ou NULL si SSL n'est pas utilisé pour cette connexion
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>compression</structfield> <type>boolean</type>
     </para>
     <para>
      True si la compression SSL est utilisée, false sinon, ou
      NULL si SSL n'est pas utilisé pour cette connexion
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>client_dn</structfield> <type>text</type>
     </para>
     <para>
      Champ Distinguished Name (DN) utilisé par le certificat du
      client, ou NULL si aucun certificat client n'a été fourni ou si
      SSL n'est pas utilisé pour cette connexion. Ce champ est tronqué
      si le champ DN est plus long que <symbol>NAMEDATALEN</symbol>
      (64 caractères dans une compilation standard).
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>client_serial</structfield> <type>numeric</type>
     </para>
     <para>
      Numéro de série du certificat client ou NULL si aucun certificat
      n'a été fourni ou si le SSL n'est pas utilisé dans cette connexion. La
      combinaison du numéro de série du certification et de l'émetteur du
      certificat identifie de façon unique un certificat (sauf si l'émetteur
      réutilise par erreur les numéros de série).
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>issuer_dn</structfield> <type>text</type>
     </para>
     <para>
      DN de l'émetteur du certificat client ou NULL si aucun certificat
      client n'a été fourni ou si le SSL n'est pas utilisé dans cette
      connexion. Ce champ est tronqué comme
      <structfield>client_dn</structfield>.
     </para></entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_ssl</structname> contiendra une
   ligne par backend ou processus d'envoi de WAL, montrant
   des statistiques sur l'usage de SSL dans cette connexion. Elle
   peut être jointe à <structname>pg_stat_activity</structname>
   ou <structname>pg_stat_replication</structname> sur la colonne
   <structfield>pid</structfield> pour obtenir plus de détails sur
   la connexion.
  </para>

  <table id="pg-stat-gssapi-view" xreflabel="pg_stat_gssapi">
   <title>Vue <structname>pg_stat_gssapi</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>pid</structfield> <type>integer</type>
     </para>
     <para>
      Identifiant du processus serveur
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>gss_authenticated</structfield> <type>boolean</type>
     </para>
     <para>
      True si l'authentification GSSAPI a été utilisée pour cette connexion
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>principal</structfield> <type>text</type>
     </para>
     <para>
      Principal utilisé pour authentifier cette connexion, ou NULL si
      GSSAPI n'a pas été utilisé pour authentifier cette connexion. Ce champ
      est tronqué si le principal est plus long que
      <symbol>NAMEDATALEN</symbol> (64 caractères dans une construction
      standard).
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>encrypted</structfield> <type>boolean</type>
     </para>
     <para>
      True si le chiffrement GSSAPI est utilisé avec cette connexion
     </para></entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_gssapi</structname> contient une ligne par
   processus serveur, affichant des informations sur l'utilisation de GSSAPI
   pour cette connexion. Elle peut être jointe à
   <structname>pg_stat_activity</structname> ou
   <structname>pg_stat_replication</structname> sur la colonne
   <structfield>pid</structfield> pour obtenir plus de détails sur la
   connexion.
  </para>

  <table id="pg-stat-archiver-view" xreflabel="pg_stat_archiver">
   <title>Vue <structname>pg_stat_archiver</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>archived_count</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de journaux de transactions archivés avec succès
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_archived_wal</structfield> <type>text</type>
      </para>
      <para>
       Nom du dernier journal de transaction archivé avec succès
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_archived_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Horodatage de la dernière opération d'archivage réussie
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>failed_count</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre d'échecs d'archivage de journaux de transactions
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_failed_wal</structfield> <type>text</type>
      </para>
      <para>
       Nom du journal de transactions correspondant au dernier archivage
       échoué
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_failed_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Horodatage de la dernière opération d'archivage échouée
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Horodatage de la dernière réinitialisation de ces statistiques
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_archiver</structname> aura toujours une seule ligne
   contenant les données du processus d'archivage de l'instance.
  </para>

  <table id="pg-stat-bgwriter-view" xreflabel="pg_stat_bgwriter">
   <title>Vue <structname>pg_stat_bgwriter</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoints_timed</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de checkpoints planifiés ayant été effectués
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoints_req</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de checkpoints demandés ayant été effectués
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoint_write_time</structfield> <type>double precision</type>
      </para>
      <para>
        Temps total passé dans la partie des checkpoints
        où les fichiers sont écrits sur disque, en millisecondes.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoint_sync_time</structfield> <type>double precision</type>
      </para>
      <para>
        Temps total passé dans la partie des checkpoints
        où les fichiers sont synchronisés sur le disque, en millisecondes.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_checkpoint</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de tampons écrits durant des checkpoints
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_clean</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de tampons écrits par le processus background writer
       (processus d'écriture en tâche de fond)
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>maxwritten_clean</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de fois que le processus background writer a arrêté
       son parcours de nettoyage pour avoir écrit trop de tampons
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_backend</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de tampons écrits directement par un processus serveur
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_backend_fsync</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de fois qu'un processus serveur a du exécuter son propre appel à
       <function>fsync</function> (normalement le processus background writer
       gère ces appels même quand le processus serveur effectue sa propre
       écriture)
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_alloc</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de tampons alloués
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Dernière fois que ces statistiques ont été réinitialisées
      </para></entry>
     </row>
    </tbody>
    </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_bgwriter</structname> aura toujours une ligne unique,
   contenant les données globales de l'instance.
  </para>

  <table id="pg-stat-database-view" xreflabel="pg_stat_database">
   <title>Vue <structname>pg_stat_database</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>datid</structfield> <type>oid</type>
     </para>
     <para>
      OID d'une base de données, or 0 for objects belonging to a shared
      relation
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>datname</structfield> <type>name</type>
     </para>
     <para>
      Nom de cette base de données, or <literal>NULL</literal> pour les objets
      partagés
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>numbackends</structfield> <type>integer</type>
     </para>
     <para>
      Nombre de processus serveur actuellement connectés à cette base de
      données, or <literal>NULL</literal> for the shared objects. C'est la
      seule colonne de cette vue qui renvoie une valeur reflétant l'état
      actuel&nbsp;; toutes les autres colonnes renvoient les valeurs
      accumulées depuis la dernière réinitialisation
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>xact_commit</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de transactions de cette base de données qui ont été
      validées
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>xact_rollback</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de transactions de cette base de données qui ont été
      annulées
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>blks_read</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de blocs disques lus dans cette base de données
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>blks_hit</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de fois que des blocs disques étaient déjà dans le cache tampon,
      et qu'il n'a donc pas été nécessaire de les lire sur disque (cela
      n'inclut que les accès dans le cache tampon de PostgreSQL, pas dans le
      cache de fichiers du système d'exploitation).
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>tup_returned</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de lignes retournées par des requêtes dans cette base de données
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>tup_fetched</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de lignes rapportées par des requêtes dans cette base de données
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>tup_inserted</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de lignes insérées par des requêtes dans cette base de données
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>tup_updated</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de lignes mises à jour par des requêtes dans cette base de données
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>tup_deleted</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de lignes supprimées par des requêtes dans cette base de données
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>conflicts</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de requêtes annulées à cause de conflits avec la restauration dans cette
      base de données. (Les conflits n'arrivent que sur des serveurs de standby&nbsp;; voir
      <xref linkend="pg-stat-database-conflicts-view"/> pour plus de détails.)
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>temp_files</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de fichiers temporaires créés par des requêtes dans cette base
      de données. Tous les fichiers temporaires sont comptabilisés, quel que soit
      la raison de la création du fichier temporaire (par exemple, un tri ou un hachage) et
      quel que soit la valeur du paramètre <xref linkend="guc-log-temp-files"/>.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>temp_bytes</structfield> <type>bigint</type>
     </para>
     <para>
      Quantité totale de données écrites dans des fichiers temporaires
      par des requêtes dans cette base de données. Tous les fichiers
      temporaires sont comptabilisés, quel que soit la raison de la création
      de ce fichier temporaire, et de la valeur du paramètre
      <xref linkend="guc-log-temp-files"/>.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>deadlocks</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de verrous mortels détectés dans cette base de données
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>checksum_failures</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre d'échecs pour la vérification des sommes de contrôle détectés sur
      cette base de données (ou sur un objet partagé), ou NULL si les sommes de
      contrôle ne sont pas activées.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>checksum_last_failure</structfield> <type>timestamp with time zone</type>
     </para>
     <para>
      Horodatage du dernier échec de vérification de somme de contrôle
      pour un bloc détecté dans cette base (ou sur un objet partagé), ou NULL
      si les sommes de contrôle ne sont pas activés.
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>blk_read_time</structfield> <type>double precision</type>
     </para>
     <para>
      Temps passé à lire des blocs de donnée dans des fichiers par des
      processus serveur dans cette base de données, en millisecondes
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>blk_write_time</structfield> <type>double precision</type>
     </para>
     <para>
      Temps passé à écrire des blocs de données dans des fichiers par
      les processus serveur dans cette base de données, en millisecondes
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
     </para>
     <para>
      Dernière fois que ces statistiques ont été réinitialisées
     </para></entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_database</structname> ne contiendra qu'une ligne
   pour chaque base de données dans l'instance, plus une pour les objets
   partagés, montrant ses statistiques globales.
  </para>

  <table id="pg-stat-database-conflicts-view" xreflabel="pg_stat_database_conflicts">
  <title>Vue <structname>pg_stat_database_conflicts</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>datid</structfield> <type>oid</type>
     </para>
     <para>
      OID de la base de données
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>datname</structfield> <type>name</type>
     </para>
     <para>
      Nom de cette base de données
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>confl_tablespace</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de requêtes dans cette base de données qui ont
      été annulées suite à la suppression de tablespaces
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>confl_lock</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de requêtes dans cette base de données qui
      ont été annulées suite à des délais dépassés sur des
      verrouillages
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>confl_snapshot</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de requêtes dans cette base de données qui ont
      été annulées à cause d'instantanés trop vieux
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>confl_bufferpin</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de requêtes dans cette base de données qui ont
      été annulées à cause de tampons verrouillés
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>confl_deadlock</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de requêtes dans cette base de données qui ont
      été annulées à cause de <literal>deadlocks</literal>
     </para></entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_database_conflicts</structname> contiendra
   une ligne par base de données, montrant des statistiques au niveau
   de chaque base de données concernant les requêtes annulées survenant à
   cause de conflits avec la restauration sur des serveurs standby. Cette
   vue contiendra seulement des informations sur les serveurs standby,
   dans la mesure où aucun conflit ne survient sur les serveurs
   primaires.
  </para>

  <table id="pg-stat-all-tables-view" xreflabel="pg_stat_all_tables">
   <title>Vue <structname>pg_stat_all_tables</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>relid</structfield> <type>oid</type>
     </para>
     <para>
      OID d'une table
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>schemaname</structfield> <type>name</type>
     </para>
     <para>
      Nom du schéma dans lequel se trouve cette table
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>relname</structfield> <type>name</type>
     </para>
     <para>
      Nom de cette table
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>seq_scan</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de parcours séquentiels initiés sur cette table
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>seq_tup_read</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de lignes vivantes rapportées par des parcours séquentiels
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>idx_scan</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de parcours d'index initiés sur cette table
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>idx_tup_fetch</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de lignes vivantes rapportées par des parcours d'index
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>n_tup_ins</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de lignes insérées
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>n_tup_upd</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de lignes mises à jour (y compris les lignes mises à jour
      par HOT)
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>n_tup_del</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de lignes supprimées
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>n_tup_hot_upd</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de lignes mises à jour par HOT (c’est-à-dire sans mises à
      jour d'index nécessaire)
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>n_live_tup</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre estimé de lignes vivantes
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>n_dead_tup</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre estimé de lignes mortes
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>n_mod_since_analyze</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre estimé de lignes modifiées depuis le dernier ANALYZE sur
      cette table
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>n_ins_since_vacuum</structfield> <type>bigint</type>
     </para>
     <para>
      Estimated number of rows inserted since this table was last vacuumed
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>last_vacuum</structfield> <type>timestamp with time zone</type>
     </para>
     <para>
      Dernière fois qu'une opération VACUUM manuelle
      a été faite sur cette table (sans compter&nbsp;
      <command>VACUUM FULL</command>)
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>last_autovacuum</structfield> <type>timestamp with time zone</type>
     </para>
     <para>
      Dernière fois que le démon autovacuum a exécuté une
      opération VACUUM sur cette table
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>last_analyze</structfield> <type>timestamp with time zone</type>
     </para>
     <para>
      Dernière fois qu'une opération ANALYZE a été lancée
      manuellement sur cette table
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>last_autoanalyze</structfield> <type>timestamp with time zone</type>
     </para>
     <para>
      Dernière fois que le démon autovacuum a exécuté une
      opération ANALYZE sur cette table
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>vacuum_count</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de fois qu'une opération VACUUM manuelle a été
      lancée sur cette table (sans compter
      <command>VACUUM FULL</command>)
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>autovacuum_count</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de fois que le démon autovacuum a exécuté
      une opération VACUUM manuelle
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>analyze_count</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de fois qu'une opération ANALYZE manuelle
      a été lancée sur cette table
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>autoanalyze_count</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de fois que le démon autovacuum a exécuté une
      opération ANALYZE sur cette table
     </para></entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_all_tables</structname> contiendra une ligne
   par table dans la base de données courante (incluant les tables TOAST),
   montrant les statistiques d'accès pour cette table spécifiquement. Les vues
   <structname>pg_stat_user_tables</structname> et
   <structname>pg_stat_sys_tables</structname> contiennent les mêmes informations,
   mais filtrent respectivement les tables utilisateurs et les tables systèmes.
  </para>

  <table id="pg-stat-all-indexes-view" xreflabel="pg_stat_all_indexes">
   <title>Vue <structname>pg_stat_all_indexes</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>relid</structfield> <type>oid</type>
     </para>
     <para>
      OID de la table pour cet index
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>indexrelid</structfield> <type>oid</type>
     </para>
     <para>
      OID de cet index
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>schemaname</structfield> <type>name</type>
     </para>
     <para>
      Nom du schéma dans lequel se trouve cet index
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>relname</structfield> <type>name</type>
     </para>
     <para>
      Nom de la table pour cet index
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>indexrelname</structfield> <type>name</type>
     </para>
     <para>
      Nom de cet index
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>idx_scan</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de parcours d'index initiés par cet index
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>idx_tup_read</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre d'entrées d'index retournées par des parcours sur cet index
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>idx_tup_fetch</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de lignes vivantes de la table rapportées par des simples parcours
      d'index utilisant cet index
     </para></entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_all_indexes</structname> contiendra une
   ligne pour chaque index dans la base de données courante, montrant les
   statistiques d'accès sur cet index spécifiquement. Les vues
   <structname>pg_stat_user_indexes</structname> et
   <structname>pg_stat_sys_indexes</structname> contiennent la même
   information, mais sont filtrées pour ne montrer respectivement que
   les index utilisateurs et les index système.
  </para>

  <para>
   Les index peuvent être utilisés avec un simple parcours d'index,
   un parcours d'index  <quote>bitmap</quote> ou l'optimiseur. Dans un parcours de
   bitmap, les sorties de plusieurs index peuvent être combinées avec
   des règles AND ou OR, c'est pourquoi il est difficile d'associer des
   lectures de lignes individuelles de la table avec des index spécifiques
   quand un parcours de bitmap est utilisé. Par conséquent, un parcours de bitmap
   incrémente le(s) valeur(s) de <structname>pg_stat_all_indexes</structname>.
   <structfield>idx_tup_read</structfield> pour le(s) index qu'il utilise, et
   incrémente la valeur de <structname>pg_stat_all_tables</structname>.<structfield>
   idx_tup_fetch</structfield> pour la table, mais il n'affecte pas
   <structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_fetch</structfield>.
   L'optimiseur accède également aux index pour vérifier si des
   constantes fournies sont en dehors des plages de valeurs enregistrées
   par les statistiques de l'optimiseur car celles-ci peuvent ne pas
   être à jour.
  </para>

  <note>
   <para>
    Les valeurs de <structfield>idx_tup_read</structfield> et <structfield>idx_tup_fetch
    </structfield> peuvent être différentes même sans aucune utilisation de parcours
    de bitmap, car <structfield>idx_tup_read</structfield> comptabilise les entrées
    d'index récupérées de cet index alors que  <structfield>idx_tup_fetch</structfield>
    comptabilise le nombre de lignes vivantes rapportées de la table. Le second sera
    moindre si des lignes mortes ou pas encore validées sont rapportées en utilisant
    l'index, ou si des lectures de lignes de la table sont évitées grâce à un
    parcours d'index seul.
   </para>
  </note>

  <table id="pg-statio-all-tables-view" xreflabel="pg_statio_all_tables">
   <title>Vue <structname>pg_statio_all_tables</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>relid</structfield> <type>oid</type>
     </para>
     <para>
      OID d'une table
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>schemaname</structfield> <type>name</type>
     </para>
     <para>
      Nom du schéma dans lequel se trouve cette table
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>relname</structfield> <type>name</type>
     </para>
     <para>
      Nom de cette table
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>heap_blks_read</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de blocs disque lus hors cache pour cette table
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>heap_blks_hit</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de blocs disque lus dans le cache pour cette table
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>idx_blks_read</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de blocs disque lus hors cache pour tous les index de cette table
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>idx_blks_hit</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de tampons lus dans le cache pour tous les index de cette table
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>toast_blks_read</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de blocs disque lus sur la partie TOAST de cette table (si présente)
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>toast_blks_hit</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de tampons récupérés sur la partie TOAST de cette table (si présente)
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>tidx_blks_read</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de blocs disque lus sur les index de la partie TOAST de cette table (si présente)
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>tidx_blks_hit</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de tampons récupérés sur les index de la partie TOAST de cette table (si présente)
     </para></entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_statio_all_tables</structname> contiendra
   une ligne pour chaque table dans la base de données courante (en
   incluant les tables TOAST), montrant les statistiques d'entrées/sorties
   de chaque table spécifiquement. Les vues
   <structname>pg_statio_user_tables</structname> et
   <structname>pg_statio_sys_tables</structname> contiennent la même
   information, mais sont filtrées pour ne montrer respectivement que
   les tables utilisateurs et les tables système.
  </para>

  <table id="pg-statio-all-indexes-view" xreflabel="pg_statio_all_indexes">
   <title>Vue <structname>pg_statio_all_indexes</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>relid</structfield> <type>oid</type>
     </para>
     <para>
      OID de la table pour cet index
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>indexrelid</structfield> <type>oid</type>
     </para>
     <para>
      OID de cet index
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>schemaname</structfield> <type>name</type>
     </para>
     <para>
      Nom du schéma dans lequel se trouve cet index
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>relname</structfield> <type>name</type>
     </para>
     <para>
      Nom de la table pour cet index
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>indexrelname</structfield> <type>name</type>
     </para>
     <para>
      Nom de cet index
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>idx_blks_read</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de blocs disque lus pour cet index
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>idx_blks_hit</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de tampons récupérés sur cet index
     </para></entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_statio_all_indexes</structname> contiendra
   une ligne pour chaque index dans la base de données courante,
   montrant les statistiques d'entrées/sorties sur chaque index
   spécifiquement. Les vues
   <structname>pg_statio_user_indexes</structname> et
   <structname>pg_statio_sys_indexes</structname> contiennent la même
   information, mais sont filtrées pour ne montrer respectivement
   que les tables utilisateur et tables système.
  </para>

  <table id="pg-statio-all-sequences-view" xreflabel="pg_statio_all_sequences">
   <title>Vue <structname>pg_statio_all_sequences</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>relid</structfield> <type>oid</type>
     </para>
     <para>
      OID de cette séquence
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>schemaname</structfield> <type>name</type>
     </para>
     <para>
      Nom du schéma dans lequel se trouve cette séquence
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>relname</structfield> <type>name</type>
     </para>
     <para>
      Nom de cette séquence
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>blks_read</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de blocs disque lus pour cette séquence
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>blks_hit</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de tampons récupérés pour cette séquence
     </para></entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_statio_all_sequences</structname> contiendra
   une ligne pour chaque séquence dans la base de données courante,
   montrant les statistiques d'entrées/sorties pour chaque séquence spécifiquement.
  </para>

  <table id="pg-stat-user-functions-view" xreflabel="pg_stat_user_functions">
   <title>Vue <structname>pg_stat_user_functions</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>funcid</structfield> <type>oid</type>
     </para>
     <para>
      OID de cette fonction
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>schemaname</structfield> <type>name</type>
     </para>
     <para>
      Nom du schéma dans lequel se trouve cette fonction
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>funcname</structfield> <type>name</type>
     </para>
     <para>
      Nom de cette fonction
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>calls</structfield> <type>bigint</type>
     </para>
     <para>
      Nombre de fois que cette fonction a été appelée
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>total_time</structfield> <type>double precision</type>
     </para>
     <para>
      Temps total passé dans cette fonction ainsi que dans toutes
      les autres fonctions appelées par elle, en millisecondes
     </para></entry>
    </row>
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>self_time</structfield> <type>double precision</type>
     </para>
     <para>
      Temps total passé dans cette fonction seule, sans inclure
      les autres fonctions appelées par elle, en millisecondes
     </para></entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <indexterm>
   <primary>SLRU</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> accesses certain on-disk information
   via <firstterm>SLRU</firstterm> (simple least-recently-used) caches.
   The <structname>pg_stat_slru</structname> view will contain
   one row for each tracked SLRU cache, showing statistics about access
   to cached pages.
  </para>

  <table id="pg-stat-slru-view" xreflabel="pg_stat_slru">
   <title><structname>pg_stat_slru</structname> View</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>name</structfield> <type>text</type>
      </para>
      <para>
       name of the SLRU
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_zeroed</structfield> <type>bigint</type>
      </para>
      <para>
       Number of blocks zeroed during initializations
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times disk blocks were found already in the SLRU,
       so that a read was not necessary (this only includes hits in the
       SLRU, not the operating system's file system cache)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks read for this SLRU
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_written</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks written for this SLRU
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_exists</structfield> <type>bigint</type>
      </para>
      <para>
       Number of blocks checked for existence for this SLRU
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>flushes</structfield> <type>bigint</type>
      </para>
      <para>
       Number of flushes of dirty data for this SLRU
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>truncates</structfield> <type>bigint</type>
      </para>
      <para>
       Number of truncates for this SLRU
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which these statistics were last reset
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_user_functions</structname> contiendra une
   ligne pour chaque fonction suivie, montrant les statistiques d'exécution
   de cette fonction. Le paramètre <xref linkend="guc-track-functions"/>
   contrôle exactement quelles fonctions sont suivies.
  </para>

  <sect2 id="monitoring-stats-functions">
   <title>Fonctions statistiques</title>

   <para>
    Une autre façon de regarder les statistiques peut être mise en place
    en écrivant des requêtes utilisant les mêmes fonctions d'accès sous-
    jacentes utilisées par les vues standards montrées au-dessus.  Pour
    des détails comme les noms de fonction, veuillez consulter les définitions
    de ces vues standards. (Par exemple, dans <application>psql</application>
    vous pouvez utiliser <literal>\d+ pg_stat_activity</literal>.)
    Les fonctions d'accès pour les statistiques par base de données prennent
    comme argument un OID pour identifier sur quelle base de données travailler.
    Les fonctions par table et par index utilisent un OID de table ou d'index.
    Les fonctions pour les statistiques par fonctions utilisent un OID de fonction.
    Notez que seuls les tables, index et fonctions dans la base de données
    courante peuvent être vus avec ces fonctions.
   </para>

   <para>
   Les fonctions supplémentaires liées à la récupération de statistiques sont
   listées dans <xref linkend="monitoring-stats-funcs-table"/>.
   </para>

   <table id="monitoring-stats-funcs-table">
    <title>Fonctions supplémentaires de statistiques</title>

    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
        <!-- See also the entry for this in func.sgml -->
       <entry role="func_table_entry"><para role="func_signature">
        <function>pg_backend_pid</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Identifiant du processus serveur gérant la session courante.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_activity</primary>
        </indexterm>
        <function>pg_stat_get_activity</function> ( <type>integer</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para>
        Retourne un enregistrement d'informations sur le processus serveur
        du PID spécifié, ou un enregistrement pour chaque processus serveur
        actif dans le système si <symbol>NULL</symbol> est spécifié.
        Les champs retournés sont des sous-ensembles de ceux dans la vue
        <structname>pg_stat_activity</structname>.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_snapshot_timestamp</primary>
        </indexterm>
        <function>pg_stat_get_snapshot_timestamp</function> ()
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Renvoie l'horodatage de l'instantané courant des statistiques
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_clear_snapshot</primary>
        </indexterm>
        <function>pg_stat_clear_snapshot</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Supprime l'image statistique courante.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset</primary>
        </indexterm>
        <function>pg_stat_reset</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Resets all statistics counters for the current database to zero.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_shared</primary>
        </indexterm>
        <function>pg_stat_reset_shared</function> ( <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Resets some cluster-wide statistics counters to zero, depending on the
        argument.  The argument can be <literal>bgwriter</literal> to reset
        all the counters shown in
        the <structname>pg_stat_bgwriter</structname>
        view,or <literal>archiver</literal> to reset all the counters shown in
        the <structname>pg_stat_archiver</structname> view.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_single_table_counters</primary>
        </indexterm>
        <function>pg_stat_reset_single_table_counters</function> ( <type>oid</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Resets statistics for a single table or index in the current database
        to zero.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_single_function_counters</primary>
        </indexterm>
        <function>pg_stat_reset_single_function_counters</function> ( <type>oid</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Resets statistics for a single function in the current database to
        zero.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_slru</primary>
        </indexterm>
        <function>pg_stat_reset_slru</function> ( <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Resets statistics to zero for a single SLRU cache, or for all SLRUs in
        the cluster.  If the argument is NULL, all counters shown in
        the <structname>pg_stat_slru</structname> view for all SLRU caches are
        reset.  The argument can be one of
        <literal>CommitTs</literal>,
        <literal>MultiXactMember</literal>,
        <literal>MultiXactOffset</literal>,
        <literal>Notify</literal>,
        <literal>Serial</literal>,
        <literal>Subtrans</literal>, or
        <literal>Xact</literal>
        to reset the counters for only that entry.
        If the argument is <literal>other</literal> (or indeed, any
        unrecognized name), then the counters for all other SLRU caches, such
        as extension-defined caches, are reset.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    <function>pg_stat_get_activity</function>, la fonction sous-jacente de la
    vue <structname>pg_stat_activity</structname>, retourne un ensemble
    d'enregistrements contenant toute l'information disponible sur chaque
    processus serveur. Parfois il peut être plus pratique de n'obtenir qu'un
    sous-ensemble de cette information. Dans ces cas-là, un ensemble plus vieux
    de fonctions d'accès aux statistiques par processus serveur peut être
    utilisé&nbsp;; celle-ci sont montrées dans <xref
    linkend="monitoring-stats-backend-funcs-table"/>. Ces fonctions d'accès
    utilisent un numéro d'identifiant du processus serveur, qui va de un au
    nombre de processus serveur actuellement actifs. La fonction
    <function>pg_stat_get_backend_idset</function> fournit une manière pratique
    de générer une ligne pour chaque processus serveur actif pour appeler ces
    fonctions. Par exemple, pour montrer les <acronym>PID</acronym> et requêtes
    en cours de tous les processus serveur&nbsp;:

 <programlisting>
 SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
        pg_stat_get_backend_activity(s.backendid) AS query
     FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;
 </programlisting>
   </para>

   <table id="monitoring-stats-backend-funcs-table">
    <title>Fonctions statistiques par processus serveur</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_idset</primary>
        </indexterm>
        <function>pg_stat_get_backend_idset</function> ()
        <returnvalue>setof integer</returnvalue>
       </para>
       <para>
        Ensemble de numéros de processus serveur actuellement actifs (de 1
        jusqu'au nombre de processus serveur actifs)
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_activity</primary>
        </indexterm>
        <function>pg_stat_get_backend_activity</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Texte de la requête la plus récente de ce processus serveur
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_activity_start</primary>
        </indexterm>
        <function>pg_stat_get_backend_activity_start</function> ( <type>integer</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Heure à laquelle la requête la plus récente a été démarrée
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_client_addr</primary>
        </indexterm>
        <function>pg_stat_get_backend_client_addr</function> ( <type>integer</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Adresse IP du client connecté à ce processus serveur
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_client_port</primary>
        </indexterm>
        <function>pg_stat_get_backend_client_port</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Numéro de port TCP que le client utilise pour communiquer
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_dbid</primary>
        </indexterm>
        <function>pg_stat_get_backend_dbid</function> ( <type>integer</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        OID de la base de données auquel ce processus serveur est connecté
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_pid</primary>
        </indexterm>
        <function>pg_stat_get_backend_pid</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Identifiant du processus serveur
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_start</primary>
        </indexterm>
        <function>pg_stat_get_backend_start</function> ( <type>integer</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Heure à laquelle ce processus a été démarré
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_userid</primary>
        </indexterm>
        <function>pg_stat_get_backend_userid</function> ( <type>integer</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        OID de l'utilisateur connecté à ce processus serveur
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_wait_event_type</primary>
        </indexterm>
        <function>pg_stat_get_backend_wait_event_type</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Nom du type d'événement d'attente si le processus est actuellement
        en attente, NULL sinon. Voir <xref linkend="wait-event-table"/> pour les
        détails.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_wait_event</primary>
        </indexterm>
        <function>pg_stat_get_backend_wait_event</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Nom de l'événement d'attente si le processus est actuellement en
        attente, NULL sinon. Voir <xref linkend="wait-event-table"/> pour les
        détails.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_xact_start</primary>
        </indexterm>
        <function>pg_stat_get_backend_xact_start</function> ( <type>integer</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Heure à laquelle la transaction courante a été démarrée
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>
 </sect1>

 <sect1 id="monitoring-locks">
  <title>Visualiser les verrous</title>

  <indexterm zone="monitoring-locks">
   <primary>verrou</primary>
   <secondary>surveillance</secondary>
  </indexterm>

  <para>
   Un autre outil utile pour surveiller l'activité des bases de données est la
   table système <structname>pg_locks</structname>. Elle permet à
   l'administrateur système de visualiser des informations sur les verrous
   restant dans le gestionnaire des verrous. Par exemple, cette fonctionnalité
   peut être utilisée pour&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Visualiser tous les verrous en cours, tous les verrous sur les relations
      d'une base de données particulière ou tous les verrous détenus par une
      session <productname>PostgreSQL</productname> particulière.
     </para>
    </listitem>

    <listitem>
     <para>
      Déterminer la relation de la base de données disposant de la plupart des
      verrous non autorisés (et qui, du coup, pourraient être une source de
      contention parmi les clients de la base de données).
     </para>
    </listitem>

    <listitem>
     <para>
      Déterminer l'effet de la contention des verrous sur les performances
      générales des bases de données, ainsi que l'échelle dans laquelle varie la
      contention sur le trafic de la base de données.
     </para>
    </listitem>
   </itemizedlist>

   Les détails sur la vue <structname>pg_locks</structname> apparaissent dans la
   <xref linkend="view-pg-locks"/>. Pour plus d'informations sur les verrous et
   la gestion des concurrences avec <productname>PostgreSQL</productname>,
   référez-vous au <xref linkend="mvcc"/>.
  </para>
 </sect1>

 <sect1 id="progress-reporting">
  <title>Rapporter la progression</title>

  <para>
   <productname>PostgreSQL</productname> a la possibilité de rapporter la
   progression de certaines commandes lors de leur exécution. Actuellement,
   les seules commandes supportant un rapport de progression sont
   <command>ANALYZE</command>, <command>CLUSTER</command>, <command>CREATE
   INDEX</command>, <command>VACUUM</command>, and <xref
   linkend="protocol-replication-base-backup"/> (i.e., replication command
   that <xref linkend="app-pgbasebackup"/> issues to take a base backup). Ceci
   pourrait être étendu dans le futur.
  </para>

  <sect2 id="analyze-progress-reporting">
   <title>ANALYZE Progress Reporting</title>
 
   <para>
    Whenever <command>ANALYZE</command> is running, the
    <structname>pg_stat_progress_analyze</structname> view will contain a
    row for each backend that is currently running that command.  The tables
    below describe the information that will be reported and provide
    information about how to interpret it.
   </para>

   <table id="pg-stat-progress-analyze-view" xreflabel="pg_stat_progress_analyze">
    <title><structname>pg_stat_progress_analyze</structname> View</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        Column Type
       </para>
       <para>
        Description
       </para></entry>
      </row>
     </thead>
 
     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>pid</structfield> <type>integer</type>
       </para>
       <para>
        Process ID of backend.
       </para></entry>
      </row>
 
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datid</structfield> <type>oid</type>
       </para>
       <para>
        OID of the database to which this backend is connected.
       </para></entry>
      </row>
 
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datname</structfield> <type>name</type>
       </para>
       <para>
        Name of the database to which this backend is connected.
       </para></entry>
      </row>
 
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relid</structfield> <type>oid</type>
       </para>
       <para>
        OID of the table being analyzed.
       </para></entry>
      </row>
 
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>phase</structfield> <type>text</type>
       </para>
       <para>
        Current processing phase. See <xref linkend="analyze-phases"/>.
       </para></entry>
      </row>
 
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>sample_blks_total</structfield> <type>bigint</type>
       </para>
       <para>
        Total number of heap blocks that will be sampled.
       </para></entry>
      </row>
 
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>sample_blks_scanned</structfield> <type>bigint</type>
       </para>
       <para>
        Number of heap blocks scanned.
       </para></entry>
      </row>
 
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ext_stats_total</structfield> <type>bigint</type>
       </para>
       <para>
        Number of extended statistics.
       </para></entry>
      </row>
 
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ext_stats_computed</structfield> <type>bigint</type>
       </para>
       <para>
        Number of extended statistics computed. This counter only advances
        when the phase is <literal>computing extended statistics</literal>.
       </para></entry>
      </row>
 
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>child_tables_total</structfield> <type>bigint</type>
       </para>
       <para>
        Number of child tables.
       </para></entry>
      </row>
 
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>child_tables_done</structfield> <type>bigint</type>
       </para>
       <para>
        Number of child tables scanned. This counter only advances when the
        phase is <literal>acquiring inherited sample rows</literal>.
       </para></entry>
      </row>
 
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>current_child_table_relid</structfield> <type>oid</type>
       </para>
       <para>
        OID of the child table currently being scanned. This field is
        only valid when the phase is
        <literal>acquiring inherited sample rows</literal>.
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
 
   <table id="analyze-phases">
    <title>ANALYZE phases</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="2*"/>
     <thead>
      <row>
       <entry>Phase</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>initializing</literal></entry>
       <entry>
        The command is preparing to begin scanning the heap.  This phase is
        expected to be very brief.
       </entry>
      </row>
      <row>
       <entry><literal>acquiring sample rows</literal></entry>
       <entry>
        The command is currently scanning the table given by
        <structfield>relid</structfield> to obtain sample rows.
       </entry>
      </row>
      <row>
       <entry><literal>acquiring inherited sample rows</literal></entry>
       <entry>
        The command is currently scanning child tables to obtain sample rows.
        Columns <structfield>child_tables_total</structfield>,
        <structfield>child_tables_done</structfield>, and
        <structfield>current_child_table_relid</structfield> contain the
        progress information for this phase.
       </entry>
      </row>
      <row>
       <entry><literal>computing statistics</literal></entry>
       <entry>
        The command is computing statistics from the sample rows obtained
        during the table scan.
       </entry>
      </row>
      <row>
       <entry><literal>computing extended statistics</literal></entry>
       <entry>
        The command is computing extended statistics from the sample rows
        obtained during the table scan.
       </entry>
      </row>
      <row>
       <entry><literal>finalizing analyze</literal></entry>
       <entry>
        The command is updating pg_class. When this phase is completed,
        <command>ANALYZE</command> will end.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
 
   <note>
    <para>
     Note that when <command>ANALYZE</command> is run on a partitioned table,
     all of its partitions are also recursively analyzed as also mentioned in
     <xref linkend="sql-analyze"/>.  In that case, <command>ANALYZE</command>
     progress is reported first for the parent table, whereby its inheritance
     statistics are collected, followed by that for each partition.
    </para>
   </note>
  </sect2>
 
  <sect2 id="create-index-progress-reporting">
   <title>Rapporter la progression du CREATE INDEX</title>

   <para>
    Quand un <command>CREATE INDEX</command> ou un <command>REINDEX</command>
    est en cours d'exécution, la vue
    <structname>pg_stat_progress_create_index</structname> contient une ligne
    pour chaque processus serveur en train de créer des index. Les tables
    ci-dessous décrivent les informations rapportées et fournissent des
    informations sur leur interprétation.
   </para>

   <table id="pg-stat-progress-create-index-view" xreflabel="pg_stat_progress_create_index">
    <title>Vue <structname>pg_stat_progress_create_index</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        Column Type
       </para>
       <para>
        Description
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>pid</structfield> <type>integer</type>
       </para>
       <para>
        Identifiant du processus serveur.
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datid</structfield> <type>oid</type>
       </para>
       <para>
        OID de la base de données de connexion du processus.
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datname</structfield> <type>name</type>
       </para>
       <para>
        Nom de la base de données de connexion du processus.
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relid</structfield> <type>oid</type>
       </para>
       <para>
        OID de la table liée à l'index en cours de création.
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>index_relid</structfield> <type>oid</type>
       </para>
       <para>
        OID de l'index en cours de création ou de réindexation. Lors d'un
        <command>CREATE INDEX</command> non concurrent, cette colonne vaut 0.
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>command</structfield> <type>text</type>
       </para>
       <para>
        La commande en cours d'exécution&nbsp;: <literal>CREATE INDEX</literal>,
        <literal>CREATE INDEX CONCURRENTLY</literal>,
        <literal>REINDEX</literal> ou <literal>REINDEX CONCURRENTLY</literal>.
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>phase</structfield> <type>text</type>
       </para>
       <para>
        Phase en cours de traitement pour la création de l'index. Voir <xref
        linkend='create-index-phases'/>.
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>lockers_total</structfield> <type>bigint</type>
       </para>
       <para>
         Nombre total de processus bloquant à attendre, si applicable.
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>lockers_done</structfield> <type>bigint</type>
       </para>
       <para>
         Nombre de processus bloquant déjà attendus.
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>current_locker_pid</structfield> <type>bigint</type>
       </para>
       <para>
         Identifiant du processus bloquant actuellement.
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>blocks_total</structfield> <type>bigint</type>
       </para>
       <para>
        Nombre total de blocs à traiter dans la phase en cours.
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>blocks_done</structfield> <type>bigint</type>
       </para>
       <para>
        Nombre de blocs déjà traités dans la phase en cours.
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tuples_total</structfield> <type>bigint</type>
       </para>
       <para>
         Nombre total de lignes à traiter dans la phase en cours.
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tuples_done</structfield> <type>bigint</type>
       </para>
       <para>
         Nombre de lignes déjà traitées dans la phase en cours.
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>partitions_total</structfield> <type>bigint</type>
       </para>
       <para>
        Lors de la création d'un index sur une table partitionnée, cette colonne
        est configurée au nombre total de partitions sur lesquels l'index est
        créé.
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>partitions_done</structfield> <type>bigint</type>
       </para>
       <para>
        Lors de la création d'un index sur une table partitionnée, cette colonne
        est configurée au nombre total de partitions sur lesquels l'index a déjà
        été créé.
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <table id="create-index-phases">
    <title>Phases du CREATE INDEX</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Phase</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>initializing</literal></entry>
       <entry>
        <command>CREATE INDEX</command> ou <command>REINDEX</command> prépare
        la création de l'index. Cette phase est normalement très brève.
       </entry>
      </row>
      <row>
       <entry><literal>waiting for writers before build</literal></entry>
       <entry>
        <command>CREATE INDEX CONCURRENTLY</command> ou <command>REINDEX
        CONCURRENTLY</command> attend que les transactions avec des verrous en
        écriture qui peuvent voir la table se finissent Cette phase est ignorée
        quand elle n'est pas en mode concurrent. Les colonnes
        <structname>lockers_total</structname>,
        <structname>lockers_done</structname> et
        <structname>current_locker_pid</structname> contiennent les
        informations de progression sur cette phase.
       </entry>
      </row>
      <row>
       <entry><literal>building index</literal></entry>
       <entry>
        L'index est en cours de construction par le code spécifique de la
        méthode d'accès. Dans cette phase, les méthodes d'accès qui supportent
        les rapports de progression remplissent eux-même les données de
        progression, et la sous-phase est indiquée dans cette colonne.
        Typiquement, <structname>blocks_total</structname> et
        <structname>blocks_done</structname> contiendront les données de
        progression, ainsi que <structname>tuples_total</structname> et
        <structname>tuples_done</structname> potentiellement.
       </entry>
      </row>
      <row>
       <entry><literal>waiting for writers before validation</literal></entry>
       <entry>
        <command>CREATE INDEX CONCURRENTLY</command> ou <command>REINDEX
        CONCURRENTLY</command> est en attente de la fin des transactions avec
        verrous en écriture pouvant potentiellement écrire dans la table. Cette
        phase est ignorée quand elle n'est pas en mode concurrent. Les colonnes
        <structname>lockers_total</structname>,
        <structname>lockers_done</structname> et
        <structname>current_locker_pid</structname> contiennent les
        informations de progression pour cette phase.
       </entry>
      </row>
      <row>
       <entry><literal>index validation: scanning index</literal></entry>
       <entry>
        <command>CREATE INDEX CONCURRENTLY</command> parcourt l'index pour
        trouver les lignes qui ont besoin d'être validées. Cette phase est
        ignorée quand elle n'est pas en mode concurrent. Les colonnes
        <structname>blocks_total</structname> (configurée à la taille totale de
        l'index) et <structname>blocks_done</structname> contiennent les
        informations de progression pour cette phase.
       </entry>
      </row>
      <row>
       <entry><literal>index validation: sorting tuples</literal></entry>
       <entry>
        <command>CREATE INDEX CONCURRENTLY</command> trie la sortie de la phase
        de parcours de l'index.
       </entry>
      </row>
      <row>
       <entry><literal>index validation: scanning table</literal></entry>
       <entry>
        <command>CREATE INDEX CONCURRENTLY</command> parcourt la table pour
        valider les enregistrements d'index collectés dans les deux phases
        précédentes. Cette phase est ignorée quand elle n'est pas en mode
        concurrent. Les colonnes <structname>blocks_total</structname>
        (configurée à la taille totale de la table) et
        <structname>blocks_done</structname> contiennent les informations de
        progression pour cette phase.
       </entry>
      </row>
      <row>
       <entry><literal>waiting for old snapshots</literal></entry>
       <entry>
        <command>CREATE INDEX CONCURRENTLY</command> ou <command>REINDEX
        CONCURRENTLY</command> est en attente que les transactions pouvant
        potentiellement voir la table relâchent leur snapshot. Cette phase est
        ignorée quand elle n'est pas en mode concurrent. Les colonnes
        <structname>lockers_total</structname>,
        <structname>lockers_done</structname> et
        <structname>current_locker_pid</structname> contiennent les
        informations de progression pour cette phase.
       </entry>
      </row>
      <row>
       <entry><literal>waiting for readers before marking dead</literal></entry>
       <entry>
        <command>REINDEX CONCURRENTLY</command> est en attente de la fin des
        transactions avec verrous en lecture sur la table, avant de marquer
        l'ancien index comme mort. Cette phase est ignorée quand elle n'est pas
        en mode concurrent. Les colonnes
        <structname>lockers_total</structname>,
        <structname>lockers_done</structname> et
        <structname>current_locker_pid</structname> contiennent les
        informations de progression pour cette phase.
       </entry>
      </row>
      <row>
       <entry><literal>waiting for readers before dropping</literal></entry>
       <entry>
        <command>REINDEX CONCURRENTLY</command> est en attente de la fin des
        transactions avec verrous en lecture sur la table, avant de supprimer
        l'ancien index. Cette phase est ignorée quand elle n'est pas en mode
        concurrent. Les colonnes <structname>lockers_total</structname>,
        <structname>lockers_done</structname> et
        <structname>current_locker_pid</structname> contiennent les
        informations de progression pour cette phase.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="vacuum-progress-reporting">
   <title>Rapporter la progression du VACUUM</title>

   <para>
    La vue <structname>pg_stat_progress_vacuum</structname> contient une ligne
    pour chaque processus serveur (incluant les processus autovacuum worker) en
    train d'exécuter un <command>VACUUM</command>. Les tableaux ci-dessous
    décrivent les informations rapportées et fournissent des informations sur
    leur interprétation. La progression des commandes <command>VACUUM FULL</command>
    est rapportée par <structname>pg_stat_progress_cluster</structname> parce
    que le <command>VACUUM FULL</command> comme le <command>CLUSTER</command>
    réécrivent la table, alors qu'un <command>VACUUM</command> simple la modifie
    directement. Voir <xref linkend='cluster-progress-reporting'/>.
   </para>

   <table id="pg-stat-progress-vacuum-view" xreflabel="pg_stat_progress_vacuum">
    <title>Vue <structname>pg_stat_progress_vacuum</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        Column Type
       </para>
       <para>
        Description
       </para></entry>
      </row>
     </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Identifiant (PID) du processus serveur.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID de la base de données où est connecté ce processus
       serveur.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Nom de la base de données où est connecté ce processus
       serveur.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID de la table nettoyée par le VACUUM.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       Phase actuelle du vacuum. Voir <xref linkend='vacuum-phases'/>.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_total</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre total de blocs de la table. Ce nombre est récupéré au début du
       parcours. Des blocs peuvent être ajoutés par la suie, mais ne seront
       pas (et n'ont pas besoin d'être) visités par ce
       <command>VACUUM</command>.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_scanned</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de blocs parcourus dans la table. Comme la <link
       linkend="storage-vm">carte de visibilité</link> est utilisée pour
       optimiser les parcours, certains blocs seront ignorés sans
       inspection&nbsp;; les blocs ignorés sont inclus dans ce total, pour que
       ce nombre puisse devenir égal à
       <structfield>heap_blks_total</structfield> quand le nettoyage se
       termine. Ce compteur avance seulement quand la phase est
       <literal>scanning heap</literal>.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_vacuumed</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de blocs nettoyés dans la table. Sauf si la table n'a pas
       d'index, ce compteur avance seulement quand la phase est
       <literal>vacuuming heap</literal>. Les blocs qui ne contiennent aucune
       ligne morte sont ignorés, donc le compteur pourrait parfois avancer par
       de larges incréments.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>index_vacuum_count</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de cycles de nettoyage d'index réalisés.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>max_dead_tuples</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de lignes mortes que nous pouvons stocker avant d'avoir besoin de
       réaliser un cycle de nettoyage d'index, basé sur <xref
       linkend="guc-maintenance-work-mem"/>.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>num_dead_tuples</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de lignes mortes récupérées depuis le dernier cycle de nettoyage
       d'index.
      </para></entry>
     </row>
    </tbody>
    </tgroup>
   </table>

   <table id="vacuum-phases">
    <title>Phases du VACUUM</title>
    <tgroup cols="2">
     <thead>
     <row>
       <entry>Phase</entry>
       <entry>Description</entry>
      </row>
     </thead>

    <tbody>
     <row>
      <entry><literal>initializing</literal></entry>
      <entry>
        <command>VACUUM</command> se prépare à commencer le parcours de la
        table. Cette phase est habituellement très rapide.
      </entry>
     </row>
     <row>
      <entry><literal>scanning heap</literal></entry>
      <entry>
        <command>VACUUM</command> parcourt la table. Il va défragmenter chaque
        bloc si nécessaire et potentiellement réaliser un gel des lignes. La
        colonne <structfield>heap_blks_scanned</structfield> peut être utilisée
        pour surveiller la progression du parcours.
      </entry>
     </row>
     <row>
      <entry><literal>vacuuming indexes</literal></entry>
      <entry>
        <command>VACUUM</command> est en train de nettoyer les index. Si une
        table a des index, ceci surviendra au moins une fois par vacuum, après
        le parcours complet de la table. Cela pourrait arriver plusieurs fois
        par vacuum si if <xref linkend="guc-maintenance-work-mem"/> n'est pas
        suffisamment important pour y enregistrer le nombre de lignes mortes
        trouvées.
      </entry>
     </row>
     <row>
      <entry><literal>vacuuming heap</literal></entry>
      <entry>
        <command>VACUUM</command> est en train de nettoyer la table. Nettoyer
        la table est différent du parcours de la table, et survient après
        chaque phase de nettoyage d'index. Si
        <structfield>heap_blks_scanned</structfield> est inférieur à
        <structfield>heap_blks_total</structfield>, le système retournera à
        parcourir la table après la fin de cette phase. Sinon, il commencera le
        nettoyage des index une fois cette phase terminée.
      </entry>
     </row>
     <row>
      <entry><literal>cleaning up indexes</literal></entry>
      <entry>
        <command>VACUUM</command> est en train de nettoyer les index. Ceci
        survient que la table ait été entièrement parcourue et que le vacuum
        des index et de la table soit terminé.
      </entry>
     </row>
     <row>
      <entry><literal>truncating heap</literal></entry>
      <entry>
        <command>VACUUM</command> est en cours de troncage de la table pour
        pouvoir redonner au système d'exploitation les pages vides en fin de
        relation. Ceci survient après le nettoyage des index.
      </entry>
     </row>
     <row>
      <entry><literal>performing final cleanup</literal></entry>
      <entry>
        <command>VACUUM</command> réalise le nettoyage final. Durant cette
        phase, <command>VACUUM</command> nettoiera la carte des espaces libres,
        mettra à jour les statistiques dans <literal>pg_class</literal>, et
        rapportera les statistiques au collecteur de statistiques. Une fois
        cette phase terminée,  <command>VACUUM</command> se terminera.
      </entry>
     </row>
    </tbody>
    </tgroup>
   </table>
  </sect2>

  <sect2 id="cluster-progress-reporting">
   <title>Rapporter la progression de CLUSTER</title>

   <para>
    Quand <command>CLUSTER</command> ou <command>VACUUM FULL</command> est en
    cours d'exécution, la vue <structname>pg_stat_progress_cluster</structname>
    contiendra une ligne pour chaque processus serveur en train d'exécuter une
    de ces deux commandes. Les tables ci-dessous décrivent les informations
    rapportées et fournissent des informations sur leur interprétation.
   </para>

   <table id="pg-stat-progress-cluster-view" xreflabel="pg_stat_progress_cluster">
    <title>Vue <structname>pg_stat_progress_cluster</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        Column Type
       </para>
       <para>
        Description
       </para></entry>
      </row>
     </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Identifiant du processus serveur.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID de la base de données de connexion du processus.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Nom de la base de données de connexion du processus.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID de la table en cours de traitement.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>command</structfield> <type>text</type>
      </para>
      <para>
       La commande exécutée. Soit <literal>CLUSTER</literal> soit
       <literal>VACUUM FULL</literal >.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
        Phase de traitement actuelle. Voir <xref linkend='cluster-phases' />.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>cluster_index_relid</structfield> <type>oid</type>
      </para>
      <para>
        Si la table est parcourue avec un index, OID de l'index utilisé. Sinon 0.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_tuples_scanned</structfield> <type>bigint</type>
      </para>
      <para>
        Nombre de lignes parcourues. Ce compteur s'incrémente seulement quand
        la phase est
        <literal>seq scanning heap</literal>,
        <literal>index scanning heap</literal>
        ou <literal>writing new heap</literal>.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_tuples_written</structfield> <type>bigint</type>
      </para>
      <para>
        Nombre de lignes écrites. Ce compteur s'incrémente seulement quand la
        phase est
        <literal>seq scanning heap</literal>,
        <literal>index scanning heap</literal>
        ou <literal>writing new heap</literal>.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_total</structfield> <type>bigint</type>
      </para>
      <para>
        Nombre total de blocs dans la table. Ce nombre est rapporté au début de
        <literal>seq scanning heap</literal>.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_scanned</structfield> <type>bigint</type>
      </para>
      <para>
        Nombre de blocs parcourus. Ce compteur s'incrément seulement quand la
        phase est <literal>seq scanning heap</literal>.
      </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>index_rebuild_count</structfield> <type>bigint</type>
      </para>
      <para>
        Nombre d'index reconstruit. Ce compteur s'incrémente seulement quand la
        phase est <literal>rebuilding index</literal>.
      </para></entry>
     </row>
    </tbody>
    </tgroup>
   </table>

   <table id="cluster-phases">
    <title>Phases de CLUSTER et VACUUM FULL</title>
    <tgroup cols="2">
     <thead>
     <row>
       <entry>Phase</entry>
       <entry>Description</entry>
      </row>
     </thead>

    <tbody>
     <row>
      <entry><literal>initializing</literal></entry>
      <entry>
        La commande prépare le début du parcours de la table. Cette phase est
        normalement très brève.
      </entry>
     </row>
     <row>
      <entry><literal>seq scanning heap</literal></entry>
      <entry>
        La commande parcourt la table en utilisant un parcours séquentiel.
      </entry>
     </row>
     <row>
      <entry><literal>index scanning heap</literal></entry>
      <entry>
        <command>CLUSTER</command> parcourt la table en utilisant un parcours
        d'index.
      </entry>
     </row>
     <row>
      <entry><literal>sorting tuples</literal></entry>
      <entry>
        <command>CLUSTER</command> trie les lignes.
      </entry>
     </row>
     <row>
      <entry><literal>writing new heap</literal></entry>
      <entry>
        <command>CLUSTER</command> est en cours d'écriture du nouveau fichier
        de la table.
      </entry>
     </row>
     <row>
      <entry><literal>swapping relation files</literal></entry>
      <entry>
        La commande bascule les fichiers nouvellement construit en place.
      </entry>
     </row>
     <row>
      <entry><literal>rebuilding index</literal></entry>
      <entry>
        La commande reconstruit les index.
      </entry>
     </row>
     <row>
      <entry><literal>performing final cleanup</literal></entry>
      <entry>
        La commande réalise le nettoyage final. Quand cette phase est terminée,
        <command>CLUSTER</command> ou <command>VACUUM FULL</command> terminera.
      </entry>
     </row>
    </tbody>
    </tgroup>
   </table>
  </sect2>

  <sect2 id="basebackup-progress-reporting">
   <title>Base Backup Progress Reporting</title>
 
   <para>
    Whenever an application like <application>pg_basebackup</application>
    is taking a base backup, the
    <structname>pg_stat_progress_basebackup</structname>
    view will contain a row for each WAL sender process that is currently
    running the <command>BASE_BACKUP</command> replication command
    and streaming the backup. The tables below describe the information
    that will be reported and provide information about how to interpret it.
   </para>
 
   <table id="pg-stat-progress-basebackup-view" xreflabel="pg_stat_progress_basebackup">
    <title><structname>pg_stat_progress_basebackup</structname> View</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        Column Type
       </para>
       <para>
        Description
       </para></entry>
      </row>
     </thead>
 
     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>pid</structfield> <type>integer</type>
       </para>
       <para>
        Process ID of a WAL sender process.
       </para></entry>
      </row>
 
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>phase</structfield> <type>text</type>
       </para>
       <para>
        Current processing phase. See <xref linkend="basebackup-phases"/>.
       </para></entry>
      </row>
 
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>backup_total</structfield> <type>bigint</type>
       </para>
       <para>
        Total amount of data that will be streamed. This is estimated and
        reported as of the beginning of
        <literal>streaming database files</literal> phase. Note that
        this is only an approximation since the database
        may change during <literal>streaming database files</literal> phase
        and WAL log may be included in the backup later. This is always
        the same value as <structfield>backup_streamed</structfield>
        once the amount of data streamed exceeds the estimated
        total size. If the estimation is disabled in
        <application>pg_basebackup</application>
        (i.e., <literal>--no-estimate-size</literal> option is specified),
        this is <literal>NULL</literal>.
       </para></entry>
      </row>
 
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>backup_streamed</structfield> <type>bigint</type>
       </para>
       <para>
        Amount of data streamed. This counter only advances
        when the phase is <literal>streaming database files</literal> or
        <literal>transferring wal files</literal>.
       </para></entry>
      </row>
 
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tablespaces_total</structfield> <type>bigint</type>
       </para>
       <para>
        Total number of tablespaces that will be streamed.
       </para></entry>
      </row>
 
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tablespaces_streamed</structfield> <type>bigint</type>
       </para>
       <para>
        Number of tablespaces streamed. This counter only
        advances when the phase is <literal>streaming database files</literal>.
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
 
   <table id="basebackup-phases">
    <title>Base backup phases</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="2*"/>
     <thead>
      <row>
       <entry>Phase</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>initializing</literal></entry>
       <entry>
        The WAL sender process is preparing to begin the backup.
        This phase is expected to be very brief.
       </entry>
      </row>
      <row>
       <entry><literal>waiting for checkpoint to finish</literal></entry>
       <entry>
        The WAL sender process is currently performing
        <function>pg_start_backup</function> to set up for
        taking a base backup, and waiting for backup start
        checkpoint to finish.
       </entry>
      </row>
      <row>
       <entry><literal>estimating backup size</literal></entry>
       <entry>
        The WAL sender process is currently estimating the total amount
        of database files that will be streamed as a base backup.
       </entry>
      </row>
      <row>
       <entry><literal>streaming database files</literal></entry>
       <entry>
        The WAL sender process is currently streaming database files
        as a base backup.
       </entry>
      </row>
      <row>
       <entry><literal>waiting for wal archiving to finish</literal></entry>
       <entry>
        The WAL sender process is currently performing
        <function>pg_stop_backup</function> to finish the backup,
        and waiting for all the WAL files required for the base backup
        to be successfully archived.
        If either <literal>--wal-method=none</literal> or
        <literal>--wal-method=stream</literal> is specified in
        <application>pg_basebackup</application>, the backup will end
        when this phase is completed.
       </entry>
      </row>
      <row>
       <entry><literal>transferring wal files</literal></entry>
       <entry>
        The WAL sender process is currently transferring all WAL logs
        generated during the backup. This phase occurs after
        <literal>waiting for wal archiving to finish</literal> phase if
        <literal>--wal-method=fetch</literal> is specified in
        <application>pg_basebackup</application>. The backup will end
        when this phase is completed.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>
 </sect1>

 <sect1 id="dynamic-trace">
 <title>Traces dynamiques</title>

 <indexterm zone="dynamic-trace">
 <primary>DTrace</primary>
 </indexterm>

 <para>
 <productname>PostgreSQL</productname> fournit un support pour les traces
 dynamiques du serveur de bases de données. Ceci permet l'appel à un outil
 externe à certains points du code pour tracer son exécution.
 </para>

 <para>
 Un certain nombre de sondes et de points de traçage sont déjà insérés dans
 le code source. Ces sondes ont pour but d'être utilisées par des développeurs
 et des administrateurs de base de données. Par défaut, les sondes ne sont pas
 compilées dans <productname>PostgreSQL</productname>&nbsp;; l'utilisateur a
 besoin de préciser explicitement au script configure de rendre disponible
 les sondes.
 </para>

 <para>
 Actuellement, l'outil <ulink
 url="https://en.wikipedia.org/wiki/DTrace">DTrace</ulink> est supporté. Il
 est disponible sur Solaris, macOS, FreeBSD, NetBSD et Oracle Linux. Le
 projet <ulink url="http://sourceware.org/systemtap/">SystemTap</ulink>
 fournit un équivalent DTrace et peut aussi être utilisé. Le support
 d'autres outils de traces dynamiques est possible théoriquement en modifiant
 les définitions des macros dans
 <filename>src/include/utils/probes.h</filename>.
 </para>

 <sect2 id="compiling-for-trace">
 <title>Compiler en activant les traces dynamiques</title>

 <para>
 Par défaut, les sondes ne sont pas disponibles, donc vous aurez besoin d'indiquer
 explicitement au script configure de les activer dans
 <productname>PostgreSQL</productname>. Pour inclure le support de DTrace,
 ajoutez <option>--enable-dtrace</option> aux options de configure. Lire
 <xref linkend="install-procedure"/> pour plus d'informations.
 </para>
 </sect2>

 <sect2 id="trace-points">
 <title>Sondes disponibles</title>

 <para>
 Un certain nombre de sondes standards sont fournies dans le code source,
 comme indiqué dans <xref linkend="dtrace-probe-point-table"/>. <xref
 linkend="typedefs-table"/> précise les types utilisés dans les sondes.
 D'autres peuvent être ajoutées pour améliorer la surveillance de
 <productname>PostgreSQL</productname>.
 </para>

 <table id="dtrace-probe-point-table">
 <title>Sondes disponibles pour DTrace</title>
 <tgroup cols="3">
  <thead>
   <row>
    <entry>Nom</entry>
    <entry>Paramètres</entry>
    <entry>Aperçu</entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry><literal>transaction-start</literal></entry>
    <entry><literal>(LocalTransactionId)</literal></entry>
    <entry>Sonde qui se déclenche au lancement d'une nouvelle transaction.
     arg0 est l'identifiant de transaction</entry>
   </row>
   <row>
    <entry><literal>transaction-commit</literal></entry>
    <entry><literal>(LocalTransactionId)</literal></entry>
    <entry>Sonde qui se déclenche quand une transaction se termine avec succès.
     arg0 est l'identifiant de transaction</entry>
   </row>
   <row>
    <entry><literal>transaction-abort</literal></entry>
    <entry><literal>(LocalTransactionId)</literal></entry>
    <entry>Sonde qui se déclenche quand une transaction échoue.
     arg0 est l'identifiant de transaction</entry>
   </row>
   <row>
    <entry><literal>query-start</literal></entry>
    <entry><literal>(const char *)</literal></entry>
    <entry>Sonde qui se déclenche lorsque le traitement d'une requête commence.
     arg0 est la requête</entry>
   </row>
   <row>
    <entry><literal>query-done</literal></entry>
    <entry><literal>(const char *)</literal></entry>
    <entry>Sonde qui se déclenche lorsque le traitement d'une requête se termine.
     arg0 est la requête</entry>
   </row>
   <row>
    <entry><literal>query-parse-start</literal></entry>
    <entry><literal>(const char *)</literal></entry>
    <entry>Sonde qui se déclenche lorsque l'analyse d'une requête commence.
     arg0 est la requête</entry>
   </row>
   <row>
    <entry><literal>query-parse-done</literal></entry>
    <entry><literal>(const char *)</literal></entry>
    <entry>Sonde qui se déclenche lorsque l'analyse d'une requête se termine.
     arg0 est la requête</entry>
   </row>
   <row>
    <entry><literal>query-rewrite-start</literal></entry>
    <entry><literal>(const char *)</literal></entry>
    <entry>Sonde qui se déclenche lorsque la ré-écriture d'une requête commence.
     arg0 est la requête</entry>
   </row>
   <row>
    <entry><literal>query-rewrite-done</literal></entry>
    <entry><literal>(const char *)</literal></entry>
    <entry>Sonde qui se déclenche lorsque la ré-écriture d'une requête se termine.
     arg0 est la requête</entry>
   </row>
   <row>
    <entry><literal>query-plan-start</literal></entry>
    <entry><literal>()</literal></entry>
    <entry>Sonde qui se déclenche lorsque la planification d'une requête commence</entry>
   </row>
   <row>
    <entry><literal>query-plan-done</literal></entry>
    <entry><literal>()</literal></entry>
    <entry>Sonde qui se déclenche lorsque la planification d'une requête se termine</entry>
   </row>
   <row>
    <entry><literal>query-execute-start</literal></entry>
    <entry><literal>()</literal></entry>
    <entry>Sonde qui se déclenche lorsque l'exécution d'une requête commence</entry>
   </row>
   <row>
    <entry><literal>query-execute-done</literal></entry>
    <entry><literal>()</literal></entry>
    <entry>Sonde qui se déclenche lorsque l'exécution d'une requête se termine</entry>
   </row>
   <row>
    <entry><literal>statement-status</literal></entry>
    <entry><literal>(const char *)</literal></entry>
    <entry>Sonde qui se déclenche à chaque fois que le processus serveur met à
     jour son statut dans
     <structname>pg_stat_activity</structname>.<structfield>status</structfield>.
     arg0 est la nouvelle chaîne de statut</entry>
   </row>
   <row>
    <entry><literal>checkpoint-start</literal></entry>
    <entry><literal>(int)</literal></entry>
    <entry>Sonde qui se déclenche quand un point de retournement commence son
     exécution.
     arg0 détient les drapeaux bit à bit utilisés pour distinguer les
     différents types de points de retournement, comme un point suite à un
     arrêt, un point immédiat ou un point forcé</entry>
   </row>
   <row>
    <entry><literal>checkpoint-done</literal></entry>
    <entry><literal>(int, int, int, int, int)</literal></entry>
    <entry>Sonde qui se déclenche quand un point de retournement a terminé son
     exécution (les sondes listées après se déclenchent en séquence lors du
     traitement d'un point de retournement).
     arg0 est le nombre de tampons mémoires écrits. arg1 est le nombre total
     de tampons mémoires. arg2, arg3 et arg4 contiennent respectivement le
     nombre de journaux de transactions ajoutés, supprimés et recyclés</entry>
   </row>
   <row>
    <entry><literal>clog-checkpoint-start</literal></entry>
    <entry><literal>(bool)</literal></entry>
    <entry>Sonde qui se déclenche quand la portion CLOG d'un point de
     retournement commence.
     arg0 est true pour un point de retournement normal, false pour un point
     de retournement suite à un arrêt</entry>
   </row>
   <row>
    <entry><literal>clog-checkpoint-done</literal></entry>
    <entry><literal>(bool)</literal></entry>
    <entry>Sonde qui se déclenche quand la portion CLOG d'un point de
     retournement commence.
     arg0 a la même signification que pour <literal>clog-checkpoint-start</literal></entry>
   </row>
   <row>
    <entry><literal>subtrans-checkpoint-start</literal></entry>
    <entry><literal>(bool)</literal></entry>
    <entry>Sonde qui se déclenche quand la portion SUBTRANS d'un point de
     retournement commence.
     arg0 est true pour un point de retournement normal, false pour un point
     de retournement suite à un arrêt</entry>
   </row>
   <row>
    <entry><literal>subtrans-checkpoint-done</literal></entry>
    <entry><literal>(bool)</literal></entry>
    <entry>Sonde qui se déclenche quand la portion SUBTRANS d'un point de
     retournement se termine.
     arg0 a la même signification que pour <literal>subtrans-checkpoint-start</literal></entry>
   </row>
   <row>
    <entry><literal>multixact-checkpoint-start</literal></entry>
    <entry><literal>(bool)</literal></entry>
    <entry>Sonde qui se déclenche quand la portion MultiXact d'un point de
     retournement commence.
     arg0 est true pour un point de retournement normal, false pour un point
     de retournement suite à un arrêt</entry>
   </row>
   <row>
    <entry><literal>multixact-checkpoint-done</literal></entry>
    <entry><literal>(bool)</literal></entry>
    <entry>Sonde qui se déclenche quand la portion MultiXact d'un point de
     retournement se termine.
     arg0 a la même signification que pour <literal>multixact-checkpoint-start</literal></entry>
   </row>
   <row>
    <entry><literal>buffer-checkpoint-start</literal></entry>
    <entry><literal>(int)</literal></entry>
    <entry>Sonde qui se déclenche quand la portion d'écriture de tampons d'un
     point de retournement commence.
     arg0 contient les drapeaux bit à bit pour distinguer différents types de
     point de retournement comme le point après arrêt, un point immédiat, un
     point forcé</entry>
   </row>
   <row>
    <entry><literal>buffer-sync-start</literal></entry>
    <entry><literal>(int, int)</literal></entry>
    <entry>Sonde qui se déclenche quand nous commençons d'écrire les tampons
     modifiés pendant un point de retournement (après identification des
     tampons qui doivent être écrits).
     arg0 est le nombre total de tampons.
     arg1 est le nombre de tampons qui sont modifiés et n'ont pas besoin
     d'être écrits</entry>
   </row>
   <row>
    <entry><literal>buffer-sync-written</literal></entry>
    <entry><literal>(int)</literal></entry>
    <entry>Sonde qui se déclenche après chaque écriture d'un tampon lors d'un
     point de retournement.
     arg0 est le numéro d'identifiant du tampon</entry>
   </row>
   <row>
    <entry><literal>buffer-sync-done</literal></entry>
    <entry><literal>(int, int, int)</literal></entry>
    <entry>Sonde qui se déclenche quand tous les tampons modifiés ont été
     écrits.
     arg0 est le nombre total de tampons.
     arg1 est le nombre de tampons réellement écrits par le processus de point
     de retournement.
     arg2 est le nombre attendu de tampons à écrire (arg1 de
     <literal>buffer-sync-start</literal>)&nbsp;; toute différence reflète d'autres processus
     écrivant des tampons lors du point de retournement</entry>
   </row>
   <row>
    <entry><literal>buffer-checkpoint-sync-start</literal></entry>
    <entry><literal>()</literal></entry>
    <entry>Sonde qui se déclenche une fois les tampons modifiés écrits par le
     noyau et avant de commencer à lancer des requêtes fsync</entry>
   </row>
   <row>
    <entry><literal>buffer-checkpoint-done</literal></entry>
    <entry><literal>()</literal></entry>
    <entry>Sonde qui se déclenche après la fin de la synchronisation des
     tampons sur le disque</entry>
   </row>
   <row>
    <entry><literal>twophase-checkpoint-start</literal></entry>
    <entry><literal>()</literal></entry>
    <entry>Sonde qui se déclenche quand la portion deux-phases d'un point de
     retournement est commencée</entry>
   </row>
   <row>
    <entry><literal>twophase-checkpoint-done</literal></entry>
    <entry><literal>()</literal></entry>
    <entry>Sonde qui se déclenche quand la portion deux-phases d'un point de
     retournement est terminée</entry>
   </row>
   <row>
    <entry><literal>buffer-read-start</literal></entry>
    <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)</literal></entry>
    <entry>Sonde qui se déclenche quand la lecture d'un tampon commence.
     arg0 et arg1 contiennent les numéros de fork et de bloc de la page (arg1
     vaudra -1 s'il s'agit de demande d'extension de la relation).
     arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
     base de données et de la relation identifiant ainsi précisément la
     relation.
     arg5 est l'identifiant du processus moteur qui a créé la relation
     temporaire pour un tampon local ou <symbol>InvalidBackendId</symbol> (-1) pour un
     tampon partagé.
     arg6 est true pour une demande d'extension de la relation, false pour
     une lecture ordinaire</entry>
   </row>
   <row>
    <entry><literal>buffer-read-done</literal></entry>
    <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool)</literal></entry>
    <entry>Sonde qui se déclenche quand la lecture d'un tampon se termine.
     arg0 et arg1 contiennent les numéros de fork et de bloc de la page (arg1
     contient le numéro de bloc du nouveau bloc ajouté s'il s'agit de demande
     d'extension de la relation).
     arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
     base de données et de la relation identifiant ainsi précisément la
     relation.
     arg5 est l'identifiant du processus moteur qui a créé la relation
     temporaire pour un tampon local ou <symbol>InvalidBackendId</symbol> (-1) pour un
     tampon partagé.
     arg6 est true pour une demande d'extension de la relation, false pour
     une lecture ordinaire.
     arg7 est true si la tampon était disponible en mémoire, false sinon</entry>
   </row>
   <row>
    <entry><literal>buffer-flush-start</literal></entry>
    <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
    <entry>Sonde qui se déclenche avant de lancer une demande d'écriture pour
     un bloc partagé.
     arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
     base de données et de la relation identifiant ainsi précisément la
     relation</entry>
   </row>
   <row>
    <entry><literal>buffer-flush-done</literal></entry>
    <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
    <entry>Sonde qui se déclenche quand une demande d'écriture se termine.
     (Notez que ceci ne reflète que le temps passé pour fournir la donnée au
     noyau&nbsp;; ce n'est habituellement pas encore écrit sur le disque.)
     Les arguments sont identiques à ceux de <literal>buffer-flush-start</literal></entry>
   </row>
   <row>
    <entry><literal>buffer-write-dirty-start</literal></entry>
    <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
    <entry>Sonde qui se déclenche quand un processus serveur commence à écrire
     un tampon modifié sur disque. Si cela arrive souvent, cela implique que
     <xref linkend="guc-shared-buffers"/> est trop petit ou que les paramètres
     de contrôle de bgwriter ont besoin d'un ajustement.)
     arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
     arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
     base de données et de la relation identifiant ainsi précisément la
     relation</entry>
   </row>
   <row>
    <entry><literal>buffer-write-dirty-done</literal></entry>
    <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
    <entry>Sonde qui se déclenche quand l'écriture d'un tampon modifié est
     terminé.
     Les arguments sont identiques à ceux de <literal>buffer-write-dirty-start</literal></entry>
   </row>
   <row>
    <entry><literal>wal-buffer-write-dirty-start</literal></entry>
    <entry><literal>()</literal></entry>
    <entry>Sonde qui se déclenche quand un processus serveur commence à écrire
     un tampon modifié d'un journal de transactions parce qu'il n'y a plus
     d'espace disponible dans le cache des journaux de transactions. (Si cela
     arrive souvent, cela implique que <xref linkend="guc-wal-buffers"/> est
     trop petit.)</entry>
   </row>
   <row>
    <entry><literal>wal-buffer-write-dirty-done</literal></entry>
    <entry><literal>()</literal></entry>
    <entry>Sonde qui se déclenche quand l'écriture d'un tampon modifié d'un
     journal de transactions est terminée</entry>
   </row>
   <row>
    <entry><literal>wal-insert</literal></entry>
    <entry><literal>(unsigned char, unsigned char)</literal></entry>
    <entry>Sonde qui se déclenche quand un enregistrement est inséré dans un
     journal de transactions.
     arg0 est le gestionnaire de ressource (rmid) pour l'enregistrement.
     arg1 contient des informations supplémentaires</entry>
   </row>
   <row>
    <entry><literal>wal-switch</literal></entry>
    <entry><literal>()</literal></entry>
    <entry>Sonde qui se déclenche quand une bascule du journal de transactions
     est demandée</entry>
   </row>
   <row>
    <entry><literal>smgr-md-read-start</literal></entry>
    <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
    <entry>Sonde qui se déclenche au début de la lecture d'un bloc d'une
     relation.
     arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
     arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
     base de données et de la relation identifiant ainsi précisément la
     relation.
     arg5 est l'identifiant du processus moteur qui a créé la relation
     temporaire pour un tampon local ou <symbol>InvalidBackendId</symbol> (-1) pour un
     tampon partagé</entry>
   </row>
   <row>
    <entry><literal>smgr-md-read-done</literal></entry>
    <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
    <entry>Sonde qui se déclenche à la fin de la lecture d'un bloc.
     arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
     arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
     base de données et de la relation identifiant ainsi précisément la
     relation.
     arg5 est l'identifiant du processus moteur qui a créé la relation
     temporaire pour un tampon local ou <symbol>InvalidBackendId</symbol> (-1) pour un
     tampon partagé.
     arg6 est le nombre d'octets réellement lus alors que arg7 est le nombre
     d'octets demandés (s'il y a une différence, il y a un problème)</entry>
   </row>
   <row>
    <entry><literal>smgr-md-write-start</literal></entry>
    <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
    <entry>Sonde qui se déclenche au début de l'écriture d'un bloc dans une
     relation.
     arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
     arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
     base de données et de la relation identifiant ainsi précisément la
     relation.
     arg5 est l'identifiant du processus moteur qui a créé la relation
     temporaire pour un tampon local ou <symbol>InvalidBackendId</symbol> (-1) pour un
     tampon partagé</entry>
   </row>
   <row>
    <entry><literal>smgr-md-write-done</literal></entry>
    <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
    <entry>Sonde qui se déclenche à la fin de l'écriture d'un bloc.
     arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
     arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
     base de données et de la relation identifiant ainsi précisément la
     relation.
     arg5 est l'identifiant du processus moteur qui a créé la relation
     temporaire pour un tampon local ou <symbol>InvalidBackendId</symbol> (-1) pour un
     tampon partagé.
     arg6 est le nombre d'octets réellement écrits alors que arg7 est le nombre
     d'octets demandés (si ces nombres sont différents, cela indique un
     problème)</entry>
   </row>
   <row>
    <entry><literal>sort-start</literal></entry>
    <entry><literal>(int, bool, int, int, bool, int)</literal></entry>
    <entry>Sonde qui se déclenche quand une opération de tri est démarré.
     arg0 indique un tri de la table, de l'index ou d'un datum.
     arg1 est true si on force les valeurs uniques.
     arg2 est le nombre de colonnes clés.
     arg3 est le nombre de ko de mémoire autorisé pour ce travail.
     arg4 est true si un accès aléatoire au résultat du tri est requis
     arg5 indicates serial when <literal>0</literal>, parallel worker when
     <literal>1</literal>, or parallel leader when <literal>2</literal>.</entry>
   </row>
   <row>
    <entry><literal>sort-done</literal></entry>
    <entry><literal>(bool, long)</literal></entry>
    <entry>Sonde qui se déclenche quand un tri est terminé.
     arg0 est true pour un tri externe, false pour un tri interne.
     arg1 est le nombre de blocs disque utilisés pour un tri externe, ou le
     nombre de ko de mémoire utilisés pour un tri interne</entry>
   </row>
   <row>
    <entry><literal>lwlock-acquire</literal></entry>
    <entry><literal>(char *, LWLockMode)</literal></entry>
    <entry>Sonde qui se déclenche quand un LWLock a été acquis.
     arg0 est la tranche de LWLock.
     arg1 est le mode de verrou attendu, soit exclusif soit partagé.</entry>
   </row>
   <row>
    <entry><literal>lwlock-release</literal></entry>
    <entry><literal>(char *)</literal></entry>
    <entry>Sonde qui se déclenche quand un LWLock a été relâché (mais notez
     que tout processus en attente n'a pas encore été réveillé).
     arg0 est la tranche de LWLock.</entry>
   </row>
   <row>
    <entry><literal>lwlock-wait-start</literal></entry>
    <entry><literal>(char *, LWLockMode)</literal></entry>
    <entry>Sonde qui se déclenche quand un LWLock n'était pas immédiatement
     disponible et qu'un processus serveur a commencé à attendre la
     disponibilité du verrou.
     arg0 est la tranche de LWLock.
     arg1 est le mode de verrou attendu, soit exclusif soit partagé.</entry>
   </row>
   <row>
    <entry><literal>lwlock-wait-done</literal></entry>
    <entry><literal>(char *, LWLockMode)</literal></entry>
    <entry>Sonde qui se déclenche quand un processus serveur n'est plus en
     attente d'un LWLock (il n'a pas encore le verrou).
     arg0 est la tranche de LWLock.
     arg1 est le mode de verrou attendu, soit exclusif soit partagé.</entry>
   </row>
   <row>
    <entry><literal>lwlock-condacquire</literal></entry>
    <entry><literal>(char *, LWLockMode)</literal></entry>
    <entry>Sonde qui se déclenche quand un LWLock a été acquis avec succès
     malgré le fait que l'appelant ait demandé de ne pas attendre.
     arg0 est la tranche de LWLock.
     arg1 est le mode de verrou attendu, soit exclusif soit partagé.</entry>
   </row>
   <row>
    <entry><literal>lwlock-condacquire-fail</literal></entry>
    <entry><literal>(char *, LWLockMode)</literal></entry>
    <entry>Sonde qui se déclenche quand un LWLock, demandé sans attente, n'est
     pas accepté.
     arg0 est la tranche de LWLock.
     arg1 est le mode de verrou attendu, soit exclusif soit partagé.</entry>
   </row>
   <row>
    <entry><literal>lock-wait-start</literal></entry>
   <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int,  LOCKMODE)</literal></entry>
    <entry>Sonde qui se déclenche quand une demande d'un gros verrou
     (<foreignphrase>lmgr lock</foreignphrase>) a commencé l'attente parce que
     le verrou n'était pas disponible.
     arg0 à arg3 sont les champs identifiant l'objet en cours de verrouillage.
     arg4 indique le type d'objet à verrouiller.
     arg5 indique le type du verrou demandé</entry>
   </row>
   <row>
    <entry><literal>lock-wait-done</literal></entry>
   <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int,  LOCKMODE)</literal></entry>
    <entry>Sonde qui se déclenche quand une demande d'un gros verrou
     (<foreignphrase>lmgr lock</foreignphrase>) a fini d'attendre (c'est-à-dire
     que le verrou a été accepté).
     Les arguments sont identiques à ceux de lock-wait-start</entry>
   </row>
   <row>
    <entry><literal>deadlock-found</literal></entry>
    <entry><literal>()</literal></entry>
    <entry>Sonde qui se déclenche quand un verrou mortel est trouvé par le
     détecteur</entry>
   </row>

  </tbody>
 </tgroup>
 </table>

 <table id="typedefs-table">
 <title>Types définis utilisés comme paramètres de sonde</title>
 <tgroup cols="2">
  <thead>
   <row>
    <entry>Type</entry>
    <entry>Definition</entry>
   </row>
  </thead>

  <tbody>

   <row>
    <entry><type>LocalTransactionId</type></entry>
    <entry><type>unsigned int</type></entry>
   </row>
   <row>
    <entry><type>LWLockMode</type></entry>
    <entry><type>int</type></entry>
   </row>
   <row>
    <entry><type>LOCKMODE</type></entry>
    <entry><type>int</type></entry>
   </row>
   <row>
    <entry><type>BlockNumber</type></entry>
    <entry><type>unsigned int</type></entry>
   </row>
   <row>
    <entry><type>Oid</type></entry>
    <entry><type>unsigned int</type></entry>
   </row>
   <row>
    <entry><type>ForkNumber</type></entry>
    <entry><type>int</type></entry>
   </row>
   <row>
    <entry><type>bool</type></entry>
    <entry><type>unsigned char</type></entry>
   </row>

  </tbody>
 </tgroup>
 </table>
 </sect2>

 <sect2 id="using-trace-points">
 <title>Utiliser les sondes</title>

 <para>
 L'exemple ci-dessous montre un script DTrace pour l'analyse du nombre de
 transactions sur le système, comme alternative à l'interrogation régulière
 de <structname>pg_stat_database</structname> avant et après un test de
 performance&nbsp;:
 <programlisting>#!/usr/sbin/dtrace -qs

 postgresql$1:::transaction-start
 {
       @start["Start"] = count();
       self->ts  = timestamp;
 }

 postgresql$1:::transaction-abort
 {
       @abort["Abort"] = count();
 }

 postgresql$1:::transaction-commit
 /self->ts/
 {
       @commit["Commit"] = count();
       @time["Total time (ns)"] = sum(timestamp - self->ts);
       self->ts=0;
 }
 </programlisting>
 À son exécution, le script de l'exemple D donne une sortie comme&nbsp;:
 <screen># ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;
 ^C

 Start                                          71
 Commit                                         70
 Total time (ns)                        2312105013
 </screen>
 </para>

 <note>
 <para>
  SystemTap utilise une notation différente de DTrace pour les scripts de
  trace, même si les points de trace sont compatibles. Il est intéressant de
  noter que, lorsque nous avons écrit ce texte, les scripts SystemTap doivent
  référencer les noms des sondes en utilisant des tirets bas doubles à la
  place des tirets simples. Il est prévu que les prochaines versions de
  SystemTap corrigent ce problème.
 </para>
 </note>

 <para>
 Vous devez vous rappeler que les programmes DTrace doivent être écrits
 soigneusement, sinon les informations récoltées pourraient ne rien valoir.
 Dans la plupart des cas où des problèmes sont découverts, c'est
 l'instrumentation qui est erronée, pas le système sous-jacent. En discutant
 des informations récupérées en utilisant un tel système, il est essentiel de
 s'assurer que le script utilisé est lui-aussi vérifié et discuter.
 </para>
 </sect2>

 <sect2 id="defining-trace-points">
 <title>Définir de nouvelles sondes</title>

 <para>
 De nouvelles sondes peuvent être définies dans le code partout où le
 développeur le souhaite bien que cela nécessite une nouvelle compilation.
 Voici les étapes nécessaires pour insérer de nouvelles sondes&nbsp;:
 </para>

 <procedure>
 <step>
  <para>
   Décider du nom de la sonde et des données nécessaires pour la sonde
  </para>
 </step>

 <step>
  <para>
   Ajoutez les définitions de sonde dans
   <filename>src/backend/utils/probes.d</filename>
  </para>
 </step>

 <step>
  <para>
   Inclure <filename>pg_trace.h</filename> s'il n'est pas déjà présent dans le
   module contenant les points de sonde, et insérer les macros
   <literal>TRACE_POSTGRESQL</literal> aux emplacements souhaités dans le code
   source
  </para>
 </step>

 <step>
  <para>
   Recompiler et vérifier que les nouvelles sondes sont disponibles
  </para>
 </step>
 </procedure>

 <formalpara>
 <title>Exemple&nbsp;:</title>
 <para>
  Voici un exemple d'ajout d'une sonde pour tracer toutes les nouvelles
  transactions par identifiant de transaction.
 </para>
 </formalpara>

 <procedure>
 <step>
  <para>
   La sonde sera nommée <literal>transaction-start</literal> et nécessite
   un paramètre de type <type>LocalTransactionId</type>
  </para>
 </step>

 <step>
  <para>
   Ajout de la définition de la sonde dans
   <filename>src/backend/utils/probes.d</filename>&nbsp;:
   <programlisting>
       probe transaction__start(LocalTransactionId);
   </programlisting>
   Notez l'utilisation du double tiret bas dans le nom de la sonde. Dans un
   script DTrace utilisant la sonde, le double tiret bas doit être remplacé
   par un tiret, donc <literal>transaction-start</literal> est le nom à
   documenter pour les utilisateurs.
  </para>
 </step>

 <step>
  <para>
   Au moment de la compilation, <literal>transaction__start</literal> est
   converti en une macro appelée <literal>TRACE_POSTGRESQL_TRANSACTION_START</literal>
   (notez que les tirets bas ne sont plus doubles ici), qui est disponible
   en incluant le fichier <filename>pg_trace.h</filename>. Il faut ajouter
   l'appel à la macro aux bons emplacements dans le code source. Dans ce
   cas, cela ressemble à&nbsp;:

   <programlisting>
     TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
   </programlisting>
  </para>
 </step>

 <step>
  <para>
   Après une nouvelle compilation et l'exécution du nouveau binaire, il
   faut vérifier que la nouvelle sonde est disponible en exécutant la
   commande DTrace suivante. Vous deviez avoir cette sortie&nbsp;:
   <screen>
 # dtrace -ln transaction-start
    ID    PROVIDER          MODULE           FUNCTION NAME
 18705 postgresql49878     postgres     StartTransactionCommand transaction-start
 18755 postgresql49877     postgres     StartTransactionCommand transaction-start
 18805 postgresql49876     postgres     StartTransactionCommand transaction-start
 18855 postgresql49875     postgres     StartTransactionCommand transaction-start
 18986 postgresql49873     postgres     StartTransactionCommand transaction-start
   </screen>
  </para>
 </step>
 </procedure>

 <para>
 Il faut faire attention à d'autres choses lors de l'ajout de macros de
 trace dans le code C&nbsp;:

 <itemizedlist>
  <listitem>
   <para>
    Vous devez faire attention au fait que les types de données indiqués
    pour les paramètres d'une sonde correspondent aux types de données des
    variables utilisées dans la macro. Dans le cas contraire, vous obtiendrez
    des erreurs de compilation.
   </para>
  </listitem>


  <listitem>
   <para>
    Sur la plupart des plateformes, si <productname>PostgreSQL</productname>
    est construit avec <option>--enable-dtrace</option>, les arguments pour
    une macro de trace seront évalués à chaque fois que le contrôle passe
    dans la macro, <emphasis>même si aucun traçage n'est réellement en
     cours</emphasis>. Cela a généralement peu d'importance si vous rapportez
    seulement les valeurs de quelques variables locales, mais faites bien
    attention à l'utilisation de fonctions coûteuses. Si vous devez le faire,
    pensez à protéger la macro avec une vérification pour vous assurer que
    la trace est bien activée&nbsp;:

    <programlisting>
     if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
         TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));
    </programlisting>

    Chaque macro de trace a une macro <literal>ENABLED</literal>
    correspondante.
   </para>
  </listitem>
 </itemizedlist>

 </para>

 </sect2>

 </sect1>

</chapter>