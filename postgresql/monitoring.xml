<?xml version="1.0" encoding="UTF-8"?>
<chapter id="monitoring">
 <title>Superviser l'activité de la base de données</title>

 <indexterm zone="monitoring">
  <primary>superviser</primary>
  <secondary>activité de la base de données</secondary>
 </indexterm>

 <indexterm zone="monitoring">
  <primary>activité de la base de données</primary>
  <secondary>superviser</secondary>
 </indexterm>

 <para>
  Un administrateur de bases de données se demande fréquemment&nbsp;:
  <quote>Que fait le système en ce moment&nbsp;?</quote> Ce chapitre explique
  la façon de le savoir.
 </para>

 <para>
  Plusieurs outils sont disponibles pour surveiller l'activité de la base de
  données et pour analyser les performances. Une grande partie de ce chapitre
  concerne la description du système de statistiques cumulatives de
  <productname>PostgreSQL</productname> mais personne ne devrait négliger les
  programmes de surveillance Unix standards tels que <command>ps</command>,
  <command>top</command>, <command>iostat</command> et
  <command>vmstat</command>. De plus, une fois qu'une requête peu performante
  a été identifiée, des investigations supplémentaires pourraient être
  nécessaires en utilisant la commande <link
  linkend="sql-explain"><command>EXPLAIN</command></link> de
  <productname>PostgreSQL</productname>. La <xref linkend="using-explain"/>
  discute de <command>EXPLAIN</command> et des autres méthodes pour
  comprendre le comportement d'une seule requête.
 </para>

 <sect1 id="monitoring-ps">
  <title>Outils Unix standard</title>

  <indexterm zone="monitoring-ps">
   <primary>ps</primary>
   <secondary>pour surveiller l'activité</secondary>
  </indexterm>

  <para>
   Sur la plupart des plateformes Unix, <productname>PostgreSQL</productname>
   modifie son titre de commande reporté par <command>ps</command> de façon à
   ce que les processus serveur individuels puissent être rapidement
   identifiés. Voici un affichage d'exemple&nbsp;:

   <screen>$ ps auxww | grep ^postgres
postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -i
postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: background writer
postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: checkpointer
postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: walwriter
postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: autovacuum launcher
postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: joe runbug 127.0.0.1 idle
postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: tgl regression [local] SELECT waiting
postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: tgl regression [local] idle in transaction
   </screen>

   (L'appel approprié de <command>ps</command> varie suivant les différentes
   plateformes, de même que les détails affichés. Cet exemple est tiré d'un
   système Linux récent.) Le premier processus affiché ici est le processus
   serveur primaire. Les arguments affichés pour cette commande sont les
   mêmes qu'à son lancement. Les quatre processus suivants sont des processus
   en tâche de fond lancés automatiquement par le processus primaire
   (le processus <quote>autovacuum launcher</quote> ne sera pas présent si
   vous avez configuré le système pour qu'il n'exécute pas l'autovacuum).
   Chacun des autres processus est un processus serveur gérant une connexion
   cliente. Tous ces processus restants initialisent l'affichage de la ligne
   de commande sous la forme&nbsp;:

   <screen>postgres: <replaceable>utilisateur</replaceable> <replaceable>base_de_données</replaceable> <replaceable>hôte</replaceable> <replaceable>activité</replaceable></screen>

   L'utilisateur, la base de données et les éléments de l'hôte(client) restent
   identiques pendant toute la vie de connexion du client mais, l'indicateur
   d'activité change. L'activité pourrait être <literal>idle</literal>
   (c'est-à-dire en attente d'une commande du client), <literal>idle in
   transaction</literal> (en attente du client à l'intérieur d'un bloc de
   <command>BEGIN</command>/<command>COMMIT</command>) ou un nom de commande
   du type <literal>SELECT</literal>. De plus, <literal>waiting</literal> est
   ajouté si le processus serveur est en attente d'un verrou détenu par une
   autre session. Dans l'exemple ci-dessus, nous pouvons supposer que le
   processus 15606 attend que le processus 15610 finisse sa transaction, et
   par conséquent libère un verrou (le processus 15610 doit être celui qui
   bloque car il n'y a aucune autre session active. Dans des cas plus
   compliqués, il serait nécessaire de regarder dans la vue système <link
   linkend="view-pg-locks"><structname>pg_locks</structname></link> pour
   déterminer qui est en train de bloquer qui.)
  </para>

  <para>
   Si <xref linkend="guc-cluster-name"/> a été configuré, le nom de l'instance
   figurera également dans la sortie&nbsp;:
   <screen>
$ psql -c 'SHOW cluster_name'
 cluster_name
--------------
 server1
(1 row)

$ ps aux|grep server1
postgres   27093  0.0  0.0  30096  2752 ?        Ss   11:34   0:00 postgres: server1: background writer
...
   </screen>
  </para>

  <para>
   Si vous avez désactivé <xref linkend="guc-update-process-title"/>, alors
   l'indicateur d'activité n'est pas mis à jour&nbsp;; le titre du processus
   est configuré une seule fois quand un nouveau processus est lancé. Sur
   certaines plateformes, ceci permet d'économiser du temps. Sur d'autres,
   cette économie est insignifiante.
  </para>

  <tip>
   <para>
    <productname>Solaris</productname> requiert une gestion particulière. Vous
    devez utiliser <command>/usr/ucb/ps</command> plutôt que
    <command>/bin/ps</command>. Vous devez aussi utiliser deux options
    <option>w</option> et non pas seulement une. En plus, votre appel
    original de la commande <command>postgres</command> doit avoir un
    affichage de statut dans <command>ps</command> plus petit que celui
    fourni par les autres processus serveur. Vous devez donc faire ces trois
    opérations sinon l'affichage de <command>ps</command> pour chaque
    processus serveur sera la ligne de commande originale de
    <command>postgres</command>.
   </para>
  </tip>
 </sect1>

 <sect1 id="monitoring-stats">
  <title>Le système de statistiques cumulatives</title>

  <indexterm zone="monitoring-stats">
   <primary>statistiques</primary>
  </indexterm>

  <para>
   Le <firstterm>système de statistiques cumulatives</firstterm> de
   <productname>PostgreSQL</productname> récupère et fournit des informations
   sur l'activité du serveur. Actuellement, l'accès aux tables et index est
   comptabilisé en terme d'accès aux lignes et aux blocs. Le nombre total de
   lignes de chaque table et les informations sur les opérations de nettoyage
   et de calcul de statistiques sont aussi récupérées pour chaque table. Si
   activé, les appels aux fonctions des utilisateurs et le temps total passé
   dans chacune sont aussi comptabilisés.
  </para>

  <para>
   <productname>PostgreSQL</productname> est également capable de renvoyer des
   informations dynamiques en temps réel sur ce qu'il se passe exactement
   dans le système, comme la commande exacte en cours d'exécution par
   d'autres processus serveur et les autres connexions qui existent dans le
   système. Cette fonctionnalité est indépendante du système de statistiques
   cumulatives.
  </para>

  <sect2 id="monitoring-stats-setup">
   <title>Configuration de la récupération de statistiques</title>

   <para>
    Comme la récupération de statistiques ajoute un temps supplémentaire à
    l'exécution de la requête, le système peut être configuré pour récupérer
    ou non des informations. Ceci est contrôlé par les paramètres de
    configuration qui sont normalement initialisés dans
    <filename>postgresql.conf</filename> (voir <xref
    linkend="runtime-config"/> pour plus de détails sur leur
    initialisation).
   </para>

   <para>
    Le paramètre <xref linkend="guc-track-activities"/> active la collecte
    d'informations sur la commande en cours d'exécution pour n'importe quel
    processus serveur.
   </para>

   <para>
    Le paramètre <xref linkend="guc-track-counts"/> contrôle si les
    statistiques cumulatives sont récupérées pour les accès aux tables et
    index.
   </para>

   <para>
    Le paramètre <xref linkend="guc-track-functions"/> active le calcul de
    statistiques sur l'utilisation des fonctions définies par l'utilisateur.
   </para>

   <para>
    Le paramètre <xref linkend="guc-track-io-timing"/> active la collecte des
    temps de lecture, d'écriture, d'extension et de synchronisation des blocs.
   </para>

   <para>
    Le paramètre <xref linkend="guc-track-wal-io-timing"/> active la collecte
    des temps d'écriture et de synchronisation des journaux de transactions.
   </para>

   <para>
    Normalement, ces paramètres sont configurés dans
    <filename>postgresql.conf</filename> de façon à ce qu'ils s'appliquent à
    tous les processus serveur, mais il est possible de les
    activer/désactiver sur des sessions individuelles en utilisant la
    commande <xref linkend="sql-set"/> (pour empêcher les utilisateurs
    ordinaires de cacher leur activité à l'administrateur, seuls les
    superutilisateurs sont autorisés à modifier ces paramètres avec
    <command>SET</command>).
   </para>

   <para>
    Les statistiques cumulatives sont placées en mémoire partagée. Chaque
    processus  <productname>PostgreSQL</productname> récupère les statistiques
    localement, puis met à jour les données partagées à des intervalles
    adéquats. Quand un serveur, y compris un secondaire physique, s'arrête
    proprement, une copie permanente des données statistiques est enregistrée
    dans le sous-répertoire <filename>pg_stat</filename>, pour que les
    statistiques survivent aux redémarrages du serveur. Par contre, en cas de
    démarrage après un arrêt sale (autrement dit, après un arrêt immédiat, un
    crash du serveur, un démarrage suite à la restauration d'une sauvegarde de
    base), tous les compteurs statistiques sont réinitialisés.
   </para>

   <para>
    Une transaction peut aussi voir des statistiques propres à son activité
    (qui ne sont pas encore transmises au collecteur) dans les vues
    <structname>pg_stat_xact_all_tables</structname>,
    <structname>pg_stat_xact_sys_tables</structname>,
    <structname>pg_stat_xact_user_tables</structname> et
    <structname>pg_stat_xact_user_functions</structname>. Ces informations se
    mettent à jour en continu pendant l'exécution de la transaction.
   </para>
  </sect2>

  <sect2 id="monitoring-stats-views">
   <title>Visualiser les statistiques</title>

   <para>
    Plusieurs vues prédéfinies, listées à <xref
    linkend="monitoring-stats-dynamic-views-table"/>, sont disponibles pour
    montrer l'état courant du système. Il existe aussi plusieurs autres vues,
    listées à <xref linkend="monitoring-stats-views-table"/>, qui montrent
    les statistiques accumulées. De manière alternative, il est possible de
    créer des vues personnalisées qui utilisent les fonctions statistiques
    sous-jacentes, comme discuté à <xref
    linkend="monitoring-stats-functions"/>.
   </para>

   <para>
    Lors de l'utilisation des vues et fonctions des statistiques cumulatives
    pour superviser les données collectées, il est important de savoir que
    l'information n'est pas mise à jour instantanément. Chaque processus serveur
    individuel vide les statistiques accumulées en mémoire partagée avant d'être
    de nouveau en attente, mais cela n'arrive pas plus fréquemment qu'une fois
    toutes les <varname>PGSTAT_MIN_INTERVAL</varname> millisecondes (1 seconde
    sauf si cette constante est modifiée avant la compilation du serveur)&nbsp;;
    donc une requête ou une transaction toujours en cours n'affecte pas les
    totaux affichés et l'information est de ce fait en retard par rapport à
    l'activité en cours. Néanmoins, l'information de la requête en cours
    récupérée par <varname>track_activities</varname> est toujours à jour.
   </para>

   <para>
    Un autre point important est que, lorsqu'un processus serveur se voit
    demander d'afficher une des statistiques accumulées, les valeurs accédées
    sont mises en cache jusqu'à la fin de la transaction courante dans la
    configuration par défaut. Donc les statistiques afficheront une information
    statique tout au long de la vue de la transaction. De façon similaire,
    l'information sur les requêtes en cours de toutes les sessions est
    récupérée quand cette information est demandée pour la première fois à
    l'intérieur d'une transaction, et la même information sera affichée tout au
    long de la transaction. Ceci est une fonctionnalité, et non pas un bug, car
    cela vous permet de réaliser plusieurs requêtes sur les statistiques et de
    corréler les résultats sans vous soucier que les nombres changent entre
    temps. Lors de l'analyse interactive des statistiques ou avec des requêtes
    coûteuses, le delta du temps entre les accès aux statistiques individuelles
    peut amener à des valeurs fausses significativement dans les statistiques
    en cache. Pour minimiser cela, <varname>stats_fetch_consistency</varname>
    peut être configuré à <literal>snapshot</literal>, au prix d'une
    utilisation mémoire accrue pour meetre en cache des données statistiques
    inutiles. Par contre, s'il est connu que les statistiques ne sont accédées
    qu'une seule fois, mettre en cache les statistiques accédées n'est pas
    nécessaire et peut être évité en configurant
    <varname>stats_fetch_consistency</varname> à <literal>none</literal>. Vous
    pouvez exécuter <function>pg_stat_clear_snapshot()</function> pour annuler
    l'image des statistiques de la transaction en cours ou les valeurs en
    cache, si applicable. La prochaine utilisation des informations
    statistiques causera (en mode snapshot) la construction d'un nouveau
    snapshot ou (en mode cache) la mise en cache des statistiques accédées.
   </para>

   <para>
    Une transaction peut aussi voir ses propres statistiques (pas encore vidées
    dans les statistiques en mémoire partagée) dans les vues
    <structname>pg_stat_xact_all_tables</structname>,
    <structname>pg_stat_xact_sys_tables</structname>,
    <structname>pg_stat_xact_user_tables</structname> et
    <structname>pg_stat_xact_user_functions</structname>. Ces nombres
    n'agissent pas comme indiqués ci-dessus&nbsp;; ils sont au contraire mis à
    jour en continue tout au long de la transaction.
   </para>

   <para>
    Certaines des informations des vues statistiques dynamiques montrées dans
    <xref linkend="monitoring-stats-dynamic-views-table"/> sont à accès
    restreint. Les utilisateurs ordinaires peuvent seulement voir toutes les
    informations sur leur propres sessions (les sessions appartenant à un
    rôle dont ils sont membres). Les lignes des autres sessions auront de
    nombreuses colonnes à NULL. Notez néanmoins que l'existence d'une session
    et ses propriétés générales, tel que l'utilisateur et la base de données,
    sont visibles à tous les utilisateurs. Les superutilisateurs et les rôles
    disposant des droits du rôle interne
    <literal>pg_read_all_stats</literal> (voir aussi <xref
    linkend="predefined-roles"/>) peuvent accéder à toutes les informations
    sur les sessions.
   </para>

   <table id="monitoring-stats-dynamic-views-table">
    <title>Vues statistiques dynamiques</title>

    <tgroup cols="2">
     <colspec colnum="1" colwidth="0.4*"/>
     <colspec colnum="2" colwidth="1.6*"/>
     <thead>
      <row>
       <entry>Nom de la vue</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <structname>pg_stat_activity</structname>
        <indexterm><primary>pg_stat_activity</primary></indexterm>
       </entry>
       <entry>
        Une ligne par processus serveur, montrant les informations liées à
        l'activité courante du processus, comme l'état et la requête en
        cours. Voir <link linkend="monitoring-pg-stat-activity-view">
        <structname>pg_stat_activity</structname></link> pour plus de
        détails.
       </entry>
      </row>

      <row>
       <entry><structname>pg_stat_replication</structname><indexterm><primary>pg_stat_replication</primary></indexterm></entry>
       <entry>
        Une ligne par processus d'envoi de WAL, montrant les statistiques sur
        la réplication vers le serveur standby connecté au processus. Voir
        <link linkend="monitoring-pg-stat-replication-view">
        <structname>pg_stat_replication</structname></link> pour les
        détails.
       </entry>
      </row>

      <row>
       <entry><structname>pg_stat_wal_receiver</structname><indexterm><primary>pg_stat_wal_receiver</primary></indexterm></entry>
       <entry>Seulement une ligne, affichant des statistiques sur le récepteur
        WAL à partir du serveur ayant ce récepteur. Voir <link
        linkend="monitoring-pg-stat-wal-receiver-view">
         <structname>pg_stat_wal_receiver</structname></link> pour les détails.
       </entry>
      </row>

      <row>
       <entry><structname>pg_stat_recovery_prefetch</structname><indexterm><primary>pg_stat_recovery_prefetch</primary></indexterm></entry>
       <entry>Seulement une ligne, affichant des statistiques sur la lecture
        en avance de blocs lors du rejeu des transactions. Voir
        <link linkend="monitoring-pg-stat-recovery-prefetch">
        <structname>pg_stat_recovery_prefetch</structname></link> pour les
        détails.
       </entry>
      </row>

      <row>
       <entry><structname>pg_stat_subscription</structname><indexterm><primary>pg_stat_subscription</primary></indexterm></entry>
       <entry>Au moins une ligne par souscription, affichant des informations
        sur les processus workers de souscription. Voir <link
        linkend="monitoring-pg-stat-subscription">
         <structname>pg_stat_subscription</structname></link> pour plus de détails.
       </entry>
      </row>

      <row>
       <entry><structname>pg_stat_ssl</structname><indexterm><primary>pg_stat_ssl</primary></indexterm></entry>
       <entry>Une ligne par connexion (régulière et de réplication),
        montrant des informations sur le chiffrement SSL utilisé pour
        ces connexions.
        Voir <link linkend="monitoring-pg-stat-ssl-view">
         <structname>pg_stat_ssl</structname></link> pour les détails.
       </entry>
      </row>

      <row>
       <entry><structname>pg_stat_gssapi</structname><indexterm><primary>pg_stat_gssapi</primary></indexterm></entry>
       <entry>Une ligne par connexion (standard et réplication), montrant des
        informations sur l'authentification et le chiffrement GSSAPI utilisés
        sur cette connexion. Voir <link linkend="monitoring-pg-stat-gssapi-view">
         <structname>pg_stat_gssapi</structname></link> pour
        les détails.
       </entry>
      </row>

      <row>
       <entry><structname>pg_stat_progress_analyze</structname><indexterm><primary>pg_stat_progress_analyze</primary></indexterm></entry>
       <entry>Une ligne pour chaque connexion (incluant celles des processus
        <foreignphrase>autovacuum worker</foreignphrase>) exécutant un
        <command>ANALYZE</command>, pour indiquer le progrès actuel.
        Voir <xref linkend="analyze-progress-reporting"/>.
       </entry>
      </row>

      <row>
       <entry><structname>pg_stat_progress_create_index</structname><indexterm><primary>pg_stat_progress_create_index</primary></indexterm></entry>
       <entry>Une ligne pour chaque processus serveur exécutant un <command>CREATE
         INDEX</command> ou un <command>REINDEX</command>, affichant la
        progression actuelle. Voir
        <xref linkend="create-index-progress-reporting"/>.
       </entry>
      </row>

      <row>
       <entry><structname>pg_stat_progress_vacuum</structname><indexterm><primary>pg_stat_progress_vacuum</primary></indexterm></entry>
       <entry>Une ligne pour chaque processus (incluant les processus
        autovacuum worker) exécutant un <command>VACUUM</command>, affichant le
        progrès en cours. Voir <xref
        linkend="vacuum-progress-reporting"/>.</entry>
      </row>

      <row>
       <entry><structname>pg_stat_progress_cluster</structname><indexterm><primary>pg_stat_progress_cluster</primary></indexterm></entry>
       <entry>Une ligne pour chaque processus serveur exécutant
        <command>CLUSTER</command> ou <command>VACUUM FULL</command>, affichant
        le progrès en cours.
        Voir <xref linkend="cluster-progress-reporting"/>.
       </entry>
      </row>

      <row>
       <entry><structname>pg_stat_progress_basebackup</structname><indexterm><primary>pg_stat_progress_basebackup</primary></indexterm></entry>
       <entry>Une ligne pour chaque processus walsender envoyant une sauvegarde de base,
        en affichant le progrès actuel.
        Voir <xref linkend="basebackup-progress-reporting"/>.
       </entry>
      </row>

     <row>
      <entry><structname>pg_stat_progress_copy</structname><indexterm><primary>pg_stat_progress_copy</primary></indexterm></entry>
      <entry>Une ligne pour chaque processus en cours d'exécution de
       <command>COPY</command>, affichant le progrès actuel.
       Voir <xref linkend="copy-progress-reporting"/>.
      </entry>
     </row>
     </tbody>
    </tgroup>
   </table>

   <table id="monitoring-stats-views-table">
    <title>Vues sur les statistiques récupérées</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Nom de la vue</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>

      <!-- everything related to global objects, alphabetically -->

      <row>
       <entry><structname>pg_stat_archiver</structname><indexterm><primary>pg_stat_archiver</primary></indexterm></entry>
       <entry>Une seule ligne, montrant les statistiques sur l'activité du
        processus d'archivage des journaux de transactions. Voir <link
        linkend="monitoring-pg-stat-archiver-view">
         <structname>pg_stat_archiver</structname></link> pour les détails.
       </entry>
      </row>

      <row>
       <entry><structname>pg_stat_bgwriter</structname><indexterm><primary>pg_stat_bgwriter</primary></indexterm></entry>
       <entry>Une seule ligne, montrant les statistiques
        d'activité du processus d'écriture d'arrière-plan.
        Voir <link linkend="monitoring-pg-stat-bgwriter-view">
         <structname>pg_stat_bgwriter</structname></link> pour plus de détails.
       </entry>
      </row>

      <row>
       <entry><structname>pg_stat_checkpointer</structname><indexterm><primary>pg_stat_checkpointer</primary></indexterm></entry>
       <entry>Une seule ligne, affichant les statistiques sur l'activité du
        processus checkpointer. Voir
        <link linkend="monitoring-pg-stat-checkpointer-view">
        <structname>pg_stat_checkpointer</structname></link> pour les détails.
       </entry>
      </row>

      <row>
       <entry><structname>pg_stat_database</structname><indexterm><primary>pg_stat_database</primary></indexterm></entry>
       <entry>Une ligne par base de données, montrant les statistiques
        globales des bases. Voir <link linkend="monitoring-pg-stat-database-view">
         <structname>pg_stat_database</structname></link>
        pour plus de détails.
       </entry>
      </row>

      <row>
       <entry><structname>pg_stat_database_conflicts</structname><indexterm><primary>pg_stat_database_conflicts</primary></indexterm></entry>
       <entry>
        Une ligne par base de données, montrant les statistiques au
        niveau de la base concernant les requêtes annulées à cause de
        conflits avec les serveurs standby en restauration.
        Voir <link linkend="monitoring-pg-stat-database-conflicts-view">
         <structname>pg_stat_database_conflicts</structname></link> pour plus de détails.
       </entry>
      </row>

     <row>
      <entry><structname>pg_stat_io</structname><indexterm><primary>pg_stat_io</primary></indexterm></entry>
      <entry>
       Une ligne pour chaque combinaison de type de processus, contexte et objet
       cible contenant des statistiques disques sur l'instance. Voir
       <link linkend="monitoring-pg-stat-io-view">
       <structname>pg_stat_io</structname></link> pour plus de détails.
     </entry>
     </row>

     <row>
      <entry><structname>pg_stat_replication_slots</structname><indexterm><primary>pg_stat_replication_slots</primary></indexterm></entry>
      <entry>Une ligne par slot de réplication, affichant des statistiques sur
      l'utilisation des slots de réplication. Voir
       <link linkend="monitoring-pg-stat-replication-slots-view">
       <structname>pg_stat_replication_slots</structname></link> pour plus de
       détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_slru</structname><indexterm><primary>pg_stat_slru</primary></indexterm></entry>
      <entry>Une ligne par SLRU, affichant les statistiques des opérations. Voir
       <link linkend="monitoring-pg-stat-slru-view">
       <structname>pg_stat_slru</structname></link> pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_subscription_stats</structname><indexterm><primary>pg_stat_subscription_stats</primary></indexterm></entry>
      <entry>Une ligne par souscription, affichant des statistiques sur les
      erreurs.
      Voir <link linkend="monitoring-pg-stat-subscription-stats">
      <structname>pg_stat_subscription_stats</structname></link> pour les détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_wal</structname><indexterm><primary>pg_stat_wal</primary></indexterm></entry>
      <entry>Une seule ligne, montrant les statistiques d'activité WAL. Voir
       <link linkend="monitoring-pg-stat-wal-view">
       <structname>pg_stat_wal</structname></link> pour plus de détails.
      </entry>
     </row>

     <!-- all "stat" for schema objects, by "importance" -->

      <row>
       <entry><structname>pg_stat_all_tables</structname><indexterm><primary>pg_stat_all_tables</primary></indexterm></entry>
       <entry>
        Une ligne par table de la base de données courante, montrant les
        statistiques d'accès de chaque table spécifiquement. Voir
        <link linkend="monitoring-pg-stat-all-tables-view">
         <structname>pg_stat_all_tables</structname></link> pour plus de détails.
       </entry>
      </row>

      <row>
       <entry><structname>pg_stat_sys_tables</structname><indexterm><primary>pg_stat_sys_tables</primary></indexterm></entry>
       <entry>Identique à <structname>pg_stat_all_tables</structname>, sauf que seules les
        tables systèmes sont affichées</entry>
      </row>

      <row>
       <entry><structname>pg_stat_user_tables</structname><indexterm><primary>pg_stat_user_tables</primary></indexterm></entry>
       <entry>Identique à <structname>pg_stat_all_tables</structname>, sauf que seules les
        tables utilisateurs sont affichées</entry>
      </row>

      <row>
       <entry><structname>pg_stat_xact_all_tables</structname><indexterm><primary>pg_stat_xact_all_tables</primary></indexterm></entry>
       <entry>Similaire à <structname>pg_stat_all_tables</structname>, mais
        décompte les actions prises dans la transaction en cours (qui ne
        sont <emphasis>pas</emphasis> encore pris en compte dans la vue
        <structname>pg_stat_all_tables</structname> et les vues du même
        type). Les colonnes correspondant au nombre de lignes vivantes et
        mortes, ainsi que celles pour les actions du VACUUM et de l'ANALYZE
        ne sont pas présentes dans cette vue</entry>
      </row>

      <row>
       <entry><structname>pg_stat_xact_sys_tables</structname><indexterm><primary>pg_stat_xact_sys_tables</primary></indexterm></entry>
       <entry>Identique à <structname>pg_stat_xact_all_tables</structname>,
        sauf que seules les tables systèmes sont affichées</entry>
      </row>

      <row>
       <entry><structname>pg_stat_xact_user_tables</structname><indexterm><primary>pg_stat_xact_user_tables</primary></indexterm></entry>
       <entry>Identique à <structname>pg_stat_xact_all_tables</structname>, sauf que seules les
        tables utilisateurs sont affichées</entry>
      </row>

      <row>
       <entry><structname>pg_stat_all_indexes</structname><indexterm><primary>pg_stat_all_indexes</primary></indexterm></entry>
       <entry>
        Une ligne par index de la base de données courante, montrant les
        statistiques d'accès de chaque index spécifiquement. Voir
        <link linkend="monitoring-pg-stat-all-indexes-view">
         <structname>pg_stat_all_indexes</structname></link> pour plus de détails.
       </entry>
      </row>

      <row>
       <entry><structname>pg_stat_sys_indexes</structname><indexterm><primary>pg_stat_sys_indexes</primary></indexterm></entry>
       <entry>Identique à <structname>pg_stat_all_indexes</structname>, sauf que seules les
        tables systèmes sont affichées</entry>
      </row>

      <row>
       <entry><structname>pg_stat_user_indexes</structname><indexterm><primary>pg_stat_user_indexes</primary></indexterm></entry>
       <entry>Identique à <structname>pg_stat_all_indexes</structname>, sauf que seules
        les tables utilisateurs sont affichées</entry>
      </row>

     <row>
      <entry><structname>pg_stat_user_functions</structname><indexterm><primary>pg_stat_user_functions</primary></indexterm></entry>
      <entry>
       Une ligne pour chaque fonction tracée, affichant des statistiques
       sur l'exécution de cette fonction. Voir
       <link linkend="monitoring-pg-stat-user-functions-view">
       <structname>pg_stat_user_functions</structname></link> pour des détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_user_functions</structname><indexterm><primary>pg_stat_xact_user_functions</primary></indexterm></entry>
      <entry>Similaire à <structname>pg_stat_user_functions</structname>, mais
      compte seulement les appels lors de la transaction en cours
      (qui ne sont <emphasis>pas</emphasis> encore inclus dans
      <structname>pg_stat_user_functions</structname>).</entry>
     </row>

      <row>
       <entry><structname>pg_statio_all_tables</structname><indexterm><primary>pg_statio_all_tables</primary></indexterm></entry>
       <entry>
        Une ligne par table de la base de données courante, montrant les
        statistiques d'entrées/sorties de chaque table spécifiquement. Voir
        <link linkend="monitoring-pg-statio-all-tables-view">
         <structname>pg_statio_all_tables</structname></link> pour plus de détails.
       </entry>
      </row>

      <row>
       <entry><structname>pg_statio_sys_tables</structname><indexterm><primary>pg_statio_sys_tables</primary></indexterm></entry>
       <entry>Identique à <structname>pg_statio_all_tables</structname>, sauf que seules
        les tables systèmes sont affichées</entry>
      </row>

      <row>
       <entry><structname>pg_statio_user_tables</structname><indexterm><primary>pg_statio_user_tables</primary></indexterm></entry>
       <entry>Identique à <structname>pg_statio_all_tables</structname>, sauf que seules
        les tables utilisateur sont affichées</entry>
      </row>

      <row>
       <entry><structname>pg_statio_all_indexes</structname><indexterm><primary>pg_statio_all_indexes</primary></indexterm></entry>
       <entry>
        Une ligne par index de la base de données courante, montrant les
        les statistiques d'entrées/sorties de chaque index spécifiquement. Voir
        <link linkend="monitoring-pg-statio-all-indexes-view">
         <structname>pg_statio_all_indexes</structname></link> pour plus de détails.
       </entry>
      </row>

      <row>
       <entry><structname>pg_statio_sys_indexes</structname><indexterm><primary>pg_statio_sys_indexes</primary></indexterm></entry>
       <entry>Identique à <structname>pg_statio_all_indexes</structname>, sauf que seuls
        les index systèmes sont affichés</entry>
      </row>

      <row>
       <entry><structname>pg_statio_user_indexes</structname><indexterm><primary>pg_statio_user_indexes</primary></indexterm></entry>
       <entry>Identique à <structname>pg_statio_all_indexes</structname>, sauf que seuls
        les index utilisateur sont affichés</entry>
      </row>

      <row>
       <entry><structname>pg_statio_all_sequences</structname><indexterm><primary>pg_statio_all_sequences</primary></indexterm></entry>
       <entry>
        Une ligne par séquence de la base de données courante, montrant les
        statistiques d'entrées/sorties de chaque séquence spécifiquement. Voir
        <link linkend="monitoring-pg-statio-all-sequences-view">
         <structname>pg_statio_all_sequences</structname></link> pour plus de détails.
       </entry>
      </row>

      <row>
       <entry><structname>pg_statio_sys_sequences</structname><indexterm><primary>pg_statio_sys_sequences</primary></indexterm></entry>
       <entry>Identique à <structname>pg_statio_all_sequences</structname>, sauf que
        seules les séquences système sont affichées (actuellement, aucune
        séquence système n'est définie, donc cette vue est toujours vide)</entry>
      </row>

      <row>
       <entry><structname>pg_statio_user_sequences</structname><indexterm><primary>pg_statio_user_sequences</primary></indexterm></entry>
       <entry>Identique à <structname>pg_statio_all_sequences</structname>, sauf que
        seules les séquences utilisateur sont affichées</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Les statistiques par index sont particulièrement utiles pour déterminer
    les index utilisés et leur efficacité.
   </para>

   <para>
    L'ensemble de vues <structname>pg_stat_io</structname> et
    <structname>pg_statio_</structname> est utile pour déterminer l'efficacité
    du cache disque. Elles peuvent être utilisées pour calculer un ratio
    de lecture en cache. Notez que, bien que les statistiques d'entrées/sorties
    disques de <productname>PostgreSQL</productname> capturent la plupart des
    fois pour lequel le noyau a été appelé réaliser des entrées/sorties disques,
    elles ne différencient pas entre les données qui ont été récupérées du
    disque et celles qui résidaient déjà dans le cache disque du noyau. Il est
    conseillé aux utilisateurs de combiner les vues statistiques de
    <productname>PostgreSQL</productname> avec des outils systèmes pour avoir
    un vision plus complète des performances des entrées/sorties disque de la
    base de données.
   </para>

  </sect2>

  <sect2 id="monitoring-pg-stat-activity-view">
   <title><structname>pg_stat_activity</structname></title>

   <indexterm>
    <primary>pg_stat_activity</primary>
   </indexterm>

   <para>
    La vue <structname>pg_stat_activity</structname> aura une ligne par
    processus serveur, montrant des informations liées à l'activité courante de
    ce processus.
   </para>

   <table id="pg-stat-activity-view" xreflabel="pg_stat_activity">
    <title>Vue <structname>pg_stat_activity</structname></title>

    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>datid</structfield> <type>oid</type>
        </para>
        <para>
         OID de la base de données auquel ce processus serveur est connecté
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>datname</structfield> <type>name</type>
        </para>
        <para>
         Nom de la base de données auquel ce processus serveur est connecté
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>pid</structfield> <type>integer</type>
        </para>
        <para>
         Identifiant du processus serveur
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>leader_pid</structfield> <type>integer</type>
        </para>
        <para>
         Identifiant du processus du leader pour une requête parallélisée si ce
         si ce processus est un worker, identifiant du processus d'un leader pour
         la réplication logique parallélisée si ce processus est un worker
         d'application parallélisée de la réplication logique.
         <literal>NULL</literal> indique que ce processus est le leader pour
         une requête parallélisée ou pour une application parallélisée sur la
         réplication logique, ou ne participe pas à une requête parallélisée.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>usesysid</structfield> <type>oid</type>
        </para>
        <para>
         OID de l'utilisateur connecté à ce processus serveur
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>usename</structfield> <type>name</type>
        </para>
        <para>
         Nom de l'utilisateur connecté à ce processus serveur
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>application_name</structfield> <type>text</type>
        </para>
        <para>
         Nom de l'application connectée à ce processus serveur
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>client_addr</structfield> <type>inet</type>
        </para>
        <para>
         Adresse IP du client pour ce processus serveur.
         Si ce champ est vide, cela indique soit que le client est
         connecté via un socket Unix sur la machine serveur soit qu'il
         s'agit d'un processus interne tel qu'autovacuum.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>client_hostname</structfield> <type>text</type>
        </para>
        <para>
         Nom d'hôte du client connecté, comme reporté par une recherche DNS
         inverse sur <structfield>client_addr</structfield>. Ce champ ne sera rempli que
         pour les connexions IP, et seulement quand <xref
         linkend="guc-log-hostname"/> est activé.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>client_port</structfield> <type>integer</type>
        </para>
        <para>
         Numéro de port TCP que le client utilise pour communiquer
         avec le processus serveur,
         ou <literal>-1</literal> si un socket Unix est utilisé.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>backend_start</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Heure de démarrage du processus.  Pour les processus backends,
         c'est l'heure où le client s'est connecté au serveur.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>xact_start</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Heure de démarrage de la transaction courante du
         processus, ou NULL si aucune transaction n'est active. Si la
         requête courante est la première de sa transaction, cette
         colonne a la même valeur que la colonne
         <structfield>query_start</structfield>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>query_start</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Heure à laquelle la requête active a été démarrée, ou
         si <structfield>state</structfield> ne vaut pas
         <literal>active</literal>, quand la dernière requête
         a été lancée.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>state_change</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Heure à laquelle l'état (<structfield>state</structfield>) a été modifié en dernier
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>wait_event_type</structfield> <type>text</type>
        </para>
        <para>
         Type de l'événement pour lequel le processus est en attente&nbsp;
         sinon NULL. Voir <xref linkend="wait-event-table"/>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>wait_event</structfield> <type>text</type>
        </para>
        <para>
         Nom de l'événement d'attente si le processus est en attente, NULL
         dans le cas contraire. Voir <xref linkend="wait-event-activity-table"/>
         jusqu'à <xref linkend="wait-event-timeout-table"/>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>state</structfield> <type>text</type>
        </para>
        <para>
         État général du processus serveur.
         Les valeurs possibles sont&nbsp;:
         <itemizedlist>
          <listitem>
           <para>
            <literal>active</literal>&nbsp;: le processus serveur exécute une
            requête.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>idle</literal>&nbsp;: le processus serveur est en attente
            d'une commande par le client.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>idle in transaction</literal>&nbsp;: le processus serveur
            est en transaction, mais n'est pas en train d'exécuter une requête.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>idle in transaction (aborted)</literal>&nbsp;: l'état est
            similaire à <literal>idle in transaction</literal>, à la différence
            qu'une des instructions de la transaction a généré une erreur.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>fastpath function call</literal>&nbsp;: le processus serveur
            exécute une fonction fast-path.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>disabled</literal>&nbsp;: cet état est affiché si <xref
            linkend="guc-track-activities"/> est désactivé pour ce processus
            serveur.
           </para>
          </listitem>
         </itemizedlist>
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>backend_xid</structfield> <type>xid</type>
        </para>
        <para>
         Identifiant de transaction de haut niveau de ce processus, si
         disponible&nbsp;;  voir
         <xref linkend="transaction-id"/>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>backend_xmin</structfield> <type>xid</type>
        </para>
        <para>
         L'horizon <literal>xmin</literal> de ce processus.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>query_id</structfield> <type>bigint</type>
       </para>
       <para>
        L'identifiant de la requête la plus récente du processus. Si
        <structfield>state</structfield> vaut <literal>active</literal>, alors cette colonne
        indique l'identifiant de la requête en cours d'exécution. Pour les autres états,
        cette colonne indique l'identifiant de la dernière requête exécutée par le processus.
        Les identifiants de requêtes ne sont pas calculés par défaut, ainsi cette colonne
        peut être nulle sauf si le paramètre <xref linkend="guc-compute-query-id"/> est activé
        ou si un module tiers calculant les identifiants de requêtes est configuré.
       </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>query</structfield> <type>text</type>
        </para>
        <para>
         Texte de la requête la plus récente pour ce processus serveur. Si
         <structfield>state</structfield> vaut <literal>active</literal>, alors
         ce champ affiche la requête en cours d'exécution. Dans tous les autres
         cas, il affichera la dernière requête à avoir été exécutée. Par défaut,
         le texte de la requête est tronqué à 1024 octets. Cette valeur peut
         être modifiée avec le paramètre
         <xref linkend="guc-track-activity-query-size"/>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>backend_type</structfield> <type>text</type>
        </para>
        <para>
         Type du processus actuel. Les types possibles sont
         <literal>autovacuum launcher</literal>, <literal>autovacuum worker</literal>,
         <literal>logical replication launcher</literal>,
         <literal>logical replication worker</literal>,
         <literal>parallel worker</literal>, <literal>background writer</literal>,
         <literal>client backend</literal>, <literal>checkpointer</literal>,
         <literal>archiver</literal>, <literal>standalone backend</literal>,
         <literal>startup</literal>, <literal>walreceiver</literal>,
         <literal>walsender</literal>, <literal>walwriter</literal> et
         <literal>walsummarizer</literal>.
         De plus, les background workers enregistrés par les extensions pourraient
         avoir des types supplémentaires.
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
    <para>
     Les colonnes <structfield>wait_event</structfield> et
     <structfield>state</structfield> sont indépendantes. Si un processus
     serveur est dans l'état <literal>active</literal>, il pourrait, ou non,
     être en attente (<literal>waiting</literal>) d'un événement. Si l'état est
     <literal>active</literal> et si <structfield>wait_event</structfield> est
     différent de NULL, cela signifie qu'une requête est en cours d'exécution,
     mais que cette exécution est bloquée quelque part dans le système.
    </para>
   </note>

   <table id="wait-event-table">
    <title>Types de Wait Event</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Type de Wait Event</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
     <row>
      <entry><literal>Activity</literal></entry>
      <entry>Le processus serveur est en attente. Ce type d'événement indique un
       processus en attente d'activité dans sa boucle principale de traitement.
       <literal>wait_event</literal> identifiera la point d'attente
       spécifique&nbsp;; voir <xref linkend="wait-event-activity-table"/>.
      </entry>
     </row>
     <row>
      <entry><literal>BufferPin</literal></entry>
      <entry>Le processus serveur est en attente de l'accès exclusif à un buffer
      de données. Les attentes de ce type peuvent être prolongées si un autre
      processus détient un curseur ouvert qui est le dernier à avoir lu des
      données à partir du buffer en question. Voir <xref
      linkend="wait-event-bufferpin-table"/>.
      </entry>
     </row>
     <row>
      <entry><literal>Client</literal></entry>
      <entry>Le processus serveur est en attente d'activité sur un socket
       connecté à l'application de l'utilisateur. Donc le serveur attend quelque
       chose indépendant de ses traitements internes..
       <literal>wait_event</literal> identifiera le point d'attente
       spécifique&nbsp;; voir <xref linkend="wait-event-client-table"/>.
      </entry>
     </row>
     <row>
      <entry><literal>Extension</literal></entry>
      <entry>Le processus serveur est en attente d'une condition définie par un
       module d'extension.
       Voir <xref linkend="wait-event-extension-table"/>.
      </entry>
     </row>
     <row>
      <entry><literal>InjectionPoint</literal></entry>
      <entry>Le processus serveur est en attente qu'un point d'injection atteigne
       une décision définie dans un test. Voir
       <xref linkend="xfunc-addin-injection-points"/> pour plus de détails. Ce type
       n'a pas de points d'attente prédéfinis.
      </entry>
     </row>
     <row>
      <entry><literal>IO</literal></entry>
      <entry>Le processus serveur est en attente de la réalisation d'une opération
       d'entrée/sortie disque. <literal>wait_event</literal> identifiera le
       point d'attente spécifique&nbsp;; voir <xref
       linkend="wait-event-io-table"/>.
      </entry>
     </row>
     <row>
      <entry><literal>IPC</literal></entry>
      <entry>Le processus serveur est en attente d'interaction avec un autre
       processus serveur. <literal>wait_event</literal> identifiera le point
       d'attente spécifique&nbsp;; voir <xref linkend="wait-event-ipc-table"/>.
      </entry>
     </row>
     <row>
      <entry><literal>Lock</literal></entry>
      <entry>Le processus serveur est en attente d'un verrou lourd. Les verrous
       lourds, gérés par le gestionnaire de verrous, protège principalement les
       objets SQL visibles tels que les tables. Néanmoins, ils sont aussi
       utilisés pour assurer des exclusions mutuelles pour certaines opérations
       internes, telles que les extensions de relation.
       <literal>wait_event</literal> identifiera le type de verrou attendu&nbsp;;
       voir <xref linkend="wait-event-lock-table"/>.
      </entry>
     </row>
     <row>
      <entry><literal>LWLock</literal></entry>
      <entry>Le processus serveur est en attente d'un verrou léger. La plupart
       de ces verrous protègent une structure de données particulière en mémoire
       partagée. <literal>wait_event</literal> contiendra un nom identifiant le
       but du verrou léger. (Certains verrous ont des noms spécifiques&nbsp;;
       les autres font partie d'un groupe de verrous, chacune avec un but
       similaire.) Voir <xref linkend="wait-event-lwlock-table"/>.
      </entry>
     </row>
     <row>
      <entry><literal>Timeout</literal></entry>
      <entry>Le processus serveur est en attente de l'expiration d'un délai.
       <literal>wait_event</literal> identifiera le point d'attente
       spécifique&nbsp;; voir <xref linkend="wait-event-timeout-table"/>.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  &wait_event_types;

   <para>
    Voici des exemple pour voir les <foreignphrase>wait
    events</foreignphrase>&nbsp;:

    <programlisting>
SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;

 pid  | wait_event_type | wait_event
------+-----------------+------------
 2540 | Lock            | relation
 6644 | LWLock          | ProcArray
(2 rows)
</programlisting>

    <programlisting>
SELECT a.pid, a.wait_event, w.description
  FROM pg_stat_activity a JOIN
       pg_wait_events w ON (a.wait_event_type = w.type AND
                            a.wait_event = w.name)
  WHERE a.wait_event is NOT NULL and a.state = 'active';
-[ RECORD 1 ]------------------------------------------------------&zwsp;------------
pid         | 686674
wait_event  | WALInitSync
description | Waiting for a newly initialized WAL file to reach durable storage
</programlisting>
   </para>

   <note>
    <para>
     Les extensions peuvent ajouter des événements <literal>Extension</literal>,
     <literal>InjectionPoint</literal>
     et <literal>LWLock</literal> aux listes affichées dans <xref
     linkend="wait-event-extension-table"/> et
     <xref linkend="wait-event-lwlock-table"/>. Dans certains cas, le nom d'un
     <literal>LWLock</literal> affecté par une extension ne sera pas disponible
     pour tous les processus serveur. Il peut être indiqué simplement comme
     <quote><literal>extension</literal></quote> plutôt que par le nom indiqué
     par l'extension.
    </para>
   </note>
  </sect2>

  <sect2 id="monitoring-pg-stat-replication-view">
   <title><structname>pg_stat_replication</structname></title>

   <indexterm>
    <primary>pg_stat_replication</primary>
   </indexterm>

   <para>
    La vue <structname>pg_stat_replication</structname> contiendra une
    ligne par processus d'envoi de WAL, montrant des statistiques sur
    la réplication avec le serveur standby connecté au processus. Seuls
    les serveurs standby directement connectés sont listés&nbsp;; aucune
    information n'est disponible concernant les serveurs standby en aval.
   </para>

   <table id="pg-stat-replication-view" xreflabel="pg_stat_replication">
    <title>Vue <structname>pg_stat_replication</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>pid</structfield> <type>integer</type>
        </para>
        <para>
         Identifiant du processus d'envoi des WAL
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>usesysid</structfield> <type>oid</type>
        </para>
        <para>
         OID de l'utilisateur connecté à ce processus
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>usename</structfield> <type>name</type>
        </para>
        <para>
         Nom de l'utilisateur connecté à ce processus
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>application_name</structfield> <type>text</type>
        </para>
        <para>
         Nom de l'application qui est connectée à ce processus
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>client_addr</structfield> <type>inet</type>
        </para>
        <para>
         Adresse IP du client connecté à ce processus. Si ce champ est
         NULL, ceci signifie que le client est connecté via un socket Unix sur
         la machine serveur.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>client_hostname</structfield> <type>text</type>
        </para>
        <para>
         Nom de l'hôte du client connecté, comme renvoyé par une
         recherche DNS inverse sur <structfield>client_addr</structfield>. Ce
         champ sera uniquement non NULL pour les connexions IP, et seulement
         si <xref linkend="guc-log-hostname"/> est activé.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>client_port</structfield> <type>integer</type>
        </para>
        <para>
         Numéro du port TCP que le client utilise pour la
         communication avec ce processus, ou <literal>-1</literal> si un socket
         Unix est utilisée.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>backend_start</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Heure à laquelle ce processus a été démarré, exemple,
         lorsque le client s'est connecté à ce processus expéditeur
         de WALs.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>backend_xmin</structfield> <type>xid</type>
        </para>
        <para>
         L'horizon <literal>xmin</literal> de ce serveur standby
         renvoyé par <xref linkend="guc-hot-standby-feedback"/>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>state</structfield> <type>text</type>
        </para>
        <para>
         État courant du processus walsender.
         Les valeurs possibles sont&nbsp;:
         <itemizedlist>
          <listitem>
           <para>
            <literal>startup</literal>&nbsp;: Le processus walsender est en
            cours de démarrage.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>catchup</literal>&nbsp;: Le secondaire connecté au
            processus walsender est en cours de rattrapage du primaire.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>streaming</literal>&nbsp;: Ce processus walsender envoie
            les modifications au serveur secondaire connecté depuis que ce
            dernier a rattrapé le primaire.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>backup</literal>&nbsp;: Ce processus walsender est en
            train d'envoyer une sauvegarde.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>stopping</literal>&nbsp;: Ce processus walsender est en
            cours d'arrêt.
           </para>
          </listitem>
         </itemizedlist>
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>sent_lsn</structfield> <type>pg_lsn</type>
        </para>
        <para>
         La position de la dernière transaction envoyée sur cette
         connexion
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>write_lsn</structfield> <type>pg_lsn</type>
        </para>
        <para>
         La position de la dernière transaction écrite sur disque
         par ce serveur standby
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>flush_lsn</structfield> <type>pg_lsn</type>
        </para>
        <para>
         La position de la dernière transaction vidée sur disque
         par ce serveur standby
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>replay_lsn</structfield> <type>pg_lsn</type>
        </para>
        <para>
         La position de la dernière transaction rejouée dans la
         base de données par ce serveur standby
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>write_lag</structfield> <type>interval</type>
        </para>
        <para>
         Durée passée entre le vidage local des WAL récents et la réception
         de notification que ce serveur secondaire les a bien écrites (mais pas
         encore vidées ou appliquées). Ceci peut être utilisé pour mesurer le
         délai que le niveau <literal>remote_write</literal> de
         <literal>synchronous_commit</literal> coûterait lors de la validation si
         ce serveur était configuré comme un serveur secondaire
         synchrone.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>flush_lag</structfield> <type>interval</type>
        </para>
        <para>
         Durée passée entre le vidage local des WAL récents et la réception
         de notification que ce serveur secondaire les a bien écrites et vidées
         sur disque (mais pas encore appliquées). Ceci peut être utilisé pour
         mesurer le délai que le niveau <literal>on</literal> de
         <literal>synchronous_commit</literal> coûterait lors de la validation si
         ce serveur était configuré comme un serveur secondaire
         synchrone.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>replay_lag</structfield> <type>interval</type>
        </para>
        <para>
         Durée passée entre le vidage local des WAL récents et la réception
         de notification que ce serveur secondaire les a bien écrites, vidées
         sur disque et appliquées. Ceci peut être utilisé pour
         mesurer le délai que le niveau <literal>remote_apply</literal> de
         <literal>synchronous_commit</literal> coûterait lors de la validation si
         ce serveur était configuré comme un serveur secondaire
         synchrone.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>sync_priority</structfield> <type>integer</type>
        </para>
        <para>
         Priorité de ce serveur standby pour être choisi comme le serveur
         <literal>standby</literal> synchrone dans une réplication synchrone basée
         sur la priorité. Ceci n'a pas d'effet sur une réplication synchrone basée
         sur un quorum.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>sync_state</structfield> <type>text</type>
        </para>
        <para>
         État synchrone de ce serveur standby.
         Les valeurs possibles sont&nbsp;:
         <itemizedlist>
          <listitem>
           <para>
            <literal>async</literal>&nbsp;: Ce serveur standby est asynchrone.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>potential</literal>&nbsp;: Ce serveur standby est maintenant
            asynchrone, mais peut potentiellement devenir synchrone si un des
            synchrones échoue.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>sync</literal>&nbsp;: Ce serveur standby est synchrone.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>quorum</literal>&nbsp;: Ce serveur standby est considéré
            comme un candidat dans les standbys avec quorum.
           </para>
          </listitem>
         </itemizedlist>
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>reply_time</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Horodatage d'envoi du dernier message de réponse reçu par le
         standby
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Les délais rapportés dans la vue
    <structname>pg_stat_replication</structname> sont des mesures de temps
    prises pour l'écriture, le vidage sur disque et le rejeu des données
    récentes des WAL et pour que le serveur d'envoi soit mis au courant. Ces
    durées représentent le délai de validation qui a été (ou aurait été)
    introduit par chaque niveau de validation synchrone si le serveur distant
    était configuré comme un standby synchrone. Pour un standby asynchrone, la
    colonne <structfield>replay_lag</structfield> renvoie une approximation du
    délai avant que les transactions récentes deviennent visibles aux requêtes.
    Si le serveur standby a complètement rattrapé le serveur d'envoi et qu'il
    n'y a plus d'activité en écriture (donc plus de nouveaux enregistrements
    dans les journaux de transactions), les délais mesurés le plus récemment
    continueront à être affichés pendant un court instant, puis seront mis à
    NULL.
   </para>

   <para>
    Les délais fonctionnent automatiquement pour la réplication physique. Les
    plugins de décodage logique pourraient émettre des messages de trace. S'ils
    ne le font pas, le mécanisme de trace affichera simplement une valeur NULL.
   </para>

   <note>
    <para>
     Les délais rapportés ne sont pas des prédictions du temps pris par le
     serveur standby pour rattraper le serveur d'envoi en constatant le taux
     actuel de rejeu. Un tel système afficherait des temps similaires alors que
     de nouveaux journaux de transactions seraient générés, mais différeraient
     lorsque le serveur deviendrait inactif. En particulier, quand le serveur
     standby a complètement rattrapé le serveur d'envoi,
     <structname>pg_stat_replication</structname> affiche le temps pris pour
     écrire, vider sur disque et rejouer l'emplacement de l'enregistrement le
     plus récemment rapporté plutôt que zéro comme certains utilisateurs
     pourraient s'y attendre. Ceci est cohérent avec le but de mesurer les
     délais de la validation synchrone et de la visibilité des transactions
     pour les transactions récentes en écriture. Pour réduire la confusion pour
     les utilisateurs s'attendant à un autre modèle de retard, les colonnes de
     retard sont réinitialisées à NULL après un court moment sur un système
     entièrement à jour et complètement inactif. Les systèmes de supervision
     devraient choisir s'ils souhaitent représenter ces colonnes comme des
     données manquantes, des données à zéro, ou continuer à afficher la
     dernière valeur connue.
    </para>
   </note>

  </sect2>

 <sect2 id="monitoring-pg-stat-replication-slots-view">
  <title><structname>pg_stat_replication_slots</structname></title>

  <indexterm>
   <primary>pg_stat_replication_slots</primary>
  </indexterm>

  <para>
   La vue <structname>pg_stat_replication_slots</structname> contiendra
   une ligne par slot de réplication logique, montrant les statistiques de son utilisation.
  </para>

  <table id="pg-stat-replication-slots-view" xreflabel="pg_stat_replication_slots">
   <title>Vue <structname>pg_stat_replication_slots</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>slot_name</structfield> <type>text</type>
       </para>
       <para>
        Un identifiant, unique à l'instance, pour le slot de réplication
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spill_txns</structfield> <type>bigint</type>
       </para>
       <para>
        Nombre de transactions déversées sur disque une fois que la mémoire
        utilisée par le décodage logique pour décoder les changements depuis les WAL, a
        dépassé <literal>logical_decoding_work_mem</literal>. Le compteur
        est incrémenté pour à la fois les transactions de plus haut niveau et les sous-transactions.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spill_count</structfield> <type>bigint</type>
       </para>
       <para>
        Nombre de fois où des transactions sont déversées sur disque pendant le
        décodage des changements des WAL pour ce slot. Ce compteur est incrémenté chaque
        fois qu'une transaction est déversée, et une même transaction peut déverser
        plusieurs fois.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spill_bytes</structfield> <type>bigint</type>
       </para>
       <para>
        Quantité de données de transaction décodées déversées sur disque pendant
        le décodage des changements des WAL pour ce slot. Ce compteur et
        ceux liés au déversement sur disque peuvent être utilisés pour mesurer les
        E/S qui se produisent lors du décodage logique et permettre d'optimiser
        <literal>logical_decoding_work_mem</literal>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stream_txns</structfield> <type>bigint</type>
       </para>
       <para>
        Nombre de transactions en cours envoyées au plugin de sortie de décodage logique
        après que la mémoire utilisée par le décodage logique pour décoder les changements
        depuis les WAL pour ce slot a dépassé <literal>logical_decoding_work_mem</literal>.
        Le flux de réplication ne fonctionne qu'avec les transactions de plus haut niveau
        (les sous-transactions ne sont pas envoyées indépendemment), ainsi le compteur
        n'est pas incrémenté pour les sous-transactions.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stream_count</structfield><type>bigint</type>
       </para>
       <para>
        Nombre de fois ou des transactions en cours sont envoyées au plugin de sortie
        de décodage logique lors du décodage des changements depuis les WAL
        pour ce slot. Ce compteur est incrémenté chaque fois qu'une transaction est
        envoyée, et la même transaction peut être envoyée plusieurs fois.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stream_bytes</structfield><type>bigint</type>
       </para>
       <para>
        Quantité de données de transactions décodées pour les transactions en cours
        envoyées par flux au plugin de sortie de décodage logique pendant que
        des changements sont décodés pour ce slot depuis les WAL. Ce compteur et
        les compteurs similaires liés pour ce slot peuvent être utilisés
        pour optimiser <literal>logical_decoding_work_mem</literal>.
       </para>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>total_txns</structfield> <type>bigint</type>
       </para>
       <para>
        Nombre de transactions décodées envoyées au plugin de sortie de décodage
        pour ce slot. Cela ne comprend que les transactions de plus haut niveau
        pour ce slot, et ce compteur n'est pas incrémenté pour les sous-transactions.
        Notez que cela inclut les transactions qui sont envoyées par flux et/ou
        déversées sur disque.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>total_bytes</structfield><type>bigint</type>
       </para>
       <para>
        Quantité de données de transactions décodées pour envoyer les transactions
        au plugin de sortie de décodage pendant que les changements sont décodés
        depuis les WAL pour ce slot.
        Notez que cela inclut les transactions qui sont envoyées par flux et/ou
        déversées sur disque.
       </para>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
       </para>
       <para>
        Date où ces statistiques ont été remises à zéro.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

  <sect2 id="monitoring-pg-stat-wal-receiver-view">
   <title><structname>pg_stat_wal_receiver</structname></title>

   <indexterm>
    <primary>pg_stat_wal_receiver</primary>
   </indexterm>

   <para>
    La vue <structname>pg_stat_wal_receiver</structname> contiendra seulement
    une ligne, affichant les statistiques du walreceiver du serveur de
    connexion.
   </para>

   <table id="pg-stat-wal-receiver-view" xreflabel="pg_stat_wal_receiver">
    <title>Vue <structname>pg_stat_wal_receiver</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>pid</structfield> <type>integer</type>
        </para>
        <para>
         Identifiant du processus de réception des enregistrements de
         transaction
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>status</structfield> <type>text</type>
        </para>
        <para>
         Statut d'activité du processus walreceiver
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>receive_start_lsn</structfield> <type>pg_lsn</type>
        </para>
        <para>
         Première position dans le journal de transaction utilisée
         quand walreceiver a été démarré
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>receive_start_tli</structfield> <type>integer</type>
        </para>
        <para>
         Première ligne de temps utilisée quand walreceiver a été démarré
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>written_lsn</structfield> <type>pg_lsn</type>
        </para>
        <para>
         Dernier emplacement dans les journaux de transactions ayant déjà été
         reçu et écrit sur disque, mais non vidé du cache. Ceci ne doit pas être
         utilisé pour des vérifications sur l'intégrité des données.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>flushed_lsn</structfield> <type>pg_lsn</type>
        </para>
        <para>
         Dernier emplacement dans les journaux de transactions ayant déjà été
         reçu et écrit sur disque, et le cache vidé, la valeur initiale de ce
         champ étant le premier emplacement utilisé lorsque le processus
         walreceiver a été démarré.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>received_tli</structfield> <type>integer</type>
        </para>
        <para>
         Numéro de la ligne de temps de la dernière position des journaux
         de transactions, déjà reçue et écrite sur disque, la valeur initiale de
         ce champ étant la ligne de temps de la première position dans les
         journaux de transactions utilisée lors du démarrage du
         walreceiver
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>last_msg_send_time</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Horodatage d'envoi du dernier message reçu à partir du walsender
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>last_msg_receipt_time</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Horodatage de la réception du dernier message à partir du walsender
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>latest_end_lsn</structfield> <type>pg_lsn</type>
        </para>
        <para>
         Dernière position de transaction reportée par le walsender associé
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>latest_end_time</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Horodatage de la dernière position de transaction reportée par le
         walsender associé
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>slot_name</structfield> <type>text</type>
        </para>
        <para>
         Nom du slot de réplication utilisé par ce walreceiver
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>sender_host</structfield> <type>text</type>
        </para>
        <para>
         Hôte de l'instance <productname>PostgreSQL</productname> auquel ce processus
         <quote>wal receiver</quote> est connecté. Il peut s'agir d'un nom d'hôte,
         d'une adresse <literal>IP</literal> ou d'un chemin d'accès à un répertoire
         si la connexion se fait via un socket Unix (dans ce dernier cas, il est facile
         de le distinguer car il s'agira toujours d'un chemin absolu débutant
         par le caractère (<literal>/</literal>).)
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>sender_port</structfield> <type>integer</type>
        </para>
        <para>
         Numéro de port de l'instance <productname>PostgreSQL</productname> auquel
         wal receiver est connecté.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>conninfo</structfield> <type>text</type>
        </para>
        <para>
         Chaîne de connexion utilisée par ce wal receiver, les informations sensibles
         au niveau sécurité sont cachés.
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="monitoring-pg-stat-recovery-prefetch">
   <title><structname>pg_stat_recovery_prefetch</structname></title>

   <indexterm>
    <primary>pg_stat_recovery_prefetch</primary>
   </indexterm>

   <para>
    La vue <structname>pg_stat_recovery_prefetch</structname> contiendra une
    seule ligne. Les colonnes <structfield>wal_distance</structfield>,
    <structfield>block_distance</structfield> et
    <structfield>io_depth</structfield> affichent les valeurs actuelles et les
    autres colonnes affichent des compteurs cumulatifs qui peuvent être
    réinitialisés avec la fonction <function>pg_stat_reset_shared</function>.
   </para>

   <table id="pg-stat-recovery-prefetch-view" xreflabel="pg_stat_recovery_prefetch">
    <title>Vue <structname>pg_stat_recovery_prefetch</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry">
        <para role="column_definition">
         <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Horodatage de la dernière réinitialisation de ces statistiques
        </para>
       </entry>
      </row>

      <row>
       <entry role="catalog_table_entry">
        <para role="column_definition">
         <structfield>prefetch</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs lus en avance parce qu'ils n'étaient pas dans le cache
        </para>
       </entry>
      </row>

      <row>
       <entry role="catalog_table_entry">
        <para role="column_definition">
         <structfield>hit</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs non lus en avance parce qu'ils étaient déjà dans le
         cache
        </para>
       </entry>
      </row>

      <row>
       <entry role="catalog_table_entry">
        <para role="column_definition">
         <structfield>skip_init</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs non lus dans le cache parce qu'ils devaient être
         initialisés à zéro
        </para>
       </entry>
      </row>

      <row>
       <entry role="catalog_table_entry">
        <para role="column_definition">
         <structfield>skip_new</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs non lus dans le cache parce qu'ils n'existaient pas
         encore
        </para>
       </entry>
      </row>

      <row>
       <entry role="catalog_table_entry">
        <para role="column_definition">
         <structfield>skip_fpw</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs non lus dans le cache parce qu'une image complète d'un
         bloc a été inclus dans le WAL
        </para>
       </entry>
      </row>

      <row>
       <entry role="catalog_table_entry">
        <para role="column_definition">
         <structfield>skip_rep</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs non lus dans le cache parce qu'ils avaient été
         récemment lus en avance
        </para>
       </entry>
      </row>

      <row>
       <entry role="catalog_table_entry">
        <para role="column_definition">
         <structfield>wal_distance</structfield> <type>int</type>
        </para>
        <para>
         Nombre d'octets que le prefetcher recherche
        </para>
       </entry>
      </row>

      <row>
       <entry role="catalog_table_entry">
        <para role="column_definition">
         <structfield>block_distance</structfield> <type>int</type>
        </para>
        <para>
         Nombre de blocs que le prefetcher recherche
        </para>
       </entry>
      </row>

      <row>
       <entry role="catalog_table_entry">
        <para role="column_definition">
         <structfield>io_depth</structfield> <type>int</type>
        </para>
        <para>
         Nombre de lectures en avance initiées mais pas encore terminées
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

  <sect2 id="monitoring-pg-stat-subscription">
   <title><structname>pg_stat_subscription</structname></title>

   <indexterm>
    <primary>pg_stat_subscription</primary>
   </indexterm>

   <para>
    La vue <structname>pg_stat_subscription</structname> contiendra une ligne
    par souscription du worker principal (avec le PID NULL si le processus
    worker n'est pas en cours d'exécution), et des lignes supplémentaires pour
    les workers gérant la copie initiale de données des tables souscrites.
   </para>

   <table id="pg-stat-subscription" xreflabel="pg_stat_subscription">
    <title>Vue <structname>pg_stat_subscription</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>subid</structfield> <type>oid</type>
        </para>
        <para>
         OID de la souscription
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>subname</structfield> <type>name</type>
        </para>
        <para>
         Nom de la souscription
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>worker_type</structfield> <type>text</type>
       </para>
       <para>
        Type de processus worker pour la souscription. Les types possibles sont
        <literal>apply</literal>, <literal>parallel apply</literal> et
        <literal>table synchronization</literal>.
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>pid</structfield> <type>integer</type>
        </para>
        <para>
         Identifiant du processus worker de la souscription
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>leader_pid</structfield> <type>integer</type>
       </para>
       <para>
        Identifiant du processus leader si ce processus est un worker
        d'application parallélisé&nbsp;; NULL si ce processus est un worker
        d'application autonome ou un worker de synchronisation de table
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>relid</structfield> <type>oid</type>
        </para>
        <para>
         OID de la relation que le processus worker synchronise&nbsp;;
         NULL pour le processus worker apply principal et ses workers
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>received_lsn</structfield> <type>pg_lsn</type>
        </para>
        <para>
         Dernier emplacement de journal de transactions reçu, la valeur
         initiale de ce champ étant 0&nbsp;; NULL pour les workers apply
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>last_msg_send_time</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Horodatage d'envoi du dernier message reçu à partir du walsender
         original&nbsp;; NULL pour les workers apply
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>last_msg_receipt_time</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Horodatage de réception du dernier message reçu du walsender
         original&nbsp;; NULL pour les workers apply
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>latest_end_lsn</structfield> <type>pg_lsn</type>
        </para>
        <para>
         Dernier emplacement des journaux de transactions rapporté par le
         walsender original&nbsp;; NULL pour les workers apply
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>latest_end_time</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Horodatage du dernier emplacement de journal de transactions
         rapporté par le walsender original
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="monitoring-pg-stat-subscription-stats">
   <title><structname>pg_stat_subscription_stats</structname></title>

   <indexterm>
    <primary>pg_stat_subscription_stats</primary>
   </indexterm>

   <para>
    La vue <structname>pg_stat_subscription_stats</structname> contiendra une
    ligne par souscription.
   </para>

   <table id="pg-stat-subscription-stats" xreflabel="pg_stat_subscription_stats">
    <title>Vue <structname>pg_stat_subscription_stats</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        Type de colonne
       </para>
       <para>
        Description
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>subid</structfield> <type>oid</type>
       </para>
       <para>
        OID de la souscription
       </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>subname</structfield> <type>name</type>
       </para>
       <para>
        Nom de la souscription
       </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>apply_error_count</structfield> <type>bigint</type>
       </para>
       <para>
        Nombre de fois où une erreur est survenue lors de l'application des
        modifications
       </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>sync_error_count</structfield> <type>bigint</type>
       </para>
       <para>
        Nombre de fois où une erreur est survenue lors de la synchronisation
        initiale de la table
       </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
       </para>
       <para>
        Horodatage de la dernière réinitialisation de ces statistiques
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

  <sect2 id="monitoring-pg-stat-ssl-view">
   <title><structname>pg_stat_ssl</structname></title>

   <indexterm>
    <primary>pg_stat_ssl</primary>
   </indexterm>

   <para>
    La vue <structname>pg_stat_ssl</structname> contiendra une
    ligne par backend ou processus d'envoi de WAL, montrant
    des statistiques sur l'usage de SSL dans cette connexion. Elle
    peut être jointe à <structname>pg_stat_activity</structname>
    ou <structname>pg_stat_replication</structname> sur la colonne
    <structfield>pid</structfield> pour obtenir plus de détails sur
    la connexion.
   </para>

   <table id="pg-stat-ssl-view" xreflabel="pg_stat_ssl">
    <title>Vue <structname>pg_stat_ssl</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>pid</structfield> <type>integer</type>
        </para>
        <para>
         ID du processus backend ou du processus d'envoi de WAL
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>ssl</structfield> <type>boolean</type>
        </para>
        <para>
         True si SSL est utilisé dans cette connexion
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>version</structfield> <type>text</type>
        </para>
        <para>
         Version de SSL utilisée, ou NULL si SSL n'est pas utilisé
         pour cette connexion
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>cipher</structfield> <type>text</type>
        </para>
        <para>
         Nom du chiffrement SSL utilisé, ou NULL si SSL n'est pas
         utilisé pour cette connexion
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>bits</structfield> <type>integer</type>
        </para>
        <para>
         Nombre de bits dans l'algorithme de chiffrement utilisé,
         ou NULL si SSL n'est pas utilisé pour cette connexion
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>client_dn</structfield> <type>text</type>
        </para>
        <para>
         Champ Distinguished Name (DN) utilisé par le certificat du
         client, ou NULL si aucun certificat client n'a été fourni ou si
         SSL n'est pas utilisé pour cette connexion. Ce champ est tronqué
         si le champ DN est plus long que <symbol>NAMEDATALEN</symbol>
         (64 caractères dans une compilation standard).
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>client_serial</structfield> <type>numeric</type>
        </para>
        <para>
         Numéro de série du certificat client ou NULL si aucun certificat
         n'a été fourni ou si le SSL n'est pas utilisé dans cette connexion. La
         combinaison du numéro de série du certification et de l'émetteur du
         certificat identifie de façon unique un certificat (sauf si l'émetteur
         réutilise par erreur les numéros de série).
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>issuer_dn</structfield> <type>text</type>
        </para>
        <para>
         DN de l'émetteur du certificat client ou NULL si aucun certificat
         client n'a été fourni ou si le SSL n'est pas utilisé dans cette
         connexion. Ce champ est tronqué comme
         <structfield>client_dn</structfield>.
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="monitoring-pg-stat-gssapi-view">
   <title><structname>pg_stat_gssapi</structname></title>

   <indexterm>
    <primary>pg_stat_gssapi</primary>
   </indexterm>

   <para>
    La vue <structname>pg_stat_gssapi</structname> contient une ligne par
    processus serveur, affichant des informations sur l'utilisation de GSSAPI
    pour cette connexion. Elle peut être jointe à
    <structname>pg_stat_activity</structname> ou
    <structname>pg_stat_replication</structname> sur la colonne
    <structfield>pid</structfield> pour obtenir plus de détails sur la
    connexion.
   </para>

   <table id="pg-stat-gssapi-view" xreflabel="pg_stat_gssapi">
    <title>Vue <structname>pg_stat_gssapi</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>pid</structfield> <type>integer</type>
        </para>
        <para>
         Identifiant du processus serveur
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>gss_authenticated</structfield> <type>boolean</type>
        </para>
        <para>
         True si l'authentification GSSAPI a été utilisée pour cette connexion
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>principal</structfield> <type>text</type>
        </para>
        <para>
         Principal utilisé pour authentifier cette connexion, ou NULL si
         GSSAPI n'a pas été utilisé pour authentifier cette connexion. Ce champ
         est tronqué si le principal est plus long que
         <symbol>NAMEDATALEN</symbol> (64 caractères dans une construction
         standard).
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>encrypted</structfield> <type>boolean</type>
        </para>
        <para>
         True si le chiffrement GSSAPI est utilisé avec cette connexion
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>credentials_delegated</structfield> <type>boolean</type>
       </para>
       <para>
        Vrai si les informations d'identification GSSAPI ont été déléguées sur
        cette connexion.
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="monitoring-pg-stat-archiver-view">
   <title><structname>pg_stat_archiver</structname></title>

   <indexterm>
    <primary>pg_stat_archiver</primary>
   </indexterm>

   <para>
    La vue <structname>pg_stat_archiver</structname> aura toujours une seule
    ligne contenant les données du processus d'archivage de l'instance.
   </para>

   <table id="pg-stat-archiver-view" xreflabel="pg_stat_archiver">
    <title>Vue <structname>pg_stat_archiver</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>archived_count</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de journaux de transactions archivés avec succès
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>last_archived_wal</structfield> <type>text</type>
        </para>
        <para>
         Nom du plus récent journal de transaction archivé avec succès
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>last_archived_time</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Horodatage de la plus récente opération d'archivage réussie
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>failed_count</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre d'échecs d'archivage de journaux de transactions
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>last_failed_wal</structfield> <type>text</type>
        </para>
        <para>
         Nom du journal de transactions correspondant au plus récent archivage
         échoué
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>last_failed_time</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Horodatage de la plus récente  opération d'archivage échouée
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Horodatage de la dernière réinitialisation de ces statistiques
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Habituellement, les fichiers WAL sont archivés dans l'ordre, du plus
    ancien ou plus récent, mais ceci n'est pas garanti et ne tient pas sous
    certaines circonstances, comme lors de la promotion d'un serveur secondaire
    ou lors d'une restauration après crash. De ce fait, il n'est pas garanti que
    tous les fichiers plus anciens que
    <structfield>last_archived_wal</structfield> aient été correctement archivés.
   </para>

  </sect2>

 <sect2 id="monitoring-pg-stat-io-view">
  <title><structname>pg_stat_io</structname></title>

  <indexterm>
   <primary>pg_stat_io</primary>
  </indexterm>

  <para>
   La vue <structname>pg_stat_io</structname> contient une ligne pour chaque
   combinaisons de type de processusn objet cible d'entrées/sorties disques,
   et contexte d'entrées/sorties disques, affichant des statistiques sur
   l'utilisation des entrées/sorties disques par l'instance. Les combinaisons
   qui n'ont pas de sens sont omises.
  </para>

  <para>
   Actuellement, les entrées/sorties disques sur des relations (par exemple,
   tables, index) sont tracées. Néanmoins, les entrées/sorties disques qui
   ne passent pas par le cache disque (par exemple lors du déplacement
   d'une table d'un tablespace à un autre) ne sont pas actuellement tracées.
  </para>

  <table id="pg-stat-io-view" xreflabel="pg_stat_io">
   <title>Vue de <structname>pg_stat_io</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        Type de colonne
       </para>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>backend_type</structfield> <type>text</type>
       </para>
       <para>
        Type de processus backend (par exemple un background worker, un autovacuum
        worker). Voir <link
        linkend="monitoring-pg-stat-activity-view">
        <structname>pg_stat_activity</structname></link> pour plus d'informations
        sur les différents <varname>backend_type</varname>. Certains
        <varname>backend_type</varname> n'accumulent pas de statistiques sur les
        entrées/sorties disques et ne seront pas inclus dans la vue.
       </para>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>object</structfield> <type>text</type>
       </para>
       <para>
        Objet cible d'une opération d'entrées/sorties disques. Les valeurs
        possibles sont&nbsp;:
       <itemizedlist>
        <listitem>
         <para>
          <literal>relation</literal>&nbsp;: relations permanentes.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>temp relation</literal>&nbsp;: relations temporaires.
         </para>
        </listitem>
       </itemizedlist>
       </para>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>context</structfield> <type>text</type>
       </para>
       <para>
        Le contexte d'une opération d'entrées/sorties disques. Les valeurs
        possibles sont&nbsp;:
       </para>
       <itemizedlist>
        <listitem>
         <para>
          <literal>normal</literal>&nbsp;: Le <varname>context</varname> par défaut
          ou standard pour un type d'opérations d'entrées/sorties disques. Par
          exemple, par défaut, les données des relation sont lues et écrites via
          le cache disque. De ce fait, les lectures et écritures des données
          des relations à partir du cache sont tracées dans le
          <varname>context</varname> <literal>normal</literal>.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>vacuum</literal>&nbsp;: les opérations d'entrées/sorties disques
          réalisées en dehors du cache disque lors du nettoyage et de l'analyse
          des relations permanentes. Le nettoyage des tables temporaires
          utilisent le même cache local que les autres opérations d'entrées/sorties
          disques des tables temporaires et sont tracées dans le
          <varname>context</varname> <literal>normal</literal>.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>bulkread</literal>&nbsp;: certaines grosses opérations de
          lecture faites en dehors du cache disque, par exemple pour un parcours
          séquentiel d'une grosse table.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>bulkwrite</literal>&nbsp;: certaines grosses opérations
          d'écriture faites en dehors du cache disque, telles que
          <command>COPY</command>.
         </para>
        </listitem>
       </itemizedlist>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>reads</structfield> <type>bigint</type>
       </para>
       <para>
        Nombre d'opérations de lectures, chacune de la taille indiquée dans
        <varname>op_bytes</varname>.
       </para>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>read_time</structfield> <type>double precision</type>
       </para>
       <para>
        Temps passés aux opérations de lecture en millisecondes (si
        <xref linkend="guc-track-io-timing"/> est activé, sinon zéro)
       </para>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>writes</structfield> <type>bigint</type>
       </para>
       <para>
        Nombre d'opérations d'écritures, chacune de la taille indiquée dans
        <varname>op_bytes</varname>.
       </para>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>write_time</structfield> <type>double precision</type>
       </para>
       <para>
        Temps passés aux opérations d'écriture en millisecondes (si
        <xref linkend="guc-track-io-timing"/> est activé, sinon zéro)
       </para>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>writebacks</structfield> <type>bigint</type>
       </para>
       <para>
        Nombre d'unités de la taille <varname>op_bytes</varname> que le
        processus a réclamé au noyau pour une écriture sur un stockage permanent.
       </para>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>writeback_time</structfield> <type>double precision</type>
       </para>
       <para>
        Temps passé en opérations de réécriture en millisecondes (si
        <xref linkend="guc-track-io-timing"/> est activé, sinon zéro). Ceci
        inclut le temps passé en queue pour les demandes d'écriture et,
        potentiellement, le temps passé à écrire des données modifiées.
       </para>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>extends</structfield> <type>bigint</type>
       </para>
       <para>
        Nombre d'opérations d'agrandissement de relations, chacune de la taille
        spécifiée dans <varname>op_bytes</varname>.
       </para>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>extend_time</structfield> <type>double precision</type>
       </para>
       <para>
        Temps passé dans des opérations d'agrandissement en millisecondes (si
        <xref linkend="guc-track-io-timing"/> est activé, sinon zéro)
       </para>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>op_bytes</structfield> <type>bigint</type>
       </para>
       <para>
        Nombre d'octets par unité de lecture, écriture ou agrandissement.
       </para>
       <para>
        Les lectures, écritures et agrandissements des relations sont faites
        dans des unités de <varname>block_size</varname>, dérivées à partir
        du paramètre de compilation <symbol>BLCKSZ</symbol>, qui vaut par
        défaut <literal>8192</literal>.
       </para>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>hits</structfield> <type>bigint</type>
       </para>
       <para>
        Nombre de fois qu'un bloc désiré a été trouvé dans le cache disque.
       </para>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>evictions</structfield> <type>bigint</type>
       </para>
       <para>
        Nombre de fois qu'un bloc a été écrit à partir d'un cache partagé ou local
        pour le rendre disponible à d'autres utilisations.
       </para>
       <para>
        Dans un <varname>context</varname> <literal>normal</literal>, cela compte
        le nombre de fois où un bloc a été enlevé d'un cache et remplacé par un
        autre bloc. Dans les contextes <literal>bulkwrite</literal>,
        <literal>bulkread</literal> et <literal>vacuum</literal>, cela compte le
        nombre de fois où un bloc a été enlevé du cache partagé pour ajouter le bloc
        dans un buffer séparé de taille limitée pour une utilisation dans le cas
        d'opération d'entrées/sorties disques en masse.
        </para>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>reuses</structfield> <type>bigint</type>
       </para>
       <para>
        Le nombre de fois où un buffer existant dans un buffer de taille limité a
        été réutilisé dans le cadre d'une opération d'entrées/sorties disques des
        contextes <literal>bulkread</literal>, <literal>bulkwrite</literal> ou
        <literal>vacuum</literal>.
       </para>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>fsyncs</structfield> <type>bigint</type>
       </para>
       <para>
        Nombre d'appels à <literal>fsync</literal>. Ils sont tracés uniquement
        dans le <varname>context</varname> <literal>normal</literal>.
       </para>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>fsync_time</structfield> <type>double precision</type>
       </para>
       <para>
        Temps passé dans les opérations fsync en millisecondes (si
        <xref linkend="guc-track-io-timing"/> est activé, sinon zéro)
       </para>
      </entry>
     </row>

     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
       </para>
       <para>
        Horodatage de la dernière réinitialisation des statistiques.
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Certains types de processus backend ne réalisent jamais d'opérations
   d'entrées/sorties sur certains objets et/ou certains contextes. Ces lignes
   sont omises de la vue. Par exemple, le checkpointer ne s'occupe pas des
   tables temporaires, donc il n'y aura pas de lignes pour
   <varname>backend_type</varname> <literal>checkpointer</literal> et
   <varname>object</varname> <literal>temp relation</literal>.
  </para>

  <para>
   De plus, certaines opérations d'entrées/sorties disques ne seront jamais
   réalisées, soit par certains types de backends soit par certains objets
   soit par certains contextes. Ces cellules seront à NULL. Par exemple, les
   tables temporaires ne sont jamais synchronisées sur disque
   (<literal>fsync</literal>), donc la colonne <varname>fsyncs</varname> sera
   à  NULL pour <varname>object</varname> <literal>temp relation</literal>. De
   plus, le background writer ne fait pas de lectures, donc la colonne
   <varname>reads</varname> seront NULL pour les lignes
   <varname>backend_type</varname> <literal>background writer</literal>.
  </para>

  <para>
   <structname>pg_stat_io</structname> peut être utilisé pour informer
   sur l'optimisation de la base.
   Par exemple&nbsp;:
   <itemizedlist>
    <listitem>
     <para>
      Un grand nombre d'<varname>évictions</varname> peut indiquer que le cache
      disque (paramètre <literal>shared_buffers</literal>) doit être
      augmenté.
     </para>
    </listitem>
    <listitem>
     <para>
      Les backends clients se basent sur le checkpointer pour s'assurer que
      les données sont enregistrées sur un stockage permanent. De grands nombres
      pour <varname>fsyncs</varname> pour <literal>client backend</literal>
      pourrait indiquer une mauvaise configuration du cache disque ou du
      checkpointer. Il existe plus d'informations sur la configuration du
      checkpointer dans <xref linkend="wal-configuration"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      Habituellement, les backends client doivent être capable de se baser sur
      les processus auxiliaires tels que le checkpointer et le background writer
      pour écrire autant que possible les données modifiées. De grands nombres d'écritures par des backends clients peuvent indiquer une mauvaise
      configuration du cache disque ou du checkpointer. Plus d'informations sur
      le checkpointer sont disponibles dans <xref linkend="wal-configuration"/>.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <note>
   <para>
    Les colonnes traçant les durées des entrées/sorties disques seront à des
    valeurs différentes de zéro si <xref linkend="guc-track-io-timing"/> est
    activé. L'utilisateur doit faire attention lors de l'utilisation de ces
    colonnes avec celles opérations d'entrée/sorties disqe correspondantes
    au cas où <varname>track_io_timing</varname> n'était pas activé en
    permanence depuis la dernière réinitialisation des statistiques.
   </para>
  </note>
  </sect2>

  <sect2 id="monitoring-pg-stat-bgwriter-view">
   <title><structname>pg_stat_bgwriter</structname></title>

   <indexterm>
    <primary>pg_stat_bgwriter</primary>
   </indexterm>

   <para>
    La vue <structname>pg_stat_bgwriter</structname> aura toujours une ligne
    unique, contenant les données sur le processus <literal>background
    writer</literal> de l'instance.
   </para>

   <table id="pg-stat-bgwriter-view" xreflabel="pg_stat_bgwriter">
    <title>Vue <structname>pg_stat_bgwriter</structname></title>

    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>buffers_clean</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de tampons écrits par le processus background writer
         (processus d'écriture en tâche de fond)
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>maxwritten_clean</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de fois que le processus background writer a arrêté
         son parcours de nettoyage pour avoir écrit trop de tampons
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>buffers_alloc</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de tampons alloués
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Dernière fois que ces statistiques ont été réinitialisées
        </para></entry>
       </row>
      </tbody>
     </tgroup>
    </table>
  
   </sect2>
  
   <sect2 id="monitoring-pg-stat-checkpointer-view">
    <title><structname>pg_stat_checkpointer</structname></title>
  
    <indexterm>
     <primary>pg_stat_checkpointer</primary>
    </indexterm>
  
    <para>
     La vue <structname>pg_stat_checkpointer</structname> aura toujours une
     seule ligne, contenant des données sur le processus checkpointer de
     l'instance.
    </para>
  
    <table id="pg-stat-checkpointer-view" xreflabel="pg_stat_checkpointer">
     <title>Vue <structname>pg_stat_checkpointer</structname></title>
     <tgroup cols="1">
      <thead>
       <row>
        <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
       </row>
      </thead>
  
      <tbody>
       <row>
        <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>num_timed</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de checkpoints planifiés suite au dépassement du délai.
         Notez que les checkpoints peuvent être ignorés si le serveur a été
         inactif depuis le dernier checkpoint. Cette valeur compte à la fois
         les checkpoints réalisés et les checkpoints ignorés
        </para></entry>
       </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>num_requested</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de checkpoints réclamés et réalisés
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>restartpoints_timed</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de restartpoints planifiés suit à un dépassement de délai ou
       à une tentative échouée
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>restartpoints_req</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de restartpoints réclamés
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>restartpoints_done</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de restartpoints réalisés
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>write_time</structfield> <type>double precision</type>
      </para>
      <para>
       Durée totale passée dans la portion de traitement des checkpoints et
       restartpoints où des fichiers ont été écrits sur disque, en millisecondes
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sync_time</structfield> <type>double precision</type>
      </para>
      <para>
       Durée totale passée dans la portion de traitement des checkpoints et
       restartpoints où des fichiers ont été synchronisés sur disque, en
       millisecondes
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_written</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de buffers écrits lors des checkpoints et restartpoints
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Horodatage de la dernière réinitialisation de ces statistiques
      </para></entry>
     </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

 <sect2 id="monitoring-pg-stat-wal-view">
   <title><structname>pg_stat_wal</structname></title>

  <indexterm>
   <primary>pg_stat_wal</primary>
  </indexterm>

  <para>
   La vue <structname>pg_stat_wal</structname> a toujours une ligne,
   contenant les données sur l'activité des journaux de transaction de
   l'instance.
  </para>

  <table id="pg-stat-wal-view" xreflabel="pg_stat_wal">
   <title>Vue <structname>pg_stat_wal</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Type de la colonne
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_records</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre total d'enregistrements générés dans les journaux de transaction
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_fpi</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre total d'images de pages complètes générées dans les journaux de
       transactions
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_bytes</structfield> <type>numeric</type>
      </para>
      <para>
       Quantité totale de journaux de transactions générés en octets.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_buffers_full</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de fois où des données de journaux de transactions ont été
       écrites sur disque parce que le cache des journaux de transactions était
       rempli
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_write</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de fois où les tampons de journaux de transactions ont été écrits
       sur disque via des appels à <function>XLogWrite</function>.
       Voir <xref linkend="wal-configuration"/> pour plus d'informations sur la
       fonction interne de journaux de transactions
       <function>XLogWrite</function>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_sync</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de fois où les fichiers des journaux de transactions ont été
       synchronisés sur disque via des appels à
       <function>issue_xlog_fsync</function> (si
       <xref linkend="guc-fsync"/> est à <literal>on</literal> et
       <xref linkend="guc-wal-sync-method"/> vaut soit
       <literal>fdatasync</literal>, <literal>fsync</literal> soit
       <literal>fsync_writethrough</literal>), sinon zéro.
       Voir <xref linkend="wal-configuration"/> pour plus d'informations sur la
       fonction interne des journaux de transaction
       <function>issue_xlog_fsync</function>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_write_time</structfield> <type>double precision</type>
      </para>
      <para>
       Temps total dépensé à l'écriture du cache des journaux de transactions
       sur disque via des appels à <function>XLogWrite</function>, en
       millisecondes (si <xref linkend="guc-track-wal-io-timing"/> est activé,
       sinon zéro). Cela inclut le temps de synchronisation quand
       <varname>wal_sync_method</varname> vaut soit
       <literal>open_datasync</literal> soit <literal>open_sync</literal>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_sync_time</structfield> <type>double precision</type>
      </para>
      <para>
       Temps total dépensé à synchroniser les fichiers des journaux de
       transactions vers le disque via des appels à
       <function>issue_xlog_fsync</function>, en millisecondes
       (si <varname>track_wal_io_timing</varname> est activé, et
       <varname>fsync</varname> vaut <literal>on</literal>, et
       <varname>wal_sync_method</varname> vaut soit
       <literal>fdatasync</literal>, soit <literal>fsync</literal> soit
       <literal>fsync_writethrough</literal>). Sinon zéro.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Date où ces statistiques ont été remises à zéro
      </para></entry>
     </row>
     </tbody>
   </tgroup>
  </table>

</sect2>

  <sect2 id="monitoring-pg-stat-database-view">
   <title><structname>pg_stat_database</structname></title>

   <indexterm>
    <primary>pg_stat_database</primary>
   </indexterm>

   <para>
    La vue <structname>pg_stat_database</structname> ne contiendra qu'une ligne
    pour chaque base de données dans l'instance, plus une pour les objets
    partagés, montrant ses statistiques globales.
   </para>

   <table id="pg-stat-database-view" xreflabel="pg_stat_database">
    <title>Vue <structname>pg_stat_database</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>datid</structfield> <type>oid</type>
        </para>
        <para>
         OID d'une base de données, ou 0 pour les objets partagés
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>datname</structfield> <type>name</type>
        </para>
        <para>
         Nom de cette base de données, or <literal>NULL</literal> pour les objets
         partagés
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>numbackends</structfield> <type>integer</type>
        </para>
        <para>
         Nombre de processus serveur actuellement connectés à cette base de
         données, ou <literal>NULL</literal> pour les objets partagés. C'est la
         seule colonne de cette vue qui renvoie une valeur reflétant l'état
         actuel&nbsp;; toutes les autres colonnes renvoient les valeurs
         accumulées depuis la dernière réinitialisation
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>xact_commit</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de transactions de cette base de données qui ont été
         validées
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>xact_rollback</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de transactions de cette base de données qui ont été
         annulées
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>blks_read</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs disques lus dans cette base de données
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>blks_hit</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de fois que des blocs disques étaient déjà dans le cache tampon,
         et qu'il n'a donc pas été nécessaire de les lire sur disque (cela
         n'inclut que les accès dans le cache tampon de PostgreSQL, pas dans le
         cache de fichiers du système d'exploitation).
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>tup_returned</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de lignes vivantes récupérées par des parcours séquentiels et par
         des enregistrements d'index renvoyés par les parcours d'index dans
         cette base
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>tup_fetched</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de lignes vivantes récupérées par les parcours d'index dans
         cette base
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>tup_inserted</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de lignes insérées par des requêtes dans cette base de données
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>tup_updated</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de lignes mises à jour par des requêtes dans cette base de données
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>tup_deleted</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de lignes supprimées par des requêtes dans cette base de données
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>conflicts</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de requêtes annulées à cause de conflits avec la restauration dans cette
         base de données. (Les conflits n'arrivent que sur des serveurs de standby&nbsp;; voir
         <link linkend="monitoring-pg-stat-database-conflicts-view">
          <structname>pg_stat_database_conflicts</structname></link> pour plus de détails.)
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>temp_files</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de fichiers temporaires créés par des requêtes dans cette base
         de données. Tous les fichiers temporaires sont comptabilisés, quel que soit
         la raison de la création du fichier temporaire (par exemple, un tri ou un hachage) et
         quel que soit la valeur du paramètre <xref linkend="guc-log-temp-files"/>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>temp_bytes</structfield> <type>bigint</type>
        </para>
        <para>
         Quantité totale de données écrites dans des fichiers temporaires
         par des requêtes dans cette base de données. Tous les fichiers
         temporaires sont comptabilisés, quel que soit la raison de la création
         de ce fichier temporaire, et de la valeur du paramètre
         <xref linkend="guc-log-temp-files"/>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>deadlocks</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de verrous mortels détectés dans cette base de données
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>checksum_failures</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre d'échecs pour la vérification des sommes de contrôle détectés sur
         cette base de données (ou sur un objet partagé), ou NULL si les sommes de
         contrôle ne sont pas activées.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>checksum_last_failure</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Horodatage du dernier échec de vérification de somme de contrôle
         pour un bloc détecté dans cette base (ou sur un objet partagé), ou NULL
         si les sommes de contrôle ne sont pas activés.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>blk_read_time</structfield> <type>double precision</type>
        </para>
        <para>
         Temps passé à lire des blocs de donnée dans des fichiers par des
         processus serveur dans cette base de données, en millisecondes
         (si <xref linkend="guc-track-io-timing"/> est activé, sinon zéro)
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>blk_write_time</structfield> <type>double precision</type>
        </para>
        <para>
         Temps passé à écrire des blocs de données dans des fichiers par
         les processus serveur dans cette base de données, en millisecondes
         (si <xref linkend="guc-track-io-timing"/> est activé, sinon zéro)
        </para></entry>
      </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>session_time</structfield> <type>double precision</type>
      </para>
      <para>
       Temps passé à écrire par les sessions de cette base de données, en
       millisecondes (notez que les statistiques sont seulement mises à jour
       quand l'état d'une session change, ainsi si des sessions ont été
       inactives longtemps, ce temps d'inactivité ne sera pas inclus)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>active_time</structfield> <type>double precision</type>
      </para>
      <para>
       Temps passé à exécuter des expressions SQL dans cette base de données,
       en millisecondes (ceci correspond à l'état <literal>actif</literal> ainsi
       qu'à l'<literal>appel de fonction fastpath</literal> dans
       <link linkend="monitoring-pg-stat-activity-view">
       <structname>pg_stat_activity</structname></link>)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idle_in_transaction_time</structfield> <type>double precision</type>
      </para>
      <para>
       Temps passé inactif dans une transaction dans cette base de données, en
       millisecondes (cela correspond aux états <literal>inactif dans une
       transaction</literal> (<quote>idle in transaction</quote>) et
       <literal>inactif dans une transaction (annulé)</literal>
       (<quote>idle in transaction (aborted)</quote>) dans <link
       linkend="monitoring-pg-stat-activity-view"><structname>pg_stat_activity</structname></link>)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre total de sessions établies dans cette base de données
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions_abandoned</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de sessions dans cette base de données qui ont été terminées
       parce que la connexion au client a été perdue
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions_fatal</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de sessions dans cette base de données qui ont été terminées
       par des erreurs fatales
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions_killed</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de sessions dans cette base de données qui ont été terminées
       par l'intervention d'un opérateur
      </para></entry>
     </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Dernière fois que ces statistiques ont été réinitialisées
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="monitoring-pg-stat-database-conflicts-view">
   <title><structname>pg_stat_database_conflicts</structname></title>

   <indexterm>
    <primary>pg_stat_database_conflicts</primary>
   </indexterm>

   <warning>
    <para>
     Utiliser <function>pg_stat_reset()</function> réinitialise aussi les
     compteurs que l'autovacuum utilise pour déterminer quand déclencher une
     opération VACUUM ou une opération ANALYZE. Réinitialiser ces compteurs peut
     empêcher l'autovacuum de réaliser un travail pourtant nécessaire, ce qui
     entrainerait comme conséquence une fragmentation des tables ou des
     statistiques obsolètes sur les données des tables. Un
     <command>ANALYZE</command> sur la base est recommandé après avoir
     réinitialisé les statistiques.
    </para>
   </warning>
 
   <para>
    La vue <structname>pg_stat_database_conflicts</structname> contiendra
    une ligne par base de données, montrant des statistiques au niveau
    de chaque base de données concernant les requêtes annulées survenant à
    cause de conflits avec la restauration sur des serveurs standby. Cette
    vue contiendra seulement des informations sur les serveurs standby,
    dans la mesure où aucun conflit ne survient sur les serveurs
    primaires.
   </para>

   <table id="pg-stat-database-conflicts-view" xreflabel="pg_stat_database_conflicts">
    <title>Vue <structname>pg_stat_database_conflicts</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>datid</structfield> <type>oid</type>
        </para>
        <para>
         OID de la base de données
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>datname</structfield> <type>name</type>
        </para>
        <para>
         Nom de cette base de données
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>confl_tablespace</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de requêtes dans cette base de données qui ont
         été annulées suite à la suppression de tablespaces
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>confl_lock</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de requêtes dans cette base de données qui
         ont été annulées suite à des délais dépassés sur des
         verrouillages
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>confl_snapshot</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de requêtes dans cette base de données qui ont
         été annulées à cause d'instantanés trop vieux
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>confl_bufferpin</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de requêtes dans cette base de données qui ont
         été annulées à cause de tampons verrouillés
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>confl_deadlock</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de requêtes dans cette base de données qui ont
         été annulées à cause de <literal>deadlocks</literal>
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>confl_active_logicalslot</structfield> <type>bigint</type>
       </para>
       <para>
        Nombre d'utilisations de slots logiques dans cette base de données qui
        ont été annulées parce que le snapshot était trop ancien ou parce que
        le paramètre <xref linkend="guc-wal-level"/> était trop bas sur le
        primaire
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="monitoring-pg-stat-all-tables-view">
   <title><structname>pg_stat_all_tables</structname></title>

   <indexterm>
    <primary>pg_stat_all_tables</primary>
   </indexterm>

   <para>
    La vue <structname>pg_stat_all_tables</structname> contiendra une ligne
    par table dans la base de données courante (incluant les tables TOAST),
    montrant les statistiques d'accès pour cette table spécifiquement. Les vues
    <structname>pg_stat_user_tables</structname> et
    <structname>pg_stat_sys_tables</structname> contiennent les mêmes informations,
    mais filtrent respectivement les tables utilisateurs et les tables systèmes.
   </para>

   <table id="pg-stat-all-tables-view" xreflabel="pg_stat_all_tables">
    <title>Vue <structname>pg_stat_all_tables</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>relid</structfield> <type>oid</type>
        </para>
        <para>
         OID d'une table
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>schemaname</structfield> <type>name</type>
        </para>
        <para>
         Nom du schéma dans lequel se trouve cette table
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>relname</structfield> <type>name</type>
        </para>
        <para>
         Nom de cette table
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>seq_scan</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de parcours séquentiels initiés sur cette table
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>last_seq_scan</structfield> <type>timestamp with time zone</type>
       </para>
       <para>
        Horodatage du dernier parcours séquentiel, basé sur l'heure de fin
        de la transaction la plus récente
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>seq_tup_read</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de lignes vivantes rapportées par des parcours séquentiels
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>idx_scan</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de parcours d'index initiés sur cette table
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>last_idx_scan</structfield> <type>timestamp with time zone</type>
       </para>
       <para>
        Horodatage du dernier parcours d'index, basé sur l'heure de fin
        de la transaction la plus récente
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>idx_tup_fetch</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de lignes vivantes rapportées par des parcours d'index
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>n_tup_ins</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre total de lignes insérées
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>n_tup_upd</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre total de lignes mises à jour. (Ceci inclut les mises à jour
         comptées dans <structfield>n_tup_hot_upd</structfield> et
         <structfield>n_tup_newpage_upd</structfield>, ainsi que les mises
         à jour non-<acronym>HOT</acronym>.)
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>n_tup_del</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre total de lignes supprimées
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>n_tup_hot_upd</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de lignes <link linkend="storage-hot">mises à jour en utilisant
         HOT</link>. Ce sont les mises à jour qui n'ont pas nécessitées de
         nouvelles versions dans les index.
        </para></entry>
       </row>
       <row>
        <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>n_tup_newpage_upd</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de lignes mises à jour où la nouvelle version de ligne va sur
         un <emphasis>nouveau</emphasis> bloc du HEAP, laissant derrière
         la version originale dont le
         <link linkend="storage-tuple-layout">champ <structfield>t_ctid</structfield>
          </link> pointe vers un bloc HEAP différent. Ce sont toujours des
         mises à jour non-<acronym>HOT</acronym>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>n_live_tup</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre estimé de lignes vivantes
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>n_dead_tup</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre estimé de lignes mortes
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>n_mod_since_analyze</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre estimé de lignes modifiées depuis le dernier ANALYZE sur
         cette table
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>n_ins_since_vacuum</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre estimé de lignes insérées depuis le dernier VACUUM sur
         cette table
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>last_vacuum</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Dernière fois qu'une opération VACUUM manuelle
         a été faite sur cette table (sans compter&nbsp;
         <command>VACUUM FULL</command>)
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>last_autovacuum</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Dernière fois que le démon autovacuum a exécuté une
         opération VACUUM sur cette table
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>last_analyze</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Dernière fois qu'une opération ANALYZE a été lancée
         manuellement sur cette table
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>last_autoanalyze</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Dernière fois que le démon autovacuum a exécuté une
         opération ANALYZE sur cette table
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>vacuum_count</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de fois qu'une opération VACUUM manuelle a été
         lancée sur cette table (sans compter
         <command>VACUUM FULL</command>)
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>autovacuum_count</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de fois que le démon autovacuum a exécuté
         une opération VACUUM manuelle
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>analyze_count</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de fois qu'une opération ANALYZE manuelle
         a été lancée sur cette table
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>autoanalyze_count</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de fois que le démon autovacuum a exécuté une
         opération ANALYZE sur cette table
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="monitoring-pg-stat-all-indexes-view">
   <title><structname>pg_stat_all_indexes</structname></title>

   <indexterm>
    <primary>pg_stat_all_indexes</primary>
   </indexterm>

   <para>
    La vue <structname>pg_stat_all_indexes</structname> contiendra une
    ligne pour chaque index dans la base de données courante, montrant les
    statistiques d'accès sur cet index spécifiquement. Les vues
    <structname>pg_stat_user_indexes</structname> et
    <structname>pg_stat_sys_indexes</structname> contiennent la même
    information, mais sont filtrées pour ne montrer respectivement que
    les index utilisateurs et les index système.
   </para>

   <table id="pg-stat-all-indexes-view" xreflabel="pg_stat_all_indexes">
    <title>Vue <structname>pg_stat_all_indexes</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>relid</structfield> <type>oid</type>
        </para>
        <para>
         OID de la table pour cet index
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>indexrelid</structfield> <type>oid</type>
        </para>
        <para>
         OID de cet index
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>schemaname</structfield> <type>name</type>
        </para>
        <para>
         Nom du schéma dans lequel se trouve cet index
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>relname</structfield> <type>name</type>
        </para>
        <para>
         Nom de la table pour cet index
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>indexrelname</structfield> <type>name</type>
        </para>
        <para>
         Nom de cet index
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>idx_scan</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de parcours d'index initiés par cet index
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>last_idx_scan</structfield> <type>timestamp with time zone</type>
       </para>
       <para>
        L'horodatage du dernier parcours de cet index, basé sur l'heure de fin
        de la transaction la plus récente
       </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>idx_tup_read</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre d'entrées d'index retournées par des parcours sur cet index
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>idx_tup_fetch</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de lignes vivantes de la table rapportées par des simples parcours
         d'index utilisant cet index
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Les index peuvent être utilisés avec un simple parcours d'index,
    un parcours d'index  <quote>bitmap</quote> ou l'optimiseur. Dans un parcours de
    bitmap, les sorties de plusieurs index peuvent être combinées avec
    des règles AND ou OR, c'est pourquoi il est difficile d'associer des
    lectures de lignes individuelles de la table avec des index spécifiques
    quand un parcours de bitmap est utilisé. Par conséquent, un parcours de bitmap
    incrémente le(s) valeur(s) de <structname>pg_stat_all_indexes</structname>.
    <structfield>idx_tup_read</structfield> pour le(s) index qu'il utilise, et
    incrémente la valeur de <structname>pg_stat_all_tables</structname>.<structfield>
     idx_tup_fetch</structfield> pour la table, mais il n'affecte pas
    <structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_fetch</structfield>.
    L'optimiseur accède également aux index pour vérifier si des
    constantes fournies sont en dehors des plages de valeurs enregistrées
    par les statistiques de l'optimiseur car celles-ci peuvent ne pas
    être à jour.
   </para>

   <note>
    <para>
     Les valeurs de <structfield>idx_tup_read</structfield> et <structfield>idx_tup_fetch
     </structfield> peuvent être différentes même sans aucune utilisation de parcours
     de bitmap, car <structfield>idx_tup_read</structfield> comptabilise les entrées
     d'index récupérées de cet index alors que  <structfield>idx_tup_fetch</structfield>
     comptabilise le nombre de lignes vivantes rapportées de la table. Le second sera
     moindre si des lignes mortes ou pas encore validées sont rapportées en utilisant
     l'index, ou si des lectures de lignes de la table sont évitées grâce à un
     parcours d'index seul.
    </para>
   </note>

   <note>
    <para>
     Les requêtes qui utilisent certaines constructions <acronym>SQL</acronym>
     pour rechercher les lignes correspondant à certaines valeurs d'une liste
     ou un tableau de plusieurs valeurs scalaires (voir <xref
     linkend="functions-comparisons"/>) réalisent plusieurs parcours d'index
     <quote>primitifs</quote> (jusqu'à un parcours primitif par valeur scalaire)
     tout au long de l'exécution de la requête. Chaque parcours d'index primitif
     interne incrémente le champ
     <structname>pg_stat_all_indexes</structname>.<structfield>idx_scan</structfield>,
     donc il est possible que le nombre de parcours d'index dépasse
     significativement le nombre total d'exécutions du nœud de parcours d'index
     de l'exécuteur.
    </para>
   </note>
  </sect2>

  <sect2 id="monitoring-pg-statio-all-tables-view">
   <title><structname>pg_statio_all_tables</structname></title>

   <indexterm>
    <primary>pg_statio_all_tables</primary>
   </indexterm>

   <para>
    La vue <structname>pg_statio_all_tables</structname> contiendra
    une ligne pour chaque table dans la base de données courante (en
    incluant les tables TOAST), montrant les statistiques d'entrées/sorties
    de chaque table spécifiquement. Les vues
    <structname>pg_statio_user_tables</structname> et
    <structname>pg_statio_sys_tables</structname> contiennent la même
    information, mais sont filtrées pour ne montrer respectivement que
    les tables utilisateurs et les tables système.
   </para>

   <table id="pg-statio-all-tables-view" xreflabel="pg_statio_all_tables">
    <title>Vue <structname>pg_statio_all_tables</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>relid</structfield> <type>oid</type>
        </para>
        <para>
         OID d'une table
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>schemaname</structfield> <type>name</type>
        </para>
        <para>
         Nom du schéma dans lequel se trouve cette table
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>relname</structfield> <type>name</type>
        </para>
        <para>
         Nom de cette table
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>heap_blks_read</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs disque lus hors cache pour cette table
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>heap_blks_hit</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs disque lus dans le cache pour cette table
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>idx_blks_read</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs disque lus hors cache pour tous les index de cette table
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>idx_blks_hit</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de tampons lus dans le cache pour tous les index de cette table
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>toast_blks_read</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs disque lus sur la partie TOAST de cette table (si présente)
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>toast_blks_hit</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de tampons récupérés sur la partie TOAST de cette table (si présente)
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>tidx_blks_read</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs disque lus sur les index de la partie TOAST de cette table (si présente)
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>tidx_blks_hit</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de tampons récupérés sur les index de la partie TOAST de cette table (si présente)
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="monitoring-pg-statio-all-indexes-view">
   <title><structname>pg_statio_all_indexes</structname></title>

   <indexterm>
    <primary>pg_statio_all_indexes</primary>
   </indexterm>

   <para>
    La vue <structname>pg_statio_all_indexes</structname> contiendra
    une ligne pour chaque index dans la base de données courante,
    montrant les statistiques d'entrées/sorties sur chaque index
    spécifiquement. Les vues
    <structname>pg_statio_user_indexes</structname> et
    <structname>pg_statio_sys_indexes</structname> contiennent la même
    information, mais sont filtrées pour ne montrer respectivement
    que les tables utilisateur et tables système.
   </para>

   <table id="pg-statio-all-indexes-view" xreflabel="pg_statio_all_indexes">
    <title>Vue <structname>pg_statio_all_indexes</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>relid</structfield> <type>oid</type>
        </para>
        <para>
         OID de la table pour cet index
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>indexrelid</structfield> <type>oid</type>
        </para>
        <para>
         OID de cet index
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>schemaname</structfield> <type>name</type>
        </para>
        <para>
         Nom du schéma dans lequel se trouve cet index
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>relname</structfield> <type>name</type>
        </para>
        <para>
         Nom de la table pour cet index
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>indexrelname</structfield> <type>name</type>
        </para>
        <para>
         Nom de cet index
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>idx_blks_read</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs disque lus pour cet index
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>idx_blks_hit</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de tampons récupérés sur cet index
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="monitoring-pg-statio-all-sequences-view">
   <title><structname>pg_statio_all_sequences</structname></title>

   <indexterm>
    <primary>pg_statio_all_sequences</primary>
   </indexterm>

   <para>
    La vue <structname>pg_statio_all_sequences</structname> contiendra
    une ligne pour chaque séquence dans la base de données courante,
    montrant les statistiques d'entrées/sorties pour chaque séquence spécifiquement.
   </para>

   <table id="pg-statio-all-sequences-view" xreflabel="pg_statio_all_sequences">
    <title>Vue <structname>pg_statio_all_sequences</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>relid</structfield> <type>oid</type>
        </para>
        <para>
         OID de cette séquence
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>schemaname</structfield> <type>name</type>
        </para>
        <para>
         Nom du schéma dans lequel se trouve cette séquence
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>relname</structfield> <type>name</type>
        </para>
        <para>
         Nom de cette séquence
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>blks_read</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs disque lus pour cette séquence
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>blks_hit</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de tampons récupérés pour cette séquence
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="monitoring-pg-stat-user-functions-view">
   <title><structname>pg_stat_user_functions</structname></title>

   <indexterm>
    <primary>pg_stat_user_functions</primary>
   </indexterm>

   <para>
    La vue <structname>pg_stat_user_functions</structname> contiendra une
    ligne pour chaque fonction suivie, montrant les statistiques d'exécution
    de cette fonction. Le paramètre <xref linkend="guc-track-functions"/>
    contrôle exactement quelles fonctions sont suivies.
   </para>

   <table id="pg-stat-user-functions-view" xreflabel="pg_stat_user_functions">
    <title>Vue <structname>pg_stat_user_functions</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>funcid</structfield> <type>oid</type>
        </para>
        <para>
         OID de cette fonction
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>schemaname</structfield> <type>name</type>
        </para>
        <para>
         Nom du schéma dans lequel se trouve cette fonction
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>funcname</structfield> <type>name</type>
        </para>
        <para>
         Nom de cette fonction
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>calls</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de fois que cette fonction a été appelée
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>total_time</structfield> <type>double precision</type>
        </para>
        <para>
         Temps total passé dans cette fonction ainsi que dans toutes
         les autres fonctions appelées par elle, en millisecondes
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>self_time</structfield> <type>double precision</type>
        </para>
        <para>
         Temps total passé dans cette fonction seule, sans inclure
         les autres fonctions appelées par elle, en millisecondes
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="monitoring-pg-stat-slru-view">
   <title><structname>pg_stat_slru</structname></title>

   <indexterm>
    <primary>SLRU</primary>
   </indexterm>

   <indexterm>
    <primary>pg_stat_slru</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> accède à certaines informations
    stockées sur disque via des caches <literal>SLRU</literal>
    (<foreignphrase>simple least-recently-used</foreignphrase>). La vue
    <structname>pg_stat_slru</structname> contiendra une ligne pour chaque
    cache SLRU tracé, affichant des statistiques sur l'accès aux pages cachées.
   </para>

   <para>
    Pour chaque cache <literal>SLRU</literal> qui fait partie du cœur du serveur,
    il existe un paramètre de configuration permettant de contrôler sa
    taille, avec le suffixe <literal>_buffers</literal> ajouté.
   </para>

   <table id="pg-stat-slru-view" xreflabel="pg_stat_slru">
    <title>Vue <structname>pg_stat_slru</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>name</structfield> <type>text</type>
        </para>
        <para>
         Nom du cache SLRU
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>blks_zeroed</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs initialisés à zéro
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>blks_hit</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de fois que les blocs disques ont été trouvés dans le cache
         SLRU, et donc qu'une lecture disque n'était pas nécessaire (ceci
         inclut seulement les lectures dans le cache SLRU, pas les lectures
         dans le cache du système d'exploitation)
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>blks_read</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs disques lus à partir de ce cache SLRU
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>blks_written</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs disques écrit dans ce cache SLRU
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>blks_exists</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs dont l'existence a été vérifiée dans ce cache SLRU
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>flushes</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de vidages de données modifiées pour ce cache SLRU
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>truncates</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de troncatures pour ce cache SLRU
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
        </para>
        <para>
         Horodatage de la dernière réinitialisation de ces statistiques
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

  <sect2 id="monitoring-stats-functions">
   <title>Fonctions statistiques</title>

   <para>
    Une autre façon de regarder les statistiques peut être mise en place
    en écrivant des requêtes utilisant les mêmes fonctions d'accès sous-
    jacentes utilisées par les vues standards montrées au-dessus.  Pour
    des détails comme les noms de fonction, veuillez consulter les définitions
    de ces vues standards. (Par exemple, dans <application>psql</application>
    vous pouvez utiliser <literal>\d+ pg_stat_activity</literal>.)
    Les fonctions d'accès pour les statistiques par base de données prennent
    comme argument un OID pour identifier sur quelle base de données travailler.
    Les fonctions par table et par index utilisent un OID de table ou d'index.
    Les fonctions pour les statistiques par fonctions utilisent un OID de fonction.
    Notez que seuls les tables, index et fonctions dans la base de données
    courante peuvent être vus avec ces fonctions.
   </para>

   <para>
    Les fonctions supplémentaires liées au système de statistiques
    cumulatives sont listées dans <xref
    linkend="monitoring-stats-funcs-table"/>.
   </para>

   <table id="monitoring-stats-funcs-table">
    <title>Fonctions supplémentaires de statistiques</title>

    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
         Fonction
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <!-- See also the entry for this in func.sgml -->
       <entry role="func_table_entry"><para role="func_signature">
         <function>pg_backend_pid</function> ()
         <returnvalue>integer</returnvalue>
        </para>
        <para>
         Identifiant du processus serveur gérant la session courante.
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>pg_stat_get_xact_blocks_fetched</primary>
       </indexterm>
       <function>pg_stat_get_xact_blocks_fetched</function> ( <type>oid</type> )
       <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Renvoie le nombre de demandes de lecture de bloc pour la table ou
        l'index dans la transaction en cours. Ce nombre soustrait à
        <function>pg_stat_get_xact_blocks_hit</function> donne le nombre
        d'appels à la fonction noyau <function>read()</function>&nbsp;; le
        nombre de lectures physiques réelles est généralement plus basse grâce
        au cache au niveau noyau.
       </para></entry>
      </row>
 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>pg_stat_get_xact_blocks_hit</primary>
       </indexterm>
       <function>pg_stat_get_xact_blocks_hit</function> ( <type>oid</type> )
       <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Renvoie le nombre de demandes de lecture de bloc pour la table ou
        l'index dans la transaction en cours, trouvé dans le cache (donc
        ne déclenchant pas les appels à la fonction noyau
        <function>read()</function>).
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_get_activity</primary>
         </indexterm>
         <function>pg_stat_get_activity</function> ( <type>integer</type> )
         <returnvalue>setof record</returnvalue>
        </para>
        <para>
         Retourne un enregistrement d'informations sur le processus serveur
         du PID spécifié, ou un enregistrement pour chaque processus serveur
         actif dans le système si <symbol>NULL</symbol> est spécifié.
         Les champs retournés sont des sous-ensembles de ceux dans la vue
         <structname>pg_stat_activity</structname>.
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_get_snapshot_timestamp</primary>
         </indexterm>
         <function>pg_stat_get_snapshot_timestamp</function> ()
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Renvoie l'horodate du snapshot des statistiques actuelles, ou NULL
         si aucun snapshot n'a été pris. Un snapshot est pris la première fois
         que des statistiques cumulatives sont accédées dans une transaction
         si le paramètre <varname>stats_fetch_consistency</varname> vaut
         <literal>snapshot</literal>.
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_clear_snapshot</primary>
         </indexterm>
         <function>pg_stat_clear_snapshot</function> ()
         <returnvalue>void</returnvalue>
        </para>
        <para>
         Annule le snapshot actuel ou les informations en cache sur les
         statistiques.
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_reset</primary>
         </indexterm>
         <function>pg_stat_reset</function> ()
         <returnvalue>void</returnvalue>
        </para>
        <para>
         Réinitialise à 0 tous les compteurs statistiques pour la base de
         données actuelle.
        </para>
        <para>
         Cette fonction est restreinte aux superutilisateurs par défaut, mais
         d'autres utilisateurs peuvent avoir le droit EXECUTE pour exécuter la
         fonction.
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_reset_shared</primary>
         </indexterm>
         <function>pg_stat_reset_shared</function> ( [ <parameter>target</parameter> <type>text</type> <literal>DEFAULT</literal> <literal>NULL</literal> ] )
         <returnvalue>void</returnvalue>
        </para>
        <para>
         Réinitialise à 0 les compteurs statistiques de l'instance, suivant
         l'argument. <parameter>target</parameter> peut valoir&nbsp;:
         <itemizedlist>
          <listitem>
           <para>
            <literal>archiver</literal>&nbsp;: Réinitialise tous les compteurs
            affichés dans la vue <structname>pg_stat_archiver</structname>.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>bgwriter</literal>&nbsp;: Réinitialise tous les compteurs
            affichés dans la vue <structname>pg_stat_bgwriter</structname>.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>checkpointer</literal>&nbsp;: Réinitialise tous les
            compteurs affichés dans la vue
            <structname>pg_stat_checkpointer</structname>.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>io</literal>&nbsp;: Réinitialise tous les compteurs
            affichés dans la vue <structname>pg_stat_io</structname>.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>recovery_prefetch</literal>&nbsp;: Réinitialise tous les
            compteurs affichés dans la vue <structname>pg_stat_recovery_prefetch</structname>.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>slru</literal>&nbsp;: Réinitialise tous les compteurs
            affichés dans la vue <structname>pg_stat_slru</structname>.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>wal</literal>&nbsp;: Réinitialise tous les compteurs
            affichés dans la vue <structname>pg_stat_wal</structname>.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>NULL</literal> ou non spécifié&nbsp;: Réinitialise tous les
            compteurs de toutes les vues.
           </para>
          </listitem>
         </itemizedlist>
        </para>
        <para>
         Cette fonction est restreinte aux superutilisateurs par défaut, mais
         d'autres utilisateurs peuvent avoir le droit EXECUTE pour exécuter la
         fonction.
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_reset_single_table_counters</primary>
         </indexterm>
         <function>pg_stat_reset_single_table_counters</function> ( <type>oid</type> )
         <returnvalue>void</returnvalue>
        </para>
        <para>
         Réinitialise à 0 les statistiques pour une table ou un index dans la
         base de données courante ou partagé pour toutes bases de l'instance.
        </para>
        <para>
         Cette fonction est restreinte aux superutilisateurs par défaut, mais
         d'autres utilisateurs peuvent avoir le droit EXECUTE pour exécuter la
         fonction.
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_reset_single_function_counters</primary>
         </indexterm>
         <function>pg_stat_reset_single_function_counters</function> ( <type>oid</type> )
         <returnvalue>void</returnvalue>
        </para>
        <para>
         Réinitialise à 0 les statistiques pour une fonction dans la base de
         données courante.
        </para>
        <para>
         Cette fonction est restreinte aux superutilisateurs par défaut, mais
         d'autres utilisateurs peuvent avoir le droit EXECUTE pour exécuter la
         fonction.
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_reset_slru</primary>
         </indexterm>
         <function>pg_stat_reset_slru</function> ( [ <parameter>target</parameter> <type>text</type> <literal>DEFAULT</literal> <literal>NULL</literal> ] )
         <returnvalue>void</returnvalue>
        </para>
        <para>
         Réinitialise à 0 les statistiques à un cache SLRU, ou pour toutes les
         SLRU de l'instance. Si <parameter>target</parameter> vaut
         <literal>NULL</literal> ou n'est pas spécifié, tous les compteurs
         affichés dans la vue <structname>pg_stat_slru</structname> sont
         réinitialisés pour tous les caches SLRU. L'argument fait partie de
         <literal>commit_timestamp</literal>,
         <literal>multixact_member</literal>,
         <literal>multixact_offset</literal>,
         <literal>notify</literal>,
         <literal>serializable</literal>,
         <literal>subtransaction</literal> ou
         <literal>transaction</literal>
         pour réinitialiser les compteurs pour cette seule entrée. Si
         l'argument est <literal>other</literal> (ou tout nom non reconnu),
         alors les compteurs de tous les autres caches SLRU, comme ceux définis
         par des extensions, sont réinitialisés.
        </para>
        <para>
         Cette fonction est restreinte aux superutilisateurs par défaut, mais
         d'autres utilisateurs peuvent avoir le droit EXECUTE pour exécuter la
         fonction.
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
          <primary>pg_stat_reset_replication_slot</primary>
        </indexterm>
        <function>pg_stat_reset_replication_slot</function> ( <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Remet à zéro les statistiques du slot de réplication définies par l'argument. Si
        l'argument est <literal>NULL</literal>, réinitialise les statistiques pour tous
        les slots de réplication.
       </para>
       <para>
         Cette fonction est restreinte aux superutilisateurs par défaut, mais
         d'autres utilisateurs peuvent avoir le droit EXECUTE pour exécuter la fonction.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
          <primary>pg_stat_reset_subscription_stats</primary>
        </indexterm>
        <function>pg_stat_reset_subscription_stats</function> ( <type>oid</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Réinitialise à zéro les statistiques d'une seule souscription affichée
        dans la vue <structname>pg_stat_subscription_stats</structname>. Si
        l'argument vaut <literal>NULL</literal>, réinitialise les statistiques
        pour toutes les souscriptions.
       </para>
       <para>
        Cette fonction est restreinte par défaut aux superutilisateurs, mais les
        autres utilisateurs peuvent se voir attribuer le droit EXECUTE pour
        exécuter la fonction.
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    <function>pg_stat_get_activity</function>, la fonction sous-jacente de la
    vue <structname>pg_stat_activity</structname>, retourne un ensemble
    d'enregistrements contenant toute l'information disponible sur chaque
    processus serveur. Parfois il peut être plus pratique de n'obtenir qu'un
    sous-ensemble de cette information. Dans ces cas-là, un autre ensemble
    de fonctions d'accès aux statistiques par processus serveur peut être
    utilisé&nbsp;; celle-ci sont montrées dans <xref
    linkend="monitoring-stats-backend-funcs-table"/>. Ces fonctions d'accès
    utilisent un numéro d'identifiant du processus serveur de la session, qui
    est un très petit entier positive (>= 0) distinct de l'identifiant du processus
    backend de toute session concurrente, bien qu'un identifiant de session
    peut être recyclé dès qu'il n'est plus utilisé. L'identifiant de processus
    backend est utilisé, entre autres choses, pour identifier le schéma
    temporaire de la session s'il en a un. La fonction
    <function>pg_stat_get_backend_idset</function> fournit une manière pratique
    de lister tous les numéros d'identifiant des processus serveurs actifs pour appeler ces
    fonctions. Par exemple, pour montrer les <acronym>PID</acronym> et requêtes
    en cours de tous les processus serveur&nbsp;:

    <programlisting>
SELECT pg_stat_get_backend_pid(backendid) AS pid,
       pg_stat_get_backend_activity(backendid) AS query
FROM pg_stat_get_backend_idset() AS backendid;
    </programlisting>
   </para>

   <table id="monitoring-stats-backend-funcs-table">
    <title>Fonctions statistiques par processus serveur</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
         Fonction
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_get_backend_activity</primary>
         </indexterm>
         <function>pg_stat_get_backend_activity</function> ( <type>integer</type> )
         <returnvalue>text</returnvalue>
        </para>
        <para>
         Texte de la requête la plus récente de ce processus serveur
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_get_backend_activity_start</primary>
         </indexterm>
         <function>pg_stat_get_backend_activity_start</function> ( <type>integer</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Heure à laquelle la requête la plus récente a été démarrée
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_get_backend_client_addr</primary>
         </indexterm>
         <function>pg_stat_get_backend_client_addr</function> ( <type>integer</type> )
         <returnvalue>inet</returnvalue>
        </para>
        <para>
         Adresse IP du client connecté à ce processus serveur
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_get_backend_client_port</primary>
         </indexterm>
         <function>pg_stat_get_backend_client_port</function> ( <type>integer</type> )
         <returnvalue>integer</returnvalue>
        </para>
        <para>
         Numéro de port TCP que le client utilise pour communiquer
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_get_backend_dbid</primary>
         </indexterm>
         <function>pg_stat_get_backend_dbid</function> ( <type>integer</type> )
         <returnvalue>oid</returnvalue>
        </para>
        <para>
         OID de la base de données auquel ce processus serveur est connecté
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_get_backend_idset</primary>
         </indexterm>
         <function>pg_stat_get_backend_idset</function> ()
         <returnvalue>setof integer</returnvalue>
        </para>
        <para>
         Ensemble de numéros de processus serveur actuellement actifs
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_get_backend_pid</primary>
         </indexterm>
         <function>pg_stat_get_backend_pid</function> ( <type>integer</type> )
         <returnvalue>integer</returnvalue>
        </para>
        <para>
         Identifiant du processus serveur
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_get_backend_start</primary>
         </indexterm>
         <function>pg_stat_get_backend_start</function> ( <type>integer</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Heure à laquelle ce processus a été démarré
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_subxact</primary>
        </indexterm>
        <function>pg_stat_get_backend_subxact</function> ( <type>integer</type> )
        <returnvalue>record</returnvalue>
       </para>
       <para>
        Renvoie un enregistrement d'informations sur le backend ayant cet
        identifiant. Les champs renvoyés sont
        <parameter>subxact_count</parameter>, qui est le nombre de
        sous-transactions dans le cache de sous-transactions du processus
        backend, et <parameter>subxact_overflow</parameter>, qui indique si le
        cache de sous-transaction du processus backend est rempli ou non.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_get_backend_userid</primary>
         </indexterm>
         <function>pg_stat_get_backend_userid</function> ( <type>integer</type> )
         <returnvalue>oid</returnvalue>
        </para>
        <para>
         Renvoie l'OID de l'utilisateur connecté à ce processus serveur
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_get_backend_wait_event</primary>
         </indexterm>
         <function>pg_stat_get_backend_wait_event</function> ( <type>integer</type> )
         <returnvalue>text</returnvalue>
        </para>
        <para>
         Renvoie le nom de l'événement d'attente si le processus est actuellement en
         attente, NULL sinon. Voir <xref linkend="wait-event-table"/> pour les
         détails.
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_get_backend_wait_event_type</primary>
         </indexterm>
         <function>pg_stat_get_backend_wait_event_type</function> ( <type>integer</type> )
         <returnvalue>text</returnvalue>
        </para>
        <para>
         Renvoie le nom du type d'événement d'attente si le processus est actuellement
         en attente, NULL sinon. Voir <xref linkend="wait-event-table"/> pour les
         détails.
        </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>pg_stat_get_backend_xact_start</primary>
         </indexterm>
         <function>pg_stat_get_backend_xact_start</function> ( <type>integer</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Heure à laquelle la transaction courante a été démarrée
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>
 </sect1>

 <sect1 id="monitoring-locks">
  <title>Visualiser les verrous</title>

  <indexterm zone="monitoring-locks">
   <primary>verrou</primary>
   <secondary>surveillance</secondary>
  </indexterm>

  <para>
   Un autre outil utile pour surveiller l'activité des bases de données est la
   table système <structname>pg_locks</structname>. Elle permet à
   l'administrateur système de visualiser des informations sur les verrous
   restant dans le gestionnaire des verrous. Par exemple, cette fonctionnalité
   peut être utilisée pour&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Visualiser tous les verrous en cours, tous les verrous sur les relations
      d'une base de données particulière ou tous les verrous détenus par une
      session <productname>PostgreSQL</productname> particulière.
     </para>
    </listitem>

    <listitem>
     <para>
      Déterminer la relation de la base de données disposant de la plupart des
      verrous non autorisés (et qui, du coup, pourraient être une source de
      contention parmi les clients de la base de données).
     </para>
    </listitem>

    <listitem>
     <para>
      Déterminer l'effet de la contention des verrous sur les performances
      générales des bases de données, ainsi que l'échelle dans laquelle varie la
      contention sur le trafic de la base de données.
     </para>
    </listitem>
   </itemizedlist>

   Les détails sur la vue <structname>pg_locks</structname> apparaissent dans la
   <xref linkend="view-pg-locks"/>. Pour plus d'informations sur les verrous et
   la gestion des concurrences avec <productname>PostgreSQL</productname>,
   référez-vous au <xref linkend="mvcc"/>.
  </para>
 </sect1>

 <sect1 id="progress-reporting">
  <title>Rapporter la progression</title>

  <para>
   <productname>PostgreSQL</productname> a la possibilité de rapporter la
   progression de certaines commandes lors de leur exécution. Actuellement,
   les seules commandes supportant un rapport de progression sont
   <command>ANALYZE</command>, <command>CLUSTER</command>, <command>CREATE
    INDEX</command>, <command>VACUUM</command>, <command>COPY</command>, et <xref
   linkend="protocol-replication-base-backup"/> (i.e., commande de réplication
   que <xref linkend="app-pgbasebackup"/> exécute pour réaliser une sauvegarde
   de base). Ceci pourrait être étendu dans le futur.
  </para>

  <sect2 id="analyze-progress-reporting">
   <title>Rapporter la progression d'ANALYZE</title>

   <indexterm>
    <primary>pg_stat_progress_analyze</primary>
   </indexterm>

   <para>
    Quand <command>ANALYZE</command> est en cours d'exécution, la vue
    <structname>pg_stat_progress_analyze</structname> contiendra une ligne
    pour chaque processus qui exécute actuellement cette commande. Les tables
    ci-dessous décrivent les informations rapportées et fournissent des
    informations sur leur interprétation.
   </para>

   <table id="pg-stat-progress-analyze-view" xreflabel="pg_stat_progress_analyze">
    <title>Vue <structname>pg_stat_progress_analyze</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>pid</structfield> <type>integer</type>
        </para>
        <para>
         Identifiant du processus serveur.
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>datid</structfield> <type>oid</type>
        </para>
        <para>
         OID de la base de données où ce processus est connecté.
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>datname</structfield> <type>name</type>
        </para>
        <para>
         Nom de la base de données où ce processus est connecté.
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>relid</structfield> <type>oid</type>
        </para>
        <para>
         OID de la table en cours de traitement par ANALYZE.
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>phase</structfield> <type>text</type>
        </para>
        <para>
         Phase de traitement courante. Voir <xref linkend="analyze-phases"/>.
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>sample_blks_total</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre total de blocs de la table à traiter.
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>sample_blks_scanned</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs parcourus.
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>ext_stats_total</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de statistiques étendues.
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>ext_stats_computed</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de statistiques étendues calculées. Ce compteur avance seulement
         quand la phase est <literal>computing extended statistics</literal>.
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>child_tables_total</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de tables enfants.
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>child_tables_done</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de tables enfants parcourues. Ce compteur avance seulement quand
         la phase est <literal>acquiring inherited sample rows</literal>.
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>current_child_table_relid</structfield> <type>oid</type>
        </para>
        <para>
         OID de la table enfant en cours de traitement. Ce champ est seulement
         valide quand la phase est <literal>acquiring inherited sample
          rows</literal>.
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <table id="analyze-phases">
    <title>Phases ANALYZE</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="2*"/>
     <thead>
      <row>
       <entry>Phase</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>initializing</literal></entry>
       <entry>
        La commande prépare le début du traitement de la table. Cette phase
        est normalement très brève.
       </entry>
      </row>
      <row>
       <entry><literal>acquiring sample rows</literal></entry>
       <entry>
        La command est en cours de parcours de la table indiquée par
        <structfield>relid</structfield> pour obtenir les lignes de
        l'échantillon.
       </entry>
      </row>
      <row>
       <entry><literal>acquiring inherited sample rows</literal></entry>
       <entry>
        La command est en cours de parcours des tables enfants pour obtenir
        les lignes de l'échantillon. Les colonnes
        <structfield>child_tables_total</structfield>,
        <structfield>child_tables_done</structfield> et
        <structfield>current_child_table_relid</structfield> contiennent les
        informations de progression pour cette phase.
       </entry>
      </row>
      <row>
       <entry><literal>computing statistics</literal></entry>
       <entry>
        La command calcule les statistiques à partir des lignes de
        l'échantillon obtenu lors du parcours de la table.
       </entry>
      </row>
      <row>
       <entry><literal>computing extended statistics</literal></entry>
       <entry>
        La commande calcule les statistiques étendues à partir des lignes de
        l'échantillon obtenu lors du parcours de la table.
       </entry>
      </row>
      <row>
       <entry><literal>finalizing analyze</literal></entry>
       <entry>
        La commande met à jour <structname>pg_class</structname>. Quand cette
        phase est terminée, <command>ANALYZE</command> terminera.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
    <para>
     Notez que quand <command>ANALYZE</command> est exécutée sur une table
     partitionnée,toutes ces partitions sont traitées récursivement. Dans ce cas, la
     progression d'<command>ANALYZE</command> est rapportée tout d'abord pour
     la table parent alors que les statistiques d'héritage sont récupérées,
     suivies par celles de chaque partition.
    </para>
   </note>
  </sect2>

  <sect2 id="cluster-progress-reporting">
   <title>Rapporter la progression de CLUSTER</title>

   <indexterm>
    <primary>pg_stat_progress_cluster</primary>
   </indexterm>

   <para>
    Quand <command>CLUSTER</command> ou <command>VACUUM FULL</command> est en
    cours d'exécution, la vue <structname>pg_stat_progress_cluster</structname>
    contiendra une ligne pour chaque processus serveur en train d'exécuter une
    de ces deux commandes. Les tables ci-dessous décrivent les informations
    rapportées et fournissent des informations sur leur interprétation.
   </para>

   <table id="pg-stat-progress-cluster-view" xreflabel="pg_stat_progress_cluster">
    <title>Vue <structname>pg_stat_progress_cluster</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>pid</structfield> <type>integer</type>
        </para>
        <para>
         Identifiant du processus serveur.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>datid</structfield> <type>oid</type>
        </para>
        <para>
         OID de la base de données de connexion du processus.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>datname</structfield> <type>name</type>
        </para>
        <para>
         Nom de la base de données de connexion du processus.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>relid</structfield> <type>oid</type>
        </para>
        <para>
         OID de la table en cours de traitement.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>command</structfield> <type>text</type>
        </para>
        <para>
         La commande exécutée. Soit <literal>CLUSTER</literal> soit
         <literal>VACUUM FULL</literal >.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>phase</structfield> <type>text</type>
        </para>
        <para>
         Phase de traitement actuelle. Voir <xref linkend='cluster-phases' />.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>cluster_index_relid</structfield> <type>oid</type>
        </para>
        <para>
         Si la table est parcourue avec un index, OID de l'index utilisé. Sinon 0.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>heap_tuples_scanned</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de lignes parcourues. Ce compteur s'incrémente seulement quand
         la phase est
         <literal>seq scanning heap</literal>,
         <literal>index scanning heap</literal>
         ou <literal>writing new heap</literal>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>heap_tuples_written</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de lignes écrites. Ce compteur s'incrémente seulement quand la
         phase est
         <literal>seq scanning heap</literal>,
         <literal>index scanning heap</literal>
         ou <literal>writing new heap</literal>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>heap_blks_total</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre total de blocs dans la table. Ce nombre est rapporté au début de
         <literal>seq scanning heap</literal>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>heap_blks_scanned</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs parcourus. Ce compteur s'incrément seulement quand la
         phase est <literal>seq scanning heap</literal>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>index_rebuild_count</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre d'index reconstruit. Ce compteur s'incrémente seulement quand la
         phase est <literal>rebuilding index</literal>.
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <table id="cluster-phases">
    <title>Phases de CLUSTER et VACUUM FULL</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Phase</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>initializing</literal></entry>
       <entry>
        La commande prépare le début du parcours de la table. Cette phase est
        normalement très brève.
       </entry>
      </row>
      <row>
       <entry><literal>seq scanning heap</literal></entry>
       <entry>
        La commande parcourt la table en utilisant un parcours séquentiel.
       </entry>
      </row>
      <row>
       <entry><literal>index scanning heap</literal></entry>
       <entry>
        <command>CLUSTER</command> parcourt la table en utilisant un parcours
        d'index.
       </entry>
      </row>
      <row>
       <entry><literal>sorting tuples</literal></entry>
       <entry>
        <command>CLUSTER</command> trie les lignes.
       </entry>
      </row>
      <row>
       <entry><literal>writing new heap</literal></entry>
       <entry>
        <command>CLUSTER</command> est en cours d'écriture du nouveau fichier
        de la table.
       </entry>
      </row>
      <row>
       <entry><literal>swapping relation files</literal></entry>
       <entry>
        La commande bascule les fichiers nouvellement construit en place.
       </entry>
      </row>
      <row>
       <entry><literal>rebuilding index</literal></entry>
       <entry>
        La commande reconstruit les index.
       </entry>
      </row>
      <row>
       <entry><literal>performing final cleanup</literal></entry>
       <entry>
        La commande réalise le nettoyage final. Quand cette phase est terminée,
        <command>CLUSTER</command> ou <command>VACUUM FULL</command> terminera.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

 <sect2 id="copy-progress-reporting">
  <title>Rapporter la progression de COPY</title>

  <indexterm>
   <primary>pg_stat_progress_copy</primary>
  </indexterm>

  <para>
   Lorsque <command>COPY</command> est en cours d'exécution, la vue
   <structname>pg_stat_progress_copy</structname> contient alors une ligne
   pour chaque processus serveur qui exécute à l'instant une commande <command>COPY</command>.
   La table ci-dessous décrit les informations qui sont affichées et fournit des informations
   sur comment les interpréter.
  </para>

  <table id="pg-stat-progress-copy-view" xreflabel="pg_stat_progress_copy">
   <title>Vue <structname>pg_stat_progress_copy</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Type de la colonne
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       ID du processus serveur.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID de la base de données sur laquelle le processus serveur est connecté.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Nom de la base de données sur laquelle le processus serveur est connecté.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID de la table sur laquelle la commande <command>COPY</command>
       s'exécute. Cette valeur vaut <literal>0</literal> si la copie se fait depuis
       une requête <command>SELECT</command>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>command</structfield> <type>text</type>
      </para>
      <para>
       La commande qui est exécutée&nbsp;: <literal>COPY FROM</literal>, ou
       <literal>COPY TO</literal>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>type</structfield> <type>text</type>
      </para>
      <para>
       Le type d'entrée/sortie à partir duquel les données sont lues ou
       écrites&nbsp;: <literal>FILE</literal>, <literal>PROGRAM</literal>,
       <literal>PIPE</literal> (pour <command>COPY FROM STDIN</command> et
       <command>COPY TO STDOUT</command>), ou <literal>CALLBACK</literal>
       (utilisée par exemple durant la synchronisation initiale de table dans
       la réplication logique).
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>bytes_processed</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre d'octets déjà traités par la commande <command>COPY</command>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>bytes_total</structfield> <type>bigint</type>
      </para>
      <para>
       Taille du fichier source pour la commande <command>COPY FROM</command>
       en octets. La valeur vaut <literal>0</literal> si cette information
       n'est pas disponible.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_processed</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de lignes déjà traitées par la commande <command>COPY</command>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_skipped</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de lignes ignorées parce qu'elles contiennent des données
       malformées. Ce compteur avance seulement quand une valeur autre que
       <literal>stop</literal> est indiqué pour l'option
       <literal>ON_ERROR</literal>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_excluded</structfield> <type>bigint</type>
      </para>
      <para>
       Nombre de lignes non traitées car exclues par la clause
       <command>WHERE</command> de la commande <command>COPY</command>.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect2>

  <sect2 id="create-index-progress-reporting">
   <title>Rapporter la progression du CREATE INDEX</title>

   <indexterm>
    <primary>pg_stat_progress_create_index</primary>
   </indexterm>

   <para>
    Quand un <command>CREATE INDEX</command> ou un <command>REINDEX</command>
    est en cours d'exécution, la vue
    <structname>pg_stat_progress_create_index</structname> contient une ligne
    pour chaque processus serveur en train de créer des index. Les tables
    ci-dessous décrivent les informations rapportées et fournissent des
    informations sur leur interprétation.
   </para>

   <table id="pg-stat-progress-create-index-view" xreflabel="pg_stat_progress_create_index">
    <title>Vue <structname>pg_stat_progress_create_index</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>pid</structfield> <type>integer</type>
        </para>
        <para>
         Identifiant du processus serveur.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>datid</structfield> <type>oid</type>
        </para>
        <para>
         OID de la base de données de connexion du processus.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>datname</structfield> <type>name</type>
        </para>
        <para>
         Nom de la base de données de connexion du processus.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>relid</structfield> <type>oid</type>
        </para>
        <para>
         OID de la table liée à l'index en cours de création.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>index_relid</structfield> <type>oid</type>
        </para>
        <para>
         OID de l'index en cours de création ou de réindexation. Lors d'un
         <command>CREATE INDEX</command> non concurrent, cette colonne vaut 0.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>command</structfield> <type>text</type>
        </para>
        <para>
         La commande en cours d'exécution&nbsp;: <literal>CREATE INDEX</literal>,
         <literal>CREATE INDEX CONCURRENTLY</literal>,
         <literal>REINDEX</literal> ou <literal>REINDEX CONCURRENTLY</literal>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>phase</structfield> <type>text</type>
        </para>
        <para>
         Phase en cours de traitement pour la création de l'index. Voir <xref
         linkend='create-index-phases'/>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>lockers_total</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre total de processus bloquant à attendre, si applicable.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>lockers_done</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de processus bloquant déjà attendus.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>current_locker_pid</structfield> <type>bigint</type>
        </para>
        <para>
         Identifiant du processus bloquant actuellement.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>blocks_total</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre total de blocs à traiter dans la phase en cours.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>blocks_done</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs déjà traités dans la phase en cours.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>tuples_total</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre total de lignes à traiter dans la phase en cours.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>tuples_done</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de lignes déjà traitées dans la phase en cours.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>partitions_total</structfield> <type>bigint</type>
        </para>
        <para>
         Lors de la création d'un index sur une table partitionnée, cette colonne
         est configurée au nombre total de partitions sur lesquels l'index est
         créé.
         Ce champs vaut <literal>0</literal> lors d'un <literal>REINDEX</literal>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>partitions_done</structfield> <type>bigint</type>
        </para>
        <para>
         Lors de la création d'un index sur une table partitionnée, cette colonne
         est configurée au nombre total de partitions sur lesquels l'index a déjà
         été créé.
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <table id="create-index-phases">
    <title>Phases du CREATE INDEX</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Phase</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>initializing</literal></entry>
       <entry>
        <command>CREATE INDEX</command> ou <command>REINDEX</command> prépare
        la création de l'index. Cette phase est normalement très brève.
       </entry>
      </row>
      <row>
       <entry><literal>waiting for writers before build</literal></entry>
       <entry>
        <command>CREATE INDEX CONCURRENTLY</command> ou <command>REINDEX
         CONCURRENTLY</command> attend que les transactions avec des verrous en
        écriture qui peuvent voir la table se finissent Cette phase est ignorée
        quand elle n'est pas en mode concurrent. Les colonnes
        <structname>lockers_total</structname>,
        <structname>lockers_done</structname> et
        <structname>current_locker_pid</structname> contiennent les
        informations de progression sur cette phase.
       </entry>
      </row>
      <row>
       <entry><literal>building index</literal></entry>
       <entry>
        L'index est en cours de construction par le code spécifique de la
        méthode d'accès. Dans cette phase, les méthodes d'accès qui supportent
        les rapports de progression remplissent eux-même les données de
        progression, et la sous-phase est indiquée dans cette colonne.
        Typiquement, <structname>blocks_total</structname> et
        <structname>blocks_done</structname> contiendront les données de
        progression, ainsi que <structname>tuples_total</structname> et
        <structname>tuples_done</structname> potentiellement.
       </entry>
      </row>
      <row>
       <entry><literal>waiting for writers before validation</literal></entry>
       <entry>
        <command>CREATE INDEX CONCURRENTLY</command> ou <command>REINDEX
         CONCURRENTLY</command> est en attente de la fin des transactions avec
        verrous en écriture pouvant potentiellement écrire dans la table. Cette
        phase est ignorée quand elle n'est pas en mode concurrent. Les colonnes
        <structname>lockers_total</structname>,
        <structname>lockers_done</structname> et
        <structname>current_locker_pid</structname> contiennent les
        informations de progression pour cette phase.
       </entry>
      </row>
      <row>
       <entry><literal>index validation: scanning index</literal></entry>
       <entry>
        <command>CREATE INDEX CONCURRENTLY</command> parcourt l'index pour
        trouver les lignes qui ont besoin d'être validées. Cette phase est
        ignorée quand elle n'est pas en mode concurrent. Les colonnes
        <structname>blocks_total</structname> (configurée à la taille totale de
        l'index) et <structname>blocks_done</structname> contiennent les
        informations de progression pour cette phase.
       </entry>
      </row>
      <row>
       <entry><literal>index validation: sorting tuples</literal></entry>
       <entry>
        <command>CREATE INDEX CONCURRENTLY</command> trie la sortie de la phase
        de parcours de l'index.
       </entry>
      </row>
      <row>
       <entry><literal>index validation: scanning table</literal></entry>
       <entry>
        <command>CREATE INDEX CONCURRENTLY</command> parcourt la table pour
        valider les enregistrements d'index collectés dans les deux phases
        précédentes. Cette phase est ignorée quand elle n'est pas en mode
        concurrent. Les colonnes <structname>blocks_total</structname>
        (configurée à la taille totale de la table) et
        <structname>blocks_done</structname> contiennent les informations de
        progression pour cette phase.
       </entry>
      </row>
      <row>
       <entry><literal>waiting for old snapshots</literal></entry>
       <entry>
        <command>CREATE INDEX CONCURRENTLY</command> ou <command>REINDEX
         CONCURRENTLY</command> est en attente que les transactions pouvant
        potentiellement voir la table relâchent leur snapshot. Cette phase est
        ignorée quand elle n'est pas en mode concurrent. Les colonnes
        <structname>lockers_total</structname>,
        <structname>lockers_done</structname> et
        <structname>current_locker_pid</structname> contiennent les
        informations de progression pour cette phase.
       </entry>
      </row>
      <row>
       <entry><literal>waiting for readers before marking dead</literal></entry>
       <entry>
        <command>REINDEX CONCURRENTLY</command> est en attente de la fin des
        transactions avec verrous en lecture sur la table, avant de marquer
        l'ancien index comme mort. Cette phase est ignorée quand elle n'est pas
        en mode concurrent. Les colonnes
        <structname>lockers_total</structname>,
        <structname>lockers_done</structname> et
        <structname>current_locker_pid</structname> contiennent les
        informations de progression pour cette phase.
       </entry>
      </row>
      <row>
       <entry><literal>waiting for readers before dropping</literal></entry>
       <entry>
        <command>REINDEX CONCURRENTLY</command> est en attente de la fin des
        transactions avec verrous en lecture sur la table, avant de supprimer
        l'ancien index. Cette phase est ignorée quand elle n'est pas en mode
        concurrent. Les colonnes <structname>lockers_total</structname>,
        <structname>lockers_done</structname> et
        <structname>current_locker_pid</structname> contiennent les
        informations de progression pour cette phase.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="vacuum-progress-reporting">
   <title>Rapporter la progression du VACUUM</title>

   <indexterm>
    <primary>pg_stat_progress_vacuum</primary>
   </indexterm>

   <para>
    La vue <structname>pg_stat_progress_vacuum</structname> contient une ligne
    pour chaque processus serveur (incluant les processus autovacuum worker) en
    train d'exécuter un <command>VACUUM</command>. Les tableaux ci-dessous
    décrivent les informations rapportées et fournissent des informations sur
    leur interprétation. La progression des commandes <command>VACUUM FULL</command>
    est rapportée par <structname>pg_stat_progress_cluster</structname> parce
    que le <command>VACUUM FULL</command> comme le <command>CLUSTER</command>
    réécrivent la table, alors qu'un <command>VACUUM</command> simple la modifie
    directement. Voir <xref linkend='cluster-progress-reporting'/>.
   </para>

   <table id="pg-stat-progress-vacuum-view" xreflabel="pg_stat_progress_vacuum">
    <title>Vue <structname>pg_stat_progress_vacuum</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>pid</structfield> <type>integer</type>
        </para>
        <para>
         Identifiant (PID) du processus serveur.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>datid</structfield> <type>oid</type>
        </para>
        <para>
         OID de la base de données où est connecté ce processus
         serveur.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>datname</structfield> <type>name</type>
        </para>
        <para>
         Nom de la base de données où est connecté ce processus
         serveur.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>relid</structfield> <type>oid</type>
        </para>
        <para>
         OID de la table nettoyée par le VACUUM.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>phase</structfield> <type>text</type>
        </para>
        <para>
         Phase actuelle du vacuum. Voir <xref linkend='vacuum-phases'/>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>heap_blks_total</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre total de blocs de la table. Ce nombre est récupéré au début du
         parcours. Des blocs peuvent être ajoutés par la suite, mais ne seront
         pas (et n'ont pas besoin d'être) visités par ce
         <command>VACUUM</command>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>heap_blks_scanned</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs parcourus dans la table. Comme la <link
         linkend="storage-vm">carte de visibilité</link> est utilisée pour
         optimiser les parcours, certains blocs seront ignorés sans
         inspection&nbsp;; les blocs ignorés sont inclus dans ce total, pour que
         ce nombre puisse devenir égal à
         <structfield>heap_blks_total</structfield> quand le nettoyage se
         termine. Ce compteur avance seulement quand la phase est
         <literal>scanning heap</literal>.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>heap_blks_vacuumed</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de blocs nettoyés dans la table. Sauf si la table n'a pas
         d'index, ce compteur avance seulement quand la phase est
         <literal>vacuuming heap</literal>. Les blocs qui ne contiennent aucune
         ligne morte sont ignorés, donc le compteur pourrait parfois avancer par
         de larges incréments.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>index_vacuum_count</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de cycles de nettoyage d'index réalisés.
        </para></entry>
      </row>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>max_dead_tuple_bytes</structfield> <type>bigint</type>
        </para>
        <para>
         Quantité de lignes mortes que nous pouvons stocker avant d'avoir besoin de
         réaliser un cycle de nettoyage d'index, basé sur <xref
         linkend="guc-maintenance-work-mem"/>.
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>dead_tuple_bytes</structfield> <type>bigint</type>
       </para>
       <para>
        Volumétrie des lignes mortes collectées depuis le dernier cycle de
        nettoyage des index.
       </para></entry>
      </row>
 
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>num_dead_item_ids</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre d'éléments morts récupérés depuis le dernier cycle de nettoyage
         d'index.
        </para></entry>
       </row>

       <row>
        <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>indexes_total</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre total d'index à nettoyer. Ce nombre est indiqué au début de la
         phase <literal>vacuuming indexes</literal> ou de la phase
         <literal>cleaning up indexes</literal>.
        </para></entry>
       </row>

       <row>
        <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>indexes_processed</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre d'index traités. Ce nombre avance seulement quand la phase est
         <literal>vacuuming indexes</literal> ou <literal>cleaning up
         indexes</literal>.
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <table id="vacuum-phases">
    <title>Phases du VACUUM</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Phase</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>initializing</literal></entry>
       <entry>
        <command>VACUUM</command> se prépare à commencer le parcours de la
        table. Cette phase est habituellement très rapide.
       </entry>
      </row>
      <row>
       <entry><literal>scanning heap</literal></entry>
       <entry>
        <command>VACUUM</command> parcourt la table. Il va défragmenter chaque
        bloc si nécessaire et potentiellement réaliser un gel des lignes. La
        colonne <structfield>heap_blks_scanned</structfield> peut être utilisée
        pour surveiller la progression du parcours.
       </entry>
      </row>
      <row>
       <entry><literal>vacuuming indexes</literal></entry>
       <entry>
        <command>VACUUM</command> est en train de nettoyer les index. Si une
        table a des index, ceci surviendra au moins une fois par vacuum,
        après le parcours complet de la table. Cela pourrait arriver
        plusieurs fois par vacuum si <xref
        linkend="guc-maintenance-work-mem"/>  (ou, dans le cas de
        l'autovacuum, <xref linkend="guc-autovacuum-work-mem"/> s'il est
        configuré) n'est pas suffisamment important pour y enregistrer le
        nombre de lignes mortes trouvées.
       </entry>
      </row>
      <row>
       <entry><literal>vacuuming heap</literal></entry>
       <entry>
        <command>VACUUM</command> est en train de nettoyer la table. Nettoyer
        la table est différent du parcours de la table, et survient après
        chaque phase de nettoyage d'index. Si
        <structfield>heap_blks_scanned</structfield> est inférieur à
        <structfield>heap_blks_total</structfield>, le système retournera à
        parcourir la table après la fin de cette phase. Sinon, il commencera le
        nettoyage des index une fois cette phase terminée.
       </entry>
      </row>
      <row>
       <entry><literal>cleaning up indexes</literal></entry>
       <entry>
        <command>VACUUM</command> est en train de nettoyer les index. Ceci
        survient après que la table ait été entièrement parcourue et que le vacuum
        des index et de la table soit terminé.
       </entry>
      </row>
      <row>
       <entry><literal>truncating heap</literal></entry>
       <entry>
        <command>VACUUM</command> est en cours de troncage de la table pour
        pouvoir redonner au système d'exploitation les pages vides en fin de
        relation. Ceci survient après le nettoyage des index.
       </entry>
      </row>
      <row>
       <entry><literal>performing final cleanup</literal></entry>
       <entry>
        <command>VACUUM</command> réalise le nettoyage final. Durant cette
        phase, <command>VACUUM</command> nettoiera la carte des espaces libres,
        mettra à jour les statistiques dans <literal>pg_class</literal>, et
        rapportera les statistiques au système de statistiques cumulatives. Une
        fois cette phase terminée, <command>VACUUM</command> se terminera.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

  <sect2 id="basebackup-progress-reporting">
   <title>Rapporter la progression de la sauvegarde de base</title>

   <indexterm>
    <primary>pg_stat_progress_basebackup</primary>
   </indexterm>

   <para>
    Quand une application comme <application>pg_basebackup</application>
    réalise une sauvegarde de base, la vue
    <structname>pg_stat_progress_basebackup</structname> contiendra une ligne
    pour chaque processus walsender en cours d'exécution de la commande de
    réplication <command>BASE_BACKUP</command> et d'envoi de la sauvegarde.
    Les tables ci-dessous décrivent les informations qui seront rapportées et
    fournissent des informations sur leur interprétation.
   </para>

   <table id="pg-stat-progress-basebackup-view" xreflabel="pg_stat_progress_basebackup">
    <title>Vue <structname>pg_stat_progress_basebackup</structname></title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         Type
        </para>
        <para>
         Description
        </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>pid</structfield> <type>integer</type>
        </para>
        <para>
         Identifiant du processus walsender.
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>phase</structfield> <type>text</type>
        </para>
        <para>
         Phase en cours de traitement. Voir <xref linkend="basebackup-phases"/>.
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>backup_total</structfield> <type>bigint</type>
        </para>
        <para>
         Quantité totale de données à envoyer. Ceci est estimé et rapporté au
         début de la phase <literal>streaming database files</literal>. Notez
         que c'est uniquement une approximation car la base de données pourrait
         changer pendant la phase <literal>streaming database files</literal>
         et les journaux de transactions pourraient être inclus dans la
         sauvegarde après coup. C'est toujours la même valeur que
         <structfield>backup_streamed</structfield> une fois la quantité de
         données envoyées dépasse la taille totale estimée. Si l'estimation est désactivée dans
         <application>pg_basebackup</application> (grâce à l'option
         <literal>--no-estimate-size</literal>), cette colonne vaut
         <literal>NULL</literal>.
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>backup_streamed</structfield> <type>bigint</type>
        </para>
        <para>
         Quantité de données envoyées. Ce compteur avance seulement quand la
         phase est <literal>streaming database files</literal> ou
         <literal>transferring wal files</literal>.
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>tablespaces_total</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre total de tablespaces à envoyer.
        </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
         <structfield>tablespaces_streamed</structfield> <type>bigint</type>
        </para>
        <para>
         Nombre de tablespaces envoyées. Ce compteur avance seulement quand la
         phase est <literal>streaming database files</literal>.
        </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <table id="basebackup-phases">
    <title>Phases de la sauvegarde de base</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="2*"/>
     <thead>
      <row>
       <entry>Phase</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>initializing</literal></entry>
       <entry>
        Le processus walsender prépare le début de la sauvegarde. Cette phase
        est normalement très brève.
       </entry>
      </row>
      <row>
       <entry><literal>waiting for checkpoint to finish</literal></entry>
       <entry>
        Le processus walsender est en cours d'exécution de
        <function>pg_backup_start</function> pour initialiser une sauvegarde
        de base, et en attente que le checkpoint de début de sauvegarde se
        finisse.
       </entry>
      </row>
      <row>
       <entry><literal>estimating backup size</literal></entry>
       <entry>
        Le processus walsender estime actuellement la quantité totale des
        fichiers de la base à envoyer comme une sauvegarde de base.
       </entry>
      </row>
      <row>
       <entry><literal>streaming database files</literal></entry>
       <entry>
        Le processus walsender est en cours d'envoi les fichiers de la base
        comme sauvegarde de base.
       </entry>
      </row>
      <row>
       <entry><literal>waiting for wal archiving to finish</literal></entry>
       <entry>
        Le processus walsender exécute actuellement le
        <function>pg_backup_stop</function> pour terminer la sauvegarde, et
        est en attente de tous les journaux de transactions requis pour que
        la sauvegarde de base soit correctement archivée.
        Si l'option <literal>--wal-method=none</literal> ou l'option
        <literal>--wal-method=stream</literal> est spécifié avec
        <application>pg_basebackup</application>, la sauvegarde se terminera
        une fois cette phase terminée.
       </entry>
      </row>
      <row>
       <entry><literal>transferring wal files</literal></entry>
       <entry>
        Le processus walsender est en cours de transfert des journaux de
        transactions générés lors de la sauvegarde. Cette phase survient après
        la phase <literal>waiting for wal archiving to finish</literal> si
        l'option <literal>--wal-method=fetch</literal> est indiquée à
        <application>pg_basebackup</application>. La sauvegarde se terminera
        quand cette phase sera terminée.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

 </sect1>

 <sect1 id="dynamic-trace">
  <title>Traces dynamiques</title>

  <indexterm zone="dynamic-trace">
   <primary>DTrace</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> fournit un support pour les traces
   dynamiques du serveur de bases de données. Ceci permet l'appel à un outil
   externe à certains points du code pour tracer son exécution.
  </para>

  <para>
   Un certain nombre de sondes et de points de traçage sont déjà insérés dans
   le code source. Ces sondes ont pour but d'être utilisées par des développeurs
   et des administrateurs de base de données. Par défaut, les sondes ne sont pas
   compilées dans <productname>PostgreSQL</productname>&nbsp;; l'utilisateur a
   besoin de préciser explicitement au script configure de rendre disponible
   les sondes.
  </para>

  <para>
   Actuellement, l'outil <ulink
   url="https://en.wikipedia.org/wiki/DTrace">DTrace</ulink> est supporté. Il
   est disponible sur Solaris, macOS, FreeBSD, NetBSD et Oracle Linux. Le
   projet <ulink url="https://sourceware.org/systemtap/">SystemTap</ulink>
   fournit un équivalent DTrace et peut aussi être utilisé. Le support
   d'autres outils de traces dynamiques est possible théoriquement en modifiant
   les définitions des macros dans
   <filename>src/include/utils/probes.h</filename>.
  </para>

  <sect2 id="compiling-for-trace">
   <title>Compiler en activant les traces dynamiques</title>

   <para>
    Par défaut, les sondes ne sont pas disponibles, donc vous aurez besoin d'indiquer
    explicitement au script configure de les activer dans
    <productname>PostgreSQL</productname>. Pour inclure le support de DTrace,
    ajoutez <option>--enable-dtrace</option> aux options de configure. Lire
    <xref linkend="configure-options-devel"/> pour plus d'informations.
   </para>
  </sect2>

  <sect2 id="trace-points">
   <title>Sondes disponibles</title>

   <para>
    Un certain nombre de sondes standards sont fournies dans le code source,
    comme indiqué dans <xref linkend="dtrace-probe-point-table"/>. <xref
    linkend="typedefs-table"/> précise les types utilisés dans les sondes.
    D'autres peuvent être ajoutées pour améliorer la surveillance de
    <productname>PostgreSQL</productname>.
   </para>

   <table id="dtrace-probe-point-table">
    <title>Sondes disponibles pour DTrace</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Paramètres</entry>
       <entry>Aperçu</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>transaction-start</literal></entry>
       <entry><literal>(LocalTransactionId)</literal></entry>
       <entry>Sonde qui se déclenche au lancement d'une nouvelle transaction.
        arg0 est l'identifiant de transaction</entry>
      </row>
      <row>
       <entry><literal>transaction-commit</literal></entry>
       <entry><literal>(LocalTransactionId)</literal></entry>
       <entry>Sonde qui se déclenche quand une transaction se termine avec succès.
        arg0 est l'identifiant de transaction</entry>
      </row>
      <row>
       <entry><literal>transaction-abort</literal></entry>
       <entry><literal>(LocalTransactionId)</literal></entry>
       <entry>Sonde qui se déclenche quand une transaction échoue.
        arg0 est l'identifiant de transaction</entry>
      </row>
      <row>
       <entry><literal>query-start</literal></entry>
       <entry><literal>(const char *)</literal></entry>
       <entry>Sonde qui se déclenche lorsque le traitement d'une requête commence.
        arg0 est la requête</entry>
      </row>
      <row>
       <entry><literal>query-done</literal></entry>
       <entry><literal>(const char *)</literal></entry>
       <entry>Sonde qui se déclenche lorsque le traitement d'une requête se termine.
        arg0 est la requête</entry>
      </row>
      <row>
       <entry><literal>query-parse-start</literal></entry>
       <entry><literal>(const char *)</literal></entry>
       <entry>Sonde qui se déclenche lorsque l'analyse d'une requête commence.
        arg0 est la requête</entry>
      </row>
      <row>
       <entry><literal>query-parse-done</literal></entry>
       <entry><literal>(const char *)</literal></entry>
       <entry>Sonde qui se déclenche lorsque l'analyse d'une requête se termine.
        arg0 est la requête</entry>
      </row>
      <row>
       <entry><literal>query-rewrite-start</literal></entry>
       <entry><literal>(const char *)</literal></entry>
       <entry>Sonde qui se déclenche lorsque la ré-écriture d'une requête commence.
        arg0 est la requête</entry>
      </row>
      <row>
       <entry><literal>query-rewrite-done</literal></entry>
       <entry><literal>(const char *)</literal></entry>
       <entry>Sonde qui se déclenche lorsque la ré-écriture d'une requête se termine.
        arg0 est la requête</entry>
      </row>
      <row>
       <entry><literal>query-plan-start</literal></entry>
       <entry><literal>()</literal></entry>
       <entry>Sonde qui se déclenche lorsque la planification d'une requête commence</entry>
      </row>
      <row>
       <entry><literal>query-plan-done</literal></entry>
       <entry><literal>()</literal></entry>
       <entry>Sonde qui se déclenche lorsque la planification d'une requête se termine</entry>
      </row>
      <row>
       <entry><literal>query-execute-start</literal></entry>
       <entry><literal>()</literal></entry>
       <entry>Sonde qui se déclenche lorsque l'exécution d'une requête commence</entry>
      </row>
      <row>
       <entry><literal>query-execute-done</literal></entry>
       <entry><literal>()</literal></entry>
       <entry>Sonde qui se déclenche lorsque l'exécution d'une requête se termine</entry>
      </row>
      <row>
       <entry><literal>statement-status</literal></entry>
       <entry><literal>(const char *)</literal></entry>
       <entry>Sonde qui se déclenche à chaque fois que le processus serveur met à
        jour son statut dans
        <structname>pg_stat_activity</structname>.<structfield>status</structfield>.
        arg0 est la nouvelle chaîne de statut</entry>
      </row>
      <row>
       <entry><literal>checkpoint-start</literal></entry>
       <entry><literal>(int)</literal></entry>
       <entry>Sonde qui se déclenche quand un point de retournement commence son
        exécution.
        arg0 détient les drapeaux bit à bit utilisés pour distinguer les
        différents types de points de retournement, comme un point suite à un
        arrêt, un point immédiat ou un point forcé</entry>
      </row>
      <row>
       <entry><literal>checkpoint-done</literal></entry>
       <entry><literal>(int, int, int, int, int)</literal></entry>
       <entry>Sonde qui se déclenche quand un point de retournement a terminé son
        exécution (les sondes listées après se déclenchent en séquence lors du
        traitement d'un point de retournement).
        arg0 est le nombre de tampons mémoires écrits. arg1 est le nombre total
        de tampons mémoires. arg2, arg3 et arg4 contiennent respectivement le
        nombre de journaux de transactions ajoutés, supprimés et recyclés</entry>
      </row>
      <row>
       <entry><literal>clog-checkpoint-start</literal></entry>
       <entry><literal>(bool)</literal></entry>
       <entry>Sonde qui se déclenche quand la portion CLOG d'un point de
        retournement commence.
        arg0 est true pour un point de retournement normal, false pour un point
        de retournement suite à un arrêt</entry>
      </row>
      <row>
       <entry><literal>clog-checkpoint-done</literal></entry>
       <entry><literal>(bool)</literal></entry>
       <entry>Sonde qui se déclenche quand la portion CLOG d'un point de
        retournement commence.
        arg0 a la même signification que pour <literal>clog-checkpoint-start</literal></entry>
      </row>
      <row>
       <entry><literal>subtrans-checkpoint-start</literal></entry>
       <entry><literal>(bool)</literal></entry>
       <entry>Sonde qui se déclenche quand la portion SUBTRANS d'un point de
        retournement commence.
        arg0 est true pour un point de retournement normal, false pour un point
        de retournement suite à un arrêt</entry>
      </row>
      <row>
       <entry><literal>subtrans-checkpoint-done</literal></entry>
       <entry><literal>(bool)</literal></entry>
       <entry>Sonde qui se déclenche quand la portion SUBTRANS d'un point de
        retournement se termine.
        arg0 a la même signification que pour <literal>subtrans-checkpoint-start</literal></entry>
      </row>
      <row>
       <entry><literal>multixact-checkpoint-start</literal></entry>
       <entry><literal>(bool)</literal></entry>
       <entry>Sonde qui se déclenche quand la portion MultiXact d'un point de
        retournement commence.
        arg0 est true pour un point de retournement normal, false pour un point
        de retournement suite à un arrêt</entry>
      </row>
      <row>
       <entry><literal>multixact-checkpoint-done</literal></entry>
       <entry><literal>(bool)</literal></entry>
       <entry>Sonde qui se déclenche quand la portion MultiXact d'un point de
        retournement se termine.
        arg0 a la même signification que pour <literal>multixact-checkpoint-start</literal></entry>
      </row>
      <row>
       <entry><literal>buffer-checkpoint-start</literal></entry>
       <entry><literal>(int)</literal></entry>
       <entry>Sonde qui se déclenche quand la portion d'écriture de tampons d'un
        point de retournement commence.
        arg0 contient les drapeaux bit à bit pour distinguer différents types de
        point de retournement comme le point après arrêt, un point immédiat, un
        point forcé</entry>
      </row>
      <row>
       <entry><literal>buffer-sync-start</literal></entry>
       <entry><literal>(int, int)</literal></entry>
       <entry>Sonde qui se déclenche quand nous commençons d'écrire les tampons
        modifiés pendant un point de retournement (après identification des
        tampons qui doivent être écrits).
        arg0 est le nombre total de tampons.
        arg1 est le nombre de tampons qui sont modifiés et n'ont pas besoin
        d'être écrits</entry>
      </row>
      <row>
       <entry><literal>buffer-sync-written</literal></entry>
       <entry><literal>(int)</literal></entry>
       <entry>Sonde qui se déclenche après chaque écriture d'un tampon lors d'un
        point de retournement.
        arg0 est le numéro d'identifiant du tampon</entry>
      </row>
      <row>
       <entry><literal>buffer-sync-done</literal></entry>
       <entry><literal>(int, int, int)</literal></entry>
       <entry>Sonde qui se déclenche quand tous les tampons modifiés ont été
        écrits.
        arg0 est le nombre total de tampons.
        arg1 est le nombre de tampons réellement écrits par le processus de point
        de retournement.
        arg2 est le nombre attendu de tampons à écrire (arg1 de
        <literal>buffer-sync-start</literal>)&nbsp;; toute différence reflète d'autres processus
        écrivant des tampons lors du point de retournement</entry>
      </row>
      <row>
       <entry><literal>buffer-checkpoint-sync-start</literal></entry>
       <entry><literal>()</literal></entry>
       <entry>Sonde qui se déclenche une fois les tampons modifiés écrits par le
        noyau et avant de commencer à lancer des requêtes fsync</entry>
      </row>
      <row>
       <entry><literal>buffer-checkpoint-done</literal></entry>
       <entry><literal>()</literal></entry>
       <entry>Sonde qui se déclenche après la fin de la synchronisation des
        tampons sur le disque</entry>
      </row>
      <row>
       <entry><literal>twophase-checkpoint-start</literal></entry>
       <entry><literal>()</literal></entry>
       <entry>Sonde qui se déclenche quand la portion deux-phases d'un point de
        retournement est commencée</entry>
      </row>
      <row>
       <entry><literal>twophase-checkpoint-done</literal></entry>
       <entry><literal>()</literal></entry>
       <entry>Sonde qui se déclenche quand la portion deux-phases d'un point de
        retournement est terminée</entry>
      </row>
      <row>
       <entry><literal>buffer-extend-start</literal></entry>
       <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, unsigned int)</literal></entry>
       <entry>Sonde qui se déclenche quand l'extension d'une relation commence.
        arg0 contient le fork à étendre. arg1, arg2 et arg3 contiennent l'OID
        du tablespace, de la base et de la relation identifiant complètement la
        relation. arg4 est l'identifiant du processus backend qui a créé la
        relation temporaire pour un buffer local ou
        <symbol>INVALID_PROC_NUMBER</symbol> (-1) pour un buffer partagé. arg5 est
        le nombre de blocs que l'appelant souhaite ajouter.</entry>
      </row>
      <row>
       <entry><literal>buffer-extend-done</literal></entry>
       <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, unsigned int,   BlockNumber)</literal></entry>
       <entry>Sonde qui se déclenche quand l'extension d'une relation se termine.
        arg0 contient le fork à étendre. arg1, arg2 et arg3 contiennent l'OID
        du tablespace, de la base et de la relation identifiant complètement la
        relation. arg4 est l'identifiant du processus backend qui a créé la
        relation temporaire pour un buffer local ou
        <symbol>INVALID_PROC_NUMBER</symbol> (-1) pour un buffer partagé. arg5 est
        le nombre de blocs correspondant à l'extension de la relation, ce qui 
        peut être moins que <literal>buffer-extend-start</literal> à cause de
        contraintes sur les ressources. arg6 contient le BlockNumber du premier
        nouveau bloc.</entry>
      </row>
      <row>
       <entry><literal>buffer-read-start</literal></entry>
       <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
       <entry>Sonde qui se déclenche quand la lecture d'un tampon commence.
        arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
        arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
        base de données et de la relation identifiant ainsi précisément la
        relation.
        arg5 est l'identifiant du processus moteur qui a créé la relation
        temporaire pour un tampon local ou <symbol>INVALID_PROC_NUMBER</symbol> (-1) pour un
        tampon partagé.</entry>
      </row>
      <row>
       <entry><literal>buffer-read-done</literal></entry>
       <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)</literal></entry>
       <entry>Sonde qui se déclenche quand la lecture d'un tampon se termine.
        arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
        arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
        base de données et de la relation identifiant ainsi précisément la
        relation.
        arg5 est l'identifiant du processus moteur qui a créé la relation
        temporaire pour un tampon local ou <symbol>INVALID_PROC_NUMBER</symbol> (-1) pour un
        tampon partagé.
        arg6 est true si la tampon était disponible en mémoire, false sinon</entry>
      </row>
      <row>
       <entry><literal>buffer-flush-start</literal></entry>
       <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
       <entry>Sonde qui se déclenche avant de lancer une demande d'écriture pour
        un bloc partagé.
        arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
        base de données et de la relation identifiant ainsi précisément la
        relation</entry>
      </row>
      <row>
       <entry><literal>buffer-flush-done</literal></entry>
       <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
       <entry>Sonde qui se déclenche quand une demande d'écriture se termine.
        (Notez que ceci ne reflète que le temps passé pour fournir la donnée au
        noyau&nbsp;; ce n'est habituellement pas encore écrit sur le disque.)
        Les arguments sont identiques à ceux de <literal>buffer-flush-start</literal></entry>
      </row>
      <row>
       <entry><literal>wal-buffer-write-dirty-start</literal></entry>
       <entry><literal>()</literal></entry>
       <entry>Sonde qui se déclenche quand un processus serveur commence à écrire
        un tampon modifié d'un journal de transactions parce qu'il n'y a plus
        d'espace disponible dans le cache des journaux de transactions. (Si cela
        arrive souvent, cela implique que <xref linkend="guc-wal-buffers"/> est
        trop petit.)</entry>
      </row>
      <row>
       <entry><literal>wal-buffer-write-dirty-done</literal></entry>
       <entry><literal>()</literal></entry>
       <entry>Sonde qui se déclenche quand l'écriture d'un tampon modifié d'un
        journal de transactions est terminée</entry>
      </row>
      <row>
       <entry><literal>wal-insert</literal></entry>
       <entry><literal>(unsigned char, unsigned char)</literal></entry>
       <entry>Sonde qui se déclenche quand un enregistrement est inséré dans un
        journal de transactions.
        arg0 est le gestionnaire de ressource (rmid) pour l'enregistrement.
        arg1 contient des informations supplémentaires</entry>
      </row>
      <row>
       <entry><literal>wal-switch</literal></entry>
       <entry><literal>()</literal></entry>
       <entry>Sonde qui se déclenche quand une bascule du journal de transactions
        est demandée</entry>
      </row>
      <row>
       <entry><literal>smgr-md-read-start</literal></entry>
       <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
       <entry>Sonde qui se déclenche au début de la lecture d'un bloc d'une
        relation.
        arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
        arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
        base de données et de la relation identifiant ainsi précisément la
        relation.
        arg5 est l'identifiant du processus moteur qui a créé la relation
        temporaire pour un tampon local ou <symbol>INVALID_PROC_NUMBER</symbol> (-1) pour un
        tampon partagé</entry>
      </row>
      <row>
       <entry><literal>smgr-md-read-done</literal></entry>
       <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
       <entry>Sonde qui se déclenche à la fin de la lecture d'un bloc.
        arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
        arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
        base de données et de la relation identifiant ainsi précisément la
        relation.
        arg5 est l'identifiant du processus moteur qui a créé la relation
        temporaire pour un tampon local ou <symbol>INVALID_PROC_NUMBER</symbol> (-1) pour un
        tampon partagé.
        arg6 est le nombre d'octets réellement lus alors que arg7 est le nombre
        d'octets demandés (s'il y a une différence, cela indique une lecture
        courte)</entry>
      </row>
      <row>
       <entry><literal>smgr-md-write-start</literal></entry>
       <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
       <entry>Sonde qui se déclenche au début de l'écriture d'un bloc dans une
        relation.
        arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
        arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
        base de données et de la relation identifiant ainsi précisément la
        relation.
        arg5 est l'identifiant du processus moteur qui a créé la relation
        temporaire pour un tampon local ou <symbol>InvalidBackendId</symbol> (-1) pour un
        tampon partagé</entry>
      </row>
      <row>
       <entry><literal>smgr-md-write-done</literal></entry>
       <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
       <entry>Sonde qui se déclenche à la fin de l'écriture d'un bloc.
        arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
        arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
        base de données et de la relation identifiant ainsi précisément la
        relation.
        arg5 est l'identifiant du processus moteur qui a créé la relation
        temporaire pour un tampon local ou <symbol>InvalidBackendId</symbol> (-1) pour un
        tampon partagé.
        arg6 est le nombre d'octets réellement écrits alors que arg7 est le nombre
        d'octets demandés (si ces nombres sont différents, cela indique une
        écriture courte)</entry>
      </row>
      <row>
       <entry><literal>sort-start</literal></entry>
       <entry><literal>(int, bool, int, int, bool, int)</literal></entry>
       <entry>Sonde qui se déclenche quand une opération de tri est démarré.
        arg0 indique un tri de la table, de l'index ou d'un datum.
        arg1 est true si on force les valeurs uniques.
        arg2 est le nombre de colonnes clés.
        arg3 est le nombre de ko de mémoire autorisé pour ce travail.
        arg4 est true si un accès aléatoire au résultat du tri est requis
        arg5 indique serial si <literal>0</literal>, parallel worker si
        <literal>1</literal>, ou parallel leader si <literal>2</literal>.</entry>
      </row>
      <row>
       <entry><literal>sort-done</literal></entry>
       <entry><literal>(bool, long)</literal></entry>
       <entry>Sonde qui se déclenche quand un tri est terminé.
        arg0 est true pour un tri externe, false pour un tri interne.
        arg1 est le nombre de blocs disque utilisés pour un tri externe, ou le
        nombre de ko de mémoire utilisés pour un tri interne</entry>
      </row>
      <row>
       <entry><literal>lwlock-acquire</literal></entry>
       <entry><literal>(char *, LWLockMode)</literal></entry>
       <entry>Sonde qui se déclenche quand un LWLock a été acquis.
        arg0 est la tranche de LWLock.
        arg1 est le mode de verrou attendu, soit exclusif soit partagé.</entry>
      </row>
      <row>
       <entry><literal>lwlock-release</literal></entry>
       <entry><literal>(char *)</literal></entry>
       <entry>Sonde qui se déclenche quand un LWLock a été relâché (mais notez
        que tout processus en attente n'a pas encore été réveillé).
        arg0 est la tranche de LWLock.</entry>
      </row>
      <row>
       <entry><literal>lwlock-wait-start</literal></entry>
       <entry><literal>(char *, LWLockMode)</literal></entry>
       <entry>Sonde qui se déclenche quand un LWLock n'était pas immédiatement
        disponible et qu'un processus serveur a commencé à attendre la
        disponibilité du verrou.
        arg0 est la tranche de LWLock.
        arg1 est le mode de verrou attendu, soit exclusif soit partagé.</entry>
      </row>
      <row>
       <entry><literal>lwlock-wait-done</literal></entry>
       <entry><literal>(char *, LWLockMode)</literal></entry>
       <entry>Sonde qui se déclenche quand un processus serveur n'est plus en
        attente d'un LWLock (il n'a pas encore le verrou).
        arg0 est la tranche de LWLock.
        arg1 est le mode de verrou attendu, soit exclusif soit partagé.</entry>
      </row>
      <row>
       <entry><literal>lwlock-condacquire</literal></entry>
       <entry><literal>(char *, LWLockMode)</literal></entry>
       <entry>Sonde qui se déclenche quand un LWLock a été acquis avec succès
        malgré le fait que l'appelant ait demandé de ne pas attendre.
        arg0 est la tranche de LWLock.
        arg1 est le mode de verrou attendu, soit exclusif soit partagé.</entry>
      </row>
      <row>
       <entry><literal>lwlock-condacquire-fail</literal></entry>
       <entry><literal>(char *, LWLockMode)</literal></entry>
       <entry>Sonde qui se déclenche quand un LWLock, demandé sans attente, n'est
        pas accepté.
        arg0 est la tranche de LWLock.
        arg1 est le mode de verrou attendu, soit exclusif soit partagé.</entry>
      </row>
      <row>
       <entry><literal>lock-wait-start</literal></entry>
       <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int,  LOCKMODE)</literal></entry>
       <entry>Sonde qui se déclenche quand une demande d'un gros verrou
        (<foreignphrase>lmgr lock</foreignphrase>) a commencé l'attente parce que
        le verrou n'était pas disponible.
        arg0 à arg3 sont les champs identifiant l'objet en cours de verrouillage.
        arg4 indique le type d'objet à verrouiller.
        arg5 indique le type du verrou demandé</entry>
      </row>
      <row>
       <entry><literal>lock-wait-done</literal></entry>
       <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int,  LOCKMODE)</literal></entry>
       <entry>Sonde qui se déclenche quand une demande d'un gros verrou
        (<foreignphrase>lmgr lock</foreignphrase>) a fini d'attendre (c'est-à-dire
        que le verrou a été accepté).
        Les arguments sont identiques à ceux de lock-wait-start</entry>
      </row>
      <row>
       <entry><literal>deadlock-found</literal></entry>
       <entry><literal>()</literal></entry>
       <entry>Sonde qui se déclenche quand un verrou mortel est trouvé par le
        détecteur</entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <table id="typedefs-table">
    <title>Types définis utilisés comme paramètres de sonde</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Type</entry>
       <entry>Definition</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry><type>LocalTransactionId</type></entry>
       <entry><type>unsigned int</type></entry>
      </row>
      <row>
       <entry><type>LWLockMode</type></entry>
       <entry><type>int</type></entry>
      </row>
      <row>
       <entry><type>LOCKMODE</type></entry>
       <entry><type>int</type></entry>
      </row>
      <row>
       <entry><type>BlockNumber</type></entry>
       <entry><type>unsigned int</type></entry>
      </row>
      <row>
       <entry><type>Oid</type></entry>
       <entry><type>unsigned int</type></entry>
      </row>
      <row>
       <entry><type>ForkNumber</type></entry>
       <entry><type>int</type></entry>
      </row>
      <row>
       <entry><type>bool</type></entry>
       <entry><type>unsigned char</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>
  </sect2>

  <sect2 id="using-trace-points">
   <title>Utiliser les sondes</title>

   <para>
    L'exemple ci-dessous montre un script DTrace pour l'analyse du nombre de
    transactions sur le système, comme alternative à l'interrogation régulière
    de <structname>pg_stat_database</structname> avant et après un test de
    performance&nbsp;:
    <programlisting>#!/usr/sbin/dtrace -qs

 postgresql$1:::transaction-start
 {
       @start["Start"] = count();
       self->ts  = timestamp;
 }

 postgresql$1:::transaction-abort
 {
       @abort["Abort"] = count();
 }

 postgresql$1:::transaction-commit
 /self->ts/
 {
       @commit["Commit"] = count();
       @time["Total time (ns)"] = sum(timestamp - self->ts);
       self->ts=0;
 }
    </programlisting>
    À son exécution, le script de l'exemple D donne une sortie comme&nbsp;:
    <screen># ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;
 ^C

 Start                                          71
 Commit                                         70
 Total time (ns)                        2312105013
    </screen>
   </para>

   <note>
    <para>
     SystemTap utilise une notation différente de DTrace pour les scripts de
     trace, même si les points de trace sont compatibles. Il est intéressant de
     noter que, lorsque nous avons écrit ce texte, les scripts SystemTap doivent
     référencer les noms des sondes en utilisant des tirets bas doubles à la
     place des tirets simples. Il est prévu que les prochaines versions de
     SystemTap corrigent ce problème.
    </para>
   </note>

   <para>
    Vous devez vous rappeler que les programmes DTrace doivent être écrits
    soigneusement, sinon les informations récoltées pourraient ne rien valoir.
    Dans la plupart des cas où des problèmes sont découverts, c'est
    l'instrumentation qui est erronée, pas le système sous-jacent. En discutant
    des informations récupérées en utilisant un tel système, il est essentiel de
    s'assurer que le script utilisé est lui-aussi vérifié et discuter.
   </para>
  </sect2>

  <sect2 id="defining-trace-points">
   <title>Définir de nouvelles sondes</title>

   <para>
    De nouvelles sondes peuvent être définies dans le code partout où le
    développeur le souhaite bien que cela nécessite une nouvelle compilation.
    Voici les étapes nécessaires pour insérer de nouvelles sondes&nbsp;:
   </para>

   <procedure>
    <step>
     <para>
      Décider du nom de la sonde et des données nécessaires pour la sonde
     </para>
    </step>

    <step>
     <para>
      Ajoutez les définitions de sonde dans
      <filename>src/backend/utils/probes.d</filename>
     </para>
    </step>

    <step>
     <para>
      Inclure <filename>pg_trace.h</filename> s'il n'est pas déjà présent dans le
      module contenant les points de sonde, et insérer les macros
      <literal>TRACE_POSTGRESQL</literal> aux emplacements souhaités dans le code
      source
     </para>
    </step>

    <step>
     <para>
      Recompiler et vérifier que les nouvelles sondes sont disponibles
     </para>
    </step>
   </procedure>

   <formalpara>
    <title>Exemple&nbsp;:</title>
    <para>
     Voici un exemple d'ajout d'une sonde pour tracer toutes les nouvelles
     transactions par identifiant de transaction.
    </para>
   </formalpara>

   <procedure>
    <step>
     <para>
      La sonde sera nommée <literal>transaction-start</literal> et nécessite
      un paramètre de type <type>LocalTransactionId</type>
     </para>
    </step>

    <step>
     <para>
      Ajout de la définition de la sonde dans
      <filename>src/backend/utils/probes.d</filename>&nbsp;:
      <programlisting>
       probe transaction__start(LocalTransactionId);
      </programlisting>
      Notez l'utilisation du double tiret bas dans le nom de la sonde. Dans un
      script DTrace utilisant la sonde, le double tiret bas doit être remplacé
      par un tiret, donc <literal>transaction-start</literal> est le nom à
      documenter pour les utilisateurs.
     </para>
    </step>

    <step>
     <para>
      Au moment de la compilation, <literal>transaction__start</literal> est
      converti en une macro appelée <literal>TRACE_POSTGRESQL_TRANSACTION_START</literal>
      (notez que les tirets bas ne sont plus doubles ici), qui est disponible
      en incluant le fichier <filename>pg_trace.h</filename>. Il faut ajouter
      l'appel à la macro aux bons emplacements dans le code source. Dans ce
      cas, cela ressemble à&nbsp;:

      <programlisting>
     TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
      </programlisting>
     </para>
    </step>

    <step>
     <para>
      Après une nouvelle compilation et l'exécution du nouveau binaire, il
      faut vérifier que la nouvelle sonde est disponible en exécutant la
      commande DTrace suivante. Vous deviez avoir cette sortie&nbsp;:
      <screen>
 # dtrace -ln transaction-start
    ID    PROVIDER          MODULE           Fonction NAME
 18705 postgresql49878     postgres     StartTransactionCommand transaction-start
 18755 postgresql49877     postgres     StartTransactionCommand transaction-start
 18805 postgresql49876     postgres     StartTransactionCommand transaction-start
 18855 postgresql49875     postgres     StartTransactionCommand transaction-start
 18986 postgresql49873     postgres     StartTransactionCommand transaction-start
      </screen>
     </para>
    </step>
   </procedure>

   <para>
    Il faut faire attention à d'autres choses lors de l'ajout de macros de
    trace dans le code C&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       Vous devez faire attention au fait que les types de données indiqués
       pour les paramètres d'une sonde correspondent aux types de données des
       variables utilisées dans la macro. Dans le cas contraire, vous obtiendrez
       des erreurs de compilation.
      </para>
     </listitem>


     <listitem>
      <para>
       Sur la plupart des plateformes, si <productname>PostgreSQL</productname>
       est construit avec <option>--enable-dtrace</option>, les arguments pour
       une macro de trace seront évalués à chaque fois que le contrôle passe
       dans la macro, <emphasis>même si aucun traçage n'est réellement en
        cours</emphasis>. Cela a généralement peu d'importance si vous rapportez
       seulement les valeurs de quelques variables locales, mais faites bien
       attention à l'utilisation de fonctions coûteuses. Si vous devez le faire,
       pensez à protéger la macro avec une vérification pour vous assurer que
       la trace est bien activée&nbsp;:

       <programlisting>
     if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
         TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));
       </programlisting>

       Chaque macro de trace a une macro <literal>ENABLED</literal>
       correspondante.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="diskusage">
  <title>Surveiller l'utilisation du disque</title>

  <para>
   Cette section discute de la surveillance de l'utilisation du disque sur un
   système de bases de données <productname>PostgreSQL</productname>.
  </para>

  <sect2 id="disk-usage">
   <title>Déterminer l'utilisation du disque</title>

   <indexterm zone="disk-usage">
    <primary>utilisation du disque</primary>
   </indexterm>

   <para>
    Chaque table a un fichier disque primaire où la plupart des données est
    enregistrée. Si la table a des colonnes potentiellement volumineuses,
    un fichier <acronym>TOAST</acronym>, associé à la table, est utilisé pour
    enregistrer les valeurs trop volumineuses pour tenir confortablement dans
    le fichier principal (voir <xref linkend="storage-toast"/>). Il existe
    un index sur la table <acronym>TOAST</acronym>. Il peut aussi y avoir
    des index sur la table de base. Chaque table et index sont enregistrés dans
    un fichier séparé sur disque &mdash; potentiellement plus d'un fichier, si
    le fichier dépasse 1 Go. Les conventions de nommage de ces fichiers sont
    décrits dans <xref linkend="storage-file-layout"/>.
   </para>

   <para>
    Vous pouvez superviser l'espace disque de trois façons&nbsp;: en utilisant
    les fonctions SQL listées dans <xref linkend="functions-admin-dbsize"/>, en
    utilisant le module <xref linkend="oid2name"/> ou en inspectant manuellement
    les catalogues systèmes. Les fonctions SQL sont le moyen le plus simple à
    utiliser et sont de ce fait les plus fréquemment recommendées. Le reste de
    cette section montre comment le faire à partir d'une inspection des
    catalogues systèmes.
   </para>

   <para>
    En utilisant <application>psql</application> sur une base récemment traitée
    par un VACUUM ou un ANALYZE, vous pouvez lancer la requête suivante pour
    voir l'utilisation disque d'une table&nbsp;:
<programlisting>
SELECT pg_relation_filepath(oid), relpages FROM pg_class WHERE relname = 'customer';

 pg_relation_filepath | relpages
----------------------+----------
 base/16384/16806     |       60
(1 row)
</programlisting>
    Chaque bloc fait habituellement 8 Ko. (Pour rappel,
    <structfield>relpages</structfield> est seulement mis à jour par les
    commandes <command>VACUUM</command>, <command>ANALYZE</command> et quelques
    commandes DDL telles que <command>CREATE INDEX</command>.) Le chemin du
    fichier est intéressant si vous souhaitez examiner le fichier de la table
    directement sur le disque.
   </para>

   <para>
    Pour afficher l'espace utilisé par les tables <acronym>TOAST</acronym>,
    utilisez la requête suivante&nbsp;:
<programlisting>
SELECT relname, relpages
FROM pg_class,
     (SELECT reltoastrelid
      FROM pg_class
      WHERE relname = 'customer') AS ss
WHERE oid = ss.reltoastrelid OR
      oid = (SELECT indexrelid
             FROM pg_index
             WHERE indrelid = ss.reltoastrelid)
ORDER BY relname;

       relname        | relpages
----------------------+----------
 pg_toast_16806       |        0
 pg_toast_16806_index |        1
</programlisting>
   </para>

   <para>
    Vous pouvez aisément afficher les tailles des index&nbsp;:
<programlisting>
SELECT c2.relname, c2.relpages
FROM pg_class c, pg_class c2, pg_index i
WHERE c.relname = 'customer' AND
      c.oid = i.indrelid AND
      c2.oid = i.indexrelid
ORDER BY c2.relname;

      relname      | relpages
-------------------+----------
 customer_id_index |       26
</programlisting>
   </para>

   <para>
    Il est facile de trouver vos tables et index les plus volumineux en
    utilisant cette requête&nbsp;:
<programlisting>
SELECT relname, relpages
FROM pg_class
ORDER BY relpages DESC;

       relname        | relpages
----------------------+----------
 bigtable             |     3290
 customer             |     3144
</programlisting>
   </para>
  </sect2>

  <sect2 id="disk-full">
   <title>Échecs pour cause de disque plein</title>

   <para>
    La tâche la plus importante en ce qui concerne la supervision des disques
    pour un administrateur de base de données est de s'assurer que le disque
    ne devienne pas plein. Un disque plein ne causera pas de corrution de
    données mais empêchera toute activité utile. Si le disque contenant les
    fichiers WAL devient plein, le serveur entre en mode panique et un arrêt
    survient.
   </para>

   <para>
    Si vous ne pouvez pas libérer de l'espace sur le disque en supprimant
    d'autres choses, vous pouvez déplacer certains fichiers de la base vers
    d'autres systèmes de fichier en utilisant des tablespaces. Voir <xref
    linkend="manage-ag-tablespaces"/> pour plus d'informations sur cela.
   </para>

   <tip>
    <para>
     Certains systèmes de fichiers sont contre-performants quand ils sont
     pratiquement plein, donc n'attendez pas que le disque soit plein pour
     entrer en action.
    </para>
   </tip>

   <para>
    Si votre système supporte des quotas disque par utilisateur, alors la base
    de données sera naturellement sujette à tout quota placé sur l'utilisateur
    qui exécute le serveur. Atteindre le quota aura les mêmes mauvais effets
    qu'un disque complètement plein.
   </para>
  </sect2>
 </sect1>
</chapter>
