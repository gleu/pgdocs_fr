<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="monitoring">
 <title>Surveiller l'activité de la base de données</title>

 <indexterm zone="monitoring">
  <primary>surveiller</primary>
  <secondary>activité de la base de données</secondary>
 </indexterm>

 <indexterm zone="monitoring">
  <primary>activité de la base de données</primary>
  <secondary>suveiller</secondary>
 </indexterm>

 <para>
  Un administrateur de bases de données se demande fréquemment&nbsp;: <quote>Que
   fait le système en ce moment&nbsp;?</quote> Ce chapitre explique la façon
  de le savoir.
 </para>

 <para>
  Plusieurs outils sont disponibles pour surveiller l'activité de la base de
  données et pour analyser les performances. Une grande partie de ce chapitre
  concerne la description du récupérateur de statistiques de
  <productname>PostgreSQL</productname> mais personne ne devrait négliger les
  programmes de surveillance Unix standards tels que <command>ps</command>,
  <command>top</command>, <command>iostat</command> et <command>vmstat</command>. De plus, une fois
  qu'une requête peu performante a été identifiée, des investigations
  supplémentaires pourraient être nécessaires en utilisant la commande <xref
  linkend="sql-explain"/> de
  <productname>PostgreSQL</productname>. La <xref linkend="using-explain"/>
  discute de <command>EXPLAIN</command> et des autres méthodes pour comprendre le
  comportement d'une seule requête.
 </para>

 <sect1 id="monitoring-ps">
  <title>Outils Unix standard</title>

  <indexterm zone="monitoring-ps">
   <primary>ps</primary>
   <secondary>pour surveiller l'activité</secondary>
  </indexterm>

  <para>
   Sur la plupart des plateformes Unix, <productname>PostgreSQL</productname> modifie
   son titre de commande reporté par <command>ps</command> de façon à ce que les
   processus serveur individuels puissent être rapidement identifiés. Voici un
   affichage d'exemple&nbsp;:

   <screen>$ ps auxww | grep ^postgres
postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -i
postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: background writer
postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: checkpointer
postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: walwriter
postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: autovacuum launcher
postgres  15558  0.0  0.0  17512  1068 ?        Ss   18:02   0:00 postgres: stats collector
postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: joe runbug 127.0.0.1 idle
postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: tgl regression [local] SELECT waiting
postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: tgl regression [local] idle in transaction
   </screen>

   (L'appel approprié de <command>ps</command> varie suivant les différentes
   plateformes, de même que les détails affichés. Cet exemple est
   tiré d'un système Linux récent.) Le premier processus affiché ici est le
   processus serveur maître. Les arguments
   affichés pour cette commande sont les mêmes qu'à son lancement. Les cinq
   processus suivants sont des processus en tâche de fond lancés
   automatiquement par le processus maître (le processus
   <quote>stats collector</quote> n'est pas présent si
   vous avez configuré le système pour qu'il ne lance pas le récupérateur de
   statistiques&nbsp;; de même que le processus <quote>autovacuum launcher</quote> peut être
   désactivé). Chacun des autres processus est un processus serveur gérant
   une connexion cliente. Tous ces processus restants initialisent l'affichage de
   la ligne de commande sous la forme&nbsp;:

   <screen>postgres: <replaceable>utilisateur</replaceable> <replaceable>base_de_données</replaceable> <replaceable>hôte</replaceable> <replaceable>activité</replaceable></screen>

  L'utilisateur, la base de données et les éléments de l'hôte (client)
  restent identiques pendant toute la vie de connexion du client mais,
  l'indicateur d'activité change. L'activité pourrait être <literal>idle</literal>
  (c'est-à-dire en attente d'une commande du client), <literal>idle in
  transaction</literal> (en attente du client à l'intérieur d'un bloc de
  <command>BEGIN</command>/<command>COMMIT</command>) ou un nom de commande du type
  <literal>SELECT</literal>. De plus, <literal>waiting</literal> est ajouté si le processus
  serveur est en attente d'un verrou détenu par une autre session.
  Dans l'exemple ci-dessus, nous pouvons supposer que le processus 15606 attend
  que le processus 15610 finisse sa transaction, et par conséquent libère un
  verrou (le processus 15610 doit être celui qui bloque car il n'y a aucune
  autre session active. Dans des cas plus compliqués, il serait nécessaire de
  regarder dans la vue système <link
  linkend="view-pg-locks"><structname>pg_locks</structname></link> pour
  déterminer qui est en train de bloquer qui.)
  </para>

  <para>
   Si <xref linkend="guc-cluster-name"/> a été configuré, le nom de l'instance
   figurera également dans la sortie&nbsp;:
<screen>
$ psql -c 'SHOW cluster_name'
 cluster_name
--------------
 server1
(1 row)

$ ps aux|grep server1
postgres   27093  0.0  0.0  30096  2752 ?        Ss   11:34   0:00 postgres: server1: background writer
...
</screen>
  </para>

  <para>
   Si vous avez désactivé <xref linkend="guc-update-process-title"/>, alors
   l'indicateur d'activité n'est pas mis à jour&nbsp;; le titre du processus
   est configuré une seule fois quand un nouveau processus est lancé. Sur
   certaines plateformes, ceci permet d'économiser du temps. Sur d'autres,
   cette économie est insignifiante.
  </para>

  <tip>
  <para>
  <productname>Solaris</productname> requiert une gestion particulière. Vous
  devez utiliser <command>/usr/ucb/ps</command> plutôt que
  <command>/bin/ps</command>. Vous devez aussi utiliser deux options
  <option>w</option> et non pas seulement une. En plus, votre appel original de
  la commande <command>postgres</command> doit avoir un affichage de statut
  dans <command>ps</command> plus petit que celui fourni par les autres
  processus serveur. Vous devez donc faire ces trois opérations sinon l'affichage de
  <command>ps</command> pour chaque processus serveur sera la ligne de commande
  originale de <command>postgres</command>.
  </para>
  </tip>
 </sect1>

 <sect1 id="monitoring-stats">
  <title>Le récupérateur de statistiques</title>

  <indexterm zone="monitoring-stats">
   <primary>statistiques</primary>
  </indexterm>

  <para>
   Le <firstterm>récupérateur de statistiques</firstterm> de
   <productname>PostgreSQL</productname> est un sous-système qui prend en charge la
   récupération et les rapports d'informations sur l'activité du serveur.
   Actuellement, le récupérateur peut compter les accès aux tables et index à la
   fois en termes de blocs disque et de lignes individuelles. Il conserve aussi
   la trace du nombre total de lignes dans chaque table ainsi que des informations
   sur les VACUUM et les ANALYZE pour chaque table.
   Il peut aussi compter le nombre d'appels aux fonctions définies par
   l'utilisateur ainsi que le temps total dépensé par chacune d'elles.
  </para>

  <para>
   <productname>PostgreSQL</productname> est également capable de
   renvoyer des informations dynamiques en temps réel sur ce qu'il se passe exactement
   dans le système, comme la commande exacte en cours
   d'exécution par d'autres processus serveur et les autres
   connexions qui existent dans le système. Cette fonctionnalité est indépendante
   du processus de récupération de données statistiques.
  </para>

 <sect2 id="monitoring-stats-setup">
  <title>Configuration de la récupération de statistiques</title>

  <para>
   Comme la récupération de statistiques ajoute un temps supplémentaire à
   l'exécution de la requête, le système peut être configuré pour récupérer ou
   non des informations. Ceci est contrôlé par les paramètres de configuration
   qui sont normalement initialisés dans <filename>postgresql.conf</filename> (voir
   <xref linkend="runtime-config"/> pour plus de détails sur leur
   initialisation).
  </para>

  <para>
   Le paramètre <xref linkend="guc-track-activities"/> active la collecte
   d'informations sur la commande en cours d'exécution pour n'importe quel
   processus serveur.
  </para>

  <para>
   Le paramètre <xref linkend="guc-track-counts"/> contrôle si les statistiques
   sont récupérées pour les accès aux tables et index.
  </para>

  <para>
   Le paramètre <xref linkend="guc-track-functions"/> active le calcul de
   statistiques sur l'utilisation des fonctions définies par l'utilisateur.
  </para>

  <para>
   Le paramètre <xref linkend="guc-track-io-timing"/> active la collecte
   des temps de lecture et d'écriture de blocs.
  </para>

  <para>
   Normalement, ces paramètres sont configurés dans
   <filename>postgresql.conf</filename> de façon à ce qu'ils s'appliquent à tous les
   processus serveur, mais il est possible de les activer/désactiver sur des
   sessions individuelles en utilisant la commande <xref
   linkend="sql-set"/> (pour empêcher les utilisateurs
   ordinaires de cacher leur activité à l'administrateur, seuls les
   superutilisateurs sont autorisés à modifier ces paramètres avec
   <command>SET</command>).
  </para>

  <para>
   Le collecteur de statistiques transmet l'information récupérée
   aux autres processus <productname>PostgreSQL</productname> à travers
   des fichiers temporaires. Ces fichiers sont stockés dans le répertoire
   défini par le paramètre <xref linkend="guc-stats-temp-directory"/>,
   par défaut <filename>pg_stat_tmp</filename>.
   Pour de meilleures performances, <varname>stats_temp_directory</varname>
   peut pointer vers un disque en RAM, diminuant ainsi les besoins en
   entrées/sorties physiques. Quand le serveur s'arrête proprement, une copie
   permanente des données statistiques est stockée dans le sous-répertoire
   <filename>pg_stat</filename>, pour que les statistiques puissent être
   conservées puis réutilisées au redémarrage du serveur. Lorsqu'au démarrage du
   serveur, la restauration est réalisée (par exemple, après un arrêt
   immédiat, un crash du serveur ou encore après une restauration PITR), tous
   les compteurs statistiques sont réinitialisés.
  </para>

  <para>
   Une transaction peut aussi voir des statistiques propres à son
   activité (qui ne sont pas encore transmises au collecteur) dans les
   vues <structname>pg_stat_xact_all_tables</structname>,
   <structname>pg_stat_xact_sys_tables</structname>,
   <structname>pg_stat_xact_user_tables</structname> et
   <structname>pg_stat_xact_user_functions</structname>.
   Ces informations se mettent à jour
   en continu pendant l'exécution de la transaction.
  </para>

 </sect2>

 <sect2 id="monitoring-stats-views">
  <title>Visualiser les statistiques</title>

  <para>
   Plusieurs vues prédéfinies, listées à <xref
   linkend="monitoring-stats-dynamic-views-table"/>, sont disponibles pour
   montrer l'état courant du système. Il existe aussi plusieurs autres
   vues, listées à <xref linkend="monitoring-stats-views-table"/>,
   qui montrent les résultats des statistiques
   récupérées. De manière alternative, il est possible de
   créer des vues personnalisées qui utilisent les
   fonctions statistiques sous-jacentes, comme discuté à <xref
   linkend="monitoring-stats-functions"/>.
  </para>

  <para>
   En utilisant les statistiques pour surveiller l'activité en cours, il est
   important de réaliser que l'information n'est pas mise à jour instantanément.
   Chaque processus serveur individuel transmet les nouvelles statistiques au
   récupérateur juste avant l'attente d'une
   nouvelle commande du client&nbsp;; donc une requête toujours en cours
   n'affecte pas les totaux affichés. De plus, le récupérateur lui-même émet un
   nouveau rapport une fois par <varname>PGSTAT_STAT_INTERVAL</varname>
   millisecondes (soit 500 millisecondes, sauf si cette valeur a été modifiée lors de la
   construction du serveur). Donc, les totaux affichés sont bien derrière
   l'activité réelle. Néanmoins, l'information sur la requête en cours récupérée
   par <varname>track_activities</varname> est toujours à jour.
  </para>

  <para>
   Un autre point important est que, lorsqu'un processus serveur se voit
   demander d'afficher une des statistiques, il récupère tout d'abord le rapport
   le plus récent émis par le processus de récupération, puis continue
   d'utiliser cette image de toutes les vues et fonctions statistiques jusqu'à
   la fin de sa transaction en cours. De façon similaire, les informations sur
   les requêtes en cours, quel que soit le processus, sont récupérées quand une
   telle information est demandée dans une transaction, et cette même information
   sera affichée lors de la transaction. Donc, les statistiques afficheront des
   informations statiques tant que vous restez dans la même transaction. Ceci est une
   fonctionnalité, et non pas un bogue, car il vous permet de traiter plusieurs
   requêtes sur les statistiques et de corréler les résultats sans vous
   inquiéter que les nombres aient pu changer. Mais si vous voulez voir les
   nouveaux résultats pour chaque requête, assurez-vous de lancer les requêtes
   en dehors de tout bloc de transaction. Autrement, vous pouvez appeler
   <function>pg_stat_clear_snapshot</function>(), qui annulera l'image statistique
   de la transaction en cours. L'utilisation suivante des informations
   statistiques causera la récupération d'une nouvelle image.
  </para>

  <table id="monitoring-stats-dynamic-views-table">
   <title>Vues statistiques dynamiques</title>

   <tgroup cols="2">
    <colspec colnum="1" colwidth="0.4*"/>
    <colspec colnum="2" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom de la vue</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <structname>pg_stat_activity</structname>
       <indexterm><primary>pg_stat_activity</primary></indexterm>
      </entry>
      <entry>
       Une ligne par processus serveur, montrant les informations
       liées à l'activité courante du processus, comme l'état et la
       requête en cours. Voir <xref linkend="pg-stat-activity-view"/>
       pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_replication</structname><indexterm><primary>pg_stat_replication</primary></indexterm></entry>
      <entry>Une ligne par processus d'envoi de WAL, montrant les
       statistiques sur la réplication vers le serveur standby connecté
       au processus.
       Voir <xref linkend="pg-stat-replication-view"/> pour les détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_wal_receiver</structname><indexterm><primary>pg_stat_wal_receiver</primary></indexterm></entry>
      <entry>Seulement une ligne, affichant des statistiques sur le récepteur
       WAL à partir du serveur ayant ce récepteur. Voir <xref
       linkend="pg-stat-wal-receiver-view"/> pour les détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_subscription</structname><indexterm><primary>pg_stat_subscription</primary></indexterm></entry>
      <entry>Au moins une ligne par souscription, affichant des informations
       sur les processus workers de souscription. Voir <xref
       linkend="pg-stat-subscription"/> pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_ssl</structname><indexterm><primary>pg_stat_ssl</primary></indexterm></entry>
      <entry>Une ligne par connexion (régulière et de réplication),
       montrant des informations sur le chiffrement SSL utilisé pour
       ces connexions.
       Voir <xref linkend="pg-stat-ssl-view"/> pour les détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_progress_vacuum</structname><indexterm><primary>pg_stat_progress_vacuum</primary></indexterm></entry>
      <entry>Une ligne pour chaque processus (incluant les processus
       autovacuum worker) exécutant un <command>VACUUM</command>, affichant le
       progrès en cours. Voir <xref
       linkend='vacuum-progress-reporting'/>.</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <table id="monitoring-stats-views-table">
   <title>Vues sur les statistiques récupérées</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>Nom de la vue</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structname>pg_stat_archiver</structname><indexterm><primary>pg_stat_archiver</primary></indexterm></entry>
      <entry>Une seule ligne, montrant les statistiques sur l'activité du
        processus d'archivage des journaux de transactions. Voir <xref
        linkend="pg-stat-archiver-view"/> pour les détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_bgwriter</structname><indexterm><primary>pg_stat_bgwriter</primary></indexterm></entry>
      <entry>Une seule ligne, montrant les statistiques
       d'activité du processus d'écriture d'arrière-plan.
       Voir <xref linkend="pg-stat-bgwriter-view"/> pour plus de détails.
     </entry>
     </row>

     <row>
      <entry><structname>pg_stat_database</structname><indexterm><primary>pg_stat_database</primary></indexterm></entry>
      <entry>Une ligne par base de données, montrant les statistiques
       globales des bases. Voir <xref linkend="pg-stat-database-view"/>
       pour plus de détails.
      </entry>
     </row>
     </tbody>

     <row>
      <entry><structname>pg_stat_database_conflicts</structname><indexterm><primary>pg_stat_database_conflicts</primary></indexterm></entry>
      <entry>
       Une ligne par base de données, montrant les statistiques au
       niveau de la base concernant les requêtes annulées à cause de
       conflits avec les serveurs standby en restauration.
       Voir <xref linkend="pg-stat-database-conflicts-view"/> pour les détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_tables</structname><indexterm><primary>pg_stat_all_tables</primary></indexterm></entry>
      <entry>
       Une ligne par table de la base de données courante, montrant les
       statistiques d'accès de chaque table spécifiquement. Voir
       <xref linkend="pg-stat-all-tables-view"/> pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_tables</structname><indexterm><primary>pg_stat_sys_tables</primary></indexterm></entry>
      <entry>Identique à <structname>pg_stat_all_tables</structname>, sauf que seules les
      tables systèmes sont affichées</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_tables</structname><indexterm><primary>pg_stat_user_tables</primary></indexterm></entry>
      <entry>Identique à <structname>pg_stat_all_tables</structname>, sauf que seules les
      tables utilisateurs sont affichées</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_all_tables</structname><indexterm><primary>pg_stat_xact_all_tables</primary></indexterm></entry>
      <entry>Similaire à <structname>pg_stat_all_tables</structname>, mais
      décompte les actions prises dans la transaction en cours (qui ne
      sont <emphasis>pas</emphasis> encore pris en compte dans la vue
      <structname>pg_stat_all_tables</structname> et les vues du même
      type). Les colonnes correspondant au nombre de lignes vivantes et
      mortes, ainsi que celles pour les actions du VACUUM et de l'ANALYZE
      ne sont pas présentes dans cette vue</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_sys_tables</structname><indexterm><primary>pg_stat_xact_sys_tables</primary></indexterm></entry>
      <entry>Identique à <structname>pg_stat_xact_all_tables</structname>,
      sauf que seules les tables systèmes sont affichées</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_user_tables</structname><indexterm><primary>pg_stat_xact_user_tables</primary></indexterm></entry>
      <entry>Identique à <structname>pg_stat_xact_all_tables</structname>, sauf que seules les
      tables utilisateurs sont affichées</entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_indexes</structname><indexterm><primary>pg_stat_all_indexes</primary></indexterm></entry>
      <entry>
       Une ligne par index de la base de données courante, montrant les
       statistiques d'accès de chaque index spécifiquement. Voir
       <xref linkend="pg-stat-all-indexes-view"/> pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_indexes</structname><indexterm><primary>pg_stat_sys_indexes</primary></indexterm></entry>
      <entry>Identique à <structname>pg_stat_all_indexes</structname>, sauf que seules les
      tables systèmes sont affichées</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_indexes</structname><indexterm><primary>pg_stat_user_indexes</primary></indexterm></entry>
      <entry>Identique à <structname>pg_stat_all_indexes</structname>, sauf que seules
      les tables utilisateurs sont affichées</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_tables</structname><indexterm><primary>pg_statio_all_tables</primary></indexterm></entry>
      <entry>
       Une ligne par table de la base de données courante, montrant les
       statistiques d'entrées/sorties de chaque table spécifiquement. Voir
       <xref linkend="pg-statio-all-tables-view"/> pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_tables</structname><indexterm><primary>pg_statio_sys_tables</primary></indexterm></entry>
      <entry>Identique à <structname>pg_statio_all_tables</structname>, sauf que seules
      les tables systèmes sont affichées</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_tables</structname><indexterm><primary>pg_statio_user_tables</primary></indexterm></entry>
      <entry>Identique à <structname>pg_statio_all_tables</structname>, sauf que seules
      les tables utilisateur sont affichées</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_indexes</structname><indexterm><primary>pg_statio_all_indexes</primary></indexterm></entry>
      <entry>
       Une ligne par index de la base de données courante, montrant les
       les statistiques d'entrées/sorties de chaque index spécifiquement. Voir
       <xref linkend="pg-statio-all-indexes-view"/> pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_indexes</structname><indexterm><primary>pg_statio_sys_indexes</primary></indexterm></entry>
      <entry>Identique à <structname>pg_statio_all_indexes</structname>, sauf que seuls
      les index systèmes sont affichés</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_indexes</structname><indexterm><primary>pg_statio_user_indexes</primary></indexterm></entry>
      <entry>Identique à <structname>pg_statio_all_indexes</structname>, sauf que seuls
      les index utilisateur sont affichés</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_sequences</structname><indexterm><primary>pg_statio_all_sequences</primary></indexterm></entry>
     <entry>
       Une ligne par séquence de la base de données courante, montrant les
       statistiques d'entrées/sorties de chaque séquence spécifiquement. Voir
       <xref linkend="pg-statio-all-sequences-view"/> pour plus de détails.
     </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_sequences</structname><indexterm><primary>pg_statio_sys_sequences</primary></indexterm></entry>
      <entry>Identique à <structname>pg_statio_all_sequences</structname>, sauf que
      seules les séquences système sont affichées (actuellement, aucune
      séquence système n'est définie, donc cette vue est toujours vide)</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_sequences</structname><indexterm><primary>pg_statio_user_sequences</primary></indexterm></entry>
      <entry>Identique à <structname>pg_statio_all_sequences</structname>, sauf que
      seules les séquences utilisateur sont affichées</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_functions</structname><indexterm><primary>pg_stat_user_functions</primary></indexterm></entry>
      <entry>
       Une ligne par fonction suivie, montrant les statistiques
       d'exécution de cette fonction. Voir
       <xref linkend="pg-stat-user-functions-view"/> pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_user_functions</structname><indexterm><primary>pg_stat_xact_user_functions</primary></indexterm></entry>
      <entry>Similaire à <structname>pg_stat_user_functions</structname>,
      mais compte seulement les appels pendant la transaction en cours
      (qui ne sont <emphasis>pas</emphasis> encore inclus dans
      <structname>pg_stat_user_functions</structname>)</entry>
     </row>
    </tgroup>
   </table>
  </sect2>

  <para>
   Les statistiques par index sont particulièrement utiles pour déterminer
   les index utilisés et leur efficacité.
  </para>

  <para>
   Les vues <structname>pg_statio_</structname> sont principalement utiles pour
   déterminer l'efficacité du cache tampon. Quand le nombre de lectures disques
   réelles est plus petit que le nombre de récupérations valides par le tampon,
   alors le cache satisfait la plupart des demandes de lecture sans faire appel
   au noyau. Néanmoins, ces statistiques ne nous donnent pas l'histoire
   complète&nbsp;: à cause de la façon dont <productname>PostgreSQL</productname> gère les
   entrées/sorties disque, les données qui ne sont pas dans le tampon de
   <productname>PostgreSQL</productname> pourraient toujours résider dans le tampon
   d'entrées/sorties du noyau et pourraient, du coup, être toujours récupérées
   sans nécessiter une lecture physique. Les utilisateurs intéressés pour
   obtenir des informations plus détaillées sur le comportement des
   entrées/sorties dans <productname>PostgreSQL</productname> sont invités à utiliser le
   récupérateur de statistiques de <productname>PostgreSQL</productname> avec les outils du
   système d'exploitation permettant une vue de la gestion des
   entrées/sorties par le noyau.
  </para>

  <table id="pg-stat-activity-view" xreflabel="pg_stat_activity">
   <title>Vue <structname>pg_stat_activity</structname></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="2.0*"/>
    <colspec colnum="2" colwidth="0.3*"/>
    <colspec colnum="3" colwidth="1.2*"/>
    <thead>
    <row>
      <entry>Colonne</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID de la base de données auquelle ce processus serveur est connecté</entry>
    </row>
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom de la base de données auquelle ce processus serveur est connecté</entry>
    </row>
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Identifiant du processus serveur</entry>
    </row>
    <row>
     <entry><structfield>usesysid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID de l'utilisateur connecté à ce processus serveur</entry>
    </row>
    <row>
     <entry><structfield>usename</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom de l'utilisateur connecté à ce processus serveur</entry>
    </row>
    <row>
     <entry><structfield>application_name</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Nom de l'application connectée à ce processus serveur</entry>
    </row>
    <row>
     <entry><structfield>client_addr</structfield></entry>
     <entry><type>inet</type></entry>
     <entry>Adresse IP du client pour ce processus serveur.
      Si ce champ est vide, cela indique soit que le client est
      connecté via un socket Unix sur la machine serveur soit qu'il
      s'agit d'un processus interne tel qu'autovacuum.
     </entry>
    </row>
    <row>
     <entry><structfield>client_hostname</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Nom d'hôte du client connecté, comme reporté par une recherche DNS
      inverse sur <structfield>client_addr</structfield>. Ce champ ne sera rempli que
      pour les connexions IP, et seulement quand <xref
      linkend="guc-log-hostname"/> est activé.
     </entry>
    </row>
    <row>
     <entry><structfield>client_port</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Numéro de port TCP que le client utilise pour communiquer
      avec le processus serveur,
      ou <literal>-1</literal> si un socket Unix est utilisé.
     </entry>
    </row>
    <row>
     <entry><structfield>backend_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Heure de démarrage du processus.  Pour les processus backends,
      c'est l'heure où le client s'est connecté au serveur.
     </entry>
    </row>
    <row>
     <entry><structfield>xact_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Heure de démarrage de la transaction courante du
      processus, ou NULL si aucune transaction n'est active. Si la
      requête courante est la première de sa transaction, cette
      colonne a la même valeur que la colonne
      <structfield>query_start</structfield>.
     </entry>
    </row>
    <row>
     <entry><structfield>query_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Heure à laquelle la requête active a été démarrée, ou
      si <structfield>state</structfield> ne vaut pas
      <literal>active</literal>, quand la dernière requête
      a été lancée.
     </entry>
    </row>
    <row>
     <entry><structfield>state_change</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Heure à laquelle l'état (<structfield>state</structfield>) a été modifié en dernier</entry>
    </row>
    <row>
     <entry><structfield>wait_event_type</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Type de l'événement pour lequel le processus est en attente&nbsp;
      sinon NULL. Les valeurs possibles sont&nbsp;:
      <itemizedlist>
       <listitem>
        <para>
          <literal>LWLock</literal>&nbsp;: Le processus attend un verrou
          léger. Ce type de verrou protège une structure de données en mémoire
          partagée. <literal>wait_event</literal> contiendra un nom
          identifiant le but du verrou léger. (Certains verrous ont des noms
          spécifiques&nbsp;; d'autres font partie d'un groupe de verrous ayant
          chacun un but similaire.)
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>Lock</literal>&nbsp;: Le processus attend un verrou lourd.
         Les verrous lourds, connus aussi en tant que verrous du gestionnaire
         de verrous ou plus simplement verrous, protègent principalement des
         objets visibles au niveau SQL, comme les tables. Néanmoins, ils sont
         aussi utilisés pour assurer une exclusion mutuelle pour certaines
         opérations internes comme l'agrandissement d'une relation.
         <literal>wait_event</literal> identifie le type de verrou attendu.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>BufferPin</literal>&nbsp;: Le processus serveur attend
         d'accéder à un tampon de données lors d'une période où aucun autre
         processus ne peut examiner ce tampon. Les attentes sur des tampons
         peuvent rétractées si un autre processus détient un curseur ouvert
         qui a lu des données dans le tampon en question.
        </para>
       </listitem>
        <listitem>
         <para>
          <literal>Activity</literal>&nbsp;: Le processus serveur est en
          attente. Ceci est utilisé par les processus système attendant une
          activité dans leur boucle principale de traitement.
          <literal>wait_event</literal> identifiera le point d'attente
          spécifique.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>Extension</literal>&nbsp;: Le processus serveur est en
          attente d'activité dans une extension. Cette catégorie est utile
          pour que les modules puissent tracer des points d'attente.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>Client</literal>&nbsp;: Le processus serveur est en attente
          d'activité d'une application utilisateur sur un socket. Autrement
          dit, le serveur attend la venue d'une activité indépendante à ses
          traitements internes. <literal>wait_event</literal> identifiera le
          point d'attente spécifique.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>IPC</literal>&nbsp;: Le processus serveur est une attente
          d'une activité d'un autre processus serveur.
          <literal>wait_event</literal> identifiera le point d'attente
          spécifique.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>Timeout</literal>&nbsp;: Le processus serveur est en
          attente de l'expiration d'un délai. <literal>wait_event</literal>
          identifiera le point d'attente spécifique.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>IO</literal>&nbsp;: Le processus serveur est en attente de
          la fin d'une opération disque. <literal>wait_event</literal>
          identifiera le point d'attente spécifique.
         </para>
        </listitem>
      </itemizedlist>
     </entry>
    </row>
    <row>
     <entry><structfield>wait_event</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Nom de l'événement d'attente si le processus est en attente, NULL
      dans le cas contraire. Voir <xref linkend="wait-event-table"/> pour plus
      de détails.
     </entry>
    </row>
    <row>
     <entry><structfield>state</structfield></entry>
     <entry><type>text</type></entry>
     <entry>État général du processus serveur.
       Les valeurs possibles sont:
       <itemizedlist>
         <listitem>
          <para>
           <literal>active</literal>&nbsp;: le processus serveur exécute une
           requête.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle</literal>&nbsp;: le processus serveur est en attente
           d'une commande par le client.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle in transaction</literal>&nbsp;: le processus serveur
           est en transaction, mais n'est pas en train d'exécuter une requête.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle in transaction (aborted)</literal>&nbsp;: l'état est
           similaire à <literal>idle in transaction</literal>, à la différence
           qu'une des instructions de la transaction a généré une erreur.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>fastpath function call</literal>&nbsp;: le processus serveur
           exécute une fonction fast-path.
          </para>
         </listitem>
         <listitem>
           <para>
           <literal>disabled</literal>&nbsp;: cet état est affiché si <xref
           linkend="guc-track-activities"/> est désactivé pour ce processus
           serveur.
          </para>
         </listitem>
       </itemizedlist>
     </entry>
    </row>
    <row>
     <entry><structfield>backend_xid</structfield></entry>
     <entry><type>xid</type></entry>
     <entry>Identifiant de transaction de haut niveau de ce processus, si
      disponible.</entry>
    </row>
    <row>
     <entry><structfield>backend_xmin</structfield></entry>
     <entry><type>xid</type></entry>
     <entry>L'horizon <literal>xmin</literal> de ce processus.</entry>
    </row>
    <row>
     <entry><structfield>query</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Texte de la requête la plus récente pour ce processus serveur. Si
      <structfield>state</structfield> vaut <literal>active</literal>, alors
      ce champ affiche la requête en cours d'exécution. Dans tous les autres
      cas, il affichera la dernière requête à avoir été exécutée. Par défaut,
      le texte de la requête est tronqué à 1024 caractères. Cette valeur peut
      être modifiée avec le paramètre
      <xref linkend="guc-track-activity-query-size"/>.
     </entry>
    </row>
    <row>
     <entry><structfield>backend_type</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Type du processus actuel. Les types possibles sont
      <literal>logical replication launcher</literal>,
      <literal>logical replication worker</literal>,
      <literal>parallel worker</literal>, <literal>background writer</literal>,
      <literal>client backend</literal>, <literal>checkpointer</literal>,
      <literal>startup</literal>, <literal>walreceiver</literal>,
      <literal>walsender</literal> et <literal>walwriter</literal>.
      De plus, les background workers enregistrés par les extensions pourraient
      avoir des types supplémentaires.
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_activity</structname> aura une ligne par processus
   serveur, montrant des informations liées à l'activité courante de ce processus.
  </para>

  <note>
   <para>
    Les colonnes <structfield>wait_event</structfield> et
    <structfield>state</structfield> sont indépendantes. Si un processus
    serveur est dans l'état <literal>active</literal>, il pourrait, ou non,
    être en attente (<literal>waiting</literal>) d'un événement. Si l'état est
    <literal>active</literal> et si <structfield>wait_event</structfield> est
    différent de NULL, cela signifie qu'une requête est en cours d'exécution,
    mais que cette exécution est bloquée quelque part dans le système.
   </para>
  </note>
 
  <table id="wait-event-table">
   <title>Description de <structname>wait_event</structname></title>

    <tgroup cols="3">
      <thead>
       <row>
        <entry>Type d'événement d'attente</entry>
        <entry>Nom d'événement d'attente</entry>
        <entry>Description</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry morerows="64"><literal>LWLock</literal></entry>
        <entry><literal>ShmemIndexLock</literal></entry>
        <entry>Attente pour trouver ou allouer de l'espace en mémoire
         partagée.</entry>
       </row>
       <row>
        <entry><literal>OidGenLock</literal></entry>
        <entry>Attente pour allouer ou affecter un OID.</entry>
       </row>
        <row>
         <entry><literal>XidGenLock</literal></entry>
         <entry>Attente pour allouer ou affecter un identifiant de
          transaction.</entry>
        </row>
        <row>
         <entry><literal>ProcArrayLock</literal></entry>
         <entry>Attente pour obtenir une image de la base ou pour effacer un
          identifiant de transaction à la fin de la transaction.</entry>
        </row>
        <row>
         <entry><literal>SInvalReadLock</literal></entry>
         <entry>Attente pour récupérer ou supprimer des messages à partir de la
          queue partagée d'invalidation.</entry>
        </row>
        <row>
         <entry><literal>SInvalWriteLock</literal></entry>
         <entry>Attente pour ajouter un message dans la queue partagée
          d'invalidation.</entry>
        </row>
        <row>
         <entry><literal>WALBufMappingLock</literal></entry>
         <entry>Attente pour replacer un bloc dans les tampons des journaux de
          transactions.</entry>
        </row>
        <row>
         <entry><literal>WALWriteLock</literal></entry>
         <entry>Attente pour l'écriture des tampons de journaux de transactions
          sur disque.</entry>
        </row>
        <row>
         <entry><literal>ControlFileLock</literal></entry>
         <entry>Attente pour lire ou mettre à jour le fichier contrôle ou pour
          créer un nouveau journal de transactions.</entry>
        </row>
        <row>
         <entry><literal>CheckpointLock</literal></entry>
         <entry>Attente pour l'exécution d'un checkpoint.</entry>
        </row>
        <row>
         <entry><literal>CLogControlLock</literal></entry>
         <entry>Attente pour lire ou mettre à jour le statut de transaction.</entry>
        </row>
        <row>
         <entry><literal>SubtransControlLock</literal></entry>
         <entry>Attente pour lire ou mettre à jour les informations de sous-
          transactions.</entry>
        </row>
        <row>
         <entry><literal>MultiXactGenLock</literal></entry>
         <entry>Attente pour lire ou mettre à jour l'état partagé multixact.</entry>
        </row>
        <row>
         <entry><literal>MultiXactOffsetControlLock</literal></entry>
         <entry>Attente pour lire ou mettre à jour les correspondances de
          décalage multixact.</entry>
        </row>
        <row>
         <entry><literal>MultiXactMemberControlLock</literal></entry>
         <entry>Attente pour lire ou mettre à jour les correspondances de
          membre multixact.</entry>
        </row>
        <row>
         <entry><literal>RelCacheInitLock</literal></entry>
         <entry>Attente pour lire ou écrire le fichier d'initialisation du cache
          de relations.</entry>
        </row>
        <row>
         <entry><literal>CheckpointerCommLock</literal></entry>
         <entry>Attente pour gérer les demandes fsync.</entry>
        </row>
        <row>
         <entry><literal>TwoPhaseStateLock</literal></entry>
         <entry>Attente pour lire ou mettre à jour l'état des transactions
          préparées.</entry>
        </row>
        <row>
         <entry><literal>TablespaceCreateLock</literal></entry>
         <entry>Attente pour créer ou supprimer le tablespace.</entry>
        </row>
        <row>
         <entry><literal>BtreeVacuumLock</literal></entry>
          <entry>Attente pour lire ou mettre à jour les informations relatives
           au vacuum pour un index Btree.</entry>
        </row>
        <row>
         <entry><literal>AddinShmemInitLock</literal></entry>
         <entry>Attente pour gérer l'allocation d'espace en mémoire partagée.</entry>
        </row>
        <row>
         <entry><literal>AutovacuumLock</literal></entry>
         <entry>Autovacuum worker ou launcher en attente de mise à jour ou de
          lecture de l'état actuel des autovacuum worker.</entry>
        </row>
        <row>
         <entry><literal>AutovacuumScheduleLock</literal></entry>
         <entry>Attente pour s'assurer que la table sélectionnée pour un vacuum
          a justement besoin d'un vacuum.
         </entry>
        </row>
        <row>
         <entry><literal>SyncScanLock</literal></entry>
         <entry>Attente pour obtenir l'emplacement de début d'un parcours d'une
          table dans le cas de parcours synchronisés.</entry>
        </row>
        <row>
         <entry><literal>RelationMappingLock</literal></entry>
         <entry>Attente pour mettre à jour le fichier de correspondance des
          relations utilisé pour enregistrer la correspondance objet logique
          vers objet physique.
         </entry>
        </row>
        <row>
         <entry><literal>AsyncCtlLock</literal></entry>
         <entry>Attente pour lire ou mettre à jour l'état partagé de notification.</entry>
        </row>
        <row>
         <entry><literal>AsyncQueueLock</literal></entry>
         <entry>Attente pour lire ou mettre à jour les messages de notification.</entry>
        </row>
        <row>
         <entry><literal>SerializableXactHashLock</literal></entry>
         <entry>Attente pour récupérer ou enregistrer des informations sur les
         transactions sérialisables.</entry>
        </row>
        <row>
         <entry><literal>SerializableFinishedListLock</literal></entry>
         <entry>Attente pour accéder à la liste des transactions sérialisées
         terminées.</entry>
        </row>
        <row>
         <entry><literal>SerializablePredicateLockListLock</literal></entry>
         <entry>Attente pour réaliser une opération sur une liste de verrous
         détenus par les transactions sérialisées.</entry>
        </row>
        <row>
         <entry><literal>OldSerXidLock</literal></entry>
         <entry>Attente pour lire ou enregistrer des transactions sérialisées
         en conflit.</entry>
        </row>
        <row>
         <entry><literal>SyncRepLock</literal></entry>
         <entry>Attente pour lire ou mettre à jour des informations sur les
          réplicas synchrones.</entry>
        </row>
        <row>
         <entry><literal>BackgroundWorkerLock</literal></entry>
         <entry>Attente pour lire ou mettre à l'état d'un background worker.</entry>
        </row>
        <row>
         <entry><literal>DynamicSharedMemoryControlLock</literal></entry>
         <entry>Attente pour lire ou mettre à jour l'état de la mémoire partagée
         dynamique.</entry>
        </row>
        <row>
         <entry><literal>AutoFileLock</literal></entry>
         <entry>Attente pour mettre à jour le fichier
          <filename>postgresql.auto.conf</filename>.</entry>
        </row>
        <row>
         <entry><literal>ReplicationSlotAllocationLock</literal></entry>
         <entry>Attente pour allouer ou libérer un slot de réplication.</entry>
        </row>
        <row>
         <entry><literal>ReplicationSlotControlLock</literal></entry>
         <entry>Attente pour lire ou mettre à jour l'état d'un slot de réplication.</entry>
        </row>
        <row>
         <entry><literal>CommitTsControlLock</literal></entry>
         <entry>Attente pour lire ou mettre à jour les horodatages de validation
          des transactions.</entry>
        </row>
        <row>
         <entry><literal>CommitTsLock</literal></entry>
         <entry>Attente pour lire ou mettre à jour la dernière valeur
          d'horodatage de transaction.</entry>
        </row>
        <row>
         <entry><literal>ReplicationOriginLock</literal></entry>
         <entry>Attente pour configurer, supprimer ou utiliser une origine
          de réplication.</entry>
        </row>
        <row>
         <entry><literal>MultiXactTruncationLock</literal></entry>
         <entry>Attente pour lire ou tronquer une information multixact.</entry>
        </row>
        <row>
         <entry><literal>OldSnapshotTimeMapLock</literal></entry>
         <entry>Attente de lecture ou mise à jour d'informations de contrôle
          d'une ancienne image de base.</entry>
        </row>
        <row>
         <entry><literal>BackendRandomLock</literal></entry>
         <entry>Attente de la génération d'un nombre aléatoire.</entry>
        </row>
        <row>
         <entry><literal>LogicalRepWorkerLock</literal></entry>
         <entry>Attente d'une action sur le processus worker de la réplication
          logique pour se terminer.</entry>
        </row>
        <row>
         <entry><literal>CLogTruncationLock</literal></entry>
         <entry>Attente de la troncature du journal de transactions (soit pour
          le faire, soit que ce soit fait).</entry>
        </row>
        <row>
         <entry><literal>clog</literal></entry>
         <entry>Attente d'I/O sur un tampon clog (statut de transaction).</entry>
        </row>
        <row>
         <entry><literal>commit_timestamp</literal></entry>
         <entry>Attente d'I/O sur un tampon d'horodatage de validation de
          transaction.</entry>
        </row>
        <row>
         <entry><literal>subtrans</literal></entry>
         <entry>Attente d'I/O sur un tampon de sous-transaction.</entry>
        </row>
        <row>
         <entry><literal>multixact_offset</literal></entry>
         <entry>Attente d'I/O sur un tampon de décalage multixact.</entry>
        </row>
        <row>
         <entry><literal>multixact_member</literal></entry>
         <entry>Attente d'I/O sur un tampon de membre multixact.</entry>
        </row>
        <row>
         <entry><literal>async</literal></entry>
         <entry>Attente d'I/O sur un tampon async (notify).</entry>
        </row>
        <row>
         <entry><literal>oldserxid</literal></entry>
         <entry>Attente d'I/O sur un tampon oldserxid.</entry>
        </row>
        <row>
         <entry><literal>wal_insert</literal></entry>
         <entry>Attente pour insérer un WAL dans un tampon mémoire.</entry>
        </row>
        <row>
         <entry><literal>buffer_content</literal></entry>
         <entry>Attente pour lire ou écrire un bloc de données en mémoire.</entry>
        </row>
        <row>
         <entry><literal>buffer_io</literal></entry>
         <entry>Attente d'I/O sur un bloc de données.</entry>
        </row>
        <row>
         <entry><literal>replication_origin</literal></entry>
         <entry>Attente pour lire ou mettre à jour le progrès de la réplication.</entry>
        </row>
        <row>
         <entry><literal>replication_slot_io</literal></entry>
         <entry>Attente d'I/O sur un slot de réplication.</entry>
        </row>
        <row>
         <entry><literal>proc</literal></entry>
         <entry>Attente pour lire ou mettre à jour l'information de verrou par
         chemin rapide (fast-path lock).</entry>
        </row>
        <row>
         <entry><literal>buffer_mapping</literal></entry>
         <entry>Attente pour associer un bloc de données avec un tampon dans
         le groupe de tampons.</entry>
        </row>
        <row>
         <entry><literal>lock_manager</literal></entry>
         <entry>Attente pour ajouter ou examiner les verrous des processus, ou
         attente pour joindre ou quitter un groupe de verrouillage (utilisé
         par les requêtes parallélisées).</entry>
        </row>
        <row>
         <entry><literal>predicate_lock_manager</literal></entry>
         <entry>Attente pour ajouter ou examiner les infirmations sur les
          verrous de prédicat.</entry>
        </row>
        <row>
         <entry><literal>parallel_query_dsa</literal></entry>
         <entry>Attente du verrou d'allocation de la mémoire partagée dynamique
         pour les requêtes dynamiques.</entry>
        </row>
        <row>
         <entry><literal>tbm</literal></entry>
         <entry>Attente du verrou sur l'itérateur partagé TBM.</entry>
        </row>
        <row>
         <entry><literal>parallel_append</literal></entry>
         <entry>Attente pour sélectionner le sous-plan suivant pendant
         l'exécution du plan <literal>Parallel Append</literal></entry>
        </row>
        <row>
         <entry><literal>parallel_hash_join</literal></entry>
         <entry>Attente pour allouer ou changer une portion de la mémoire ou
         pour mettre à jour les compteurs pendant l'exécution d'un
         <literal>Parallel Hash</literal> du plan d'exécution.
         </entry>
        </row>
        <row>
         <entry morerows="9"><literal>Lock</literal></entry>
         <entry><literal>relation</literal></entry>
         <entry>Attente pour acquérir un verrou sur une relation.</entry>
        </row>
        <row>
         <entry><literal>extend</literal></entry>
         <entry>Attente pour étendre une relation.</entry>
        </row>
        <row>
         <entry><literal>page</literal></entry>
         <entry>Attente pour acquérir un verrou sur une page d'une relation.</entry>
        </row>
        <row>
         <entry><literal>tuple</literal></entry>
         <entry>Attente pour acquérir un verrou sur une ligne.</entry>
        </row>
        <row>
         <entry><literal>transactionid</literal></entry>
         <entry>Attente de la fin d'une transaction.</entry>
        </row>
        <row>
         <entry><literal>virtualxid</literal></entry>
         <entry>Attente pour acquérir un verrou de transaction virtuel.</entry>
        </row>
        <row>
         <entry><literal>speculative token</literal></entry>
         <entry>Attente pour acquérir un verrou d'insertion spéculatif.</entry>
        </row>
        <row>
         <entry><literal>object</literal></entry>
         <entry>Attente pour acquérir un verrou sur un objet de base qui n'est
         pas une relation.</entry>
        </row>
        <row>
         <entry><literal>userlock</literal></entry>
         <entry>Attente pour acquérir un verrou utilisateur.</entry>
        </row>
        <row>
         <entry><literal>advisory</literal></entry>
         <entry>Attente pour acquérir un verrou utilisateur informatif.</entry>
        </row>
        <row>
         <entry><literal>BufferPin</literal></entry>
         <entry><literal>BufferPin</literal></entry>
         <entry>Attente pour acquérir un blocage d'un tampon.</entry>
        </row>
        <row>
         <entry morerows="13"><literal>Activity</literal></entry>
         <entry><literal>ArchiverMain</literal></entry>
         <entry>Attente dans la boucle principale du processus
         d'archivage.</entry>
        </row>
        <row>
         <entry><literal>AutoVacuumMain</literal></entry>
         <entry>Attente dans la boucle principale du processus autovacuum
         launcher.</entry>
        </row>
        <row>
         <entry><literal>BgWriterHibernate</literal></entry>
         <entry>Attente du processus background writer, hibernation.</entry>
        </row>
        <row>
         <entry><literal>BgWriterMain</literal></entry>
         <entry>Attente dans la boucle principale du processus background
         writer.</entry>
        </row>
        <row>
         <entry><literal>CheckpointerMain</literal></entry>
         <entry>Attente dans la boucle principale du processus
         checkpointer.</entry>
        </row>
        <row>
         <entry><literal>LogicalApplyMain</literal></entry>
         <entry>Attente dans la boucle principale du processus logical
         apply.</entry>
        </row>
        <row>
         <entry><literal>LogicalLauncherMain</literal></entry>
         <entry>Attente dans la boucle principale du processus logical
         launcher.</entry>
        </row>
        <row>
         <entry><literal>PgStatMain</literal></entry>
         <entry>Attente dans la boucle principale du processus de collecte des
         statistiques.</entry>
        </row>
        <row>
         <entry><literal>RecoveryWalAll</literal></entry>
         <entry>Attente de WAL à partir de tout type de source (local, archive
         ou flux) lors de la restauration.</entry>
        </row>
        <row>
         <entry><literal>RecoveryWalStream</literal></entry>
         <entry>Attente de WAL à partir du flux lors de la restauration.</entry>
        </row>
        <row>
         <entry><literal>SysLoggerMain</literal></entry>
         <entry>Attente dans la boucle principale du processus syslogger.</entry>
        </row>
        <row>
         <entry><literal>WalReceiverMain</literal></entry>
         <entry>Attente dans la boucle principale du processus WAL receiver.</entry>
        </row>
        <row>
         <entry><literal>WalSenderMain</literal></entry>
         <entry>Attente dans la boucle principale du processus WAL sender.</entry>
        </row>
        <row>
         <entry><literal>WalWriterMain</literal></entry>
         <entry>Attente dans la boucle principale du processus WAL writer.</entry>
        </row>
        <row>
         <entry morerows="7"><literal>Client</literal></entry>
         <entry><literal>ClientRead</literal></entry>
         <entry>Attente de lecture de données provenant du client.</entry>
        </row>
        <row>
         <entry><literal>ClientWrite</literal></entry>
         <entry>Attente d'écriture de données provenant du client.</entry>
        </row>
        <row>
         <entry><literal>LibPQWalReceiverConnect</literal></entry>
         <entry>Attente dans le WAL receiver pour établir une connexion avec
         le serveur distant.</entry>
        </row>
        <row>
         <entry><literal>LibPQWalReceiverReceive</literal></entry>
         <entry>Attente dans le WAL receiver pour recevoir des données du
         serveur distant.</entry>
        </row>
        <row>
         <entry><literal>SSLOpenServer</literal></entry>
         <entry>Attente du SSL lors d'une tentative de connexion.</entry>
        </row>
        <row>
         <entry><literal>WalReceiverWaitStart</literal></entry>
         <entry>Attente du processus de démarrage pour envoyer les données
         initiales de la réplication en flux.</entry>
        </row>
        <row>
         <entry><literal>WalSenderWaitForWAL</literal></entry>
         <entry>Attente de WAL à vider sur disque par le processus WAL sender.</entry>
        </row>
        <row>
         <entry><literal>WalSenderWriteData</literal></entry>
         <entry>Attente de toute activité lors du traitement des réponses
         provenant du WAL receiver dans le processus WAL sender.</entry>
        </row>
        <row>
         <entry><literal>Extension</literal></entry>
         <entry><literal>Extension</literal></entry>
         <entry>Attente dans une extension.</entry>
        </row>
        <row>
         <entry morerows="16"><literal>IPC</literal></entry>
         <entry><literal>BgWorkerShutdown</literal></entry>
         <entry>Attente de l'arrêt d'un background worker.</entry>
        </row>
        <row>
         <entry><literal>BgWorkerStartup</literal></entry>
         <entry>Attente du démarrage d'un background worker.</entry>
        </row>
        <row>
         <entry><literal>BtreePage</literal></entry>
         <entry>Attente de la disponibilité du numéro de bloc nécessaire pour
         continuer un parcours parallélisé d'un index B-tree.</entry>
        </row>
        <row>
         <entry><literal>ClogGroupUpdate</literal></entry>
         <entry>Waiting for group leader to update transaction status at transaction end.</entry>
        </row>
        <row>
         <entry><literal>ExecuteGather</literal></entry>
         <entry>Attente d'activité d'un processus fils lors de l'exécution
         d'un n&oelig;ud <literal>Gather</literal>.</entry>
        </row>
        <row>
          <entry><literal>Hash/Batch/Allocating</literal></entry>
          <entry>Attente de l'élection d'un participant (worker)
          <literal>Parallel Hash</literal> pour lui attribuer une table de
          hachage.</entry>
        </row>
        <row>
          <entry><literal>Hash/Batch/Electing</literal></entry>
          <entry>Élection d'un participant (worker) au
          <literal>Parallel Hash</literal> pour lui attribuer une table de
          hachage.</entry>
        </row>
        <row>
          <entry><literal>Hash/Batch/Loading</literal></entry>
          <entry>Attente d'autres participants (workers) au
          <literal>Parallel Hash</literal> afin de terminer le chargement
          d'une table de hachage</entry>
        </row>
        <row>
          <entry><literal>Hash/Build/Allocating</literal></entry>
          <entry>Attente qu'un participant (worker) élu au
          <literal>Parallel Hash</literal> s'attribue la table de hachage
          initiale.</entry>
        </row>
        <row>
          <entry><literal>Hash/Build/Electing</literal></entry>
          <entry>Élection d'un participant (worker) au <literal>Parallel Hash</literal>
          pour l'attribution de la table de hachage initiale.</entry>
        </row>
        <row>
          <entry><literal>Hash/Build/HashingInner</literal></entry>
          <entry>Attente que d'autres participants (worker) au
          <literal>Parallel Hash</literal> aient terminé le hachage de la
          relation interne.</entry>
        </row>
        <row>
          <entry><literal>Hash/Build/HashingOuter</literal></entry>
          <entry>Attente que d'autres participants (worker) au
          <literal>Parallel Hash</literal> aient terminé le partitionnement de la
          relation externe</entry>
        </row>
        <row>
          <entry><literal>Hash/GrowBatches/Allocating</literal></entry>
          <entry>Attente qu'un participant (worker) élu au <literal>Parallel Hash</literal>
          s'attribue d'autres lots de traitement.</entry>
        </row>
        <row>
          <entry><literal>Hash/GrowBatches/Deciding</literal></entry>
          <entry>Élection d'un participant (worker) au <literal>Parallel Hash</literal>
          à la décision de la croissance future des lots de traitements.</entry>
        </row>
        <row>
          <entry><literal>Hash/GrowBatches/Electing</literal></entry>
          <entry>Élection d'un participant (worker) au <literal>Parallel Hash</literal>
          pour l'affectation de lots de traitements supplémentaires.</entry>
        </row>
        <row>
          <entry><literal>Hash/GrowBatches/Finishing</literal></entry>
          <entry>Attente d'un participant (worker) élu au <literal>Parallel Hash</literal>
          à la décision de la croissance future des lots de traitements.</entry>
        </row>
        <row>
          <entry><literal>Hash/GrowBatches/Repartitioning</literal></entry>
          <entry>Attente que d'autres participants (workers) au <literal>Parallel Hash</literal>
          aient terminé le repartitionnement.</entry>
        </row>
        <row>
          <entry><literal>Hash/GrowBuckets/Allocating</literal></entry>
          <entry>Attente qu'un participant (worker) élu au <literal>Parallel Hash</literal>
          ait terminé l'affectation de plus de paquets.</entry>
        </row>
        <row>
          <entry><literal>Hash/GrowBuckets/Electing</literal></entry>
          <entry>Élection d'un participant (worker) au <literal>Parallel Hash</literal>
          pour l'affectation de plus de paquets.</entry>
         </row>
         <row>
          <entry><literal>Hash/GrowBuckets/Reinserting</literal></entry>
          <entry>Attente que d'autres participants (worker) au <literal>Parallel Hash</literal> 
          aient terminé d'insérer les lignes dans de nouveaux paquets.</entry>
        </row>
        <row>
         <entry><literal>LogicalSyncData</literal></entry>
         <entry>Attente de l'envoi de données du serveur distant en
         réplication logique pour la synchronisation initiale de
         tables.</entry>
        </row>
        <row>
         <entry><literal>LogicalSyncStateChange</literal></entry>
         <entry>Attente du changement d'état du serveur distant en réplication
         logique.</entry>
        </row>
        <row>
         <entry><literal>MessageQueueInternal</literal></entry>
         <entry>Attente de l'attachement dans la queue de messages partagées
         d'autres processus.</entry>
        </row>
        <row>
         <entry><literal>MessageQueuePutMessage</literal></entry>
         <entry>Attente de l'écriture d'un message du protocole dans une queue
         de messages partagée.</entry>
        </row>
        <row>
         <entry><literal>MessageQueueReceive</literal></entry>
         <entry>Attente de la réception d'octets d'une queue de messages
         partagée.</entry>
        </row>
        <row>
         <entry><literal>MessageQueueSend</literal></entry>
         <entry>Attente de l'envoi d'octets provenant d'une queue de messages
         partagé.</entry>
        </row>
        <row>
         <entry><literal>ParallelBitmapScan</literal></entry>
         <entry>Attente de l'initialisation d'un parcours bitmap
         parallélisé.</entry>
        </row>
        <row>
         <entry><literal>ParallelCreateIndexScan</literal></entry>
         <entry>Waiting for parallel <command>CREATE INDEX</command> workers to finish heap scan.</entry>
        </row>
        <row>
         <entry><literal>ParallelFinish</literal></entry>
         <entry>Attente la fin du traitement de processus workers
         parallélisés.</entry>
        </row>
        <row>
         <entry><literal>ProcArrayGroupUpdate</literal></entry>
         <entry>Attente de l'effacement de l'identifiant de transactions en
         fin de transaction par le leader du groupe.</entry>
        </row>
        <row>
         <entry><literal>ReplicationOriginDrop</literal></entry>
         <entry>Attente du placement en inactivité de l'origine de réplication
         pour sa suppression.</entry>
        </row>
        <row>
         <entry><literal>ReplicationSlotDrop</literal></entry>
         <entry>Attente du placement en inactivité d'un slot de réplication
         pour sa suppression.</entry>
        </row>
        <row>
         <entry><literal>SafeSnapshot</literal></entry>
         <entry>Attente d'un snapshot pour une transaction <literal>READ ONLY
         DEFERRABLE</literal>.</entry>
        </row>
        <row>
         <entry><literal>SyncRep</literal></entry>
         <entry>Attente de confirmation du serveur distant lors d'une
         réplication synchrone.</entry>
        </row>
        <row>
         <entry morerows="2"><literal>Timeout</literal></entry>
         <entry><literal>BaseBackupThrottle</literal></entry>
         <entry>Attente d'une sauvegarde de base provoquée par un délai
         d'attente dépassé pendant une forte activité système.</entry>
        </row>
        <row>
         <entry><literal>PgSleep</literal></entry>
         <entry>Attente du processus ayant appelé <function>pg_sleep</function>.</entry>
        </row>
        <row>
         <entry><literal>RecoveryApplyDelay</literal></entry>
         <entry>Attente lors de l'application des WAL à la restauration pour
         respecter le délai configuré.</entry>
        </row>
        <row>
         <entry morerows="65"><literal>IO</literal></entry>
         <entry><literal>BufFileRead</literal></entry>
         <entry>Attente de lecture à partir d'un fichier en cache.</entry>
        </row>
        <row>
         <entry><literal>BufFileWrite</literal></entry>
         <entry>Attente d'écriture dans un fichier en cache.</entry>
        </row>
        <row>
         <entry><literal>ControlFileRead</literal></entry>
         <entry>Attente d'une lecture du fichier de contrôle.</entry>
        </row>
        <row>
         <entry><literal>ControlFileSync</literal></entry>
         <entry>Attente que le fichier de contrôle atteigne un stockage
         stable.</entry>
        </row>
        <row>
         <entry><literal>ControlFileSyncUpdate</literal></entry>
         <entry>Attente d'une mise à jour pour que le fichier de contrôle
         atteigne un stockage stable.</entry>
        </row>
        <row>
         <entry><literal>ControlFileWrite</literal></entry>
         <entry>Attente d'une écriture dans le fichier de contrôle.</entry>
        </row>
        <row>
         <entry><literal>ControlFileWriteUpdate</literal></entry>
         <entry>Attente d'une écriture pour mettre à jour le fichier de
         contrôle.</entry>
        </row>
        <row>
         <entry><literal>CopyFileRead</literal></entry>
         <entry>Attente d'une lecture lors d'une opération de copie de
         fichier.</entry>
        </row>
        <row>
         <entry><literal>CopyFileWrite</literal></entry>
         <entry>Attente d'une écriture lors d'une opération de copie de
         fichier.</entry>
        </row>
        <row>
         <entry><literal>DataFileExtend</literal></entry>
         <entry>Attente de l'extension d'un fichier de données.</entry>
        </row>
        <row>
         <entry><literal>DataFileFlush</literal></entry>
         <entry>Attente qu'un fichier de données atteignent un stockage stable.</entry>
        </row>
        <row>
         <entry><literal>DataFileImmediateSync</literal></entry>
         <entry>Attente de la synchronisation immédiate d'un fichier de
         données dans un stockage table.</entry>
        </row>
        <row>
         <entry><literal>DataFilePrefetch</literal></entry>
         <entry>Attente d'une prélecture asynchrone d'un fichier de
         données.</entry>
        </row>
        <row>
         <entry><literal>DataFileRead</literal></entry>
         <entry>Attente d'une lecture à partir d'un fichier de données.</entry>
        </row>
        <row>
         <entry><literal>DataFileSync</literal></entry>
         <entry>Attente que les changements d'un fichier de données atteignent
         le stockage stable.</entry>
        </row>
        <row>
         <entry><literal>DataFileTruncate</literal></entry>
         <entry>Attente de la troncature d'un fichier de données.</entry>
        </row>
        <row>
         <entry><literal>DataFileWrite</literal></entry>
         <entry>Attente d'une écriture sur un fichier de données.</entry>
        </row>
        <row>
         <entry><literal>DSMFillZeroWrite</literal></entry>
         <entry>Attente de l'écriture de zéro octet dans un fichier de mémoire
         partagée dynamique.</entry>
        </row>
        <row>
         <entry><literal>LockFileAddToDataDirRead</literal></entry>
         <entry>Attente d'une lecture lors de l'ajout d'une ligne dans le
         fichier de verrouillage du répertoire de données.</entry>
        </row>
        <row>
         <entry><literal>LockFileAddToDataDirSync</literal></entry>
         <entry>Attente que les données atteignent un stockage stable lors de
         l'ajout d'une ligne dans le fichier de verrouillage du répertoire de
         données.</entry>
        </row>
        <row>
         <entry><literal>LockFileAddToDataDirWrite</literal></entry>
         <entry>Attente d'une écriture lors de l'ajout d'une ligne dans le
         fichier de verrouillage du répertoire de données.</entry>
        </row>
        <row>
         <entry><literal>LockFileCreateRead</literal></entry>
         <entry>Attente d'une lecture lors de la création du fichier de
         verrouillage du répertoire de données.</entry>
        </row>
        <row>
         <entry><literal>LockFileCreateSync</literal></entry>
         <entry>Attente que les données atteignent le stockage stable lors de
         la création du fichier de verrouillage du répertoire de
         données.</entry>
        </row>
        <row>
         <entry><literal>LockFileCreateWrite</literal></entry>
         <entry>Attente d'une écriture lors de la création du fichier de
         verrouillage du répertoire de données.</entry>
        </row>
        <row>
         <entry><literal>LockFileReCheckDataDirRead</literal></entry>
         <entry>Attente d'une lecture lors de la vérification du fichier de
         verrouillage du répertoire de données.</entry>
        </row>
        <row>
         <entry><literal>LogicalRewriteCheckpointSync</literal></entry>
         <entry>Attente que les correspondances de réécriture logique
         atteignent un stockage stable lors d'un checkpoint.</entry>
        </row>
        <row>
         <entry><literal>LogicalRewriteMappingSync</literal></entry>
         <entry>Attente que la correspondance des données atteignent un
         stockage stable lors d'une réécriture logique.</entry>
        </row>
        <row>
         <entry><literal>LogicalRewriteMappingWrite</literal></entry>
         <entry>Attente d'une réécriture des correspondances des données lors
         d'une réécriture logique.</entry>
        </row>
        <row>
         <entry><literal>LogicalRewriteSync</literal></entry>
         <entry>Attente que les correspondances de réécriture logique
         atteignent un stockage stable.</entry>
        </row>
        <row>
         <entry><literal>LogicalRewriteWrite</literal></entry>
         <entry>Attente d'une écriture des correspondances de réécriture
         logique.</entry>
        </row>
        <row>
         <entry><literal>RelationMapRead</literal></entry>
         <entry>Attente d'une lecture dans le fichier de correspondance des
         relations.</entry>
        </row>
        <row>
         <entry><literal>RelationMapSync</literal></entry>
         <entry>Attente que le fichier de correspondance des relations
         atteigne un stockage stable.</entry>
        </row>
        <row>
         <entry><literal>RelationMapWrite</literal></entry>
         <entry>Attente d'une écriture dans le fichier de correspondance des
         relations.</entry>
        </row>
        <row>
         <entry><literal>ReorderBufferRead</literal></entry>
         <entry>Attente d'une lecture lors de la gestion du tri des
         tampons.</entry>
        </row>
        <row>
         <entry><literal>ReorderBufferWrite</literal></entry>
         <entry>Attente d'une écriture lors de la gestion du tri des
         tampons.</entry>
        </row>
        <row>
         <entry><literal>ReorderLogicalMappingRead</literal></entry>
         <entry>Attente d'une lecture d'une correspondance logique lors de la
         gestion du tri des tampons.</entry>
        </row>
        <row>
         <entry><literal>ReplicationSlotRead</literal></entry>
         <entry>Attente d'une lecture à partir d'un fichier de contrôle pour
         un slot de réplication.</entry>
        </row>
        <row>
         <entry><literal>ReplicationSlotRestoreSync</literal></entry>
         <entry>Attente qu'un fichier de contrôle pour un slot de réplication
         atteigne le stockage stable lors de sa restauration en
         mémoire.</entry>
        </row>
        <row>
         <entry><literal>ReplicationSlotSync</literal></entry>
         <entry>Attente qu'un fichier de contrôle pour un slot de réplication
         atteigne le stockage stable.</entry>
        </row>
        <row>
         <entry><literal>ReplicationSlotWrite</literal></entry>
         <entry>Attente d'une écriture dans un fichier de contrôle pour un
         slot de réplication.</entry>
        </row>
        <row>
         <entry><literal>SLRUFlushSync</literal></entry>
         <entry>Attente que les données SLRU atteignent un stockage stable
         lors d'un checkpoint ou lors d'un arrêt du serveur de bases de
         données.</entry>
        </row>
        <row>
         <entry><literal>SLRURead</literal></entry>
         <entry>Attente d'une lecture à partir d'un bloc SLRU.</entry>
        </row>
        <row>
         <entry><literal>SLRUSync</literal></entry>
         <entry>Attente que les données SLRU atteignent un stockage stable
         suivant l'écriture d'un bloc.</entry>
        </row>
        <row>
         <entry><literal>SLRUWrite</literal></entry>
         <entry>Attente d'une écriture dans un bloc SLRU.</entry>
        </row>
        <row>
         <entry><literal>SnapbuildRead</literal></entry>
         <entry>Attente d'une lecture pour un snapshot du catalogue historique
         sérialisé.</entry>
        </row>
        <row>
         <entry><literal>SnapbuildSync</literal></entry>
         <entry>Attente que le snapshot du catalogue historique sérialisé
         atteigne un stockage stable.</entry>
        </row>
        <row>
         <entry><literal>SnapbuildWrite</literal></entry>
         <entry>Attente d'une écriture dans le snapshot du catalogue
         historique sérialisé.</entry>
        </row>
        <row>
         <entry><literal>TimelineHistoryFileSync</literal></entry>
         <entry>Attente que le fichier d'historique des timelines reçu via le
         flux de réplication atteigne un stockage stable.</entry>
        </row>
        <row>
         <entry><literal>TimelineHistoryFileWrite</literal></entry>
         <entry>Attente d'une écriture dans le fichier d'historique des
         timelines reçu via le flux de réplication.</entry>
        </row>
        <row>
         <entry><literal>TimelineHistoryRead</literal></entry>
         <entry>Attente d'une lecture dans le fichier d'historique des
         timelines reçu via le flux de réplication.</entry>
        </row>
        <row>
         <entry><literal>TimelineHistorySync</literal></entry>
         <entry>Attente qu'un nouveau fichier d'historique des timelines
         atteigne le stockage stable.</entry>
        </row>
        <row>
         <entry><literal>TimelineHistoryWrite</literal></entry>
         <entry>Attente d'une écriture d'un fichier d'historique des
         timelines.</entry>
        </row>
        <row>
         <entry><literal>TwophaseFileRead</literal></entry>
         <entry>Attente d'une lecture dans un fichier d'état pour le
         2PC.</entry>
        </row>
        <row>
         <entry><literal>TwophaseFileSync</literal></entry>
         <entry>Attente que le fichier d'état du 2PC atteigne un stockage
         stable.</entry>
        </row>
        <row>
         <entry><literal>TwophaseFileWrite</literal></entry>
         <entry>Attente d'une écriture dans un fichier d'état pour le
         2PC.</entry>
        </row>
        <row>
         <entry><literal>WALBootstrapSync</literal></entry>
         <entry>Attente que le WAL atteigne le stockage stable pendant
         l'initialisation (bootstrapping).</entry>
        </row>
        <row>
         <entry><literal>WALBootstrapWrite</literal></entry>
         <entry>Attente d'une écriture d'une page WAL lors de l'initialisation
         (bootstrapping).</entry>
        </row>
        <row>
         <entry><literal>WALCopyRead</literal></entry>
         <entry>Attente d'une lecture lors de la création d'un nouveau segment
         WAL en copiant un existant.</entry>
        </row>
        <row>
         <entry><literal>WALCopySync</literal></entry>
         <entry>Attente qu'un nouveau segment WAL créé, en copiant un existant,
         atteigne un stockage stable.</entry>
        </row>
        <row>
         <entry><literal>WALCopyWrite</literal></entry>
         <entry>Attente d'une écriture lors de la création d'un nouveau
         segment WAL par copie d'un existant.</entry>
        </row>
        <row>
         <entry><literal>WALInitSync</literal></entry>
         <entry>Attente qu'un fichier WAL nouvellement initialisée atteigne le
         stockage stable.</entry>
        </row>
        <row>
         <entry><literal>WALInitWrite</literal></entry>
         <entry>Attente d'une écriture lors de l'initialisation d'un nouveau
         fichier WAL.</entry>
        </row>
        <row>
         <entry><literal>WALRead</literal></entry>
         <entry>Attente d'une lecture à partir d'un fichier WAL.</entry>
        </row>
        <row>
         <entry><literal>WALSenderTimelineHistoryRead</literal></entry>
         <entry>Attente d'une lecture dans un fichier d'historique de
         timelines lors de la commande timeline du walsender.</entry>
        </row>
        <row>
         <entry><literal>WALSyncMethodAssign</literal></entry>
         <entry>Attente que les données atteignent un stockage stable lors de
         l'affectation de la méthode de synchronisation des WAL.</entry>
        </row>
        <row>
         <entry><literal>WALWrite</literal></entry>
         <entry>Attente d'une écriture dans un fichier WAL.</entry>
        </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <para>
     Pour les tranches enregistrées par les extensions, le nom est indiqué par
     l'extension et peut être affiché comme <structfield>wait_event</structfield>.
     Il est tout à fait possible que l'utilisateur ait enregistré la tranche dans
     un des processus serveur (en allouant de la mémoire partagée dynamique),
     auquel cas les autres processus serveur n'ont pas cette information. Dans
     ce cas, le texte <literal>extension</literal> est affiché.
    </para>
   </note>

   <para>
     Voici un exemple de visualisation d'événements d'attente&nbsp;:

<programlisting>
SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;
 pid  | wait_event_type |  wait_event
------+-----------------+---------------
 2540 | Lock            | relation
 6644 | LWLock          | ProcArrayLock
(2 rows)
</programlisting>
   </para>

  <table id="pg-stat-replication-view" xreflabel="pg_stat_replication">
   <title>Vue <structname>pg_stat_replication</structname></title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Colonne</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Identifiant du processus d'envoi des WAL</entry>
    </row>
    <row>
     <entry><structfield>usesysid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID de l'utilisateur connecté à ce processus</entry>
    </row>
    <row>
     <entry><structfield>usename</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom de l'utilisateur connecté à ce processus</entry>
    </row>
    <row>
     <entry><structfield>application_name</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Nom de l'application qui est connectée à ce processus</entry>
    </row>
    <row>
     <entry><structfield>client_addr</structfield></entry>
     <entry><type>inet</type></entry>
     <entry>Adresse IP du client connecté à ce processus. Si ce champ est
      NULL, ceci signifie que le client est connecté via un socket Unix sur
      la machine serveur.</entry>
    </row>
    <row>
     <entry><structfield>client_hostname</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Nom de l'hôte du client connecté, comme renvoyé par une
     recherche DNS inverse sur <structfield>client_addr</structfield>. Ce
     champ sera uniquement non NULL pour les connexions IP, et seulement
     si <xref linkend="guc-log-hostname"/> est activé.
     </entry>
    </row>
    <row>
     <entry><structfield>client_port</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Numéro du port TCP que le client utilise pour la
      communication avec ce processus, ou <literal>-1</literal> si un socket
      Unix est utilisée.</entry>
    </row>
    <row>
     <entry><structfield>backend_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Heure à laquelle ce processus a été démarré, exemple,
     lorsque le client s'est connecté à ce processus expéditeur
     de WALs.</entry>
    </row>
    <row>
     <entry><structfield>backend_xmin</structfield></entry>
     <entry><type>xid</type></entry>
     <entry>L'horizon <literal>xmin</literal> de ce serveur standby
      renvoyé par <xref linkend="guc-hot-standby-feedback"/>.</entry>
    </row>
    <row>
     <entry><structfield>state</structfield></entry>
     <entry><type>text</type></entry>
     <entry>État courant du processus walsender.
       Les valeurs possibles sont&nbsp;:
       <itemizedlist>
         <listitem>
          <para>
           <literal>startup</literal>&nbsp;: Le processus walsender est en
           cours de démarrage.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>catchup</literal>&nbsp;: Le secondaire connecté au
           processus walsender est en cours de rattrapage du primaire.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>streaming</literal>&nbsp;: Ce processus walsender envoie
           les modifications au serveur secondaire connecté depuis que ce
           dernier a rattrapé le primaire.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>backup</literal>&nbsp;: Ce processus walsender est en
           train d'envoyer une sauvegarde.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>stopping</literal>&nbsp;: Ce processus walsender est en
           cours d'arrêt.
          </para>
         </listitem>
       </itemizedlist>
     </entry>
    </row>
    <row>
     <entry><structfield>sent_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>La position de la dernière transaction envoyée sur cette
      connexion</entry>
    </row>
    <row>
     <entry><structfield>write_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>La position de la dernière transaction écrite sur disque
      par ce serveur standby</entry>
    </row>
    <row>
     <entry><structfield>flush_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>La position de la dernière transaction vidée sur disque
      par ce serveur standby</entry>
    </row>
    <row>
     <entry><structfield>replay_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>La position de la dernière transaction rejouée dans la
      base de données par ce serveur standby</entry>
    </row>
    <row>
     <entry><structfield>write_lag</structfield></entry>
     <entry><type>interval</type></entry>
     <entry>Durée passée entre le vidage local des WAL récents et la réception
      de notification que ce serveur secondaire les a bien écrites (mais pas
      encore vidées ou appliquées). Ceci peut être utilisé pour mesurer le
      délai que le niveau <literal>remote_write</literal> de
      <literal>synchronous_commit</literal> coûterait lors de la validation si
      ce serveur était configuré comme un serveur secondaire
      synchrone.</entry>
    </row>
    <row>
     <entry><structfield>flush_lag</structfield></entry>
     <entry><type>interval</type></entry>
     <entry>Durée passée entre le vidage local des WAL récents et la réception
      de notification que ce serveur secondaire les a bien écrites et vidées
      sur disque (mais pas encore appliquées). Ceci peut être utilisé pour
      mesurer le délai que le niveau <literal>on</literal> de
      <literal>synchronous_commit</literal> coûterait lors de la validation si
      ce serveur était configuré comme un serveur secondaire
      synchrone.</entry>
    </row>
    <row>
     <entry><structfield>replay_lag</structfield></entry>
     <entry><type>interval</type></entry>
     <entry>Durée passée entre le vidage local des WAL récents et la réception
      de notification que ce serveur secondaire les a bien écrites, vidées
      sur disque et appliquées. Ceci peut être utilisé pour
      mesurer le délai que le niveau <literal>remote_apply</literal> de
      <literal>synchronous_commit</literal> coûterait lors de la validation si
      ce serveur était configuré comme un serveur secondaire
      synchrone.</entry>
    </row>
    <row>
     <entry><structfield>sync_priority</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Priorité de ce serveur standby pour être choisi comme le serveur
      <literal>standby</literal> synchrone dans une réplication synchrone basée
      sur la priorité. Ceci n'a pas d'effet sur une réplication synchrone basée
      sur un quorum.</entry>
    </row>
    <row>
     <entry><structfield>sync_state</structfield></entry>
     <entry><type>text</type></entry>
     <entry>État synchrone de ce serveur standby.
       Les valeurs possibles sont&nbsp;:
       <itemizedlist>
         <listitem>
          <para>
           <literal>async</literal>&nbsp;: Ce serveur standby est asynchrone.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>potential</literal>&nbsp;: Ce serveur standby est maintenant
           asynchrone, mais peut potentiellement devenir synchrone si un des
           synchrones échoue.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>sync</literal>&nbsp;: Ce serveur standby est synchrone.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>quorum</literal>&nbsp;: Ce serveur standby est considéré
           comme un candidat dans les standbys avec quorum.
          </para>
         </listitem>
       </itemizedlist>
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_replication</structname> contiendra une
   ligne par processus d'envoi de WAL, montrant des statistiques sur
   la réplication avec le serveur standby connecté au processus. Seuls
   les serveurs standby directement connectés sont listés&nbsp;; aucune
   information n'est disponible concernant les serveurs standby en aval.
  </para>
 
  <para>
   Les délais rapportés dans la vue
   <structname>pg_stat_replication</structname> sont des mesures de temps
   prises pour l'écriture, le vidage sur disque et le rejeu des données
   récentes des WAL et pour que le serveur d'envoi soit mis au courant. Ces
   durées représentent le délai de validation qui a été (ou aurait été)
   introduit par chaque niveau de validation synchrone si le serveur distant
   était configuré comme un standby synchrone. Pour un standby asynchrone, la
   colonne <structfield>replay_lag</structfield> renvoie une approximation du
   délai avant que les transactions récentes deviennent visibles aux requêtes.
   Si le serveur standby a complètement rattrapé le serveur d'envoi et qu'il
   n'y a plus d'activité en écriture (donc plus de nouveaux enregistrements
   dans les journaux de transactions), les délais mesurés le plus récemment
   continueront à être affichés pendant un court instant, puis seront mis à
   NULL.
  </para>

  <para>
   Les délais fonctionnent automatiquement pour la réplication physique. Les
   plugins de décodage logique pourraient émettre des messages de trace. S'ils
   ne le font pas, le mécanisme de trace affichera simplement une valeur NULL.
  </para>

  <note>
   <para>
    Les délais rapportés ne sont pas des prédictions du temps pris par le
    serveur standby pour rattraper le serveur d'envoi en constatant le taux
    actuel de rejeu. Un tel système afficherait des temps similaires alors que
    de nouveaux journaux de transactions seraient générés, mais différeraient
    lorsque le serveur deviendrait inactif. En particulier, quand le serveur
    standby a complètement rattrapé le serveur d'envoi,
    <structname>pg_stat_replication</structname> affiche le temps pris pour
    écrire, vider sur disque et rejouer l'emplacement de l'enregistrement le
    plus récemment rapporté plutôt que zéro comme certains utilisateurs
    pourraient s'y attendre. Ceci est cohérent avec le but de mesurer les
    délais de la validation synchrone et de la visibilité des transactions
    pour les transactions récentes en écriture. Pour réduire la confusion pour
    les utilisateurs s'attendant à un autre modèle de retard, les colonnes de
    retard sont réinitialisées à NULL après un court moment sur un système
    entièrement à jour et complètement inactif. Les systèmes de supervision
    devraient choisir s'ils souhaitent représenter ces colonnes comme des
    données manquantes, des données à zéro, ou continuer à afficher la
    dernière valeur connue.
   </para>
  </note>

  <table id="pg-stat-wal-receiver-view" xreflabel="pg_stat_wal_receiver">
   <title>Vue <structname>pg_stat_wal_receiver</structname></title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Colonne</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Identifiant du processus de réception des enregistrements de
      transaction</entry>
    </row>
    <row>
     <entry><structfield>status</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Statut d'activité du processus walreceiver</entry>
    </row>
    <row>
     <entry><structfield>receive_start_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>Première position dans le journal de transaction utilisée
      quand walreceiver a été démarré</entry>
    </row>
    <row>
     <entry><structfield>receive_start_tli</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Première ligne de temps utilisée quand walreceiver a été démarré</entry>
    </row>
    <row>
     <entry><structfield>received_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>Dernière position des journaux de transactions, déjà reçue et
      écrite sur disque, la valeur initiale de ce champ étant la première
      position dans les journaux de transactions utilisée lors du démarrage du
      walreceiver</entry>
    </row>
    <row>
     <entry><structfield>received_tli</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Numéro de la ligne de temps de la dernière position des journaux
      de transactions, déjà reçue et écrite sur disque, la valeur initiale de
      ce champ étant la ligne de temps de la première position dans les
      journaux de transactions utilisée lors du démarrage du
      walreceiver</entry>
    </row>
    <row>
     <entry><structfield>last_msg_send_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Horodatage d'envoi du dernier message reçu à partir du walsender</entry>
    </row>
    <row>
     <entry><structfield>last_msg_receipt_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Horodatage de la réception du dernier message à partir du walsender</entry>
    </row>
    <row>
     <entry><structfield>latest_end_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>Dernière position de transaction reportée par le walsender associé</entry>
    </row>
    <row>
     <entry><structfield>latest_end_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Horodatage de la dernière position de transaction reportée par le
      walsender associé</entry>
    </row>
    <row>
     <entry><structfield>slot_name</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Nom du slot de réplication utilisé par ce walreceiver</entry>
    </row>
    <row>
     <entry><structfield>sender_host</structfield></entry>
     <entry><type>text</type></entry>
     <entry>
      Hôte de l'instance <productname>PostgreSQL</productname> auquel ce processus
      <quote>wal receiver</quote> est connecté. Il peut s'agir d'un nom d'hôte,
      d'une adresse <literal>IP</literal> ou d'un chemin d'accès à un répertoire
      si la connexion se fait via un socket Unix (dans ce dernier cas, il est facile 
      de le distinguer car il s'agira toujours d'un chemin absolu débutant 
      par le caractère (<literal>/</literal>).)
     </entry>
    </row>
    <row>
     <entry><structfield>sender_port</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>
      Numéro de port de l'instance <productname>PostgreSQL</productname> auquel
      wal receiver est connecté.
     </entry>
    </row>
    <row>
     <entry><structfield>conninfo</structfield></entry>
     <entry><type>text</type></entry>
     <entry>
      Chaîne de connexion utilisée par ce wal receiver, les informations sensibles
      au niveau sécurité sont cachés.
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_wal_receiver</structname> contiendra seulement
   une ligne, affichant les statistiques du walreceiver du serveur de
   connexion.
  </para>

  <table id="pg-stat-subscription" xreflabel="pg_stat_subscription">
   <title>Vue <structname>pg_stat_subscription</structname></title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Colonne</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>subid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID de la souscription</entry>
    </row>
    <row>
     <entry><structfield>subname</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Nom de la souscription</entry>
    </row>
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Identifiant du processus worker de la souscription</entry>
    </row>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>Oid</type></entry>
     <entry>OID de la relation que le processus worker synchronise&nbsp;;
      NULL pour le processus worker apply principal</entry>
    </row>
    <row>
     <entry><structfield>received_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>Dernier emplacement de journal de transactions reçu, la valeur
     initiale de ce champ étant 0</entry>
    </row>
    <row>
     <entry><structfield>last_msg_send_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Horodatage d'envoi du dernier message reçu à partir du walsender
     original</entry>
    </row>
    <row>
     <entry><structfield>last_msg_receipt_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Horodatage de réception du dernier message reçu du walsender
     original</entry>
    </row>
    <row>
     <entry><structfield>latest_end_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>Dernier emplacement des journaux de transactions rapporté par le
     walsender original</entry>
    </row>
    <row>
     <entry><structfield>latest_end_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Horodatage du dernier emplacement de journal de transactions
     rapporté par le walsender original</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_subscription</structname> contiendra une ligne
   par souscription du worker principal (avec le PID NULL si le processus
   worker n'est pas en cours d'exécution), et des lignes supplémentaires pour
   les workers gérant la copie initiale de données des tables souscrites.
  </para>

  <table id="pg-stat-ssl-view" xreflabel="pg_stat_ssl">
  <title>Vue <structname>pg_stat_ssl</structname></title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Colonne</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>ID du processus backend ou du processus d'envoi de WAL</entry>
    </row>
    <row>
     <entry><structfield>ssl</structfield></entry>
     <entry><type>boolean</type></entry>
     <entry>True si SSL est utilisé dans cette connexion</entry>
    </row>
    <row>
     <entry><structfield>version</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Version de SSL utilisée, ou NULL si SSL n'est pas utilisé
      pour cette connexion</entry>
    </row>
    <row>
     <entry><structfield>cipher</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Nom du chiffrement SSL utilisé, ou NULL si SSL n'est pas
      utilisé pour cette connexion</entry>
    </row>
    <row>
     <entry><structfield>bits</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Nombre de bits dans l'algorithme de chiffrement utilisé,
      ou NULL si SSL n'est pas utilisé pour cette connexion</entry>
    </row>
    <row>
     <entry><structfield>compression</structfield></entry>
     <entry><type>boolean</type></entry>
     <entry>True si la compression SSL est utilisée, false sinon, ou
      NULL si SSL n'est pas utilisé pour cette connexion</entry>
    </row>
    <row>
     <entry><structfield>clientdn</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Champ Distinguished Name (DN) utilisé par le certificat du
      client, ou NULL si aucun certificat client n'a été fourni ou si
      SSL n'est pas utilisé pour cette connexion. Ce champ est tronqué
      si le champ DN est plus long que <symbol>NAMEDATALEN</symbol>
      (64 caractères dans une compilation standard)</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_ssl</structname> contiendra une
   ligne par backend ou processus d'envoi de WAL, montrant
   des statistiques sur l'usage de SSL dans cette connexion. Elle
   peut être jointe à <structname>pg_stat_activity</structname>
   ou <structname>pg_stat_replication</structname> sur la colonne
   <structfield>pid</structfield> pour obtenir plus de détails sur
   la connexion.
  </para>

  <table id="pg-stat-archiver-view" xreflabel="pg_stat_archiver">
   <title>Vue <structname>pg_stat_archiver</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Colonne</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>archived_count</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Nombre de journaux de transactions archivés avec succès</entry>
     </row>
     <row>
      <entry><structfield>last_archived_wal</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Nom du dernier journal de transaction archivé avec succès</entry>
     </row>
     <row>
      <entry><structfield>last_archived_time</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Horodatage de la dernière opération d'archivage réussie</entry>
     </row>
     <row>
      <entry><structfield>failed_count</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Nombre d'échecs d'archivage de journaux de transactions</entry>
     </row>
     <row>
      <entry><structfield>last_failed_wal</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Nom du journal de transactions correspondant au dernier archivage
        échoué</entry>
     </row>
     <row>
      <entry><structfield>last_failed_time</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Horodatage de la dernière opération d'archivage échouée</entry>
     </row>
     <row>
      <entry><structfield>stats_reset</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Horodatage de la dernière réinitialisation de ces statistiques</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_archiver</structname> aura toujours une seule ligne
   contenant les données du processus d'archivage de l'instance.
  </para>

  <table id="pg-stat-bgwriter-view" xreflabel="pg_stat_bgwriter">
   <title>Vue <structname>pg_stat_bgwriter</structname></title>

   <tgroup cols="3">
    <thead>
    <row>
      <entry>Colonne</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>checkpoints_timed</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Nombre de checkpoints planifiés ayant été effectués</entry>
     </row>
     <row>
      <entry><structfield>checkpoints_req</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Nombre de checkpoints demandés ayant été effectués</entry>
     </row>
     <row>
      <entry><structfield>checkpoint_write_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry>
        Temps total passé dans la partie des checkpoints
        où les fichiers sont écrits sur disque, en millisecondes.
      </entry>
     </row>
     <row>
      <entry><structfield>checkpoint_sync_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry>
        Temps total passé dans la partie des checkpoints
        où les fichiers sont synchronisés sur le disque, en millisecondes.
      </entry>
     </row>
     <row>
      <entry><structfield>buffers_checkpoint</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Nombre de tampons écrits durant des checkpoints</entry>
     </row>
     <row>
      <entry><structfield>buffers_clean</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Nombre de tampons écrits par le processus background writer
      (processus d'écriture en tâche de fond)</entry>
     </row>
     <row>
      <entry><structfield>maxwritten_clean</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Nombre de fois que le processus background writer a arrêté
       son parcours de nettoyage pour avoir écrit trop de tampons</entry>
     </row>
     <row>
      <entry><structfield>buffers_backend</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Nombre de tampons écrits directement par un processus serveur</entry>
     </row>
     <row>
      <entry><structfield>buffers_backend_fsync</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Nombre de fois qu'un processus serveur a du exécuter son propre appel à
       <function>fsync</function> (normalement le processus background writer gère
        ces appels même quand le processus serveur effectue sa propre écriture)</entry>
     </row>
     <row>
      <entry><structfield>buffers_alloc</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Nombre de tampons alloués</entry>
     </row>
     <row>
      <entry><structfield>stats_reset</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Dernière fois que ces statistiques ont été réinitialisées</entry>
     </row>
    </tbody>
    </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_bgwriter</structname> aura toujours une ligne unique,
   contenant les données globales de l'instance.
  </para>

  <table id="pg-stat-database-view" xreflabel="pg_stat_database">
   <title>Vue <structname>pg_stat_database</structname></title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Colonne</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID d'une base de données</entry>
    </row>
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom de cette base de données</entry>
    </row>
    <row>
     <entry><structfield>numbackends</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Nombre de processus serveur actuellement connectés à cette base de données.
     C'est la seule colonne de cette vue qui renvoie une valeur reflétant l'état actuel&nbsp;;
     toutes les autres colonnes renvoient les valeurs accumulées depuis la dernière
     réinitialisation</entry>
    </row>
    <row>
     <entry><structfield>xact_commit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de transactions de cette base de données qui ont été
      validées</entry>
    </row>
    <row>
     <entry><structfield>xact_rollback</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de transactions de cette base de données qui ont été
      annulées</entry>
    </row>
    <row>
     <entry><structfield>blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de blocs disques lus dans cette base de données</entry>
    </row>
    <row>
     <entry><structfield>blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de fois que des blocs disques étaient déjà dans le cache tampon,
      et qu'il n'a donc pas été nécessaire de les lire sur disque (cela n'inclut que les accès
      dans le cache tampon de PostgreSQL, pas dans le cache de fichiers du système d'exploitation).
     </entry>
    </row>
    <row>
     <entry><structfield>tup_returned</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de lignes retournées par des requêtes dans cette base de données</entry>
    </row>
    <row>
     <entry><structfield>tup_fetched</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de lignes rapportées par des requêtes dans cette base de données</entry>
    </row>
    <row>
     <entry><structfield>tup_inserted</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de lignes insérées par des requêtes dans cette base de données</entry>
    </row>
    <row>
     <entry><structfield>tup_updated</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de lignes mises à jour par des requêtes dans cette base de données</entry>
    </row>
    <row>
     <entry><structfield>tup_deleted</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de lignes supprimées par des requêtes dans cette base de données</entry>
    </row>
    <row>
     <entry><structfield>conflicts</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de requêtes annulées à cause de conflits avec la restauration dans cette
      base de données. (Les conflits n'arrivent que sur des serveurs de standby&nbsp;; voir
      <xref linkend="pg-stat-database-conflicts-view"/> pour plus de détails.)
     </entry>
    </row>
    <row>
     <entry><structfield>temp_files</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de fichiers temporaires créés par des requêtes dans cette base
      de données. Tous les fichiers temporaires sont comptabilisés, quel que soit
      la raison de la création du fichier temporaire (par exemple, un tri ou un hachage) et
      quel que soit la valeur du paramètre <xref linkend="guc-log-temp-files"/>.
     </entry>
    </row>
    <row>
     <entry><structfield>temp_bytes</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Quantité totale de données écrites dans des fichiers temporaires
      par des requêtes dans cette base de données. Tous les fichiers
      temporaires sont comptabilisés, quel que soit la raison de la création
      de ce fichier temporaire, et de la valeur du paramètre
       <xref linkend="guc-log-temp-files"/>.
     </entry>
    </row>
    <row>
     <entry><structfield>deadlocks</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de verrous mortels détectés dans cette base de données</entry>
    </row>
    <row>
     <entry><structfield>blk_read_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>Temps passé à lire des blocs de donnée dans des fichiers par des
      processus serveur dans cette base de données, en millisecondes</entry>
    </row>
    <row>
     <entry><structfield>blk_write_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>Temps passé à écrire des blocs de données dans des fichiers par
      les processus serveur dans cette base de données, en millisecondes</entry>
    </row>
    <row>
     <entry><structfield>stats_reset</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Dernière fois que ces statistiques ont été réinitialisées</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_database</structname> ne contiendra qu'une
   ligne pour chaque base de données dans l'instance, montrant ses
   statistiques globales.
  </para>

  <table id="pg-stat-database-conflicts-view" xreflabel="pg_stat_database_conflicts">
  <title>Vue <structname>pg_stat_database_conflicts</structname></title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Colonne</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID de la base de données</entry>
    </row>
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom de cette base de données</entry>
    </row>
    <row>
     <entry><structfield>confl_tablespace</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de requêtes dans cette base de données qui ont
      été annulées suite à la suppression de tablespaces</entry>
    </row>
    <row>
     <entry><structfield>confl_lock</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de requêtes dans cette base de données qui
      ont été annulées suite à des délais dépassés sur des
      verrouillages</entry>
    </row>
    <row>
     <entry><structfield>confl_snapshot</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de requêtes dans cette base de données qui ont
      été annulées à cause d'instantanés trop vieux</entry>
    </row>
    <row>
     <entry><structfield>confl_bufferpin</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de requêtes dans cette base de données qui ont
      été annulées à cause de tampons verrouillés</entry>
    </row>
    <row>
     <entry><structfield>confl_deadlock</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de requêtes dans cette base de données qui ont
     été annulées à cause de <literal>deadlocks</literal></entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_database_conflicts</structname> contiendra
   une ligne par base de données, montrant des statistiques au niveau
   de chaque base de données concernant les requêtes annulées survenant à
   cause de conflits avec la restauration sur des serveurs standby. Cette
   vue contiendra seulement des informations sur les serveurs standby,
   dans la mesure où aucun conflit ne survient sur les serveurs
   primaires.
  </para>

  <table id="pg-stat-all-tables-view" xreflabel="pg_stat_all_tables">
   <title>Vue <structname>pg_stat_all_tables</structname></title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Colonne</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID d'une table</entry>
    </row>
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom du schéma dans lequel se trouve cette table</entry>
    </row>
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom de cette table</entry>
    </row>
    <row>
     <entry><structfield>seq_scan</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de parcours séquentiels initiés sur cette table</entry>
    </row>
    <row>
     <entry><structfield>seq_tup_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de lignes vivantes rapportées par des parcours séquentiels</entry>
    </row>
    <row>
     <entry><structfield>idx_scan</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de parcours d'index initiés sur cette table</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_fetch</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de lignes vivantes rapportées par des parcours d'index</entry>
    </row>
    <row>
     <entry><structfield>n_tup_ins</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de lignes insérées</entry>
    </row>
    <row>
     <entry><structfield>n_tup_upd</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de lignes mises à jour (y compris les lignes mises à jour
      par HOT)</entry>
    </row>
    <row>
     <entry><structfield>n_tup_del</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de lignes supprimées</entry>
    </row>
    <row>
     <entry><structfield>n_tup_hot_upd</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de lignes mises à jour par HOT (c’est-à-dire sans mises à
     jour d'index nécessaire)</entry>
    </row>
    <row>
     <entry><structfield>n_live_tup</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre estimé de lignes vivantes</entry>
    </row>
    <row>
     <entry><structfield>n_dead_tup</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre estimé de lignes mortes</entry>
    </row>
    <row>
     <entry><structfield>n_mod_since_analyze</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre estimé de lignes modifiées depuis le dernier ANALYZE sur
      cette table</entry>
    </row>
    <row>
     <entry><structfield>last_vacuum</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Dernière fois qu'une opération VACUUM manuelle
      a été faite sur cette table (sans compter&nbsp;
      <command>VACUUM FULL</command>)</entry>
    </row>
    <row>
     <entry><structfield>last_autovacuum</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Dernière fois que le démon autovacuum a exécuté une
     opération VACUUM sur cette table</entry>
    </row>
    <row>
     <entry><structfield>last_analyze</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Dernière fois qu'une opération ANALYZE a été lancée
      manuellement sur cette table</entry>
    </row>
    <row>
     <entry><structfield>last_autoanalyze</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Dernière fois que le démon autovacuum a exécuté une
      opération ANALYZE sur cette table</entry>
    </row>
    <row>
     <entry><structfield>vacuum_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de fois qu'une opération VACUUM manuelle a été
      lancée sur cette table (sans compter
      <command>VACUUM FULL</command>)</entry>
    </row>
    <row>
     <entry><structfield>autovacuum_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de fois que le démon autovacuum a exécuté
      une opération VACUUM manuelle</entry>
    </row>
    <row>
     <entry><structfield>analyze_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de fois qu'une opération ANALYZE manuelle
      a été lancée sur cette table</entry>
    </row>
    <row>
     <entry><structfield>autoanalyze_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de fois que le démon autovacuum a exécuté une
      opération ANALYZE sur cette table</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_all_tables</structname> contiendra une ligne
   par table dans la base de données courante (incluant les tables TOAST),
   montrant les statistiques d'accès pour cette table spécifiquement. Les vues
   <structname>pg_stat_user_tables</structname> et
   <structname>pg_stat_sys_tables</structname> contiennent les mêmes informations,
   mais filtrent respectivement les tables utilisateurs et les tables systèmes.
  </para>

  <table id="pg-stat-all-indexes-view" xreflabel="pg_stat_all_indexes">
   <title>Vue <structname>pg_stat_all_indexes</structname></title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Colonne</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID de la table pour cet index</entry>
    </row>
    <row>
     <entry><structfield>indexrelid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID de cet index</entry>
    </row>
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom du schéma dans lequel se trouve cet index</entry>
    </row>
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom de la table pour cet index</entry>
    </row>
    <row>
     <entry><structfield>indexrelname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom de cet index</entry>
    </row>
    <row>
     <entry><structfield>idx_scan</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de parcours d'index initiés par cet index</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre d'entrées d'index retournées par des parcours sur cet index</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_fetch</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de lignes vivantes de la table rapportées par des simples parcours
      d'index utilisant cet index</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_all_indexes</structname> contiendra une
   ligne pour chaque index dans la base de données courante, montrant les
   statistiques d'accès sur cet index spécifiquement. Les vues
   <structname>pg_stat_user_indexes</structname> et
   <structname>pg_stat_sys_indexes</structname> contiennent la même
   information, mais sont filtrées pour ne montrer respectivement que
   les index utilisateurs et les index système.
  </para>

  <para>
   Les index peuvent être utilisés avec un simple parcours d'index,
   un parcours d'index  <quote>bitmap</quote> ou l'optimiseur. Dans un parcours de
   bitmap, les sorties de plusieurs index peuvent être combinées avec
   des règles AND ou OR, c'est pourquoi il est difficile d'associer des
   lectures de lignes individuelles de la table avec des index spécifiques
   quand un parcours de bitmap est utilisé. Par conséquent, un parcours de bitmap
   incrémente le(s) valeur(s) de <structname>pg_stat_all_indexes</structname>.
   <structfield>idx_tup_read</structfield> pour le(s) index qu'il utilise, et
   incrémente la valeur de <structname>pg_stat_all_tables</structname>.<structfield>
   idx_tup_fetch</structfield> pour la table, mais il n'affecte pas
   <structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_fetch</structfield>.
   L'optimiseur accède également aux index pour vérifier si des
   constantes fournies sont en dehors des plages de valeurs enregistrées
   par les statistiques de l'optimiseur car celles-ci peuvent ne pas
   être à jour.
  </para>

  <note>
   <para>
    Les valeurs de <structfield>idx_tup_read</structfield> et <structfield>idx_tup_fetch
    </structfield> peuvent être différentes même sans aucune utilisation de parcours
    de bitmap, car <structfield>idx_tup_read</structfield> comptabilise les entrées
    d'index récupérées de cet index alors que  <structfield>idx_tup_fetch</structfield>
    comptabilise le nombre de lignes vivantes rapportées de la table. Le second sera
    moindre si des lignes mortes ou pas encore validées sont rapportées en utilisant
    l'index, ou si des lectures de lignes de la table sont évitées grâce à un
    parcours d'index seul.
   </para>
  </note>

  <table id="pg-statio-all-tables-view" xreflabel="pg_statio_all_tables">
   <title>Vue <structname>pg_statio_all_tables</structname></title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Colonne</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID d'une table</entry>
    </row>
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom du schéma dans lequel se trouve cette table</entry>
    </row>
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom de cette table</entry>
    </row>
    <row>
     <entry><structfield>heap_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de blocs disque lus pour cette table</entry>
    </row>
    <row>
     <entry><structfield>heap_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de tampons récupérés pour cette table</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de blocs disque lus par tous les index de cette table</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de tampons récupérés sur tous les index de cette table</entry>
    </row>
    <row>
     <entry><structfield>toast_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de blocs disque lus sur la partie TOAST de cette table (si présente)</entry>
    </row>
    <row>
     <entry><structfield>toast_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de tampons récupérés sur la partie TOAST de cette table (si présente)</entry>
    </row>
    <row>
     <entry><structfield>tidx_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de blocs disque lus sur les index de la partie TOAST de cette table (si présente)</entry>
    </row>
    <row>
     <entry><structfield>tidx_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de tampons récupérés sur les index de la partie TOAST de cette table (si présente)</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_statio_all_tables</structname> contiendra
   une ligne pour chaque table dans la base de données courante (en
   incluant les tables TOAST), montrant les statistiques d'entrées/sorties
   de chaque table spécifiquement. Les vues
   <structname>pg_statio_user_tables</structname> et
   <structname>pg_statio_sys_tables</structname> contiennent la même
   information, mais sont filtrées pour ne montrer respectivement que
   les tables utilisateurs et les tables système.
  </para>

  <table id="pg-statio-all-indexes-view" xreflabel="pg_statio_all_indexes">
   <title>Vue <structname>pg_statio_all_indexes</structname></title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Colonne</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID de la table pour cet index</entry>
    </row>
    <row>
     <entry><structfield>indexrelid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID de cet index</entry>
    </row>
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom du schéma dans lequel se trouve cet index</entry>
    </row>
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom de la table pour cet index</entry>
    </row>
    <row>
     <entry><structfield>indexrelname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom de cet index</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de blocs disque lus pour cet index</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de tampons récupérés sur cet index</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_statio_all_indexes</structname> contiendra
   une ligne pour chaque index dans la base de données courante,
   montrant les statistiques d'entrées/sorties sur chaque index
   spécifiquement. Les vues
   <structname>pg_statio_user_indexes</structname> et
   <structname>pg_statio_sys_indexes</structname> contiennent la même
   information, mais sont filtrées pour ne montrer respectivement
   que les tables utilisateur et tables système.
  </para>

  <table id="pg-statio-all-sequences-view" xreflabel="pg_statio_all_sequences">
   <title>Vue <structname>pg_statio_all_sequences</structname></title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Colonne</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID de cette séquence</entry>
    </row>
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom du schéma dans lequel se trouve cette séquence</entry>
    </row>
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom de cette séquence</entry>
    </row>
    <row>
     <entry><structfield>blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de blocs disque lus pour cette séquence</entry>
    </row>
    <row>
     <entry><structfield>blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de tampons récupérés pour cette séquence</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_statio_all_sequences</structname> contiendra
   une ligne pour chaque séquence dans la base de données courante,
   montrant les statistiques d'entrées/sorties pour chaque séquence spécifiquement.
  </para>

  <table id="pg-stat-user-functions-view" xreflabel="pg_stat_user_functions">
   <title>Vue <structname>pg_stat_user_functions</structname></title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Colonne</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>funcid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID de cette fonction</entry>
    </row>
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom du schéma dans lequel se trouve cette fonction</entry>
    </row>
    <row>
     <entry><structfield>funcname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom de cette fonction</entry>
    </row>
    <row>
     <entry><structfield>calls</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Nombre de fois que cette fonction a été appelée</entry>
    </row>
    <row>
     <entry><structfield>total_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>Temps total passé dans cette fonction ainsi que dans toutes
     les autres fonctions appelées par elle, en millisecondes</entry>
    </row>
    <row>
     <entry><structfield>self_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>Temps total passé dans cette fonction seule, sans inclure
     les autres fonctions appelées par elle, en millisecondes</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_stat_user_functions</structname> contiendra une
   ligne pour chaque fonction suivie, montrant les statistiques d'exécution
   de cette fonction. Le paramètre <xref linkend="guc-track-functions"/>
   contrôle exactement quelles fonctions sont suivies.
  </para>

 <sect2 id="monitoring-stats-functions">
  <title>Fonctions Statistiques</title>

  <para>
   Une autre façon de regarder les statistiques peut être mise en place
   en écrivant des requêtes utilisant les mêmes fonctions d'accès sous-
   jacentes utilisées par les vues standards montrées au-dessus.  Pour
   des détails comme les noms de fonction, veuillez consulter les définitions
   de ces vues standards. (Par exemple, dans <application>psql</application>
   vous pouvez utiliser <literal>\d+ pg_stat_activity</literal>.)
   Les fonctions d'accès pour les statistiques par base de données prennent
   comme argument un OID pour identifier sur quelle base de données travailler.
   Les fonctions par table et par index utilisent un OID de table ou d'index.
   Les fonctions pour les statistiques par fonctions utilisent un OID de fonction.
   Notez que seuls les tables, index et fonctions dans la base de données
   courante peuvent être vus avec ces fonctions.
  </para>

  <para>
   Les fonctions supplémentaires liées à la récupération de statistiques sont listées dans <xref
   linkend="monitoring-stats-funcs-table"/>.
  </para>

  <table id="monitoring-stats-funcs-table">
   <title>Fonctions supplémentaires de statistiques</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Fonction</entry>
      <entry>Type renvoyé</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>

     <row>
       <!-- See also the entry for this in func.sgml -->
   <entry><literal><function>pg_backend_pid()</function></literal></entry>
   <entry><type>integer</type></entry>
   <entry>
    Identifiant du processus serveur gérant la session courante.
   </entry>
  </row>

  <row>
   <entry><literal><function>pg_stat_get_activity</function>(<type>integer</type>)</literal><indexterm><primary>pg_stat_get_activity</primary></indexterm></entry>
   <entry><type>setof record</type></entry>
   <entry>
    Retourne un enregistrement d'informations sur le processus serveur
    du PID spécifié, ou un enregistrement pour chaque processus serveur
    actif dans le système si <symbol>NULL</symbol> est spécifié.
    Les champs retournés sont des sous-ensembles de ceux dans la vue
    <structname>pg_stat_activity</structname>.
   </entry>
  </row>

  <row>
      <entry><literal><function>pg_stat_get_snapshot_timestamp()</function></literal><indexterm><primary>pg_stat_get_snapshot_timestamp</primary></indexterm></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>
       Renvoie l'horodatage de l'instantané courant des statistiques
      </entry>
     </row>

     <row>
   <entry><literal><function>pg_stat_clear_snapshot()</function></literal><indexterm><primary>pg_stat_clear_snapshot</primary></indexterm></entry>
   <entry><type>void</type></entry>
   <entry>
    Supprime l'image statistique courante.
   </entry>
  </row>

  <row>
   <entry><literal><function>pg_stat_reset()</function></literal><indexterm><primary>pg_stat_reset</primary></indexterm></entry>
   <entry><type>void</type></entry>
   <entry>
    Remet à zéro tous les compteurs de statistique pour la base de données
    courante (nécessite les droits super-utilisateur par défaut, mais le droit
    EXECUTE peut être donné à d'autres pour cette fonction).
   </entry>
  </row>

  <row>
   <entry><literal><function>pg_stat_reset_shared</function>(text)</literal><indexterm><primary>pg_stat_reset_shared</primary></indexterm></entry>
   <entry><type>void</type></entry>
   <entry>
    Remet à zéro quelques statistiques globales de l'instance, en fonction de
    l'argument (nécessite les droits super-utilisateur by default, mais le
    droit EXECUTE peut être donné sur cette fonction à d'autres rôles).
    Appeler <literal>pg_stat_reset_shared('bgwriter')</literal>
    réinitialisera tous les compteurs montrés dans la vue
    <structname>pg_stat_bgwriter</structname>.
    Appeler <literal>pg_stat_reset_shared('archiver')</literal> réinitialisera
    tous les compteurs indiqués dans la vue
    <structname>pg_stat_archiver</structname>.
   </entry>
  </row>

  <row>
   <entry><literal><function>pg_stat_reset_single_table_counters</function>(oid)</literal><indexterm><primary>pg_stat_reset_single_table_counters</primary></indexterm></entry>
   <entry><type>void</type></entry>
   <entry>
    Remet à zéro les statistiques pour une seule table ou index dans la base
    de données courante (nécessite les droits super-utilisateur par défaut,
    mais le droit EXECUTE peut être donné à d'autres pour cette fonction).
   </entry>
  </row>

  <row>
   <entry><literal><function>pg_stat_reset_single_function_counters</function>(oid)</literal><indexterm><primary>pg_stat_reset_single_function_counters</primary></indexterm></entry>
   <entry><type>void</type></entry>
   <entry>
    Remet à zéro les statistiques pour une seule fonction dans la base
    de données courante (nécessite les droits super-utilisateur par défaut,
    mais le droit EXECUTE peut être donné à d'autres pour cette fonction).
   </entry>
  </row>
 </tbody>
</tgroup>
</table>

<para>
<function>pg_stat_get_activity</function>, la fonction sous-jacente de
la vue <structname>pg_stat_activity</structname>, retourne un ensemble
d'enregistrements contenant toute l'information disponible sur chaque
processus serveur. Parfois il peut être plus pratique de n'obtenir
qu'un sous-ensemble de cette information. Dans ces cas-là, un ensemble
plus vieux de fonctions d'accès aux statistiques par processus serveur
peut être utilisé&nbsp;; celle-ci sont montrées dans <xref
linkend="monitoring-stats-backend-funcs-table"/>.
Ces fonctions d'accès utilisent un numéro d'identifiant du processus serveur, qui
va de un au nombre de processus serveur actuellement actifs.
La fonction <function>pg_stat_get_backend_idset</function> fournit une
manière pratique de générer une ligne pour chaque processus serveur
actif pour appeler ces fonctions. Par exemple, pour montrer les
<acronym>PID</acronym> et requêtes en cours de tous les processus serveur&nbsp;:

<programlisting>
SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
       pg_stat_get_backend_activity(s.backendid) AS query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;
</programlisting>
</para>

<table id="monitoring-stats-backend-funcs-table">
<title>Fonctions statistiques par processus serveur</title>

<tgroup cols="3">
 <thead>
  <row>
   <entry>Fonction</entry>
   <entry>Type renvoyé</entry>
   <entry>Description</entry>
  </row>
 </thead>

 <tbody>

  <row>
   <entry><literal><function>pg_stat_get_backend_idset()</function></literal></entry>
   <entry><type>setof integer</type></entry>
   <entry>Ensemble de numéros de processus serveur actuellement actifs (de 1 jusqu'au
    nombre de processus serveur actifs)</entry>
  </row>

  <row>
   <entry><literal><function>pg_stat_get_backend_activity(integer)</function></literal></entry>
   <entry><type>text</type></entry>
   <entry>Texte de la requête la plus récente de ce processus serveur</entry>
  </row>

  <row>
   <entry><literal><function>pg_stat_get_backend_activity_start(integer)</function></literal></entry>
   <entry><type>timestamp with time zone</type></entry>
   <entry>Heure à laquelle la requête la plus récente a été démarrée</entry>
  </row>

  <row>
   <entry><literal><function>pg_stat_get_backend_client_addr(integer)</function></literal></entry>
   <entry><type>inet</type></entry>
   <entry>Adresse IP du client connecté à ce processus serveur</entry>
  </row>

  <row>
   <entry><literal><function>pg_stat_get_backend_client_port(integer)</function></literal></entry>
   <entry><type>integer</type></entry>
   <entry>Numéro de port TCP que le client utilise pour communiquer</entry>
  </row>

  <row>
   <entry><literal><function>pg_stat_get_backend_dbid(integer)</function></literal></entry>
   <entry><type>oid</type></entry>
   <entry>OID de la base de données auquelle ce processus serveur est connecté</entry>
  </row>

  <row>
   <entry><literal><function>pg_stat_get_backend_pid(integer)</function></literal></entry>
   <entry><type>integer</type></entry>
   <entry>Identifiant du processus serveur</entry>
  </row>

  <row>
   <entry><literal><function>pg_stat_get_backend_start(integer)</function></literal></entry>
   <entry><type>timestamp with time zone</type></entry>
   <entry>Heure à laquelle ce processus a été démarré</entry>
  </row>

  <row>
   <entry><literal><function>pg_stat_get_backend_userid(integer)</function></literal></entry>
   <entry><type>oid</type></entry>
   <entry>OID de l'utilisateur connecté à ce processus serveur</entry>
  </row>

  <row>
    <entry><literal><function>pg_stat_get_backend_wait_event_type(integer)</function></literal></entry>
    <entry><type>text</type></entry>
    <entry>Nom du type d'événement d'attente si le processus est actuellement
     en attente, NULL sinon. Voir <xref linkend="wait-event-table"/> pour les
     détails.</entry>
  </row>

  <row>
    <entry><literal><function>pg_stat_get_backend_wait_event(integer)</function></literal></entry>
    <entry><type>text</type></entry>
    <entry>Nom de l'événement d'attente si le processus est actuellement en
     attente, NULL sinon. Voir <xref linkend="wait-event-table"/> pour les
     détails.</entry>
  </row>

  <row>
   <entry><literal><function>pg_stat_get_backend_xact_start(integer)</function></literal></entry>
   <entry><type>timestamp with time zone</type></entry>
   <entry>Heure à laquelle la transaction courante a été démarrée</entry>
  </row>

 </tbody>
</tgroup>
</table>

</sect2>
</sect1>

<sect1 id="monitoring-locks">
<title>Visualiser les verrous</title>

<indexterm zone="monitoring-locks">
<primary>verrou</primary>
<secondary>surveillance</secondary>
</indexterm>

<para>
Un autre outil utile pour surveiller l'activité des bases de données est la
table système <structname>pg_locks</structname>. Elle permet à
l'administrateur système de visualiser des informations sur les verrous
restant dans le gestionnaire des verrous. Par exemple, cette fonctionnalité
peut être utilisée pour&nbsp;:

<itemizedlist>
<listitem>
 <para>
  Visualiser tous les verrous en cours, tous les verrous sur les relations
  d'une base de données particulière ou tous les verrous détenus par une
  session <productname>PostgreSQL</productname> particulière.
 </para>
</listitem>

<listitem>
 <para>
  Déterminer la relation de la base de données disposant de la plupart des
  verrous non autorisés (et qui, du coup, pourraient être une source de
  contention parmi les clients de la base de données).
 </para>
</listitem>

<listitem>
 <para>
  Déterminer l'effet de la contention des verrous sur les performances
  générales des bases de données, ainsi que l'échelle dans laquelle varie la
  contention sur le trafic de la base de données.
 </para>
</listitem>
</itemizedlist>

Les détails sur la vue <structname>pg_locks</structname> apparaissent dans la
<xref linkend="view-pg-locks"/>. Pour plus d'informations sur les verrous et
la gestion des concurrences avec <productname>PostgreSQL</productname>,
référez-vous au <xref linkend="mvcc"/>.
</para>
</sect1>
 
 <sect1 id="progress-reporting">
  <title>Rapporter la progression</title>

  <para>
   <productname>PostgreSQL</productname> a la possibilité de rapporter la
   progression de certaines commandes lors de leur exécution. Actuellement, la
   seule commande supportant un rapport de progression est
   <command>VACUUM</command>. Ceci pourrait être étendu dans le futur.
  </para>

 <sect2 id="vacuum-progress-reporting">
  <title>Rapporter la progression du VACUUM</title>

  <para>
   La vue <structname>pg_stat_progress_vacuum</structname> contient une ligne
   pour chaque processus serveur (incluant les processus autovacuum worker) en
   train d'exécuter un <command>VACUUM</command>. Les tableaux ci-dessous
   décrivent les informations rapportées et fournissent des informations sur
   leur interprétation. Le rapport de progression n'est actuellement pas
   supporté pour <command>VACUUM FULL</command>. De ce fait, les processus
   serveur exécutant un <command>VACUUM FULL</command> ne feront pas partie de
   la liste fournie par la vue.
  </para>

  <table id="pg-stat-progress-vacuum-view" xreflabel="pg_stat_progress_vacuum">
   <title>Vue <structname>pg_stat_progress_vacuum</structname></title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Colonne</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Identifiant (PID) du processus serveur.</entry>
    </row>
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID de la base de données où est connecté ce processus
      serveur.</entry>
    </row>
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Nom de la base de données où est connecté ce processus
      serveur.</entry>
    </row>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID de la table nettoyée par le VACUUM.</entry>
    </row>
    <row>
     <entry><structfield>phase</structfield></entry>
     <entry><type>text</type></entry>
     <entry>
       Phase actuelle du vacuum. Voir <xref linkend='vacuum-phases'/>.
     </entry>
    </row>
    <row>
     <entry><structfield>heap_blks_total</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       Nombre total de blocs de la table. Ce nombre est récupéré au début du
       parcours. Des blocs peuvent être ajoutés par la suie, mais ne seront
       pas (et n'ont pas besoin d'être) visités par ce
       <command>VACUUM</command>.
     </entry>
    </row>
    <row>
     <entry><structfield>heap_blks_scanned</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       Nombre de blocs parcourus dans la table. Comme la <link
       linkend="storage-vm">carte de visibilité</link> est utilisée pour
       optimiser les parcours, certains blocs seront ignorés sans
       inspection&nbsp;; les blocs ignorés sont inclus dans ce total, pour que
       ce nombre puisse devenir égal à
       <structfield>heap_blks_total</structfield> quand le nettoyage se
       termine. Ce compteur avance seulement quand la phase est
       <literal>scanning heap</literal>.
     </entry>
    </row>
    <row>
     <entry><structfield>heap_blks_vacuumed</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       Nombre de blocs nettoyés dans la table. Sauf si la table n'a pas
       d'index, ce compteur avance seulement quand la phase est
       <literal>vacuuming heap</literal>. Les blocs qui ne contiennent aucune
       ligne morte sont ignorés, donc le compteur pourrait parfois avancer par
       de larges incréments.
     </entry>
    </row>
    <row>
     <entry><structfield>index_vacuum_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       Nombre de cycles de nettoyage d'index réalisés.
     </entry>
    </row>
    <row>
     <entry><structfield>max_dead_tuples</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
      Nombre de lignes mortes que nous pouvons stocker avant d'avoir besoin de
      réaliser un cycle de nettoyage d'index, basé sur <xref
      linkend="guc-maintenance-work-mem"/>.
     </entry>
    </row>
    <row>
     <entry><structfield>num_dead_tuples</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       Nombre de lignes mortes récupérées depuis le dernier cycle de nettoyage
       d'index.
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <table id="vacuum-phases">
   <title>Phases du VACUUM</title>
   <tgroup cols="2">
    <thead>
    <row>
      <entry>Phase</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><literal>initializing</literal></entry>
     <entry>
       <command>VACUUM</command> se prépare à commencer le parcours de la
       table. Cette phase est habituellement très rapide.
     </entry>
    </row>
    <row>
     <entry><literal>scanning heap</literal></entry>
     <entry>
       <command>VACUUM</command> parcourt la table. Il va défragmenter chaque
       bloc si nécessaire et potentiellement réaliser un gel des lignes. La
       colonne <structfield>heap_blks_scanned</structfield> peut être utilisée
       pour surveiller la progression du parcours.
     </entry>
    </row>
    <row>
     <entry><literal>vacuuming indexes</literal></entry>
     <entry>
       <command>VACUUM</command> est en train de nettoyer les index. Si une
       table a des index, ceci surviendra au moins une fois par vacuum, après
       le parcours complet de la table. Cela pourrait arriver plusieurs fois
       par vacuum si if <xref linkend="guc-maintenance-work-mem"/> n'est pas
       suffisamment important pour y enregistrer le nombre de lignes mortes
       trouvées.
     </entry>
    </row>
    <row>
     <entry><literal>vacuuming heap</literal></entry>
     <entry>
       <command>VACUUM</command> est en train de nettoyer la table. Nettoyer
       la table est différent du parcours de la table, et survient après
       chaque phase de nettoyage d'index. Si
       <structfield>heap_blks_scanned</structfield> est inférieur à
       <structfield>heap_blks_total</structfield>, le système retournera à
       parcourir la table après la fin de cette phase. Sinon, il commencera le
       nettoyage des index une fois cette phase terminée.
     </entry>
    </row>
    <row>
     <entry><literal>cleaning up indexes</literal></entry>
     <entry>
       <command>VACUUM</command> est en train de nettoyer les index. Ceci
       survient que la table ait été entièrement parcourue et que le vacuum
       des index et de la table soit terminé.
     </entry>
    </row>
    <row>
     <entry><literal>truncating heap</literal></entry>
     <entry>
       <command>VACUUM</command> est en cours de tronquage de la table pour
       pouvoir redonner au système d'exploitation les pages vides en fin de
       relation. Ceci survient après le nettoyage des index.
     </entry>
    </row>
    <row>
     <entry><literal>performing final cleanup</literal></entry>
     <entry>
       <command>VACUUM</command> réalise le nettoyage final. Durant cette
       phase, <command>VACUUM</command> nettoiera la carte des espaces libres,
       mettra à jour les statistiques dans <literal>pg_class</literal>, et
       rapportera les statistiques au collecteur de statistiques. Une fois
       cette phase terminée,  <command>VACUUM</command> se terminera.
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

 </sect2>
 </sect1>


<sect1 id="dynamic-trace">
<title>Traces dynamiques</title>

<indexterm zone="dynamic-trace">
<primary>DTrace</primary>
</indexterm>

<para>
<productname>PostgreSQL</productname> fournit un support pour les traces
dynamiques du serveur de bases de données. Ceci permet l'appel à un outil
externe à certains points du code pour tracer son exécution.
</para>

<para>
Un certain nombre de sondes et de points de traçage sont déjà insérés dans
le code source. Ces sondes ont pour but d'être utilisées par des développeurs
et des administrateurs de base de données. Par défaut, les sondes ne sont pas
compilées dans <productname>PostgreSQL</productname>&nbsp;; l'utilisateur a
besoin de préciser explicitement au script configure de rendre disponible
les sondes.
</para>

<para>
Actuellement, l'outil <ulink
url="https://en.wikipedia.org/wiki/DTrace">DTrace</ulink> est supporté. Il
est disponible sur Solaris, macOS, FreeBSD, NetBSD et Oracle Linux. Le
projet <ulink url="http://sourceware.org/systemtap/">SystemTap</ulink>
fournit un équivalent DTrace et peut aussi être utilisé. Le support
d'autres outils de traces dynamiques est possible théoriquement en modifiant
les définitions des macros dans
<filename>src/include/utils/probes.h</filename>.
</para>

<sect2 id="compiling-for-trace">
<title>Compiler en activant les traces dynamiques</title>

<para>
Par défaut, les sondes ne sont pas disponibles, donc vous aurez besoin d'indiquer
explicitement au script configure de les activer dans
<productname>PostgreSQL</productname>. Pour inclure le support de DTrace,
ajoutez <option>--enable-dtrace</option> aux options de configure. Lire
<xref linkend="install-procedure"/> pour plus d'informations.
</para>
</sect2>

<sect2 id="trace-points">
<title>Sondes disponibles</title>

<para>
Un certain nombre de sondes standards sont fournies dans le code source,
comme indiqué dans <xref linkend="dtrace-probe-point-table"/>. <xref
linkend="typedefs-table"/> précise les types utilisés dans les sondes.
D'autres peuvent être ajoutées pour améliorer la surveillance de
<productname>PostgreSQL</productname>.
</para>

<table id="dtrace-probe-point-table">
<title>Sondes disponibles pour DTrace</title>
<tgroup cols="3">
 <thead>
  <row>
   <entry>Nom</entry>
   <entry>Paramètres</entry>
   <entry>Aperçu</entry>
  </row>
 </thead>

 <tbody>
  <row>
   <entry><literal>transaction-start</literal></entry>
   <entry><literal>(LocalTransactionId)</literal></entry>
   <entry>Sonde qui se déclenche au lancement d'une nouvelle transaction.
    arg0 est l'identifiant de transaction</entry>
  </row>
  <row>
   <entry><literal>transaction-commit</literal></entry>
   <entry><literal>(LocalTransactionId)</literal></entry>
   <entry>Sonde qui se déclenche quand une transaction se termine avec succès.
    arg0 est l'identifiant de transaction</entry>
  </row>
  <row>
   <entry><literal>transaction-abort</literal></entry>
   <entry><literal>(LocalTransactionId)</literal></entry>
   <entry>Sonde qui se déclenche quand une transaction échoue.
    arg0 est l'identifiant de transaction</entry>
  </row>
  <row>
   <entry><literal>query-start</literal></entry>
   <entry><literal>(const char *)</literal></entry>
   <entry>Sonde qui se déclenche lorsque le traitement d'une requête commence.
    arg0 est la requête</entry>
  </row>
  <row>
   <entry><literal>query-done</literal></entry>
   <entry><literal>(const char *)</literal></entry>
   <entry>Sonde qui se déclenche lorsque le traitement d'une requête se termine.
    arg0 est la requête</entry>
  </row>
  <row>
   <entry><literal>query-parse-start</literal></entry>
   <entry><literal>(const char *)</literal></entry>
   <entry>Sonde qui se déclenche lorsque l'analyse d'une requête commence.
    arg0 est la requête</entry>
  </row>
  <row>
   <entry><literal>query-parse-done</literal></entry>
   <entry><literal>(const char *)</literal></entry>
   <entry>Sonde qui se déclenche lorsque l'analyse d'une requête se termine.
    arg0 est la requête</entry>
  </row>
  <row>
   <entry><literal>query-rewrite-start</literal></entry>
   <entry><literal>(const char *)</literal></entry>
   <entry>Sonde qui se déclenche lorsque la ré-écriture d'une requête commence.
    arg0 est la requête</entry>
  </row>
  <row>
   <entry><literal>query-rewrite-done</literal></entry>
   <entry><literal>(const char *)</literal></entry>
   <entry>Sonde qui se déclenche lorsque la ré-écriture d'une requête se termine.
    arg0 est la requête</entry>
  </row>
  <row>
   <entry><literal>query-plan-start</literal></entry>
   <entry><literal>()</literal></entry>
   <entry>Sonde qui se déclenche lorsque la planification d'une requête commence</entry>
  </row>
  <row>
   <entry><literal>query-plan-done</literal></entry>
   <entry><literal>()</literal></entry>
   <entry>Sonde qui se déclenche lorsque la planification d'une requête se termine</entry>
  </row>
  <row>
   <entry><literal>query-execute-start</literal></entry>
   <entry><literal>()</literal></entry>
   <entry>Sonde qui se déclenche lorsque l'exécution d'une requête commence</entry>
  </row>
  <row>
   <entry><literal>query-execute-done</literal></entry>
   <entry><literal>()</literal></entry>
   <entry>Sonde qui se déclenche lorsque l'exécution d'une requête se termine</entry>
  </row>
  <row>
   <entry><literal>statement-status</literal></entry>
   <entry><literal>(const char *)</literal></entry>
   <entry>Sonde qui se déclenche à chaque fois que le processus serveur met à
    jour son statut dans
    <structname>pg_stat_activity</structname>.<structfield>status</structfield>.
    arg0 est la nouvelle chaîne de statut</entry>
  </row>
  <row>
   <entry><literal>checkpoint-start</literal></entry>
   <entry><literal>(int)</literal></entry>
   <entry>Sonde qui se déclenche quand un point de retournement commence son
    exécution.
    arg0 détient les drapeaux bit à bit utilisés pour distinguer les
    différents types de points de retournement, comme un point suite à un
    arrêt, un point immédiat ou un point forcé</entry>
  </row>
  <row>
   <entry><literal>checkpoint-done</literal></entry>
   <entry><literal>(int, int, int, int, int)</literal></entry>
   <entry>Sonde qui se déclenche quand un point de retournement a terminé son
    exécution (les sondes listées après se déclenchent en séquence lors du
    traitement d'un point de retournement).
    arg0 est le nombre de tampons mémoires écrits. arg1 est le nombre total
    de tampons mémoires. arg2, arg3 et arg4 contiennent respectivement le
    nombre de journaux de transactions ajoutés, supprimés et recyclés</entry>
  </row>
  <row>
   <entry><literal>clog-checkpoint-start</literal></entry>
   <entry><literal>(bool)</literal></entry>
   <entry>Sonde qui se déclenche quand la portion CLOG d'un point de
    retournement commence.
    arg0 est true pour un point de retournement normal, false pour un point
    de retournement suite à un arrêt</entry>
  </row>
  <row>
   <entry><literal>clog-checkpoint-done</literal></entry>
   <entry><literal>(bool)</literal></entry>
   <entry>Sonde qui se déclenche quand la portion CLOG d'un point de
    retournement commence.
    arg0 a la même signification que pour <literal>clog-checkpoint-start</literal></entry>
  </row>
  <row>
   <entry><literal>subtrans-checkpoint-start</literal></entry>
   <entry><literal>(bool)</literal></entry>
   <entry>Sonde qui se déclenche quand la portion SUBTRANS d'un point de
    retournement commence.
    arg0 est true pour un point de retournement normal, false pour un point
    de retournement suite à un arrêt</entry>
  </row>
  <row>
   <entry><literal>subtrans-checkpoint-done</literal></entry>
   <entry><literal>(bool)</literal></entry>
   <entry>Sonde qui se déclenche quand la portion SUBTRANS d'un point de
    retournement se termine.
    arg0 a la même signification que pour <literal>subtrans-checkpoint-start</literal></entry>
  </row>
  <row>
   <entry><literal>multixact-checkpoint-start</literal></entry>
   <entry><literal>(bool)</literal></entry>
   <entry>Sonde qui se déclenche quand la portion MultiXact d'un point de
    retournement commence.
    arg0 est true pour un point de retournement normal, false pour un point
    de retournement suite à un arrêt</entry>
  </row>
  <row>
   <entry><literal>multixact-checkpoint-done</literal></entry>
   <entry><literal>(bool)</literal></entry>
   <entry>Sonde qui se déclenche quand la portion MultiXact d'un point de
    retournement se termine.
    arg0 a la même signification que pour <literal>multixact-checkpoint-start</literal></entry>
  </row>
  <row>
   <entry><literal>buffer-checkpoint-start</literal></entry>
   <entry><literal>(int)</literal></entry>
   <entry>Sonde qui se déclenche quand la portion d'écriture de tampons d'un
    point de retournement commence.
    arg0 contient les drapeaux bit à bit pour distinguer différents types de
    point de retournement comme le point après arrêt, un point immédiat, un
    point forcé</entry>
  </row>
  <row>
   <entry><literal>buffer-sync-start</literal></entry>
   <entry><literal>(int, int)</literal></entry>
   <entry>Sonde qui se déclenche quand nous commençons d'écrire les tampons
    modifiés pendant un point de retournement (après identification des
    tampons qui doivent être écrits).
    arg0 est le nombre total de tampons.
    arg1 est le nombre de tampons qui sont modifiés et n'ont pas besoin
    d'être écrits</entry>
  </row>
  <row>
   <entry><literal>buffer-sync-written</literal></entry>
   <entry><literal>(int)</literal></entry>
   <entry>Sonde qui se déclenche après chaque écriture d'un tampon lors d'un
    point de retournement.
    arg0 est le numéro d'identifiant du tampon</entry>
  </row>
  <row>
   <entry><literal>buffer-sync-done</literal></entry>
   <entry><literal>(int, int, int)</literal></entry>
   <entry>Sonde qui se déclenche quand tous les tampons modifiés ont été
    écrits.
    arg0 est le nombre total de tampons.
    arg1 est le nombre de tampons réellement écrits par le processus de point
    de retournement.
    arg2 est le nombre attendu de tampons à écrire (arg1 de
    <literal>buffer-sync-start</literal>)&nbsp;; toute différence reflète d'autres processus
    écrivant des tampons lors du point de retournement</entry>
  </row>
  <row>
   <entry><literal>buffer-checkpoint-sync-start</literal></entry>
   <entry><literal>()</literal></entry>
   <entry>Sonde qui se déclenche une fois les tampons modifiés écrits par le
    noyau et avant de commencer à lancer des requêtes fsync</entry>
  </row>
  <row>
   <entry><literal>buffer-checkpoint-done</literal></entry>
   <entry><literal>()</literal></entry>
   <entry>Sonde qui se déclenche après la fin de la synchronisation des
    tampons sur le disque</entry>
  </row>
  <row>
   <entry><literal>twophase-checkpoint-start</literal></entry>
   <entry><literal>()</literal></entry>
   <entry>Sonde qui se déclenche quand la portion deux-phases d'un point de
    retournement est commencée</entry>
  </row>
  <row>
   <entry><literal>twophase-checkpoint-done</literal></entry>
   <entry><literal>()</literal></entry>
   <entry>Sonde qui se déclenche quand la portion deux-phases d'un point de
    retournement est terminée</entry>
  </row>
  <row>
   <entry><literal>buffer-read-start</literal></entry>
   <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)</literal></entry>
   <entry>Sonde qui se déclenche quand la lecture d'un tampon commence.
    arg0 et arg1 contiennent les numéros de fork et de bloc de la page (arg1
    vaudra -1 s'il s'agit de demande d'extension de la relation).
    arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
    base de données et de la relation identifiant ainsi précisément la
    relation.
    arg5 est l'identifiant du processus moteur qui a créé la relation
    temporaire pour un tampon local ou <symbol>InvalidBackendId</symbol> (-1) pour un
    tampon partagé.
    arg6 est true pour une demande d'extension de la relation, false pour
    une lecture ordinaire</entry>
  </row>
  <row>
   <entry><literal>buffer-read-done</literal></entry>
   <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool)</literal></entry>
   <entry>Sonde qui se déclenche quand la lecture d'un tampon se termine.
    arg0 et arg1 contiennent les numéros de fork et de bloc de la page (arg1
    contient le numéro de bloc du nouveau bloc ajouté s'il s'agit de demande
    d'extension de la relation).
    arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
    base de données et de la relation identifiant ainsi précisément la
    relation.
    arg5 est l'identifiant du processus moteur qui a créé la relation
    temporaire pour un tampon local ou <symbol>InvalidBackendId</symbol> (-1) pour un
    tampon partagé.
    arg6 est true pour une demande d'extension de la relation, false pour
    une lecture ordinaire.
    arg7 est true si la tampon était disponible en mémoire, false sinon</entry>
  </row>
  <row>
   <entry><literal>buffer-flush-start</literal></entry>
   <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
   <entry>Sonde qui se déclenche avant de lancer une demande d'écriture pour
    un bloc partagé.
    arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
    base de données et de la relation identifiant ainsi précisément la
    relation</entry>
  </row>
  <row>
   <entry><literal>buffer-flush-done</literal></entry>
   <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
   <entry>Sonde qui se déclenche quand une demande d'écriture se termine.
    (Notez que ceci ne reflète que le temps passé pour fournir la donnée au
    noyau&nbsp;; ce n'est habituellement pas encore écrit sur le disque.)
    Les arguments sont identiques à ceux de <literal>buffer-flush-start</literal></entry>
  </row>
  <row>
   <entry><literal>buffer-write-dirty-start</literal></entry>
   <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
   <entry>Sonde qui se déclenche quand un processus serveur commence à écrire
    un tampon modifié sur disque. Si cela arrive souvent, cela implique que
    <xref linkend="guc-shared-buffers"/> est trop petit ou que les paramètres
    de contrôle de bgwriter ont besoin d'un ajustement.)
    arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
    arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
    base de données et de la relation identifiant ainsi précisément la
    relation</entry>
  </row>
  <row>
   <entry><literal>buffer-write-dirty-done</literal></entry>
   <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
   <entry>Sonde qui se déclenche quand l'écriture d'un tampon modifié est
    terminé.
    Les arguments sont identiques à ceux de <literal>buffer-write-dirty-start</literal></entry>
  </row>
  <row>
   <entry><literal>wal-buffer-write-dirty-start</literal></entry>
   <entry><literal>()</literal></entry>
   <entry>Sonde qui se déclenche quand un processus serveur commence à écrire
    un tampon modifié d'un journal de transactions parce qu'il n'y a plus
    d'espace disponible dans le cache des journaux de transactions. (Si cela
    arrive souvent, cela implique que <xref linkend="guc-wal-buffers"/> est
    trop petit.)</entry>
  </row>
  <row>
   <entry><literal>wal-buffer-write-dirty-done</literal></entry>
   <entry><literal>()</literal></entry>
   <entry>Sonde qui se déclenche quand l'écriture d'un tampon modifié d'un
    journal de transactions est terminée</entry>
  </row>
  <row>
   <entry><literal>wal-insert</literal></entry>
   <entry><literal>(unsigned char, unsigned char)</literal></entry>
   <entry>Sonde qui se déclenche quand un enregistrement est inséré dans un
    journal de transactions.
    arg0 est le gestionnaire de ressource (rmid) pour l'enregistrement.
    arg1 contient des informations supplémentaires</entry>
  </row>
  <row>
   <entry><literal>wal-switch</literal></entry>
   <entry><literal>()</literal></entry>
   <entry>Sonde qui se déclenche quand une bascule du journal de transactions
    est demandée</entry>
  </row>
  <row>
   <entry><literal>smgr-md-read-start</literal></entry>
   <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
   <entry>Sonde qui se déclenche au début de la lecture d'un bloc d'une
    relation.
    arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
    arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
    base de données et de la relation identifiant ainsi précisément la
    relation.
    arg5 est l'identifiant du processus moteur qui a créé la relation
    temporaire pour un tampon local ou <symbol>InvalidBackendId</symbol> (-1) pour un
    tampon partagé</entry>
  </row>
  <row>
   <entry><literal>smgr-md-read-done</literal></entry>
   <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
   <entry>Sonde qui se déclenche à la fin de la lecture d'un bloc.
    arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
    arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
    base de données et de la relation identifiant ainsi précisément la
    relation.
    arg5 est l'identifiant du processus moteur qui a créé la relation
    temporaire pour un tampon local ou <symbol>InvalidBackendId</symbol> (-1) pour un
    tampon partagé.
    arg6 est le nombre d'octets réellement lus alors que arg7 est le nombre
    d'octets demandés (s'il y a une différence, il y a un problème)</entry>
  </row>
  <row>
   <entry><literal>smgr-md-write-start</literal></entry>
   <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
   <entry>Sonde qui se déclenche au début de l'écriture d'un bloc dans une
    relation.
    arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
    arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
    base de données et de la relation identifiant ainsi précisément la
    relation.
    arg5 est l'identifiant du processus moteur qui a créé la relation
    temporaire pour un tampon local ou <symbol>InvalidBackendId</symbol> (-1) pour un
    tampon partagé</entry>
  </row>
  <row>
   <entry><literal>smgr-md-write-done</literal></entry>
   <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
   <entry>Sonde qui se déclenche à la fin de l'écriture d'un bloc.
    arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
    arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
    base de données et de la relation identifiant ainsi précisément la
    relation.
    arg5 est l'identifiant du processus moteur qui a créé la relation
    temporaire pour un tampon local ou <symbol>InvalidBackendId</symbol> (-1) pour un
    tampon partagé.
    arg6 est le nombre d'octets réellement écrits alors que arg7 est le nombre
    d'octets demandés (si ces nombres sont différents, cela indique un
    problème)</entry>
  </row>
  <row>
   <entry><literal>sort-start</literal></entry>
   <entry><literal>(int, bool, int, int, bool, int)</literal></entry>
   <entry>Sonde qui se déclenche quand une opération de tri est démarré.
    arg0 indique un tri de la table, de l'index ou d'un datum.
    arg1 est true si on force les valeurs uniques.
    arg2 est le nombre de colonnes clés.
    arg3 est le nombre de Ko de mémoire autorisé pour ce travail.
    arg4 est true si un accès aléatoire au résultat du tri est requis
    arg5 indicates serial when <literal>0</literal>, parallel worker when
    <literal>1</literal>, or parallel leader when <literal>2</literal>.</entry>
  </row>
  <row>
   <entry><literal>sort-done</literal></entry>
   <entry><literal>(bool, long)</literal></entry>
   <entry>Sonde qui se déclenche quand un tri est terminé.
    arg0 est true pour un tri externe, false pour un tri interne.
    arg1 est le nombre de blocs disque utilisés pour un tri externe, ou le
    nombre de Ko de mémoire utilisés pour un tri interne</entry>
  </row>
  <row>
   <entry><literal>lwlock-acquire</literal></entry>
   <entry><literal>(char *, LWLockMode)</literal></entry>
   <entry>Sonde qui se déclenche quand un LWLock a été acquis.
    arg0 est la tranche de LWLock.
    arg1 est le mode de verrou attendu, soit exclusif soit partagé.</entry>
  </row>
  <row>
   <entry><literal>lwlock-release</literal></entry>
   <entry><literal>(char *)</literal></entry>
   <entry>Sonde qui se déclenche quand un LWLock a été relâché (mais notez
    que tout processus en attente n'a pas encore été réveillé).
    arg0 est la tranche de LWLock.</entry>
  </row>
  <row>
   <entry><literal>lwlock-wait-start</literal></entry>
   <entry><literal>(char *, LWLockMode)</literal></entry>
   <entry>Sonde qui se déclenche quand un LWLock n'était pas immédiatement
    disponible et qu'un processus serveur a commencé à attendre la
    disponibilité du verrou.
    arg0 est la tranche de LWLock.
    arg1 est le mode de verrou attendu, soit exclusif soit partagé.</entry>
  </row>
  <row>
   <entry><literal>lwlock-wait-done</literal></entry>
   <entry><literal>(char *, LWLockMode)</literal></entry>
   <entry>Sonde qui se déclenche quand un processus serveur n'est plus en
    attente d'un LWLock (il n'a pas encore le verrou).
    arg0 est la tranche de LWLock.
    arg1 est le mode de verrou attendu, soit exclusif soit partagé.</entry>
  </row>
  <row>
   <entry><literal>lwlock-condacquire</literal></entry>
   <entry><literal>(char *, LWLockMode)</literal></entry>
   <entry>Sonde qui se déclenche quand un LWLock a été acquis avec succès
    malgré le fait que l'appelant ait demandé de ne pas attendre.
    arg0 est la tranche de LWLock.
    arg1 est le mode de verrou attendu, soit exclusif soit partagé.</entry>
  </row>
  <row>
   <entry><literal>lwlock-condacquire-fail</literal></entry>
   <entry><literal>(char *, LWLockMode)</literal></entry>
   <entry>Sonde qui se déclenche quand un LWLock, demandé sans attente, n'est
    pas accepté.
    arg0 est la tranche de LWLock.
    arg1 est le mode de verrou attendu, soit exclusif soit partagé.</entry>
  </row>
  <row>
   <entry><literal>lock-wait-start</literal></entry>
   <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</literal></entry>
   <entry>Sonde qui se déclenche quand une demande d'un gros verrou
    (<foreignphrase>lmgr lock</foreignphrase>) a commencé l'attente parce que
    le verrou n'était pas disponible.
    arg0 à arg3 sont les champs identifiant l'objet en cours de verrouillage.
    arg4 indique le type d'objet à verrouiller.
    arg5 indique le type du verrou demandé</entry>
  </row>
  <row>
   <entry><literal>lock-wait-done</literal></entry>
   <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</literal></entry>
   <entry>Sonde qui se déclenche quand une demande d'un gros verrou
    (<foreignphrase>lmgr lock</foreignphrase>) a fini d'attendre (c'est-à-dire
    que le verrou a été accepté).
    Les arguments sont identiques à ceux de lock-wait-start</entry>
  </row>
  <row>
   <entry><literal>deadlock-found</literal></entry>
   <entry><literal>()</literal></entry>
   <entry>Sonde qui se déclenche quand un verrou mortel est trouvé par le
    détecteur</entry>
  </row>

 </tbody>
</tgroup>
</table>

<table id="typedefs-table">
<title>Types définis utilisés comme paramètres de sonde</title>
<tgroup cols="2">
 <thead>
  <row>
   <entry>Type</entry>
   <entry>Definition</entry>
  </row>
 </thead>

 <tbody>

  <row>
   <entry><type>LocalTransactionId</type></entry>
   <entry><type>unsigned int</type></entry>
  </row>
  <row>
   <entry><type>LWLockMode</type></entry>
   <entry><type>int</type></entry>
  </row>
  <row>
   <entry><type>LOCKMODE</type></entry>
   <entry><type>int</type></entry>
  </row>
  <row>
   <entry><type>BlockNumber</type></entry>
   <entry><type>unsigned int</type></entry>
  </row>
  <row>
   <entry><type>Oid</type></entry>
   <entry><type>unsigned int</type></entry>
  </row>
  <row>
   <entry><type>ForkNumber</type></entry>
   <entry><type>int</type></entry>
  </row>
  <row>
   <entry><type>bool</type></entry>
   <entry><type>char</type></entry>
  </row>

 </tbody>
</tgroup>
</table>
</sect2>

<sect2 id="using-trace-points">
<title>Utiliser les sondes</title>

<para>
L'exemple ci-dessous montre un script DTrace pour l'analyse du nombre de
transactions sur le système, comme alternative à l'interrogation régulière
de <structname>pg_stat_database</structname> avant et après un test de
performance&nbsp;:
<programlisting>#!/usr/sbin/dtrace -qs

postgresql$1:::transaction-start
{
      @start["Start"] = count();
      self->ts  = timestamp;
}

postgresql$1:::transaction-abort
{
      @abort["Abort"] = count();
}

postgresql$1:::transaction-commit
/self->ts/
{
      @commit["Commit"] = count();
      @time["Total time (ns)"] = sum(timestamp - self->ts);
      self->ts=0;
}
</programlisting>
À son exécution, le script de l'exemple D donne une sortie comme&nbsp;:
<screen># ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;
^C

Start                                          71
Commit                                         70
Total time (ns)                        2312105013
</screen>
</para>

<note>
<para>
 SystemTap utilise une notation différente de DTrace pour les scripts de
 trace, même si les points de trace sont compatibles. Il est intéressant de
 noter que, lorsque nous avons écrit ce texte, les scripts SystemTap doivent
 référencer les noms des sondes en utilisant des tirets bas doubles à la
 place des tirets simples. Il est prévu que les prochaines versions de
 SystemTap corrigent ce problème.
</para>
</note>

<para>
Vous devez vous rappeler que les programmes DTrace doivent être écrits
soigneusement, sinon les informations récoltées pourraient ne rien valoir.
Dans la plupart des cas où des problèmes sont découverts, c'est
l'instrumentation qui est erronée, pas le système sous-jacent. En discutant
des informations récupérées en utilisant un tel système, il est essentiel de
s'assurer que le script utilisé est lui-aussi vérifié et discuter.
</para>
</sect2>

<sect2 id="defining-trace-points">
<title>Définir de nouvelles sondes</title>

<para>
De nouvelles sondes peuvent être définies dans le code partout où le
développeur le souhaite bien que cela nécessite une nouvelle compilation.
Voici les étapes nécessaires pour insérer de nouvelles sondes&nbsp;:
</para>

<procedure>
<step>
 <para>
  Décider du nom de la sonde et des données nécessaires pour la sonde
 </para>
</step>

<step>
 <para>
  Ajoutez les définitions de sonde dans
  <filename>src/backend/utils/probes.d</filename>
 </para>
</step>

<step>
 <para>
  Inclure <filename>pg_trace.h</filename> s'il n'est pas déjà présent dans le
  module contenant les points de sonde, et insérer les macros
  <literal>TRACE_POSTGRESQL</literal> aux emplacements souhaités dans le code
  source
 </para>
</step>

<step>
 <para>
  Recompiler et vérifier que les nouvelles sondes sont disponibles
 </para>
</step>
</procedure>

<formalpara>
<title>Exemple&nbsp;:</title>
<para>
 Voici un exemple d'ajout d'une sonde pour tracer toutes les nouvelles
 transactions par identifiant de transaction.
</para>
</formalpara>

<procedure>
<step>
 <para>
  La sonde sera nommée <literal>transaction-start</literal> et nécessite
  un paramètre de type <type>LocalTransactionId</type>
 </para>
</step>

<step>
 <para>
  Ajout de la définition de la sonde dans
  <filename>src/backend/utils/probes.d</filename>&nbsp;:
  <programlisting>
      probe transaction__start(LocalTransactionId);
  </programlisting>
  Notez l'utilisation du double tiret bas dans le nom de la sonde. Dans un
  script DTrace utilisant la sonde, le double tiret bas doit être remplacé
  par un tiret, donc <literal>transaction-start</literal> est le nom à
  documenter pour les utilisateurs.
 </para>
</step>

<step>
 <para>
  Au moment de la compilation, <literal>transaction__start</literal> est
  converti en une macro appelée <literal>TRACE_POSTGRESQL_TRANSACTION_START</literal>
  (notez que les tirets bas ne sont plus doubles ici), qui est disponible
  en incluant le fichier <filename>pg_trace.h</filename>. Il faut ajouter
  l'appel à la macro aux bons emplacements dans le code source. Dans ce
  cas, cela ressemble à&nbsp;:

  <programlisting>
    TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
  </programlisting>
 </para>
</step>

<step>
 <para>
  Après une nouvelle compilation et l'exécution du nouveau binaire, il
  faut vérifier que la nouvelle sonde est disponible en exécutant la
  commande DTrace suivante. Vous deviez avoir cette sortie&nbsp;:
  <screen>
# dtrace -ln transaction-start
   ID    PROVIDER          MODULE           FUNCTION NAME
18705 postgresql49878     postgres     StartTransactionCommand transaction-start
18755 postgresql49877     postgres     StartTransactionCommand transaction-start
18805 postgresql49876     postgres     StartTransactionCommand transaction-start
18855 postgresql49875     postgres     StartTransactionCommand transaction-start
18986 postgresql49873     postgres     StartTransactionCommand transaction-start
  </screen>
 </para>
</step>
</procedure>

<para>
Il faut faire attention à d'autres choses lors de l'ajout de macros de
trace dans le code C&nbsp;:

<itemizedlist>
 <listitem>
  <para>
   Vous devez faire attention au fait que les types de données indiqués
   pour les paramètres d'une sonde correspondent aux types de données des
   variables utilisées dans la macro. Dans le cas contraire, vous obtiendrez
   des erreurs de compilation.
  </para>
 </listitem>


 <listitem>
  <para>
   Sur la plupart des plateformes, si <productname>PostgreSQL</productname>
   est construit avec <option>--enable-dtrace</option>, les arguments pour
   une macro de trace seront évalués à chaque fois que le contrôle passe
   dans la macro, <emphasis>même si aucun traçage n'est réellement en
    cours</emphasis>. Cela a généralement peu d'importance si vous rapportez
   seulement les valeurs de quelques variables locales, mais faites bien
   attention à l'utilisation de fonctions coûteuses. Si vous devez le faire,
   pensez à protéger la macro avec une vérification pour vous assurer que
   la trace est bien activée&nbsp;:

   <programlisting>
    if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
        TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));
   </programlisting>

   Chaque macro de trace a une macro <literal>ENABLED</literal>
   correspondante.
  </para>
 </listitem>
</itemizedlist>

</para>

</sect2>

</sect1>

</chapter>
