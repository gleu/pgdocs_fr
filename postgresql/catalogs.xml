<?xml version="1.0" encoding="UTF-8"?>
<chapter id="catalogs">
 <title>Catalogues système</title>

  <para>
   Les catalogues système représentent l'endroit où une base de données relationnelle
   stocke les métadonnées des schémas, telles que les informations sur les tables 
   et les colonnes, et des données de suivi interne.
   Les catalogues système de <productname>PostgreSQL</productname> sont de
   simples tables. Elle peuvent être supprimées et recrées. Il est possible
   de leur ajouter des colonnes, d'y insérer et modifier des valeurs, et de
   mettre un joyeux bazar dans le système. En temps normal, l'utilisateur n'a aucune
   raison de modifier les catalogues
   système, il y a toujours des commandes SQL pour le faire. (Par
   exemple, <command>CREATE DATABASE</command> insère une ligne dans le 
   catalogue <structname>pg_database</structname> &mdash; et crée physiquement
   la base de données sur le disque.) Il y a des exceptions pour certaines 
   opérations particulièrement ésotériques, comme l'ajout de méthodes d'accès
   aux index.
  </para>

 <sect1 id="catalogs-overview">
  <title>Aperçu</title>

  <para>
   <xref linkend="catalog-table"/> liste les catalogues système.
   Une documentation plus détaillée des catalogues système suit.
  </para>

  <para>
   La plupart des catalogues système sont recopiés de la base de données modèle
   lors de la création de la base de données et deviennent alors spécifiques à 
   chaque base de données. Un petit nombre de catalogues sont physiquement 
   partagés par toutes les bases de données d'une installation de 
   <productname>PostgreSQL</productname>. Ils sont indiqués dans les 
   descriptions des catalogues.
  </para>

  <table id="catalog-table">
   <title>Catalogues système</title>

   <tgroup cols="2">
    <colspec colnum="1" colwidth="1*"/>
    <colspec colnum="2" colwidth="2*"/>
    <thead>
     <row>
      <entry>Nom du catalogue</entry>
      <entry>Contenu</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="catalog-pg-aggregate"><structname>pg_aggregate</structname></link></entry>
      <entry>fonctions d'agrégat</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-am"><structname>pg_am</structname></link></entry>
      <entry>méthodes d'accès aux index</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amop"><structname>pg_amop</structname></link></entry>
      <entry>opérateurs des méthodes d'accès</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link></entry>
      <entry>procédures de support des méthodes d'accès</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attrdef"><structname>pg_attrdef</structname></link></entry>
      <entry>valeurs par défaut des colonnes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link></entry>
      <entry>colonnes des tables (<quote>attributs</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link></entry>
      <entry>identifiants d'autorisation (rôles)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link></entry>
      <entry>relations d'appartenance aux identifiants d'autorisation</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-cast"><structname>pg_cast</structname></link></entry>
      <entry>conversions de types de données (<foreignphrase>cast</foreignphrase>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-class"><structname>pg_class</structname></link></entry>
      <entry>tables, index, séquences, vues (<quote>relations</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link></entry>
      <entry>contraintes de vérification, contraintes uniques, contraintes de clés primaires, contraintes de clés étrangères</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link></entry>
      <entry>collationnement (information locale)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-conversion"><structname>pg_conversion</structname></link></entry>
      <entry>informations de conversions de codage</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-database"><structname>pg_database</structname></link></entry>
      <entry>bases de données du cluster <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-db-role-setting"><structname>pg_db_role_setting</structname></link></entry>
      <entry>configuration par rôle et par base de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-default-acl"><structname>pg_default_acl</structname></link></entry>
      <entry>droits par défaut sur des types d'objets</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-depend"><structname>pg_depend</structname></link></entry>
      <entry>dépendances entre objets de la base de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-description"><structname>pg_description</structname></link></entry>
      <entry>descriptions ou commentaires des objets de base de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-enum"><structname>pg_enum</structname></link></entry>
      <entry>définitions des labels et des valeurs des enum</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-extension"><structname>pg_extension</structname></link></entry>
      <entry>extensions installées</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-foreign-data-wrapper"><structname>pg_foreign_data_wrapper</structname></link></entry>
      <entry>définitions des wrappers de données distantes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link></entry>
      <entry>définitions des serveurs distants</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-foreign-table"><structname>pg_foreign_table</structname></link></entry>
      <entry>informations supplémentaires sur les tables distantes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-index"><structname>pg_index</structname></link></entry>
      <entry>informations supplémentaires des index</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-inherits"><structname>pg_inherits</structname></link></entry>
      <entry>hiérarchie d'héritage de tables</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-language"><structname>pg_language</structname></link></entry>
      <entry>langages d'écriture de fonctions</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link></entry>
      <entry>pages de données pour les «&nbsp;Large Objects&nbsp;»</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link></entry>
      <entry>métadonnées pour les «&nbsp;Large Objects&nbsp;»</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link></entry>
      <entry>schémas</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link></entry>
      <entry>classes d'opérateurs de méthodes d'accès</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link></entry>
      <entry>opérateurs</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link></entry>
      <entry>familles d'opérateurs de méthodes d'accès</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-pltemplate"><structname>pg_pltemplate</structname></link></entry>
      <entry>données modèles pour les langages procéduraux</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link></entry>
      <entry>fonctions et procédures</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link></entry>
      <entry>règles de réécriture de requêtes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link></entry>
      <entry>labels de sécurité sur les objets d'une base de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link></entry>
      <entry>dépendances sur les objets partagés</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link></entry>
      <entry>commentaires sur les objets partagés</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link></entry>
      <entry>statistiques de l'optimiseur de requêtes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link></entry>
      <entry><foreignphrase>tablespaces</foreignphrase> du cluster de bases de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link></entry>
      <entry>déclencheurs</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-config"><structname>pg_ts_config</structname></link></entry>
      <entry>configuration de la recherche plein texte</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-config-map"><structname>pg_ts_config_map</structname></link></entry>
      <entry>configuration de la recherche plein texte pour la correspondance
      des lexèmes (<foreignphrase>token</foreignphrase>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-dict"><structname>pg_ts_dict</structname></link></entry>
      <entry>dictionnaires de la recherche plein texte</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-parser"><structname>pg_ts_parser</structname></link></entry>
      <entry>analyseurs de la recherche plein texte</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-template"><structname>pg_ts_template</structname></link></entry>
      <entry>modèles de la recherche plein texte</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-type"><structname>pg_type</structname></link></entry>
      <entry>types de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link></entry>
      <entry>correspondance d'utilisateurs sur des serveurs distants</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-aggregate">
  <title><structname>pg_aggregate</structname></title>

  <indexterm zone="catalog-pg-aggregate">
   <primary>pg_aggregate</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_aggregate</structname> stocke les informations 
   concernant les fonctions d'agrégat. Une fonction d'agrégat est une fonction
   qui opère sur un ensemble de données (typiquement une colonne de chaque ligne
   qui correspond à une condition de requête) et retourne une valeur unique 
   calculée à partir de toutes ces valeurs.
   Les fonctions d'agrégat classiques sont
   <function>sum</function> (somme), <function>count</function> (compteur) et
   <function>max</function> (plus grande valeur). Chaque entrée de
   <structname>pg_aggregate</structname> est une extension d'une entrée de
   <structname>pg_proc</structname>. L'entrée de <structname>pg_proc</structname>
   contient le nom de l'agrégat, les types de données d'entrée et de sortie, et
   d'autres informations similaires aux fonctions ordinaires.
  </para>

  <table>
   <title>Les colonnes de <structname>pg_aggregate</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>aggfnoid</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID <structname>pg_proc</structname> de la fonction d'agrégat</entry>
     </row>
     <row>
      <entry><structfield>aggtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction de transition</entry>
     </row>
     <row>
      <entry><structfield>aggfinalfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction finale (0 s'il n'y en a pas)</entry>
     </row>
     <row>
      <entry><structfield>aggsortop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Opérateur de tri associé (0 s'il n'y en a pas)</entry>
     </row>
     <row>
      <entry><structfield>aggtranstype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de la donnée interne de transition (état) de la fonction d'agrégat</entry>
     </row>
     <row>
      <entry><structfield>agginitval</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Valeur initiale de la fonction de transition. C'est un champ texte qui
       contient la valeur initiale dans sa représentation externe en chaîne de 
       caractères. Si ce champ est NULL, la valeur d'état de transition 
       est initialement NULL.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les nouvelles fonctions d'agrégat sont enregistrées avec la commande
   <xref linkend="sql-createaggregate"/>.
   La <xref linkend="xaggr"/>  fournit de plus amples informations sur
   l'écriture des fonctions d'agrégat et sur
   la signification des fonctions de transition.
  </para>

 </sect1>

 <sect1 id="catalog-pg-am">
  <title><structname>pg_am</structname></title>

  <indexterm zone="catalog-pg-am">
   <primary>pg_am</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_am</structname> stocke les informations
   concernant les méthodes d'accès aux index. On trouve une ligne par méthode d'accès
   supportée par le système. Le contenu de ce catalogue est discuté en détails
   dans <xref linkend="indexam"/>.
   </para>

  <table>
   <title>Colonnes de <structname>pg_am</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>amname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la méthode d'accès</entry>
     </row>

     <row>
      <entry><structfield>amstrategies</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre de stratégies d'opérateur pour cette méthode d'accès,
       ou zéro si la méthode d'accès n'a pas un ensemble fixe de stratégies
       opérateurs</entry>
     </row>

     <row>
      <entry><structfield>amsupport</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre de routines de support pour cette méthode d'accès</entry>
     </row>

     <row>
      <entry><structfield>amcanorder</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La méthode d'accès supporte-t-elle les parcours
       ordonnés par la valeur de la colonne indexée&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amcanorderbyop</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La méthode d'accès supporte-t-elle les parcours ordonnés
       par le résultat d'un opérateur sur une colonne indexée&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amcanbackward</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La méthode d'accès supporte-t-elle les parcours en
       arrière&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amcanunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La méthode d'accès supporte-t-elle les index
       uniques&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amcanmulticol</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La méthode d'accès supporte-t-elle les index
       multicolonnes&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amoptionalkey</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La méthode d'accès supporte-t-elle un parcours sans
      contrainte pour la première colonne de l'index&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amsearchnulls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La méthode d'accès supporte-t-elle les recherches
       <literal>IS NULL</literal>/<literal>NOT NULL</literal>&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amstorage</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Le type de données de stockage d'index peut-il différer du type de
      données de la colonne&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amclusterable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La commande CLUSTER peut-elle être utilisée avec un index de ce
      type&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>ampredlocks</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Un index de ce type peut-il gérer finement des verrous de
       prédicat&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amkeytype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de donnée stockée dans l'index, ou zéro si le type n'est pas
       de taille fixe</entry>
     </row>

     <row>
      <entry><structfield>aminsert</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>insérer cette ligne</quote></entry>
     </row>

     <row>
      <entry><structfield>ambeginscan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>préparer un nouveau parcours</quote></entry>
     </row>

     <row>
      <entry><structfield>amgettuple</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>prochaine ligne valide</quote>, ou zéro si aucune</entry>
     </row>

     <row>
      <entry><structfield>amgetbitmap</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>récupérer toutes les lignes valides</quote></entry>
     </row>

     <row>
      <entry><structfield>amrescan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>(re)démarrer le parcours d'index</quote></entry>
     </row>

     <row>
      <entry><structfield>amendscan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>nettoyer après le parcours d'index</quote></entry>
     </row>

     <row>
      <entry><structfield>ammarkpos</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>marquer la position actuelle du parcours</quote></entry>
     </row>

     <row>
      <entry><structfield>amrestrpos</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>restaurer une position de parcours marquée</quote></entry>
     </row>

     <row>
      <entry><structfield>ambuild</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>construire un nouvel index</quote></entry>
     </row>

     <row>
      <entry><structfield>ambuildempty</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>construire un index vide</quote></entry>
     </row>

     <row>
      <entry><structfield>ambulkdelete</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction de destruction en masse</entry>
     </row>

     <row>
      <entry><structfield>amvacuumcleanup</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction de nettoyage post-<command>VACUUM</command></entry>
     </row>

     <row>
      <entry><structfield>amcostestimate</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction d'estimation du coût de parcours d'un index</entry>
     </row>

     <row>
      <entry><structfield>amoptions</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction d'analyse et de validation du champ
       <structfield>reloptions</structfield> d'un index</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-amop">
  <title><structname>pg_amop</structname></title>

  <indexterm zone="catalog-pg-amop">
   <primary>pg_amop</primary>
  </indexterm>

  <para> Le catalogue <structname>pg_amop</structname> stocke les
  informations concernant les opérateurs associés aux familles
  d'opérateurs des méthodes d'accès aux index. Il y a une ligne pour
  chaque opérateur membre d'une famille. Un membre d'une famille peut
  être soit un opérateur de <firstterm>recherche</firstterm> soit un
  opérateur de <firstterm>tri</firstterm>. Un opérateur peut apparaître
  dans plus d'une famille, mais ne peut pas apparaître dans plus d'une
  position à l'intérieur d'une famille.
  </para>

  <table>
   <title>Colonnes de <structname>pg_amop</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>amopfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>La famille d'opérateur</entry>
     </row>

     <row>
      <entry><structfield>amoplefttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de données en entrée, côté gauche, de l'opérateur</entry>
     </row>

     <row>
      <entry><structfield>amoprighttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de données en entrée, côté droit, de l'opérateur</entry>
     </row>

     <row>
      <entry><structfield>amopstrategy</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Numéro de stratégie d'opérateur</entry>
     </row>

     <row>
      <entry><structfield>amoppurpose</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>But de l'opérateur, soit <literal>s</literal> pour
       recherche soit <literal>o</literal> pour tri</entry>
     </row>

     <row>
      <entry><structfield>amopopr</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>OID de l'opérateur</entry>
     </row>

     <row>
      <entry><structfield>amopmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>Méthode d'accès à l'index pour cette famille d'opérateur</entry>
     </row>

     <row>
      <entry><structfield>amopsortfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>La famille d'opérateur B-tree utilisée par cette entrée pour
       trier s'il s'agit d'un opérateur de tri&nbsp;; zéro s'il s'agit
       d'un opérateur de recherche</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Un opérateur de <quote>recherche</quote> indique qu'un index de cet
   opérateur peut être utilisé pour rechercher toutes les lignes
   satisfaisant une clause <literal>WHERE</literal>
   <replaceable>colonne_indexé</replaceable>
   <replaceable>opérateur</replaceable>
   <replaceable>constante</replaceable>. Cet opérateur doit évidemment
   renvoyer un booléen et le type de l'entrée gauche doit correspondre
   au type de données de la colonne de l'index.
  </para>

  <para>
   Un opérateur de <quote>tri</quote> indique qu'un index de cette
   famille d'opérateur peut être parcouru pour renvoyer les lignes dans
   l'ordre représenté par une clause
   <literal>ORDER BY</literal>
   <replaceable>colonne_indexé</replaceable>
   <replaceable>opérateur</replaceable>
   <replaceable>constante</replaceable>. Cet opérateur peut renvoyer
   tout type de données triable, bien que le type de l'entrée gauche doit
   correspondre au type de données de la colonne de l'index. La
   sémantique exacte de la clause <literal>ORDER BY</literal> est
   spécifié par la colonne <structfield>amopsortfamily</structfield> qui
   doit référencer une famille d'opérateur B-tree pour le type de
   résultat de l'opérateur.
  </para>

  <note>
   <para>
    Actuellement, il est supposé que l'ordre de tri pour un opérateur de
    tri est celui par défaut de la famille d'opérateur référencée,
    c'est-à-dire <literal>ASC NULLS LAST</literal>. Ceci pourrait changer
    en ajoutant des colonnes supplémentaires pour y indiquer explicitement
    les options de tri.
   </para>
  </note>

  <para>
   Une entrée dans <structfield>amopmethod</structfield> doit correspondre
   au <structname>opfmethod</structname> de sa famille d'opérateur parent
   (l'inclusion de <structfield>amopmethod</structfield> à ce niveau est une dénormalisation
   intentionnelle de la structure du catalogue pour des raisons de performance).
   De plus, <structfield>amoplefttype</structfield> et
   <structfield>amoprighttype</structfield> doivent correspondre aux champs
   <structfield>oprleft</structfield> et <structfield>oprright</structfield>
   de l'entrée <structname>pg_operator</structname> référencée.
  </para>

 </sect1>


 <sect1 id="catalog-pg-amproc">
  <title><structname>pg_amproc</structname></title>

  <indexterm zone="catalog-pg-amproc">
   <primary>pg_amproc</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_amproc</structname> stocke les informations
   concernant les procédures de support associées aux familles d'opérateurs
   de méthodes  d'accès. Il y a une ligne pour chaque procédure de support
   appartenant à une famille.
  </para>

  <table>
   <title>Colonnes de <structname>pg_amproc</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>amprocfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>La famille d'opérateur</entry>
     </row>

     <row>
      <entry><structfield>amproclefttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de données en entrée, côté gauche, de l'opérateur associé</entry>
     </row>

     <row>
      <entry><structfield>amprocrighttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de données en entrée, côté droit, de l'opérateur associé</entry>
     </row>

     <row>
      <entry><structfield>amprocnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Numéro de procédure de support</entry>
     </row>

     <row>
      <entry><structfield>amproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID de la procédure</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   On interprète habituellement les champs
   <structfield>amproclefttype</structfield> et
   <structfield>amprocrighttype</structfield> comme identifiant les types
   de données des côtés gauche et droit d'opérateur(s) supporté(s) par une procédure
   particulière. Pour certaines méthodes d'accès, ils correspondent
   aux types de données en entrée de la procédure elle-même. Il existe une
   notion de procédures de support par <quote>défaut</quote> pour un index,
   procédures pour lesquelles <structfield>amproclefttype</structfield> et
   <structfield>amprocrighttype</structfield> sont tous deux équivalents à
   l'<structfield>opcintype</structfield> de l'opclass de l'index.
  </para>

 </sect1>


 <sect1 id="catalog-pg-attrdef">
  <title><structname>pg_attrdef</structname></title>

  <indexterm zone="catalog-pg-attrdef">
   <primary>pg_attrdef</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_attrdef</structname> stocke les valeurs par
   défaut des colonnes. Les informations principales des colonnes sont stockées
   dans <structname>pg_attribute</structname> (voir plus loin). Seules les
   colonnes pour lesquelles une valeur par défaut est explicitement indiquée
   (quand la table est créée ou quand une colonne est ajoutée) ont une entrée dans 
   <structname>pg_attrdef</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_attrdef</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>adrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>La table à laquelle appartient la colonne</entry>
     </row>

     <row>
      <entry><structfield>adnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>Numéro de la colonne</entry>
     </row>

     <row>
      <entry><structfield>adbin</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>Représentation interne de la valeur par défaut de la colonne</entry>
     </row>

     <row>
      <entry><structfield>adsrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Représentation lisible de la valeur par défaut</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Le champ <structfield>adsrc</structfield> est historique. Il est
   préférable 
   de ne pas l'utiliser parce qu'il ne conserve pas de trace des modifications qui
   peuvent affecter la représentation de la valeur par défaut. La
   compilation inverse du champ <structfield>adbin</structfield> (avec
   <function>pg_get_expr</function> par exemple) est une meilleure façon d'afficher la
   valeur par défaut.
  </para>

 </sect1>


 <sect1 id="catalog-pg-attribute">
  <title><structname>pg_attribute</structname></title>

  <indexterm zone="catalog-pg-attribute">
   <primary>pg_attribute</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_attribute</structname> stocke les informations
   concernant les colonnes des tables. Il y a exactement une ligne de 
   <structname>pg_attribute</structname> par colonne de table de
   la base de données. (Il y a aussi des attributs pour les index et, en fait,
   tous les objets qui possèdent des entrées dans <structname>pg_class</structname>.)
  </para>

  <para>
   Le terme attribut, équivalent à colonne, est utilisé pour des raisons 
   historiques.
  </para>

  <table>
   <title>Colonnes de <structname>pg_attribute</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>attrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>La table à laquelle appartient la colonne</entry>
     </row>

     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Le nom de la colonne</entry>
     </row>

     <row>
      <entry><structfield>atttypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Le type de données de la colonne</entry>
     </row>

     <row>
      <entry><structfield>attstattarget</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Contrôle le niveau de détail des
       statistiques accumulées pour la colonne par
       <xref linkend="sql-analyze"/>.
       Une valeur 0 indique qu'aucune statistique ne doit être collectée.
       Une valeur négative indique d'utiliser l'objectif de statistiques 
       par défaut.
       Le sens exact d'une valeur positive dépend du type de données.
       Pour les données scalaires, <structfield>attstattarget</structfield>
       est à la fois le nombre de <quote>valeurs les plus courantes</quote>
       à collecter et le nombre d'histogrammes à créer.
      </entry>
     </row>

     <row>
      <entry><structfield>attlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Une copie de <literal>pg_type.typlen</literal> pour le type de la
       colonne.
      </entry>
     </row>

     <row>
      <entry><structfield>attnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Le numéro de la colonne. La numérotation des colonnes ordinaires
       démarre à 1. Les colonnes système, comme les 
       <structfield>oid</structfield>, ont des numéros négatifs arbitraires.
      </entry>
     </row>

     <row>
      <entry><structfield>attndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Nombre de dimensions, si la colonne est de type tableau, sinon 0.
       (Pour l'instant, le nombre de dimensions des tableaux n'est pas contrôlé,
       donc une valeur autre que 0 indique que <quote>c'est un tableau</quote>.)
      </entry>
     </row>

     <row>
      <entry><structfield>attcacheoff</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Toujours -1 sur disque, mais peut être mis à jour lorsque la ligne
       est chargée en mémoire, pour 
       mettre en cache l'emplacement de l'attribut dans la ligne.
      </entry>
     </row>

     <row>
      <entry><structfield>atttypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Stocke des données spécifiques au type
       de données précisé lors de la création de la table (par exemple, la
       taille maximale d'une colonne de type <type>varchar</type>). Il est
       transmis aux fonctions spécifiques au type d'entrée de données et de
       vérification de taille. La valeur est généralement -1 pour les types
       de données qui n'ont pas besoin de <structfield>atttypmod</structfield>.
      </entry>
     </row>

     <row>
      <entry><structfield>attbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Une copie de <literal>pg_type.typbyval</literal> du type de la
       colonne.
      </entry>
     </row>

     <row>
      <entry><structfield>attstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Contient normalement une copie de
       <literal>pg_type.typstorage</literal> du type de la colonne.
       Pour les types de données TOASTables, cette valeur 
       peut être modifiée après la création de la colonne pour en contrôler
       les règles de stockage.
      </entry>
     </row>

     <row>
      <entry><structfield>attalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Une copie de <literal>pg_type.typalign</literal> du type de 
       la colonne.
      </entry>
     </row>

     <row>
      <entry><structfield>attnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Indique une contrainte de non-nullité de colonne. Il est possible de changer
       cette colonne pour activer ou désactiver cette contrainte. 
       </entry>
     </row>

     <row>
      <entry><structfield>atthasdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Indique que la colonne a une valeur par défaut. Dans ce cas, il y 
       a une entrée correspondante dans le catalogue 
       <structname>pg_attrdef</structname> pour définir cette valeur.
      </entry>
     </row>

     <row>
      <entry><structfield>attisdropped</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Indique que la colonne a été supprimée et n'est plus valide. Une 
       colonne supprimée est toujours présente physiquement dans la table,
       mais elle est ignorée par l'analyseur de requête et ne peut être
       accédée en SQL.
      </entry>
     </row>

     <row>
      <entry><structfield>attislocal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       La colonne est définie localement dans la relation. Une
       colonne peut être simultanément définie localement et héritée.
      </entry>
     </row>

     <row>
      <entry><structfield>attinhcount</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Nombre d'ancêtres directs de la colonne. Une colonne qui a au moins un
       ancêtre ne peut être ni supprimée ni renommée.
      </entry>
     </row>

     <row>
      <entry><structfield>attcollation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry>
       Le collationnement défini de la colonne, ou zéro si la colonne
       n'est pas un type de données collationnable.
      </entry>
     </row>

     <row>
      <entry><structfield>attacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Droits d'accès niveau colonne, s'il y en a qui ont été spécifiquement
       accordés à cette colonne
      </entry>
     </row>

     <row>
      <entry><structfield>attoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Options au niveau colonne, en tant que chaînes du type
       <quote>motclé=valeur</quote>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
	Dans l'entrée <structname>pg_attribute</structname> d'une colonne
	supprimée, <structfield>atttypid</structfield> est réinitialisée à
	0 mais <structfield>attlen</structfield> et les autres champs copiés à
	partir de <structname>pg_type</structname> sont toujours valides. Cet arrangement est
	nécessaire pour s'adapter à la situation où le type de données de la
	colonne supprimée a été ensuite supprimé et qu'il n'existe donc plus de
	ligne <structname>pg_type</structname>. <structfield>attlen</structfield> et les
	autres champs peuvent être utilisés pour interpréter le contenu
	d'une ligne de la table.
  </para>
 </sect1>


 <sect1 id="catalog-pg-authid">
  <title><structname>pg_authid</structname></title>

  <indexterm zone="catalog-pg-authid">
   <primary>pg_authid</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_authid</structname> contient les informations
   concernant les identifiants pour les autorisations d'accès aux bases de données
   (rôles). Un rôle englobe les concepts d'<quote>utilisateur</quote> et de
   <quote>groupe</quote>. Un utilisateur est essentiellement un rôle qui a
   l'attribut de connexion (<structfield>rolcanlogin</structfield>). Tout rôle (avec ou
   sans <structfield>rolcanlogin</structfield>) peut avoir d'autres rôles comme
   membres&nbsp;; voir
   <link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link>.
  </para>

  <para>
   Comme ce catalogue contient les mots de passe, il ne doit pas être lisible par
   tout le monde.
   <link linkend="view-pg-roles"><structname>pg_roles</structname></link>
   est une vue, lisible par tout le monde, de 
   <structname>pg_authid</structname> qui masque le champ du mot de passe.
  </para>

  <para>
   <xref linkend="user-manag"/> contient des informations détaillées sur les
   utilisateurs et sur la gestion des droits.
  </para>

  <para>
   Comme l'identité des utilisateurs est identique pour tout le cluster de bases
   de données, <structname>pg_authid</structname> est partagé par toutes les
   bases du cluster&nbsp;; il n'existe qu'une seule copie de
   <structname>pg_authid</structname> par cluster, non une par base de
   données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_authid</structname></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rolname</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Nom du rôle</entry>
     </row>

     <row>
      <entry><structfield>rolsuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Le rôle est superutilisateur</entry>
     </row>

     <row>
      <entry><structfield>rolinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Le rôle hérite automatiquement des droits des rôles dont il est
       membre</entry>
     </row>

     <row>
      <entry><structfield>rolcreaterole</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Le rôle peut créer d'autres rôles</entry>
     </row>

     <row>
      <entry><structfield>rolcreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Le rôle peut créer des bases de données</entry>
     </row>

     <row>
      <entry><structfield>rolcatupdate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       Le rôle peut mettre à jour les catalogues système directement. (Même
       un superutilisateur ne peut le faire si cette colonne n'est pas à
       <literal>true</literal>.)
      </entry>
     </row>

     <row>
      <entry><structfield>rolcanlogin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       Le rôle peut se connecter, c'est-à-dire qu'il peut être donné
       comme identifiant d'autorisation de session.
      </entry>
     </row>

     <row>
      <entry><structfield>rolreplication</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       Le rôle est un rôle de réplication, c'est-à-dire qu'il peut
       initier une réplication en flux (voir <xref
       linkend="streaming-replication"/>) et lancer/arrêter le mode de
       sauvegarde système grâce aux fonctions
       <function>pg_start_backup</function> et
       <function>pg_stop_backup</function>.
      </entry>
     </row>

     <row>
      <entry><structfield>rolconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry>
       Pour les rôles qui peuvent se connecter, indique le nombre maximum
       de connexions concurrentes que le rôle peut initier. -1 signifie qu'il
       n'y a pas de limite.
      </entry>
     </row>

     <row>
      <entry><structfield>rolpassword</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Le mot de passe (éventuellement chiffré)&nbsp;; NULL si aucun.
       Si le mot de passe est chiffré, cette colonne commence par la chaîne
       <literal>md5</literal>
       suivi par un hachage md5 hexadécimal sur 32 caractères. Le hachage
       md5 correspondra au mot de passe de l'utilisateur concaténé à son nom.
       Par exemple si l'utilisateur <literal>joe</literal> a le mot de passe <literal>xyzzy</literal>,
       <productname>PostgreSQL</productname> enregistrera le hachage md5
       du mot <literal>xyzzyjoe</literal>). Un mot de passe qui ne suit
       pas ce format est supposé non chiffré.</entry>
     </row>

     <row>
      <entry><structfield>rolvaliduntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>Date d'expiration du mot de passe (utilisée uniquement pour
       l'authentification par mot de passe)&nbsp;; NULL si indéfiniment
       valable
       </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-auth-members">
  <title><structname>pg_auth_members</structname></title>

  <indexterm zone="catalog-pg-auth-members">
   <primary>pg_auth_members</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_auth_members</structname> contient les relations
   d'appartenance entre les rôles. Tout ensemble non circulaire d'appartenances est
   autorisé.
  </para>

  <para>
   Parce que les identités de l'utilisateur sont valables sur l'ensemble du
   cluster, <structname>pg_auth_members</structname> est partagé par toutes les bases
   de données d'un cluster&nbsp;: il n'existe qu'une seule copie de
   <structname>pg_auth_members</structname> par cluster, pas une par base de
   données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_auth_members</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>roleid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Identifiant d'un rôle qui a un membre</entry>
     </row>

     <row>
      <entry><structfield>member</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Identifiant d'un rôle qui est membre d'un
        <structfield>roleid</structfield></entry>
     </row>

     <row>
      <entry><structfield>grantor</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Identifiant du rôle qui a autorisé cette appartenance</entry>
     </row>

     <row>
      <entry><structfield>admin_option</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si <structfield>member</structfield> peut donner
      l'appartenance à <structfield>roleid</structfield> aux autres</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-cast">
  <title><structname>pg_cast</structname></title>

  <indexterm zone="catalog-pg-cast">
   <primary>pg_cast</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_cast</structname> stocke les chemins de 
   conversion de type de donnée, qu'il s'agisse de ceux par défaut ou ceux 
   définis avec la commande <xref linkend="sql-createcast"/>.
  </para>

  <para>
   <structname>pg_cast</structname> ne représente pas toutes les conversions de
   type que le système connaît, seulement celles qui ne peuvent pas se déduire
   à partir de règles génériques. Par exemple, la conversion entre un domaine
   et son type de base n'est pas représentée explicitement dans
   <structname>pg_cast</structname>.  Autre exception importante&nbsp;:
   <quote>les conversions automatiques d'entrée/sortie</quote>, celles réalisées en
   utilisant les propres fonctions d'entrée/sortie du type de données pour
   convertir vers ou à partir du <type>text</type> ou des autres types de
   chaînes de caractères, ne sont pas représentées explicitement dans
   <structname>pg_cast</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_cast</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>castsource</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID du type de données source</entry>
     </row>

     <row>
      <entry><structfield>casttarget</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID du type de données cible</entry>
     </row>

     <row>
      <entry><structfield>castfunc</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       OID de la fonction à utiliser pour réaliser la conversion. 0 si la méthode
       ne requiert pas une fonction.
      </entry>
     </row>

     <row>
      <entry><structfield>castcontext</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Indique dans quel contexte la conversion peut être utilisée.
       <literal>e</literal> si seules les conversions explicites sont autorisées (avec
       <literal>CAST</literal> ou <literal>::</literal>).
       <literal>a</literal> si les conversions implicites lors de l'affectation à une
       colonne sont autorisées, en plus des conversions explicites.
       <literal>i</literal> si les conversions implicites dans les expressions sont 
       autorisées en plus des autres cas.
      </entry>
     </row>
     
     <row>
      <entry><structfield>castmethod</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Indique comment la conversion est effectuée.
       <literal>f</literal> signifie que la fonction indiquée dans le champ
       <structfield>castfunc</structfield> est utilisée.
       <literal>i</literal> signifie que les fonctions d'entrée/sortie sont utilisées.
       <literal>b</literal> signifie que les types sont binairement coercibles, et
       que par conséquent aucune conversion n'est nécessaire.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
    Les fonctions de transtypage listées dans <structname>pg_cast</structname>
    doivent toujours prendre le type source de la conversion comme type du
    premier argument et renvoyer le type de destination de la conversion comme
    type de retour. Une fonction de conversion peut avoir jusqu'à trois
    arguments. Le deuxième argument, s'il est présent, doit être de type
    <type>integer</type>&nbsp;; il reçoit le modificateur de type associé avec le
    type de destination ou 1 s'il n'y en a pas. Le troisième
    argument, s'il est présent, doit être de type <type>boolean</type>&nbsp;; il
    reçoit <literal>true</literal> si la conversion est une conversion explicite,
    <literal>false</literal> sinon.
  </para>

<!-- C'est lourd et assez indigeste. Surtout un vendredi soir ! -->
<!-- A la relecture, on n'est que jeudi, mais, euh, c'est toujours aussi
lourd ! -->
<!-- coercion ? -->
  <para>
    Il est possible de créer une entrée <structname>pg_cast</structname>
    dans laquelle les types source et cible sont identiques si la fonction associée
    prend plus d'un argument. De telles entrées représentent les
    <quote>fonctions de forçage de longueur</quote> qui forcent la validité des valeurs de
    ce type pour une valeur particulière du modificateur de type.
  </para>
<!-- Je me demande si c'est vraiment moins lourd ainsi -->

  <para>
    Quand une entrée <structname>pg_cast</structname> possède des types différents
    pour la source et la cible et une fonction qui prend plus d'un
    argument, le transtypage et le forçage de longueur s'effectuent en une
    seule étape. Lorsqu'une telle entrée n'est pas disponible, le forçage
    vers un type qui utilise un modificateur de type implique deux étapes,
    une de transtypage, l'autre pour appliquer le modificateur.
  </para>
 </sect1>

 <sect1 id="catalog-pg-class">
  <title><structname>pg_class</structname></title>

  <indexterm zone="catalog-pg-class">
   <primary>pg_class</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_class</structname> liste les tables, et 
   à peu près tout ce qui contient des colonnes ou ressemble de près ou de loin à
   une table. Cela inclut les index (mais il faut aussi aller voir dans
   <structname>pg_index</structname>), les séquences, les vues, les types
   composites et les tables TOAST&nbsp;; voir
   <structfield>relkind</structfield>.
   Par la suite, lorsque l'on parle de <quote>relation</quote>, on
   sous-entend tous ces types d'objets. Les colonnes ne sont pas toutes
   significatives pour tous les types de relations.
  </para>

<!-- namespace ? (doit-il être traduit ?) -->
<!-- Le 14/03/2007, je déclare que non -->
  <table>
   <title>Colonnes de <structname>pg_class</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>relname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la table, vue, index, etc.</entry>
     </row>

     <row>
      <entry><structfield>relnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       OID du <foreignphrase>namespace</foreignphrase> qui contient la relation.
      </entry>
     </row>

     <row>
      <entry><structfield>reltype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       OID du type de données qui correspond au type de ligne de la table,
       s'il y en a un.
       0 pour les index qui n'ont pas d'entrée dans <structname>pg_type</structname>.
      </entry>
     </row>

     <row>
      <entry><structfield>reloftype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       Pour les tables typées, l'OID du type composite sous-jacent. Sinon, 0
       dans tous les autres cas.
      </entry>
     </row>

     <row>
      <entry><structfield>relowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire de la relation.</entry>
     </row>

     <row>
      <entry><structfield>relam</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>S'il s'agit d'un index, OID de la méthode d'accès utilisée (B-tree,
       hash, etc.)</entry>
     </row>

     <row>
      <entry><structfield>relfilenode</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Nom du fichier disque de la relation&nbsp;; zéro signifie que
       c'est une relation <quote>mapped</quote> dont le nom de fichier est
       déterminé par un statut de bas niveau.</entry>
     </row>

     <row>
      <entry><structfield>reltablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>
       Le <foreignphrase>tablespace</foreignphrase> dans lequel est stocké
       la relation. Si 0, il s'agit du
       <foreignphrase>tablespace</foreignphrase> par défaut de la base de
       données. (Sans intérêt si la relation n'est pas liée à un fichier disque.)
     </entry>
     </row>

     <row>
      <entry><structfield>relpages</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Taille du fichier disque, exprimée en pages (de taille 
       <symbol>BLCKSZ</symbol>).
       Ce n'est qu'une estimation utilisée par le planificateur. Elle est mise à 
       jour par les commandes <command>VACUUM</command>,
       <command>ANALYZE</command> et quelques commandes DDL comme <command>CREATE
       INDEX</command>.
      </entry>
     </row>

     <row>
      <entry><structfield>reltuples</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>
       Nombre de lignes de la table.
       Ce n'est qu'une estimation utilisée par le planificateur. Elle est mise à 
       jour par les commandes <command>VACUUM</command>,
       <command>ANALYZE</command> et quelques commandes DDL comme
       <command>CREATE INDEX</command>.
      </entry>
     </row>

     <row>
      <entry><structfield>reltoastrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       OID de la table TOAST associée à cette table. 0 s'il n'y en a pas.
       La table TOAST stocke les attributs de grande taille <quote>hors 
       ligne</quote> dans une table secondaire.
      </entry>
     </row>

     <row>
      <entry><structfield>reltoastidxid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       Pour une table TOAST, OID de son index. 0 si ce n'est pas une table
       TOAST.
      </entry>
     </row>

     <row>
      <entry><structfield>relhasindex</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai si c'est une table et qu'elle possède (ou possédait encore
       récemment) quelque index.
      </entry>
     </row>

     <row>
      <entry><structfield>relisshared</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si cette table est partagée par toutes les bases de données
      du cluster. Seuls certains catalogues système (comme
      <structname>pg_database</structname>) sont partagés.</entry>
     </row>

     <row>
      <entry><structfield>relpersistence</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>p</literal> = table permanente, <literal>u</literal> =
       table non tracée dans les journaux de transactions,
       <literal>t</literal> = table temporaire
      </entry>
     </row>

     <row>
      <entry><structfield>relkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>r</literal> = table ordinaire, <literal>i</literal> = index,
       <literal>S</literal> = séquence, <literal>v</literal> = vue, <literal>c</literal> =
       type composite, <literal>t</literal> = table TOAST,
       <literal>f</literal> = table distante.
      </entry>
     </row>

     <row>
      <entry><structfield>relnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Nombre de colonnes utilisateur dans la relation (sans compter les
       colonnes système). Il doit y avoir le même nombre d'entrées dans
       <structname>pg_attribute</structname>. Voir aussi
       <literal>pg_attribute.attnum</literal>.
      </entry>
     </row>

     <row>
      <entry><structfield>relchecks</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Nombre de contraintes de vérification (<literal>CHECK</literal>) sur la table&nbsp;; voir le
       catalogue <link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link>.
      </entry>
     </row>

     <row>
      <entry><structfield>relhasoids</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai si un OID est engendré pour chaque ligne de la relation.
      </entry>
     </row>

     <row>
      <entry><structfield>relhaspkey</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai si la table a (ou a eu) une clé primaire.
      </entry>
     </row>

     <row>
      <entry><structfield>relhasrules</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si la table contient (ou a contenu) des règles&nbsp;; voir le catalogue
       <link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link>.
      </entry>
     </row>

     <row>
      <entry><structfield>relhastriggers</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai si la table a (ou a eu) des triggers&nbsp;; voir le catalogue
       <link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link>
      </entry>
     </row>

     <row>
      <entry><structfield>relhassubclass</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si au moins une table hérite ou a hérité de la table
      considérée.</entry>
     </row>

     <row>
      <entry><structfield>relfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       Tous les ID de transaction avant celui-ci ont été remplacés par un ID de
       transaction permanent (<quote>frozen</quote>). Ceci est utilisé pour
       déterminer si la table doit être nettoyée (VACUUM) pour éviter un
       bouclage des ID de transaction 
       (<foreignphrase>ID wraparound</foreignphrase>) ou pour compacter
       <literal>pg_clog</literal>.
       0 (<symbol>InvalidTransactionId</symbol>) si la relation n'est pas
       une table.
      </entry>
     </row>

     <row>
      <entry><structfield>relacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Droits d'accès&nbsp;; voir <xref linkend="sql-grant"/> et <xref
       linkend="sql-revoke"/> pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structfield>reloptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Options spécifiques de la méthode d'accès, représentées par des chaînes du type
       <quote>motclé=valeur</quote>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Plusieurs des drapeaux booléens dans <structname>pg_class</structname> sont
   maintenus faiblement&nbsp;: la valeur true est garantie s'il s'agit du bon
   état, mais elle pourrait ne pas être remise à false immédiatement quand la
   condition n'est plus vraie. Par exemple,
   <structfield>relhasindex</structfield> est configurée par
   <command>CREATE INDEX</command> mais n'est jamais remise à false par
   <command>DROP INDEX</command>. C'est <command>VACUUM</command> qui le fera
   <structfield>relhasindex</structfield> s'il découvre que la table n'a pas
   d'index. Cet arrangement évite des fenêtres de vulnérabilité et améliore
   la concurrence.
  </para>
 </sect1>

 <sect1 id="catalog-pg-constraint">
  <title><structname>pg_constraint</structname></title>

  <indexterm zone="catalog-pg-constraint">
   <primary>pg_constraint</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_constraint</structname> stocke les vérifications,
   clés primaires, clés uniques, étrangères et d'exclusion des tables. (Les
   contraintes de
   colonnes ne sont pas traitées de manière particulière. Elles sont 
   équivalentes à des contraintes de tables.) Les contraintes NOT NULL sont
   représentées dans le catalogue <structname>pg_attribute</structname>, pas ici.
  </para>

  <para>
   Les triggers de contraintes définies par des utilisateurs (créés avec
   <command>CREATE CONSTRAINT TRIGGER</command>) ont aussi une entrée dans
   cette table.
  </para>

  <para>
   Les contraintes de vérification de domaine sont également stockées dans
   ce catalogue.
  </para>

  <table>
   <title>Colonnes de <structname>pg_constraint</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la contrainte (pas nécessairement unique&nbsp;!)</entry>
     </row>

     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       OID du <foreignphrase>namespace</foreignphrase> qui contient la contrainte.
      </entry>
     </row>

     <row>
      <entry><structfield>contype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
        <literal>c</literal> = contrainte de vérification,
        <literal>f</literal> = contrainte de clé étrangère,
        <literal>p</literal> = contrainte de clé primaire,
        <literal>u</literal> = contrainte d'unicité,
        <literal>t</literal> = contrainte trigger,
        <literal>x</literal> = contrainte d'exclusion
      </entry>
     </row>

     <row>
      <entry><structfield>condeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La contrainte peut-elle être retardée
      (<foreignphrase>deferable</foreignphrase>)&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>condeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La contrainte est-elle retardée par défaut&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>convalidated</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La contrainte a-t-elle été validée&nbsp;? actuellement,
       peut seulement valoir false pour les clés étrangères</entry>
     </row>

     <row>
      <entry><structfield>conrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Table à laquelle appartient la contrainte&nbsp;; 0 si ce n'est pas
       une contrainte de table.
      </entry>
     </row>

     <row>
      <entry><structfield>contypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Domaine auquel appartient la contrainte&nbsp;; 0 si ce n'est pas
       une contrainte de domaine.
      </entry>
     </row>

     <row>
      <entry><structfield>conindid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>L'index qui force cette contrainte (unique, clé primaire, clé
       étrangère, d'exclusion)&nbsp;; sinon 0</entry>
     </row>

     <row>
      <entry><structfield>confrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Si c'est une clé étrangère, la table référencée&nbsp;; sinon
       0</entry>
     </row>

     <row>
      <entry><structfield>confupdtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Code de l'action de mise à jour de la clé étrangère&nbsp;:
            <literal>a</literal> = no action,
            <literal>r</literal> = restrict,
            <literal>c</literal> = cascade,
            <literal>n</literal> = set null,
            <literal>d</literal> = set default
          </entry>
     </row>

     <row>
      <entry><structfield>confdeltype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Code de l'action de suppression de clé étrangère&nbsp;:
            <literal>a</literal> = no action,
            <literal>r</literal> = restrict,
            <literal>c</literal> = cascade,
            <literal>n</literal> = set null,
            <literal>d</literal> = set default
          </entry>
     </row>

     <row>
      <entry><structfield>confmatchtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Type de concordance de la clé étrangère&nbsp;:
            <literal>f</literal> = full,
            <literal>p</literal> = partial,
            <literal>u</literal> = simple (non spécifié)
          </entry>
     </row>

     <row>
      <entry><structfield>conislocal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Cette contrainte est définie localement dans la relation. Notez qu'une
       contrainte peut être définie localement et héritée simultanément
      </entry>
     </row>

     <row>
      <entry><structfield>coninhcount</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Le nombre d'ancêtres d'héritage directs que cette contraite possède. Une contrainte
       avec un nombre non nul d'ancêtres ne peut être ni supprimée ni renommée.
      </entry>
     </row>

     <row>
      <entry><structfield>conkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>S'il s'agit d'une contrainte de table (incluant les clés
       étrangères mais pas les triggers de contraintes),
       liste des colonnes contraintes</entry>
     </row>

     <row>
      <entry><structfield>confkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>S'il s'agit d'une clé étrangère, liste des colonnes référencées</entry>
     </row>

     <row>
      <entry><structfield>conpfeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>S'il s'agit d'une clé étrangère, liste des opérateurs d'égalité pour les
       comparaisons clé primaire/clé étrangère</entry>
     </row>

     <row>
      <entry><structfield>conppeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>S'il s'agit d'une clé étrangère, liste des opérateurs d'égalité pour les
       comparaisons clé primaire/clé primaire</entry>
     </row>

     <row>
      <entry><structfield>conffeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>S'il s'agit d'une clé étrangère, liste des opérateurs d'égalité pour les
       comparaisons clé étrangère/clé étrangère</entry>
     </row>

     <row>
      <entry><structfield>conexclop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Si une contrainte d'exclusion, liste les opérateurs d'exclusion
       par colonne</entry>
     </row>

     <row>
      <entry><structfield>conbin</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>S'il s'agit d'une contrainte de vérification, représentation
       interne de l'expression</entry>
     </row>

     <row>
      <entry><structfield>consrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>S'il s'agit d'une contrainte de vérification, représentation
       compréhensible de l'expression</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Dans le cas d'une contrainte d'exclusion, <structfield>conkey</structfield>
   est seulement utile pour les éléments contraints qui sont de simples
   références de colonnes. Dans les autres cas, un zéro apparaît dans
   <structfield>conkey</structfield> et l'index associé doit être consulté
   pour découvrir l'expression contrainte. (du coup,
   <structfield>conkey</structfield> a le même contenu que
   <structname>pg_index</structname>.<structfield>indkey</structfield> pour
   l'index.)
  </para>

  <note>
   <para>
    <structfield>consrc</structfield> n'est pas actualisé lors de la modification
    d'objets référencés&nbsp;; par exemple, il ne piste pas les renommages de
    colonnes. Plutôt que se fier à ce champ, il est préférable d'utiliser
    <function>pg_get_constraintdef()</function> pour extraire la définition d'une
    contrainte de vérification.
   </para>
  </note>

  <note>
   <para>
    <literal>pg_class.relchecks</literal> doit accepter le même nombre de 
    contraintes de vérification pour chaque relation.
   </para>
  </note>

 </sect1>

 <sect1 id="catalog-pg-collation">
  <title><structname>pg_collation</structname></title>

  <indexterm zone="catalog-pg-collation">
   <primary>pg_collation</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_collation</structname> décrit les
   collationnements disponibles, qui sont essentiellement des
   correspondances entre un nom SQL et des catégories de locales du
   système d'exploitation. Voir <xref linkend="collation"/> pour plus
   d'informations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_collation</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>collname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du collationnement (unique par schéma et encodage)</entry>
     </row>

     <row>
      <entry><structfield>collnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       L'OID du schéma contenant ce collationnement
      </entry>
     </row>

     <row>
      <entry><structfield>collowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire du collationnement</entry>
     </row>

     <row>
      <entry><structfield>collencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Encodage pour lequel le collationnement est disponible. -1
       s'il fonctionne pour tous les encodages</entry>
     </row>

     <row>
      <entry><structfield>collcollate</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry><symbol>LC_COLLATE</symbol> pour ce collationnement</entry>
     </row>

     <row>
      <entry><structfield>collctype</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry><symbol>LC_CTYPE</symbol> pour ce collationnement</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Notez que la clé unique de ce catalogue est (<structfield>collname</structfield>,
   <structfield>collencoding</structfield>, <structfield>collnamespace</structfield>)
   et non pas seulement
   (<structfield>collname</structfield>, <structfield>collnamespace</structfield>).
   <productname>PostgreSQL</productname> ignore habituellement tous les
   collationnement qui n'ont pas de colonne
   <structfield>collencoding</structfield> égale soit à l'encodage de
   la base de données en cours ou -1. La création de nouvelles entrées
   de même nom qu'une autre entrée dont
   <structfield>collencoding</structfield> vaut -1 est interdite. Du
   coup, il suffit d'utiliser un nom SQL qualifié du schéma 
   (<replaceable>schéma</replaceable>.<replaceable>nom</replaceable>)
   pour identifier un collationnement bien que cela ne soit pas unique
   d'après la définition du catalogue. Ce catalogue a été défini ainsi
   car <application>initdb</application> le remplit au moment de
   l'initialisation de l'instance avec les entrées pour toutes les locales
   disponibles sur le système, donc il doit être capable de contenir les
   entrées de tous les encodages qui pourraient être utilisés dans
   l'instance.
  </para>

  <para>
   Dans la base de données <literal>template0</literal>, il pourrait
   être utile de créer les collationnement dont l'encodage ne correspond
   pas à l'encodage de la base ded onnées car ils pourraient correspondre
   aux encodages de bases de données créées par la suite à partir de ce
   modèle de base de données. Cela doit être fait manuellement
   actuellement.
  </para>
 </sect1>

 <sect1 id="catalog-pg-conversion">
  <title><structname>pg_conversion</structname></title>

  <indexterm zone="catalog-pg-conversion">
   <primary>pg_conversion</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_conversion</structname> décrit les procédures
   de conversion de codage. Voir la commande
   <xref linkend="sql-createconversion"/> pour plus d'informations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_conversion</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la conversion (unique au sein d'un
      <foreignphrase>namespace</foreignphrase>)</entry>
     </row>

     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       OID du <foreignphrase>namespace</foreignphrase> qui contient la conversion.
      </entry>
     </row>

     <row>
      <entry><structfield>conowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid">
      <structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire de la conversion</entry>
     </row>

     <row>
      <entry><structfield>conforencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>ID du codage source</entry>
     </row>

     <row>
      <entry><structfield>contoencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>ID du codage de destination</entry>
     </row>

     <row>
      <entry><structfield>conproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"> <structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Procédure de conversion</entry>
     </row>

     <row>
      <entry><structfield>condefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai s'il s'agit de la conversion par défaut</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-database">
  <title><structname>pg_database</structname></title>

  <indexterm zone="catalog-pg-database">
   <primary>pg_database</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_database</structname> stocke les informations
   concernant
   les bases de données disponibles. Celles-ci sont créées avec la
   commande <xref linkend="sql-createdatabase"/>. Consulter le
   <xref linkend="managing-databases"/> pour les détails sur la signification de
   certains paramètres.
  </para>

  <para>
   Contrairement à la plupart des catalogues système,
   <structname>pg_database</structname> est partagé par toutes les bases de
   données d'un cluster&nbsp;: il n'y a qu'une seule copie de
   <structname>pg_database</structname> par cluster, pas une par base.
  </para>

  <table>
   <title>Colonnes de <structname>pg_database</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>datname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la base de données</entry>
     </row>

     <row>
      <entry><structfield>datdba</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid">
      <structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire de la base, généralement l'utilisateur qui l'a
       créée</entry>
     </row>

     <row>
      <entry><structfield>encoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Encodage de la base de données (la fonction
       <function>pg_encoding_to_char()</function> peut convertir ce nombre en
       nom de l'encodage)</entry>
     </row>

     <row>
      <entry><structfield>datcollate</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>LC_COLLATE pour cette base de données</entry>
     </row>

     <row>
      <entry><structfield>datctype</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>LC_CTYPE pour cette base de données</entry>
     </row>

     <row>
      <entry><structfield>datistemplate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Si ce champ est vrai, alors la base peut être utilisée dans la clause
       <literal>TEMPLATE</literal> de la commande
       <command>CREATE DATABASE</command> pour créer une nouvelle base comme clone de 
       celle-ci.
      </entry>
     </row>

     <row>
      <entry><structfield>datallowconn</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Si ce champ est faux, alors personne ne peut se connecter à cette
       base de données. Ceci est utilisé pour interdire toute modification de la base 
       <literal>template0</literal>.
      </entry>
     </row>

     <row>
      <entry><structfield>datconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Nombre maximum de connexions concurrentes autorisées sur
       la base de données. -1 indique l'absence de limite.
      </entry>
     </row>

     <row>
      <entry><structfield>datlastsysoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>
       Dernier OID système de la base de données&nbsp;; utile en particulier
       pour <application>pg_dump</application>.
      </entry>
     </row>

     <row>
      <entry><structfield>datfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       Tous les ID de transaction avant celui-ci ont été remplacés par un ID
       de transaction permanent (<quote>frozen</quote>). Ceci est
       utilisé pour déterminer si la table doit être nettoyée (VACUUM) pour
       éviter un bouclage des ID de transaction 
       (<foreignphrase>ID wraparound</foreignphrase>) ou pour compacter
       <literal>pg_clog</literal>.
       C'est la valeur minimale des valeurs par table de  
       <structname>pg_class</structname>.<structfield>relfrozenxid</structfield>.
      </entry>
     </row>

     <row>
      <entry><structfield>dattablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>
       Le <foreignphrase>tablespace</foreignphrase> par défaut de la base de données.
       Dans cette base de données, toutes les tables pour lesquelles
       <structname>pg_class</structname>.<structfield>reltablespace</structfield>
       vaut 0 sont stockées dans celui-ci&nbsp;; en particulier, tous les catalogues
       système non partagés s'y trouvent.
      </entry>
     </row>

     <row>
      <entry><structfield>datacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Droits d'accès&nbsp;; voir <xref linkend="sql-grant"/> et <xref
        linkend="sql-revoke"/> pour les détails.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-db-role-setting">
  <title><structname>pg_db_role_setting</structname></title>

  <indexterm zone="catalog-pg-db-role-setting">
   <primary>pg_db_role_setting</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_db_role_setting</structname> enregistre les
   valeurs par défaut qui ont été configurées pour les variables de
   configuration, pour chaque combinaison de rôle et de base.
  </para>

  <para>
   Contrairement à la plupart des catalogues systèmes,
   <structname>pg_db_role_setting</structname> est partagé parmi toutes lees
   bases de données de l'instance&nbsp;: il n'existe qu'une copie de
   <structname>pg_db_role_setting</structname> par instance, pas une par base
   de données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_db_role_setting</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>setdatabase</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>L'OID de la base de données pour laquelle la configuration est
       applicable&nbsp;; zéro si cette configuration n'est pas spécifique à
       une base de données</entry>
     </row>

     <row>
      <entry><structfield>setrole</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>L'OID du rôle pour laquelle la configuration est applicable&nbsp;;
       zéro si cette configuration n'est pas spécifique à un rôle</entry>
     </row>

     <row>
      <entry><structfield>setconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Valeurs par défaut pour les variables de configuration</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-default-acl">
  <title><structname>pg_default_acl</structname></title>

  <indexterm zone="catalog-pg-default-acl">
   <primary>pg_default_acl</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_default_acl</structname> enregistre les droits
   initiaux à affecter aux nouveaux objets créés.
  </para>

  <table>
   <title>Colonnes de <structname>pg_default_acl</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>defaclrole</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>OID du rôle associé à cette entrée</entry>
     </row>

     <row>
      <entry><structfield>defaclnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>OID du schéma associé à cette entrée, 0 si aucun</entry>
     </row>

     <row>
      <entry><structfield>defaclobjtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Type de l'objet pour cette entrée&nbsp;:
       <literal>r</literal> = relation (table, vue),
       <literal>S</literal> = séquence,
       <literal>f</literal> = fonction
      </entry>
     </row>

     <row>
      <entry><structfield>defaclacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Droits d'accès qu'auront les nouveaux objets de ce type
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Une entrée <structname>pg_default_acl</structname> affiche les droits
   initiaux affectés à un objet appartenant à l'utilisateur indiqué. Il existe
   actuellement deux types d'entrées&nbsp;: des entrées <quote>globales</quote>
   avec <structfield>defaclnamespace</structfield> = 0, et des entrées
   <quote>par schéma</quote> qui référencent un schéma. Si une entrée globale
   est présente, alors elle <emphasis>surcharge</emphasis> les droits par
   défaut codés en dur pour le type de l'objet. Une entrée par schéma, si
   présente, représente les droits à <emphasis>ajouter</emphasis> aux droits
   par défaut globaux ou aux droits codés en dur.
  </para>

  <para>
   Notez que quand une entrée de droits (ACL) dans un autre catalogue est NULL,
   cela veut dire que les droits par défaut codés en dur sont utilisés pour
   cet objet, et <emphasis>non pas</emphasis> ce qui pourrait être dans
   <structname>pg_default_acl</structname> à ce moment.
   <structname>pg_default_acl</structname> est seulement consulté durant la
   création de l'objet.
  </para>

 </sect1>

 <sect1 id="catalog-pg-depend">
  <title><structname>pg_depend</structname></title>

  <indexterm zone="catalog-pg-depend">
   <primary>pg_depend</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_depend</structname> enregistre les relations de
   dépendances entre les objets de la base de données. Cette information permet
   à la commande <command>DROP</command> de trouver les objets qui doivent être
   supprimés conjointement par la commande <command>DROP CASCADE</command>
   ou au contraire empêchent la suppression dans le cas de
   <command>DROP RESTRICT</command>.
  </para>

  <para>
   Voir aussi <link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link>,
   qui remplit la même fonction pour les dépendances impliquant des
   objets partagés sur tout le cluster.
  </para>

  <table>
   <title>Colonnes de <structname>pg_depend</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID du catalogue système dans lequel l'objet dépendant se
       trouve.</entry>
     </row>

     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>OID de l'objet dépendant</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour une colonne de table, ce champ indique le numéro de colonne (les
       champs <structfield>objid</structfield> et
       <structfield>classid</structfield> font référence à 
       la table elle-même). Pour tous les autres types d'objets, cette colonne
       est à 0.
      </entry>
     </row>

     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID du catalogue système dans lequel l'objet référencé se trouve.
      </entry>
     </row>

     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>OID de l'objet référencé</entry>
     </row>

     <row>
      <entry><structfield>refobjsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour une colonne de table, ce champ indique le numéro de colonne (les
       champs <structfield>refobjid</structfield> et
       <structfield>refclassid</structfield> font référence
       à la table elle même). Pour tous les autres types d'objets, cette colonne
       est à 0.
      </entry>
     </row>

     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Code définissant la sémantique particulière de la relation de dépendance. Voir le 
       texte.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Dans tous les cas, une entrée de <structname>pg_depend</structname> indique
   que l'objet de référence ne peut pas être supprimé sans supprimer aussi l'objet
   dépendant. Néanmoins, il y a des nuances, identifiées par
   <structfield>deptype</structfield>&nbsp;:

   <variablelist>
    <varlistentry>
     <term><symbol>DEPENDENCY_NORMAL</symbol> (<literal>n</literal>)</term>
     <listitem>
      <para>
       Une relation normale entre des objets créés séparément. L'objet dépendant
       peut être supprimé sans affecter l'objet référencé. Ce dernier ne
       peut être supprimé qu'en précisant l'option <literal>CASCADE</literal>,
       auquel cas l'objet dépendant est supprimé lui-aussi. Exemple&nbsp;: une
       colonne de table a une dépendance normale avec ses types de données. 
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_AUTO</symbol> (<literal>a</literal>)</term>
     <listitem>
      <para>
       L'objet dépendant peut être supprimé séparément de l'objet référencé,
       mais il l'est automatiquement avec la suppression de ce dernier,
       quel que soit le mode <literal>RESTRICT</literal> ou <literal>CASCADE</literal>.
       Exemple&nbsp;: une contrainte nommée sur une table est auto-dépendante
       de la table, elle est automatiquement supprimée avec celle-ci.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_INTERNAL</symbol> (<literal>i</literal>)</term>
     <listitem>
      <para>
       L'objet dépendant est créé conjointement à l'objet référencé et 
       fait partie intégrante de son implantation interne. Un
       <command>DROP</command> de l'objet dépendant est interdit
       (l'utilisateur est averti qu'il peut effectuer un
       <command>DROP</command> de l'objet référencé à la place). La suppression
       de l'objet référencé est propagée à l'objet dépendant que
       <command>CASCADE</command> soit précisé ou non.
       Exemple&nbsp;: un trigger créé pour vérifier une contrainte de
       clé étrangère est rendu dépendant de l'entrée de la contrainte dans
       <structname>pg_constraint</structname>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_EXTENSION</symbol> (<literal>e</literal>)</term>
     <listitem>
      <para>
       L'objet dépendant est un membre de l'<firstterm>extension</firstterm>
       qui est l'objet référencé (voir
       <link linkend="catalog-pg-extension"><structname>pg_extension</structname></link>).
       L'objet dépendant peut être supprimé seulement via l'instruction
       <command>DROP EXTENSION</command> sur l'objet référence.
       Fonctionnellement, ce type de dépendance agit de la même façon
       qu'une dépendance interne mais il est séparé pour des raisons de
       clarté et pour simplifier <application>pg_dump</application>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_PIN</symbol> (<literal>p</literal>)</term>
     <listitem>
      <para>
       Il n'y a pas d'objet dépendant&nbsp;; ce type d'entrée signale que le
       système lui-même dépend de l'objet référencé, et donc que l'objet ne doit
       jamais être supprimé. Les entrées de ce type sont créées uniquement par
       <command>initdb</command>. Les colonnes de l'objet dépendant 
       contiennent des zéros.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   D'autres types de dépendance peuvent apparaître dans le futur.
  </para>

 </sect1>


 <sect1 id="catalog-pg-description">
  <title><structname>pg_description</structname></title>

  <indexterm zone="catalog-pg-description">
   <primary>pg_description</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_description</structname> stocke les descriptions 
   (commentaires) optionnelles de chaque objet de la base de données. Les
   descriptions sont manipulées avec la commande <xref linkend="sql-comment"/>
   et lues avec les commandes <literal>\d</literal>
   de <application>psql</application>. <structname>pg_description</structname>
   contient les descriptions prédifinies de nombreux objets internes.
  </para>

  <para>
   Voir aussi 
   <link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link>,
   qui offre la même fonction pour les descriptions des
   objets partagés au sein d'un cluster.
  </para>

  <table>
   <title>Colonnes de <structname>pg_description</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>OID de l'objet commenté</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal>
      <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID du catalogue système dans lequel apparaît l'objet</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour un commentaire de colonne de table, le numéro de la colonne. Les champs
       <structfield>objoid</structfield> et <structfield>classoid</structfield>
       font référence à la
       table elle-même. Pour tous les autres types de données, cette colonne 
       est à 0.
      </entry>
     </row>

     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Texte quelconque commentant l'objet</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-enum">
  <title><structname>pg_enum</structname></title>

  <indexterm zone="catalog-pg-enum">
   <primary>pg_enum</primary>
  </indexterm>

  <para>
   Le catalogue système <structname>pg_enum</structname> contient des
   entrées indiquant les valeurs et labels de chaque type enum. La
   représentation interne d'une valeur enum donnée est en fait l'OID de
   sa ligne associée dans <structname>pg_enum</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_enum</structname></title>

    <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>enumtypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID de l'entrée <structname>pg_type</structname> correspondant à
       cette valeur d'enum</entry>
     </row>

     <row>
      <entry><structfield>enumsortorder</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>La position de tri de cette valeur enum dans son type
       enum</entry>
     </row>

     <row>
      <entry><structfield>enumlabel</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Le label texte pour cette valeur d'enum</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les OID des lignes de <structname>pg_enum</structname> suivent une
   règle spéciale&nbsp;: les OID pairs sont garantis triés de la même
   façon que l'ordre de tri de leur type enum. Autrement dit, si deux OID
   pairs appartiennent au même type enum, l'OID le plus petit doit avoir
   la plus petite valeur dans la colonne
   <structfield>enumsortorder</structfield>. Les valeurs d'OID impaires
   n'ont pas d'ordre de tri. Cette règle permet que les routines de
   comparaison d'enum évitent les recherches dans les catalogues dans la
   plupart des cas standards. Les routines qui créent et modifient les
   types enum tentent d'affecter des OID paires aux valeurs enum tant que
   c'est possible.
  </para>

  <para>
   Quand un type enum est créé, ses membres sont affectés dans l'ordre
   des positions 1..<replaceable>n</replaceable>. Les membres ajoutés par
   la suite doivent se voir affecter des valeurs négatives ou
   fractionnelles de <structfield>enumsortorder</structfield>. Le seul
   prérequis pour ces valeurs est qu'elles soient correctement triées
   et uniques pour chaque type enum.
  </para>
 </sect1>


 <sect1 id="catalog-pg-extension">
  <title><structname>pg_extension</structname></title>

  <indexterm zone="catalog-pg-extension">
   <primary>pg_extension</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_extension</structname> stocke les
   informations sur les extensions installées. Voir <xref
   linkend="extend-extensions"/> pour des détails sur les extensions.
  </para>

  <table>
   <title>Colonnes de <structname>pg_extension</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>extname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de l'extension</entry>
     </row>

     <row>
      <entry><structfield>extowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire de l'extension</entry>
     </row>

     <row>
      <entry><structfield>extnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>Schéma contenant les objets exportés de l'extension</entry>
     </row>

     <row>
      <entry><structfield>extrelocatable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True si l'extension peut être déplacée dans un autre schéma</entry>
     </row>

     <row>
      <entry><structfield>extversion</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Nom de la version de l'extension</entry>
     </row>

     <row>
      <entry><structfield>extconfig</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Tableaux d'OID de type <type>regclass</type> pour la table
       de configuration de l'extension, ou <literal>NULL</literal> si aucun</entry>
     </row>

     <row>
      <entry><structfield>extcondition</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Tableau de conditions de filtre (clauses
       <literal>WHERE</literal>) pour la table de configuration de
       l'extension, ou <literal>NULL</literal> si aucun</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Notez que, contrairement aux autres catalogues ayant une colonne de
   <quote>schéma</quote>, <structfield>extnamespace</structfield> n'est
   pas le schéma contenant l'extension. Les noms des extensions ne
   sont jamais qualifiés d'un schéma. En fait,
   <structfield>extnamespace</structfield> indique le schéma qui
   contient la plupart ou tous les objets de l'extension. Si
   <structfield>extrelocatable</structfield> vaut true, alors ce schéma
   doit en fait contenir tous les objets de l'extension, dont le nom
   peut être qualifié avec le nom du schéma.
  </para>
 </sect1>

 <sect1 id="catalog-pg-foreign-data-wrapper">
  <title><structname>pg_foreign_data_wrapper</structname></title>

  <indexterm zone="catalog-pg-foreign-data-wrapper">
   <primary>pg_foreign_data_wrapper</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_foreign_data_wrapper</structname> stocke les
   définitions des wrappers de données distantes. Un wrapper de données distantes
   est le mécanisme par lequel des données externes, stockées sur des serveurs
   distants, sont accédées.
  </para>

  <table>
   <title>Colonnes de <structname>pg_foreign_data_wrapper</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>fdwname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du wrapper de données distantes</entry>
     </row>

     <row>
      <entry><structfield>fdwowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire du wrapper de données distantes</entry>
     </row>

     <row>
      <entry><structfield>fdwhandler</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       Référence une fonction de gestion responsable de la fourniture
       de routines d'exécution pour le wrapper de données distantes.
       Zéro si aucune fonction n'est fournie.
      </entry>
     </row>

     <row>
      <entry><structfield>fdwvalidator</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       Référence le validateur de fonction qui est responsable de vérifier la
       validité des options passées au wrapper de données distantes,
       ainsi que les options des serveurs distants et les correspondances
       utilisateurs du wrapper de données distantes. Zéro si aucun validateur n'est fourni.
      </entry>
     </row>

     <row>
      <entry><structfield>fdwacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Droits d'accès&nbsp;; voir <xref linkend="sql-grant"/> et <xref
       linkend="sql-revoke"/> pour plus de détails
      </entry>
     </row>

     <row>
      <entry><structfield>fdwoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Options spécifiques pour un wrapper de données distantes, sous la forme de chaînes
       <quote>motclé=valeur</quote>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-foreign-server">
  <title><structname>pg_foreign_server</structname></title>

  <indexterm zone="catalog-pg-foreign-server">
   <primary>pg_foreign_server</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_foreign_server</structname> stocke les
   définitions de serveurs distants. Un serveur distant décrit une
   source de données externes, comme un serveur distant. Les serveurs
   distants sont accédés via des wrappers de données distantes.
  </para>

  <table>
   <title>Colonnes <structname>pg_foreign_server</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Reférence</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>srvname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du serveur distant</entry>
     </row>

     <row>
      <entry><structfield>srvowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire du serveur distant</entry>
     </row>

     <row>
      <entry><structfield>srvfdw</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-data-wrapper"><structname>pg_foreign_data_wrapper</structname></link>.oid</literal></entry>
      <entry>OID du wrapper de données distantes pour ce serveur distant</entry>
     </row>

     <row>
      <entry><structfield>srvtype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Type du serveur (optionnel)</entry>
     </row>

     <row>
      <entry><structfield>srvversion</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Version du serveur (optionnel)</entry>
     </row>

     <row>
      <entry><structfield>srvacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Droits d'accès&nbsp;; voir <xref linkend="sql-grant"/> et <xref
       linkend="sql-revoke"/> pour les détails
      </entry>
     </row>

     <row>
      <entry><structfield>srvoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Options pour le serveur distant, sous la forme de chaînes
       <quote>motclé=valeur</quote>.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-foreign-table">
  <title><structname>pg_foreign_table</structname></title>

  <indexterm zone="catalog-pg-foreign-table">
   <primary>pg_foreign_table</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_foreign_table</structname> contient des
   informations supplémentaires sur les tables distantes. Une table
   distante est principalement représentée par une entrée dans le
   catalogue <structname>pg_class</structname>, comme toute table
   ordinaire. Son entrée dans <structname>pg_foreign_table</structname>
   contient les informations pertinentes aux seules tables distantes, et
   pas aux autres types de relation.
  </para>

  <table>
   <title>Colonnes de <structname>pg_foreign_table</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>ftrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID de l'entrée dans le catalogue
       <structname>pg_class</structname> pour cette table distante</entry>
     </row>

     <row>
      <entry><structfield>ftserver</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.oid</literal></entry>
      <entry>OID du serveur distant pour cette table distante</entry>
     </row>

     <row>
      <entry><structfield>ftoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Options de la table distante, sous la forme de chaînes
       <quote>clé=valeur</quote>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-index">
  <title><structname>pg_index</structname></title>

  <indexterm zone="catalog-pg-index">
   <primary>pg_index</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_index</structname> contient une partie des 
   informations concernant les index. Le reste se trouve pour l'essentiel dans
   <structname>pg_class</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_index</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>indexrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID de l'entrée dans <structname>pg_class</structname> de
      l'index</entry>
     </row>

     <row>
      <entry><structfield>indrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID de l'entrée dans <structname>pg_class</structname> de la table sur 
       laquelle porte l'index
      </entry>
     </row>

     <row>
      <entry><structfield>indnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre de colonnes de l'index (duplique
      <literal>pg_class.relnatts</literal>)</entry>
     </row>

     <row>
      <entry><structfield>indisunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai s'il s'agit d'un index d'unicité</entry>
     </row>

     <row>
      <entry><structfield>indisprimary</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai s'il s'agit de l'index de clé primaire de la table
      (<structfield>indisunique</structfield> doit toujours être vrai quand ce champ l'est.)</entry>
     </row>

     <row>
      <entry><structfield>indisexclusion</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai s'il s'agit de l'index supportant une contrainte
       d'exclusion</entry>
     </row>

     <row>
      <entry><structfield>indimmediate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Si vrai, la vérification de l'unicité est forcée immédiatement
      lors de l'insertion (inutile si <structfield>indisunique</structfield>
      ne vaut pas true)</entry>
     </row>

     <row>
      <entry><structfield>indisclustered</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si la table a été réorganisée en fonction de l'index</entry>
     </row>

     <row>
      <entry><structfield>indisvalid</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Si vrai, l'index est valide pour les requêtes. Faux signifie
       que l'index peut être incomplet&nbsp;: les opérations INSERT/UPDATE
       peuvent toujours l'utiliser, mais il ne peut pas être utilisé
       sans risque pour les requêtes, et, dans le cas d'un index d'unicité,
       celle-ci n'est plus non-plus garantie.</entry>
     </row>

     <row>
      <entry><structfield>indcheckxmin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Si vrai, les requêtes ne doivent pas utiliser l'index tant que le
       <structfield>xmin</structfield> de cette ligne de
       <structname>pg_index</structname> est en-dessous de leur horizon
       d'événements <symbol>TransactionXmin</symbol>, car la table peut
       contenir des chaînes
       HOT cassées avec des lignes incompatibles qu'elles peuvent voir.
      </entry>
     </row>

     <row>
      <entry><structfield>indisready</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Si vrai, l'index est actuellement prêt pour les insertions. Faux indique
       que l'index doit être ignoré par les opérations
       <command>INSERT</command>/<command>UPDATE</command>
      </entry>
     </row>

     <row>
      <entry><structfield>indkey</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>
       C'est un tableau de valeurs <structfield>indnatts</structfield> qui
       indique les colonnes de la table indexées. Par
       exemple, une valeur <literal>1 3</literal> signifie que la première et
       la troisième colonne de la table composent la clé de l'index. Un 0 dans
       ce tableau indique que l'attribut de l'index correspondant est une
       expression sur les colonnes de la table plutôt qu'une simple référence
       de colonne.
      </entry>
     </row>

     <row>
      <entry><structfield>indcollation</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry>
       Pour chaque colonne dans la clé de l'index, cette colonne contient
       l'OID du collationnement à utiliser pour l'index.
      </entry>
     </row>

     <row>
      <entry><structfield>indclass</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>
       Pour chaque colonne de la clé d'indexation, contient l'OID de la
       classe d'opérateur à utiliser. Voir
       <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>
       pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structfield>indoption</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry></entry>
      <entry>
       C'est un tableau de valeurs <structfield>indnatts</structfield> qui
       enregistrent des drapeaux d'information par colonne. La signification
       de ces drapeaux est définie par la méthode d'accès à l'index.
      </entry>
     </row>

     <row>
      <entry><structfield>indexprs</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>Arbres d'expression (en représentation
      <function>nodeToString()</function>)
      pour les attributs d'index qui ne sont pas de simples références de 
      colonnes. Il s'agit d'une liste qui contient un élément par entrée à
      0 dans <structfield>indkey</structfield>. Nul si tous les attributs d'index sont 
      de simples références.</entry>
      </row>

     <row>
      <entry><structfield>indpred</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry> Arbre d'expression (en représentation
       <function>nodeToString()</function>) pour les prédicats d'index partiels.
       Nul s'il ne s'agit pas d'un index partiel.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-inherits">
  <title><structname>pg_inherits</structname></title>

  <indexterm zone="catalog-pg-inherits">
   <primary>pg_inherits</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_inherits</structname> enregistre l'information sur la 
   hiérarchie d'héritage des tables. Il existe une entrée pour chaque table enfant
   direct dans la base de données. (L'héritage indirect peut être déterminé en
   suivant les chaînes d'entrées.)
  </para>

  <table>
   <title>Colonnes de <structname>pg_inherits</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>inhrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       OID de la table fille
      </entry>
     </row>

     <row>
      <entry><structfield>inhparent</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       OID de la table mère
      </entry>
     </row>

     <row>
      <entry><structfield>inhseqno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       S'il y a plus d'un parent direct pour une table fille (héritage multiple), ce 
       nombre indique dans quel ordre les colonnes héritées doivent être 
       arrangées. Le compteur commence à 1.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-language">
  <title><structname>pg_language</structname></title>

  <indexterm zone="catalog-pg-language">
   <primary>pg_language</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_language</structname> enregistre les langages
   utilisables pour l'écriture de fonctions ou 
   procédures stockées. Voir <xref linkend="sql-createlanguage"/> et dans le
   <xref linkend="xplang"/> pour plus d'information sur les gestionnaires
   de langages.
  </para>

  <table>
   <title>Colonnes de <structname>pg_language</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>lanname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du langage</entry>
     </row>

     <row>
      <entry><structfield>lanowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire du langage</entry>
     </row>

     <row>
      <entry><structfield>lanispl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Faux pour les langages internes (comme <acronym>SQL</acronym>) et
       vrai pour les langages utilisateur. À l'heure actuelle, 
       <application>pg_dump</application> utilise ce champ pour déterminer 
       les langages à sauvegarder mais cela peut être 
       un jour remplacé par un mécanisme différent.
      </entry>
     </row>

     <row>
      <entry><structfield>lanpltrusted</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai s'il s'agit d'un langage de confiance
       (<foreignphrase>trusted</foreignphrase>), ce qui signifie qu'il
       est supposé ne pas donner accès à ce qui dépasse
       l'exécution normale des requêtes SQL. Seuls les superutilisateurs
       peuvent créer des fonctions dans des langages qui ne sont pas dignes de
       confiance.
      </entry>
     </row>

     <row>
      <entry><structfield>lanplcallfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       Pour les langages non-internes, ceci référence le gestionnaire de
       langage, fonction spéciale en charge de l'exécution de toutes
       les fonctions écrites dans ce langage.
      </entry>
     </row>

     <row>
      <entry><structfield>laninline</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       Ceci référence une fonction qui est capable d'exécuter des blocs de
       code anonyme <quote>en ligne</quote> (blocs <xref linkend="sql-do"/>).
       Zéro si les blocs en ligne ne sont pas supportés
      </entry>
     </row>

     <row>
      <entry><structfield>lanvalidator</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       Ceci référence une fonction de validation de langage, en charge de 
       vérifier la syntaxe et la validité des nouvelles fonctions lors de
       leur création. 0 si aucun validateur n'est fourni.
      </entry>
     </row>

     <row>
      <entry><structfield>lanacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Droits d'accès&nbsp;;; voir <xref linkend="sql-grant"/> et
      <xref linkend="sql-revoke"/> pour les détails.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-largeobject">
  <title><structname>pg_largeobject</structname></title>

  <indexterm zone="catalog-pg-largeobject">
   <primary>pg_largeobject</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_largeobject</structname> contient les données
   qui décrivent les <quote>objets volumineux</quote>
   (<foreignphrase>large objects</foreignphrase>). Un objet volumineux
   est identifié par un OID qui lui est affecté lors de sa création.
   Chaque objet volumineux est coupé en segments ou <quote>pages</quote>
   suffisamment petits pour être facilement stockés dans des lignes de 
   <structname>pg_largeobject</structname>.
   La taille de données par page est définie par <symbol>LOBLKSIZE</symbol>, qui vaut
   actuellement <literal>BLCKSZ/4</literal>, soit habituellement 2&nbsp;Ko).
  </para>

  <para>
   Avant <productname>PostgreSQL</productname> 9.0, il n'existait pas de
   droits associés aux «&nbsp;Large Objects&nbsp;». Du coup,
   <structname>pg_largeobject</structname> était lisible par tout le monde et
   pouvait être utilisé pour obtenir les OID (et le contenu) de tous les
   «&nbsp;Large Objects&nbsp;» du système. Ce n'est plus le cas&nbsp;;
   utilisez <link
   linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link>
   pour obtenir une liste des OID des «&nbsp;Large Objects&nbsp;».
  </para>

  <table>
   <title>Colonnes de <structname>pg_largeobject</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>loid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link>.oid</literal></entry>
      <entry>Identifiant de l'objet volumineux qui contient la page</entry>
     </row>

     <row>
      <entry><structfield>pageno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Numéro de la page au sein de l'objet volumineux, en partant
       de 0</entry>
     </row>

     <row>
      <entry><structfield>data</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
     <entry>
       Données effectivement stockées dans l'objet volumineux. Il ne fait
       jamais plus de <symbol>LOBLKSIZE</symbol> mais peut faire moins.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Chaque ligne de <structname>pg_largeobject</structname> contient les données
   d'une page de l'objet volumineux, en commençant au décalage d'octet
   (<literal>pageno * LOBLKSIZE</literal>) dans l'objet. Ceci permet un stockage
   diffus&nbsp;: des pages peuvent manquer, d'autres faire moins de
   <literal>LOBLKSIZE</literal> octets même s'il ne s'agit pas de la dernière de
   l'objet. Les parties manquantes sont considérées comme des suites de zéro.
  </para>

 </sect1>


 <sect1 id="catalog-pg-largeobject-metadata">
  <title><structname>pg_largeobject_metadata</structname></title>

  <indexterm zone="catalog-pg-largeobject-metadata">
   <primary>pg_largeobject_metadata</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_largeobject_metadata</structname> contient des
   méta-données associées aux «&nbsp;Larges Objects&nbsp;». Les données des
   «&nbsp;Larges Objects&nbsp;» sont réellement stockées dans <link
   linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_largeobject_metadata</structname></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>lomowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire du «&nbsp;Larges Object&nbsp;»</entry>
     </row>

     <row>
      <entry><structfield>lomacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Droits d'accès&nbsp;; pour plus de détails, voir
       <xref linkend="sql-grant"/> et <xref linkend="sql-revoke"/>
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-namespace">
  <title><structname>pg_namespace</structname></title>

  <indexterm zone="catalog-pg-namespace">
   <primary>pg_namespace</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_namespace</structname> stocke les
   <foreignphrase>namespace</foreignphrase>. Un
   <foreignphrase>namespace</foreignphrase> est la structure sous-jacente
   aux schémas SQL&nbsp;: chaque <foreignphrase>namespace</foreignphrase>
   peut contenir un ensemble séparé de relations, types, etc. sans
   qu'il y ait de conflit de nommage.
  </para>

  <table>
   <title>Colonnes de <structname>pg_namespace</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>nspname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du <foreignphrase>namespace</foreignphrase></entry>
     </row>

     <row>
      <entry><structfield>nspowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire du <foreignphrase>namespace</foreignphrase></entry>
     </row>

     <row>
      <entry><structfield>nspacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Droits d'accès&nbsp;; voir <xref linkend="sql-grant"/> et <xref
        linkend="sql-revoke"/> pour les détails.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-opclass">
  <title><structname>pg_opclass</structname></title>

  <indexterm zone="catalog-pg-opclass">
   <primary>pg_opclass</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_opclass</structname> définit les classes
   d'opérateurs de méthodes d'accès aux index. Chaque classe d'opérateurs définit
   la sémantique pour les colonnes d'index d'un type particulier et d'une
   méthode d'accès particulière. Une classe d'opérateur définit essentiellement
   qu'une famille d'opérateur particulier est applicable à un type de données
   indexable particulier. L'ensemble des opérateurs de la famille actuellement
   utilisables avec la colonne indexée sont tous ceux qui acceptent le type de
   données de la colonne en tant qu'entrée du côté gauche.
  </para>

  <para>
   Les classes d'opérateurs sont longuement décrites dans la
   <xref linkend="xindex"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_opclass</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>opcmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>Méthode d'accès à l'index pour laquelle est définie la classe
       d'opérateurs</entry>
     </row>

     <row>
      <entry><structfield>opcname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la classe d'opérateurs</entry>
     </row>

     <row>
      <entry><structfield>opcnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry><foreignphrase>Namespace</foreignphrase> de la classe d'opérateurs</entry>
     </row>

     <row>
      <entry><structfield>opcowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire de la classe d'opérateurs</entry>
     </row>

     <row>
      <entry><structfield>opcfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>Famille d'opérateur contenant la classe d'opérateur</entry>
     </row>

     <row>
      <entry><structfield>opcintype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de données que la classe d'opérateurs indexe</entry>
     </row>

     <row>
      <entry><structfield>opcdefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si la classe d'opérateurs est la classe par défaut pour
       <structfield>opcintype</structfield></entry>
     </row>

     <row>
      <entry><structfield>opckeytype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de données stocké dans l'index ou 0 s'il s'agit du même que
       <structfield>opcintype</structfield></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   L'<structfield>opcmethod</structfield> d'une classe d'opérateurs doit
   coïncider avec l'<structname>opfmethod</structname> de la famille
   d'opérateurs qui le contient. Il ne doit pas non plus y avoir plus d'une
   ligne <structname>pg_opclass</structname> pour laquelle
   <structname>opcdefault</structname> est vrai, quelque soit la combinaison de 
   <structname>opcmethod</structname> et <structname>opcintype</structname>.
  </para>

 </sect1>


 <sect1 id="catalog-pg-operator">
  <title><structname>pg_operator</structname></title>

  <indexterm zone="catalog-pg-operator">
   <primary>pg_operator</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_operator</structname> stocke les informations
   concernant les opérateurs. Voir la commande <xref
   linkend="sql-createoperator"/> et la <xref linkend="xoper"/> pour plus
   d'informations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_operator</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oprname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de l'opérateur</entry>
     </row>

     <row>
      <entry><structfield>oprnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       OID du <foreignphrase>namespace</foreignphrase> qui contient l'opérateur
      </entry>
     </row>

     <row>
      <entry><structfield>oprowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire de l'opérateur</entry>
     </row>

     <row>
      <entry><structfield>oprkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>b</literal> = infix (<quote>les deux</quote>), <literal>l</literal> = prefix
       (<quote>gauche</quote>), <literal>r</literal> = postfix (<quote>droit</quote>)
      </entry>
     </row>

     <row>
      <entry><structfield>oprcanmerge</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>L'opérateur supporte les jointures de fusion</entry>
     </row>

     <row>
      <entry><structfield>oprcanhash</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>L'opérateur supporte les jointures par découpage</entry>
     </row>

     <row>
      <entry><structfield>oprleft</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de l'opérande de gauche</entry>
     </row>

     <row>
      <entry><structfield>oprright</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de l'opérande de droite</entry>
     </row>

     <row>
      <entry><structfield>oprresult</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type du résultat</entry>
     </row>

     <row>
      <entry><structfield>oprcom</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Commutateur de l'opérateur, s'il existe</entry>
     </row>

     <row>
      <entry><structfield>oprnegate</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Négateur de l'opérateur, s'il existe</entry>
     </row>

     <row>
      <entry><structfield>oprcode</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction codant l'opérateur</entry>
     </row>

     <row>
      <entry><structfield>oprrest</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction d'estimation de la sélectivité de restriction de
      l'opérateur</entry>
     </row>

     <row>
      <entry><structfield>oprjoin</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction d'estimation de la sélectivité de jointure de
       l'opérateur</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les colonnes inutilisées contiennent des zéros. 
   <structfield>oprleft</structfield> vaut, par exemple, 0 pour un opérateur préfixe.
  </para>

 </sect1>


 <sect1 id="catalog-pg-opfamily">
  <title><structname>pg_opfamily</structname></title>

  <indexterm zone="catalog-pg-opfamily">
   <primary>pg_opfamily</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_opfamily</structname> définit les familles 
   d'opérateur. Chaque famille d'opérateur est un ensemble d'opérateurs et
   de routines de support associées codant les sémantiques définies
   pour une méthode d'accès particulière de l'index. De plus, les opérateurs
   d'une famille sont tous <quote>compatibles</quote>, au sens défini
   par la méthode d'accès. Le concept de famille d'opérateur autorise
   l'utilisation des opérateurs inter-type de données avec des index et
   l'utilisation des sémantiques de méthode d'accès.
  </para>

  <para>
   Les familles d'opérateur sont décrites dans <xref linkend="xindex"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_opfamily</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><structfield>opfmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>Méthode d'accès à l'index pour la famille d'opérateur</entry>
     </row>

     <row>
      <entry><structfield>opfname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la famille d'opérateur</entry>
     </row>

     <row>
      <entry><structfield>opfnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry><foreignphrase>namespace</foreignphrase> de la famille d'opérateur</entry>
     </row>

     <row>
      <entry><structfield>opfowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire de la famille d'opérateur</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   La majorité des informations définissant une famille d'opérateur n'est pas
   dans la ligne correspondante de <structname>pg_opfamily</structname> mais dans les lignes
   associées de
   <link linkend="catalog-pg-amop"><structname>pg_amop</structname></link>,
   <link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>,
   et
   <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.
  </para>

 </sect1>


 <sect1 id="catalog-pg-pltemplate">
  <title><structname>pg_pltemplate</structname></title>

  <indexterm zone="catalog-pg-pltemplate">
   <primary>pg_pltemplate</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_pltemplate</structname> stocke les informations
   squelettes (<quote>template</quote>) des langages procéduraux. Un squelette
   de langage permet la création de ce langage dans une base de données
   particulière à l'aide d'une simple commande <command>CREATE LANGUAGE</command>, sans
   qu'il soit nécessaire de spécifier les détails de l'implantation.
  </para>

  <para>
   Contrairement à la plupart des catalogues système,
   <structname>pg_pltemplate</structname> est partagé par toutes les bases
   de données d'un cluster&nbsp;: il n'existe qu'une seule copie de
   <structname>pg_pltemplate</structname> par cluster, et non une par base
   de données. L'information est de ce fait accessible à toute base de
   données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_pltemplate</structname></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>tmplname</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Nom du langage auquel est associé le modèle</entry>
     </row>

     <row>
      <entry><structfield>tmpltrusted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal>True</literal> s'il s'agit d'un langage de
       confiance</entry>
     </row>

     <row>
      <entry><structfield>tmpldbacreate</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal>True</literal> s'il s'agit d'un langage créé par le
       propriétaire de la base</entry>
     </row>

     <row>
      <entry><structfield>tmplhandler</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Nom de la fonction de gestion des appels</entry>
     </row>

     <row>
      <entry><structfield>tmplinline</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Nom de la fonction de gestion des blocs anonymes. NULL sinon</entry>
     </row>

     <row>
      <entry><structfield>tmplvalidator</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Nom de la fonction de validation, ou NULL si aucune</entry>
     </row>

     <row>
      <entry><structfield>tmpllibrary</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Chemin de la bibliothèque partagée qui code le
       langage</entry>
     </row>

     <row>
      <entry><structfield>tmplacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry>Droits d'accès au modèle (inutilisé)</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Il n'existe actuellement aucune commande de manipulation des modèles de
   langages procéduraux&nbsp;; pour modifier l'information intégrée, un
   superutilisateur doit modifier la table en utilisant les commandes
   <command>INSERT</command>, <command>DELETE</command> ou
   <command>UPDATE</command> habituelles.
  </para>

  <note>
   <para>
    Il est probable que <structname>pg_pltemplate</structname> sera
    supprimé dans une prochaine version de
    <productname>PostgreSQL</productname>, pour conserver cette information
    des langages de procédure dans leur scripts d'installation respectifs.
   </para>
  </note>


 </sect1>


 <sect1 id="catalog-pg-proc">
  <title><structname>pg_proc</structname></title>

  <indexterm zone="catalog-pg-proc">
   <primary>pg_proc</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_proc</structname> stocke les informations
   concernant les fonctions (ou procédures). Voir
   <xref linkend="sql-createfunction"/>
   et <xref linkend="xfunc"/> pour plus
   d'informations.
  </para>

  <para>
   Cette table contient des données sur les fonctions d'agrégat et
   les fonctions simples. Si <structfield>proisagg</structfield> est vrai, il
   doit y avoir une ligne correspondante dans
   <structfield>pg_aggregate</structfield>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_proc</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>proname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la fonction</entry>
     </row>

     <row>
      <entry><structfield>pronamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       OID du <foreignphrase>namespace</foreignphrase> auquel appartient la fonction
      </entry>
     </row>

     <row>
      <entry><structfield>proowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire de la fonction</entry>
     </row>

     <row>
      <entry><structfield>prolang</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-language"><structname>pg_language</structname></link>.oid</literal></entry>
      <entry>Langage de codage ou interface d'appel de la fonction</entry>
     </row>

     <row>
      <entry><structfield>procost</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>Coût d'exécution estimé (en unité de
       <xref linkend="guc-cpu-operator-cost"/>)&nbsp;; si <structfield>proretset</structfield>,
       il s'agit d'un coût par ligne</entry>
     </row>

     <row>
      <entry><structfield>prorows</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>Nombre estimé de ligne de résultat (zéro si <structfield>proretset</structfield> est faux)</entry>
     </row>

     <row>
      <entry><structfield>provariadic</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry> Type des données des éléments du tableau de paramètres variadic,
          ou zéro si la fonction n'a pas de paramètres variadiques.</entry>
     </row>

     <row>
      <entry><structfield>proisagg</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Si vrai, la fonction est une fonction d'agrégat</entry>
     </row>

     <row>
      <entry><structfield>proiswindow</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La fonction est une fonction window</entry>
     </row>

     <row>
      <entry><structfield>prosecdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Si vrai, la fonction définit la sécurité (c'est une
       fonction <quote>setuid</quote>)
      </entry>
     </row>

     <row>
      <entry><structfield>proisstrict</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Si vrai, la fonction retourne NULL si l'un de ses arguments est
       NULL. Dans ce cas, la fonction n'est en fait pas appelée du tout. 
       Les fonctions qui ne sont pas <quote>strictes</quote> doivent 
       traiter les paramètres NULL.
      </entry>
     </row>

     <row>
      <entry><structfield>proretset</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Si vrai, la fonction retourne un ensemble (c'est-à-dire des valeurs
       multiples du type défini)
      </entry>
     </row>

     <row>
      <entry><structfield>provolatile</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Indique si le résultat de la 
       fonction dépend uniquement de ses arguments ou s'il est affecté par
       des facteurs externes. Il vaut <literal>i</literal> pour les fonctions
       <quote>immuables</quote>, qui, pour un jeu de paramètres identique en
       entrée, donnent toujours le même résultat. Il vaut <literal>s</literal> pour les
       fonctions <quote>stables</quote>, dont le résultat (pour les mêmes paramètres
       en entrée) ne change pas au cours du parcours (de table). Il vaut
       <literal>v</literal> pour les fonctions <quote>volatiles</quote>, dont le
       résultat peut varier à tout instant. (<literal>v</literal> est
       également utilisé pour les fonctions qui ont des effets de bord, afin que les appels
       à ces fonctions ne soient pas optimisés.)
      </entry>
     </row>

     <row>
      <entry><structfield>pronargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre d'arguments en entrée</entry>
     </row>

     <row>
      <entry><structfield>pronargdefaults</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre d'arguments qui ont des valeurs par défaut</entry>
     </row>

     <row>
      <entry><structfield>prorettype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de données renvoyé</entry>
     </row>

     <row>
      <entry><structfield>proargtypes</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       Un tableau contenant les types de données des arguments de la fonction.
       Ceci n'inclut que les arguments en entrée (dont les arguments
       <literal>INOUT</literal> et <literal>VARIADIC</literal>) et représente,
       du coup, la signature d'appel de la fonction.
      </entry>
     </row>

     <row>
      <entry><structfield>proallargtypes</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       Un tableau contenant les types de données des arguments de la fonction. Ceci
       inclut tous les arguments (y compris les arguments <literal>OUT</literal>
       et <literal>INOUT</literal>)&nbsp;; néanmoins, si tous les arguments sont
       <literal>IN</literal>, ce champ est NULL. L'indice commence à 1 alors
       que, pour des raisons historiques, <structfield>proargtypes</structfield>
       commence à 0.
      </entry>
     </row>

     <row>
      <entry><structfield>proargmodes</structfield></entry>
      <entry><type>char[]</type></entry>
      <entry></entry>
      <entry>
        Un tableau contenant les modes des arguments de la fonction, codés avec
        <literal>i</literal> pour les arguments <literal>IN</literal>,
        <literal>o</literal> pour les arguments <literal>OUT</literal>,
        <literal>b</literal> pour les arguments <literal>INOUT</literal>,
        <literal>v</literal> pour les arguments <literal>VARIADIC</literal>,
        <literal>t</literal> pour les arguments <literal>TABLE</literal>.
        Si tous les arguments sont des arguments <literal>IN</literal>, ce
	champ est NULL.
        Les indices correspondent aux positions de
        <structfield>proallargtypes</structfield>, et non à celles de
        <structfield>proargtypes</structfield>.
      </entry>
     </row>

     <row>
      <entry><structfield>proargnames</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Un tableau contenant les noms des arguments de la fonction. Les arguments
       sans nom sont initialisés à des chaînes vides dans le tableau.
       Si aucun des arguments n'a de nom, ce champ est NULL.
       Les indices correspondent aux positions de
       <structfield>proallargtypes</structfield>, et non à celles de
       <structfield>proargtypes</structfield>.
      </entry>
     </row>

     <row>
      <entry><structfield>proargdefaults</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       Arbres d'expression (en représentation <function>nodeToString()</function>)
       pour les valeurs par défaut. C'est une liste avec <structfield>pronargdefaults</structfield>
       éléments, correspondant aux <replaceable>N</replaceable> derniers arguments
       d'<emphasis>entrée</emphasis> (c'est-à-dire, les <replaceable>N</replaceable>
       dernières positions <structfield>proargtypes</structfield>).
       Si aucun des arguments n'a de valeur par défaut, ce champ vaudra null.
      </entry>
     </row>

     <row>
      <entry><structfield>prosrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Ce champ indique au gestionnaire de fonctions la façon d'invoquer la
       fonction. Il peut s'agir du code source pour un langage interprété, d'un
       symbole de lien, d'un nom de fichier ou de toute autre chose, en
       fonction du langage ou de la convention d'appel.
      </entry>
     </row>

     <row>
      <entry><structfield>probin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Information supplémentaire sur la façon d'invoquer la fonction.
       Encore une fois, l'interprétation dépend du langage.
      </entry>
     </row>

     <row>
      <entry><structfield>proconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Configuration locale à la fonction pour les variables configurables
       à l'exécution</entry>
     </row>

     <row>
      <entry><structfield>proacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Droits d'accès&nbsp;; voir
       <xref linkend="sql-grant"/> et
       <xref linkend="sql-revoke"/> pour plus de détails.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Pour les fonctions compilées, intégrées ou chargées dynamiquement,
   <structfield>prosrc</structfield> contient le nom de la fonction en langage C
   (symbole de lien). Pour tous les autres types
   de langages, <structfield>prosrc</structfield> contient le code source de la
   fonction. <structfield>probin</structfield> est inutilisé, sauf pour les 
   fonctions C chargées dynamiquement, pour lesquelles il donne le nom de 
   fichier de la bibliothèque partagée qui contient la fonction.
  </para>

 </sect1>

 <sect1 id="catalog-pg-rewrite">
  <title><structname>pg_rewrite</structname></title>

  <indexterm zone="catalog-pg-rewrite">
   <primary>pg_rewrite</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_rewrite</structname> stocke les règles de 
   réécriture pour les tables et les vues.
  </para>

  <table>
   <title>Colonnes de <structname>pg_rewrite</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la règle</entry>
     </row>

     <row>
      <entry><structfield>ev_class</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Table sur laquelle porte la règle</entry>
     </row>

     <row>
      <entry><structfield>ev_attr</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Colonne sur laquelle porte la règle. Actuellement, cette colonne
       vaut toujours 0 pour indiquer qu'il s'agit de la table entière.
      </entry>
     </row>

     <row>
      <entry><structfield>ev_type</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Type d'évènement associé à la règle&nbsp;:
        1 = <command>SELECT</command>,
	2 = <command>UPDATE</command>,
	3 = <command>INSERT</command>, 
        4 = <command>DELETE</command>
      </entry>
     </row>

     <row>
      <entry><structfield>ev_enabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Contrôle l'exécution de la règle suivant le mode <xref
       linkend="guc-session-replication-role"/>.
       <literal>O</literal> = la règle se déclenche dans les modes
       <quote>origin</quote> et <quote>local</quote>,
       <literal>D</literal> = la règle est désactivée,
       <literal>R</literal> = la règle s'exécute en mode <quote>replica</quote>,
       <literal>A</literal> = la règle s'exécute à chaque fois.
      </entry>
     </row>

     <row>
      <entry><structfield>is_instead</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai s'il s'agit d'une règle <literal>INSTEAD</literal> 
       (à la place de).
      </entry>
     </row>

     <row>
      <entry><structfield>ev_qual</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       Arbre d'expression (sous la forme d'une représentation
       <function>nodeToString()</function>) pour la condition qualifiant la
       règle.
      </entry>
     </row>

     <row>
      <entry><structfield>ev_action</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       Arbre de requête (sous la forme d'une représentation
       <function>nodeToString()</function>) pour l'action de la règle.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <literal>pg_class.relhasrules</literal>
    doit être vrai si une table possède une règle dans ce catalogue.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-seclabel">
  <title><structname>pg_seclabel</structname></title>

  <indexterm zone="catalog-pg-seclabel">
   <primary>pg_seclabel</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_seclabel</structname> stocke les
   informations sur les labels de sécurité des objets de la base de
   données. Les labels de sécurité peuvent être manipulés avec la
   commande <xref linkend="sql-security-label"/>. Pour visualiser plus
   facilement les labels de sécurité, voir <xref
   linkend="view-pg-seclabels"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_seclabel</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>L'OID de l'objet concerné par ce label de sécurité</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>L'OID du catalogue système où cet objet apparaît</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour un label de sécurité sur la colonne d'une table, cette
       colonne correspond au numéro de colonne
       (<structfield>objoid</structfield> et
       <structfield>classoid</structfield> font référence à la table
       elle-même). Pour tous les autres types d'objet, cette colonne
       vaut zéro.
      </entry>
     </row>

     <row>
      <entry><structfield>provider</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Le fournisseur du label associé avec ce label.</entry>
     </row>

     <row>
      <entry><structfield>label</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Le label de sécurité appliqué sur cet objet.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-shdepend">
  <title><structname>pg_shdepend</structname></title>

  <indexterm zone="catalog-pg-shdepend">
   <primary>pg_shdepend</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_shdepend</structname> enregistre les relations
   de dépendance entre les objets de la base de données et les objets partagés,
   comme les rôles. Cette information permet à
   <productname>PostgreSQL</productname> de s'assurer que tous ces objets sont
   déréférencés avant toute tentative de suppression.
  </para>

  <para>
   Voir aussi
   <link linkend="catalog-pg-depend"><structname>pg_depend</structname></link>, qui
   réalise une fonction similaire pour les dépendances impliquant les objets
   contenus dans une seule base de données.
  </para>

  <para>
   Contrairement à la plupart des catalogues système,
   <structname>pg_shdepend</structname> est partagé par toutes les bases de
   données d'un cluster&nbsp;: il n'existe qu'une seule copie de
   <structname>pg_shdepend</structname> par cluster, pas une par base de
   données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_shdepend</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>dbid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>L'OID de la base de données dont fait partie l'objet dépendant.
      0 pour un objet partagé</entry>
     </row>

     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>L'OID du catalogue système dont fait partie l'objet
        dépendant</entry>
     </row>

     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>L'OID de l'objet dépendant</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour une colonne de table, c'est le numéro de colonne (les 
       <structfield>objid</structfield> et <structfield>classid</structfield>
       font référence à la table elle-même). Pour tous les autres types d'objets,
       cette colonne vaut zéro
      </entry>
     </row>

     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>L'OID du catalogue système dont fait partie l'objet référencé
        (doit être un catalogue partagé)</entry>
     </row>

     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>L'OID de l'objet référencé</entry>
     </row>

     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Un code définissant les sémantiques spécifiques des relations de cette
       dépendance&nbsp;; voir le texte.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Dans tous les cas, une entrée <structname>pg_shdepend</structname> indique
   que l'objet référencé ne peut pas être supprimé sans supprimer aussi
   l'objet dépendant. Néanmoins, il existe quelques différences identifiées
   par le <structfield>deptype</structfield>&nbsp;:

   <variablelist>
    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_OWNER</symbol> (<literal>o</literal>)</term>
     <listitem>
      <para>
       L'objet référencé (qui doit être un rôle) est le propriétaire de
       l'objet dépendant.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_ACL</symbol> (<literal>a</literal>)</term>
     <listitem>
      <para>
       L'objet référencé (qui doit être un rôle) est mentionné dans la liste
       de contrôle des accès (<acronym>ACL</acronym>, acronyme de
       <foreignphrase>access control list</foreignphrase>) de l'objet
       dépendant. (Une entrée <symbol>SHARED_DEPENDENCY_ACL</symbol> n'est
       pas créée
       pour le propriétaire de l'objet car ce dernier a toujours une
       entrée <symbol>SHARED_DEPENDENCY_OWNER</symbol>.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_PIN</symbol> (<literal>p</literal>)</term>
     <listitem>
      <para>
       Il n'existe pas d'objet dépendant&nbsp;; ce type d'entrée est un signal
       indiquant que le système lui-même dépend de l'objet référencé et que,
       cet objet ne doit donc jamais être supprimé. Les entrées de ce type
       ne sont créées que par <command>initdb</command>. Les colonnes
       pour l'objet dépendant contiennent des zéros.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   D'autres types de dépendances peuvent s'avérer nécessaires dans le futur.
   La définition actuelle ne supporte que les rôles comme objets référencés.
  </para>

 </sect1>

 <sect1 id="catalog-pg-shdescription">
  <title><structname>pg_shdescription</structname></title>

  <indexterm zone="catalog-pg-shdescription">
   <primary>pg_shdescription</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_shdescription</structname> stocke les descriptions
   optionelles (commentaires) des objets partagés de la base. Les
   descriptions peuvent être manipulées avec la commande <xref
   linkend="sql-comment"/> et visualisées avec les commandes
   <literal>\d</literal> de <application>psql</application>.
  </para>

  <para>
   Voir aussi
   <link linkend="catalog-pg-description"><structname>pg_description</structname></link>,
   qui assure les mêmes fonctions, mais pour les objets d'une seule base.
  </para>

  <para>
   Contrairement à la plupart des catalogues systèmes,
   <structname>pg_shdescription</structname>
   est partagée par toutes les bases d'un cluster&nbsp;: il n'existe qu'une seule copie
   de <structname>pg_shdescription</structname> par cluster, et non une par
   base.
  </para>

  <table>
   <title>Colonnes de <structname>pg_shdescription</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>L'OID de l'objet concerné par la description</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>L'OID du catalogue système où cet objet apparaît</entry>
     </row>

     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Texte arbitraire servant de description de l'objet</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-statistic">
  <title><structname>pg_statistic</structname></title>

  <indexterm zone="catalog-pg-statistic">
   <primary>pg_statistic</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_statistic</structname> stocke des données
   statistiques sur le contenu de la base de données. Les entrées sont créées
   par <xref linkend="sql-analyze"/>, puis
   utilisées par le planificateur de requêtes.
   Les données statistiques sont, par définition des approximations, 
   même si elles sont à jour.
  </para>

  <para>
   D'habitude, il existe une entrée, avec
   <structfield>stainherit</structfield> = <literal>false</literal>, pour
   chaque colonne de table qui a été analysée. Si la table a des enfants, une
   seconde entrée avec <structfield>stainherit</structfield> =
   <literal>true</literal> est aussi créé. Cette ligne représente les
   statistiques de la colonne sur l'arbre d'héritage, autrement dit les
   statistiques pour les données que vous voyez avec
   <literal>SELECT <replaceable>colonne</replaceable> FROM
   <replaceable>table</replaceable>*</literal>, alors que la ligne
   <structfield>stainherit</structfield> = <literal>false</literal> représente
   le résultat de
   <literal>SELECT <replaceable>column</replaceable> FROM ONLY <replaceable>table</replaceable></literal>.
  </para>

  <para>
   <structname>pg_statistic</structname> stocke aussi les données
   statistiques des valeurs des expressions d'index. Elles sont décrites
   comme si elles étaient de vraies colonnes&nbsp;; en particulier,
   <structfield>starelid</structfield> référence l'index. Néanmoins, aucune
   entrée n'est effectuée pour une colonne d'index ordinaire sans expression
   car cela est redondant avec l'entrée correspondant à la colonne sous-jacente de la
   table. Actuellement, les entrées pour les expressions d'index ont toujours
   <structfield>stainherit</structfield> = <literal>false</literal>.
  </para>

  <para>
   Comme des statistiques différentes peuvent être appropriées pour des types de 
   données différents, <structname>pg_statistic</structname> ne fait
   qu'un minimum de suppositions sur les types de statistiques qu'il
   stocke. Seules des statistiques extrêmement générales (comme les valeurs
   NULL) ont des colonnes dédiées. Tout le reste est stocké dans des 
   <quote>connecteurs</quote>, groupes de colonnes associées 
   dont le contenu est identifié par un numéro de code dans l'une des colonnes
   du connecteur. Pour plus d'information, voir 
   <filename>src/include/catalog/pg_statistic.h</filename>.
  </para>

  <para>
   <structname>pg_statistic</structname> ne doit pas être lisible par le
   public,
   car même les données statistiques sont sensibles.
   (Exemple&nbsp;: les valeurs maximales et minimales d'une colonne de salaire
   peuvent être intéressantes).
   <link linkend="view-pg-stats"><structname>pg_stats</structname></link> est
   une vue sur <structname>pg_statistic</structname> accessible à tous, qui
   n'expose que les informations sur les tables accessibles à
   l'utilisateur courant.
  </para>

  <table>
   <title>Colonnes de <structname>pg_statistic</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>starelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Table ou index à qui la colonne décrite appartient</entry>
     </row>

     <row>
      <entry><structfield>staattnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>Numéro de la colonne décrite</entry>
     </row>

     <row>
      <entry><structfield>stainherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Si vrai, les statistiques incluent les colonnes enfants de
       l'héritage, pas uniquement les valeurs de la relation spécifiée</entry>
     </row>

     <row>
      <entry><structfield>stanullfrac</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>Fraction des entrées de la colonne qui ont une valeur
       NULL</entry>
     </row>

     <row>
      <entry><structfield>stawidth</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Taille moyenne, en octets, des entrées non NULL</entry>
     </row>

     <row>
      <entry><structfield>stadistinct</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry> 
       Nombre de valeurs distinctes non NULL dans la colonne. Une 
       valeurs positive est le nombre réel de valeurs distinctes. Une valeur
       négative est le négatif d'un multiplieur pour le nombre de lignes dans
       la table&nbsp;;
       par exemple, une colonne dans laquelle les valeurs apparaissent environ
       deux fois en moyenne peut être représentée par 
       <structfield>stadistinct</structfield> = -0.5. 0 indique que le
       nombre de valeurs distinctes est inconnu.
      </entry>
     </row>

     <row>
      <entry><structfield>stakind<replaceable>N</replaceable></structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Numéro de code indiquant le type de statistiques stockées dans
       <quote>le connecteur</quote> numéro <replaceable>N</replaceable> de la ligne de
       <structname>pg_statistic</structname>.
      </entry>
     </row>

     <row>
      <entry><structfield>staop<replaceable>N</replaceable></structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>
       Opérateur utilisé pour dériver les statistiques stockées dans 
       <quote>le connecteur</quote> numéro <replaceable>N</replaceable>. Par exemple, un
       connecteur d'histogramme montre l'opérateur <literal>&lt;</literal>,
       qui définit l'ordre de tri des données.
      </entry>
     </row>

     <row>
      <entry><structfield>stanumbers<replaceable>N</replaceable></structfield></entry>
      <entry><type>float4[]</type></entry>
      <entry></entry>
      <entry>
       Statistiques numériques du type approprié pour
       <quote>le connecteur</quote> numéro <replaceable>N</replaceable> ou NULL si le type
       de connecteur n'implique pas de valeurs numériques.
      </entry>
     </row>

     <row>
      <entry><structfield>stavalues<replaceable>N</replaceable></structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       Valeurs de données de la colonne du type approprié pour 
       <quote>le connecteur</quote> numéro <replaceable>N</replaceable> ou NULL si
       le type de connecteur ne stocke aucune valeur de données. Chaque valeur
       d'élément du tableau est en fait du type de données de la colonne 
       indiquée, si bien qu'il n'y a aucun moyen de définir le type de ces colonnes 
       plus précisément qu'avec le type <type>anyarray</type> (tableau quelconque).
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-tablespace">
   <title><structname>pg_tablespace</structname></title>
   
   <indexterm zone="catalog-pg-tablespace">
     <primary>pg_tablespace</primary>
   </indexterm>
   
   <para>
     Le catalogue <structname>pg_tablespace</structname> enregistre les
     informations des <foreignphrase>tablespaces</foreignphrase> disponibles.
     Les tables peuvent être placées dans des
     <foreignphrase>tablespaces</foreignphrase> particuliers pour faciliter 
     l'administration des espaces de stockage.
   </para>
   
   <para>
     Contrairement à la plupart des catalogues système, 
     <structname>pg_tablespace</structname> est partagée par toutes les bases
     de données du cluster&nbsp;: il n'y a donc qu'une copie de
     <structname>pg_tablespace</structname> par cluster, et non une par
     base.
   </para>
   
   <table>
     <title>Colonnes de <structname>pg_tablespace</structname></title>
   
   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
     <thead>
       <row>
         <entry>Nom</entry>
         <entry>Type</entry>
         <entry>Références</entry>
         <entry>Description</entry>
       </row>
     </thead>
     
     <tbody>
       <row>
         <entry><structfield>spcname</structfield></entry>
         <entry><type>name</type></entry>
         <entry></entry>
         <entry>Nom du <foreignphrase>tablespace</foreignphrase></entry>
       </row>
       
       <row>
         <entry><structfield>spcowner</structfield></entry>
         <entry><type>oid</type></entry>
         <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
         <entry>Propriétaire du <foreignphrase>tablespace</foreignphrase>,
	 habituellement l'utilisateur qui l'a créé</entry>
       </row>
       
       <row>
         <entry><structfield>spclocation</structfield></entry>
         <entry><type>text</type></entry>
         <entry></entry>
         <entry>Emplacement (chemin vers le répertoire) du
	 <foreignphrase>tablespace</foreignphrase></entry>
       </row>
       
       <row>
         <entry><structfield>spcacl</structfield></entry>
         <entry><type>aclitem[]</type></entry>
         <entry></entry>
         <entry>
           Droits d'accès&nbsp;; voir
           <xref linkend="sql-grant"/> et
           <xref linkend="sql-revoke"/> pour les
           détails.
           </entry>
           </row>

           <row>
            <entry><structfield>spcoptions</structfield></entry>
            <entry><type>text[]</type></entry>
            <entry></entry>
            <entry>
             Options au niveau tablespace, sous la forme de chaînes
             <quote>motclé=valeur</quote>
            </entry>
           </row>
         </tbody>
       </tgroup>
     </table>
   </sect1>


   <sect1 id="catalog-pg-trigger">
  <title><structname>pg_trigger</structname></title>

  <indexterm zone="catalog-pg-trigger">
   <primary>pg_trigger</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_trigger</structname> stocke les informations
   concernant les déclencheurs des tables et des vues. Voir la commande
   <xref linkend="sql-createtrigger"/>
   pour plus d'informations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_trigger</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>tgrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Table sur laquelle porte le déclencheur</entry>
     </row>

     <row>
      <entry><structfield>tgname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>
       Nom du déclencheur (doit être unique parmi les déclencheurs 
       d'une table)
      </entry>
     </row>

     <row>
      <entry><structfield>tgfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction à appeler</entry>
     </row>

     <row>
      <entry><structfield>tgtype</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Masque de bits identifiant les conditions de déclenchement</entry>
     </row>

     <row>
      <entry><structfield>tgenabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Contrôle l'exécution du trigger suivant le mode <xref
       linkend="guc-session-replication-role"/>.
       <literal>O</literal> = le trigger se déclenche dans les modes
       <quote>origin</quote> et <quote>local</quote>,
       <literal>D</literal> = le trigger est désactivé,
       <literal>R</literal> = le trigger s'exécute en mode <quote>replica</quote>,
       <literal>A</literal> = le trigger s'exécute à chaque fois.
      </entry>
     </row>

     <row>
      <entry><structfield>tgisinternal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si le trigger est généré en interne (habituellement pour
       forcer la contrainte identifiée par
       <structfield>tgconstraint</structfield>)</entry>
     </row>


     <row>
      <entry><structfield>tgconstrrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>La table référencée par une contrainte d'intégrité
       référentielle</entry>
     </row>

     <row>
      <entry><structfield>tgconstrindid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>L'index supportant une contrainte unique, clé primaire ou
       d'intégrité référentielle</entry>
     </row>

     <row>
      <entry><structfield>tgconstraint</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link>.oid</literal></entry>
      <entry>L'entrée <structname>pg_constraint</structname> associé au trigger,
      si elle existe</entry>
     </row>

     <row>
      <entry><structfield>tgdeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si le déclencheur contrainte est retardable</entry>
     </row>

     <row>
      <entry><structfield>tginitdeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si le déclencheur de contrainte est initialement retardé</entry>
     </row>

     <row>
      <entry><structfield>tgnargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre de chaînes d'arguments passées à la fonction du
       déclencheur</entry>
     </row>

     <row>
      <entry><structfield>tgattr</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>numéros de colonne, si le trigger est spécifique à la colonne&nbsp;;
       sinon un tableau vide</entry>
     </row>

     <row>
      <entry><structfield>tgargs</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>
       Chaînes d'arguments à passer au déclencheur, chacune terminée par un
       NULL
      </entry>
     </row>

     <row>
      <entry><structfield>tgqual</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>Arbre d'expression (d'après la représentation de
       <function>nodeToString()</function> pour la condition
       <literal>WHEN</literal> du trigger, ou NULL si aucune</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Actuellement, les triggers spécifiques par colonne sont supportés seulement
   pour les événements <literal>UPDATE</literal> et, du coup,
   <structfield>tgattr</structfield> est valable seulement pour ce type
   d'événements. <structfield>tgtype</structfield> pourrait contenir des
   informations pour d'autres types d'événement mais ils sont supposés valides
   pour la table complète, quel que soit le contenu de
   <structfield>tgattr</structfield>.
  </para>

  <note>
   <para>
    Quand <structfield>tgconstraint</structfield> est différent de zéro,
    <structfield>tgconstrrelid</structfield>,
    <structfield>tgconstrindid</structfield>,
    <structfield>tgdeferrable</structfield> et
    <structfield>tginitdeferred</structfield> sont grandement redondants avec
    l'entrée <structname>pg_constraint</structname> référencée. Néanmoins, il
    est possible qu'un trigger non déferrable soit associé à une contrainte
    déferrable&nbsp;: les contraintes de clé étrangère peuvent avoir quelques
    triggers déferrables et quelques triggers non déferrables.
   </para>
  </note>

  <note>
   <para>
    <literal>pg_class.relhastriggers</literal> doit valoir true si la relation
    possède au moins un trigger dans ce catalogue.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-ts-config">
  <title><structname>pg_ts_config</structname></title>

  <indexterm zone="catalog-pg-ts-config">
   <primary>pg_ts_config</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_ts_config</structname> contient des entrées
   représentant les configurations de la recherche plein texte. Une
   configuration spécifie un analyseur et une liste de dictionnaires à
   utiliser pour chacun des types d'éléments en sortie de l'analyseur.
   L'analyseur est présenté dans l'entrée de
   <structname>pg_ts_config</structname> mais la correspondance
   élément/dictionnaire est définie par des entrées supplémentaires dans
   <link
   linkend="catalog-pg-ts-config-map"><structname>pg_ts_config_map</structname></link>.
  </para>

  <para>
   Les fonctionnalités de recherche plein texte de
   <productname>PostgreSQL</productname> sont expliquées en détail dans
   <xref linkend="textsearch"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_ts_config</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>cfgname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la configuration</entry>
     </row>

     <row>
      <entry><structfield>cfgnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       OID du <foreignphrase>namespace</foreignphrase> qui contient la configuration
      </entry>
     </row>

     <row>
      <entry><structfield>cfgowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire de la configuration</entry>
     </row>

     <row>
      <entry><structfield>cfgparser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-parser"><structname>pg_ts_parser</structname></link>.oid</literal></entry>
      <entry>OID de l'analyseur pour la configuration</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-config-map">
  <title><structname>pg_ts_config_map</structname></title>

  <indexterm zone="catalog-pg-ts-config-map">
   <primary>pg_ts_config_map</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_ts_config_map</structname> contient des entrées
   présentant les dictionnaires de recherche plein texte à 
   consulter et l'ordre de consultation, pour chaque type de lexème en sortie de
   chaque analyseur de configuration.
  </para>

  <para>
   Les fonctionnalités de la recherche plein texte de
   <productname>PostgreSQL</productname> sont expliquées en détail dans
   <xref linkend="textsearch"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_ts_config_map</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>mapcfg</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-config"><structname>pg_ts_config</structname></link>.oid</literal></entry>
      <entry>OID de l'entrée <structname>pg_ts_config</structname> qui possède
       l'entrée</entry>
     </row>

     <row>
      <entry><structfield>maptokentype</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Un type de lexème émis par l'analyseur de configuration</entry>
     </row>

     <row>
      <entry><structfield>mapseqno</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Ordre dans lequel consulter l'entrée (les plus petits
       <structfield>mapseqno</structfield> en premier)</entry>
     </row>

     <row>
      <entry><structfield>mapdict</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-dict"><structname>pg_ts_dict</structname></link>.oid</literal></entry>
      <entry>OID du dictionnaire de recherche plein texte à consulter</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-dict">
  <title><structname>pg_ts_dict</structname></title>

  <indexterm zone="catalog-pg-ts-dict">
   <primary>pg_ts_dict</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_ts_dict</structname> contient des entrées
   définissant les dictionnaires de recherche plein texte. Un dictionnaire
   dépend d'un modèle de recherche plein texte qui spécifie toutes les
   fonctions d'implantation nécessaires&nbsp;; le dictionnaire lui-même
   fournit des valeurs pour les paramètres utilisateur
   supportés par le modèle. Cette division du travail permet la création
   de dictionnaires par des utilisateurs non privilégiés. Les paramètres sont
   indiqués par une chaîne, <structfield>dictinitoption</structfield>,
   dont le format et la signification dépendent du modèle.
  </para>

  <para>
   Les fonctionnalités de la recherche plein texte de
   <productname>PostgreSQL</productname> sont expliquées en détail dans
   <xref linkend="textsearch"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_ts_dict</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>dictname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du dictionnaire de recherche plein texte</entry>
     </row>

     <row>
      <entry><structfield>dictnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       OID du <foreignphrase>namespace</foreignphrase> contenant le dictionnaire
      </entry>
     </row>

     <row>
      <entry><structfield>dictowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire du dictionnaire</entry>
     </row>

     <row>
      <entry><structfield>dicttemplate</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-template"><structname>pg_ts_template</structname></link>.oid</literal></entry>
      <entry>OID du modèle de recherche plein texte du dictionnaire</entry>
     </row>

     <row>
      <entry><structfield>dictinitoption</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Chaîne d'options d'initialisation du modèle</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-parser">
  <title><structname>pg_ts_parser</structname></title>

  <indexterm zone="catalog-pg-ts-parser">
   <primary>pg_ts_parser</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_ts_parser</structname> contient des entrées
   définissant les analyseurs de la recherche plein texte. Un analyseur est
   responsable du découpage du texte en entrée en lexèmes et de l'assignation
   d'un type d'élément à chaque lexème. Puisqu'un analyseur doit être
   codé à l'aide de fonctions écrites en langage C, la création de nouveaux
   analyseurs est restreinte aux superutilisateurs des bases de données.
  </para>

  <para>
   Les fonctionnalités de la recherche plein texte de
   <productname>PostgreSQL</productname> sont expliquées en détail dans
   <xref linkend="textsearch"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_ts_parser</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>prsname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de l'analyseur de recherche plein texte</entry>
     </row>

     <row>
      <entry><structfield>prsnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       OID du <foreignphrase>namespace</foreignphrase> qui contient l'analyseur
      </entry>
     </row>

     <row>
      <entry><structfield>prsstart</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID de la fonction de démarrage de l'analyseur</entry>
     </row>

     <row>
      <entry><structfield>prstoken</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID de la fonction next-token de l'analyseur</entry>
     </row>

     <row>
      <entry><structfield>prsend</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID de la fonction d'arrêt de l'analyseur</entry>
     </row>

     <row>
      <entry><structfield>prsheadline</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID de la fonction headline de l'analyseur</entry>
     </row>

     <row>
      <entry><structfield>prslextype</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID de la fonction lextype de l'analyseur</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-template">
  <title><structname>pg_ts_template</structname></title>

  <indexterm zone="catalog-pg-ts-template">
   <primary>pg_ts_template</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_ts_template</structname> contient des entrées
   définissant les modèles de recherche plein texte. Un modèle est
   le squelette d'implantation d'une classe de dictionnaires de recherche
   plein texte. Puisqu'un modèle doit être codé à l'aide de fonctions codées en
   langage C, la création de nouveaux modèles est restreinte aux
   superutilisateurs des bases de données.
  </para>

  <para>
   Les fonctionnalités de la recherche plein texte de
   <productname>PostgreSQL</productname> sont expliquées en détail dans
   <xref linkend="textsearch"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_ts_template</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>tmplname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du modèle de recherche plein texte</entry>
     </row>

     <row>
      <entry><structfield>tmplnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       OID du <foreignphrase>namespace</foreignphrase> qui contient le modèle
      </entry>
     </row>

     <row>
      <entry><structfield>tmplinit</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID de la fonction d'initialisation du modèle</entry>
     </row>

     <row>
      <entry><structfield>tmpllexize</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID de la fonction lexize du modèle</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-type">
  <title><structname>pg_type</structname></title>

  <indexterm zone="catalog-pg-type">
   <primary>pg_type</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_type</structname> stocke les informations
   concernant les
   types de données. Les types basiques et d'énumération (types scalaires) sont créés avec la 
   commande <xref linkend="sql-createtype"/> et les domaines avec
   <xref linkend="sql-createdomain"/>.
   Un type composite est créé automatiquement pour chaque table de la base
   pour représenter la structure des lignes de la table. Il est aussi possible
   de créer des types composites avec <command>CREATE TYPE AS</command>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_type</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>typname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du type</entry>
     </row>

     <row>
      <entry><structfield>typnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       OID du <foreignphrase>namespace</foreignphrase> qui contient le type
      </entry>
     </row>

     <row>
      <entry><structfield>typowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire du type</entry>
     </row>

     <row>
      <entry><structfield>typlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Pour les types de taille fixe, <structfield>typlen</structfield> est le
       nombre d'octets de la représentation interne du type. Mais pour les types
       de longueur variable, <structfield>typlen</structfield> est négatif.
       -1 indique un type <quote>varlena</quote>  (qui a un attribut de longueur),
       -2 indique une chaîne C terminée par le caractère NULL.
      </entry>
     </row>

     <row>
      <entry><structfield>typbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <structfield>typbyval</structfield> détermine si les routines internes
       passent une valeur de ce type par valeur ou par référence.
       <structfield>typbyval</structfield> doit être faux si 
       <structfield>typlen</structfield> ne vaut pas 1, 2 ou 4 (ou 8 sur les
       machines dont le mot-machine est de 8 octets). Les types de longueur
       variable sont toujours passés par référence. 
       <structfield>typbyval</structfield> peut être faux même si la longueur
       permet un passage par valeur.
      </entry>
     </row>

     <row>
      <entry><structfield>typtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>typtype</structfield> vaut <literal>b</literal> pour un
       type de base, <literal>c</literal> pour un type composite
       (le type d'une ligne de table, par exemple),
       <literal>d</literal> pour un domaine,
       <literal>e</literal> pour un enum
       ou <literal>p</literal> pour un pseudo-type. 
       Voir aussi <structfield>typrelid</structfield> et
       <structfield>typbasetype</structfield>.
      </entry>
     </row>

     <row>
      <entry><structfield>typcategory</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>typcategory</structfield> est une classification arbitraire
       de types de données qui est utilisée par l'analyseur pour déterminer
       la conversion implicite devant être <quote>préférée</quote>. Voir
       <xref linkend="catalog-typcategory-table"/>
      </entry>
     </row>

     <row>
      <entry><structfield>typispreferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai si ce type est une cible de conversion préférée dans sa
       <structfield>typcategory</structfield>
      </entry>
     </row>

     <row>
      <entry><structfield>typisdefined</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai si le type est défini et faux s'il ne s'agit que d'un conteneur
       pour un type qui n'est pas encore défini. Lorsque 
       <structfield>typisdefined</structfield> est faux, rien, à part le nom du
       type, le <foreignphrase>namespace</foreignphrase> et l'OID, n'est fiable.
      </entry>
     </row>

     <row>
      <entry><structfield>typdelim</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Caractère qui sépare deux valeurs de ce type lorsque le programme
       lit les valeurs d'un tableau en entrée. Le délimiteur est
       associé au type d'élément du tableau, pas au type tableau.
      </entry>
     </row>

     <row>
      <entry><structfield>typrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       S'il s'agit d'un type composite (voir
       <structfield>typtype</structfield>), alors cette colonne pointe vers la
       ligne de <structname>pg_class</structname> qui définit la table
       correspondante. Pour un type composite sans table, l'entrée dans
       <structname>pg_class</structname> ne représente pas vraiment une table,
       mais elle est néanmoins nécessaire pour trouver les lignes de
       <structname>pg_attribute</structname> liées au type. 0 pour les types
       autres que composites.
      </entry>
     </row>

     <row>
      <entry><structfield>typelem</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       Si <structfield>typelem</structfield> est différent de zéro, alors il identifie
       une autre ligne de <structname>pg_type</structname>. Le type courant peut
       alors être utilisé comme un tableau contenant des valeurs de type
       <structfield>typelem</structfield>. Un <quote>vrai</quote> type tableau a
       une longueur variable (<structfield>typlen</structfield> = -1), mais
       certains types de longueur fixe (<structfield>typlen</structfield> &gt;
       0) ont aussi un <structfield>typelem</structfield> non nul, par exemple 
       <type>name</type> et <type>point</type>. Si un type de longueur fixe 
       a un <structfield>typelem</structfield>, alors sa représentation interne
       est composée d'un certain nombre de valeurs du type
       <structfield>typelem</structfield>, sans autre donnée. Les types de
       données tableau de taille variable ont un en-tête défini par les
       sous-routines de tableau.
       </entry>
     </row>

     <row>
      <entry><structfield>typarray</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       Si <structfield>typarray</structfield> est différent de zéro, alors il
       identifie une autre ligne dans <structname>pg_type</structname>, qui est
       le type tableau <quote>true</quote> disposant de ce type en élément.
      </entry>
     </row>

     <row>
      <entry><structfield>typinput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction de conversion en entrée (format texte)</entry>
     </row>

     <row>
      <entry><structfield>typoutput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction de conversion en sortie (format texte)</entry>
     </row>

     <row>
      <entry><structfield>typreceive</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction de conversion en entrée (format binaire), 
       ou 0 s'il n'y en a pas</entry>
     </row>

     <row>
      <entry><structfield>typsend</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction de conversion en sortie (format binaire), 
       ou 0 s'il n'y en a pas</entry>
     </row>

     <row>
      <entry><structfield>typmodin</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction en entrée de modification du type ou 0 si le type ne
       supporte pas les modificateurs</entry>
     </row>

     <row>
      <entry><structfield>typmodout</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction en sortie de modification du type ou 0 pour utiliser le
       format standard</entry>
     </row>

     <row>
      <entry><structfield>typanalyze</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <command>ANALYZE</command> personnalisée ou 0 pour
        utiliser la fonction standard</entry>
     </row>

     <row>
      <entry><structfield>typalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>

       <structfield>typalign</structfield> est l'alignement requis pour stocker
       une valeur de ce type. Cela s'applique au stockage sur disque ainsi
       qu'à la plupart des représentations de cette valeur dans
       <productname>PostgreSQL</productname>.
       Lorsque des valeurs multiples sont stockées consécutivement, comme dans
       la représentation d'une ligne complète sur disque, un remplissage est 
       inséré avant la donnée de ce type pour qu'elle commence à l'alignement
       indiqué. La référence de l'alignement est le début de la première donnée
       de la séquence.
      </para><para>
       Les valeurs possibles sont&nbsp;:
       <itemizedlist>
        <listitem>
         <para><literal>c</literal> = alignement <type>char</type>, 
          aucun alignement n'est nécessaire&nbsp;;</para>
        </listitem>
        <listitem>
         <para><literal>s</literal> = alignement <type>short</type> (deux octets sur la
          plupart des machines)&nbsp;;</para>
        </listitem>
        <listitem>
         <para><literal>i</literal> = alignement <type>int</type> (quatre octets sur la
          plupart des machines)&nbsp;;</para>
        </listitem>
        <listitem>
         <para><literal>d</literal> = alignement <type>double</type> (huit octets sur
          la plupart des machines, mais pas sur toutes).</para>
        </listitem>
       </itemizedlist>
      </para><note>
       <para>
        Pour les types utilisés dans les tables systèmes il est indispensable
        que les tailles et alignements définis dans
        <structname>pg_type</structname> soient en accord avec la façon dont le 
        compilateur dispose la colonne dans une structure représentant une 
        ligne de table.
       </para>
      </note></entry>
     </row>

     <row>
      <entry><structfield>typstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typstorage</structfield> indique, pour les types varlena 
       (ceux pour lesquels <structfield>typlen</structfield> = -1), si le type
       accepte le TOASTage et la stratégie par défaut à 
       utiliser pour les attributs de ce type. Les valeurs possibles sont&nbsp;:
       <itemizedlist>
        <listitem>
         <para><literal>p</literal>&nbsp;: la valeur doit être stockée
          normalement&nbsp;;</para>
        </listitem>
        <listitem>
         <para>
          <literal>e</literal>&nbsp;: la valeur peut être stockée dans une relation
           <quote>secondaire </quote> (si la relation en a une, voir 
           <literal>pg_class.reltoastrelid</literal>)&nbsp;;
          </para>
        </listitem>
        <listitem>
         <para><literal>m</literal>&nbsp;: la valeur peut être stockée compressée sur
          place&nbsp;;</para>
        </listitem>
        <listitem>
         <para><literal>x</literal>&nbsp;: la valeur peut être stockée compressée sur
          place ou stockée dans une relation <quote>secondaire</quote>.
         </para>
        </listitem>
       </itemizedlist>
       Les colonnes <literal>m</literal> peuvent aussi être déplacées dans 
       une table de stockage secondaire, mais seulement en dernier recours
       (les colonnes <literal>e</literal> et <literal>x</literal> sont
       déplacées les premières).
      </para></entry>
     </row>

     <row>
      <entry><structfield>typnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry><para>
       Représente une contrainte non NULL
       pour le type. Ceci n'est utilisé que pour les domaines.
      </para></entry>
     </row>

     <row>
      <entry><structfield>typbasetype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry><para>
       S'il s'agit d'un domaine (voir <structfield>typtype</structfield>),
       alors <structfield>typbasetype</structfield> identifie le type sur
       lequel celui-ci est fondé. 0 s'il ne s'agit pas d'un domaine.
       </para></entry>
     </row>

     <row>
      <entry><structfield>typtypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       Les domaines utilisent ce champ pour 
       enregistrer le <literal>typmod</literal> à appliquer à leur type de base (-1 si
       le type de base n'utilise pas de <literal>typmod</literal>). -1 si ce type
       n'est pas un domaine.
      </para></entry>
     </row>

     <row>
      <entry><structfield>typndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       Le nombre de dimensions de
       tableau pour un domaine sur un tableau (c'est-à-dire dont
       <structfield>typbasetype</structfield> est un type tableau). 0 pour les
       types autres que les domaines sur des types tableaux.
     </para></entry>
     </row>

     <row>
      <entry><structfield>typcollation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry><para>
       <structfield>typcollation</structfield> spécifie le collationnement
       du type. Si le type ne supporte pas les collationnemens, cette
       colonne vaut zéro. Un type de base qui supporte les collationnements
       aura <symbol>DEFAULT_COLLATION_OID</symbol> ici. Un domaine sur
       un type collationnable peut avoir un autre OID de collationnement
       si ce dernier a été précisé pour le domaine.
      </para></entry>
     </row>

     <row>
      <entry><structfield>typdefaultbin</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry><para>
       Si <structfield>typdefaultbin</structfield> n'est pas NULL, ce champ est la 
       représentation <function>nodeToString()</function> d'une expression par 
       défaut pour le type. Ceci n'est utilisé que pour les domaines.
      </para></entry>
     </row>

     <row>
      <entry><structfield>typdefault</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry><para>
       NULL si le type n'a pas de valeur par
       défaut associée. Si <structfield>typdefaultbin</structfield> est non NULL,
       ce champ doit contenir une version lisible de 
       l'expression par défaut représentée par <structfield>typdefaultbin</structfield>.
       Si <structfield>typdefaultbin</structfield> est NULL et si
       ce champ ne l'est pas, alors il stocke la représentation externe de la valeur par
       défaut du type, qui peut être passée à la fonction de conversion en
       entrée du type pour produire une constante.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <xref linkend="catalog-typcategory-table"/> liste les valeurs de
   <structfield>typcategory</structfield> définies par le système. Tout ajout
   futur à la liste sera aussi une lettre ASCII majuscule. Tous les autres
   caractères ASCII sont réservés pour les catégories définies par l'utilisateur.
  </para>

  <table id="catalog-typcategory-table">
   <title>Codes <structfield>typcategory</structfield></title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>Code</entry>
      <entry>Catégorie</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>A</literal></entry>
      <entry>Types tableaux</entry>
     </row>
     <row>
      <entry><literal>B</literal></entry>
      <entry>Types booléens</entry>
     </row>
     <row>
      <entry><literal>C</literal></entry>
      <entry>Types composites</entry>
     </row>
     <row>
      <entry><literal>D</literal></entry>
      <entry>Types date/time</entry>
     </row>
     <row>
      <entry><literal>E</literal></entry>
      <entry>Types enum</entry>
     </row>
     <row>
      <entry><literal>G</literal></entry>
      <entry>Types géometriques</entry>
     </row>
     <row>
      <entry><literal>I</literal></entry>
      <entry>Types adresses réseau</entry>
     </row>
     <row>
      <entry><literal>N</literal></entry>
      <entry>Types numériques</entry>
     </row>
     <row>
      <entry><literal>P</literal></entry>
      <entry>Pseudo-types</entry>
     </row>
     <row>
      <entry><literal>S</literal></entry>
      <entry>Types chaînes</entry>
     </row>
     <row>
      <entry><literal>T</literal></entry>
      <entry>Types 'Timespan' (étendue de temps, intervalle)</entry>
     </row>
     <row>
      <entry><literal>U</literal></entry>
      <entry>Types définis par l'utilisateur</entry>
     </row>
     <row>
      <entry><literal>V</literal></entry>
      <entry>Types Bit-string</entry>
     </row>
     <row>
      <entry><literal>X</literal></entry>
      <entry>Type <type>unknown</type></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-user-mapping">
  <title><structname>pg_user_mapping</structname></title>

  <indexterm zone="catalog-pg-user-mapping">
   <primary>pg_user_mapping</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_user_mapping</structname> stocke les correspondances
   entre utilisateurs locaux et distants. L'accès à ce catalogue est interdite
   aux utilisateurs normaux, utilisez la vue 
   <link linkend="view-pg-user-mappings"><structname>pg_user_mappings</structname></link>
   à la place.
  </para>

  <table>
   <title>Colonnes de <structname>pg_user_mapping</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Réference</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>umuser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>OID du rôle à faire correspondre, 0 si l'utilisateur à
       correspondre est public.</entry>
     </row>

     <row>
      <entry><structfield>umserver</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.oid</literal></entry>
      <entry>
       L'OID du serveur distant qui contient cette correspondance
      </entry>
     </row>

     <row>
      <entry><structfield>umoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Options spécifiques à la correspondance d'utilisateurs, sous forme de
       chaînes <quote>motclé=valeur</quote>.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="views-overview">
  <title>Vues système</title>

  <para>
   En plus des catalogues système, <productname>PostgreSQL</productname>
   fournit un certain nombre de vues internes. Certaines fournissent un
   moyen simple d'accéder à des requêtes habituellement utilisées
   dans les catalogues systèmes. D'autres vues donnent accès à l'état
   interne du serveur.
  </para>

  <para>
   Le schéma d'information (<xref linkend="information-schema"/>) fournit un autre
   ensemble de vues qui recouvrent les fonctionnalités des vues système. Comme
   le schéma d'information fait parti du standard SQL, alors que les vues décrites ici
   sont spécifiques à <productname>PostgreSQL</productname>, il est généralement
   préférable d'utiliser le schéma d'information si celui-ci apporte toutes les
   informations nécessaires.
  </para>

  <para>
   <xref linkend="view-table"/> liste les vues systèmes décrites plus en
   détails dans la suite du document.
   Il existe de plus
   des vues permettant d'accéder aux résultats du collecteur de
   statistiques&nbsp; elles sont décrites dans le
   <xref linkend="monitoring-stats-views-table"/>.
  </para>

  <para>
   Sauf lorsque c'est indiqué, toutes les vues décrites ici sont en lecture seule.
  </para>

  <table id="view-table">
   <title>Vues système</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>Nom de la vue</entry>
      <entry>But</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="view-pg-available-extensions"><structname>pg_available_extensions</structname></link></entry>
      <entry>extensions disponibles</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-available-extension-versions"><structname>pg_available_extension_versions</structname></link></entry>
      <entry>versions disponibles des extensions</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-cursors"><structname>pg_cursors</structname></link></entry>
      <entry>curseurs ouverts</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-group"><structname>pg_group</structname></link></entry>
      <entry>groupe d'utilisateurs de la base de données</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-indexes"><structname>pg_indexes</structname></link></entry>
      <entry>index</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-locks"><structname>pg_locks</structname></link></entry>
      <entry>verrous posés au moment de la consultation</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-prepared-statements"><structname>pg_prepared_statements</structname></link></entry>
      <entry>instructions préparées</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-prepared-xacts"><structname>pg_prepared_xacts</structname></link></entry>
      <entry>transactions préparées</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-roles"><structname>pg_roles</structname></link></entry>
      <entry>rôles des bases de données</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-rules"><structname>pg_rules</structname></link></entry>
      <entry>règles</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-seclabels"><structname>pg_seclabels</structname></link></entry>
      <entry>labels de sécurité</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-settings"><structname>pg_settings</structname></link></entry>
      <entry>configuration</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-shadow"><structname>pg_shadow</structname></link></entry>
      <entry>utilisateurs des bases de données</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-stats"><structname>pg_stats</structname></link></entry>
      <entry>statistiques du planificateur</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-tables"><structname>pg_tables</structname></link></entry>
      <entry>tables</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-timezone-abbrevs"><structname>pg_timezone_abbrevs</structname></link></entry>
      <entry>abréviations des fuseaux horaires</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-timezone-names"><structname>pg_timezone_names</structname></link></entry>
      <entry>noms des fuseaux horaires</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-user"><structname>pg_user</structname></link></entry>
      <entry>utilisateurs des bases de données</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-user-mappings"><structname>pg_user_mappings</structname></link></entry>
      <entry>user mappings</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-views"><structname>pg_views</structname></link></entry>
      <entry>vues</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-available-extensions">
  <title><structname>pg_available_extensions</structname></title>

  <indexterm zone="view-pg-available-extensions">
   <primary>pg_available_extensions</primary>
  </indexterm>

  <para>
   La vue <structname>pg_available_extensions</structname> liste les
   extensions disponibles pour cette installation. Voir aussi le
   catalogue <link
   linkend="catalog-pg-extension"><structname>pg_extension</structname></link>
   qui affiche les extensions actuellement installées.
  </para>

  <table>
   <title>Colonnes de <structname>pg_available_extensions</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Nom de l'extension</entry>
     </row>

     <row>
      <entry><structfield>default_version</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Nom de la version par défaut, ou <literal>NULL</literal> si
       aucune version n'est indiquée</entry>
     </row>

     <row>
      <entry><structfield>installed_version</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Version actuellement installée pour cette extension, ou
       <literal>NULL</literal> si elle n'est pas installée</entry>
     </row>

     <row>
      <entry><structfield>comment</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Chaîne de commentaire à partir du fichier de contrôle de
       l'extension</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_available_extensions</structname> est en lecture
   seule.
  </para>
 </sect1>

 <sect1 id="view-pg-available-extension-versions">
  <title><structname>pg_available_extension_versions</structname></title>

  <indexterm zone="view-pg-available-extension-versions">
   <primary>pg_available_extension_versions</primary>
  </indexterm>

  <para>
   La vue <structname>pg_available_extension_versions</structname> liste
   les versions spécifiques des extensions disponibles sur cette
   installation. Voir aussi le catalogue <link
   linkend="catalog-pg-extension"><structname>pg_extension</structname></link>
   qui affiche les extensions actuellement installées.
  </para>

  <table>
   <title>Colonnes de <structname>pg_available_extension_versions</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Nom de l'extension</entry>
     </row>

     <row>
      <entry><structfield>version</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Nom de la version</entry>
     </row>

     <row>
      <entry><structfield>installed</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>True si cette version de l'extension est actuellement
       installée</entry>
     </row>

     <row>
      <entry><structfield>superuser</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>True si seuls les superutilisateurs sont autorisés à
       installer cette extension</entry>
     </row>

     <row>
      <entry><structfield>relocatable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>True si l'extension peut être déplacée dans un autre
       schéma</entry>
     </row>

     <row>
      <entry><structfield>schema</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Nom du schéma dans lequel l'extension doit être installée
       ou <literal>NULL</literal> si elle est déplaçable partiellement
       ou complètement</entry>
     </row>

     <row>
      <entry><structfield>requires</structfield></entry>
      <entry><type>name[]</type></entry>
      <entry>Noms des extensions requises, ou <literal>NULL</literal> si
       aucune extension supplémentaire n'est nécessaire</entry>
     </row>

     <row>
      <entry><structfield>comment</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Chaîne de commentaire provenant du fichier de contrôle de
       l'extension</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_available_extension_versions</structname> est
   en lecture seule.
  </para>
 </sect1>

 <sect1 id="view-pg-cursors">
  <title><structname>pg_cursors</structname></title>

  <indexterm zone="view-pg-cursors">
   <primary>pg_cursors</primary>
  </indexterm>

  <para>
   La vue <structname>pg_cursors</structname> liste les curseurs actuellement
   disponibles. Les curseurs peuvent être définis de plusieurs façons&nbsp;:
   <itemizedlist>
    <listitem>
     <para>
      via l'instruction SQL
      <xref linkend="sql-declare"/>&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      via le message Bind du protocole frontend/backend, décrit
      dans le <xref linkend="protocol-flow-ext-query"/>&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      via l'interface de programmation du serveur (SPI), décrite dans le
      <xref linkend="spi-interface"/>.
     </para>
    </listitem>
   </itemizedlist>

   La vue <structname>pg_cursors</structname> affiche les curseurs créés par
   tout moyen précédent. Les curseurs n'existent que pour la durée de la
   transaction qui les définit, sauf s'ils ont été déclarés avec
   <literal>WITH HOLD</literal>. De ce fait, les curseurs volatils
   (<foreignphrase>non-holdable</foreignphrase>) ne sont
   présents dans la vue que jusqu'à la fin de la transaction qui les a créés.

   <note>
    <para>
     Les curseurs sont utilisés en interne pour coder certains
     composants de <productname>PostgreSQL</productname>, comme les langages
     procéduraux. La vue <structname>pg_cursors</structname> peut ainsi
     inclure des curseurs qui n'ont pas été créés explicitement par
     l'utilisateur.
    </para>
   </note>
  </para>

  <table>
   <title>Colonnes de <structname>pg_cursors</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Le nom du curseur</entry>
     </row>

     <row>
      <entry><structfield>statement</structfield></entry>
      <entry><type>text</type></entry>
      <entry>La chaîne utilisée comme requête pour créer le curseur</entry>
     </row>

     <row>
      <entry><structfield>is_holdable</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <literal>true</literal> si le curseur est persistant
       (<foreignphrase>holdable</foreignphrase>)
       (c'est-à-dire s'il peut être accédé après la validation de la transaction
       qui l'a déclaré)&nbsp;; <literal>false</literal> sinon
       </entry>
     </row>

     <row>
      <entry><structfield>is_binary</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <literal>true</literal> si le curseur a été déclaré binaire
       (<literal>BINARY</literal>)&nbsp;; <literal>false</literal>
       sinon
       </entry>
     </row>

     <row>
      <entry><structfield>is_scrollable</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <literal>true</literal> si le curseur autorise une récupération non
       séquentielle des lignes&nbsp;; <literal>false</literal> sinon
       </entry>
     </row>

     <row>
      <entry><structfield>creation_time</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>L'heure à laquelle le curseur a été déclaré</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_cursors</structname> est en lecture seule.
  </para>

 </sect1>

 <sect1 id="view-pg-group">
  <title><structname>pg_group</structname></title>

  <indexterm zone="view-pg-group">
   <primary>pg_group</primary>
  </indexterm>

  <para>
   La vue <structname>pg_group</structname> existe pour des raisons de
   compatibilité ascendante&nbsp;: elle émule un catalogue qui a existé avant
   la version 8.1 de <productname>PostgreSQL</productname>. Elle affiche les
   noms et membres de tous les rôles dont l'attribut
   <structfield>rolcanlogin</structfield> est dévalidé, ce qui est une
   approximation des rôles utilisés comme groupes.
  </para>

  <table>
   <title>Colonnes de <structname>pg_group</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>groname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Nom du groupe</entry>
     </row>

     <row>
      <entry><structfield>grosysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Identifiant du groupe</entry>
     </row>

     <row>
      <entry><structfield>grolist</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Un tableau contenant les identifiants des rôles du
      groupe</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-indexes">
  <title><structname>pg_indexes</structname></title>

  <indexterm zone="view-pg-indexes">
   <primary>pg_indexes</primary>
  </indexterm>

  <para>
   La vue <structname>pg_indexes</structname> fournit un accès aux
   informations utiles sur chaque index de la base de données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_indexes</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.4*"/>
    <colspec colnum="3" colwidth="1.3*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Nom du schéma contenant les tables et index</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Nom de la table portant l'index</entry>
     </row>
     <row>
      <entry><structfield>indexname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Nom de l'index</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>Nom du <foreignphrase>tablespace</foreignphrase> contenant
      l'index (NULL s'il s'agit de celui par défaut pour la base de données)</entry>
     </row>
     <row>
      <entry><structfield>indexdef</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Définition de l'index (une commande <command>CREATE INDEX</command>
       reconstruite)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-locks">
  <title><structname>pg_locks</structname></title>

  <indexterm zone="view-pg-locks">
   <primary>pg_locks</primary>
  </indexterm>

  <para>
   La vue <structname>pg_locks</structname> fournit un accès aux informations
   concernant les verrous détenus par les transactions ouvertes
   sur le serveur de bases de données. Voir le <xref linkend="mvcc"/>
   pour une discussion plus importante sur les verrous.
  </para>

  <para>
   <structname>pg_locks</structname> contient une ligne par objet verrouillable
   actif, type de verrou demandé et transaction associée. Un même
   objet verrouillable peut apparaître plusieurs fois si plusieurs
   transactions ont posé ou attendent des verrous sur celui-ci. Toutefois, un
   objet qui n'est pas actuellement verrouillé n'apparaît pas.
  </para>

  <para>
   Il existe plusieurs types distincts d'objets verrouillables&nbsp;: les
   relations complètes (tables, par exemple), les pages individuelles de
   relations, des tuples individuels de relations, les identifiants de
   transaction (virtuels et permanents) et les objets généraux de la base
   de données (identifiés par
   l'OID de la classe et l'OID de l'objet, de la même façon que dans
   <structname>pg_description</structname> ou
   <structname>pg_depend</structname>). De plus, le droit d'étendre une
   relation est représenté comme un objet verrouillable distinct. Et
   enfin, les verrous informatifs peuvent être pris sur les numéros qui
   ont la signification définie par l'utilisateur.
  </para>

  <table>
   <title>Colonnes <structname>pg_locks</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>locktype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Type de l'objet verrouillable&nbsp;:
       <literal>relation</literal>,
       <literal>extend</literal>,
       <literal>page</literal>,
       <literal>tuple</literal>,
       <literal>transactionid</literal>,
       <literal>virtualxid</literal>,
       <literal>object</literal>,
       <literal>userlock</literal> ou
       <literal>advisory</literal>
      </entry>
     </row>
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>
       L'OID de la base de données dans laquelle existe l'objet, 0 si
       l'objet est partagé ou NULL si l'objet est un identifiant de
       transaction
      </entry>
     </row>
     <row>
      <entry><structfield>relation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       L'OID de la relation ou NULL si l'objet n'est pas une relation ni
       une partie de relation
      </entry>
     </row>
     <row>
      <entry><structfield>page</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>
       Le numéro de page à l'intérieur de cette relation ou NULL si l'objet
       n'est pas un tuple ou une page de relation
      </entry>
     </row>
     <row>
      <entry><structfield>tuple</structfield></entry>
      <entry><type>smallint</type></entry>
      <entry></entry>
      <entry>
       Le numéro du tuple dans la page ou NULL si l'objet n'est pas un tuple
      </entry>
     </row>
     <row>
      <entry><structfield>virtualxid</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       L'identifiant virtuel d'une transaction, ou NULL si l'objet n'est pas un
       identifiant virtuel de transaction
      </entry>
     </row>
     <row>
      <entry><structfield>transactionid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       L'identifiant d'une transaction ou NULL si l'objet n'est pas un
       identifiant de transaction
      </entry>
     </row>
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       L'OID du catalogue système contenant l'objet ou NULL si l'objet n'est
       pas un objet général de la base de données
      </entry>
     </row>
     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>n'importe quelle colonne OID</entry>
      <entry>
       L'OID de l'objet dans son catalogue système ou NULL si l'objet n'est
       pas un objet général de la base de données.
      </entry>
     </row>
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>smallint</type></entry>
      <entry></entry>
      <entry>
       Numéro de la colonne ciblée par le verrou
       (<structfield>classid</structfield> et <structfield>objid</structfield>
       font référence à la table elle-même), ou 0 si la cible est un
       autre objet de la base de données, ou NULL si l'objet n'est pas
       un objet de la base de données.
      </entry>
     </row>
     <row>
      <entry><structfield>virtualtransaction</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       L'identifiant virtuel de la transaction qui détient ou attend le verrou.
      </entry>
     </row>
     <row>
      <entry><structfield>pid</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>
       L'identifiant du processus serveur qui détient ou attend le verrou.
       NULL si le verrou est possédé par une transaction préparée.
      </entry>
     </row>
     <row>
      <entry><structfield>mode</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Nom du type de verrou détenu ou attendu par ce processus (voir la
       <xref linkend="locking-tables"/> et <xref linkend="xact-serializable"/>)</entry>
     </row>
     <row>
      <entry><structfield>granted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry><literal>True</literal> si le verrou est détenu,
      <literal>false</literal> s'il est attendu</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structfield>granted</structfield> est <literal>true</literal> sur une ligne
   représentant un verrou tenu par la transaction indiquée. Une valeur
   <literal>false</literal> indique que cette
   transaction attend l'acquisition du verrou, ce qui implique qu'une autre
   transaction a choisi un mode de verrouillage conflictuel sur le même objet
   verrouillable. La transaction en attente dort jusqu'au relâchement du verrou
   (ou jusqu'à ce qu'une situation de blocage soit détectée). Une transaction
   unique peut attendre l'acquisition d'au plus un verrou à la fois.
  </para>

  <para>
   Chaque transaction détient un verrou exclusif sur son identifiant virtuel de
   transaction pour toute sa durée. Si un identifiant permanent est affecté à
   la transaction (ce qui arrive habituellement si la transaction change l'état
   de la base de données), il détient aussi un verrou exclusif sur son
   identifiant de transaction permanent jusqu'à sa fin. Quand une transaction
   trouve
   nécessaire d'attendre spécifiquement une autre transaction, elle le fait en
   essayant d'acquérir un verrou partagé sur l'identifiant de l'autre
   transaction (identifiant virtuel ou permanent selon la situation).
   Ceci n'est couronné de succès que lorsque l'autre
   transaction termine et relâche son verrou.
  </para>

  <para>
   Bien que les lignes constituent un type d'objet verrouillable, les informations sur
   les verrous de niveau ligne sont stockées sur disque, et non en mémoire.
   Ainsi, les verrous de niveau ligne n'apparaissent normalement pas dans cette
   vue. Si une transaction attend un verrou de niveau ligne, elle
   apparaît sur la vue comme en attente de l'identifiant permanent de la transaction
   actuellement détentrice de ce verrou de niveau ligne.
  </para>

  <para>
   Les verrous consultatifs peuvent être acquis par des clés constituées soit
   d'une seule valeur <type>bigint</type>, soit de deux valeurs
   <type>integer</type>. Une clé <type>bigint</type> est affichée avec
   sa moitié haute dans la colonne <structfield>classid</structfield>, sa
   partie basse dans la colonne <structfield>objid</structfield> et
   <structfield>objsubid</structfield> à 1. Les clés <type>integer</type> sont
   affichées avec la première clé dans la colonne
   <structfield>classid</structfield>, la
   deuxième clé dans la colonne <structfield>objid</structfield> et
   <structfield>objsubid</structfield> à 2. La signification réelle des clés
   est laissée à l'utilisateur. Les verrous consultatifs sont locaux à chaque base,
   la colonne <structfield>database</structfield> a donc un sens dans ce cas.
  </para>

  <para>
   <structname>pg_locks</structname> fournit une vue globale de tous les verrous
   du cluster, pas seulement de ceux de la base en cours d'utilisation. Bien que
   la colonne <structfield>relation</structfield> puisse être jointe avec
   <structname>pg_class</structname>.<structfield>oid</structfield> pour identifier
   les relations verrouillées, ceci ne fonctionne correctement qu'avec les
   relations de la base accédée (celles pour lesquelles la colonne
   <structfield>database</structfield> est l'OID de la base actuelle ou 0).
  </para>

  <para>
   La vue <structname>pg_locks</structname> affiche des données provenant
   du gestionnaire de verrous standards et du gestionnaire de verrous de
   prédicats, qui sont des systèmes autrement séparés. Quand un utilisateur
   accède à cette vue, les structures de données internes de chaque
   gestionnaire de verrous sont temporairement verrouillées, et des copies
   sont faites que la vue va afficher. Chaque gestionnaire de verrous
   produira du coup un ensemble cohérent de résultats mais, comme nous
   ne verrouillons pas les deux gestionnaires simultanément, il est
   possible que des verrous soient donnés ou relachés après avoir
   interrogé le gestionnaire de verrous standard et avant avoir interrogé
   le gestionnaire de verrous de prédicat. Chaque gestionnaire est
   verrouillé le moins de temps possible pour réduire l'impact sur les
   performances mais un impact sur les performances du serveur peut
   néanmoins être observé si la vue est utilisée fréquemment.
  </para>

  <para>
   La colonne
   <structfield>pid</structfield> peut être jointe à la colonne
   <structfield>procpid</structfield> de la vue
   <structname>pg_stat_activity</structname> pour obtenir plus
   d'informations sur la session qui détient ou attend un verrou.
   De plus, si des transactions préparées sont utilisées, la colonne
   <structfield>transaction</structfield> peut être jointe à la colonne
   <structfield>transaction</structfield> de la vue
   <structname>pg_prepared_xacts</structname> pour obtenir plus d'informations
   sur les transactions préparées qui détiennent des verrous. (Une
   transaction préparée ne peut jamais être en attente d'un verrou mais elle
   continue à détenir les verrous qu'elle a acquis pendant son exécution.)
  </para>

 </sect1>

 <sect1 id="view-pg-prepared-statements">
  <title><structname>pg_prepared_statements</structname></title>

  <indexterm zone="view-pg-prepared-statements">
   <primary>pg_prepared_statements</primary>
  </indexterm>

  <para>
   La vue <structname>pg_prepared_statements</structname> affiche toutes les
   instructions préparées disponibles pour la session en cours. Voir
   <xref linkend="sql-prepare"/> pour de plus
   amples informations sur les instructions préparées.
  </para>

  <para>
   <structname>pg_prepared_statements</structname> contient une ligne pour
   chaque instruction préparée. Les lignes sont ajoutées à la vue quand une
   nouvelle instruction préparée est créée et supprimée quand une instruction
   préparée est abandonnée (par exemple, via la commande
   <xref linkend="sql-deallocate"/>).
  </para>

  <table>
   <title>Colonnes de <structname>pg_prepared_statements</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       L'identifiant de l'instruction préparée
      </entry>
     </row>
     <row>
      <entry><structfield>statement</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       La requête soumise par le client pour créer cette instruction
       préparée. Pour les instructions préparées créées en SQL, c'est
       l'instruction <command>PREPARE</command> soumise par le client.
       Pour les instructions préparées créées via le protocole
       frontend/backend, c'est le texte de l'intruction préparée
       elle-même.
      </entry>
     </row>
     <row>
      <entry><structfield>prepare_time</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>
       L'heure de création de l'instruction préparée
      </entry>
     </row>
     <row>
      <entry><structfield>parameter_types</structfield></entry>
      <entry><type>regtype[]</type></entry>
      <entry>
       Les types des paramètres attendus par l'instruction préparée sous la
       forme d'un tableau de <type>regtype</type>. L'OID correspondant à un
       élément de ce tableau peut être obtenu en convertissant la valeur
       <type>regtype</type> en <type>oid</type>.
      </entry>
     </row>
     <row>
      <entry><structfield>from_sql</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <literal>true</literal> si l'instruction préparée a été créée via
       l'instruction SQL <command>PREPARE</command>&nbsp;;
       <literal>false</literal> si l'instruction a été préparée via le protocole
       frontend/backend
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_prepared_statements</structname> est en lecture seule.
  </para>
 </sect1>

 <sect1 id="view-pg-prepared-xacts">
  <title><structname>pg_prepared_xacts</structname></title>

  <indexterm zone="view-pg-prepared-xacts">
   <primary>pg_prepared_xacts</primary>
  </indexterm>

  <para>
   La vue <structname>pg_prepared_xacts</structname> affiche les informations
   concernant les transactions actuellement préparées pour une validation en deux
   phases (voir
   <xref linkend="sql-prepare-transaction"/>
   pour les détails).
  </para>

  <para>
   <structname>pg_prepared_xacts</structname> contient une ligne par
   transaction préparée. L'entrée est supprimée quand la transaction est
   validée ou annulée.
  </para>

  <table>
   <title>Colonnes de <structname>pg_prepared_xacts</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>transaction</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       L'identifiant numérique de la transaction préparée
      </entry>
     </row>
     <row>
      <entry><structfield>gid</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       L'identifiant global de transaction assigné à la transaction
      </entry>
     </row>
     <row>
      <entry><structfield>prepared</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry></entry>
      <entry>
       L'heure de préparation de la transaction pour validation
      </entry>
     </row>
     <row>
      <entry><structfield>owner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>
       Le nom de l'utilisateur qui a exécuté la transaction
      </entry>
     </row>
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.datname</literal></entry>
      <entry>
       Nom de la base de données dans laquelle a été exécutée la transaction
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Lors d'un accès à la vue <structname>pg_prepared_xacts</structname>,
   les structures de données du
   gestionnaire interne des transactions sont momentanément verrouillées et
   une copie de la vue est faite pour affichage. Ceci assure que la vue
   produit un ensemble cohérent de résultats tout en ne bloquant pas les
   opérations normales plus longtemps que nécessaire. Néanmoins, si la vue
   est accédée fréquemment, les performances de la base de données peuvent
   être impactées.
  </para>

 </sect1>


 <sect1 id="view-pg-roles">
  <title><structname>pg_roles</structname></title>

  <indexterm zone="view-pg-roles">
   <primary>pg_roles</primary>
  </indexterm>

  <para>
   La vue <structname>pg_roles</structname> fournit un accès aux informations
   des rôles de base de données. C'est tout simplement une vue accessible
   de <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link> qui
   n'affiche pas le champ du mot de passe.
  </para>

  <para>
   Cette vue expose explicitement la colonne OID de la table sous-jacente car
   elle est nécessaire pour réaliser des jointures avec les autres catalogues.
  </para>

  <table>
   <title>Colonnes de <structname>pg_roles</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rolname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du rôle</entry>
     </row>

     <row>
      <entry><structfield>rolsuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Le rôle est un superutilisateur</entry>
     </row>

     <row>
      <entry><structfield>rolinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Le rôle hérite automatiquement des droits des rôles dont il est
       membre</entry>
     </row>

     <row>
      <entry><structfield>rolcreaterole</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Le rôle peut créer d'autres rôles</entry>
     </row>

     <row>
      <entry><structfield>rolcreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Le rôle peut créer des bases de données</entry>
     </row>

     <row>
      <entry><structfield>rolcatupdate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Le rôle peut mettre à jour explicitement les catalogues système. 
       (Même un superutilisateur ne peut pas le faire si cette colonne n'est
       pas positionnée à <literal>true</literal>.)
      </entry>
     </row>

     <row>
      <entry><structfield>rolcanlogin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Le rôle peut se connecter, c'est-à-dire que ce rôle peut être indiqué
       comme identifiant initial d'autorisation de session.
      </entry>
     </row>

     <row>
      <entry><structfield>rolreplication</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Le rôle est un rôle de réplication. Autrement dit, ce rôle peut
       être utilisé pour lancer une réplication en flux (voir <xref
       linkend="streaming-replication"/>) et peut mettre en place le
       mode de sauvegarde système en utilisant les fonctions
       <function>pg_start_backup</function> et
       <function>pg_stop_backup</function>.
      </entry>
     </row>

     <row>
      <entry><structfield>rolconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour les rôles autorisés à se connecter, ceci indique le nombre
       maximum de connexions concurrentes autorisées par rôle. -1
       signifie qu'il n'y a pas de limite.
      </entry>
     </row>

     <row>
      <entry><structfield>rolpassword</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Ce n'est pas le mot de passe (toujours
        <literal>********</literal>)</entry>
     </row>

     <row>
      <entry><structfield>rolvaliduntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry></entry>
      <entry>Estampille temporelle d'expiration du mot de passe (utilisée
       uniquement pour l'authentification par mot de passe)&nbsp;; NULL s'il
       est indéfiniment valable</entry>
     </row>

     <row>
      <entry><structfield>rolconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Valeurs par défaut de certaines variables spécifiques pour
       ce rôle</entry>
     </row>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Identifiant du rôle</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-rules">
  <title><structname>pg_rules</structname></title>

  <indexterm zone="view-pg-rules">
   <primary>pg_rules</primary>
  </indexterm>

  <para>
   La vue <structname>pg_rules</structname> fournit un accès à des informations
   utiles sur les règles de réécriture des requêtes.
  </para>

  <table>
   <title>Colonnes de <structname>pg_rules</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Nom du schéma contenant la table</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Nom de la table pour laquelle est créée la règle</entry>
     </row>
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link>.rulename</literal></entry>
      <entry>Nom de la règle</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Définition de la règle (une commande de création reconstruite)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_rules</structname> exclut les règles <literal>ON SELECT</literal>
   des vues&nbsp;; elles sont accessibles dans <structname>pg_views</structname>.
  </para>

 </sect1>

 <sect1 id="view-pg-seclabels">
  <title><structname>pg_seclabels</structname></title>

  <indexterm zone="view-pg-seclabels">
   <primary>pg_seclabels</primary>
  </indexterm>

  <para>
   La vue <structname>pg_seclabels</structname> fournit des informations
   sur les labels de sécurité. C'est une version du catalogue
   <link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>
   bien plus lisible.
  </para>

  <table>
   <title>Colonnes de <structname>pg_seclabels</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Référence</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>L'OID de l'objet concerné par ce label de sécurité</entry>
     </row>
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>L'OID du catalogue système où cet objet apparaît</entry>
     </row>
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour un label de sécurité sur une colonne d'une table, cette
       colonne correspond au numéro de colonne (les colonnes
       <structfield>objoid</structfield> et
       <structfield>classoid</structfield> font référence à la table).
       Pour tous les autres types d'objets, cette colonne vaut zéro.
      </entry>
     </row>
     <row>
      <entry><structfield>objtype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
         Le type d'objet auquel s'applique ce label, en texte.
      </entry>
     </row>
     <row>
      <entry><structfield>objnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       L'OID du schéma de cet objet si applicable&nbsp;; NULL dans les
       autres cas.
      </entry>
     </row>
     <row>
      <entry><structfield>objname</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Le nom de l'objet auquel s'applique ce label, en texte.
      </entry>
     </row>
     <row>
      <entry><structfield>provider</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>.provider</literal></entry>
      <entry>Le fournisseur associé à ce label.</entry>
     </row>
     <row>
      <entry><structfield>label</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>.label</literal></entry>
      <entry>Le label de sécurité appliqué à cet objet.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-settings">
  <title><structname>pg_settings</structname></title>

  <indexterm zone="view-pg-settings">
   <primary>pg_settings</primary>
  </indexterm>

  <para>
   La vue <structname>pg_settings</structname> fournit un accès aux paramètres
   d'exécution du serveur. C'est essentiellement une interface alternative aux
   commandes <xref linkend="sql-show"/> et <xref linkend="sql-set"/>. Elle fournit
   aussi un accès à certaines informations des paramètres qui ne sont pas directement
   accessibles avec <command>SHOW</command>, telles que les valeurs minimales et maximales.
  </para>

  <table>
   <title>Colonnes de <structname>pg_settings</structname></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Nom du paramètre d'exécution</entry>
     </row>
     <row>
      <entry><structfield>setting</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Valeur actuelle du paramètre</entry>
     </row>
     <row>
      <entry><structfield>unit</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Unité implicite du paramètre</entry>
     </row>
     <row>
      <entry><structfield>category</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Groupe logique du paramètre</entry>
     </row>
     <row>
      <entry><structfield>short_desc</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Description brève du paramètre</entry>
     </row>
     <row>
      <entry><structfield>extra_desc</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Information supplémentaire, plus détaillée, sur le paramètre</entry>
     </row>
     <row>
      <entry><structfield>context</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Contexte requis pour positionner la valeur du paramètre (voir
       ci-dessous)</entry>
     </row>
     <row>
      <entry><structfield>vartype</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Type du paramètre (<literal>bool</literal>,
       <literal>enum</literal>,
       <literal>integer</literal>,
       <literal>real</literal> ou <literal>string</literal>)
      </entry>
     </row>
     <row>
      <entry><structfield>source</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Source de la valeur du paramètre actuel</entry>
     </row>
     <row>
      <entry><structfield>min_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Valeur minimale autorisée du paramètre (NULL pour les valeurs non
       numériques)</entry>
     </row>
     <row>
      <entry><structfield>max_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Valeur maximale autorisée du paramètre (NULL pour les valeurs non
       numériques)</entry>
     </row>
     <row>
      <entry><structfield>enumvals</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry>Valeurs autorisées pour un paramètre enum (NULL pour les valeurs
       non enum)</entry>
     </row>
     <row>
      <entry><structfield>boot_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Valeur de paramètre prise au démarrage du serveur si le paramètre
      n'est pas positionné d'une autre façon</entry>
     </row>
     <row>
      <entry><structfield>reset_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Valeur à laquelle <command>RESET</command> ramènerait le paramètre
      dans la session courante</entry>
     </row>
     <row>
      <entry><structfield>sourcefile</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Fichier de configuration dans lequel ce fichier a été positionné
      (NULL pour les valeurs positionnées ailleurs que dans un fichier de
      configuration, ou quand interrogé par un utilisateur standard).
      Pratique quand on utilise des directives d'inclusion de configuration</entry>
     </row>
     <row>
      <entry><structfield>sourceline</structfield></entry>
      <entry><type>integer</type></entry>
      <entry>Numéro de ligne du fichier de configuration à laquelle cette
      valeur a été positionnée (NULL pour des valeurs positionnées ailleurs
      que dans un fichier de configuration, ou quand interrogé par un
      non-superutilisateur).
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  
  <para>
   Il existe différentes valeurs de <structfield>context</structfield>.
   Les voici, classées dans l'ordre de difficulté décroissante pour la
   modification d'un paramètre&nbsp;:
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>internal</literal></term>
    <listitem>
     <para>
      Ces paramètres ne peuvent pas être modifiés directement&nbsp;; ils
      reflètent des valeurs internes. Certaines sont modifiables en
      compilant le serveur avec des options différentes pour l'étape
      de configuration, ou en changeant des options lors de l'étape du
      <command>initdb</command>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>postmaster</literal></term>
    <listitem>
     <para>
      Ces paramètres sont seulement appliqués au démarrage du serveur,
      donc toute modification nécessite un redémarrage du serveur. Les
      valeurs sont typiquement conservées dans le fichier
      <filename>postgresql.conf</filename> ou passées sur la ligne de
      commande lors du lancement du serveur. Bien sûr, tout paramètre
      dont la colonne <structfield>context</structfield> est inférieure
      peut aussi être configuré au démarrage du serveur.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>sighup</literal></term>
    <listitem>
     <para>
      Les modifications sur ces paramètres peuvent se faire dans le
      fichier <filename>postgresql.conf</filename> sans avoir à
      redémarrer le serveur. L'envoi d'un signal
      <systemitem>SIGHUP</systemitem> au processus père (historiquement
      appelé postmaster) le forcera à relire le fichier
      <filename>postgresql.conf</filename> et à appliquer les
      modifications. Ce processus enverra aussi le signal 
      <systemitem>SIGHUP</systemitem> aux processus fils pour qu'ils
      tiennent compte des nouvelles valeurs.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>backend</literal></term>
    <listitem>
     <para>
      Les modifications sur ces paramètres peuvent se faire dans le
      fichier <filename>postgresql.conf</filename> sans avoir à
      redémarrer le serveur&nbsp;; ils peuvent aussi être configurés
      pour une session particulière dans le paquet de demande de
      connexion (par exemple, via la variable d'environnement
      <literal>PGOPTIONS</literal> gérée par la bibliothèque
      <application>libpq</application>). Néanmoins, ces modifications ne
      changent jamais une fois que la session a démarré. Si vous les
      changez dans le fichier <filename>postgresql.conf</filename>,
      envoyez un signal <systemitem>SIGHUP</systemitem> à postmaster
      car ça le forcera à relire le fichier
      <filename>postgresql.conf</filename>. Les nouvelles valeurs
      affecteront seulement les sessions lancées après la relecture de
      la configuration.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>superuser</literal></term>
    <listitem>
     <para>
      Ces paramètres sont configurables partir du fichier
      <filename>postgresql.conf</filename> ou à l'intérieur d'une
      session via la commande <command>SET</command>&nbsp;; mais seuls
      les superutilisateurs peuvent les modifier avec
      <command>SET</command>. Les modifications apportées dans le fichier
      <filename>postgresql.conf</filename> affecteront aussi les
      sessions existantes si aucune valeur locale à la session n'a été
      établie avec une commande <command>SET</command>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>user</literal></term>
    <listitem>
     <para>
      Ces paramètres peuvent être configurés à partir du fichier
      <filename>postgresql.conf</filename> ou à l'intérieur d'une session
      via la commande <command>SET</command>. Tout utilisateur est
      autorisé à modifier la valeur sur sa session. les modifi Any user is
      allowed to change his session-local value. Les modifications
      apportées dans le fichier <filename>postgresql.conf</filename>
      affecteront aussi les sessions existantes si aucune valeur locale
      à la session n'a été établie avec une commande
      <command>SET</command>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Voir <xref linkend="config-setting"/> pour plus d'informations sur les
   différentes façons de modifier ces paramètres.
  </para>

  <para>
   La vue <structname>pg_settings</structname> n'accepte ni insertion ni
   suppression mais peut être actualisée. Une requête <command>UPDATE</command>
   appliquée
   à une ligne de <structname>pg_settings</structname> est équivalente à
   exécuter la commande <xref linkend="sql-set"/>
   sur ce paramètre. Le changement affecte uniquement la valeur utilisée
   par la session en cours. Si un <command>UPDATE</command> est lancé à
   l'intérieur d'une transaction annulée par la suite, les effets de la
   commande <command>UPDATE</command> disparaissent à l'annulation de la
   transaction. Lorsque la transaction est validée, les effets
   persistent jusqu'à la fin de la session, à moins qu'un autre
   <command>UPDATE</command> ou <command>SET</command> ne modifie la valeur.
  </para>

 </sect1>

 <sect1 id="view-pg-shadow">
  <title><structname>pg_shadow</structname></title>

  <indexterm zone="view-pg-shadow">
   <primary>pg_shadow</primary>
  </indexterm>

  <para>
   La vue <structname>pg_shadow</structname> existe pour des raisons de
   compatibilité ascendante&nbsp;: elle émule un catalogue qui a existé avant
   la version 8.1 de <productname>PostgreSQL</productname>. Elle affiche les
   propriétés de tous les rôles marqués <structfield>rolcanlogin</structfield>
   dans <link
   linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.
  </para>

  <para>
   Cette table tire son nom de la nécessité de ne pas être publiquement
   lisible, car elle contient les mots de passe.
   <link linkend="view-pg-user"><structname>pg_user</structname></link>
   est une vue sur <structname>pg_shadow</structname>, publiquement
   accessible, car elle masque le contenu du champ de mot de passe.
  </para>

  <table>
   <title>Colonnes de <structname>pg_shadow</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Nom de l'utilisateur</entry>
     </row>

     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Identifiant de l'utilisateur</entry>
     </row>

     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>L'utilisateur peut créer des bases de données</entry>
     </row>

     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>L'utilisateur est un superutilisateur</entry>
     </row>

     <row>
      <entry><structfield>usecatupd</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       L'utilisateur peut mettre à jour les catalogues système. (Même un
       superutilisateur ne peut pas le faire si cette colonne ne vaut pas
       <literal>true</literal>.)
      </entry>
     </row>

     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Mot de passe (éventuellement chiffré)&nbsp;; NULL si aucun. Voir
      <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>
      pour des détails sur le stockage des mots de passe chiffrés.</entry>
     </row>

     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>abstime</type></entry>
      <entry></entry>
      <entry>Estampille temporelle d'expiration du mot de passe (utilisée
      uniquement pour l'authentification par mot de passe)</entry>
     </row>

     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Valeurs de session par défaut des variables de configuration
        </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-stats">
  <title><structname>pg_stats</structname></title>

  <indexterm zone="view-pg-stats">
   <primary>pg_stats</primary>
  </indexterm>

  <para>
   La vue <structname>pg_stats</structname> fournit un accès aux informations
   stockées dans la table système
   <link linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link>.
   Cette vue n'autorise l'accès qu'aux seules lignes de
   <structname>pg_statistic</structname> correspondant aux tables sur
   lesquelles l'utilisateur a un droit de lecture. Elle peut donc sans
   risque être publiquement accessible en lecture.
  </para>

  <para>
   <structname>pg_stats</structname> est aussi conçue pour afficher l'information
   dans un format plus lisible que le catalogue sous-jacent &mdash; au prix de
   l'extension du schéma lorsque de nouveaux types de connecteurs sont définis dans
   <structname>pg_statistic</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_stats</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Nom du schéma contenant la table</entry>
     </row>

     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attname</literal></entry>
      <entry>Nom de la colonne décrite par la ligne</entry>
     </row>

     <row>
      <entry><structfield>inherited</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Si vrai, cette ligne inclut les colonnes enfant de l'héritage,
       pas seulement les valeurs de la table spécifiée</entry>
     </row>

     <row>
      <entry><structfield>null_frac</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>Fraction d'entrées de colonnes qui sont NULL</entry>
     </row>

     <row>
      <entry><structfield>avg_width</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Largeur moyenne en octets des entrées de la colonne</entry>
     </row>

     <row>
      <entry><structfield>n_distinct</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>Si positif, nombre estimé de valeurs distinctes dans
      la colonne. Si négatif, nombre de valeurs distinctes divisé par le
      nombre de lignes, le tout muliplié par -1. (La forme négative est utilisée
      quand <command>ANALYZE</command> croit que le nombre de valeurs distinctes a
      tendance à grossir au fur et à mesure que la table grossit&nbsp;; la forme
      positive est utilisée lorsque la commande semble avoir un nombre fixe de
      valeurs possibles.) Par exemple, -1 indique une colonne unique pour
      laquelle le nombre de valeurs distinctes est identique au nombre de
      lignes.
      </entry>
     </row>

     <row>
      <entry><structfield>most_common_vals</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>Liste de valeurs habituelles de la colonne. (NULL si
       aucune valeur ne semble identique aux autres.)
       Pour certains types de données comme <type>tsvector</type>, c'est une
       liste d'éléments les plus fréquents, plutôt que des valeurs du type
       lui-même.
       </entry>
     </row>

     <row>
      <entry><structfield>most_common_freqs</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>Liste de fréquences des valeurs ou éléments les plus courants,
       c'est-à-dire le nombre d'occurrences de chacune divisé par le nombre
       total de lignes. (NULL lorsque
       <structfield>most_common_vals</structfield> l'est.)
       Pour certains types de données comme <type>tsvector</type>, il peut
       aussi stocker des informations supplémentaires, le rendant plus long
       que le tableau <structfield>most_common_vals</structfield>.
     </entry>
     </row>

     <row>
      <entry><structfield>histogram_bounds</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>Liste de valeurs qui divisent les valeurs de la colonne en
       groupes de population approximativement identiques. Les valeurs dans
       <structfield>most_common_vals</structfield>, s'il y en a, sont omises de ce
       calcul d'histogramme. (Cette colonne est NULL si le type de données de la
       colonne ne dispose pas de l'opérateur <literal>&lt;</literal> ou si la liste
       <structfield>most_common_vals</structfield> compte la population complète.)
      </entry>
     </row>

     <row>
      <entry><structfield>correlation</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>Corrélation statistique entre l'ordre physique des lignes et
       l'ordre logique des valeurs de la colonne. Ceci va de -1 à +1. Lorsque la
       valeur est proche de -1 ou +1, un parcours de l'index sur la colonne
       est estimé moins coûteux que si cette valeur tend vers 0, à cause de la
       réduction du nombre d'accès aléatoires au disque. (Cette colonne est NULL si le type
       de données de la colonne ne dispose pas de l'opérateur <literal>&lt;</literal>.)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Le nombre maximum d'entrées dans <structfield>most_common_vals</structfield>
   et <structfield>histogram_bounds</structfield> est configurable colonne par colonne en
   utilisant la commande <command>ALTER TABLE SET STATISTICS</command> ou globalement
   avec le paramètre d'exécution <xref linkend="guc-default-statistics-target"/>.
  </para>

 </sect1>

 <sect1 id="view-pg-tables">
  <title><structname>pg_tables</structname></title>

  <indexterm zone="view-pg-tables">
   <primary>pg_tables</primary>
  </indexterm>

  <para>
   La vue <structname>pg_tables</structname> fournit un accès aux informations
   utiles de chaque table de la base de données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_tables</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Nom du schéma qui possède la table</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Nom de la table</entry>
     </row>
     <row>
      <entry><structfield>tableowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Nom du propriétaire de la table</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link
       linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>Nom du <foreignphrase>tablespace</foreignphrase> qui contient
      la table (NULL s'il s'agit du
      <foreignphrase>tablespace</foreignphrase> par défaut de la base)</entry>
     </row>
     <row>
      <entry><structfield>hasindexes</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasindex</literal></entry>
      <entry>Vrai si la table comporte (ou a récemment comporté) des index</entry>
     </row>
     <row>
      <entry><structfield>hasrules</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasrules</literal></entry>
      <entry>Vrai si la table dispose (ou disposait) de règles</entry>
     </row>
     <row>
      <entry><structfield>hastriggers</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.reltriggers</literal></entry>
      <entry>Vrai si la table dispose (ou disposait) de déclencheurs</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-timezone-abbrevs">
  <title><structname>pg_timezone_abbrevs</structname></title>

  <indexterm zone="view-pg-timezone-abbrevs">
   <primary>pg_timezone_abbrevs</primary>
  </indexterm>

  <para>
   La vue <structname>pg_timezone_abbrevs</structname> fournit la liste des
   abréviations de fuseaux horaires actuellement reconnues par les routines
   de saisie date/heure. Le contenu de cette vue change avec la modification
   du paramètre d'exécution <xref linkend="guc-timezone-abbreviations"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_timezone_abbrevs</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>abbrev</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Abréviation du fuseau horaire</entry>
     </row>
     <row>
      <entry><structfield>utc_offset</structfield></entry>
      <entry><type>interval</type></entry>
      <entry>Décalage de l'UTC (positif signifiant à l'est de Greenwich)</entry>
     </row>
     <row>
      <entry><structfield>is_dst</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal>true</literal> s'il s'agit d'une abréviation de fuseau
      horaire soumis aux changements d'heure hiver/été</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-timezone-names">
  <title><structname>pg_timezone_names</structname></title>

  <indexterm zone="view-pg-timezone-names">
   <primary>pg_timezone_names</primary>
  </indexterm>

<!-- DST : Daylight Saving Time -->
  <para>
   La vue <structname>pg_timezone_names</structname> fournit la liste des
   noms de fuseaux horaires reconnus par <command>SET TIMEZONE</command>,
   avec les abréviations acceptées, les décalages UTC, et l'état du changement
   d'heure. (Techniquement, <productname>PostgreSQL</productname> utilise
   <acronym>UT1</acronym> plutôt que UTC car les secondes intercalaires
   ne sont pas gérées.) Contrairement aux abréviations indiquées dans
   <link linkend="view-pg-timezone-abbrevs"><structname>pg_timezone_abbrevs</structname></link>,
   la majorité des noms impliquent des règles concernant les dates de
   changement d'heure. De ce fait, l'information associée change en fonction
   des frontières de changement d'heure locales.
   L'information affichée est calculée suivant la valeur
   courante de <function>CURRENT_TIMESTAMP</function>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_timezone_names</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Nom du fuseau horaire</entry>
     </row>
     <row>
      <entry><structfield>abbrev</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Abréviation du fuseau horaire</entry>
     </row>
     <row>
      <entry><structfield>utc_offset</structfield></entry>
      <entry><type>interval</type></entry>
      <entry>Décalage à partir d'UTC (positif signifiant à l'est de Greenwich)</entry>
     </row>
     <row>
      <entry><structfield>is_dst</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal>true</literal> si les changements d'heure hiver/été
       sont suivis</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-user">
  <title><structname>pg_user</structname></title>

  <indexterm zone="view-pg-user">
   <primary>pg_user</primary>
  </indexterm>

  <para>
   La vue <structname>pg_user</structname> fournit un accès aux informations
   concernant les utilisateurs de la base de données. C'est une simple vue
   publiquement lisible de
   <link linkend="view-pg-shadow"><structname>pg_shadow</structname></link>
   qui masque la valeur du champ de mot de passe.
  </para>

  <table>
   <title>Colonnes de <structname>pg_user</structname></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Nom de l'utilisateur</entry>
     </row>

     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry>Identifiant de l'utilisateur (un nombre arbitraire utilisé en
       référence à cet utilisateur)</entry>
     </row>

     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>L'utilisateur peut créer des bases de données</entry>
     </row>

     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>L'utilisateur est un superutilisateur</entry>
     </row>

     <row>
      <entry><structfield>usecatupd</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       L'utilisateur peut mettre à jour les tables systèmes. (Même un
       superutilisateur ne peut pas le faire si cette colonne n'est
       pas positionnée à <literal>true</literal>.)
      </entry>
     </row>

     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Ce n'est pas le mot de passe (toujours <literal>********</literal>)</entry>
     </row>

     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>abstime</type></entry>
      <entry>Estampille temporelle d'expiration du mot de passe (utilisée
      uniquement pour l'authentification par mot de passe)</entry>
     </row>

     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry>Variables d'exécution par défaut de la session</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-user-mappings">
  <title><structname>pg_user_mappings</structname></title>

  <indexterm zone="view-pg-user-mappings">
   <primary>pg_user_mappings</primary>
  </indexterm>

  <para>
   La vue <structname>pg_user_mappings</structname> donne accès aux informations
   sur les correspondances d'utilisateurs. C'est essentiellement une vue
   accessible à tous sur
   <link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link>
   qui cache le champ d'options si l'utilisateur n'a pas le droit de l'utiliser.
  </para>

  <table>
   <title>Colonnes de <structname>pg_user_mappings</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Réference</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>umid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link>.oid</literal></entry>
      <entry>OID de la correspondance d'utilisateur</entry>
     </row>

     <row>
      <entry><structfield>srvid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.oid</literal></entry>
      <entry>
       OID du serveur distant qui contient cette correspondance
      </entry>
     </row>

     <row>
      <entry><structfield>srvname</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Nom du serveur distant
      </entry>
     </row>

     <row>
      <entry><structfield>umuser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>OID du rôle local mis en correspondance, 0 si la correspondance d'utilisateur est public</entry>
     </row>

     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de l'utilisateur local à mettre en correspondance</entry>
     </row>

     <row>
      <entry><structfield>umoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Options spécifiques à la correspondance d'utilisateurs, sous la forme
       de chaînes <quote>motclé=valeur</quote>, si l'utilisateur courant est
       le propriétaire du serveur distant, sinon null.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="view-pg-views">
  <title><structname>pg_views</structname></title>

  <indexterm zone="view-pg-views">
   <primary>pg_views</primary>
  </indexterm>

  <para>
   La vue <structname>pg_views</structname> donne accès à des informations utiles
   à propos de chaque vue de la base.
  </para>

  <table>
   <title>Colonnes de <structname>pg_views</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Nom du schéma contenant la vue</entry>
     </row>
     <row>
      <entry><structfield>viewname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Nom de la vue</entry>
     </row>
     <row>
      <entry><structfield>viewowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Nom du propriétaire de la vue</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Définition de la vue (une requête <command>SELECT</command> reconstruite)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

</chapter>
