<?xml version="1.0" encoding="UTF-8"?>
<chapter id="catalogs">
 <title>Catalogues système</title>

 <para>
  Les catalogues système représentent l'endroit où une base de données relationnelle
  stocke les métadonnées des schémas, telles que les informations sur les tables
  et les colonnes, et des données de suivi interne.
  Les catalogues système de <productname>PostgreSQL</productname> sont de
  simples tables. Elles peuvent être supprimées et recrées. Il est possible
  de leur ajouter des colonnes, d'y insérer et modifier des valeurs, et de
  mettre un joyeux bazar dans le système. En temps normal, l'utilisateur n'a aucune
  raison de modifier les catalogues
  système, il y a toujours des commandes SQL pour le faire. (Par
  exemple, <command>CREATE DATABASE</command> insère une ligne dans le
  catalogue <structname>pg_database</structname> &mdash; et crée physiquement
  la base de données sur le disque.) Il y a des exceptions pour certaines
  opérations particulièrement ésotériques, mais au fil du temps la plupart de
  ces opérations ont été mises à disposition sous la forme de commandes SQL. De
  ce fait, le besoin de modifier directement les catalogues systèmes est de plus
  en plus faible. 
 </para>

 <sect1 id="catalogs-overview">
  <title>Aperçu</title>

  <para>
   <xref linkend="catalog-table"/> liste les catalogues système.
   Une documentation plus détaillée des catalogues système suit.
  </para>

  <para>
   La plupart des catalogues système sont recopiés de la base de données modèle
   lors de la création de la base de données et deviennent alors spécifiques à
   chaque base de données. Un petit nombre de catalogues sont physiquement
   partagés par toutes les bases de données d'une installation de
   <productname>PostgreSQL</productname>. Ils sont indiqués dans les
   descriptions des catalogues.
  </para>

  <table id="catalog-table">
   <title>Catalogues système</title>

   <tgroup cols="2">
    <colspec colnum="1" colwidth="1*"/>
    <colspec colnum="2" colwidth="2*"/>
    <thead>
     <row>
      <entry>Nom du catalogue</entry>
      <entry>Contenu</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="catalog-pg-aggregate"><structname>pg_aggregate</structname></link></entry>
      <entry>fonctions d'agrégat</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-am"><structname>pg_am</structname></link></entry>
      <entry>méthodes d'accès aux relations</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amop"><structname>pg_amop</structname></link></entry>
      <entry>opérateurs des méthodes d'accès</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link></entry>
      <entry>fonctions de support des méthodes d'accès</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attrdef"><structname>pg_attrdef</structname></link></entry>
      <entry>valeurs par défaut des colonnes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link></entry>
      <entry>colonnes des tables (<quote>attributs</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link></entry>
      <entry>identifiants d'autorisation (rôles)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link></entry>
      <entry>relations d'appartenance aux identifiants d'autorisation</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-cast"><structname>pg_cast</structname></link></entry>
      <entry>conversions de types de données (<foreignphrase>cast</foreignphrase>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-class"><structname>pg_class</structname></link></entry>
      <entry>tables, index, séquences, vues (<quote>relations</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link></entry>
      <entry>collationnement (information locale)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link></entry>
      <entry>contraintes de vérification, contraintes uniques, contraintes de clés primaires, contraintes de clés étrangères</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-conversion"><structname>pg_conversion</structname></link></entry>
      <entry>informations de conversions de codage</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-database"><structname>pg_database</structname></link></entry>
      <entry>bases de données du cluster <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-db-role-setting"><structname>pg_db_role_setting</structname></link></entry>
      <entry>configuration par rôle et par base de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-default-acl"><structname>pg_default_acl</structname></link></entry>
      <entry>droits par défaut sur des types d'objets</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-depend"><structname>pg_depend</structname></link></entry>
      <entry>dépendances entre objets de la base de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-description"><structname>pg_description</structname></link></entry>
      <entry>descriptions ou commentaires des objets de base de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-enum"><structname>pg_enum</structname></link></entry>
      <entry>définitions des labels et des valeurs des enum</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-event-trigger"><structname>pg_event_trigger</structname></link></entry>
      <entry>triggers sur événement</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-extension"><structname>pg_extension</structname></link></entry>
      <entry>extensions installées</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-foreign-data-wrapper"><structname>pg_foreign_data_wrapper</structname></link></entry>
      <entry>définitions des wrappers de données distantes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link></entry>
      <entry>définitions des serveurs distants</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-foreign-table"><structname>pg_foreign_table</structname></link></entry>
      <entry>informations supplémentaires sur les tables distantes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-index"><structname>pg_index</structname></link></entry>
      <entry>informations supplémentaires des index</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-inherits"><structname>pg_inherits</structname></link></entry>
      <entry>hiérarchie d'héritage de tables</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-init-privs"><structname>pg_init_privs</structname></link></entry>
      <entry>droits initiaux des objets</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-language"><structname>pg_language</structname></link></entry>
      <entry>langages d'écriture de fonctions</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link></entry>
      <entry>pages de données pour les «&nbsp;Large Objects&nbsp;»</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link></entry>
      <entry>métadonnées pour les «&nbsp;Large Objects&nbsp;»</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link></entry>
      <entry>schémas</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link></entry>
      <entry>classes d'opérateurs de méthodes d'accès</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link></entry>
      <entry>opérateurs</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link></entry>
      <entry>familles d'opérateurs de méthodes d'accès</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-parameter-acl"><structname>pg_parameter_acl</structname></link></entry>
      <entry>paramètres de configuration pour lesquels des droits ont été donnés</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-partitioned-table"><structname>pg_partitioned_table</structname></link></entry>
      <entry>clés de partitionnement des tables</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-policy"><structname>pg_policy</structname></link></entry>
      <entry>politiques de sécurité niveau ligne</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link></entry>
      <entry>fonctions et procédures</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-publication"><structname>pg_publication</structname></link></entry>
      <entry>publications pour la réplication logique</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-publication-namespace"><structname>pg_publication_namespace</structname></link></entry>
      <entry>correspondance schéma publication</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-publication-rel"><structname>pg_publication_rel</structname></link></entry>
      <entry>correspondance relation-publication</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-range"><structname>pg_range</structname></link></entry>
      <entry>informations sur les types d'intervalles de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-replication-origin"><structname>pg_replication_origin</structname></link></entry>
      <entry>origines de réplication enregistrées</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link></entry>
      <entry>règles de réécriture de requêtes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link></entry>
      <entry>labels de sécurité sur les objets d'une base de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-sequence"><structname>pg_sequence</structname></link></entry>
      <entry>séquences</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link></entry>
      <entry>dépendances sur les objets partagés</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link></entry>
      <entry>commentaires sur les objets partagés</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shseclabel"><structname>pg_shseclabel</structname></link></entry>
      <entry>labels de sécurité sur des objets partagés</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link></entry>
      <entry>statistiques de l'optimiseur de requêtes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-statistic-ext"><structname>pg_statistic_ext</structname></link></entry>
      <entry>statistiques étendues de l'optimiseur de requêtes (définitions)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-statistic-ext-data"><structname>pg_statistic_ext_data</structname></link></entry>
      <entry>statistiques étendues de l'optimiseur de requêtes (statistiques)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-subscription"><structname>pg_subscription</structname></link></entry>
      <entry>souscriptions pour la réplication logique</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-subscription-rel"><structname>pg_subscription_rel</structname></link></entry>
      <entry>état des relations pour les souscriptions</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link></entry>
      <entry><foreignphrase>tablespaces</foreignphrase> du cluster de bases de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-transform"><structname>pg_transform</structname></link></entry>
      <entry>transformations (conversions de types de données vers les langages procéduraux)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link></entry>
      <entry>triggers</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-config"><structname>pg_ts_config</structname></link></entry>
      <entry>configuration de la recherche plein texte</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-config-map"><structname>pg_ts_config_map</structname></link></entry>
      <entry>configuration de la recherche plein texte pour la correspondance
       des lexèmes (<foreignphrase>token</foreignphrase>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-dict"><structname>pg_ts_dict</structname></link></entry>
      <entry>dictionnaires de la recherche plein texte</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-parser"><structname>pg_ts_parser</structname></link></entry>
      <entry>analyseurs de la recherche plein texte</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-template"><structname>pg_ts_template</structname></link></entry>
      <entry>modèles de la recherche plein texte</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-type"><structname>pg_type</structname></link></entry>
      <entry>types de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link></entry>
      <entry>correspondance d'utilisateurs sur des serveurs distants</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-aggregate">
  <title><structname>pg_aggregate</structname></title>

  <indexterm zone="catalog-pg-aggregate">
   <primary>pg_aggregate</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_aggregate</structname> stocke les informations
   concernant les fonctions d'agrégat. Une fonction d'agrégat est une fonction
   qui opère sur un ensemble de données (typiquement une colonne de chaque ligne
   qui correspond à une condition de requête) et retourne une valeur unique
   calculée à partir de toutes ces valeurs.
   Les fonctions d'agrégat classiques sont
   <function>sum</function> (somme), <function>count</function> (compteur) et
   <function>max</function> (plus grande valeur). Chaque entrée de
   <structname>pg_aggregate</structname> est une extension d'une entrée de
   <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.
   L'entrée de <structname>pg_proc</structname>
   contient le nom de l'agrégat, les types de données d'entrée et de sortie, et
   d'autres informations similaires aux fonctions ordinaires.
  </para>

  <table>
   <title>Les colonnes de <structname>pg_aggregate</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggfnoid</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID <structname>pg_proc</structname> de la fonction d'agrégat
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggkind</structfield> <type>char</type>
       </para>
       <para>
        Type d'agrégat&nbsp;:
        <literal>n</literal> pour les agrégats <quote>normaux</quote> (standards),
        <literal>o</literal> pour les agrégats d'<quote>ensemble trié</quote>, ou
        <literal>h</literal> pour les agrégats d'<quote>ensembles hypothétiques</quote>
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggnumdirectargs</structfield> <type>int2</type>
       </para>
       <para>
        Nombre d'arguments directs (non agrégés) d'un ensemble trié ou d'un
        ensemble hypothétique, comptant un tableau variadique comme un seul
        argument. Si cette valeur est égale à <structfield>pronargs</structfield>,
        l'agrégat doit être variadique et le tableau variadique décrit aussi les
        arguments agrégés ainsi que les arguments directs finaux. Toujours à 0
        pour les agrégats standards.
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggtransfn</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction de transition
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggfinalfn</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction finale (0 s'il n'y en a pas)
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggcombinefn</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction combine (zero s'il n'y en a pas)
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggserialfn</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction de sérialisation (zero s'il n'y en a pas)
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggdeserialfn</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction de désérialisation (zero s'il n'y en a pas)
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggmtransfn</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction de transition en avant pour le mode d'agrégat avec
        déplacement (zéro sinon)
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggminvtransfn</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction de transition inverse pour le mode d'agrégat avec
        déplacement (zéro sinon)
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggmfinalfn</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction finale pour le mode d'agrégat avec déplacement (zéro
        sinon)
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggfinalextra</structfield> <type>bool</type>
       </para>
       <para>
        Vrai pour passer des arguments supplémentaires à <structfield>aggfinalfn</structfield>
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggmfinalextra</structfield> <type>bool</type>
       </para>
       <para>
        Vrai pour passer des arguments supplémentaires à <structfield>aggmfinalfn</structfield>
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggfinalmodify</structfield> <type>char</type>
       </para>
       <para>
        Si <structfield>aggfinalfn</structfield> modifie la valeur d'état
        de transition&nbsp;:
        <literal>r</literal> s'il est en lecture seule,
        <literal>s</literal> si <structfield>aggtransfn</structfield>
        ne peut pas être appliqué après <structfield>aggfinalfn</structfield>,
        ou <literal>w</literal> s'il écrit sur la valeur
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggmfinalmodify</structfield> <type>char</type>
       </para>
       <para>
        Comme <structfield>aggfinalmodify</structfield>, mais pour
        <structfield>aggmfinalfn</structfield>
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggsortop</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Opérateur de tri associé (0 s'il n'y en a pas)
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggtranstype</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Type de la donnée interne de transition (état) de la fonction d'agrégat
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggtransspace</structfield> <type>int4</type>
       </para>
       <para>
        Taille moyenne approximative (en octets) des données de l'état de
        transition, ou zéro pour utiliser une estimation par défaut
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggmtranstype</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Type de données de la transition interne (état) de la fonction
        d'agrégat pour le mode d'agrégat avec déplacement (zéro sinon)
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggmtransspace</structfield> <type>int4</type>
       </para>
       <para>
        Taille moyenne approximative (en octets) des données d'état de
        transition pour le mode d'agrégat avec déplacement ou zéro pour utiliser
        une estimation par défaut
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>agginitval</structfield> <type>text</type>
       </para>
       <para>
        Valeur initiale de la fonction de transition. C'est un champ texte qui
        contient la valeur initiale dans sa représentation externe en chaîne de
        caractères. Si ce champ est NULL, la valeur d'état de transition
        est initialement NULL.
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>aggminitval</structfield> <type>text</type>
       </para>
       <para>
        La valeur initiale de l'état de transition pour le mode d'agrégat avec
        déplacement. C'est un champ texte contenant la valeur initiale dans sa
        représentation externe sous forme de chaîne. Si ce champ est NULL, la
        valeur de l'état de transition commence avec NULL.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les nouvelles fonctions d'agrégat sont enregistrées avec la commande
   <link linkend="sql-createaggregate"><command>CREATE AGGREGATE</command></link>.
   La <xref linkend="xaggr"/>  fournit de plus amples informations sur
   l'écriture des fonctions d'agrégat et sur
   la signification des fonctions de transition.
  </para>

 </sect1>

 <sect1 id="catalog-pg-am">
  <title><structname>pg_am</structname></title>

  <indexterm zone="catalog-pg-am">
   <primary>pg_am</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_am</structname> stocke les informations
   concernant les méthodes d'accès aux relations. On trouve une ligne par
   méthode d'accès supportée par le système. Actuellement, seuls les tables et les index ont
   des méthodes d'accès. Ce qui concerne les méthodes d'accès aux tables et aux index est
   discuté en détails dans, respectivement, <xref linkend="tableam"/> et <xref linkend="indexam"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_am</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>amname</structfield> <type>name</type>
       </para>
       <para>
        Nom de la méthode d'accès
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>amhandler</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de la fonction gestionnaire responsable de la fourniture des
        informations sur la méthode d'accès
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>amtype</structfield> <type>char</type>
       </para>
       <para>
        <literal>t</literal> = table (incluant les vues matérialisées),
        <literal>i</literal> = index.
       </para></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    Avant <productname>PostgreSQL</productname> 9.6,
    <structname>pg_am</structname> contenait plusieurs colonnes
    supplémentaires représentant des propriétés des méthodes d'accès aux
    index. Ces données sont maintenant uniquement visibles au niveau du code
    C. Néanmoins, <function>pg_index_column_has_property()</function> et les
    fonctions relatives ont été ajoutées pour permettre aux requêtes SQL
    d'inspecter les propriétés des méthodes d'accès aux index. Voir <xref
    linkend="functions-info-catalog-table"/>.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-amop">
  <title><structname>pg_amop</structname></title>

  <indexterm zone="catalog-pg-amop">
   <primary>pg_amop</primary>
  </indexterm>

  <para> Le catalogue <structname>pg_amop</structname> stocke les
   informations concernant les opérateurs associés aux familles
   d'opérateurs des méthodes d'accès aux index. Il y a une ligne pour
   chaque opérateur membre d'une famille. Un membre d'une famille peut
   être soit un opérateur de <firstterm>recherche</firstterm> soit un
   opérateur de <firstterm>tri</firstterm>. Un opérateur peut apparaître
   dans plus d'une famille, mais ne peut pas apparaître dans plus d'une
   position à l'intérieur d'une famille.
  </para>

  <table>
   <title>Colonnes de <structname>pg_amop</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>amopfamily</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        La famille d'opérateur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>amoplefttype</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Type de données en entrée, côté gauche, de l'opérateur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>amoprighttype</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Type de données en entrée, côté droit, de l'opérateur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>amopstrategy</structfield> <type>int2</type>
       </para>
       <para>
        Numéro de stratégie d'opérateur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>amoppurpose</structfield> <type>char</type>
       </para>
       <para>
        But de l'opérateur, soit <literal>s</literal> pour
        recherche soit <literal>o</literal> pour tri
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>amopopr</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de l'opérateur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>amopmethod</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-am"><structname>pg_am</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Méthode d'accès à l'index pour cette famille d'opérateur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>amopsortfamily</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        La famille d'opérateur B-tree utilisée par cette entrée pour
        trier s'il s'agit d'un opérateur de tri&nbsp;; zéro s'il s'agit
        d'un opérateur de recherche
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Un opérateur de <quote>recherche</quote> indique qu'un index de cet
   opérateur peut être utilisé pour rechercher toutes les lignes
   satisfaisant une clause <literal>WHERE</literal>
   <replaceable>colonne_indexée</replaceable>
   <replaceable>opérateur</replaceable>
   <replaceable>constante</replaceable>. Cet opérateur doit évidemment
   renvoyer un booléen et le type de l'entrée gauche doit correspondre
   au type de données de la colonne de l'index.
  </para>

  <para>
   Un opérateur de <quote>tri</quote> indique qu'un index de cette
   famille d'opérateur peut être parcouru pour renvoyer les lignes dans
   l'ordre représenté par une clause
   <literal>ORDER BY</literal>
   <replaceable>colonne_indexée</replaceable>
   <replaceable>opérateur</replaceable>
   <replaceable>constante</replaceable>. Cet opérateur peut renvoyer
   tout type de données triable, bien que le type de l'entrée gauche doit
   correspondre au type de données de la colonne de l'index. La
   sémantique exacte de la clause <literal>ORDER BY</literal> est
   spécifié par la colonne <structfield>amopsortfamily</structfield> qui
   doit référencer une famille d'opérateur B-tree pour le type de
   résultat de l'opérateur.
  </para>

  <note>
   <para>
    Actuellement, il est supposé que l'ordre de tri pour un opérateur de
    tri est celui par défaut de la famille d'opérateur référencée,
    c'est-à-dire <literal>ASC NULLS LAST</literal>. Ceci pourrait changer
    en ajoutant des colonnes supplémentaires pour y indiquer explicitement
    les options de tri.
   </para>
  </note>

  <para>
   Une entrée dans <structfield>amopmethod</structfield> doit correspondre
   au <structfield>opfmethod</structfield> de sa famille d'opérateur parent
   (l'inclusion de <structfield>amopmethod</structfield> à ce niveau est une dénormalisation
   intentionnelle de la structure du catalogue pour des raisons de performance).
   De plus, <structfield>amoplefttype</structfield> et
   <structfield>amoprighttype</structfield> doivent correspondre aux champs
   <structfield>oprleft</structfield> et <structfield>oprright</structfield>
   de l'entrée <link
   linkend="catalog-pg-operator"><structname>pg_operator</structname></link>
   référencée.
  </para>

 </sect1>


 <sect1 id="catalog-pg-amproc">
  <title><structname>pg_amproc</structname></title>

  <indexterm zone="catalog-pg-amproc">
   <primary>pg_amproc</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_amproc</structname> stocke les informations
   concernant les fonctions de support associées aux familles d'opérateurs
   de méthodes  d'accès. Il y a une ligne pour chaque fonction de support
   appartenant à une famille.
  </para>

  <table>
   <title>Colonnes de <structname>pg_amproc</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>amprocfamily</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        La famille d'opérateur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>amproclefttype</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Type de données en entrée, côté gauche, de l'opérateur associé
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>amprocrighttype</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Type de données en entrée, côté droit, de l'opérateur associé
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>amprocnum</structfield> <type>int2</type>
       </para>
       <para>
        Numéro de fonction de support
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>amproc</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de la fonction
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   On interprète habituellement les champs
   <structfield>amproclefttype</structfield> et
   <structfield>amprocrighttype</structfield> comme identifiant les types
   de données des côtés gauche et droit d'opérateur(s) supporté(s) par une fonction
   particulière. Pour certaines méthodes d'accès, ils correspondent
   aux types de données en entrée de la fonction elle-même. Il existe une
   notion de fonctions de support par <quote>défaut</quote> pour un index,
   fonctions pour lesquelles <structfield>amproclefttype</structfield> et
   <structfield>amprocrighttype</structfield> sont tous deux équivalents à
   l'<structfield>opcintype</structfield> de la classe d'opérateurs de l'index.
  </para>

 </sect1>


 <sect1 id="catalog-pg-attrdef">
  <title><structname>pg_attrdef</structname></title>

  <indexterm zone="catalog-pg-attrdef">
   <primary>pg_attrdef</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_attrdef</structname> stocke les valeurs par
   défaut des colonnes. Les informations principales des colonnes sont stockées
   dans <link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.
   Seules les colonnes pour lesquelles une valeur par défaut est explicitement
   indiquée (quand la table est créée ou quand une colonne est ajoutée) ont
   une entrée dans <structname>pg_attrdef</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_attrdef</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>adrelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        La table à laquelle appartient la colonne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>adnum</structfield> <type>int2</type>
        (référence <link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.<structfield>attnum</structfield>)
       </para>
       <para>
        Numéro de la colonne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>adbin</structfield> <type>pg_node_tree</type>
       </para>
       <para>
        La valeur par défaut de la colonne, dans la représentation
        <function>nodeToString()</function>. Utilisez <literal>pg_get_expr(adbin,
         adrelid)</literal> pour la convertir en une expression SQL.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-attribute">
  <title><structname>pg_attribute</structname></title>

  <indexterm zone="catalog-pg-attribute">
   <primary>pg_attribute</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_attribute</structname> stocke les informations
   concernant les colonnes des tables. Il y a exactement une ligne de
   <structname>pg_attribute</structname> par colonne de table de
   la base de données. (Il y a aussi des attributs pour les index et, en fait,
   tous les objets qui possèdent des entrées dans
   <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.)
  </para>

  <para>
   Le terme attribut, équivalent à colonne, est utilisé pour des raisons
   historiques.
  </para>

  <table>
   <title>Colonnes de <structname>pg_attribute</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attrelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        La table à laquelle appartient la colonne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attname</structfield> <type>name</type>
       </para>
       <para>
        Le nom de la colonne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>atttypid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Le type de données de la colonne (zéro pour une colonne supprimée)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attlen</structfield> <type>int2</type>
       </para>
       <para>
        Une copie de <literal>pg_type.typlen</literal> pour le type de la
        colonne.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attnum</structfield> <type>int2</type>
       </para>
       <para>
        Le numéro de la colonne. La numérotation des colonnes ordinaires
        démarre à 1. Les colonnes système, comme les
        <structfield>ctid</structfield>, ont des numéros négatifs arbitraires.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attcacheoff</structfield> <type>int4</type>
       </para>
       <para>
        Toujours -1 sur disque, mais peut être mis à jour lorsque la ligne
        est chargée en mémoire, pour
        mettre en cache l'emplacement de l'attribut dans la ligne.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>atttypmod</structfield> <type>int4</type>
       </para>
       <para>
        Stocke des données spécifiques au type
        de données précisé lors de la création de la table (par exemple, la
        taille maximale d'une colonne de type <type>varchar</type>). Il est
        transmis aux fonctions spécifiques au type d'entrée de données et de
        vérification de taille. La valeur est généralement -1 pour les types
        de données qui n'ont pas besoin de <structfield>atttypmod</structfield>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attndims</structfield> <type>int4</type>
       </para>
       <para>
        Nombre de dimensions, si la colonne est de type tableau, sinon 0.
        (Pour l'instant, le nombre de dimensions des tableaux n'est pas contrôlé,
        donc une valeur autre que 0 indique que <quote>c'est un tableau</quote>.)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attbyval</structfield> <type>bool</type>
       </para>
       <para>
        Une copie de <literal>pg_type.typbyval</literal> du type de la
        colonne.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attalign</structfield> <type>char</type>
       </para>
       <para>
        Une copie de <literal>pg_type.typalign</literal> du type de
        la colonne.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attstorage</structfield> <type>char</type>
       </para>
       <para>
        Contient normalement une copie de
        <literal>pg_type.typstorage</literal> du type de la colonne.
        Pour les types de données TOASTables, cette valeur
        peut être modifiée après la création de la colonne pour en contrôler
        les règles de stockage.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attcompression</structfield> <type>char</type>
       </para>
       <para>
        La méthode de compression actuelle de la colonne. Habituellement,
        cette colonne vaut <literal>'\0'</literal> pour indiquer
        l'utilisation de la configuration par défaut(voir <xref
        linkend="guc-default-toast-compression"/>). Sinon,
        <literal>'p'</literal> sélectionne la compression pglz, alors que
        <literal>'l'</literal> sélectionne la compression
        <productname>LZ4</productname>. Néanmoins, ce champ est ignoré à
        chaque fois que <structfield>attstorage</structfield> ne permet pas
        la compression.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attnotnull</structfield> <type>bool</type>
       </para>
       <para>
        Indique une contrainte de non-nullité de colonne. Il est possible de changer
        cette colonne pour activer ou désactiver cette contrainte.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>atthasdef</structfield> <type>bool</type>
       </para>
       <para>
        Cette colonne a une expression par défaut ou une expression générée,
        auquel cas il y aura un enregistrement correspondant dans le catalogue
        <link linkend="catalog-pg-attrdef"><structname>pg_attrdef</structname></link>
        qui définit réellement
        l'expression. (Vérifiez <structfield>attgenerated</structfield> pour
        déterminer si c'est une expression par défaut ou générée.)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>atthasmissing</structfield> <type>bool</type>
       </para>
       <para>
        Cette colonne a une valeur qui est utilisée quand la colonne est
        complètement manquante de la ligne, ce qui arrive quand une colonne est
        ajoutée avec une valeur par défaut et non volatile (contrainte
        <literal>DEFAULT</literal>) après la création de la ligne. La valeur
        actuellement utilisée est enregistrée dans la colonne
        <structfield>attmissingval</structfield>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attidentity</structfield> <type>char</type>
       </para>
       <para>
        Si vide (<literal>''</literal>), alors ce n'est pas une colonne
        identité. Sinon, <literal>a</literal> signifie toujours généré alors
        que <literal>d</literal> signifie généré par défaut.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attgenerated</structfield> <type>char</type>
       </para>
       <para>
        Si c'est un octet zéro (<literal>''</literal>), alors ce n'est pas une
        colonne générée. Sinon, <literal>s</literal> = stockée. (D'autres
        valeurs pourraient être ajoutées dans le futur.)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attisdropped</structfield> <type>bool</type>
       </para>
       <para>
        Indique que la colonne a été supprimée et n'est plus valide. Une
        colonne supprimée est toujours présente physiquement dans la table,
        mais elle est ignorée par l'analyseur de requête et ne peut être
        accédée en SQL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attislocal</structfield> <type>bool</type>
       </para>
       <para>
        La colonne est définie localement dans la relation. Une
        colonne peut être simultanément définie localement et héritée.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attinhcount</structfield> <type>int2</type>
       </para>
       <para>
        Nombre d'ancêtres directs de la colonne. Une colonne qui a au moins un
        ancêtre ne peut être ni supprimée ni renommée.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>attcollation</structfield> <type>oid</type>
       (référence <link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.<structfield>oid</structfield>)
      </para>
      <para>
       La collation définie de la colonne ou zéro si la colonne n'est pas
       d'un type utilisant les collations.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>attstattarget</structfield> <type>int2</type>
      </para>
      <para>
       <structfield>attstattarget</structfield> contrôle le niveau de détails
       des statistiques accumulées pour cette colonne par
       <link linkend="sql-analyze"><command>ANALYZE</command></link>. Une valeur
       zéro indique qu'aucune statistique ne doit être récupérée. Une valeur
       NULL demande d'utiliser la cible de statistiques par défaut du
       système. La signification exacte des valeurs positives est dépendante
       de la donnée. Pour les types de données scalaires,
       <structfield>attstattarget</structfield> est à la fois le nombre cible
       des <quote>valeurs les plus communes</quote> à récupérer et le nombre
       cible des paniers de l'histogramme à créer.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attacl</structfield> <type>aclitem[]</type>
       </para>
       <para>
        Droits d'accès niveau colonne, s'il y en a qui ont été spécifiquement
        accordés à cette colonne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attoptions</structfield> <type>text[]</type>
       </para>
       <para>
        Options au niveau colonne, en tant que chaînes du type
        <quote>motclé=valeur</quote>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attfdwoptions</structfield> <type>text[]</type>
       </para>
       <para>
        Options du wrapper de données distances, au niveau colonne, en tant que
        chaînes du type <quote>keyword=value</quote>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>attmissingval</structfield> <type>anyarray</type>
       </para>
       <para>
        Cette colonne a un tableau à un élément contenant la valeur utilisée
        quand la colonne est complètement manquante de la ligne, comme cela
        peut survenir quand la colonne est ajoutée avec une valeur par défaut
        (<literal>DEFAULT</literal>) non volatile après la création de la
        ligne. La valeur est seulement utilisée quand
        <structfield>atthasmissing</structfield> est true. S'il n'y a pas de
        valeur, la colonne est NULL.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Dans l'entrée <structname>pg_attribute</structname> d'une colonne
   supprimée, <structfield>atttypid</structfield> est réinitialisée à
   0 mais <structfield>attlen</structfield> et les autres champs copiés à
   partir de <link linkend="catalog-pg-type"><structname>pg_type</structname></link>
   sont toujours valides. Cet arrangement est
   nécessaire pour s'adapter à la situation où le type de données de la
   colonne supprimée a été ensuite supprimé et qu'il n'existe donc plus de
   ligne <structname>pg_type</structname>. <structfield>attlen</structfield> et les
   autres champs peuvent être utilisés pour interpréter le contenu
   d'une ligne de la table.
  </para>
 </sect1>


 <sect1 id="catalog-pg-authid">
  <title><structname>pg_authid</structname></title>

  <indexterm zone="catalog-pg-authid">
   <primary>pg_authid</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_authid</structname> contient les informations
   concernant les identifiants pour les autorisations d'accès aux bases de données
   (rôles). Un rôle englobe les concepts d'<quote>utilisateur</quote> et de
   <quote>groupe</quote>. Un utilisateur est essentiellement un rôle qui a
   l'attribut de connexion (<structfield>rolcanlogin</structfield>). Tout rôle (avec ou
   sans <structfield>rolcanlogin</structfield>) peut avoir d'autres rôles comme
   membres&nbsp;; voir
   <link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link>.
  </para>

  <para>
   Comme ce catalogue contient les mots de passe, il ne doit pas être lisible par
   tout le monde.
   <link linkend="view-pg-roles"><structname>pg_roles</structname></link>
   est une vue, lisible par tout le monde, de
   <structname>pg_authid</structname> qui masque le champ du mot de passe.
  </para>

  <para>
   <xref linkend="user-manag"/> contient des informations détaillées sur les
   utilisateurs et sur la gestion des droits.
  </para>

  <para>
   Comme l'identité des utilisateurs est identique pour tout le cluster de bases
   de données, <structname>pg_authid</structname> est partagé par toutes les
   bases du cluster&nbsp;; il n'existe qu'une seule copie de
   <structname>pg_authid</structname> par cluster, non une par base de
   données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_authid</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>rolname</structfield> <type>name</type>
       </para>
       <para>
        Nom du rôle
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>rolsuper</structfield> <type>bool</type>
       </para>
       <para>
        Le rôle est superutilisateur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>rolinherit</structfield> <type>bool</type>
       </para>
       <para>
        Le rôle hérite automatiquement des droits des rôles dont il est
        membre
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>rolcreaterole</structfield> <type>bool</type>
       </para>
       <para>
        Le rôle peut créer d'autres rôles
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>rolcreatedb</structfield> <type>bool</type>
       </para>
       <para>
        Le rôle peut créer des bases de données
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>rolcanlogin</structfield> <type>bool</type>
       </para>
       <para>
        Le rôle peut se connecter, c'est-à-dire qu'il peut être donné
        comme identifiant d'autorisation de session.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>rolreplication</structfield> <type>bool</type>
       </para>
       <para>
        Le rôle est un rôle de réplication. Ce type de rôle peut initier des
        connexions de réplication et créer/supprimer des slots de réplication.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>rolbypassrls</structfield> <type>bool</type>
       </para>
       <para>
        Le rôle contourne chaque politique de sécurité niveau ligne. Voir
        <xref linkend="ddl-rowsecurity"/> pour plus d'informations.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>rolconnlimit</structfield> <type>int4</type>
       </para>
       <para>
        Pour les rôles qui peuvent se connecter, indique le nombre maximum
        de connexions concurrentes que le rôle peut initier. -1 signifie qu'il
        n'y a pas de limite, -2 indique que la base de données est invalide.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>rolpassword</structfield> <type>text</type>
       </para>
       <para>
        Le mot de passe (éventuellement chiffré)&nbsp;; NULL si aucun.
        Le format dépend de la forme de chiffrement utilisé.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>rolvaliduntil</structfield> <type>timestamptz</type>
       </para>
       <para>
        Date d'expiration du mot de passe (utilisée uniquement pour
        l'authentification par mot de passe)&nbsp;; NULL si indéfiniment
        valable
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Pour un mot de passe chiffré en MD5, la colonne
   <structfield>rolpassword</structfield> commencera avec la chaîne
   <literal>md5</literal> suivi d'un hachage MD5 hexadécimal sur 32
   caractères. Le hachage MD5 sera à partir du mot de passe de l'utilisateur
   concaténé au nom de l'utilisateur. Par exemple, si l'utilisateur
   <literal>joe</literal> a pour mot de passe <literal>xyzzy</literal>,
   <productname>PostgreSQL</productname> enregistrera le hachage MD5 de
   <literal>xyzzyjoe</literal>.
  </para>

  <para>
   Si le mot de passe est chiffré avec SCRAM-SHA-256, il a le format&nbsp;:
   <synopsis>
SCRAM-SHA-256$<replaceable>&lt;nombre d'itération&gt;</replaceable>:<replaceable>&lt;sel&gt;</replaceable>$<replaceable>&lt;CléEnregistrée&gt;</replaceable>:<replaceable>&lt;CléServeur&gt;</replaceable>
   </synopsis>
   où <replaceable>sel</replaceable>, <replaceable>CléEnregistré</replaceable>
   et <replaceable>CléServeur</replaceable> sont dans un format Base64. Ce
   format est le même que celui spécifié par la <ulink
   url="https://datatracker.ietf.org/doc/html/rfc5803">RFC 5803</ulink>.
  </para>

  <para>
   Un mot de passe qui ne suit aucun de ces formats est supposé non chiffré.
  </para>
 </sect1>


 <sect1 id="catalog-pg-auth-members">
  <title><structname>pg_auth_members</structname></title>

  <indexterm zone="catalog-pg-auth-members">
   <primary>pg_auth_members</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_auth_members</structname> contient les relations
   d'appartenance entre les rôles. Tout ensemble non circulaire d'appartenances est
   autorisé.
  </para>

  <para>
   Parce que les identités de l'utilisateur sont valables sur l'ensemble du
   cluster, <structname>pg_auth_members</structname> est partagé par toutes les bases
   de données d'un cluster&nbsp;: il n'existe qu'une seule copie de
   <structname>pg_auth_members</structname> par cluster, pas une par base de
   données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_auth_members</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>oid</structfield> <type>oid</type>
      </para>
      <para>
       Identifiant de la ligne
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>roleid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Identifiant d'un rôle qui a un membre
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>member</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Identifiant d'un rôle qui est membre d'un
        <structfield>roleid</structfield>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>grantor</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Identifiant du rôle qui a autorisé cette appartenance
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>admin_option</structfield> <type>bool</type>
       </para>
       <para>
        Vrai si <structfield>member</structfield> peut donner
        l'appartenance à <structfield>roleid</structfield> aux autres
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>inherit_option</structfield> <type>bool</type>
      </para>
      <para>
       Vrai si le membre hérite automatiquement des droits du rôle cible
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>set_option</structfield> <type>bool</type>
      </para>
      <para>
       Vrai si le membre peut utiliser
       <link linkend="sql-set-role"><command>SET ROLE</command></link>
       vers le rôle cible
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-cast">
  <title><structname>pg_cast</structname></title>

  <indexterm zone="catalog-pg-cast">
   <primary>pg_cast</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_cast</structname> stocke les chemins de
   conversion de type de donnée, qu'il s'agisse de ceux par défaut ou ceux
   définis par un utilisateur.
  </para>

  <para>
   <structname>pg_cast</structname> ne représente pas toutes les conversions de
   type que le système connaît, seulement celles qui ne peuvent pas se déduire
   à partir de règles génériques. Par exemple, la conversion entre un domaine
   et son type de base n'est pas représentée explicitement dans
   <structname>pg_cast</structname>.  Autre exception importante&nbsp;:
   <quote>les conversions automatiques d'entrée/sortie</quote>, celles réalisées en
   utilisant les propres fonctions d'entrée/sortie du type de données pour
   convertir vers ou à partir du <type>text</type> ou des autres types de
   chaînes de caractères, ne sont pas représentées explicitement dans
   <structname>pg_cast</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_cast</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>castsource</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du type de données source
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>casttarget</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du type de données cible
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>castfunc</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de la fonction à utiliser pour réaliser la conversion. 0 si la méthode
        ne requiert pas une fonction.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>castcontext</structfield> <type>char</type>
       </para>
       <para>
        Indique dans quel contexte la conversion peut être utilisée.
        <literal>e</literal> si seules les conversions explicites sont autorisées (avec
        <literal>CAST</literal> ou <literal>::</literal>).
        <literal>a</literal> si les conversions implicites lors de l'affectation à une
        colonne sont autorisées, en plus des conversions explicites.
        <literal>i</literal> si les conversions implicites dans les expressions sont
        autorisées en plus des autres cas.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>castmethod</structfield> <type>char</type>
       </para>
       <para>
        Indique comment la conversion est effectuée.
        <literal>f</literal> signifie que la fonction indiquée dans le champ
        <structfield>castfunc</structfield> est utilisée.
        <literal>i</literal> signifie que les fonctions d'entrée/sortie sont utilisées.
        <literal>b</literal> signifie que les types sont binairement coercibles, et
        que par conséquent aucune conversion n'est nécessaire.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les fonctions de transtypage listées dans <structname>pg_cast</structname>
   doivent toujours prendre le type source de la conversion comme type du
   premier argument et renvoyer le type de destination de la conversion comme
   type de retour. Une fonction de conversion peut avoir jusqu'à trois
   arguments. Le deuxième argument, s'il est présent, doit être de type
   <type>integer</type>&nbsp;; il reçoit le modificateur de type associé avec le
   type de destination ou 1 s'il n'y en a pas. Le troisième
   argument, s'il est présent, doit être de type <type>boolean</type>&nbsp;; il
   reçoit <literal>true</literal> si la conversion est une conversion explicite,
   <literal>false</literal> sinon.
  </para>

  <para>
   Il est possible de créer une entrée <structname>pg_cast</structname>
   dans laquelle les types source et cible sont identiques si la fonction associée
   prend plus d'un argument. De telles entrées représentent les
   <quote>fonctions de forçage de longueur</quote> qui forcent la validité des valeurs de
   ce type pour une valeur particulière du modificateur de type.
  </para>

  <para>
   Quand une entrée <structname>pg_cast</structname> possède des types différents
   pour la source et la cible et une fonction qui prend plus d'un
   argument, le transtypage et le forçage de longueur s'effectuent en une
   seule étape. Lorsqu'une telle entrée n'est pas disponible, le forçage
   vers un type qui utilise un modificateur de type implique deux étapes,
   une de transtypage, l'autre pour appliquer le modificateur.
  </para>
 </sect1>

 <sect1 id="catalog-pg-class">
  <title><structname>pg_class</structname></title>

  <indexterm zone="catalog-pg-class">
   <primary>pg_class</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_class</structname> décrit les tables, et
   les autres objets qui contiennent des colonnes ou ressemblent
   à une table. Cela inclut les index (mais il faut aussi aller voir dans <link
   linkend="catalog-pg-index"><structname>pg_index</structname></link>), les
   séquences (mais voir aussi <link
   linkend="catalog-pg-sequence"><structname>pg_sequence</structname></link>),
   les vues, les vues matérialisées, les types
   composites et les tables TOAST&nbsp;; voir
   <structfield>relkind</structfield>.
   Par la suite, lorsque l'on parle de <quote>relation</quote>, on
   sous-entend tous ces types d'objets. Les colonnes de
   <structname>pg_class</structname> ne sont pas toutes
   significatives pour tous les types de relations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_class</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relname</structfield> <type>name</type>
       </para>
       <para>
        Nom de la table, vue, index, etc.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relnamespace</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du <foreignphrase>namespace</foreignphrase> qui contient la relation.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>reltype</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du type de données qui correspond au type de ligne de la table,
        s'il y en a un.
        0 pour les index, séquences et tables TOAST qui n'ont pas d'entrée
        dans <structname>pg_type</structname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>reloftype</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Pour les tables typées, l'OID du type composite sous-jacent. Sinon, 0
        dans tous les autres cas.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire de la relation.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relam</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-am"><structname>pg_am</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        La méthode d'accès utilisée pour accéder à cette table ou index.
        Sans intérêt si la relation est une séquence ou n'a pas de fichier
        sur disque, sauf pour les tables partitionnées pour lesquelles,
        si elle est configurée, cette méthode est prioritaire sur
        <varname>default_table_access_method</varname> pour déterminer
        la méthode d'accès à utiliser pour les partitions créées quand
        elle n'est pas précisée dans la commande de création.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relfilenode</structfield> <type>oid</type>
       </para>
       <para>
        Nom du fichier disque de la relation&nbsp;; zéro signifie que
        c'est une relation <quote>mapped</quote> dont le nom de fichier est
        déterminé par un statut de bas niveau.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>reltablespace</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Le <foreignphrase>tablespace</foreignphrase> dans lequel est stocké
        la relation. Si 0, il s'agit du
        <foreignphrase>tablespace</foreignphrase> par défaut de la base de
        données. Sans intérêt si la relation n'a pas de fichier sur disque,
        sauf pour les tables partitionnées, où il s'agit du tablespace dans
        lequel les partitions sont créées so aucun tablespace n'est précisé dans
        la commande de création.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relpages</structfield> <type>int4</type>
       </para>
       <para>
        Taille du fichier disque, exprimée en pages (de taille
        <symbol>BLCKSZ</symbol>).
        Ce n'est qu'une estimation utilisée par le planificateur. Elle est mise à
        jour par les commandes <link
        linkend="sql-vacuum"><command>VACUUM</command></link>, <link
        linkend="sql-analyze"><command>ANALYZE</command></link> et quelques
        commandes DDL comme <link linkend="sql-createindex"><command>CREATE
        INDEX</command></link>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>reltuples</structfield> <type>float4</type>
       </para>
       <para>
        Nombre de lignes de la table.
        Ce n'est qu'une estimation utilisée par le planificateur. Elle est
        mise à jour par <link
        linkend="sql-vacuum"><command>VACUUM</command></link>, <link
        linkend="sql-analyze"><command>ANALYZE</command></link> et quelques
        commandes DDL comme <link linkend="sql-createindex"><command>CREATE
        INDEX</command></link>. Si la table n'a jamais été traitée par un
        VACUUM ou un ANALYZE, <structfield>reltuples</structfield> contient
        <literal>-1</literal> indiquant que le nombre de lignes est inconnu.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relallvisible</structfield> <type>int4</type>
       </para>
       <para>
        Nombre de pages marquées entièrement visibles dans la carte de visibilité
        de la table. Ceci n'est qu'une estimation utilisée par le planificateur.
        Elle est mise à jour par <link
        linkend="sql-vacuum"><command>VACUUM</command></link>, <link
        linkend="sql-analyze"><command>ANALYZE</command></link> et quelques
        commandes DDL comme <link linkend="sql-createindex"><command>CREATE
        INDEX</command></link>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>reltoastrelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de la table TOAST associée à cette table. Zéro s'il n'y en a pas.
        La table TOAST stocke les attributs de grande taille <quote>hors
         ligne</quote> dans une table secondaire.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relhasindex</structfield> <type>bool</type>
       </para>
       <para>
        Vrai si c'est une table et qu'elle possède (ou possédait encore
        récemment) quelque index.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relisshared</structfield> <type>bool</type>
       </para>
       <para>
        Vrai si cette table est partagée par toutes les bases de données
        du cluster. Seuls certains catalogues système (comme
        <link linkend="catalog-pg-database"><structname>pg_database</structname></link>)
        sont partagés.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relpersistence</structfield> <type>char</type>
       </para>
       <para>
        <literal>p</literal> = table/séquence permanente, <literal>u</literal>
        = table/séquence non journalisée, <literal>t</literal> = table/séquence
        temporaire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relkind</structfield> <type>char</type>
       </para>
       <para>
        <literal>r</literal> = table,
        <literal>i</literal> = index,
        <literal>S</literal> = séquence,
        <literal>t</literal> = table TOAST,
        <literal>v</literal> = vue,
        <literal>m</literal> = vue matérialisée,
        <literal>c</literal> = type composite,
        <literal>f</literal> = table externe,
        <literal>p</literal> = table partitionnée
        <literal>I</literal> = index partitionné
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relnatts</structfield> <type>int2</type>
       </para>
       <para>
        Nombre de colonnes utilisateur dans la relation (sans compter les
        colonnes système). Il doit y avoir le même nombre d'entrées dans
        <link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.
        Voir aussi
        <structname>pg_attribute</structname>.<structfield>attnum</structfield>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relchecks</structfield> <type>int2</type>
       </para>
       <para>
        Nombre de contraintes de vérification (<literal>CHECK</literal>) sur la table&nbsp;; voir le
        catalogue <link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relhasrules</structfield> <type>bool</type>
       </para>
       <para>
        Vrai si la table contient (ou a contenu) des règles&nbsp;; voir le catalogue
        <link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relhastriggers</structfield> <type>bool</type>
       </para>
       <para>
        Vrai si la table a (ou a eu) des triggers&nbsp;; voir le catalogue
        <link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relhassubclass</structfield> <type>bool</type>
       </para>
       <para>
        Vrai si au moins une table ou un index hérite ou a hérité d'un
        enfant, ou a une partition
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relrowsecurity</structfield> <type>bool</type>
       </para>
       <para>
        Vrai si la table a la sécurité niveau ligne activée&nbsp;; voir
        le catalogue <link linkend="catalog-pg-policy"><structname>pg_policy</structname></link>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relforcerowsecurity</structfield> <type>bool</type>
       </para>
       <para>
        Vrai si la sécurité niveau ligne (si activée) s'appliquera aussi au propriétaire de la table&nbsp;; voir
        le catalogue <link linkend="catalog-pg-policy"><structname>pg_policy</structname></link>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relispopulated</structfield> <type>bool</type>
       </para>
       <para>
        Vrai si la relation est peuplée (ceci est vrai pour toutes les
        relations autres que certaines vues matérialisées)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relreplident</structfield> <type>char</type>
       </para>
       <para>
        Colonnes utilisées pour former une <quote>identité de réplica</quote>
        pour les lignes&nbsp;:
        <literal>d</literal> = par défaut (clé primaire, si présente),
        <literal>n</literal> = rien,
        <literal>f</literal> = toutes les colonnes
        <literal>i</literal> = index avec
        <structfield>indisreplident</structfield> configuré (identique à rien
        si l'index utilisé a été supprimé)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relispartition</structfield> <type>bool</type>
       </para>
       <para>
        True si la table ou l'index est une partition
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relrewrite</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Pour les nouvelles relations écrites lors d'une opération DDL qui
        requiert une réécriture de la table, cette colonne contient l'OID de la
        relation originale&nbsp;; zéro sinon. Cet état est seulement visible en
        interne&nbsp;; ce champ ne devrait jamais contenir autre chose que zéro
        pour une relation visible par l'utilisateur.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relfrozenxid</structfield> <type>xid</type>
       </para>
       <para>
        Tous les ID de transaction avant celui-ci ont été remplacés par un ID de
        transaction permanent (<quote>frozen</quote>). Ceci est utilisé pour
        déterminer si la table doit être nettoyée (VACUUM) pour éviter un
        bouclage des ID de transaction
        (<foreignphrase>ID wraparound</foreignphrase>) ou pour compacter
        <literal>pg_xact</literal>.
        0 (<symbol>InvalidTransactionId</symbol>) si la relation n'est pas
        une table.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relminmxid</structfield> <type>xid</type>
       </para>
       <para>
        Tous les identifiants MultiXact avant celui-i ont été remplacés
        par un identifiant de transaction dans cette table. Ceci est utilisé pour
        tracer si la table a besoin d'être traitée par le VACUUM pour empêcher
        un bouclage des identifiants MultiXact ou pour permettre à
        <literal>pg_multixact</literal> d'être réduits. Cette colonne vaut zéro
        (<symbol>InvalidTransactionId</symbol>) si la relation n'est pas une
        table.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relacl</structfield> <type>aclitem[]</type>
       </para>
       <para>
        Droits d'accès&nbsp;; voir <xref linkend="ddl-priv"/>
        pour plus de détails.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>reloptions</structfield> <type>text[]</type>
       </para>
       <para>
        Options spécifiques de la méthode d'accès, représentées par des chaînes du type
        <quote>motclé=valeur</quote>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relpartbound</structfield> <type>pg_node_tree</type>
       </para>
       <para>
        Si la table est une partition (voir <structfield>relispartition</structfield>),
        représentation interne de la limite de la partition
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Plusieurs des drapeaux booléens dans <link linkend="catalog-pg-class"><structname>pg_class</structname></link> sont
   maintenus faiblement&nbsp;: la valeur true est garantie s'il s'agit du bon
   état, mais elle pourrait ne pas être remise à false immédiatement quand la
   condition n'est plus vraie. Par exemple,
   <structfield>relhasindex</structfield> est configurée par
   <link linkend="sql-createindex"><command>CREATE INDEX</command></link> mais
   n'est jamais remise à false par <link linkend="sql-dropindex"><command>DROP
   INDEX</command></link>. C'est <link
   linkend="sql-vacuum"><command>VACUUM</command></link> qui le fera
   <structfield>relhasindex</structfield> s'il découvre que la table n'a pas
   d'index. Cet arrangement évite des fenêtres de vulnérabilité et améliore
   la concurrence.
  </para>
 </sect1>

 <sect1 id="catalog-pg-collation">
  <title><structname>pg_collation</structname></title>

  <indexterm zone="catalog-pg-collation">
   <primary>pg_collation</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_collation</structname> décrit les
   collationnements disponibles, qui sont essentiellement des
   correspondances entre un nom SQL et des catégories de locales du
   système d'exploitation. Voir <xref linkend="collation"/> pour plus
   d'informations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_collation</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collname</structfield> <type>name</type>
       </para>
       <para>
        Nom du collationnement (unique par schéma et encodage)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collnamespace</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID du schéma contenant ce collationnement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire du collationnement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collprovider</structfield> <type>char</type>
       </para>
       <para>
        Fournisseur du collationnement&nbsp;: <literal>d</literal> = le
        défaut de la base de données, <literal>b</literal> = interne,
        <literal>c</literal> = libc,
        <literal>i</literal> = icu
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collisdeterministic</structfield> <type>bool</type>
       </para>
       <para>
        Est-ce que le collationnement est déterministe&nbsp;?
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collencoding</structfield> <type>int4</type>
       </para>
       <para>
        Encodage pour lequel le collationnement est disponible. -1
        s'il fonctionne pour tous les encodages
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collcollate</structfield> <type>text</type>
       </para>
       <para>
        <symbol>LC_COLLATE</symbol> pour ce collationnement
        Si le fournisseur n'est pas <literal>libc</literal>,
        <structfield>collcollate</structfield> vaut
        <literal>NULL</literal> et <structfield>colllocale</structfield> est
        utilisé à la place.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collctype</structfield> <type>text</type>
       </para>
       <para>
        <symbol>LC_CTYPE</symbol> pour ce collationnement
        Si le fournisseur n'est pas <literal>libc</literal>,
        <structfield>collctype</structfield> vaut
        <literal>NULL</literal> et <structfield>colllocale</structfield> est
        utilisé à la place.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>colllocale</structfield> <type>text</type>
      </para>
      <para>
       Nom de la locale du fournisseur de la collation pour cet objet.
       Si le fournisseur est <literal>libc</literal>,
       <structfield>colllocale</structfield> vaut
       <literal>NULL</literal>&nbsp;;
       <structfield>collcollate</structfield> et
       <structfield>collctype</structfield> sont utilisés à la place.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collicurules</structfield> <type>text</type>
      </para>
      <para>
       Règles de collation ICU pour cette collation
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>collversion</structfield> <type>text</type>
       </para>
       <para>
        Version spécifique au fournisseur du collationnement. C'est enregistré
        quand le collationnement est créé, puis vérifié quand il est utilisé,
        pour détecter les changements dans la définition du collationnement qui
        pourraient amener une corruption des données.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Notez que la clé unique de ce catalogue est (<structfield>collname</structfield>,
   <structfield>collencoding</structfield>, <structfield>collnamespace</structfield>)
   et non pas seulement
   (<structfield>collname</structfield>, <structfield>collnamespace</structfield>).
   <productname>PostgreSQL</productname> ignore habituellement tous les
   collationnement qui n'ont pas de colonne
   <structfield>collencoding</structfield> égale soit à l'encodage de
   la base de données en cours ou -1. La création de nouvelles entrées
   de même nom qu'une autre entrée dont
   <structfield>collencoding</structfield> vaut -1 est interdite. Du
   coup, il suffit d'utiliser un nom SQL qualifié du schéma
   (<replaceable>schéma</replaceable>.<replaceable>nom</replaceable>)
   pour identifier un collationnement bien que cela ne soit pas unique
   d'après la définition du catalogue. Ce catalogue a été défini ainsi
   car <application>initdb</application> le remplit au moment de
   l'initialisation de l'instance avec les entrées pour toutes les locales
   disponibles sur le système, donc il doit être capable de contenir les
   entrées de tous les encodages qui pourraient être utilisés dans
   l'instance.
  </para>

  <para>
   Dans la base de données <literal>template0</literal>, il pourrait
   être utile de créer les collationnement dont l'encodage ne correspond
   pas à l'encodage de la base de données car ils pourraient correspondre
   aux encodages de bases de données créées par la suite à partir de ce
   modèle de base de données. Cela doit être fait manuellement
   actuellement.
  </para>
 </sect1>

 <sect1 id="catalog-pg-constraint">
  <title><structname>pg_constraint</structname></title>

  <indexterm zone="catalog-pg-constraint">
   <primary>pg_constraint</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_constraint</structname> stocke les vérifications,
   clés primaires, clés uniques, étrangères et d'exclusion des tables, ainsi
   que pour les contraintes non NULL sur les domaines. (Les contraintes de
   colonnes ne sont pas traitées de manière particulière. Elles sont
   équivalentes à des contraintes de tables.) Les contraintes NOT NULL sur les
   relations sont représentées dans le catalogue
   <link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>,
   pas ici.
  </para>

  <para>
   Les triggers de contraintes définies par des utilisateurs (créés avec
   <link linkend="sql-createtrigger"> <command>CREATE CONSTRAINT
   TRIGGER</command></link>) ont aussi une entrée dans cette table.
  </para>

  <para>
   Les contraintes de vérification de domaine sont également stockées dans
   ce catalogue.
  </para>

  <table>
   <title>Colonnes de <structname>pg_constraint</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>conname</structfield> <type>name</type>
       </para>
       <para>
        Nom de la contrainte (pas nécessairement unique&nbsp;!)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>connamespace</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du <foreignphrase>namespace</foreignphrase> qui contient la contrainte.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>contype</structfield> <type>char</type>
       </para>
       <para>
        <literal>c</literal> = contrainte de vérification,
        <literal>f</literal> = contrainte de clé étrangère,
        <literal>n</literal> = contrainte non NULL (seulement pour les domaines),
        <literal>p</literal> = contrainte de clé primaire,
        <literal>u</literal> = contrainte d'unicité,
        <literal>t</literal> = contrainte trigger,
        <literal>x</literal> = contrainte d'exclusion
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>condeferrable</structfield> <type>bool</type>
       </para>
       <para>
        La contrainte peut-elle être retardée
        (<foreignphrase>deferable</foreignphrase>)&nbsp;?
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>condeferred</structfield> <type>bool</type>
       </para>
       <para>
        La contrainte est-elle retardée par défaut&nbsp;?
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>convalidated</structfield> <type>bool</type>
       </para>
       <para>
        La contrainte a-t-elle été validée&nbsp;? actuellement,
        peut seulement valoir false pour les clés étrangères et les contraintes
        CHECK
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>conrelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Table à laquelle appartient la contrainte&nbsp;; zéro si ce n'est pas
        une contrainte de table.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>contypid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Domaine auquel appartient la contrainte&nbsp;; zéro si ce n'est pas
        une contrainte de domaine.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>conindid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'index qui force cette contrainte (unique, clé primaire, clé
        étrangère, d'exclusion)&nbsp;; sinon zéro
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>conparentid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        La contrainte correspondante dans la table partitionnée parent si
        c'est une contrainte dans une partition&nbsp;; sinon zéro
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>confrelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Si c'est une clé étrangère, la table référencée&nbsp;; sinon zéro
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>confupdtype</structfield> <type>char</type>
       </para>
       <para>
        Code de l'action de mise à jour de la clé étrangère&nbsp;:
        <literal>a</literal> = no action,
        <literal>r</literal> = restrict,
        <literal>c</literal> = cascade,
        <literal>n</literal> = set null,
        <literal>d</literal> = set default
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>confdeltype</structfield> <type>char</type>
       </para>
       <para>
        Code de l'action de suppression de clé étrangère&nbsp;:
        <literal>a</literal> = no action,
        <literal>r</literal> = restrict,
        <literal>c</literal> = cascade,
        <literal>n</literal> = set null,
        <literal>d</literal> = set default
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>confmatchtype</structfield> <type>char</type>
       </para>
       <para>
        Type de concordance de la clé étrangère&nbsp;:
        <literal>f</literal> = full,
        <literal>p</literal> = partial,
        <literal>s</literal> = simple
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>conislocal</structfield> <type>bool</type>
       </para>
       <para>
        Cette contrainte est définie localement dans la relation. Notez qu'une
        contrainte peut être définie localement et héritée simultanément
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>coninhcount</structfield> <type>int2</type>
       </para>
       <para>
        Le nombre d'ancêtres d'héritage directs que cette contraite possède. Une contrainte
        avec un nombre non nul d'ancêtres ne peut être ni supprimée ni renommée.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>connoinherit</structfield> <type>bool</type>
       </para>
       <para>
        Cette contrainte est définie localement pour la relation. C'est une
        contrainte non héritable.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>conkey</structfield> <type>int2[]</type>
        (référence <link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.<structfield>attnum</structfield>)
       </para>
       <para>
        S'il s'agit d'une contrainte de table (incluant les clés
        étrangères mais pas les triggers de contraintes),
        liste des colonnes contraintes
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>confkey</structfield> <type>int2[]</type>
        (référence <link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.<structfield>attnum</structfield>)
       </para>
       <para>
        S'il s'agit d'une clé étrangère, liste des colonnes référencées
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>conpfeqop</structfield> <type>oid[]</type>
        (référence <link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        S'il s'agit d'une clé étrangère, liste des opérateurs d'égalité pour
        les comparaisons clé primaire/clé étrangère
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>conppeqop</structfield> <type>oid[]</type>
        (référence <link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        S'il s'agit d'une clé étrangère, liste des opérateurs d'égalité pour les
        comparaisons clé primaire/clé primaire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>conffeqop</structfield> <type>oid[]</type>
        (référence <link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        S'il s'agit d'une clé étrangère, liste des opérateurs d'égalité pour les
        comparaisons clé étrangère/clé étrangère
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confdelsetcols</structfield> <type>int2[]</type>
       (référence <link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.<structfield>attnum</structfield>)
      </para>
      <para>
       S'il s'agit d'une clé étrangère avec une action <literal>SET
       NULL</literal> ou <literal>SET DEFAULT</literal> pour une suppression de
       ligne, liste des colonnes qui seront mises à jour.  Si null, toutes les
       colonnes référençantes seront mises à jour.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>conexclop</structfield> <type>oid[]</type>
        (référence <link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Si une contrainte d'exclusion, liste les opérateurs d'exclusion
        par colonne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>conbin</structfield> <type>pg_node_tree</type>
       </para>
       <para>
        Si c'est une contrainte CHECK, représentation interne de l'expression.
        (Il est recommandé d'utiliser <function>pg_get_constraintdef()</function>
        pour extraire la définition d'une contrainte CHECK.)
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Dans le cas d'une contrainte d'exclusion, <structfield>conkey</structfield>
   est seulement utile pour les éléments contraints qui sont de simples
   références de colonnes. Dans les autres cas, un zéro apparaît dans
   <structfield>conkey</structfield> et l'index associé doit être consulté
   pour découvrir l'expression contrainte. (du coup,
   <structfield>conkey</structfield> a le même contenu que
   <link linkend="catalog-pg-index"><structname>pg_index</structname></link>.<structfield>indkey</structfield>
   pour l'index.)
  </para>

  <note>
   <para>
    <literal>pg_class.relchecks</literal> doit accepter le même nombre de
    contraintes de vérification pour chaque relation.
   </para>
  </note>

 </sect1>

 <sect1 id="catalog-pg-conversion">
  <title><structname>pg_conversion</structname></title>

  <indexterm zone="catalog-pg-conversion">
   <primary>pg_conversion</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_conversion</structname> décrit les fonctions
   de conversion de codage. Voir la commande
   <xref linkend="sql-createconversion"/> pour plus d'informations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_conversion</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>conname</structfield> <type>name</type>
       </para>
       <para>
        Nom de la conversion (unique au sein d'un
        <foreignphrase>namespace</foreignphrase>)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>connamespace</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du <foreignphrase>namespace</foreignphrase> qui contient la conversion.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>conowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire de la conversion
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>conforencoding</structfield> <type>int4</type>
       </para>
       <para>
        Identifiant de l'encodage source
        (<link linkend="pg-encoding-to-char"><function>pg_encoding_to_char()</function></link>
        peut traduire ce nombre par le nom de l'encodage)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>contoencoding</structfield> <type>int4</type>
       </para>
       <para>
        Identifiant de l'encodage de destination
        (<link linkend="pg-encoding-to-char"><function>pg_encoding_to_char()</function></link>
        peut traduire ce nombre par le nom de l'encodage)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>conproc</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Procédure de conversion
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>condefault</structfield> <type>bool</type>
       </para>
       <para>
        Vrai s'il s'agit de la conversion par défaut
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-database">
  <title><structname>pg_database</structname></title>

  <indexterm zone="catalog-pg-database">
   <primary>pg_database</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_database</structname> stocke les informations
   concernant
   les bases de données disponibles. Celles-ci sont créées avec la
   commande <link linkend="sql-createdatabase"><command>CREATE
   DATABASE</command></link>. Consulter le <xref
   linkend="managing-databases"/> pour les détails sur la signification de
   certains paramètres.
  </para>

  <para>
   Contrairement à la plupart des catalogues système,
   <structname>pg_database</structname> est partagé par toutes les bases de
   données d'un cluster&nbsp;: il n'y a qu'une seule copie de
   <structname>pg_database</structname> par cluster, pas une par base.
  </para>

  <table>
   <title>Colonnes de <structname>pg_database</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datname</structfield> <type>name</type>
       </para>
       <para>
        Nom de la base de données
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datdba</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire de la base, généralement l'utilisateur qui l'a
        créée
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>encoding</structfield> <type>int4</type>
       </para>
       <para>
        Encodage de la base de données (la fonction <link
        linkend="pg-encoding-to-char"><function>pg_encoding_to_char()</function></link>
        peut convertir ce nombre en nom de l'encodage)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datlocprovider</structfield> <type>char</type>
      </para>
      <para>
       Fournisseur de la locale pour cette base de données&nbsp;:
       <literal>b</literal>= interne,
       <literal>c</literal> = libc,
       <literal>i</literal> = icu
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datistemplate</structfield> <type>bool</type>
       </para>
       <para>
        Si vrai, alors cette base de données peut être clonée par tout utilisateur
        ayant l'attribut <literal>CREATEDB</literal>&nbsp;; si faux, seuls les
        superutilisateurs et le propriétaire de la base de données peuvent la
        cloner.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datallowconn</structfield> <type>bool</type>
       </para>
       <para>
        Si ce champ est faux, alors personne ne peut se connecter à cette
        base de données. Ceci est utilisé pour interdire toute modification de la base
        <literal>template0</literal>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>dathasloginevt</structfield> <type>bool</type>
      </para>
      <para>
        Indique qu'il existe des triggers sur événement de connexion pour
        cette base de données. Ce drapeau est utilisé pour éviter des
        recherches supplémentaires sur la table
        <structname>pg_event_trigger</structname> à chaque lancement d'un
        processus serveur. Cette information est utilisée en interne par
         <productname>PostgreSQL</productname> et ne devrait pas être
         modifiée manuellement ou lu par la supervision.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datconnlimit</structfield> <type>int4</type>
       </para>
       <para>
        Nombre maximum de connexions concurrentes autorisées sur
        la base de données. -1 indique l'absence de limite.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datfrozenxid</structfield> <type>xid</type>
       </para>
       <para>
        Tous les ID de transaction avant celui-ci ont été remplacés par un ID
        de transaction permanent (<quote>frozen</quote>). Ceci est
        utilisé pour déterminer si la table doit être nettoyée (VACUUM) pour
        éviter un bouclage des ID de transaction
        (<foreignphrase>ID wraparound</foreignphrase>) ou pour compacter
        <literal>pg_xact</literal>.
        C'est la valeur minimale des valeurs par table de
        <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>relfrozenxid</structfield>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datminmxid</structfield> <type>xid</type>
       </para>
       <para>
        Tous les identifiants MultiXact avant celui-i ont été remplacés
        par un identifiant de transaction dans cette table. Ceci est utilisé pour
        tracer si la base de données a besoin d'être traitée par le VACUUM pour
        empêcher un bouclage des identifiants MultiXact ou pour
        permettre à <literal>pg_multixact</literal> d'être réduit. Il s'agit aussi
        de la valeur minimale des valeurs de
        <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>relminmxid</structfield>
        pour chaque table.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>dattablespace</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Le <foreignphrase>tablespace</foreignphrase> par défaut de la base de données.
        Dans cette base de données, toutes les tables pour lesquelles
        <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>reltablespace</structfield>
        vaut zéro sont stockées dans celui-ci&nbsp;; en particulier, tous les catalogues
        système non partagés s'y trouvent.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datcollate</structfield> <type>text</type>
      </para>
      <para>
       LC_COLLATE pour cette base de données
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datctype</structfield> <type>text</type>
      </para>
      <para>
       LC_CTYPE pour cette base de données
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datlocale</structfield> <type>text</type>
      </para>
      <para>
       Nom de la locale du fournisseur de collation pour cette base de
       données. Si le fournisseur est <literal>libc</literal>,
       <structfield>datlocale</structfield> vaut
       <literal>NULL</literal>&nbsp;;
       <structfield>datcollate</structfield> et
       <structfield>datctype</structfield> sont utilisés à la place.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>daticurules</structfield> <type>text</type>
      </para>
      <para>
       Règles de collation ICU pour cette base de données
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datcollversion</structfield> <type>text</type>
      </para>
      <para>
       Version spécifique du fournisseur pour cette collation. Cette information
       est enregistrée quand la base de données est créée et est vérifiée à
       chaque utilisation de la base pour détecter les changements de définition
       de la collation, qui pourraient amener à une corruption des données.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>datacl</structfield> <type>aclitem[]</type>
       </para>
       <para>
        Droits d'accès&nbsp;; voir <xref linkend="ddl-priv"/> pour les
        détails.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-db-role-setting">
  <title><structname>pg_db_role_setting</structname></title>

  <indexterm zone="catalog-pg-db-role-setting">
   <primary>pg_db_role_setting</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_db_role_setting</structname> enregistre les
   valeurs par défaut qui ont été configurées pour les variables de
   configuration, pour chaque combinaison de rôle et de base.
  </para>

  <para>
   Contrairement à la plupart des catalogues systèmes,
   <structname>pg_db_role_setting</structname> est partagé parmi toutes les
   bases de données de l'instance&nbsp;: il n'existe qu'une copie de
   <structname>pg_db_role_setting</structname> par instance, pas une par base
   de données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_db_role_setting</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>setdatabase</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-database"><structname>pg_database</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID de la base de données pour laquelle la configuration est
        applicable&nbsp;; zéro si cette configuration n'est pas spécifique à
        une base de données
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>setrole</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID du rôle pour laquelle la configuration est applicable&nbsp;;
        zéro si cette configuration n'est pas spécifique à un rôle
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>setconfig</structfield> <type>text[]</type>
       </para>
       <para>
        Valeurs par défaut pour les variables de configuration
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-default-acl">
  <title><structname>pg_default_acl</structname></title>

  <indexterm zone="catalog-pg-default-acl">
   <primary>pg_default_acl</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_default_acl</structname> enregistre les droits
   initiaux à affecter aux nouveaux objets créés.
  </para>

  <table>
   <title>Colonnes de <structname>pg_default_acl</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>defaclrole</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du rôle associé à cette entrée
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>defaclnamespace</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du schéma associé à cette entrée, zéro si aucun
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>defaclobjtype</structfield> <type>char</type>
       </para>
       <para>
        Type de l'objet pour cette entrée&nbsp;:
        <literal>r</literal> = relation (table, vue),
        <literal>S</literal> = séquence,
        <literal>f</literal> = fonction,
        <literal>T</literal> = type,
        <literal>n</literal> = schéma
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>defaclacl</structfield> <type>aclitem[]</type>
       </para>
       <para>
        Droits d'accès qu'auront les nouveaux objets de ce type
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Une entrée <structname>pg_default_acl</structname> affiche les droits
   initiaux affectés à un objet appartenant à l'utilisateur indiqué. Il existe
   actuellement deux types d'entrées&nbsp;: des entrées <quote>globales</quote>
   avec <structfield>defaclnamespace</structfield> = zéro, et des entrées
   <quote>par schéma</quote> qui référencent un schéma. Si une entrée globale
   est présente, alors elle <emphasis>surcharge</emphasis> les droits par
   défaut codés en dur pour le type de l'objet. Une entrée par schéma, si
   présente, représente les droits à <emphasis>ajouter</emphasis> aux droits
   par défaut globaux ou aux droits codés en dur.
  </para>

  <para>
   Notez que quand une entrée de droits (ACL) dans un autre catalogue est NULL,
   cela veut dire que les droits par défaut codés en dur sont utilisés pour
   cet objet, et <emphasis>non pas</emphasis> ce qui pourrait être dans
   <structname>pg_default_acl</structname> à ce moment.
   <structname>pg_default_acl</structname> est seulement consulté durant la
   création de l'objet.
  </para>

 </sect1>

 <sect1 id="catalog-pg-depend">
  <title><structname>pg_depend</structname></title>

  <indexterm zone="catalog-pg-depend">
   <primary>pg_depend</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_depend</structname> enregistre les relations de
   dépendances entre les objets de la base de données. Cette information permet
   à la commande <command>DROP</command> de trouver les objets qui doivent être
   supprimés conjointement par la commande <command>DROP CASCADE</command>
   ou au contraire empêchent la suppression dans le cas de
   <command>DROP RESTRICT</command>.
  </para>

  <para>
   Voir aussi <link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link>,
   qui remplit la même fonction pour les dépendances impliquant des
   objets partagés sur tout le cluster.
  </para>

  <table>
   <title>Colonnes de <structname>pg_depend</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>classid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du catalogue système dans lequel l'objet dépendant se trouve
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>objid</structfield> <type>oid</type>
        (référence toute colonne OID)
       </para>
       <para>
        OID de l'objet dépendant
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>objsubid</structfield> <type>int4</type>
       </para>
       <para>
        Pour une colonne de table, ce champ indique le numéro de colonne (les
        champs <structfield>objid</structfield> et
        <structfield>classid</structfield> font référence à
        la table elle-même). Pour tous les autres types d'objets, cette colonne
        est à 0.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>refclassid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du catalogue système dans lequel l'objet référencé se trouve.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>refobjid</structfield> <type>oid</type>
        (référence toute colonne OID)
       </para>
       <para>
        OID de l'objet référencé
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>refobjsubid</structfield> <type>int4</type>
       </para>
       <para>
        Pour une colonne de table, ce champ indique le numéro de colonne (les
        champs <structfield>refobjid</structfield> et
        <structfield>refclassid</structfield> font référence
        à la table elle même). Pour tous les autres types d'objets, cette colonne
        est à 0.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>deptype</structfield> <type>char</type>
       </para>
       <para>
        Code définissant la sémantique particulière de la relation de dépendance. Voir le
        texte.
       </para></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Dans tous les cas, une entrée de <structname>pg_depend</structname> indique
   que l'objet de référence ne peut pas être supprimé sans supprimer aussi l'objet
   dépendant. Néanmoins, il y a des nuances, identifiées par
   <structfield>deptype</structfield>&nbsp;:

   <variablelist>
    <varlistentry>
     <term><symbol>DEPENDENCY_NORMAL</symbol> (<literal>n</literal>)</term>
     <listitem>
      <para>
       Une relation normale entre des objets créés séparément. L'objet dépendant
       peut être supprimé sans affecter l'objet référencé. Ce dernier ne
       peut être supprimé qu'en précisant l'option <literal>CASCADE</literal>,
       auquel cas l'objet dépendant est supprimé lui-aussi. Exemple&nbsp;: une
       colonne de table a une dépendance normale avec ses types de données.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_AUTO</symbol> (<literal>a</literal>)</term>
     <listitem>
      <para>
       L'objet dépendant peut être supprimé séparément de l'objet référencé,
       mais il l'est automatiquement avec la suppression de ce dernier,
       quel que soit le mode <literal>RESTRICT</literal> ou <literal>CASCADE</literal>.
       Exemple&nbsp;: une contrainte nommée sur une table est auto-dépendante
       de la table, elle est automatiquement supprimée avec celle-ci.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_INTERNAL</symbol> (<literal>i</literal>)</term>
     <listitem>
      <para>
       L'objet dépendant est créé conjointement à l'objet référencé et fait
       partie intégrante de son implantation interne. Un
       <command>DROP</command> direct de l'objet dépendant est interdit
       (l'utilisateur est averti qu'il peut effectuer un
       <command>DROP</command> de l'objet référencé à la place). La
       suppression de l'objet référencé résultera en une suppression
       automatique de l'objet dépendant que <command>CASCADE</command> soit
       précisé ou non. Si l'objet dépendant doit être supprimé à cause de la
       dépendance en un autre objet en cours de suppression, la suppression
       est convertie en une suppression de l'objet référencé, pour que les
       dépendances <literal>NORMAL</literal> et <literal>AUTO</literal> de
       l'objet
       dépendant se comportent comme s'ils s'agissaient de dépendances de
       l'objet référencé. Par exemple, la règle <literal>ON SELECT</literal>
       d'une vue est rendue en interne dépendante de la vue, empêchant sa
       suppression tant que la vue existe. Les dépendances de la règle (comme
       les tables auxquelles elle fait référence) agissent comme si elles
       dépendaient de la vue.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_PARTITION_PRI</symbol> (<literal>P</literal>)</term>
     <term><symbol>DEPENDENCY_PARTITION_SEC</symbol> (<literal>S</literal>)</term>
     <listitem>
      <para>
       L'objet dépendant a été créé lors de la création de l'objet référencé,
       mais il s'agit vraiment d'un détail d'implémentation interne.
       Néanmoins, contrairement à <literal>INTERNAL</literal>, il existe plus
       d'un objet référencé. L'objet dépendant ne doit pas être supprimé sauf
       si au moins un des objets référencés est supprimé&nbsp;; si c'est le
       cas, l'objet dépendant doit être supprimé que
       <literal>CASCADE</literal> soit indiqué ou pas. De plus, contrairement
       à <literal>INTERNAL</literal>, une suppression de certains autres
       objets dont l'objet dépendant dépend ne résulte pas en une suppression
       automatique d'objet référencé par une patition. De ce fait, si la
       suppression ne cascade pas vers au moins un de ces objets via un autre
       chemin, elle sera refusée. (Dans la plupart des cas, l'objet dépendant
       partage toutes ses dépendances non-partitions avec au moins un objet
       référencé par partition, donc cette restriction ne résulte pas dans le
       blocage de suppression en cascade). Les dépendances de partitions
       primaire et secondaire se comportent de façon identique sauf que la
       dépendance primaire est préféré pour une utilisation dans les messages
       d'erreur. De ce fait, un objet dépendant d'une partition devrait avoir
       une dépendance de partition primaire et une ou plusieurs dépendances de
       partition secondaires. Notez que les dépendances de partition sont
       faites en plus, et non pas à la place, de toute dépendant que l'objet
       aurait normalement. Ceci simplifie les opérations
       <command>ATTACH/DETACH PARTITION</command>&nbsp;: les dépendances
       partitions ont seulement besoin d'être ajoutées ou supprimées. Par
       exemple, une partition d'un index est rendue dépendante de la partition
       de la table et de l'index partitionné, pour qu'elle disparaisse si l'un
       des deux est supprimé, mais pas autrement. La dépendance sur l'index
       parent est primaire, pour que si l'utilisateur essaie de supprimer
       l'index partitionné, le message d'erreur suggèrera la suppression de
       l'index parent à la place (et non pas de la table).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_EXTENSION</symbol> (<literal>e</literal>)</term>
     <listitem>
      <para>
       L'objet dépendant est un membre de l'<firstterm>extension</firstterm>
       qui est l'objet référencé (voir
       <link linkend="catalog-pg-extension"><structname>pg_extension</structname></link>).
       L'objet dépendant peut être supprimé seulement via l'instruction
       <link linkend="sql-dropextension"><command>DROP EXTENSION</command></link>
       sur l'objet référence.
       Fonctionnellement, ce type de dépendance agit de la même façon
       qu'une dépendance <literal>INTERNAL</literal> mais il est séparé pour des raisons de
       clarté et pour simplifier <application>pg_dump</application>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_AUTO_EXTENSION</symbol> (<literal>x</literal>)</term>
     <listitem>
      <para>
       L'objet dépendant n'est pas un membre de l'extension qui est l'objet
       référencé (et donc ne doit pas être ignoré par
       <application>pg_dump</application>), mais il ne peut fonctionner sans
       l'extension et doit être supprimé automatiquement si l'extension l'est.
       L'objet dépendant peut aussi être supprimé tout seul.
       Fonctionnellement, ce type de dépendance agit de la même façon que la
       dépendance <literal>AUTO</literal>, mais il est séparé pour des raisons
       de clareté et pour simplifier <application>pg_dump</application>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   D'autres types de dépendance peuvent apparaître dans le futur.
  </para>

  <para>
   Notez qu'il est bien possible que les deux objets soient liés par plus d'un
   enregistrement dans <structname>pg_depend</structname>. Par exemple, un
   index fils partitionné pourrait avoir à la fois une dépendance de type
   partition sur la table partitionnée associée et une dépendance automatique
   de chaque colonne de la table qu'il indexe. Ce type de situation exprime
   l'union de plusieurs sémantiques de dépendances. Un objet dépendant peut
   être supprimé sans <literal>CASCADE</literal> si toutes ses dépendances
   satisfont la condition de suppression automatique. Dans le cas contraire,
   toutes les restrictions de dépendance sur les objets à supprimer ensemble
   doivent être satisfaites.
  </para>

  <para>
   La plupart des objets créés lors de l'exécution
   d'<application>initdb</application> sont considérés <quote>fixés</quote>, ce
   qui signifie que le système lui-même dépend de ces objets.  De ce fait, il
   n'est pas autorisé de les supprimer. De plus, sachant que ces objets fixés ne
   seront pas supprimés, le mécanisme de dépendance ne s'occupe pas de créer les
   entrées dans <structname>pg_depend</structname> montrant les dépendances
   entre eux. De ce fait, par exemple, une colonne d'une table de type
   <type>numeric</type> a une dépendance de type <literal>NORMAL</literal> sur
   le type de données <type>numeric</type>, mais cette dépendance n'apparaît pas
   dans <structname>pg_depend</structname>.
  </para>
 </sect1>


 <sect1 id="catalog-pg-description">
  <title><structname>pg_description</structname></title>

  <indexterm zone="catalog-pg-description">
   <primary>pg_description</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_description</structname> stocke les descriptions
   (commentaires) optionnelles de chaque objet de la base de données. Les
   descriptions sont manipulées avec la commande <link
   linkend="sql-comment"><command>COMMENT</command></link>
   et lues avec les commandes <literal>\d</literal>
   de <application>psql</application>. <structname>pg_description</structname>
   contient les descriptions prédifinies de nombreux objets internes.
  </para>

  <para>
   Voir aussi
   <link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link>,
   qui offre la même fonction pour les descriptions des
   objets partagés au sein d'un cluster.
  </para>

  <table>
   <title>Colonnes de <structname>pg_description</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>objoid</structfield> <type>oid</type>
        (référence toute colonne OID)
       </para>
       <para>
        OID de l'objet commenté
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>classoid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du catalogue système dans lequel apparaît l'objet
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>objsubid</structfield> <type>int4</type>
       </para>
       <para>
        Pour un commentaire de colonne de table, le numéro de la colonne. Les champs
        <structfield>objoid</structfield> et <structfield>classoid</structfield>
        font référence à la
        table elle-même. Pour tous les autres types de données, cette colonne
        est à 0.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>description</structfield> <type>text</type>
       </para>
       <para>
        Texte quelconque commentant l'objet
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-enum">
  <title><structname>pg_enum</structname></title>

  <indexterm zone="catalog-pg-enum">
   <primary>pg_enum</primary>
  </indexterm>

  <para>
   Le catalogue système <structname>pg_enum</structname> contient des
   entrées indiquant les valeurs et labels de chaque type enum. La
   représentation interne d'une valeur enum donnée est en fait l'OID de
   sa ligne associée dans <structname>pg_enum</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_enum</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>enumtypid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de l'entrée <link
        linkend="catalog-pg-type"><structname>pg_type</structname></link>
        correspondant à cette valeur d'enum
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>enumsortorder</structfield> <type>float4</type>
       </para>
       <para>
        La position de tri de cette valeur enum dans son type
        enum
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>enumlabel</structfield> <type>name</type>
       </para>
       <para>
        Le label texte pour cette valeur d'enum
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les OID des lignes de <structname>pg_enum</structname> suivent une
   règle spéciale&nbsp;: les OID pairs sont garantis triés de la même
   façon que l'ordre de tri de leur type enum. Autrement dit, si deux OID
   pairs appartiennent au même type enum, l'OID le plus petit doit avoir
   la plus petite valeur dans la colonne
   <structfield>enumsortorder</structfield>. Les valeurs d'OID impaires
   n'ont pas d'ordre de tri. Cette règle permet que les routines de
   comparaison d'enum évitent les recherches dans les catalogues dans la
   plupart des cas standards. Les routines qui créent et modifient les
   types enum tentent d'affecter des OID paires aux valeurs enum tant que
   c'est possible.
  </para>

  <para>
   Quand un type enum est créé, ses membres sont affectés dans l'ordre
   des positions 1..<replaceable>n</replaceable>. Les membres ajoutés par
   la suite doivent se voir affecter des valeurs négatives ou
   fractionnelles de <structfield>enumsortorder</structfield>. Le seul
   prérequis pour ces valeurs est qu'elles soient correctement triées
   et uniques pour chaque type enum.
  </para>
 </sect1>

 <sect1 id="catalog-pg-event-trigger">
  <title><structname>pg_event_trigger</structname></title>

  <indexterm zone="catalog-pg-event-trigger">
   <primary>pg_event_trigger</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_event_trigger</structname> enregistre les
   triggers sur événement.
   Voir <xref linkend="event-triggers"/> pour plus d'informations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_event_trigger</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>evtname</structfield> <type>name</type>
       </para>
       <para>
        Nom du trigger (doit être unique)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>evtevent</structfield> <type>name</type>
       </para>
       <para>
        Identifie l'événement pour lequel ce trigger se déclenche
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>evtowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire du trigger d'événement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>evtfoid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        La fonction à appeler
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>evtenabled</structfield> <type>char</type>
       </para>
       <para>
        Contrôle le mode <xref linkend="guc-session-replication-role"/> dans
        lequel ce trigger d'événement se déclenche.
        <literal>O</literal> = le trigger se déclenche dans les modes <quote>origin</quote> et <quote>local</quote>,
        <literal>D</literal> = le trigger est désactivé,
        <literal>R</literal> = le trigger se déclenche dans le mode <quote>replica</quote>,
        <literal>A</literal> = le trigger se déclenche toujours.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>evttags</structfield> <type>text[]</type>
       </para>
       <para>
        Balises de commande pour lesquelles ce trigger va se déclencher. Si
        NULL, le déclenchement de ce trigger n'est pas restreint sur la base
        de la balise de commande.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-extension">
  <title><structname>pg_extension</structname></title>

  <indexterm zone="catalog-pg-extension">
   <primary>pg_extension</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_extension</structname> stocke les
   informations sur les extensions installées. Voir <xref
   linkend="extend-extensions"/> pour des détails sur les extensions.
  </para>

  <table>
   <title>Colonnes de <structname>pg_extension</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>extname</structfield> <type>name</type>
       </para>
       <para>
        Nom de l'extension
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>extowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire de l'extension
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>extnamespace</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Schéma contenant les objets exportés de l'extension
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>extrelocatable</structfield> <type>bool</type>
       </para>
       <para>
        Vrai si l'extension peut être déplacée dans un autre schéma
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>extversion</structfield> <type>text</type>
       </para>
       <para>
        Nom de la version de l'extension
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>extconfig</structfield> <type>oid[]</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Tableaux d'OID de type <type>regclass</type> pour la table
        de configuration de l'extension, ou <literal>NULL</literal> si aucun
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>extcondition</structfield> <type>text[]</type>
       </para>
       <para>
        Tableau de conditions de filtre (clauses
        <literal>WHERE</literal>) pour la table de configuration de
        l'extension, ou <literal>NULL</literal> si aucun
       </para></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Notez que, contrairement aux autres catalogues ayant une colonne de
   <quote>schéma</quote>, <structfield>extnamespace</structfield> n'est
   pas le schéma contenant l'extension. Les noms des extensions ne
   sont jamais qualifiés d'un schéma. En fait,
   <structfield>extnamespace</structfield> indique le schéma qui
   contient la plupart ou tous les objets de l'extension. Si
   <structfield>extrelocatable</structfield> vaut true, alors ce schéma
   doit en fait contenir tous les objets de l'extension, dont le nom
   peut être qualifié avec le nom du schéma.
  </para>
 </sect1>

 <sect1 id="catalog-pg-foreign-data-wrapper">
  <title><structname>pg_foreign_data_wrapper</structname></title>

  <indexterm zone="catalog-pg-foreign-data-wrapper">
   <primary>pg_foreign_data_wrapper</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_foreign_data_wrapper</structname> stocke les
   définitions des wrappers de données distantes. Un wrapper de données distantes
   est le mécanisme par lequel des données externes, stockées sur des serveurs
   distants, sont accédées.
  </para>

  <table>
   <title>Colonnes de <structname>pg_foreign_data_wrapper</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>fdwname</structfield> <type>name</type>
       </para>
       <para>
        Nom du wrapper de données distantes
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>fdwowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire du wrapper de données distantes
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>fdwhandler</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Référence une fonction de gestion responsable de la fourniture
        de routines d'exécution pour le wrapper de données distantes.
        Zéro si aucune fonction n'est fournie.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>fdwvalidator</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Référence le validateur de fonction qui est responsable de vérifier la
        validité des options passées au wrapper de données distantes,
        ainsi que les options des serveurs distants et les correspondances
        utilisateurs du wrapper de données distantes. Zéro si aucun validateur n'est fourni.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>fdwacl</structfield> <type>aclitem[]</type>
       </para>
       <para>
        Droits d'accès&nbsp;; voir <xref linkend="ddl-priv"/>
        pour plus de détails
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>fdwoptions</structfield> <type>text[]</type>
       </para>
       <para>
        Options spécifiques pour un wrapper de données distantes, sous la forme de chaînes
        <quote>motclé=valeur</quote>
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-foreign-server">
  <title><structname>pg_foreign_server</structname></title>

  <indexterm zone="catalog-pg-foreign-server">
   <primary>pg_foreign_server</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_foreign_server</structname> stocke les
   définitions de serveurs distants. Un serveur distant décrit une
   source de données externes, comme un serveur distant. Les serveurs
   distants sont accédés via des wrappers de données distantes.
  </para>

  <table>
   <title>Colonnes de <structname>pg_foreign_server</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>srvname</structfield> <type>name</type>
       </para>
       <para>
        Nom du serveur distant
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>srvowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire du serveur distant
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>srvfdw</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-foreign-data-wrapper"><structname>pg_foreign_data_wrapper</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du wrapper de données distantes pour ce serveur distant
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>srvtype</structfield> <type>text</type>
       </para>
       <para>
        Type du serveur (optionnel)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>srvversion</structfield> <type>text</type>
       </para>
       <para>
        Version du serveur (optionnel)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>srvacl</structfield> <type>aclitem[]</type>
       </para>
       <para>
        Droits d'accès&nbsp;; voir <xref linkend="ddl-priv"/>
        pour les détails
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>srvoptions</structfield> <type>text[]</type>
       </para>
       <para>
        Options pour le serveur distant, sous la forme de chaînes
        <quote>motclé=valeur</quote>.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-foreign-table">
  <title><structname>pg_foreign_table</structname></title>

  <indexterm zone="catalog-pg-foreign-table">
   <primary>pg_foreign_table</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_foreign_table</structname> contient des
   informations supplémentaires sur les tables distantes. Une table
   distante est principalement représentée par une entrée dans le
   catalogue <link linkend="catalog-pg-class"><structname>pg_class</structname></link>,
   comme toute table
   ordinaire. Son entrée dans <structname>pg_foreign_table</structname>
   contient les informations pertinentes aux seules tables distantes, et
   pas aux autres types de relation.
  </para>

  <table>
   <title>Colonnes de <structname>pg_foreign_table</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ftrelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de l'entrée dans le catalogue
        <link linkend="catalog-pg-class"><structname>pg_class</structname></link>
        pour cette table distante
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ftserver</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du serveur distant pour cette table distante
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ftoptions</structfield> <type>text[]</type>
       </para>
       <para>
        Options de la table distante, sous la forme de chaînes
        <quote>clé=valeur</quote>
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-index">
  <title><structname>pg_index</structname></title>

  <indexterm zone="catalog-pg-index">
   <primary>pg_index</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_index</structname> contient une partie des
   informations concernant les index. Le reste se trouve pour l'essentiel dans
   <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_index</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indexrelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de l'entrée dans
        <link linkend="catalog-pg-class"><structname>pg_class</structname></link>
        pour l'index
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indrelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de l'entrée dans <link linkend="catalog-pg-class"><structname>pg_class</structname></link> de la table sur
        laquelle porte l'index
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indnatts</structfield> <type>int2</type>
       </para>
       <para>
        Le nombre total de colonnes dans l'index (duplique
        <literal>pg_class.relnatts</literal>). Ce nombre inclut les attributs
        clé et supplémentaires.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indnkeyatts</structfield> <type>int2</type>
       </para>
       <para>
        Le nombre de <firstterm>colonnes clés</firstterm> dans l'index,
        sans compter les <firstterm>colonnes supplémentaires</firstterm>, qui
        sont simplement enregistrés et ne participent pas à la sémantique de
        l'index
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indisunique</structfield> <type>bool</type>
       </para>
       <para>
        Vrai s'il s'agit d'un index d'unicité
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>indnullsnotdistinct</structfield> <type>bool</type>
      </para>
      <para>
       Cette valeur est seulement utilisée pour les index d'unicité. Si sa
       valeur est false, cet index d'unicité considérera les valeurs NULL comme
       distinctes les unes des autres (donc l'index peut contenir plusieurs
       valeurs NULL dans une colonne, ce qui correspond au comportement par
       défaut de PostgreSQL). Si sa valeur est true, il considérera les valeurs
       NULL comme égales (donc l'index peut seulement contenir une valeur NULL
       dans une colonne).
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indisprimary</structfield> <type>bool</type>
       </para>
       <para>
        Vrai s'il s'agit de l'index de clé primaire de la table
        (<structfield>indisunique</structfield> doit toujours être vrai quand
        ce champ l'est.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indisexclusion</structfield> <type>bool</type>
       </para>
       <para>
        Vrai s'il s'agit de l'index supportant une contrainte
        d'exclusion
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indimmediate</structfield> <type>bool</type>
       </para>
       <para>
        Si vrai, la vérification de l'unicité est forcée immédiatement
        lors de l'insertion (inutile si <structfield>indisunique</structfield>
        ne vaut pas true)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indisclustered</structfield> <type>bool</type>
       </para>
       <para>
        Vrai si la table a été réorganisée en fonction de l'index
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indisvalid</structfield> <type>bool</type>
       </para>
       <para>
        Si ce drapeau est vrai, l'index est valide pour les requêtes.
        Faux signifie
        que l'index peut être incomplet&nbsp;: les opérations
        <link linkend="sql-insert"><command>INSERT</command></link> /
        <link linkend="sql-update"><command>UPDATE</command></link>
        peuvent toujours l'utiliser, mais il ne peut pas être utilisé
        sans risque pour les requêtes, et, dans le cas d'un index d'unicité,
        cette propriété n'est plus garantie.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indcheckxmin</structfield> <type>bool</type>
       </para>
       <para>
        Si vrai, les requêtes ne doivent pas utiliser l'index tant que le
        <structfield>xmin</structfield> de cette ligne de
        <structname>pg_index</structname> est en-dessous de leur horizon
        d'événements <symbol>TransactionXmin</symbol>, car la table peut
        contenir des <link linkend="storage-hot">chaînes HOT</link>
        cassées avec des lignes incompatibles qu'elles peuvent voir.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indisready</structfield> <type>bool</type>
       </para>
       <para>
        Si vrai, l'index est actuellement prêt pour les insertions. Faux indique
        que l'index doit être ignoré par les opérations
        <link linkend="sql-insert"><command>INSERT</command></link> /
        <link linkend="sql-update"><command>UPDATE</command></link>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indislive</structfield> <type>bool</type>
       </para>
       <para>
        Si faux, l'index est en cours de suppression et devrait être complètement
        ignoré (y compris pour les décisions sur la sûreté de HOT)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indisreplident</structfield> <type>bool</type>
       </para>
       <para>
        Si vrai, cet index a été choisi comme <quote>identité de réplication</quote>
        en utilisant <link linkend="sql-altertable-replica-identity"><command>ALTER
        TABLE ... REPLICA IDENTITY USING INDEX ...</command></link>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indkey</structfield> <type>int2vector</type>
        (référence <link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.<structfield>attnum</structfield>)
       </para>
       <para>
        C'est un tableau de valeurs <structfield>indnatts</structfield> qui
        indique les colonnes de la table indexées. Par exemple, une valeur
        <literal>1 3</literal> signifie que la première et la troisième colonne
        de la table composent la clé de l'index. Les colonnes clés viennent
        avant les colonnes supplémentaires, non clés. Un 0 dans ce tableau
        indique que l'attribut de l'index correspondant est une expression sur
        les colonnes de la table plutôt qu'une simple référence de colonne.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indcollation</structfield> <type>oidvector</type>
        (référence <link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Pour chaque colonne dans la clé de l'index (<structfield>indnkeyatts</structfield> values), cette colonne contient
        l'OID du collationnement à utiliser pour l'index, ou zéro si la colonne
        n'est pas d'un type de données collationnable.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indclass</structfield> <type>oidvector</type>
        (référence <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Pour chaque colonne de la clé d'indexation (<structfield>indnkeyatts</structfield> values), contient l'OID de la
        classe d'opérateurs à utiliser. Voir
        <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>
        pour plus de détails.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indoption</structfield> <type>int2vector</type>
       </para>
       <para>
        C'est un tableau de valeurs <structfield>indnkeyatts</structfield> qui
        enregistrent des drapeaux d'information par colonne. La signification
        de ces drapeaux est définie par la méthode d'accès à l'index.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indexprs</structfield> <type>pg_node_tree</type>
       </para>
       <para>
        Arbres d'expression (en représentation
        <function>nodeToString()</function>)
        pour les attributs d'index qui ne sont pas de simples références de
        colonnes. Il s'agit d'une liste qui contient un élément par entrée à
        0 dans <structfield>indkey</structfield>. Nul si tous les attributs d'index sont
        de simples références.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>indpred</structfield> <type>pg_node_tree</type>
       </para>
       <para>
        Arbre d'expression (en représentation
        <function>nodeToString()</function>) pour les prédicats d'index partiels.
        Nul s'il ne s'agit pas d'un index partiel.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-inherits">
  <title><structname>pg_inherits</structname></title>

  <indexterm zone="catalog-pg-inherits">
   <primary>pg_inherits</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_inherits</structname> enregistre l'information
   sur la hiérarchie d'héritage des tables et des index. Il existe une entrée
   pour chaque table ou index enfant direct dans la base de données.
   (L'héritage indirect peut être déterminé en suivant les chaînes d'entrées.)
  </para>

  <table>
   <title>Colonnes de <structname>pg_inherits</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>inhrelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de la table fille ou de l'index fille
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>inhparent</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de la table mère ou de l'index mère
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>inhseqno</structfield> <type>int4</type>
       </para>
       <para>
        S'il y a plus d'un parent direct pour une table fille (héritage multiple), ce
        nombre indique dans quel ordre les colonnes héritées doivent être
        arrangées. Le compteur commence à 1.
       </para>
       <para>
        Les index ne peuvent pas avoir plusieurs héritages car elle peuvent
        seulement hériter dans le cas du partitionnement déclaratif.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>inhdetachpending</structfield> <type>bool</type>
      </para>
      <para>
       <literal>true</literal> pour une partition qui est en cours de
       détachement&nbsp;; <literal>false</literal> sinon.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-init-privs">
  <title><structname>pg_init_privs</structname></title>

  <indexterm zone="catalog-pg-init-privs">
   <primary>pg_init_privs</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_init_privs</structname> enregistre des
   informations sur les droits initiaux des objets dans le système. Il
   existe une entrée pour chaque objet de la base qui n'a pas sa
   configuration initiale des droits.
  </para>

  <para>
   Les objets peuvent avoir des droits initiaux, soit en ayant ces droits
   configurés quand le système est initialisé (par
   <application>initdb</application>) soit quand l'objet est créé lors d'un
   <link linkend="sql-createextension"><command>CREATE
   EXTENSION</command></link> et que le script de l'extension configure les
   droits initiaux en utilisant la commande <link
   linkend="sql-grant"><command>GRANT</command></link>. Notez
   que le système gère automatiquement l'enregistrement des droits lors de
   l'exécution du script de l'extension et que les auteurs d'extension ont juste
   besoin d'utiliser les commandes <command>GRANT</command> et
   <command>REVOKE</command> dans leur scripts pour que les droits soient
   enregistrés. La colonne <literal>privtype</literal> indique si le droit
   initial a été configuré par <application>initdb</application> ou par une
   commande <command>CREATE EXTENSION</command>.
  </para>

  <para>
   Les objects qui ont des droits initiaux configurés par
   <application>initdb</application> auront des entrées où
   <literal>privtype</literal> vaut <literal>'i'</literal> alors que les
   objets qui ont des droits initiaux configurés par <command>CREATE
    EXTENSION</command> auront des entrées dont <literal>privtype</literal>
   vaut <literal>'e'</literal>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_init_privs</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>objoid</structfield> <type>oid</type>
        (référence toute colonne OID)
       </para>
       <para>
        L'OID de l'objet spécifié
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>classoid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID du catalogue spécifique où se trouve l'objet
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>objsubid</structfield> <type>int4</type>
       </para>
       <para>
        Pour une colonne de table, c'est le numéro de la colonne
        (<structfield>objoid</structfield> et <structfield>classoid</structfield>
        font référence à la table elle-même). Pour tous les autres types
        d'objet, cette colonne vaut zéro.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>privtype</structfield> <type>char</type>
       </para>
       <para>
        Un code définissant le type de droit initial pour cet objet&nbsp;;
        voir le texte.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>initprivs</structfield> <type>aclitem[]</type>
       </para>
       <para>
        Les droits d'accès initiaux&nbsp;; voir <xref linkend="ddl-priv"/>
        pour les détails
       </para></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-language">
  <title><structname>pg_language</structname></title>

  <indexterm zone="catalog-pg-language">
   <primary>pg_language</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_language</structname> enregistre les langages
   utilisables pour l'écriture de fonctions ou
   procédures stockées. Voir <xref linkend="sql-createlanguage"/> et dans le
   <xref linkend="xplang"/> pour plus d'information sur les gestionnaires
   de langages.
  </para>

  <table>
   <title>Colonnes de <structname>pg_language</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>lanname</structfield> <type>name</type>
       </para>
       <para>
        Nom du langage
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>lanowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire du langage
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>lanispl</structfield> <type>bool</type>
       </para>
       <para>
        Faux pour les langages internes (comme <acronym>SQL</acronym>) et
        vrai pour les langages utilisateur. À l'heure actuelle,
        <application>pg_dump</application> utilise ce champ pour déterminer
        les langages à sauvegarder mais cela peut être
        un jour remplacé par un mécanisme différent.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>lanpltrusted</structfield> <type>bool</type>
       </para>
       <para>
        Vrai s'il s'agit d'un langage de confiance
        (<foreignphrase>trusted</foreignphrase>), ce qui signifie qu'il
        est supposé ne pas donner accès à ce qui dépasse
        l'exécution normale des requêtes SQL. Seuls les superutilisateurs
        peuvent créer des fonctions dans des langages qui ne sont pas dignes de
        confiance.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>lanplcallfoid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Pour les langages non-internes, ceci référence le gestionnaire de
        langage, fonction spéciale en charge de l'exécution de toutes
        les fonctions écrites dans ce langage. Zéro pour les langages internes.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>laninline</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Ceci référence une fonction qui est capable d'exécuter des blocs de
        code anonyme <quote>en ligne</quote> (blocs <xref linkend="sql-do"/>).
        Zéro si les blocs en ligne ne sont pas supportés
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>lanvalidator</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Ceci référence une fonction de validation de langage, en charge de
        vérifier la syntaxe et la validité des nouvelles fonctions lors de
        leur création. 0 si aucun validateur n'est fourni.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>lanacl</structfield> <type>aclitem[]</type>
       </para>
       <para>
        Droits d'accès&nbsp;;; voir <xref linkend="ddl-priv"/>
        pour les détails.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-largeobject">
  <title><structname>pg_largeobject</structname></title>

  <indexterm zone="catalog-pg-largeobject">
   <primary>pg_largeobject</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_largeobject</structname> contient les données
   qui décrivent les <quote>Large Objects</quote>
   (<foreignphrase>large objects</foreignphrase>). Un Large Object
   est identifié par un OID qui lui est affecté lors de sa création.
   Chaque Large Object est coupé en segments ou <quote>pages</quote>
   suffisamment petits pour être facilement stockés dans des lignes de
   <structname>pg_largeobject</structname>.
   La taille de données par page est définie par <symbol>LOBLKSIZE</symbol>, qui vaut
   actuellement <literal>BLCKSZ/4</literal>, soit habituellement 2&nbsp;ko).
  </para>

  <para>
   Avant <productname>PostgreSQL</productname> 9.0, il n'existait pas de
   droits associés aux «&nbsp;Large Objects&nbsp;». Du coup,
   <structname>pg_largeobject</structname> était lisible par tout le monde et
   pouvait être utilisé pour obtenir les OID (et le contenu) de tous les
   «&nbsp;Large Objects&nbsp;» du système. Ce n'est plus le cas&nbsp;;
   utilisez <link
   linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link>
   pour obtenir une liste des OID des «&nbsp;Large Objects&nbsp;».
  </para>

  <table>
   <title>Colonnes de <structname>pg_largeobject</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>loid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Identifiant du Large Object qui contient la page
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>pageno</structfield> <type>int4</type>
       </para>
       <para>
        Numéro de la page au sein du Large Object, en partant
        de 0
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>data</structfield> <type>bytea</type>
       </para>
       <para>
        Données effectivement stockées dans le Large Object. Il ne fait
        jamais plus de <symbol>LOBLKSIZE</symbol> mais peut faire moins.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Chaque ligne de <structname>pg_largeobject</structname> contient les données
   d'une page du Large Object, en commençant au décalage d'octet
   (<literal>pageno * LOBLKSIZE</literal>) dans l'objet. Ceci permet un stockage
   diffus&nbsp;: des pages peuvent manquer, d'autres faire moins de
   <literal>LOBLKSIZE</literal> octets même s'il ne s'agit pas de la dernière de
   l'objet. Les parties manquantes sont considérées comme des suites de zéro.
  </para>

 </sect1>


 <sect1 id="catalog-pg-largeobject-metadata">
  <title><structname>pg_largeobject_metadata</structname></title>

  <indexterm zone="catalog-pg-largeobject-metadata">
   <primary>pg_largeobject_metadata</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_largeobject_metadata</structname> contient des
   méta-données associées aux «&nbsp;Larges Objects&nbsp;». Les données des
   «&nbsp;Larges Objects&nbsp;» sont réellement stockées dans <link
   linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_largeobject_metadata</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>lomowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire du «&nbsp;Larges Object&nbsp;»
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>lomacl</structfield> <type>aclitem[]</type>
       </para>
       <para>
        Droits d'accès&nbsp;; pour plus de détails, voir
        <xref linkend="ddl-priv"/>
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-namespace">
  <title><structname>pg_namespace</structname></title>

  <indexterm zone="catalog-pg-namespace">
   <primary>pg_namespace</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_namespace</structname> stocke les
   <foreignphrase>namespace</foreignphrase>. Un
   <foreignphrase>namespace</foreignphrase> est la structure sous-jacente
   aux schémas SQL&nbsp;: chaque <foreignphrase>namespace</foreignphrase>
   peut contenir un ensemble séparé de relations, types, etc. sans
   qu'il y ait de conflit de nommage.
  </para>

  <table>
   <title>Colonnes de <structname>pg_namespace</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>nspname</structfield> <type>name</type>
       </para>
       <para>
        Nom du <foreignphrase>namespace</foreignphrase>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>nspowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire du <foreignphrase>namespace</foreignphrase>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>nspacl</structfield> <type>aclitem[]</type>
       </para>
       <para>
        Droits d'accès&nbsp;; voir <xref linkend="ddl-priv"/>
        pour les détails.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-opclass">
  <title><structname>pg_opclass</structname></title>

  <indexterm zone="catalog-pg-opclass">
   <primary>pg_opclass</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_opclass</structname> définit les classes
   d'opérateurs de méthodes d'accès aux index. Chaque classe d'opérateurs définit
   la sémantique pour les colonnes d'index d'un type particulier et d'une
   méthode d'accès particulière. Une classe d'opérateurs définit essentiellement
   qu'une famille d'opérateur particulier est applicable à un type de données
   indexable particulier. L'ensemble des opérateurs de la famille actuellement
   utilisables avec la colonne indexée sont tous ceux qui acceptent le type de
   données de la colonne en tant qu'entrée du côté gauche.
  </para>

  <para>
   Les classes d'opérateurs sont longuement décrites dans la
   <xref linkend="xindex"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_opclass</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>opcmethod</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-am"><structname>pg_am</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Méthode d'accès à l'index pour laquelle est définie la classe
        d'opérateurs
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>opcname</structfield> <type>name</type>
       </para>
       <para>
        Nom de la classe d'opérateurs
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>opcnamespace</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        <foreignphrase>Namespace</foreignphrase> de la classe d'opérateurs
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>opcowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire de la classe d'opérateurs
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>opcfamily</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Famille d'opérateur contenant la classe d'opérateurs
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>opcintype</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Type de données que la classe d'opérateurs indexe
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>opcdefault</structfield> <type>bool</type>
       </para>
       <para>
        Vrai si la classe d'opérateurs est la classe par défaut pour
        <structfield>opcintype</structfield>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>opckeytype</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Type de données stocké dans l'index ou 0 s'il s'agit du même que
        <structfield>opcintype</structfield>
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   L'<structfield>opcmethod</structfield> d'une classe d'opérateurs doit
   coïncider avec l'<structfield>opfmethod</structfield> de la famille
   d'opérateurs qui le contient. Il ne doit pas non plus y avoir plus d'une
   ligne <structname>pg_opclass</structname> pour laquelle
   <structfield>opcdefault</structfield> est vrai, quelque soit la combinaison de
   <structfield>opcmethod</structfield> et <structfield>opcintype</structfield>.
  </para>

 </sect1>


 <sect1 id="catalog-pg-operator">
  <title><structname>pg_operator</structname></title>

  <indexterm zone="catalog-pg-operator">
   <primary>pg_operator</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_operator</structname> stocke les informations
   concernant les opérateurs. Voir la commande <xref
   linkend="sql-createoperator"/> et la <xref linkend="xoper"/> pour plus
   d'informations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_operator</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oprname</structfield> <type>name</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oprname</structfield> <type>name</type>
       </para>
       <para>
        Nom de l'opérateur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oprnamespace</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du <foreignphrase>namespace</foreignphrase> qui contient l'opérateur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oprowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire de l'opérateur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oprkind</structfield> <type>char</type>
       </para>
       <para>
        <literal>b</literal> = opérateur infix (<quote>les deux</quote>) ou
        <literal>l</literal> = opérateur préfixe (<quote>gauche</quote>)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oprcanmerge</structfield> <type>bool</type>
       </para>
       <para>
        L'opérateur supporte les jointures de fusion
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oprcanhash</structfield> <type>bool</type>
       </para>
       <para>
        L'opérateur supporte les jointures par découpage
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oprleft</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Type de l'opérande de gauche (zéro si opérateur préfixe)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oprright</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Type de l'opérande de droite
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oprresult</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Type du résultat
        (zéro pour un opérateur <quote>shell</quote> pas encore défini)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oprcom</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Commutateur de l'opérateur, s'il existe (zéro sinon)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oprnegate</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Négateur de l'opérateur, s'il existe (zéro sinon)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oprcode</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction codant l'opérateur
        (zéro pour un opérateur <quote>shell</quote> pas encore défini)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oprrest</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction d'estimation de la sélectivité de restriction de
        l'opérateur (zéro sinon)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oprjoin</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction d'estimation de la sélectivité de jointure de
        l'opérateur (zéro sinon)
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-opfamily">
  <title><structname>pg_opfamily</structname></title>

  <indexterm zone="catalog-pg-opfamily">
   <primary>pg_opfamily</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_opfamily</structname> définit les familles
   d'opérateur. Chaque famille d'opérateur est un ensemble d'opérateurs et
   de routines de support associées codant les sémantiques définies
   pour une méthode d'accès particulière de l'index. De plus, les opérateurs
   d'une famille sont tous <quote>compatibles</quote>, au sens défini
   par la méthode d'accès. Le concept de famille d'opérateur autorise
   l'utilisation des opérateurs inter-type de données avec des index et
   l'utilisation des sémantiques de méthode d'accès.
  </para>

  <para>
   Les familles d'opérateur sont décrites dans <xref linkend="xindex"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_opfamily</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>opfmethod</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-am"><structname>pg_am</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Méthode d'accès à l'index pour la famille d'opérateur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>opfname</structfield> <type>name</type>
       </para>
       <para>
        Nom de la famille d'opérateur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>opfnamespace</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        <foreignphrase>namespace</foreignphrase> de la famille d'opérateur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>opfowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire de la famille d'opérateur
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   La majorité des informations définissant une famille d'opérateur n'est pas
   dans la ligne correspondante de <structname>pg_opfamily</structname> mais dans les lignes
   associées de
   <link linkend="catalog-pg-amop"><structname>pg_amop</structname></link>,
   <link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>,
   et
   <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.
  </para>

 </sect1>

 <sect1 id="catalog-pg-parameter-acl">
  <title><structname>pg_parameter_acl</structname></title>

  <indexterm zone="catalog-pg-parameter-acl">
   <primary>pg_parameter_acl</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_parameter_acl</structname> enregistre les
   paramètres de configuration pour lesquels des droits ont été donnés pour un
   ou plusieurs rôles.  Aucun enregistrement n'est fait pour les paramètres qui
   ont les droits par défaut.
  </para>

  <para>
   Contrairement aux autres catalogues systèmes,
   <structname>pg_parameter_acl</structname> est partagé parmi toutes les bases
   de données d'une instance&nbsp;: il n'existe qu'une copie de
   <structname>pg_parameter_acl</structname> par instance, et non pas par base
   de données.
  </para>

  <table>
   <title><structname>pg_parameter_acl</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>oid</structfield> <type>oid</type>
      </para>
      <para>
       Identifiant de ligne
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>parname</structfield> <type>text</type>
      </para>
      <para>
       Nom d'un paramètre de configuration pour lequel des droits ont été
       donnés
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>paracl</structfield> <type>aclitem[]</type>
      </para>
      <para>
       Droits d'accès&nbsp;; voir <xref linkend="ddl-priv"/> pour les détails
      </para></entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-partitioned-table">
  <title><structname>pg_partitioned_table</structname></title>

  <indexterm zone="catalog-pg-partitioned-table">
   <primary>pg_partitioned_table</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_partitioned_table</structname> enregistre des
   informations sur la façon dont les tables sont partitionnées.
  </para>

  <table>
   <title>Colonnes de <structname>pg_partitioned_table</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>partrelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID de la table partitionnée, référencé dans <link
        linkend="catalog-pg-class"><structname>pg_class</structname></link>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>partstrat</structfield> <type>char</type>
       </para>
       <para>
        Stratégie de partitionnement&nbsp;; <literal>h</literal> = partitionnement par hachage,
        <literal>l</literal> = partitionnement par liste,
        <literal>r</literal> = partitionnement par intervalles
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>partnatts</structfield> <type>int2</type>
       </para>
       <para>
        Le nombre de colonnes de la clé de partitionnement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>partdefid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID de l'enregistrement dans <link
        linkend="catalog-pg-class"><structname>pg_class</structname></link> pour
        la partition par défaut de cette table partitionnée ou zéro si cette
        table partitionnée n'a pas de partition par défaut.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>partattrs</structfield> <type>int2vector</type>
        (référence <link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.<structfield>attnum</structfield>)
       </para>
       <para>
        Tableau de <structfield>partnatts</structfield> valeurs indiquant les
        colonnes de la table faisant partie de la clé de partitionnement. Par
        exemple, une valeur <literal>1 3</literal> signifierait que les
        première et troisième colonnes de la table forment la clé de
        partitionnement. Un zéro dans ce tableau indique que la colonne
        correspondante dans la clé partitionnement est une expression, plutôt
        qu'une simple référence de colonne.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>partclass</structfield> <type>oidvector</type>
        (référence <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Pour chaque colonne de la clé de partitionnement, ceci contient l'OID
        de la classe d'opérateurs à utiliser. Voir <link
        linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>
        pour les détails.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>partcollation</structfield> <type>oidvector</type>
        (référence <link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Pour chaque colonne de la clé de partitionnement, ceci contient l'OID
        du collationnement à utiliser pour le partitionnement, ou zéro si la
        colonne n'est pas d'un type de données collationnable.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>partexprs</structfield> <type>pg_node_tree</type>
       </para>
       <para>
        Arbres d'expression (dans une représentation
        <function>nodeToString()</function>) pour les colonnes de la clé de
        partitionnement qui ne sont pas des simples références de colonne.
        C'est une liste avec un élément pour chaque élément 0 dans
        <structfield>partattrs</structfield>. NULL si tous les colonnes de la
        clé de partitionnement sont des références simples.
       </para></entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-policy">
  <title><structname>pg_policy</structname></title>

  <indexterm zone="catalog-pg-policy">
   <primary>pg_policy</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_policy</structname> stocke les politiques
   de sécurité niveau ligne pour les tables. Une politique inclue le
   type de commandes auquel elle s'applique (éventuellement toutes les
   commandes), les rôles auxquels elle s'applique, l'expression à ajouter
   comme barrière de sécurité aux requêtes qui incluent la table,
   et l'expression à ajouter comme option <literal>WITH CHECK</literal>
   aux requêtes qui tentent d'ajouter de nouvelles lignes à la table.
  </para>

  <table>
   <title>Colonnes de <structname>pg_policy</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>polname</structfield> <type>name</type>
       </para>
       <para>
        Le nom de la politique de sécurité
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>polrelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        La table à laquelle s'applique la politique de sécurité
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>polcmd</structfield> <type>char</type>
       </para>
       <para>
        Le type de commande auquel est appliqué la politique de sécurité&nbsp;:
        <literal>r</literal> pour <xref linkend="sql-select"/>,
        <literal>a</literal> pour <xref linkend="sql-insert"/>,
        <literal>w</literal> pour <xref linkend="sql-update"/>,
        <literal>d</literal> pour <xref linkend="sql-delete"/>
        ou <literal>*</literal> pour tous
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>polpermissive</structfield> <type>bool</type>
       </para>
       <para>
        La politique est-elle permissive ou restrictive&nbsp;?
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>polroles</structfield> <type>oid[]</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Les rôles à qui est appliquée la politique de sécurité&nbsp;;
        zéro signifie <literal>PUBLIC</literal>
        (et apparaît normalement seule dans le tableau)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>polqual</structfield> <type>pg_node_tree</type>
       </para>
       <para>
        L'arbre de l'expression à ajouter aux barrières de sécurité pour les
        requêtes qui utilisent la table
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>polwithcheck</structfield> <type>pg_node_tree</type>
       </para>
       <para>
        L'arbre de l'expression à ajouter aux qualifications WITH CHECK pour
        les requêtes qui tentent d'ajouter des lignes à la table
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    Les politiques de sécurité stockées dans
    <structname>pg_policy</structname> sont seulement appliquées lorsque
    <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>relrowsecurity</structfield>
    est positionné pour leur table.
   </para>
  </note>

 </sect1>

 <sect1 id="catalog-pg-proc">
  <title><structname>pg_proc</structname></title>

  <indexterm zone="catalog-pg-proc">
   <primary>pg_proc</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_proc</structname> enregistre des informations sur les
   fonctions, procédures, fonctions d'agrégat et fonctions de fenêtrage
   (connues sous le nom collectif de routines). Voir <xref
   linkend="sql-createfunction"/>, <xref linkend="sql-createprocedure"/> et
   <xref linkend="xfunc"/> pour plus d'informations.
  </para>

  <para>
   Si <structfield>prokind</structfield> indique que l'enregistrement est pour
   une fonction d'agrégat, il devrait y avoir une ligne correspondante dans
   <link linkend="catalog-pg-aggregate"><structfield>pg_aggregate</structfield></link>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_proc</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>proname</structfield> <type>name</type>
       </para>
       <para>
        Nom de la fonction
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>pronamespace</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du schéma (<foreignphrase>namespace</foreignphrase>) auquel
        appartient la fonction
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>proowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire de la fonction
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>prolang</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-language"><structname>pg_language</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Langage de codage ou interface d'appel de la fonction
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>procost</structfield> <type>float4</type>
       </para>
       <para>
        Coût d'exécution estimé (en unité de <xref
        linkend="guc-cpu-operator-cost"/>)&nbsp;; si
        <structfield>proretset</structfield>, il s'agit d'un coût par
        ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>prorows</structfield> <type>float4</type>
       </para>
       <para>
        Nombre estimé de lignes de résultat (zéro si
        <structfield>proretset</structfield> est faux)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>provariadic</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Type des données des éléments du tableau de paramètres variadic,
        ou zéro si la fonction n'a pas de paramètres variadiques
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>prosupport</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction optionnelle de support pour le planificateur
        (voir <xref linkend="xfunc-optimization"/>), ou zéro sinon
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>prokind</structfield> <type>char</type>
       </para>
       <para>
        <literal>f</literal> pour une fonction normale,
        <literal>p</literal> pour une procédure, <literal>a</literal> pour une
        fonction d'agrégat ou <literal>w</literal> pour une fonction de
        fenêtrage
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>prosecdef</structfield> <type>bool</type>
       </para>
       <para>
        Si vrai, la fonction définit la sécurité (c'est une
        fonction <quote>setuid</quote>)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>proleakproof</structfield> <type>bool</type>
       </para>
       <para>
        Cette fonction n'a pas d'effets de bord. Aucune information sur les
        arguments n'est reportée sauf via la valeur de retour. Toute fonction
        qui pourrait renvoyer une erreur dépendant des valeurs de ses arguments
        n'est pas considérée sans fuite.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>proisstrict</structfield> <type>bool</type>
       </para>
       <para>
        Si vrai, la fonction retourne NULL si l'un de ses arguments est
        NULL. Dans ce cas, la fonction n'est en fait pas appelée du tout.
        Les fonctions qui ne sont pas <quote>strictes</quote> doivent
        traiter les paramètres NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>proretset</structfield> <type>bool</type>
       </para>
       <para>
        Si vrai, la fonction retourne un ensemble (c'est-à-dire des valeurs
        multiples du type défini)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>provolatile</structfield> <type>char</type>
       </para>
       <para>
        Indique si le résultat de la fonction dépend uniquement de ses
        arguments ou s'il est affecté par des facteurs externes. Il vaut
        <literal>i</literal> pour les fonctions <quote>immuables</quote>, qui,
        pour un jeu de paramètres identique en entrée, donnent toujours le même
        résultat. Il vaut <literal>s</literal> pour les fonctions
        <quote>stables</quote>, dont le résultat (pour les mêmes paramètres en
        entrée) ne change pas au cours du parcours (de table). Il vaut
        <literal>v</literal> pour les fonctions <quote>volatiles</quote>, dont
        le résultat peut varier à tout instant. (<literal>v</literal> est
        également utilisé pour les fonctions qui ont des effets de bord, afin
        que les appels à ces fonctions ne soient pas optimisés.)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>proparallel</structfield> <type>char</type>
       </para>
       <para>
        <structfield>proparallel</structfield> indique si la fonction peut être
        utilisé en parallèle. Cette colonne vaut <literal>s</literal> pour les
        fonctions exécutables sans restriction en mode parallèle. Elle vaut
        <literal>r</literal> pour les fonctions pouvant être exécutées en
        parallèle mais leur exécution est restreinte au chef du groupe&nbsp;;
        les processus de parallélisme en tâche de fond ne peuvent pas faire
        appel à ces fonctions. Elle vaut <literal>u</literal> pour les fonctions
        qui ne peuvent pas être exécutées en mode parallèle. La présence d'une
        telle fonction force une exécution non parallélisée.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>pronargs</structfield> <type>int2</type>
       </para>
       <para>
        Nombre d'arguments en entrée
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>pronargdefaults</structfield> <type>int2</type>
       </para>
       <para>
        Nombre d'arguments qui ont des valeurs par défaut
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>prorettype</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Type de données renvoyé
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>proargtypes</structfield> <type>oidvector</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Un tableau contenant les types de données des arguments de la fonction.
        Ceci n'inclut que les arguments en entrée (dont les arguments
        <literal>INOUT</literal> et <literal>VARIADIC</literal>), et représente
        ainsi la signature d'appel de la fonction.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>proallargtypes</structfield> <type>oid[]</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Un tableau contenant les types de données des arguments de la fonction. Ceci
        inclut tous les arguments (y compris les arguments <literal>OUT</literal>
        et <literal>INOUT</literal>)&nbsp;; néanmoins, si tous les arguments sont
        <literal>IN</literal>, ce champ est NULL. L'indice commence à 1 alors
        que, pour des raisons historiques, <structfield>proargtypes</structfield>
        commence à 0.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>proargmodes</structfield> <type>char[]</type>
       </para>
       <para>
        Un tableau contenant les modes des arguments de la fonction, codés avec
        <literal>i</literal> pour les arguments <literal>IN</literal>,
        <literal>o</literal> pour les arguments <literal>OUT</literal>,
        <literal>b</literal> pour les arguments <literal>INOUT</literal>,
        <literal>v</literal> pour les arguments <literal>VARIADIC</literal>,
        <literal>t</literal> pour les arguments <literal>TABLE</literal>.
        Si tous les arguments sont des arguments <literal>IN</literal>, ce
        champ est NULL.
        Les indices correspondent aux positions de
        <structfield>proallargtypes</structfield>, et non à celles de
        <structfield>proargtypes</structfield>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>proargnames</structfield> <type>text[]</type>
       </para>
       <para>
        Un tableau contenant les noms des arguments de la fonction. Les arguments
        sans nom sont initialisés à des chaînes vides dans le tableau.
        Si aucun des arguments n'a de nom, ce champ est NULL.
        Les indices correspondent aux positions de
        <structfield>proallargtypes</structfield>, et non à celles de
        <structfield>proargtypes</structfield>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>proargdefaults</structfield> <type>pg_node_tree</type>
       </para>
       <para>
        Arbres d'expression (en représentation <function>nodeToString()</function>)
        pour les valeurs par défaut. C'est une liste avec <structfield>pronargdefaults</structfield>
        éléments, correspondant aux <replaceable>N</replaceable> derniers arguments
        d'<emphasis>entrée</emphasis> (c'est-à-dire, les <replaceable>N</replaceable>
        dernières positions <structfield>proargtypes</structfield>).
        Si aucun des arguments n'a de valeur par défaut, ce champ vaudra null.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>protrftypes</structfield> <type>oid[]</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID du type de données pour lequel les transformations s'appliquent.
        Un tableau de types de données argument/résultat pour lesquels
        appliquer les transformations (à partir de la clause
        <literal>TRANSFORM</literal> de la fonction). NULL sinon.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>prosrc</structfield> <type>text</type>
       </para>
       <para>
        Ce champ indique au gestionnaire de fonctions la façon d'invoquer la
        fonction. Il peut s'agir du code source pour un langage interprété, d'un
        symbole de lien, d'un nom de fichier ou de toute autre chose, en
        fonction du langage ou de la convention d'appel.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>probin</structfield> <type>text</type>
       </para>
       <para>
        Information supplémentaire sur la façon d'invoquer la fonction.
        Encore une fois, l'interprétation dépend du langage.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>prosqlbody</structfield> <type>pg_node_tree</type>
      </para>
      <para>
       Corps de fonction SQL pré-analysé. Ceci est utilisé pour les fonctions
       en langage SQL quand le corps est donné dans la notation du standard SQL
       plutôt que comme un litéral de chaîne. Il est NULL dans les autres cas.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>proconfig</structfield> <type>text[]</type>
       </para>
       <para>
        Configuration locale à la fonction pour les variables configurables
        à l'exécution
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>proacl</structfield> <type>aclitem[]</type>
       </para>
       <para>
        Droits d'accès&nbsp;; voir
        <xref linkend="ddl-priv"/> pour plus de détails
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Pour les fonctions compilées, natives ou chargées dynamiquement,
   <structfield>prosrc</structfield> contient le nom de la fonction en
   langage C(symbole de lien). Pour les fonctions en langage SQL,
   <structfield>prosrc</structfield> contient le texte source de la fonction
   si elle est indiquée sous la forme d'une chaîne litérale&nbsp;; mais si le
   corps de la fonction est indiquée dans le style du standard SQL,
   <structfield>prosrc</structfield> est inutilisé (typiquement, une chaîne
   vide) et <structfield>prosqlbody</structfield> contient la définition
   pré-analysée. Pour tous les autres types de langages,
   <structfield>prosrc</structfield> contient le code source de la fonction.
   <structfield>probin</structfield> est NULL, sauf pour les fonctions C
   chargées dynamiquement, pour lesquelles il donne le nom de fichier de la
   bibliothèque partagée qui contient la fonction.
  </para>

 </sect1>

 <sect1 id="catalog-pg-publication">
  <title><structname>pg_publication</structname></title>

  <indexterm zone="catalog-pg-publication">
   <primary>pg_publication</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_publication</structname> contient toutes les
   publications créées dans la base de données. Pour plus d'informations sur
   les publications, voir <xref linkend="logical-replication-publication"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_publication</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>pubname</structfield> <type>name</type>
       </para>
       <para>
        Nom de la publication
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>pubowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire de la publication
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>puballtables</structfield> <type>bool</type>
       </para>
       <para>
        Si true, cette publication inclut automatiquement toutes les
        tables de la base de données, ceci incluant aussi toutes les tables
        créées dans le futur.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>pubinsert</structfield> <type>bool</type>
       </para>
       <para>
        Si true, les opérations <xref linkend="sql-insert"/> sont répliquées
        pour les tables de cette publication.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>pubupdate</structfield> <type>bool</type>
       </para>
       <para>
        Si true, les opérations <xref linkend="sql-update"/> sont répliquées
        pour les tables de cette publication.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>pubdelete</structfield> <type>bool</type>
       </para>
       <para>
        Si true, les opérations <xref linkend="sql-delete"/> sont répliquées
        pour les tables de cette publication
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>pubtruncate</structfield> <type>bool</type>
       </para>
       <para>
        Si true, les opérations <xref linkend="sql-truncate"/> sont
        répliquées pour les tables de la publication.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>pubviaroot</structfield> <type>bool</type>
       </para>
       <para>
        Si true, les opérations sur une partition feuille sont répliquées en
        utilisant l'identité et le schéma de son ancêtre mentionné dans la
        publication à la place de la sienne.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-publication-namespace">
  <title><structname>pg_publication_namespace</structname></title>

  <indexterm zone="catalog-pg-publication-namespace">
   <primary>pg_publication_namespace</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_publication_namespace</structname> contient la
   correspondance entre les schémas et les publications dans la base de données.
   C'est une correspondance plusieurs-à-plusieurs.
  </para>

  <table>
   <title><structname>pg_publication_namespace</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>oid</structfield> <type>oid</type>
      </para>
      <para>
       Identifiant de ligne
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pnpubid</structfield> <type>oid</type>
       (référence <link linkend="catalog-pg-publication"><structname>pg_publication</structname></link>.<structfield>oid</structfield>)
      </para>
      <para>
       Référence à la publication
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pnnspid</structfield> <type>oid</type>
       (référence <link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.<structfield>oid</structfield>)
      </para>
      <para>
       Référence au schéma
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-publication-rel">
  <title><structname>pg_publication_rel</structname></title>

  <indexterm zone="catalog-pg-publication-rel">
   <primary>pg_publication_rel</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_publication_rel</structname> contient la
   correspondance entre relations et publications dans la base de données.
   C'est une correspondance N-N (plusieurs à plusieurs). Voir aussi <xref
   linkend="view-pg-publication-tables"/> pour une meilleure vision de cette
   information.
  </para>

  <table>
   <title>Colonnes de <structname>pg_publication_rel</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>prpubid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-publication"><structname>pg_publication</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Référence à la publication
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>prrelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Référence à la relation
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>prqual</structfield> <type>pg_node_tree</type>
      </para>
      <para>
       Arbre d'expression (dans la représentation de
       <function>nodeToString()</function> pour la condition qualifiante de la
       publication de la relation.  NULL s'il n'y a pas de condition qualifiante
       de la publication.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>prattrs</structfield> <type>int2vector</type>
       (référence <link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.<structfield>attnum</structfield>)
      </para>
      <para>
       Tableau de valeurs qui indique les colonnes de table qui font partie de
       la publication. Par exemple, une valeur de <literal>1 3</literal>
       signifie que les première et troisième colonnes sont publiées.  Une
       valeur NULL indique que toutes les colonnes sont publiées.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-range">
  <title><structname>pg_range</structname></title>

  <indexterm zone="catalog-pg-range">
   <primary>pg_range</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_range</structname> enregistre des informations
   sur les types range. Ce sont des informations supplémentaires à celles
   déjà disponibles dans
   <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_range</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>rngtypid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du type range
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>rngsubtype</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du type élément (sous-type) du type range
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>rngmultitypid</structfield> <type>oid</type>
       (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
      </para>
      <para>
       OID du type multirange pour ce type range
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>rngcollation</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du collationnement utilisé pour les comparaisons d'intervalles,
        ou zéro si aucun
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>rngsubopc</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de la classe d'opérateurs du sous-type, utilisée pour les
        comparaisons d'intervalles
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>rngcanonical</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de la fonction de conversion d'une valeur range en sa forme
        canonique, ou zéro si aucune
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>rngsubdiff</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de la fonction de renvoi de la différence entre deux valeurs
        d'éléments, sous la forme d'un <type>double precision</type>, ou zéro
        si aucune
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structfield>rngsubopc</structfield> (et <structfield>rngcollation</structfield>
   si le type de l'élément peut utilisé un collationnement) détermine l'ordre de
   tri utilisé par le type range. <structfield>rngcanonical</structfield> est
   utilisé quand le type de l'élément est discret.
   <structfield>rngsubdiff</structfield> est optionnel mais doit être fourni pour
   améliorer les performances des index GiST sur le type range.
  </para>

 </sect1>

 <sect1 id="catalog-pg-replication-origin">
  <title><structname>pg_replication_origin</structname></title>

  <indexterm zone="catalog-pg-replication-origin">
   <primary>pg_replication_origin</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_replication_origin</structname>
   contient toutes les origines de réplication créées. Pour
   plus d'informations sur les origines de réplication, voir <xref
   linkend="replication-origins"/>.
  </para>

  <para>
   Contrairement à la plupart des catalogues systèmes,
   <structname>pg_replication_origin</structname> est partagé parmi toutes les
   bases de données d'une instance&nbsp;; il n'existe qu'une seule copie de
   <structname>pg_replication_origin</structname> par instance, et non pas une
   par base.
  </para>

  <table>
   <title>Colonnes de <structname>pg_replication_origin</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>roident</structfield> <type>oid</type>
       </para>
       <para>
        Un identifiant, unique pour l'instance, de l'origine de
        réplication. Ne devrait jamais quitter le système.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>roname</structfield> <type>text</type>
       </para>
       <para>
        Le nom externe, défini par l'utilisateur, d'une origine
        de réplication.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-rewrite">
  <title><structname>pg_rewrite</structname></title>

  <indexterm zone="catalog-pg-rewrite">
   <primary>pg_rewrite</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_rewrite</structname> stocke les règles de
   réécriture pour les tables et les vues.
  </para>

  <table>
   <title>Colonnes de <structname>pg_rewrite</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>rulename</structfield> <type>name</type>
       </para>
       <para>
        Nom de la règle
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ev_class</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Table sur laquelle porte la règle
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ev_type</structfield> <type>char</type>
       </para>
       <para>
        Type d'événement associé à la règle&nbsp;:
        1 = <xref linkend="sql-select"/>,
        2 = <xref linkend="sql-update"/>,
        3 = <xref linkend="sql-insert"/>,
        4 = <xref linkend="sql-delete"/>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ev_enabled</structfield> <type>char</type>
       </para>
       <para>
        Contrôle l'exécution de la règle suivant le mode <xref
        linkend="guc-session-replication-role"/>.
        <literal>O</literal> = la règle se déclenche dans les modes
        <quote>origin</quote> et <quote>local</quote>,
        <literal>D</literal> = la règle est désactivée,
        <literal>R</literal> = la règle s'exécute en mode <quote>replica</quote>,
        <literal>A</literal> = la règle s'exécute à chaque fois.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>is_instead</structfield> <type>bool</type>
       </para>
       <para>
        Vrai s'il s'agit d'une règle <literal>INSTEAD</literal>
        (à la place de).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ev_qual</structfield> <type>pg_node_tree</type>
       </para>
       <para>
        Arbre d'expression (sous la forme d'une représentation
        <function>nodeToString()</function>) pour la condition qualifiant la
        règle.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>ev_action</structfield> <type>pg_node_tree</type>
       </para>
       <para>
        Arbre de requête (sous la forme d'une représentation
        <function>nodeToString()</function>) pour l'action de la règle.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <literal>pg_class.relhasrules</literal>
    doit être vrai si une table possède une règle dans ce catalogue.
   </para>
  </note>

 </sect1>

 <sect1 id="catalog-pg-seclabel">
  <title><structname>pg_seclabel</structname></title>

  <indexterm zone="catalog-pg-seclabel">
   <primary>pg_seclabel</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_seclabel</structname> stocke les
   informations sur les labels de sécurité des objets de la base de
   données. Les labels de sécurité peuvent être manipulés avec la
   commande <link linkend="sql-security-label"><command>SECURITY LABEL</command></link>.
   Pour visualiser plus facilement les labels de sécurité, voir <xref
   linkend="view-pg-seclabels"/>.
  </para>

  <para>
   Voir aussi <link linkend="catalog-pg-shseclabel"><structname>pg_shseclabel</structname></link>,
   qui réaliser une opération similaire pour les labels de sécurité des objets globaux/partagés.
  </para>

  <table>
   <title>Colonnes de <structname>pg_seclabel</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>objoid</structfield> <type>oid</type>
        (référence toute colonne OID)
       </para>
       <para>
        L'OID de l'objet concerné par ce label de sécurité
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>classoid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID du catalogue système où cet objet apparaît
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>objsubid</structfield> <type>int4</type>
       </para>
       <para>
        Pour un label de sécurité sur la colonne d'une table, cette
        colonne correspond au numéro de colonne
        (<structfield>objoid</structfield> et
        <structfield>classoid</structfield> font référence à la table
        elle-même). Pour tous les autres types d'objet, cette colonne
        vaut zéro.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>provider</structfield> <type>text</type>
       </para>
       <para>
        Le fournisseur du label associé avec ce label.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>label</structfield> <type>text</type>
       </para>
       <para>
        Le label de sécurité appliqué sur cet objet.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-sequence">
  <title><structname>pg_sequence</structname></title>

  <indexterm zone="catalog-pg-sequence">
   <primary>pg_sequence</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_sequence</structname> contient des informations
   sur les séquences. Certaines de ces informations sur les séquences, comme le
   nom ou le schéma, sont dans
   <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_sequence</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>seqrelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID de l'enregistrement de cette séquence dans
        <link linkend="catalog-pg-class"><structname>pg_class</structname></link>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>seqtypid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Type de données de la séquence
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>seqstart</structfield> <type>int8</type>
       </para>
       <para>
        Valeur de démarrage de la sequence
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>seqincrement</structfield> <type>int8</type>
       </para>
       <para>
        Valeur d'incrément de la séquence
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>seqmax</structfield> <type>int8</type>
       </para>
       <para>
        Valeur maximale de la séquence
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>seqmin</structfield> <type>int8</type>
       </para>
       <para>
        Valeur minimale de la séquence
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>seqcache</structfield> <type>int8</type>
       </para>
       <para>
        Taille du cache de la séquence
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>seqcycle</structfield> <type>bool</type>
       </para>
       <para>
        La séquence fait-elle un cycle
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-shdepend">
  <title><structname>pg_shdepend</structname></title>

  <indexterm zone="catalog-pg-shdepend">
   <primary>pg_shdepend</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_shdepend</structname> enregistre les relations
   de dépendance entre les objets de la base de données et les objets partagés,
   comme les rôles. Cette information permet à
   <productname>PostgreSQL</productname> de s'assurer que tous ces objets sont
   déréférencés avant toute tentative de suppression.
  </para>

  <para>
   Voir aussi
   <link linkend="catalog-pg-depend"><structname>pg_depend</structname></link>, qui
   réalise une fonction similaire pour les dépendances impliquant les objets
   contenus dans une seule base de données.
  </para>

  <para>
   Contrairement à la plupart des catalogues système,
   <structname>pg_shdepend</structname> est partagé par toutes les bases de
   données d'un cluster&nbsp;: il n'existe qu'une seule copie de
   <structname>pg_shdepend</structname> par cluster, pas une par base de
   données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_shdepend</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>dbid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-database"><structname>pg_database</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID de la base de données dont fait partie l'objet dépendant.
        ou 0 pour un objet partagé
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>classid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID du catalogue système dont fait partie l'objet dépendant
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>objid</structfield> <type>oid</type>
        (référence toute colonne OID)
       </para>
       <para>
        L'OID de l'objet dépendant
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>objsubid</structfield> <type>int4</type>
       </para>
       <para>
        Pour une colonne de table, c'est le numéro de colonne (les
        <structfield>objid</structfield> et <structfield>classid</structfield>
        font référence à la table elle-même). Pour tous les autres types d'objets,
        cette colonne vaut zéro
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>refclassid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID du catalogue système dont fait partie l'objet référencé
        (doit être un catalogue partagé)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>refobjid</structfield> <type>oid</type>
        (référence toute colonne OID)
       </para>
       <para>
        L'OID de l'objet référencé
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>deptype</structfield> <type>char</type>
       </para>
       <para>
        Un code définissant les sémantiques spécifiques des relations de cette
        dépendance&nbsp;; voir le texte.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Dans tous les cas, une entrée <structname>pg_shdepend</structname> indique
   que l'objet référencé ne peut pas être supprimé sans supprimer aussi
   l'objet dépendant. Néanmoins, il existe quelques différences identifiées
   par le <structfield>deptype</structfield>&nbsp;:

   <variablelist>
    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_OWNER</symbol> (<literal>o</literal>)</term>
     <listitem>
      <para>
       L'objet référencé (qui doit être un rôle) est le propriétaire de
       l'objet dépendant.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_ACL</symbol> (<literal>a</literal>)</term>
     <listitem>
      <para>
       L'objet référencé (qui doit être un rôle) est mentionné dans la liste
       de contrôle des accès (<acronym>ACL</acronym>, acronyme de
       <foreignphrase>access control list</foreignphrase>) de l'objet
       dépendant. (Une entrée <symbol>SHARED_DEPENDENCY_ACL</symbol> n'est
       pas créée
       pour le propriétaire de l'objet car ce dernier a toujours une
       entrée <symbol>SHARED_DEPENDENCY_OWNER</symbol>.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_INITACL</symbol> (<literal>i</literal>)</term>
     <listitem>
      <para>
       L'objet référencé (qui doit être un rôle) est mentionné dans une
       entrée
       <link linkend="catalog-pg-init-privs"><structname>pg_init_privs</structname></link>
       pour l'objet dépendant.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_POLICY</symbol> (<literal>r</literal>)</term>
     <listitem>
      <para>
       L'objet référencé (qui doit être un rôle) est mentionné
       comme la cible d'un objet de politique de sécurité dépendant.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_TABLESPACE</symbol> (<literal>t</literal>)</term>
     <listitem>
      <para>
       L'objet référencé (qui doit être un tablespace) est mentionné comme le
       tablespace pour une relation qui n'a pas de stockage.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   D'autres types de dépendances peuvent s'avérer nécessaires dans le futur.
   La définition actuelle ne supporte que les rôles et les tablespaces comme
   objets référencés.
  </para>

  <para>
   Comme dans le catalogue <structname>pg_depend</structname>, la plupart des
   objets créés pendant <application>initdb</application> sont considérés
   <quote>fixes</quote>. Aucun enregistrement n'est fait dans
   <structname>pg_shdepend</structname> pour des objets fixés soit en tant
   qu'objet référencée soit en tant qu'objet dépendant.
  </para>

 </sect1>

 <sect1 id="catalog-pg-shdescription">
  <title><structname>pg_shdescription</structname></title>

  <indexterm zone="catalog-pg-shdescription">
   <primary>pg_shdescription</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_shdescription</structname> stocke les
   descriptions optionelles (commentaires) des objets partagés de la base.
   Les descriptions peuvent être manipulées avec la commande <link
   linkend="sql-comment"><command>COMMENT</command></link> et visualisées
   avec les commandes <literal>\d</literal> de
   <application>psql</application>.
  </para>

  <para>
   Voir aussi
   <link linkend="catalog-pg-description"><structname>pg_description</structname></link>,
   qui assure les mêmes fonctions, mais pour les objets d'une seule base.
  </para>

  <para>
   Contrairement à la plupart des catalogues systèmes,
   <structname>pg_shdescription</structname>
   est partagée par toutes les bases d'un cluster&nbsp;: il n'existe qu'une seule copie
   de <structname>pg_shdescription</structname> par cluster, et non une par
   base.
  </para>

  <table>
   <title>Colonnes de <structname>pg_shdescription</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>objoid</structfield> <type>oid</type>
        (référence toute colonne OID)
       </para>
       <para>
        L'OID de l'objet concerné par la description
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>classoid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID du catalogue système où cet objet apparaît
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>description</structfield> <type>text</type>
       </para>
       <para>
        Texte arbitraire servant de description de l'objet
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-shseclabel">
  <title><structname>pg_shseclabel</structname></title>

  <indexterm zone="catalog-pg-shseclabel">
   <primary>pg_shseclabel</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_shseclabel</structname> stocke les labels de
   sécurité pour les objets partagés du serveur. Les labels de sécurité
   peuvent être manipulés avec la commande <link
   linkend="sql-security-label"><command>SECURITY LABEL</command></link>.
   Pour une façon plus simple de voir les labels de sécurité, voir <xref
   linkend="view-pg-seclabels"/>.
  </para>

  <para>
   Voir aussi <link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>,
   qui réalise une fonction similaire pour les labels de sécurité sur des objets
   internes à une base de données.
  </para>

  <para>
   Contrairement à la plupart des catalogues systèmes,
   <structname>pg_shseclabel</structname> est partagé entre toutes les bases
   de données d'une instance&nbsp;; il n'existe qu'une copie de
   <structname>pg_shseclabel</structname> par instance, et non pas une par
   base de données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_shseclabel</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>objoid</structfield> <type>oid</type>
        (référence toute colonne OID)
       </para>
       <para>
        L'OID de l'objet auquel s'applique ce label de sécurité
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>classoid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID du catalogue système où cet objet apparaît
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>provider</structfield> <type>text</type>
       </para>
       <para>
        Le fournisseur de label associé avec ce label
       </para></entry>
     </row>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>label</structfield> <type>text</type>
       </para>
       <para>
        Le label de sécurité appliqué à cet objet
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-statistic">
  <title><structname>pg_statistic</structname></title>

  <indexterm zone="catalog-pg-statistic">
   <primary>pg_statistic</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_statistic</structname> stocke des données
   statistiques sur le contenu de la base de données. Les entrées sont créées
   par <link linkend="sql-analyze"><command>ANALYZE</command></link>, puis
   utilisées par le planificateur de requêtes.
   Les données statistiques sont, par définition des approximations,
   même si elles sont à jour.
  </para>

  <para>
   D'habitude, il existe une entrée, avec
   <structfield>stainherit</structfield> = <literal>false</literal>, pour
   chaque colonne de table qui a été analysée. Si la table a des enfants ou
   des partitions, une
   seconde entrée avec <structfield>stainherit</structfield> =
   <literal>true</literal> est aussi créé. Cette ligne représente les
   statistiques de la colonne sur l'arbre d'héritage, autrement dit les
   statistiques pour les données que vous voyez avec
   <literal>SELECT <replaceable>colonne</replaceable> FROM
    <replaceable>table</replaceable>*</literal>, alors que la ligne
   <structfield>stainherit</structfield> = <literal>false</literal> représente
   le résultat de
   <literal>SELECT <replaceable>column</replaceable> FROM ONLY <replaceable>table</replaceable></literal>.
  </para>

  <para>
   <structname>pg_statistic</structname> stocke aussi les données
   statistiques des valeurs des expressions d'index. Elles sont décrites
   comme si elles étaient de vraies colonnes&nbsp;; en particulier,
   <structfield>starelid</structfield> référence l'index. Néanmoins, aucune
   entrée n'est effectuée pour une colonne d'index ordinaire sans expression
   car cela est redondant avec l'entrée correspondant à la colonne sous-jacente de la
   table. Actuellement, les entrées pour les expressions d'index ont toujours
   <structfield>stainherit</structfield> = <literal>false</literal>.
  </para>

  <para>
   Comme des statistiques différentes peuvent être appropriées pour des types de
   données différents, <structname>pg_statistic</structname> ne fait
   qu'un minimum de suppositions sur les types de statistiques qu'il
   stocke. Seules des statistiques extrêmement générales (comme les valeurs
   NULL) ont des colonnes dédiées. Tout le reste est stocké dans des
   <quote>connecteurs</quote>, groupes de colonnes associées
   dont le contenu est identifié par un numéro de code dans l'une des colonnes
   du connecteur. Pour plus d'information, voir
   <filename>src/include/catalog/pg_statistic.h</filename>.
  </para>

  <para>
   <structname>pg_statistic</structname> ne doit pas être lisible par le
   public,
   car même les données statistiques sont sensibles.
   (Exemple&nbsp;: les valeurs maximales et minimales d'une colonne de salaire
   peuvent être intéressantes).
   <link linkend="view-pg-stats"><structname>pg_stats</structname></link> est
   une vue sur <structname>pg_statistic</structname> accessible à tous, qui
   n'expose que les informations sur les tables accessibles à
   l'utilisateur courant.
  </para>

  <table>
   <title>Colonnes de <structname>pg_statistic</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>starelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Table ou index à qui la colonne décrite appartient
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>staattnum</structfield> <type>int2</type>
        (référence <link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.<structfield>attnum</structfield>)
       </para>
       <para>
        Numéro de la colonne décrite
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stainherit</structfield> <type>bool</type>
       </para>
       <para>
        Si vrai, les statistiques incluent les valeurs des colonnes enfants de
        l'héritage, pas uniquement les valeurs de la relation spécifiée
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stanullfrac</structfield> <type>float4</type>
       </para>
       <para>
        Fraction des entrées de la colonne qui ont une valeur
        NULL
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stawidth</structfield> <type>int4</type>
       </para>
       <para>
        Taille moyenne, en octets, des entrées non NULL
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stadistinct</structfield> <type>float4</type>
       </para>
       <para>
        Nombre de valeurs distinctes non NULL dans la colonne. Une
        valeurs positive est le nombre réel de valeurs distinctes. Une valeur
        négative est le négatif d'un multiplieur pour le nombre de lignes dans
        la table&nbsp;;
        par exemple, une colonne dans laquelle 90% des lignes ne sont pas NULL
        et dans laquelle chaque valeur non NULL apparaît deux fois en moyenne,
        pourrait être représentée avec un
        <structfield>stadistinct</structfield> à -0,4.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stakind<replaceable>N</replaceable></structfield> <type>int2</type>
       </para>
       <para>
        Numéro de code indiquant le type de statistiques stockées dans
        <quote>le connecteur</quote> numéro <replaceable>N</replaceable> de la ligne de
        <structname>pg_statistic</structname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>staop<replaceable>N</replaceable></structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Opérateur utilisé pour dériver les statistiques stockées dans
        <quote>le connecteur</quote> numéro <replaceable>N</replaceable>. Par exemple, un
        connecteur d'histogramme montre l'opérateur <literal>&lt;</literal>,
        qui définit l'ordre de tri des données.
        Zéro si le type de statistique ne requiert pas un opérateur.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stacoll<replaceable>N</replaceable></structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Le collationnement utilisé pour dériver les statistiques enregistrées
        dans le <replaceable>N</replaceable>-ième <quote>slot</quote>. Par
        exemple, un slot histogramme pour une colonne collationnable
        afficherait le collationnement qui définit l'ordre de tri de la donnée.
        Zéro pour les données sans collationnement.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stanumbers<replaceable>N</replaceable></structfield> <type>float4[]</type>
       </para>
       <para>
        Statistiques numériques du type approprié pour
        <quote>le connecteur</quote> numéro <replaceable>N</replaceable> ou NULL si le type
        de connecteur n'implique pas de valeurs numériques.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stavalues<replaceable>N</replaceable></structfield> <type>anyarray</type>
       </para>
       <para>
        Valeurs de données de la colonne du type approprié pour
        <quote>le connecteur</quote> numéro <replaceable>N</replaceable> ou NULL si
        le type de connecteur ne stocke aucune valeur de données. Chaque valeur
        d'élément du tableau est en fait du type de données de la colonne
        indiquée, ou un type en relation comme un type élément d'un tableau, si
        bien qu'il n'y a aucun moyen de définir le type de ces colonnes
        plus précisément qu'avec le type <type>anyarray</type> (tableau quelconque).
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-statistic-ext">
  <title><structname>pg_statistic_ext</structname></title>

  <indexterm zone="catalog-pg-statistic-ext">
   <primary>pg_statistic_ext</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_statistic_ext</structname> contient des
   définitions des statistiques étendues pour l'optimiseur de requêtes. Chaque ligne de ce
   catalogue correspond à un <firstterm>objet statistique</firstterm> créé
   avec <link linkend="sql-createstatistics"><command>CREATE STATISTICS</command></link>.
  </para>

  <para>
   Normalement, il existe un enregistrement, avec
   <structfield>stxdinherit</structfield> = <literal>false</literal>, pour
   chaque objet statistique qui a été analysé. Si la table a un fils dans un
   héritage ou une partition, un deuxième enregistrelent avec
   <structfield>stxdinherit</structfield> = <literal>true</literal> est aussi
   créé.  Cette ligne représente l'objet statistique dansl'arbre d'héritage, par
   exemple les statistiques pour les données que vous verriez avec
   <literal>SELECT * FROM <replaceable>table</replaceable>*</literal>, alors
   qu'une ligne <structfield>stxdinherit</structfield> =
   <literal>false</literal> représente le résultat de <literal>SELECT * FROM
   ONLY <replaceable>table</replaceable></literal>.
  </para>

  <para>
   Tout comme <link
   linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link>,
   <structname>pg_statistic_ext_data</structname> ne doit
   pas être lisible par tout le monde car son contenu peut être considéré
   comme sensible. (Par exemple, les combinaisons de valeurs les plus communes
   des colonnes  pourraient être intéressantes.) <link
   linkend="view-pg-stats-ext"><structname>pg_stats_ext</structname></link>
   est une vue, lisible par tout le monde, interrogeant
   <link linkend="catalog-pg-statistic-ext"><structname>pg_statistic_ext</structname></link>
   (après une jointure sur
   <structname>pg_statistic_ext</structname>) en exposant uniquement les
   informations sur les tables dont l'utilisateur courant est le propriétaire.
  </para>

  <table>
   <title>Colonnes de <structname>pg_statistic_ext</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stxrelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Table contenant les colonnes décrites par cet objet
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stxname</structfield> <type>name</type>
       </para>
       <para>
        Nom de l'objet statistique
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stxnamespace</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du schéma contenant l'objet statistique
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stxowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire de l'objet statistique
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stxkeys</structfield> <type>int2vector</type>
       (référence <link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.<structfield>attnum</structfield>)
      </para>
      <para>
       Un tableau de numéros de colonnes, indiquant les colonnes concernées
       par cet objet statistique&nbsp;; par exemple, une valeur
       <literal>1 3</literal> signifie que la première et la troisième
       colonnes sont concernées
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stxstattarget</structfield> <type>int2</type>
      </para>
      <para>
       <structfield>stxstattarget</structfield> contrôle le niveau de détail
       des statistiques accumulées pour cet objet statistique par <link
       linkend="sql-analyze"><command>ANALYZE</command></link>. Une valeur
       zéro indique qu'aucune statistique
       ne doit être récupérée. Une valeur NULL indique d'utiliser le
       maximum des cibles statistiques des colonnes référencées, si elles sont
       configurés, ou la cible par défaut du système. Les valeurs positives de
       <structfield>stxstattarget</structfield> déterminent le nombre cible de
       <quote>valeurs les plus communes</quote> à récupérer.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stxkind</structfield> <type>char[]</type>
       </para>
       <para>
        Un tableau contenant des codes pour les types statistiques
        activés&nbsp;; les valeurs valides sont&nbsp;:
        <literal>d</literal> pour des statistiques n-distinct,
        <literal>f</literal> pour des statistiques de dépendance fonctionnelle,
        <literal>m</literal> pour des statistiques sur les valeurs les plus
        communes (<foreignphrase>most common values</foreignphrase> ou
        <acronym>MCV</acronym>)
        et <literal>e</literal> pour des statistiques sur des expressions
       </para></entry>
      </row>

      <row>
       <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stxexprs</structfield> <type>pg_node_tree</type>
       </para>
       <para>
        Arbres d'expression (dans la représentation
        <function>nodeToString()</function>) pour les attributs des objets
        statistiques qui ne sont pas de simples références de colonnes. C'est
        une liste avec une un élément par expression. Null si tous les
        attributs des objets statistiques sont des références simples.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Un enregistrement de <structname>pg_statistic_ext</structname> est rempli
   complètement lors du <link linkend="sql-createstatistics"><command>CREATE
   STATISTICS</command></link>, mais les vraies valeurs statistiques ne sont
   pas calculées à ce moment-là. Les commandes <link
   linkend="sql-analyze"><command>ANALYZE</command></link> ultérieures
   calculent les valeurs souhaitées et peuplent l'enregistrement dans <link
   linkend="catalog-pg-statistic-ext-data"><structname>pg_statistic_ext_data</structname></link>.
  </para>
 </sect1>

 <sect1 id="catalog-pg-statistic-ext-data">
  <title><structname>pg_statistic_ext_data</structname></title>

  <indexterm zone="catalog-pg-statistic-ext">
   <primary>pg_statistic_ext_data</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_statistic_ext_data</structname> contient les
   données pour les statistiques étendues de l'optimiseur, définies dans
   <link
   linkend="catalog-pg-statistic-ext"><structname>pg_statistic_ext</structname></link>.
   Chaque ligne de ce catalogue correspond à un <firstterm>objet
   statistique</firstterm> créé avec <link
   linkend="sql-createstatistics"><command>CREATE
   STATISTICS</command></link>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_statistic_ext_data</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stxoid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-statistic-ext"><structname>pg_statistic_ext</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Objet statistique étendu contenant la définition pour cette donnée
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stxdinherit</structfield> <type>bool</type>
      </para>
      <para>
       Si true, les statistiques incluent des valeurs des tables filles, pas
       seulement les valeurs dans la relation indiquée
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stxdndistinct</structfield> <type>pg_ndistinct</type>
       </para>
       <para>
        Nombre de valeurs distinctes, sérialisé sous la forme d'un type
        <structname>pg_ndistinct</structname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stxddependencies</structfield> <type>pg_dependencies</type>
       </para>
       <para>
        Statistiques de dépendance fonctionnelle, sérialisées sous la forme
        d'un type <structname>pg_dependencies</structname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stxdmcv</structfield> <type>pg_mcv_list</type>
       </para>
       <para>
        Statistiques MCV (valeurs les plus communes), sérialisées sous la
        forme d'un type <structname>pg_mcv_list</structname>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stxdexpr</structfield> <type>pg_statistic[]</type>
      </para>
      <para>
       Statistiques par expression, sérialisées sous la forme d'un tableau de
       type <structname>pg_statistic</structname>
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-subscription">
  <title><structname>pg_subscription</structname></title>

  <indexterm zone="catalog-pg-subscription">
   <primary>pg_subscription</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_subscription</structname> contient toutes les
   souscriptions existantes pour la réplication logique. Pour plus
   d'informations sur la réplication logique, voir <xref
   linkend="logical-replication"/>.
  </para>

  <para>
   Contrairement à la plupart des catalogues systèmes,
   <structname>pg_subscription</structname> est partagé parmi toutes les bases
   de données d'une instance. Il existe une seule copie de
   <structname>pg_subscription</structname> par instance, et non pas une par
   base de données.
  </para>

  <para>
   L'accès à la colonne <structfield>subconninfo</structfield> est interdite
   aux utilisateurs standards car elle pourrait contenir des mots de passe en
   clair.
  </para>

  <table>
   <title>Colonnes de <structname>pg_subscription</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de la ligne (attribut caché&nbsp;; doit être
        sélectionné explicitement)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>subdbid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-database"><structname>pg_database</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de la base de données où réside la souscription
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subskiplsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       LSN de fin de la transaction dont les changements doivent être ignorés
       si le LSN est valide&nbsp;; sinon <literal>0/0</literal>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>subname</structfield> <type>name</type>
       </para>
       <para>
        Nom de la souscription
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>subowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire de la souscription
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>subenabled</structfield> <type>bool</type>
       </para>
       <para>
        Si true, la souscription est activée et doit répliquer
       </para></entry>
      </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>subbinary</structfield> <type>bool</type>
       </para>
       <para>
        Si true, la souscription demandera que le publieur envoie des données
        dans le format binaire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>substream</structfield> <type>char</type>
       </para>
       <para>
        Contrôle la gestion du flux des transactions en cours&nbsp;:
        <literal>f</literal> = interdit ce flux,
        <literal>t</literal> = divise les changements des transactions en cours
        sur disque et les applique une fois que la transaction est validée sur
        le publieur et reçue sur l'abonné,
        <literal>p</literal> = applique les modifications directement en utilisant
        un apply worker parallélisé si disponible
        (identique à <literal>t</literal> si aucun worker disponible)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subtwophasestate</structfield> <type>char</type>
      </para>
      <para>
       Code d'état pour le mode de validation en deux phases&nbsp;:
       <literal>d</literal> = désactivé,
       <literal>p</literal> = activation en cours,
       <literal>e</literal> = activé
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subdisableonerr</structfield> <type>bool</type>
      </para>
      <para>
       Si true, la souscription sera désactivée si un des workers détecte
       une erreur
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subpasswordrequired</structfield> <type>bool</type>
      </para>
      <para>
       Si true, la souscription se verra obligée de fournir un mot de passe
       pour l'authentification
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subrunasowner</structfield> <type>bool</type>
      </para>
      <para>
       Si true, la souscription sera exécutée avec les droits du propriétaire
       de la souscription
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subfailover</structfield> <type>bool</type>
      </para>
      <para>
       Si true, les slots de réplication associés (c'est-à-dire le slot
       principal et les slots de synchronisation de la table) de la base
       de données publieur sont activés pour être synchronisés vers les
       serveurs secondaires
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>subconninfo</structfield> <type>text</type>
       </para>
       <para>
        Chaîne de connexion vers la base de données source
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>subslotname</structfield> <type>name</type>
       </para>
       <para>
        Nom du slot de réplication dans la base de données source (aussi
        utilisé pour le nom origine de la réplication locale)&nbsp;;
        null représente <literal>NONE</literal>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>subsynccommit</structfield> <type>text</type>
       </para>
       <para>
        Contient la valeur du paramètre <varname>synchronous_commit</varname>
        pour les processus workers de la souscription.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>subpublications</structfield> <type>text[]</type>
       </para>
       <para>
        Tableau de noms de publications souscrites. Ceci référence les
        publications définies dans la base d'origine. Pour plus d'informations sur les
        publications, voir <xref linkend="logical-replication-publication"/>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>suborigin</structfield> <type>text</type>
      </para>
      <para>
       La valeur origine doit valoir soit <literal>none</literal> soit
       <literal>any</literal>. La valeur par défaut est <literal>any</literal>.
       Si <literal>none</literal>, la souscription demandera au publieur
       de n'envoyer que les changements qui n'ont pas une origine. Si
       <literal>any</literal>, le publieur envoie les changements quelque
       soit l'origine.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-subscription-rel">
  <title><structname>pg_subscription_rel</structname></title>

  <indexterm zone="catalog-pg-subscription-rel">
   <primary>pg_subscription_rel</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_subscription_rel</structname> contient l'état
   de chaque relation répliquée dans chaque souscription. C'est une
   correspondance N-N (plusieurs à plusieurs).
  </para>

  <para>
   Ce catalogue contient seulement les tables connues à la souscription après
   exécution de <link linkend="sql-createsubscription"><command>CREATE
   SUBSCRIPTION</command></link> ou <link
   linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION ... REFRESH
   PUBLICATION</command></link>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_subscription_rel</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>srsubid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-subscription"><structname>pg_subscription</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Référence à la souscription
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>srrelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Référence à la relation
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>srsubstate</structfield> <type>char</type>
       </para>
       <para>
        Code d'état&nbsp;:
        <literal>i</literal> = initialisation,
        <literal>d</literal> = données en cours de copie,
        <literal>f</literal> = copie de la table terminée,
        <literal>s</literal> = synchronisée,
        <literal>r</literal> = prête (réplication normale)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>srsublsn</structfield> <type>pg_lsn</type>
       </para>
       <para>
        LSN distant du changement d'état utilisé pour la coordination
        de la synchronisation pour les états <literal>s</literal> ou
        <literal>r</literal>, sinon NULL
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-tablespace">
  <title><structname>pg_tablespace</structname></title>

  <indexterm zone="catalog-pg-tablespace">
   <primary>pg_tablespace</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_tablespace</structname> enregistre les
   informations des <foreignphrase>tablespaces</foreignphrase> disponibles.
   Les tables peuvent être placées dans des
   <foreignphrase>tablespaces</foreignphrase> particuliers pour faciliter
   l'administration des espaces de stockage.
  </para>

  <para>
   Contrairement à la plupart des catalogues système,
   <structname>pg_tablespace</structname> est partagée par toutes les bases
   de données du cluster&nbsp;: il n'y a donc qu'une copie de
   <structname>pg_tablespace</structname> par cluster, et non une par
   base.
  </para>

  <table>
   <title>Colonnes de <structname>pg_tablespace</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spcname</structfield> <type>name</type>
       </para>
       <para>
        Nom du <foreignphrase>tablespace</foreignphrase>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spcowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire du <foreignphrase>tablespace</foreignphrase>,
        habituellement l'utilisateur qui l'a créé
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spcacl</structfield> <type>aclitem[]</type>
       </para>
       <para>
        Droits d'accès&nbsp;; voir
        <xref linkend="ddl-priv"/> pour les
        détails.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spcoptions</structfield> <type>text[]</type>
       </para>
       <para>
        Options au niveau tablespace, sous la forme de chaînes
        <quote>motclé=valeur</quote>
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-transform">
  <title><structname>pg_transform</structname></title>

  <indexterm zone="catalog-pg-transform">
   <primary>pg_transform</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_transform</structname> stocke des
   informations à propos des transformations, qui sont un mécanisme
   pour adapter des types de données aux langages procéduraux.
   Voir <xref linkend="sql-createtransform"/> pour plus d'informations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_transform</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>trftype</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID du type de donnée auquel cette transformation s'applique
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>trflang</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-language"><structname>pg_language</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID du langage auquel cette transformation s'applique
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>trffromsql</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID de la fonction à utiliser pour la conversion du type de
        données envoyé au langage procédural (par exemple, les paramètres
        de la fonction). Zéro est stocké si le comportement par défaut doit
        être utilisé.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>trftosql</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID de la fonction à utiliser pour convertir les sorties du
        langage procédural (par exemple, les valeurs de retour) vers
        le type de données. Zéro est stocké si le comportement par défaut doit
        être utilisé.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-trigger">
  <title><structname>pg_trigger</structname></title>

  <indexterm zone="catalog-pg-trigger">
   <primary>pg_trigger</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_trigger</structname> stocke les informations
   concernant les triggers des tables et des vues. Voir la commande
   <xref linkend="sql-createtrigger"/>
   pour plus d'informations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_trigger</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tgrelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Table sur laquelle porte le trigger
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tgparentid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Trigger parent à partir duquel ce trigger est cloné (ceci survient
        quand les partitions sont créées ou attachées à une table
        partitionnée), zéro si ce n'est pas un clone.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tgname</structfield> <type>name</type>
       </para>
       <para>
        Nom du trigger (doit être unique parmi les triggers
        d'une table)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tgfoid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction à appeler
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tgtype</structfield> <type>int2</type>
       </para>
       <para>
        Masque de bits identifiant les conditions de déclenchement
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tgenabled</structfield> <type>char</type>
       </para>
       <para>
        Contrôle l'exécution du trigger suivant le mode <xref
        linkend="guc-session-replication-role"/>.
        <literal>O</literal> = le trigger se déclenche dans les modes
        <quote>origin</quote> et <quote>local</quote>,
        <literal>D</literal> = le trigger est désactivé,
        <literal>R</literal> = le trigger s'exécute en mode <quote>replica</quote>,
        <literal>A</literal> = le trigger s'exécute à chaque fois.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tgisinternal</structfield> <type>bool</type>
       </para>
       <para>
        Vrai si le trigger est généré en interne (habituellement pour
        forcer la contrainte identifiée par
        <structfield>tgconstraint</structfield>)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tgconstrrelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        La table référencée par une contrainte d'intégrité référentielle
        (zéro si le trigger n'a pas pour but une contrainte d'intégrité
        référentielle)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tgconstrindid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'index supportant une contrainte unique, clé primaire, clé
        d'intégrité référentielle, contrainte d'exclusion (zéro si le trigger
        ne concerne pas un de ces types de contrainte)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tgconstraint</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'entrée <structname>pg_constraint</structname> associé au trigger,
        si elle existe
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tgdeferrable</structfield> <type>bool</type>
       </para>
       <para>
        Vrai si le trigger contrainte est retardable
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tginitdeferred</structfield> <type>bool</type>
       </para>
       <para>
        Vrai si le trigger de contrainte est initialement retardé
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tgnargs</structfield> <type>int2</type>
       </para>
       <para>
        Nombre de chaînes d'arguments passées à la fonction du
        trigger
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tgattr</structfield> <type>int2vector</type>
        (référence <link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.<structfield>attnum</structfield>)
       </para>
       <para>
        numéros de colonne, si le trigger est spécifique à la colonne&nbsp;;
        sinon un tableau vide
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tgargs</structfield> <type>bytea</type>
       </para>
       <para>
        Chaînes d'arguments à passer au trigger, chacune terminée par un
        NULL
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tgqual</structfield> <type>pg_node_tree</type>
       </para>
       <para>
        Arbre d'expression (d'après la représentation de
        <function>nodeToString()</function> pour la condition
        <literal>WHEN</literal> du trigger, ou NULL si aucune
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tgoldtable</structfield> <type>name</type>
       </para>
       <para>
        Nom de la clause <literal>REFERENCING</literal> pour <literal>OLD TABLE</literal>,
        ou NULL si aucun
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tgnewtable</structfield> <type>name</type>
       </para>
       <para>
        Nom de la clause <literal>REFERENCING</literal> pour <literal>NEW TABLE</literal>,
        ou NULL si aucun
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Actuellement, les triggers spécifiques par colonne sont supportés seulement
   pour les événements <literal>UPDATE</literal> et, du coup,
   <structfield>tgattr</structfield> est valable seulement pour ce type
   d'événements. <structfield>tgtype</structfield> pourrait contenir des
   informations pour d'autres types d'événement mais ils sont supposés valides
   pour la table complète, quel que soit le contenu de
   <structfield>tgattr</structfield>.
  </para>

  <note>
   <para>
    Quand <structfield>tgconstraint</structfield> est différent de zéro,
    <structfield>tgconstrrelid</structfield>,
    <structfield>tgconstrindid</structfield>,
    <structfield>tgdeferrable</structfield> et
    <structfield>tginitdeferred</structfield> sont grandement redondants avec
    l'entrée référencée de <link
    linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link>.
    Néanmoins, il
    est possible qu'un trigger non déferrable soit associé à une contrainte
    déferrable&nbsp;: les contraintes de clé étrangère peuvent avoir quelques
    triggers déferrables et quelques triggers non déferrables.
   </para>
  </note>

  <note>
   <para>
    <literal>pg_class.relhastriggers</literal> doit valoir true si la relation
    possède au moins un trigger dans ce catalogue.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-ts-config">
  <title><structname>pg_ts_config</structname></title>

  <indexterm zone="catalog-pg-ts-config">
   <primary>pg_ts_config</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_ts_config</structname> contient des entrées
   représentant les configurations de la recherche plein texte. Une
   configuration spécifie un analyseur et une liste de dictionnaires à
   utiliser pour chacun des types d'éléments en sortie de l'analyseur.
   L'analyseur est présenté dans l'entrée de
   <link linkend="catalog-pg-ts-config"><structname>pg_ts_config</structname></link>
   mais la correspondance
   élément/dictionnaire est définie par des entrées supplémentaires dans
   <link
   linkend="catalog-pg-ts-config-map"><structname>pg_ts_config_map</structname></link>.
  </para>

  <para>
   Les fonctionnalités de recherche plein texte de
   <productname>PostgreSQL</productname> sont expliquées en détail dans
   <xref linkend="textsearch"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_ts_config</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>cfgname</structfield> <type>name</type>
       </para>
       <para>
        Nom de la configuration
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>cfgnamespace</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du <foreignphrase>namespace</foreignphrase> qui contient la configuration
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>cfgowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire de la configuration
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>cfgparser</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-ts-parser"><structname>pg_ts_parser</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de l'analyseur pour la configuration
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-config-map">
  <title><structname>pg_ts_config_map</structname></title>

  <indexterm zone="catalog-pg-ts-config-map">
   <primary>pg_ts_config_map</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_ts_config_map</structname> contient des entrées
   présentant les dictionnaires de recherche plein texte à
   consulter et l'ordre de consultation, pour chaque type de lexème en sortie de
   chaque analyseur de configuration.
  </para>

  <para>
   Les fonctionnalités de la recherche plein texte de
   <productname>PostgreSQL</productname> sont expliquées en détail dans
   <xref linkend="textsearch"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_ts_config_map</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>mapcfg</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-ts-config"><structname>pg_ts_config</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de l'entrée <structname>pg_ts_config</structname> qui possède
        l'entrée
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>maptokentype</structfield> <type>int4</type>
       </para>
       <para>
        Un type de lexème émis par l'analyseur de configuration
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>mapseqno</structfield> <type>int4</type>
       </para>
       <para>
        Ordre dans lequel consulter l'entrée (les plus petits
        <structfield>mapseqno</structfield> en premier)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>mapdict</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-ts-dict"><structname>pg_ts_dict</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du dictionnaire de recherche plein texte à consulter
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-dict">
  <title><structname>pg_ts_dict</structname></title>

  <indexterm zone="catalog-pg-ts-dict">
   <primary>pg_ts_dict</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_ts_dict</structname> contient des entrées
   définissant les dictionnaires de recherche plein texte. Un dictionnaire
   dépend d'un modèle de recherche plein texte qui spécifie toutes les
   fonctions d'implantation nécessaires&nbsp;; le dictionnaire lui-même
   fournit des valeurs pour les paramètres utilisateur
   supportés par le modèle. Cette division du travail permet la création
   de dictionnaires par des utilisateurs non privilégiés. Les paramètres sont
   indiqués par une chaîne, <structfield>dictinitoption</structfield>,
   dont le format et la signification dépendent du modèle.
  </para>

  <para>
   Les fonctionnalités de la recherche plein texte de
   <productname>PostgreSQL</productname> sont expliquées en détail dans
   <xref linkend="textsearch"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_ts_dict</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>dictname</structfield> <type>name</type>
       </para>
       <para>
        Nom du dictionnaire de recherche plein texte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>dictnamespace</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du <foreignphrase>namespace</foreignphrase> contenant le dictionnaire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>dictowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire du dictionnaire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>dicttemplate</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-ts-template"><structname>pg_ts_template</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du modèle de recherche plein texte du dictionnaire
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>dictinitoption</structfield> <type>text</type>
       </para>
       <para>
        Chaîne d'options d'initialisation du modèle
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-parser">
  <title><structname>pg_ts_parser</structname></title>

  <indexterm zone="catalog-pg-ts-parser">
   <primary>pg_ts_parser</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_ts_parser</structname> contient des entrées
   définissant les analyseurs de la recherche plein texte. Un analyseur est
   responsable du découpage du texte en entrée en lexèmes et de l'assignation
   d'un type d'élément à chaque lexème. Puisqu'un analyseur doit être
   codé à l'aide de fonctions écrites en langage C, la création de nouveaux
   analyseurs est restreinte aux superutilisateurs des bases de données.
  </para>

  <para>
   Les fonctionnalités de la recherche plein texte de
   <productname>PostgreSQL</productname> sont expliquées en détail dans
   <xref linkend="textsearch"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_ts_parser</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>prsname</structfield> <type>name</type>
       </para>
       <para>
        Nom de l'analyseur de recherche plein texte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>prsnamespace</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du <foreignphrase>namespace</foreignphrase> qui contient l'analyseur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>prsstart</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de la fonction de démarrage de l'analyseur (zéro si aucune)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>prstoken</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de la fonction de récupération du jeton suivant de l'analyseur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>prsend</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de la fonction d'arrêt de l'analyseur
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>prsheadline</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de la fonction headline de l'analyseur  (zéro si aucune)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>prslextype</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de la fonction lextype de l'analyseur
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-template">
  <title><structname>pg_ts_template</structname></title>

  <indexterm zone="catalog-pg-ts-template">
   <primary>pg_ts_template</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_ts_template</structname> contient des entrées
   définissant les modèles de recherche plein texte. Un modèle est
   le squelette d'implantation d'une classe de dictionnaires de recherche
   plein texte. Puisqu'un modèle doit être codé à l'aide de fonctions codées en
   langage C, la création de nouveaux modèles est restreinte aux
   superutilisateurs des bases de données.
  </para>

  <para>
   Les fonctionnalités de la recherche plein texte de
   <productname>PostgreSQL</productname> sont expliquées en détail dans
   <xref linkend="textsearch"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_ts_template</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tmplname</structfield> <type>name</type>
       </para>
       <para>
        Nom du modèle de recherche plein texte
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tmplnamespace</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du <foreignphrase>namespace</foreignphrase> qui contient le modèle
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tmplinit</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de la fonction d'initialisation du modèle (zéro si aucune)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>tmpllexize</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de la fonction lexize du modèle
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-type">
  <title><structname>pg_type</structname></title>

  <indexterm zone="catalog-pg-type">
   <primary>pg_type</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_type</structname> stocke les informations
   concernant les types de données. Les types basiques et d'énumération
   (types scalaires) sont créés avec la commande <link
   linkend="sql-createtype"><command>CREATE TYPE</command></link> et les
   domaines avec <link linkend="sql-createdomain"><command>CREATE
   DOMAIN</command></link>. Un type composite est créé automatiquement pour
   chaque table de la base pour représenter la structure des lignes de la
   table. Il est aussi possible de créer des types composites avec
   <command>CREATE TYPE AS</command>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_type</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typname</structfield> <type>name</type>
       </para>
       <para>
        Nom du type
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typnamespace</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du <foreignphrase>namespace</foreignphrase> qui contient le type
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typowner</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Propriétaire du type
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typlen</structfield> <type>int2</type>
       </para>
       <para>
        Pour les types de taille fixe, <structfield>typlen</structfield> est le
        nombre d'octets de la représentation interne du type. Mais pour les types
        de longueur variable, <structfield>typlen</structfield> est négatif.
        -1 indique un type <quote>varlena</quote>  (qui a un attribut de longueur),
        -2 indique une chaîne C terminée par le caractère NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typbyval</structfield> <type>bool</type>
       </para>
       <para>
        <structfield>typbyval</structfield> détermine si les routines internes
        passent une valeur de ce type par valeur ou par référence.
        <structfield>typbyval</structfield> doit être faux si
        <structfield>typlen</structfield> ne vaut pas 1, 2 ou 4 (ou 8 sur les
        machines dont le mot-machine est de 8 octets). Les types de longueur
        variable sont toujours passés par référence.
        <structfield>typbyval</structfield> peut être faux même si la longueur
        permet un passage par valeur.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typtype</structfield> <type>char</type>
       </para>
       <para>
        <structfield>typtype</structfield> vaut <literal>b</literal> pour un
        type de base, <literal>c</literal> pour un type composite
        (le type d'une ligne de table, par exemple),
        <literal>d</literal> pour un domaine,
        <literal>e</literal> pour un enum,
        <literal>p</literal> pour un pseudo-type,
        <literal>r</literal> pour un type range ou
        <literal>m</literal> pour un type multirange.
        Voir aussi <structfield>typrelid</structfield> et
        <structfield>typbasetype</structfield>.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typcategory</structfield> <type>char</type>
       </para>
       <para>
        <structfield>typcategory</structfield> est une classification arbitraire
        de types de données qui est utilisée par l'analyseur pour déterminer
        la conversion implicite devant être <quote>préférée</quote>. Voir
        <xref linkend="catalog-typcategory-table"/>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typispreferred</structfield> <type>bool</type>
       </para>
       <para>
        Vrai si ce type est une cible de conversion préférée dans sa
        <structfield>typcategory</structfield>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typisdefined</structfield> <type>bool</type>
       </para>
       <para>
        Vrai si le type est défini et faux s'il ne s'agit que d'un conteneur
        pour un type qui n'est pas encore défini. Lorsque
        <structfield>typisdefined</structfield> est faux, rien, à part le nom du
        type, le <foreignphrase>namespace</foreignphrase> et l'OID, n'est fiable.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typdelim</structfield> <type>char</type>
       </para>
       <para>
        Caractère qui sépare deux valeurs de ce type lorsque le programme
        lit les valeurs d'un tableau en entrée. Le délimiteur est
        associé au type d'élément du tableau, pas au type tableau.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typrelid</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        S'il s'agit d'un type composite (voir
        <structfield>typtype</structfield>), alors cette colonne pointe vers la
        ligne de <link linkend="catalog-pg-class"><structname>pg_class</structname></link> qui définit la table
        correspondante. Pour un type composite sans table, l'entrée dans
        <link linkend="catalog-pg-class"><structname>pg_class</structname></link> ne représente pas vraiment une table,
        mais elle est néanmoins nécessaire pour trouver les lignes de
        <link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link> liées au type. 0 pour les types
        autres que composites.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>typsubscript</structfield> <type>regproc</type>
       (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
      </para>
      <para>
       OID de la fonction du gestionnaire des indices, ou zéro si ce type ne
       supporte pas les indices. Les types qui sont des vrais types tableau
       ont <structfield>typsubscript</structfield> =
       <function>array_subscript_handler</function>, mais les autres types
       pourraient avoir d'autres fonctions de gestion pour implémenter le
       comportement spécialisé d'indices.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typelem</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Si <structfield>typelem</structfield> est différent de zéro, alors il
        identifie une autre ligne de <structname>pg_type</structname>,
        définissant le type renvoyé par indice. Ceci devrait valoir zéro si
        <structfield>typsubscript</structfield> vaut zéro. Néanmoins, il peut
        valoir zéro quand <structfield>typsubscript</structfield> ne vaut pas
        zéro, si le gestionnaire n'a pas besoin de
        <structfield>typelem</structfield> pur déterminer le type de résultat
        avec indice. Notez qu'une dépendance
        <structfield>typelem</structfield> est considéré impliqué un contenu
        physique du type élément dans ce type&nbsp;; donc les modifications DDL
        sur le type élément pourrait être restreint par la présence de ce
        type.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typarray</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Si <structfield>typarray</structfield> est différent de zéro, alors il
        identifie une autre ligne dans <structname>pg_type</structname>, qui est
        le type tableau <quote>true</quote> disposant de ce type en élément.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typinput</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction de conversion en entrée (format texte)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typoutput</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction de conversion en sortie (format texte)
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typreceive</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction de conversion en entrée (format binaire),
        ou zéro s'il n'y en a pas
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typsend</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction de conversion en sortie (format binaire),
        ou zéro s'il n'y en a pas
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typmodin</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction en entrée de modification du type ou zéro si le type ne
        supporte pas les modificateurs
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typmodout</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction en sortie de modification du type ou zéro pour utiliser le
        format standard
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typanalyze</structfield> <type>regproc</type>
        (référence <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        Fonction <xref linkend="sql-analyze"/> personnalisée ou zéro pour
        utiliser la fonction standard
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typalign</structfield> <type>char</type>
       </para>
       <para>
        <structfield>typalign</structfield> est l'alignement requis pour stocker
        une valeur de ce type. Cela s'applique au stockage sur disque ainsi
        qu'à la plupart des représentations de cette valeur dans
        <productname>PostgreSQL</productname>.
        Lorsque des valeurs multiples sont stockées consécutivement, comme dans
        la représentation d'une ligne complète sur disque, un remplissage est
        inséré avant la donnée de ce type pour qu'elle commence à l'alignement
        indiqué. La référence de l'alignement est le début de la première donnée
        de la séquence. Les valeurs possibles sont&nbsp;:
        <itemizedlist>
         <listitem>
          <para><literal>c</literal> = alignement <type>char</type>,
           aucun alignement n'est nécessaire&nbsp;;</para>
         </listitem>
         <listitem>
          <para><literal>s</literal> = alignement <type>short</type> (deux octets sur la
           plupart des machines)&nbsp;;</para>
         </listitem>
         <listitem>
          <para><literal>i</literal> = alignement <type>int</type> (quatre octets sur la
           plupart des machines)&nbsp;;</para>
         </listitem>
         <listitem>
          <para><literal>d</literal> = alignement <type>double</type> (huit octets sur
           la plupart des machines, mais pas sur toutes).</para>
         </listitem>
        </itemizedlist>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typstorage</structfield> <type>char</type>
       </para>
       <para>
        <structfield>typstorage</structfield> indique, pour les types varlena
        (ceux pour lesquels <structfield>typlen</structfield> = -1), si le type
        accepte le TOASTage et la stratégie par défaut à utiliser pour les
        attributs de ce type. Les valeurs possibles sont&nbsp;:
        <itemizedlist>
         <listitem>
          <para><literal>p</literal>
           (<foreignphrase>plain</foreignphrase>)&nbsp;: la valeur doit être
           stockée normalement (les types scalaires utilisent toujours cette
           valeur)&nbsp;;</para>
         </listitem>
         <listitem>
          <para>
           <literal>e</literal> (<foreignphrase>external</foreignphrase>&nbsp;:
           la valeur peut être stockée dans une relation
           <quote>secondaire</quote> <quote>TOAST</quote> (si la relation en a
           une, voir <literal>pg_class.reltoastrelid</literal>)&nbsp;;
          </para>
         </listitem>
         <listitem>
          <para><literal>m</literal>
           (<foreignphrase>main</foreignphrase>)&nbsp;: la valeur peut être
           stockée compressée sur place&nbsp;;</para>
         </listitem>
         <listitem>
          <para><literal>x</literal>
           (<foreignphrase>extended</foreignphrase>)&nbsp;: la valeur peut être
           stockée compressée sur place ou stockée dans une relation
           <quote>secondaire</quote>.</para>
         </listitem>
        </itemizedlist>
        <literal>x</literal> est le choix habituel pour les types de données
        utilisant les TOAST.
        Les colonnes <literal>m</literal> peuvent aussi être déplacées dans
        une table de stockage secondaire, mais seulement en dernier recours
        (les colonnes <literal>e</literal> et <literal>x</literal> sont
        déplacées les premières).
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typnotnull</structfield> <type>bool</type>
       </para>
       <para>
        Représente une contrainte non NULL.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typbasetype</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        S'il s'agit d'un domaine (voir <structfield>typtype</structfield>),
        alors <structfield>typbasetype</structfield> identifie le type sur
        lequel celui-ci est fondé. 0 s'il ne s'agit pas d'un domaine.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typtypmod</structfield> <type>int4</type>
       </para>
       <para>
        Les domaines utilisent ce champ pour
        enregistrer le <literal>typmod</literal> à appliquer à leur type de base (-1 si
        le type de base n'utilise pas de <literal>typmod</literal>). -1 si ce type
        n'est pas un domaine.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typndims</structfield> <type>int4</type>
       </para>
       <para>
        Le nombre de dimensions de
        tableau pour un domaine sur un tableau (c'est-à-dire dont
        <structfield>typbasetype</structfield> est un type tableau). 0 pour les
        types autres que les domaines sur des types tableaux.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typcollation</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        <structfield>typcollation</structfield> spécifie le collationnement
        du type. Si le type ne supporte pas les collationnemens, cette
        colonne vaut zéro. Un type de base qui supporte les collationnements
        aura une valeur différente de zéro, habituellement
        <symbol>DEFAULT_COLLATION_OID</symbol> ici. Un domaine sur
        un type collationnable peut avoir un OID de collationnement différent de celui du
        type de base
        si ce dernier a été précisé pour le domaine.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typdefaultbin</structfield> <type>pg_node_tree</type>
       </para>
       <para>
        Si <structfield>typdefaultbin</structfield> n'est pas NULL, ce champ est la
        représentation <function>nodeToString()</function> d'une expression par
        défaut pour le type. Ceci n'est utilisé que pour les domaines.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typdefault</structfield> <type>text</type>
       </para>
       <para>
        NULL si le type n'a pas de valeur par
        défaut associée. Si <structfield>typdefaultbin</structfield> est non NULL,
        ce champ doit contenir une version lisible de
        l'expression par défaut représentée par <structfield>typdefaultbin</structfield>.
        Si <structfield>typdefaultbin</structfield> est NULL et si
        ce champ ne l'est pas, alors il stocke la représentation externe de la valeur par
        défaut du type, qui peut être passée à la fonction de conversion en
        entrée du type pour produire une constante.
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>typacl</structfield> <type>aclitem[]</type>
       </para>
       <para>
        Droits d'accès&nbsp;; voir <xref linkend="ddl-priv"/>
        pour les détails
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    Pour les types de données à largeur fixe utilisés dans les tables
    systèmes, il est critique que la taille et l'alignement définis dans
    <structname>pg_type</structname> soient en accord avec la façon dont le
    compilateur placera la colonne dans une structure représentant une ligne
    de la table.
   </para>
  </note>

  <para>
   <xref linkend="catalog-typcategory-table"/> liste les valeurs de
   <structfield>typcategory</structfield> définies par le système. Tout ajout
   futur à la liste sera aussi une lettre ASCII majuscule. Tous les autres
   caractères ASCII sont réservés pour les catégories définies par l'utilisateur.
  </para>

  <table id="catalog-typcategory-table">
   <title>Codes <structfield>typcategory</structfield></title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>Code</entry>
      <entry>Catégorie</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>A</literal></entry>
      <entry>Types tableaux</entry>
     </row>
     <row>
      <entry><literal>B</literal></entry>
      <entry>Types booléens</entry>
     </row>
     <row>
      <entry><literal>C</literal></entry>
      <entry>Types composites</entry>
     </row>
     <row>
      <entry><literal>D</literal></entry>
      <entry>Types date/time</entry>
     </row>
     <row>
      <entry><literal>E</literal></entry>
      <entry>Types enum</entry>
     </row>
     <row>
      <entry><literal>G</literal></entry>
      <entry>Types géometriques</entry>
     </row>
     <row>
      <entry><literal>I</literal></entry>
      <entry>Types adresses réseau</entry>
     </row>
     <row>
      <entry><literal>N</literal></entry>
      <entry>Types numériques</entry>
     </row>
     <row>
      <entry><literal>P</literal></entry>
      <entry>Pseudo-types</entry>
     </row>
     <row>
      <entry><literal>S</literal></entry>
      <entry>Types chaînes</entry>
     </row>
     <row>
      <entry><literal>R</literal></entry>
      <entry>Types range</entry>
     </row>
     <row>
      <entry><literal>T</literal></entry>
      <entry>Types 'Timespan' (étendue de temps, intervalle)</entry>
     </row>
     <row>
      <entry><literal>U</literal></entry>
      <entry>Types définis par l'utilisateur</entry>
     </row>
     <row>
      <entry><literal>V</literal></entry>
      <entry>Types Bit-string</entry>
     </row>
     <row>
      <entry><literal>X</literal></entry>
      <entry>Type <type>unknown</type></entry>
     </row>
     <row>
      <entry><literal>Z</literal></entry>
      <entry>Types à usage interne</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-user-mapping">
  <title><structname>pg_user_mapping</structname></title>

  <indexterm zone="catalog-pg-user-mapping">
   <primary>pg_user_mapping</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_user_mapping</structname> stocke les correspondances
   entre utilisateurs locaux et distants. L'accès à ce catalogue est interdite
   aux utilisateurs normaux, utilisez la vue
   <link linkend="view-pg-user-mappings"><structname>pg_user_mappings</structname></link>
   à la place.
  </para>

  <table>
   <title>Colonnes de <structname>pg_user_mapping</structname></title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>oid</structfield> <type>oid</type>
       </para>
       <para>
        Identifiant de ligne
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>umuser</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du rôle à faire correspondre, zéro si l'utilisateur à
        correspondre est public
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>umserver</structfield> <type>oid</type>
        (référence <link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        L'OID du serveur distant qui contient cette correspondance
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>umoptions</structfield> <type>text[]</type>
       </para>
       <para>
        Options spécifiques à la correspondance d'utilisateurs, sous forme de
        chaînes <quote>motclé=valeur</quote>. Cette colonne s'affichera comme
        NULL sauf si l'utilisateur courant est celui en cours de correspondance
        ou si la correspondance concerne <literal>PUBLIC</literal> et que
        l'utilisateur courant est le propriétaire du serveur ou que
        l'utilisateur courant est un superutilisateur. Le but est de protéger
        les informations sur les mots de passe, enregistrées dans une option de
        la correspondance d'utilisateur.
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>
</chapter>
