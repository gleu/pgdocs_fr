<?xml version="1.0" encoding="UTF-8"?>
<chapter id="ecpg">
 <title><application>ECPG</application> &mdash; <acronym>SQL</acronym> embarqué en C</title>

 <indexterm zone="ecpg"><primary>SQL embarqué</primary><secondary>en C</secondary></indexterm>
 <indexterm zone="ecpg"><primary>C</primary></indexterm>
 <indexterm zone="ecpg"><primary>ECPG</primary></indexterm>

 <para>
  Ce chapitre décrit le module de <acronym>SQL</acronym> embarqué pour
  <productname>PostgreSQL</productname>. Il a été écrit par Linus Tolke
  (<email>linus@epact.se</email>) et Michael Meskes (<email>
   meskes@postgresql.org</email>). Initialement, il a été écrit pour fonctionner
  avec le <acronym>C</acronym>. Il fonctionne aussi avec le <acronym>C++</acronym>,
  mais il ne reconnait pas encore toutes les syntaxes du <acronym>C++</acronym>.
 </para>

 <para>
  Ce document est assez incomplet. Mais comme l'interface est standardisée, des
  informations supplémentaires peuvent être trouvées dans beaucoup de documents
  sur le SQL.
 </para>

 <sect1 id="ecpg-concept">
  <title>Le Concept</title>

  <para>
   Un programme SQL embarqué est composé de code écrit dans un langage de
   programmation ordinaire, dans notre cas le C, mélangé avec des commandes SQL
   dans des sections spécialement balisées. Pour compiler le programme,
   le code source (<filename>*.pgc</filename>) passe d'abord dans un préprocesseur
   pour SQL embarqué, qui le convertit en un programme C ordinaire (<filename>*.c</filename>),
   afin qu'il puisse ensuite être traité par un compilateur C. (Pour les détails sur la compilation
   et l'édition de lien dynamique voyez <xref linkend="ecpg-process"/>).
   Les applications ECPG converties appellent les fonctions de la librairie libpq au travers
   de la librairie SQL embarquée (ecpgli), et communique avec le server PostgreSQL au travers du
   protocole client-serveur normal.
  </para>

  <para>
   Le <acronym>SQL</acronym> embarqué a des avantages par rapport aux
   autres méthodes de manipulation du <acronym>SQL</acronym> dans le code
   C. Premièrement, il s'occupe du laborieux passage d'information de et vers
   les variables de votre programme <acronym>C</acronym>. Deuxièmement, le
   code SQL du programme est vérifié à la compilation au niveau syntaxique.
   Troisièmement, le <acronym>SQL</acronym> embarqué en C est supporté par beaucoup
   d'autres bases de données <acronym>SQL</acronym>. L'implémentation
   <productname>PostgreSQL</productname> est conçue pour correspondre à ce standard
   autant que possible, et il est habituellement possible de porter du
   <acronym>SQL</acronym> embarqué d'autres bases SQL vers <productname>PostgreSQL</productname> assez simplement.
  </para>

  <para>
   Comme déjà expliqué précédemment, les programmes écrits pour du <acronym>SQL</acronym> embarqué
   sont des programmes C normaux, avec du code spécifique inséré pour exécuter des opérations
   liées à la base de données. Ce code spécifique est toujours de la forme:
   <programlisting>
EXEC SQL ...;
   </programlisting>
   Ces ordres prennent, syntaxiquement, la place d'un ordre SQL.
   En fonction de l'ordre lui-même, ils peuvent apparaître au niveau
   global ou à l'intérieur d'une fonction. Les ordres <acronym>SQL</acronym>
   embarqués suivent les règles habituelles de sensibilité à la casse
   du code <acronym>SQL</acronym>, et pas celles du C. De plus, ils permettent
   des commentaires imbriqués comme en C, qui font partie du standard SQL.
   Néanmoins, la partie C du programme suit le standard C de ne pas accepter
   des commentaires imbriqués.
  </para>

  <para>
   Les sections suivantes expliquent tous les ordres SQL embarqués.
  </para>
 </sect1>

 <sect1 id="ecpg-connect">
  <title>Gérer les Connexions à la Base de Données</title>

  <para>
   Si des utilisateurs pour lesquels nous n'avons pas confiance ont accès à
   une base de données qui n'a pas adopté une <link
   linkend="ddl-schemas-patterns">méthode sécurisée d'usage des
    schemas</link>, commencez chaque session en supprimant les schémas
   modifiables par tout le monde du paramètre <varname>search_path</varname>.
   Par exemple, ajoutez <literal>options=-c search_path=</literal> à
   <literal><replaceable>options</replaceable></literal> ou exécutez
   <literal>EXEC SQL SELECT pg_catalog.set_config('search_path', '',
    false);</literal> tout de suite après la connexion. Cette considération
   n'est pas spécifique à ECPG&nbsp;; elle s'applique à chaque interface
   permettant d'exécuter des commandes SQL arbitraires.
  </para>

  <para>
   Cette section explique comment ouvrir, fermer, et changer de connexion
   à la base.
  </para>

  <sect2 id="ecpg-connecting">
   <title>Se Connecter au Serveur de Base de Données</title>

   <para>
    On se connecte à la base de données avec l'ordre suivant:
    <programlisting>
EXEC SQL CONNECT TO <replaceable>cible</replaceable> <optional>AS <replaceable>nom-connexion</replaceable></optional> <optional>USER <replaceable>nom-utilisateur</replaceable></optional>;
    </programlisting>
    La <replaceable>cible</replaceable> peut être spécifiée des façons
    suivantes:

    <itemizedlist>
     <listitem>
      <simpara>
       <literal><replaceable>nomdb</replaceable><optional>@<replaceable>nomhôte</replaceable></optional><optional>:<replaceable>port</replaceable></optional></literal>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <literal>tcp:postgresql://<replaceable>nomhôte</replaceable><optional>:<replaceable>port</replaceable></optional><optional>/<replaceable>nomdb</replaceable></optional><optional>?<replaceable>options</replaceable></optional></literal>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <literal>unix:postgresql://<replaceable>nomhôte</replaceable><optional>:<replaceable>port</replaceable></optional><optional>/<replaceable>nomdb</replaceable></optional><optional>?<replaceable>options</replaceable></optional></literal>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       une chaine SQL littérale contenant une des formes précédentes
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       une référence à une variable caractère contenant une des formes précédentes (voyez les exemples)
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <literal>DEFAULT</literal>
      </simpara>
     </listitem>
    </itemizedlist>

    Si vous spécifiez la chaine de connexion de façon littérale (c'est à dire,
    pas par une référence à une variable) et que vous ne mettez pas la valeur
    entre guillemets, alors les règles d'insensibilité à la casse du SQL normal
    sont appliquées. Dans ce cas, vous pouvez aussi mettre entre guillemets doubles
    chaue paramètre individuel séparément au besoin. En pratique, il y a probablement
    moins de risques d'erreur à utiliser une  chaîne de caractères entre simples
    guillemets, ou une référence à une variable. La cible de connexion
    <literal>DEFAULT</literal> initie une connexion à la base de données par défaut
    avec l'utilisateur par défaut. Il n'est pas nécessaire de préciser séparément
    un nom d'utilisateur ou un nom de connexion dans ce cas.
   </para>

   <para>
    Il y a aussi plusieurs façons de spécifier le nom de l'utilisateur&nbsp;:

    <itemizedlist>
     <listitem>
      <simpara>
       <literal><replaceable>nomutilisateur</replaceable></literal>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <literal><replaceable>nomutilisateur</replaceable>/<replaceable>motdepasse</replaceable></literal>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <literal><replaceable>nomutilisateur</replaceable> IDENTIFIED BY <replaceable>motdepasse</replaceable></literal>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <literal><replaceable>nomutilisateur</replaceable> USING <replaceable>motdepasse</replaceable></literal>
      </simpara>
     </listitem>
    </itemizedlist>

    Comme précédemment, les paramètres <replaceable>nomutilisateur</replaceable> et
    <replaceable>motdepasse</replaceable> peuvent être un identifiant SQL,
    une chaîne SQL littérale, ou une référence à une variable caractère.
   </para>

   <para>
    Si la cible de connexion inclut des <replaceable>options</replaceable>,
    cela consiste en des spécifications
    <literal><replaceable>motclé</replaceable>=<replaceable>valeur</replaceable></literal>
    séparées par des esperluettes (<literal>&amp;</literal>). Les mots clés
    autorisés sont les mêmes que ceux reconnus par
    <application>libpq</application> (voir <xref
    linkend="libpq-paramkeywords"/>). Les espaces sont ignorés avant tout
    <replaceable>mot-clé</replaceable> ou <replaceable>valeur</replaceable>,
    mais pas à l'intérieur ou après. Notez qu'il n'existe pas de moyens
    d'écrire write <literal>&amp;</literal> à l'intérieur d'une
    <replaceable>valeur</replaceable>.
   </para>

   <para>
    Le <replaceable>nom-connexion</replaceable> est utilisé pour gérer
    plusieurs connexions dans un programme. Il peut être omis si le programme
    n'utilise qu'une connexion. La connexion la plus récemment ouverte devient
    la connexion courante, qui est utilisée par défaut quand un ordre SQL doit
    être exécuté (voyez plus bas dans ce chapitre).
   </para>

   <para>
    Voici quelques exemples d'ordres <command>CONNECT</command>:
    <programlisting>
EXEC SQL CONNECT TO mabase@sql.mondomaine.com;

EXEC SQL CONNECT TO unix:postgresql://sql.mondomaine.com/mabase AS maconnexion USER john;

EXEC SQL BEGIN DECLARE SECTION;
const char *cible = "mabase@sql.mondomaine.com";
const char *utilisateur = "john";
const char *motdepasse = "secret";
EXEC SQL END DECLARE SECTION;
 ...
EXEC SQL CONNECT TO :cible USER :utilisateur USING :motdepasse;
/* or EXEC SQL CONNECT TO :cible USER :utilisateur/:motdepasse; */
    </programlisting>
    La dernière forme utilise la variante dont on parlait précédemment sous le
    nom de référence par variable. Vous verrez dans les sections finales comment
    des variables C peuvent être utilisées dans des ordres SQL quand vous
    les préfixez par deux-points.
   </para>

   <para>
    Notez que le format de la cible de connexion n'est pas spécifié dans
    le standard SQL. Par conséquent si vous voulez développer des applications
    portables, vous pourriez vouloir utiliser quelque chose ressemblant au dernier
    exemple pour encapsuler la cible de connexion quelque part.
   </para>
  </sect2>

  <sect2 id="ecpg-set-connection">
   <title>Choisir une connexion</title>

   <para>
    Les ordres des programmes SQL embarqué sont par défaut exécutés dans
    la connexion courante, c'est à dire la plus récemment ouverte. Si
    une application a besoin de gérer plusieurs connexions, alors il y
    a deux façons de le gérer.
   </para>

   <para>
    La première solution est de choisir explicitement une connexion pour
    chaque ordre SQL, par exemple:
    <programlisting>
EXEC SQL AT <replaceable>nom-connexion</replaceable> SELECT ...;
    </programlisting>
    Cette option est particulièrement appropriée si l'application a besoin
    d'alterner les accès à plusieurs connexions.
   </para>

   <para>
    Si votre application utilise plusieurs threads d'exécution, ils ne peuvent pas
    utiliser une connexion simultanément. Vous devez soit contrôler explicitement l'accès à
    la connexion (en utilisant des mutexes), ou utiliser une connexion pour chaque thread.
   </para>

   <para>
    La seconde option est d'exécuter un ordre pour changer de connexion
    courante. Cet ordre est:
    <programlisting>
EXEC SQL SET CONNECTION <replaceable>nom-connexion</replaceable>;
    </programlisting>
    Cette option est particulièrement pratique si de nombreux ordres doivent
    être exécutés sur la même connexion.
   </para>

   <para>
    Voici un programme exemple qui gère plusieurs connexions à base de données:
    <programlisting><![CDATA[
#include <stdio.h>

EXEC SQL BEGIN DECLARE SECTION;
    char nomdb[1024];
EXEC SQL END DECLARE SECTION;

int
main()
{
    EXEC SQL CONNECT TO basetest1 AS con1 USER utilisateurtest;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
    EXEC SQL CONNECT TO basetest2 AS con2 USER utilisateurtest;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
    EXEC SQL CONNECT TO basetest3 AS con3 USER utilisateurtest;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    /* Cette requête serait exécuté dans la dernière base ouverte "basetest3". */
    EXEC SQL SELECT current_database() INTO :nomdb;
    printf("courante=%s (devrait être basetest3)\n", nomdb);

    /* Utiliser "AT" pour exécuter une requête dans "basetest2" */
    EXEC SQL AT con2 SELECT current_database() INTO :nomdb;
    printf("courante=%s (devrait être basetest2)\n", nomdb);

    /* Basculer la connexion courante à "basetest1". */
    EXEC SQL SET CONNECTION con1;

    EXEC SQL SELECT current_database() INTO :nomdb;
    printf("courante=%s (devrait être basetest1)\n", nomdb);

    EXEC SQL DISCONNECT ALL;
    return 0;
}
]]></programlisting>

   Cet exemple devrait produire cette sortie&nbsp;:
<screen>
courante=basetest3 (devrait être basetest3)
courante=basetest2 (devrait être basetest2)
courante=basetest1 (devrait être basetest1)
    </screen>
   </para>
  </sect2>

  <sect2 id="ecpg-disconnect">
   <title>Fermer une Connexion</title>

   <para>
    Pour fermer une connexion, utilisez l'ordre suivant&nbsp;:
    <programlisting>
EXEC SQL DISCONNECT <optional><replaceable>connexion</replaceable></optional>;
    </programlisting>
    La <replaceable>connexion</replaceable> peut être spécifiée des façons
    suivantes:

    <itemizedlist>
     <listitem>
      <simpara>
       <literal><replaceable>nom-connexion</replaceable></literal>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <literal>DEFAULT</literal>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <literal>CURRENT</literal>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <literal>ALL</literal>
      </simpara>
     </listitem>
    </itemizedlist>

    Si aucun nom de connexion n'est spécifié, la connexion courante est
    fermée.
   </para>

   <para>
    C'est une bonne pratique qu'une application ferme toujours explicitement
    toute connexion qu'elle a ouverte.
   </para>
  </sect2>

 </sect1>

 <sect1 id="ecpg-commands">
  <title>Exécuter des Commandes SQL</title>

  <para>
   Toute commande SQL peut être exécutée à l'intérieur d'une application
   SQL embarquée.
   Voici quelques exemples montrant comment le faire.
  </para>

  <sect2 id="ecpg-executing">
   <title>Exécuter des Ordres SQL</title>

   <para>
    Créer une table&nbsp;:
    <programlisting>
EXEC SQL CREATE TABLE truc (nombre integer, ascii char(16));
EXEC SQL CREATE UNIQUE INDEX num1 ON truc(nombre);
EXEC SQL COMMIT;
    </programlisting>
   </para>

   <para>
    Insérer des lignes&nbsp;:
    <programlisting>
EXEC SQL INSERT INTO truc (nombre, ascii) VALUES (9999, 'doodad');
EXEC SQL COMMIT;
    </programlisting>
   </para>

   <para>
    Supprimer des lignes&nbsp;:
    <programlisting>
EXEC SQL DELETE FROM truc WHERE nombre = 9999;
EXEC SQL COMMIT;
    </programlisting>
   </para>

   <para>
    Mettre à jour des lignes&nbsp;:
    <programlisting>
EXEC SQL UPDATE truc
    SET ascii = 'trucmachin'
    WHERE nombre = 9999;
EXEC SQL COMMIT;
    </programlisting>
   </para>

   <para>
    Les ordres <literal>SELECT</literal> qui retournent un seul enregistrement
    peuvent aussi être exécutés en utilisant <literal>EXEC SQL</literal> directement.
    Pour traiter des jeux de résultats de plusieurs enregistrements, une application
    doit utiliser un curseur; voyez <xref linkend="ecpg-cursors"/> plus bas.
    (Exceptionnellement, une application peut récupérer plusieurs enregistrements
    en une seule fois dans une variable hôte tableau; voyez <xref linkend="ecpg-variables-arrays"/>.)
   </para>

   <para>
    Select mono-ligne&nbsp;:
    <programlisting>
EXEC SQL SELECT truc INTO :trucmachin FROM table1 WHERE ascii = 'doodad';
    </programlisting>
   </para>

   <para>
    De même, un paramètre de configuration peut être récupéré
    avec la commande <literal>SHOW</literal>&nbsp;:
    <programlisting>
EXEC SQL SHOW search_path INTO :var;
    </programlisting>
   </para>

   <para>
    Les tokens de la forme
    <literal>:<replaceable>quelquechose</replaceable></literal> sont des
    <firstterm>variables hôtes</firstterm>, c'est-à-dire qu'ils font
    référence à des variables dans le programme C. Elles sont expliquées
    dans <xref linkend="ecpg-variables"/>.
   </para>
  </sect2>

  <sect2 id="ecpg-cursors">
   <title>Utiliser des Curseurs</title>

   <para>
    Pour récupérer un résultat contenant plusieurs enregistrements, une
    application doit déclarer un curseur et récupérer chaque enregistrement
    de ce curseur. Les étapes pour déclarer un curseur sont les suivantes:
    déclarer le curseur, l'ouvrir, récupérer un enregistrement à partir du
    curseur, répéter, et finalement le fermer.
   </para>

   <para>
    Select avec des curseurs&nbsp;:
    <programlisting>
EXEC SQL DECLARE truc_machin CURSOR FOR
    SELECT nombre, ascii FROM foo
    ORDER BY ascii;
EXEC SQL OPEN truc_machin;
EXEC SQL FETCH truc_machin INTO :TrucMachin, MachinChouette;
...
EXEC SQL CLOSE truc_machin;
EXEC SQL COMMIT;
    </programlisting>
   </para>

   <para>
    Pour plus de détails à propos de la déclaration du curseur,
    voyez <xref linkend="ecpg-sql-declare"/>, et
    voyez <xref linkend="sql-fetch"/> pour le détail de la commande
    <literal>FETCH</literal>
   </para>

   <note>
    <para>
     La commande <command>DECLARE</command> ne déclenche pas réellement
     l'envoi d'un ordre au serveur PostgreSQL. Le curseur est ouvert
     dans le processus serveur (en utilisant la commande
     <command>DECLARE</command>) au moment où la commande
     <command>OPEN</command> est exécutée.
    </para>
   </note>
  </sect2>

  <sect2 id="ecpg-transactions">
   <title>Gérer les Transactions</title>

   <para>
    Dans le mode par défaut, les ordres SQL ne sont validés que quand
    <command>EXEC SQL COMMIT</command> est envoyée. L'interface SQL
    embarquée supporte aussi l'auto-commit des transactions (de façon
    similaire au comportement de <application>psql</application>) via
    l'option de ligne de commande <option>-t</option> d'<command>ecpg</command>
    (voyez <xref linkend="app-ecpg"/>) ou par l'ordre
    <literal>EXEC SQL SET AUTOCOMMIT TO ON</literal>. En mode auto-commit,
    chaque commande est validée automatiquement sauf si elle se trouve dans
    un bloc explicite de transaction. Ce mode peut être explicitement désactivé
    en utilisant <literal>EXEC SQL SET AUTOCOMMIT TO OFF</literal>.
   </para>

   <para>
    Les commandes suivantes de gestion de transaction sont disponibles&nbsp;:

    <variablelist>
     <varlistentry>
      <term><literal>EXEC SQL COMMIT</literal></term>
      <listitem>
       <para>
        Valider une transaction en cours.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL ROLLBACK</literal></term>
      <listitem>
       <para>
        Annuler une transaction en cours.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL PREPARE TRANSACTION </literal><replaceable class="parameter">transaction_id</replaceable></term>
      <listitem>
       <para>
        Préparer la transaction courante pour une transaction en deux phases.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL COMMIT PREPARED </literal><replaceable class="parameter">transaction_id</replaceable></term>
      <listitem>
       <para>
        Valide une transaction qui est dans un état préparé.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL ROLLBACK PREPARED </literal><replaceable class="parameter">transaction_id</replaceable></term>
      <listitem>
       <para>
        Annule une transaction qui est dans un état préparé.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL SET AUTOCOMMIT TO ON</literal></term>
      <listitem>
       <para>
        Activer le mode auto-commit.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL SET AUTOCOMMIT TO OFF</literal></term>
      <listitem>
       <para>
        Désactiver le mode auto-commit. C'est la valeur par défaut.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-prepared">
   <title>Requêtes préparées</title>

   <para>
    Quand les valeurs à passer à un ordre SQL ne sont pas connues au
    moment de la compilation, ou que le même ordre SQL va être utilisé
    de nombreuses fois, les requêtes préparées peuvent être utiles.
   </para>

   <para>
    L'ordre est préparé en utilisant la commande <literal>PREPARE</literal>.
    Pour les valeurs qui ne sont pas encore connues, utilisez le substitut
    <quote><literal>?</literal></quote>:
    <programlisting>
EXEC SQL PREPARE stmt1 FROM "SELECT oid, datname FROM pg_database WHERE oid = ?";
    </programlisting>
   </para>

   <para>
    Si un ordre retourne une seule ligne, l'application peut appeler
    <literal>EXECUTE</literal> après <literal>PREPARE</literal> pour
    exécuter l'ordre, en fournissant les vraies valeurs pour les substituts
    avec une clause <literal>USING</literal>&nbsp;:
    <programlisting>
EXEC SQL EXECUTE stmt1 INTO :dboid, :dbname USING 1;
    </programlisting>
   </para>

   <para>
    Si un ordre retourne plusieurs enregistrements, l'application peut
    utiliser un curseur déclarés en se servant d'une requête préparée.
    Pour lier les paramètres d'entrée, le curseur doit être ouvert avec une
    clause <literal>USING</literal>&nbsp;:
    <programlisting>
EXEC SQL PREPARE stmt1 FROM "SELECT oid,datname FROM pg_database WHERE oid &gt; ?";
EXEC SQL DECLARE foo_bar CURSOR FOR stmt1;

/* Quand la fin du jeu de résultats est atteinte, sortir de la boucle while */
EXEC SQL WHENEVER NOT FOUND DO BREAK;

EXEC SQL OPEN foo_bar USING 100;
...
while (1)
{
    EXEC SQL FETCH NEXT FROM foo_bar INTO :dboid, :dbname;
    ...
}
EXEC SQL CLOSE foo_bar;
    </programlisting>
   </para>

   <para>
    Quand vous n'avez plus besoin de la requête préparée, vous devriez
    la désallouer&nbsp;:
    <programlisting>
EXEC SQL DEALLOCATE PREPARE <replaceable>nom</replaceable>;
    </programlisting>
   </para>

   <para>
    Pour plus de détails sur <literal>PREPARE</literal>,
    voyez <xref linkend="ecpg-sql-prepare"/>. Voyez aussi
    <xref linkend="ecpg-dynamic"/> pour plus de détails à propos
    de l'utilisation des substituts et des paramètres d'entrée.
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-variables">
  <title>Utiliser des Variables Hôtes</title>

  <para>
   Dans <xref linkend="ecpg-commands"/> vous avez vu comment exécuter
   des ordres SQL dans un programme SQL embarqué. Certains de ces ordres
   n'ont utilisé que des valeurs constantes et ne fournissaient pas
   de moyen pour insérer des valeurs fournies par l'utilisateur dans
   des ordres ou pour permettre au programme de traiter les valeurs
   retournées par la requête. Ces types d'ordres ne sont pas très utiles
   dans des applications réelles. Cette section explique en détail comment
   faire passer des données entre votre programme en C et les ordres SQL embarqués
   en utilisant un simple mécanisme appelé <firstterm>variables hôtes</firstterm>.
   Dans un programme SQL embarqué nous considérons que les ordres SQL
   sont des <firstterm>invités</firstterm> dans le code du programme C qui
   est le <firstterm>langage hôte</firstterm>. Par conséquent, les variables du
   programme C sont appelées <firstterm>variables hôtes</firstterm>.
  </para>

  <para>
   Une autre façon d'échanger des valeurs entre les serveurs PostgreSQL
   et les applications ECPG est l'utilisation de descripteurs SQL, décrits
   dans <xref linkend="ecpg-descriptors"/>.
  </para>

  <sect2 id="ecpg-variables-overview">
   <title>Aperçu</title>

   <para>
    Passer des données entre le programme en C et les ordres SQL est
    particulièrement simple en SQL embarqué. Plutôt que d'avoir
    un programme qui conne des données dans un ordre SQL, ce qui
    entraîne des complications variées, comme protéger correctement la
    valeur, vous pouvez simplement écrire le nom d'une variable C
    dans un ordre SQL, préfixée par un deux-points. Par exemple&nbsp;:
    <programlisting>
EXEC SQL INSERT INTO unetable VALUES (:v1, 'foo', :v2);
    </programlisting>
    Cet ordre fait référence à deux variables C appelées
    <varname>v1</varname> et <varname>v2</varname> et utilise aussi
    une chaîne SQL classique, pour montrer que vous n'êtes pas obligé
    de vous cantonner à un type de données ou à l'autre.
   </para>

   <para>
    Cette façon d'insérer des variables C dans des ordres SQL fonctionne
    partout où une expression de valeur est attendue dans un ordre SQL.
   </para>
  </sect2>

  <sect2 id="ecpg-declare-sections">
   <title>Sections Declare</title>

   <para>
    Pour passer des données du programme à la base, par exemple comme
    paramètres d'une requête, ou pour passer des données de la base vers
    le programme, les variables C qui sont prévues pour contenir ces données
    doivent être déclarées dans des sections spécialement identifiées, afin
    que le préprocesseur SQL embarqué puisse s'en rendre compte.
   </para>

   <para>
    Cette section commence par&nbsp;:
    <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    </programlisting>
    et se termine par:
    <programlisting>
EXEC SQL END DECLARE SECTION;
    </programlisting>
    Entre ces lignes, il doit y avoir des déclarations de variables C normales,
    comme&nbsp;:
    <programlisting>
int   x = 4;
char  foo[16], bar[16];
    </programlisting>
    Comme vous pouvez le voir, vous pouvez optionnellement assigner une valeur
    initiale à une variable. La portée de la variable est déterminée par
    l'endroit où se trouve la section de déclaration dans le programme.
    Vous pouvez aussi déclarer des variables avec la syntaxe suivante, qui crée
    une section declare implicite&nbsp;:
    <programlisting>
EXEC SQL int i = 4;
    </programlisting>
    Vous pouvez avoir autant de sections de déclaration que vous voulez
    dans un programme.
   </para>

   <para>
    Ces déclarations sont aussi envoyées dans le fichier produit comme
    des variables C normales, il n'est donc pas nécessaire de les déclarer
    une seconde fois. Les variables qui n'ont pas besoin d'être utilisées dans
    des commandes SQL peuvent être déclarées normalement à l'extérieur de
    ces sections spéciales.
   </para>

   <para>
    La définition d'une structure ou d'un union doit aussi être présente
    dans une section <literal>DECLARE</literal>. Sinon, le préprocesseur ne
    peut pas traiter ces types, puisuq'il n'en connait pas la définition.
   </para>
  </sect2>

  <sect2 id="ecpg-retrieving">
   <title>Récupérer des Résultats de Requêtes</title>

   <para>
    Maintenant, vous devriez être capable de passer des données générées
    par votre programme dans une commande SQL. Mais comment récupérer les
    résultats d'une requête&nbsp;?
    À cet effet, le SQL embarqué fournit certaines variantes spéciales de
    commandes <command>SELECT</command> et <command>FETCH</command> habituelles.
    Ces commandes ont une clause spéciale <literal>INTO</literal> qui spécifie
    dans quelles variables hôtes les valeurs récupérées doivent être stockées.
    <command>SELECT</command> est utilisé pour une requête qui ne retourne qu'un
    seul enregistrement, et <command>FETCH</command> est utilisé pour une
    requête qui retourne plusieurs enregistrement, en utilisant un curseur.
   </para>

   <para>
    Voici un exemple&nbsp;:
    <programlisting>
/*
 * Avec cette table:
 * CREATE TABLE test1 (a int, b varchar(50));
 */

EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL SELECT a, b INTO :v1, :v2 FROM test;
    </programlisting>
    La clause <literal>INTO</literal> apparaît entre la liste de sélection
    et la clause <literal>FROM</literal>. Le nombre d'éléments dans la liste
    SELECT et dans la liste après <literal>INTO</literal> (aussi appelée la liste
    cible) doivent être égaux.
   </para>

   <para>
    Voici un exemple utilisant la commande <command>FETCH</command>&nbsp;:
    <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL DECLARE truc CURSOR FOR SELECT a, b FROM test;

 ...

do
{
    ...
    EXEC SQL FETCH NEXT FROM truc INTO :v1, :v2;
    ...
} while (...);
    </programlisting>
    Ici, la clause <literal>INTO</literal> apparaît après toutes les
    clauses normales.
   </para>
  </sect2>

  <sect2 id="ecpg-variables-type-mapping">
   <title>Correspondance de Type</title>

   <para>
    Quand les applications ECPG échangent des valeurs entre le
    serveur PostgreSQL et l'application C, comme quand elles
    récupèrent des résultats de requête venant du serveur, ou
    qu'elles exécutent des ordres SQL avec des paramètres d'entrée,
    les valeurs doivent être converties entre les types de données
    PostgreSQL et les types du language hôte (ceux du langage C).
    Une des fonctionnalités les plus importantes d'ECPG est qu'il
    s'occupe de cela automatiquement dans la plupart des cas.
   </para>

   <para>
    De ce point de vue, il y a deux sortes de types de données&nbsp;: des types
    de données PostgreSQL simples, comme des <type>integer</type> et
    <type>text</type>, qui peuvent être lus et écrits directement par
    l'application. Les autres types PostgreSQL, comme <type>timestamp</type>
    ou <type>numeric</type> ne peuvent être accédés qu'à travers des fonctions
    spéciales de librairie; voyez <xref linkend="ecpg-special-types"/>.
   </para>

   <para>
    <xref linkend="ecpg-datatype-hostvars-table"/> montre quels types de
    données de PostgreSQL correspondent à quels types C. Quand vous
    voulez envoyer ou recevoir une valeur d'un type PostgreSQL donné,
    vous devriez déclarer une variable C du type C correspondant dans la
    section declare.
   </para>

   <table id="ecpg-datatype-hostvars-table">
    <title>Correspondance Entre les Types PostgreSQL et les Types de Variables C</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>type de données PostgreSQL</entry>
       <entry>type de variable hôte</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><type>smallint</type></entry>
       <entry><type>short</type></entry>
      </row>

      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type></entry>
      </row>

      <row>
       <entry><type>bigint</type></entry>
       <entry><type>long long int</type></entry>
      </row>

      <row>
       <entry><type>decimal</type></entry>
       <entry><type>decimal</type><footnote id="ecpg-datatype-table-fn1"><para>Ce type ne peut être accédé qu'à travers des fonctions spéciales de librairie. Voyez <xref linkend="ecpg-special-types"/>.</para></footnote></entry>
      </row>

      <row>
       <entry><type>numeric</type></entry>
       <entry><type>numeric</type><footnote id="ecpg-datatype-table-fn2"><para>Ce type ne peut être accédé qu'à travers des fonctions spéciales de librairie. Voyez <xref linkend="ecpg-special-types"/>.</para></footnote></entry>
      </row>

      <row>
       <entry><type>real</type></entry>
       <entry><type>float</type></entry>
      </row>

      <row>
       <entry><type>double precision</type></entry>
       <entry><type>double</type></entry>
      </row>

      <row>
       <entry><type>smallserial</type></entry>
       <entry><type>short</type></entry>
      </row>

      <row>
       <entry><type>serial</type></entry>
       <entry><type>int</type></entry>
      </row>

      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>long long int</type></entry>
      </row>

      <row>
       <entry><type>oid</type></entry>
       <entry><type>unsigned int</type></entry>
      </row>

      <row>
       <entry><type>character(<replaceable>n</replaceable>)</type>, <type>varchar(<replaceable>n</replaceable>)</type>, <type>text</type></entry>
       <entry><type>char[<replaceable>n</replaceable>+1]</type>, <type>VARCHAR[<replaceable>n</replaceable>+1]</type></entry>
      </row>

      <row>
       <entry><type>name</type></entry>
       <entry><type>char[NAMEDATALEN]</type></entry>
      </row>

      <row>
       <entry><type>timestamp</type></entry>
       <entry><type>timestamp</type><footnote id="ecpg-datatype-table-fn3"><para>Ce type ne peut être accédé qu'à travers des fonctions spéciales de librairie. Voyez <xref linkend="ecpg-special-types"/>.</para></footnote></entry>
      </row>

      <row>
       <entry><type>interval</type></entry>
       <entry><type>interval</type><footnote id="ecpg-datatype-table-fn4"><para>Ce type ne peut être accédé qu'à travers des fonctions spéciales de librairie. Voyez <xref linkend="ecpg-special-types"/>.</para></footnote></entry>
      </row>

      <row>
       <entry><type>date</type></entry>
       <entry><type>date</type><footnote id="ecpg-datatype-table-fn5"><para>Ce type ne peut être accédé qu'à travers des fonctions spéciales de librairie. Voyez <xref linkend="ecpg-special-types"/>.</para></footnote></entry>
      </row>

      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type><footnote><para>déclaré dans <filename>ecpglib.h</filename> si non natif</para></footnote></entry>
      </row>

      <row>
       <entry><type>bytea</type></entry>
       <entry><type>char *</type>, <type>bytea[<replaceable>n</replaceable>]</type></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <sect3 id="ecpg-char">
    <title>Manipuler des Chaînes de Caractères</title>

    <para>
     Pour manipuler des types chaînes de caractères SQL, comme
     <type>varchar</type> et <type>text</type>, il y a deux façons de
     déclarer les variables hôtes.
    </para>

    <para>
     Une façon est d'utiliser <type>char[]</type>, un tableau de
     <type>char</type>, qui est la façon la plus habituelle de gérer des
     données texte en C.
     <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    char str[50];
EXEC SQL END DECLARE SECTION;
     </programlisting>
     Notez que vous devez gérer la longueur vous-même. Si vous utilisez
     cette variable he comme variable cible d'une requête qui retourne
     une chaîne de plus de 49 caractères, un débordement de tampon
     se produira.
    </para>

    <para>
     L'autre façon est d'utiliser le type <type>VARCHAR</type>, qui
     est un type spécial fourni par ECPG. La définition d'un tableau
     de type <type>VARCHAR</type> est convertie dans un <type>struct</type>
     nommé pour chaque variable. Une déclaration comme&nbsp;:
     <programlisting>
VARCHAR var[180];
     </programlisting>
     est convertie en:
     <programlisting>
struct varchar_var { int len; char arr[180]; } var;
     </programlisting>
     Le membre <structfield>arr</structfield> contient la chaîne terminée
     par un octet à zéro. Par conséquent, la variable hôte doit être
     déclarée avec la longueur incluant le terminateur de chaîne. Le membre
     <structfield>len</structfield> stocke la longueur de la chaîne stockée
     dans <structfield>arr</structfield> sans l'octet zéro final. Quand
     une variable hôte est utilisé comme entrée pour une requête, si
     <literal>strlen</literal> et <structfield>len</structfield> sont différents,
     le plus petit est utilisé.
    </para>

    <para>
     <type>VARCHAR</type> peut être écrit en majuscule ou en minuscule, mais pas dans
     un mélange des deux.
    </para>

    <para>
     Les variables hôtes <type>char</type> et <type>VARCHAR</type> peuvent
     aussi contenir des valeurs d'autres types SQL, qui seront stockés
     dans leur forme chaîne.
    </para>
   </sect3>

   <sect3 id="ecpg-special-types">
    <title>Accéder à des Types de Données Spéciaux</title>

    <para>
     ECPG contient des types spéciaux qui vous aident  interagir facilement
     avec des types de données spéciaux du serveur PostgreSQL. En particulier,
     sont supportés les types <type>numeric</type>, <type>decimal</type>,
     <type>date</type>, <type>timestamp</type>, et <type>interval</type>.
     Ces types de données ne peuvent pas être mis de façon utile en correspondance
     avec des types primitifs du langage hôtes (tels que <type>int</type>,
     <type>long long int</type>, ou <type>char[]</type>), parce qu'ils ont
     une structure interne complexe. Les applications manipulent ces types en
     déclarant des variables hôtes dans des types spéciaux et en y accédant
     avec des fonctions de la librairie pgtypes. La librairie pgtypes, décrite
     en détail dans <xref linkend="ecpg-pgtypes"/> contient des fonctions de
     base pour traiter ces types, afin que vous n'ayez pas besoin d'envoyer une
     requête au serveur SQL juste pour additionner un interval à un timestamp
     par exemple.
    </para>

    <para>
     Les sous-sections suivantes décrivent ces types de données spéciaux.
     Pour plus de détails à propos des fonctions de librairie pgtype, voyez
     <xref linkend="ecpg-pgtypes"/>.
    </para>

    <sect4>
     <title>timestamp, date</title>

     <para>
      Voici une méthode pour manipuler des variables <type>timestamp</type>
      dans l'application hôte ECPG.
     </para>

     <para>
      Tout d'abord, le programme doit inclure le fichier d'en-tête pour
      le type <type>timestamp</type>&nbsp;:
      <programlisting>
#include &lt;pgtypes_timestamp.h>
      </programlisting>
     </para>

     <para>
      Puis, déclarez une variable hôte comme type <type>timestamp</type>
      dans la section declare&nbsp;:
      <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
timestamp ts;
EXEC SQL END DECLARE SECTION;
      </programlisting>
     </para>

     <para>
      Et après avoir lu une valeur dans la variable hôte, traitez la
      en utilisant les fonctions de la librairie pgtypes. Dans l'exemple
      qui suit, la valeur <type>timestamp</type> est convertie sous forme texte
      (ASCII) avec la fonction <function>PGTYPEStimestamp_to_asc()</function>&nbsp;:
      <programlisting>
EXEC SQL SELECT now()::timestamp INTO :ts;

printf("ts = %s\n", PGTYPEStimestamp_to_asc(ts));
      </programlisting>
      Cet exemple affichere des résultats de ce type:
      <screen>
ts = 2010-06-27 18:03:56.949343
      </screen>
     </para>

     <para>
      Par ailleurs, le type DATE peut être manipulé de la même façon.
      Le programme doit inclure <filename>pgtypes_date.h</filename>, déclarer une variable
      hôte comme étant du type date et convertir une valeur DATE dans
      sa forme texte en utilisant la fonction <function>PGTYPESdate_to_asc()</function>.
      Pour plus de détails sur les fonctions de la librairie pgtypes,
      voyez <xref linkend="ecpg-pgtypes"/>.
     </para>
    </sect4>

    <sect4 id="ecpg-type-interval">
     <title>interval</title>

     <para>
      La manipulation du type <type>interval</type> est aussi similaire
      aux types <type>timestamp</type> et <type>date</type>. Il est nécessaire,
      par contre, d'allouer de la mémoire pour une valeur de type
      <type>interval</type> de façon explicite. Ou dit autrement, l'espace
      mémoire pour la variable doit être allouée du tas, et non de la pile.
     </para>

     <para>
      Voici un programme de démonstration&nbsp;:
      <programlisting>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pgtypes_interval.h>

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    interval *in;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    in = PGTYPESinterval_new();
    EXEC SQL SELECT '1 min'::interval INTO :in;
    printf("interval = %s\n", PGTYPESinterval_to_asc(in));
    PGTYPESinterval_free(in);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
      </programlisting>
     </para>
    </sect4>

    <sect4 id="ecpg-type-numeric-decimal">
     <title>numeric, decimal</title>

     <para>
      La manipulation des types <type>numeric</type> et
      <type>decimal</type> est similaire au type <type>interval</type>:
      elle requiert de définir d'un pointeur, d'allouer de la mémoire
      sur le tas, et d'accéder la variable au mouyen des fonctions de
      librairie pgtypes. Pour plus de détails sur les fonctions de la
      librairie pgtypes, voyez <xref linkend="ecpg-pgtypes"/>.
     </para>

     <para>
      Aucune fonction n'est fournie spécifiquement pour le type
      <type>decimal</type>. Une application doit le convertir vers
      une variable <type>numeric</type> en utilisant une fonction de
      la librairie pgtypes pour pouvoir le traiter.
     </para>

     <para>
      Voici un programme montrant la manipulation des variables de type
      <type>numeric</type> et <type>decimal</type>.
      <programlisting>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pgtypes_numeric.h>

EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    numeric *num;
    numeric *num2;
    decimal *dec;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    num = PGTYPESnumeric_new();
    dec = PGTYPESdecimal_new();

    EXEC SQL SELECT 12.345::numeric(4,2), 23.456::decimal(4,2) INTO :num, :dec;

    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 0));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 1));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 2));

    /* Convertir le decimal en numeric pour montrer une valeur décimale. */
    num2 = PGTYPESnumeric_new();
    PGTYPESnumeric_from_decimal(dec, num2);

    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 0));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 1));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 2));

    PGTYPESnumeric_free(num2);
    PGTYPESdecimal_free(dec);
    PGTYPESnumeric_free(num);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
      </programlisting>
     </para>
    </sect4>

    <sect4>
     <title>bytea</title>

     <para>
      La gestion du type <type>bytea</type> est aussi similaire au type
      <type>VARCHAR</type>. La définition d'un tableau de type
      <type>bytea</type> est convertie en une structure nommée pour chaque
      variable. Une déclaration comme&nbsp;:
      <programlisting>
bytea var[180];
      </programlisting>
      est traduit en&nbsp;:
      <programlisting>
struct bytea_var { int len; char arr[180]; } var;
      </programlisting>
      Le membre <structfield>arr</structfield> accueille des données au format
      binaire. Il peut même gérer <literal>'\0'</literal> comme faisant partie
      des données, contrairement à <type>VARCHAR</type>. La donnée est
      converti de/vers le format hexadécimal et envoyé/reçu par ecpglib.
     </para>

     <note>
      <para>
       Une variable <type>bytea</type> peut être utilisé uniquement quand
       <xref linkend="guc-bytea-output"/> est configuré à
       <literal>hex</literal>.
      </para>
     </note>
    </sect4>
   </sect3>

   <sect3 id="ecpg-variables-nonprimitive-c">
    <title>Variables Hôtes avec des Types Non-Primitifs</title>

    <para>
     Vous pouvez aussi utiliser des tableaux, typedefs, structs et pointeurs
     comme variables hôtes.
    </para>

    <sect4 id="ecpg-variables-arrays">
     <title>Arrays</title>

     <para>
      Il y a deux cas d'utilisations pour des tableaux comme variables hôtes.
      Le premier est une façon de stocker des chaînes de texte dans des
      <type>char[]</type> ou <type>VARCHAR[]</type>, comme expliqué
      <xref linkend="ecpg-char"/>. Le second cas d'utilisation est de
      récupérer plusieurs enregistrements d'une requête sans utiliser de
      curseur. Sans un tableau, pour traiter le résultat d'une requête
      de plusieurs lignes, il est nécessaire d'utiliser un curseur et la
      commande <command>FETCH</command>. Mais avec une variable hôte de
      type variable, plusieurs enregistrements peuvent être récupérés
      en une seule fois. La longueur du tableau doit être définie pour
      pouvoir recevoir tous les enregistrements d'un coup, sans quoi un
      buffer overflow se produira probablement.
     </para>

     <para>
      Les exemples suivants parcourent la table système
      <literal>pg_database</literal> et montrent tous les OIDs et
      noms des bases de données disponibles&nbsp;:
      <programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int dbid[8];
    char dbname[8][16];
    int i;
EXEC SQL END DECLARE SECTION;

    memset(dbname, 0, sizeof(char)* 16 * 8);
    memset(dbid, 0, sizeof(int) * 8);

    EXEC SQL CONNECT TO testdb;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    /* Récupérer plusieurs enregistrements dans des tableaux d'un coup. */
    EXEC SQL SELECT oid,datname INTO :dbid, :dbname FROM pg_database;

    for (i = 0; i &lt; 8; i++)
        printf("oid=%d, dbname=%s\n", dbid[i], dbname[i]);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
      </programlisting>

      Cet exemple affiche le résultat suivant. (Les valeurs exactes dépendent
      de votre environnement.)
      <screen>
oid=1, dbname=template1
oid=11510, dbname=template0
oid=11511, dbname=postgres
oid=313780, dbname=testdb
oid=0, dbname=
oid=0, dbname=
oid=0, dbname=
      </screen>
     </para>
    </sect4>

    <sect4 id="ecpg-variables-struct">
     <title>Structures</title>

     <para>
      Une structure dont les noms des membres correspondent aux noms de
      colonnes du résultat d'une requête peut être utilisée pour récupérer
      plusieurs colonnes d'un coup. La structure permet de gérer plusieurs
      valeurs de colonnes dans une seule variable hôte.
     </para>

     <para>
      L'exemple suivant récupère les OIDs, noms, et tailles des bases
      de données disponibles à partir de la table système
      <literal>pg_database</literal>, et en utilisant la fonction
      <function>pg_database_size()</function>. Dans cet exemple,
      une variable structure <varname>dbinfo_t</varname> avec des
      membres dont les noms correspondent à chaque colonnes du résultat
      du <literal>SELECT</literal> est utilisée pour récupérer une ligne
      de résultat sans avoir besoin de mettre plusieurs variables hôtes
      dans l'ordre <literal>FETCH</literal>.
      <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
       long long int size;
    } dbinfo_t;

    dbinfo_t dbval;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;

    /* quand la fin du jeu de données est atteint, sortir de la boucle while */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        /* Récupérer plusieurs colonnes dans une structure. */
        EXEC SQL FETCH FROM cur1 INTO :dbval;

        /* Afficher les membres de la structure. */
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, dbval.size);
    }

    EXEC SQL CLOSE cur1;
      </programlisting>
     </para>

     <para>
      Cet exemple montre le résultat suivant. (Les valeurs exactes dépendent
      du contexte.)
      <screen>
oid=1, datname=template1, size=4324580
oid=11510, datname=template0, size=4243460
oid=11511, datname=postgres, size=4324580
oid=313780, datname=testdb, size=8183012
      </screen>
     </para>

     <para>
      Les variables hôtes structures <quote>absorbent</quote> autant
      de colonnes que la structure a de champs. Des colonnes additionnelles
      peuvent être assignées à d'autres variables hôtes. Par exemple, le
      programme ci-dessus pourrait être restructuré comme ceci, avec
      la variable <varname>size</varname> hors de la structure&nbsp;:
      <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
    } dbinfo_t;

    dbinfo_t dbval;
    long long int size;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;

    /* quand la fin du jeu de données est atteint, sortir de la boucle while */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        /* Récupérer plusieurs colonnes dans une structure. */
        EXEC SQL FETCH FROM cur1 INTO :dbval, :size;

        /* Afficher les membres de la structure. */
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, size);
    }

    EXEC SQL CLOSE cur1;
      </programlisting>
     </para>
    </sect4>

    <sect4>
     <title>Typedefs</title>

     <para>
      Utilisez le mot clé <literal>typedef</literal> pour faire correspondre de
      nouveaux types aux types existants.
      <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef char mychartype[40];
    typedef long serial_t;
EXEC SQL END DECLARE SECTION;
      </programlisting>
      Notez que vous pourriez aussi utiliser:
      <programlisting>
EXEC SQL TYPE serial_t IS long;
      </programlisting>
      Cette déclaration n'a pas besoin de faire partie d'une section declare.
     </para>
    </sect4>

    <sect4>
     <title>Pointeurs</title>

     <para>
      Vous pouvez déclarer des pointeurs vers les types les plus communs.
      Notez toutefois que vous ne pouvez pas utiliser des pointeurs comme
      variables cibles de requêtes sans auto-allocation. Voyez
      <xref linkend="ecpg-descriptors"/> pour plus d'information sur
      l'auto-allocation.
     </para>

     <para>
      <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    int   *intp;
    char **charp;
EXEC SQL END DECLARE SECTION;
      </programlisting>
     </para>
    </sect4>
   </sect3>
  </sect2>

  <sect2 id="ecpg-variables-nonprimitive-sql">
   <title>Manipuler des Types de Données SQL Non-Primitives</title>

   <para>
    Cette section contient des informations sur comment manipuler des
    types non-scalaires et des types de données définies au niveau SQL par
    l'utilisateur dans des applications ECPG. Notez que c'est distinct de
    la manipulation des variables hôtes des types non-primitifs, décrits
    dans la section précédente.
   </para>

   <sect3>
    <title>Tableaux</title>

    <para>
     Les tableaux SQL multi-dimensionnels ne sont pas directement supportés
     dans ECPG. Les tableaux SQL à une dimension peuvent être placés dans des
     variables hôtes de type tableau C et vice-versa. Néanmoins, lors de la
     création d'une instruction, ecpg ne connaît pas le type des colonnes, donc
     il ne peut pas vérifier si un tableau C est à placer dans un tableau SQL
     correspondant. Lors du traitement de la sortie d'une requête SQL, ecpg
     a suffisamment d'informations et, de ce fait, vérifie si les deux sont
     des tableaux.
    </para>

    <para>
     Si une requête accède aux <emphasis>éléments</emphasis> d'un tableau
     séparément, cela évite l'utilisation des tableaux dans ECPG. Dans ce cas, une
     variable hôte avec un type qui peut être mis en correspondance
     avec le type de l'élément devrait être utilisé. Par exemple, si
     le type d'une colonne est un tableau d'<type>integer</type>, une
     variable hôte de type <type>int</type> peut être utilisée. Par ailleurs,
     si le type de l'élément est <type>varchar</type>, ou <type>text</type>,
     une variable hôte de type <type>char[]</type> ou <type>VARCHAR[]</type>
     peut être utilisée.
    </para>

    <para>
     Voici un exemple. Prenez la table suivante&nbsp;:
     <programlisting>
CREATE TABLE t3 (
    ii integer[]
);

testdb=&gt; SELECT * FROM t3;
     ii
-------------
 {1,2,3,4,5}
(1 row)
     </programlisting>

     Le programme de démonstration suivant récupère le 4ème élément du
     tableau et le stocke dans une variable hôte de type <type>int</type>&nbsp;:
     <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii;
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii ;
    printf("ii=%d\n", ii);
}

EXEC SQL CLOSE cur1;
     </programlisting>

     Cet exemple affiche le résultat suivant&nbsp;:
     <screen>
ii=4
     </screen>
    </para>

    <para>
     Pour mettre en correspondance de multiples éléments de tableaux
     avec les multiples éléments d'une variable hôte tableau, chaque
     élément du tableau doit être géré séparément, par exemple&nbsp;:
     <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[1], ii[2], ii[3], ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii_a[0], :ii_a[1], :ii_a[2], :ii_a[3];
    ...
}
     </programlisting>
    </para>

    <para>
     Notez à nouveau que
     <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* FAUX */
    EXEC SQL FETCH FROM cur1 INTO :ii_a;
    ...
}
     </programlisting>
     ne fonctionnerait pas correctement dans ce cas, parce que vous ne pouvez
     pas mettre en correspondance une colonne de type tableau et une variable
     hôte de type tableau directement.
    </para>

    <para>
     Un autre contournement possible est de stocker les tableaux dans
     leur forme de représentation texte dans des variables hôtes de type
     <type>char[]</type> ou <type>VARCHAR[]</type>. Pour plus de détails sur
     cette représentation, voyez <xref linkend="arrays-input"/>. Notez que
     cela implique que le tableau ne peut pas être accédé naturellement
     comme un tableau dans le programme hôte (sans traitement supplémentaire
     qui transforme la représentation texte).
    </para>
   </sect3>

   <sect3>
    <title>Types Composite</title>

    <para>
     Les types composite ne sont pas directement supportés dans ECPG, mais un contournement simple
     est possible.
     Les contournements disponibles sont similaires à ceux décrits pour les tableaux
     ci-dessus: soit accéder à chaque attribut séparément, ou utiliser la représentation
     externe en mode chaîne de caractères.
    </para>

    <para>
     Pour les exemples suivants, soient les types et tables suivants&nbsp;:
     <programlisting>
CREATE TYPE comp_t AS (intval integer, textval varchar(32));
CREATE TABLE t4 (compval comp_t);
INSERT INTO t4 VALUES ( (256, 'PostgreSQL') );
     </programlisting>

     La solution la plus évidente est d'accéder à chaque attribut séparément.
     Le programme suivant récupère les données de la table exemple en
     sélectionnant chaque attribut du type <type>comp_t</type> séparément&nbsp;:
     <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int intval;
varchar textval[33];
EXEC SQL END DECLARE SECTION;

/* Mettre chaque élément de la colonne de type composite dans la liste SELECT. */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* Récupérer chaque élément du type de colonne composite dans des variables hôtes. */
    EXEC SQL FETCH FROM cur1 INTO :intval, :textval;

    printf("intval=%d, textval=%s\n", intval, textval.arr);
}

EXEC SQL CLOSE cur1;
     </programlisting>
    </para>

    <para>
     Pour améliorer cet exemple, les variables hôtes qui vont stocker
     les valeurs dans la commande <command>FETCH</command> peuvent être
     rassemblées sous forme de structure, voyez <xref linkend="ecpg-variables-struct"/>.
     Pour passer à la structure, l'exemple peut-être modifié comme ci dessous.
     Les deux variables hôtes, <varname>intval</varname> et
     <varname>textval</varname>, deviennent membres de <structname>comp_t</structname>,
     et la structure est spécifiée dans la commande <command>FETCH</command>.
     <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
typedef struct
{
    int intval;
    varchar textval[33];
} comp_t;

comp_t compval;
EXEC SQL END DECLARE SECTION;

/* Mettre chaque élément de la colonne de type composite dans la liste SELECT. */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* Mettre toutes les valeurs de la liste SELECT dans une structure. */
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}

EXEC SQL CLOSE cur1;
     </programlisting>

     Bien qu'une structure soit utilisée dans la commande
     <command>FETCH</command>, les noms d'attributs dans la clause
     <command>SELECT</command> sont spécifiés un par un. Cela peut être
     amélioré en utilisant un <literal>*</literal> pour demander
     tous les attributs de la valeur de type composite.
     <programlisting>
...
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).* FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* Mettre toutes les valeurs de la liste SELECT dans une structure. */
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}
...
     </programlisting>
     De cette façon, les types composites peuvent être mis en correspondance
     avec des structures de façon quasi transparentes, alors qu'ECPG
     ne comprend pas lui-même le type composite.
    </para>

    <para>
     Et pour finir, il est aussi possible de stocker les valeurs de
     type composite dans leur représentation externe de type chaîne
     dans des variables hôtes de type <type>char[]</type> ou
     <type>VARCHAR[]</type>. Mais de cette façon, il n'est pas facilement
     possible d'accéder aux champs de la valeur dans le programme hôte.
    </para>
   </sect3>

   <sect3>
    <title>Types de Base Définis par l'Utilisateur</title>

    <para>
     Les nouveaux types de base définis par l'utilisateur ne sont pas
     directement supportés par ECPG. Vous pouvez utiliser les représentations
     externes de type chaîne et les variables hôtes de type <type>char[]</type>
     ou <type>VARCHAR[]</type>, et cette solution est en fait
     appropriée et suffisante pour de nombreux types.
    </para>

    <para>
     Voici un exemple utilisant le type de données <type>complex</type>
     de l'exemple tiré de <xref linkend="xtypes"/>. La représentation
     externe sous forme de chaîne de ce type est
     <literal>(%lf,%lf)</literal>, qui est définie dans les fonctions
     <function>complex_in()</function> et <function>complex_out()</function>.
     L'exemple suivant insère les valeurs de type complexe
     <literal>(1,1)</literal> et <literal>(3,3)</literal> dans les colonnes
     <literal>a</literal> et <literal>b</literal>, et les sélectionne à partir
     de la table après cela.

     <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    varchar a[64];
    varchar b[64];
EXEC SQL END DECLARE SECTION;

    EXEC SQL INSERT INTO test_complex VALUES ('(1,1)', '(3,3)');

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT a, b FROM test_complex;
    EXEC SQL OPEN cur1;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH FROM cur1 INTO :a, :b;
        printf("a=%s, b=%s\n", a.arr, b.arr);
    }

    EXEC SQL CLOSE cur1;
     </programlisting>

     Cet exemple affiche le résultat suivant&nbsp;:
     <screen>
a=(1,1), b=(3,3)
     </screen>
    </para>

    <para>
     Un autre contournement est d'éviter l'utilisation directe des types
     définis par l'utilisateur dans ECPG et à la place créer une fonction
     ou un cast qui convertit entre le type défini par l'utilisateur et
     un type primitif que ECPG peut traiter. Notez, toutefois, que les
     conversions de types, particulièrement les implicites, ne devraient
     être introduits dans le système de typage qu'avec la plus grande
     prudence.
    </para>

    <para>
     Par exemple,
     <programlisting>
CREATE FUNCTION create_complex(r double, i double) RETURNS complex
LANGUAGE SQL
IMMUTABLE
AS $$ SELECT $1 * complex '(1,0')' + $2 * complex '(0,1)' $$;
     </programlisting>
     Après cette définition, ce qui suit
     <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
double a, b, c, d;
EXEC SQL END DECLARE SECTION;

a = 1;
b = 2;
c = 3;
d = 4;

EXEC SQL INSERT INTO test_complex VALUES (create_complex(:a, :b), create_complex(:c, :d));
     </programlisting>
     a le même effet que
     <programlisting>
EXEC SQL INSERT INTO test_complex VALUES ('(1,2)', '(3,4)');
     </programlisting>
    </para>
   </sect3>
  </sect2>

  <sect2 id="ecpg-indicators">
   <title>Indicateurs</title>

   <para>
    Les exemples précédents ne gèrent pas les valeurs nulles. En fait,
    les exemples de récupération de données remonteront une erreur si
    ils récupèrent une valeur nulle de la base. Pour être capable de passer
    des valeurs nulles à la base ou d'un récupérer, vous devez rajouter
    une seconde spécification de variable hôte à chaque variable hôte
    contenant des données. Cette seconde variable est appelée
    l'<firstterm>indicateur</firstterm> et contient un drapeau qui indique
    si le datum est null, dans quel cas la valeur de la vraie variable
    hôte est ignorée. Voici un exemple qui gère la récupération de valeurs
    nulles correctement&nbsp;:
    <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
VARCHAR val;
int val_ind;
EXEC SQL END DECLARE SECTION:

 ...

EXEC SQL SELECT b INTO :val :val_ind FROM test1;
    </programlisting>
    La variable indicateur <varname>val_ind</varname> sera zéro si
    la valeur n'était pas nulle, et sera négative si la valeur était nulle.
   </para>

   <para>
    L'indicateur a une autre fonction: si la valeur de l'indicateur est
    positive, cela signifie que la valeur n'est pas nulle, mais qu'elle
    a été tronquée quand elle a été stockée dans la variable hôte.
   </para>

   <para>
    Si l'argument <literal>-r no_indicator</literal> est passée au
    préprocesseur <command>ecpg</command>, il fonction dans le mode
    <quote>no-indicator</quote>. En mode no-indicator, si aucune variable
    indicator n'est spécifiée, les valeurs nulles sont signalées (en
    entrée et en sortie) pour les types chaînes de caractère comme
    des chaînes vides et pour les types integer comme la plus petite valeur
    possible pour le type (par exemple, <symbol>INT_MIN</symbol> pour
    <type>int</type>).
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-dynamic">
  <title>SQL Dynamique</title>

  <para>
   Fréquemment, les ordres SQL particuliers qu'une application doit
   exécuter sont connus au moment où l'application est écrite. Dans
   certains cas, par contre, les ordres SQL sont composés à l'exécution
   ou fournis par une source externe. Dans ces cas, vous ne pouvez
   pas embarquer les ordres SQL directement dans le code source C, mais
   il y a une fonctionnalité qui vous permet d'exécuter des ordres SQL
   que vous fournissez dans une variable de type chaîne.
  </para>

  <sect2 id="ecpg-dynamic-without-result">
   <title>Exécuter des Ordres SQL Dynamiques sans Jeu de Donnée</title>

   <para>
    La façon la plus simple d'exécuter un ordre SQL dynamique est d'utiliser la
    commande <command>EXECUTE IMMEDIATE</command>. Par exemple&nbsp;:
    <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "CREATE TABLE test1 (...);";
EXEC SQL END DECLARE SECTION;

EXEC SQL EXECUTE IMMEDIATE :stmt;
    </programlisting>
    <command>EXECUTE IMMEDIATE</command> peut être utilisé
    pour des ordres SQL qui ne retournent pas de données (par exemple,
    LDD, <command>INSERT</command>, <command>UPDATE</command>,
    <command>DELETE</command>). Vous ne pouvez pas exécuter d'ordres
    qui ramènent des données (par exemple, <command>SELECT</command>)
    de cette façon. La prochaine section décrit comment le faire.
   </para>
  </sect2>

  <sect2 id="ecpg-dynamic-input">
   <title>Exécuter une requête avec des paramètres d'entrée</title>

   <para>
    Une façon plus puissante d'exécuter des ordres SQL arbitraires
    est de les préparer une fois et d'exécuter la requête préparée aussi
    souvent que vous le souhaitez. Il est aussi possible de préparer une
    version généralisé d'une requête et d'ensuite en exécuter des versions
    spécifiques par substitution de paramètres. Quand vous préparez la requête,
    mettez des points d'interrogation où vous voudrez substituer des
    paramètres ensuite. Par exemple&nbsp;:
    <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "INSERT INTO test1 VALUES(?, ?);";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt USING 42, 'foobar';
    </programlisting>
   </para>

   <para>
    Quand vous n'avez plus besoin de la requête préparée, vous devriez
    la désallouer&nbsp;:
    <programlisting>
EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;
    </programlisting>
   </para>
  </sect2>

  <sect2 id="ecpg-dynamic-with-result">
   <title>Exécuter une Requête avec un Jeu de Données</title>

   <para>
    Pour exécuter une requête SQL avec une seule ligne de résultat,
    vous pouvez utiliser <command>EXECUTE</command>. Pour enregistrer
    le résultat, ajoutez une clause <literal>INTO</literal>.
    <programlisting><![CDATA[
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "SELECT a, b, c FROM test1 WHERE a > ?";
int v1, v2;
VARCHAR v3[50];
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt INTO :v1, :v2, :v3 USING 37;
]]>
    </programlisting>
    Une commande <command>EXECUTE</command> peut avoir une clause
    <literal>INTO</literal>, une clause <literal>USING</literal>,
    les deux, ou aucune.
   </para>

   <para>
    Si une requête peut ramener plus d'un enregistrement, un curseur
    devrait être utilisé, comme dans l'exemple suivant.
    Voyez <xref linkend="ecpg-cursors"/>  pour plus de détails à
    propos des curseurs.)
    <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char dbaname[128];
char datname[128];
char *stmt = "SELECT u.usename as dbaname, d.datname "
             "  FROM pg_database d, pg_user u "
             "  WHERE d.datdba = u.usesysid";
EXEC SQL END DECLARE SECTION;

EXEC SQL CONNECT TO testdb AS con1 USER testuser;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

EXEC SQL PREPARE stmt1 FROM :stmt;

EXEC SQL DECLARE cursor1 CURSOR FOR stmt1;
EXEC SQL OPEN cursor1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH cursor1 INTO :dbaname,:datname;
    printf("dbaname=%s, datname=%s\n", dbaname, datname);
}

EXEC SQL CLOSE cursor1;

EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
    </programlisting>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-pgtypes">
  <title>Librairie pgtypes</title>

  <para>
   La librairie pgtypes met en correspondance les types de la base de
   données <productname>PostgreSQL</productname> avec des équivalents en C
   qui peuvent être utilisés dans des programmes en C. Elle fournit aussi
   des fonctions pour effectuer les calculs de base avec ces types en C, c'est
   à dire, sans l'aide du serveur <productname>PostgreSQL</productname>. Voyez
   l'exemple suivant&nbsp;:
   <programlisting><![CDATA[
EXEC SQL BEGIN DECLARE SECTION;
   date date1;
   timestamp ts1, tsout;
   interval iv1;
   char *out;
EXEC SQL END DECLARE SECTION;

PGTYPESdate_today(&date1);
EXEC SQL SELECT started, duration INTO :ts1, :iv1 FROM datetbl WHERE d=:date1;
PGTYPEStimestamp_add_interval(&ts1, &iv1, &tsout);
out = PGTYPEStimestamp_to_asc(&tsout);
printf("Started + duration: %s\n", out);
PGTYPESchar_free(out);
]]>
   </programlisting>
  </para>

  <sect2 id="ecpg-pgtypes-cstrings">
   <title>Chaîne de caractères</title>

   <para>
    Certaines fonctions comme <function>PGTYPESnumeric_to_asc</function>
    renvoient un pointeur vers une chaîne de caractères fraichement allouée.
    Ces allocations doivent être libérées avec
    <function>PGTYPESchar_free</function> plutôt que
    <function>free</function>. (Ceci est seulement important sur Windows où
    l'allocation et la désallocation de la mémoire ont parfois besoin d'être
    réalisées par la même bibliothèque.)
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-numeric">
   <title>Le type numeric</title>
   <para>
    Le type numeric permet de faire des calculs de précision arbitraire. Voyez
    <xref linkend="datatype-numeric"/>  pour le type équivalent dans le serveur
    <productname>PostgreSQL</productname>. En raison de cette précision arbitraire
    cette variable doit pouvoir s'étendre et se réduire dynamiquement. C'est pour
    cela que vous ne pouvez créer des variables numeric que sur le tas, en utilisant
    les fonctions <function>PGTYPESnumeric_new</function> et
    <function>PGTYPESnumeric_free</function>. Le type décimal, qui est similaire mais de
    précision limitée, peut être créé sur la pile ou sur le tas.
   </para>
   <para>
    Les fonctions suivantes peuvent être utilisées pour travailler avec le type numeric&nbsp;:
    <variablelist>
     <varlistentry>
      <term><function>PGTYPESnumeric_new</function></term>
      <listitem>
       <para>
        Demander un pointeur vers une variable numérique nouvellement allouée.
        <synopsis>
numeric *PGTYPESnumeric_new(void);
        </synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESnumeric_free</function></term>
      <listitem>
       <para>
        Désallouer un type numérique, libérer toute sa mémoire.
        <synopsis>
void PGTYPESnumeric_free(numeric *var);
        </synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESnumeric_from_asc</function></term>
      <listitem>
       <para>
        Convertir un type numérique à partir de sa notation chaîne.
        <synopsis>
numeric *PGTYPESnumeric_from_asc(char *str, char **endptr);
        </synopsis>
        Les formats valides sont par exemple:
        <literal>-2</literal>,
        <literal>.794</literal>,
        <literal>+3.44</literal>,
        <literal>592.49E07</literal> or
        <literal>-32.84e-4</literal>.
        Si la valeur peut être convertie correctement, un pointeur valide est
        retourné, sinon un pointeur NULL. À l'heure actuelle ECPG traite toujours
        la chaine en entier, il n'est donc pas possible pour le moment de
        stocker l'adresse du premier caractère invalide dans <literal>*endptr</literal>.
        Vous pouvez sans risque positionner <literal>endptr</literal> à NULL.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESnumeric_to_asc</function></term>
      <listitem>
       <para>
        Retourne un pointeur vers la chaîne allouée par <function>malloc</function> qui contient
        la représentation chaîne du type numérique <literal>num</literal>.
        <synopsis>
char *PGTYPESnumeric_to_asc(numeric *num, int dscale);
        </synopsis>
        La valeur numérique sera affichée avec <literal>dscale</literal> chiffres
        décimaux, et sera arrondie si nécessaire.
        Le résultat doit être libéré avec <function>PGTYPESchar_free()</function>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESnumeric_add</function></term>
      <listitem>
       <para>
        Ajoute deux variables numériques à une troisième.
        <synopsis>
int PGTYPESnumeric_add(numeric *var1, numeric *var2, numeric *result);
        </synopsis>
        La fonction additionne les variables <literal>var1</literal> et
        <literal>var2</literal> dans la variable résultat
        <literal>result</literal>.
        La fonction retourne 0 en cas de succès et -1 en cas d'erreur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESnumeric_sub</function></term>
      <listitem>
       <para>
        Soustrait deux variables numériques et retourne le résultat dans
        une troisième.
        <synopsis>
int PGTYPESnumeric_sub(numeric *var1, numeric *var2, numeric *result);
        </synopsis>
        La fonction soustrait la variable <literal>var2</literal> de
        la variable <literal>var1</literal>. Le résultat de l'opération est
        stocké dans la variable <literal>result</literal>.
        La fonction retourne 0 en cas de succès et -1 en cas d'erreur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESnumeric_mul</function></term>
      <listitem>
       <para>
        Multiplie deux valeurs numeric et retourne le résultat dans une
        troisième.
        <synopsis>
int PGTYPESnumeric_mul(numeric *var1, numeric *var2, numeric *result);
        </synopsis>
        La fonction multiplie la variable <literal>var2</literal> de
        la variable <literal>var1</literal>. Le résultat de l'opération est
        stocké dans la variable <literal>result</literal>.
        La fonction retourne 0 en cas de succès et -1 en cas d'erreur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESnumeric_div</function></term>
      <listitem>
       <para>
        Divise deux valeurs numeric et retourne le résultat dans une troisième.
        <synopsis>
int PGTYPESnumeric_div(numeric *var1, numeric *var2, numeric *result);
        </synopsis>
        La fonction divise la variable <literal>var2</literal> de
        la variable <literal>var1</literal>. Le résultat de l'opération est
        stocké dans la variable <literal>result</literal>.
        La fonction retourne 0 en cas de succès et -1 en cas d'erreur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESnumeric_cmp</function></term>
      <listitem>
       <para>
        Compare deux variables numeric.
        <synopsis>
int PGTYPESnumeric_cmp(numeric *var1, numeric *var2)
        </synopsis>
        Cette fonction compare deux variables numeric. En cas d'erreur,
        <literal>INT_MAX</literal> est retourné. En cas de réussite, la
        fonction retourne un des trois résultats suivants&nbsp;:
        <itemizedlist>
         <listitem>
          <para>
           1, si <literal>var1</literal> est plus grand que <literal>var2</literal>
          </para>
         </listitem>
         <listitem>
          <para>
           -1, si <literal>var1</literal> est plus petit que <literal>var2</literal>
          </para>
         </listitem>
         <listitem>
          <para>
           0, si <literal>var1</literal> et <literal>var2</literal> sont égaux
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESnumeric_from_int</function></term>
      <listitem>
       <para>
        Convertit une variable int en variable numeric.
        <synopsis>
int PGTYPESnumeric_from_int(signed int int_val, numeric *var);
        </synopsis>
        Cette fonction accepte une variable de type signed int et la stocke dans
        la variable numeric <literal>var</literal>. La fonction retourne 0 en cas de
        réussite, et -1 en cas d'échec.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESnumeric_from_long</function></term>
      <listitem>
       <para>
        Convertit une variable long int en variable numeric.
        <synopsis>
int PGTYPESnumeric_from_long(signed long int long_val, numeric *var);
        </synopsis>
        Cette fonction accepte une variable de type signed long int et la stocke dans
        la variable numeric <literal>var</literal>. La fonction retourne 0 en cas de
        réussite, et -1 en cas d'échec.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESnumeric_copy</function></term>
      <listitem>
       <para>
        Copie une variable numeric dans une autre.
        <synopsis>
int PGTYPESnumeric_copy(numeric *src, numeric *dst);
        </synopsis>
        Cette fonction copie la valeur de la variable vers laquelle
        <literal>src</literal> pointe dans la variable vers laquelle
        <literal>dst</literal>. Elle retourne 0 en cas de réussite et -1 en
        cas d'échec.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESnumeric_from_double</function></term>
      <listitem>
       <para>
        Convertit une variable de type double en variable numeric.
        <synopsis>
int  PGTYPESnumeric_from_double(double d, numeric *dst);
        </synopsis>
        Cette fonction accepte une variable de type double et la stocke dans
        la variable numeric <literal>dst</literal>. La fonction retourne 0 en cas de
        réussite, et -1 en cas d'échec.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESnumeric_to_double</function></term>
      <listitem>
       <para>
        Convertit une variable de type numeric en double.
        <synopsis>
int PGTYPESnumeric_to_double(numeric *nv, double *dp)
        </synopsis>
        Cette fonction convertit la valeur numeric de la variable vers la quelle
        <literal>nv</literal> pointe vers la variable double vers laquelle
        <literal>dp</literal> pointe. Elle retourne 0 en cas de réussite et -1 en
        cas d'échec, les cas de dépassement de capacité inclus. En cas de dépassement,
        la variable globale <literal>errno</literal> sera positionnée à
        <literal>PGTYPES_NUM_OVERFLOW</literal> en plus.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESnumeric_to_int</function></term>
      <listitem>
       <para>
        Convertit une variable de type numeric en int.
        <synopsis>
int PGTYPESnumeric_to_int(numeric *nv, int *ip);
        </synopsis>
        Cette fonction convertit la valeur numeric de la variable vers la quelle
        <literal>nv</literal> pointe vers la variable int vers laquelle
        <literal>ip</literal> pointe. Elle retourne 0 en cas de réussite et -1 en
        cas d'échec, les cas de dépassement de capacité inclus. En cas de dépassement,
        la variable globale <literal>errno</literal> sera positionnée à
        <literal>PGTYPES_NUM_OVERFLOW</literal> en plus.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESnumeric_to_long</function></term>
      <listitem>
       <para>
        Convertit une variable de type numeric en long.
        <synopsis>
int PGTYPESnumeric_to_long(numeric *nv, long *lp);
        </synopsis>
        Cette fonction convertit la valeur numeric de la variable vers la quelle
        <literal>nv</literal> pointe vers la variable long vers laquelle
        <literal>lp</literal> pointe. Elle retourne 0 en cas de réussite et -1 en
        cas d'échec, les cas de dépassement de capacité inclus. En cas de dépassement,
        la variable globale <literal>errno</literal> sera positionnée à
        <literal>PGTYPES_NUM_OVERFLOW</literal> en plus.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESnumeric_to_decimal</function></term>
      <listitem>
       <para>
        Convertit une variable de type numeric en decimal.
        <synopsis>
int PGTYPESnumeric_to_decimal(numeric *src, decimal *dst);
        </synopsis>
        Cette fonction convertit la valeur numeric de la variable vers la quelle
        <literal>src</literal> pointe vers la variable decimal vers laquelle
        <literal>dst</literal> pointe. Elle retourne 0 en cas de réussite et -1 en
        cas d'échec, les cas de dépassement de capacité inclus. En cas de dépassement,
        la variable globale <literal>errno</literal> sera positionnée à
        <literal>PGTYPES_NUM_OVERFLOW</literal> en plus.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESnumeric_from_decimal</function></term>
      <listitem>
       <para>
        Convertit une variable de type decimal en numeric.
        <synopsis>
int PGTYPESnumeric_from_decimal(decimal *src, numeric *dst);
        </synopsis>
        Cette fonction convertit la valeur decimal de la variable vers la quelle
        <literal>src</literal> pointe vers la variable numeric vers laquelle
        <literal>dst</literal> pointe. Elle retourne 0 en cas de réussite et -1 en
        cas d'échec. Comme le type decimal est implémentée comme une version limitée
        du type numeric, un dépassement ne peut pas se produire lors de cette conversion.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-date">
   <title>Le Type date</title>
   <para>
    Le type date en C permet à votre programme de traiter les données type type
    SQL date. Voyez <xref linkend="datatype-datetime"/> pour le type équivalent
    du serveur <productname>PostgreSQL</productname>.
   </para>
   <para>
    Les fonctions suivantes peuvent être utilisées pour travailler avec le type date&nbsp;:
    <variablelist>
     <varlistentry id="pgtypesdatefromtimestamp">
      <term><function>PGTYPESdate_from_timestamp</function></term>
      <listitem>
       <para>
        Extraire la partie date d'un timestamp.
        <synopsis>
date PGTYPESdate_from_timestamp(timestamp dt);
        </synopsis>
        Cette fonction reçoit un timestamp comme seul argument et retourne la partie
        date extraite de ce timestamp.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatefromasc">
      <term><function>PGTYPESdate_from_asc</function></term>
      <listitem>
       <para>
        Convertit une date à partir de sa représentation textuelle.
        <synopsis>
date PGTYPESdate_from_asc(char *str, char **endptr);
        </synopsis>
        Cette fonction reçoit une chaîne char* C <literal>str</literal> et un pointeur
        vers une chaîne char* C <literal>endptr</literal>. À l'heure actuelle ECPG traite
        toujours intégralement la chaîne, et ne supporte donc pas encore l'adresse du premier
        caractère invalide dans <literal>*endptr</literal>. Vous pouvez positionner
        <literal>endptr</literal> à NULL sans risque.
       </para>
       <para>
        Notez que la fonction attend toujours une date au format MDY et qu'il n'y
        a aucune variable à l'heure actuelle pour changer cela dans ECPG.
       </para>
       <para>
        <xref linkend="ecpg-pgtypesdate-from-asc-table"/> montre les formats
        autorisés en entrée.
       </para>
       <table id="ecpg-pgtypesdate-from-asc-table">
        <title>Formats d'Entrée Valides pour <function>PGTYPESdate_from_asc</function></title>
        <tgroup cols="2">
         <thead>
          <row>
           <entry>Entrée</entry>
           <entry>Sortie</entry>
          </row>
         </thead>
         <tbody>
          <row>
           <entry><literal>January 8, 1999</literal></entry>
           <entry><literal>January 8, 1999</literal></entry>
          </row>
          <row>
           <entry><literal>1999-01-08</literal></entry>
           <entry><literal>January 8, 1999</literal></entry>
          </row>
          <row>
           <entry><literal>1/8/1999</literal></entry>
           <entry><literal>January 8, 1999</literal></entry>
          </row>
          <row>
           <entry><literal>1/18/1999</literal></entry>
           <entry><literal>January 18, 1999</literal></entry>
          </row>
          <row>
           <entry><literal>01/02/03</literal></entry>
           <entry><literal>February 1, 2003</literal></entry>
          </row>
          <row>
           <entry><literal>1999-Jan-08</literal></entry>
           <entry><literal>January 8, 1999</literal></entry>
          </row>
          <row>
           <entry><literal>Jan-08-1999</literal></entry>
           <entry><literal>January 8, 1999</literal></entry>
          </row>
          <row>
           <entry><literal>08-Jan-1999</literal></entry>
           <entry><literal>January 8, 1999</literal></entry>
          </row>
          <row>
           <entry><literal>99-Jan-08</literal></entry>
           <entry><literal>January 8, 1999</literal></entry>
          </row>
          <row>
           <entry><literal>08-Jan-99</literal></entry>
           <entry><literal>January 8, 1999</literal></entry>
          </row>
          <row>
           <entry><literal>08-Jan-06</literal></entry>
           <entry><literal>January 8, 2006</literal></entry>
          </row>
          <row>
           <entry><literal>Jan-08-99</literal></entry>
           <entry><literal>January 8, 1999</literal></entry>
          </row>
          <row>
           <entry><literal>19990108</literal></entry>
           <entry><literal>ISO 8601; January 8, 1999</literal></entry>
          </row>
          <row>
           <entry><literal>990108</literal></entry>
           <entry><literal>ISO 8601; January 8, 1999</literal></entry>
          </row>
          <row>
           <entry><literal>1999.008</literal></entry>
           <entry><literal>year and day of year</literal></entry>
          </row>
          <row>
           <entry><literal>J2451187</literal></entry>
           <entry><literal>Julian day</literal></entry>
          </row>
          <row>
           <entry><literal>January 8, 99 BC</literal></entry>
           <entry><literal>year 99 before the Common Era</literal></entry>
          </row>
         </tbody>
        </tgroup>
       </table>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatetoasc">
      <term><function>PGTYPESdate_to_asc</function></term>
      <listitem>
       <para>
        Retourne la représentation textuelle d'une variable date.
        <synopsis>
char *PGTYPESdate_to_asc(date dDate);
        </synopsis>
        La fonction reçoit la date <literal>dDate</literal> comme unique paramètre.
        Elle retournera la date dans la forme <literal>1999-01-18</literal>, c'est-à-dire
        le format <literal>YYYY-MM-DD</literal>.
        Le résultat doit être libéré avec <function>PGTYPESchar_free()</function>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatejulmdy">
      <term><function>PGTYPESdate_julmdy</function></term>
      <listitem>
       <para>
        Extrait les valeurs pour le jour, le mois et l'année d'une variable de
        type date.
        <synopsis>
void PGTYPESdate_julmdy(date d, int *mdy);
        </synopsis>
        <!-- almost same description as for rjulmdy() -->
        La fonction reçoit la date <literal>d</literal> et un pointeur vers un tableau
        de 3 valeurs entières <literal>mdy</literal>. Le nom de variable indique l'ordre
        séquentiel: <literal>mdy[0]</literal> contiendra le numéro du mois,
        <literal>mdy[1]</literal> contiendra le numéro du jour et
        <literal>mdy[2]</literal> contiendra l'année.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatemdyjul">
      <term><function>PGTYPESdate_mdyjul</function></term>
      <listitem>
       <para>
        Crée une valeur date à partir d'un tableau de 3 entiers qui spécifient
        le jour, le mois et l'année de la date.
        <synopsis>
void PGTYPESdate_mdyjul(int *mdy, date *jdate);
        </synopsis>
        Cette fonction reçoit le tableau des 3 entiers (<literal>mdy</literal>) comme
        premier argument, et son second argument est un pointeur vers la variable de
        type date devant contenir le résultat de l'opération.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatedayofweek">
      <term><function>PGTYPESdate_dayofweek</function></term>
      <listitem>
       <para>
        Retourne un nombre représentant le jour de la semaine pour une valeur date.
        <synopsis>
int PGTYPESdate_dayofweek(date d);
        </synopsis>
        La fonction reçoit la variable date <literal>d</literal> comme seul argument
        et retourne un entier qui indique le jour de la semaine pour cette date.
        this date.
        <itemizedlist>
         <listitem>
          <para>
           0 - Dimanche
          </para>
         </listitem>
         <listitem>
          <para>
           1 - Lundi
          </para>
         </listitem>
         <listitem>
          <para>
           2 - Mardi
          </para>
         </listitem>
         <listitem>
          <para>
           3 - Mercredi
          </para>
         </listitem>
         <listitem>
          <para>
           4 - Jeudi
          </para>
         </listitem>
         <listitem>
          <para>
           5 - Vendredi
          </para>
         </listitem>
         <listitem>
          <para>
           6 - Samedi
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatetoday">
      <term><function>PGTYPESdate_today</function></term>
      <listitem>
       <para>
        Récupérer la date courante.
        <synopsis>
void PGTYPESdate_today(date *d);
        </synopsis>
        Cette fonction reçoit un pointeur vers une variable date
        (<literal>d</literal>) qu'il positionne à la date courante.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatefmtasc">
      <term><function>PGTYPESdate_fmt_asc</function></term>
      <listitem>
       <para>
        Convertir une variable de type date vers sa représentation textuelle en
        utilisant un masque de formatage.
        <synopsis>
int PGTYPESdate_fmt_asc(date dDate, char *fmtstring, char *outbuf);
        </synopsis>
        La fonction reçoit la date à convertir (<literal>dDate</literal>), le masque
        de formatage (<literal>fmtstring</literal>) et la chaîne qui contiendra la
        représentation textuelle de la date (<literal>outbuf</literal>).
       </para>
       <para>
        En cas de succès, 0 est retourné, et une valeur négative si une erreur s'est produite.
       </para>
       <para>
        Les littéraux suivants sont les spécificateurs de champs que vous pouvez utiliser:
        <itemizedlist>
         <listitem>
          <para>
           <literal>dd</literal> - Le numéro du jour du mois.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>mm</literal> - Le numéro du mois de l'année.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>yy</literal> - Le numéro de l'année comme nombre à deux chiffres.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>yyyy</literal> - Le numéro de l'année comme nombre à quatre chiffres.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ddd</literal> - Le nom du jour (abrégé).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>mmm</literal> - Le nom du mois (abrégé).
          </para>
         </listitem>
        </itemizedlist>
        Tout autre caractère est recopié tel quel dans la chaîne de sortie.
       </para>
       <para>
        <xref linkend="ecpg-pgtypesdate-fmt-asc-example-table"/> indique quelques formats possibles. Cela
        vous donnera une idée de comment utiliser cette fonction. Toutes les lignes de sortie
        reposent sur la même date&nbsp;: Le 23 novembre 1959.
       </para>
       <table id="ecpg-pgtypesdate-fmt-asc-example-table">
        <title>Formats d'Entrée Valides pour <function>PGTYPESdate_fmt_asc</function></title>
        <tgroup cols="2">
         <thead>
          <row>
           <entry>Format</entry>
           <entry>Résultat</entry>
          </row>
         </thead>
         <tbody>
          <row>
           <entry><literal>mmddyy</literal></entry>
           <entry><literal>112359</literal></entry>
          </row>
          <row>
           <entry><literal>ddmmyy</literal></entry>
           <entry><literal>231159</literal></entry>
          </row>
          <row>
           <entry><literal>yymmdd</literal></entry>
           <entry><literal>591123</literal></entry>
          </row>
          <row>
           <entry><literal>yy/mm/dd</literal></entry>
           <entry><literal>59/11/23</literal></entry>
          </row>
          <row>
           <entry><literal>yy mm dd</literal></entry>
           <entry><literal>59 11 23</literal></entry>
          </row>
          <row>
           <entry><literal>yy.mm.dd</literal></entry>
           <entry><literal>59.11.23</literal></entry>
          </row>
          <row>
           <entry><literal>.mm.yyyy.dd.</literal></entry>
           <entry><literal>.11.1959.23.</literal></entry>
          </row>
          <row>
           <entry><literal>mmm. dd, yyyy</literal></entry>
           <entry><literal>Nov. 23, 1959</literal></entry>
          </row>
          <row>
           <entry><literal>mmm dd yyyy</literal></entry>
           <entry><literal>Nov 23 1959</literal></entry>
          </row>
          <row>
           <entry><literal>yyyy dd mm</literal></entry>
           <entry><literal>1959 23 11</literal></entry>
          </row>
          <row>
           <entry><literal>ddd, mmm. dd, yyyy</literal></entry>
           <entry><literal>Mon, Nov. 23, 1959</literal></entry>
          </row>
          <row>
           <entry><literal>(ddd) mmm. dd, yyyy</literal></entry>
           <entry><literal>(Mon) Nov. 23, 1959</literal></entry>
          </row>
         </tbody>
        </tgroup>
       </table>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatedefmtasc">
      <term><function>PGTYPESdate_defmt_asc</function></term>
      <listitem>
       <para>
        Utiliser un masque de formatage pour convertir une chaîne de caractère
        <type>char*</type> en une valeur de type date.
        <synopsis>
int PGTYPESdate_defmt_asc(date *d, char *fmt, char *str);
        </synopsis>
        <!-- same description as rdefmtdate -->
        La fonction reçoit un pointeur vers la valeur de date qui devrait stocker
        le résultat de l'opération (<literal>d</literal>), le masque de formatage à
        utiliser pour traiter la date (<literal>fmt</literal>) et la chaîne de
        caractères char* C contenant la représentation textuelle de la date
        (<literal>str</literal>). La représentation textuelle doit correspondre
        au masque de formatage. Toutefois, vous n'avez pas besoin d'avoir une
        correspondance exacte entre la chaîne et le masque de formatage. La fonction
        n'analyse qu'en ordre séquentiel et cherche les litéraux <literal>yy</literal>
        ou <literal>yyyy</literal> qui indiquent la position de l'année,
        <literal>mm</literal> qui indique la position du mois et
        <literal>dd</literal> qui indique la position du jour.
       </para>
       <para>
        <xref linkend="ecpg-rdefmtdate-example-table"/> indique quelques formats possibles. Cela vous
        donnera une idée de comment utiliser cette fonction
       </para>
       <table id="ecpg-rdefmtdate-example-table">
        <title>Formats d'Entrée Valides pour <function>rdefmtdate</function></title>
        <tgroup cols="3">
         <thead>
          <row>
           <entry>Format</entry>
           <entry>Chaîne</entry>
           <entry>Résultat</entry>
          </row>
         </thead>
         <tbody>
          <row>
           <entry><literal>ddmmyy</literal></entry>
           <entry><literal>21-2-54</literal></entry>
           <entry><literal>1954-02-21</literal></entry>
          </row>
          <row>
           <entry><literal>ddmmyy</literal></entry>
           <entry><literal>2-12-54</literal></entry>
           <entry><literal>1954-12-02</literal></entry>
          </row>
          <row>
           <entry><literal>ddmmyy</literal></entry>
           <entry><literal>20111954</literal></entry>
           <entry><literal>1954-11-20</literal></entry>
          </row>
          <row>
           <entry><literal>ddmmyy</literal></entry>
           <entry><literal>130464</literal></entry>
           <entry><literal>1964-04-13</literal></entry>
          </row>
          <row>
           <entry><literal>mmm.dd.yyyy</literal></entry>
           <entry><literal>MAR-12-1967</literal></entry>
           <entry><literal>1967-03-12</literal></entry>
          </row>
          <row>
           <entry><literal>yy/mm/dd</literal></entry>
           <entry><literal>1954, February 3rd</literal></entry>
           <entry><literal>1954-02-03</literal></entry>
          </row>
          <row>
           <entry><literal>mmm.dd.yyyy</literal></entry>
           <entry><literal>041269</literal></entry>
           <entry><literal>1969-04-12</literal></entry>
          </row>
          <row>
           <entry><literal>yy/mm/dd</literal></entry>
           <entry><literal>In the year 2525, in the month of July, mankind will be alive on the 28th day</literal></entry>
           <entry><literal>2525-07-28</literal></entry>
          </row>
          <row>
           <entry><literal>dd-mm-yy</literal></entry>
           <entry><literal>I said on the 28th of July in the year 2525</literal></entry>
           <entry><literal>2525-07-28</literal></entry>
          </row>
          <row>
           <entry><literal>mmm.dd.yyyy</literal></entry>
           <entry><literal>9/14/58</literal></entry>
           <entry><literal>1958-09-14</literal></entry>
          </row>
          <row>
           <entry><literal>yy/mm/dd</literal></entry>
           <entry><literal>47/03/29</literal></entry>
           <entry><literal>1947-03-29</literal></entry>
          </row>
          <row>
           <entry><literal>mmm.dd.yyyy</literal></entry>
           <entry><literal>oct 28 1975</literal></entry>
           <entry><literal>1975-10-28</literal></entry>
          </row>
          <row>
           <entry><literal>mmddyy</literal></entry>
           <entry><literal>Nov 14th, 1985</literal></entry>
           <entry><literal>1985-11-14</literal></entry>
          </row>
         </tbody>
        </tgroup>
       </table>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-timestamp">
   <title>Le Type timestamp</title>
   <para>
    Le type timestamp en C permet à vos programmes de manipuler les données du
    type SQL timestamp. Voyez <xref linkend="datatype-datetime"/> pour le type
    équivalent dans le serveur <productname>PostgreSQL</productname>.
   </para>
   <para>
    Les fonctions suivantes peuvent être utilisées pour manipuler le type
    timestamp&nbsp;:
    <variablelist>
     <varlistentry id="pgtypestimestampfromasc">
      <term><function>PGTYPEStimestamp_from_asc</function></term>
      <listitem>
       <para>
        Transformer un timestamp de sa représentation texte vers une variable
        timestamp.
        <synopsis>
timestamp PGTYPEStimestamp_from_asc(char *str, char **endptr);
        </synopsis>
        La fonction reçoit la chaîne à analyser (<literal>str</literal>) et un
        pointeur vers un char* C (<literal>endptr</literal>).
        À l'heure actuelle ECPG traite toujours intégralement la
        chaîne, et ne supporte donc pas encore l'adresse du premier
        caractère invalide dans <literal>*endptr</literal>. Vous pouvez
        positionner <literal>endptr</literal> à NULL sans risque.
       </para>
       <para>
        La fonction retourne le timestamp identifié en cas de réussite. En
        cas d'erreur, <literal>PGTYPESInvalidTimestamp</literal> est retourné
        et <varname>error</varname> est positionné à <literal>PGTYPES_TS_BAD_TIMESTAMP</literal>.
        Voyez <xref linkend="pgtypesinvalidtimestamp"/> pour des informations importantes
        sur cette valeur.
       </para>
       <para>
        En général, la chaîne d'entrée peut contenir toute combinaison d'une
        spécification de date autorisée, un caractère espace et une spécification
        de temps (time) autorisée. Notez que les timezones ne sont pas supportées par
        ECPG. Il peut les analyzer mais n'applique aucune calcul comme le ferait le
        serveur <productname>PostgreSQL</productname> par exemple. Les spécificateurs
        de timezone sont ignorées en silence.
       </para>
       <para>
        <xref linkend="ecpg-pgtypestimestamp-from-asc-example-table"/> contient quelques exemples pour les chaînes d'entrée.
       </para>
       <table id="ecpg-pgtypestimestamp-from-asc-example-table">
        <title>Formats d'Entrée Valide pour <function>PGTYPEStimestamp_from_asc</function></title>
        <tgroup cols="2">
         <thead>
          <row>
           <entry>Entrée</entry>
           <entry>Résultat</entry>
          </row>
         </thead>
         <tbody>
          <row>
           <entry><literal>1999-01-08 04:05:06</literal></entry>
           <entry><literal>1999-01-08 04:05:06</literal></entry>
          </row>
          <row>
           <entry><literal>January 8 04:05:06 1999 PST</literal></entry>
           <entry><literal>1999-01-08 04:05:06</literal></entry>
          </row>
          <row>
           <entry><literal>1999-Jan-08 04:05:06.789-8</literal></entry>
           <entry><literal>1999-01-08 04:05:06.789 (time zone specifier ignored)</literal></entry>
          </row>
          <row>
           <entry><literal>J2451187 04:05-08:00</literal></entry>
           <entry><literal>1999-01-08 04:05:00 (time zone specifier ignored)</literal></entry>
          </row>
         </tbody>
        </tgroup>
       </table>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestamptoasc">
      <term><function>PGTYPEStimestamp_to_asc</function></term>
      <listitem>
       <para>
        Convertit une date vers une chaîne char* C.
        <synopsis>
char *PGTYPEStimestamp_to_asc(timestamp tstamp);
        </synopsis>
        Cette fonction reçoit le timestamp <literal>tstamp</literal> comme
        seul argument et retourne une chaîne allouée qui contient la
        représentation textuelle du timestamp.
        Le résultat doit être libéré avec <function>PGTYPESchar_free()</function>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestampcurrent">
      <term><function>PGTYPEStimestamp_current</function></term>
      <listitem>
       <para>
        Récupère le timestamp courant.
        <synopsis>
void PGTYPEStimestamp_current(timestamp *ts);
        </synopsis>
        Cette fonction récupère le timestamp courant et le sauve dans la
        variable timestamp vers laquelle <literal>ts</literal> pointe.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestampfmtasc">
      <term><function>PGTYPEStimestamp_fmt_asc</function></term>
      <listitem>
       <para>
        Convertit une variable timestamp vers un char* C en utilisant un
        masque de formatage.
        <synopsis>
int PGTYPEStimestamp_fmt_asc(timestamp *ts, char *output, int str_len, char *fmtstr);
        </synopsis>
        Cette fonction reçoit un pointeur vers le timestamp à convertir comme
        premier argument (<literal>ts</literal>), un pointeur vers le tampon
        de sortie (<literal>output</literal>), la longueur maximale qui a été
        allouée pour le tampon de sortie (<literal>str_len</literal>) et le
        masque de formatage à utiliser pour la conversion (<literal>fmtstr</literal>).
       </para>
       <para>
        En cas de réussite, la fonction retourne 0, et une valeur négative en
        cas d'erreur.
       </para>
       <para>
        Vous pouvez utiliser les spécificateurs de format suivant pour le masque de
        formatage. Les spécificateurs sont les mêmes que ceux utilisés dans la fonction
        <function>strftime</function> de la <productname>libc</productname>. Tout
        spécificateur ne correspondant pas à du formatage sera copié dans le tampon de
        sortie.
        <!-- This is from the FreeBSD man page:
             http://www.freebsd.org/cgi/man.cgi?query=strftime&apropos=0&sektion=3&manpath=FreeBSD+7.0-current&format=html
        -->
        <itemizedlist>
         <listitem>
          <para>
           <literal>%A</literal> - est remplacé par la représentation nationale du nom complet du
           jour de la semaine.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%a</literal> - est remplacé par la représentation nationale du
           nom abrégé du jour de la semaine.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%B</literal> - est remplacé par la représentation nationale du nom complet
           du mois.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%b</literal> - est remplacé par la représentation nationale du
           nom abrégé du mois.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%C</literal> - est remplacé par (année / 100) sous forme de nombre décimal;
           les chiffres seuls sont précédés par un zéro.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%c</literal> - est remplacé par la représentation nationale de time et date.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%D</literal> - est équivalent à
           <literal>%m/%d/%y</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%d</literal> - est remplacé par le jour du mois sous forme de
           nombre décimal (01&ndash;31).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%E*</literal> <literal>%O*</literal> -  Extensions locales POSIX
           Les séquences:
           <literal>%Ec</literal>
           <literal>%EC</literal>
           <literal>%Ex</literal>
           <literal>%EX</literal>
           <literal>%Ey</literal>
           <literal>%EY</literal>
           <literal>%Od</literal>
           <literal>%Oe</literal>
           <literal>%OH</literal>
           <literal>%OI</literal>
           <literal>%Om</literal>
           <literal>%OM</literal>
           <literal>%OS</literal>
           <literal>%Ou</literal>
           <literal>%OU</literal>
           <literal>%OV</literal>
           <literal>%Ow</literal>
           <literal>%OW</literal>
           <literal>%Oy</literal>
           sont supposées fournir des représentations alternatives.
          </para>
          <para>
           De plus, <literal>%OB</literal> est implémenté pour représenter
           des noms de mois alternatifs (utilisé seul, sans jour mentionné).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%e</literal> - est remplacé par le jour du mois comme nombre décimal
           (1&ndash;31)&nbsp;; les chiffres seuls sont précédés par un blanc.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%F</literal> - est équivalent à <literal>%Y-%m-%d</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%G</literal> - est remplacé par une année comme nombre décimal avec le siècle.
           L'année courante est celle qui contient la plus grande partie de la semaine
           (Lundi est le premier jour de la semaine).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%g</literal> - est remplacé par la même année que dans
           <literal>%G</literal>, mais comme un nombre décimal sans le siècle.
           (00&ndash;99).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%H</literal> - est remplacé par l'heure (horloge sur 24 heures) comme
           nombre décimal (00&ndash;23).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%h</literal> - comme <literal>%b</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%I</literal> - est remplacé par l'heure (horloge sur 12 heures) comme
           nombre décimal(01&ndash;12).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%j</literal> - est remplacé par le jour de l'année comme
           nombre décimal (001&ndash;366).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%k</literal> - est remplacé par l'heure (horloge sur 24 heures) comme
           nombre décimal (0&ndash;23)&nbsp;; les chiffres seuls sont précédés par un blanc.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%l</literal> - est remplacé par l'heure (horloge sur 12 heures) comme
           nombre décimal (1&ndash;12)&nbsp;; les chiffres seuls sont précédés par un blanc.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%M</literal> - est remplacé par la minute comme
           nombre décimal (00&ndash;59).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%m</literal> - est remplacé par le mois comme nombre décimal
           (01&ndash;12).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%n</literal> - est remplacé par un caractère nouvelle ligne.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%O*</literal> - comme <literal>%E*</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%p</literal> - est remplacé par la représentation nationale de
           <quote>ante meridiem</quote> ou <quote>post meridiem</quote> suivant la valeur appropriée.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%R</literal> - est équivalent à <literal>%H:%M</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%r</literal> - est équivalent à <literal>%I:%M:%S
            %p</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%S</literal> - est remplacé par la seconde comme
           nombre décimal (00&ndash;60).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%s</literal> - est remplacé par le nombre de secondes depuis
           l'Epoch, en UTC.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%T</literal> - est équivalent à <literal>%H:%M:%S</literal>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%t</literal> - est remplacé par une tabulation.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%U</literal> - est remplacé par le numéro de la semaine dans
           l'année (Dimanche est le premier jour de la semaine) comme nombre décimal
           (00&ndash;53).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%u</literal> - est remplacé par le jour de la semaine (Lundi comme
           premier jour de la semaine) comme nombre décimal (1&ndash;7).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%V</literal> - est remplacé par le numéro de la semaine dans l'année
           (Lundi est le premier jour de la semaine) comme nombre décimal (01&ndash;53).
           Si l'année contenant le 1er Janvier a 4 jours ou plus dans la nouvelle année,
           alors c'est la semaine numéro 1; sinon, c'est la dernière semaine de l'année
           précédente, et la semaine suivante est la semaine 1.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%v</literal> - est équivalent à
           <literal>%e-%b-%Y</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%W</literal> - est remplacé par le numéro de la semaine dans l'année
           (Lundi est le premier jour de la semaine) comme nombre décimal (00&ndash;53).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%w</literal> - est remplacé par le jour de la semaine (Dimanche comme
           premier jour de la semaine) comme nombre décimal (0&ndash;6).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%X</literal> - est remplacé par la représentation nationale
           du temps.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%x</literal> - est remplacé par la représentation nationale
           de la date.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%Y</literal> - est remplacé par l'année avec le siècle comme un
           nombre décimal.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%y</literal> - est remplacé par l'année sans le siècle comme
           un nombre décimal (00&ndash;99).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%Z</literal> - est remplacé par le nom de la zone de temps.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%z</literal> - est remplacé par le décalage de la zone de temps
           par rapport à UTC; un signe plus initial signifie à l'est d'UTC, un signe
           moins à l'ouest d'UTC, les heures et les minutes suivent avec deux chiffres
           chacun et aucun délimiteur entre eux (forme commune pour les entêtes de
           date spécifiés par la RFC 822).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%+</literal> - est remplacé par la représentation nationale de
           la date et du temps.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%-*</literal> - extension de la libc GNU. Ne pas faire de padding (bourrage)
           sur les sorties numériques.
          </para>
         </listitem>
         <listitem>
          <para>
           $_* - extension de la libc GNU.    Spécifie explicitement l'espace pour le padding.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%0*</literal> - extension de la libc GNU. Spécifie explicitement le zéro
           pour le padding.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>%%</literal> - est remplacé par <literal>%</literal>.
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestampsub">
      <term><function>PGTYPEStimestamp_sub</function></term>
      <listitem>
       <para>
        Soustraire un timestamp d'un autre et sauver le résultat dans
        une variable de type interval.
        <synopsis>
int PGTYPEStimestamp_sub(timestamp *ts1, timestamp *ts2, interval *iv);
        </synopsis>
        Cette fonction soustrait la variable timestamp vers laquelle pointe
        <literal>ts2</literal> de la variable de timestamp vers laquelle
        <literal>ts1</literal> pointe, et stockera le résultat dans la variable interval
        vers laquelle <literal>iv</literal> pointe.
       </para>
       <para>
        En cas de succès, la fonction retourne 0, et une valeur négative
        si une erreur s'est produite.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestampdefmtasc">
      <term><function>PGTYPEStimestamp_defmt_asc</function></term>
      <listitem>
       <para>
        Convertit une valeur timestamp de sa représentation textuelle
        en utilisant un masque de formatage.
        <synopsis>
int PGTYPEStimestamp_defmt_asc(char *str, char *fmt, timestamp *d);
        </synopsis>
        Cette fonction reçoit la représentation textuelle d'un timestamp dans la
        variable <literal>str</literal> ainsi que le masque de formatage à utiliser
        dans la variable <literal>fmt</literal>. Le résultat sera stocké dans la variable
        vers laquelle <literal>d</literal> pointe.
       </para>
       <para>
        Si le masque de formatage <literal>fmt</literal> est NULL, la fonction se rabattra
        vers le masque de formatage par défaut qui est <literal>%Y-%m-%d
         %H:%M:%S</literal>.
       </para>
       <para>
        C'est la fonction inverse de <xref
        linkend="pgtypestimestampfmtasc"/>. Voyez la documentation à cet endroit
        pour découvrir toutes les entrées possibles de masque de formatage.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestampaddinterval">
      <term><function>PGTYPEStimestamp_add_interval</function></term>
      <listitem>
       <para>
        Ajouter une variable interval à une variable timestamp.
        <synopsis>
int PGTYPEStimestamp_add_interval(timestamp *tin, interval *span, timestamp *tout);
        </synopsis>
        Cette fonction reçoit un pointeur vers une variable timestamp <literal>tin</literal>
        et un pointeur vers une variable interval <literal>span</literal>. Elle ajoute
        l'intervalle au timestapm et sauve le timestamp résultat dans la variable vers
        laquelle <literal>tout</literal> pointe.
       </para>
       <para>
        En cas de succès, la fonction retourne 0, et une valeur négative
        si une erreur s'est produite.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestampsubinterval">
      <term><function>PGTYPEStimestamp_sub_interval</function></term>
      <listitem>
       <para>
        Soustrait une variable interval d'une variable timestamp.
        <synopsis>
int PGTYPEStimestamp_sub_interval(timestamp *tin, interval *span, timestamp *tout);
        </synopsis>
        Cette fonction soustrait la variable interval vers laquelle <literal>span</literal>
        pointe de la variable timestamp vers laquelle <literal>tin</literal> pointe
        et sauve le résultat dans la variable vers laquelle <literal>tout</literal> pointe.
       </para>
       <para>
        En cas de succès, la fonction retourne 0, et une valeur négative
        si une erreur s'est produite.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-interval">
   <title>Le Type interval</title>
   <para>
    Le type interval en C permet à vos programmes de manipuler des données
    du type SQL interval. Voyez <xref linkend="datatype-datetime"/> pour le
    type équivalent dans le serveur <productname>PostgreSQL</productname>.
   </para>
   <para>
    Les fonctions suivantes peuvent être utilisées pour travailler avec le type interval&nbsp;:
    <variablelist>

     <varlistentry id="pgtypesintervalnew">
      <term><function>PGTYPESinterval_new</function></term>
      <listitem>
       <para>
        Retourne un pointeur vers une variable interval nouvellement allouée.
        <synopsis>
interval *PGTYPESinterval_new(void);
        </synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesintervalfree">
      <term><function>PGTYPESinterval_free</function></term>
      <listitem>
       <para>
        Libère la mémoire d'une variable interval précédemment allouée.
        <synopsis>
void PGTYPESinterval_free(interval *intvl);
        </synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesintervalfromasc">
      <term><function>PGTYPESinterval_from_asc</function></term>
      <listitem>
       <para>
        Convertit un interval à partir de sa représentation textuelle.
        <synopsis>
interval *PGTYPESinterval_from_asc(char *str, char **endptr);
        </synopsis>
        Cette fonction traite la chaîne d'entrée <literal>str</literal> et retourne
        un pointeur vers une variable interval allouée.

        À l'heure actuelle ECPG traite toujours intégralement la
        chaîne, et ne supporte donc pas encore l'adresse du premier
        caractère invalide dans <literal>*endptr</literal>. Vous pouvez
        positionner <literal>endptr</literal> à NULL sans risque.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesintervaltoasc">
      <term><function>PGTYPESinterval_to_asc</function></term>
      <listitem>
       <para>
        Convertit une variable de type interval vers sa représentation textuelle.
        <synopsis>
char *PGTYPESinterval_to_asc(interval *span);
        </synopsis>
        Cette fonction convertit la variable interval vers laquelle <literal>span</literal>
        pointe vers un char* C. La sortie ressemble à cet exemple&nbsp;:
        <literal>@ 1 day 12 hours 59 mins 10 secs</literal>.
        Le résultat doit être libéré avec <function>PGTYPESchar_free()</function>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesintervalcopy">
      <term><function>PGTYPESinterval_copy</function></term>
      <listitem>
       <para>
        Copie une variable de type interval.
        <synopsis>
int PGTYPESinterval_copy(interval *intvlsrc, interval *intvldest);
        </synopsis>
        Cette fonction copie la variable interval vers laquelle <literal>intvlsrc</literal>
        pointe vers la variable vers laquelle <literal>intvldest</literal> pointe. Notez
        que vous devrez allouer la mémoire pour la variable destination auparavant.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-decimal">
   <title>Le Type decimal</title>
   <para>
    Le type decimal est similaire au type numeric. Toutefois il est limité à
    une précision maximale de 30 chiffres significatifs. À l'opposeé du type
    numeric que ne peut être créé que sur le tas, le type decimal peur être
    créé soit sur la pile soit sur le tas (au moyen des
    fonctions <function>PGTYPESdecimal_new</function> et
    <function>PGTYPESdecimal_free</function>).
    Il y a beaucoup d'autres fonctions qui manipulent le type decimal dans le
    mode de compatibilité <productname>Informix</productname> décrit dans
    <xref linkend="ecpg-informix-compat"/>.
   </para>
   <para>
    Les fonctions suivantes peut être utilisée pour travailler avec le type decimal
    et ne sont pas seulement contenues dans la librairie <literal>libcompat</literal>.
    <variablelist>
     <varlistentry>
      <term><function>PGTYPESdecimal_new</function></term>
      <listitem>
       <para>
        Demande un pointeur vers une variable decimal nouvellement allouée.
        <synopsis>
decimal *PGTYPESdecimal_new(void);
        </synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESdecimal_free</function></term>
      <listitem>
       <para>
        Libère un type decimal, libère toute sa mémoire.
        <synopsis>
void PGTYPESdecimal_free(decimal *var);
        </synopsis>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-errno">
   <title>errno Valeurs de pgtypeslib</title>
   <para>
    <variablelist>
     <varlistentry>
      <term><literal>PGTYPES_NUM_BAD_NUMERIC</literal></term>
      <listitem>
       <para>
        Un argument devrait contenir une variable numeric (ou pointer vers
        une variable numeric) mais en fait sa représentation en mémoire était
        invalide.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_OVERFLOW</literal></term>
      <listitem>
       <para>
        Un dépassement de capacité s'est produit. Comme le type numeric peut
        travailler avec une précision quasi-arbitraire, convertir une variable
        numeric vers d'autres types peut causer un dépassement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_UNDERFLOW</literal></term>
      <listitem>
       <para>
        Un soupassement de capacité s'est produit. Comme le type numeric peut
        travailler avec une précision quasi-arbitraire, convertir une variable
        numeric vers d'autres types peut causer un soupassement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_DIVIDE_ZERO</literal></term>
      <listitem>
       <para>
        Il y a eu une tentative de division par zéro.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DATE</literal></term>
      <listitem>
       <para>
        Une chaîne de date invalide a été passée à la fonction
        <function>PGTYPESdate_from_asc</function>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_EARGS</literal></term>
      <listitem>
       <para>
        Des arguments invalides ont été passés à la fonction
        <function>PGTYPESdate_defmt_asc</function>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOSHORTDATE</literal></term>
      <listitem>
       <para>
        Un indicateur invalide a été trouvé dans la chaîne d'entrée
        par la fonction <function>PGTYPESdate_defmt_asc</function>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_INTVL_BAD_INTERVAL</literal></term>
      <listitem>
       <para>
        Une chaîne invalide d'interval a été passée à la fonction
        <function>PGTYPESinterval_from_asc</function>, ou une valeur
        invalide d'interval a été passée à la fonction
        <function>PGTYPESinterval_to_asc</function>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOTDMY</literal></term>
      <listitem>
       <para>
        Il n'a pas été possible de trouver la correspondance dans
        l'assignement jour/mois/année de la fonction
        <function>PGTYPESdate_defmt_asc</function>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DAY</literal></term>
      <listitem>
       <para>
        Un jour de mois invalide a été trouvé par la fonction
        <function>PGTYPESdate_defmt_asc</function>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_MONTH</literal></term>
      <listitem>
       <para>
        Une valeur de mois invalide a été trouvée par la fonction
        <function>PGTYPESdate_defmt_asc</function>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_BAD_TIMESTAMP</literal></term>
      <listitem>
       <para>
        Une chaîne de timestamp invalide a été passée à la fonction
        <function>PGTYPEStimestamp_from_asc</function>,
        ou une valeur invalide de timestamp a été passée à la fonction
        <function>PGTYPEStimestamp_to_asc</function>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_ERR_EINFTIME</literal></term>
      <listitem>
       <para>
        Une valeur infinie de timestamp a été rencontrée dans un context
        qui ne peut pas la manipuler.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-constants">
   <title>Constantes Spéciales de pgtypeslib</title>
   <para>
    <variablelist>
     <varlistentry id="pgtypesinvalidtimestamp">
      <term><literal>PGTYPESInvalidTimestamp</literal></term>
      <listitem>
       <para>
        Une valeur de timestamp représentant un timestamp invalide. C'est retourné
        par la fonction <function>PGTYPEStimestamp_from_asc</function> en cas d'erreur
        de conversion.
        Notez qu'en raison de la représentation interne du type de données <type>timestamp</type>,
        <literal>PGTYPESInvalidTimestamp</literal> est aussi un timestamp valide en même temps.
        Il est positionné à <literal>1899-12-31 23:59:59</literal>. Afin de detecter les erreurs,
        assurez vous que votre application teste non seulement <literal>PGTYPESInvalidTimestamp</literal>
        mais aussi <literal>error != 0</literal> après chaque appel à
        <function>PGTYPEStimestamp_from_asc</function>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-descriptors">
  <title>Utiliser les Zones de Descripteur</title>

  <para>
   Une zone de descripteur SQL (SQL Descriptor Area ou SQLDA)
   est une méthode plus sophistiquée pour traiter le
   résultat d'un ordre <command>SELECT</command>, <command>FETCH</command> ou
   <command>DESCRIBE</command>. Une zone de descripteur SQL regroupe les données
   d'un enregistrement avec ses métadonnées dans une seule structure. Ces
   métadonnées sont particulièrement utiles quand on exécute des ordres SQL
   dynamiques, où_la nature des colonnes résultat ne sont pas forcément
   connues à l'avance. PostgreSQL fournit deux façons d'utiliser des Zones
   de Descripteur: les Zones de Descripteur SQL nommée et les structures C SQLDA.
  </para>

  <sect2 id="ecpg-named-descriptors">
   <title>Zones de Descripteur SQL nommées</title>

   <para>
    Une zone descripteur SQL nommé est composée d'un entête, qui contient
    des données concernant l'ensemble du descripteur, et une ou plusieurs
    zones de descriptions d'objets, qui en fait décrivent chaque colonne
    de l'enregistrement résultat.
   </para>

   <para>
    Avant que vous puissiez utiliser une zone de descripteur SQL, vous devez
    en allouer une&nbsp;:
    <programlisting>
EXEC SQL ALLOCATE DESCRIPTOR <replaceable>identifiant</replaceable>;
    </programlisting>
    L'identifiant sert de <quote>nom de variable</quote> de la zone de
    descripteur. <!-- La portée de descripteur est QUOI?. -->
    Quand vous n'avez plus besoin du descripteur, vous devriez le désallouer:
    <programlisting>
EXEC SQL DEALLOCATE DESCRIPTOR <replaceable>identifiant</replaceable>;
    </programlisting>
   </para>

   <para>
    Pour utiliser une zone de descripteur, spécifiez le comme cible de
    stockage dans une clause <literal>INTO</literal>, à la place
    d'une liste de variables hôtes&nbsp;:
    <programlisting>
EXEC SQL FETCH NEXT FROM mycursor INTO SQL DESCRIPTOR mydesc;
    </programlisting>
    Si le jeu de données retourné est vide, la zone de descripteur contiendra
    tout de même les métadonnées de la requête, c'est à dire les noms des
    champs.
   </para>

   <para>
    Pour les requêtes préparées mais pas encore exécutées, l'ordre
    <command>DESCRIBE</command> peut être utilisé pour récupérer les
    métadonnées du résultat&nbsp;:
    <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char *sql_stmt = "SELECT * FROM table1";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
    </programlisting>
   </para>

   <para>
    Avant PostgreSQL 9.0, le mot clé <literal>SQL</literal> était optionnel,
    par conséquent utiliser <literal>DESCRIPTOR</literal> et
    <literal>SQL DESCRIPTOR</literal> produisaent les mêmes zones de
    descripteur SQL. C'est maintenant obligatoire, et oublier le mot clé
    <literal>SQL</literal> produit des zones de descripteurs SQLDA,
    voyez <xref linkend="ecpg-sqlda-descriptors"/>.
   </para>

   <para>
    Dans les ordres <command>DESCRIBE</command> et <command>FETCH</command>,
    les mots-clés <literal>INTO</literal> et <literal>USING</literal> peuvent
    être utilisés de façon similaire&nbsp;: ils produisent le jeu de données
    et les métadonnées de la zone de descripteur.
   </para>

   <para>
    Maintenant, comment récupérer les données de la zone de descripteur&nbsp;?
    Vous pouvez voir la zone de descripteur comme une structure avec des
    champs nommés. Pour récupérer la valeur d'un champ à partir de l'entête
    et le stocker dans une variable hôte, utilisez la commande suivante&nbsp;:
    <programlisting>
EXEC SQL GET DESCRIPTOR <replaceable>name</replaceable> :<replaceable>hostvar</replaceable> = <replaceable>field</replaceable>;
    </programlisting>
    À l'heure actuelle, il n'y a qu'un seul champ d'entête défini:
    <replaceable>COUNT</replaceable>, qui dit combien il y a de zones
    de descripteurs d'objets (c'est à dire, combien de colonnes il y a dans le résultat).
    La variable hôte doit être de type integer. Pour récupérer un champ de la
    zone de description d'objet, utilisez la commande suivante&nbsp;:
    <programlisting>
EXEC SQL GET DESCRIPTOR <replaceable>name</replaceable> VALUE <replaceable>num</replaceable> :<replaceable>hostvar</replaceable> = <replaceable>field</replaceable>;
    </programlisting>
    <replaceable>num</replaceable> peut être un integer literal, ou une
    variable hôte contenant un integer. Les champs possibles sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term><literal>CARDINALITY</literal> (integer)</term>
      <listitem>
       <para>
        nombres d'enregistrements dans le résultat
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATA</literal></term>
      <listitem>
       <para>
        objet de donnée proprement dit (par conséquent, le type de données de
        ce champ dépend de la requête)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATETIME_INTERVAL_CODE</literal> (integer)</term>
      <listitem>
       <para>
        Quand <literal>TYPE</literal> est <literal>9</literal>,
        <literal>DATETIME_INTERVAL_CODE</literal> aura une valeur de
        <literal>1</literal> pour <literal>DATE</literal>,
        <literal>2</literal> pour <literal>TIME</literal>,
        <literal>3</literal> pour <literal>TIMESTAMP</literal>,
        <literal>4</literal> pour <literal>TIME WITH TIME ZONE</literal>, or
        <literal>5</literal> pour <literal>TIMESTAMP WITH TIME ZONE</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATETIME_INTERVAL_PRECISION</literal> (integer)</term>
      <listitem>
       <para>
        non implémenté
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>INDICATOR</literal> (integer)</term>
      <listitem>
       <para>
        l'indicateur (indique une valeur null ou une troncature de valeur)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>KEY_MEMBER</literal> (integer)</term>
      <listitem>
       <para>
        non implémenté
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>LENGTH</literal> (integer)</term>
      <listitem>
       <para>
        longueur de la donnée en caractères
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NAME</literal> (string)</term>
      <listitem>
       <para>
        nom de la colonne
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NULLABLE</literal> (integer)</term>
      <listitem>
       <para>
        non implémenté
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>OCTET_LENGTH</literal> (integer)</term>
      <listitem>
       <para>
        longueur de la représentation caractère de la donnée en octets
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PRECISION</literal> (integer)</term>
      <listitem>
       <para>
        précision (pour les types <type>numeric</type>)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RETURNED_LENGTH</literal> (integer)</term>
      <listitem>
       <para>
        longueur de la donnée en caractères
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RETURNED_OCTET_LENGTH</literal> (integer)</term>
      <listitem>
       <para>
        longueur de la représentation caractère de la donnée en octets
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SCALE</literal> (integer)</term>
      <listitem>
       <para>
        échelle (pour le type <type>numeric</type>)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>TYPE</literal> (integer)</term>
      <listitem>
       <para>
        code numérique du type de données de la colonne
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Dans les ordres <command>EXECUTE</command>, <command>DECLARE</command>
    and <command>OPEN</command>, l'effet des mots clés
    <literal>INTO</literal> and <literal>USING</literal>
    est différent. Une zone de descripteur peut aussi être
    construite manuellement pour fournir les paramètres d'entré
    pour une requête ou un curseur et <literal>USING SQL DESCRIPTOR
     <replaceable>name</replaceable></literal> est la façon de passer
    les paramètres d'entrée à une requête paramétrisée. L'ordre
    pour construire une zone de descripteur SQL est ci-dessous:
    <programlisting>
EXEC SQL SET DESCRIPTOR <replaceable>name</replaceable> VALUE <replaceable>num</replaceable> <replaceable>field</replaceable> = :<replaceable>hostvar</replaceable>;
    </programlisting>
   </para>

   <para>
    PostgreSQL supporte la récupération de plus d'un enregistrement
    dans un ordre <command>FETCH</command> et les variables hôtes dans
    ce cas doivent être des tableaux. Par exemple&nbsp;:
    <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int id[5];
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH 5 FROM mycursor INTO SQL DESCRIPTOR mydesc;

EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :id = DATA;
    </programlisting>

   </para>

  </sect2>

  <sect2 id="ecpg-sqlda-descriptors">
   <title>Zones de Descripteurs SQLDA</title>

   <para>
    Une zone de descripteur SQLDA est une structure C qui peut aussi être utilisé
    pour récupérer les résultats et les métadonnées d'une requête. Une structure
    stocke un enregistrement du jeu de résultat.
    <programlisting>
EXEC SQL include sqlda.h;
sqlda_t         *mysqlda;

EXEC SQL FETCH 3 FROM mycursor INTO DESCRIPTOR mysqlda;
    </programlisting>
    Netez que le mot clé <literal>SQL</literal> est omis. Les paragraphes qui parlent
    des cas d'utilisation de <literal>INTO</literal> and <literal>USING</literal>
    dans <xref linkend="ecpg-named-descriptors"/> s'appliquent aussi ici, avec un point
    supplémentaire. Dans un ordre <command>DESCRIBE</command> le mot clé
    <literal>DESCRIPTOR</literal> peut être complètement omis si le mot clé
    <literal>INTO</literal> est utilisé&nbsp;:
    <programlisting>
EXEC SQL DESCRIBE prepared_statement INTO mysqlda;
    </programlisting>
   </para>

   <procedure>
    <para>
     Le déroulement général d'un programme qui utilise des SQLDA est:
    </para>
    <step><simpara>Préparer une requête, et déclarer un curseur pour l'utiliser.</simpara></step>
    <step><simpara>Déclarer une SQLDA pour les lignes de résultat.</simpara></step>
    <step><simpara>Déclarer une SQLDA pour les paramètres d'entrées, et les initialiser (allocation mémoire, positionnement des paramètres).</simpara></step>
    <step><simpara>Ouvrir un curseur avec la SQLDA d'entrée.</simpara></step>
    <step><simpara>Récupérer les enregistrements du curseur, et les stocker dans une SQLDA de sortie.</simpara></step>
    <step><simpara>Lire les valeurs de la SQLDA de sortie vers les variables hôtes (avec conversion si nécessaire).</simpara></step>
    <step><simpara>Fermer le curseur.</simpara></step>
    <step><simpara>Libérer la zone mémoire allouée pour la SQLDA d'entrée.</simpara></step>
   </procedure>

   <sect3>
    <title>Structure de Données SQLDA</title>

    <para>
     Les SQLDA utilisent 3 types de structures de données:
     <type>sqlda_t</type>, <type>sqlvar_t</type>,
     et <type>struct sqlname</type>.
    </para>

    <tip>
     <para>
      La structure de la SQLDA de PostgreSQL est similaire à celle
      de DB2 Universal Database d'IBM, des informations techniques
      sur la SQLDA de DB2 peuvent donc aider à mieux comprendre celle de
      PostgreSQL.
     </para>
    </tip>

    <sect4 id="ecpg-sqlda-sqlda">
     <title>Structure sqlda_t</title>

     <para>
      Le type de structure <type>sqlda_t</type> est le type de la SQLDA
      proprement dit. Il contient un enregistrement. Et deux ou plus
      <type>sqlda_t</type> peuvent être connectées par une liste
      chaînée par le pointeur du champ <structfield>desc_next</structfield>,
      représentant par conséquent une collection ordonnée d'enregistrements.
      Par conséquent, quand deux enregistrements ou plus sont récupérés,
      l'application peut les lire en suivant le pointeur
      <structfield>desc_next</structfield> dans chaque nœud <type>sqlda_t</type>.
     </para>

     <para>
      La définition de <type>sqlda_t</type> est&nbsp;:
      <programlisting>
struct sqlda_struct
{
    char            sqldaid[8];
    long            sqldabc;
    short           sqln;
    short           sqld;
    struct sqlda_struct *desc_next;
    struct sqlvar_struct sqlvar[1];
};

typedef struct sqlda_struct sqlda_t;
      </programlisting>

      La signification des champs est&nbsp;:

      <variablelist>
       <varlistentry>
        <term><literal>sqldaid</literal></term>
        <listitem>
         <para>
          Elle contient la chaîne littérale <literal>"SQLDA  "</literal>.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>sqldabc</literal></term>
        <listitem>
         <para>
          Il contient la taille de l'espace alloué en octets.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>sqln</literal></term>
        <listitem>
         <para>
          Il content le nombre de paramètres d'entrée pour une requête paramétrique, dans
          le cas où il est passé à un ordre <command>OPEN</command>, <command>DECLARE</command> ou
          <command>EXECUTE</command> utilisant le mot clé <literal>USING</literal>.
          Dans le cas où il sert de sortie à un ordre <command>SELECT</command>,
          <command>EXECUTE</command> ou <command>FETCH</command> statements,
          sa valeur est la même que celle du champ <literal>sqld</literal>.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>sqld</literal></term>
        <listitem>
         <para>
          Il contient le nombre de champs du résultat.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>desc_next</literal></term>
        <listitem>
         <para>
          Si la requête retourne plus d'un enregistrement, plusieurs structures
          SQLDA chaînées sont retournées, et <literal>desc_next</literal> contient
          un pointeur vers l'élément suivant (enregistrement) de la liste.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>sqlvar</literal></term>
        <listitem>
         <para>
          C'est le tableau des colonnes du résultat.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </sect4>

    <sect4 id="ecpg-sqlda-sqlvar">
     <title>Structure de sqlvar_t</title>

     <para>
      Le type structure <type>sqlvar_t</type> contient la valeur
      d'une colonne et les métadonnées telles que son type et sa longueur.
      La définition du type est&nbsp;:

      <programlisting>
struct sqlvar_struct
{
    short          sqltype;
    short          sqllen;
    char          *sqldata;
    short         *sqlind;
    struct sqlname sqlname;
};

typedef struct sqlvar_struct sqlvar_t;
      </programlisting>

      La signification des champs est&nbsp;:

      <variablelist>
       <varlistentry>
        <term><literal>sqltype</literal></term>
        <listitem>
         <para>
          Contient l'identifiant de type du champ. Pour les valeurs,
          voyez <literal>enum ECPGttype</literal> dans <literal> ecpgtype.h</literal>.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>sqllen</literal></term>
        <listitem>
         <para>
          Contient la longueur binaire du champ, par exemple 4 octets pour
          <type>ECPGt_int</type>.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>sqldata</literal></term>
        <listitem>
         <para>
          Pointe vers la donnée. Le format de la donnée est décrit
          dans <xref linkend="ecpg-variables-type-mapping"/>.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>sqlind</literal></term>
        <listitem>
         <para>
          Pointe vers l'indicateur de nullité. 0 signifie non nul,
          -1 signifie nul.
          null.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>sqlname</literal></term>
        <listitem>
         <para>
          Le nom du champ.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </sect4>

    <sect4 id="ecpg-sqlda-sqlname">
     <title>Structure struct sqlname</title>

     <para>
      Une structure <type>struct sqlname</type> contient un nom de colonne.
      Il est utilisé comme membre de la structure <type>sqlvar_t</type>.
      La définition de la structure est&nbsp;:
      <programlisting>
#define NAMEDATALEN 64

struct sqlname
{
        short           length;
        char            data[NAMEDATALEN];
};
      </programlisting>
      La signification des champs est&nbsp;:
      <variablelist>
       <varlistentry>
        <term><literal>length</literal></term>
        <listitem>
         <para>
          Contient la longueur du nom du champ.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>data</literal></term>
        <listitem>
         <para>
          Contient le nom du champ proprement dit.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </sect4>
   </sect3>

   <sect3 id="ecpg-sqlda-output">
    <title>Récupérer un jeu de données au moyen d'une SQLDA</title>

    <procedure>
     <para>
      Les étapes générales pour récupérer un jeu de données au moyen
      d'une SQLDA sont&nbsp;:
     </para>
     <step><simpara>Déclarer une structure <type>sqlda_t</type> pour recevoir le jeu de données.</simpara></step>
     <step><simpara>Exécuter des commandes <command>FETCH</command>/<command>EXECUTE</command>/<command>DESCRIBE</command> pour traiter une requête en spécifiant la SQLDA déclarée.</simpara></step>
     <step><simpara>Vérifier le nombre d'enregistrements dans le résultat en inspectant <structfield>sqln</structfield>, un membre de la structure <type>sqlda_t</type>.</simpara></step>
     <step><simpara>Récupérer les valeurs de chaque colonne des membres <literal>sqlvar[0]</literal>, <literal>sqlvar[1]</literal>, etc., de la structure <type>sqlda_t</type>.</simpara></step>
     <step><simpara>Aller à l'enregistrement suivant (<type>sqlda_t</type> structure) en suivant le pointeur <structfield>desc_next</structfield>, un membre de la structure <type>sqlda_t</type>.</simpara></step>
     <step><simpara>Répéter l'étape ci-dessus au besoin.</simpara></step>
    </procedure>

    <para>
     Voici un exemple de récupération d'un jeu de résultats au moyen d'une SQLDA.
    </para>

    <para>
     Tout d'abord, déclarer une structure <type>sqlda_t</type> pour recevoir le jeu de résultats.
     <programlisting>
sqlda_t *sqlda1;
     </programlisting>
    </para>

    <para>
     Puis, spécifier la SQLDA dans une commande. Voici
     un exemple avec une commande <command>FETCH</command>.
     <programlisting>
EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
     </programlisting>
    </para>

    <para>
     Faire une boucle suivant la liste chaînée pour récupérer les
     enregistrements.
     <programlisting>
sqlda_t *cur_sqlda;

for (cur_sqlda = sqlda1;
     cur_sqlda != NULL;
     cur_sqlda = cur_sqlda->desc_next)
{
    ...
}
     </programlisting>
    </para>

    <para>
     Dans la boucle, faire une autre boucle pour récupérer chaque colonne
     de données (<type>sqlvar_t</type>) de l'enregistrement.
     <programlisting>
for (i = 0; i &lt; cur_sqlda->sqld; i++)
{
    sqlvar_t v = cur_sqlda->sqlvar[i];
    char *sqldata = v.sqldata;
    short sqllen  = v.sqllen;
    ...
}
     </programlisting>
    </para>

    <para>
     Pour récupérer une valeur de colonne, vérifiez la valeur de
     <structfield>sqltype</structfield>. Puis, suivant le type de la colonne,
     basculez sur une façon appropriée de copier les données du champ
     <structfield>sqlvar</structfield> vers une variable hôte.
     <programlisting><![CDATA[
char var_buf[1024];

switch (v.sqltype)
{
    case ECPGt_char:
        memset(&var_buf, 0, sizeof(var_buf));
        memcpy(&var_buf, sqldata, (sizeof(var_buf) <= sqllen ? sizeof(var_buf) - 1 : sqllen));
        break;

    case ECPGt_int: /* integer */
        memcpy(&intval, sqldata, sqllen);
        snprintf(var_buf, sizeof(var_buf), "%d", intval);
        break;

    ...
}
]]></programlisting>
    </para>
   </sect3>

   <sect3 id="ecpg-sqlda-input">
    <title>Passer des Paramètres de Requête en Utilisant une SQLDA</title>

    <procedure>
     <para>
      La méthode générale pour utiliser une SQLDA pour passer des paramètres
      d'entrée à une requête préparée sont&nbsp;:
     </para>
     <step><simpara>Créer une requête préparée (prepared statement)</simpara></step>
     <step><simpara>Déclarer une structure sqlda_t comme SQLDA d'entrée.</simpara></step>
     <step><simpara>Allouer une zone mémorie (comme structure sqlda_t) pour la SQLDA d'entrée.</simpara></step>
     <step><simpara>Positionner (copier) les valeurs d'entrée dans la mémoire allouée.</simpara></step>
     <step><simpara>Ouvrir un curseur en spécifiant la SQLDA d'entrée.</simpara></step>
    </procedure>

    <para>
     Voici un exemple.
    </para>

    <para>
     D'abord, créer une requête préparée.
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char query[1024] = "SELECT d.oid, * FROM pg_database d, pg_stat_database s WHERE d.oid = s.datid AND (d.datname = ? OR d.oid = ?)";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :query;
     </programlisting>
    </para>

    <para>
     Puis, allouer de la mémoire pour une SQLDA, et positionner
     le nombre de paramètres d'entrée dans <structfield>sqln</structfield>,
     une variable membre de la structure&lt;sqlda_t&gt;. Quand deux paramètres
     d'entrée ou plus sont requis pour la requête préparée, l'application
     doit allouer de la mémoire supplémentaire qui est calculée par
     (nombre de paramètres -1) * sizeof&lt;sqlvar_t&gt;. Les exemples affichés
     ici allouent de l'espace mémoire pour deux paramètres d'entrée.
     <programlisting>
sqlda_t *sqlda2;

sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));

sqlda2->sqln = 2; /* nombre de variables d'entrée */
     </programlisting>
    </para>

    <para>
     Après l'allocation mémoire, stocker les valeurs des paramètres dans
     le tableau<literal>sqlvar[]</literal>. (C'est le même tableau que
     celui qui est utilisé quand la SQLDA reçoit un jeu de résultats.)
     Dans cet exemple, les paramètres d'entrée sont
     <literal>"postgres"</literal>, de type chaîne, et <literal>1</literal>,
     de type integer.
     <programlisting>
sqlda2->sqlvar[0].sqltype = ECPGt_char;
sqlda2->sqlvar[0].sqldata = "postgres";
sqlda2->sqlvar[0].sqllen  = 8;

int intval = 1;
sqlda2->sqlvar[1].sqltype = ECPGt_int;
sqlda2->sqlvar[1].sqldata = (char *) &amp;intval;
sqlda2->sqlvar[1].sqllen  = sizeof(intval);
     </programlisting>
    </para>

    <para>
     En ouvrant un curseur et en spécifiant la SQLDA qui a été
     positionné auparavant, les paramètres d'entrée sont passés
     à la requête préparée.
     <programlisting>
EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
     </programlisting>
    </para>

    <para>
     Et pour finir, après avoir utilisé les SQLDAs d'entrée, la mémoire
     allouée doit être libérée explicitement, contrairement aux SQLDAs
     utilisé pour recevoir le résultat d'une requête.
     <programlisting>
free(sqlda2);
     </programlisting>
    </para>
   </sect3>

   <sect3 id="ecpg-sqlda-example">
    <title>Une application de Démonstration Utilisant SQLDA</title>

    <para>
     Voici un programme de démonstration, qui montre comment récupérer
     des statistiques d'accès des bases, spécifiées par les paramètres
     d'entrée, dans les catalogues systèmes.
    </para>

    <para>
     Cette application joint deux tables systèmes, pg_database et
     pg_stat_database sur l'oid de la base, et récupère et affiche
     aussi les statistiques des bases qui sont spécifiées par
     deux paramètres d'entrées (une base <literal>postgres</literal> et
     un OID <literal>1</literal>).
    </para>

    <para>
     Tout d'abord, déclarer une SQLDA pour l'entrée et une SQLDA pour la sortie.
     <programlisting>
EXEC SQL include sqlda.h;

sqlda_t *sqlda1; /* un descripteur de sortie */
sqlda_t *sqlda2; /* un descripteur d'entrée  */
     </programlisting>
    </para>

    <para>
     Puis, se connecter à la base, préparer une requête, et déclarer un
     curseur pour la requête préparée.
     <programlisting>
int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
     </programlisting>
    </para>

    <para>
     Puis, mettre des valeurs dans la SQLDA d'entrée pour les
     paramètres d'entrée. Allouer de la mémoire pour la SQL d'entrée,
     et positionner le nombre de paramètres d'entrée dans
     <literal>sqln</literal>. Stocker le type, la valeur et la longueur
     de la valeur dans <literal>sqltype</literal>, <literal>sqldata</literal>
     et <literal>sqllen</literal> dans la structure <literal>sqlvar</literal>.

     <programlisting>
    /* Créer une structure SQLDA pour les paramètres d'entrée. */
    sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
    sqlda2->sqln = 2; /* number of input variables */

    sqlda2->sqlvar[0].sqltype = ECPGt_char;
    sqlda2->sqlvar[0].sqldata = "postgres";
    sqlda2->sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2->sqlvar[1].sqltype = ECPGt_int;
    sqlda2->sqlvar[1].sqldata = (char *)&amp;intval;
    sqlda2->sqlvar[1].sqllen  = sizeof(intval);
     </programlisting>
    </para>

    <para>
     Après avoir positionné la SQLDA d'entrée, ouvrir un curseur
     avec la SQLDA d'entrée.

     <programlisting>
    /* Ouvrir un curseur avec les paramètres d'entrée. */
    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
     </programlisting>
    </para>

    <para>
     Récupérer les enregistrements dans la SQLDA de sortie à partir
     du curseur ouvert. (En général, il faut appeler <command>FETCH</command>
     de façon répétée dans la boucle, pour récupérer tous les enregistrements
     du jeu de données.)
     <programlisting>
    while (1)
    {
        sqlda_t *cur_sqlda;

        /* Assigner le descripteur au curseur  */
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
     </programlisting>
    </para>

    <para>
     Ensuite, récupérer les enregistrements du FETCH de la SQLDA,
     en suivant la liste chaînée de la structure <type>sqlda_t</type>.
     <programlisting>
    for (cur_sqlda = sqlda1 ;
         cur_sqlda != NULL ;
         cur_sqlda = cur_sqlda->desc_next)
    {
        ...
     </programlisting>
    </para>

    <para>
     Lire chaque colonne dans le premier enregistrement. Le nombre de colonnes
     est stocké dans <structfield>sqld</structfield>, les données réelles
     de la première colonne sont stockées dans <literal>sqlvar[0]</literal>,
     tous deux membres de la structure<type>sqlda_t</type>.

     <programlisting>
        /* Afficher toutes les colonnes d'un enregistrement. */
        for (i = 0; i &lt; sqlda1-&gt;sqld; i++)
        {
            sqlvar_t v = sqlda1->sqlvar[i];
            char *sqldata = v.sqldata;
            short sqllen  = v.sqllen;

            strncpy(name_buf, v.sqlname.data, v.sqlname.length);
            name_buf[v.sqlname.length] = '\0';
     </programlisting>
    </para>

    <para>
     Maintenant, la donnée de la colonne est stockée dans la variable
     <literal>v</literal>.
     Copier toutes les données dans les variables host, en inspectant
     <literal>v.sqltype</literal> pour connaître le type de la colonne.
     <programlisting><![CDATA[
            switch (v.sqltype) {
                int intval;
                double doubleval;
                unsigned long long int longlongval;

                case ECPGt_char:
                    memset(&var_buf, 0, sizeof(var_buf));
                    memcpy(&var_buf, sqldata, (sizeof(var_buf) <= sqllen ? sizeof(var_buf)-1 : sqllen));
                    break;

                case ECPGt_int: /* integer */
                    memcpy(&intval, sqldata, sqllen);
                    snprintf(var_buf, sizeof(var_buf), "%d", intval);
                    break;

                ...

                default:
                    ...
            }

            printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
        }
]]></programlisting>
    </para>

    <para>
     Fermer le curseur après avoir traité tous les enregistrements, et
     se déconnecter de la base de données.
<programlisting>
    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;
     </programlisting>
    </para>

    <para>
     Le programme dans son entier est visible dans
     <xref linkend="ecpg-sqlda-example-example"/>.
    </para>

    <example id="ecpg-sqlda-example-example">
     <title>Programme de Démonstration SQLDA</title>
     <programlisting>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;stdlib.h>
#include &lt;stdio.h>
#include &lt;unistd.h>

EXEC SQL include sqlda.h;

sqlda_t *sqlda1; /* descripteur pour la sortie */
sqlda_t *sqlda2; /* descripteur pour l'entrée */

EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";

    int intval;
    unsigned long long int longlongval;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO uptimedb AS con1 USER uptime;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;

    /* Créer une structure SQLDB pour let paramètres d'entrée */
    sqlda2 = (sqlda_t *)malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
    sqlda2->sqln = 2; /* a number of input variables */

    sqlda2->sqlvar[0].sqltype = ECPGt_char;
    sqlda2->sqlvar[0].sqldata = "postgres";
    sqlda2->sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2->sqlvar[1].sqltype = ECPGt_int;
    sqlda2->sqlvar[1].sqldata = (char *) &amp;intval;
    sqlda2->sqlvar[1].sqllen  = sizeof(intval);

    /* Ouvrir un curseur avec les paramètres d'entrée. */
    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;

    while (1)
    {
        sqlda_t *cur_sqlda;

        /* Assigner le descripteur au curseur  */
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;

        for (cur_sqlda = sqlda1 ;
             cur_sqlda != NULL ;
             cur_sqlda = cur_sqlda->desc_next)
        {
            int i;
            char name_buf[1024];
            char var_buf[1024];

            /* Afficher toutes les colonnes d'un enregistrement. */
            for (i=0 ; i&lt;cur_sqlda->sqld ; i++)
            {
                sqlvar_t v = cur_sqlda->sqlvar[i];
                char *sqldata = v.sqldata;
                short sqllen  = v.sqllen;

                strncpy(name_buf, v.sqlname.data, v.sqlname.length);
                name_buf[v.sqlname.length] = '\0';

                switch (v.sqltype)
                {
                    case ECPGt_char:
                        memset(&amp;var_buf, 0, sizeof(var_buf));
                        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf)&lt;=sqllen ? sizeof(var_buf)-1 : sqllen) );
                        break;

                    case ECPGt_int: /* integer */
                        memcpy(&amp;intval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%d", intval);
                        break;

                    case ECPGt_long_long: /* bigint */
                        memcpy(&amp;longlongval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%lld", longlongval);
                        break;

                    default:
                    {
                        int i;
                        memset(var_buf, 0, sizeof(var_buf));
                        for (i = 0; i &lt; sqllen; i++)
                        {
                            char tmpbuf[16];
                            snprintf(tmpbuf, sizeof(tmpbuf), "%02x ", (unsigned char) sqldata[i]);
                            strncat(var_buf, tmpbuf, sizeof(var_buf));
                        }
                    }
                        break;
                }

                printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
            }

            printf("\n");
        }
    }

    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;

    return 0;
}
     </programlisting>

     <para>
      L'exemple suivant devrait ressembler à quelque chose comme
      ce qui suit (des nombres seront différents).
     </para>

     <screen>
oid = 1 (type: 1)
datname = template1 (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = t (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl = {=c/uptime,uptime=CTc/uptime} (type: 1)
datid = 1 (type: 1)
datname = template1 (type: 1)
numbackends = 0 (type: 5)
xact_commit = 113606 (type: 9)
xact_rollback = 0 (type: 9)
blks_read = 130 (type: 9)
blks_hit = 7341714 (type: 9)
tup_returned = 38262679 (type: 9)
tup_fetched = 1836281 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)

oid = 11511 (type: 1)
datname = postgres (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = f (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl =  (type: 1)
datid = 11511 (type: 1)
datname = postgres (type: 1)
numbackends = 0 (type: 5)
xact_commit = 221069 (type: 9)
xact_rollback = 18 (type: 9)
blks_read = 1176 (type: 9)
blks_hit = 13943750 (type: 9)
tup_returned = 77410091 (type: 9)
tup_fetched = 3253694 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)
     </screen>
    </example>
   </sect3>
  </sect2>
 </sect1>

 <sect1 id="ecpg-errors">
  <title>Gestion des Erreurs</title>

  <para>
   Cett section explique comment vous pouvez traiter des conditions
   d'exception et des avertissements dans un programme SQL embarqué.
   Il y a deux fonctionnalités non-exclusives pour cela.

   <itemizedlist>
    <listitem>
     <simpara>
      Des fonctions de rappel (callbacks) peuvent être configurées
      pour traiter les conditions d'avertissement et d'erreur en
      utilisant la commande <literal>WHENEVER</literal>.
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      Des informations détaillées à propos de l'erreur ou de l'avertissement
      peuvent être obtenues de la variable <varname>sqlca</varname>.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>

  <sect2 id="ecpg-whenever">
   <title>Mettre en Place des Callbacks</title>

   <para>
    Une méthode simple pour intercepter des erreurs et des avertissements
    est de paramétrer des actions spécifiques à exécuter dès qu'une condition
    particulière se produit. En général&nbsp;:
    <programlisting>
EXEC SQL WHENEVER <replaceable>condition</replaceable> <replaceable>action</replaceable>;
    </programlisting>
   </para>

   <para>
    <replaceable>condition</replaceable> peut être un des éléments suivants&nbsp;:

    <variablelist>
     <varlistentry>
      <term><literal>SQLERROR</literal></term>
      <listitem>
       <para>
        L'action spécifiée est appelée dès qu'une erreur se produit durant
        l'exécution d'un ordre SQL.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLWARNING</literal></term>
      <listitem>
       <para>
        L'action spécifiée est appelée dès qu'un avertissement se produit
        durant l'exécution d'un ordre SQL.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NOT FOUND</literal></term>
      <listitem>
       <para>
        L'action spécifiée est appelée dès qu'un ordre SQL
        récupère ou affecte zéro enregistrement. (Cette condition n'est
        pas une erreur, mais vous pourriez être intéressé par un traitement
        spécial dans ce cas).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    <replaceable>action</replaceable> peut être un des éléments suivants:

    <variablelist>
     <varlistentry>
      <term><literal>CONTINUE</literal></term>
      <listitem>
       <para>
        Cela signifie en fait que la condition est ignorée. C'est le
        comportement par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>GOTO <replaceable>label</replaceable></literal></term>
      <term><literal>GO TO <replaceable>label</replaceable></literal></term>
      <listitem>
       <para>
        Sauter au label spécifié (en utilisant un ordre <literal>goto</literal>
        C).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLPRINT</literal></term>
      <listitem>
       <para>
        Affiche un message vers la sortie standard. C'est utile pour
        des programmes simples ou durant le prototypage. Le détail du
        message ne peut pas être configuré.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>STOP</literal></term>
      <listitem>
       <para>
        Appelle <literal>exit(1)</literal>, ce qui mettra fin au
        programme.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DO BREAK</literal></term>
      <listitem>
       <para>
        Exécuter l'ordre C <literal>break</literal>. Cela ne devrait
        être utilisé que dans des boucles ou des ordres <literal>switch</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DO CONTINUE</literal></term>
      <listitem>
       <para>
        Exécute l'instruction C <literal>continue</literal>. Ceci doit
        seulement être utilisé dans les instructions de boucle. Son exécution
        fait que le flot de contrôle est renvoyé au sommet de la boucle.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CALL <replaceable>name</replaceable> (<replaceable>args</replaceable>)</literal></term>
      <term><literal>DO <replaceable>name</replaceable> (<replaceable>args</replaceable>)</literal></term>
      <listitem>
       <para>
        Appelle la fonction C spécifiée avec les arguments spécifiés. (Son
        utilisation est différente des instructions <literal>CALL</literal> et
        <literal>DO</literal> dans la grammaire habituelle de PostgreSQL.)
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    Le standard SQL ne fournit que les actions
    <literal>CONTINUE</literal> et <literal>GOTO</literal> (and
    <literal>GO TO</literal>).
   </para>

   <para>
    Voici un exemple de ce que pourriez vouloir utiliser dans un programme
    simple. Il affichera un message quand un avertissement se produit et
    tuera le programme quand une erreur se produit:
    <programlisting>
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLERROR STOP;
    </programlisting>
   </para>

   <para>
    L'ordre <literal>EXEC SQL WHENEVER</literal> est une directive
    du préprocesseur SQL, pas un ordre SQL. L'action sur erreur ou
    avertissement qu'il met en place s'applique à tous les ordres SQL
    embarqués qui apparaissent après le point où le gestionnaire est
    mis en place, sauf si une autre action a été mise en place pour la
    même condition entre le premier <literal>EXEC SQL WHENEVER</literal>
    et l'ordre SQL entrainant la condition, quel que soit le déroulement
    du programme C. Par conséquent, aucun des extraits des deux
    programmes C suivants n'aura l'effet escompté&nbsp;:
    <programlisting>
/*
 * WRONG
 */
int main(int argc, char *argv[])
{
    ...
    if (verbose) {
        EXEC SQL WHENEVER SQLWARNING SQLPRINT;
    }
    ...
    EXEC SQL SELECT ...;
    ...
}
    </programlisting>

    <programlisting>
/*
 * WRONG
 */
int main(int argc, char *argv[])
{
    ...
    set_error_handler();
    ...
    EXEC SQL SELECT ...;
    ...
}

static void set_error_handler(void)
{
    EXEC SQL WHENEVER SQLERROR STOP;
}
    </programlisting>
   </para>
  </sect2>

  <sect2 id="ecpg-sqlca">
   <title>sqlca</title>

   <para>
    Pour une gestion plus approfondie des erreurs, l'interface SQL
    embarquée fournit une variable globale appelée <varname>sqlca</varname>
    (SQL communication area, ou zone de communication SQL)
    qui a la structure suivante&nbsp;:
    <programlisting>
struct
{
    char sqlcaid[8];
    long sqlabc;
    long sqlcode;
    struct
    {
        int sqlerrml;
        char sqlerrmc[SQLERRMC_LEN];
    } sqlerrm;
    char sqlerrp[8];
    long sqlerrd[6];
    char sqlwarn[8];
    char sqlstate[5];
} sqlca;
    </programlisting>
    (Dans un programme multi-threadé, chaque thread récupère automatiquement
    sa propre copie de <varname>sqlca</varname>. Ce fonctionnement est similaire
    à celui de la variable C globale <varname>errno</varname>.)
    <varname>errno</varname>.)
   </para>

   <para>
    <varname>sqlca</varname> couvre à la fois les avertissements
    et les erreurs. Si plusieurs avertissements ou erreurs se produisent
    durant l'exécution d'un ordre, alors <varname>sqlca</varname>
    ne contiendra d'informations que sur le dernier.
   </para>

   <para>
    Si aucune erreur ne s'est produite durant le dernier ordre
    <acronym>SQL</acronym>,
    <literal>sqlca.sqlcode</literal> vaudra 0
    <literal>sqlca.sqlstate</literal> vaudra
    <literal>"00000"</literal>.  Si un avertissement ou erreur s'est produit, alors
    <literal>sqlca.sqlcode</literal> sera négatif
    <literal>sqlca.sqlstate</literal> sera différent de
    <literal>"00000"</literal>.  Une valeur positive de
    <literal>sqlca.sqlcode</literal> indique une condition sans gravité
    comme le fait que la dernière requête ait retourné zéro enregistrements.
    <literal>sqlcode</literal> et <literal>sqlstate</literal> sont deux
    différents schémas de code d'erreur&nbsp;; les détails sont fournis plus bas.
   </para>

   <para>
    Si le dernier ordre SQL a réussi, alors
    <literal>sqlca.sqlerrd[1]</literal> contient l'OID de la ligne traitée,
    si applicable, et
    <literal>sqlca.sqlerrd[2]</literal> contient le nombre d'enregistrements
    traités ou retournés, si applicable à la commande.
   </para>

   <para>
    En cas d'erreur ou d'avertissement,
    <literal>sqlca.sqlerrm.sqlerrmc</literal> contiendra une chaine
    qui décrira une erreur. Le champ
    <literal>sqlca.sqlerrm.sqlerrml</literal> contiendra la longueur
    du message d'erreur qui est stocké dans
    <literal>sqlca.sqlerrm.sqlerrmc</literal> (le résultat de
    <function>strlen()</function>, par réellement intéressant pour
    un programmeur C). Notez que certains messages sont trop longs pour
    tenir dans le tableau de taille fixe <literal>sqlerrmc</literal>;
    ils seront tronqués.
   </para>

   <para>
    En cas d'avertissement, <literal>sqlca.sqlwarn[2]</literal> est positionné
    à <literal>W</literal>. (Dans tous les autres cas, il est positionné
    à quelque chose de différent de <literal>W</literal>.) Si
    <literal>sqlca.sqlwarn[1]</literal> est positionné à
    <literal>W</literal>, alors une valeur a été tronquée quand elle a été
    stockée dans une variable hôte. <literal>sqlca.sqlwarn[0]</literal> est
    positionné à <literal>W</literal> si n'importe lequel des autres éléments
    est positionné pour indiquer un avertissement.
   </para>

   <para>
    Les champs <structfield>sqlcaid</structfield>,
    <structfield>sqlabc</structfield>,
    <structfield>sqlerrp</structfield>, et les éléments restants de
    <structfield>sqlerrd</structfield> et
    <structfield>sqlwarn</structfield> ne contiennent pour le moment
    aucune information utile.
   </para>

   <para>
    La structure <varname>sqlca</varname> n'est pas définie dans le
    standard SQL, mais est implémentée dans plusieurs autres systèmes
    de base de données. Les définitions sont similaires dans leur
    principe, mais si vous voulez écrire des applications portables,
    vous devriez étudier les différentes implémentations de façon
    attentive.
   </para>

   <para>
    Voici un exemple qui combine l'utilisation de <literal>WHENEVER</literal>
    et de <varname>sqlca</varname>, en affichant le contenu de
    <varname>sqlca</varname> quand une erreur se produit. Cela pourrait être
    utile pour déboguer ou prototyper des applications, avant d'installer
    un gestionnaire d'erreurs plus <quote>user-friendly</quote>.

    <programlisting>
EXEC SQL WHENEVER SQLERROR CALL print_sqlca();

void
print_sqlca()
{
    fprintf(stderr, "==== sqlca ====\n");
    fprintf(stderr, "sqlcode: %ld\n", sqlca.sqlcode);
    fprintf(stderr, "sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
    fprintf(stderr, "sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
    fprintf(stderr, "sqlerrd: %ld %ld %ld %ld %ld %ld\n", sqlca.sqlerrd[0],sqlca.sqlerrd[1],sqlca.sqlerrd[2],
                                                          sqlca.sqlerrd[3],sqlca.sqlerrd[4],sqlca.sqlerrd[5]);
    fprintf(stderr, "sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0], sqlca.sqlwarn[1], sqlca.sqlwarn[2],
                                                          sqlca.sqlwarn[3], sqlca.sqlwarn[4], sqlca.sqlwarn[5],
                                                          sqlca.sqlwarn[6], sqlca.sqlwarn[7]);
    fprintf(stderr, "sqlstate: %5s\n", sqlca.sqlstate);
    fprintf(stderr, "===============\n");
}
    </programlisting>

    Le résultat pourrait ressembler à ce qui suit (ici une erreur
    due à un nom de table mal saisi)&nbsp;:

    <screen>
==== sqlca ====
sqlcode: -400
sqlerrm.sqlerrml: 49
sqlerrm.sqlerrmc: relation "pg_databasep" does not exist on line 38
sqlerrd: 0 0 0 0 0 0
sqlwarn: 0 0 0 0 0 0 0 0
sqlstate: 42P01
===============
    </screen>
   </para>
  </sect2>

  <sect2 id="ecpg-sqlstate-sqlcode">
   <title><literal>SQLSTATE</literal> contre <literal>SQLCODE</literal></title>

   <para>
    Les champs <literal>sqlca.sqlstate</literal> et
    <literal>sqlca.sqlcode</literal> sont deux schémas qui fournissent
    des codes d'erreurs. Les deux sont dérivés du standard SQL, mais
    <literal>SQLCODE</literal> a été marqué comme déprécié dans l'édition
    SQL-92 du standard, et a été supprimé des éditions suivantes.
    Par conséquent, les nouvelles applications ont fortement intérêt
    à utiliser <literal>SQLSTATE</literal>.
   </para>

   <para>
    <literal>SQLSTATE</literal> est un tableau de cinq caractères.
    Les cinq caractères contiennent des chiffres ou des lettres en
    majuscule qui représentent les codes des différentes conditions
    d'erreur et d'avertissement.
    <literal>SQLSTATE</literal> a un schéma hiérarchique: les deux premiers
    caractères indiquent la classe générique de la condition, les trois
    caractères suivants indiquent la sous-classe de la condition générique.
    Un état de succès est indiqué par le code <literal>00000</literal>.
    Les codes <literal>SQLSTATE</literal> sont pour la plupart définis
    dans le standard SQL. Le serveur <productname>PostgreSQL</productname>
    supporte nativement les codes d'erreur <literal>SQLSTATE</literal>;
    par conséquent, un haut niveau de cohérence entre toutes les applications
    peut être obtenu en utilisant ce schéma de codes d'erreur.
    Pour plus d'informations voyez <xref linkend="errcodes-appendix"/>.
   </para>

   <para>
    <literal>SQLCODE</literal>, le schéma d'erreurs déprécié, est un
    entier simple. Une valeur de 0 indique le succès, une valeur
    positive indique un succès avec des informations supplémentaires,
    une valeur négative indique une erreur. Le standard SQL ne définit
    que la valeur positive +100, qui indique que l'ordre précédent a
    retourné ou affecté zéro enregistrement, et aucune valeur négative
    spécifique. par conséquent, ce schéma ne fournit qu'une piètre
    portabilité et n'a pas de hiérarchie de code d'erreurs. Historiquement,
    le processeur de SQL embarqué de <productname>PostgreSQL</productname>
    a assigné des valeurs spécifiques de <literal>SQLCODE</literal> pour
    son utilisation propre, qui sont listées ci-dessous avec leur valeur
    numérique et leur nom symbolique. Rappelez vous qu'ils ne sont pas
    portables vers d'autres implémentations SQL.
    Pour simplifier le portage des applications vers le schéma
    <literal>SQLSTATE</literal>, les valeurs <literal>SQLSTATE</literal>
    sont aussi listées. Il n'y a pas, toutefois, de correspondance un à un
    ou un à plusieurs entre les deux schémas (c'est en fait du plusieurs
    à plusieurs), vous devriez donc consulter la liste globale
    <literal>SQLSTATE</literal> dans <xref linkend="errcodes-appendix"/>
    au cas par cas.
   </para>

   <para>
    Voici les valeurs de <literal>SQLCODE</literal> assignées&nbsp;:

    <variablelist>
     <varlistentry>
      <term>0 (<symbol>ECPG_NO_ERROR</symbol>)</term>
      <listitem>
       <para>
        Indique pas d'erreur. (SQLSTATE 00000)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>100 (<symbol>ECPG_NOT_FOUND</symbol>)</term>
      <listitem>
       <para>
        C'est un état sans danger indiquant que la dernière commande
        a récupéré ou traité zéro enregistrements, ou que vous êtes
        au bout du curseur.  (SQLSTATE 02000)
       </para>

       <para>
        Quand vous bouclez sur un curseur, vous pourriez utiliser ce code
        comme façon de détecter quand arrêter la boucle, comme ceci:
        <programlisting>
while (1)
{
    EXEC SQL FETCH ... ;
    if (sqlca.sqlcode == ECPG_NOT_FOUND)
        break;
}
        </programlisting>
        Mais <literal>WHENEVER NOT FOUND DO BREAK</literal> fait en
        fait cela en interne, il n'y a donc habituellement aucun avantage
        à écrire ceci de façon explicite.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-12 (<symbol>ECPG_OUT_OF_MEMORY</symbol>)</term>
      <listitem>
       <para>
        Indique que votre mémoire virtuelle est épuisée. La valeur
        numérique est définie comme <literal>-ENOMEM</literal>.
        (SQLSTATE YE001)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-200 (<symbol>ECPG_UNSUPPORTED</symbol>)</term>
      <listitem>
       <para>
        Indique que le préprocesseur a généré quelque chose que la
        librairie ne connait pas. Peut-être êtes vous en train
        d'utiliser des versions incompatibles du préprocesseur et
        de la librairie. (SQLSTATE YE002)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-201 (<symbol>ECPG_TOO_MANY_ARGUMENTS</symbol>)</term>
      <listitem>
       <para>
        Cela signifie que la commande a spécifié plus de variables
        hôte que la commande n'en attendait. (SQLSTATE 07001 or 07002)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-202 (<symbol>ECPG_TOO_FEW_ARGUMENTS</symbol>)</term>
      <listitem>
       <para>
        Cela signifie que la commande a spécifié moins de variables
        hôtes que la commande n'en attendait.  (SQLSTATE 07001 or 07002)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-203 (<symbol>ECPG_TOO_MANY_MATCHES</symbol>)</term>
      <listitem>
       <para>
        Cela signifie que la requête a retourné pluiseurs enregistrements
        mais que l'ordre n'était capable d'en recevoir qu'un (par exemple
        parce que les variables spécifiées ne sont pas des tableaux.
        (SQLSTATE 21000)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-204 (<symbol>ECPG_INT_FORMAT</symbol>)</term>
      <listitem>
       <para>
        La variable hôte est du type <type>int</type> et la donnée dans
        la base de données est d'un type différent et contient une valeur
        qui ne peut pas être interprétée comme un <type>int</type>.
        La librairie utilise <function>strtol()</function> pour cette
        conversion.  (SQLSTATE 42804).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-205 (<symbol>ECPG_UINT_FORMAT</symbol>)</term>
      <listitem>
       <para>
        La variable hôte est du type <type>unsigned int</type> et la donnée dans
        la base de données est d'un type différent et contient une valeur
        qui ne peut pas être interprétée comme un <type>unsigned int</type>.
        La librairie utilise <function>strtoul()</function> pour cette
        conversion.  (SQLSTATE 42804).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-206 (<symbol>ECPG_FLOAT_FORMAT</symbol>)</term>
      <listitem>
       <para>
        La variable hôte est du type <type>float</type> et la donnée dans
        la base de données est d'un type différent et contient une valeur
        qui ne peut pas être interprétée comme un <type>float</type>.
        La librairie utilise <function>strtod()</function> pour cette
        conversion.  (SQLSTATE 42804).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-207 (<symbol>ECPG_NUMERIC_FORMAT</symbol>)</term>
      <listitem>
       <para>
        La variable hôte est du type <type>numeric</type> et la donnée dans
        la base de données est d'un type différent et contient une valeur
        qui ne peut pas être interprétée comme un <type>numeric</type>.
        (SQLSTATE 42804).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-208 (<symbol>ECPG_INTERVAL_FORMAT</symbol>)</term>
      <listitem>
       <para>
        La variable hôte est du type <type>interval</type> et la donnée dans
        la base de données est d'un type différent et contient une valeur
        qui ne peut pas être interprétée comme un <type>interval</type>.
        (SQLSTATE 42804).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-209 (<symbol>ECPG_DATE_FORMAT</symbol>)</term>
      <listitem>
       <para>
        La variable hôte est du type <type>date</type> et la donnée dans
        la base de données est d'un type différent et contient une valeur
        qui ne peut pas être interprétée comme un <type>date</type>.
        (SQLSTATE 42804).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-210 (<symbol>ECPG_TIMESTAMP_FORMAT</symbol>)</term>
      <listitem>
       <para>
        La variable hôte est du type <type>timestamp</type> et la donnée dans
        la base de données est d'un type différent et contient une valeur
        qui ne peut pas être interprétée comme un <type>timestamp</type>.
        (SQLSTATE 42804).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-211 (<symbol>ECPG_CONVERT_BOOL</symbol>)</term>
      <listitem>
       <para>
        Cela signifie que la variable hôte est de type <type>bool</type>
        et que la donnée dans la base n'est ni <literal>'t'</literal> ni
        <literal>'f'</literal>.  (SQLSTATE 42804)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-212 (<symbol>ECPG_EMPTY</symbol>)</term>
      <listitem>
       <para>
        L'ordre envoyé au serveur <productname>PostgreSQL</productname>
        était vide.  (Cela ne peut normalement pas arriver dans un
        programme SQL embarqué, cela pourrait donc laisser supposer
        une erreur interne.)  (SQLSTATE YE002)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-213 (<symbol>ECPG_MISSING_INDICATOR</symbol>)</term>
      <listitem>
       <para>
        Une valeur null a été retournée et aucune variable d'indicateur
        null n'a été fournie. (SQLSTATE 22002)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-214 (<symbol>ECPG_NO_ARRAY</symbol>)</term>
      <listitem>
       <para>
        Une variable ordinaire a été utilisée à un endroit qui
        nécessite un tableau. (SQLSTATE 42804)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-215 (<symbol>ECPG_DATA_NOT_ARRAY</symbol>)</term>
      <listitem>
       <para>
        La base a retourné une variable ordinaire à un endroir
        qui nécessite une variable de tableau.  (SQLSTATE 42804)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-216 (<symbol>ECPG_ARRAY_INSERT</symbol>)</term>
      <listitem>
       <para>
        La valeur n'a pas pu être insérée dans le tableau. (SQLSTATE 42804)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-220 (<symbol>ECPG_NO_CONN</symbol>)</term>
      <listitem>
       <para>
        Le programme a essayé d'utiliser une connexion qui n'existe pas.
        (SQLSTATE 08003)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-221 (<symbol>ECPG_NOT_CONN</symbol>)</term>
      <listitem>
       <para>
        Le programme a essayé d'utiliser une connexion qui existe mais
        n'est pas ouverte.  (C'est une erreur interne.)  (SQLSTATE YE002)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-230 (<symbol>ECPG_INVALID_STMT</symbol>)</term>
      <listitem>
       <para>
        L'ordre que vous essayez d'exécuter n'a pas été préparé.
        (SQLSTATE 26000)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-239 (<symbol>ECPG_INFORMIX_DUPLICATE_KEY</symbol>)</term>
      <listitem>
       <para>
        Erreur de clé en doublon, violation de contrainte unique (mode
        de compatibilité Informix).  (SQLSTATE 23505)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-240 (<symbol>ECPG_UNKNOWN_DESCRIPTOR</symbol>)</term>
      <listitem>
       <para>
        Le descripteur spécifié n'a pas été trouvé. L'ordre que vous essayez
        d'utiliser n'a pas été préparé.  (SQLSTATE 33000)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-241 (<symbol>ECPG_INVALID_DESCRIPTOR_INDEX</symbol>)</term>
      <listitem>
       <para>
        L'index de descripteur spécifié était hors de portée.
        (SQLSTATE 07009)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-242 (<symbol>ECPG_UNKNOWN_DESCRIPTOR_ITEM</symbol>)</term>
      <listitem>
       <para>
        Un objet de descripteur invalide a été demandé.  (C'est une erreur
        interne.)  (SQLSTATE YE002)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-243 (<symbol>ECPG_VAR_NOT_NUMERIC</symbol>)</term>
      <listitem>
       <para>
        Durant l'exécution d'un ordre dynamique, la base a retourné
        une valeur numeric et la variable hôte n'était pas numeric.
        (SQLSTATE 07006)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-244 (<symbol>ECPG_VAR_NOT_CHAR</symbol>)</term>
      <listitem>
       <para>
        Durant l'exécution d'un ordre dynamique, la base a retourné
        une valeur non numeric et la variable hôte était numeric.
        (SQLSTATE 07006)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-284 (<symbol>ECPG_INFORMIX_SUBSELECT_NOT_ONE</symbol>)</term>
      <listitem>
       <para>
        Un résultat de la sous-requête n'était pas un enregistrement seul
        (mode de compatibilité Informix).  (SQLSTATE 21000)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-400 (<symbol>ECPG_PGSQL</symbol>)</term>
      <listitem>
       <para>
        Une erreur causée par le serveur <productname>PostgreSQL</productname>.
        Le message contient le message d'erreur du serveur
        <productname>PostgreSQL</productname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-401 (<symbol>ECPG_TRANS</symbol>)</term>
      <listitem>
       <para>
        Le serveur <productname>PostgreSQL</productname> a signalé que
        nous ne pouvons pas démarrer, valider ou annuler la transaction.
        (SQLSTATE 08007)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-402 (<symbol>ECPG_CONNECT</symbol>)</term>
      <listitem>
       <para>
        La tentative de connexion à la base n'a pas réussi.
        (SQLSTATE 08001)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-403 (<symbol>ECPG_DUPLICATE_KEY</symbol>)</term>
      <listitem>
       <para>
        Erreur de clé dupliquée, violation d'une contrainte unique.  (SQLSTATE
        23505)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-404 (<symbol>ECPG_SUBSELECT_NOT_ONE</symbol>)</term>
      <listitem>
       <para>
        Un résultat de la sous-requête n'est pas un enregistrement unique.  (SQLSTATE 21000)
       </para>
      </listitem>
     </varlistentry>

     <!-- currently not used by the code -->
     <!--
    <varlistentry>
     <term>-600 (<symbol>ECPG_WARNING_UNRECOGNIZED</symbol>)</term>
     <listitem>
      <para>
       An unrecognized warning was received from the server.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-601 (<symbol>ECPG_WARNING_QUERY_IGNORED</symbol>)</term>
     <listitem>
      <para>
       Current transaction is aborted.  Queries are ignored until the
       end of the transaction block.
      </para>
     </listitem>
    </varlistentry>
-->

     <varlistentry>
      <term>-602 (<symbol>ECPG_WARNING_UNKNOWN_PORTAL</symbol>)</term>
      <listitem>
       <para>
        Un nom de curseur invalide a été spécifié.  (SQLSTATE 34000)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-603 (<symbol>ECPG_WARNING_IN_TRANSACTION</symbol>)</term>
      <listitem>
       <para>
        Transaction en cours.  (SQLSTATE 25001)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-604 (<symbol>ECPG_WARNING_NO_TRANSACTION</symbol>)</term>
      <listitem>
       <para>
        Il n'y a pas de transaction active (en cours).  (SQLSTATE 25P01)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>-605 (<symbol>ECPG_WARNING_PORTAL_EXISTS</symbol>)</term>
      <listitem>
       <para>
        Un nom de curseur existant a été spécifié.  (SQLSTATE 42P03)
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-preproc">
  <title>Directives de Préprocesseur</title>

  <para>
   Plusieurs directives de préprocesseur sont disponibles, qui modifient
   comment le préprocesseur <command>ecpg</command> analyse et traite
   un fichier.
  </para>

  <sect2 id="ecpg-include">
   <title>Inclure des Fichiers</title>

   <para>
    Pour inclure un fichier externe dans votre fichier SQL embarqué, utilisez&nbsp;:
    <programlisting>
EXEC SQL INCLUDE <replaceable>filename</replaceable>;
EXEC SQL INCLUDE &lt;<replaceable>filename</replaceable>&gt;;
EXEC SQL INCLUDE "<replaceable>filename</replaceable>";
    </programlisting>
    Le préprocesseur de SQL embarqué recherchera un fichier appelé
    <literal><replaceable>filename</replaceable>.h</literal>,
    le préprocessera, et l'incluera dans la sortie C résultante. En
    conséquence de quoi, les ordres SQL embarqués dans le fichier inclus
    seront traités correctement.
   </para>

   <para>
    Le préprocesseurs <command>ecpg</command> cherchera un fichier dans
    plusieurs répertoires dans l'ordre suivant&nbsp;:

    <itemizedlist>
     <listitem><simpara>répertoire courant</simpara></listitem>
     <listitem><simpara><filename>/usr/local/include</filename></simpara></listitem>
     <listitem><simpara>Le répertoire d'inclusion de PostgreSQL, défini à la compilation (par exemple, <filename>/usr/local/pgsql/include</filename>)</simpara></listitem>
     <listitem><simpara><filename>/usr/include</filename></simpara></listitem>
    </itemizedlist>

    Mais quand <literal>EXEC SQL INCLUDE
     "<replaceable>filename</replaceable>"</literal> est utilisé, seul
    le répertoire courant est parcouru.
   </para>

   <para>
    Dans chaque répertoire, le préprocesseur recherchera d'abord le nom
    de fichier tel que spécifié, et si non trouvé, rajoutera <literal>.h</literal>
    au nom de fichier et essaiera à nouveau (sauf si le nom de fichier spécifié
    a déjà ce suffixe).
   </para>

   <para>
    Notez que <command>EXEC SQL INCLUDE</command> est <emphasis>différent</emphasis> de:
    <programlisting>
#include &lt;<replaceable>filename</replaceable>.h&gt;
    </programlisting>
    parce que ce fichier ne serait pas soumis au préprocessing des commandes SQL.
    Naturellement, vous pouvez continuer d'utiliser la directive C
    <literal>#include</literal> pour inclure d'autres fichiers d'entête.
    files.
   </para>

   <note>
    <para>
     Le nom du fichier à inclure est sensible à la casse, même si le
     reste de la commande <literal>EXEC SQL INCLUDE</literal> suit les
     règles normales de sensibilité à la casse de SQL.
    </para>
   </note>
  </sect2>

  <sect2 id="ecpg-define">
   <title>Les Directives define et undef</title>
   <para>
    Similaires aux directives <literal>#define</literal> qui sont connues en C,
    le SQL embarqué a un concept similaire&nbsp;:
    <programlisting>
EXEC SQL DEFINE <replaceable>name</replaceable>;
EXEC SQL DEFINE <replaceable>name</replaceable> <replaceable>value</replaceable>;
    </programlisting>
    Vous pouvez donc définir un nom:
    <programlisting>
EXEC SQL DEFINE HAVE_FEATURE;
    </programlisting>
    Et vous pouvez aussi définir des constantes:
    <programlisting>
EXEC SQL DEFINE MYNUMBER 12;
EXEC SQL DEFINE MYSTRING 'abc';
    </programlisting>
    Utilisez <literal>undef</literal> pour supprimer une définition précédente&nbsp;:
    <programlisting>
EXEC SQL UNDEF MYNUMBER;
    </programlisting>
   </para>

   <para>
    Bien sûr, vous pouvez continuer d'utiliser les versions C de <literal>#define</literal>
    et <literal>#undef</literal> dans votre programme SQL embarqué. La différence
    est le moment où vos valeurs définies sont évalues. Si vous utilisez
    <literal>EXEC SQL DEFINE</literal> alors la préprocesseur <command>ecpg</command>
    évalue les définition et substitiue les valeurs. Par exemple si vous écrivez&nbsp;:
    <programlisting>
EXEC SQL DEFINE MYNUMBER 12;
...
EXEC SQL UPDATE Tbl SET col = MYNUMBER;
    </programlisting>
    alors <command>ecpg</command> fera d'emblée la substitution et votre compilateur C ne
    verra jamais aucun nom ou identifiant <literal>MYNUMBER</literal>. Notez que vous ne
    pouvez pas utiliser <literal>#define</literal> pour une constante que vous allez utiliser
    dans une requête SQL embarquée parce que dans ce cas le précomipilateur SQL embarqué
    n'est pas capable de voir cette déclaration.
   </para>
  </sect2>

  <sect2 id="ecpg-ifdef">
   <title>Directives ifdef, ifndef, elif, else, et endif</title>
   <para>
    Vous pouvez utiliser les directives suivantes pour compiler des sections de code
    sous condition&nbsp;:

    <variablelist>
     <varlistentry>
      <term><literal>EXEC SQL ifdef <replaceable>nom</replaceable>;</literal></term>
      <listitem>
       <para>
        Vérifie un <replaceable>nom</replaceable> et traite les lignes suivante si
        <replaceable>nom</replaceable> a été créé avec <literal>EXEC SQL define
         <replaceable>nom</replaceable></literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL ifndef <replaceable>nom</replaceable>;</literal></term>
      <listitem>
       <para>
        Vérifie un <replaceable>nom</replaceable> et traite les lignes suivantes si
        <replaceable>nom</replaceable> <emphasis>n'a pas</emphasis> été défini avec
        <literal>EXEC SQL define <replaceable>nom</replaceable></literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL elif <replaceable>name</replaceable>;</literal></term>
      <listitem>
       <para>
        Commence une section alternative optionnelle après une directive
        <literal>EXEC SQL ifdef <replaceable>name</replaceable></literal> ou
        <literal>EXEC SQL ifndef <replaceable>name</replaceable></literal>. Il
        peut y avoir autant de sections <literal>elif</literal> que nécessaire.
        Les lignes suivant un <literal>elif</literal> seront traitées si
        <replaceable>name</replaceable> a été défini <emphasis>et</emphasis>
        qu'aucune section précédente pour la même construction
        <literal>ifdef</literal>/<literal>ifndef</literal>...<literal>endif</literal>
        n'a été traitée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL else;</literal></term>
      <listitem>
       <para>
        Commence une section finale, optionnelle, après une directive
        <literal>EXEC SQL ifdef <replaceable>name</replaceable></literal> ou
        <literal>EXEC SQL ifndef <replaceable>name</replaceable></literal>. Les
        lignes suivantes seront traitées si aucune section précédente de la même
        construction
        <literal>ifdef</literal>/<literal>ifndef</literal>...<literal>endif</literal>
        n'a été traitée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL endif;</literal></term>
      <listitem>
       <para>
        Termine une construction
        <literal>ifdef</literal>/<literal>ifndef</literal>...<literal>endif</literal>.
        Les lignes suivantes sont traitées normalement.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Les constructions
    <literal>ifdef</literal>/<literal>ifndef</literal>...<literal>endif</literal>
    peuvent être imbriquées, jusqu'à 127 niveaux.
   </para>

   <para>
    Cet exemple compilera exactement une des trois commandes <literal>SET
     TIMEZONE</literal>&nbsp;:
    <programlisting>
EXEC SQL ifdef TZVAR;
EXEC SQL SET TIMEZONE TO TZVAR;
EXEC SQL elif TZNAME;
EXEC SQL SET TIMEZONE TO TZNAME;
EXEC SQL else;
EXEC SQL SET TIMEZONE TO 'GMT';
EXEC SQL endif;
    </programlisting>
   </para>

  </sect2>
 </sect1>

 <sect1 id="ecpg-process">
  <title>Traiter des Programmes en SQL Embarqué</title>

  <para>
   Maintenant que vous avez une idée de comment rédiger des programmes
   SQL embarqué en C, vous voudrez probablement savoir comment les compiler.
   Avant de les compiler, vous passez le fichier dans le préprocesseur
   <acronym>C</acronym> <acronym>SQL</acronym> embarqué, qui convertira
   les ordres <acronym>SQL</acronym> que vous avez utilisé vers des appels
   de fonction spéciaux. Ces fonctions récupèrent des données à partir de
   leurs arguments, effectuent les commands <acronym>SQL</acronym> en
   utilisant l'interface <application>libpq</application>, et met le
   résultat dans les arguments spécifiés comme sortie.
  </para>

  <para>
   Le programme préprocesseur est appelé <filename>ecpg</filename> et fait
   partie d'une installation normale de <productname>PostgreSQL</productname>.
   Les programmes SQL embarqués sont typiquement nommés avec une extension
   <filename>.pgc</filename>. Si vous avez un fichier de programme appelé
   <filename>prog1.pgc</filename>, vous pouvez le préprocesseur en appelant
   simplement&nbsp;:
   <programlisting>
ecpg prog1.pgc
   </programlisting>
   Cela créera un fichier appelé <filename>prog1.c</filename>. Si
   vos fichiers d'entrée ne suivent pas les règles de nommage suggérées,
   vous pouvez spécifier le fichier de sortie explicitement en utilisant
   l'option <option>-o</option>.
  </para>

  <para>
   Le fichier préprocessé peut être compilé normalement, par exemple&nbsp;:
   <programlisting>
cc -c prog1.c
   </programlisting>
   Les fichiers sources C générés incluent les fichiers d'entête de
   l'installation <productname>PostgreSQL</productname>, donc si vous avez
   installé <productname>PostgreSQL</productname> à un endroit qui n'est
   pas recherché par défaut, vous devrez ajouter une option comme
   <literal>-I/usr/local/pgsql/include</literal> à la ligne de commande de
   compilation.
  </para>

  <para>
   Pour lier un programme SQL embarqué, vous aurez besoin d'inclure la
   librairie <filename>libecpg</filename>, comme ceci&nbsp;:
   <programlisting>
cc -o myprog prog1.o prog2.o ... -lecpg
   </programlisting>
   De nouveau, vous pourriez avoir besoin d'ajouter une option comme
   <literal>-L/usr/local/pgsql/lib</literal> à la ligne de commande.
  </para>

  <para>
   Vous pouvez utiliser <command>pg_config</command>
   <indexterm><primary>pg_config</primary><secondary sortas="ecpg">avec
     ecpg</secondary></indexterm>
   ou <command>pkg-config</command>
   <indexterm><primary>pkg-config</primary><secondary sortas="ecpg">avec
     ecpg</secondary></indexterm>
   avec le package <literal>libecpg</literal> pour obtenir les chemins de votre
   installation.
  </para>

  <para>
   Si vous gérez le processus de compilation d'un projet de grande
   taille en utilisant <application>make</application>, il serait
   pratique d'inclure la règle implicite suivante à vos makefiles&nbsp;:
   <programlisting>
ECPG = ecpg

%.c: %.pgc
        $(ECPG) $&lt;
   </programlisting>
  </para>

  <para>
   La syntaxe complète de la commande <command>ecpg</command> est
   détaillée dans <xref linkend="app-ecpg"/>.
  </para>

  <para>
   La librairie <application>ecpg</application> est thread-safe par
   défaut. Toutefois, vous aurez peut-être besoin d'utiliser des
   options de ligne de commande spécifiques aux threads pour compiler
   votre code client.
  </para>
 </sect1>

 <sect1 id="ecpg-library">
  <title>Fonctions de la Librairie</title>

  <para>
   La librairie <filename>libecpg</filename> contient principalement
   des fonctions <quote>cachées</quote> qui sont utilisée pour implémenter
   les fonctionnalités exprimées par les commandes SQL embarquées.
   Mais il y a quelques fonctions qui peuvent être appelées directement
   de façon utile. Notez que cela rendra votre code non-portable.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     <function>ECPGdebug(int <replaceable>on</replaceable>, FILE
      *<replaceable>stream</replaceable>)</function> active les
     traces de déboggage si appelé avec une valeur différente de 0 en
     premier argument. La trace contient tous les ordres
     <acronym>SQL</acronym> avec toutes les variables d'entrées insérées,
     et les résultats du serveur <productname>PostgreSQL</productname>.
     Cela peut être très utile quand vous êtes à la recherche d'erreurs
     dans vos ordres <acronym>SQL</acronym>.
    </para>
    <note>
     <para>
      Sous Windows, si les librairies <application>ecpg</application> et les
      applications sont compilées avec des options différentes, cet appel de
      fonction fera planter l'application parce que la représentation interne des
      pointeurs <filename>FILE</filename> diffère. En particulier,
      les options multithreaded/single-threaded, release/debug, et static/dynamic
      doivent être les mêmes pour la librairie et toutes les applications qui
      l'utilisent.
     </para>
    </note>
   </listitem>

   <listitem>
    <para>
     <function>ECPGget_PGconn(const char *<replaceable>nom_connexion</replaceable>)
     </function> retourne le descripteur de connexion à la base de données de la librairie
     identifié par le nom fourni. Si <replaceable>nom_connexion</replaceable> est positionné à
     <literal>NULL</literal>, le descripteur de connexion courant est retourné. Si aucun
     descripteur de connexion ne peut être identifié, la fonction retourne <literal>NULL</literal>.
     Le descripteur de connexion retourné peut être utilisé pour appeler toute autre fonction
     de la <application>libpq</application>, si nécessaire.
    </para>
    <note>
     <para>
      C'est une mauvaise idée de manipuler les descripteurs de connexion à la base de donnée faits par
      <application>ecpg</application> directement avec des routines de <application>libpq</application>.
     </para>
    </note>
   </listitem>

   <listitem>
    <para>
     <function>ECPGtransactionStatus(const char *<replaceable>nom_connexion</replaceable>)</function>
     retourne l'état de la transaction courante de la connexion identifiée par <replaceable>nom_connexion</replaceable>.
     Voyez <xref linkend="libpq-status"/> et la fonction de la libpq
     <xref linkend="libpq-PQtransactionStatus"/> pour les détails
     à propos des codes d'état retournés.
    </para>
   </listitem>

   <listitem>
    <para>
     <function>ECPGstatus(int <replaceable>lineno</replaceable>,
      const char* <replaceable>nom_connexion</replaceable>)</function>
     retourne vrai si vous êtes connecté à une base et faux sinon.
     <replaceable>nom_connexion</replaceable> peut valoir <literal>NULL</literal>
     si une seule connexion est utilisée.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="ecpg-lo">
  <title>Large Objects</title>

  <para>
   Les Large objects ne sont pas supportés directement par ECPG, mais
   les application ECPG peuvent manipuler des large objects au moyen
   des fonctions large objects de la libpq, en obtenant l'objet
   <type>PGconn</type> nécessaire par l'appel de la fonction
   <function>ECPGget_PGconn</function>. (Toutefois, l'utilisation directe
   de la fonction <function>ECPGget_PGconn</function> et la manipulation
   d'objets <type>PGconn</type> devrait être effectuée de façon très
   prudente, et idéalement pas mélangée avec d'autres appels à la base
   par ECPG.)
  </para>

  <para>
   Pour plus de détails à propos de <function>ECPGget_PGconn</function>,
   voyez <xref linkend="ecpg-library"/>. Pour les informations sur
   les fonctions d'interfaçage avec les large objects, voyez
   <xref linkend="largeobjects"/>.
  </para>

  <para>
   Les fonctions large object doivent être appelées dans un bloc de
   transaction, donc quand autocommit est à off, les commandes
   <command>BEGIN</command> doivent être effectuées explicitement.
  </para>

  <para>
   <xref linkend="ecpg-lo-example"/> montre un programme de démonstration
   sur les façons de créer, écrire et lire un large object dans une
   application ECPG.
  </para>

  <example id="ecpg-lo-example">
   <title>Programme ECPG Accédant à un Large Object</title>
   <programlisting><![CDATA[
#include <stdio.h>
#include <stdlib.h>
#include <libpq-fe.h>
#include <libpq/libpq-fs.h>

EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    PGconn     *conn;
    Oid         loid;
    int         fd;
    char        buf[256];
    int         buflen = 256;
    char        buf2[256];
    int         rc;

    memset(buf, 1, buflen);

    EXEC SQL CONNECT TO testdb AS con1;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    conn = ECPGget_PGconn("con1");
    printf("conn = %p\n", conn);

    /* créer */
    loid = lo_create(conn, 0);
    if (loid < 0)
        printf("lo_create() failed: %s", PQerrorMessage(conn));

    printf("loid = %d\n", loid);

    /* test d'écriture */
    fd = lo_open(conn, loid, INV_READ|INV_WRITE);
    if (fd < 0)
        printf("lo_open() failed: %s", PQerrorMessage(conn));

    printf("fd = %d\n", fd);

    rc = lo_write(conn, fd, buf, buflen);
    if (rc < 0)
        printf("lo_write() failed\n");

    rc = lo_close(conn, fd);
    if (rc < 0)
        printf("lo_close() failed: %s", PQerrorMessage(conn));

    /* read test */
    fd = lo_open(conn, loid, INV_READ);
    if (fd < 0)
        printf("lo_open() failed: %s", PQerrorMessage(conn));

    printf("fd = %d\n", fd);

    rc = lo_read(conn, fd, buf2, buflen);
    if (rc < 0)
        printf("lo_read() failed\n");

    rc = lo_close(conn, fd);
    if (rc < 0)
        printf("lo_close() failed: %s", PQerrorMessage(conn));

    /* vérifier */
    rc = memcmp(buf, buf2, buflen);
    printf("memcmp() = %d\n", rc);

    /* nettoyer */
    rc = lo_unlink(conn, loid);
    if (rc < 0)
        printf("lo_unlink() failed: %s", PQerrorMessage(conn));

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
]]></programlisting>
  </example>
 </sect1>

 <sect1 id="ecpg-cpp">
  <title>Applications <acronym>C++</acronym></title>

  <para>
   ECPG a un support limité pour les applications C++. Cette
   section décrit certains pièges.
  </para>

  <para>
   Le préprocesseur <command>ecpg</command> prend un fichier
   d'entrée écrit en C (ou quelque chose qui ressemble à du C) et
   des commandes SQL embarquées, et convertit les commandes SQL
   embarquées dans des morceaux de langage, et finalement génère
   un fichier <filename>.c</filename>. Les déclarations de fichiers
   d'entête des fonctions de librairie utilisées par les morceaux
   de langage C que génère <command>ecpg</command> sont entourées de
   blocs <literal>extern "C" { ... }</literal> quand ils sont
   utilisés en C++, ils devraient donc fonctionner de façon transparente
   en C++.
  </para>

  <para>
   En général, toutefois, le préprocesseur <command>ecpg</command>
   ne comprend que le C; il ne gère pas la syntaxe spéciale et les
   mots réservés du langage C++. Par conséquent, du code SQL embarqué
   écrit dans du code d'une application C++ qui utilise des fonctionnalités
   compliquées spécifiques au C++ pourrait ne pas être préprocessé
   correctement ou pourrait ne pas fonctionner comme prévu.
  </para>

  <para>
   Une façon sûre d'utiliser du code SQL embarqué dans une application
   C++ est de cacher les appels à ECPG dans un module C, que le code
   C++ de l'application appelle pour accéder à la base, et lier ce module
   avec le reste du code C++. Voyez <xref linkend="ecpg-cpp-and-c"/>
   à ce sujet.
  </para>

  <sect2 id="ecpg-cpp-scope">
   <title>Portée des Variable Hôtes</title>

   <para>
    Le préprocesseur <command>ecpg</command> comprend la porté des
    variables C. Dans le langage C, c'est plutôt simple parce que la
    portée des variables ne dépend que du bloc de code dans lequel
    elle se trouve. En C++, par contre, les variables d'instance sont
    référencées dans un bloc de code différent de la position de déclaration,
    ce qui fait que le préprocesseur <command>ecpg</command> ne comprendra
    pas la portée des variables d'instance.
   </para>

   <para>
    Par exemple, dans le cas suivant, le préprocesseur <command>ecpg</command>
    ne peut pas trouver de déclaration pour la variable <literal>dbname</literal>
    dans la méthode <literal>test</literal>, une erreur va donc se produire.

<programlisting>
class TestCpp
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    EXEC SQL CONNECT TO testdb1;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
}

void Test::test()
{
    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

TestCpp::~TestCpp()
{
    EXEC SQL DISCONNECT ALL;
}
   </programlisting>

   Ce code génèrera une erreur comme celle qui suit&nbsp;:
   <screen>
<userinput>ecpg test_cpp.pgc</userinput>
test_cpp.pgc:28: ERROR: variable "dbname" is not declared
   </screen>
  </para>

  <para>
   Pour éviter ce problème de portée, la méthode <literal>test</literal>
   pourrait être modifiée pour utiliser une variable locale comme stockage
   intermédiaire. Mais cette approche n'est qu'un mauvais contournement,
   parce qu'elle rend le code peu élégant et réduit la performance.

   <programlisting>
void TestCpp::test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char tmp[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :tmp;
    strlcpy(dbname, tmp, sizeof(tmp));

    printf("current_database = %s\n", dbname);
}
   </programlisting>
  </para>
 </sect2>

 <sect2 id="ecpg-cpp-and-c">
  <title>Développement d'application C++ avec un Module Externe en C</title>

  <para>
   Si vous comprenez ces limitations techniques du préprocesseur
   <command>ecpg</command> en C++, vous arriverez peut-être à la conclusion
   que lier des objets C et C++ au moment du link pour permettre à des
   applications C++ d'utiliser les fonctionnalités d'ECPG pourrait
   être mieux que d'utiliser des commandes SQL embarquées dans du code
   C++ directement. Cette section décrit un moyen de séparer des commandes
   SQL embarquées du code d'une application C++ à travers un exemple simple.
   Dans cet exemple, l'application est implémentée en C++, alors que
   C et ECPG sont utilisés pour se connecter au serveur PostgreSQL.
  </para>

  <para>
   Trois types de fichiers devront être créés: un fichier C
   (<filename>*.pgc</filename>), un fichier d'entête, et un fichier C++&nbsp;:

   <variablelist>
    <varlistentry>
     <term><filename>test_mod.pgc</filename></term>
     <listitem>
      <para>
       Un module de routines pour exécuter des commandes SQL embarquées en C.
       Il sera converti en <filename>test_mod.c</filename> par le préprocesseur.

       <programlisting>
#include "test_mod.h"
#include &lt;stdio.h&gt;

void
db_connect()
{
    EXEC SQL CONNECT TO testdb1;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
}

void
db_test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

void
db_disconnect()
{
    EXEC SQL DISCONNECT ALL;
}
       </programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><filename>test_mod.h</filename></term>
     <listitem>
      <para>
       Un fichier d'entête avec les déclarations des fonctions
       du module C (<filename>test_mod.pgc</filename>). Il est inclus
       par <filename>test_cpp.cpp</filename>. Ce fichier devra avoir un
       bloc <literal>extern "C"</literal> autour des déclarations,
       parce qu'il sera lié à partir d'un module C++.

       <programlisting>
#ifdef __cplusplus
extern "C" {
#endif

void db_connect();
void db_test();
void db_disconnect();

#ifdef __cplusplus
}
#endif
       </programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><filename>test_cpp.cpp</filename></term>
     <listitem>
      <para>
       Le code principal de l'application, incluant
       la routine <function>main</function>, et dans cet exemple
       une classe C++.

       <programlisting>
#include "test_mod.h"

class TestCpp
{
  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    db_connect();
}

void
TestCpp::test()
{
    db_test();
}

TestCpp::~TestCpp()
{
    db_disconnect();
}

int
main(void)
{
    TestCpp *t = new TestCpp();

    t->test();
    return 0;
}
       </programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Pour construire l'application, procédez comme suit. Convertissez
   <filename>test_mod.pgc</filename> en <filename>test_mod.c</filename> en
   lançant <command>ecpg</command>, et générez
   <filename>test_mod.o</filename> en compilant
   <filename>test_mod.c</filename> avec le compilateur C:
   <programlisting>
ecpg -o test_mod.c test_mod.pgc
cc -c test_mod.c -o test_mod.o
   </programlisting>
  </para>

  <para>
   Puis, générez <filename>test_cpp.o</filename> en compilant
   <filename>test_cpp.cpp</filename> avec le compilateur C++:
   <programlisting>
c++ -c test_cpp.cpp -o test_cpp.o
   </programlisting>
  </para>

  <para>
   Finalement, liez ces objets, <filename>test_cpp.o</filename>
   et <filename>test_mod.o</filename>, dans un exécutable, en utilisant
   le compilateur C++:
   <programlisting>
c++ test_cpp.o test_mod.o -lecpg -o test_cpp
   </programlisting>
  </para>
 </sect2>
</sect1>

<sect1 id="ecpg-sql-commands">
 <title>Commandes SQL Embarquées</title>

 <para>
  Cette section décrit toutes les commandes SQL qui sont spécifiques
  au SQL embarqué. Consultez aussi les commandes SQL listées
  dans <xref linkend="sql-commands"/>, qui peuvent aussi être utilisée
  dans du SQL embarqué, sauf mention contraire.
 </para>

 <refentry id="ecpg-sql-allocate-descriptor">
  <refnamediv>
   <refname>ALLOCATE DESCRIPTOR</refname>
   <refpurpose>alloue une zone de descripteur SQL</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
ALLOCATE DESCRIPTOR <replaceable class="parameter">name</replaceable>
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <command>ALLOCATE DESCRIPTOR</command> alloue une nouvelle zone de descripteur
    SQL nommée, qui pourra être utilisée pour échanger des données entre le
    serveur PostgreSQL et le programme hôte.
   </para>

   <para>
    Les zones de descripteur devraient être libérées après utilisation
    avec la commande <command>DEALLOCATE DESCRIPTOR</command>.
   </para>
  </refsect1>

  <refsect1>
   <title>Paramètres</title>

   <variablelist>
    <varlistentry>
     <term><replaceable class="parameter">name</replaceable></term>
     <listitem>
      <para>
       Un nom de descripeur SQL, sensible à la casse. Il peut être un
       identifiant SQL ou une variable hôte.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
EXEC SQL ALLOCATE DESCRIPTOR mydesc;
   </programlisting>
  </refsect1>

  <refsect1>
   <title>Compatibilité</title>

   <para>
    <command>ALLOCATE DESCRIPTOR</command> est spécifié par
    le standard SQL.
   </para>
  </refsect1>

  <refsect1>
   <title>Voir aussi</title>

   <simplelist type="inline">
    <member><xref linkend="ecpg-sql-deallocate-descriptor"/></member>
    <member><xref linkend="ecpg-sql-get-descriptor"/></member>
    <member><xref linkend="ecpg-sql-set-descriptor"/></member>
   </simplelist>
  </refsect1>
 </refentry>

 <refentry id="ecpg-sql-connect">
  <refnamediv>
   <refname>CONNECT</refname>
   <refpurpose>établit une connexion à la base de données</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
CONNECT TO <replaceable>connection_target</replaceable> [ AS <replaceable>nom_connexion</replaceable> ] [ USER <replaceable>connection_user_name</replaceable> ]
CONNECT TO DEFAULT
CONNECT <replaceable>connection_user_name</replaceable>
DATABASE <replaceable>connection_target</replaceable>
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    La commande <command>CONNECT</command> établit une connexion
    entre le client et le serveur PostgreSQL.
   </para>
  </refsect1>

  <refsect1>
   <title>Paramètres</title>

   <variablelist>
    <varlistentry>
     <term><replaceable class="parameter">connection_target</replaceable></term>
     <listitem>
      <para>
       <replaceable class="parameter">connection_target</replaceable>
       spécifie le serveur cible de la connexion dans une des formes
       suivantes&nbsp;:

       <variablelist>
        <varlistentry>
         <term>[ <replaceable>database_name</replaceable> ] [ <literal>@</literal><replaceable>host</replaceable> ] [ <literal>:</literal><replaceable>port</replaceable> ]</term>
         <listitem>
          <para>
           Se connecter par TCP/IP
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>unix:postgresql://</literal><replaceable>host</replaceable> [ <literal>:</literal><replaceable>port</replaceable> ] <literal>/</literal> [ <replaceable>database_name</replaceable> ] [ <literal>?</literal><replaceable>connection_option</replaceable> ]</term>
         <listitem>
          <para>
           Se connecter par une socket de domaine Unix
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>tcp:postgresql://</literal><replaceable>host</replaceable> [ <literal>:</literal><replaceable>port</replaceable> ] <literal>/</literal> [ <replaceable>database_name</replaceable> ] [ <literal>?</literal><replaceable>connection_option</replaceable> ]</term>
         <listitem>
          <para>
           Se connecter par TCP/IP
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term>constante de type chaîne SQL</term>
         <listitem>
          <para>
           contient une valeur d'une des formes précédentes
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term>variable hôte</term>
         <listitem>
          <para>
           variable hôte du type <type>char[]</type>
           ou <type>VARCHAR[]</type> contenant une valeur d'une des
           formes précédentes
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">connection_name</replaceable></term>
     <listitem>
      <para>
       Un identifiant optionnel pour la connexion, afin qu'on puisse
       y faire référence dans d'autres commandes. Cela peut être un
       identifiant SQL ou une variable hôte.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">connection_user</replaceable></term>
     <listitem>
      <para>
       Le nom d'utilisateur pour une connexion à la base de données.
      </para>

      <para>
       Ce paramètre peut aussi spécifier un nom d'utilisateur et un mot de passe, en utilisant une des formes
       <literal><replaceable>user_name</replaceable>/<replaceable>password</replaceable></literal>,
       <literal><replaceable>user_name</replaceable> IDENTIFIED BY <replaceable>password</replaceable></literal>, or
       <literal><replaceable>user_name</replaceable> USING <replaceable>password</replaceable></literal>.
      </para>

      <para>
       Nom d'utilisateur et mot de passe peuvent être des identifiants
       SQL, des constantes de type chaîne, ou des variables hôtes.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>DEFAULT</literal></term>
     <listitem>
      <para>
       Utiliser tous les paramètres de connexion par défaut, comme défini par libpq.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Exemples</title>

   <para>
    Voici plusieurs variantes pour spécifier des paramètres de connexion&nbsp;:
    <programlisting>
EXEC SQL CONNECT TO "connectdb" AS main;
EXEC SQL CONNECT TO "connectdb" AS second;
EXEC SQL CONNECT TO "unix:postgresql://200.46.204.71/connectdb" AS main USER connectuser;
EXEC SQL CONNECT TO "unix:postgresql://localhost/connectdb" AS main USER connectuser;
EXEC SQL CONNECT TO 'connectdb' AS main;
EXEC SQL CONNECT TO 'unix:postgresql://localhost/connectdb' AS main USER :user;
EXEC SQL CONNECT TO :db AS :id;
EXEC SQL CONNECT TO :db USER connectuser USING :pw;
EXEC SQL CONNECT TO @localhost AS main USER connectdb;
EXEC SQL CONNECT TO REGRESSDB1 as main;
EXEC SQL CONNECT TO AS main USER connectdb;
EXEC SQL CONNECT TO connectdb AS :id;
EXEC SQL CONNECT TO connectdb AS main USER connectuser/connectdb;
EXEC SQL CONNECT TO connectdb AS main;
EXEC SQL CONNECT TO connectdb@localhost AS main;
EXEC SQL CONNECT TO tcp:postgresql://localhost/ USER connectdb;
EXEC SQL CONNECT TO tcp:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY connectpw;
EXEC SQL CONNECT TO tcp:postgresql://localhost:20/connectdb USER connectuser IDENTIFIED BY connectpw;
EXEC SQL CONNECT TO unix:postgresql://localhost/ AS main USER connectdb;
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb AS main USER connectuser;
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY "connectpw";
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser USING "connectpw";
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb?connect_timeout=14 USER connectuser;
    </programlisting>
   </para>

   <para>
    Voici un programme exemple qui illustre l'utilisation de variables
    hôtes pour spécifier des paramètres de connexion&nbsp;:
    <programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    char *dbname     = "testdb";    /* nom de la base */
    char *user       = "testuser";  /* nom d'utilisateur pour la connexion */
    char *connection = "tcp:postgresql://localhost:5432/testdb";
                                    /* chaîne de connexion */
    char ver[256];                  /* buffer pour contenir la chaîne de version */
EXEC SQL END DECLARE SECTION;

    ECPGdebug(1, stderr);

    EXEC SQL CONNECT TO :dbname USER :user;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
    EXEC SQL SELECT version() INTO :ver;
    EXEC SQL DISCONNECT;

    printf("version: %s\n", ver);

    EXEC SQL CONNECT TO :connection USER :user;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
    EXEC SQL SELECT version() INTO :ver;
    EXEC SQL DISCONNECT;

    printf("version: %s\n", ver);

    return 0;
}
    </programlisting>
   </para>
  </refsect1>

  <refsect1>
   <title>Compatibilité</title>

   <para>
    <command>CONNECT</command> est spécifié dans le standard SQL, mais
    le format des paramètres de connexion est
    spécifique à l'implémentation.
   </para>
  </refsect1>

  <refsect1>
   <title>Voir aussi</title>

   <simplelist type="inline">
    <member><xref linkend="ecpg-sql-disconnect"/></member>
    <member><xref linkend="ecpg-sql-set-connection"/></member>
   </simplelist>
  </refsect1>
 </refentry>

 <refentry id="ecpg-sql-deallocate-descriptor">
  <refnamediv>
   <refname>DEALLOCATE DESCRIPTOR</refname>
   <refpurpose>désalloue une zone de descripteur SQL</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
DEALLOCATE DESCRIPTOR <replaceable class="parameter">name</replaceable>
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <command>DEALLOCATE DESCRIPTOR</command> désalloue une zone de
    descripteur SQL nommée.
   </para>
  </refsect1>

  <refsect1>
   <title>Paramètres</title>

   <variablelist>
    <varlistentry>
     <term><replaceable class="parameter">name</replaceable></term>
     <listitem>
      <para>
       Le nom du descripteur qui va être désalloué.
       Il est sensible à la casse. Cela peut-être un identifiant SQL
       ou une variable hôte.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Exemples</title>

   <programlisting>
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;
   </programlisting>
  </refsect1>

  <refsect1>
   <title>Compatibilité</title>

   <para>
    <command>DEALLOCATE DESCRIPTOR</command> est spécifié dans le
    standard SQL
   </para>
  </refsect1>

  <refsect1>
   <title>See Also</title>

   <simplelist type="inline">
    <member><xref linkend="ecpg-sql-allocate-descriptor"/></member>
    <member><xref linkend="ecpg-sql-get-descriptor"/></member>
    <member><xref linkend="ecpg-sql-set-descriptor"/></member>
   </simplelist>
  </refsect1>
 </refentry>

 <refentry id="ecpg-sql-declare">
  <refnamediv>
   <refname>DECLARE</refname>
   <refpurpose>définit un curseur</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
DECLARE <replaceable class="parameter">nom_curseur</replaceable> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="parameter">nom_prepare</replaceable>
DECLARE <replaceable class="parameter">nom_curseur</replaceable> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="parameter">query</replaceable>
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <command>DECLARE</command> déclare un cusreur pour itérer
    sur le jeu de résultat d'une requête préparée. Cette commande a
    une sémantique légèrement différente de celle de l'ordre SQL
    direct <command>DECLARE</command>. Là ou ce dernier exécute
    une requête et prépare le jeu de résultat pour la récupération,
    cette commande SQL embarqué se contente de déclarer un nom comme
    <quote>variable de boucle</quote> pour itérer sur le résultat d'une
    requête; l'exécution réelle se produit quand le curseur est ouvert
    avec la commande <command>OPEN</command>.
   </para>
  </refsect1>

  <refsect1>
   <title>Paramètres</title>
   <variablelist>

    <varlistentry>
     <term><replaceable class="parameter">nom_curseur</replaceable></term>
     <listitem>
      <para>
       Un nom de curseur, sensible à la casse. Cela peut être un identifiant
       SQL ou une variable hôte.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nom_prepare</replaceable></term>
     <listitem>
      <para>
       Le nom de l'une requête préparée, soit comme un identifiant SQL
       ou comme une variable hôte.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">query</replaceable></term>
     <listitem>
      <para>
       Une commande <xref linkend="sql-select"/> ou
       <xref linkend="sql-values"/> qui fournira les enregistrements
       que le curseur devra retourner.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   <para>
    Pour la signification des options du curseur,
    voyez <xref linkend="sql-declare"/>.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemples</title>

   <para>
    Exemples de déclaration de curseur pour une requête&nbsp;:
    <programlisting>
EXEC SQL DECLARE C CURSOR FOR SELECT * FROM My_Table;
EXEC SQL DECLARE C CURSOR FOR SELECT Item1 FROM T;
EXEC SQL DECLARE cur1 CURSOR FOR SELECT version();
    </programlisting>
   </para>

   <para>
    Un exemple de déclaration de curseur pour une requête préparée&nbsp;:
    <programlisting>
EXEC SQL PREPARE stmt1 AS SELECT version();
EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
    </programlisting>
   </para>
  </refsect1>

  <refsect1>
   <title>Compatibilité</title>

   <para>
    <command>DECLARE</command> est spécifié dans le standard SQL.
   </para>
  </refsect1>

  <refsect1>
   <title>Voir aussi</title>

   <simplelist type="inline">
    <member><xref linkend="ecpg-sql-open"/></member>
    <member><xref linkend="sql-close"/></member>
    <member><xref linkend="sql-declare"/></member>
   </simplelist>
  </refsect1>
 </refentry>

 <refentry id="ecpg-sql-describe">
  <refnamediv>
   <refname>DESCRIBE</refname>
   <refpurpose>obtient des informations à propos d'une requête préparée ou d'un jeu de résultat</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
DESCRIBE [ OUTPUT ] <replaceable class="parameter">nom_prepare</replaceable> USING [ SQL ] DESCRIPTOR <replaceable class="parameter">nom_descripteur</replaceable>
DESCRIBE [ OUTPUT ] <replaceable class="parameter">nom_prepare</replaceable> INTO [ SQL ] DESCRIPTOR <replaceable class="parameter">nom_descripteur</replaceable>
DESCRIBE [ OUTPUT ] <replaceable class="parameter">nom_prepare</replaceable> INTO <replaceable class="parameter">nom_sqlda</replaceable>
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <command>DESCRIBE</command> récupère des informations sur les
    métadonnées à propos des colonnes de résultat contenues dans
    une requête préparée, sans déclencher la récupération d'un
    enregistrement.
   </para>
  </refsect1>

  <refsect1>
   <title>Paramètres</title>

   <variablelist>
    <varlistentry>
     <term><replaceable class="parameter">nom_prepare</replaceable></term>
     <listitem>
      <para>
       Le nom d'une requête préparée. Cela peut être un identifiant
       SQL ou une variable hôte.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nom_descripteur</replaceable></term>
     <listitem>
      <para>
       Un nom de descripteur. Il est sensible à la casse. Cela peut
       être un identifiant SQL ou une variable hôte.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nom_sqlda</replaceable></term>
     <listitem>
      <para>
       Le nom d'une variable SQLDA.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Exemples</title>

   <programlisting>
EXEC SQL ALLOCATE DESCRIPTOR mydesc;
EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :charvar = NAME;
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;
   </programlisting>
  </refsect1>

  <refsect1>
   <title>Compatibilité</title>

   <para>
    <command>DESCRIBE</command> est spécifié dans le standard SQL.
   </para>
  </refsect1>

  <refsect1>
   <title>Voir aussi</title>

   <simplelist type="inline">
    <member><xref linkend="ecpg-sql-allocate-descriptor"/></member>
    <member><xref linkend="ecpg-sql-get-descriptor"/></member>
   </simplelist>
  </refsect1>
 </refentry>

 <refentry id="ecpg-sql-disconnect">
  <refnamediv>
   <refname>DISCONNECT</refname>
   <refpurpose>met fin à une connexion de base de données</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
DISCONNECT <replaceable class="parameter">nom_connexion</replaceable>
DISCONNECT [ CURRENT ]
DISCONNECT DEFAULT
DISCONNECT ALL
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <command>DISCONNECT</command> ferme une connexion (ou toutes les
    connexions) à la base de données.
   </para>
  </refsect1>

  <refsect1>
   <title>Paramètres</title>

   <variablelist>
    <varlistentry>
     <term><replaceable class="parameter">nom_connexion</replaceable></term>
     <listitem>
      <para>
       Une connexion à la base établie par la
       commande <command>CONNECT</command>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>CURRENT</literal></term>
     <listitem>
      <para>
       Ferme la connexion <quote>courante</quote>, qui est soit la
       connexion ouverte la plus récemment, soit la connexion spécifiée
       par la commande <command>SET CONNECTION</command>. C'est aussi
       la valeur par défaut si aucun argument n'est donné à la commande
       <command>DISCONNECT</command>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>DEFAULT</literal></term>
     <listitem>
      <para>
       Ferme la connexion par défaut.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ALL</literal></term>
     <listitem>
      <para>
       Ferme toutes les connexions ouvertes.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Exemples</title>

   <programlisting>
int
main(void)
{
    EXEC SQL CONNECT TO testdb AS DEFAULT USER testuser;
    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL CONNECT TO testdb AS con2 USER testuser;
    EXEC SQL CONNECT TO testdb AS con3 USER testuser;

    EXEC SQL DISCONNECT CURRENT;  /* close con3          */
    EXEC SQL DISCONNECT DEFAULT;  /* close DEFAULT       */
    EXEC SQL DISCONNECT ALL;      /* close con2 and con1 */

    return 0;
}
   </programlisting>
  </refsect1>

  <refsect1>
   <title>Compatibilité</title>

   <para>
    <command>DISCONNECT</command> est spécifié dans le standard SQL.
   </para>
  </refsect1>

  <refsect1>
   <title>Voir aussi</title>

   <simplelist type="inline">
    <member><xref linkend="ecpg-sql-connect"/></member>
    <member><xref linkend="ecpg-sql-set-connection"/></member>
   </simplelist>
  </refsect1>
 </refentry>

 <refentry id="ecpg-sql-execute-immediate">
  <refnamediv>
   <refname>EXECUTE IMMEDIATE</refname>
   <refpurpose>prépare et exécute un ordre dynamique</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
EXECUTE IMMEDIATE <replaceable class="parameter">chaine</replaceable>
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <command>EXECUTE IMMEDIATE</command> prépare et exécute
    immédiatement un ordre SQL spécifié dynamiquement, sans
    récupérer les enregistrements du résultat.
   </para>
  </refsect1>

  <refsect1>
   <title>Paramètres</title>

   <variablelist>
    <varlistentry>
     <term><replaceable class="parameter">chaine</replaceable></term>
     <listitem>
      <para>
       Une chaîne C littérale ou une variable hôte contenant l'ordre
       SQL à exécuter.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Exemples</title>

   <para>
    Voici un exemple qui exécute un ordre <command>INSERT</command>
    en utilisant <command>EXECUTE IMMEDIATE</command> et une variable
    hôte appelée <varname>commande</varname>:
    <programlisting>
sprintf(commande, "INSERT INTO test (name, amount, letter) VALUES ('db: ''r1''', 1, 'f')");
EXEC SQL EXECUTE IMMEDIATE :commande;
    </programlisting>
   </para>
  </refsect1>

  <refsect1>
   <title>Compatibility</title>

   <para>
    <command>EXECUTE IMMEDIATE</command> est spécifié dans le standard SQL.
   </para>
  </refsect1>
 </refentry>

 <refentry id="ecpg-sql-get-descriptor">
  <refnamediv>
   <refname>GET DESCRIPTOR</refname>
   <refpurpose>récupère des informations d'une zone de descripteur SQL</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
GET DESCRIPTOR <replaceable class="parameter">nom_descripteur</replaceable> <replaceable class="parameter">:cvariable</replaceable> = <replaceable class="parameter">element_entete_descripteur</replaceable> [, ... ]
GET DESCRIPTOR <replaceable class="parameter">nom_descripteur</replaceable> VALUE <replaceable class="parameter">numero_colonne</replaceable> <replaceable class="parameter">:cvariable</replaceable> = <replaceable class="parameter">element_descripteur</replaceable> [, ... ]
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <command>GET DESCRIPTOR</command> récupère des informations
    à propos du résultat d'une requête à partir d'une zone de
    descripteur SQL et les stocke dans des variables hôtes. Une
    zone de descripteur est d'ordinaire remplie en utilisant
    <command>FETCH</command> ou <command>SELECT</command> avant
    d'utiliser cette commande pour transférer l'information dans des
    variables du langage hôte.
   </para>

   <para>
    Cette commande a deux formes: la première forme récupère les
    objets de <quote>l'entête</quote> du descripteur, qui s'appliquent
    au jeu de résultat dans son ensemble. Un exemple est le nombre
    d'enregistrements. La seconde forme, qui nécessite le nombre de
    colonnes comme paramètre additionnel, récupère des informations
    sur une colonne particulière. Par exemple, le type de la colonne,
    et la valeur réelle de la colonne.
   </para>
  </refsect1>

  <refsect1>
   <title>Paramètres</title>

   <variablelist>
    <varlistentry>
     <term><replaceable class="parameter">nom_descripteur</replaceable></term>
     <listitem>
      <para>
       Un nom de descripteur.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">element_entete_descripteur</replaceable></term>
     <listitem>
      <para>
       Un marqueur identifiant de quel objet de l'entête récupérer l'information.
       Seul <literal>COUNT</literal>, qui donne le nombre de colonnes dans le résultat,
       est actuellement supporté.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">numero_colonne</replaceable></term>
     <listitem>
      <para>
       Le numéro de la colonne à propos duquel on veut récupérer
       des informations. Le compte commence à 1.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">element_descripteur</replaceable></term>
     <listitem>
      <para>
       Un marqueur identifiant quel élément d'information récupérer
       d'une colonne. Voir <xref linkend="ecpg-named-descriptors"/>
       pour une liste d'objets supportés.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">cvariable</replaceable></term>
     <listitem>
      <para>
       Une variable hôte qui recevra les données récupérées de la
       zone de descripteur.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Exemples</title>

   <para>
    Un exemple de récupération du nombre de colonnes dans un résultat:
    <programlisting>
EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
    </programlisting>
   </para>

   <para>
    Un exemple de récupération de la longueur des données de la première colonne:
    <programlisting>
EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
    </programlisting>
   </para>

   <para>
    Un exemple de récupération des données de la seconde colonne en
    tant que chaîne:
    <programlisting>
EXEC SQL GET DESCRIPTOR d VALUE 2 :d_data = DATA;
    </programlisting>
   </para>

   <para>
    Voici un exemple pour la procédure complète, lors de l'exécution
    de <literal>SELECT current_database();</literal> et montrant le
    nombre de colonnes, la longueur de la colonne, et la données de
    la colonne:
    <programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int  d_count;
    char d_data[1024];
    int  d_returned_octet_length;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL ALLOCATE DESCRIPTOR d;

    /* Déclarer un curseur, l'ouvrir, et assigner un descripteur au curseur */
    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database();
    EXEC SQL OPEN cur;
    EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;

    /* Récupérer le nombre total de colonnes */
    EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
    printf("d_count                 = %d\n", d_count);

    /* Récupérer la longueur d'une colonne retournée */
    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
    printf("d_returned_octet_length = %d\n", d_returned_octet_length);

    /* Récupérer la colonne retournée en tant que chaîne */
    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_data = DATA;
    printf("d_data                  = %s\n", d_data);

    /* Fermer */
    EXEC SQL CLOSE cur;
    EXEC SQL COMMIT;

    EXEC SQL DEALLOCATE DESCRIPTOR d;
    EXEC SQL DISCONNECT ALL;

    return 0;
}
    </programlisting>
    Quand l'exemple est exécuté, son résultat ressemble à ceci:
    <screen>
d_count                 = 1
d_returned_octet_length = 6
d_data                  = testdb
    </screen>
   </para>
  </refsect1>

  <refsect1>
   <title>Compatibilité</title>

   <para>
    <command>GET DESCRIPTOR</command> est spécifié dans le standard SQL.
   </para>
  </refsect1>

  <refsect1>
   <title>Voir aussi</title>

   <simplelist type="inline">
    <member><xref linkend="ecpg-sql-allocate-descriptor"/></member>
    <member><xref linkend="ecpg-sql-set-descriptor"/></member>
   </simplelist>
  </refsect1>
 </refentry>

 <refentry id="ecpg-sql-open">
  <refnamediv>
   <refname>OPEN</refname>
   <refpurpose>ouvre un curseur dynamique</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
OPEN <replaceable class="parameter">nom_curseur</replaceable>
OPEN <replaceable class="parameter">nom_curseur</replaceable> USING <replaceable class="parameter">valeur</replaceable> [, ... ]
OPEN <replaceable class="parameter">nom_curseur</replaceable> USING SQL DESCRIPTOR <replaceable class="parameter">nom_descripteur</replaceable>
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <command>OPEN</command> ouvre un curseur et optionnellement
    lie (bind) les valeurs aux conteneurs (placeholders) dans la déclaration du curseur.
    Le curseur doit préalablement avoir été déclaré avec la commande
    <command>DECLARE</command>. L'exécution d'<command>OPEN</command>
    déclenche le début de l'exécution de la requête sur le serveur.
   </para>
  </refsect1>

  <refsect1>
   <title>Paramètres</title>

   <variablelist>
    <varlistentry>
     <term><replaceable class="parameter">nom_curseur</replaceable></term>
     <listitem>
      <para>
       Le nom du curseur à ouvrir. Cela peut être un identifiant SQL
       ou une variable hôte.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">valeur</replaceable></term>
     <listitem>
      <para>
       Une valeur à lier au placeholder du curseur. Cela peut être
       une constante SQL, une variable hôte, ou une variable hôte avec
       indicateur.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nom_descripteur</replaceable></term>
     <listitem>
      <para>
       Le nom du descripteur contenant les valeurs à attacher aux
       placeholders du curseur. Cela peut être un identifiant SQL
       ou une variable hôte.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Exemples</title>

   <programlisting>
EXEC SQL OPEN a;
EXEC SQL OPEN d USING 1, 'test';
EXEC SQL OPEN c1 USING SQL DESCRIPTOR mydesc;
EXEC SQL OPEN :curname1;
   </programlisting>
  </refsect1>

  <refsect1>
   <title>Compatibilité</title>

   <para>
    <command>OPEN</command> est spécifiée dans le standard SQL.
   </para>
  </refsect1>

  <refsect1>
   <title>Voir aussi</title>

   <simplelist type="inline">
    <member><xref linkend="ecpg-sql-declare"/></member>
    <member><xref linkend="sql-close"/></member>
   </simplelist>
  </refsect1>
 </refentry>

 <refentry id="ecpg-sql-prepare">
  <refnamediv>
   <refname>PREPARE</refname>
   <refpurpose>prépare un ordre pour son exécution</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
PREPARE <replaceable class="parameter">nom</replaceable> FROM <replaceable class="parameter">chaîne</replaceable>
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <command>PREPARE</command> prépare l'exécution d'un ordre
    spécifié dynamiquement sous forme d'une chaîne. C'est différent
    des ordres SQL directs <xref linkend="sql-prepare"/>, qui peuvent
    aussi être utilisés dans des programmes embarqués. La commande
    <xref linkend="sql-execute"/> peut être utilisée pour exécuter
    les deux types de requêtes préparées.
   </para>
  </refsect1>

  <refsect1>
   <title>Paramètres</title>

   <variablelist>
    <varlistentry>
     <term><replaceable class="parameter">nom_prepare</replaceable></term>
     <listitem>
      <para>
       Un identifiant pour la requête préparée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">chaîne</replaceable></term>
     <listitem>
      <para>
       Une chaîne littérale C ou une variable hôte contenant un ordre
       SQL préparable, soit SELECT, INSERT, UPDATE ou DELETE.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Exemples</title>
   <programlisting>
char *stmt = "SELECT * FROM test1 WHERE a = ? AND b = ?";

EXEC SQL ALLOCATE DESCRIPTOR outdesc;
EXEC SQL PREPARE foo FROM :stmt;

EXEC SQL EXECUTE foo USING SQL DESCRIPTOR indesc INTO SQL DESCRIPTOR outdesc;
   </programlisting>
  </refsect1>

  <refsect1>
   <title>Compatibilité</title>

   <para>
    <command>PREPARE</command> est spécifié dans le standard SQL.
   </para>
  </refsect1>

  <refsect1>
   <title>Voir aussi</title>

   <simplelist type="inline">
    <member><xref linkend="ecpg-sql-connect"/></member>
    <member><xref linkend="ecpg-sql-disconnect"/></member>
   </simplelist>
  </refsect1>
 </refentry>

 <refentry id="ecpg-sql-set-autocommit">
  <refnamediv>
   <refname>SET AUTOCOMMIT</refname>
   <refpurpose>configure le comportement de l'autocommit pour la session en cours</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
SET AUTOCOMMIT { = | TO } { ON | OFF }
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <command>SET AUTOCOMMIT</command> configure le comportement de l'autocommit
    pour la session en cours de la base de données. Par défaut, les programmes
    SQL embarqués ne sont <emphasis>pas</emphasis> en mode autocommit, donc
    <command>COMMIT</command> doit être exécuté explicitement quand il est
    voulu. Cette commande modifie le mode autocommit pour la session, où
    chaque requête individuelle est validée implicitement.
   </para>
  </refsect1>

  <refsect1>
   <title>Compatibilité</title>

   <para>
    <command>SET AUTOCOMMIT</command> est une extension de PostgreSQL ECPG.
   </para>
  </refsect1>
 </refentry>

 <refentry id="ecpg-sql-set-connection">
  <refnamediv>
   <refname>SET CONNECTION</refname>
   <refpurpose>sélectionne une connexion de base</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
SET CONNECTION [ TO | = ] <replaceable class="parameter">nom_connexion</replaceable>
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <command>SET CONNECTION</command> configure la connexion à la base de
    données <quote>actuelle</quote>, qui est celle que toutes les commandes
    utilisent, sauf en cas de surcharge.
   </para>
  </refsect1>

  <refsect1>
   <title>Paramètres</title>

   <variablelist>
    <varlistentry>
     <term><replaceable class="parameter">nom_connexion</replaceable></term>
     <listitem>
      <para>
       Un nom de connexion établi par la commande <command>CONNECT</command>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>DEFAULT</literal></term>
     <listitem>
      <para>
       configure la connexion à la connexion par défaut.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Exemples</title>

   <programlisting>
EXEC SQL SET CONNECTION TO con2;
EXEC SQL SET CONNECTION = con1;
   </programlisting>
  </refsect1>

  <refsect1>
   <title>Compatibility</title>

   <para>
    <command>SET CONNECTION</command> est indiqué dans le standard SQL.
   </para>
  </refsect1>

  <refsect1>
   <title>Voir aussi</title>

   <simplelist type="inline">
    <member><xref linkend="ecpg-sql-connect"/></member>
    <member><xref linkend="ecpg-sql-disconnect"/></member>
   </simplelist>
  </refsect1>
 </refentry>

 <refentry id="ecpg-sql-set-descriptor">
  <refnamediv>
   <refname>SET DESCRIPTOR</refname>
   <refpurpose>positionne des informations dans une zone de descripteur SQL</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
SET DESCRIPTOR <replaceable class="parameter">nom_descripteur</replaceable> <replaceable class="parameter">objet_entete_descripteur</replaceable> = <replaceable>valeur</replaceable> [, ... ]
SET DESCRIPTOR <replaceable class="parameter">nom_descripteur</replaceable> VALUE <replaceable class="parameter">numero</replaceable> <replaceable class="parameter">objet_descripteur</replaceable> = <replaceable>valeur</replaceable> [, ...]
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <command>SET DESCRIPTOR</command> remplit une zone de descripteur SQL
    de valeurs. La zone de descripteur est habituellement utilisée pour
    lier les paramètres lors d'une exécution de requête préparée
   </para>

   <para>
    Cette commande a deux formes: la première forme s'applique à l'
    <quote>entête</quote> du descripteur, qui est indépendant des
    données spécifiques. La seconde forme assigne des valeurs aux
    données, identifiées par un numéro.
   </para>
  </refsect1>

  <refsect1>
   <title>Paramètres</title>

   <variablelist>
    <varlistentry>
     <term><replaceable class="parameter">nom_descripteur</replaceable></term>
     <listitem>
      <para>
       Un nom de descripteur.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">objet_entete_descripteur</replaceable></term>
     <listitem>
      <para>
       Un identifiant pour spécifier quelle information de l'entête
       est concernée. Seul <literal>COUNT</literal>, qui sert à indiquer
       le nombre de descripteurs, est supporté pour le moment.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">number</replaceable></term>
     <listitem>
      <para>
       Le numéro de l'objet du descripteur à modifier. Le compte commence
       à 1.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">objet_descripteur</replaceable></term>
     <listitem>
      <para>
       Un identifiant spécifiant quelle information du descripteur est
       concernée. Voyez <xref linkend="ecpg-named-descriptors"/> pour
       une liste des identifiants supportés.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">valeur</replaceable></term>
     <listitem>
      <para>
       Une valeur à stocker dans l'objet descripteur. Cela peut être
       une constante SQL ou une variable hôte.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Exemples</title>
   <programlisting>
EXEC SQL SET DESCRIPTOR indesc COUNT = 1;
EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = 2;
EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = :val1;
EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val1, DATA = 'some string';
EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val2null, DATA = :val2;
   </programlisting>
  </refsect1>

  <refsect1>
   <title>Compatibilité</title>

   <para>
    <command>SET DESCRIPTOR</command> est spécifié dans le standard SQL.
   </para>
  </refsect1>

  <refsect1>
   <title>Voir aussi</title>

   <simplelist type="inline">
    <member><xref linkend="ecpg-sql-allocate-descriptor"/></member>
    <member><xref linkend="ecpg-sql-get-descriptor"/></member>
   </simplelist>
  </refsect1>
 </refentry>

 <refentry id="ecpg-sql-type">
  <refnamediv>
   <refname>TYPE</refname>
   <refpurpose>définit un nouveau type de données</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
TYPE <replaceable class="parameter">nom_type</replaceable> IS <replaceable class="parameter">ctype</replaceable>
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    La commande <command>TYPE</command> définit un nouveau type C. C'est
    équivalent à mettre un <literal>typedef</literal> dans une section
    declare.
   </para>

   <para>
    Cette commande n'est reconnue que quand <command>ecpg</command>
    est exécutée avec l'option <option>-c</option>.
   </para>
  </refsect1>

  <refsect1>
   <title>Paramètres</title>

   <variablelist>
    <varlistentry>
     <term><replaceable class="parameter">nom_type</replaceable></term>
     <listitem>
      <para>
       Le nom du nouveau type. Ce doit être un nom de type valide en C.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">ctype</replaceable></term>
     <listitem>
      <para>
       Une spécification de type C.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Exemples</title>

   <programlisting>
EXEC SQL TYPE customer IS
    struct
    {
        varchar name[50];
        int     phone;
    };

EXEC SQL TYPE cust_ind IS
    struct ind
    {
        short   name_ind;
        short   phone_ind;
    };

EXEC SQL TYPE c IS char reference;
EXEC SQL TYPE ind IS union { int integer; short smallint; };
EXEC SQL TYPE intarray IS int[AMOUNT];
EXEC SQL TYPE str IS varchar[BUFFERSIZ];
EXEC SQL TYPE string IS char[11];
   </programlisting>

   <para>
    Voici un programme de démonstration qui utilise
    <command>EXEC SQL TYPE</command>:
    <programlisting>
EXEC SQL WHENEVER SQLERROR SQLPRINT;

EXEC SQL TYPE tt IS
    struct
    {
        varchar v[256];
        int     i;
    };

EXEC SQL TYPE tt_ind IS
    struct ind {
        short   v_ind;
        short   i_ind;
    };

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    tt t;
    tt_ind t_ind;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    EXEC SQL SELECT current_database(), 256 INTO :t:t_ind LIMIT 1;

    printf("t.v = %s\n", t.v.arr);
    printf("t.i = %d\n", t.i);

    printf("t_ind.v_ind = %d\n", t_ind.v_ind);
    printf("t_ind.i_ind = %d\n", t_ind.i_ind);

    EXEC SQL DISCONNECT con1;

    return 0;
}
    </programlisting>

    La sortie de ce programme ressemble à ceci:
    <screen>
t.v = testdb
t.i = 256
t_ind.v_ind = 0
t_ind.i_ind = 0
    </screen>
   </para>
  </refsect1>

  <refsect1>
   <title>Compatibilité</title>

   <para>
    La commande <command>TYPE</command> est une extension PostgreSQL.
   </para>
  </refsect1>
 </refentry>

 <refentry id="ecpg-sql-var">
  <refnamediv>
   <refname>VAR</refname>
   <refpurpose>définit une variable</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
VAR <replaceable>nomvar</replaceable> IS <replaceable>ctype</replaceable>
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    La commande <command>VAR</command> assigne un nouveau type de données C
    à une variable hôte. La variable hôte doit être précédemment déclarée
    dans une section de déclaration.
   </para>
  </refsect1>

  <refsect1>
   <title>Paramètres</title>

   <variablelist>
    <varlistentry>
     <term><replaceable class="parameter">nomvar</replaceable></term>
     <listitem>
      <para>
       Un nom de variable C.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">ctype</replaceable></term>
     <listitem>
      <para>
       Une spécification de type C.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Exemples</title>

   <programlisting>
Exec sql begin declare section;
short a;
exec sql end declare section;
EXEC SQL VAR a IS int;
   </programlisting>
  </refsect1>

  <refsect1>
   <title>Compatibilité</title>

   <para>
    La commande <command>VAR</command> est une extension PostgreSQL.
   </para>
  </refsect1>
 </refentry>

 <refentry id="ecpg-sql-whenever">
  <refnamediv>
   <refname>WHENEVER</refname>
   <refpurpose>spécifie l'action à effectuer quand un ordre SQL entraîne le déclenchement d'une classe d'exception</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
WHENEVER { NOT FOUND | SQLERROR | SQLWARNING } <replaceable class="parameter">action</replaceable>
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    Définit un comportement qui sera appelé dans des cas spéciaux (
    enregistrements non trouvés, avertissements ou erreurs SQL) dans
    le résultat de l'exécution SQL.
   </para>
  </refsect1>

  <refsect1>
   <title>Paramètres</title>

   <para>
    Voyez <xref linkend="ecpg-whenever"/> pour une description
    des paramètres.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemples</title>

   <programlisting>
EXEC SQL WHENEVER NOT FOUND CONTINUE;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER NOT FOUND DO CONTINUE;
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLWARNING DO warn();
EXEC SQL WHENEVER SQLERROR sqlprint;
EXEC SQL WHENEVER SQLERROR CALL print2();
EXEC SQL WHENEVER SQLERROR DO handle_error("select");
EXEC SQL WHENEVER SQLERROR DO sqlnotice(NULL, NONO);
EXEC SQL WHENEVER SQLERROR DO sqlprint();
EXEC SQL WHENEVER SQLERROR GOTO error_label;
EXEC SQL WHENEVER SQLERROR STOP;
   </programlisting>

   <para>
    Une application classique est l'utilisation de
    <literal>WHENEVER NOT FOUND BREAK</literal> pour gérer le
    bouclage sur des jeux de résultats:
    <programlisting>
int
main(void)
{
    EXEC SQL CONNECT TO testdb AS con1;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
    EXEC SQL ALLOCATE DESCRIPTOR d;
    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database(), 'hoge', 256;
    EXEC SQL OPEN cur;

    /* quand la fin du jeu de résultat est atteinte, sortir de la boucle */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;
        ...
    }

    EXEC SQL CLOSE cur;
    EXEC SQL COMMIT;

    EXEC SQL DEALLOCATE DESCRIPTOR d;
    EXEC SQL DISCONNECT ALL;

    return 0;
}
    </programlisting>
   </para>
  </refsect1>

  <refsect1>
   <title>Compatibilité</title>

   <para>
    <command>WHENEVER</command> est spécifié dans le standard SQL,
    mais la plupart des actions sont des extensions PostgreSQL.
   </para>
  </refsect1>
 </refentry>
</sect1>

<sect1 id="ecpg-informix-compat">
 <title>Mode de Compatibilité <productname>Informix</productname></title>
 <para>
  <command>ecpg</command> peut être exécuté dans un mode appelé <firstterm>mode de compatibilité
   Informix</firstterm>. Si ce mode est actif, il essaie de se comporté comme s'il était le
  précompilateur <productname>Informix</productname> pour <productname>Informix</productname> E/SQL.
  En gros, cela va vous permettre d'utiliser le signe dollar au lieu de la primitive
  <literal>EXEC SQL</literal> pour fournir des commandes SQL embarquées:
  <programlisting>
$int j = 3;
$CONNECT TO :dbname;
$CREATE TABLE test(i INT PRIMARY KEY, j INT);
$INSERT INTO test(i, j) VALUES (7, :j);
$COMMIT;
  </programlisting>
 </para>

 <note>
  <para>
   Il ne doit par y avoir d'espace entre le <literal>$</literal>
   et la directive de préprocesseur qui le suit, c'est à
   dire <literal>include</literal>, <literal>define</literal>,
   <literal>ifdef</literal>, etc. Sinon, le préprocesseur comprendra
   le mot comme une variable hôte.
  </para>
 </note>

 <para>
  Il y a deux modes de compatibilité: <literal>INFORMIX</literal>, <literal>INFORMIX_SE</literal>
 </para>
 <para>
  Quand vous liez des programmes qui sont dans ce mode de compatibilité, rappelez
  vous de lier avec <literal>libcompat</literal> qui est fournie avec ECPG.
 </para>
 <para>
  En plus du liant syntaxique expliqué précédemment, le mode de compatibilité <productname>Informix</productname>
  porte d'ESQL vers ECPG quelques fonctions pour l'entrée, la sortie et la transformation des données, ainsi
  que pour le SQL embarqué.
 </para>
 <para>
  Le mode de compatibilité <productname>Informix</productname> est
  fortement connecté à la librairie pgtypeslib d'ECPG. pgtypeslib met
  en correspondance les types de données SQL et les types de données du
  programme hôte C et la plupart des fonctions additionnelles du mode
  de compatibilité <productname>Informix</productname> vous permettent
  de manipuler ces types C des programmes hôtes. Notez toutefois que
  l'étendue de cette compatibilité est limitée. Il n'essaie pas de
  copier le comportement d'<productname>Informix</productname>; il vous
  permet de faire plus ou mois les mêmes opérations et vou fournit des
  fonctions qui ont le même nom et ont à la base le même comportement,
  mais ce n'est pas un produit de remplacement transparent si vous
  utilisez <productname>Informix</productname> à l'heure actuelle. De
  plus, certains types de données sont différents. Par exemple, les
  types datetime et interval de <productname>PostgreSQL</productname>
  ne savent pas traiter des ranges comme par exemple <literal>YEAR TO
   MINUTE</literal>, donc vous n'aurez pas de support pour cela dans
  ECPG non plus.
 </para>

 <sect2 id="ecpg-informix-types">
  <title>Types supplémentaires</title>
  <para>
   Le pseudo-type "string" spécifique à Informix pour stocker des
   chaînes de caractères ajustées à droite est maintenant
   supporté dans le mode Informix sans avoir besoin d'utiliser
   <literal>typedef</literal>. En fait, en mode Informix, ECPG refuse
   de traiter les fichiers sources qui contiennent <literal>typedef
    untype string;</literal>
   <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
string userid; /* cette variable contient des données ajustées */
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH MYCUR INTO :userid;
   </programlisting>
  </para>
 </sect2>

 <sect2 id="ecpg-informix-statements">
  <title>Ordres SQL Embarqués Supplémentaires/Manquants</title>
  <para>
   <variablelist>
    <varlistentry>
     <term><literal>CLOSE DATABASE</literal></term>
     <listitem>
      <para>
       Cet ordre ferme la connexion courante. En fait, c'est un synonyme
       du <literal>DISCONNECT CURRENT</literal> d'ECPG:
       <programlisting>
$CLOSE DATABASE;                /* ferme la connexion courante */
EXEC SQL CLOSE DATABASE;
       </programlisting>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>FREE nom_curseur</literal></term>
     <listitem>
      <para>
       En raison des différences sur la façon dont ECPG fonctionne
       par rapport à l'ESQL/C d'Informix (c'est à dire quelles étapes
       sont purement des transformations grammaticales et quelles étapes
       s'appuient sur la librairie sous-jacente), il n'y a pas d'ordre
       <literal>FREE nom_curseur</literal> dans ECPG. C'est parce
       que, dans ECPG, <literal>DECLARE CURSOR</literal> ne génère
       pas un appel de fonction à la librairie qui utilise le nom du
       curseur. Ce qui implique qu'il n'y a pas à gérer les curseurs
       SQL à l'exécution dans la librairie ECPG, seulement dans le
       serveur PostgreSQL.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>FREE nom_requete</literal></term>
     <listitem>
      <para>
       <literal>FREE nom_requete</literal> est un synonyme de <literal>DEALLOCATE PREPARE nom_requete</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </sect2>

 <sect2 id="ecpg-informix-sqlda">
  <title>Zones de Descripteurs SQLDA Compatibles Informix</title>
  <para>
   Le mode de compatibilité Informix supporte une structure différente
   de celle décrite dans <xref linkend="ecpg-sqlda-descriptors"/>. Voyez
   ci-dessous:
   <programlisting>
struct sqlvar_compat
{
    short   sqltype;
    int     sqllen;
    char   *sqldata;
    short  *sqlind;
    char   *sqlname;
    char   *sqlformat;
    short   sqlitype;
    short   sqlilen;
    char   *sqlidata;
    int     sqlxid;
    char   *sqltypename;
    short   sqltypelen;
    short   sqlownerlen;
    short   sqlsourcetype;
    char   *sqlownername;
    int     sqlsourceid;
    char   *sqlilongdata;
    int     sqlflags;
    void   *sqlreserved;
};

struct sqlda_compat
{
    short  sqld;
    struct sqlvar_compat *sqlvar;
    char   desc_name[19];
    short  desc_occ;
    struct sqlda_compat *desc_next;
    void  *reserved;
};

typedef struct sqlvar_compat    sqlvar_t;
typedef struct sqlda_compat     sqlda_t;
   </programlisting>
  </para>

  <para>
   Les propriétés globales sont:
   <variablelist>

    <varlistentry>
     <term><literal>sqld</literal></term>
     <listitem>
      <para>
       Le nombre de champs dans le descripteur <literal>SQLDA</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>sqlvar</literal></term>
     <listitem>
      <para>
       Un pointeur vers les propriétés par champ.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>desc_name</literal></term>
     <listitem>
      <para>
       Inutilisé, rempli d'octets à zéro.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>desc_occ</literal></term>
     <listitem>
      <para>
       La taille de la structure allouée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>desc_next</literal></term>
     <listitem>
      <para>
       Un pointeur vers la structure SQLDA suivante si le jeu de
       résultat contient plus d'un enregistrement.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>reserved</literal></term>
     <listitem>
      <para>
       Pointeur inutilisé, contient NULL. Gardé pour la compatibilité
       Informix.
      </para>
     </listitem>
    </varlistentry>

   </variablelist>

   Les propriétés par champ sont ci-dessous, elles sont stockées
   dans le tableau <literal>sqlvar</literal>:

   <variablelist>

    <varlistentry>
     <term><literal>sqltype</literal></term>
     <listitem>
      <para>
       Type du champ. Les constantes sont dans
       <literal>sqltypes.h</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>sqllen</literal></term>
     <listitem>
      <para>
       La longueur du champ de données.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>sqldata</literal></term>
     <listitem>
      <para>
       Un pointeur vers le champ de données. Ce pointeur est de type
       <literal>char*</literal>, la donnée pointée par lui est en
       format binaire. Par exemple:
       <programlisting>
int intval;

switch (sqldata->sqlvar[i].sqltype)
{
    case SQLINTEGER:
        intval = *(int *)sqldata->sqlvar[i].sqldata;
        break;
  ...
}
       </programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>sqlind</literal></term>
     <listitem>
      <para>
       Un pointeur vers l'indicateur NULL. Si retourné par DESCRIBE
       ou FETCH alors c'est toujours un pointeur valide. Si utilisé
       comme valeur d'entrée pour <literal>EXECUTE ... USING
        sqlda;</literal> alors une valeur de pointeur NULL signifie
       que la valeur pour ce champ est non nulle. Sinon, un pointeur
       valide et <literal>sqlitype</literal> doivent être positionnés
       correctement. Par exemple:
       <programlisting>
if (*(int2 *)sqldata->sqlvar[i].sqlind != 0)
    printf("value is NULL\n");
       </programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>sqlname</literal></term>
     <listitem>
      <para>
       Le nom du champ. Chaîne terminée par 0.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>sqlformat</literal></term>
     <listitem>
      <para>
       Réservé dans Informix, valeurs de <xref linkend="libpq-PQfformat"/> pour le champ.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>sqlitype</literal></term>
     <listitem>
      <para>
       Type de l'indicateur de données NULL. C'est toujours SQLSMINT
       quand les données sont retournées du serveur. Quand la
       <literal>SQLDA</literal> est utilisée pour une requête
       paramétrique, la donnée est traitée en fonction du type de
       donnée positionné.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>sqlilen</literal></term>
     <listitem>
      <para>
       Longueur de l'indicateur de données NULL.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>sqlxid</literal></term>
     <listitem>
      <para>
       Type étendu du champ, résultat de <xref linkend="libpq-PQftype"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>sqltypename</literal></term>
     <term><literal>sqltypelen</literal></term>
     <term><literal>sqlownerlen</literal></term>
     <term><literal>sqlsourcetype</literal></term>
     <term><literal>sqlownername</literal></term>
     <term><literal>sqlsourceid</literal></term>
     <term><literal>sqlflags</literal></term>
     <term><literal>sqlreserved</literal></term>
     <listitem>
      <para>
       Inutilisé.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>sqlilongdata</literal></term>
     <listitem>
      <para>
       C'est égal à <literal>sqldata</literal> si <literal>sqllen</literal>
       est plus grand que 32nbsp;ko.
      </para>
     </listitem>
    </varlistentry>

   </variablelist>

   Par exemple:
   <programlisting>
EXEC SQL INCLUDE sqlda.h;

    sqlda_t        *sqlda; /* Ceci n'a pas besoin d'être dans la DECLARE SECTION embarquée */

    EXEC SQL BEGIN DECLARE SECTION;
    char *prep_stmt = "select * from table1";
    int i;
    EXEC SQL END DECLARE SECTION;

    ...

    EXEC SQL PREPARE mystmt FROM :prep_stmt;

    EXEC SQL DESCRIBE mystmt INTO sqlda;

    printf("# of fields: %d\n", sqlda-&gt;sqld);
    for (i = 0; i &lt; sqlda-&gt;sqld; i++)
      printf("field %d: \"%s\"\n", sqlda-&gt;sqlvar[i]-&gt;sqlname);

    EXEC SQL DECLARE mycursor CURSOR FOR mystmt;
    EXEC SQL OPEN mycursor;
    EXEC SQL WHENEVER NOT FOUND GOTO out;

    while (1)
    {
      EXEC SQL FETCH mycursor USING sqlda;
    }

    EXEC SQL CLOSE mycursor;

    free(sqlda); /* La structure principale doit être totalement libérée par free()
                  * sqlda and sqlda-&gt;sqlvar sont dans une seule zone allouée */
   </programlisting>
   Pour plus d'informations, voyez l'entête
   <literal>sqlda.h</literal> et le test de non-régression
   <literal>src/interfaces/ecpg/test/compat_informix/sqlda.pgc</literal>.
  </para>
 </sect2>

 <sect2 id="ecpg-informix-functions">
  <title>Fonctions Additionnelles</title>
  <para>
   <variablelist>
    <varlistentry>
     <term><function>decadd</function></term>
     <listitem>
      <para>
       Ajoute deux valeurs décimales.
       <synopsis>
int decadd(decimal *arg1, decimal *arg2, decimal *sum);
       </synopsis>
       La fonction reçoit un poiteur sur la première opérande de
       type decimal (<literal>arg1</literal>), un pointeur sur la
       seconde opérande de type decimal (<literal>arg2</literal>)
       et un pointeur sur la valeur de type decimal qui contiendra la
       somme (<literal>sum</literal>). En cas de succès, la fonction
       retourne 0. <symbol>ECPG_INFORMIX_NUM_OVERFLOW</symbol>
       est retourné en cas de dépassement et
       <symbol>ECPG_INFORMIX_NUM_UNDERFLOW</symbol> en cas de
       soupassement. -1 est retourné pour les autres échecs et
       <varname>errno</varname> est positionné au nombre correspondant
       <varname>errno</varname> de pgtypeslib.
       pgtypeslib.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>deccmp</function></term>
     <listitem>
      <para>
       Compare deux variables de type decimal.
       <synopsis>
int deccmp(decimal *arg1, decimal *arg2);
       </synopsis>
       La fonction reçoit un pointeur vers la première valeur decimal (<literal>arg1</literal>), un pointeur vers la seconde valeur decimal (<literal>arg2</literal>) et retourne une valeur entière qui indique quelle elle la plus grosse valeur.
       <itemizedlist>
        <listitem>
         <para>
          1, si la valeur pointée par <literal>arg1</literal> est plus grande que
          celle pointée par <literal>arg2</literal>.
         </para>
        </listitem>
        <listitem>
         <para>
          -1 si la valeur pointée par <literal>arg1</literal> est plus
          petite que la valeur pointée par <literal>arg2</literal>.
         </para>
        </listitem>
        <listitem>
         <para>
          0 si les deux valeurs pointées par <literal>arg1</literal>
          et <literal>arg2</literal> sont égales.
         </para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>deccopy</function></term>
     <listitem>
      <para>
       Copie une valeur decimal.
       <synopsis>
void deccopy(decimal *src, decimal *target);
       </synopsis>
       La fonction reçoit un pointeur vers la valeur decimal qui doit
       être copiée comme premier argument (<literal>src</literal>)
       et un pointeur vers la structure de type décimale cible
       (<literal>target</literal>) comme second argument.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>deccvasc</function></term>
     <listitem>
      <para>
       Convertit une valeur de sa représentation ASCII vers un type decimal.
       <synopsis>
int deccvasc(char *cp, int len, decimal *np);
       </synopsis>
       La fonction reçoit un pointeur vers une chaîne
       qui contient la représentation chaîne du nombre à
       convertir (<literal>cp</literal>) ainsi que sa longueur
       <literal>len</literal>. <literal>np</literal> est un pointeur
       vers la valeur decimal dans laquelle sauver le résultat de
       l'opération.
      </para>
      <para>
       Voici quelques formats valides:
       <literal>-2</literal>,
       <literal>.794</literal>,
       <literal>+3.44</literal>,
       <literal>592.49E07</literal> ou
       <literal>-32.84e-4</literal>.
      </para>
      <para>
       La fonction retourne 0 en cas de succès. Si un
       dépassement ou un soupassement se produisent,
       <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal>
       ou <literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal> est
       retourné. Si la représentation ASCII n'a pas pu être
       interprétée, <literal>ECPG_INFORMIX_BAD_NUMERIC</literal> est retourné
       ou <literal>ECPG_INFORMIX_BAD_EXPONENT</literal> si le problème
       s'est produit lors de l'analyse de l'exposant.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>deccvdbl</function></term>
     <listitem>
      <para>
       Convertit une valeur de type double vers une valeur de type decimal.
       <synopsis>
int deccvdbl(double dbl, decimal *np);
       </synopsis>
       La fonction reçoit la variable de type double qui devrait être
       convertie comme premier argument (<literal>dbl</literal>). Comme
       second argument (<literal>np</literal>), la fonction reçoit
       un pointeur vers la variable decimal qui recevra le résultat
       de l'opération.
      </para>
      <para>
       La fonction retourne 0 en cas de succès et une valeur négative si
       la conversion a échoué.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>deccvint</function></term>
     <listitem>
      <para>
       Convertit une valeur de type int vers une valeur de type decimal.
       <synopsis>
int deccvint(int in, decimal *np);
       </synopsis>
       La fonction reçoit la variable de type int à convertir comme
       premier argument (<literal>in</literal>). Comme second argument
       (<literal>np</literal>), la fonction reçoit un pointeur vers
       la variable decimal qui recevra le résultat de l'opération.
      </para>
      <para>
       La fonction retourne 0 en cas de succès et une valeur négative si
       la conversion a échoué.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>deccvlong</function></term>
     <listitem>
      <para>
       Convertit une valeur de type long vers une valeur de type decimal.
       <synopsis>
int deccvlong(long lng, decimal *np);
       </synopsis>
       La fonction reçoit la variable de type long à convertir comme
       premier argument (<literal>lng</literal>). Comme second argument
       (<literal>np</literal>), la fonction reçoit un pointeur vers
       la variable decimal qui recevra le résultat de l'opération.
      </para>
      <para>
       La fonction retourne 0 en cas de succès et une valeur négative si
       la conversion a échoué.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>decdiv</function></term>
     <listitem>
      <para>
       Divise deux variables de type decimal.
       <synopsis>
int decdiv(decimal *n1, decimal *n2, decimal *result);
       </synopsis>
       La fonction reçoit des pointeurs vers les deux
       variables qui sont le premier (<literal>n1</literal>)
       et le second (<literal>n2</literal>) opérandes et
       calcule <literal>n1</literal>/<literal>n2</literal>.
       <literal>result</literal> est un pointeur vers la variable qui
       recevra le résultat de l'opération.
      </para>
      <para>
       En cas de succès, 0 est retourné, et une valeur négative si la
       division échoue.  En cas de dépassement ou de soupassement, la
       fonction retourne <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> ou
       <literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal> respectivement. Si
       une tentative de division par zéro se produit, la fonction
       retourne <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>decmul</function></term>
     <listitem>
      <para>
       Multiplie deux valeurs decimal.
       <synopsis>
int decmul(decimal *n1, decimal *n2, decimal *result);
       </synopsis>
       La fonction reçoit des pointeurs vers les deux
       variables qui sont le premier (<literal>n1</literal>)
       et le second (<literal>n2</literal>) opérandes et
       calcule <literal>n1</literal>/<literal>n2</literal>.
       <literal>result</literal> est un pointeur vers la variable qui
       recevra le résultat de l'opération.
      </para>
      <para>
       En cas de succès, 0 est retourné, et une valeur négative si la
       division échoue.  En cas de dépassement ou de soupassement, la
       fonction retourne <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> ou
       <literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal> respectivement.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>decsub</function></term>
     <listitem>
      <para>
       Soustrait une valeur decimal d'une autre.
       <synopsis>
int decsub(decimal *n1, decimal *n2, decimal *result);
       </synopsis>
       La fonction reçoit des pointeurs vers les deux
       variables qui sont le premier (<literal>n1</literal>)
       et le second (<literal>n2</literal>) opérandes et
       calcule <literal>n1</literal>/<literal>n2</literal>.
       <literal>result</literal> est un pointeur vers la variable qui
       recevra le résultat de l'opération.
      </para>
      <para>
       En cas de succès, 0 est retourné, et une valeur négative si la
       division échoue.  En cas de dépassement ou de soupassement, la
       fonction retourne <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> ou
       <literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal> respectivement.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>dectoasc</function></term>
     <listitem>
      <para>
       Convertit une variable de type decimal vers sa représentation
       ASCII sous forme de chaîne C char*.
       <synopsis>
int dectoasc(decimal *np, char *cp, int len, int right)
       </synopsis>
       La fonction reçoit un pointeur vers une variable de type
       decimal (<literal>np</literal>) qu'elle convertit vers
       sa représentation textuelle. <literal>cp</literal> est le
       tampon qui devra contenir le résultat de l'opération. Le
       paramètre <literal>right</literal> spécifie combien de
       chiffres après la virgule doivent être inclus dans la
       sortie. Le résultat sera arrondi à ce nombre de chiffres
       décimaux. Positionner <literal>right</literal> à -1 indique
       que tous les chiffres décimaux disponibles devraient être
       inclus dans la sortie. Si la longueur du tampon de sortie, qui
       est indiquée par <literal>len</literal> n'est pas suffisante
       pour contenir toute la représentation en incluant le caractère
       NUL final, seul un caractère unique <literal>*</literal> est
       stocké dans le résultat, et -1 est retourné.
      </para>
      <para>
       La fonction retourne -1 si le tampon <literal>cp</literal> était
       trop petit ou <literal>ECPG_INFORMIX_OUT_OF_MEMORY</literal>
       si plus de mémoire n'était disponible.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>dectodbl</function></term>
     <listitem>
      <para>
       Convertit une variable de type decimal vers un double.
       <synopsis>
int dectodbl(decimal *np, double *dblp);
       </synopsis>
       La fonction reçoit un pointeur vers la valeur decimal à
       convertir (<literal>np</literal>) et un pointeur vers la
       variable double qui devra recevoir le résultat de l'opération
       (<literal>dblp</literal>).
      </para>
      <para>
       La fonction retourne 0 en cas de succès et une valeur négative si
       la conversion a échoué.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>dectoint</function></term>
     <listitem>
      <para>
       Convertit une variable de type decimal vers un integer.
       <synopsis>
int dectoint(decimal *np, int *ip);
       </synopsis>
       La fonction reçoit un pointeur vers la valeur decimal à
       convertir (<literal>np</literal>) et un pointeur vers la
       variable integer qui devra recevoir le résultat de l'opération
       (<literal>ip</literal>).
      </para>
      <para>
       La fonction retourne 0 en cas de succès et une valeur négative
       si la conversion a échoué. Si un dépassement s'est produit,
       <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> est retourné.
      </para>
      <para>
       Notez que l'implémentation d'ECPG diffère
       de celle d'<productname>Informix</productname>.
       <productname>Informix</productname> limite un integer entre
       -32767 et 32767, alors que la limite de l'implémentation d'ECPG
       dépend de l'architecture (<literal>-INT_MAX .. INT_MAX</literal>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>dectolong</function></term>
     <listitem>
      <para>
       Convertit une variable de type decimal vers un long integer.
       <synopsis>
int dectolong(decimal *np, long *lngp);
       </synopsis>
       La fonction reçoit un pointeur vers la valeur decimal à
       convertir (<literal>np</literal>) et un pointeur vers la
       variable long qui devra recevoir le résultat de l'opération
       (<literal>lngp</literal>).
      </para>
      <para>
       La fonction retourne 0 en cas de succès et une valeur négative
       si la conversion a échoué. Si un dépassement s'est produit,
       <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> est retourné.
      </para>
      <para>
       Notez que l'implémentation d'ECPG diffère
       de celle d'<productname>Informix</productname>.
       <productname>Informix</productname> limite un integer entre
       --2,147,483,647 à 2,147,483,647 alors que la limite de l'implémentation d'ECPG
       dépend de l'architecture (<literal>-LONG_MAX .. LONG_MAX</literal>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>rdatestr</function></term>
     <listitem>
      <para>
       Convertit une date vers une chaîne char* C.
       <synopsis>
int rdatestr(date d, char *str);
       </synopsis>
       La fonction reçoit deux arguments, le premier est la date à
       convertir (<literal>d</literal>) et le second est un pointeur
       vers la chaîne cible. Le format de sortie est toujours
       <literal>yyyy-mm-dd</literal>, vous aurez donc à allouer au
       moins 11 octets (en incluant le terminateur NUL) pour la chaîne.
      </para>
      <para>
       La fonction retourne 0 en cas de succès et une valeur négative
       si la conversion a échoué.
      </para>
      <para>
       Notez que l'implémentation d'ECPG diffère de
       celle de <productname>Informix</productname>. Dans
       <productname>Informix</productname> le format peut être modifié
       par le positionnement de variable d'enregistrement. Dans ECPG
       par contre, vous ne pouvez pas changer le format de sortie.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>rstrdate</function></term>
     <listitem>
      <para>
       Convertit la représentation textuelle d'une date.
       <synopsis>
int rstrdate(char *str, date *d);
       </synopsis>
       La fonction reçoit la représentation textuelle d'une date
       à convertir (<literal>str</literal>) et un pointeur vers une
       variable de type date (<literal>d</literal>). Cette fonction ne
       vous permet pas de fournir un masque de formatage. Il utilise
       le format par défaut d'<productname>Informix</productname> qui
       est <literal>mm/dd/yyyy</literal>. En interne, cette fonction est
       implémentée au travers de <function>rdefmtdate</function>. Par
       conséquent, <function>rstrdate</function> n'est pas plus
       rapide et si vous avez le choix, vous devriez opter pour
       <function>rdefmtdate</function>, qui vous permet de spécifier
       le masque de formatage explicitement.
      </para>
      <para>
       La fonction retourne les mêmes valeurs que <function>rdefmtdate</function>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>rtoday</function></term>
     <listitem>
      <para>
       Récupère la date courante.
       <synopsis>
void rtoday(date *d);
       </synopsis>
       La fonction reçoit un poiteur vers une variable de type date
       (<literal>d</literal>) qu'elle positionne à la date courante.
      </para>
      <para>
       En interne, cette fonction utilise la fonction <xref
       linkend="pgtypesdatetoday"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>rjulmdy</function></term>
     <listitem>
      <para>
       Extrait les valeurs pour le jour, le mois et l'année d'une
       variable de type date.
       <synopsis>
int rjulmdy(date d, short mdy[3]);
       </synopsis>
       La fonction reçoit la date <literal>d</literal>
       et un pointeur vers un tableau de 3 entiers courts
       <literal>mdy</literal>. Le nom de la variable indique l'ordre
       séquentiel: <literal>mdy[0]</literal> contiendra le numéro du
       mois, <literal>mdy[1]</literal> contiendra le numéro du jour,
       et <literal>mdy[2]</literal> contiendra l'année.
      </para>
      <para>
       La fonction retourne toujours 0 pour le moment.
      </para>
      <para>
       En interne, cette fonction utilise la fonction <xref
       linkend="pgtypesdatejulmdy"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>rdefmtdate</function></term>
     <listitem>
      <para>
       Utilise un masque de formatage pour convertir une chaîne de
       caractère vers une valeur de type date.
       <synopsis>
int rdefmtdate(date *d, char *fmt, char *str);
       </synopsis>
       La fonction reçoit un pointeur vers une valeur date qui devra
       contenir le résultat de l'opération (<literal>d</literal>),
       le masque de formatage à utiliser pour traiter la date
       (<literal>fmt</literal>) et la chaîne de caractère char*
       C qui contient la représentation textuelle de la date
       (<literal>str</literal>). La représentation textuelle
       doit correspondre au masque de formatage. La fonction
       n'analyse qu'en ordre séquentiel et recherche les littéraux
       <literal>yy</literal> ou <literal>yyyy</literal> qui indiquent
       la position de l'année, <literal>mm</literal> qui indique la
       position du mois et <literal>dd</literal> qui indique la position
       du jour.
      </para>
      <para>
       La fonction retourne les valeurs suivantes:
       <itemizedlist>
        <listitem>
         <para>
          0 - La fonction s'est terminée avec succès.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>ECPG_INFORMIX_ENOSHORTDATE</literal> - La date
          ne contient pas de délimiteur entre le jour, le mois et
          l'année. Dans ce cas, la chaîne en entrée doit faire
          exactement 6 ou 8 caractères, mais ce n'est pas le cas.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>ECPG_INFORMIX_ENOTDMY</literal> - La chaîne de
          formatage n'indique pas correctement l'ordre séquentiel de
          l'année, du mois, et du jour.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>ECPG_INFORMIX_BAD_DAY</literal> - La chaîne d'entrée
          ne contient pas de jour valide.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>ECPG_INFORMIX_BAD_MONTH</literal> - La chaîne d'entrée
          ne contient pas de mois valide.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>ECPG_INFORMIX_BAD_YEAR</literal> - La chaîne d'entrée
          ne contient pas d'année valide.
         </para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
       En interne, cette fonction est implémentée en utilisant la fonction
       <xref linkend="pgtypesdatedefmtasc"/>. Voyez la référence à cet endroi
       pour la table d'exemples.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>rfmtdate</function></term>
     <listitem>
      <para>
       Convertit une variable de type date vers sa représentation
       textuelle en utilisant un masque de formatage.
       <synopsis>
int rfmtdate(date d, char *fmt, char *str);
       </synopsis>
       La fonction reçoit une date à convertir (<literal>d</literal>), le masque de formatage (<literal>fmt</literal>) et la chaîne qui contiendra la représentation textuelle de la date (<literal>str</literal>).
      </para>
      <para>
       La fonction retourne 0 en cas de succès et une valeur négative
      </para>
      <para>
       En interne, cette fonction utilise la fonction
       <xref linkend="pgtypesdatefmtasc"/>, voyez la référence pour des exemples.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>rmdyjul</function></term>
     <listitem>
      <para>
       Crée une valeur date à partir d'un tableau de 3 entiers courts
       qui spécifient le jour, le mois et l'année de la date.
       <synopsis>
int rmdyjul(short mdy[3], date *d);
       </synopsis>
       La fonction reçoit le tableau des 3 entiers courst
       (<literal>mdy</literal>) et un pointeur vers une variable de
       type date qui contiendra le résultat de l'opération.
      </para>
      <para>
       La fonction retourne toujours 0 à l'heure actuelle.
      </para>
      <para>
       En interne la fonction est implémentée en utilisant la fonction
       <xref linkend="pgtypesdatemdyjul"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>rdayofweek</function></term>
     <listitem>
      <para>
       Retourne un nombre représentant le jour de la semaine pour une valeur de date.
       <synopsis>
int rdayofweek(date d);
       </synopsis>
       La fonction reçoit la variable date <literal>d</literal> comme
       seul argument et retourne un entier qui indique le jour de la
       semaine pour cette date.
       <itemizedlist>
        <listitem>
         <para>
          0 - Dimanche
         </para>
        </listitem>
        <listitem>
         <para>
          1 - Lundi
         </para>
        </listitem>
        <listitem>
         <para>
          2 - Mardi
         </para>
        </listitem>
        <listitem>
         <para>
          3 - Mercredi
         </para>
        </listitem>
        <listitem>
         <para>
          4 - Jeudi
         </para>
        </listitem>
        <listitem>
         <para>
          5 - Vendredi
         </para>
        </listitem>
        <listitem>
         <para>
          6 - Samedi
         </para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
       En interne, cette fonction est implémentée en utilisant la fonction
       <xref linkend="pgtypesdatedayofweek"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>dtcurrent</function></term>
     <listitem>
      <para>
       Récupère le timestamp courant.
       <synopsis>
void dtcurrent(timestamp *ts);
       </synopsis>
       La fonction récupère le timestamp courant et l'enregistre dans
       la variable timestamp vers laquelle <literal>ts</literal> pointe.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>dtcvasc</function></term>
     <listitem>
      <para>
       Convertit un timestamp de sa représentation textuelle vers une
       variable timestamp.
       <synopsis>
int dtcvasc(char *str, timestamp *ts);
       </synopsis>
       La fonction reçoit la chaîne à traiter (<literal>str</literal>)
       et un pointeur vers la variable timestamp qui contiendra le
       résultat de l'opération (<literal>ts</literal>).
      </para>
      <para>
       La fonction retourne 0 en cas de succès et une valeur négative
      </para>
      <para>
       En interne, cette fonction utilise la fonction
       <xref linkend="pgtypestimestampfromasc"/>. Voyez la référence pour
       un tableau avec des exemples de formats.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>dtcvfmtasc</function></term>
     <listitem>
      <para>
       Convertit un timestamp de sa représentation textuelle vers une
       variable timestamp en utilisant un masque de formatage.
       <synopsis>
dtcvfmtasc(char *inbuf, char *fmtstr, timestamp *dtvalue)
       </synopsis>
       La fonction reçoit la chaîne à traiter
       (<literal>inbuf</literal>), le masque de formatage à utiliser
       (<literal>fmtstr</literal>) et un pointeur vers la variable
       timestamp qui contiendra le résultat de l'opération
       (<literal>dtvalue</literal>).
      </para>
      <para>
       Cette fonction est implémentée en utilisant la fonction
       <xref linkend="pgtypestimestampdefmtasc"/>. Voyez la documentation
       à cet endroit pour la liste des spécificateurs de formats qui
       peuvent être utilisés.
      </para>
      <para>
       La fonction retourne 0 en cas de succès et une valeur négative
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>dtsub</function></term>
     <listitem>
      <para>
       Soustrait un timestamp d'un autre et retourne une variable de
       type interval.
       <synopsis>
int dtsub(timestamp *ts1, timestamp *ts2, interval *iv);
       </synopsis>
       La fonction soustrait la variable timestamp vers laquelle
       <literal>ts2</literal> pointe de la variable timestamp vers
       laquelle <literal>ts1</literal> pointe et stockera le résultat
       dans la variable intervalle vers laquelle <literal>iv</literal>
       pointe.
      </para>
      <para>
       En cas de succès, la fonction retourne 0, et une valeur négative
       si une erreur s'est produite.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>dttoasc</function></term>
     <listitem>
      <para>
       Convertit une variable timestamp vers une chaîne char* C.
       <synopsis>
int dttoasc(timestamp *ts, char *output);
       </synopsis>
       La fonction reçoit un pointeur vers une variable timestamp à
       convertir (<literal>ts</literal>) et la chaîne qui devra contenir
       le résultat de l'opération (<literal>output</literal>). Elle
       convertit <literal>ts</literal> vers sa représentation textuelle
       comme spécifié par le standard SQL, qui est <literal>YYYY-MM-DD
        HH:MM:SS</literal>.
      </para>
      <para>
       En cas de succès, la fonction retourne 0, et une valeur négative
       si une erreur s'est produite.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>dttofmtasc</function></term>
     <listitem>
      <para>
       Convertit une variable timestamp vers un char* C en utilisant
       un masque de formatage.
       <synopsis>
int dttofmtasc(timestamp *ts, char *output, int str_len, char *fmtstr);
       </synopsis>
       La fonction reçoit un pointeur vers le timestamp à convertir
       comme premier argument (<literal>ts</literal>), un pointeur
       vers le tampon de sortie (<literal>output</literal>), la
       longueur maximale qui a été allouée pour le tampon de sortie
       (<literal>str_len</literal>) et le masque de formatage à utiliser
       pour la conversion (<literal>fmtstr</literal>).
      </para>
      <para>
       En cas de succès, la fonction retourne 0, et une valeur négative
       si une erreur s'est produite.
      </para>
      <para>
       En interne, cette fonction utilise la fonction
       <xref linkend="pgtypestimestampfmtasc"/>. Voyez la référence
       pour des informations sur les spécifications de masque de formatage
       qui sont utilisables.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>intoasc</function></term>
     <listitem>
      <para>
       Convertit une variable interval en chaîne char* C.
       <synopsis>
int intoasc(interval *i, char *str);
       </synopsis>
       La fonction reçoit un pointeur vers la variable interval à
       convertir (<literal>i</literal>) et la chaîne qui contiendra le
       résultat de l'opération (<literal>str</literal>). Elle convertit
       <literal>i</literal> vers sa représentation textuelle suivant
       le standard SQL, qui est <literal>YYYY-MM-DD HH:MM:SS</literal>.
      </para>
      <para>
       En cas de succès, la fonction retourne 0, et une valeur négative
       si une erreur s'est produite.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>rfmtlong</function></term>
     <listitem>
      <para>
       Convertit une valeur long integer vers sa représentation
       textuelle en utilisant un masque de formatage.
       <synopsis>
int rfmtlong(long lng_val, char *fmt, char *outbuf);
       </synopsis>
       La fonction reçoit la valeur long <literal>lng_val</literal>,
       le masque de formatage <literal>fmt</literal> et un pointeur
       vers le tampon de sortie <literal>outbuf</literal>. Il convertit
       la valeur long vers sa représentation textuelle en fonction du
       masque de formatage.
      </para>
      <para>
       Le masque de formatage peut être composé des caractères
       suivants de spécification:
       <itemizedlist>
        <listitem>
         <para>
          <literal>*</literal> (asterisk) - si cette position était blanc sans cela, mettez y un astérisque.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>&amp;</literal> (ampersand) - si cette position était blanc sans cela, mettez y un zéro.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>#</literal> - transforme les zéros initiaux en blancs.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>&lt;</literal> - justifie à gauche le nombre dans la chaîne.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>,</literal> (virgule) - Groupe les nombres de 4
          chiffres ou plus en groupes de 3 chiffres séparés par
          des virgules.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>.</literal> (point) - Ce caractère sépare la partie
          entière du nombre de sa partie fractionnaire.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>-</literal> (moins) - le signe moins apparaît si
          le nombre est négatif.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>+</literal> (plus) - le signe plus apparaît si
          le nombre est positif.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>(</literal> - ceci remplace le signe moins devant
          une valeur négative. Le signe moins n'apparaîtra pas.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>)</literal> - Ce caractère remplace le signe moins
          et est affiché après la valeur négative.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>$</literal> - le symbole monétaire.
         </para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>rupshift</function></term>
     <listitem>
      <para>
       Passe une chaîne en majuscule.
       <synopsis>
void rupshift(char *str);
       </synopsis>
       La fonction reçoit un pointeur vers une chaîne et convertit
       tous ses caractères en majuscules.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>byleng</function></term>
     <listitem>
      <para>
       Retourne le nombre de caractères dans une chaîne sans compter les blancs finaux.
       <synopsis>
int byleng(char *str, int len);
       </synopsis>
       La fonction attend une chaîne de longueur fixe comme premier
       argument (<literal>str</literal>) et sa longueur comme second
       argument (<literal>len</literal>). Elle retourne le nombre
       de caractères significatifs, c'est à dire la longueur de la
       chaîne sans ses blancs finaux.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>ldchar</function></term>
     <listitem>
      <para>
       Copie une chaîne de longueur fixe vers une chaîne terminée
       par un NUL.
       <synopsis>
void ldchar(char *src, int len, char *dest);
       </synopsis>
       La fonction reçoit la chaîne de longueur fixe
       à copier (<literal>src</literal>), sa longueur
       (<literal>len</literal>) et un pointeur vers la mémoire
       destinataire (<literal>dest</literal>). Notez que vous aurez
       besoin de réserver au moins <literal>len+1</literal> octets pour
       la chaine vers laquelle pointe <literal>dest</literal>. Cette
       fonction copie au plus <literal>len</literal> octets vers le
       nouvel emplacement (moins si la chaîne source a des blancs
       finaux) et ajoute le terminateur NUL.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>rgetmsg</function></term>
     <listitem>
      <para>
       <synopsis>
int rgetmsg(int msgnum, char *s, int maxsize);
       </synopsis>
       Cette fonction existe mais n'est pas implémentée pour le moment!
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>rtypalign</function></term>
     <listitem>
      <para>
       <synopsis>
int rtypalign(int offset, int type);
       </synopsis>
       Cette fonction existe mais n'est pas implémentée pour le moment!
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>rtypmsize</function></term>
     <listitem>
      <para>
       <synopsis>
int rtypmsize(int type, int len);
       </synopsis>
       Cette fonction existe mais n'est pas implémentée pour le moment!
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>rtypwidth</function></term>
     <listitem>
      <para>
       <synopsis>
int rtypwidth(int sqltype, int sqllen);
       </synopsis>
       Cette fonction existe mais n'est pas implémentée pour le moment!
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="rsetnull">
     <term><function>rsetnull</function></term>
     <listitem>
      <para>
       Set a variable to NULL.
       <synopsis>
int rsetnull(int t, char *ptr);
       </synopsis>
       La fonction reçoit un entier qui indique le type de variable
       et un pointeur vers la variable elle même, transtypé vers un
       pointeur char*.
      </para>
      <para>
       Les types suivants existent&nbsp;:
       <itemizedlist>
        <listitem>
         <para>
          <literal>CCHARTYPE</literal> - Pour une variable de type <type>char</type> ou <type>char*</type>
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>CSHORTTYPE</literal> - Pour une variable de type <type>short int</type>
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>CINTTYPE</literal> - Pour une variable de type <type>int</type>
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>CBOOLTYPE</literal> - Pour une variable de type <type>boolean</type>
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>CFLOATTYPE</literal> - Pour une variable de type <type>float</type>
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>CLONGTYPE</literal> - Pour une variable de type <type>long</type>
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>CDOUBLETYPE</literal> - Pour une variable de type <type>double</type>
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>CDECIMALTYPE</literal> - Pour une variable de type <type>decimal</type>
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>CDATETYPE</literal> - Pour une variable de type <type>date</type>
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>CDTIMETYPE</literal> - Pour une variable de type <type>timestamp</type>
         </para>
        </listitem>
       </itemizedlist>
      </para>

      <para>
       Voici un exemple d'appel à cette fonction:
       <programlisting><![CDATA[
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

rsetnull(CCHARTYPE, (char *) c);
rsetnull(CSHORTTYPE, (char *) &s);
rsetnull(CINTTYPE, (char *) &i);
]]>
       </programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>risnull</function></term>
     <listitem>
      <para>
       Teste si une variable est NULL.
       <synopsis>
int risnull(int t, char *ptr);
       </synopsis>
       Cette fonction reçoit le type d'une variable à tester
       (<literal>t</literal>) ainsi qu'un pointeur vers cette
       variable (<literal>ptr</literal>). Notez que ce dernier doit
       être transtypé vers un char*. Voyez la fonction <xref
       linkend="rsetnull"/> pour une liste de types de variables
       possibles.
      </para>
      <para>
       Voici un exemple de comment utiliser cette fonction:
       <programlisting><![CDATA[
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

risnull(CCHARTYPE, (char *) c);
risnull(CSHORTTYPE, (char *) &s);
risnull(CINTTYPE, (char *) &i);
]]>
       </programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </sect2>

 <sect2 id="ecpg-informix-constants">
  <title>Constantes Supplémentaires</title>
  <para>
   Notez que toutes les constantes ici décrivent des erreurs et qu'elles
   sont toutes définies pour représenter des valeurs négatives. Dans
   les descriptions des différentes constantes vous pouvez aussi trouver
   la valeur que les constantes représentent dans l'implémentation
   actuelle. Toutefois, vous ne devriez pas vous fier à ce nombre. Vous
   pouvez toutefois vous appuyer sur le faite que toutes sont définies
   comme des valeurs négatives.
   values.
   <variablelist>
    <varlistentry>
     <term><literal>ECPG_INFORMIX_NUM_OVERFLOW</literal></term>
     <listitem>
      <para>
       Les fonctions retournent cette valeur si un dépassement s'est
       produit dans un calcul. En interne, elle est définie à -1200
       (la définition <productname>Informix</productname>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal></term>
     <listitem>
      <para>
       Les fonctions retournent cette valeur si un soupassement s'est
       produit dans un calcul. En interne, elle est définie à -1201
       (la définition <productname>Informix</productname>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ECPG_INFORMIX_DIVIDE_ZERO</literal></term>
     <listitem>
      <para>
       Les fonctions retournent cette valeur si une division par zéro
       a été tentée. En interne, elle est définie à -1202
       (la définition <productname>Informix</productname>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ECPG_INFORMIX_BAD_YEAR</literal></term>
     <listitem>
      <para>
       Les fonctions retournent cette valeur si une mauvaise valeur
       pour une année a été trouvée lors de l'analyse d'une date. En
       interne elle est définie à -1204
       (la définition <productname>Informix</productname>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ECPG_INFORMIX_BAD_MONTH</literal></term>
     <listitem>
      <para>
       Les fonctions retournent cette valeur si une mauvaise valeur
       pour un mois a été trouvée lors de l'analyse d'une date. En
       interne elle est définie à -1205
       (la définition <productname>Informix</productname>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ECPG_INFORMIX_BAD_DAY</literal></term>
     <listitem>
      <para>
       Les fonctions retournent cette valeur si une mauvaise valeur
       pour un jour a été trouvée lors de l'analyse d'une date. En
       interne elle est définie à -1206
       (la définition <productname>Informix</productname>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ECPG_INFORMIX_ENOSHORTDATE</literal></term>
     <listitem>
      <para>
       Les fonctions retournent cette valeur si une routine d'analyse
       a besoin d'une représentation courte de date mais que la
       chaîne passée n'était pas de la bonne longueur. En
       interne elle est définie à -1206 (la définition
       <productname>Informix</productname>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ECPG_INFORMIX_DATE_CONVERT</literal></term>
     <listitem>
      <para>
       Les fonctions retournent cette valeur si une erreur s'est produite durant
       un formatage de date. En interne, elle est
       définie à -1210 (la définition <productname>Informix</productname>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ECPG_INFORMIX_OUT_OF_MEMORY</literal></term>
     <listitem>
      <para>
       Les fonctions retournent cette valeur si elles se sont retrouvées à
       court de mémoire durant leur fonctionnement. En interne, elle est
       définie à -1211 (la définition <productname>Informix</productname>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ECPG_INFORMIX_ENOTDMY</literal></term>
     <listitem>
      <para>
       Les fonctions retournent cette valeur si la routine d'analyse devait
       recevoir un masque de formatage (comme <literal>mmddyy</literal>) mai
       que tous les champs n'étaient pas listés correctement.
       En interne, elle est définie à -1212 (la définition <productname>Informix</productname>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ECPG_INFORMIX_BAD_NUMERIC</literal></term>
     <listitem>
      <para>
       Les fonctions retournent cette valeur soit parce qu'une routine
       d'analyse ne peut pas analyser la représentation textuelle d'une
       valeur numérique parce qu'elle contient des erreurs, soit parce
       qu'une routine ne peut pas terminer un calcul impliquant des
       variables numeric parce qu'au moins une des variables numeric est
       invalide. En interne, elle est définie à -1213 (la définition
       <productname>Informix</productname>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ECPG_INFORMIX_BAD_EXPONENT</literal></term>
     <listitem>
      <para>
       Les fonctions retournent cette valeur si elles n'ont pas
       réussi à analyser l'exposant de la représentation textuelle
       d'une valeur numérique.
       En interne, elle est définie à -1216 (la définition
       <productname>Informix</productname>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ECPG_INFORMIX_BAD_DATE</literal></term>
     <listitem>
      <para>
       Les fonctions retournent cette valeur si une chaîne de
       date invalide leur a été passée.
       En interne, elle est définie à -1218 (la définition
       <productname>Informix</productname>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ECPG_INFORMIX_EXTRA_CHARS</literal></term>
     <listitem>
      <para>
       Les fonctions retournent cette valeur si trop de caractères
       ont été trouvés dans la représentation textuelle d'un format
       date.
       En interne, elle est définie à -1264 (la définition
       <productname>Informix</productname>).
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </sect2>
</sect1>

<sect1 id="ecpg-develop">
 <title>Fonctionnement Interne</title>

 <para>
  Cette section explique comment <application>ECPG</application>
  fonctionne en interne. Cette information peut être utile pour
  comprendre comment utiliser <application>ECPG</application>.
 </para>

 <para>
  Les quatre premières lignes écrites sur la sortie par
  <command>ecpg</command> sont des lignes fixes. Deux sont des
  commentaires et deux sont des lignes d'inclusion nécessaires pour
  s'interfacer avec la librairie. Puis le préprocesseur lit le fichier
  et écrit la sortie. La plupart du temps, il répète simplement
  tout dans la sortie.
 </para>

 <para>
  Quand il voit un ordre <command>EXEC SQL</command>, il intervient
  et le modifie. La commande débute par <command>EXEC SQL</command>
  et se termine par <command>;</command>. Tout ce qui se trouve entre
  deux est traité comme un ordre <acronym>SQL</acronym> et analysé
  pour substitution de variables.
 </para>

 <para>
  Une substitution de variable se produit quand un symbole commence
  par un deux-points (<literal>:</literal>). La variable dont c'est le
  nom est recherchée parmi les variables qui ont été précédemment
  déclarées dans une section <literal>EXEC SQL DECLARE</literal>.
 </para>

 <para>
  La fonction la plus importante de la librairie est
  <function>ECPGdo</function>, qui s'occupe de l'exécution de la
  plupart des commandes. Elle prend un nombre variable d'arguments. Le
  nombre de ces arguments peut rapidement dépasser la cinquantaine, et
  nous espérons que cela ne posera de problème sur aucune plateforme.
 </para>

 <para>
  Les arguments sont:

  <variablelist>
   <varlistentry>
    <term>Un numéro de ligne</term>
    <listitem>
     <para>
      C'est le numéro de la ligne originale; c'est utilisé uniquement pour les messages d'erreu.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Une chaîne</term>
    <listitem>
     <para>
      C'est la commande <acronym>SQL</acronym> à exécuter. Elle est
      modifiée par les variables d'entrée, c'est à dire les variables
      qui n'étaient pas connues au moment de la compilation mais qui
      doivent tout de même faire partie de la commande. Aux endroits
      où ces variables doivent être positionnées, la chaîne contient
      des <literal>?</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Variables d'Entrée</term>
    <listitem>
     <para>
      Chaque variable d'entrée entraîne la création de dix
      arguments. (Voir plus bas.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>ECPGt_EOIT</parameter></term>
    <listitem>
     <para>
      Un <type>enum</type> annonçant qu'il n'y a pas de variable
      d'entrées supplémentaires.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Variables de Sortie</term>
    <listitem>
     <para>
      Chaque variable de sortie entraîne la création de dix
      arguments. (Voir plus bas.) Ces variables sont renseignées par
      la fonction.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>ECPGt_EORT</parameter></term>
    <listitem>
     <para>
      Un <type>enum</type> annonçant qu'il n'y a plus de variables.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </para>

 <para>
  Pour chaque variable qui fait partie d'une commande
  <acronym>SQL</acronym>, la fonction reçoit dix arguments:

  <orderedlist>
   <listitem>
    <para>
     Le type sous forme de symbole spécial.
    </para>
   </listitem>

   <listitem>
    <para>
     Un pointeur vers la valeur ou un pointeur vers le pointeur.
    </para>
   </listitem>

   <listitem>
    <para>
     La taille de la variable si elle est <type>char</type> ou <type>varchar</type>.
    </para>
   </listitem>

   <listitem>
    <para>
     Le nombre d'éléments du tableau (pour les fetch sur tableau).
    </para>
   </listitem>

   <listitem>
    <para>
     Le décalage vers le prochain élément du tableau (pour les fetch sur tableau).
    </para>
   </listitem>

   <listitem>
    <para>
     Le type de la variable indicateur sous forme de symbole special.
    </para>
   </listitem>

   <listitem>
    <para>
     Un pointeur vers la variable indicateur.
    </para>
   </listitem>

   <listitem>
    <para>
     0
    </para>
   </listitem>

   <listitem>
    <para>
     Le nombre d'éléments du tableau d'indicateurs (pour les fetch sur tableau).
    </para>
   </listitem>

   <listitem>
    <para>
     Le décalage vers le prochain élément du tableau d'indicateurs (pour
     les fetch sur tableau).
    </para>
   </listitem>
  </orderedlist>
 </para>

 <para>
  Notez que toutes les commandes SQL ne sont pas traitées de cette
  façon. Par exemple, un ordre d'ouverture de curseur comme:
  <programlisting>
EXEC SQL OPEN <replaceable>cursor</replaceable>;
  </programlisting>
  n'est pas copié vers la sortie. À la place, la commande de curseur
  <command>DECLARE</command> est utilisée à l'endroit de la commande
  <command>OPEN</command> parce qu'elle ouvre effectivement le curseur.
 </para>

 <para>
  Voici un exemple complet expliquant la sortie du préprocesseur sur
  un fichier <filename>foo.pgc</filename> (quelques détails pourraient
  changer en fonction de la version exacte du préprocesseur):
  <programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int index;
int result;
EXEC SQL END DECLARE SECTION;
...
EXEC SQL SELECT res INTO :result FROM mytable WHERE index = :index;
  </programlisting>
  est traduit en&nbsp;:
  <programlisting><![CDATA[
/* Processed by ecpg (2.6.0) */
/* These two include files are added by the preprocessor */
#include <ecpgtype.h>;
#include <ecpglib.h>;

/* exec sql begin declare section */

#line 1 "foo.pgc"

 int index;
 int result;
/* exec sql end declare section */
...
ECPGdo(__LINE__, NULL, "SELECT res FROM mytable WHERE index = ?     ",
        ECPGt_int,&(index),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EOIT,
        ECPGt_int,&(result),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
#line 147 "foo.pgc"
]]>
  </programlisting>
  (L'indentation est ajoutée ici pour améliorer la lisibilité et
  n'est pas quelque chose que le préprocesseur effectue).
 </para>
</sect1>
</chapter>
