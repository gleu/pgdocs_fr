<?xml version="1.0" encoding="UTF-8"?>
<refentry id="pgupgrade">
 <indexterm zone="pgupgrade">
  <primary>pg_upgrade</primary>
 </indexterm>

 <refmeta>
  <refentrytitle><application>pg_upgrade</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>pg_upgrade</refname>
  <refpurpose>met à jour une instance de serveur <productname>PostgreSQL</productname></refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <cmdsynopsis>
   <command>pg_upgrade</command>
   <arg choice="plain"><option>-b</option></arg>
   <arg choice="plain"><replaceable>ancien_dir_exec</replaceable></arg>
   <arg choice="plain"><option>-B</option></arg>
   <arg choice="plain"><replaceable>nouveau_dir_exec</replaceable></arg>
   <arg choice="plain"><option>-d</option></arg>
   <arg choice="plain"><replaceable>ancien_dir_donnees</replaceable></arg>
   <arg choice="plain"><option>-D</option></arg>
   <arg choice="plain"><replaceable>nouveau_dir_donnees</replaceable></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <application>pg_upgrade</application> (auparavant appelé <application>pg_migrator</application>) permet
   la mise à jour des fichiers de données d'une version majeure de
   <productname>PostgreSQL</productname> vers une autre version majeure sans
   nécessiter la partie sauvegarde/restauration typiquement requise pour les
   mises à jour majeures, par exemple de la version 8.4.7 à la version majeure
   courante de <productname>PostgreSQL</productname>. Cet outil n'est pas
   utile pour les mises à jour mineures, par exemple pour une migration de la
   9.0.1 à la 9.0.4.
  </para>

  <para>
   Les versions majeures de PostgreSQL ajoutent régulièrement de nouvelles
   fonctionnalités qui modifient la composition des tables systèmes. Par contre,
   le format de stockage des données change rarement.
   <application>pg_upgrade</application> utilise cette information pour réaliser
   des mises à jour rapides en créant les nouvelles tables systèmes et en
   réutilisant les anciens fichiers de données utilisateurs. Si une version
   majeure future change le format des données d'une façon qui rend l'ancien
   format illisible, <application>pg_upgrade</application> ne sera pas
   utilisable pour ces mises à jour. (La communauté tente d'éviter ce type de
   situation.)
  </para>

  <para>
   <application>pg_upgrade</application> fait de son mieux pour s'assurer que
   les clusters, ancien et nouveau, soient compatibles
   binairement, c'est-à-dire en vérificant les paramètres de temps modifiables
   à la compilation, en incluant les binaires 32/64 bits. Il est important que
   tout module externe soit aussi
   compatible binairement, bien que cela ne soit pas vérifié
   <application>pg_upgrade</application>.
  </para>

  <para>
   pg_upgrade supporte la mise à jour de version 8.3.X et ultérieures vers la
   dernière version majeure de <productname>PostgreSQL</productname>, ceci
   incluant les versions intermédiaires (snapshots) et les versions alpha.
  </para>

 </refsect1>

 <refsect1>
  <title>Options</title>

  <para>
   <application>pg_upgrade</application> accepte les arguments suivant en
   ligne de commande&nbsp;:

   <variablelist>

    <varlistentry>
     <term><option>-b</option> <replaceable>direxec</replaceable></term>
     <term><option>--old-bindir=</option><replaceable>direxec</replaceable></term>
     <listitem><para>indique le répertoire des exécutables de l'ancienne
       version de PostgreSQL&nbsp;; variable d'environnement
       <envar>PGBINOLD</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-B</option> <replaceable>direxec</replaceable></term>
     <term><option>--new-bindir=</option><replaceable>direxec</replaceable></term>
     <listitem><para>indique le répertoire des exécutables de la nouvelle
       version de PostgreSQL&nbsp;; variable d'environnement
       <envar>PGBINNEW</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-c</option></term>
     <term><option>--check</option></term>
     <listitem><para>vérifie seulement les instances, ne modifie pas les
       données</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-d</option> <replaceable>repdonnées</replaceable></term>
     <term><option>--old-datadir=</option><replaceable>repdonnées</replaceable></term>
     <listitem><para>indique le répertoire des données de l'ancienne
       instance&nbsp;; variable d'environnement <envar>PGDATAOLD</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-D</option> <replaceable>repdonnées</replaceable></term>
     <term><option>--new-datadir=</option><replaceable>repdonnées</replaceable></term>
     <listitem><para>indique le répertoire des données de la nouvelle
       instance&nbsp;; variable d'environnement <envar>PGDATANEW</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-j</option></term>
     <term><option>--jobs</option></term>
     <listitem><para>nombre de processus ou threads simultanés à utiliser</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-k</option></term>
     <term><option>--link</option></term>
     <listitem><para>utilise des liens plutôt que de copier les fichiers vers
       la nouvelle instance</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-o</option> <replaceable class="parameter">options</replaceable></term>
     <term><option>--old-options</option> <replaceable class="parameter">options</replaceable></term>
     <listitem><para>options à fournir directement à l'ancienne commande <command>postgres</command></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-O</option> <replaceable class="parameter">options</replaceable></term>
     <term><option>--new-options</option> <replaceable class="parameter">options</replaceable></term>
     <listitem><para>options à fournir directement à la nouvelle commande <command>postgres</command></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-p</option> <replaceable>port</replaceable></term>
     <term><option>--old-port=</option><replaceable>port</replaceable></term>
     <listitem><para>indique le numéro de port de l'ancienne
       instance&nbsp;; variable d'environnement <envar>PGPORTOLD</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-P</option> <replaceable>port</replaceable></term>
     <term><option>--new-port=</option><replaceable>port</replaceable></term>
     <listitem><para>indique le numéro de port de la nouvelle
       instance&nbsp;; variable d'environnement <envar>PGPORTNEW</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-r</option></term>
     <term><option>--retain</option></term>
     <listitem><para>conserve les fichiers SQL et les journaux applicatifs,
       y compris en cas d'exécution réussie.
      </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-u</option> <replaceable>nom_utilisateur</replaceable></term>
     <term><option>--user=</option><replaceable>nom_utilisateur</replaceable></term>
     <listitem><para>superutilisateur de l'instance&nbsp;;variable
       d'environnement <envar>PGUSER</envar></para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-v</option></term>
     <term><option>--verbose</option></term>
     <listitem><para>active les traces internes</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-V</option></term>
     <term><option>--version</option></term>
     <listitem><para>affiche la version puis quitte</para></listitem>
    </varlistentry>

    <varlistentry>
     <term><option>-?</option></term>
     <term><option>--help</option></term>
     <listitem><para>affiche l'aide puis quitte</para></listitem>
    </varlistentry>

   </variablelist>
  </para>

 </refsect1>

 <refsect1>
  <title>Usage</title>

  <para>
   Ci-après sont décrites les étapes permettant de réaliser une mise à jour
   avec <application>pg_upgrade</application>&nbsp;:
  </para>

  <procedure>
   <step performance="optional">
    <title>Si nécessaire, déplacez l'ancienne instance</title>

    <para>
     Si vous utilisez un répertoire d'installation spécifique à la version,
     par exemple <filename>/opt/PostgreSQL/9.1</filename>, vous n'avez pas besoin de déplacer
     l'ancien répertoire de l'instance. Les installeurs graphiques utilisent
     tous des répertoires d'installation spécifiques à la version.
    </para>

    <para>
     Si votre répertoire d'installation n'est pas spécifique à la version,
     par exemple <filename>/usr/local/pgsql</filename>, il est nécessaire de déplacer le répertoire
     d'installation actuelle de PostgreSQL pour qu'il n'interfère pas avec la
     nouvelle installation de <productname>PostgreSQL</productname>. Une fois
     que le serveur actuel <productname>PostgreSQL</productname> est arrêté,
     il est bon de renommer le répertoire d'installation de PostgreSQL&nbsp;;
     en supposant que l'ancien répertoire est <filename>/usr/local/pgsql</filename>, vous pouvez
     saisir ceci&nbsp;:

     <programlisting>
mv /usr/local/pgsql /usr/local/pgsql.old
     </programlisting>
     pour renommer le répertoire.
    </para>
   </step>

   <step>
    <title>Pour une installation par les sources, construisez la nouvelle version</title>

    <para>
     Construisez la nouvelle version de PostgreSQL avec des options de
     compilation compatibles avec l'ancienne instance.
     <application>pg_upgrade</application> utilisera
     <command>pg_controldata</command> pour vérifier que tous les paramètres
     sont compatibles avant de lancer la mise à jour.
    </para>
   </step>

   <step>
    <title>Installez les nouveaux exécutables de PostgreSQL</title>

    <para>
     Installez les nouveaux exécutables du serveur ainsi que les fichiers de
     support.
    </para>

    <para>
     Pour les installations à partir des sources, si vous préférez installer
     le nouveau serveur dans un emplacement particulier, utilisez le mot clé
     <literal>prefix</literal>&nbsp;:

     <programlisting>
make prefix=/usr/local/pgsql.new install
     </programlisting>
    </para>
   </step>

   <step>
    <title>Installez pg_upgrade et pg_upgrade_support</title>
    <para>
     Installez l'exécutable <application>pg_upgrade</application> et la
     bibliothèque
     <application>pg_upgrade_support</application> dans la nouvelle installation
     de PostgreSQL
    </para>
   </step>

   <step>
    <title>Initialisez la nouvelle instance PostgreSQL</title>

    <para>
     Initialisez la nouvelle instance avec <command>initdb</command>.
     Encore une fois, utilisez des options d'<command>initdb</command> qui
     correspondent à celles
     de l'ancienne instance. Beaucoup d'installeurs font cette étape
     automatiquement. Il n'est pas nécessaire de démarrer la nouvelle
     instance.
    </para>
   </step>

   <step>
    <title>Installez les fichiers objets partagés personnalisés (ou DLL)</title>

    <para>
     Installez tous fichiers objets partagés personnalisés (ou DLL) utilisés
     par l'ancien cluster dans le nouveau cluster, par exemple
     <filename>pgcrypto.so</filename>, qu'ils proviennent des modules
     <filename>contrib</filename> ou de toute autre source. N'installez pas
     les définitions du schéma, par exemple <command>CREATE EXTENSION pgcrypto</command>,
     car elles seront aussi mises à jour à partir de l'ancien cluster.
     De plus, tous les fichiers personnalisés de la recherche plein texte
     (dictionnaire, synonyme, thésaurus, mots d'arrêt) doivent aussi être copiés
     dans la nouvelle instance.
    </para>
   </step>

   <step>
    <title>Ajustez l'authentification</title>

    <para>
     <command>pg_upgrade</command> se connectera à l'ancien et au nouveau
     serveurs plusieurs fois. Vous devez donc configurer l'authentification à
     <literal>peer</literal> dans <filename>pg_hba.conf</filename> ou
     configurer un fichier <filename>~/.pgpass</filename>
     (voir <xref linkend="libpq-pgpass"/> pour les détails).
    </para>
   </step>

   <step>
    <title>Arrêtez les deux serveurs</title>

    <para>
     Assurez-vous que les deux serveurs de bases de données sont stoppés. Pour
     cela, vous pouvez utiliser la commande suivante sous Unix&nbsp;:

     <programlisting>
pg_ctl -D /opt/PostgreSQL/8.4 stop
pg_ctl -D /opt/PostgreSQL/9.0 stop
     </programlisting>

     et la commande suivante sous Windows (en utilisant les bons noms de
     service)&nbsp;:

     <programlisting>
NET STOP postgresql-8.4
NET STOP postgresql-9.0
     </programlisting>

     ou encore&nbsp;:

     <programlisting>
NET STOP pgsql-8.3  (<productname>PostgreSQL</productname> 8.3 et antérieurs
utilisent un autre nom de service)
     </programlisting>
    </para>
   </step>

   <step>
    <title>Exécutez <application>pg_upgrade</application></title>

    <para>
     Exécutez toujours le binaire <application>pg_upgrade</application> dans
     le nouveau serveur, pas l'ancien. <application>pg_upgrade</application>
     nécessite de spécifier les repértoires de l'instance
     (<varname>PGDATA</varname>) et des exécutables pour l'ancien et la
     nouvelle instance (<filename>bin</filename>). Vous pouvez aussi indiquer des valeurs
     pour l'utilisateur et le port, et si vous voulez que les données soient
     ajoutées par lien ou par copie (cette dernière étant la valeur par
     défaut).
    </para>

    <para>
     Si vous utilisez les liens, la mise à jour sera bien plus rapide
     (pas de copie de données) et utilisera moins d'espace disque,
     mais vous ne serez plus capable d'accéder à
     votre ancienne instance une fois que vous aurez démarré la nouvelle
     instance après la mise à jour. Le mode des liens nécessite aussi
     que les répertoires des données de l'ancienne et de la nouvelle
     instances soient situés sur le même système de fichiers. (Les tablespaces
     et le répertoire <filename>pg_xlog</filename> peuvent être sur des systèmes de
     fichiers différents.) Voir
     <literal>pg_upgrade --help</literal> pour une liste complète des
     options.
    </para>

    <para>
     L'option <option>--jobs</option> permet l'utilisation de plusieurs
     processeurs pour la copie ou la création de liens des fichiers, et pour
     la sauvegarde et la restauration parallélisés des schémas des bases.
     Une bonne valeur pour commencer correspond au nombre de processeurs et
     de tablespaces. Cette option peut réduire très fortement la durée de mise
     à jour d'un serveur contenant plusieurs bases de données et s'exécutant
     sur une machine multiprocesseurs.
    </para>

    <para>
     Pour les utilisateurs Windows, vous devez être connecté avec un compte
     administrateur, puis lancé un shell en tant qu'utilisateur <literal>postgres</literal> et
     configuré la variable PATH correctement&nbsp;:

     <programlisting>
RUNAS /USER:postgres "CMD.EXE"
SET PATH=%PATH%;C:\Program Files\PostgreSQL\9.0\bin;
     </programlisting>

     Enfin, vous lancez <application>pg_upgrade</application> avec les noms
     des répertoires entre guillemets doubles, par exemple&nbsp;:

     <programlisting>
pg_upgrade.exe
        --old-datadir "C:/Program Files/PostgreSQL/8.4/data"
        --new-datadir "C:/Program Files/PostgreSQL/9.0/data"
        --old-bindir "C:/Program Files/PostgreSQL/8.4/bin"
        --new-bindir "C:/Program Files/PostgreSQL/9.0/bin"
     </programlisting>

     Une fois lancé, <command>pg_upgrade</command> vérifiera que les deux instances sont
     compatibles puis lancera la mise à jour. vous pouvez utiliser <command>pg_upgrade
      --check</command> pour ne faire que les vérifications, même si
     l'ancienne installation est en cours d'exécution. <command>pg_upgrade
      --check</command> indiquera aussi tout ajustement manuel que vous
     devrez faire après la mise à jour. <command>pg_upgrade</command> réclame
     des droits en écriture dans le répertoire courant. Si vous devez utiliser
     le mode lien, vous devez utiliser l'option <option>--check</option> pour
     activer les vérifications spécifiques au mode lien.
    </para>

    <para>
     Évidemment, personne ne doit accéder aux instances pendant la mise
     à jour. Par défaut, <application>pg_upgrade</application> lance les
     serveurs sur le port 50432 pour éviter les connexions clientes non
     désirées. Vous pouvez utiliser le même numéro de port pour chaque instance
     lors d'une mise à jour car l'ancienne et la nouvelle instance ne seront pas
     lancées en même temps. Cependant, lors de la vérification d'un ancien serveur
     en cours d'exécution, l'ancien et le nouveau numéro de port doivent être
     différents.
    </para>

    <para>
     Si une erreur survient lors de la restauration du schéma de la base de
     données, <command>pg_upgrade</command> quittera et vous devrez retourner sur l'ancienne
     instance comme indiqué dans <xref linkend="pgupgrade-step-revert"/>. Pour essayer de nouveau
     pg_upgrade, vous aurez besoin de modifier l'ancienne instance pour que
     la restauration du schéma par <command>pg_upgrade</command> réussisse. Si le problème
     est dû à un module contrib, vous pourriez avoir besoin de désinstaller
     le module contrib à partir de l'ancienne instance et de l'installer sur
     la nouvelle après la mise à jour en espérant que le module n'est pas
     utilisé pour stocker des données de l'utilisateur.
    </para>
   </step>

   <step>
    <title>Restaurez <filename>pg_hba.conf</filename></title>

    <para>
     Si vous avez modifié <filename>pg_hba.conf</filename>, restaurez-le à sa
     configuration d'origine.
     Il pourrait aussi être nécessaire d'ajuster les fichiers de configuration
     dans la nouvelle instance pour correspondre à l'ancienne instance, par
     exemple le fichier <filename>postgresql.conf</filename>.
    </para>
   </step>

   <step>
    <title>Traitement post-mise à jour</title>

    <para>
     Si tout traitement post-mise à jour est requis, pg_upgrade lancera des
     avertissements à la fin de son travail. Il générera aussi des fichiers
     de script à exécuter par l'administrateur. Les fichiers de script se
     connecteront à chaque base de données pour réaliser un traitement
     post-mise à jour. Chaque script doit être exécuté avec la commande
     suivante&nbsp;:

     <programlisting>
psql --username postgres --file script.sql postgres
     </programlisting>

     Ces scripts peuvent être exécutés dans n'importe quel ordre et peuvent
     être supprimés une fois qu'ils ont été exécutés.
    </para>

    <caution>
     <para>
      En général, il n'est pas prudent d'accéder aux tables référencées dans
      les scripts de reconstruction tant que ses scripts n'ont pas été exécutés
      entièrement&nbsp;; le faire malgré tout pourrait amener des résultats
      incorrects ou des contre-performances. Les tables non référencées dans
      les scripts de reconstruction peuvent être utilisées immédiatement.
     </para>
    </caution>
   </step>

   <step>
    <title>Statistiques</title>
    <caution>
     <para>
      Comme les statistiques de l'optimiseur ne sont pas transférées par
      <command>pg_upgrade</command>, il vous sera demandé d'exécuter une commande
      pour regénérer les informations statistiques à la fin de la mise à jour.
      Vous pourriez avoir besoin de configurer les paramètres de connexion
      correspondant à la nouvelle instance.
     </para>
    </caution>
   </step>

   <step>
    <title>Supprimez l'ancienne instance</title>

    <para>
     Une fois que vous êtes satisfait par la mise à jour, vous pouvez supprimer
     les répertoires de données de l'ancienne instance en exécutant le script
     mentionné à la fin de <command>pg_upgrade</command>. (Une suppression
     automatique n'est pas possible si vous avez des tablespaces définis par
     un utilisateur à l'intérieur de l'ancien répertoire de données.) Vous
     devrez supprimer manuellement les anciens répertoires
     d'installation, par exemple <filename>bin</filename>,
     <filename>share</filename>.
    </para>
   </step>

   <step id="pgupgrade-step-revert" performance="optional">
    <title>Retourner sur l'ancienne instance</title>

    <para>
     Si, après avoir exécuté <command>pg_upgrade</command>, vous souhaitez retourner à l'ancienne
     instance, il existe plusieurs options.
    </para>

    <itemizedlist>
     <listitem>
      <para>
       Si vous avez exécuté <command>pg_upgrade</command> avec l'option
       <option>--check</option>, aucune modification n'a eu lieu sur
       l'ancienne instance, donc vous pouvez la réutiliser immédiatement.
      </para>
     </listitem>

     <listitem>
      <para>
       Si vous avez exécuté <command>pg_upgrade</command> avec l'option
       <option>--link</option>, les fichiers de données sont partagés entre
       l'ancienne et la nouvelle instances. Si vous avez démarré la nouvelle
       instance, le nouveau serveur a écrit dans les fichiers partagés et il
       est du coup dangereux d'utiliser l'ancienne instance.
      </para>
     </listitem>

     <listitem>
      <para>
       Si vous avez exécuté <command>pg_upgrade</command>
       <emphasis>sans</emphasis> l'option <option>--link</option> ou si vous
       n'avez pas lancé le nouveau serveur, l'ancien serveur ne sera pas
       modifié, hormis, si la liaison a débuté, l'ajout d'un suffixe
       <literal>.old</literal> au fichier <filename>$PGDATA/global/pg_control</filename>.
       Pour réutiliser l'ancienne instance, il est possible de supprimer le
       suffixe <filename>.old</filename> du fichier <filename>$PGDATA/global/pg_control</filename>.
       Vous pouvez alors relancer l'ancienne instance.
      </para>
     </listitem>
    </itemizedlist>
   </step>
  </procedure>

 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   <application>pg_upgrade</application> ne supporte pas la mise à jour de bases de données
   qui contiennent les types systèmes identifiants d'objet <type>reg*</type> suivant :
   <type>regproc</type>, <type>regprocedure</type>, <type>regoper</type>,
   <type>regoperator</type>, <type>regconfig</type>, et
   <type>regdictionary</type>.  (<type>regtype</type> peut être mis à jour.)
  </para>

  <para>
   Chaque échec, reconstruction, ou cas de réindexation qui affectent votre
   installation sera signalé par <application>pg_upgrade</application>.
   Les scripts de reconstruction des tables et index à exécuter après la mise à
   jour seront générés automatiquement. Si vous essayez d'automatiser la mise à
   jour de plusieurs instances, vous devriez découvrir que les instances ayant
   des schémas de base identiques nécessitent les mêmes étapes après mise à jour
   pour toutes les mises à jour d'instance. Ceci est dû au fait que les étapes
   après mise à jour sont basés sur les schémas de base et non pas sur les
   données utilisateurs.
  </para>

  <para>
   Pour effectuer un test de déploiement, vous pouvez créer une simple copie du
   schéma de votre ancienne instance, insérer des données fictives, et le mettre à jour.
  </para>

  <para>
   Si vous mettez à jour une instance antérieure à
   <productname>PostgreSQL</productname> 9.2 qui utilise un répertoire dédié aux
   fichiers de configuration, vous devrez spécifier le répertoire des données à
   <application>pg_upgrade</application>, et  spécifier le répertoire de
   configuration au serveur, c'est-à-dire <literal>-d /repertoire-des-donnees
    -o '-D /repertoire-de-configuration'</literal>.
  </para>

  <para>
   Lors de l'utilisation d'un ancien serveur (pré-9.1) qui utilise un répertoire
   pour la socket de domaine Unix qui diffère du répertoire par défaut ou qui
   diffère de celui de la nouvelle instance, configurez <envar>PGHOST</envar>
   pour pointer vers l'emplacement de la socket de l'ancien serveur.
   (Ceci ne concerne pas Windows.)
  </para>

  <para>
   Un serveur en standby utilisant le Log-Shipping (<xref linkend="warm-standby"/>)
   ne peut pas être mis à jour car le serveur doit autoriser les écritures. Le
   moyen le plus simple est de mettre à jour le serveur primaire et d'utiliser
   <command>rsync</command> pour reconstruire les esclaves. Vous pouvez exécuter
   <command>rsync</command> quand le serveur principal est arrêté ou en l'intégrant
   dans une sauvegarde de fichiers (<xref linkend="backup-base-backup"/>) qui va
   surcharger l'ancienne instance du standby.
  </para>

  <para>
   Si vous voulez utiliser l'option <option>--link</option> mais que vous ne
   voulez pas que votre ancienne instance soit modifiée lorsque la nouvelle
   instance démarrera, créez une copie de l'ancien serveur et mettez-le à jour
   avec l'option <option>--link</option>.  Pour créer une copie valide de votre
   ancienne instance, utilisez la commande <command>rsync</command> pour créer
   une copie incohérente de votre ancienne instance alors que le serveur tourne
   toujours, puis arrêtez l'ancien serveur et lancez à nouveau la commande
   <command>rsync</command> pour rendre cohérent la copie avant le moindre
   changement. Vous pouvez exclure certains fichiers, par exemple
   <filename>postmaster.pid</filename>, comme documenté dans <xref
   linkend="backup-lowlevel-base-backup"/>. Si votre système de fichiers supporte
   les instantanés de système de fichiers ou des copies style copy-on-write des
   fichiers, vous pouvez utiliser cela pour faire une sauvegarde de l'ancienne
   instance (répertoire de données et tablespaces utilisateurs). Il faut néanmoins
   soit faire les copies simultanément soit les faire alors que le serveur est
   arrêté.
  </para>

  <refsect2>
   <title>Limites de la mise à jour depuis PostgreSQL 8.3</title>

   <para>
    La mise à jour <emphasis>à partir de</emphasis> PostgreSQL 8.3 comporte quelques restrictions
    supplémentaires. Par exemple, pg_upgrade ne fonctionnera pas pour une
    mise à jour à partir d'une 8.3 si une colonne utilisateur est définie
    comme&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       le type de données <type>tsquery</type>
      </para>
     </listitem>
     <listitem>
      <para>
       le type de données <type>name</type> et qu'il ne s'agit pas de la
       première colonne
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Vous devez supprimer ce type de colonnes et les mettre à jour manuellement.
   </para>

   <para>
    pg_upgrade ne fonctionnera pas si le module contrib
    <filename>ltree</filename> est installé dans une base de données.
   </para>

   <para>
    pg_upgrade nécessitera une reconstruction de la table si&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       une colonne utilisateur est de type <type>tsvector</type>
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    pg_upgrade nécessitera un réindexage si&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       un index est de type hash ou GIN
      </para>
     </listitem>
     <listitem>
      <para>
       un index utilise <function>bpchar_pattern_ops</function>
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    De plus, le format de stockage des dates et heures par défaut a changé
    vers l'entier après l'arrivée de <productname>PostgreSQL</productname> 8.3.
    pg_upgrade vérifiera que le format de stockage utilisé sur l'ancienne
    instance correspond à celui utilisé sur la nouvelle instance. Assurez-vous
    que votre nouvelle instance est construite avec le drapeau de configuration
    <option>--disable-integer-datetimes</option>.
   </para>

   <para>
    Pour les utilisateurs Windows, notez que, dû à une configuration différente
    sur ce paramètre par l'installeur graphique et l'installeur MSI, il est
    seulement possible de mettre à jour une version 8.3 provenant de l'installeur
    vers la version 8.4 ou ultérieure de l'installeur graphique. Il
    n'est pas possible de mettre à jour un répertoire des données créé par
    l'installeur MSI à un répertoire de données créé par le nouvel installeur graphique.
   </para>

  </refsect2>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="app-initdb"/></member>
   <member><xref linkend="app-pg-ctl"/></member>
   <member><xref linkend="app-pgdump"/></member>
   <member><xref linkend="app-postgres"/></member>
  </simplelist>
 </refsect1>
</refentry>

