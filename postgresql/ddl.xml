<?xml version="1.0" encoding="UTF-8"?>
<chapter id="ddl">
 <title>Définition des données</title>

 <para>
  Ce chapitre couvre la création des structures de données amenées à contenir
  les données. Dans une base relationnelle, les données brutes
  sont stockées dans des tables. De ce fait, une grande partie de ce chapitre
  est consacrée à l'explication de la création et de la modification des tables
  et aux fonctionnalités disponibles pour contrôler les données stockées dans les tables.
  L'organisation des tables dans des schémas et l'attribution de privilèges
  sur les tables sont ensuite décrits. Pour finir, d'autres fonctionnalités,
  telles que l'héritage, le partitionnement de tables, les vues, les fonctions et les déclencheurs sont
  passées en revue.
 </para>

 <sect1 id="ddl-basics">
  <title>Notions fondamentales sur les tables</title>

  <indexterm zone="ddl-basics">
   <primary>table</primary>
  </indexterm>

  <indexterm>
   <primary>ligne</primary>
  </indexterm>

  <indexterm>
   <primary>colonne</primary>
  </indexterm>

  <para>
   Une table dans une base relationnelle ressemble beaucoup à un tableau
   sur papier&nbsp;: elle est constituée de lignes et de colonnes. Le nombre
   et l'ordre des colonnes sont fixes et chaque colonne a un nom. Le
   nombre de lignes est variable &mdash; il représente le nombre de données
   stockées à un instant donné. Le SQL n'apporte aucune garantie sur l'ordre des
   lignes dans une table. Quand une table est lue, les lignes
   apparaissent dans un ordre non spécifié, sauf si un tri est demandé
   explicitement. Tout cela est expliqué dans le <xref linkend="queries"/>.
   De plus, le SQL n'attribue pas d'identifiant unique aux lignes. Il est
   donc possible d'avoir plusieurs lignes identiques au sein d'une table.
   C'est une conséquence du modèle mathématique sur lequel repose le SQL,
   même si cela n'est habituellement pas souhaitable.
   Il est expliqué plus bas dans ce chapitre comment traiter ce problème.
  </para>

  <para>
   Chaque colonne a un type de données. Ce type limite l'ensemble
   de valeurs qu'il est possible d'attribuer à une colonne. Il attribue
   également une sémantique aux données stockées dans la colonne pour
   permettre les calculs sur celles-ci. Par exemple, une colonne déclarée dans un
   type numérique n'accepte pas les chaînes textuelles&nbsp;; les données
   stockées dans une telle colonne peuvent être utilisées dans des
   calculs mathématiques.
   Par opposition, une colonne déclarée de type chaîne de
   caractères accepte pratiquement n'importe quel type de donnée mais ne
   se prête pas aux calculs mathématiques. D'autres types d'opérations,
   telle la concaténation de chaînes, sont cependant disponibles.
  </para>

  <para>
   <productname>PostgreSQL</productname> inclut un ensemble conséquent de types
   de données intégrés pour s'adapter à diverses applications. Les
   utilisateurs peuvent aussi définir leurs propres types de données.
  </para>
  <para>
   La plupart des types de données intégrés ont des noms et des sémantiques
   évidents. C'est pourquoi leur explication détaillée est reportée au
   <xref linkend="datatype"/>.
  </para>
  <!-- fractional : fraction -->
  <para>
   Parmi les types les plus utilisés, on trouve
   <type>integer</type> pour les entiers, <type>numeric</type> pour
   les éventuelles fractions, <type>text</type> pour les chaînes de
   caractères, <type>date</type> pour les dates, <type>time</type> pour
   les heures et <type>timestamp</type> pour les valeurs
   qui contiennent à la fois une date et une heure.
  </para>

  <indexterm>
   <primary>table</primary>
   <secondary>création</secondary>
  </indexterm>

  <!-- identifier : identifiant ou indicateur. Voire identificateur -->
  <para>
   Pour créer une table, on utilise la commande bien nommée
   <xref linkend="sql-createtable"/>. Dans cette
   commande, il est nécessaire d'indiquer, au minimum, le nom de la
   table, les noms des colonnes et le type de données de chacune d'elles.
   Par exemple&nbsp;:
   <programlisting>CREATE TABLE ma_premiere_table (
    premiere_colonne text,
    deuxieme_colonne integer
);</programlisting>
   Cela crée une table nommée <literal>ma_premiere_table</literal> avec
   deux colonnes. La première colonne, nommée
   <literal>premiere_colonne</literal>, est de type <type>text</type>&nbsp;;
   la seconde colonne, nommée <literal>deuxieme_colonne</literal>, est de type
   <type>integer</type>.
   Les noms des table et colonnes se conforment à la syntaxe des identifiants expliquée
   dans la <xref linkend="sql-syntax-identifiers"/>. Les noms des types sont souvent
   aussi des identifiants mais il existe des exceptions. Le séparateur de la
   liste des colonnes est la virgule. La liste doit être entre parenthèses.
  </para>

<!-- capillo-tracté s'il s'agit donc de cheveux de traie ou simplifié à l'extrême -->
   <para>
    L'exemple qui précède est à l'évidence extrêmement simpliste. On donne
    habituellement aux tables et aux colonnes des noms qui indiquent les
    données stockées. L'exemple ci-dessous est un peu plus réaliste&nbsp;:
    <programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric
);</programlisting>
   (Le type <type>numeric</type> peut stocker des fractions
   telles que les montants.)
  </para>

  <tip>
   <para>
    Quand de nombreuses tables liées sont créées, il est préférable de définir
    un motif cohérent pour le nommage des tables et des colonnes. On a ainsi
    la possibilité d'utiliser le pluriel ou le singulier des noms, chacune
    ayant ses fidèles et ses détracteurs.
   </para>
  </tip>

<!-- Par contre, utilisé par Céline (pas Dion, mais Louis-Ferdinand) dans un
souci de provocation, n'est à l'évidence pas une construction grammaticale
préconisée par l'Académie Française. On lui préférera "En revanche",
"Cependant", "Au contraire"... -->
    <para>
     Le nombre de colonnes d'un table est limité. En fonction du type de
     colonnes, il oscille entre 250 et 1600.
     Définir une table avec un nombre de colonnes proche de cette limite est,
     cependant, très inhabituel et doit conduire à se poser des questions quant
     à la conception du modèle.
    </para>

    <indexterm>
     <primary>table</primary>
     <secondary>suppression</secondary>
    </indexterm>

    <para>
     Lorsqu'une table n'est plus utile, elle peut être supprimée à l'aide de la
     commande <xref linkend="sql-droptable"/>. Par exemple&nbsp;:
     <programlisting>DROP TABLE ma_premiere_table;
DROP TABLE produits;</programlisting>
   Tenter de supprimer une table qui n'existe pas lève une erreur.
   Il est, néanmoins, habituel dans les fichiers de scripts SQL d'essayer
   de supprimer chaque table avant de la créer. Les messages
   d'erreur sont alors ignorés afin que le script fonctionne que la table
   existe ou non. (La variante <literal>DROP TABLE IF EXISTS</literal> peut
   aussi être utilisée pour éviter les messages d'erreur mais elle ne fait pas partie du
   standard SQL.)
  </para>

  <para>
   Pour la procédure de modification d'une table qui existe déjà, voir la
   <xref linkend="ddl-alter"/> plus loin dans ce chapitre.
  </para>

  <para>
   Les outils précédemment décrits permettent de créer des tables
   fonctionnelles. Le reste de ce chapitre est consacré à l'ajout de fonctionnalités
   à la définition de tables pour garantir l'intégrité des données, la sécurité
   ou l'ergonomie. Le lecteur impatient d'insérer des données dans ses tables
   peut sauter au <xref linkend="dml"/> et lire le reste de
   ce chapitre plus tard.
  </para>
 </sect1>

 <sect1 id="ddl-default">
  <title>Valeurs par défaut</title>

  <indexterm zone="ddl-default">
   <primary>valeur par défaut</primary>
  </indexterm>

  <para>
   Une valeur par défaut peut être attribuée à une colonne. Quand une nouvelle
   ligne est créée et qu'aucune valeur n'est indiquée pour certaines de ses
   colonnes, celles-ci sont remplies avec leurs valeurs par défaut respectives.
   Une commande de manipulation de données peut aussi demander explicitement
   que la valeur d'une colonne soit positionnée à la valeur par défaut, sans
   qu'il lui soit nécessaire de connaître cette valeur (les détails concernant les
   commandes de manipulation de données sont donnés dans le <xref linkend="dml"/>).
  </para>

  <para>
   <indexterm>
    <primary>valeur NULL</primary>
    <secondary>valeur par défaut</secondary>
   </indexterm>
   Si aucune valeur par défaut n'est déclarée explicitement, la valeur
   par défaut est la valeur NULL. Cela a un sens dans la mesure où l'on
   peut considérer que la valeur NULL représente des données inconnues.
  </para>

  <para>
   Dans la définition d'une table, les valeurs par défaut sont listées après
   le type de données de la colonne. Par exemple:
<programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric <emphasis>DEFAULT 9.99</emphasis>
);</programlisting>
  </para>

  <para>
   La valeur par défaut peut être une expression, alors évaluée à l'insertion
   de cette valeur (<emphasis>pas</emphasis> à la création de la
   table). Un exemple commun est la colonne de type <type>timestamp</type>
   dont la valeur par défaut est <literal>now()</literal>. Elle se voit ainsi
   attribuée l'heure d'insertion. Un autre exemple est
   la génération d'un <quote>numéro de série</quote> pour chaque ligne.
   Dans <productname>PostgreSQL</productname>, cela s'obtient habituellement par
   quelque chose comme
<programlisting>CREATE TABLE produits (
    no_produit integer <emphasis>DEFAULT nextval('produits_no_produit_seq')</emphasis>,
    ...
);</programlisting>
   où la fonction <literal>nextval()</literal> fournit des valeurs successives à
   partir d'un <firstterm>objet séquence</firstterm> (voir la <xref
   linkend="functions-sequence"/>). Cet arrangement est suffisamment commun
   pour qu'il ait son propre raccourci&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit <emphasis>SERIAL</emphasis>,
    ...
);</programlisting>
   Le raccourci <literal>SERIAL</literal> est discuté plus tard dans la <xref
   linkend="datatype-serial"/>.
  </para>
 </sect1>

 <sect1 id="ddl-constraints">
  <title>Contraintes</title>

  <indexterm zone="ddl-constraints">
   <primary>contrainte</primary>
  </indexterm>

  <para>
   Les types de données sont un moyen de restreindre la nature des données qui
   peuvent être stockées dans une table. Pour beaucoup d'applications,
   toutefois, la contrainte fournie par ce biais est trop grossière.
   Par exemple, une colonne qui
   contient le prix d'un produit ne doit accepter que des valeurs
   positives. Mais il n'existe pas de type de données standard qui n'accepte que
   des valeurs positives. Un autre problème peut provenir de la volonté de
   contraindre les données d'une colonne par rapport aux autres colonnes ou lignes.
   Par exemple, dans une table contenant des informations de produit, il
   ne peut y avoir qu'une ligne par numéro de produit.
  </para>

  <para>
   Pour cela, SQL permet de définir des contraintes sur les colonnes
   et les tables. Les contraintes donnent autant de contrôle sur les
   données des tables qu'un utilisateur peut le souhaiter. Si un utilisateur
   tente de stocker des données dans une colonne en violation d'une contrainte, une erreur est
   levée. Cela s'applique même si la valeur vient de la définition de la
   valeur par défaut.
  </para>

  <sect2 id="ddl-constraints-check-constraints">
   <title>Contraintes de vérification</title>

   <indexterm>
    <primary>contrainte de vérification</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>vérification</secondary>
   </indexterm>

   <para>
    La contrainte de vérification est la contrainte la plus
    générique qui soit. Elle permet d'indiquer que la valeur
    d'une colonne particulière doit satisfaire une expression booléenne
    (valeur de vérité). Par exemple, pour obliger les prix des produits
    à être positifs, on peut utiliser&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric <emphasis>CHECK (prix &gt; 0)</emphasis>
);</programlisting>
   </para>

   <para>
    La définition de contrainte vient après
    le type de données, comme pour les définitions de valeur par défaut. Les
    valeurs par défaut et les contraintes peuvent être données dans
    n'importe quel ordre. Une contrainte de vérification s'utilise avec
    le mot clé <literal>CHECK</literal> suivi d'une expression entre
    parenthèses. L'expression de la contrainte implique habituellement la
    colonne à laquelle elle s'applique, la contrainte n'ayant dans le cas
    contraire que peu de sens.
   </para>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>nom</secondary>
   </indexterm>

   <para>
    la contrainte peut prendre un nom distinct. Cela
    clarifie les messages d'erreur et permet de faire référence
    à la contrainte lorsqu'elle doit être modifiée.
    La syntaxe est&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric <emphasis>CONSTRAINT prix_positif</emphasis> CHECK (prix &gt; 0)
);</programlisting>
    Pour indiquer une contrainte nommée, on utilise le mot-clé
    <literal>CONSTRAINT</literal> suivi d'un identifiant et de la
    définition de la contrainte (si aucun nom n'est précisé,
    le système en choisit un).
   </para>

   <para>
    Une contrainte de vérification peut aussi faire référence à plusieurs
    colonnes. Dans le cas d'un produit, on peut vouloir stocker le prix normal
    et un prix réduit en s'assurant que le prix réduit soit bien inférieur au
    prix normal.
<programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric CHECK (prix &gt; 0),
    prix_promotion numeric CHECK (prix_promotion &gt; 0),
    <emphasis>CHECK (prix &gt; prix_promotion)</emphasis>
);</programlisting>
   </para>

   <para>
    Si les deux premières contraintes n'offrent pas de nouveauté, la troisième
    utilise une nouvelle syntaxe. Elle n'est pas attachée à une colonne
    particulière mais apparaît comme un élément distinct dans
    la liste des colonnes. Les définitions de
    colonnes et ces définitions de contraintes peuvent être définies dans
    un ordre quelconque.
   </para>

   <para>
    Les deux premières contraintes sont appelées contraintes de
    colonne tandis que la troisième est appelée contrainte de table parce
    qu'elle est écrite séparément d'une définition de colonne particulière.
    Les contraintes de colonne peuvent être écrites comme des contraintes de
    table, mais l'inverse n'est pas forcément possible puisqu'une contrainte de colonne est
    supposée ne faire référence qu'à la colonne à laquelle elle est
    attachée (<productname>PostgreSQL</productname> ne vérifie pas cette règle
    mais il est préférable de la suivre pour s'assurer que les définitions de
    tables fonctionnent avec d'autres systèmes de bases de données).
    L'exemple ci-dessus peut aussi s'écrire&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric,
    CHECK (prix &gt; 0),
    prix_promotion numeric,
    CHECK (prix_promotion &gt; 0),
    CHECK (prix &gt; prix_promotion)
);</programlisting>
    ou même&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric CHECK (prix &gt; 0),
    prix_promotion numeric,
    CHECK (prix_promotion &gt; 0 AND prix &gt; prix_promotion)
);</programlisting>
    C'est une question de goût.
   </para>

   <para>
    Les contraintes de table peuvent être nommées, tout comme
    les contraintes de colonne&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric,
    CHECK (prix &gt; 0),
    prix_promotion numeric,
    CHECK (prix_promotion &gt; 0),
    <emphasis>CONSTRAINT promo_valide</emphasis> CHECK (prix &gt; prix_promotion)
);</programlisting>
   </para>

   <indexterm>
    <primary>valeur NULL</primary>
    <secondary sortas="check constraints">avec contraintes de vérification</secondary>
   </indexterm>

   <para>
    Une contrainte de vérification est satisfaite si
    l'expression est évaluée vraie ou NULL. Puisque la
    plupart des expressions sont évaluées NULL si l'une
    des opérandes est nulle, elles n'interdisent pas les valeurs NULL
    dans les colonnes contraintes. Pour s'assurer qu'une colonne ne
    contient pas de valeurs NULL, la contrainte NOT NULL décrite
    dans la section suivante peut être utilisée.
   </para>
  </sect2>

  <sect2>
   <title>Contraintes de non nullité (NOT NULL)</title>

   <indexterm>
    <primary>contrainte NOT NULL</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>NOT NULL</secondary>
   </indexterm>

   <para>
    Une contrainte NOT NULL indique simplement qu'une colonne ne peut
    pas prendre la valeur NULL. Par exemple&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer <emphasis>NOT NULL</emphasis>,
    nom text <emphasis>NOT NULL</emphasis>,
    prix numeric
);</programlisting>
   </para>

   <para>
    Une contrainte NOT NULL est toujours écrite comme une contrainte de
    colonne. Elle est fonctionnellement équivalente à la création d'une
    contrainte de vérification <literal>CHECK (<replaceable>nom_colonne</replaceable>
    IS NOT NULL)</literal>. Toutefois, dans <productname>PostgreSQL</productname>,
    il est plus efficace de créer explicitement une contrainte NOT NULL.
    L'inconvénient est que les contraintes de non-nullité ainsi créées ne
    peuvent pas être explicitement nommées.
   </para>

   <para>
    Une colonne peut évidemment avoir plusieurs contraintes. Il suffit
    d'écrire les contraintes les unes après les autres&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer NOT NULL,
    nom text NOT NULL,
    prix numeric NOT NULL CHECK (prix &gt; 0)
);</programlisting>
    L'ordre n'a aucune importance. Il ne détermine pas l'ordre de vérification
    des contraintes.
   </para>

   <para>
    La contrainte <literal>NOT NULL</literal> a un contraire&nbsp;; la contrainte
    <literal>NULL</literal>. Elle ne signifie pas que la colonne doit
    être NULL, ce qui est assurément inutile, mais sélectionne le comportement
    par défaut, à savoir que la colonne peut être NULL. La contrainte
    <literal>NULL</literal> n'est pas présente dans le standard SQL et ne doit pas
    être utilisée dans des applications portables (elle n'a été ajoutée
    dans <productname>PostgreSQL</productname> que pour assurer la
    compatibilité avec d'autres bases de données). Certains utilisateurs
    l'apprécient néanmoins car elle permet de basculer aisément d'une
    contrainte à l'autre dans un fichier de script. On peut, par exemple, commencer avec&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer NULL,
    nom text NULL,
    prix numeric NULL
);</programlisting>
    puis insérer le mot-clé <literal>NOT</literal> en fonction des besoins.
   </para>

   <tip>
    <para>
     Dans la plupart des bases de données, il est préférable que la majorité des
     colonnes soient marquées NOT NULL.
    </para>
   </tip>
  </sect2>

  <sect2 id="ddl-constraints-unique-constraints">
   <title>Contraintes d'unicité</title>

   <indexterm>
    <primary>contrainte d'unicité</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>unicité</secondary>
   </indexterm>

   <para>
    Les contraintes d'unicité garantissent l'unicité des données contenues dans
    une colonne ou un groupe de colonnes par rapport à toutes
    les lignes de la table. La syntaxe est&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer <emphasis>UNIQUE</emphasis>,
    nom text,
    prix numeric
);</programlisting>
    lorsque la contrainte est écrite comme contrainte de colonne et&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric,
    <emphasis>UNIQUE (no_produit)</emphasis>
);</programlisting>
    lorsqu'elle est écrite comme contrainte de table.
   </para>

   <para>
    Pour définir une contrainte unique pour un groupe de colonnes, saisissez-
    la en tant que contrainte de table avec les noms des colonnes séparés par
    des virgules&nbsp;:
<programlisting>CREATE TABLE exemple (
    a integer,
    b integer,
    c integer,
    <emphasis>UNIQUE (a, c)</emphasis>
);</programlisting>
    Cela précise que la combinaison de valeurs dans les colonnes indiquées
    est unique sur toute la table. Sur une colonne prise isolément ce
    n'est pas nécessairement le cas (et habituellement cela ne l'est pas).
   </para>

   <para>
    Une contrainte d'unicité peut être nommée, de la
    façon habituelle&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer <emphasis>CONSTRAINT doit_etre_different</emphasis> UNIQUE,
    nom text,
    prix numeric
);</programlisting>
   </para>

   <para>
    Ajouter une contrainte unique va automatiquement créer un index unique
    B-tree sur la colonne ou le groupe de colonnes listées dans la contrainte.
    Une restriction d'unicité couvrant seulement certaines lignes ne peut pas
    être écritre comme une contrainte unique mais il est possible de forcer ce
    type de restriction en créant un <link linkend="indexes-partial">index
    partiel</link> unique.
   </para>

   <indexterm>
    <primary>valeur NULL</primary>
    <secondary sortas="unique constraints">avec contrainte d'unicité</secondary>
   </indexterm>

   <para>
    En général, une contrainte d'unicité est violée si plus d'une ligne de la
    table possèdent des valeurs identiques sur toutes les colonnes de la
    contrainte. En revanche, deux valeurs NULL ne sont jamais considérées
    égales. Cela signifie qu'il est possible de stocker des lignes dupliquées
    contenant une valeur NULL dans au moins une des colonnes contraintes. Ce
    comportement est conforme au standard SQL, mais d'autres bases SQL
    n'appliquent pas cette règle. Il est donc préférable d'être prudent lors
    du développement d'applications portables.
   </para>
      </sect2>

      <sect2 id="ddl-constraints-primary-keys">
       <title>Clés primaires</title>

       <indexterm>
	<primary>clé primaire</primary>
       </indexterm>

       <indexterm>
	<primary>contrainte</primary>
	<secondary>clé primaire</secondary>
       </indexterm>

       <para>
        Une contrainte de type clé primaire indique qu'une colonne, ou un
        groupe de colonnes, peut être utilisée comme un identifiant unique de
        ligne pour cette table. Ceci nécessite que les valeurs soient à la
        fois uniques et non NULL. Les définitions de table suivantes acceptent
        de ce fait les mêmes données&nbsp;:
    <programlisting>CREATE TABLE produits (
	no_produit integer UNIQUE NOT NULL,
	nom text,
	prix numeric
    );</programlisting>

    <programlisting>CREATE TABLE produits (
	no_produit integer <emphasis>PRIMARY KEY</emphasis>,
	nom text,
	prix numeric
    );</programlisting>
       </para>

       <para>
	Les clés primaires peuvent également contraindre plusieurs colonnes&nbsp;; la
	syntaxe est semblable aux contraintes d'unicité&nbsp;:
    <programlisting>CREATE TABLE exemple (
	a integer,
	b integer,
	c integer,
	<emphasis>PRIMARY KEY (a, c)</emphasis>
    );</programlisting>
       </para>

       <para>
        Ajouter une clé primaire créera automatiquement un index unique B-tree
        sur la colonne ou le groupe de colonnes listé dans la clé primaire, et
        forcera les colonnes à être marquées <literal>NOT NULL</literal>.
       </para>

   <para>
    L'ajout d'une clé primaire créera automatiquement un index B-tree unique
    sur la colonne ou le groupe de colonnes utilisé dans la clé primaire.
   </para>

       <para>
	Une table a, au plus, une clé primaire. (Le nombre de contraintes UNIQUE NOT NULL,
	qui assurent pratiquement la même fonction, n'est pas limité, mais une seule
	peut être identifiée comme clé primaire.) La théorie des
	bases de données relationnelles impose que chaque table ait
	une clé primaire. Cette règle n'est pas forcée par
	<productname>PostgreSQL</productname>, mais il est préférable de la
	respecter.
       </para>

   <para>
    Les clés primaires sont utiles pour la documentation et pour les
    applications clientes. Par exemple, une application graphique qui permet
    la modifier des valeurs des lignes a probablement besoin de connaître la
    clé primaire d'une table pour être capable d'identifier les lignes de
    façon unique. Le système de bases de données utilise une clé primaire de
    différentes façons. Par exemple, la clé primaire définit les colonnes
    cibles par défaut pour les clés étrangères référençant cette table.
   </para>
      </sect2>

      <sect2 id="ddl-constraints-fk">
       <title>Clés étrangères</title>

       <indexterm>
	<primary>clé étrangère</primary>
       </indexterm>

       <indexterm>
	<primary>contrainte</primary>
	<secondary>clé étrangère</secondary>
       </indexterm>

       <indexterm>
	<primary>intégrité référentielle</primary>
       </indexterm>

       <para>
	Une contrainte de clé étrangère stipule que les valeurs d'une
	colonne (ou d'un groupe de colonnes) doivent correspondre aux valeurs
	qui apparaissent dans les lignes d'une autre table.
	On dit que cela maintient l'<firstterm>intégrité référentielle</firstterm>
	entre les deux tables.
       </para>

       <para>
	Soit la table de produits, déjà utilisée plusieurs fois&nbsp;:
    <programlisting>CREATE TABLE produits (
	no_produit integer PRIMARY KEY,
	nom text,
	prix numeric
    );</programlisting>
	Soit également une table qui stocke les commandes de
	ces produits. Il est intéressant de s'assurer que la table des
	commandes ne contient que des commandes de produits
	qui existent réellement. Pour cela, une contrainte
	de clé étrangère est définie dans la table des commandes qui référence la
	table produit&nbsp;:
    <programlisting>CREATE TABLE commandes (
	id_commande integer PRIMARY KEY,
	no_produit integer <emphasis>REFERENCES produits (no_produit)</emphasis>,
	quantite integer
    );</programlisting>
	Il est désormais impossible de créer des commandes pour lesquelles
	les valeurs non NULL de <structfield>no_produit</structfield> n'apparaissent pas dans la table
	produits.
       </para>
    <!-- referencing/referenced
	 référençant/référencée ? -->
     <para>
      Dans cette situation, on dit que la table des commandes est la table
      <firstterm>qui référence</firstterm> et la table des produits est la table
      <firstterm>référencée</firstterm>.  De la même façon, il y a des colonnes
      qui référencent et des colonnes référencées.
     </para>

     <para>
      La commande précédente peut être raccourcie en
      <programlisting>CREATE TABLE commandes (
	id_commande integer PRIMARY KEY,
	no_produit integer <emphasis>REFERENCES produits</emphasis>,
	quantite integer
    );</programlisting>
	parce qu'en l'absence de liste de colonnes, la clé primaire de la
	table de référence est utilisée comme colonne de référence.
       </para>

       <para>
	Une clé étrangère peut aussi contraindre et référencer un groupe de colonnes.
	Comme cela a déjà été évoqué, il faut alors l'écrire sous forme d'une contrainte de table.
	Exemple de syntaxe&nbsp;:
    <programlisting>CREATE TABLE t1 (
      a integer PRIMARY KEY,
      b integer,
      c integer,
      <emphasis>FOREIGN KEY (b, c) REFERENCES autre_table (c1, c2)</emphasis>
    );</programlisting>
	Le nombre et le type des colonnes contraintes doivent correspondre
	au nombre et au type des colonnes référencées.
       </para>

       <para>
	Une contrainte de clé étrangère peut être nommée de la façon habituelle.
       </para>

       <para>
	Une table peut contenir plusieurs contraintes de clé étrangère. Les
	relation n-n entre tables sont implantées ainsi. Soient
	des tables qui contiennent des produits et des commandes, avec la
	possibilité d'autoriser une commande à contenir plusieurs produits
	(ce que la structure ci-dessus ne permet pas). On peut pour cela
	utiliser la structure de table suivante&nbsp;:
    <programlisting>CREATE TABLE produits (
	no_produit integer PRIMARY KEY,
	nom text,
	prix numeric
    );

    CREATE TABLE commandes (
	id_commande integer PRIMARY KEY,
	adresse_de_livraison text,
	...
    );

    CREATE TABLE commande_produits (
	no_produit integer REFERENCES produits,
	id_commande integer REFERENCES commandes,
	quantite integer,
	PRIMARY KEY (no_produit, id_commande)
    );</programlisting>
	La clé primaire de la dernière table recouvre les clés étrangères.
       </para>

       <indexterm>
	<primary>CASCADE</primary>
	<secondary>action clé étrangère</secondary>
       </indexterm>

       <indexterm>
	<primary>RESTRICT</primary>
	<secondary>action clé étrangère</secondary>
       </indexterm>

       <para>
	Les clés étrangères interdisent désormais la création
	de commandes qui ne soient pas liées à un produit. Qu'arrive-t-il si un produit
	est supprimé alors qu'une commande y fait référence&nbsp;? SQL
	permet aussi de le gérer. Intuitivement, plusieurs options existent&nbsp;:
	<itemizedlist spacing="compact">
	 <listitem><para>interdire d'effacer un produit référencé&nbsp;;</para></listitem>
	 <listitem><para>effacer aussi les commandes&nbsp;;</para></listitem>
	 <listitem><para>autre chose ?</para></listitem>
	</itemizedlist>
       </para>

       <para>
	Pour illustrer ce cas, la politique suivante est implantée sur
	l'exemple de relations n-n évoqué plus haut&nbsp;:
	<itemizedlist spacing="compact">
	 <listitem><para>quand quelqu'un veut retirer un produit qui est encore
	  référencé par une commande
	  (au travers de <literal>commande_produits</literal>), on
	  l'interdit&nbsp;;</para></listitem>
	 <listitem><para>si quelqu'un supprime une commande, les éléments
	  de la commande sont aussi supprimés.</para></listitem>
	</itemizedlist>

    <programlisting>CREATE TABLE produits (
	no_produit integer PRIMARY KEY,
	nom text,
	prix numeric
    );

    CREATE TABLE commandes (
	id_commande integer PRIMARY KEY,
	adresse_de_livraison text,
	...
    );

    CREATE TABLE commande_produits (
	no_produit integer REFERENCES produits <emphasis>ON DELETE RESTRICT</emphasis>,
	id_commande integer REFERENCES commandes <emphasis>ON DELETE CASCADE</emphasis>,
	quantite integer,
	PRIMARY KEY (no_produit, id_commande)
    );</programlisting>
       </para>

    <!-- CASCADE : cascader ? -->
      <para>
       Restreindre les suppressions et les cascader sont les deux
       options les plus communes. <literal>RESTRICT</literal> empêche la
       suppression d'une ligne référencée. <literal>NO ACTION</literal> impose
       la levée d'une erreur si des lignes référençant existent lors de la
       vérification de la contrainte. Il s'agit du comportement par
       défaut en l'absence de précision. La différence entre
       <literal>RESTRICT</literal> et <literal>NO ACTION</literal>
       est l'autorisation par
       <literal>NO ACTION</literal> du report de la vérification à la fin de la
       transaction, ce que <literal>RESTRICT</literal> ne permet pas.
       <literal>CASCADE</literal> indique que, lors de la suppression d'une ligne
       référencée, les lignes la référençant doivent être automatiquement
       supprimées. Il existe deux autres options&nbsp;:
       <literal>SET NULL</literal> et <literal>SET DEFAULT</literal>.
       Celles-ci imposent que les colonnes qui référencent dans les lignes référencées
       soient
       réinitialisées à NULL ou à leur valeur par défaut, respectivement, lors
       de la suppression d'une ligne référencée. Elles ne dispensent pas pour
       autant d'observer les contraintes. Par exemple, si une action précise
       <literal>SET DEFAULT</literal> mais que la valeur par défaut ne
       satisfait pas la clé étrangère, l'opération échoue.
      </para>

      <para>
       À l'instar de <literal>ON DELETE</literal>, existe <literal>ON
        UPDATE</literal>, évoqué lorsqu'une colonne référencée est modifiée
       (actualisée). Les actions possibles sont les mêmes. Dans ce cas,
       <literal>CASCADE</literal> signifie que les valeurs mises à jour dans
       la colonne référencée doivent être copiées dans les lignes de référence.
      </para>

      <para>
       Habituellement, une ligne de référence n'a pas besoin de satisfaire la
       clé étrangère si une de ses colonnes est NULL. Si la clause <literal>MATCH
        FULL</literal> est ajoutée à la déclaration de la clé étrangère, une ligne
       de référence échappe à la clé étrangère seulement si toutes ses colonnes de
       référence sont NULL (donc un mélange de valeurs NULL et non NULL échoue
       forcément sur une contrainte <literal>MATCH FULL</literal>). Si vous ne
       voulez pas que les lignes de référence soient capables d'empêcher la
       satisfaction de la clé étrangère, déclarez les colonnes de référence comme
       <literal>NOT NULL</literal>.
      </para>

      <para>
       Une clé étrangère doit référencer les colonnes qui soit sont une clé primaire
       soit forment une contrainte d'unicité. Cela signifie que les colonnes
       référencées ont toujours un index (celui qui garantie la clé primaire ou
       la contrainte unique). Donc les vérifications sur la ligne de référence
       seront performantes.
       Comme la suppression d'une ligne de la table référencée ou la mise à jour
       d'une colonne référencée nécessitera un parcours de la table référée pour
       trouver les lignes correspondant à l'ancienne valeur, il est souvent
       intéressant d'indexer les colonnes référencées. Comme cela n'est pas
       toujours nécessaire et qu'il y a du choix sur la façon d'indexer, l'ajout
       d'une contrainte de clé étrangère ne crée pas automatiquement un index sur
       les colonnes référencées.
      </para>

      <para>
       Le <xref linkend="dml"/> contient de plus amples informations sur
       l'actualisation et la suppression de données. Voir aussi la description
       de la syntaxe des clés étrangères dans la documentation de référence sur
       <xref linkend="sql-createtable"/>.
      </para>

      <para>
       Une clé étrangère peut faire référence à des colonnes qui constituent une clé
       primaire ou forment une contrainte d'unicité. Si la clé étrangère référence
       une contrainte d'unicité, des possibilités supplémentaires sont offertes
       concernant la correspondance des valeurs NULL. Celles-ci sont expliquées
       dans la documentation de référence de
       <xref linkend="sql-createtable"/>.
      </para>
     </sect2>

     <sect2 id="ddl-constraints-exclusion">
      <title>Contraintes d'exclusion</title>

      <indexterm>
       <primary>contrainte d'exclusion</primary>
      </indexterm>

      <indexterm>
       <primary>contrainte</primary>
       <secondary>exclusion</secondary>
      </indexterm>

      <para>
       Les contraintes d'exclusion vous assurent que si deux lignes sont
       comparées sur les colonnes ou expressions spécifiées en utilisant les
       opérateurs indiqués, au moins une de ces comparaisons d'opérateurs reverra
       false ou NULL. La syntaxe est&nbsp;:
       <programlisting>
CREATE TABLE cercles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
       </programlisting>
      </para>

      <para>
       Voir aussi <link linkend="sql-createtable-exclude"><command>CREATE
         TABLE ... CONSTRAINT ... EXCLUDE</command></link> pour plus de détails.
      </para>

      <para>
       L'ajout d'une contrainte d'exclusion créera automatiquement un index du
       type spécifié dans la déclaration de la contrainte.
      </para>
     </sect2>
    </sect1>

    <sect1 id="ddl-system-columns">
     <title>Colonnes système</title>

     <para>
      Chaque table contient plusieurs <firstterm>colonnes système</firstterm>
      implicitement définies par le système. De ce fait, leurs noms ne peuvent
      pas être utilisés comme noms de colonnes utilisateur (ces restrictions sont
      distinctes de celles sur l'utlisation de mot-clés&nbsp;; mettre le nom
      entre guillemets ne permet pas d'échapper à cette règle). Il n'est pas
      vraiment utile de se préoccuper de ces colonnes, mais au minimum de
      savoir qu'elles existent.
     </para>

     <indexterm>
      <primary>colonne</primary>
      <secondary>colonne système</secondary>
     </indexterm>

     <variablelist>
      <varlistentry>
       <term><structfield>oid</structfield></term>
       <listitem>
        <para>
         <indexterm>
          <primary>OID</primary>
          <secondary>colonne</secondary>
         </indexterm>
         L'identifiant objet (<foreignphrase>object ID</foreignphrase>) d'une ligne. Cette
         colonne n'est présente que si la table a été créée en précisant
         <literal>WITH OIDS</literal> ou si la variable de configuration
         <xref linkend="guc-default-with-oids"/> était activée à ce moment-là.
         Cette colonne est de type oid (même nom que la colonne)&nbsp;; voir la
         <xref linkend="datatype-oid"/> pour obtenir plus d'informations sur ce type.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><structfield>tableoid</structfield></term>
       <listitem>
        <indexterm>
         <primary>tableoid</primary>
        </indexterm>

        <para>
         L' OID de la table contenant la ligne. Cette colonne est
         particulièrement utile pour les requêtes qui utilisent des hiérarchies
         d'héritage (voir <xref linkend="ddl-inherit"/>). Il est, en effet,
         difficile, en son absence, de savoir de quelle table provient une ligne.
         <structfield>tableoid</structfield>
         peut être joint à la colonne <structfield>oid</structfield> de
         <structname>pg_class</structname> pour obtenir le nom de la table.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><structfield>xmin</structfield></term>
       <listitem>
        <indexterm>
         <primary>xmin</primary>
        </indexterm>

        <para>
         L'identifiant (ID de transaction) de la transaction qui a inséré cette
         version de la ligne. (Une version de ligne est un état individuel
         de la ligne&nbsp;; toute mise à jour d'une ligne crée une nouvelle
         version de ligne pour la même ligne logique.)
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><structfield>cmin</structfield></term>
       <listitem>
        <indexterm>
         <primary>cmin</primary>
        </indexterm>

        <para>
         L'identifiant de commande (à partir de zéro) au sein de la transaction
         d'insertion.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><structfield>xmax</structfield></term>
       <listitem>
        <indexterm>
         <primary>xmax</primary>
        </indexterm>

        <para>
         L'identifiant (ID de transaction) de la transaction de suppression, ou zéro
         pour une version de ligne non effacée. Il est possible que la colonne ne
         soit pas nulle pour une version de ligne visible&nbsp;; cela
         indique habituellement que la transaction de suppression n'a pas été
         effectuée, ou qu'une tentative de suppression a été annulée.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><structfield>cmax</structfield></term>
       <listitem>
        <indexterm>
         <primary>cmax</primary>
        </indexterm>

        <para>
         L'identifiant de commande au sein de la transaction de suppression, ou
         zéro.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><structfield>ctid</structfield></term>
       <listitem>
        <indexterm>
         <primary>ctid</primary>
        </indexterm>

        <para>
         La localisation physique de la version de ligne au sein de sa table.
         Bien que le <structfield>ctid</structfield> puisse être utilisé
         pour trouver la version de ligne très rapidement, le
         <structfield>ctid</structfield>  d'une ligne change si
         la ligne est actualisée ou déplacée par un <command>VACUUM FULL</command>.
         <structfield>ctid</structfield> est donc inutilisable comme
         identifiant de ligne sur le long terme. Il est préférable d'utiliser l'OID,
         ou, mieux encore, un numéro
         de série utilisateur, pour identifier les lignes logiques.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Les OID sont des nombres de 32 bits et sont attribués à partir d'un
      compteur unique sur le cluster. Dans une base de données volumineuse ou
      agée, il est possible que le compteur boucle. Il est de ce fait peu
      pertinent de considérer que les OID puissent être uniques&nbsp;; pour
      identifier les lignes d'une table, il est fortement recommandé d'utiliser
      un générateur de séquence. Néanmoins, les OID peuvent également être
      utilisés sous réserve que quelques précautions soient prises&nbsp;:

      <itemizedlist>
       <listitem>
        <para>
         une contrainte d'unicité doit être ajoutée sur la colonne OID de chaque
         table dont l'OID est utilisé pour identifier les lignes.
         Dans ce cas (ou dans celui d'un index d'unicité), le système
         n'engendre pas d'OID qui puisse correspondre à celui d'une ligne
         déjà présente. Cela n'est évidemment possible que si la table contient
         moins de 2<superscript>32</superscript> (4 milliards) lignes&nbsp;; en pratique, la
         taille de la table a tout intérêt à être bien plus petite que ça, dans
         un souci de performance&nbsp;;
        </para>
       </listitem>
       <listitem>
        <para>
         l'unicité inter-tables des OID ne doit jamais être envisagée&nbsp;;
         pour obtenir un identifiant unique sur l'ensemble de la base, il faut
         utiliser la combinaison du <structfield>tableoid</structfield> et de l'OID de
         ligne&nbsp;;
        </para>
       </listitem>
       <listitem>
        <para>
         les tables en question doivent être créées avec l'option
         <literal>WITH OIDS</literal>. Depuis <productname>PostgreSQL</productname> 8.1,
         <literal>WITHOUT OIDS</literal> est l'option par défaut.
        </para>
       </listitem>
      </itemizedlist>
     </para>

     <para>
      Les identifiants de transaction sont aussi des nombres de 32 bits. Dans
      une base de données agée, il est possible que les ID de
      transaction bouclent. Cela n'est pas un problème fatal
      avec des procédures de maintenance appropriées&nbsp;; voir le <xref
      linkend="maintenance"/> pour les détails. Il est, en revanche, imprudent
      de considérer l'unicité des ID de transaction sur le long terme (plus
      d'un milliard de transactions).
     </para>

     <para>
      Les identifiants de commande sont aussi des nombres de 32 bits. Cela
      crée une limite dure de 2<superscript>32</superscript> (4 milliards)
      commandes <acronym>SQL</acronym> au sein d'une unique transaction. En
      pratique, cette limite n'est pas un problème &mdash; la limite est sur
      le nombre de commandes <acronym>SQL</acronym>, pas sur le nombre de lignes
      traitées.
      De plus, seules les commandes qui modifient réellement le contenu de la base
      de données consomment un identifiant de commande.
     </para>
    </sect1>

    <sect1 id="ddl-alter">
     <title>Modification des tables</title>

     <indexterm zone="ddl-alter">
      <primary>table</primary>
      <secondary>modification</secondary>
     </indexterm>

     <para>
      Lorsqu'une table est créée et qu'une erreur a été commise ou que les
      besoins de l'application changent, il est alors possible de la supprimer et
      de la récréer. Cela n'est toutefois pas pratique si la table contient
      déjà des données ou qu'elle est référencée par d'autres objets de la base
      de données (une contrainte de clé étrangère, par exemple). C'est pourquoi
      <productname>PostgreSQL</productname> offre une série de commandes
      permettant de modifier une table existante. Cela n'a rien à voir
      avec la modification des données contenues dans la table&nbsp;; il ne
      s'agit ici, que de modifier la définition, ou structure, de la table.
     </para>

     <para>
      Il est possible
      <itemizedlist spacing="compact">
       <listitem>
        <para>d'ajouter des colonnes&nbsp;;</para>
       </listitem>
       <listitem>
        <para>de supprimer des colonnes&nbsp;;</para>
       </listitem>
       <listitem>
        <para>d'ajouter des contraintes&nbsp;;</para>
       </listitem>
       <listitem>
        <para>de supprimer des contraintes&nbsp;;</para>
       </listitem>
       <listitem>
        <para>de modifier des valeurs par défaut&nbsp;;</para>
       </listitem>
       <listitem>
        <para>de modifier les types de données des colonnes&nbsp;;</para>
       </listitem>
       <listitem>
        <para>de renommer des colonnes&nbsp;;</para>
       </listitem>
       <listitem>
        <para>de renommer des tables.</para>
       </listitem>
      </itemizedlist>

      Toutes ces actions sont réalisées à l'aide de la commande
      <xref linkend="sql-altertable"/>,
      dont la page de référence est bien plus détaillée.
     </para>

     <sect2 id="ddl-alter-adding-a-column">
      <title>Ajouter une colonne</title>

      <indexterm>
       <primary>colonne</primary>
       <secondary>ajouter</secondary>
      </indexterm>

      <para>
       La commande d'ajout d'une colonne ressemble à&nbsp;:
       <programlisting>ALTER TABLE produits ADD COLUMN description text;</programlisting>
    La nouvelle colonne est initialement remplie avec la valeur par défaut
    précisée (NULL en l'absence de clause <literal>DEFAULT</literal>).
   </para>

   <para>
    Des contraintes de colonne peuvent être définies dans la même commande,
    à l'aide de la syntaxe habituelle&nbsp;:
<programlisting>ALTER TABLE produits ADD COLUMN description text CHECK (description &lt;&gt; '');</programlisting>
    En fait, toutes les options applicables à la description d'une colonne
    dans <command>CREATE TABLE</command> peuvent être utilisées ici. Il ne
    faut toutefois pas oublier que la valeur par défaut doit satisfaire les contraintes
    données. Dans le cas contraire, <literal>ADD</literal> échoue. Il est
    aussi possible d'ajouter les contraintes ultérieurement (voir ci-dessous) après
    avoir rempli la nouvelle colonne correctement.
   </para>

  <tip>
   <para>
    Ajouter une colonne avec une valeur par défaut nécessite la mise à jour
    de chaque ligne de la table pour stocker la valeur de la nouvelle colonne.
    Cependant, si aucune valeur par défaut n'est précisée,
    <productname>PostgreSQL</productname> peut éviter la mise à jour physique.
    Il est, de ce fait, préférable, si la colonne doit être remplie en majorité
    avec des valeurs différentes de la valeur par défaut, d'ajouter
    la colonne sans valeur par défaut, d'insérer les bonnes valeurs avec une
    commande <command>UPDATE</command> puis d'ajouter la valeur par défaut désirée
    comme décrit ci-dessus.
   </para>
  </tip>

  </sect2>

  <sect2 id="ddl-alter-removing-a-column">
   <title>Supprimer une colonne</title>

   <indexterm>
    <primary>colonne</primary>
    <secondary>supprimer</secondary>
   </indexterm>

   <para>
    La commande de suppression d'une colonne ressemble à celle-ci&nbsp;:
<programlisting>ALTER TABLE produits DROP COLUMN description;</programlisting>
    Toute donnée dans cette colonne disparaît. Les contraintes de table
    impliquant la colonne sont également supprimées. Néanmoins, si la colonne est
    référencée par une contrainte de clé étrangère d'une autre table,
    <productname>PostgreSQL</productname> ne supprime pas silencieusement
    cette contrainte. La suppression de tout ce qui
    dépend de la colonne peut être autorisée en ajoutant <literal>CASCADE</literal>&nbsp;:
<programlisting>ALTER TABLE produits DROP COLUMN description CASCADE;</programlisting>
    Voir la <xref linkend="ddl-depend"/> pour une description du mécanisme général.
   </para>
  </sect2>

  <sect2 id="ddl-alter-adding-a-constraint">
   <title>Ajouter une contrainte</title>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>ajouter</secondary>
   </indexterm>

   <para>
    Pour ajouter une contrainte, la syntaxe de contrainte de table est utilisée.
    Par exemple&nbsp;:
<programlisting>ALTER TABLE produits ADD CHECK (nom &lt;&gt; '');
ALTER TABLE produits ADD CONSTRAINT autre_nom UNIQUE (no_produit);
ALTER TABLE produits ADD FOREIGN KEY (id_groupe_produit) REFERENCES groupes_produits;</programlisting>
    Pour ajouter une contrainte NOT NULL, qui ne peut pas être écrite
    sous forme d'une contrainte de table, la syntaxe suivante est utilisée&nbsp;:
<programlisting>ALTER TABLE produits ALTER COLUMN no_produit SET NOT NULL;</programlisting>
   </para>

   <para>
    La contrainte étant immédiatement vérifiée, les données de la
    table doivent satisfaire la contrainte avant qu'elle ne soit ajoutée.
   </para>
  </sect2>

  <sect2 id="ddl-alter-removing-a-constraint">
   <title>Supprimer une contrainte</title>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>supprimer</secondary>
   </indexterm>

   <para>
    Pour supprimer une contrainte, il faut connaître son nom. Si elle a été
    explicitement nommé, il n'y a aucune difficulté. Dans le cas contraire,
    le système a engendré et attribué un nom qu'il faut découvrir. La commande
    <literal>\d <replaceable>table</replaceable></literal>
    de <application>psql</application> peut être utile ici&nbsp;; d'autres interfaces
    offrent aussi la possibilité d'examiner les détails de table. La commande est&nbsp;:
<programlisting>ALTER TABLE produits DROP CONSTRAINT un_nom;</programlisting>
    (Dans le cas d'un nom de contrainte engendré, comme <literal>$2</literal>,
    il est nécessaire de l'entourer de guillemets doubles pour en faire
    un identifiant valable.)
   </para>

   <para>
    Comme pour la suppression d'une colonne, <literal>CASCADE</literal> peut
    être ajouté pour supprimer une contrainte dont dépendent d'autres objets.
    Une contrainte de clé étrangère, par exemple, dépend d'une contrainte de
    clé primaire ou d'unicité sur la(les) colonne(s) référencée(s).
   </para>

   <para>
    Cela fonctionne de la même manière pour tous les types de contrainte,
    à l'exception des contraintes NOT NULL. Pour supprimer une contrainte NOT NULL,
    on écrit&nbsp;:
<programlisting>ALTER TABLE produits ALTER COLUMN no_produit DROP NOT NULL;</programlisting>
    (Les contraintes NOT NULL n'ont pas de noms.)
   </para>
  </sect2>

  <sect2>
   <title>Modifier la valeur par défaut d'une colonne</title>

   <indexterm>
    <primary>valeur par défaut</primary>
    <secondary>modifier</secondary>
   </indexterm>

   <para>
    La commande de définition d'une nouvelle valeur par défaut de colonne
    ressemble à celle-ci&nbsp;:
<programlisting>ALTER TABLE produits ALTER COLUMN prix SET DEFAULT 7.77;</programlisting>
    Cela n'affecte pas les lignes existantes de la table, mais uniquement la valeur
    par défaut pour les futures commandes <command>INSERT</command>.
   </para>

   <para>
    Pour retirer toute valeur par défaut, on écrit&nbsp;:
<programlisting>ALTER TABLE produits ALTER COLUMN prix DROP DEFAULT;</programlisting>
    C'est équivalent à mettre la valeur par défaut à NULL. En conséquence,
    il n'y a pas d'erreur à retirer une valeur par défaut qui n'a pas été définie
    car NULL est la valeur par défaut implicite.
   </para>
  </sect2>

  <sect2>
   <title>Modifier le type de données d'une colonne</title>

   <indexterm>
    <primary>type de données d'une colonne</primary>
    <secondary>modification</secondary>
   </indexterm>

   <para>
    La commande de conversion du type de données d'une colonne ressemble à celle-ci&nbsp;:
    <programlisting>ALTER TABLE produits ALTER COLUMN prix TYPE numeric(10,2);</programlisting>
    Elle ne peut réussir que si chaque valeur de la colonne peut être
    convertie dans le nouveau type par une conversion implicite. Si une
    conversion plus complexe est nécessaire, une clause
    <literal>USING</literal> peut être ajoutée qui indique comment calculer
    les nouvelles valeurs à partir des anciennes.
   </para>

   <para>
    <productname>PostgreSQL</productname> tente de convertir la valeur par défaut de la
    colonne le cas échéant, ainsi que toute contrainte impliquant la colonne. Mais ces
    conversions peuvent échouer ou produire des résultats surprenants. Il est
    souvent préférable de supprimer les contraintes de la colonne avant d'en
    modifier le type, puis d'ajouter ensuite les contraintes convenablement modifiées.
   </para>
  </sect2>

  <sect2>
   <title>Renommer une colonne</title>

   <indexterm>
    <primary>colonne</primary>
    <secondary>renommer</secondary>
   </indexterm>

   <para>
    Pour renommer une colonne&nbsp;:
<programlisting>ALTER TABLE produits RENAME COLUMN no_produit TO numero_produit;</programlisting>
   </para>
  </sect2>

  <sect2>
   <title>Renommer une table</title>

   <indexterm>
    <primary>table</primary>
    <secondary>renommer</secondary>
   </indexterm>

   <para>
    Pour renommer une table&nbsp;:
<programlisting>ALTER TABLE produits RENAME TO elements;</programlisting>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-priv">
  <title>Droits</title>

  <indexterm zone="ddl-priv">
   <primary>droit</primary>
  </indexterm>

  <indexterm>
   <primary>permission</primary>
   <see>droit</see>
  </indexterm>

  <indexterm zone="ddl-priv">
   <primary>propriétaire</primary>
  </indexterm>

  <indexterm zone="ddl-priv">
   <primary>GRANT</primary>
  </indexterm>

  <indexterm zone="ddl-priv">
   <primary>REVOKE</primary>
  </indexterm>

  <para>
   Quand un objet est créé, il se voit affecter un propriétaire. Le propriétaire
   est normalement le rôle qui a exécuté la requête de création. Pour la
   plupart des objets, l'état initial est que seul le propriétaire (et les
   superutilisateurs) peuvent faire quelque chose avec cet objet. Pour permettre
   aux autres rôles de l'utiliser, des <firstterm>droits</firstterm> doivent
   être donnés.
  </para>

  <para>
   Il existe un certain nombre de droits différents&nbsp;: <literal>SELECT</literal>,
   <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>,
   <literal>TRUNCATE</literal>, <literal>REFERENCES</literal>, <literal>TRIGGER</literal>,
   <literal>CREATE</literal>, <literal>CONNECT</literal>, <literal>TEMPORARY</literal>,
   <literal>EXECUTE</literal> et <literal>USAGE</literal>.
   Les droits applicables à un objet particulier varient
   selon le type d'objet (table, fonction...). La page de référence
   <xref linkend="sql-grant"/> fournit une
   information complète sur les différents types de droits gérés par
   <productname>PostgreSQL</productname>.  La section et
   les chapitres suivants présentent l'utilisation de ces droits.
  </para>

  <para>
   Le droit de modifier ou de détruire un objet est le privilège du seul propriétaire.
  </para>

  <para>
   Un objet peut se voir affecter un nouveau propriétaire avec la commande
   <command>ALTER</command> correspondant à l'objet, par exemple <xref
   linkend="sql-altertable"/>. Les superutilisateurs peuvent toujours le
   faire. Les rôles ordinaires peuvent seulement le faire s'ils sont le
   propriétaire actuel de l'objet (ou un membre du rôle propiétaire) et un
   membre du nouveau rôle propriétaire.
  </para>

  <para>
   La commande <command>GRANT</command> est
   utilisée pour accorder des privilèges.
   Par exemple, si <literal>joe</literal>
   est un rôle et <literal>comptes</literal> une table, le
   privilège d'actualiser la table <literal>comptes</literal> peut être accordé
   à <literal>joe</literal> avec&nbsp;:
<programlisting>GRANT UPDATE ON comptes TO joe;</programlisting>
   Écrire <literal>ALL</literal> à la place d'un droit spécifique accorde tous
   les droits applicables à ce type d'objet.
  </para>

  <para>
   Le nom de <quote>rôle</quote> spécial <literal>PUBLIC</literal> peut
   être utilisé pour donner un privilège à tous les rôles du système. De plus,
   les rôles de type <quote>group</quote> peuvent être configurés pour aider à
   la gestion des droits quand il y a beaucoup d'utilisateurs dans une base
   &mdash; pour les détails, voir <xref linkend="user-manag"/>.
  </para>

  <para>
   Pour révoquer un privilège, on utilise la commande bien-nommée
   <command>REVOKE</command>, comme dans l'exemple ci-dessous&nbsp;:
<programlisting>REVOKE ALL ON comptes FROM PUBLIC;</programlisting>
   Les privilèges spéciaux du propriétaire de l'objet (c'est-à-dire, le droit
   d'exécuter <command>DROP</command>, <command>GRANT</command>,
   <command>REVOKE</command>, etc.) appartiennent toujours implicitement au
   propriétaire. Il ne peuvent être ni
   accordés ni révoqués. Mais le propriétaire de l'objet peut choisir
   de révoquer ses propres droits ordinaires pour, par exemple, mettre
   une table en lecture seule pour lui-même et pour les autres.
  </para>

  <para>
   Habituellement, seul le propriétaire de l'objet (ou un superutilisateur)
   peut accorder ou révoquer les droits sur un objet. Néanmoins, il est possible
   de donner un privilège <quote>avec possibilité de transmission</quote>
   (<foreignphrase><quote>with grant option</quote></foreignphrase>), qui donne
   à celui qui le reçoit la permission de le donner à d'autres. Si cette option est ensuite
   révoquée, alors tous ceux qui ont reçu ce privilège par cet utilisateur
   (directement ou indirectement via la chaîne des dons) perdent ce privilège.
   Pour les détails, voir les pages de références
   <xref linkend="sql-grant"/> et
   <xref linkend="sql-revoke"/>.
  </para>
 </sect1>

 <sect1 id="ddl-rowsecurity">
  <title>Row Security Policies</title>

  <indexterm zone="ddl-rowsecurity">
   <primary>row-level security</primary>
  </indexterm>

  <indexterm zone="ddl-rowsecurity">
   <primary>politique</primary>
  </indexterm>

  <para>
   En plus des <link linkend="ddl-priv">système de droits</link> du
   standard SQL disponible via <xref linkend="sql-grant"/>, les
   tables peuvent avoir des <firstterm>politiques de sécurité pour
   l'accès aux lignes</firstterm>
   qui restreignent, utilisateur par utilisateur, les lignes qui
   peuvent être renvoyées par les requêtes d'extraction ou les
   commandes d'insertions, de mises à jour ou de suppressions. Cette
   fonctionnalité est aussi connue sous le nom <firstterm>Row-Level
   Security</firstterm>. Par défaut, les tables n'ont aucune politique
   de ce type pour que, si un utilisateur a accès à une table selon
   les droits du standard SQL, toutes les lignes de la table sont
   accessibles aux requêtes de lecture ou d'écriture.
  </para>

  <para>
   Lorsque la protection des lignes est activée sur une table (avec
   l'instruction <link linkend="sql-altertable">ALTER TABLE ... ENABLE
   ROW LEVEL SECURITY</link>), tous les accès classiques à la table
   pour sélectionner ou modifier des lignes doivent être autorisés par
   une politique de sécurité. Cependant, le propriétaire de la table
   n'est typiquement pas soumis aux politiques de sécurité. Si aucune
   politique n'existe pour la table, une politique de rejet est utilisé
   par défaut, ce qui signifie qu'aucune ligne n'est visible ou
   ne peut être modifiée. Les opérations qui s'appliquent pour
   la table dans sa globalité, comme <command>TRUNCATE</command>
   et <literal>REFERENCES</literal>, ne sont pas soumis à ces
   restrictions de niveau ligne.
  </para>

  <para>
   Les politiques de sécurité niveau ligne peuvent s'appliquer en particulier
   soit à des commandes, soit à des rôles, soit aux deux. Une politique
   est indiquée comme s'appliquant à toutes les commandes par
   <literal>ALL</literal>, ou seulement à <literal>SELECT</literal>,
   <literal>INSERT</literal>, <literal>UPDATE</literal> ou
   <literal>DELETE</literal>. Plusieurs rôles peuvent être affectés
   à une politique donnée, et les règles normales d'appartenance et
   d'héritage s'appliquent.
  </para>

  <para>
   Pour indiquer les lignes visibles ou modifiables pour une politique,
   une expression renvoyant un booléen est
   requise. Cette expression sera évaluée pour chaque ligne avant
   toutes conditions ou fonctions qui seraient indiquées dans les
   requêtes de l'utilisateur. (La seule exception à cette règle
   sont les fonctions marquées <literal>leakproof</literal>, qui annoncent ne
   pas dévoiler d'information&nbsp;; l'optimiseur peut choisir d'appliquer
   de telles fonctions avant les vérifications de sécurité niveau
   ligne). Les lignes pour lesquelles l'expression ne renvoie pas
   <literal>true</literal> ne sont pas traitées. Des expressions
   différentes peuvent être indiquées pour fournir des contrôles
   indépendants pour les lignes qui sont visibles et pour celles qui sont
   modifiées. Les expressions attachées à la politique sont exécutées
   dans le cours de la requête et avec les droits de l'utilisateur
   qui exécute la commande, bien que les fonctions définies avec
   l'attribut <literal>SECURITY DEFINER</literal> peuvent être utilisées pour accèder à des
   données qui ne seraient pas disponibles à l'utilisateur effectuant
   la requête.
  </para>

  <para>
   Les superutilisateurs et les roles avec l'attribut
   <literal>BYPASSRLS</literal> ne sont pas soumis au système de
   sécurité niveau ligne lorsqu'ils accèdent une table. Il en
   est de même par défaut du propriétaire d'une table, bien
   qu'il puisse choisir de se soumettre à ces contrôles avec
   <link linkend="sql-altertable">ALTER TABLE ... FORCE ROW LEVEL
   SECURITY</link>.
  </para>

  <para>
   L'activation ou la désactivation de la sécurité niveau ligne,
   comme de l'ajout des polices à une table, est toujours le privilège
   du seul propriétaire de la table.
  </para>

  <para>
   Les politiques sont créées en utilisant l'instruction <xref linkend="sql-createpolicy"/>,
   modifiées avec la commande <xref linkend="sql-alterpolicy"/>
   et supprimées avec la commande <xref linkend="sql-droppolicy"/>.
   Pour activer et désactiver la sécurité niveau ligne pour une table
   donnée, utilisez la commande <xref linkend="sql-altertable"/>.
  </para>

  <para>
   Chaque politique possède un nom et de multiples politiques peuvent être
   définies pour une table. Comme les politiques sont spécifiques à
   une table, chaque politique pour une même table doit avoir un nom
   différent. Différentes tables peuvent avoir des noms de politique de
   même nom.
  </para>

  <para>
   Lorque plusieurs politiques sont applicables pour une même requête,
   elles sont combinées en utilisant either <literal>OR</literal> (pour les
   politiques permissives, ce qui est le comportement par défaut) ou en
   utilisant <literal>AND</literal> (pour les politiques restrictives).  C'est
   similaire à la règle qu'un rôle donné à les privilèges de tous les rôles
   dont il est membre.  Les politiques permissives et restrictives sont
   discutées plus en détail ci-dessous.
  </para>

  <para>
   À titre de simple exemple, nous allons ici créer une politique sur
   la relation <literal>comptes</literal> pour autoriser seulement les
   membres du rôle <literal>admins</literal> à accèder seulement aux
   lignes de leurs propres comptes&nbsp;:
  </para>

<programlisting>
CREATE TABLE comptes (admin text, societe text, contact_email text);

ALTER TABLE comptes ENABLE ROW LEVEL SECURITY;

CREATE POLICY compte_admins ON comptes TO admins
    USING (admin = current_user);
</programlisting>

<para>
   Si aucun rôle n'est indiqué ou si le nom de pseudo rôle
   <literal>PUBLIC</literal> est utilisé, alors la politique s'applique
   à tous les utilisateurs du système. Pour autoriser tous les
   utilisateurs à accèder à leurs propres lignes dans une table
   <literal>utilisateurs</literal>, une simple politique peut être
   utilisée&nbsp;:
  </para>

<programlisting>
CREATE POLICY police_utilisateur ON utilisateurs
    USING (user_name = current_user);
</programlisting>

  <para>
   Pour utiliser une politique différente pour les lignes ajoutées à
   la table de celle appliquées pour les lignes visibles, la clause
   <literal>WITH CHECK</literal> peut être utilisée. Cette politique
   autorisera tous les utilisateurs à voir toutes les lignes de la
   table <literal>utilisateurs</literal>, mais seulement à modifier
   les leurs&nbsp;:
  </para>

<programlisting>
CREATE POLICY police_utilisateur ON utilisateurs
    USING (true)
    WITH CHECK (user_name = current_user);
</programlisting>

  <para>
   La sécurité niveau ligne peut également être désactivée avec
   la commande <command>ALTER TABLE</command>. La désactivation de la
   sécurité niveau ligne ne supprime pas les polices qui sont définies
   pour la table&nbsp;; elles sont simplement ignorées. L'ensemble des lignes
   sont alors visibles et modifiables, selon le système standard des
   droits SQL.
  </para>

  <para>
   Ci-dessous se trouve un exemple plus conséquent de la manière dont
   cette fonctionnalité peut être utilisée en production. La table
   <literal>passwd</literal> simule le fichier des mots de passe d'un
   système Unix.
  </para>

<programlisting>
-- Simple exemple basée sur le fichier passwd
CREATE TABLE passwd (
  user_name             text UNIQUE NOT NULL,
  pwhash                text,
  uid                   int  PRIMARY KEY,
  gid                   int  NOT NULL,
  real_name             text NOT NULL,
  home_phone            text,
  extra_info            text,
  home_dir              text NOT NULL,
  shell                 text NOT NULL
);

CREATE ROLE admin;  -- Administrateur
CREATE ROLE bob;    -- Utilisateur normal
CREATE ROLE alice;  -- Utilisateur normal

-- Chargement de la table
INSERT INTO passwd VALUES
  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
INSERT INTO passwd VALUES
  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
INSERT INTO passwd VALUES
  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');

-- Assurez vous d'activer le row level security pour la table
ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;

-- Créer les polices
-- L'administrateur peut voir toutes les lignes et en ajouter comme il le souhaite
CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
-- Les utilisateurs normaux peuvent voir toutes les lignes
CREATE POLICY all_view ON passwd FOR SELECT USING (true);
-- Les utilisateurs normaux peuvent mettre à jour leurs propres lignes,
-- tout en limitant les shells qu'ils peuvent choisir
CREATE POLICY user_mod ON passwd FOR UPDATE
  USING (current_user = user_name)
  WITH CHECK (
    current_user = user_name AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  );

-- Donner à admin tous les droits normaux
GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
-- Les utilisateurs ne peuvent que sélectionner des colonnes publiques
GRANT SELECT
  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
  ON passwd TO public;
-- Autoriser les utilisateurs à mettre à jour certaines colonnes
GRANT UPDATE
  (pwhash, real_name, home_phone, extra_info, shell)
  ON passwd TO public;
</programlisting>

  <para>
   Comme avec tous les réglages de sécurité, il est important de
   tester et de s'assurer que le système se comporte comme attendu. En
   utilisant l'exemple ci-dessus, les manipulations ci-dessous montrent
   que le système des droits fonctionne correctement
  </para>

<programlisting>
-- admin peut voir toutes les lignes et les colonnes
postgres=&gt; set role admin;
SET
postgres=&gt; table passwd;
 user_name | pwhash | uid | gid | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+--------+-----+-----+-----------+--------------+------------+-------------+-----------
 admin     | xxx    |   0 |   0 | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | xxx    |   1 |   1 | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | xxx    |   2 |   1 | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

-- Tester ce que Alice est capable de faire:
postgres=&gt; set role alice;
SET
postgres=&gt; table passwd;
ERROR:  permission denied for relation passwd
postgres=&gt; select user_name,real_name,home_phone,extra_info,home_dir,shell from passwd;
 user_name | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+-----------+--------------+------------+-------------+-----------
 admin     | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

postgres=&gt; update passwd set user_name = 'joe';
ERROR:  permission denied for relation passwd
-- Alice est autorisée à modifier son propre nom (real_name), mais pas celui des autres
postgres=&gt; update passwd set real_name = 'Alice Doe';
UPDATE 1
postgres=&gt; update passwd set real_name = 'John Doe' where user_name = 'admin';
UPDATE 0
postgres=&gt; update passwd set shell = '/bin/xx';
ERROR:  new row violates WITH CHECK OPTION for "passwd"
postgres=&gt; delete from passwd;
ERROR:  permission denied for relation passwd
postgres=&gt; insert into passwd (user_name) values ('xxx');
ERROR:  permission denied for relation passwd
-- Alice peut modifier son propre mot de passe; RLS empêche silencieusement la mise à jour d'autres lignes
postgres=&gt; update passwd set pwhash = 'abc';
UPDATE 1
</programlisting>

  <para>
   Toutes les politiques construites jusqu'à maintenant étaient des politiques
   permissives, ce qui veut dire que quand plusieurs politiques sont appliquées
   elles sont combinées en utilisant l'opérateur booléen <quote>OR</quote>.  Bien que les
   politiques permissives puissent être construites pour autoriser l'accès à
   des lignes dans les cas attendus, il peut être plus simple de combiner des
   politiques permissives avec des politiques restrictives (que
   l'enregistrement doit passer et qui sont combinées en utilisant l'opérateur
   booléen <quote>AND</quote>).  En continuant sur l'exemple ci-dessus, nous ajoutons une
   politique restrictive pour exiger que l'administrateur soit connecté via une
   socket unix locale pour accéder aux enregistrement de la table <literal>passwd</literal>&nbsp;:
  </para>

<programlisting>
CREATE POLICY admin_local_only ON passwd AS RESTRICTIVE TO admin
    USING (pg_catalog.inet_client_addr() IS NULL);
</programlisting>

  <para>
   Nous pouvons alors voir qu'un administrateur se connectant depuis le réseau
   ne verra aucun enregistrement, du fait de la politique restrictive :
  </para>

<programlisting>
=&gt; SELECT current_user;
 current_user 
--------------
 admin
(1 row)

=&gt; select inet_client_addr();
 inet_client_addr 
------------------
 127.0.0.1
(1 row)

=&gt; SELECT current_user;
 current_user 
--------------
 admin
(1 row)

=&gt; TABLE passwd;
 user_name | pwhash | uid | gid | real_name | home_phone | extra_info | home_dir | shell
-----------+--------+-----+-----+-----------+------------+------------+----------+-------
(0 rows)

=&gt; UPDATE passwd set pwhash = NULL;
UPDATE 0
</programlisting>

  <para>
   Les vérifications d'intégrité référentielle, tel que les
   contraintes d'unicité ou de clefs primaires et les références
   de clefs étrangères, passent toujours outre la sécurité niveau
   ligne pour s'assurer que l'intégrité des données est maintenue. Une
   attention particulière doit être prise lors de la mise en place des
   schémas et des politiques de sécurité de niveau ligne pour éviter le
   <quote>covert channel</quote> dévoilant des informations à travers
   de telles vérifications d'intégrité référentielle.
  </para>

  <para>
   Dans certains contextes, il est important d'être certain que la
   sécurité niveau ligne n'est pas appliquée. Par exemple, lors d'une
   sauvegarde, il y aurait des conséquences désastreuses si la sécurité niveau ligne
   a pour conséquence de soustraire silencieusement certaines lignes
   de la sauvegarde. Dans une telle situation, vous pouvez positionner
   le paramètre de configuration <xref linkend="guc-row-security"/>
   à <literal>off</literal>. En lui-même, ce paramètre ne passe pas
   outre la sécurité niveau ligne&nbsp;; ce qu'il fait, c'est qu'il lève une
   erreur si une des requêtes devait être filtrée par une police. La
   raison de l'erreur peut alors être recherchée et résolue.
  </para>

  <para>
   Dans les exemple ci-dessus, les expressions attachées aux polices
   considèrent uniquement les valeurs de la ligne courante accèdée
   ou modifiée. C'est le plus simple et le plus performant des cas&nbsp;;
   lorsque c'est possible, il est préférable de concevoir les
   applications qui utilisent cette fonctionnalité de la sorte. S'il
   est nécessaire de consulter d'autres lignes ou tables pour que
   la politique puisse prendre une décision, ceci peut être réalisé
   en utilisant dans les expressions des politiques des sous-requêtes
   <command>SELECT</command> ou des fonctions qui contiennent des
   commandes <command>SELECT</command>. Cependant, faites attention que
   de tels accès peuvent créer des accès concurrents qui pourraient
   permettre de dévoiler des informations si aucune précaution n'est
   prise. À titre d'exemple, considérez la création de la table
   suivante&nbsp;:
  </para>

<programlisting>
-- définition des droits de groupes
CREATE TABLE groupes (groupe_id int PRIMARY KEY,
                     nom_groupe text NOT NULL);

INSERT INTO groupes VALUES
  (1, 'bas'),
  (2, 'moyen'),
  (5, 'haut');

GRANT ALL ON groupes TO alice;  -- alice est l'administratrice
GRANT SELECT ON groupes TO public;

-- définition des niveaux de droits utilisateurs
CREATE TABLE utilisateurs (nom_utilisateur text PRIMARY KEY,
                    groupe_id int NOT NULL REFERENCES groupes);

INSERT INTO utilisateurs VALUES
  ('alice', 5),
  ('bob', 2),
  ('mallory', 2);

GRANT ALL ON utilisateurs TO alice;
GRANT SELECT ON utilisateurs TO public;

-- table contenant l'information à protéger
CREATE TABLE information (info text,
                          groupe_id int NOT NULL REFERENCES groupes);

INSERT INTO information VALUES
  ('peu secret', 1),
  ('légèrement secret', 2),
  ('très secret', 5);

ALTER TABLE information ENABLE ROW LEVEL SECURITY;

-- une ligne devrait être visible et modifiable pour les utilisateurs
-- dont le groupe_id est égal ou plus grand au groupe_id de la ligne
CREATE POLICY fp_s ON information FOR SELECT
  USING (groupe_id &lt;= (SELECT groupe_id FROM utilisateurs WHERE nom_utilisateur = current_user));
CREATE POLICY fp_u ON information FOR UPDATE
  USING (groupe_id &lt;= (SELECT groupe_id FROM utilisateurs WHERE nom_utilisateur = current_user));

-- nous comptons sur les RLS pour protéger la table information
GRANT ALL ON information TO public;
</programlisting>

  <para>
   Maintenant, supposez qu'<literal>alice</literal> souhaite modifier
   l'information <quote>légèrement secrète</quote>, mais décide que
   <literal>mallory</literal> ne devrait pas pouvoir obtenir ce nouveau
   contenu, elle le fait ainsi&nbsp;:
  </para>

<programlisting>
BEGIN;
UPDATE utilisateurs SET groupe_id = 1 WHERE nom_utilisateur = 'mallory';
UPDATE information SET info = 'caché à mallory' WHERE groupe_id = 2;
COMMIT;
</programlisting>

<para>
   Ceci semble correct, il n'y a pas de fenêtre pendant laquelle
   <literal>mallory</literal> devrait pouvoir accèder à la chaîne
   <quote>caché à mallory</quote>. Cependant il y a une situation de
   compétition ici. Si <literal>mallory</literal> fait en parallèle,
   disons&nbsp;:
<programlisting>
SELECT * FROM information WHERE groupe_id = 2 FOR UPDATE;
</programlisting>
   et sa transaction est en mode <literal>READ COMMITED</literal>, il est
   possible qu'elle voit <quote>caché à mallory</quote>. C'est possible
   si sa transaction accède la ligne <structname>information</structname>
   juste après qu'<literal>alice</literal> l'ai fait. Elle est
   bloquée en attendant que la transaction d'<literal>alice</literal>
   valide, puis récupère la ligne mise à jour grâce à la clause
   <literal>FOR UPDATE</literal>. Cependant, elle ne récupère
   <emphasis>pas</emphasis> une ligne mise à jour pour la commande
   implicite <command>SELECT</command> sur la table utilisateurs parce
   que cette sous-commande n'a pas la clause <literal>FOR UPDATE</literal>&nbsp;;
   à la place, la ligne <structname>utilisateurs</structname> est lue avec
   une image de la base de données prise au début de la requête. Ainsi,
   l'expression de la politique teste l'ancienne valeur du niveau de droit
   de <literal>mallory</literal> et l'autorise à voir la valeur mise
   à jour.
  </para>

  <para>
   Il y a plusieurs solutions à ce problème. Une simple réponse
   est d'utiliser <literal>SELECT ... FOR SHARE</literal> dans
   la sous-commande <command>SELECT</command> de la politique de
   sécurité niveau ligne. Cependant, ceci demande à donner le
   droit <literal>UPDATE</literal> sur la table référencée (ici
   <structname>utilisateurs</structname>) aux utilisateurs concernés, ce
   qui peut ne pas être souhaité. (Uune autre politique de sécurité
   niveau ligne pourrait être mise en place pour les empêcher d'exercer ce
   droit&nbsp;; ou la sous-commande <command>SELECT</command> pourrait
   être incluse dans une fonction marquée <literal>security definer</literal>).
   De plus, l'utilisation intensive concurrente de verrous partagés sur les
   lignes de la table référencée pourrait poser un problème de
   performance, tout spécialement si des mises à jour de cette table sont
   fréquentes. Une autre solution envisageable, si les mises à jour de
   la table référencée ne sont pas fréquentes, est de prendre un
   verrou exclusif sur la table référencée lors des mises à jour,
   de telle manière qu'aucune autre transaction concurrente ne pourrait
   consulter d'anciennes valeurs. Ou une transaction pourrait attendre que
   toutes les transactions se terminent après avoir validées une mise
   à jour de la table référencée et avant de faire des modifications
   qui reposent sur la nouvelle politique de sécurité.
  </para>

  <para>
   Pour plus de détails, voir <xref linkend="sql-createpolicy"/>
   et <xref linkend="sql-altertable"/>.
  </para>

 </sect1>

 <sect1 id="ddl-schemas">
  <title>Schémas</title>

  <indexterm zone="ddl-schemas">
   <primary>schéma</primary>
  </indexterm>

  <para>
   Un cluster de bases de données <productname>PostgreSQL</productname>
   contient une ou plusieurs base(s) nommée(s). Si les utilisateurs et groupes
   d'utilisateurs sont partagés sur l'ensemble du cluster, aucune
   autre donnée n'est partagée. Toute connexion cliente
   au serveur ne peut accéder qu'aux données d'une seule base, celle
   indiquée dans la requête de connexion.
  </para>

  <note>
   <para>
    Les utilisateurs d'un cluster n'ont pas obligatoirement le droit d'accéder à
    toutes les bases du cluster. Le partage des noms d'utilisateur signifie
    qu'il ne peut pas y avoir plusieurs utilisateurs nommés <literal>joe</literal>,
    par exemple, dans deux bases du même cluster&nbsp;; mais le système peut être
    configuré pour n'autoriser <literal>joe</literal> à accéder qu'à certaines bases.
   </para>
  </note>

<!-- Je ne sais pas si coller le (s) à la suite de la balise fermante passe...
-->
       <para>
        Une base de données contient un ou plusieurs
        <firstterm>schéma</firstterm>(s) nommé(s) qui, eux, contiennent des
        tables. Les schémas contiennent aussi d'autres
        types d'objets nommés (types de données, fonctions et opérateurs, par
        exemple).
        Le même nom d'objet peut être utilisé dans différents schémas sans conflit&nbsp;; par exemple,
        <literal>schema1</literal> et <literal>mon_schema</literal> peuvent tous les deux
        contenir une table nommée <literal>ma_table</literal>. À la différence des
        bases de données, les schémas ne sont pas séparés de manière rigide&nbsp;:
        un utilisateur peut accéder aux objets de n'importe quel schéma de la
        base de données à laquelle il est connecté, sous réserve qu'il en ait le
        droit.
       </para>

       <para>
        Il existe plusieurs raisons d'utiliser les schémas&nbsp;:

        <itemizedlist>
         <listitem>
          <para>
           autoriser de nombreux utilisateurs à utiliser une base de données
           sans interférer avec les autres&nbsp;;
          </para>
         </listitem>

         <listitem>
          <para>
           organiser les objets de la base de données en groupes logiques afin de faciliter
           leur gestion&nbsp;;
          </para>
         </listitem>

         <listitem>
          <para>
           les applications tiers peuvent être placées dans des schémas séparés
           pour éviter les collisions avec les noms d'autres objets.
          </para>
         </listitem>
        </itemizedlist>

        Les schémas sont comparables aux répertoires du système d'exploitation, à
        ceci près qu'ils ne peuvent pas être imbriqués.
       </para>

       <sect2 id="ddl-schemas-create">
        <title>Créer un schéma</title>

        <indexterm zone="ddl-schemas-create">
         <primary>schéma</primary>
         <secondary>créer</secondary>
        </indexterm>

        <para>
         Pour créer un schéma, on utilise la commande
         <xref linkend="sql-createschema"/>.
         Le nom du schéma est libre. Par exemple&nbsp;:
         <programlisting>CREATE SCHEMA mon_schema;</programlisting>
   </para>

   <indexterm>
    <primary>nom qualifié</primary>
   </indexterm>

   <indexterm>
    <primary>nom</primary>
    <secondary>qualifié</secondary>
   </indexterm>

   <para>
    Pour créer les objets d'un schéma ou y accéder, on écrit un
    <firstterm>nom qualifié</firstterm> constitué du nom du schéma et
    du nom de la table séparés par un point&nbsp;:
<synopsis><replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable></synopsis>
    Cela fonctionne partout où un nom de table est attendu, ce qui inclut les
    commandes de modification de la table et les commandes d'accès aux données
    discutées dans les chapitres suivants. (Pour des raisons de
    simplification, seules les tables sont évoquées, mais les mêmes principes
    s'appliquent aux autres objets nommés, comme les types et les
    fonctions.)
   </para>

   <para>
    La syntaxe encore plus générale
<synopsis><replaceable>base</replaceable><literal>.</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable></synopsis>
    peut aussi être utilisée, mais à l'heure actuelle, cette syntaxe n'existe
    que pour des raisons de conformité avec le standard SQL. Si un nom de base de
    données est précisé, ce doit être celui de la base à laquelle
    l'utilisateur est connecté.
   </para>

   <para>
    Pour créer une table dans le nouveau schéma, on utilise&nbsp;:
<programlisting>CREATE TABLE mon_schema.ma_table (
 ...
);</programlisting>
   </para>

   <indexterm>
    <primary>schéma</primary>
    <secondary>suppression</secondary>
   </indexterm>

   <para>
    Pour effacer un schéma vide (tous les objets qu'il contient ont été
    supprimés), on utilise&nbsp;:
<programlisting>DROP SCHEMA mon_schema;</programlisting>
    Pour effacer un schéma et les objets qu'il contient, on utilise&nbsp;:
<programlisting>DROP SCHEMA mon_schema CASCADE;</programlisting>
    La <xref linkend="ddl-depend"/> décrit le mécanisme général sous-jacent.
   </para>

   <para>
    Il n'est pas rare de vouloir créer un schéma dont un autre utilisateur est
    propriétaire (puisque c'est l'une des méthodes de restriction de l'activité des
    utilisateurs à des <foreignphrase>namespaces</foreignphrase> pré-définis).
    La syntaxe en est&nbsp;:
<programlisting>CREATE SCHEMA <replaceable>nom_schema</replaceable> AUTHORIZATION <replaceable>nom_utilisateur</replaceable>;</programlisting>
    Le nom du schéma peut être omis, auquel cas le nom de l'utilisateur est
    utilisé. Voir la <xref linkend="ddl-schemas-patterns"/> pour en connaître
    l'utilité.
   </para>

   <para>
    Les noms de schéma commençant par <literal>pg_</literal> sont réservés pour
    les besoins du système et ne peuvent être créés par les utilisateurs.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-public">
   <title>Le schéma public</title>

   <indexterm zone="ddl-schemas-public">
    <primary>schéma</primary>
    <secondary>public</secondary>
   </indexterm>

   <para>
    Dans les sections précédentes, les tables sont créées sans qu'un nom de
    schéma soit indiqué. Par défaut, ces tables (et les autres objets) sont
    automatiquement placées dans un schéma nommé <quote>public</quote>. Toute
    nouvelle base de données contient un tel schéma. Les instructions
    suivantes sont donc équivalentes&nbsp;:
<programlisting>CREATE TABLE produits ( ... );</programlisting>
    et&nbsp;:
<programlisting>CREATE TABLE public.produits ( ... );</programlisting>
   </para>
  </sect2>

  <sect2 id="ddl-schemas-path">
   <title>Chemin de parcours des schémas</title>

   <indexterm>
    <primary>chemin de recherche</primary>
   </indexterm>

   <indexterm>
    <primary>nom non qualifié</primary>
   </indexterm>

   <indexterm>
    <primary>nom</primary>
    <secondary>non qualifié</secondary>
   </indexterm>

   <para>
    Non seulement l'écriture de noms qualifiés est contraignante, mais il est,
    de toute façon, préférable de ne pas fixer un nom de schéma dans les
    applications. De ce fait, les tables sont souvent appelées par des
    <firstterm>noms non-qualifiés</firstterm>, soit le seul nom de la table.
    Le système détermine
    la table appelée en suivant un <firstterm>chemin de recherche</firstterm>,
    liste de schémas dans lesquels chercher. La première table correspondante
    est considérée comme la table voulue. S'il n'y a pas de correspondance, une
    erreur est remontée, quand bien même il existerait des tables dont le nom
    correspond dans d'autres schémas de la base.
   </para>

   <indexterm>
    <primary>schéma</primary>
    <secondary>courant</secondary>
   </indexterm>

   <para>
    Le premier schéma du chemin de recherche est appelé schéma courant.
    En plus d'être le premier schéma parcouru, il est aussi le schéma dans lequel
    les nouvelles tables sont créées si la commande <command>CREATE TABLE</command>
    ne précise pas de nom de schéma.
   </para>

   <indexterm>
    <primary>paramètre de configuration <varname>search_path</varname></primary>
   </indexterm>

   <para>
    Le chemin de recherche courant est affiché à l'aide de la commande&nbsp;:
<programlisting>SHOW search_path;</programlisting>
    Dans la configuration par défaut, ceci renvoie&nbsp;:
<screen> search_path
--------------
 "$user", public</screen>
    Le premier élément précise qu'un schéma de même nom que l'utilisateur
    courant est recherché. En l'absence d'un tel schéma, l'entrée est ignorée.
    Le deuxième élément renvoie au schéma public précédemment évoqué.
   </para>

   <para>
    C'est, par défaut, dans le premier schéma du chemin de recherche qui
    existe que sont créés les nouveaux objets. C'est la raison
    pour laquelle les objets sont créés, par défaut, dans le schéma public.
    Lorsqu'il est fait référence à un objet, dans tout autre contexte, sans
    qualification par un schéma (modification de table, modification de
    données ou requêtes), le chemin de recherche est traversé jusqu'à ce qu'un objet
    correspondant soit trouvé. C'est pourquoi, dans la configuration par défaut,
    tout accès non qualifié ne peut que se référer au schéma public.
   </para>

   <para>
    Pour ajouter un schéma au chemin, on écrit&nbsp;:
<programlisting>SET search_path TO mon_schema,public;</programlisting>
    (<literal>$user</literal> est omis à ce niveau car il n'est pas
    immédiatement nécessaire.) Il est alors possible d'accéder à la table
    sans qu'elle soit qualifiée par un schéma&nbsp;:
<programlisting>DROP TABLE ma_table;</programlisting>
    Puisque <literal>mon_schema</literal> est le premier élément du
    chemin, les nouveaux objets sont, par défaut, créés dans ce schéma.
   </para>

   <para>
    On peut aussi écrire&nbsp;:
<programlisting>SET search_path TO mon_schema;</programlisting>
    Dans ce cas, le schéma public n'est plus accessible sans qualification explicite.
    Hormis le fait qu'il existe par défaut, le schéma public n'a rien de
    spécial. Il peut même être effacé.
   </para>

   <para>
    On peut également se référer à la <xref linkend="functions-info"/>
    qui détaille les autres façons
    de manipuler le chemin de recherche des schémas.
   </para>

   <para>
    Le chemin de recherche fonctionne de la même façon pour les noms de type de
    données, les noms de fonction et les noms d'opérateur que pour les noms de
    table. Les noms des types de données et des fonctions peuvent être qualifiés de la
    même façon que les noms de table. S'il est nécessaire d'écrire un nom
    d'opérateur qualifié dans une expression, il y a une condition
    spéciale. Il faut écrire&nbsp;:
<synopsis><literal>OPERATOR(</literal><replaceable>schéma</replaceable><literal>.</literal><replaceable>opérateur</replaceable><literal>)</literal></synopsis>
    Cela afin d'éviter toute ambiguïté syntaxique. Par exemple&nbsp;:
<programlisting>SELECT 3 OPERATOR(pg_catalog.+) 4;</programlisting>
    En pratique, il est préférable de s'en remettre au chemin de recherche pour les opérateurs,
    afin de ne pas avoir à écrire quelque chose d'aussi étrange.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-priv">
   <title>Schémas et privilèges</title>

   <indexterm zone="ddl-schemas-priv">
    <primary>privilèges</primary>
    <secondary sortas="schemas">sur les schémas</secondary>
   </indexterm>

   <para>
    Par défaut, les utilisateurs ne peuvent pas accéder aux objets présents
    dans les schémas qui ne leur appartiennent pas. Pour le permettre, le
    propriétaire du schéma doit donner le droit <literal>USAGE</literal> sur
    le schéma. Pour autoriser les utilisateurs à manipuler les objets d'un
    schéma, des privilèges supplémentaires doivent éventuellement être accordés, en
    fonction de l'objet.
   </para>

   <para>
    Un utilisateur peut aussi être autorisé à créer des objets dans le
    schéma d'un d'autre. Pour cela, le privilège
    <literal>CREATE</literal> sur le schéma doit être accordé. Par défaut,
    tout le monde bénéficie des droits <literal>CREATE</literal> et
    <literal>USAGE</literal> sur le schéma <literal>public</literal>.
    Cela permet à tous les utilisateurs qui peuvent se connecter
    à une base de données de créer des objets dans son schéma
    <literal>public</literal>. Si cela ne doit pas être le cas, ce privilège
    peut être révoqué&nbsp;:
<programlisting>REVOKE CREATE ON SCHEMA public FROM PUBLIC;</programlisting>
    Le premier <quote>public</quote> est le schéma, le second
    <quote>public</quote> signifie <quote>tout utilisateur</quote>. Dans le
    premier cas, c'est un identifiant, dans le second, un mot clé,
    d'où la casse différente. (Se reporter aux règles de la
    <xref linkend="sql-syntax-identifiers"/>.)
   </para>
  </sect2>

  <sect2 id="ddl-schemas-catalog">
   <title>Le schéma du catalogue système</title>

   <indexterm zone="ddl-schemas-catalog">
    <primary>catalogue système</primary>
    <secondary>schéma</secondary>
   </indexterm>

   <para>
    En plus du schéma <literal>public</literal> et de ceux créés par les
    utilisateurs, chaque base de données contient un schéma
    <literal>pg_catalog</literal>. Celui-ci contient
    les tables systèmes et tous les types de données, fonctions et opérateurs
    intégrés. <literal>pg_catalog</literal> est toujours dans le chemin
    de recherche. S'il n'est pas nommé explicitement dans le chemin, il est
    parcouru implicitement <emphasis>avant</emphasis> le parcours des schémas
    du chemin. Cela garantit que les noms internes sont toujours accessibles.
    En revanche, <literal>pg_catalog</literal> peut être explicitement placé à la
    fin si les noms utilisateur doivent surcharger les noms internes.
   </para>

   <para>
    Comme les noms des catalogues systèmes commencent par <literal>pg_</literal>,
    il est préférable d'éviter d'utiliser de tels noms pour
    se prémunir d'éventuels conflits si une version ultérieure devait définir
    une table système qui porte le même nom que la table créée. (Le chemin de recherche par
    défaut implique qu'une référence non qualifiée à cette table pointe sur la table système).
    Les tables systèmes continueront de suivre la convention qui leur impose
    des noms préfixés par <literal>pg_</literal>. Il n'y a donc pas de
    conflit possible avec des noms de table utilisateur non qualifiés, sous
    réserve que les utilisateurs évitent le préfixe <literal>pg_</literal>.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-patterns">
   <title>Utilisation</title>

   <para>
    Les schémas peuvent être utilisés de différentes façons pour organiser
    les données. Certaines d'entre elles, recommandées, sont facilement supportés par la
    configuration par défaut&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       si aucun schéma n'est créé, alors tous les utilisateurs
       ont implicitement accès au schéma public. Cela permet de simuler une
       situation dans laquelle les schémas ne sont pas disponibles.
       Cette situation est essentiellement recommandée lorsqu'il n'y a qu'un
       utilisateur, ou un très petit nombre d'utilisateurs qui coopèrent au
       sein d'une base de données. Cette configuration permet aussi d'opérer
       une transition en douceur depuis un monde où les schémas sont inconnus&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       pour chaque utilisateur, un schéma, de nom identique à celui de
       l'utilisateur, peut être créé. Le chemin de recherche par défaut
       commence par <literal>$user</literal>, soit le nom de l'utilisateur.
       Si tous les utilisateurs disposent d'un schéma distinct, ils accèdent, par
       défaut, à leur propre schéma.
     <!--  </para>

      <para> -->
         Dans cette configuration, il est possible de révoquer l'accès
         au schéma public (voire de supprimer ce schéma)
         pour confiner les utilisateurs dans leur propre schéma&nbsp;;
        </para>
       </listitem>

       <listitem>
        <para>
         l'installation d'applications partagées (tables utilisables
         par tout le monde, fonctionnalités supplémentaires fournies par
         des applications tiers, etc) peut se faire dans des schémas distincts.
         Il faut alors accorder des privilèges appropriés
         pour permettre aux autres utilisateurs d'y accéder. Les utilisateurs
         peuvent alors se référer à ces objets additionnels en qualifiant
         leur nom du nom de schéma ou ajouter les schémas
         supplémentaires dans leur chemin de recherche, au choix.
        </para>
       </listitem>
      </itemizedlist>
     </para>
    </sect2>

    <sect2 id="ddl-schemas-portability">
     <title>Portabilité</title>

     <para>
      Dans le standard SQL, la notion d'objets d'un même schéma
      appartenant à des utilisateurs différents n'existe pas. De plus,
      certaines implantations ne permettent pas de créer des
      schémas de nom différent de celui de leur propriétaire.
      En fait, les concepts de schéma et d'utilisateur sont presque
      équivalents dans un système de base de données qui n'implante
      que le support basique des schémas tel que spécifié dans le standard.
      De ce fait, beaucoup d'utilisateurs considèrent les noms
      qualifiés comme correspondant en réalité à
      <literal><replaceable>utilisateur</replaceable>.<replaceable>table</replaceable></literal>.
      C'est comme cela que <productname>PostgreSQL</productname> se comporte
      si un schéma utilisateur est créé pour chaque utilisateur.
     </para>

     <para>
      Le concept de schéma <literal>public</literal> n'existe pas non plus dans le
      standard SQL. Pour plus de conformité au standard, le schéma
      <literal>public</literal> ne devrait pas être utilisé (voire être
      supprimé).
     </para>

     <para>
      Certains systèmes de bases de données n'implantent pas du
      tout les schémas, ou fournissent le support de
      <foreignphrase>namespace</foreignphrase> en
      autorisant (peut-être de façon limitée) l'accès inter-bases
      de données. Dans ce cas, la portabilité maximale est obtenue en n'utilisant
      pas les schémas.
     </para>
    </sect2>
   </sect1>

   <sect1 id="ddl-inherit">
    <title>L'héritage</title>

    <indexterm>
     <primary>héritage</primary>
    </indexterm>

    <indexterm>
     <primary>table</primary>
     <secondary>héritage</secondary>
    </indexterm>

    <para>
     <productname>PostgreSQL</productname> implante l'héritage des tables,
     qui peut s'avérer très utile pour les concepteurs de bases de données. (SQL:1999 et
     les versions suivantes définissent une fonctionnalité d'héritage de
     type qui diffère par de nombreux aspects des fonctionnalités décrites ici.)
    </para>

    <para>
     Soit l'exemple d'un modèle de données de villes. Chaque état comporte
     plusieurs villes mais une seule capitale. Pour récupérer rapidement la
     ville capitale d'un état donné, on peut créer deux tables, une pour les
     capitales et une pour les villes qui ne
     sont pas des capitales. Mais, que se passe-t'il dans le cas où toutes
     les données d'une ville doivent être récupérées, qu'elle soit une capitale
     ou non&nbsp;? L'héritage peut aider à résoudre ce problème. La
     table <structname>capitales</structname> est définie pour hériter de
     <structname>villes</structname>&nbsp;:

     <programlisting>CREATE TABLE villes (
    nom             text,
    population      float,
    altitude        int     -- (en pied)
);

CREATE TABLE capitales (
    etat           char(2)
) INHERITS (villes);</programlisting>

   Dans ce cas, la table <structname>capitales</structname> <firstterm>hérite</firstterm> de
   toutes les colonnes de sa table parent, <structname>villes</structname>. Les capitales
   ont aussi une colonne supplémentaire, <structfield>etat</structfield>, qui
   indique l'état dont elles sont capitales.
  </para>

  <para>
   Dans <productname>PostgreSQL</productname>, une table peut hériter de zéro
   à plusieurs autres tables et une requête faire référence aux
   lignes d'une table ou à celles d'une table et de ses
   descendantes. Ce dernier comportement est celui par défaut.
  </para>
  <para>
   Par exemple, la requête suivante retourne les noms et altitudes de toutes
   les villes, y compris les capitales, situées à une altitude supérieure
   à 500 pieds&nbsp;:

<programlisting>SELECT nom, altitude
    FROM villes
    WHERE altitude &gt; 500;</programlisting>

   Avec les données du tutoriel de <productname>PostgreSQL</productname>
   (voir <xref linkend="tutorial-sql-intro"/>), ceci renvoie&nbsp;:

<programlisting>   nom     | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845</programlisting>
  </para>

  <para>
   D'un autre côté, la requête suivante retourne les noms et altitudes
   de toutes les villes, qui ne sont
   pas des capitales, situées à une altitude supérieure à 500 pieds&nbsp;:

<programlisting>SELECT nom, altitude
    FROM ONLY villes
    WHERE altitude &gt; 500;

   nom     | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953</programlisting>
  </para>

  <para>
   Le mot clé <literal>ONLY</literal> indique que la requête s'applique
   uniquement
   aux <structname>villes</structname>, et non pas à toutes les tables en-dessous
   de <structname>villes</structname> dans la hiérarchie de l'héritage. Un
   grand nombre des commandes déjà évoquées &mdash;
   <command>SELECT</command>, <command>UPDATE</command> et
   <command>DELETE</command> &mdash; supportent le mot clé
   <literal>ONLY</literal>.
  </para>

  <para>
   Vous pouvez aussi écrire le nom de la table avec une <literal>*</literal>
   à la fin pour indiquer spécifiquement que les tables filles sont
   inclues&nbsp;:

<programlisting>SELECT name, altitude
    FROM cities*
    WHERE altitude &gt; 500;</programlisting>

   Écrire <literal>*</literal> n'est pas nécessaire, puisque ce comportement
   est toujours le comportement par défaut.  Toutefois, cette syntaxe est
   toujours supportée pour raison de compatibilité avec les anciennes versions
   où le comportement par défaut pouvait être changé.
  </para>

  <para>
  Dans certains cas, il peut être intéressant de savoir de quelle table provient une ligne
  donnée. Une colonne système appelée <structfield>TABLEOID</structfield>
  présente dans chaque table donne la table d'origine&nbsp;:

<programlisting>SELECT v.tableoid, v.nom, v.altitude
FROM villes v
WHERE v.altitude &gt; 500;</programlisting>

   qui renvoie&nbsp;:

<programlisting> tableoid |   nom     | altitude
----------+-----------+----------
   139793 | Las Vegas |     2174
   139793 | Mariposa  |     1953
   139798 | Madison   |      845</programlisting>

   (Reproduire cet exemple conduit probablement à des
   OID numériques différents). Une jointure avec
   <structname>pg_class</structname>, permet d'obtenir les noms réels des tables&nbsp;:

<programlisting>SELECT p.relname, v.nom, v.altitude
FROM villes v, pg_class p
WHERE v.altitude &gt; 500 AND v.tableoid = p.oid;</programlisting>

   ce qui retourne&nbsp;:

<programlisting> relname   |   nom     | altitude
-----------+-----------+----------
 villes    | Las Vegas |     2174
 villes    | Mariposa  |     1953
 capitales | Madison   |      845</programlisting>

  </para>

  <para>
   Une autre manière d'obtenir le même effet est d'utiliser le
   pseudo-type <type>regclass</type> qui affichera l'OID de la table de
   façon symbolique&nbsp;:

<programlisting>
SELECT v.tableoid::regclass, v.nom, v.altitude
FROM villes v
WHERE v.altitude &gt; 500;
</programlisting>
  </para>

  <para>
   L'héritage ne propage pas automatiquement les données des commandes
   <command>INSERT</command> ou <command>COPY</command> aux autres tables de
   la hiérarchie de l'héritage. Dans l'exemple considéré, l'instruction
   <command>INSERT</command> suivante échoue&nbsp;:
<programlisting>INSERT INTO villes (nom, population, altitude, etat)
VALUES ('Albany', NULL, NULL, 'NY');</programlisting>
   On pourrait espérer que les données soient magiquement routées vers la table
   <structname>capitales</structname> mais ce n'est pas le cas&nbsp;:
   <command>INSERT</command> insère toujours dans la table indiquée. Dans
   certains cas, il est possible de rediriger l'insertion en utilisant une
   règle (voir <xref linkend="rules"/>). Néanmoins, cela n'est d'aucune aide
   dans le
   cas ci-dessus car la table <structname>villes</structname> ne contient pas la
   colonne <structfield>etat</structfield>. La commande est donc rejetée avant que la
   règle ne soit appliquée.
  </para>

  <para>
   Toutes les contraintes de vérification et toutes les contraintes NOT NULL
   sur une table parent sont automatiquement héritées par les tables enfants,
   sauf si elles sont spécifiées explicitement avec des clauses <literal>NO
   INHERIT</literal>.
   Les autres types de contraintes (unicité, clé primaire, clé étrangère)
   ne sont pas hérités.
  </para>

  <para>
   Une table peut hériter de plusieurs tables, auquel cas elle possède
   l'union des colonnes définies par les tables mèress. Toute colonne déclarée
   dans la définition de la table enfant est ajoutée à cette dernière. Si le même nom
   de colonne apparaît dans plusieurs tables mères, ou à la fois dans une
   table mère et dans la définition de la table enfant, alors ces colonnes sont
   <quote>assemblées</quote> pour qu'il n'en existe qu'une dans la table
   enfant. Pour être assemblées, les colonnes doivent avoir le même type de
   données, sinon une erreur est levée. Les contraintes de vérification et les
   contraintes non NULL héritables sont assemblées de façon similaire. De ce
   fait, par exemple, une colonne assemblée sera marquée non NULL si une des
   définitions de colonne d'où elle provient est marquée non NULL. Les
   contraintes de vérification sont assemblées si elles ont le même nom, et
   l'assemblage échouera si leurs conditions sont différentes.
  </para>

  <para>
   L'héritage de table est établi à la création de la table
   enfant, à l'aide de la clause <literal>INHERITS</literal> de l'instruction
   <xref linkend="sql-createtable"/>.
   Alternativement, il est possible d'ajouter à une table, définie de façon
   compatible, une nouvelle relation de parenté à l'aide de la clause
   <literal>INHERIT</literal> de
   <xref linkend="sql-altertable"/>. Pour cela,
   la nouvelle table enfant doit déjà inclure des colonnes de mêmes nom et
   type que les colonnes de la table parent. Elle doit aussi contenir
   des contraintes de vérification de mêmes nom et expression que celles
   de la table parent.
  </para>
  <para>
   De la même façon, un lien d'héritage peut être supprimé
   d'un enfant à l'aide de la variante <literal>NO INHERIT</literal>
   d'<command>ALTER TABLE</command>. Ajouter et supprimer dynamiquement des liens
   d'héritage de cette façon est utile quand cette relation d'héritage est
   utilisée pour le partitionnement des tables (voir
   <xref linkend="ddl-partitioning"/>).
  </para>

  <para>
   Un moyen pratique de créer une table compatible en vue d'en faire
   ultérieurement une table enfant est d'utiliser la clause
   <literal>LIKE</literal> dans <command>CREATE TABLE</command>. Ceci crée
   une nouvelle table avec les même
   colonnes que la table source. S'il existe des contraintes
   <literal>CHECK</literal> définies sur la table source, l'option
   <literal>INCLUDING CONSTRAINTS</literal> de <literal>LIKE</literal> doit
   être indiquée car le nouvel enfant doit avoir des contraintes qui
   correspondent à celles du parent pour être considérée compatible.
  </para>

  <para>
   Une table mère ne peut pas être supprimée tant qu'elle a des enfants.
   Pas plus que les colonnes ou les contraintes de vérification des tables
   enfants ne peuvent être supprimées ou modifiées si elles sont héritées.
   La suppression d'une table et de tous ces descendants peut être aisément
   obtenue en supprimant la table mère avec l'option
   <literal>CASCADE</literal> (voir <xref linkend="ddl-depend"/>).
  </para>

  <para>
   <xref linkend="sql-altertable"/>
   propage toute modification dans les définitions des colonnes et
   contraintes de vérification à travers la hiérarchie d'héritage. Là encore,
   supprimer des colonnes qui dépendent d'autres tables mères n'est possible
   qu'avec l'option <literal>CASCADE</literal>. <command>ALTER TABLE</command>
   suit les mêmes règles d'assemblage de colonnes dupliquées et de rejet que
   l'instruction <command>CREATE TABLE</command>.
  </para>

  <para>
   Les requêtes sur tables héritées réalisent des vérifications de droit sur
   la table parent seulement. De ce fait, par exemple, donner le droit
   <literal>UPDATE</literal> sur la table <structname>villes</structname>
   implique que les droits de mise à jour des lignes dans la table
   <structname>capitales</structname> soient elles-aussi vérifiées quand elles
   sont accédées via la table <structname>villes</structname>. Ceci préserve
   l'apparence que les données proviennent (aussi) de la table parent. Mais la
   table <structname>capitales</structname> ne pouvait pas être mise à jour
   directement sans droit supplémentaire. De façon similaire, les politiques
   de sécurité au niveau ligne de la table parent (voir <xref
   linkend="ddl-rowsecurity"/>) sont appliquées aux lignes provenant des
   tables filles avec une requête héritée. Les politiques de tables enfant
   sont appliquées seulement quand la table enfant est explicitement nommée
   dans la requête. Dans ce cas, toute politique attachée à ses parents est
   ignorée.
  </para>

  <para>
   Les tables distantes (voir <xref linkend="ddl-foreign-data"/>)
   peuvent aussi participer aux hiérarchies d'héritage, soit comme
   table parente soit comme table enfant, comme les tables standards
   peuvent l'être. Si une table distante fait partie d'une hiérarchie
   d'héritage, toutes les opérations non supportées par la table
   étrangère ne sont pas non plus supportées sur l'ensemble de la
   hiérarchie.
  </para>

 <sect2 id="ddl-inherit-caveats">
  <title>Restrictions</title>

  <para>
   Notez que toutes les commandes SQL fonctionnent avec les
   héritages. Les commandes utilisées pour récupérer des données, pour modifier
   des données ou pour modifier le schéma (autrement dit
   <literal>SELECT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>,
   la plupart des variantes de <literal>ALTER TABLE</literal>, mais pas
   <literal>INSERT</literal> ou <literal>ALTER TABLE ... RENAME</literal>)
   incluent par défaut les tables filles et supportent la notation
   <literal>ONLY</literal> pour les exclure. Les commandes qui font de la
   maintenance de bases de données et de la configuration (par exemple
   <literal>REINDEX</literal>, <literal>VACUUM</literal>) fonctionnent
   typiquement uniquement sur les tables physiques, individuelles et ne
   supportent pas la récursion sur les tables de l'héritage. Le comportement
   respectif de chaque commande individuelle est documenté dans la référence
   (<xref linkend="sql-commands"/>).
  </para>

  <para>
    Il existe une réelle limitation à la fonctionnalité d'héritage&nbsp;: les index
    (dont les contraintes d'unicité) et les contraintes de clés étrangères
    ne s'appliquent qu'aux tables mères, pas à leurs héritiers. Cela
    est valable pour le côté référençant et le côté référencé d'une contrainte
    de clé étrangère. Ce qui donne, dans les termes de l'exemple ci-dessus&nbsp;:

    <itemizedlist>
      <listitem>
        <para>
          si <structname>villes</structname>.<structfield>nom</structfield>
	  est déclarée <literal>UNIQUE</literal> ou clé primaire
	  (<literal>PRIMARY KEY</literal>), cela n'empêche pas la table
	  <structname>capitales</structname> de posséder des lignes
          avec des noms dupliqués dans <structname>villes</structname>. Et ces lignes
          upliquées s'affichent par défaut dans les requêtes sur
          <structname>villes</structname>. En fait, par défaut,
          <structname>capitales</structname> n'a pas de contrainte
          d'unicité du tout et, du coup, peut contenir plusieurs lignes avec le
          même nom. Une contrainte d'unicité peut être ajoutée à
          <structname>capitales</structname> mais cela n'empêche pas la duplication
          avec <structname>villes</structname>&nbsp;;
        </para>
      </listitem>

      <listitem>
        <para>
          de façon similaire, si
          <structname>villes</structname>.<structfield>nom</structfield> fait référence
          (<literal>REFERENCES</literal>) à une autre table, cette contrainte
	  n'est pas automatiquement propagée à
	  <structname>capitales</structname>. Il est facile de contourner ce
	  cas de figure en ajoutant manuellement la même contrainte
	  <literal>REFERENCES</literal> à
	  <structname>capitales</structname>&nbsp;;
        </para>
      </listitem>

      <listitem>
        <para>
          si une autre table indique <literal>REFERENCES villes(nom)</literal>,
	  cela l'autorise à contenir les noms des villes mais pas les noms des
	  capitales. Il n'existe pas de contournement efficace de ce cas.
        </para>
      </listitem>
    </itemizedlist>

    Ces déficiences seront probablement corrigées dans une version future,
    mais, en attendant, il est obligatoire de réfléchir consciencieusement à l'utilité
    de l'héritage pour une application donnée.
  </para>

   </sect2>
  </sect1>

  <sect1 id="ddl-partitioning">
   <title>Partitionnement de tables</title>

   <indexterm>
    <primary>partitionnement</primary>
   </indexterm>

   <indexterm>
    <primary>table</primary>
    <secondary>partitionnement</secondary>
   </indexterm>

   <indexterm>
    <primary>table partitionnée</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> offre un support basique du
    partitionnement de table. Cette section explique pourquoi et comment
    implanter le partitionnement lors de la conception de la base
    de données.
   </para>

   <sect2 id="ddl-partitioning-overview">
     <title>Aperçu</title>

   <para>
    Le partitionnement fait référence à la division d'une table logique
    volumineuse en plusieurs parties physiques plus petites. Le partitionnement comporte
    de nombreux avantages&nbsp;:
   <itemizedlist>
    <listitem>
     <para>
     <!-- substitutes for ? -->
     les performances des requêtes peuvent être significativement améliorées
     dans certaines situations, particulièrement lorsque la plupart des lignes
     fortement accédées d'une table se trouvent sur une seule partition ou sur un
     petit nombre de partitions. Le partitionnement se substitue aux colonnes
     principales des index, réduisant ainsi la taille des index et facilitant
     la tenue en mémoire des parties les plus utilisées de l'index&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     lorsque les requêtes ou les mises à jour accèdent à un important pourcentage
     d'une seule partition, les performances peuvent être grandement améliorées
     par l'utilisation avantageuse de parcours séquentiels sur cette
     partition plutôt que d'utiliser un index et des lectures aléatoires
     réparties sur toute la table&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     les chargements et suppressions importants de données peuvent être
     obtenus par l'ajout ou la suppression de partitions, sous réserve que ce
     besoin ait été pris en compte lors de la conception du partitionnement.
     Exécuter <command>ALTER TABLE DETACH PARTITION</command> ou supprimer une
     partition individuelle en utilisant <command>DROP TABLE</command> est bien
     plus rapide qu'une opération de masse.  Cela supprime également la
     surcharge dû au <command>VACUUM</command> causé par un
     <command>DELETE</command> massif&nbsp;;
    </para>
   </listitem>

   <listitem>
    <para>
     les données peu utilisées peuvent être déplacées sur un média de
     stockage moins cher et plus lent.
    </para>
   </listitem>
  </itemizedlist>

  Les bénéfices ne sont réellement intéressants que si cela permet d'éviter une
  table autrement plus volumineuse. Le point d'équilibre exact à partir
  duquel une table tire des bénéfices du partitionnement dépend de
  l'application. Toutefois, le partitionnement doit être envisagé si
  la taille de la table peut être amenée à dépasser la taille de la
  mémoire physique du serveur.
 </para>

 <para>
  <productname>PostgreSQL</productname> offre un support natif pour les formes
  suivantes de partitionnement :

  <variablelist>
   <varlistentry>
    <!-- range ? Intervalle -->
    <term>Partitionnement par intervalles</term>

    <!-- overlap ? Recouvrement, chevauchement... -->
    <listitem>
     <para>
      La table est partitionnée en <quote>intervalles</quote> (ou échelles)
      définis par une colonne clé ou par un ensemble de colonnes, sans
      recouvrement entre les intervalles de valeurs affectées aux différentes
      partitions. Il est possible, par exemple, de partitionner par échelles de
      date ou par intervalles d'identifiants pour des objets métier
      particuliers.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Partitionnement par liste</term>

    <listitem>
     <para>
      La table est partitionnée en listant explicitement les valeurs clés
      qui apparaissent dans chaque partition.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

     Si votre application nécessite d'utiliser d'autres formes de
     partitionnement qui ne sont pas listées au-dessus, des méthodes
     alternatives comme l'héritage et des vues <literal>UNION ALL</literal>
     peuvent être utilisées à la place.  De telles méthodes offrent de la
     flexibilité mais n'ont pas certains des bénéfices de performance du
     partitionnement déclaratif natif.
 </para>
</sect2>

  <sect2 id="ddl-partitioning-declarative">
   <title>Partitionnement Declaratif</title>

   <para>
    <productname>PostgreSQL</productname> donne un moyen de spécifier comment
    diviser une table en morceaux appelés partitions.  La table qui est divisée
    est appelée <firstterm>table partitionnée</firstterm>.  La spécification
    consiste en une <firstterm>méthode de partitionnement</firstterm> et une
    liste de colonnes ou expression à utiliser comme la <firstterm>clé de
        partitionnement</firstterm>.
   </para>

   <para>
    Toutes les lignes insérées dans la table partitionnées seront redirigées
    vers une des <firstterm>partitions</firstterm> en se basant sur la valeur
    de la clé de partitionnement.  Chaque partition a un sous-ensemble des
    données défini par ses <firstterm>limites de partition</firstterm>.  Pour
    l'instant, les méthodes de partitionnement supportées sont le
    partitionnement par intervalles et par liste, où on assigne à chaque
    partition respectivement un intervalle de clés et une liste de clé.
   </para>

   <para>
    Les partitions peuvent elle-même être définies comme des tables
    partitionnées, en utilisant ce qu'on appelle du
    <firstterm>sous-partitionnement</firstterm>.  Les partitions peuvent avoir
    leur propres index, contraintes et valeurs par défaut, différentes de
    celles des autres partitions.  Les index doivent être créés séparément pour
    chaque partition.  Voir <xref linkend="sql-createtable"/> pour plus de
    détails sur la création des tables partitionnées et des partitions.
   </para>

   <para>
    Il n'est pas possible de transformer une table standard en table
    partitioner et inversement.  Par contre, il est possible d'ajouter une
    table standard ou une table partitionnée contenant des données comme une
    partition d'une table partitionnée, ou de supprimer une partition d'une
    table partitionnée la transformant en table standard; voir <xref
        linkend="sql-altertable"/> pour en apprendre plus sur les sous
    commandes <command>ATTACH PARTITION</command> et <command>DETACH
        PARTITION</command>.
   </para>

   <para>
    Dans les fait les partitions individuelles sont liées à la table
    partitionnées grâce à l'héritage; il n'est pas possible d'utiliser une
    partie des fonctionnalités de l'héritage vues dans la section précédentes
    avec les tables partitionnées et les partitions.  Par exemple, une
    partition ne peut pas avoir d'autre parent qu'une table partitionnée dont
    elle est une partition, et une table standard ne peut pas hériter d'une
    table partitionnée faisant d'elle son parent.  Cela veut dire que les
    tables partitionnées et les partitions ne participent pas à l'héritage avec
    les tables standard.  Puisqu'une hiérarchie de partition étant constituée
    d'une table partitionnée et ses partitions il s'agit toujours d'une
    hiérarchie d'héritage, toutes les règles normales de l'héritage
    s'appliquent comme décrit dans <xref linkend="ddl-inherit"/> avec quelques
    exception, les plus notables étant :

    <itemizedlist>
     <listitem>
      <para>
       Les contraintes <literal>CHECK</literal> et <literal>NOT NULL</literal>
       d'une table partitionnées sont toujours héritées par toutes les
       partitions.  La création de contraintes <literal>CHECK</literal> qui
       sont marquées comme <literal>NO INHERIT</literal> n'est pas autorisée
       sur une table partitionnée.  partitioned tables.
      </para>
     </listitem>

     <listitem>
      <para>
       Utiliser <literal>ONLY</literal> pour ajouter ou supprimer une
       contrainte sur la table partitionnée uniquement est supporter s'il n'y a
       pas de partitionK  Une fois qu'il existe des partitions, utiliser
       <literal>ONLY</literal> remontera une erreur puisqu'ajouter ou supprimer
       des contraintes sur uniquement la table partitionnée, quand des
       partitions existent, n'est pas supporté.  À la place, des contraintes
       peuvent être ajoutées ou supprimées, quand elles ne sont pas présentes
       sur la table parente, diretement sur les partitions.  Comme une table
       partitionnée ne contient jamais de données directement, essayer
       d'utiliser <command>TRUNCATE</command> <literal>ONLY</literal> sur une
       table partitionnée retournera toujours une erreur.
      </para>
     </listitem>

     <listitem>
      <para>
       Les partitions ne peuvent pas avoir de colonnes qui ne sont pas
       présentes dans le parent.  Il n'est pas non plus possible de spécifier
       des colonnes quand une partition est crée avec <command>CREATE
           TABLE</command> pas plus qu'il n'est possible d'ajouter des colonnes
       aux partitions une fois celles-ci crées en utilisant <command>ALTER
           TABLE</command>.  Des tables peuvent être ajoutée comme des
       partitions avec <command>ALTER TABLE ... ATTACH PARTITION</command>
       seulement si leurs colonnes correspondent exactement à celles du parent,
       en incluant toutes les colonnes <literal>oid</literal>.
      </para>
     </listitem>

     <listitem>
      <para>
       Vous ne pouvez pas supprimer la contrainte <literal>NOT NULL</literal>
       d'une colonne d'une partition si la contrainte est présente dans la
       table parente.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Les partitions peuvent également être des tables étrangères (voir
    <xref linkend="sql-createforeigntable"/>), bien que ce cas ait des
    limitations qui n'existent pas avec des tables normales.  Par exemple, les
    données insérées dans la table partitionnée ne sont pas redirigées vers la
    partition qui est une table étrangère.
   </para>

   <sect3 id="ddl-partitioning-declarative-example">
    <title>Exemple</title>

   <para>
    Imaginons que nous sommes en train de construire une base de données pour
    une grande société de crème glacée.  La société mesure les pics de
    températures chaque jours ainsi que les ventes de crème glacée dans chaque
    région.  Conceptuellement, nous voulons une table comme ceci :

<programlisting>CREATE TABLE mesure (
    id_ville        int not null,
    date_trace      date not null,
    temperature     int,
    ventes          int
);</programlisting>

     La plupart des requêtes n'accèdent qu'aux données de la dernière
     semaine, du dernier mois ou du dernier trimestre car cette table est
     essentiellement utilisée pour préparer des rapports en ligne pour la
     direction. Pour réduire le nombre de données anciennes à stocker,
     seules les trois dernières années sont conservées. Au début
     de chaque mois, les données du mois le plus ancien sont supprimées.
     Dans cette situation, le partitionnement permet de répondre aux
     différents besoins identifiés sur la table des mesures.
    </para>

   <para>
    Pour utiliser le partitionnement déclaratif dans ce cas d'utilisation, il
    faut utiliser les étapes suivantes :

    <orderedlist spacing="compact">
     <listitem>
      <para>
       Créer une table <structname>measurement</structname> comme une table
       partitionnée en spécifiant la clause <literal>PARTITION BY</literal>, ce
       qui inclue la méthode de partitionnement ( <literal>RANGE</literal> dans
       ce cas) ainsi que la liste de la ou les colonnes à utiliser comme clé de
       partitionnement.
<programlisting>+CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
</programlisting>
       </para>

      <para>
       Vous pourriez décider d'utiliser plusieurs colonnes dans la clé de
       partitionnement pour le partitionnement par intervalles, si vous le
       souhaitez.  Bien sûr, cela aura souvent pour conséquence un plus grand
       nombre de partitions, chacune étant individuellement plus petite.  D'un
       autre côté, utiliser moins de partitions pourrait entraîner un critère
       de partitionnement plus grossier et moins de partitions.  Une requête
       accédants à la table partitionnée aura à parcourir moins de partitions
       si les conditions implique une partie ou la totalité de ces colonnes.
       Par exemple, imaginez une table partitionner par intervalles utilisant
       les colonnes <structfield>lastname</structfield> et
       <structfield>firstname</structfield> (dans cet ordre) comme clé de
       partitionnement.
      </para>
     </listitem>

     <listitem>
      <para>
       Créez les partitions.  La définition de chaque partition doit spécifier
       les limites qui correspondent à la méthode de partitionnement ainsi qu'à
       la clé de partitionnement du parent.  Veuillez noter que spécifier des
       limites telles que les valeurs de la nouvelle partition pourront se
       chevaucher avec celles d'une ou plusieurs autres partitions retournera
       une erreur.  Insérer des données dans la table parents qui ne ne
       correspondent pas à une des partitions existante remontera une erreur;
       la partition appropriée doit être ajoutée manuellement.
      </para>

      <para>
       les partitions ainsi crées sont de tous les points de vue des table
       <productname>PostgreSQL</productname> normales (ou, potentiellement, des
       tables étrangères).  Il est possible de spécifier une tablespace et des
       paramètres de stockage pour chacune des partitions séparément.
      </para>

      <para>
       Il n'est pas nécessaire de créer les contraintes de table décrivant les
       conditions limites de la partition pour les partitions.  À la place, des
       contraintes de partitions sont générées implicitement à partir de la
       spécification de limite de partition chaque fois qu'il est nécessaire de
       s'y référer.

 <programlisting>
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01')

CREATE TABLE measurement_y2006m03 PARTITION OF measurement
    FOR VALUES FROM ('2006-03-01') TO ('2006-04-01')

 ...
CREATE TABLE measurement_y2007m11 PARTITION OF measurement
    FOR VALUES FROM ('2007-11-01') TO ('2007-12-01')

CREATE TABLE measurement_y2007m12 PARTITION OF measurement
    FOR VALUES FROM ('2007-12-01') TO ('2008-01-01')
    TABLESPACE fasttablespace;

CREATE TABLE measurement_y2008m01 PARTITION OF measurement
    FOR VALUES FROM ('2008-01-01') TO ('2008-02-01')
    TABLESPACE fasttablespace
    WITH (parallel_workers = 4);
 </programlisting>
      </para>

      <para>
       Pour implémenter le sous-partitionnement, spécifiez la clause
       <literal>PARTITION BY</literal> dans les commandes utilisées pour créer
       des partitions individuelle, par exemple :

<programlisting>
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01')
    PARTITION BY RANGE (peaktemp);
</programlisting>

       Après avoir crée les partition de
       <structname>measurement_y2006m02</structname>, toute donnée insérée dans
       <structname>measurement</structname> qui correspond à
       <structname>measurement_y2006m02</structname> (ou donnée qui est
       directement insérée dans <structname>measurement_y2006m02</structname>,
       sous réserve qu'elle satisfasse sa contrainte de partition) sera
       redirigée vers l'une de ses partitions en se basant sur la colonne
       <structfield>peaktemp</structfield>.  La clé de partition spécifiée
       pourrait se chevaucher avec la clé de partition du parent, il faut donc
       faire spécialement attention lorsque les limites d'une sous-partition
       sont spécifiée afin que l'ensemble de donnée qu'elle accepte constitue
       un sous-ensemble de ce que les propres limites de la partition accepte;
       le système n'essayera pas de vérifier si c'est vraiment le cas.
      </para>
     </listitem>

     <listitem>
      <para>
        Créer un index sur la ou les colonnées de la clé, ainsi que tout autre
        index vous pourriez vouloir pour chaque partition.  (L'index sur la clé
        n'est pas strictement nécessaire, mais c'est utile dans la plupart des
        scénario.  Si vous voulez que les valeurs de la clé soient unique alors
        vous devriez toujours créer un index unique ou une contrainte de clé
        primaire pour chaque partition.)
     </para>

<programlisting>CREATE INDEX ON measurement_y2006m02 (logdate);
CREATE INDEX ON measurement_y2006m03 (logdate);
...
CREATE INDEX ON measurement_y2007m11 (logdate);
CREATE INDEX ON measurement_y2007m12 (logdate);
CREATE INDEX ON measurement_y2008m01 (logdate);</programlisting>
       <para>
        Assurez vous que le paramètre de configuration <xref
            linkend="guc-constraint-exclusion"/> ne soit pas désactivé dans
        <filename>postgresql.conf</filename>.  S'il l'et, les requêtes ne
        seront pas optimisée comme voulu.
        </para>
       </listitem>
    </orderedlist>
   </para>

   <para>
    Dans l'exemple ci-dessus nous créerions une nouvelle partition chaque mois,
    il serait donc avisé d'écrire un script qui génère le DDL nécessaire
    automatiquement.
   </para>
   </sect3>

   <sect3 id="ddl-partitioning-declarative-maintenance">
    <title>Maintenance des partitions</title>

    <para>
      Normalement l'ensemble des partitions établie lors que de définition
      initiale de la table n'a pas vocation à demeurer statique.  Il est normal
      de vouloir supprimer d'anciennes partitions de données et périodiquement
      ajouter de nouvelles partitions pour les nouvelles données.  Un des
      avantages les plus importants du partitionnement est précisément qu'il
      permet d'exécuter cette tâche de maintenance normalement pénible
      instantanément en manipulant la structure de la partition, plutôt que de
      physiquement bouger de grands ensemble de données.
    </para>

    <para>
     Le moyen le plus simple pour supprimer d'anciennes données est de
     supprimer la partition qui n'est plus nécessaire :
<programlisting>
DROP TABLE measurement_y2006m02;
</programlisting>
     Cela peut supprimer des millions d'enregistrement très rapidement car il
     n'est pas nécessaire de supprimer chaque enregistrement séparément.
     Veuillez noter toutefois que la commande ci-dessus nécessaire de prendre
     un verrou de type <literal>ACCESS EXCLUSIVE</literal> sur la table
     parente.
    </para>

   <para>
     Une autre possibilité qui est généralement préférable est de supprimer la
     partition de la table partitionnée mais de la conserver en tant que table
     :

<programlisting>
ALTER TABLE measurement DETACH PARTITION measurement_y2006m02;
</programlisting>

     Cela permet d'effectuer ensuite d'autres opérations sur les données avant
     de la supprimer.  Par exemple, il s'agit souvent du moment idéal pour
     sauvegarder les données en utilisant <command>COPY</command>,
     <application>pg_dump</application>, ou des outils similaires.  Cela
     pourrait également être le bon moment pour agréger les données dans un
     format moins volumineux, effectuer d'autres manipulations de données ou
     exécuter des rapports.
   </para>

   <para>
     De la même manière nous pouvons ajouter une nouvelle partition pour gérer
     les nouvelles données.  Nous pouvons créer une partition vide dans la
     table partitionnée exactement comme la première partition a été crée
     précédemment :

<programlisting>
CREATE TABLE measurement_y2008m02 PARTITION OF measurement
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01')
    TABLESPACE fasttablespace;
</programlisting>

     De manière alternative, il est parfois plus utile de créer la nouvelle
     table en dehors de la structure de la partition, et d'en faire une
     partition plus tard.  Cela permet de charger des données, les vérifier et
     effectuer des transformations avant que les donnés apparaissent dans la
     table partitionnée :

<programlisting>
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS)
  TABLESPACE fasttablespace;

ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );

\copy measurement_y2008m02 from 'measurement_y2008m02'
-- possibly some other data preparation work

ALTER TABLE measurement ATTACH PARTITION measurement_y2008m02
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01' );
</programlisting>
    </para>

    <para>
     Avant d'exécuter une commande <command>ATTACH PARTITION</command>, il est
     recommannder de créer une contrainte <literal>CHECK</literal> sur la table
     qui doit être attachée décrivant la contrainte de partition désirée.  De
     cette manière le système n'aura pas besoin d'effectuer une parcours de la
     table pour valider la contrainte de partition implicite.  Sans une telle
     contrainte, la table sera parcourue pour valider la contrainte de
     partition tout en ayant un verrou de niveau <literal>ACCESS
         EXCLUSIVE</literal> sur la table parente.  Vous pouvez alors supprimer
     la contrainte après que <command>ATTACH PARTITION</command> soit fini, car
     elle n'est plus nécessaire.
    </para>
   </sect3>

   <sect3 id="ddl-partitioning-declarative-limitations">
    <title>Limitations</title>

   <para>
    Les limitations suivantes s'appliquent aux tables partitionnées :
    <itemizedlist>
     <listitem>
      <para>
       Il n'y a pas de commande disponible pour créer les index correspondant
       sur toutes les partitions automatiquement.  Les index doivent être
       ajoutés sur chaque partition avec des commandes séparées.  Cela signifie
       également qu'il n'y a pas de moyen de créer une clé primaire, un index
       unique ou une contrainte d'exclusion couvrant toutes les partitions; il
       est seulement possible de contraindre chaque partition de niveau feuille
       individuellement.
      </para>
     </listitem>

     <listitem>
      <para>
       Puisque les clés primaires ne sont pas supportées sur les tables
       partitionnées, les clés étrangères référençant des tables partitionnées
       ne sont pas supportées, pas plus qu'une clé étrangères depuis une table
       partitionnées référençant une autre table.
      </para>
     </listitem>

     <listitem>
      <para>
       Utiliser la clause <literal>ON CONFLICT</literal> avec des tables
       partitionnées remontera une erreur, car les contraintes unique ou
       d'exclusion ne peuvent être créer que sur les partitions individuelles.
       Il n'y a pas de support pour imposer l'unicité (ou une contrainte
       d'exclusion) sur l'intégralité d'une hiérarchie de partitionnement.
      </para>
     </listitem>

     <listitem>
      <para>
       Un <command>UPDATE</command> qui a pour conséquence de déplacer une
       ligne d'une partition à une autre échouera, car la nouvelle ligne ne
       satisfera pas la contrainte de partition implicite de la partition
       d'origine.
      </para>
     </listitem>

     <listitem>
      <para>
       Les triggers de lignes, si nécessaires, doivent être définie sur les
       partitions individuelles et non sur la table partitionnée.
      </para>
     </listitem>
    </itemizedlist>
    </para>
    </sect3>
   </sect2>

   <sect2 id="ddl-partitioning-implementation-inheritance">
    <title>Implementation utilisant l'héritage</title>
    <para>
     Bien que le partitionnement déclaratif natif soit adapté pour la plupart
     des cas d'usage courants, il y a certains cas où une approche plus
     flexible pourrait être utile.  Le partitionnement peut être implémenté en
     utilisant l'héritage de table, ce qui permet plusieurs autres
     fonctionnalités qui ne sont pas supportées par le partitionnement
     déclaratif, comme :

     <itemizedlist>
      <listitem>
       <para>
        Le partitionnement impose le fait que toutes les partitions doivent
        avoir exactement le même ensemble de colonne que le parent, mais
        l'héritage de table permet aux enfants d'avoir des colonnes
        supplémentaires qui ne sont pas présentes dans la table parent.
       </para>
      </listitem>

      <listitem>
       <para>
        L'héritage de table permet de multiples héritages.
       </para>
      </listitem>

      <listitem>
       <para>
        Le partitionnement déclaratif ne supporte que le partitionnement pas
        liste et par intervalles, alors que l'héritage de table autorise la
        division des données de la manière choisie par l'utilisateur.  (Notez
        toutefois que si les contraintes d'exclusions ne sont pas capable de
        filtrer la liste des partitions de manière efficace, la performance des
        requêtes sera très mauvaise.)
       </para>
      </listitem>

      <listitem>
       <para>
        Certaines opérations nécessaire un verrou plus fort en utilisant le
        partitionnement déclaratif qu'en utilisant l'héritage de table.  Par
        exemple, ajouter un supprimer une partition d'une table partitionnée
        nécessaire de prendre un verrou de type <literal>ACCESS
            EXCLUSIVE</literal> sur la table parente, alors qu'un verrou de
        type <literal>SHARE UPDATE EXCLUSIVE</literal> est suffisant dans le
        cas de l'héritage classique.
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <sect3 id="ddl-partitioning-inheritance-example">
     <title>Exemple</title>

     <para>
      Nous utilisons la même table <structname>measurement</structname> que
      nous avons déjà utilisé au dessus.  Pour l'implémenter comme une table
      partitionnée en utilisant l'héritage, utilisez les étapes suivantes :

      <orderedlist spacing="compact">
       <listitem>
        <para>
         Créez la table <quote>master</quote>, à partir de laquelle toutes les
         partitions seront héritées.  Cette table ne contiendra aucune données.
         Ne définissez aucune contrainte de vérification sur cette table, à
         moins que vous n'ayez l'intention de l'appliquer de manière identique
         sur toutes les partitions.  Il n'y a aucun intérêt à définir d'index
         ou de contrainte unique sur elle non plus.  Pour notre exemple, la
         table master correspond à la table
         <structname>measurement</structname> définie à l'origine.
        </para>
       </listitem>

       <listitem>
        <para>
         Créez plusieurs tables <quote>enfant</quote> qui chacune hérite de la
         table master.  Normalement, ces tables n'auront aucune colonne
         supplémentaires par rapport à celles héritées de la table master.
         Tout comme avec le partitionnement déclaratif, ces partitions sont de
         tous les aspects des tables (ou tables étrangères)
         <productname>PostgreSQL</productname> normales.
        </para>

        <para>
<programlisting>
CREATE TABLE measurement_y2006m02 () INHERITS (measurement);
CREATE TABLE measurement_y2006m03 () INHERITS (measurement);
...
CREATE TABLE measurement_y2007m11 () INHERITS (measurement);
CREATE TABLE measurement_y2007m12 () INHERITS (measurement);
CREATE TABLE measurement_y2008m01 () INHERITS (measurement);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
         Ajoutez les contraintes de tables qui ne se chevauchent pas sur les
         tables de partition pour définir les valeurs de clé autorisées dans
         chaque partition.
        </para>

        <para>
         Les exemples typiques seraient :
<programlisting>
CHECK ( x = 1 )
CHECK ( county IN ( 'Oxfordshire', 'Buckinghamshire', 'Warwickshire' ))
CHECK ( outletID &gt;= 100 AND outletID &lt; 200 )
</programlisting>
         Assurez-vous que les contraintes garantissent qu'il n'y a pas de
         chevauchement entre les valeurs de clés permises dans différentes
         partitions.   Une erreur fréquente est de mettre en place des
         contraintes d'intervalle comme ceci :
<programlisting>
CHECK ( outletID BETWEEN 100 AND 200 )
CHECK ( outletID BETWEEN 200 AND 300 )
</programlisting>
         Cet exemple est faux puisqu'on ne peut pas savoir à quelle partition
         appartient la valeur de clé 200.
        </para>

        <para>
         Il serait préférable de créer à la place les partitions comme cela :

<programlisting>
CREATE TABLE measurement_y2006m02 (
    CHECK ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2006m03 (
    CHECK ( logdate &gt;= DATE '2006-03-01' AND logdate &lt; DATE '2006-04-01' )
) INHERITS (measurement);

...
CREATE TABLE measurement_y2007m11 (
    CHECK ( logdate &gt;= DATE '2007-11-01' AND logdate &lt; DATE '2007-12-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2007m12 (
    CHECK ( logdate &gt;= DATE '2007-12-01' AND logdate &lt; DATE '2008-01-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2008m01 (
    CHECK ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
) INHERITS (measurement);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
         Pour chaque partition, crez un index sur la ou les colonnes de la clé,
         ainsi que tout autre index que vous voudriez.
<programlisting>
CREATE INDEX measurement_y2006m02_logdate ON measurement_y2006m02 (logdate);
CREATE INDEX measurement_y2006m03_logdate ON measurement_y2006m03 (logdate);
CREATE INDEX measurement_y2007m11_logdate ON measurement_y2007m11 (logdate);
CREATE INDEX measurement_y2007m12_logdate ON measurement_y2007m12 (logdate);
CREATE INDEX measurement_y2008m01_logdate ON measurement_y2008m01 (logdate);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
         Nous voulons que notre application soit capable de dire
         <literal>INSERT INTO measurement ...</literal> et d'avoir les données
         redirigées dans la table de partition appropriée.  Nous pouvons
         réaliser cela en attachant une fonction de déclencheur convenable sur
         la table master.  Si les données doivent être ajoutées sur la dernière
         table de partition uniquement, nous pouvons utiliser une fonction de
         déclencheur très simple :

<programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting>
        </para>

        <para>
         Après avoir crée la fonction, nous créons un déclencheur qui appelle
         la fonction de déclencheur :

     <programlisting>
CREATE TRIGGER insert_mesure_trigger
    BEFORE INSERT ON mesure
    FOR EACH ROW EXECUTE PROCEDURE mesure_insert_trigger();
     </programlisting>

     La fonction déclencheur doit être redéfinie chaque mois pour qu'elle
     pointe toujours sur la partition active. La définition du déclencheur
     n'a pas besoin d'être redéfinie.
    </para>

    <para>
     Il est également possible de laisser le serveur localiser la partition
     dans laquelle doit être insérée la ligne proposée en entrée. Une
     fonction déclencheur plus complexe peut être utilisée pour cela&nbsp;:

     <programlisting>
CREATE OR REPLACE FUNCTION mesure_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF ( NEW.date_trace &gt;= DATE '2006-02-01' AND
         NEW.date_trace &lt; DATE '2006-03-01' ) THEN
        INSERT INTO mesure_a2006m02 VALUES (NEW.*);
    ELSIF ( NEW.date_trace &gt;= DATE '2006-03-01' AND
            NEW.date_trace &lt; DATE '2006-04-01' ) THEN
        INSERT INTO mesure_a2006m03 VALUES (NEW.*);
    ...
    ELSIF ( NEW.date_trace &gt;= DATE '2008-01-01' AND
            NEW.date_trace &lt; DATE '2008-02-01' ) THEN
        INSERT INTO mesure_a2008m01 VALUES (NEW.*);
    ELSE
        RAISE EXCEPTION 'Date en dehors de l''intervalle. Corrigez la fonction mesure_insert_trigger() !';
    END IF;
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
     </programlisting>

     La définition du déclencheur ne change pas. Chaque
     test <literal>IF</literal> doit correspondre exactement à la
     contrainte <literal>CHECK</literal> de cette partition.
    </para>

    <para>
     Bien que cette fonction soit plus complexe que celle du mois seul,
     il n'est pas nécessaire de l'actualiser aussi fréquemment, les branches
     pouvant être ajoutées avant d'être utiles.
    </para>

    <note>
     <para>
      En pratique, il pourrait préférable de vérifier prioritairement la
      dernière partition créée si la plupart des insertions lui sont
      destinées. Pour des raisons de simplicité, les tests du déclencheur
      sont présentés dans le même ordre que les autres parties de l'exemple.
     </para>
    </note>

    <para>
         Une approche différente est de rediriger les insertions dans la table
         de partition appropriée à l'aide de règles, plutôt qu'un déclencheur,
         sur la table master.  Par exemple :

<programlisting>
CREATE RULE measurement_insert_y2006m02 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
DO INSTEAD
    INSERT INTO measurement_y2006m02 VALUES (NEW.*);
...
CREATE RULE measurement_insert_y2008m01 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
DO INSTEAD
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
</programlisting>

         Une règle à un surcout bien plus important qu'une trigger, mais le
         surcout n'est payé qu'une fois par requête plutôt qu'une fois par
         ligne, cette méthode peut être avantageuse pour les situations
         d'insertions de masse.  Toutefois, dans la plupart des cas  la méthode
         du déclencheur offrira de meilleure performances.
    </para>

        <para>
         Soyez conscient que <command>COPY</command> ignore les règles.  Si vous voulez utiliser
         <command>COPY</command> pour insérer des données, vous cevrez les
         copier dans la bonne table de partitions plutôt que dans la table
         master.  <command>COPY</command> déclenche les déclencheurs, vous
         pouvez donc l'utilisez normalement si vous utilisez l'approche par
         déclencheur.
        </para>

        <para>
         Un autre inconvénient à l'approche par règle est qu'il n'y a pas de
         moyen simple de forcer une erreur si l'ensemble de règles ne couvre
         pas la date d'insertion; les données iront silencieusement  dans la
         table master à la place.
        </para>
       </listitem>

       <listitem>
        <para>
         Assurez vous que le paramètre de configuration <xref
             linkend="guc-constraint-exclusion"/> ne soit pas désactivé dans
         <filename>postgresql.conf</filename>.  S'il l'est, les requêtes ne
         seront pas optimisées comme voulu.
        </para>
       </listitem>
      </orderedlist>
     </para>

     <para>
      Comme nous pouvons le voir, un schéma de partitionnement complexe peut
      nécessiter une quantité de DDL non négligeable.  Dans l'exemple du dessus
      nous créerions une nouvelle partition chaque mois, il serait donc sage
      d'écrire un script qui génère le DDL requis automatiquement.
     </para>
    </sect3>

    <sect3 id="ddl-partitioning-inheritance-maintenance">
     <title>Partition Maintenance</title>
     <para>
      Pour supprimer les anciennes données rapidement, il suffit de supprimer
      la partition qui n'est plus nécessaire :
  <programlisting>DROP TABLE mesure_a2006m02;
  </programlisting>
     </para>

    <para>
     Pour supprimer la partition de la table partitionnée mais pour garder
     l'accès à la table en tant que telle :
  <programlisting>ALTER TABLE mesure_a2006m02 NO INHERIT mesure;
  </programlisting>
 </para>

    <para>
     Pour ajouter une nouvelle partition pour gérer les nouvelels données,
     créez une partition vide tout comme les partitions originales ont été
     crées au dessus :

  <programlisting>
CREATE TABLE mesure_a2008m02 (
    CHECK ( date_trace &gt;= DATE '2008-02-01' AND date_trace &lt; DATE '2008-03-01' )
    ) INHERITS (mesure);
  </programlisting>

     De manière alternative, vous pourriez vouloir créer la nouvelle table en
     dehors de la structure de partition, et en faire une partition après avoir
     chargé, vérifié et transformé les données :

  <programlisting>
CREATE TABLE mesure_a2008m02
  (LIKE mesure INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
ALTER TABLE mesure_a2008m02 ADD CONSTRAINT y2008m02
   CHECK ( date_trace &gt;= DATE '2008-02-01' AND date_trace &lt; DATE '2008-03-01' );
\copy mesure_a2008m02 from 'mesure_a2008m02'
-- quelques travaux de préparation des données
ALTER TABLE mesure_a2008m02 INHERIT mesure;
  </programlisting>

 </para>
   </sect3>

   <sect3 id="ddl-partitioning-inheritance-caveats">
    <title>Restrictions</title>
    <para>
     Les restrictions suivantes s'appliquent aux tables partitionnées utilisant
     l'héritage&nbsp;:
     <itemizedlist>
      <listitem>
        <para>
        Il n'existe pas de moyen automatique de vérifier que toutes les
        contraintes de vérification (<literal>CHECK</literal>) sont
        mutuellement exclusives. Il est plus sûr de créer un code qui fabrique
        les partitions et crée et/ou modifie les objets associés plutôt que de
        les créer manuellement&nbsp;;
       </para>
      </listitem>

      <listitem>
       <para>
        les schémas montrés ici supposent que les colonnes clés du
        partitionnement d'une ligne ne changent jamais ou, tout du moins, ne
        changent pas suffisamment pour nécessiter un déplacement vers une autre
        partition. Une commande  <command>UPDATE</command> qui tente de le
        faire échoue à cause des contraintes <literal>CHECK</literal>. Pour
        gérer ce type de cas, des déclencheurs peuvent être convenablement
        positionnés pour la mise à jour sur les tables de partition mais cela
        rend la gestion de la structure beaucoup plus complexe.
       </para>
      </listitem>

      <listitem>
       <para>
        si <command>VACUUM</command> ou <command>ANALYZE</command> sont lancés
        manuellement, il est obligatoire de les utiliser sur chaque partition.
        Une commande comme&nbsp;:
<programlisting>
ANALYZE measurement;
</programlisting>
        ne traite que la table maître.
       </para>
      </listitem>

      <listitem>
       <para>
        Les commandes <command>INSERT</command> avec des clauses <literal>ON
            CONFLICT</literal> ont probablement peu de chances de fonctionner
        comme attendu, dans la mesure où l'action du <literal>ON
            CONFLICT</literal> est uniquement effectuée dans le cas de
        violations qui sont uniques à la table cible, pas à ses tables enfants.
       </para>
      </listitem>

      <listitem>
       <para>
        Les déclencheurs ou les règles seront nécessaires pour rediriger les
        lignes vers la partition voulue, à moins que l'application ne soit
        explicitement au courant du schéma de partitionnement.  Les
        déclencheurs peuvent être plus compliqués à écrire, et seront bien plus
        lent que la redirection de ligne effectuée en interne par le
        partitionnement déclaratif.
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect3>
  </sect2>

  <sect2 id="ddl-partitioning-constraint-exclusion">
    <title>Partitioning and Constraint Exclusion</title>

 <indexterm>
  <primary>exclusion de contrainte</primary>
 </indexterm>

 <para>
  L'<firstterm>exclusion de contrainte</firstterm> est une technique
  d'optimisation des requêtes pour améliorer les performances sur les tables
  partitionnées telles que décrites plus haut (les tables partitionnées qui
  utilisent le partitionnement déclaratif ainsi que celles qui implémentées en
  utilisant l'héritage). Par exemple&nbsp;:

  <programlisting>SET constraint_exclusion = on;
SELECT count(*) FROM mesure WHERE date_trace &gt;= DATE '2008-01-01';</programlisting>

    Sans exclusion de contrainte, la requête ci-dessus parcourt chacune
    des partitions de la table <structname>mesure</structname>. Avec l'exclusion
    de contrainte activée, le planificateur examine les contraintes de chaque
    partition et tente de prouver que la partition qui n'a pas besoin d'être
    parcourue parce qu'elle ne peut pas contenir de lignes correspondant à
    la clause <literal>WHERE</literal> de la requête. Quand le planificateur peut
    le prouver, il exclut la partition du plan de requête.
   </para>

   <para>
    La commande <command>EXPLAIN</command> permet d'afficher la
    différence entre un plan avec <varname>constraint_exclusion</varname>
    activé (<foreignphrase>on</foreignphrase>) et un plan avec ce paramètre désactivé
    (<foreignphrase>off</foreignphrase>). Un plan typique non optimisé pour ce type de
    table est&nbsp;:

<programlisting>SET constraint_exclusion = off;
EXPLAIN SELECT count(*) FROM mesure WHERE date_trace &gt;= DATE '2008-01-01';

                                          QUERY PLAN
-------------------------------------------------------------------------------------
 Aggregate  (cost=158.66..158.68 rows=1 width=0)
   -&gt;  Append  (cost=0.00..151.88 rows=2715 width=0)
         -&gt;  Seq Scan on mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on mesure_a2006m02 mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on mesure_ay2006m03 mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2008-01-01'::date)
...
         -&gt;  Seq Scan on mesure_a2007m12 mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on mesure_a2008m01 mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2008-01-01'::date)
  </programlisting>

  Quelques partitions, voire toutes, peuvent utiliser des parcours d'index
  à la place des parcours séquentiels de la table complète mais le fait est
  qu'il n'est pas besoin de parcourir les anciennes partitions pour répondre
  à cette requête. Lorsque l'exclusion de contrainte est activée,
  un plan significativement moins coûteux est obtenu, qui délivre la même
  réponse&nbsp;:

  <programlisting>SET constraint_exclusion = on;
EXPLAIN SELECT count(*) FROM mesure WHERE date_trace &gt;= DATE '2008-01-01';
                                          QUERY PLAN
-------------------------------------------------------------------------------------
 Aggregate  (cost=63.47..63.48 rows=1 width=0)
   ->  Append  (cost=0.00..60.75 rows=1086 width=0)
         ->  Seq Scan on mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2008-01-01'::date)
         ->  Seq Scan on mesure_a2008m01 mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2008-01-01'::date)</programlisting>
   </para>

   <para>
    L'exclusion de contraintes n'est pilotée que par les contraintes
    <literal>CHECK</literal>, pas par la présence d'index. Il n'est donc pas
    nécessaire de définir des index sur les colonnes clés. Le fait qu'un index
    doive être créé pour une partition donnée dépend de ce que les requêtes qui
    parcourent la partition parcourent en général une grande partie de la partition
    ou seulement une petite partie. Un index est utile dans le dernier cas, pas dans le premier.
   </para>

   <para>
    La valeur par défaut (et donc recommandée) de <xref
    linkend="guc-constraint-exclusion"/> n'est ni <literal>on</literal> ni
    <literal>off</literal>, mais un état intermédiaire appelé
    <literal>partition</literal>, qui fait que la technique est appliquée
    seulement aux requêtes qui semblent fonctionner avec des tables
    partitionnées. La valeur <literal>on</literal> fait que le planificateur
    examine les contraintes <literal>CHECK</literal> dans chaque requête, y
    compris les requêtes simples qui ont peu de chance d'en profiter.
   </para>

 <para>
  Les restrictions suivantes s'appliquent à l'exclusion de contraintes, qui
  sont utilisées à la fois par l'héritage et par les tables
  partitionnées&nbsp;:

  <itemizedlist>
   <listitem>
    <para>
     l'exclusion de contrainte ne fonctionne que si la clause
     <literal>WHERE</literal> de la requête contient des constantes (ou des
     paramètres externes). Par exemple, une comparaison entre une fonction
     non immutable telle que <function>CURRENT_TIMESTAMP</function> ne peut
     pas être optimisée car le planificateur ne peut pas savoir dans quelle
     partition la valeur de la fonction ira lors de l'exécution.
    </para>
   </listitem>

   <listitem>
    <para>
     les contraintes de partitionnement doivent rester simples.  Dans le cas
     contraire, le planificateur peut rencontrer des difficultés à déterminer
     les partitions qu'il n'est pas nécessaire de parcourir.  Des conditions
     simples d'égalité pour le partitionnement de liste ou des tests
     d'intervalle simples lors de partitionnement par intervalles sont
     recommandées, comme cela est illustré dans les exemples précédents. Une
     bonne règle consiste à s'assurer que les comparaisons entre colonnes de
     partitionnement et constantes utilisées par les contraintes de
     partitionnement se fassent uniquement à l'aide d'opérateurs utilisables
     par les index B-tree, ce qui s'applique même aux tables partitionnées, car
     seules les colonnes indexable avec un index B-Tree sont autorisées dans la
     clé de partitionnement.  (Ce n'est pas un problème quand on utilise le
     partitionnement déclaratif, puisque les contraintes générées
     automatiquement sont suffisamment simples pour être comprises par
     l'optimiseur.).
    </para>
   </listitem>

   <listitem>
    <para>
     toutes les contraintes de toutes les partitions de la table maître sont
     examinées lors de l'exclusion de contraintes. De ce fait, un grand nombre
     de partitions augmente considérablement le temps de
     planification de la requête. Un partitionnement qui utilise ces
     techniques fonctionne assez bien jusqu'environ une centaine de partitions&nbsp;;
     il est impensable de vouloir atteindre des milliers de partitions.
    </para>
   </listitem>

  </itemizedlist>
 </para>
</sect2>
</sect1>

<sect1 id="ddl-foreign-data">
<title>Données distantes</title>

<indexterm>
 <primary>données distantes</primary>
</indexterm>
<indexterm>
 <primary>table distante</primary>
</indexterm>
<indexterm>
 <primary>correspondance d'utilisateur</primary>
</indexterm>

<para>
 <productname>PostgreSQL</productname> implémente des portions de la norme
 SQL/MED, vous permettant d'accéder à des données qui résident en dehors
 de PostgreSQL en utilisant des requêtes SQL standards. On utilise le terme
 de <firstterm>données distantes</firstterm> pour de telles données. (Notez
 que cet usage ne doit pas être confondu avec les clés étrangères qui sont
 un type de contrainte à l'intérieur d'une base de données.)
</para>

<para>
 Les données distantes sont accédées grâce à un <firstterm>wrapper de
  données distantes</firstterm>. Ce dernier est une bibliothèque qui peut
 communiquer avec une source de données externe, cachant les détails de la
 connexion vers la source de données et de la récupération des données à
 partir de cette source. Il existe des wrappers de données distantes
 disponibles en tant que modules <filename>contrib</filename>.
 D'autres types de wrappers de données distantes peuvent faire partie
 de produits tiers. Si aucun des wrappers de données distantes ne vous
 convient, vous pouvez écrire le votre. Voir <xref
 linkend="fdwhandler"/>.
</para>

<para>
 Pour accéder aux données distantes, vous devez créer un objet de type
 <firstterm>serveur distant</firstterm> qui définit la façon de se connecter
 à une source de données externes particulière suivant un ensemble d'options
 utilisées par un wrapper de données distantes. Ensuite, vous aurez besoin
 de créer une ou plusieurs <firstterm>tables distantes</firstterm>, qui
 définissent la structure des données distantes. Une table distante peut
 être utilisée dans des requêtes comme tout autre table, mais une table
 distante n'est pas stockée sur le serveur PostgreSQL. À chaque utilisation,
 <productname>PostgreSQL</productname> demande au wrapper de données
 distantes de récupérer les données provenant de la source externe, ou
 de transmettre les données à la source externe dans le cas de commandes
 de mise à jour.
</para>

<para>
 Accéder à des données distantes pourrait nécessiter une
 authentification auprès de la source de données externes. Cette
 information peut être passée par une <firstterm>correspondance
  d'utilisateur</firstterm>, qui peut fournir des données comme les noms
 d'utilisateurs et mots de passe en se basant sur le rôle
 <productname>PostgreSQL</productname> actuel.
</para>

<para>
 Pour plus d'informations, voir
 <xref linkend="sql-createforeigndatawrapper"/>,
 <xref linkend="sql-createserver"/>,
 <xref linkend="sql-createusermapping"/>,
 <xref linkend="sql-createforeigntable"/> et
 <xref linkend="sql-importforeignschema"/>.
</para>
</sect1>

<sect1 id="ddl-others">
<title>Autres objets de la base de données</title>

<para>
 Les tables sont les objets centraux dans une structure de base de
 données relationnelles, car ce sont elles qui stockent les données.
 Mais ce ne sont pas les seuls objets qui
 existent dans une base de données. De nombreux autres types d'objets
 peuvent être créés afin de rendre l'utilisation et la gestion
 des données plus efficace ou pratique. Ils ne sont pas abordés
 dans ce chapitre mais une liste en est dressée à titre d'information.
</para>

<itemizedlist>
 <listitem>
  <para>
   Vues
  </para>
 </listitem>

 <listitem>
  <para>
   Fonctions et opérateurs
  </para>
 </listitem>

 <listitem>
  <para>
   Types de données et domaines
  </para>
 </listitem>

 <listitem>
  <para>
   Déclencheurs et règles de réécriture
  </para>
 </listitem>
</itemizedlist>

<para>
 Des informations détaillées sur ces sujets apparaissent dans la <xref
 linkend="server-programming"/>.
</para>
</sect1>

<sect1 id="ddl-depend">
<title>Gestion des dépendances</title>

<indexterm zone="ddl-depend">
 <primary>CASCADE</primary>
 <secondary sortas="DROP">with DROP</secondary>
</indexterm>

<indexterm zone="ddl-depend">
 <primary>RESTRICT</primary>
 <secondary sortas="DROP">with DROP</secondary>
</indexterm>

<para>
 Lorsque des structures de base complexes sont créées qui impliquent
 beaucoup de tables avec des contraintes de clés étrangères, des
 vues, des déclencheurs, des fonctions, etc., un réseau de dépendances entre
 les objets est implicitement créé.
 Par exemple, une table avec une contrainte de clé étrangère dépend
 de la table à laquelle elle fait référence.
</para>

<para>
 Pour garantir l'intégrité de la structure entière de la base,
 <productname>PostgreSQL</productname> s'assure qu'un objet dont d'autres
 objets dépendent ne peut pas être supprimé. Ainsi, toute
 tentative de suppression de la table des produits
 utilisée dans la <xref linkend="ddl-constraints-fk"/>, sachant que la
 table des commandes en dépend, lève un message d'erreur
 comme celui-ci&nbsp;:
 <screen>DROP TABLE produits;

ERROR:  cannot drop table produits because other objects depend on it
DETAIL:  constraint commandes_no_produit_fkey on table commandes depends on table produits
HINT:  Use DROP ... CASCADE to drop the dependent objects too.</screen>

ou en français&nbsp;:
<screen>DROP TABLE produits;

NOTICE:  la contrainte commandes_no_produit_fkey sur la table commandes dépend
de la table produits
ERREUR:  la table produits ne peut pas être supprimée, car d'autre objets en
dépendent
HINT:  Utiliser DROP ... CASCADE pour supprimer également les objets
dépendants.</screen>

   Le message d'erreur contient un indice utile&nbsp;: pour ne pas avoir à
   supprimer individuellement chaque objet dépendant, on peut
   lancer
<screen>DROP TABLE produits CASCADE;</screen>
   et tous les objets dépendants sont ainsi effacés, comme tous les objets
   dépendant de ces derniers, récursivement. Dans ce cas, la table des
   commandes n'est pas supprimée, mais seulement la contrainte de clé étrangère.
   Elle s'arrête là car rien ne dépend d'une contrainte de clé étrangère.
   (Pour vérifier ce que fait <command>DROP ... CASCADE</command>, on peut
   lancer <command>DROP</command> sans <literal>CASCADE</literal> et lire les messages
   <literal>DETAIL</literal>.)
  </para>

  <para>
   Pratiquement toutes les commandes <command>DROP</command> dans
   <productname>PostgreSQL</productname> supportent l'utilisation de
   <literal>CASCADE</literal>. La nature des dépendances
   est évidemment fonction de la nature des objets. On peut aussi écrire
   <literal>RESTRICT</literal> au lieu de <literal>CASCADE</literal>
   pour obtenir le comportement par défaut, à savoir interdire les
   suppressions d'objets dont dépendent d'autres objets.
  </para>

  <note>
   <para>
    D'après le standard SQL, il est nécessaire d'indiquer
    <literal>RESTRICT</literal> ou <literal>CASCADE</literal> dans une
    commande <command>DROP</command>.
    Aucun système de base de donnée ne force cette règle, en réalité,
    mais le choix du comportement par défaut,
    <literal>RESTRICT</literal> ou <literal>CASCADE</literal>,
    varie suivant le système.
   </para>
  </note>

  <para>
   Si une commande <command>DROP</command> liste plusieurs objets,
   <literal>CASCADE</literal> est seulement requis quand il existe des
   dépendances en dehors du groupe spécifié. Par exemple, en indiquant
   <literal>DROP TABLE tab1, tab2</literal>, l'existence d'une clé étrangère
   référençant <literal>tab1</literal> à partir de <literal>tab2</literal> ne
   signifie pas que <literal>CASCADE</literal> est nécessaire pour réussir.
  </para>

  <para>
   Pour les fonctions définies par les utilisateurs,
   <productname>PostgreSQL</productname> trace les dépendances associées avec
   les propriétés de la fonction visibles en externe, comme les types de
   données des arguments et du résultat. Par contre, il ne trace
   <emphasis>pas</emphasis> les dépendances seulement connues en examinant le
   corps de la fonction. Par exemple&nbsp;:

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow',
                             'green', 'blue', 'purple');

CREATE TABLE my_colors (color rainbow, note text);

CREATE FUNCTION get_color_note (rainbow) RETURNS text AS
  'SELECT note FROM my_colors WHERE color = $1'
  LANGUAGE SQL;
</programlisting>

   (Voir <xref linkend="xfunc-sql"/> pour une explication sur les fonctions en
   SQL.) <productname>PostgreSQL</productname> aura connaissance du fait que
   la fonction <function>get_color_note</function> dépends du type
   <type>rainbow</type>&nbsp;: supprimer ce type de données forcera la
   suppression de la fonction parce que le type de son argument ne serait plus
   défini. Mais <productname>PostgreSQL</productname> ne considérera pas que
   la fonction <function>get_color_note</function> dépende de la table
   <structname>my_colors</structname>, et donc ne supprimera pas la fonction
   si la table est supprimée. Bien qu'il y ait des inconvénients à cette
   approche, il y a aussi des avantages. La fonction est toujours valide d'une
   certaine façon si la table est manquante, bien que son exécution causera
   une erreur. Créer une nouvelle table de même nom permettra à la fonction
   d'être valide de nouveau.
  </para>
 </sect1>

</chapter>
