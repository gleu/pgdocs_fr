<?xml version="1.0" encoding="UTF-8"?>
<chapter id="protocol">
 <title>Protocole Frontend/Backend</title>

 <indexterm zone="protocol">
  <primary>protocole</primary>
  <secondary>frontend-backend</secondary>
 </indexterm>

 <para>
  <productname>PostgreSQL</productname> utilise un protocole de messages pour la
  communication entre le <foreignphrase>frontend</foreignphrase> et le
  <foreignphrase>backend</foreignphrase> (clients et serveurs). Le protocole
  est supporté sur <acronym>TCP/IP</acronym> et aussi sur les sockets de domaine
  Unix. Le numéro de port 5432 a été enregistré auprès de l'IANA comme numéro de port
  TCP attribué pour les serveurs utilisant ce protocole, mais, en pratique, tout
  numéro de port non privilégié peut être utilisé.
 </para>

 <para>
  Ce document décrit la version 3.0 de ce protocole, implémenté dans
  <productname>PostgreSQL</productname> 7.4 et ses versions ultérieures. Pour la
  description des versions précédentes du protocole, voir les versions
  précédentes de la documentation <productname>PostgreSQL</productname>. Un
  serveur peut accepter plusieurs versions du protocole.  Le message
  <foreignphrase>startup-request</foreignphrase> initial indique au serveur la
  version du protocole que le client essaie d'utiliser. Si la version majeure
  demandée par le client n'est pas comprise par le serveur, la connexion sera
  rejetée (par exemple, cela surviendrait si le client demandait la version 4.0
  du protocole, qui n'existe pas au moment de l'écriture de ce chapitre). Si la
  version mineure demandée par le client n'est pas acceptée par le serveur (par
  exemple si le client réclame la version 3.1 mais que le serveur n'accepte que
  la version 3.0), le serveur peut soit rejeter la connexion soit répondre avec
  un message <literal>NegotiateProtocolVersion</literal> contenant la version
  mineure la plus haute qu'il accepte pour ce protocole.  Le client peut ensuite
  choisir soit de tenter une nouvelle connexion avec la version indiquée du
  protocole soit annuler la connexion.
 </para>

  <para>
   Pour servir plusieurs clients avec efficacité, le serveur lance un nouveau
   processus <quote>backend</quote> pour chaque backend. Dans l'implémentation
   actuelle, un nouveau processus fils est créé immédiatement après la détection
   d'une connexion entrante.  Cependant, ceci est transparent pour le protocole.
   Pour le protocole, les termes <quote>backend</quote> et <quote>server</quote>
   sont interchangeables&nbsp;; de la même façon, les termes
   <quote>frontend</quote> et <quote>client</quote> sont interchangeables.
  </para>

 <sect1 id="protocol-overview">
  <title>Aperçu</title>

  <para>
   Le protocole a différentes phases pour le démarrage et les opérations
   normales. Dans la phase de démarrage, le client ouvre une connexion au
   serveur et s'authentifie à la satisfaction du serveur. (Cela pourrait ne
   nécessiter qu'un seul message ou plusieurs messages, suivant la méthode
   d'authentification utilisée.) Si tout va bien, le serveur envoie ensuite une
   information de statut au client, et entre enfin dans les opérations normales.
   Sauf pour le message initial startup-request, cette partie du protocole est
   conduite par le serveur.
  </para>

  <para>
   Lors des opérations normales, le client envoie des requêtes et d'autres
   commandes au backend, et le backend envoie les résultats des requêtes ainsi
   que d'autres réponses. Il existe quelques cas (comme par exemple
   <command>NOTIFY</command>) où le backend enverra des messages non sollicités
   mais pour la plupart, cette portion d'une session est conduite par des
   demandes du client.
  </para>

  <para>
   La fin d'une session est normalement le choix du client mais elle peut être
   forcée par le backend dans certains cas. Dans tous les cas, quand le backend
   ferme la connexion, cela annulera toute transaction ouverte (incomplète)
   avant de quitter.
  </para>

  <para>
   Lors des opérations normales, les commandes SQL peuvent être exécutées via
   deux sous-protocoles. Dans le protocole <quote>simple query</quote> (requête
   simple), le client envoie simplement une chaîne de caractères contenant la
   requête.  Cette chaîne est immédiatement analysée puis exécutée par le
   backend. Dans le protocole <quote>extended query</quote> (requête étendue),
   le traitement des requêtes est séparé en plusieurs étapes&nbsp;: l'analyse,
   le lien avec les valeurs des paramètres, et l'exécution. Ceci offre des
   bénéfices de flexibilité et de performance, au prix d'une complexité plus
   importante.
  </para>

  <para>
   Les opérations normales ont des sous-protocoles supplémentaires pour les
   opérations spéciales comme <command>COPY</command>.
  </para>

 <sect2 id="protocol-message-concepts">
  <title>Aperçu des messages</title>

  <para>
   Toute la communication se fait via un flux de message. Le premier octet d'un
   message identifie le type de message, et les quatre prochains octets
   précisent la longueur du message (cette longueur s'inclut elle-même, mais
   pas l'octet de type de message). Le contenu restant du message est déterminé
   par le type de message. Pour des raisons historiques, le tout premier message
   envoyé par le client (le message de démarrage) n'a pas d'octet initial de
   type de message.
  </para>

  <para>
   Pour éviter de perdre la synchronisation avec le flux de message, les
   serveurs et les clients lisent typiquement un message entier (en utilisant le
   nombre d'octets) avant de commencer l'analyse de son contenu. Ceci permet une
   récupération facilitée si une erreur est détectée lors du traitement du
   contenu. Dans les situations extrêmes (comme un manque mémoire pour mettre en
   cache le message), le receveur peut utiliser le nombre d'octets pour
   déterminer la quantité de données à ignorer avant de continuer la lecture des
   messages.
  </para>

  <para>
   Inversement, serveurs et clients doivent faire attention à ne jamais envoyer
   un message partiel. Ceci se fait habituellement en construisant le message
   entier dans un cache avant de l'envoyer. Si un échec de communication
   survient lors d'un envoi ou de la réception d'un message, la seule réaction
   sensible est d'abandonner la connexion parce qu'il y a très peu d'espoir de
   récupérer la synchronisation entre messages.
  </para>
 </sect2>

  <sect2 id="protocol-query-concepts">
   <title>Aperçu des requêtes étendues</title>

   <para>
    Dans le protocole de requête étendue, l'exécution de commandes SQL est
    divisée en plusieurs étapes. L'état conservé entre les étapes est représenté
    par deux types d'objets&nbsp;: les <firstterm>requêtes préparées</firstterm>
    et les <firstterm>portails</firstterm>. Une requête préparée représente le
    résultat de l'analyse sémantique d'une chaîne de caractères contenant une
    requête. Une requête préparée n'est pas prête à s'exécuter parce qu'elle
    pourrait manquer des valeurs spécifiques pour ses
    <firstterm>paramètres</firstterm>. Un portail représente une instruction
    prête à être exécutée ou une requête déjà partiellement exécutée, avec
    toutes valeurs manquantes de paramètres renseignées. (Pour les requêtes
    <command>SELECT</command>, un portail est équivalent à un curseur ouvert
    mais nous pouvons choisir d'utiliser un terme différent vu que les curseurs
    ne gèrent pas les requêtes autres que <command>SELECT</command>.)
   </para>

   <para>
    En aperçu, le cycle d'exécution consiste en une étape
    <firstterm>parse</firstterm>, qui crée une requête préparée à partir d'une
    chaîne de caractères contenant la requête&nbsp;; une étape
    <firstterm>bind</firstterm>, qui crée un portail à partir d'une requête
    préparée et des valeurs nécessaires pour les paramètres&nbsp;; et une étape
    <firstterm>execute</firstterm> qui exécute la requête d'un portail. Dans le
    cas d'une requête qui renvoie des lignes (<command>SELECT</command>,
    <command>SHOW</command>, etc.), l'étape d'exécution doit connaître le nombre
    limité de lignes à récupérer, si bien que plusieurs étapes d'exécution
    pourraient être nécessaires pour terminer l'opération.
   </para>

   <para>
    Le backend peut garder trace de plusieurs requêtes préparées et portails
    (mais notez qu'ils n'existent que dans une session et ne sont jamais
    partagés entre sessions). Les requêtes préparées et les portails existants
    sont référencés par des noms assignés lors de leur création. De plus, les
    requêtes préparées et portails <quote>sans nom</quote> existent. Bien que
    ces derniers se comportement largement de la même façon que des objets
    nommés, les opérations les concernant sont optimisées dans le cas d'une
    requête exécutée une seule fois, puis annulée, alors que les opérations sur
    des objets nommés sont optimisées dans un contexte d'utilisation multiple.
   </para>
  </sect2>

  <sect2 id="protocol-format-codes">
   <title>Formats et codes de format</title>

   <para>
    Les données d'un type de données particulier pourraient être transmises dans
    un <firstterm>format</firstterm> parmi plusieurs. Depuis
    <productname>PostgreSQL</productname> 7.4, les seuls formats acceptés sont
    <quote>text</quote> et <quote>binary</quote>, mais le protocole permet des
    extensions futures. Le format désiré pour toute valeur est indiqué par un
    <firstterm>code format</firstterm>. Les clients peuvent spécifier un code
    format pour chaque valeur transmise de paramètre et pour chaque colonne d'un
    résultat de requête. Le texte a le code format zéro, le binaire a le code
    format un, et tous les autres codes format sont réservés pour une définition
    future.
   </para>

   <para>
    La représentation textuelle des valeurs correspond à la façon dont un type
    de données est représenté sous forme de chaîne de caractères par les
    fonction de conversion d'entrée/sortie.  Dans la représentation transmise,
    il n'existe pas de caractère nul en fin de chaîne&nbsp;; le client doit
    ajouter un aux valeurs reçues s'il veut les traiter comme des chaînes de
    caractères du langage C. (Le format texte n'autorise pas les NULL
    embarqués.)
   </para>

   <para>
    Les représentations binaires pour les entiers utiliser l'ordre d'octet
    réseau (l'octet le plus significatif en premier). Pour les autres types de
    données, consultez la documentation ou le code source pour apprendre leur
    représentation binaire.  Gardez en tête que les représentations binaires des
    types de données complexes pourraient changer au fur et à mesure des
    versions du serveur&nbsp;; le format texte est généralement le choix le plus
    portable.
   </para>
  </sect2>
 </sect1>

 <sect1 id="protocol-flow">
  <title>Flot de messages</title>

  <para>
   Cette section décrit le flot de message et la sémantique de chaque type de
   message. (Les détails sur la représentation exacte de chaque message
   apparaît dans <xref linkend="protocol-message-formats"/>.) Il existe
   plusieurs sous-protocoles différents dépendant de l'état de la
   connexion&nbsp;: démarrage, requête, appel de fonction,
   <command>COPY</command>, et fin. Il existe aussi plusieurs cas spéciaux pour
   les opérations asynchrones (incluant les réponses aux notifications et les
   annulations de commande), qui peuvent survenir à tout moment après la phase
   de démarrage.
  </para>

  <sect2 id="protocol-flow-start-up">
   <title>Démarrage (Start-up)</title>

   <para>
    Pour commencer une session, un client ouvre une connexion au serveur et
    envoie un message de démarrage. Ce message inclut les noms de l'utilisateur
    et de la base de données sur laquelle l'utilisateur souhaite se
    connecter&nbsp;; il identifie aussi la version particulière du protocole à
    utiliser. (En option, le message de démarrage peut inclure différentes
    configurations de paramètres.) Le serveur utilise ensuite cette information
    et le contenu des fichiers de configuration (tels que
    <filename>pg_hba.conf</filename>) pour déterminer si la connexion est
    acceptable et le type d'authentification requis (si c'est le cas).
   </para>

   <para>
    Ensuite, le serveur envoie un message approprié de demande
    d'authentification, auquel le client doit répondre avec un message approprié
    de réponse d'authentification (par exemple, avec un mot de passe).  Pour
    toutes les méthodes d'authentification, sauf GSSAPI, SSPI et SASL, il existe
    au moins une requête et une réponse. Pour certaines méthodes, aucune réponse
    n'est nécessaire, et donc aucune demande d'authentification n'arrive.  Pour
    les méthodes GSSAPI, SSPI et SASL, plusieurs échanges de paquets pourraient
    être nécessaires pour terminer l'authentification.
   </para>

   <para>
    Le cycle d'authentification se termine avec le serveur rejetant la tentative
    de connexion (message ErrorResponse), ou renvoyant le message
    AuthenticationOk.
   </para>

   <para>
    Dans cette phase, les messages possibles provenant du serveur sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
        La demande de connexion a été rejetée. Le serveur ferme
        immédiatement la connexion.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationOk</term>
      <listitem>
       <para>
        L'échange d'authentification s'est terminé avec succès.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationKerberosV5</term>
      <listitem>
       <para>
        Le client doit maintenant prendre part à un dialogue d'authentification
        Kerberos V5 (qui n'est pas décrit ici, et fait partie de la
        spécification Kerberos) avec le serveur. Si ce dialogue réussit, le
        serveur répond avec un AuthenticationOk, sinon il répond avec un
        ErrorResponse. Ceci n'est plus accepté.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationCleartextPassword</term>
      <listitem>
       <para>
        Le client doit maintenant envoyer un message PasswordMessage contenant
        le mot de passe en clair. Si le mot de passe est bon, le serveur répond
        avec un message AuthenticationOk, sinon il répond avec un message
        ErrorResponse.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationMD5Password</term>
      <listitem>
       <para>
        Le client doit maintenant envoyer un message PasswordMessage contenant
        le mot de passe (avec le nom de l'utilisateur) chiffré avec MD5, puis
        chiffré de nouveau en utilisant le sel aléatoire de quatre octets
        indiqué dans le message AuthenticationMD5Password. S'il s'agit du bon
        mot de passe, le serveur répond avec un message AuthenticationOk, sinon
        il répond avec nu message ErrorResponse. Le message PasswordMessage réel
        peut être calculé en SQL avec un <literal>concat('md5',
        md5(concat(md5(concat(motdepasse, nomdutilisateur)),
        selaléatoire)))</literal>.  (Gardez en tête que la fonction
        <function>md5()</function> renvoie le résultat sous la forme d'une
        chaîne hexadécimale.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationGSS</term>
      <listitem>
       <para>
        Le client doit maintenant initier une négociation GSSAPI. Le client
        enverra un message GSSResponse avec la première partie du flux de
        données GSSAPI en réponse à cela. Si plusieurs messages sont nécessaires,
        le serveur répondra avec AuthenticationGSSContinue.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSSPI</term>
      <listitem>
       <para>
        Le client doit maintenant initier une négociation SSPI. Le client
        enverra un message GSSResponse avec la première partie du flux de
        données SSPI en réponse à cela. Si plusieurs messages sont nécessaires,
        le serveur répondra avec AuthenticationGSSContinue.
       </para>
      </listitem>

     </varlistentry>
     <varlistentry>
      <term>AuthenticationGSSContinue</term>
      <listitem>
       <para>
        Ce message contient les données de réponse de l'étape précédente de la
        négociation GSSAPI ou SSPI (AuthenticationGSS, AuthenticationSSPI ou un
        AuthenticationGSSContinue précédent). Si les données GSSAPI ou SSPI de
        ce message indique que plus de données sont nécessaires pour terminer
        l'authentification, le client doit envoyer les données dans un autre
        message GSSResponse. Si l'authentification GSSAPI ou SSPI est terminée
        par ce message, le serveur enverra ensuite un message AuthenticationOk
        pour indiquer une authentification réussie ou un message ErrorResponse
        pour indiquer un échec.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSASL</term>
      <listitem>
       <para>
        Le client doit maintenant initier une négociation SASL, en utilisant un
        des mécanismes SASL listés dans le message. Le client doit envoyer un
        message SASLInitialResponse avec le nom du mécanisme sélectionné, et la
        première partie du flux de données SASL en réponse à ceci. Si plus de
        messages sont nécessaires, le serveur répondra avec un message
        AuthenticationSASLContinue. Voir <xref linkend="sasl-authentication"/>
        pour les détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSASLContinue</term>
      <listitem>
       <para>
        Ce message contient des données de challenge provenant des étapes
        précédentes de la négociation SASL (AuthenticationSASL, ou d'un
        précédent AuthenticationSASLContinue). Le client doit répondre avec un
        message SASLResponse.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSASLFinal</term>
      <listitem>
       <para>
        L'authentification SASL a terminé avec les données supplémentaires
        spécifiques du mécanisme pour le client. Le serveur enverra ensuite le
        message AuthenticationOk pour indiquer une authentification réussie ou
        un message ErrorResponse pour indiquer un échec. Ce message est envoyé
        uniquement si le mécanisme SASL indique que des données supplémentaires
        doivent être envoyées du serveur au client à la fin.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NegotiateProtocolVersion</term>
      <listitem>
       <para>
        Le serveur n'accepte pas la version mineure du protocole réclamée par le
        client, mais accepte une version plus ancienne du protocole&nbsp;; ce
        message indique la version mineure la plus haute que le serveur accepté.
        Ce message sera aussi envoyé si le client a demandé des options non
        acceptées du protocole (par exemple commençant avec
        <literal>_pq_.</literal>) dans le paquet de démarrage. Ce message sera
        suivi par un message ErrorResponse ou par un message indiquant le succès
        ou l'échec de l'authentification.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <para>
    Si le client n'accepte pas la méthode d'authentification demandée par le
    client, il doit immédiatement fermer la connexion.
   </para>

   <para>
    Après avoir reçu le message AuthenticationOk, le client doit attendre plus
    de messages du serveur.  Dans cette phase, un processus backend est démarré,
    et le client est juste un partenaire intéressé.  Il est toujours possible
    que la demande de démarrage échoue (ErrorResponse) ou que le serveur décline
    le support de la version mineure demandée du protocole
    (NegotiateProtocolVersion), mais dans un cas normal, le backend enverra
    quelques messages ParameterStatus, BackendKeyData et enfin ReadyForQuery.
   </para>

   <para>
    Lors de cette phase, le backend tentera d'appliquer toute configuration
    supplémentaire de paramètre d'exécution donnée lors du message de démarrage.
    EN cas de succès, ces valeurs deviennent les valeurs par défaut de la
    session. Une erreur cause un message ErrorResponse puis quitte.
   </para>

   <para>
    Les messages possibles provenant du backend dans cette phase sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term>BackendKeyData</term>
      <listitem>
       <para>
        Ce message fournit des données de clé secrète que le client doit
        conserver s'il souhaite être capable d'annuler des requêtes plus tard.
        Le client ne doit pas répondre à ce message mais doit continuer à
        attendre un message ReadyForQuery.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ParameterStatus</term>
      <listitem>
       <para>
        Ce message informe le client sur la configuration actuelle (initiale)
        d'un paramètre serveur, tel que <xref linkend="guc-client-encoding"/> ou
        <xref linkend="guc-datestyle"/>. Le client peut ignorer ce message, ou
        enregistrer la configuration pour une utilisation ultérieure&nbsp;; voir
        <xref linkend="protocol-async"/> pour plus de détails. Le client ne doit
        pas répondre à ce message, mais doit continuer à attendre un message
        ReadyForQuery.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery</term>
      <listitem>
       <para>
        Le démarrage est terminé. Le client peut maintenant exécuter des
        commandes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
        Le démarrage a échoué. La connexion est fermée après l'envoi de ce
        message.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse</term>
      <listitem>
       <para>
        Un message d'avertissement a été envoyé. Le client doit afficher le
        message mais continuer à attendre des messages ReadyForQuery ou
        ErrorResponse.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Le message ReadyForQuery est le même que le backend enverra après chaque
    cycle de commande. Suivant les besoins du client, il est raisonnable de
    considérer le message ReadyForQuery comme débutant un cycle de commande ou
    de le considérer comme terminant la phase de démarrage et chaque cycle de
    commandes suivant.
   </para>
  </sect2>

  <sect2 id="protocol-flow-simple-query">
   <title>Requête simple</title>

   <para>
    Un cycle de requête simple est initié par le client envoyant un message
    Query au backend. The message inclut une commande SQL (ou des commandes)
    exprimée sous la forme d'une chaîne de caractères. Le backend envoie alors
    une ou plusieurs réponses suivant le contenu de la chaîne de texte, et
    termine par un message ReadyForQuery. Ce dernier message informe le client
    qu'il peut envoyer une nouvelle commande. (Il n'est pas absolument
    nécessaire que le client attende le message ReadyForQuery avant de lancer
    une autre commande, mais le client prend alors la responsabilité de
    comprendre ce qu'il se passe si la commande précédente échoue et que les
    commandes suivantes déjà lancées réussissent.)
   </para>

   <para>
    Les messages de réponse possibles du backend sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term>CommandComplete</term>
      <listitem>
       <para>
        Une commande SQL terminée normalement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>CopyInResponse</term>
      <listitem>
       <para>
        Le backend est prêt à copier des données du client vers une
        table&nbsp;; voir <xref linkend="protocol-copy"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>CopyOutResponse</term>
      <listitem>
       <para>
        Le backend est prêt à copier les données d'une table vers le
        client&nbsp;; voir <xref linkend="protocol-copy"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>RowDescription</term>
      <listitem>
       <para>
        Indique que les lignes sont prêtes à être renvoyées en réponse à une
        requête <command>SELECT</command>, <command>FETCH</command>, etc. Le
        contenu de ce message décrit la disposition des colonnes pour les
        lignes. Ceci sera suivi par un message DataRow pour chaque ligne
        renvoyée au client.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>DataRow</term>
      <listitem>
       <para>
        Un des ensembles de lignes renvoyés par une requête
        <command>SELECT</command>, <command>FETCH</command>, etc.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>EmptyQueryResponse</term>
      <listitem>
       <para>
        Une chaîne a été reconnue à la place d'une requête.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
        Une erreur est survenue.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery</term>
      <listitem>
       <para>
        Le traitement de la requête est terminé. Un message séparé est envoyé
        pour l'indiquer parce que la chaîne de texte pourrait contenir plusieurs
        commandes SQL. (Le message CommandComplete marque la fin du traitement
        d'une commande SQL, et non pas de la chaîne complète.) Le message
        ReadyForQuery sera toujours envoyé, que le traitement se termine avec
        succès ou avec échec.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse</term>
      <listitem>
       <para>
        Un message d'avertissement a été envoyé en relation à la requête. Les
        avertissements sont en plus des autres réponses, autrement dit le
        backend continuera de traiter la commande.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <para>
    La réponse à une requête <command>SELECT</command> (ou autres requêtes qui
    renvoient des ensembles de lignes, tels que <command>EXPLAIN</command> ou
    <command>SHOW</command>), consiste normalement en des messages
    RowDescription, zéro ou plusieurs messages DataRow, et enfin un message
    CommandComplete. <command>COPY</command> vers ou à partir du client fait
    appel à un protocole spécial décrit dans <xref linkend="protocol-copy"/>.
    Tous les autres types de requêtes produisent normalement seulement un
    message CommandComplete.
   </para>

   <para>
    Comme une chaîne de texte peut contenir plusieurs requêtes (séparées par des
    points-virgules), il pourrait y avoir plusieurs séquences de réponses avant
    que le backend finisse le traitement de la chaîne. Le message ReadyForQuery
    est lancé quand la chaîne entière a été traitée et que le backend est prêt à
    accepter une nouvelle chaîne de texte.
   </para>

   <para>
    Si une chaîne de caractères complètement vide est reçue (aucun contenu
    autre que les espaces blancs), la réponse est EmptyQueryResponse suivi par
    ReadyForQuery.
   </para>

   <para>
    Au cas où une erreur survient, le message ErrorResponse est envoyé suivi
    d'un message ReadyForQuery. Tous les autres traitement de chaîne de texte
    sont annulés par le message ErrorResponse (même s'il reste des requêtes dans
    la chaîne). Notez que ceci pourrait survenir au milieu de la séquence de
    messages générés par une requête individuel.
   </para>

   <para>
    Dans le mode simple requête, le format de valeurs récupérées est toujours du
    texte, sauf quand la commande données est un <command>FETCH</command> à
    partir d'un curseur déclaré avec l'option <literal>BINARY</literal>. Dans ce
    cas, les valeurs récupérées sont dans un format binaire. Les codes format
    donnés dans le message RowDescription indiquent le format utilisé.
   </para>

   <para>
    Un client doit être préparé pour accepter des messages ErrorResponse et
    NoticeResponse à chaque fois qu'il est attendu d'autres types de message.
    Voir aussi <xref linkend="protocol-async"/> pour les messages que le backend
    pourrait générer à cause d'événements externes.
   </para>

   <para>
    Une pratique recommandée est de coder des clients dans un style machine
    d'états qui acceptera tout type de message à tout moment où cela aurait du
    sens, plutôt que de coder des suppositions sur la séquence exacte des
    messages.
   </para>

   <sect3 id="protocol-flow-multi-statement">
    <title>Plusieurs requêtes dans le mode requête simple</title>

    <para>
     Quand un message simple Query contient plus d'une requête SQL (séparé par
     des points-virgules), ces requêtes sont exécutées comme une seule
     transaction, sauf si des commandes de contrôle de transaction explicites
     sont inclus pour forcer un comportement différent. Par exemple, si le
     message contient&nbsp;:
<programlisting>
INSERT INTO mytable VALUES(1);
SELECT 1/0;
INSERT INTO mytable VALUES(2);
</programlisting>
     alors une erreur de division par zéro dans la requête
     <command>SELECT</command> forcera l'annulation du premier
     <command>INSERT</command>. De plus, comme l'exécution du message est
     abandonnée à la première erreur, le deuxième <command>INSERT</command>
     n'est jamais tenté.
    </para>

    <para>
     Si le message contient à la place&nbsp;:
<programlisting>
BEGIN;
INSERT INTO mytable VALUES(1);
COMMIT;
INSERT INTO mytable VALUES(2);
SELECT 1/0;
</programlisting>
     alors le premier <command>INSERT</command> est validé par la commande
     <command>COMMIT</command> explicite. Le deuxième <command>INSERT</command>
     et le <command>SELECT</command> sont toujours traités comme une seule
     transaction, donc l'échec de division par zéro annulera le second
     <command>INSERT</command>, mais pas le premier.
    </para>

    <para>
     Ce comportement est implémenté en exécutant les requêtes dans un message
     message multi-requêtes dans un <firstterm>bloc de transaction
     implicite</firstterm> sauf s'il existe un bloc de transaction explicite
     pour leur exécution. La principale différence entre un bloc de transaction
     implicite et un bloc standard est qu'un bloc implicite est fermé
     automatiquement à la fin d'un message Query, soit par une validation
     implicite s'il n'y a pas d'erreur, soit par une annulation implicite s'il y
     avait une erreur. Ceci est similaire à la validation ou à l'annulation
     implicite qui survient pour une requête exécutée par elle-même (quand elle
     n'est pas dans un bloc de transaction).
    </para>

    <para>
     Si la session est déjà dans un bloc de transaction, en résultat d'un
     <command>BEGIN</command> dans un message précédent, alors le message Query
     continue simplement ce bloc de transaction, si le message contient une ou
     plusieurs requêtes. Néanmoins, si le message Query contient un
     <command>COMMIT</command> ou un <command>ROLLBACK</command> fermant le bloc
     de transaction existant, alors toutes les requêtes suivantes sont exécutées
     dans un bloc de transaction explicite.  Inversement, si un
     <command>BEGIN</command> apparaît dans un message Query multi-requêtes,
     alors il démarre un bloc de transaction standard qui sera uniquement
     terminé par un <command>COMMIT</command> ou <command>ROLLBACK</command>
     explicite, apparaissant soit dans ce message Query soit dans un message
     suivant. Si le <command>BEGIN</command> suit certaines requêtes qui ont
     été exécutées sous la forme d'un bloc de transaction implicite, ces
     requêtes ne sont pas immédiatement validées&nbsp;; en effet, elles sont
     inclues rétroactivement dans le nouveau bloc de transaction standard.
    </para>

    <para>
     Un <command>COMMIT</command> ou un <command>ROLLBACK</command> apparaissant
     dans un bloc de transaction implicite est exécuté de façon normale, fermant
     le bloc implicite&nbsp;; néanmoins, un message d'avertissement sera renvoyé
     car un <command>COMMIT</command> ou un <command>ROLLBACK</command> sans
     <command>BEGIN</command> pourrait être une erreur. Si des requêtes suivent,
     un nouveau bloc de transaction implicite sera démarré pour elles.
    </para>

    <para>
     Les savepoints ne sont pas autorisés dans un bloc de transaction implicite
     car elles pourraient entrer en conflit avec le comportement de fermeture
     automatique du bloc en cas d'erreur.
    </para>

    <para>
     Rappelez-vous que, quelque soient les commandes de contrôle des
     transactions présentes, l'exécution d'un message Query s'arrête à la
     première erreur. Donc sur cet exemple&nbsp;:
<programlisting>
BEGIN;
SELECT 1/0;
ROLLBACK;
</programlisting>
     dans un seul message Query, la session sera laissée à l'intérieur d'un bloc
     de transaction standard en échec car <command>ROLLBACK</command> n'est pas
     atteint après l'erreur de division par zéro. Un autre
     <command>ROLLBACK</command> sera nécessaire pour restaurer la session dans
     un état utilisable.
    </para>

    <para>
     Un autre comportement à noter est que l'analyse lexicale et syntaxique est
     réalisée sur la chaîne de caractères entière avant qu'une seule requête ne
     soit exécutée.  De ce fait, les erreurs simples (telle qu'un mot clé mal
     orthographié) dans des requêtes ultérieures peuvent empêcher l'exécution
     des requêtes. Ceci est habituellement invisible pour les utilisateurs car
     les requêtes vont de toute façon être intégralement annulées quand elles
     font partie d'un bloc de transaction implicite. Cependant, cela peut se
     voir lors d'une tentative sur plusieurs transactions dans un message Query
     multi-requêtes. Par exemple, si une faute est intégrée à l'exemple
     précédent comme ceci&nbsp;:
<programlisting>
BEGIN;
INSERT INTO mytable VALUES(1);
COMMIT;
INSERT INTO mytable VALUES(2);
SELCT 1/0;<!-- this typo is intentional -->
</programlisting>
     alors aucune des requêtes ne sera exécutée, résultant en une différence
     visible, à savoir que le premier <command>INSERT</command> n'est pas
     validé. Les erreurs détectées lors de l'analyse sémantique ou plus tard,
     comme une table ou une colonne mal nommée, n'ont pas cet effet.
    </para>
   </sect3>
  </sect2>

  <sect2 id="protocol-flow-ext-query">
   <title>Requête étendue</title>

   <para>
    Le protocole de requête étendue divise le protocole de requête simple décrit
    ci-dessus en plusieurs étapes.  Le résultat des étapes préparatoires peut
    être ré-utilisé plusieurs fois pour améliorer l'efficacité.  De plus, des
    fonctionnalités supplémentaires sont disponibles, tel que la possibilité de
    fournir des valeurs de données comme paramètres séparés au lieu d'avoir à
    les insérer directement dans la chaîne de la requête.
   </para>

   <para>
    Dans le protocole étendu, le client envoie en premier lieu un message Parse,
    qui contient une chaîne de caractères pour la requête, avec en options
    quelques informations sur les types de données des paramètres, et le nom
    d'un objet représentant la requête préparée (une chaîne vide indiquera une
    requête préparée sans nom).  La réponse est soit un message ParseComplete
    soit un message ErrorResponse. Les types de données des paramètres peuvent
    être des types de données indiquées par leur OID. Si aucun type n'est
    indiqué, l'analyseur tentera de deviner les types de données de la même
    façon qu'il le ferait pour des constantes de chaînes non typées.
   </para>

   <note>
    <para>
     Un type de paramètre peut être laissé sans spécification en le configurant
     à zéro ou en faisant en sorte que le table d'OID des types de paramètres
     soit de taille inférieur au nombre de symboles de paramètres
     (<literal>$</literal><replaceable>n</replaceable>) utilisés dans la chaîne
     de requête. Un autre cas spécial est qu'un type de paramètre peut être
     indiqué comme <type>void</type> (autrement dit, l'OID du pseudo-type
     <type>void</type>). Ceci permet l'utilisation de symboles de paramètre pour
     les paramètres de fonction qui sont en réalité des paramètres OUT.
     D'habitude, il n'y a pas de contexte dans lequel un paramètre
     <type>void</type> pourrait être utilisé, mais si un tel symbole de
     paramètre apparaît dans la liste de paramètres d'une fonction, il est en
     fait ignoré. Par exemple, un appel de fonction tel que
     <literal>foo($1,$2,$3,$4)</literal> pourrait correspondre à une fonction
     avec deux arguments IN et deux arguments OUT, si <literal>$3</literal> et
     <literal>$4</literal> sont indiqués comme étant de type <type>void</type>.
    </para>
   </note>

   <note>
    <para>
     La chaîne de requête contenue dans un message Parse ne peut pas inclure
     plus d'une requête SQL&nbsp;; dans le cas contraire une erreur SQL est
     levée. Cette restriction n'existe pas dans le protocole requête simple mais
     elle existe dans le protocole étendu parce que permettre à des requêtes
     préparées ou à des portails de contenir plusieurs commandes compliquerait
     indument le protocole.
    </para>
   </note>

   <para>
    En cas de succès à la création, un objet nommé de requête préparé existe
    jusqu'à la fin de la session, sauf s'il est détruit explicitement. Une
    requête préparée sans nom dure seulement jusqu'à l'exécution du prochain
    message Parse pour une requête préparée sans nom. (Notez qu'un message Query
    détruit aussi une requête préparée sans nom.) Les requêtes préparées nommées
    doivent être explicitement fermées avant de pouvoir être redéfinies par un
    autre message Parse, mais ceci n'est pas requis pour une requête préparée
    sans nom. Les requêtes préparées nommées peuvent aussi être créées et
    accédées au niveau des commandes SQL en utilisant les instructions
    <command>PREPARE</command> et <command>EXECUTE</command>.
   </para>

   <para>
    Une fois qu'une requête préparée existe, elle peut être préparée pour une
    exécution en utilisant le message Bind. Ce dernier donne le nom de la
    requête préparée source (ou une chaîne vide dans le cas d'une requête
    préparée sans nom) et les valeurs à utiliser pour tous les paramètres
    présents dans la requête préparée. L'ensemble de paramètres fournis doit
    correspondre ceux requis par la requête préparée. (Si vous avez indiqué un
    ou plusieurs paramètres <type>void</type> dans le message Parse, donnez des
    valeurs NULL pour chacune dans le message Bind.) Bind spécifie aussi le
    format à utiliser pour toute donnée renvoyée par la requête&nbsp;; le format
    peut être spécifié de façon globale ou par colonne. La réponse est soit
    BindComplete soit ErrorResponse.
   </para>

   <note>
    <para>
     Le choix entre une sortie texte et une sortie binaire est déterminé par les
     codes format donnés dans Bind, quelque soit la commande SQL impliquée.
     L'attribut <literal>BINARY</literal> dans les déclarations de curseur est
     hors sujet lors de l'utilisation du protocole de requête étendue.
    </para>
   </note>

   <para>
    La planification/optimisation de la requête survient typiquement quand le
    message Bind est traité. Si la requête préparée n'a pas de paramètres ou si
    elle est exécutée de façon répétée, le serveur pourrait sauvegarde le plan
    créé et le ré-utiliser lors des messages Bind suivants pour la même requête
    préparée. Néanmoins, il le fera seulement s'il trouve qu'un plan générique
    peut être créé, sans être trop inefficace par rapport à un plan dépendant
    des valeurs spécifiques fournies pour les paramètres. Ceci survient de façon
    transparente pour ce qui concerne le protocole.
   </para>

   <para>
    S'il est créé avec succès, un objet portail nommé dure jusqu'à la fin de la
    transaction en cours, sauf en cas de destruction explicite. Un portail non
    nommé est détruit à la fin de la transaction ou dès l'exécution du prochain
    message Bind pour un portal non nommé. (Notez qu'un simple message Query
    détruit aussi le portail sans nom.) Les portails nommés doivent être fermés
    explicitement avant de pouvoir être redéfinis par un autre message Bind,
    mais ceci n'est pas requis pour un portail non nommé. Les portails nommés
    peuvent aussi être utilisés et accédés au niveau des commandes SQL, en
    utilisant les instructions <command>DECLARE CURSOR</command> et
    <command>FETCH</command>.
   </para>

   <para>
    Une fois que le portail existe, il peut être exécuté en utilisant un message
    Execute. Ce dernier spécifie le nom du portail (une chaîne vide indique un
    portail non nommé) et un nombre maximum de lignes de résultat (zéro
    signifiant <quote>récupère toutes les lignes</quote>).  Ce nombre a
    seulement un sens pour les portails contenant des commandes renvoyant des
    ensembles de lignes&nbsp;; dans les autres cas, la commande est toujours
    exécutée jusqu'à sa fin, et le nombre de lignes est ignoré. Les réponses
    possibles à Exécute sont les mêmes que celles décrites ci-dessus pour les
    requêtes lancées via le protocole de requête simple, sauf que Execute ne
    cause pas l'exécution de ReadyForQuery ou RowDescription.
   </para>

   <para>
    Si Execute termine avant la fin de l'exécution d'un portail (à cause de
    l'atteinte d'un nombre de lignes résultats différent de zéro), il enverra un
    message PortalSuspended&nbsp;; l'apparence de ce message indique au client
    qu'un autre Execute devrait être exécuté contre le même portail pour
    terminer l'opération. Le message CommandComplete indiquant la fin de la
    commande SQL source n'est pas envoyé jusqu'à la fin de l'exécution du
    portail. De ce fait, une phase Execute est toujours terminée par
    l'apparition d'exactement un de ces messages&nbsp;: CommandComplete,
    EmptyQueryResponse (si le portail a été créé à partir d'une chaîne vide de
    requête), ErrorResponse ou PortalSuspended.
   </para>

   <para>
    À la fin de chaque série de messages du protocole de requête étendue, le
    client doit envoyer un message Sync. Ce message sans paramètre fait que le
    backend ferme la transaction en cours si elle n'est pas à l'intérieur d'un
    bloc de transaction <command>BEGIN</command>/<command>COMMIT</command>
    (<quote>fermer</quote> signifiant une validation s'il n'y a pas d'erreur et
    une annulation dans le cas d'une erreur). Une réponse ReadyForQuery est
    ensuite produite. Le but de Sync est de fournir un point de
    resynchronisation pour les erreurs. Quand une erreur est détectée lors du
    traitement de tout message du protocole de requête étendu, le backend envoie
    un message ErrorResponse, puis lit et annule les messages jusqu'à la
    réception d'un Sync, envoie un message ReadyForQuery et enfin retourne à un
    traitement habituelle des messages.  (Mais notez qu'une erreur dans le
    traitement du message Sync n'est pas ignoré &mdash; ceci assure qu'il y a
    bien un et un seul ReadyForQuery envoyé pour chaque Sync.)
   </para>

   <note>
    <para>
     Sync ne ferme pas un bloc de transaction ouvert avec
     <command>BEGIN</command>.  Il est possible de détecter cette situation car
     le message ReadyForQuery inclut des informations de statut de la
     transaction.
    </para>
   </note>

   <para>
    En plus de ces opérations fondamentales et requises, il existe plusieurs
    opérations optionnelles pouvant être utilisées avec le protocole de requête
    étendue.
   </para>

   <para>
    Le message Describe (variant du portail) indique le nom d'un portail
    existant (ou une chaîne vide pour le portail non nommé). La réponse est un
    message RowDescription décrivant les lignes qui seront retournées par
    l'exécution du portail&nbsp;; ou un message NoData si le portail ne contient
    pas une requête qui renverra des lignes&nbsp;; ou ErrorResponse s'il
    n'existe pas un tel portail.
   </para>

   <para>
    Le message Describe (variant de la requête) indique le nom d'une requête
    préparée existante (ou une chaîne vide pour la requête préparée non nommée).
    La réponse est un message ParameterDescription décrivant les paramètres
    nécessaires pour la requête, suivi par un message RowDescription décrivant
    les lignes qui seront renvoyés quand la requête sera enfin exécutée (ou un
    message NoData si la requête ne renverra pas de lignes). Le message
    ErrorResponse est renvoyé si cette requête préparée n'existe pas. Notez que,
    comme Bind n'a pas été exécutée, les formats à utiliser pour les colonnes
    renvoyés ne sont pas encore connus du backend&nbsp;; les champs de code
    format seront à zéro dans le message RowDescription dans ce cas.
   </para>

   <tip>
    <para>
     Dans la plupart des scénarios, le client doit envoyer une variante ou
     l'autre de Describe avant d'envoyer le message Execute, pour s'assurer
     qu'il sait comment interpréter les résultats qu'il récupérera.
    </para>
   </tip>

   <para>
    Le message Close ferme une requête préparée ou un portail existant, et
    libère les ressources. Ce n'est pas une erreur d'envoyer Close pour un nom
    inexistant de requête préparée ou de portail. La réponse est habituellement
    CloseComplete, mais pourrait être ErrorResponse si des difficultés sont
    rencontrées lors de la libération des ressources. Notez que fermer
    implicitement une requête préparée ferme tout portail ouvert qui était
    construit par cette requête.
   </para>

   <para>
    Le message Flush ne cause pas la génération d'une sortie spécifique mais
    force le backend à renvoyer toutes les données en attente dans les buffers de
    sortie. Un Flush doit être envoyé après toute commande de requête étendue
    sauf Sync, si le client souhaite examiner les résultats de cette commande
    avant de lancer d'autres commandes. Sans Flush, les messages renvoyés par le
    backend seront combinés dans le plus petit nombre de paquets pour minimiser
    la surcharge réseau.
   </para>

   <note>
    <para>
     Le message Query en requête simple est approximativement équivalent à une
     série Parse, Bind, Describe portail, Execute, Close, Sync, en utilisant une
     requête préparée et un portail non nommés et aucun paramètre. Une
     différence est qu'il acceptera plusieurs requêtes SQL dans la chaîne de
     requête, réalisant automatiquement les séquences bind/describe/execute pour
     chaque requête, les unes à la suite des autres.  Une autre différence est
     qu'il ne renvoie pas les messages ParseComplete, BindComplete,
     CloseComplete et NoData.
    </para>
   </note>
  </sect2>

  <sect2 id="protocol-flow-pipelining">
   <title>Pipelines</title>

   <indexterm zone="protocol-flow-pipelining">
    <primary>pipelines</primary>
    <secondary>spécification du protocole</secondary>
   </indexterm>

   <para>
    L'utilisation du protocole de requête étendue autorise les
    <firstterm>pipelines</firstterm>, autrement dit l'envoi d'une série de
    requêtes sans attendre que les premières se terminent. Ceci réduit le nombre
    d'aller/retour réseau nécessaire pour terminer une série d'opérations.
    Néanmoins, l'utilisateur doit faire attention au comportement souhaité si
    une des étapes échoue car les requêtes suivantes seront déjà envoyées au
    serveur.
   </para>

   <para>
    Une façon de gérer cela est de transformer la série complète de requête en
    une seule transaction, donc de l'entourer des commandes
    <command>BEGIN</command> ...  <command>COMMIT</command>. Cela n'aide
    cependant pas les personnes qui souhaiteraient que certaines commandes
    soient validées indépendamment des autres.
   </para>

   <para>
    Le protocole de requête étendue fournit un autre moyen pour gérer cette
    problématique. Il s'agit d'oublier d'envoyer les messages Sync entre les
    étapes qui sont dépendantes. Comme, après une erreur, le moteur ignorera les
    messages des commandes jusqu'à ce qu'il trouve un message Sync, cela
    autorise les commandes ultérieures d'un pipeline d'être automatiquement
    ignorées si une commande précédente échoue, sans que le client ait à gérer
    cela explicitement avec des commandes <command>BEGIN</command> et
    <command>COMMIT</command>. Les segments à valider indépendamment dans le
    pipeline peuvent être séparées par des messages Sync.
   </para>

   <para>
    Si le client n'a pas exécuté un <command>BEGIN</command> explicite, alors
    chaque Sync implique un <command>COMMIT</command> implicite si les étapes
    prédédentes ont réussi ou un <command>ROLLBACK</command> implicite si elles
    ont échoué. Néanmoins, il existe quelques commandes DDL (comme
    <command>CREATE DATABASE</command>) qui ne peuvent pas être exécutées dans
    un bloc de transaction. Si une de ces commandes est exécutée dans un
    pipeline, cela échouera sauf s'il s'agit de la première commande du pipeline.
    De plus, en cas de succès, cela forcera une validation immédiate pour
    préserver la cohérence de la base. De ce fait, un Sync suivant immédiatement une des ces
    commandes n'aura pas d'effet autre que de répondre avec ReadyForQuery.
   </para>

   <para>
    Lors de l'utilisation de cette méthode, la fin du pipelin doit être
    déterminée en comptant les messages ReadyForQuery et en attendant que cela
    atteigne le nombre de Sync envoyés. Compter les réponses de fin de commande
    n'est pas fiable car certaines commandes pourraient être ignorées et
    donc ne pas produire de message de fin.
   </para>
  </sect2>

  <sect2 id="protocol-flow-function-call">
   <title>Appel de fonction (<foreignphrase>Function Call</foreignphrase>)</title>

   <para>
    Le sous-protocole d'appel de fonction permet au client de demander un appel
    direct de toute fonction qui existe dans le catalogue système
    <structname>pg_proc</structname> de la base de données. Le client doit avoir
    le droit d'exécution sur la fonction.
   </para>

   <note>
    <para>
     Le sous-protocole d'appel de fonction est une ancienne fonctionnalité qu'il
     est certainement préférable d'éviter dans du nouveau code. Des résultats
     similaires peuvent être accomplis en configurant une requête préparée qui
     exécute <literal>SELECT function($1, ...)</literal>. Le cycle de l'appel de
     fonction peut ensuite être remplacé avec les messages Bind/Execute.
    </para>
   </note>

   <para>
    Un cycle d'appel de fonction est initié par le client en envoyant un message
    FunctionCall au backend. Le backend envoie alors un ou plusieurs messages de
    réponse suivant le résultat de l'appel de fonction, et termine avec un
    message ReadyForQuery. Ce message informe le client qu'il peut envoyer une
    nouvelle requête ou un nouvel appel de fonction.
   </para>

   <para>
    Les messages de réponse possible provenant du backend sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
        Une erreur est survenue
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>FunctionCallResponse</term>
      <listitem>
       <para>
        L'appel de fonction s'est terminé et a renvoyé le résultat donné dans le
        message. (Notez que le protocole d'appel de fonction peut seulement
        gérer un résultat scalaire simple, pas un type ligne ou un ensemble de
        résultats.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery</term>
      <listitem>
       <para>
        Le traitement de l'appel de fonction est terminé. Le message
        ReadyForQuery sera toujours envoyé, que le traitement termine avec
        succès ou avec une erreur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse</term>
      <listitem>
       <para>
        Un message d'avertissement a été lancé en relation avec l'appel de
        fonction. Les notes sont en plus des autres réponses, autrement dit le
        backend continuera à traiter la commande.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="protocol-copy">
   <title>Opérations COPY</title>

   <para>
    La commande <command>COPY</command> permet une transfert de données en masse
    très rapide du ou à partir du serveur. Les opérations de copie vers le
    serveur (<foreignphrase>copy-in</foreignphrase>) ou à partir du serveur
    (<foreignphrase>copy-out</foreignphrase>) font basculer la connexion dans un
    sous-protocole distinct, qui dure jusqu'à la fin de l'opération.
   </para>

   <para>
    Le mode <literal>Copy-in</literal> (transfert de données vers le serveur)
    est initié quand le backend exécute une requête SQL <command>COPY FROM
    STDIN</command>. Le backend envoie un message CopyInResponse au client. Le
    client doit alors envoyer zéro ou plusieurs messages CopyData, formant un
    flux de données en entrée. (Les limites du message ne sont pas nécessaires
    liées aux limites des lignes, bien qu'il s'agit souvent d'un choix
    raisonnable.) Le client peut terminer le mode <literal>copy-in</literal> en
    envoyant soit un message CopyDone (permettant une fin avec succès) ou un
    message CopyFail (qui causera l'échec de la requête SQL
    <command>COPY</command> avec un message d'erreur). Le backend annule alors
    le mode de traitement de commande dans lequel il était entré au début de la
    commande <command>COPY</command>, qui sera soit le protocole de requête
    simple ou celui de requête étendu.  Il enverra ensuite soit un message
    CommandComplete (en cas de réussite) soit un message ErrorResponse (dans le
    cas contraire).
   </para>

   <para>
    Dans le cas d'une erreur détecté par le backend lors du mode
    <literal>copy-in</literal> (incluant la réception d'un message CopyFail), le
    backend enverra un message ErrorResponse. Si la commande
    <command>COPY</command> a été lancée via un message de requête étendue, le
    backend ignorera maintenant les messages du client jusqu'à la réception d'un
    message Sync. Après, il enverra un message ReadyForQuery et retournera à un
    traitement normal. Si la commande <command>COPY</command> a été lancé via un
    message Query, le reste de ce message est ignoré et le message ReadyForQuery
    est envoyé. Dans tous les cas, les messages CopyData, CopyDone ou CopyFail
    suivants envoyés par le client seront simplement ignorés.
   </para>

   <para>
    Le backend ignorera les messages Flush et Sync reçus lors du mode
    <literal>copy-in</literal>.  La réception de tout autre message qui ne
    concerne pas la copie constitue une erreur qui annulera l'état
    <literal>copy-in</literal> comme décrit ci-dessus. (L'exception pour Flush
    et Sync est pour simplifier les bibliothèques clientes qui envoient toujours
    Flush ou Sync après un message Execute, sans vérifier si la commande à
    exécuter est un <command>COPY FROM STDIN</command>.)
   </para>

   <para>
    Le mode <foreignphrase>Copy-out</foreignphrase> (transfert de données à
    partir du serveur) est initié lorsque le backend exécute une requête SQL
    <command>COPY TO STDOUT</command>. Le backend envoie un message
    CopyOutResponse au client, suivi par zéro ou plusieurs messages CopyData
    (toujours un par ligne), suivi par un message CopyDone. Le backend annulera
    alors le mode de traitement de commande dans lequel il était avant le
    lancement de <command>COPY</command>. Enfin, il envoie CommandComplete.  Le
    client ne peut pas annuler le transfert (sauf en fermant la connexion ou en
    envoyant une requête Cancel), mais il peut ignorer les messages CopyData et
    CopyDone indésirables.
   </para>

   <para>
    Dans le cas d'une erreur détectée par le backend en mode
    <literal>copy-out</literal>, le backend lancera un message ErrorResponse et
    reviendra en traitement normal.  Le client devrait traiter la réception de
    ErrorResponse comme terminant le mode <literal>copy-out</literal>.
   </para>

   <para>
    Il est possible que les messages NoticeResponse et ParameterStatus soient
    mélangés entre des messages CopyData&nbsp;; les clients doivent gérer ces
    cas, et devraient être préparés aussi pour tout type de message asynchrone
    (voir <xref linkend="protocol-async"/>). Sinon, tout type de message autre
    que CopyData ou CopyDone peut être traité comme terminant le mode
    <literal>copy-out</literal>.
   </para>

   <para>
    Il existe un autre mode relatif à la copie, appelé
    <foreignphrase>copy-both</foreignphrase>, qui permet des transferts de
    données en masse et très rapides vers <emphasis>et</emphasis> à partir du
    serveur. Le mode <literal>copy-both</literal> est initié quand un backend en
    mode walsender exécute une instruction <command>START_REPLICATION</command>.
    Le backend envoie un message CopyBothResponse au client. Le backend et le
    client peuvent ensuite envoyer des messages CopyData jusqu'à ce que l'un des
    deux envoie un message CopyDone. Une fois que le client a envoyé un message
    CopyDone, le connexion passe du mode <literal>copy-both</literal> au mode
    <literal>copy-out</literal> et le client ne peut plus envoyer de messages
    CopyData.  De la même façon, quand le serveur envoie un message CopyDone, la
    connexion passe en mode <literal>copy-in</literal>, et le serveur ne peut
    plus envoyer de messages CopyData. Une fois que les deux ont envoyé un
    message CopyDone, le mode de copie est terminé, et le backend revient au
    mode de traitement des commandes. Dans le cas où une erreur est détectée par
    le backend pendant le mode <literal>copy-both</literal>, le backend enverra
    un message ErrorResponse, ignorera les messages du client jusqu'à ce qu'un
    message Sync ne soit reçu, puis enverra un message ReadyForQuery avant de
    revenir au traitement normal.  Le client doit traiter la réception d'un
    message ErrorResponse comme terminant la copie dans les deux
    directions&nbsp;; aucun message CopyDone ne devra être envoyé dans ce cas.
    Voir <xref linkend="protocol-replication"/> pour plus d'informations sur le
    sous-protocole transmis sur le mode <literal>copy-both</literal>.
   </para>

   <para>
    Les messages CopyInResponse, CopyOutResponse et CopyBothResponse incluent
    des champs qui informent le client du nombre de colonnes par ligne et des
    codes format utilisés pour chaque colonne. (Sur l'implémentation actuelle,
    toutes les colonnes d'une opération <command>COPY</command> donnée
    utiliseront le même format, mais le design des messages ne le force pas.)
   </para>

  </sect2>

  <sect2 id="protocol-async">
   <title>Opérations asynchrones</title>

   <para>
    Il existe différents cas où le backend enverra des messages qui ne sont pas
    spécifiquement demandés par le flux de commande du client. Les clients
    doivent être préparés à gérer aussi ces messages à tout moment, même quand
    une requête n'est pas en cours.  Au minimum, un client devrait vérifier ces
    cas avant de continuer à lire la réponse à une requête.
   </para>

   <para>
    Il est possible que des messages NoticeResponse soient générés à cause d'une
    activité externe&nbsp;; par exemple, si l'administrateur de la base de
    données ordonne un arrêt <quote>rapide</quote> de la base de données, le
    backend enverra un message NoticeResponse indiquant ce fait avant de fermer
    la connexion. Les clients doivent donc être prêts à accepter et afficher les
    messages NoticeResponse, même quand la connexion n'exécute pas de requêtes.
   </para>

   <para>
    Les messages ParameterStatus seront générés à chaque fois qu'une valeur
    change pour un des paramètres pour lesquels le backend pense que le client
    doit être notifié.  La plupart du temps, ceci survient en réponse à une
    commande SQL <command>SET</command> exécutée par le client, et ce cas est
    effectivement synchrone &mdash; mais il est aussi possible qu'un changement
    de valeur de paramètres survient parce que l'administrateur a modifié un
    fichier de configuration, puis envoyé le signal
    <systemitem>SIGHUP</systemitem> au serveur. De plus, si une commande
    <command>SET</command> est annulé, un message ParameterStatus approprié sera
    généré pour rapporter la valeur effective.
   </para>

   <para>
    Il existe actuellement un ensemble, codé en dur, de paramètres pour lesquels
    un message ParameterStatus sera généré. En voici la liste&nbsp;:
    <simplelist type="vert" columns="2">
     <member><varname>application_name</varname></member>
     <member><varname>client_encoding</varname></member>
     <member><varname>DateStyle</varname></member>
     <member><varname>default_transaction_read_only</varname></member>
     <member><varname>in_hot_standby</varname></member>
     <member><varname>integer_datetimes</varname></member>
     <member><varname>IntervalStyle</varname></member>
     <member><varname>is_superuser</varname></member>
     <member><varname>scram_iterations</varname></member>
     <member><varname>server_encoding</varname></member>
     <member><varname>server_version</varname></member>
     <member><varname>session_authorization</varname></member>
     <member><varname>standard_conforming_strings</varname></member>
     <member><varname>TimeZone</varname></member>
    </simplelist>
    (<varname>default_transaction_read_only</varname> et
    <varname>in_hot_standby</varname> ne sont pas rapportés avant la version
    14&nbsp;; <varname>scram_iterations</varname> n'est par rapporté avant la
    version 16.)
    Notez que
    <varname>server_version</varname>,
    <varname>server_encoding</varname> et
    <varname>integer_datetimes</varname>
    sont des pseudos-paramètres qui ne peuvent pas changer après le démarrage.
    Cet ensemble pourrrait être modifié dans le futur, voire même devenir
    configurable. En conséquence, un client devrait simplement ignorer les
    messages ParameterStatus pour les paramètres qu'il ne comprend pas ou qui ne
    sont pas intéressants pour lui.
   </para>

   <para>
    Si un client exécute une commande <command>LISTEN</command>, alors le
    backend enverra un message NotificationResponse (à ne pas confondre avec
    NoticeResponse&nbsp;!) à chaque fois qu'une commande
    <command>NOTIFY</command> est exécutée pour le même nom de canal.
   </para>

   <note>
    <para>
     Actuellement, NotificationResponse peut seulement être envoyé en dehors
     d'une transaction, et donc il ne surviendra pas au milieu d'une série de
     réponses à des commandes, bien qu'il puisse survenir juste avant un message
     ReadyForQuery. Il est déconseillé de concevoir la logique du client comme
     assumant cela. Une bonne pratique est d'être capable d'accepter un message
     NotificationResponse à tout moment dans le protocole.
    </para>
   </note>
  </sect2>

  <sect2 id="protocol-flow-canceling-requests">
   <title>Annuler des requêtes en cours</title>

   <para>
    Lors du traitement d'une requête, le client pourrait demander l'annulation
    de la requête. La demande d'annulation n'est pas envoyée directement sur la
    connexion ouverte sur le backend pour des raisons d'efficacité de
    l'implémentation&nbsp;: nous ne voulons pas avoir le backend en train de
    vérifier constamment pour une nouvelle entrée en provenance du client lors
    du traitement de la requête. Les demandes d'annulation sont relativement peu
    fréquentes, donc nous pouvons les rendre un peu compliquées pour éviter un
    pénalité sur les cas normaux.
   </para>

   <para>
    Pour demander une annulation, le client ouvre une nouvelle connexion au
    serveur et envoie un message CancelRequest, plutôt que le message
    StartupMessage qui serait habituellement envoyé lors d'une nouvelle
    connexion. Le serveur traitera cette demande, puis fermera la connexion.
    Pour des raisons de sécurité, aucune réponse directe n'est faite au message
    de demande d'annulation.
   </para>

   <para>
    Un message CancelRequest sera ignoré sauf s'il contient la même donnée clé
    (PID et clé sécrète) passée au client lors de la connexion. Si la demande
    correspond  au PID et à la clé secrète pour un backend en cours d'exécution
    d'une requête, le traitement de la requête est annulé. (Dans
    l'implémentation actuelle, ceci se fait en envoyant un signal spécial au
    processus backend qui traite la requête.)
   </para>

   <para>
    Le signal d'annulation pourrait avoir un effet ou pas &mdash; par exemple,
    s'il arrive après que le backend ait terminé le traitement de la requête, il
    n'aura aucun effet. Si l'annulation est réelle, la commande en cours est
    arrêtée avec un message d'erreur.
   </para>

   <para>
    Le résultat de tout ceci est que, pour des raisons de sécurité et
    d'efficacité, le client n'a pas de façon de savoir si la requête
    d'annulation a réussi. Il doit continuer d'attendre que le backend réponse à
    la requête. Exécuter une annulation améliore simplement les chances que la
    requête en cours termine rapidement, et améliore les chances qu'elle
    échouera avec un message d'erreur au lieu d'un succès.
   </para>

   <para>
    Comme la requête d'annulation est envoyée sur une nouvelle connexion au
    serveur et non pas via le lien standard de communication client/backend, il
    est possible d'envoyer une demande d'annulation pour tout processus, pas
    uniquement pour le client dont la requête est à annuler. Ceci apporte une
    flexibilité supplémentaire lors de la construction d'applications
    multi-processus. Cela introduit aussi un risque de sécurité dans le fait que
    des personnes non autorisées pourraient tenter d'annuler des requêtes. Le
    risque de sécurité est mitigé par le besoin d'une clé secrète générée
    dynamiquement, à fournir lors de demandes d'annulation.
   </para>
  </sect2>

  <sect2 id="protocol-flow-termination">
   <title>Arrêt</title>

   <para>
    La procédure normale et propre d'arrêt est que le client envoie un message
    Terminate et ferme immédiatement la connexion. Sur réception de ce message,
    le backend ferme la connexion et quitte.
   </para>

   <para>
    Dans les rares cas (tel qu'un arrêt de base demandé par l'administrateur),
    le backend pourrait se déconnecter sans demande du client. Dans ce genre de
    cas, le backend tentera d'envoyer un message d'erreur ou d'information,
    donnant la raison de la déconnexion avant de fermer la connexion.
   </para>

   <para>
    D'autres scénarios d'arrêt surgissent de différents cas d'échec, tel qu'un
    core dump d'un bout ou de l'autre, une perte du lien de communication, une
    perte de la synchronisation sur les messages, etc. Si soit le client soit le
    backend voit une fin inattendue de la connexion, il doit faire son ménage et
    quitter.  Le client a l'option de lancer un nouveau backend en recontactant
    le serveur s'il ne veut pas quitter. Fermer la connexion est aussi conseillé
    si un type de message non reconnu est reçu car cela indique probablement la
    perte de synchronisation des messages.
   </para>

   <para>
    Pour un arrêt normal ou anormal, toute transaction ouverte est annulée, et
    non pas validée. Néanmoins, notez que si un client se déconnecter alors
    qu'une requête autre qu'un <command>SELECT</command> est en cours de
    traitement, le backend finira probablement la requête sans se rendre compte
    de la déconnexion. Si la requête est exécutée en dehors d'un bloc de
    transaction (séquence <command>BEGIN</command> ...
    <command>COMMIT</command>), alors ses résultats pourraient être validées
    avant que le backend ne s'aperçoive de la déconnexion.
   </para>
  </sect2>

  <sect2 id="protocol-flow-ssl">
   <title>Chiffrement <acronym>SSL</acronym> de la session</title>

   <para>
    Si <productname>PostgreSQL</productname> a été compilé avec le support de
    <acronym>SSL</acronym>, les communications client/backend peuvent être
    chiffrés en utilisant <acronym>SSL</acronym>. Cela fournit une sécurité sur
    la communication pour les environnements où des attaquants pourraient être
    en mesure de capturer le trafic de la session. Pour plus d'informations sur
    le chiffrement des sessions <productname>PostgreSQL</productname> avec
    <acronym>SSL</acronym>, voir <xref linkend="ssl-tcp"/>.
   </para>

   <para>
    Pour initier une connexion chiffrée avec <acronym>SSL</acronym>, le client
    envoie dès le début un message SSLRequest au lieu de StartupMessage. Le
    serveur répond avec un seul octet contenant <literal>S</literal> ou
    <literal>N</literal>, indiquant s'il est, respectivement, prêt ou non à
    utiliser <acronym>SSL</acronym>. Le client pourrait fermer la connexion à ce
    point s'il n'est pas satisfait par la réponse. Pour continuer après un
    <literal>S</literal>, le client réalise une poignée de main
    <acronym>SSL</acronym> de démarrage (non décrit ici, car partie de la
    spécification <acronym>SSL</acronym>) avec le serveur. Si la poignée de main
    est réussie, le client continue avec l'habituel StartupMessage. Dans ce cas,
    le message StartupMessage et toutes les données qui suivent seront chiffrés
    avec <acronym>SSL</acronym>. Pour continuer après un <literal>N</literal>,
    le client envoie le message habituel StartupMessage et continue sans
    chiffrement.  (Il est aussi possible de lancer un message GSSENCRequest
    après une réponse <literal>N</literal> pour tenter l'utilisation du
    chiffrement <acronym>GSSAPI</acronym> à la place du chiffrement
    <acronym>SSL</acronym>.)
   </para>

   <para>
    Le client doit aussi se préparer à gérer un message ErrorMessage en réponse
    à un message SSLRequest. Le client ne doit pas afficher ce message d'erreur
    à l'utilisateur/application car le serveur n'a pas été authentifié
    (<ulink url="https://www.postgresql.org/support/security/CVE-2024-10977/">CVE-2024-10977</ulink>).
    Dans ce cas, la
    connexion doit être fermée mais le client pourrait choisir d'ouvrir une
    connexion propre et continuer sans demander <acronym>SSL</acronym>.
   </para>

   <para>
    Quand le chiffrement <acronym>SSL</acronym> peut être réalisé, le serveur
    est supposé envoyer l'octet <literal>S</literal>, puis attendre que le
    client initie une poignée de main <acronym>SSL</acronym>. Si des octets
    supplémentaires sont disponibles en lecture, cela signifie probablement
    qu'une attaque de type
    <foreignphrase>man-in-the-middle</foreignphrase> est en cours et tente de
    réaliser la technique <foreignphrase>buffer-stuffing</foreignphrase> (<ulink
    url="https://www.postgresql.org/support/security/cve-2021-23222/">CVE-2021-23222</ulink>).
    Les clients doivent être codés soit pour lire exactement un octet de la
    socket avant de renvoyer la socket à leur bibliothèque SSL ou de la traiter
    comme une violation du protocole s'ils voient qu'ils ont déjà des octets
    supplémentaires.
   </para>

   <para>
    De la même façon, le serveur s'attend à ce que le client ne commence pas
    la négociation <acronym>SSL</acronym> tant qu'il n'a pas reçu la réponse
    en un octet du serveur à la demande de <acronym>SSL</acronym>. Si le
    client commence la négociation <acronym>SSL</acronym> immédiatement,
    sans attendre la réception de la réponse du serveur, cela peut réduire
    la latence de connexion d'un aller/retour. Néanmoins, cela a un
    coût&nbsp;: ne pas être capable de gérer le cas où le serveur envoie une
    réponse négative à la demande de <acronym>SSL</acronym>. Dans ce cas,
    au lieu de continuer avec une connexion GSSAPI ou non chiffrée ou une
    erreur de procotole, le serveur se déconnectera tout simplement.
   </para>

   <para>
    Un message initial SSLRequest peut aussi être utilisé dans une connexion
    en cours d'ouverture pour envoyer un message CancelRequest.
   </para>

   <para>
     Une autre façon d'initier le chiffrement <acronym>SSL</acronym> est
     disponible. Le serveur reconnaitra les connexions qui commencent
     immédiatement une négociation <acronym>SSL</acronym> sans paquet
     SSLRequest. Une fois la connexion <acronym>SSL</acronym> établie, le
     serveur attendra un paquet standard startup-request et continuera la
     négociation sur un canal chiffré. Dans ce cas, toute autre requête de
     chiffrement sera refusée. Cette méthode n'est pas préférée pour les
     outils généralistes car elle ne peut pas négotier le meilleur
     chiffrement de la connexion et ne peut pas gérer les connexions non
     chiffrées. Cependant, c'est utile pour des environnements où le serveur
     et le client sont contrôlés ensemble. Dans ce cas, cela évite une
     latence d'un aller/retour, et permet l'utilisation d'outils réseaux
     dépendants de connexions standards <acronym>SSL</acronym>. Lors de
     l'utilisation de connexions <acronym>SSL</acronym> de ce style, le
     client doit utiliser l'extension ALPN définie par la
     <ulink url="https://tools.ietf.org/html/rfc7301">RFC 7301</ulink> pour
     se protéger contre les attaques de confusion de protocole. Le protocole
     <productname>PostgreSQL</productname> est enregistré sous le nom
     "postgresql" sur le resgistre <ulink url="https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids">IANA
     TLS ALPN Protocol IDs</ulink>.
   </para>

   <para>
    Alors que le protocole lui-même ne fournit pas de moyens pour que le serveur
    force un chiffrement <acronym>SSL</acronym>, l'administrateur peut
    configurer le serveur de telle façon qu'il rejette les sessions non
    chiffrées. Cela se fait pendant la vérification de l'authentification.
   </para>
  </sect2>

  <sect2 id="protocol-flow-gssapi">
   <title>Chiffrement <acronym>GSSAPI</acronym> des sessions</title>

   <para>
    Si <productname>PostgreSQL</productname> a été compilé avec le support de
    <acronym>GSSAPI</acronym>, les communications client/backend peuvent être
    chiffrées en utilisant <acronym>GSSAPI</acronym>. Ceci fournit une sécurité
    de la communication dans les environnements où les attaquants pourraient
    être en mesure de capturer le trafic de la session. Pour plus d'informations
    sur le chiffrement des sessions <productname>PostgreSQL</productname> avec
    <acronym>GSSAPI</acronym>, voir <xref linkend="gssapi-enc"/>.
   </para>

   <para>
    Pour initier une connexion chiffrée avec <acronym>GSSAPI</acronym>, le
    client doit au départ envoyer un message GSSENCRequest plutôt qu'un message
    StartupMessage. Le serveur répond avec un seul octet contenant
    <literal>G</literal> ou <literal>N</literal>, indiquant s'il est,
    respectivement, disposé ou non pour réaliser un chiffrement
    <acronym>GSSAPI</acronym>. Le client pourrait fermer la connexion à ce stage
    s'il n'est pas satisfait par la réponse. Pour continuer après un
    <literal>G</literal>, en utilisant les fonctions C de GSSAPI comme indiqué
    dans la <ulink url="https://datatracker.ietf.org/doc/html/rfc2744">RFC 2744</ulink> ou
    un équivalent, le client réalise une initialisation de
    <acronym>GSSAPI</acronym> en appelant
    <function>gss_init_sec_context()</function> dans une boucle et en envoyant
    le résultat au serveur, en commençant avec une entrée vide, et en continuant
    avec chaque résultat du serveur jusqu'à la fin. Lors de l'envoi de résultats
    de <function>gss_init_sec_context()</function> au serveur, il ajoute la
    longueur du message sous la forme d'un entier sous quatre octets dans
    l'ordre des octets du réseau.  Pour continuer après un <literal>N</literal>,
    il envoie le message habituel StartupMessage puis continue sans chiffrement.
    (Une autre solution est de lancer un message SSLRequest après une réponse
    <literal>N</literal> pour tenter l'utilisation d'un chiffrement
    <acronym>SSL</acronym> à la place du chiffrement <acronym>GSSAPI</acronym>.)
   </para>

   <para>
    Le client doit aussi être préparé à gérer une réponse ErrorMessage pour
    GSSENCRequest provenant du serveur. Le client ne doit pas afficher ce message
    d'erreur à l'utilisation/application carle serveur n'a pas été authentifié
    (<ulink url="https://www.postgresql.org/support/security/CVE-2024-10977/">CVE-2024-10977</ulink>).
    Dans ce cas, la connexion doit être
    termée, mais le client peut choisir d'ouvrir une nouvelle connexion et de
    continuer sans demander de chiffrement <acronym>GSSAPI</acronym>.
   </para>

   <para>
    Quand le chiffrement <acronym>GSSAPI</acronym> peut être réalisé, le serveur
    est supposé envoyer l'octet <literal>G</literal>, puis attendre que le
    client initie une poignée de main <acronym>GSSAPI</acronym>. Si des octets
    supplémentaires sont disponibles en lecture, cela signifie probablement
    qu'une attaque de type
    <foreignphrase>man-in-the-middle</foreignphrase> est en cours et tente de
    réaliser la technique <foreignphrase>buffer-stuffing</foreignphrase> (<ulink
    url="https://www.postgresql.org/support/security/cve-2021-23222/">CVE-2021-23222</ulink>).
    Les clients doivent être codés soit pour lire exactement un octet de la
    socket avant de renvoyer la socket à leur bibliothèque GSSAPI ou de la traiter
    comme une violation du protocole s'ils voient qu'ils ont déjà des octets
    supplémentaires à lire.
   </para>

   <para>
    Un message initial GSSENCRequest peut aussi être utilisé dans une
    connexion en cours d'ouverture pour envoyer un message CancelRequest.
   </para>

   <para>
    Une fois que le chiffrement <acronym>GSSAPI</acronym> a été établi avec
    succès, le client utilise la fonction <function>gss_wrap()</function> pour
    chiffrer le message StartupMessage habituel et toutes les données qui
    suivent, ajoutant la longueur du résultat de <function>gss_wrap()</function>
    sous la forme d'un entier sous quatre octets dans l'ordre d'octets du réseau
    à la charge chiffrée réelle. Notez que le serveur acceptera seulement des
    paquets chiffrés provenant du client qui font moins de 16&nbsp;Ko&nbsp;;
    <function>gss_wrap_size_limit()</function> devrait être utilisé par le
    client pour déterminer la taille du message non chiffré qui sera contenu
    dans cette limite, et les messages plus larges devront être divisés en
    plusieurs appels à <function>gss_wrap()</function>. Les segments typiques
    sont 8&nbsp;Ko de données non chiffrées, résultant en des paquets chiffrés
    légèrement supérieurs à 8&nbsp;Ko mais bien contenu dans les 16&nbsp;Ko
    maximum. Il est attendu que le serveur n'envoie pas de paquets de plus de
    16&nbsp;;Ko au client.
   </para>

   <para>
    Alors que le protocole lui-même ne fournit pas de moyens pour que le serveur
    force un chiffrement <acronym>GSSAPI</acronym>, l'administrateur peut
    configurer le serveur de telle façon qu'il rejette les sessions non
    chiffrées. Cela se fait pendant la vérification de l'authentification.
   </para>
  </sect2>
 </sect1>

 <sect1 id="sasl-authentication">
  <title>Authentification SASL</title>

  <para>
   <firstterm>SASL</firstterm> est un cadre pour l'authentification dans des
   protocoles orientés connexions. Actuellement,
   <productname>PostgreSQL</productname> implémente deux mécanismes
   d'authentification SASL, SCRAM-SHA-256 et SCRAM-SHA-256-PLUS. D'autres
   pourraient être ajoutés dans le futur. Les étapes ci-dessous illustrent
   comment l'authentification SASL est réalisé en général, alors que la
   sous-section suivante donne plus de détails sur SCRAM-SHA-256 et
   SCRAM-SHA-256-PLUS.
  </para>

  <procedure>
   <title>Flot de message d'authentification SASL</title>

   <step id="sasl-auth-begin">
    <para>
     Pour commencer un échange d'authentification SASL, le serveur envoie un
     message AuthenticationSASL. Il inclut une liste des mécanismes
     d'authentification SASL que le serveur peut accepter, dans l'ordre de
     préférence du serveur.
    </para>
   </step>

   <step id="sasl-auth-initial-response">
    <para>
     Le client sélectionne un des mécanismes supportés dans la liste, et envoie
     un message SASLInitialResponse au serveur. Le message inclut le nom du
     mécanisme sélectionné, et un optionnel <literal>Initial Client
     Response</literal>, si le mécanisme sélectionné utilise cela.
    </para>
   </step>

   <step id="sasl-auth-continue">
    <para>
     Un ou plusieurs messages <literal>server-challenge</literal> et
     <literal>client-response</literal> suivront. Chaque message
     <literal>server-challenge</literal> est envoyé dans un message
     AuthenticationSASLContinue, suivi par une réponse d'un client dans un
     message SASLResponse. Les particularités des messages sont spécifiques au
     mécanisme.
    </para>
   </step>

   <step id="sasl-auth-end">
    <para>
     Enfin, quand l'échange d'authentification est terminé avec succès, le
     serveur envoie un message AuthenticationSASLFinal, suivi immédiatement par
     un message AuthenticationOk. Le message AuthenticationSASLFinal contient
     des données supplémentaires du serveur au client, dont le contenu est
     spécifique au mécanisme d'authentification sélectionné. Si le mécanisme
     d'authentification n'utilise pas les données supplémentaires envoyées en
     fin, le message AuthenticationSASLFinal n'est pas envoyé.
    </para>
   </step>
  </procedure>

  <para>
   En cas d'erreur, le serveur peut annuler l'authentification à tout moment,
   et envoie un message ErrorMessage.
  </para>

  <sect2 id="sasl-scram-sha-256">
   <title>Authentification SCRAM-SHA-256</title>

   <para>
    Les mécanismes SASL implémentés actuellement sont
    <literal>SCRAM-SHA-256</literal> et son variant avec la liaison de canal
    <literal>SCRAM-SHA-256-PLUS</literal>. Ils sont décrits en détails dans
    <ulink url="https://datatracker.ietf.org/doc/html/rfc7677">RFC 7677</ulink> et <ulink
    url="https://datatracker.ietf.org/doc/html/rfc5802">RFC 5802</ulink>.
   </para>

   <para>
    Quand SCRAM-SHA-256 est utilisé dans PostgreSQL, le serveur ignorera le nom
    d'utilisateur que le client envoie dans
    <structname>client-first-message</structname>. Le nom d'utilisateur qui
    était déjà envoyé dans le message de démarrage est utilisé à la place.
    <productname>PostgreSQL</productname> accepte plusieurs encodages de
    caractères, alors que SCRAM impose l'utilisation d'UTF-8 pour le nom
    d'utilisateur, donc il pourrait être impossible de représenter le nom
    d'utilisateur PostgreSQL en UTF-8.
   </para>

   <para>
    La spécification SCRAM impose que le mot de passe soit aussi en UTF-8, et
    soit traité avec l'algorithme <firstterm>SASLprep</firstterm>. Néanmoins,
    <productname>PostgreSQL</productname> ne requiert pas l'utilisation d'UTF-8
    pour le mot de passE. Quand le mot de passe d'un utilisateur est configuré,
    il est traité avec SASLprep comme s'il était en UTF-8, quelque soit
    l'encodage réel. Néanmoins, s'il ne s'agit pas d'une séquence légale
    d'octets UTF-8 ou s'il contient des séquences d'octets UTF-8 qui sont
    interdites par l'algorithme SASLprep, le mot de passe brut sera utilisé sans
    le traitement de SASLprep, au lieu de renvoyer une erreur. Ceci permet au
    mot de passe d'être normalisé quand il est en UTF-8, en autorisant toujours
    l'utilisation d'un mot de passe non UTF-8, sans nécessiter que le système
    connaisse l'encodage du mot de passe.
   </para>

   <para>
    La liaison de canal (<firstterm>Channel binding</firstterm>) est accepté par
    PostgreSQL si ce dernier a été compilé avec le support de SSL. Le nom du
    mécanisme SASL pour SCRAM avec liaison de canal est
    <literal>SCRAM-SHA-256-PLUS</literal>. Le type de liaison utilisé par
    PostgreSQL est <literal>tls-server-end-point</literal>.
   </para>

   <para>
    Dans <acronym>SCRAM</acronym> sans liaison de canal, le serveur choisit un
    nombre aléatoire qui est transmis au client pour être mélangé avec le mot de
    passe fourni par l'utilisateur dans le hachage transmis du mot de passe.
    Bien que ceci empêche le hachage du mot de passe d'être retransmis avec
    succès dans une session ultérieure, cela n'empêche pas un faux serveur entre
    le serveur réel et le client de passer la valeur aléatoire du serveur et de
    s'authentifier avec succès.
   </para>

   <para>
    <acronym>SCRAM</acronym> avec liaison de canal empêche ce type d'attaques
    <foreignphrase>man-in-the-middle</foreignphrase> en mélangeant la signature
    du certificat du serveur dans le hachage transmis du mot de passe. Bien
    qu'un faux serveur peut retransmettre le certificat du vrai serveur, il n'a
    pas accès à la clé privée correspondant à ce certificat et ne peut donc pas
    prouver qu'il en est le propriétaire, imposant de ce fait un échec de la
    connexion SSL.
   </para>

   <procedure>
    <title>Exemple</title>
    <step id="scram-begin">
     <para>
      Le serveur envoie un message AuthenticationSASL. Il inclut une liste des
      mécanismes d'authentification SASL que le serveur peut accepter. Ce sera
      <literal>SCRAM-SHA-256-PLUS</literal> et <literal>SCRAM-SHA-256</literal>
      si le serveur dispose du support de SSL. Dans le cas contraire, ce sera
      uniquement le dernier.
     </para>
    </step>

    <step id="scram-client-first">
     <para>
      Le client répond en envoyant un message SASLInitialResponse, qui indique
      le mécanisme choisi, <literal>SCRAM-SHA-256</literal> ou
      <literal>SCRAM-SHA-256-PLUS</literal>. (Un client est libre de choisir un
      mécanisme mais pour une sécurité plus forte, il devra choisir la variante
      à liaison de canal s'il le gère.) Dans le champ <literal>Initial Client
      response</literal>, le message contient le message SCRAM
      <structname>client-first-message</structname>. Le message
      <structname>client-first-message</structname> contient aussi le type de
      liaison de canal choisi par le client.
     </para>
    </step>

    <step id="scram-server-first">
     <para>
      Le serveur envoie un message AuthenticationSASLContinue, avec un message
      SCRAM <structname>server-first-message</structname> comme contenu.
     </para>
    </step>

    <step id="scram-client-final">
     <para>
      Le client envoie un message SASLResponse, avec le message SCRAM
      <structname>client-final-message</structname> comme contenu.
     </para>
    </step>

    <step id="scram-server-final">
     <para>
      Le serveur envoie un message AuthenticationSASLFinal, avec le message
      SCRAM <structname>server-final-message</structname>, suivi immédiatement
      par un message AuthenticationOk.
     </para>
    </step>
   </procedure>
  </sect2>
 </sect1>

 <sect1 id="protocol-replication">
  <title>Protocole de réplication en flux</title>

  <para>
   Pour initier une réplication en flux, le client envoie le paramètre
   <literal>replication</literal> dans le message de démarrage. Une valeur
   booléenne à <literal>true</literal> (ou <literal>on</literal>,
   <literal>yes</literal>, <literal>1</literal>) indique au backend d'entrer
   dans le mode walsender de réplication physique, dans lequel un petit ensemble
   de commandes de réplication, affichées ci-dessous, peut être exécuté à la
   place de requêtes SQL.
  </para>

  <para>
   Passer <literal>database</literal> comme valeur du paramètre
   <literal>replication</literal> instruit le backend à entrer en mode walsender
   de réplication logique, se connectant à la base de données spécifiée par le
   paramètre <literal>dbname</literal>. Dans le mode walsender de réplication
   logique, les commandes de réplication affichées ci-dessous peuvent être
   exécutées ainsi que des commandes SQL standards.
  </para>

  <para>
   Dans les deux modes walsender, seul le protocole de requête simple peut
   être utilisé.
  </para>

  <para>
   Dans le but de tester des commandes de réplication, vous pouvez faire une
   connexion de réplication via l'outil <application>psql</application> ou tout
   autre outil utilisant la bibliothèque <application>libpq</application> avec
   une chaîne de connexion incluant l'option <literal>replication</literal>, par
   exemple&nbsp;:
<programlisting>
psql "dbname=postgres replication=database" -c "IDENTIFY_SYSTEM;"
</programlisting>
   Néanmoins, il est souvent plus utile d'utiliser
   <xref linkend="app-pgreceivewal"/> (pour la réplication physique) ou
   <xref linkend="app-pgrecvlogical"/> (pour la réplication logique).
  </para>

  <para>
   Les commandes de réplication sont tracées dans les journaux applicatifs du
   serveur quand <xref linkend="guc-log-replication-commands"/> est activé.
  </para>

  <para>
   Les commandes acceptées en mode réplication sont&nbsp;:

   <variablelist>
    <varlistentry id="protocol-replication-identify-system">
     <term><literal>IDENTIFY_SYSTEM</literal>
      <indexterm><primary>IDENTIFY_SYSTEM</primary></indexterm>
     </term>
     <listitem>
      <para>
       Demande au serveur de s'identifier. Le serveur répond avec un ensemble de
       résultats contenant une ligne composée de quatre champs&nbsp;:
      </para>

      <variablelist>
       <varlistentry>
        <term><literal>systemid</literal> (<type>text</type>)</term>
        <listitem>
         <para>
          L'identifiant système unique de l'instance. Ceci peut être utilisé
          pour vérifier que la sauvegarde utilisée pour initialiser le serveur
          secondaire provient bien de la même instance.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>timeline</literal> (<type>int8</type>)</term>
        <listitem>
         <para>
          Identifiant de timeline actuel. Aussi utile pour vérifier que le
          serveur secondaire est cohérent avec le primaire.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>xlogpos</literal> (<type>text</type>)</term>
        <listitem>
         <para>
          Emplacement actuel de vidage des journaux de transactions. Utile
          pour obtenir un emplacement connu dans les journaux de transactions
          où commencer le flux.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>dbname</literal> (<type>text</type>)</term>
        <listitem>
         <para>
          Base de données où se connecter, ou NULL.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>

    <varlistentry id="protocol-replication-show">
     <term><literal>SHOW</literal> <replaceable class="parameter">nom</replaceable>
      <indexterm><primary>SHOW</primary></indexterm>
     </term>
     <listitem>
      <para>
       Demande au serveur d'envoyer la configuration actuelle d'un paramètre.
       C'est similaire à la commande SQL <xref linkend="sql-show"/>.
      </para>

      <variablelist>
       <varlistentry>
        <term><replaceable class="parameter">nom</replaceable></term>
        <listitem>
         <para>
          Le nom d'un paramètre. Les paramètres disponibles sont documentées
          dans <xref linkend="runtime-config"/>.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>

    <varlistentry id="protocol-replication-timeline-history">
     <term><literal>TIMELINE_HISTORY</literal> <replaceable class="parameter">tli</replaceable>
      <indexterm><primary>TIMELINE_HISTORY</primary></indexterm>
     </term>
     <listitem>
      <para>
       Demande au serveur d'envoyer le fichier d'historique des timelines pour
       la timeline <replaceable class="parameter">tli</replaceable>. Le serveur
       répond avec un ensemble de résultat d'une seule ligne comprenant deux
       champs. Bien que les champs soient du type <type>text</type>, elles
       renvoient réellement des octets bruts sans conversion d'encodage&nbsp;:
      </para>

      <variablelist>
       <varlistentry>
        <term><literal>filename</literal> (<type>text</type>)</term>
        <listitem>
         <para>
          Nom du fichier d'historique des timelines, par exemple
          <filename>00000002.history</filename>.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>content</literal> (<type>text</type>)</term>
        <listitem>
         <para>
          Contenu du fichier d'historique des timelines.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>

    <varlistentry id="protocol-replication-create-replication-slot" xreflabel="create_replication_slot">
     <term><literal>CREATE_REPLICATION_SLOT</literal> <replaceable class="parameter">nom_slot</replaceable> [ <literal>TEMPORARY</literal> ] { <literal>PHYSICAL</literal> | <literal>LOGICAL</literal> <replaceable class="parameter">plugin_sortie</replaceable> } [ ( <replaceable class="parameter">option</replaceable> [, ...] ) ]
      <indexterm><primary>CREATE_REPLICATION_SLOT</primary></indexterm>
     </term>
     <listitem>
      <para>
       Crée un slot de réplication physique ou logique. Voir
       <xref linkend="streaming-replication-slots"/> pour plus d'informations
       sur les slots de réplication.
      </para>

      <variablelist>
       <varlistentry>
        <term><replaceable class="parameter">nom_slot</replaceable></term>
        <listitem>
         <para>
          Le nom du slot à créer. Ce doit être un nom valide pour un slot de
          réplication (voir <xref
          linkend="streaming-replication-slots-manipulation"/>).
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><replaceable class="parameter">output_plugin</replaceable></term>
        <listitem>
         <para>
          Le nom du plugin de sortie utilisé pour le décodage logique
          (voir <xref linkend="logicaldecoding-output-plugin"/>).
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>TEMPORARY</literal></term>
        <listitem>
         <para>
          Indique que ce slot de réplication est un slot temporaire. Les slots
          temporaires ne sont pas sauvegardés sur disque et sont automatiquement
          supprimés en cas d'erreur ou quand la session est terminée.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

      <para>Les options suivantes sont acceptées&nbsp;:</para>

      <variablelist>
       <varlistentry>
        <term><literal>TWO_PHASE [ <replaceable class="parameter">boolean</replaceable> ]</literal></term>
        <listitem>
         <para>
          Si true, ce slot de réplication logique accepte le décodage des
          validations en deux phases. Avec cette option, les commandes relatives
          au 2PC telles que <literal>PREPARE TRANSACTION</literal>,
          <literal>COMMIT PREPARED</literal> et <literal>ROLLBACK
          PREPARED</literal> sont décodées et transmises. La transaction sera
          décodée et transmise au moment du <literal>PREPARE
          TRANSACTION</literal>. La valeur par défaut est false.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>RESERVE_WAL [ <replaceable class="parameter">boolean</replaceable> ]</literal></term>
        <listitem>
         <para>
          Si true, ce slot de réplication physique réserve immédiatement les
          <acronym>WAL</acronym>. Sinon, les <acronym>WAL</acronym> sont
          seulement réservés à la connexion d'un client de réplication en flux.
          La valeur par défaut est false.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SNAPSHOT { 'export' | 'use' | 'nothing' }</literal></term>
        <listitem>
         <para>
          Décide ce qu'il faut faire du snapshot créé lors de l'initialisation
          du slot logique. <literal>'export'</literal>, qui est la valeur par
          défaut, exportera le snapshot à utiliser dans d'autres sessions. Cette
          option ne peut pas être utilisée à l'intérieur d'une transaction.
          <literal>'use'</literal> utilisera le snapshot pour la transaction
          courante exécutant la commande. Cette option doit être utilisée dans
          une transaction, et <literal>CREATE_REPLICATION_SLOT</literal> doit
          être la première commande exécutée dans cette transaction. Enfin,
          <literal>'nothing'</literal> utilisera uniquement le snapshot pour le
          décodage logique comme d'habitude mais ne fera rien de plus avec.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>FAILOVER [ <replaceable class="parameter">boolean</replaceable> ]</literal></term>
        <listitem>
         <para>
          Si true, le slot est activé pour être synchronisé vers les
          serveurs secondaires, pour que la réplication logique puisse
          continuer après une bascule de type failover. La valeur par défaut
          est false.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

      <para>
       En réponse à cette commande, le serveur enverra un ensemble de résultat
       d'une ligne contenant les champs suivants&nbsp;:

       <variablelist>
        <varlistentry>
         <term><literal>slot_name</literal> (<type>text</type>)</term>
         <listitem>
          <para>
           Le nom du slot de réplication nouvellement créé.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>consistent_point</literal> (<type>text</type>)</term>
         <listitem>
          <para>
           L'emplacement dans les WAL à partir duquel le slot devient cohérent.
           C'est l'emplacement le plus proche à partir duquel le flux peut
           commencer sur ce slot de réplication.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>snapshot_name</literal> (<type>text</type>)</term>
         <listitem>
          <para>
           L'identifiant du snapshot exporté par la commande. Le snapshot est
           valide jusqu'à l'exécution d'une nouvelle commande sur cette
           connexion ou jusqu'à la fermeture de la connexion de réplication.
           NULL si le slot créé est physique.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>output_plugin</literal> (<type>text</type>)</term>
         <listitem>
          <para>
           Le nom du plugin de sortie utilisé par le slot de réplication
           nouvellement créé. NULL si le slot créé est physique.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="protocol-replication-create-replication-slot-legacy">
     <term><literal>CREATE_REPLICATION_SLOT</literal> <replaceable class="parameter">slot_name</replaceable> [ <literal>TEMPORARY</literal> ] { <literal>PHYSICAL</literal> [ <literal>RESERVE_WAL</literal> ] | <literal>LOGICAL</literal> <replaceable class="parameter">output_plugin</replaceable> [ <literal>EXPORT_SNAPSHOT</literal> | <literal>NOEXPORT_SNAPSHOT</literal> | <literal>USE_SNAPSHOT</literal> | <literal>TWO_PHASE</literal> ] }
     </term>
     <listitem>
      <para>
       Pour la compatibilité avec les anciennes versions, cette syntaxe
       alternative pour <literal>CREATE_REPLICATION_SLOT</literal> est toujours
       acceptée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="protocol-replication-alter-replication-slot" xreflabel="ALTER_REPLICATION_SLOT">
     <term><literal>ALTER_REPLICATION_SLOT</literal> <replaceable class="parameter">nom_slot</replaceable> ( <replaceable class="parameter">option</replaceable> [, ...] )
      <indexterm><primary>ALTER_REPLICATION_SLOT</primary></indexterm>
     </term>
     <listitem>
      <para>
       Modifie la définition d'un slot de réplication. Voir <xref
       linkend="streaming-replication-slots"/> pour plus d'informations sur
       les slots de réplication. Cette commande accepte actuellement
       uniquement les slots de réplication logique.
      </para>

      <variablelist>
       <varlistentry>
        <term><replaceable class="parameter">slot_name</replaceable></term>
        <listitem>
         <para>
          Le nom du slot à modifier. Doit être un nom valide de slot de
          réplication (voir <xref
          linkend="streaming-replication-slots-manipulation"/>).
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

      <para>Les options suivants sont acceptées&nbsp;:</para>

      <variablelist>
       <varlistentry>
        <term><literal>FAILOVER [ <replaceable class="parameter">boolean</replaceable> ]</literal></term>
        <listitem>
         <para>
          Si true, le slot est activé pour être synchronisé vers les serveurs
          secondaires pour que la réplication logique puisse continuer après
          une bascule de type failover.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </listitem>
    </varlistentry>

    <varlistentry id="protocol-replication-read-replication-slot">
     <term><literal>READ_REPLICATION_SLOT</literal> <replaceable class="parameter">nom_slot</replaceable>
      <indexterm><primary>READ_REPLICATION_SLOT</primary></indexterm>
     </term>
     <listitem>
      <para>
       Lit certaines informations associées avec un slot de réplication.
       Renvoie une ligne avec des valeurs <literal>NULL</literal> si le slot de
       réplication n'existe pas. Cette commande est actuellement uniquement
       acceptée pour les slots de réplication physique.
      </para>

      <para>
       En réponse à cette commande, le serveur renverra un ensemble de
       résultats d'une ligne, contenant les champs suivants&nbsp;:
       <variablelist>
        <varlistentry>
         <term><literal>slot_type</literal> (<type>text</type>)</term>
         <listitem>
          <para>
           Le type du slot de réplication, soit <literal>physical</literal>
           soit <literal>NULL</literal>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>restart_lsn</literal> (<type>text</type>)</term>
         <listitem>
          <para>
           Le <literal>restart_lsn</literal> du slot de réplication.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>restart_tli</literal> (<type>int8</type>)</term>
         <listitem>
          <para>
           L'identifiant de timeline associé avec <literal>restart_lsn</literal>,
           suivant l'historique actuelle des timelines.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="protocol-replication-start-replication">
     <term><literal>START_REPLICATION</literal> [ <literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable> ] [ <literal>PHYSICAL</literal> ] <replaceable class="parameter">XXX/XXX</replaceable> [ <literal>TIMELINE</literal> <replaceable class="parameter">tli</replaceable> ]
      <indexterm><primary>START_REPLICATION</primary></indexterm>
     </term>
     <listitem>
      <para>
       Demande au serveur de commencer le flux de WAL, en commençant à
       l'emplacement <replaceable class="parameter">XXX/XXX</replaceable>.  Si
       l'option <literal>TIMELINE</literal> est spécifiée, le flux commence sur
       la timeline <replaceable class="parameter">tli</replaceable>&nbsp;; sinon
       la timeline actuelle du serveur est sélectionnée. Le serveur peut
       répondre avec une erreur, par exemple si la section demandée de WAL a
       déjà été recyclée. En cas de succès, le serveur répond avec un message
       CopyBothResponse, puis commence le flux de WAL vers le client.
      </para>

      <para>
       Si un nom de slot est fourni via <replaceable
       class="parameter">slot_name</replaceable>, il sera mis à jour au fur et à
       mesure de la progression de la réplication pour que le serveur se
       rappelle des segments WAL et, si <varname>hot_standby_feedback</varname>
       vaut <literal>on</literal>, des transactions toujours nécessaires pour le
       secondaire.
      </para>

      <para>
       If the client requests a timeline that's not the latest but is part of
       the history of the server, the server will stream all the WAL on that
       timeline starting from the requested start point up to the point where
       the server switched to another timeline. If the client requests
       streaming at exactly the end of an old timeline, the server skips COPY
       mode entirely.
      </para>

      <para>
       Après le flux de tous les WAL d'une timeline qui n'est pas la dernière,
       le serveur terminera le flux en sortant du mode COPY. Quand le client
       reconnait cette situation en quittant lui aussi le mode COPY, le serveur
       envoie un ensemble de résultats d'une ligne et de deux colonnes,
       indiquant la prochaine timeline dans l'historique du serveur. La première
       colonne est l'identifiant de la prochaine timeline (type
       <type>int8</type>), et la deuxième colonne est l'emplacement des WAL où
       la bascule a eu lieu (type <type>text</type>). Habituellement, la
       position de bascule est la fin du WAL en cours de flux, mais il existe
       des cas particuliers où le serveur peut envoyer certains WAL de
       l'ancienne timeline qu'il n'a pas encore rejoué avant la promotion.
       Enfin, le serveur envoie deux messages CommandComplete (un qui termine le
       CopyData et l'autre qui termine le <literal>START_REPLICATION</literal>
       lui-même), et est prêt à accepter une nouvelle commande.
      </para>

      <para>
       Les données WAL sont envoyées sous la forme d'une série de messages
       CopyData&nbsp;;
       voir <xref linkend="protocol-message-types"/> et <xref
       linkend="protocol-message-formats"/> pour les détails.
       (Ceci permet le mélange d'autres informations&nbsp;; en
       particulier, le serveur peut envoyer un message ErrorResponse s'il
       rencontre un échec après le début du flux.) La charge de chaque message
       CopyData du serveur vers le client contient un message sur un des formats
       suivants&nbsp;:
      </para>

      <variablelist>
       <varlistentry id="protocol-replication-xlogdata">
        <term>XLogData (B)</term>
        <listitem>
         <variablelist>
          <varlistentry>
           <term>Byte1('w')</term>
           <listitem>
            <para>
             Identifie le message comme des données WAL.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term>Int64</term>
           <listitem>
            <para>
             Le début des données WAL dans ce message.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term>Int64</term>
           <listitem>
            <para>
             La fin actuelle des WAL sur le serveur.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term>Int64</term>
           <listitem>
            <para>
             L'horloge système du serveur au moment de la transmission,
             en microsecondes depuis le 1er janvier 2000 à minuit.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term>Byte<replaceable>n</replaceable></term>
           <listitem>
            <para>
             Une section du flux de données WAL.
            </para>

            <para>
             Un enregistrement WAL seul n'est jamais divisé en deux messages
             XLogData. Quand un enregistrement WAL arrive sur une limite de
             page d'un WAL et est, de ce fait, déjà divisé en utilisant les
             enregistrements de continuité, il peut être divisé sur la limite de
             la page. Autrement dit, le premier enregistrement WAL principal et
             ses enregistrements de continuité peuvent être envoyés dans
             différents messages XLogData.
            </para>
           </listitem>
          </varlistentry>
         </variablelist>
        </listitem>
       </varlistentry>

       <varlistentry id="protocol-replication-primary-keepalive-message">
        <term>Primary keepalive message (B)</term>
        <listitem>
         <variablelist>
          <varlistentry>
           <term>Byte1('k')</term>
           <listitem>
            <para>
             Identifie le message comme un keepalive de l'envoyeur.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term>Int64</term>
           <listitem>
            <para>
             La fin actuelle du WAL sur le serveur.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term>Int64</term>
           <listitem>
            <para>
             L'horloge système du serveur au moment de la transmission, en
             microsecondes depuis le 1er janvier 2000.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term>Byte1</term>
           <listitem>
            <para>
             1 signifie que le client devrait répondre à ce message aussi
             vite que possible pour éviter une déconnexion par dépassement
             de délai d'attente.
            </para>
           </listitem>
          </varlistentry>
         </variablelist>
        </listitem>
       </varlistentry>
      </variablelist>

      <para>
       Le processus en réception peut envoyer des réponses à l'émetteur à tout
       moment, en utilisant un des formats de message suivants (aussi dans la
       charge d'un message CopyData)&nbsp;:
      </para>

      <variablelist>
       <varlistentry id="protocol-replication-standby-status-update">
        <term>Standby status update (F)</term>
        <listitem>
         <variablelist>
          <varlistentry>
           <term>Byte1('r')</term>
           <listitem>
            <para>
             Identifie le message comme mise à jour du statut du receveur.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term>Int64</term>
           <listitem>
            <para>
             L'emplacement du dernier octet du WAL + 1 réçu et écrit sur
             disque par le secondaire.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term>Int64</term>
           <listitem>
            <para>
             L'emplacement du dernier octet du WAL + 1 vidé sur disque par le
             secondaire.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term>Int64</term>
           <listitem>
            <para>
             L'emplacement du dernier octet du WAL + 1 appliqué sur disque par le
             secondaire.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term>Int64</term>
           <listitem>
            <para>
             L'horloge système du serveur au moment de la transmission, en
             microsecondes depuis le 1er janvier 2000.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term>Byte1</term>
           <listitem>
            <para>
             Si 1, le client demande au serveur de répondre immédiatement à
             ce message. Ceci peut être utilisé pour appeler le serveur,
             pour tester si la connexion est toujours active.
            </para>
           </listitem>
          </varlistentry>
         </variablelist>
        </listitem>
       </varlistentry>

       <varlistentry id="protocol-replication-hot-standby-feedback-message">
        <term>Hot standby feedback message (F)</term>
        <listitem>
         <variablelist>
          <varlistentry>
           <term>Byte1('h')</term>
           <listitem>
            <para>
             Identifie le message comme un message de retour d'informations du
             serveur secondaire.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term>Int64</term>
           <listitem>
            <para>
             L'horloge système du serveur au moment de la transmission, en
             microsecondes depuis le 1er janvier 2000.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term>Int32</term>
           <listitem>
            <para>
             Le <literal>xmin</literal> global actuel du secondaire, excluant
             le <literal>catalog_xmin</literal> de tout slot de réplication.
             Si cette valeur et le <literal>catalog_xmin</literal> suivant
             sont à 0, ceci est traité comme une notification que le retour
             du secondaire ne sera plus envoyé sur cette connexion. Des
             messages ultérieurs différents de zéro pourraient ré-initier le
             mécanisme de retour.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term>Int32</term>
           <listitem>
            <para>
             Le nombre epoch du <literal>xmin</literal> global sur le
             serveur secondaire.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term>Int32</term>
           <listitem>
            <para>
             Le <literal>catalog_xmin</literal> le plus bas de tout slot de
             réplication sur le secondaire. Configuré à 0 si aucun
             <literal>catalog_xmin</literal> n'existe sur le secondaire ou si
             le retour d'informations du secondaire est en cours de
             désactivation.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term>Int32</term>
           <listitem>
            <para>
             Le nombre epoch du <literal>catalog_xmin</literal> sur le secondaire.
            </para>
           </listitem>
          </varlistentry>
         </variablelist>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>

    <varlistentry id="protocol-replication-start-replication-slot-logical">
     <term><literal>START_REPLICATION</literal> <literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable> <literal>LOGICAL</literal> <replaceable class="parameter">XXX/XXX</replaceable> [ ( <replaceable>option_name</replaceable> [ <replaceable>option_value</replaceable> ] [, ...] ) ]</term>
     <listitem>
      <para>
       Demande au serveur de commencer le flux de WAL pour la réplication
       logique, en commençant soit à la position WAL <replaceable
       class="parameter">XXX/XXX</replaceable> soit à la position
       <literal>confirmed_flush_lsn</literal> du slot (voir <xref
       linkend="view-pg-replication-slots"/>), suivant la position la plus
       grande. Ce comportement facilite la tache pour les clients qui évitent
       ainsi de mettre à jour le statut LSN local quand il n'y a aucune donnée à
       traiter. Cependant, commencer à un LSN différent de celui demandé
       pourrait ne pas récupérer certaines types d'erreurs clients&nbsp;; donc
       le client pourrait souhaiter vérifier que
       <literal>confirmed_flush_lsn</literal> correspond à ses attentes avant de
       lancer <literal>START_REPLICATION</literal>.
      </para>

      <para>
       Le serveur peut répondre avec une erreur, par exemple si le slot
       n'existe pas. En cas de succès, le serveur répond avec un message
       CopyBothResponse, puis lance le flux de WAL vers le client.
      </para>

      <para>
       Le message à l'intérieur des messages CopyBothResponse sont du même
       format documenté que pour <literal>START_REPLICATION ...
       PHYSICAL</literal>, ceci incluant les deux messages CommandComplete.
      </para>

      <para>
       Le plugin de sortie associé avec le slot sélectionné est utilisé pour
       traiter la sortie pour le flux.
      </para>

      <variablelist>
       <varlistentry>
        <term><literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable></term>
        <listitem>
         <para>
          Le nom du slot pour lequel envoyer en flux les changements. Ce
          paramètre est requis, et doit correspondre à un slot existant de
          réplication logique créé avec
          <literal>CREATE_REPLICATION_SLOT</literal> dans le mode
          <literal>LOGICAL</literal> mode.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><replaceable class="parameter">XXX/XXX</replaceable></term>
        <listitem>
         <para>
          L'emplacement dans le WAL à partir duquel commence le flot.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><replaceable class="parameter">option_name</replaceable></term>
        <listitem>
         <para>
          Le nom d'une option passée au plugin de décodage logique du slot.
          Voir <xref linkend="protocol-logical-replication"/> pour les options
          qui sont acceptées par le plugin standard (<literal>pgoutput</literal>).
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><replaceable class="parameter">option_value</replaceable></term>
        <listitem>
         <para>
          Valeur optionnelle, sous le forme d'une constante de type chaîne de
          caractères, associée à l'option indiquée.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>

    <varlistentry id="protocol-replication-drop-replication-slot">
     <term>
      <literal>DROP_REPLICATION_SLOT</literal> <replaceable class="parameter">slot_name</replaceable> <optional> <literal>WAIT</literal> </optional>
      <indexterm><primary>DROP_REPLICATION_SLOT</primary></indexterm>
     </term>
     <listitem>
      <para>
       Supprime un slot de réplication, libérant toute ressource réservée.
      </para>

      <variablelist>
       <varlistentry>
        <term><replaceable class="parameter">slot_name</replaceable></term>
        <listitem>
         <para>
          Le nom du slot à supprimer.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>WAIT</literal></term>
        <listitem>
         <para>
          Cette option force la commande à attendre si le slot est actif et
          jusqu'à ce que ce dernier devienne inactif. Dans le cas contraire,
          une erreur est levée (comportement par défaut).
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>

    <varlistentry id="protocol-replication-upload-manifest">
     <term>
      <literal>UPLOAD_MANIFEST</literal>
      <indexterm><primary>UPLOAD_MANIFEST</primary></indexterm>
     </term>
     <listitem>
      <para>
       Charge un manifeste de sauvegarde pour préparer une sauvegarde
       incrémentale.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="protocol-replication-base-backup" xreflabel="base_backup">
     <term><literal>BASE_BACKUP</literal> [ ( <replaceable class="parameter">option</replaceable> [, ...] ) ]
      <indexterm><primary>BASE_BACKUP</primary></indexterm>
     </term>
     <listitem>
      <para>
       Demande au serveur le lancement d'une sauvegarde en flux. Le système
       sera automatiquement placé en mode sauvegarde avant que la sauvegarde ne
       commence, et sorti de ce mode quand la sauvegarde est terminée. Les options
       suivantes sont acceptées&nbsp;:

       <variablelist>
        <varlistentry>
         <term><literal>LABEL</literal> <replaceable>'label'</replaceable></term>
         <listitem>
          <para>
           Configure le label de la sauvegarde. Si aucun label n'est donné, le
           label <literal>base backup</literal> sera utilisé. Les règles de
           guillemet pour le label sont les mêmes que pour une chaîne SQL
           standard lorsque <xref linkend="guc-standard-conforming-strings"/>
           vaut <literal>on</literal>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TARGET</literal> <replaceable>'target'</replaceable></term>
         <listitem>
          <para>
           Indique au serveur où envoyer la sauvegarde. Si la cible est
           <literal>client</literal> (ce qui est la valeur par défaut), les
           données de la sauvegarde sont envoyées au client. Si elle vaut
           <literal>server</literal>, les données de la sauvegarde sont écrites
           sur le serveur dans le chemin indiqué par l'option
           <literal>TARGET_DETAIL</literal>. Si elle vaut
           <literal>blackhole</literal>, les données de la sauvegarde ne sont
           pas envoyées&nbsp;; elles sont simplement ignorées.
          </para>

          <para>
           La cible <literal>server</literal> nécessite l'attribut
           <literal>SUPERUSER</literal> ou être membre du rôle
           <literal>pg_write_server_files</literal>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TARGET_DETAIL</literal> <replaceable>'detail'</replaceable></term>
         <listitem>
          <para>
           Fournit des informations supplémentaires sur la cible de sauvegarde.
          </para>

          <para>
           Actuellement, cette option peut seulement être utilisée quand la
           cible de sauvegarde est <literal>server</literal>. Elle indique le
           répertoire du serveur, répertoire dans lequel la sauvegarde sera
           écrite.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>PROGRESS [ <replaceable class="parameter">boolean</replaceable> ]</literal></term>
         <listitem>
          <para>
           Si configuré à true, réclame des informations nécessaires pour
           générer un rapport de progression. Cela enverra une taille
           approximative dans l'en-tête de chaque tablespace, qui peut être
           utilisé pour calculer le reste du flux. Le calcul se fait en
           énumérant toutes les tailles de fichier avant que le transfert ne
           commence, et cela pourrait avoir un impact négatif sur les
           performances. En particulier, cela pourrait prendre du temps avant
           que les premières données ne soient envoyées. Comme les fichiers de
           la base peuvent évoluer pendant la sauvegarde, la taille n'est
           qu'approximative, et pourrait soit augmenter soit diminuer entre le
           moment de l'approximation et celui de l'envoi des fichiers. La valeur
           par défaut est false.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>CHECKPOINT { 'fast' | 'spread' }</literal></term>
         <listitem>
          <para>
           Configure le type de checkpoint à réaliser au début de la
           sauvegarde. La valeur par défaut est <literal>spread</literal>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>WAL [ <replaceable class="parameter">boolean</replaceable> ]</literal></term>
         <listitem>
          <para>
           Si configuré à true, inclut les segments WAL nécessaires dans la
           sauvegarde. Cela inclura tous les fichiers entre le début et la fin
           de la sauvegarde, et ils seront placés dans le répertoire
           <filename>pg_wal</filename> du répertoire principal. La valeur par
           défaut est false.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>WAIT [ <replaceable class="parameter">boolean</replaceable> ]</literal></term>
         <listitem>
          <para>
           Si configuré à true, la sauvegarde attendra jusqu'à ce que le dernier
           segment WAL requis soit archivé ou émettra un message d'avertissement
           si l'archivage des journaux de transactions n'est pas activé. Si
           false, la sauvegarde n'attendra pas et ne préviendra pas, laissant le
           client responsable de la vérification de la disponibilité du dernier
           segment WAL. La valeur par défaut est false.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>COMPRESSION</literal> <replaceable>'method'</replaceable></term>
         <listitem>
          <para>
           Demande au serveur de compresser la sauvegarde en utilisant la
           méthode indiquée.  Actuellement, les méthodes acceptées sont
           <literal>gzip</literal>, <literal>lz4</literal> et
           <literal>zstd</literal>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>COMPRESSION_DETAIL</literal> <replaceable>detail</replaceable></term>
         <listitem>
          <para>
           Donne les détails sur la méthode de compression choisie. Ceci devrait
           être utilisé en conjonction avec l'option
           <literal>COMPRESSION</literal>. Si la valeur est un entier, elle
           indique le niveau de compression. Sinon, elle peut être une liste
           d'éléments séparés par des virgules, chaque élément étant de la forme
           <replaceable>motclé</replaceable> ou <replaceable>motclé=valeur</replaceable>.
           Actuellement, les mots clés acceptés sont <literal>level</literal>,
           <literal>long</literal> et <literal>workers</literal>.
          </para>

          <para>
           Le mot clé <literal>level</literal> configure le niveau de
           compression. Pour <literal>gzip</literal>, le niveau de compression
           devrait être un entier compris entre <literal>1</literal> et
           <literal>9</literal> (par défaut
           <literal>Z_DEFAULT_COMPRESSION</literal> ou <literal>-1</literal>),
           pour <literal>lz4</literal> un entier compris entre 1 et 12 (par
           défaut <literal>0</literal> pour le mode de compression rapide), et
           pour <literal>zstd</literal> un entier compris entre
           <literal>ZSTD_minCLevel()</literal> (habituellement
           <literal>-131072</literal>) et <literal>ZSTD_maxCLevel()</literal>
           (habituellement <literal>22</literal>), (par défaut
           <literal>ZSTD_CLEVEL_DEFAULT</literal> ou <literal>3</literal>).
          </para>

          <para>
           Le mot clé <literal>long</literal> active le mode de correspondance
           longue distance pour un ratio de compression amélioré, aux dépends
           d'une utilisation plus forte de la mémoire. Le mode longue distance
           est acceptée uniquement pour <literal>zstd</literal>.
          </para>

          <para>
           Le mot clé <literal>workers</literal> configure le nombre de threads
           devant être utilisé pour paralléliser la compression. Cette
           fonctionnalité n'est disponible qu'avec <literal>zstd</literal>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>MAX_RATE</literal> <replaceable>rate</replaceable></term>
         <listitem>
          <para>
           Limite la quantité maximale de données transférées du serveur au
           client par unité de temps. L'unité attendue est du Ko par seconde.
           Si cette option est indiqué, la valeur doit être soit égale à zéro,
           soit être compris dans l'intervalle allant de 32 ko à 1 Go (valeurs
           inclues). Si un zéro est passé ou si l'option n'est pas indiquée,
           aucune restriction n'est imposée pendant le transfert.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TABLESPACE_MAP [ <replaceable class="parameter">boolean</replaceable> ]</literal></term>
         <listitem>
          <para>
           Si true, inclut des informations sur les liens symboliques présents
           dans le répertoire <filename>pg_tblspc</filename> dans un fichier
           nommé <filename>tablespace_map</filename>. Le fichier de cartographie
           des tablespaces inclut, pour chaque tablespace, le nom du lien
           symbolique dans le répertoire <filename>pg_tblspc/</filename> et le
           chemin complet de ce lien symbolique.  La valeur par défaut est
           false.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>VERIFY_CHECKSUMS [ <replaceable class="parameter">boolean</replaceable> ]</literal></term>
         <listitem>
          <para>
           Si true, les sommes de contrôle sont vérifiées lors d'une sauvegarde
           si elles sont activées. Si false, elles sont ignorées. La valeur par
           défaut est true.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>MANIFEST</literal> <replaceable>manifest_option</replaceable></term>
         <listitem>
          <para>
           Quand cette option est indiquée avec une valeur
           <literal>yes</literal> ou <literal>force-encode</literal>, un
           manifest de sauvegarde est créé et envoyé avec la sauvegarde. Le
           manifeste est une liste de chaque fichier présent dans la sauvegarde
           à l'exception des fichiers WAL qui y sont inclus. Il enregistre aussi
           la taille, l'horodatage de la dernière modification et en option une
           somme de contrôle pour chaque fichier. Une valeur de
           <literal>force-encode</literal> force tous les noms de fichier à être
           codé en hexadécimal&nbsp;; sinon ce type d'encodage est réalisé
           seulement pour les fichiers dont le nom est une séquence d'octets non
           UTF8. <literal>force-encode</literal> existe principalement pour des
           tests, pour être sûr que les clients qui lisent le manifeste de
           sauvegarde puissent gérer ce cas. Pour la compatibilité avec les
           anciennes versions, la valeur par défaut est <literal>MANIFEST
           'no'</literal>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>MANIFEST_CHECKSUMS</literal> <replaceable>checksum_algorithm</replaceable></term>
         <listitem>
          <para>
           Précise l'algorithme des sommes de contrôle, à appliquer à chaque
           fichier inclus dans le manifeste de sauvegarde. Actuellement, les
           seuls algorithmes disponibles sont <literal>NONE</literal>,
           <literal>CRC32C</literal>, <literal>SHA224</literal>,
           <literal>SHA256</literal>, <literal>SHA384</literal> et
           <literal>SHA512</literal>.  La valeur par défaut est
           <literal>CRC32C</literal>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>INCREMENTAL</literal></term>
         <listitem>
          <para>
           Réclame une sauvegarde incrémentale. La commande
           <literal>UPLOAD_MANIFEST</literal> doit être exécutée avant de
           lancer une sauvegarde de base avec cette option.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>

      <para>
       Quand la sauvegarde est lancée, le serveur enverra tout d'abord deux
       ensembles de résultats ordinaires, suivis par un ou plusieurs résultats
       CopyOutResponse.
      </para>

      <para>
       Le premier ensemble de résultat contient la position de départ de la
       sauvegarde, sur une liste ligne comprenant deux colonnes. La première
       colonne contient la position de départ donné dans un format correspondant
       à XLogRecPtr, et la deuxième colonne contient l'identifiant de la
       timeline correspondante.
      </para>

      <para>
       Le deuxième ensemble de résultat a une ligne pour chaque tablespace.
       Voici la liste des champs de cette ligne&nbsp;:

       <variablelist>
        <varlistentry>
         <term><literal>spcoid</literal> (<type>oid</type>)</term>
         <listitem>
          <para>
           L'OID du tablespace, ou NULL s'il s'agit du répertoire principal.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>spclocation</literal> (<type>text</type>)</term>
         <listitem>
          <para>
           Le chemin complet du répertoire du tablespace, ou NULL si c'est le
           répertoire principal.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>size</literal> (<type>int8</type>)</term>
         <listitem>
          <para>
           La taille approximative du tablespace, en kilooctets (1024 octets),
           si le rapport de progression a été demandé&nbsp;; sinon NULL.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>

      <para>
       Après le deuxième ensemble de résultats, un message CopyOutResponse sera
       envoyé. La chaque de chaque message CopyData contiendra un message dans
       un des formats suivants&nbsp;:
      </para>

      <variablelist>
       <varlistentry>
        <term>new archive (B)</term>
        <listitem>
         <variablelist>
          <varlistentry>
           <term>Byte1('n')</term>
           <listitem><para>
            Identifie le messaage comme indiquant le début d'une nouvelle
            archive. Il y a aura une archive pour le répertoire principal des
            données et une archive pour chaque tablespace supplémentaire&nbsp;;
            chacune utilisera le format tar (en suivant le format <quote>ustar
            interchange format</quote> spécifié dans le standard POSIX
            1003.1-2008).
           </para></listitem>
          </varlistentry>

          <varlistentry>
           <term>String</term>
           <listitem><para>
            Le nom du fichier pour cette archive.
           </para></listitem>
          </varlistentry>

          <varlistentry>
           <term>String</term>
           <listitem><para>
            Pour le répertoire principal des données, une chaîne vide. Pour
            les autres tablespaces, le chemin complet vers le répertoire à
            partir duquel cette archive a été créée.
           </para></listitem>
          </varlistentry>
         </variablelist>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term>manifest (B)</term>
        <listitem>
         <variablelist>
          <varlistentry>
           <term>Byte1('m')</term>
           <listitem><para>
            Identifie le message comme indiquant le début d'un manifeste de
            sauvegarde.
           </para></listitem>
          </varlistentry>
         </variablelist>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term>archive or manifest data (B)</term>
        <listitem>
         <variablelist>
          <varlistentry>
           <term>Byte1('d')</term>
           <listitem><para>
            Identifie le message comme contenant une archive ou des données
            du manifeste.
           </para></listitem>
          </varlistentry>

          <varlistentry>
           <term>Byte<replaceable>n</replaceable></term>
           <listitem><para>
            Octets des données.
           </para></listitem>
          </varlistentry>
         </variablelist>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term>progress report (B)</term>
        <listitem>
         <variablelist>
          <varlistentry>
           <term>Byte1('p')</term>
           <listitem><para>
            Identifie le message comme un rapport de progression.
           </para></listitem>
          </varlistentry>

          <varlistentry>
           <term>Int64</term>
           <listitem><para>
            Le nombre d'octets du tablespace actuel pour lequel le traitement a
            terminé.
           </para></listitem>
          </varlistentry>
         </variablelist>
        </listitem>
       </varlistentry>
      </variablelist>

      <para>
       Après que le CopyOutResponse et tous ces types de réponses aient été
       envoyés, un ensemble de résultat ordinaire final sera envoyé, contenant
       la position finale dans les WAL de la sauvegarde, dans le même format que
       la position de départ.
      </para>

      <para>
       L'archive tar pour le répertoire de données principal et pour chaque
       tablespace contiendra tous les fichiers des répertoires, qu'ils
       appartiennent à <productname>PostgreSQL</productname> ou pas (fichiers
       ajoutées dans le même répertoire).  Les fichiers exclus sont&nbsp;:

       <itemizedlist spacing="compact" mark="bullet">
        <listitem>
         <para>
          <filename>postmaster.pid</filename>
         </para>
        </listitem>
        <listitem>
         <para>
          <filename>postmaster.opts</filename>
         </para>
        </listitem>
        <listitem>
         <para>
          <filename>pg_internal.init</filename> (trouvé dans plusieurs répertoires)
         </para>
        </listitem>
        <listitem>
         <para>
          Différents fichiers et répertoires temporaires créés pendant les
          opérations du serveur PostgreSQL, tels que les fichiers ou répertoire
          commençant avec <filename>pgsql_tmp</filename> et les objets
          temporaires.
         </para>
        </listitem>
        <listitem>
         <para>
          Relations non journalisées, sauf pour le type init qui est requis pour
          recréer à vide les relations non journalisés lors d'une restauration.
         </para>
        </listitem>
        <listitem>
         <para>
          <filename>pg_wal</filename>, en incluant les sous-répertoires. Si la
          sauvegarde est exécuté avec les fichiers WAL inclus, une version
          synthétisée de <filename>pg_wal</filename> sera inclus, mais elle
          contiendra seulement les fichiers nécessaires pour que la sauvegarde
          fonctionne, et pas le reste du contenu.
         </para>
        </listitem>
        <listitem>
         <para>
          <filename>pg_dynshmem</filename>, <filename>pg_notify</filename>,
          <filename>pg_replslot</filename>, <filename>pg_serial</filename>,
          <filename>pg_snapshots</filename>, <filename>pg_stat_tmp</filename> et
          <filename>pg_subtrans</filename> sont copiés sous la forme de
          répertoires vides (même s'il s'agit de lien symbolique).
         </para>
        </listitem>
        <listitem>
         <para>
          Fichiers autres que les fichiers et répertoires standards, tels que des
          liens symboliques (autre que pour les répertoires indiqués ci-dessus),
          les fichiers périphériques et les fichiers du système d'exploitation.
          Les liens symboliques dans
          <filename>pg_tblspc</filename> sont maintenus.)
         </para>
        </listitem>
       </itemizedlist>
       Propriétaire, groupe et droits sont configurés si le système de fichiers
       sous-jacent l'accepte.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Dans toutes les commandes ci-dessus, lors de la spécification d'un
   paramètre de type <type>boolean</type>, la partie
   <replaceable class="parameter">valeur</replaceable> peut être omise,
   ce qui sera équivalent à indiquer <literal>TRUE</literal>.
  </para>
 </sect1>

<sect1 id="protocol-logical-replication">
 <title>Protocole de réplication logique en flux</title>

 <para>
  Cette section décrit le protocole de réplication logique qui consiste en un
  flux de message démarré par la commande  <literal>START_REPLICATION</literal>
  <literal>SLOT</literal> <replaceable class="parameter">nom_slot</replaceable>
  <literal>LOGICAL</literal>.
 </para>

 <para>
  Le protocole de réplication logique en flux se base sur les primitives du
  protocole de réplication physique en flux.
 </para>

 <para>
  Le décodage logique <productname>PostgreSQL</productname> accepte des plugins
  de sortie. <literal>pgoutput</literal> est le plugin standard utilisé par la
  réplication logique native.
 </para>

 <sect2 id="protocol-logical-replication-params">
  <title>Paramètres de la réplication logique en flux</title>

  <para>
   En utilisant la commande de réplication logique
   <literal>START_REPLICATION</literal>, le plugin <literal>pgoutput</literal>
   accepte les options suivantes&nbsp;:

   <variablelist>
    <varlistentry>
     <term>
      proto_version
     </term>
     <listitem>
      <para>
       La version du protocole. Actuellement, les versions <literal>1</literal>,
       <literal>2</literal>, <literal>3</literal> et <literal>4</literal> sont
       supportées. Une version valide est requise.
      </para>
      <para>
       La version <literal>2</literal> n'est supportée qu'à partir de la version
       14 et permet la transmission de transactions volumineuses non terminées.
      </para>
      <para>
       La version <literal>3</literal> n'est supportée qu'à partir de la version
       15 et permet l'utilisation de la validation en deux phases (2PC) avec la
       réplication logique.
      </para>
      <para>
       La version <literal>4</literal> est acceptée uniquement à partir de la
       version 16, et elle permet l'envoi de grandes transactions en cours pour
       une application en parallèle.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      publication_names
     </term>
     <listitem>
      <para>
       Liste séparée par des virgules contenant les noms de publication
       auxquelles s'abonner (recevoir les modifications). Les noms individuels
       de publication sont traités comme des noms d'objets standard et peuvent
       être mis entre guillemets si nécessaire. Il est requis d'indiquer
       au moins un nom de publication.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      binary
     </term>
     <listitem>
      <para>
       Option booléenne pour utiliser le mode de transfert binaire. Le mode
       binaire est plus rapide que le mode texte mais un peu moins robuste.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      messages
     </term>
     <listitem>
      <para>
       Option booléenne pour activer l'envoi de messages qui sont écrits par
       <function>pg_logical_emit_message</function>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      streaming
     </term>
     <listitem>
      <para>
       Option booléenne pour activer l'envoi en flux des transactions en cours.
       Il accepte une valeur supplémentaire <literal>parallel</literal> pour
       activer l'envoi d'informations supplémentaires avec certains messages
       utilisés pour la parallélisation. Il est requis d'activer au minimum la
       version 2 du protocole.  La version 4 est nécessaire pour l'option
       <literal>parallel</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      two_phase
     </term>
     <listitem>
      <para>
       Option booléenne pour activer les transactions en deux phases. Il est
       requis d'activer au minimum la version3 du protocole.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      origin
     </term>
     <listitem>
      <para>
       Option pour envoyer les changements suivant leur origine. Les valeurs
       possibles sont <literal>none</literal> pour envoyer uniquement les
       changements qui n'ont pas d'origine associée, et <literal>any</literal>
       pour envoyer les changements quelque soit leur origine. Ceci peut être
       utilisé pour éviter des boucles (réplication infinie de la même donnée)
       parmi les nœuds de réplication.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </para>
 </sect2>

 <sect2 id="protocol-logical-messages">
  <title>Messages du protocole de réplication logique</title>

  <para>
   Les messages individuels du protocole sont discutés dans les sous-sections
   suivantes. Les messages individuels sont décrits dans
   <xref linkend="protocol-logicalrep-message-formats"/>.
  </para>

  <para>
   Tous les message haut niveau du protocole commencent avec un octet de type
   de message. Bien que représenté dans le code comme un caractère, c'est en
   fait un octet signé sans encodage associé.
  </para>

  <para>
   Comme le protocole de réplication en flux fournit une longueur de message,
   il n'est pas nécessaire que les messages haut niveau du protocole embarquent
   une longueur dans leur en-tête.
  </para>

 </sect2>

 <sect2 id="protocol-logical-messages-flow">
  <title>Flot des messages du protocole de réplication logique</title>

  <para>
   À l'exception de la commande <literal>START_REPLICATION</literal> et des
   messages de progression du rejeu, toutes les informations se déplacent
   uniquement du backend vers le client.
  </para>

  <para>
   Le protocole de réplication logique envoie les transactions individuelles
   l'une après l'autre. Cela signifie que tous les messages entre une paire de
   messages Begin et Commit appartiennent à la même transaction. De façon
   similaire, tous les messages entre une paire de messages Begin Prepare et
   Prepare appartiennent à la même transaction.  Il envoie aussi les changements
   de grosses transactions en cours entre une paire de messages Stream Start et
   Stream Stop. Le dernier lot d'une telle transaction contient un message
   Stream Commit ou Stream Abort.
  </para>

  <para>
   Chaque transaction envoyée contient zéro ou plusieurs messages DML (Insert,
   Update, Delete). Dans le cas d'une configuration en cascade, elle peut aussi
   contenir des messages Origin. Le message origine indique que la transaction
   provient d'un autre nœud de réplication. Comme un nœud de réplication peut
   être à peu près tout dans le cas du protocole de réplication logique, le seul
   identifiant est le nom de l'origine. C'est au client de gérer ceci.  Le
   message Origin est toujours envoyé avant tout message DML dans la
   transaction.
  </para>

  <para>
   Chaque message DML contient un OID de relation, identifiant la relation
   concernée. Avant le premier message DML pour un OID de relation donné, un
   message Relation sera envoyé, décrivant le schéma de cette relation. Après
   cela, un nouveau message Relation sera envoyé si la définition de la relation
   a changé depuis l'envoi du dernier message Relation.  (Le protocole suppose
   que le client est capable de se rappeler de cette méta donnée pour toutes les
   relations impliquées.)
  </para>

  <para>
   Les messages Relation identifient les types des colonnes par leur OID. Dans
   le cas d'un type interne, il est supposé que le client peut rechercher cet
   OID localement, donc aucune donnée supplémentaire n'est nécessaire. Pour les
   OID de type utilisateur, un message Type sera envoyé avant le message
   Relation pour fournir le nom du type associé à cet OID. De ce fait, un
   client qui a besoin d'identifier spécifiquement les types des colonnes d'une
   relation devrait placer en cache le contenu des messages Type, et consulter
   ce cache pour vérifier si l'OID du type y est défini. Dans le cas contraire,
   il sera possible de rechercher localement l'OID du type.
  </para>
 </sect2>
</sect1>

 <sect1 id="protocol-message-types">
  <title>Types de données des messages</title>

  <para>
   Cette section décrit les types de données de base utilisés dans les
   messages.
  </para>

  <variablelist>
   <varlistentry>
    <term>Int<replaceable>n</replaceable>(<replaceable>i</replaceable>)</term>
    <listitem>
     <para>
      Un entier sur <replaceable>n</replaceable> bits dans l'ordre d'octet
      réseau (l'octet le plus significatif en premier).
      Si <replaceable>i</replaceable> est précisé, il s'agit de la valeur
      exacte qui apparaîtra, sinon la valeur est variable.
      Par exemple, Int16, Int32(42).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Int<replaceable>n</replaceable>[<replaceable>k</replaceable>]</term>
    <listitem>
     <para>
      Un tableau d'entiers de <replaceable>k</replaceable>
      <replaceable>n</replaceable> bits, chacun dans l'ordre d'octet réseau.
      La longueur du tableau <replaceable>k</replaceable> est toujours
      déterminée par un champ précédent dans le message.
      Par exemple, Int16[M].
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>String(<replaceable>s</replaceable>)</term>
    <listitem>
     <para>
      Une chaîne terminée par un octet nul (chaîne du type C). Il n'y a pas
      de limitation spécifique de longueur sur les chaînes.
      Si <replaceable>s</replaceable> est indiqué, il s'agit de la valeur
      exacte qui apparaîtra. Sinon la valeur est variable.
      Par exemple, String, String("user").
     </para>

     <note>
      <para>
       <emphasis>Il n'y a pas de limite prédéfinie</emphasis> sur la longueur
       d'une chaîne qui peut être renvoyée par le backend. Une bonne
       stratégie de codage pour un client est d'utiliser un tampon expansif
       pour que tout ce qui puisse être stocké en mémoire soit accepté. Si
       ce n'est pas faisable, lire la chaîne et ignorer les caractères en fin
       qui ne rentrent pas dans le tampon de taille fixe.
      </para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Byte<replaceable>n</replaceable>(<replaceable>c</replaceable>)</term>
    <listitem>
     <para>
      Exactement <replaceable>n</replaceable> octets. Si la largeur du champ
      <replaceable>n</replaceable> n'est pas une constante, il est toujours
      déterminable à partir d'un champ précédent dans le message. Si
      <replaceable>c</replaceable> est indiqué, il s'agit de la valeur exacte.
      Par exemple, Byte2, Byte1('\n').
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>

 <sect1 id="protocol-message-formats">
  <title>Formats de message</title>

  <para>
   Cette section décrit le format détaillé de chaque message. Tous sont
   marqués pour indiquer qu'ils peuvent être envoyés par un client
   (F, pour <foreignphrase>frontend</foreignphrase> en anglais), par un
   backend (B) ou les deux (F &amp; B).
   Notez que, bien que chaque message inclut un décompte d'octets au début,
   le format de message est défini pour que la fin du message puisse être
   trouvée sans faire référence au nombre d'octets. Ceci aide à vérifier
   la validité du message. (Le message CopyData est une exception car
   il fait partie d'un flux de données&nbsp;; le contenu de tout message
   CopyData individuel ne peut pas être interprété indépendamment.)
  </para>

  <variablelist>
   <varlistentry id="protocol-message-formats-authenticationok">
    <term>AuthenticationOk (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('R')</term>
       <listitem>
        <para>
         Identifie le message comme une demande d'authentification.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(8)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(0)</term>
       <listitem>
        <para>
         Indique que l'authentification est réussie.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-authenticationkerberosv5">
    <term>AuthenticationKerberosV5 (B)</term>
    <listitem>

     <variablelist>
      <varlistentry>
       <term>Byte1('R')</term>
       <listitem>
        <para>
         Identifie le message comme une demande d'authentification.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(8)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(2)</term>
       <listitem>
        <para>
         Indique que l'authentification Kerberos V5 est requise.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-authenticationcleartextpassword">
    <term>AuthenticationCleartextPassword (B)</term>
    <listitem>

     <variablelist>
      <varlistentry>
       <term>Byte1('R')</term>
       <listitem>
        <para>
         Identifie le message comme une demande d'authentification.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(8)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(3)</term>
       <listitem>
        <para>
         Indique que l'authentification par mot de passe en clair en requise.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-authenticationmd5password">
    <term>AuthenticationMD5Password (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('R')</term>
       <listitem>
        <para>
         Identifie le message comme une demande d'authentification.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(12)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(5)</term>
       <listitem>
        <para>
         Indique que le mot de passe chiffré avec MD5 est requis.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte4</term>
       <listitem>
        <para>
         Le sel à utiliser lors du chiffrement du mot de passe.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-authenticationgss">
    <term>AuthenticationGSS (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('R')</term>
       <listitem>
        <para>
         Identifie le message comme une demande d'authentification.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Int32(8)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(7)</term>
       <listitem>
        <para>
         Indique qu'une authentification GSSAPI est requise.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-authenticationgsscontinue">
    <term>AuthenticationGSSContinue (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('R')</term>
       <listitem>
        <para>
         Identifie le message comme une demande d'authentification.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(8)</term>
       <listitem>
        <para>
         Indique que ce message contient des données GSSAPI ou SSPI.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte<replaceable>n</replaceable></term>
       <listitem>
        <para>
         Données d'authentification GSSAPI ou SSPI.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-authenticationsspi">
    <term>AuthenticationSSPI (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('R')</term>
       <listitem>
        <para>
         Identifie le message comme une demande d'authentification.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(8)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(9)</term>
       <listitem>
        <para>
         Indique que l'authentification SSPI est requise.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-authenticationsasl">
    <term>AuthenticationSASL (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('R')</term>
       <listitem>
        <para>
         Identifie le message comme une demande d'authentification.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(10)</term>
       <listitem>
        <para>
         Indique que l'authentification SASL est requise.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Le corps du message est une liste de mécanismes d'authentification SASL,
      dans l'ordre de préférence du serveur. Un octet zéro est requis en fin
      après le nom du dernier mécanisme d'authentification. Pour chaque
      mécanisme, il y a ce qui suit&nbsp;:

      <variablelist>
       <varlistentry>
        <term>String</term>
        <listitem>
         <para>
          Nom d'un mécanisme d'authentification SASL.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-authenticationsaslcontinue">
    <term>AuthenticationSASLContinue (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('R')</term>
       <listitem>
        <para>
         Identifie le message comme une demande d'authentification.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(11)</term>
       <listitem>
        <para>
         Indique que ce message contient un challenge SASL.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte<replaceable>n</replaceable></term>
       <listitem>
        <para>
         Données SASL, spécifiques au mécanisme SASL utilisé.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-authenticationsaslfinal">
    <term>AuthenticationSASLFinal (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('R')</term>
       <listitem>
        <para>
         Identifie le message comme une demande d'authentification.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(12)</term>
       <listitem>
        <para>
         Indique que l'authentification SASL s'est terminée.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte<replaceable>n</replaceable></term>
       <listitem>
        <para>
         Données supplémentaires SASL, spécifiques au mécanisme SASL
         utilisé.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-backendkeydata">
    <term>BackendKeyData (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('K')</term>
       <listitem>
        <para>
         Identifie le message comme une donnée clé d'annulation. Le client
         doit conserver ces valeurs s'il souhaite être capable d'exécuter
         ultérieurement des messages CancelRequest.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(12)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Identifiant du processus de ce backend.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Clé secrète de ce backend.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-bind">
    <term>Bind (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('B')</term>
       <listitem>
        <para>
         Identifie le message comme une commande Bind.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Le nom du portail de destination
         (une chaîne vide sélectionne le portail non nommé).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Le nom de la requête préparée source
         (une chaîne vide sélectionne la requête préparée non nommée).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16</term>
       <listitem>
        <para>
         Le nombre de codes formats des paramètres
         (dénoté <replaceable>C</replaceable> ci-dessous).
         Il peut valoir zéro pour indiquer qu'il n'y a pas de paramètres ou
         que les paramètres peuvent tous utiliser le format par défaut
         (text)&nbsp;; ou un, auquel cas le code format spécifié est appliqué
         à tous les paramètres&nbsp;; ou il peut être égal au nombre réel
         de paramètres.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16[<replaceable>C</replaceable>]</term>
       <listitem>
        <para>
         Les codes format des paramètres. Il n'y a que deux valeurs
         possibles&nbsp;: zéro pour texte, un pour binaire.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16</term>
       <listitem>
        <para>
         Le nombre de valeurs de paramètres (potentiellement zéro).
         Ce nombre doit correspondre au nombre de paramètres nécessaires
         pour la requête.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Ensuite, la paire suivante de champs apparaît pour chaque paramètre&nbsp;:
     </para>

     <variablelist>
      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         La longueur de la valeur du paramètre en octets (ce nombre ne s'inclut
         pas). Peut valoir zéro. En cas particulier, -1 indique une valeur NULL
         du paramètre.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte<replaceable>n</replaceable></term>
       <listitem>
        <para>
         La valeur du paramètre, dans le format indiqué par le code format
         associé.
         <replaceable>n</replaceable> est la longueur ci-dessus.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Après le dernier paramètre, les champs suivants apparaissent&nbsp;:
     </para>

     <variablelist>
      <varlistentry>
       <term>Int16</term>
       <listitem>
        <para>
         Le nombre de codes formats des colonnes de résultat
         (dénoté par <replaceable>R</replaceable> ci-dessous).
         Ce nombre peut valoir zéro pour indiquer qu'il n'y a pas de colonnes
         de résultats ou que les colonnes de résultats devraient toutes utiliser
         le format par défaut (texte)&nbsp;; ou un, auquel cas le code format
         spécifié est appliqué à toutes les colonnes du résultat (s'il y en
         a)&nbsp;; ou il peut être égal au nombre réel de colonnes résultats
         de la requête.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16[<replaceable>R</replaceable>]</term>
       <listitem>
        <para>
         Les codes format des colonnes du résultat. Il n'existe que deux
         possibilités&nbsp;: zéro pour texte, un pour binaire.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-bindcomplete">
    <term>BindComplete (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('2')</term>
       <listitem>
        <para>
         Identifie le message comme un indicateur de fin de Bind.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(4)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-cancelrequest">
    <term>CancelRequest (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Int32(16)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(80877102)</term>
       <listitem>
        <para>
         Le code de demande d'annulation. La valeur est choisie pour contenir
         <literal>1234</literal> sur les 16 bits les plus significatifs, et
         <literal>5678</literal> sur les 16 bits les moins significatifs.
         (Pour éviter toute confusion, ce code ne doit pas être le même que tout
         numéro de version de protocole.)
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         L'identifiant de processus du backend cible.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         La clé secrète du backend cible.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-close">
    <term>Close (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('C')</term>
       <listitem>
        <para>
         Identifie le message comme une commande Close.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte1</term>
       <listitem>
        <para>
         '<literal>S</literal>' pour fermer une requête préparée&nbsp;; ou
         '<literal>P</literal>' pour fermer un portail.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Le nom de la requête préparée ou du portail à fermer (une chaîne vide
         sélectionne la requête préparée ou le portail non nommé).
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-closecomplete">
    <term>CloseComplete (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('3')</term>
       <listitem>
        <para>
         Identifie le message comme un indicateur de fin de Close.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(4)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-commandcomplete">
    <term>CommandComplete (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('C')</term>
       <listitem>
        <para>
         Identifie le message comme une réponse de fin de commande.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
       <para>
        La balise de la commande. C'est habituellement un mot simple qui
        identifie la commande SQL terminée.
       </para>

       <para>
        Pour une commande <command>INSERT</command>, la balise est
        <literal>INSERT <replaceable>oid</replaceable>
        <replaceable>lignes</replaceable></literal>, où
        <replaceable>lignes</replaceable> correspond au nombre de lignes
        insérées. <replaceable>oid</replaceable> était l'identifiant d'objet
        de la ligne insérée si <replaceable>lignes</replaceable> valait 1
        et que la table cible avait des OID, mais les colonnes systèmes OID
        ne sont plus supportées&nbsp;; de ce fait,
        <replaceable>oid</replaceable> est toujours à 0.
       </para>

       <para>
        Pour une commande <command>DELETE</command>, la balise est
        <literal>DELETE <replaceable>lignes</replaceable></literal> où
        <replaceable>lignes</replaceable> correspond au nombre de lignes
        supprimées.
       </para>

       <para>
        Pour une commande <command>UPDATE</command>, la balise est
        <literal>UPDATE <replaceable>lignes</replaceable></literal> où
        <replaceable>lignes</replaceable> correspond au nombre de lignes mises
        à jour.
       </para>

       <para>
        Pour une commande <command>MERGE</command>, la balise est
        <literal>MERGE <replaceable>lignes</replaceable></literal> où
        <replaceable>lignes</replaceable> correspond au nombre de lignes insérées,
        mises à jour ou supprimées.
       </para>

       <para>
        Pour une commande <command>SELECT</command> ou <command>CREATE TABLE
        AS</command>, la balise est <literal>SELECT <replaceable>lignes</replaceable></literal>
        où <replaceable>lignes</replaceable> correspond au nombre de lignes
        récupérées.
       </para>

       <para>
        Pour une commande <command>MOVE</command>, la balise est
        <literal>MOVE <replaceable>lignes</replaceable></literal> où
        <replaceable>lignes</replaceable> correspond au nombre de lignes de
        déplacement du curseur.
       </para>

       <para>
        Pour une commande <command>FETCH</command>, la balise est
        <literal>FETCH <replaceable>lignes</replaceable></literal> où
        <replaceable>lignes</replaceable> est le nombre de lignes qui ont été
        récupérées du curseur.
       </para>

       <para>
        Pour une commande <command>COPY</command>, la balise est
        <literal>COPY <replaceable>lignes</replaceable></literal> où
        <replaceable>lignes</replaceable> est le nombre de lignes copiées.
        (Note&nbsp;: le nombre de lignes apparaît seulement dans
        <productname>PostgreSQL</productname> 8.2 et les versions ultérieures.)
       </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-copydata">
    <term>CopyData (F &amp; B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('d')</term>
       <listitem>
        <para>
         Identifie le message comme des données <command>COPY</command>.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte<replaceable>n</replaceable></term>
       <listitem>
        <para>
         Données qui forment une partie d'un flux de données
         <command>COPY</command>. Les messages envoyés à partir du backend
         correspondront toujours à des lignes de données simples, mais les
         messages envoyés par les clients pourraient diviser le flux de
         données de façon arbitraire.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-copydone">
    <term>CopyDone (F &amp; B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('c')</term>
       <listitem>
        <para>
         Identifie le message comme un indicateur de fin de
         <command>COPY</command>.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(4)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-copyfail">
    <term>CopyFail (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('f')</term>
       <listitem>
        <para>
         Identifie le message comme un indicateur d'échec de
         <command>COPY</command>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Un message d'erreur à rapporter comme cause de l'échec.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-copyinresponse">
    <term>CopyInResponse (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('G')</term>
       <listitem>
        <para>
         Identifie le message comme une réponse Start Copy In. Le client doit
         maintenant envoyer des données <literal>copy-in</literal> (s'il n'est
         pas préparé à le faire, il envoie un message CopyFail).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int8</term>
       <listitem>
        <para>
         0 indique que le format global de <command>COPY</command> est du
         texte (lignes séparées par des retours à la ligne, colonnes séparées
         par des caractères séparateurs, etc.).
         1 indique que le format global de copie est binaire (similaire au
         format DataRow).
         Voir <xref linkend="sql-copy"/> pour plus d'informations.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16</term>
       <listitem>
        <para>
         Le nombre de colonnes dans les données à copier
         (dénoté <replaceable>N</replaceable> ci-dessous).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16[<replaceable>N</replaceable>]</term>
       <listitem>
        <para>
         Les codes format à utiliser pour chaque colonne. Il n'y a que deux
         possibilités&nbsp;: zéro pour texte, un pour binaire. Tous doivent
         être à zéro pour que le format de copie global soit du texte.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-copyoutresponse">
    <term>CopyOutResponse (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('H')</term>
       <listitem>
        <para>
         Identifie le message comme une réponse Start Copy Out.
         Ce message sera suivi par les données <literal>copy-out</literal>.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int8</term>
       <listitem>
        <para>
         0 indique que le format global de <command>COPY</command> est du texte
         (lignes séparées par des retours à la ligne, colonnes séparées par
         des caractères séparateurs, etc.). 1 indique que le format global de
         copie est binaire (similaire au format DataRow). Voir
         <xref linkend="sql-copy"/> pour plus d'informations.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16</term>
       <listitem>
        <para>
         Le nombre de colonnes des données à copier
         (dénoté <replaceable>N</replaceable> ci-dessous).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16[<replaceable>N</replaceable>]</term>
       <listitem>
        <para>
         Les codes format à utiliser pour chaque colonne. Il n'y a que deux
         possibilités&nbsp;: zéro pour texte, un pour binaire. Ils doivent
         être tous à zéro pour que le format global de copie soit du texte.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-copybothresponse">
    <term>CopyBothResponse (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('W')</term>
       <listitem>
        <para>
         Identifie le message comme une réponse Start Copy Both.
         Ce message est utilisé uniquement pour la réplication en flux.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int8</term>
       <listitem>
        <para>
         0 indique que le format global de <command>COPY</command> est du texte
         (lignes séparées par des retours à la ligne, colonnes séparées par
         des caractères séparateurs, etc.). 1 indique que le format global de
         copie est binaire (similaire au format DataRow). Voir
         <xref linkend="sql-copy"/> pour plus d'informations.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16</term>
       <listitem>
        <para>
         Le nombre de colonnes dans les données à copier
         (dénoté <replaceable>N</replaceable> ci-dessous).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16[<replaceable>N</replaceable>]</term>
       <listitem>
        <para>
         Les codes format à utiliser pour chaque colonne. Il n'y a que deux
         possibilités&nbsp;: zéro pour texte, un pour binaire. Ils doivent
         être tous à zéro pour que le format global de copie soit du texte.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-datarow">
    <term>DataRow (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('D')</term>
       <listitem>
        <para>
         Identifie le message comme une ligne de données.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16</term>
       <listitem>
        <para>
         Le nombre de valeurs de colonnes (potentiellement zéro).
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Ensuite, la paire de champs suivants apparaît pour chaque colonne&nbsp;:
     </para>

     <variablelist>
      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         La longueur de la valeur de la colonne, en octets (ce décompte ne
         s'inclue pas lui-même). Peut valoir zéro. Cas particulier, -1 indique
         une valeur de colonne NULL.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte<replaceable>n</replaceable></term>
       <listitem>
        <para>
         La valeur de la colonne, dans le format indiqué par le code format
         associé. <replaceable>n</replaceable> est la longueur ci-dessus.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-describe">
    <term>Describe (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('D')</term>
       <listitem>
        <para>
         Identifie le message comme une commande Describe.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte1</term>
       <listitem>
        <para>
         '<literal>S</literal>' pour décrire une requête préparée&nbsp;; ou
         '<literal>P</literal>' pour décrire un portail.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Le nom de la requête préparée ou du portail à décrire (une chaîne vide
         sélectionne la requête préparée ou le portail non nommé).
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-emptyqueryresponse">
    <term>EmptyQueryResponse (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('I')</term>
       <listitem>
        <para>
         Identifie le message comme une réponse à une chaîne vide de requête.
         (Cela se substitue à CommandComplete.)
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(4)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-errorresponse">
    <term>ErrorResponse (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('E')</term>
       <listitem>
        <para>
         Identifie le message comme une erreur.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Le corps du message consiste en un ou plusieurs champs identifiés, suivi
      par un octet zéro comme terminaison. Les champs peuvent apparaître dans
      n'importe quel ordre. Pour chaque champ, il existe ce qui suit&nbsp;:
     </para>

     <variablelist>
      <varlistentry>
       <term>Byte1</term>
       <listitem>
        <para>
         Un code identifiant le type de champ&nbsp;; si zéro, c'est le message
         de terminaison, et aucune chaîne ne suit. Les types de champs
         actuellement définis sont listés dans <xref
         linkend="protocol-error-fields"/>. Comme plus de types de champs
         pourraient être ajoutés dans le futur, les clients devraient ignorer
         silencieusement les champs dont le type n'est pas reconnu.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         La valeur du champ.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-execute">
    <term>Execute (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('E')</term>
       <listitem>
        <para>
         Identifie le message comme une commande Execute.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Le nom du portail à exécuter (une chaîne vide sélectionne le portail
         non nommé).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Nombre maximum de lignes à renvoyer si le portail contient une requête
         qui renvoie des lignes (ignoré sinon). Zéro indique <quote>pas de
         limite</quote>.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-flush">
    <term>Flush (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('H')</term>
       <listitem>
        <para>
         Identifie le message comme une commande Flush.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(4)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-functioncall">
    <term>FunctionCall (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('F')</term>
       <listitem>
        <para>
         Identifie le message comme un appel de fonction.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Indique l'identifiant d'objet de la fonction à appeler.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16</term>
       <listitem>
        <para>
         Le nombre de codes formats des arguments
         (dénoté <replaceable>C</replaceable> ci-dessous).
         Ce nombre peut valoir zéro pour indiquer qu'il n'y a pas d'arguments
         ou que tous les arguments utilisent le format par défaut (texte)&nbsp;;
         ou un, auquel cas le code format spécifié est appliqué à tous les
         arguments&nbsp;; ou être égal au nombre réel d'arguments.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16[<replaceable>C</replaceable>]</term>
       <listitem>
        <para>
         Les codes formats des arguments. Il n'existe que deux
         possibilités&nbsp;: zéro pour texte, un pour binaire.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16</term>
       <listitem>
        <para>
         Indique le nombre d'arguments à fournir à la fonction.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Ensuite, la paire suivant de champs apparaît pour chaque argument&nbsp;:
     </para>

     <variablelist>
      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         La longueur de la valeur de l'argument, en octets (ce décompte ne
         s'inclue pas lui-même). Peut valoir zéro. Cas particulier, -1 indique
         une valeur de colonne NULL.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte<replaceable>n</replaceable></term>
       <listitem>
        <para>
         La valeur de l'argument, dans le format indiqué par le code format
         associé.
         <replaceable>n</replaceable> est la longueur ci-dessus.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Après le dernier argument, le champ suivant apparaît&nbsp;:
     </para>

     <variablelist>
      <varlistentry>
       <term>Int16</term>
       <listitem>
        <para>
         Le code format pour le résultat de la fonction. Il n'existe que deux
         possibilités&nbsp;: 0 pour texte, 1 pour binaire.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-functioncallresponse">
    <term>FunctionCallResponse (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('V')</term>
       <listitem>
        <para>
         Identifie le message comme un résultat d'appel de fonction.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         La longueur du résultat de la fonction, en octets (ce décompte ne
         s'inclue pas lui-même). Peut valoir zéro. Cas particulier, -1 indique
         une valeur de colonne NULL.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte<replaceable>n</replaceable></term>
       <listitem>
        <para>
         La valeur du résultat de la fonction, dans le format indiqué par le
         code format associé.
         <replaceable>n</replaceable> est la longueur ci-dessus.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-gssencrequest">
    <term>GSSENCRequest (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Int32(8)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(80877104)</term>
       <listitem>
        <para>
         Le code de demande de chiffrement <acronym>GSSAPI</acronym>. La valeur
         est choisie pour contenir <literal>1234</literal> sur les 16 bits les
         plus significatifs, et <literal>5680</literal> sur les 16 bits les
         moins significatifs.  (Pour éviter toute confusion, ce code ne doit pas
         être le même que le numéro de version du protocole.)
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-gssresponse">
    <term>GSSResponse (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('p')</term>
       <listitem>
        <para>
         Identifie le message comme une réponse GSSAPI ou SSPI. Notez que ceci
         est aussi utilisé pour les messages de réponse SASL et mot de passe.
         Le type exact du message peut être déduit du contexte.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte<replaceable>n</replaceable></term>
       <listitem>
        <para>
         Données spécifiques du message GSSAPI/SSPI.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-negotiateprotocolversion">
    <term>NegotiateProtocolVersion (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('v')</term>
       <listitem>
        <para>
         Identifie le message comme un message de négociation de version
         du protocole.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Version mineure la plus récente supportée par le serveur pour la
         version majeure réclamée par le client.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Nombre d'options du protocole non reconnues par le serveur.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Puis, pour l'option de protocole non reconnue par le serveur, il y a ce
      qui suit&nbsp;:
     </para>

     <variablelist>
      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Le nom de l'option.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-nodata">
    <term>NoData (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('n')</term>
       <listitem>
        <para>
         Identifie le message comme un indicateur d'absence de données.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(4)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-noticeresponse">
    <term>NoticeResponse (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('N')</term>
       <listitem>
        <para>
         Identifie le message comme une information.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Le corps du message consiste en un ou plusieurs champs identifiés, suivi
      par un octet zéro comme terminaison. Les champs peuvent apparaître dans
      n'importe quel ordre. Pour chaque champ, il existe ce qui suit&nbsp;:
     </para>

     <variablelist>
      <varlistentry>
       <term>Byte1</term>
       <listitem>
        <para>
         Un code identifiant le type de champs&nbsp;; si zéro, ceci est le
         message de terminaison et aucune chaîne de caractères ne suit. Les
         types de champs actuellement définis sont listés dans
         <xref linkend="protocol-error-fields"/>.
         Comme plus de types de champs pourraient être ajoutés dans le futur,
         les clients devraient ignorer silencieusement les champs dont le type
         leur est inconnu.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         La valeur du champ.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-notificationresponse">
    <term>NotificationResponse (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('A')</term>
       <listitem>
        <para>
         Identifie le message comme une réponse à une notification.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         L'identifiant du processus backend notifiant.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Le nom du canal où la notification a été levée.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         La <quote>charge</quote> passée par le processus notifiant.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-parameterdescription">
    <term>ParameterDescription (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('t')</term>
       <listitem>
        <para>
         Identifie le message comme une description de paramètre.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16</term>
       <listitem>
        <para>
         Le nombre de paramètres utilisés par la requête (peut valoir zéro).
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Ensuite, pour chaque paramètre, il y a ce qui suit&nbsp;:
     </para>

     <variablelist>
      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Indique l'identifiant d'objet du type de données du paramètre.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-parameterstatus">
    <term>ParameterStatus (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('S')</term>
       <listitem>
        <para>
         Identifie le message comme un rapport de statut d'un paramètre.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Le nom du paramètre.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         La valeur actuelle de ce paramètre.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-parse">
    <term>Parse (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('P')</term>
       <listitem>
        <para>
         Identifie le message comme une commande Parse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Le nom de la requête préparée de destination (une chaîne vide
         sélectionne la requête préparée non nommée).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         La chaîne de requête à analyser.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16</term>
       <listitem>
        <para>
         Le nombre de types de données des paramètres (peut valoir zéro).
         Notez que cela n'est pas une indication du nombre de paramètres qui
         pourraient apparaître dans la requête de chaîne, seulement le nombre
         de types que le client souhaite pré-déclarer.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Ensuite, pour chaque paramètre, il y a ce qui suit&nbsp;:
     </para>

     <variablelist>
      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Indique l'identifiant d'objet du type de données du paramètre. Placer
         un zéro ici est équivalent à laisser le type sans spécification.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-parsecomplete">
    <term>ParseComplete (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('1')</term>
       <listitem>
        <para>
         Identifie le message comme un indicateur de fin de Parse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(4)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-passwordmessage">
    <term>PasswordMessage (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('p')</term>
       <listitem>
        <para>
         Identifie le message comme une réponse de mot de passe. Notez que c'est
         aussi utilisé pour les messages de réponse pour GSSAPI, SSPI et SASL.
         Le type exact de message peut être déduit du contexte.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Le mot de passe (chiffré si demandé).
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-portalsuspended">
    <term>PortalSuspended (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('s')</term>
       <listitem>
        <para>
         Identifie le message comme un indicateur de portal-suspended.
         Notez que ceci survient uniquement si la limite de lignes a été atteint
         pour un message Execute.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(4)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-query">
    <term>Query (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('Q')</term>
       <listitem>
        <para>
         Identifie le message comme une simple requête.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         La requête elle-même.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-readyforquery">
    <term>ReadyForQuery (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('Z')</term>
       <listitem>
        <para>
         Identifie le type de message. ReadyForQuery est envoyé quand le
         backend est prêt pour un nouveau cycle de requête.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(5)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte1</term>
       <listitem>
        <para>
         Indicateur du statut de transaction du backend.  Les valeurs possibles
         sont '<literal>I</literal>' si inactif (et pas dans un bloc de
         transaction)&nbsp;; '<literal>T</literal>' si dans un bloc de
         transaction&nbsp;; ou '<literal>E</literal>' si dans un bloc de
         transaction en échec (les requêtes seront rejetées jusqu'à la fin du
         bloc).
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-rowdescription">
    <term>RowDescription (B)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('T')</term>
       <listitem>
        <para>
         Identifie le message comme une description de ligne.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16</term>
       <listitem>
        <para>
         Indique le nombre de champs dans une ligne (peut valoir zéro).
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Ensuite, pour chaque champ, il y a ce qui suit&nbsp;:
     </para>

     <variablelist>
      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Le nom du champ.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Si le champ peut être identifié comme une colonne d'une table précise,
         l'identifiant d'objet de la table&nbsp;; sinon zéro.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16</term>
       <listitem>
        <para>
         Si le champ peut être identifié comme une colonne d'une table précise,
         le numéro de la colonne&nbsp;; sinon zéro.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         L'identifiant d'objet du type de données du champ.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16</term>
       <listitem>
        <para>
         La taille du type de données (voir <varname>pg_type.typlen</varname>).
         Notez que les valeurs négatives désignent des types à taille variable.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Le modifieur du type (voir <varname>pg_attribute.atttypmod</varname>).
         La signification du modifieur dépend du type.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16</term>
       <listitem>
        <para>
         Le code format en cours d'utilisation pour le champ. Actuellement, ce
         sera soit zéro (texte) soit un (binaire). Dans un RowDescription
         renvoyé à partir de la variante requête de Describe, le code format
         n'est pas encore connu et sera toujours zéro.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-saslinitialresponse">
    <term>SASLInitialResponse (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('p')</term>
       <listitem>
        <para>
         Identifie le message comme une réponse SASL initiale. Notez que ce
         message est aussi utilisé pour les messages de réponse de GSSAPI, SSPI
         et mot de passe. Le type exact de message est déduit du contexte.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Nom du mécanisme d'authentification SASL que le client a sélectionné.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du "Initial Client Response" spécifique au mécanisme SASL,
         ou -1 en cas d'absence de <literal>Initial Response</literal>.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte<replaceable>n</replaceable></term>
       <listitem>
        <para>
         "Initial Response" spécifique au mécanisme SASL.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-saslresponse">
    <term>SASLResponse (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('p')</term>
       <listitem>
        <para>
         Identifie le message comme une réponse SASL. Notez que ce message est
         aussi utilisé par les messages réponses de GSSAPI, SSPI et mot de
         passe. Le type exact de message peut être déduit du contexte.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte<replaceable>n</replaceable></term>
       <listitem>
        <para>
         Données du message spécifique au mécanisme SASL.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-sslrequest">
    <term>SSLRequest (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Int32(8)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(80877103)</term>
       <listitem>
        <para>
         Le code de demande de chiffrement <acronym>SSL</acronym>. La valeur
         est choisie pour contenir <literal>1234</literal> sur les 16 bits les
         plus significatifs, et <literal>5679</literal> sur les 16 bits les
         moins significatifs. (Pour éviter toute confusion, ce code ne doit pas
         être le même que le numéro de version du protocole.)
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-startupmessage">
    <term>StartupMessage (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(196608)</term>
       <listitem>
        <para>
         Le numéro de version du protocole. Les 16 bits les plus significatifs
         sont le numéro de version majeure (3 pour le protocole décrit ici).
         Les 16 bits les moins significatifs sont le numéro de version mineure
         (0 pour le protocole décrit ici).
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Le numéro de version du protocole est suivi par une ou plusieurs paires de
      nom/valeur de paramètre. Un octet zéro est requis comme terminaison après
      la dernière paire nom/valeur. Les paramètres peuvent apparaître dans
      n'importe quel ordre.  <literal>user</literal> est requis, les autres sont
      optionnels. Chaque paramètre est spécifié ainsi&nbsp;:
     </para>

     <variablelist>
      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Le nom du paramètre. Actuellement, les noms reconnus sont&nbsp;:

         <variablelist>
          <varlistentry>
           <term><literal>user</literal></term>
           <listitem>
            <para>
             Le nom de l'utilisateur pour la connexion à la base. Requis, pas
             de valeur par défaut.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term><literal>database</literal></term>
           <listitem>
            <para>
             La base de données où se connecter. Par défaut, le nom de
             l'utilisateur.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term><literal>options</literal></term>
           <listitem>
            <para>
             Arguments de la ligne de commande pour le backend. (C'est abandonné
             au profit de la configuration de paramètres individuels.) Les
             espaces dans cette chaîne permettent de séparer les arguments,
             à moins qu'ils ne soient échappés avec un caractère antislash
             (<literal>\</literal>)&nbsp;; écrire <literal>\\</literal> pour
             représenter un antislash litéral.
            </para>
           </listitem>
          </varlistentry>

          <varlistentry>
           <term><literal>replication</literal></term>
           <listitem>
            <para>
             Utilisé pour se connecter en mode de réplication en flux, où un petit
             ensemble de commandes de réplication peuvent être exécutées au lieu
             de requêtes SQL. Les valeurs peuvent être <literal>true</literal>,
             <literal>false</literal> ou <literal>database</literal>, et la
             valeur par défaut est <literal>false</literal>. Voir <xref
             linkend="protocol-replication"/> pour plus de détails.
            </para>
           </listitem>
          </varlistentry>
         </variablelist>

         En plus de tout cela, d'autres paramètres pourraient être listés. Les
         noms de paramètre commençant avec <literal>_pq_.</literal> sont
         réservés pour une utilisation en tant qu'extensions du protocole,
         alors que les autres sont traités comme des paramètres d'exécution
         à configurer au démarrage du backend. De telles configurations seront
         appliquées au démarrage du serveur (après analyse des arguments en
         ligne de commande s'il y en a) et agiront comme valeurs par défaut
         de la session.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         La valeur du paramètre.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-sync">
    <term>Sync (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('S')</term>
       <listitem>
        <para>
         Identifie le message comme une commande Sync.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(4)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-message-formats-terminate">
    <term>Terminate (F)</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('X')</term>
       <listitem>
        <para>
         Identifie le message comme une fin de session.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32(4)</term>
       <listitem>
        <para>
         Longueur du contenu du message en octets, longueur incluse.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>

 <sect1 id="protocol-error-fields">
  <title>Champs des messages d'erreur et de notification</title>

  <para>
   Cette section décrit les champs qui peuvent apparaître dans des messages
   ErrorResponse et NoticeResponse. Chaque type de champ a un jeton
   d'identification sur un seul octet. Notez que tout type de champ devrait
   apparaître au moins une fois par message.
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>S</literal></term>
    <listitem>
     <para>
      Sévérité&nbsp;: le contenu du champ est <literal>ERROR</literal>,
      <literal>FATAL</literal>, ou <literal>PANIC</literal> (dans un message
      d'erreur), ou <literal>WARNING</literal>, <literal>NOTICE</literal>,
      <literal>DEBUG</literal>, <literal>INFO</literal> ou
      <literal>LOG</literal> (dans un message de notification), ou une
      traduction localisée d'un de ces messages. Toujours présent.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>V</literal></term>
    <listitem>
     <para>
      Sévérité&nbsp;: le contenu du champ est <literal>ERROR</literal>,
      <literal>FATAL</literal>, ou <literal>PANIC</literal> (dans un message
      d'erreur), ou <literal>WARNING</literal>, <literal>NOTICE</literal>,
      <literal>DEBUG</literal>, <literal>INFO</literal>, ou
      <literal>LOG</literal> (dans un message de notification). Ceci est
      identique au champ <literal>S</literal> sauf que son contenu n'est jamais
      localisé. Il est présent uniquement dans les messages générés par un
      serveur <productname>PostgreSQL</productname> en version 9.6 ou
      ultérieure.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>C</literal></term>
    <listitem>
     <para>
      Code&nbsp;: le code SQLSTATE pour l'erreur (voir <xref
      linkend="errcodes-appendix"/>). Non localisable. Toujours présent.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>M</literal></term>
    <listitem>
     <para>
      Message&nbsp;: le message d'erreur principal, lisible par un humain. Il
      doit être précis mais court (typiquement une ligne). Toujours présent.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>D</literal></term>
    <listitem>
     <para>
      Détail&nbsp;: un message d'erreur secondaire et optionnel apportant plus
      d'informations sur le problème. Pourrait utiliser plusieurs lignes.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>H</literal></term>
    <listitem>
     <para>
      Astuce&nbsp;: une suggestion optionnelle pour corriger le problème.  Ceci
      doit différer du Détail parce qu'il offre un conseil (potentiellement
      inapproprié) plutôt que des faits certains. Pourrait utiliser plusieurs
      lignes.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>P</literal></term>
    <listitem>
     <para>
      Position&nbsp;: la valeur du champ est un entier décimal ASCII, indiquant
      la position du curseur sur l'erreur comme un index sur la chaîne requête
      originale. Le premier caractère est à l'index 1, et les positions sont
      mesurées en caractères, et non pas en octets.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>p</literal></term>
    <listitem>
     <para>
      Position interne&nbsp;: ceci est défini de la même façon que le champ
      <literal>P</literal>, mais est utilisé quand la position du curseur fait
      référence à une commande générée en interne plutôt qu'une commande
      exécutée par le client. Le champ <literal>q</literal> apparaîtra toujours
      quand ce champ apparaît.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>q</literal></term>
    <listitem>
     <para>
      Requête interne&nbsp;: le texte d'une commande générée en interne. Cela
      pourrait être une requête SQL exécutée par une fonction PL/pgSQL par
      exemple.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>W</literal></term>
    <listitem>
     <para>
      Où&nbsp;: une indication du contexte dans lequel l'erreur s'est produite.
      Actuellement, cela inclut la pile d'appels des fonctions en langage
      procédural et les requêtes générées en interne. La trace est composée
      d'une entrée par ligne, la plus récente en premier.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>s</literal></term>
    <listitem>
     <para>
      Nom du schéma&nbsp;: si l'erreur était associée à un objet particulier
      de la base, le nom du schéma contenant cet objet, s'il existe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>t</literal></term>
    <listitem>
     <para>
      Nom de la table&nbsp;: si l'erreur était associée à une table
      particulière, le nom de la table. (Référez-vous au champ du nom de
      schéma pour le nom du schéma de la table.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>c</literal></term>
    <listitem>
     <para>
      Nom de la colonne&nbsp;: si l'erreur était associée à une colonne
      particulière de la table, le nom de la colonne. (Référez-vous aux champs
      de nom de schéma et de table pour identifier la table.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>d</literal></term>
    <listitem>
     <para>
      Nom du type de données&nbsp;: si l'erreur était associée à un type
      de données particulier, le nom du type de données. (Référez-vous au champ
      du nom de schéma pour le nom du schéma du type de données.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>n</literal></term>
    <listitem>
     <para>
      Nom de contrainte&nbsp;: si l'erreur était associée à une contrainte
      particulière, le nom de la contrainte. Référez-vous aux champs listés
      ci-dessus pour la table ou le domaine associé. (Dans ce but, les index
      sont traités comme des contraintes, même si elles n'ont pas été créées
      avec une syntaxe de contrainte.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>F</literal></term>
    <listitem>
     <para>
      Fichier&nbsp;: le nom du fichier source où l'erreur a été rapportée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>L</literal></term>
    <listitem>
     <para>
      Ligne&nbsp;: le numéro de ligne dans le fichier source où l'erreur a été
      rapportée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>R</literal></term>
    <listitem>
     <para>
      Routine&nbsp;: le nom de la routine ayant rapporté l'erreur.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <note>
   <para>
    Les champs du nom du schéma, de la table, de la colonne, du type de données
    et de la contrainte sont fournis seulement pour un nombre limité de types
    d'erreur&nbsp;; voir <xref linkend="errcodes-appendix"/>. Les clients ne
    doivent pas supposer que la présence d'un de ces champs garantie la présence
    d'un autre champ. Les sources des erreurs observent les relations notées
    ci-dessus, mais les fonctions définies par les utilisateurs pourraient
    utiliser ces champs d'une autre façon. Dans la même veine, les clients ne
    devraient pas supposer que ces champs parlent d'objets actuels dans la base
    actuelle.
   </para>
  </note>

  <para>
   Le client est responsable du formatage des informations affichées&nbsp;;
   en particulier, il doit diviser les lignes longues si nécessaires. Les
   caractères de retour chariot apparaissant dans les champs du message d'erreur
   doivent être traités comme des changements de paragraphes, pas comme des
   changements de lignes.
  </para>
 </sect1>

 <sect1 id="protocol-logicalrep-message-formats">
  <title>Formats des messages de la réplication logique</title>

  <para>
   Cette section décrit le format détaillé de chaque message de réplication
   logique. Ces messages sont renvoyés soit par l'interface SQL du slot de
   réplication soit par un walsender. Dans ce dernier cas, ils sont encapsulés à
   l'intérieur de messages WAL du protocole de réplication, comme décrit dans
   <xref linkend="protocol-replication"/>, et obéissent généralement au même
   flux de message que la réplication physique.
  </para>

  <variablelist>
   <varlistentry id="protocol-logicalrep-message-formats-begin">
    <term>Begin</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('B')</term>
       <listitem>
        <para>
         Identifie le message comme un message begin.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (XLogRecPtr)</term>
       <listitem>
        <para>
         Le LSN final de la transaction.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (TimestampTz)</term>
       <listitem>
        <para>
         Horodatage de la validation de la transaction. La valeur est un nombre
         de microsecondes depuis l'epoch PostgreSQL (1er janvier 2000).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (TransactionId)</term>
       <listitem>
        <para>
         Xid de la transaction.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-logicalrep-message-formats-message">
    <term>Message</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('M')</term>
       <listitem>
        <para>
         Identifie le message comme un message de décodage logique.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (TransactionId)</term>
       <listitem>
        <para>
         Xid de la transaction (seulement présent pour les transactions en
         flux). Ce champ est disponible depuis la version 2 du protocole.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int8</term>
       <listitem>
        <para>
         Drapeaux&nbsp;; soit 0 pour aucun drapeau, ou 1 si le message de
         décodage logique est transactionnel.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (XLogRecPtr)</term>
       <listitem>
        <para>
         Le LSN du message de décodage logique.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Le préfixe du message de décodage logique.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Longueur du contenu.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte<replaceable>n</replaceable></term>
       <listitem>
        <para>
         Le contenu du message de décodage logique.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-logicalrep-message-formats-commit">
    <term>Commit</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('C')</term>
       <listitem>
        <para>
         Identifie le message comme un message de Commit.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int8(0)</term>
       <listitem>
        <para>
         Drapeaux&nbsp;; actuellement inutilisé.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (XLogRecPtr)</term>
       <listitem>
        <para>
         Le LSN du commit.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (XLogRecPtr)</term>
       <listitem>
        <para>
         Le LSN de fin de la transaction.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (TimestampTz)</term>
       <listitem>
        <para>
         Horodatage de la validation de la transaction. La valeur est en nombre
         de microsecondes depuis l'epoch PostgreSQL (1er janvier 2000).
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-logicalrep-message-formats-origin">
    <term>Origin</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('O')</term>
       <listitem>
        <para>
         Identifie le message comme un message Origin.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (XLogRecPtr)</term>
       <listitem>
        <para>
         Le LSN de la validation sur le serveur d'origine.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Nom de l'origine.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Notez qu'il peut y avoir plusieurs messages Origin dans une même
      transaction.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-logicalrep-message-formats-relation">
    <term>Relation</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('R')</term>
       <listitem>
        <para>
         Identifie le message comme un message Relation.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (TransactionId)</term>
       <listitem>
        <para>
         XID de la transaction (seulement présent pour les transactions en
         flux). Ce champ est disponible à partir de la version 2 du protocole.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (Oid)</term>
       <listitem>
        <para>
         OID de la relation.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Schéma (chaîne vide pour <literal>pg_catalog</literal>).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Nom de la relation.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int8</term>
       <listitem>
        <para>
         Configuration de l'identité de réplication pour la relation (identique
         à <structfield>relreplident</structfield> dans
         <structname>pg_class</structname>).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int16</term>
       <listitem>
        <para>
         Nombre de colonnes.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Ensuite, la partie suivante du message apparaît pour chaque colonne inclus
      dans la publication, à l'exception des colonnes générées&nbsp;:
     </para>

     <variablelist>
      <varlistentry>
       <term>Int8</term>
       <listitem>
        <para>
         Drapeaux pour la colonne. Actuellement, peut valoir soit 0 pour aucun
         drapeau ou 1 pour marquer la colonne comme faisant partie de la clé.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Nom de la colonne.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (Oid)</term>
       <listitem>
        <para>
         OID du type de données de la colonne.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Modifieur de type de la colonne (<structfield>atttypmod</structfield>).
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-logicalrep-message-formats-type">
    <term>Type</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('Y')</term>
       <listitem>
        <para>
         Identifie le message comme un message Type.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (TransactionId)</term>
       <listitem>
        <para>
         XID de la transaction (seulement présent pour les transactions en flux).
         Ce champ est disponible depuis la version 2 du protocole.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (Oid)</term>
       <listitem>
        <para>
         OID du type de données.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Schéma (chaîne vide pour <literal>pg_catalog</literal>).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Nom du type de données.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-logicalrep-message-formats-insert">
    <term>Insert</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('I')</term>
       <listitem>
        <para>
         Identifie le message comme un message Insert.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (TransactionId)</term>
       <listitem>
        <para>
         XID de la transaction (seulement présent pour les transactions en flux).
         Ce champ est disponible depuis la version 2 du protocole.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (Oid)</term>
       <listitem>
        <para>
         OID de la relation correspondant à l'identifiant du message Relation
         message.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte1('N')</term>
       <listitem>
        <para>
         Identifie le message TupleData suivant comme une nouvelle ligne.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>TupleData</term>
       <listitem>
        <para>
         Message TupleData représentant le contenu de la nouvelle ligne.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-logicalrep-message-formats-update">
    <term>Update</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('U')</term>
       <listitem>
        <para>
         Identifie le message comme un message Update.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (TransactionId)</term>
       <listitem>
        <para>
         XID de la transaction (seulement présent pour les transactions en flux).
         Ce champ est disponible depuis la version 2 du protocole.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (Oid)</term>
       <listitem>
        <para>
         OID de la relation correspondant à l'identifiant du message Relation
         message.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte1('K')</term>
       <listitem>
        <para>
         Identifie les sous-messages TupleData suivants comme une clé. Ce champ
         est optionnel et est présent uniquement si la mise à jour a modifié des
         données dans une des colonnes qui font partie de l'index REPLICA
         IDENTITY.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte1('O')</term>
       <listitem>
        <para>
         Identifie les sous-messages TupleData suivants comme une ancienne
         ligne. Ce champ est optionnel et est présent uniquement si la table
         ciblée par la mise à jour a REPLICA IDENTITY configuré à FULL.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>TupleData</term>
       <listitem>
        <para>
         Message TupleData représentant le contenu de l'ancienne ligne ou la clé
         primaire. Seulement présent si la partie 'O' ou 'K' précédente est
         présente.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte1('N')</term>
       <listitem>
        <para>
         Identifie le message TupleData suivant comme la nouvelle ligne.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>TupleData</term>
       <listitem>
        <para>
         Message TupleData représentant le contenu de la nouvelle ligne.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Le message Update peut contenir soit une partie d'un message 'K' soit
      une partie d'un message 'O', mais jamais les deux.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-logicalrep-message-formats-delete">
    <term>Delete</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('D')</term>
       <listitem>
        <para>
         Identifie le message comme un message Delete.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (TransactionId)</term>
       <listitem>
        <para>
         XID de la transaction (seulement présent pour les transactions en flux).
         Ce champ est disponible depuis la version 2 du protocole.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (Oid)</term>
       <listitem>
        <para>
         OID de la relation correspondant ç l'identifiant du message Relation
         message.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte1('K')</term>
       <listitem>
        <para>
         Identifie le sous-message TupleData suivant comme une clé. Ce champ
         est présent si la table ciblée par la suppression utilise un index
         comme REPLICA IDENTITY.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Byte1('O')</term>
       <listitem>
        <para>
         Identifie le message TupleData suivant comme une ancienne ligne. Ce
         champ est présent si la table ciblée par la suppression a le
         REPLICA IDENTITY configuré à FULL.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>TupleData</term>
       <listitem>
        <para>
         Message TupleData représentant le contenu de l'ancienne ligne ou clé
         primaire, suivant le champ précédent.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Le message Delete pourrait contenir soit une partie d'un message 'K' soit
      une partie d'un message 'O', mais jamais les deux.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-logicalrep-message-formats-truncate">
    <term>Truncate</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('T')</term>
       <listitem>
        <para>
         Identifie le message comme un message Truncate.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (TransactionId)</term>
       <listitem>
        <para>
         XID de la transaction (seulement présent pour les transactions en flux).
         Ce champ est disponible depuis la version 2 du protocole.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32</term>
       <listitem>
        <para>
         Nombre de relations.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int8</term>
       <listitem>
        <para>
         Options pour <command>TRUNCATE</command>&nbsp;:
         1 pour <literal>CASCADE</literal>, 2 pour <literal>RESTART
         IDENTITY</literal>
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (Oid)</term>
       <listitem>
        <para>
         OID de la relation correspondant à l'identifiant du message Relation.
         Ce champ est répété pour chaque relation.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Les messages suivants (Stream Start, Stream Stop, Stream Commit et
   Stream Abort) sont disponibles depuis la version 2 du protocole.
  </para>

  <variablelist>
   <varlistentry id="protocol-logicalrep-message-formats-stream-start">
    <term>Stream Start</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('S')</term>
       <listitem>
        <para>
         Identifie le message comme un message de début de flux.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (TransactionId)</term>
       <listitem>
        <para>
         Xid de la transaction.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int8</term>
       <listitem>
        <para>
         Une valeur de 1 indique qu'il s'agit du premier segment pour cet XID,
         et une valeur de 0 pour tout autre segment de flux.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-logicalrep-message-formats-stream-stop">
    <term>Stream Stop</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('E')</term>
       <listitem>
        <para>
         Identifie le message comme un message d'arrêt de flux.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-logicalrep-message-formats-stream-commit">
    <term>Stream Commit</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('c')</term>
       <listitem>
        <para>
         Identifie le message comme un message de validation du flux.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (TransactionId)</term>
       <listitem>
        <para>
         XID de la transaction.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int8(0)</term>
       <listitem>
        <para>
         Drapeaux&nbsp;; actuellement inutilisé.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (XLogRecPtr)</term>
       <listitem>
        <para>
         Le LSN de la validation.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (XLogRecPtr)</term>
       <listitem>
        <para>
         Le LSN final de la transaction.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (TimestampTz)</term>
       <listitem>
        <para>
         Horodatage de la validation de la transaction. La valeur est un nombre
         de microsecondes depuis l'epoch PostgreSQL (1er janvier 2000).
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-logicalrep-message-formats-stream-abort">
    <term>Stream Abort</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('A')</term>
       <listitem>
        <para>
         Identifie le message comme un message d'annulation de flux.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (TransactionId)</term>
       <listitem>
        <para>
         XID de la transaction.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (TransactionId)</term>
       <listitem>
        <para>
         XID de la sous-transaction (identique à l'XID de la transaction pour
         les transactions haut niveau).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (XLogRecPtr)</term>
       <listitem>
        <para>
         LSN de l'annulation. Ce champ est disponible à partir de la version 4
         du protocole.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (TimestampTz)</term>
       <listitem>
        <para>
         Horodatage de l'annulation de la transaction. La valeur est en nombre
         de microsecondes depuis l'epoch PostgreSQL (2000-01-01). Ce champ est
         disponible depuis la version 4 du protocole.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Les messages suivants (Begin Prepare, Prepare, Commit Prepared, Rollback
   Prepared, Stream Prepare) sont disponibles depuis la version 3 du
   protocole.
  </para>

  <variablelist>
   <varlistentry id="protocol-logicalrep-message-formats-begin-prepare">
    <term>Begin Prepare</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('b')</term>
       <listitem>
        <para>
         Identifie le message comme le début d'une transaction préparée.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (XLogRecPtr)</term>
       <listitem>
        <para>
         Le LSN de la préparation de la transaction.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (XLogRecPtr)</term>
       <listitem>
        <para>
         Le LSN final de la transaction préparée.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (TimestampTz)</term>
       <listitem>
        <para>
         Horodatage de la phase de préparation de la transaction. La valeur est
         en nombre de microsecondes depuis l'epoch PostgreSQL (1er janvier
         2000).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (TransactionId)</term>
       <listitem>
        <para>
         XID de la transaction.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Le GID défini par l'utilisateur pour la transaction préparée.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-logicalrep-message-formats-prepare">
    <term>Prepare</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('P')</term>
       <listitem>
        <para>
         Identifie le message comme un message de transaction préparée.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int8(0)</term>
       <listitem>
        <para>
         Drapeaux&nbsp;; actuellement inutilisé.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (XLogRecPtr)</term>
       <listitem>
        <para>
         Le LSN de la préparation.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (XLogRecPtr)</term>
       <listitem>
        <para>
         Le LSN final de la transaction préparée.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (TimestampTz)</term>
       <listitem>
        <para>
         Horodatage de la phase de préparation de la transaction. La valeur est
         en nombre de microsecondes depuis l'epoch PostgreSQL (1er janvier 2000).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (TransactionId)</term>
       <listitem>
        <para>
         XID de la transaction.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Le GID défini par l'utilisateur pour la transaction préparée.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-logicalrep-message-formats-commit-prepared">
    <term>Commit Prepared</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('K')</term>
       <listitem>
        <para>
         Identifie le message comme le message de validation d'une transaction
         préparée.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int8(0)</term>
       <listitem>
        <para>
         Drapeaux&nbsp;; actuellement inutilisé.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (XLogRecPtr)</term>
       <listitem>
        <para>
         Le LSN de la validation de la transaction préparée.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (XLogRecPtr)</term>
       <listitem>
        <para>
         Le LSN final de la validation de la transaction préparée.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (TimestampTz)</term>
       <listitem>
        <para>
         Horodatage de la validation de la transaction. La valeur est en
         nombre de microsecondes depuis l'epoch PostgreSQL (1er janvier 2000).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (TransactionId)</term>
       <listitem>
        <para>
         XID de la transaction.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Le GID défini par l'utilisateur pour la transaction préparée.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-logicalrep-message-formats-rollback-prepared">
    <term>Rollback Prepared</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('r')</term>
       <listitem>
        <para>
         Identifie le message comme le message d'annulation d'une transaction
         préparée.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int8(0)</term>
       <listitem>
        <para>
         Drapeaux&nbsp;; actuellement inutilisé.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (XLogRecPtr)</term>
       <listitem>
        <para>
         Le LSN final de la transaction préparée.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (XLogRecPtr)</term>
       <listitem>
        <para>
         Le LSN final de la transaction préparée annulée.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (TimestampTz)</term>
       <listitem>
        <para>
         Horodatage de la phase de préparation de la transaction. La valeur est
         en nombre de microsecondes depuis l'epoch PostgreSQL (1er janvier
         2000).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (TimestampTz)</term>
       <listitem>
        <para>
         Horodatage de la phase d'annulation de la transaction. La valeur est
         en nombre de microsecondes depuis l'epoch PostgreSQL (1er janvier
         2000).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (TransactionId)</term>
       <listitem>
        <para>
         XID de la transaction.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Le GID défini par l'utilisateur pour la transaction préparée.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>

   <varlistentry id="protocol-logicalrep-message-formats-stream-prepare">
    <term>Stream Prepare</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Byte1('p')</term>
       <listitem>
        <para>
         Identifie le message comme un message de préparation en flux 2PC.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int8(0)</term>
       <listitem>
        <para>
         Drapeaux&nbsp;; actuellement inutilisé.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (XLogRecPtr)</term>
       <listitem>
        <para>
         Le LSN de la phase de préparation.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (XLogRecPtr)</term>
       <listitem>
        <para>
         Le LSN final de la transaction préparée.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int64 (TimestampTz)</term>
       <listitem>
        <para>
         Horodatage de la phase de préparation de la transaction. La valeur est
         en nombre de microsecondes depuis l'epoch PostgreSQL (1er janvier
         2000).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Int32 (TransactionId)</term>
       <listitem>
        <para>
         XID de la transaction.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>String</term>
       <listitem>
        <para>
         Le GID défini par l'utilisateur pour la transaction préparée.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Les parties de message suivants sont partagées par les messages ci-dessus.
  </para>

  <variablelist>
   <varlistentry id="protocol-logicalrep-message-formats-tupledata">
    <term>TupleData</term>
    <listitem>
     <variablelist>
      <varlistentry>
       <term>Int16</term>
       <listitem>
        <para>
         Nombre de colonnes.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Ensuite, un des sous-messages suivants apparaît pour chaque colonne, à
      l'exception des colonnes générées)&nbsp;:

      <variablelist>
       <varlistentry>
        <term>Byte1('n')</term>
        <listitem>
         <para>
          Identifie la donnée comme une valeur NULL.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      ou
      <variablelist>
       <varlistentry>
        <term>Byte1('u')</term>
        <listitem>
         <para>
          Identifie la valeur TOAST non modifiée (la valeur réelle n'est pas
          envoyée).
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      ou
      <variablelist>
       <varlistentry>
        <term>Byte1('t')</term>
        <listitem>
         <para>
          Identifie la donnée comme une valeur formatée en texte.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      ou
      <variablelist>
       <varlistentry>
        <term>Byte1('b')</term>
        <listitem>
         <para>
          Identifie la donnée comme une valeur formatée en binaire.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term>Int32</term>
        <listitem>
         <para>
          Longueur de la valeur de la colonne.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term>Byte<replaceable>n</replaceable></term>
        <listitem>
         <para>
          La valeur de la colonne, en format soit binaire soit texte. (Comme
          spécifié dans l'octet de format précédent.)
          <replaceable>n</replaceable> est la longueur ci-dessus.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>

 <sect1 id="protocol-changes">
  <title>Résumé des changements depuis le protocole 2.0</title>

  <para>
   Cette section fournit une liste rapide des changements, au bénéfice des
   développeurs essayant de mettre à jour leur bibliothèque client existante
   avec le protocole 3.0.
  </para>

  <para>
   Le paquet de démarrage initial utilise un format flexible de liste de chaînes
   de caractères, au lieu d'un format fixé. Notez que les valeurs par défaut
   d'une session pour les paramètres d'exécution peuvent maintenant être
   spécifiées directement dans le paquet de démarrage. (En fait, vous pouvez le
   faire avant en utilisant le champ <literal>options</literal> mais, étant
   donné la largeur limité de ce champ et le manque de moyen pour mettre entre
   guillemets les espaces blancs dans les valeurs, ce n'était pas une technique
   très sûre.)
  </para>

  <para>
   Tous les messages ont maintenant un compteur de longueur suivant
   immédiatement l'octet du type de message (sauf pour les paquets de démarrage
   qui n'ont pas d'octet de type). De plus, notez que le message PasswordMessage
   a maintenant un octet de type
  </para>

  <para>
   Les messages ErrorResponse et NoticeResponse ('<literal>E</literal>' et
   '<literal>N</literal>') contiennent maintenant plusieurs champs, à partir
   desquels le code du client peut assembler un message d'erreur avec le
   niveau de verbosité désiré. Notez que les champs individuels ne finiront
   habituellement pas avec un retour chariot, alors que la chaîne seule
   envoyée dans le protocole précédent le faisait toujours.
  </para>

  <para>
   Le message ReadyForQuery ('<literal>Z</literal>') inclut un indicateur de
   statut de transaction.
  </para>

  <para>
   La distinction entre les types de message BinaryRow et DataRow n'existe
   plus&nbsp;; le type de message DataRow sert à renvoyer des données dans tous
   les formats. Notez que la disposition de DataRow a changé pour faciliter
   l'analyse. De plus, la représentation des valeurs binaires a changé&nbsp;:
   elle n'est plus directement liée à la représentation interne du serveur.
  </para>

  <para>
   Il existe un nouveau sous-protocole de <quote>requête étendue</quote>, qui
   ajoute les types de message client Parse, Bind, Execute, Describe, Close,
   Flush et Sync, ainsi que les types de message backend ParseComplete,
   BindComplete, PortalSuspended, ParameterDescription, NoData et CloseComplete.
   Les clients existants n'ont pas besoin de s'occuper de ce sous-protocole,
   mais l'utiliser pourrait permettre des améliorations en performance et en
   fonctionnalité.
  </para>

  <para>
   Les données de <command>COPY</command> sont maintenant encapsulées dans des
   messages CopyData et CopyDone. Il existe une façon bien définie de reprendre
   après des erreurs survenues pendant un <command>COPY</command>. Le
   <quote><literal>\.</literal></quote> de la dernière ligne n'est plus
   nécessaire, et n'est plus envoyé lors d'un <command>COPY OUT</command>. (Il
   est toujours reconnu comme terminaison lors d'un <command>COPY IN</command>,
   mais son utilisation est abandonnée et finira par être supprimée.) Le
   <command>COPY</command> binaire est supporté. Les messages CopyInResponse et
   CopyOutResponse incluent des champs indiquant le nombre de colonnes et le
   format de chaque colonne.
  </para>

  <para>
   La disposition des messages FunctionCall et FunctionCallResponse a changé.
   FunctionCall accepte maintenant de passer des arguments NULL aux fonctions.
   Il peut aussi gérer de passer des paramètres et de récupérer des résultats au
   format texte ou binaire. Il n'y a plus de raison de considérer FunctionCall
   comme une faille potentielle de sécurité car il n'offre pas d'accès direct
   aux représentations internes des données du serveur.
  </para>

  <para>
   Le backend envoie des messages ParameterStatus ('<literal>S</literal>')
   lors du démarrage de la connexion pour tous les paramètres qu'il considère
   intéressant pour la bibliothèque cliente. De plus, un message
   ParameterStatus est envoyé à chaque fois que la valeur active est modifiée
   pour chacun de ces paramètres.
  </para>

  <para>
   Le message RowDescription ('<literal>T</literal>') apporte de nouveaux champs
   pour l'OID de la table et le numéro de la colonne pour chaque colonne
   de la ligne décrite. Il affiche aussi le code format pour chaque colonne.
  </para>

  <para>
   Le message CursorResponse ('<literal>P</literal>') n'est plus généré par le
   backend.
  </para>

  <para>
   Le message NotificationResponse ('<literal>A</literal>') a un champ
   supplémentaire de type chaîne de caractères, qui peut porter une
   <quote>charge</quote> passé depuis l'événement <command>NOTIFY</command>.
  </para>

  <para>
   Le message EmptyQueryResponse ('<literal>I</literal>') incluait un paramètre
   de chaîne vide&nbsp;; il a été supprimé.
  </para>
 </sect1>
</chapter>
