<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="protocol">
 <title>Protocole client/serveur</title>

 <indexterm zone="protocol">
  <primary>protocol</primary>
  <secondary>frontend-backend</secondary>
 </indexterm>

 <para>
  <productname>postgresql</productname> utilise un protocole messages pour la
  communication entre les clients et les serveurs (<quote>frontend</quote> et
  <quote>backend</quote>). Le protocole est supporté par <acronym>TCP/IP</acronym>
  et par les sockets de domaine Unix. Le numéro de port 5432 a été enregistré
  auprès de l'IANA comme numéro de port TCP personnalisé pour les serveurs
  supportant ce protocole, mais en pratique tout numéro de port non privilégié
  peut être utilisé.
 </para>

 <para>
  Ce document décrit la version 3.0 de ce protocole, telle qu'implantée dans
  <productname>postgresql</productname> depuis la version 7.4. pour obtenir la
  description des versions précédentes du protocole, il faudra se reporter aux
  versions antérieures de la documentation de <productname>postgresql</productname>. un
  même serveur peut prendre en charge plusieurs versions du protocole. Lors de l'établissement
  de la communication, le client indique au serveur la version du protocole qu'il
  souhaite utiliser. Si la version majeure demandée par le client n'est pas
  supportée par le serveur, la connexion sera rejetée (par exemple, ceci
  arriverait si le client réclamait la version de protocole 4.0, qui n'existe
  pas au moment où ceci est écrit). Si la version mineure demandée par le
  client n'est pas supportée par le serveur (par exemple si le client réclame
  la version 3.1 mais que le serveur ne supporte que la version 3.0), le
  serveur peut soit rejeter la connexion soit répondre avec un message
  NegotiateProtocolVersion contenant le numéro de version mineur le plus haut
  qu'il supporte pour cette version du protocole. Le client peut ensuite
  choisir soit de continuer avec la connexion en utilisant la version
  spécifiée par le serveur soit d'annuler la connexion.
 </para>

 <para>
  Pour répondre efficacement à de multiples clients, le serveur lance un
  nouveau serveur (<quote>backend</quote>) pour chaque client. Dans l'implémentation
  actuelle, un nouveau processus fils est créé immédiatement après la détection
  d'une connexion entrante. Et cela de façon transparente pour le
  protocole. Pour le protocole, les termes <quote>backend</quote> et
  <quote>serveur</quote> sont interchangeables&nbsp;; comme <quote>frontend</quote>,
  <quote>interface</quote> et <quote>client</quote>.
 </para>

 <sect1 id="protocol-overview">
  <title>Aperçu</title>

  <para>
   Le protocole utilise des phases distinctes pour le lancement et le fonctionnement
   habituel. Dans la phase de lancement, le client ouvre une connexion au
   serveur et s'authentifie (ce qui peut impliquer un message simple, ou plusieurs
   messages, en fonction de la méthode d'authentification utilisée). En cas de
   réussite, le serveur
   envoie une information de statut au client et entre dans le mode normal de
   fonctionnement. Exception faite du message initial de demande de lancement, cette
   partie du protocole est conduite par le serveur.
  </para>

  <para>
   En mode de fonctionnement normal, le client envoie requêtes et commandes au
   serveur et celui-ci retourne les résultats de requêtes et autres réponses.
   Il existe quelques cas (comme <command>notify</command>) pour lesquels le serveur
   enverra des messages non sollicités. Mais dans l'ensemble, cette partie
   de la session est conduite par les requêtes du client.
  </para>

  <para>
   En général, c'est le client qui décide de la clôture de la session. Il arrive,
   cependant, qu'elle soit forcée par le moteur. Dans tous les cas, lors de la
   fermeture de la connexion par le serveur, toute transaction ouverte (non terminée)
   sera annulée.
  </para>

  <para>
   En mode opérationnel normal, les commandes SQL peuvent être exécutées
   via deux sous-protocoles. Dans le protocole des <quote>requêtes simples</quote>,
   le client envoie juste une chaîne, la requête, qui est analysée et exécutée
   immédiatement par le serveur. Dans le protocole des <quote>requêtes
    étendues</quote>, le traitement des requêtes est découpé en de nombreuses
   étapes&nbsp;: l'analyse, le lien avec les valeurs de paramètres et
   l'exécution. Ceci offre flexibilité et gains en performances
   au prix d'une complexité supplémentaire.
  </para>

  <para>
   Le mode opérationnel normal offre des sous-protocoles supplémentaires pour
   certaines opérations comme <command>copy</command>.
  </para>

  <sect2 id="protocol-message-concepts">
   <title>Aperçu des messages</title>

   <para>
    Toute la communication s'effectue au travers d'un flux de messages. Le premier octet
    d'un message identifie le type de message et les quatre octets suivants
    spécifient la longueur du reste du message (cette longueur inclut les 4 octets
    de longueur, mais pas l'octet du type de message). Le reste du contenu du
    message est déterminé par le type de message. Pour des raisons historiques,
    le tout premier message envoyé par le client (le message de lancement) n'a
    pas l'octet initial de type du message.
   </para>

   <para>
    Pour éviter de perdre la synchronisation avec le flux de messages, le
    serveur et le client stockent le message complet dans un tampon
    (en utilisant le nombre d'octets) avant de tenter de traiter son contenu.
    Cela permet une récupération simple si une erreur est détectée lors du
    traitement du contenu. Dans les situations extrêmes (telles que de ne pas avoir
    assez de mémoire pour placer le message dans le tampon), le récepteur
    peut utiliser le nombre d'octets pour déterminer le nombre d'entrées à ignorer
    avant de continuer la lecture des messages.
   </para>

   <para>
    En revanche, serveurs et clients doivent être attentifs à ne pas envoyer
    de message incomplet. Ceci est habituellement obtenu en plaçant le message
    complet dans un tampon avant de commencer l'envoi. Si un échec de
    communications survient pendant l'envoi ou la réception d'un message, la
    seule réponse plausible est l'abandon de la connexion. Il y a, en effet, peu d'espoir
    de resynchronisation des messages.
   </para>
  </sect2>

  <sect2 id="protocol-query-concepts">
   <title>Aperçu des requêtes étendues</title>

   <para>
    Dans le protocole des requêtes étendues, l'exécution de commandes SQL est
    scindée en plusieurs étapes. L'état retenu entre les étapes est représenté
    par deux types d'objets&nbsp;: les <firstterm>instructions préparées</firstterm> et
    les <firstterm>portails</firstterm>. Une instruction préparée représente le résultat
    de l'analyse syntaxique et de l'analyse sémantique d'une
    chaîne de requête textuelle. Une instruction préparée en elle-même n'est pas prête à
    être exécutée parce qu'il peut lui manquer certaines valeurs de
    <firstterm>paramètres</firstterm>. Un portail représente une instruction prête à être
    exécutée ou déjà partiellement exécutée, dont toutes les valeurs de
    paramètres manquants sont données (pour les instructions
    <command>select</command>, un portail est équivalent à un curseur ouvert. il est
    choisi d'utiliser un terme différent, car les curseurs ne gèrent pas les
    instructions autres que <command>select</command>)
   </para>

   <para>
    Le cycle d'exécution complet consiste en une étape d'<firstterm>analyse syntaxique</firstterm>,
    qui crée une instruction préparée à partir d'une chaîne de requête textuelle&nbsp;;
    une étape de <firstterm>liaison</firstterm>, qui crée un portail à partir d'une
    instruction préparée et des valeurs pour les paramètres nécessaires&nbsp;;
    et une étape d'<firstterm>exécution</firstterm> qui exécute une requête du portail.
    Dans le cas d'une requête qui renvoie des lignes (<command>select</command>,
    <command>show</command>, etc), il peut être signalé à l'étape d'exécution
    que seul un certain nombre de lignes doivent être retournées, de sorte que
    de multiples étapes d'exécution seront nécessaires pour terminer l'opération.
   </para>

   <para>
    Le serveur peut garder la trace de multiples instructions préparées et
    portails (qui n'existent qu'à l'intérieur d'une session, et ne sont jamais
    partagés entre les sessions). Les instructions
    préparées et les portails sont référencés par les noms qui leur sont affectés
    à la création. De plus, il existe une instruction préparée et un portail
    <quote>non nommés</quote>. Bien qu'ils se comportent comme des objets
    nommés, les opérations y sont optimisées en vue d'une exécution unique
    de la requête avant son annulation puis est annulée. En revanche, les
    opérations sur les objets nommés sont optimisées pour des utilisations multiples.
   </para>
  </sect2>

  <sect2 id="protocol-format-codes">
   <title>Formats et codes de format</title>

   <para>
    Les données d'un type particulier pouvaient être transmises sous
    différents <firstterm>formats</firstterm>. Depuis <productname>PostgreSQL</productname> 7.4, les
    seuls formats supportés sont le <quote>texte</quote> et le <quote>binaire</quote> mais
    le protocole prévoit des extensions futures. Le format souhaité pour toute valeur
    est spécifié par un <firstterm>code de format</firstterm>. les clients peuvent spécifier
    un code de format pour chaque valeur de paramètre transmise et pour chaque
    colonne du résultat d'une requête. Une donnée de type texte a comme code
    de format zéro (0) et une donnée de type binaire a comme code de format un (1).
    Tous les autres codes de format sont réservés pour des définitions futures.
   </para>

   <para>
    La représentation au format texte des valeurs est toute chaîne de caractères
    produite et acceptée par les fonctions de conversion en entrée/sortie pour le
    type de données particulier.
    Dans la représentation transmise, il n'y a pas de caractère nul
    de terminaison de chaîne&nbsp;; le client doit en ajouter un aux valeurs reçues
    s'il souhaite les traiter comme des chaînes C (le format texte n'autorise pas
    les valeurs nulles intégrées).
   </para>

   <para>
    Les représentations binaires des entiers utilisent l'ordre d'octet
    réseau (octet le plus significatif en premier). Pour les autres types de
    données, il faudra consulter la documentation ou le code source pour connaître
    la représentation binaire. Les représentations binaires
    des types de données complexes changent parfois entre les versions du
    serveur&nbsp;; le format texte reste le choix le plus portable.
   </para>
  </sect2>
 </sect1>

 <sect1 id="protocol-flow">
  <title>Flux de messages</title>

  <para>
   Cette section décrit le flux des messages et la sémantique de chaque type
   de message (les détails concernant la représentation exacte de chaque message
   apparaissent dans <xref linkend="protocol-message-formats"/>). il existe
   différents sous-protocoles en fonction de l'état de la connexion&nbsp;: lancement,
   requête, appel de fonction, COPY et clôture. Il existe aussi des provisions
   spéciales pour les opérations asynchrones (incluant les
   réponses aux notifications et les annulations de commande), qui peuvent
   arriver à tout moment après la phase de lancement.
  </para>

  <sect2>
   <title>Lancement</title>

   <para>
    Pour débuter une session, un client ouvre une connexion au serveur et
    envoie un message de démarrage. Ce message inclut les noms de l'utilisateur
    et de la base de données à laquelle le client souhaite se connecter&nbsp;; il
    identifie aussi la version particulière du protocole à utiliser
    (optionnellement, le message de démarrage peut inclure des précisions
    supplémentaires pour les paramètres d'exécution). Le serveur utilise
    ces informations et le contenu des fichiers de configuration
    (tels que <filename>pg_hba.conf</filename>) pour déterminer si la connexion
    est acceptable et quelle éventuelle authentification supplémentaire est requise.
   </para>

   <para>
    Le serveur envoie ensuite le message de demande d'authentification
    approprié, auquel le client doit répondre avec le message de réponse
    d'authentification adapté (tel un mot de passe). Pour toutes les méthodes
    d'authentification, sauf GSSAPI, SSPI et SASL, il y a au maximum une requête et
    une réponse. Avec certaines méthodes, aucune réponse du client n'est
    nécessaire&nbsp; aucune demande d'authentification n'est alors effectuée.
    Pour GSSAPI, SSPI et SASL, plusieurs échanges de paquets peuvent être
    nécessaire pour terminer l'authentification.
   </para>

   <para>
    Le cycle d'authentification se termine lorsque le serveur rejette la tentative
    de connexion (ErrorResponse) ou l'accepte (AuthenticationOk).
   </para>

   <para>
    Les messages possibles du serveur dans cette phase sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term>errorresponse</term>
      <listitem>
       <para>
        La tentative de connexion a été rejetée.
        Le serveur ferme immédiatement la connexion.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>authenticationok</term>
      <listitem>
       <para>
        L'échange d'authentification s'est terminé avec succès.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>authenticationkerberosv5</term>
      <listitem>
       <para>
        Le client doit alors prendre part à un dialogue
        d'authentification Kerberos V5 (spécification Kerberos, non décrite ici)
        avec le serveur. En cas de succès, le serveur répond AuthenticationOk,
        ErrorResponse sinon. Ce n'est plus supporté.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>authenticationcleartextpassword</term>
      <listitem>
       <para>
        Le client doit alors envoyer un PasswordMessage contenant le mot
        de passe en clair. Si le mot de passe est correct, le serveur répond
        AuthenticationOk, ErrorResponse sinon.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>authenticationmd5password</term>
      <listitem>
       <para>
        Le client doit envoyer un PasswordMessage contenant le mot de passe
        (avec le nom de l'utilisateur) chiffré en MD5, puis chiffré de
        nouveau avec un salt aléatoire sur 4 octets indiqué dans le message
        AuthenticationMD5Password. S'il s'agit du bon mot de passe, le
        serveur répond avec un AuthenticationOk, sinon il répond avec un
        ErrorResponse. Le PasswordMessage réel peut être calculé en SQL
        avec <literal>concat('md5',
         md5(concat(md5(concat(password, username)), random-salt)))</literal>.
        (Gardez en tête que la fonction <function>md5()</function> renvoie
        son résultat sous la forme d'une chaîne hexadécimale.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>authenticationscmcredential</term>
      <listitem>
       <para>
        Cette réponse est possible uniquement pour les connexions locales de
        domaine Unix sur les plateformes qui supportent les messages
        de légitimation SCM. Le client doit fournir un message de légitimation
        SCM, puis envoyer une donnée d'un octet. Le contenu de cet octet
        importe peu&nbsp;; il n'est utilisé que pour s'assurer que le serveur
        attend assez longtemps pour recevoir le message de légitimation.
        Si la légitimation est acceptable, le serveur répond AuthenticationOk,
        ErrorResponse sinon.
        (Ce type de message n'est envoyé que par des serveurs dont la
        version est antérieure à la 9.1. Il pourrait être supprimé de
        la spécification du protocole.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationGSS</term>
      <listitem>
       <para>
        L'interface doit maintenant initier une négociation GSSAPI. L'interface
        doit envoyer un GSSResponse avec la première partie du flux de
        données GSSAPI en réponse à ceci. Si plus de messages sont nécessaires,
        le serveur répondra avec AuthenticationGSSContinue.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSSPI</term>
      <listitem>
       <para>
        L'interface doit maintenant initier une négociation SSPI. L'interface
        doit envoyer un GSSResponse avec la première partie du flux de
        données SSPI en réponse à ceci. Si plus de messages sont nécessaires,
        le serveur répondra avec AuthenticationGSSContinue.
       </para>
      </listitem>

     </varlistentry>

     <varlistentry>
      <term>AuthenticationGSSContinue</term>
      <listitem>
       <para>
        Ce message contient les données de la réponse de l'étape précédente
        pour la négociation GSSAPI ou SSPI (AuthenticationGSS ou un précédent
        AuthenticationGSSContinue). Si les données GSSAPI dans ce message
        indique que plus de données sont nécessaire pour terminer
        l'authentification, l'interface doit envoyer cette donnée dans un
        autre GSSResponse. Si l'authentification GSSAPI ou SSPI est
        terminée par ce
        message, le serveur enverra ensuite AuthenticationOk pour indiquer une
        authentification réussie ou ErrorResponse pour indiquer l'échec.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSASL</term>
      <listitem>
       <para>
        L'interface doit maintenant initier une négociation SASL en utilisant
        un des mécanismes SASL listés dans le message. L'interface enverra un
        SASLInitialResponse avec le nom du mécanisme sélectionné, et la
        première partie du flux de données SASL en réponse à ceci. Si plus de
        messages sont nécessaires, le serveur répondra avec
        AuthenticationSASLContinue. Voir <xref linkend="sasl-authentication"/>
        pour les détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSASLContinue</term>
      <listitem>
       <para>
        Ce message contient les données de challenge provenant de l'étape
        précédente de la négociation SASL (AuthenticationSASL ou un précédent
        AuthenticationSASLContinue). L'interface doit répondre avec un message
        SASLResponse.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSASLFinal</term>
      <listitem>
       <para>
        L'authentification SASL s'est terminée avec les données
        supplémentaires du mécanisme sélectionné pour le client. Le serveur
        enverra ensuite AuthenticationOk pour indiquer le succès de
        l'authentification ou un ErrorResponse pour indiquer l'échec. Ce
        message est seulement envoyé si le mécanisme SASL indique l'envoi de
        données supplémentaires du serveur au client à la fin.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NegotiateProtocolVersion</term>
      <listitem>
       <para>
        Le serveur ne supporte par la version mineure du protocole réclamée
        par le client mais supporte une version précédente du protocole. Ce
        message indique la plus haute version mineure supportée. Ce message
        sera aussi envoyé si le client demande des options de protocole non
        supportées (commençant par <literal>_pq_.</literal>) dans le paquet de
        démarrage. Ce message sera suivi par un ErrorResponse ou un message
        indiquant le succès ou l'échec de l'authentification.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Si le client ne supporte pas la méthode d'authentification demandée par le
    serveur, il doit immédiatement fermer la connexion.
   </para>

   <para>
    Après la réception du message AuthenticationOk, le client attend d'autres
    messages du serveur. Au cours de cette phase, un processus serveur est lancé
    et le client est simplement en attente. Il est encore possible que la tentative de
    lancement échoue (ErrorResponse) ou que le serveur décline le supporte de
    la version mineure du protocole demandée (NegotiateProtocolVersion) mais,
    dans la plupart des cas, le serveur enverra les messages ParameterStatus,
    BackendKeyData et enfin ReadyForQuery.
   </para>

   <para>
    Durant cette phase, le serveur tentera d'appliquer tous les paramètres
    d'exécution supplémentaires qui ont été fournis par le message de lancement.
    En cas de succès, ces valeurs deviennent les valeurs par défaut de la session.
    Une erreur engendre ErrorResponse et déclenche la sortie.
   </para>

   <para>
    Les messages possibles du serveur dans cette phase sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term>backendkeydata</term>
      <listitem>
       <para>
        Ce message fournit une clé secrète que le client doit conserver s'il
        souhaite envoyer des annulations de requêtes par la suite.
        Le client ne devrait pas répondre à ce message, mais continuer à attendre
        un message ReadyForQuery.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>parameterstatus</term>
      <listitem>
       <para>
        Ce message informe le client de la configuration actuelle (initiale)
        des paramètres du serveur, tels <varname>client_encoding</varname> ou
        <varname>datestyle</varname>. le client peut ignorer ce message ou enregistrer
        la configuration pour ses besoins futurs&nbsp;; voir
        <xref linkend="protocol-async"/> pour plus de détails. le client ne
        devrait pas répondre à ce message mais continuer à attendre un message
        ReadyForQuery.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>readyforquery</term>
      <listitem>
       <para>
        Le lancement est terminé. Le client peut dès lors envoyer des commandes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>errorresponse</term>
      <listitem>
       <para>
        Le lancement a échoué. La connexion est fermée après l'envoi de ce
        message.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>noticeresponse</term>
      <listitem>
       <para>
        Un message d'avertissement a été envoyé. Le client devrait afficher ce
        message mais continuer à attendre un ReadyForQuery ou un ErrorResponse.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Le même message ReadyForQuery est envoyé à chaque cycle de commande.
    En fonction des besoins de codage du client, il est possible de
    considérer ReadyForQuery comme le début d'un cycle de commande, ou de le
    considérer comme terminant la phase de lancement et chaque cycle de commande.
   </para>
  </sect2>

  <sect2>
   <title>Requête simple</title>

   <para>
    Un cycle de requête simple est initié par le client qui envoie un message
    Query au serveur. Le message inclut une commande SQL (ou plusieurs) exprimée
    comme une chaîne texte. Le serveur envoie, alors, un ou plusieurs messages
    de réponse dépendant du contenu de la chaîne représentant la requête et
    enfin un message ReadyForQuery. ReadyForQuery informe le client qu'il peut
    envoyer une nouvelle commande. Il n'est pas nécessaire que le client attende
    ReadyForQuery avant de lancer une autre commande mais le client prend alors
    la responsabilité de ce qui arrive si la commande précédente échoue et que
    les commandes suivantes, déjà lancées, réussissent.
   </para>

   <para>
    Les messages de réponse du serveur sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term>commandcomplete</term>
      <listitem>
       <para>
        Commande SQL terminée normalement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>copyinresponse</term>
      <listitem>
       <para>
        Le serveur est prêt à copier des données du client vers une table&nbsp;
        voir <xref linkend="protocol-copy"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>copyoutresponse</term>
      <listitem>
       <para>
        Le serveur est prêt à copier des données d'une table vers le client&nbsp;;
        voir <xref linkend="protocol-copy"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>rowdescription</term>
      <listitem>
       <para>
        Indique que des lignes vont être envoyées en réponse à une
        requête <command>select</command>, <command>fetch</command>...
        Le contenu de ce message décrit le placement des colonnes dans les
        lignes. Le contenu est suivi d'un message DataRow pour chaque ligne envoyée
        au client.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>datarow</term>
      <listitem>
       <para>
        Un des ensembles de lignes retournés par une requête
        <command>select</command>, <command>fetch</command>...
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>emptyqueryresponse</term>
      <listitem>
       <para>
        Une chaîne de requête vide a été reconnue.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>errorresponse</term>
      <listitem>
       <para>
        Une erreur est survenue.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>readyforquery</term>
      <listitem>
       <para>
        Le traitement d'une requête est terminé. Un message séparé est envoyé
        pour l'indiquer parce qu'il se peut que la chaîne de la requête contienne
        plusieurs commandes SQL. CommandComplete marque la fin du traitement
        d'une commande SQL, pas de la chaîne complète. ReadyForQuery sera
        toujours envoyé que le traitement se termine avec succès ou non.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>noticeresponse</term>
      <listitem>
       <para>
        Un message d'avertissement concernant la requête a été envoyé. Les
        avertissements sont complémentaires des autres réponses, le serveur
        continuera à traiter la commande.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <para>
    La réponse à une requête <command>select</command> (ou à d'autres requêtes, telles
    <command>explain</command> ou <command>show</command>, qui retournent des ensembles de
    données) consiste normalement en un RowDescription, plusieurs messages
    DataRow (ou aucun) et pour finir un CommandComplete. <command>copy</command> depuis
    ou vers le client utilise un protocole spécial décrit dans
    <xref linkend="protocol-copy"/>. Tous les autres types de requêtes produisent
    uniquement un message CommandComplete.
   </para>

   <para>
    Puisqu'une chaîne de caractères peut contenir plusieurs requêtes (séparées
    par des points virgules), il peut y avoir plusieurs séquences de réponses
    avant que le serveur ne finisse de traiter la chaîne. ReadyForQuery est
    envoyé lorsque la chaîne complète a été traitée et que le serveur est prêt à
    accepter une nouvelle chaîne de requêtes.
   </para>

   <para>
    Si une chaîne de requêtes complètement vide est reçue (aucun contenu autre
    que des espaces fines), la réponse sera EmptyQueryResponse suivie de
    ReadyForQuery.
   </para>

   <para>
    En cas d'erreur, ErrorResponse est envoyé suivi de ReadyForQuery. Tous les
    traitements suivants de la chaîne sont annulés par ErrorResponse (quelque
    soit le nombre de requêtes restant à traiter). Ceci peut survenir au
    milieu de la séquence de messages engendrés par une requête individuelle.
   </para>

   <para>
    En mode de requêtage simple, les valeurs récupérées sont toujours au format
    texte, sauf si la commande est un <command>fetch</command> sur un curseur déclaré
    avec l'option <literal>binary</literal>. dans ce cas, les valeurs récupérées sont
    au format binaire. Les codes de format donnés dans le message RowDescription
    indiquent le format utilisé.
   </para>

   <para>
    La planification de requêtes pour des instructions préparées survient
    lorsque le message Parse est reçu. Si une requête sera exécuté de façon
    répété avec différents paramètres, il pourrait être bénéfique d'envoyer un
    seul message Parse contenant une requête avec paramètres, suivie de
    plusieurs messages Bind et Execute. Ceci évitera de planifier de nouveau
    la requête pour chaque exécution.
   </para>

   <para>
    L'instruction préparée non nommée est planifiée lors du traitement de Parse
    si le message Parse ne définit aucun paramètre. Mais s'il existe des
    paramètres, la planification de la requête est repoussée jusqu'à ce que le
    premier message Bind de cette instruction est reçu. Le planificateur
    considérera les valeurs réelles des paramètres fournies dans le message
    Bind lors de la planification de la requête.
   </para>

   <note>
    <para>
     Les plans de requêtes générés à partir d'une requête avec paramètres
     pourraient être moins efficaces que les plans de requêtes générés à partir
     d'une requête équivalente dont les valeurs de paramètres réelles ont été
     placées. Le planificateur de requêtes ne peut pas prendre les décisions
     suivant les valeurs réelles des paramètres (par exemple, la sélectivité
     de l'index) lors de la planification d'une requête avec paramètres affectée
     à un objet instruction préparée nommée. La pénalité possible est évitée
     lors de l'utilisation d'une instruction non nommée car elle n'est pas
     planifiée jusqu'à ce que des valeurs réelles de paramètres soient
     disponibles.
    </para>

    <para>
     Si un autre Bind référençant l'objet instruction préparée non nommée est
     reçu, la requête n'est pas de nouveau planifiée. Les valeurs de paramètres
     utilisées dans le premier message Bind pourrait produire un plan de requête
     qui est seulement efficace pour un sous-ensemble des valeurs de paramètres
     possibles. Pour forcer une nouvelle planification de la requête pour un
     ensemble nouveau de paramètres, envoyez un autre message Parse pour
     remplacer l'objet instruction préparée non nommée.
    </para>
   </note>

   <para>
    Un client doit être préparé à accepter des messages ErrorResponse et
    NoticeResponse quand bien même il s'attendrait à un autre type de message.
    Voir aussi <xref linkend="protocol-async"/> concernant les messages que le
    client pourrait engendrer du fait d'événements extérieurs.
   </para>

   <para>
    La bonne pratique consiste à coder les clients dans un style machine-état
    qui acceptera tout type de message à tout moment plutôt que de parier sur
    la séquence exacte des messages.
   </para>

   <sect3 id="protocol-flow-multi-statement">
    <title>Plusieurs instructions dans une requête simple</title>

    <para>
     Lorsqu'un simple message de requête contient plus d'une instruction SQL
     (séparés par des points-virgules), ces instructions sont exécutés comme une
     seule transaction à moins que des commandes explicites de contrôle des
     transactions ne soient incluses pour forcer un comportement différent.
     Par exemple, si le message contient&nbsp;:
<programlisting>
INSERT INTO mytable VALUES(1);
SELECT 1/0;
INSERT INTO mytable VALUES(2);
</programlisting>
     l'échec de la division par zéro dans le <command>SELECT</command> forcera
     le retour en arrière du premier <command>INSERT</command>. De plus, comme
     l'exécution du message est abandonnée à la première erreur, le second
     <command>INSERT</command> n'est jamais executé.
    </para>

    <para>
     Si au lieu de cela, le message contient&nbsp;:
<programlisting>
BEGIN;
INSERT INTO mytable VALUES(1);
COMMIT;
INSERT INTO mytable VALUES(2);
SELECT 1/0;
</programlisting>
     Alors le premier <command>INSERT</command> est validée par la commande
     <command>COMMIT</command> explicite. Le second <command>INSERT</command>
     et le <command>SELECT</command> sont toujours traités comme une seule
     transaction, de sorte que l'échec de la division par zéro fera annuler
     (<literal>rollback</literal>) le second <command>INSERT</command>, mais
     pas le premier.
    </para>

    <para>
     Ce comportement est implémenté en exécutant les instructions dans un message
     de requête multi-instructions dans un
     <firstterm>bloc de transaction implicite</firstterm>, à moins qu'il n'y ait
     un bloc de transaction explicite dans lequel elles puissent être exécutées.
     La principale différence entre un bloc de transaction implicite et un bloc
     normal est qu'un bloc implicite est fermé automatiquement à la fin du
     message de requête, soit par un <literal>COMMIT</literal> implicite s'il
     n'y a pas d'erreur, soit par un <literal>ROLLBACK</literal> implicite s'il
     y a une erreur. Ceci est similaire au <literal>COMMIT</literal> ou
     <literal>ROLLBACK</literal> implicite qui se produit pour une instruction
     exécutée par elle-même (lorsqu'elle n'est pas dans un bloc de transaction).
    </para>

    <para>
     Si la session se trouve déjà dans un bloc de transaction à la suite d'un
     <command>BEGIN</command> dans un message précédent, le message de requête
     poursuit simplement ce bloc de transaction, que le message contienne une
     ou plusieurs instructions. Toutefois, si le message de requête contient un
     <command>COMMIT</command> ou un <command>ROLLBACK</command> fermant le bloc
     de transaction existant, toutes les instructions suivantes sont exécutées
     dans un bloc de transaction implicite. À l'inverse, si un <command>BEGIN</command>
     apparaît dans un message de requête multi-instructions, il lance un bloc
     de transaction normal qui ne sera terminé que par un <command>COMMIT</command>
     ou un <command>ROLLBACK</command> explicite&nbsp;; que celui-ci apparaisse dans
     ce message de requête ou dans un autre. Si le <command>BEGIN</command>
     suit certaines instructions qui ont été exécutés comme un bloc de transaction
     implicite, ces instructions ne sont pas immédiatement validées&nbsp;; en fait,
     ils sont inclus rétroactivement dans le nouveau bloc de transaction normal.
    </para>

    <para>
     Un <command>COMMIT</command> ou <command>ROLLBACK</command> apparaissant dans
     un bloc de transaction implicite est exécuté normalement, fermant ainsi le bloc
     implicite&nbsp;; cependant, un avertissement sera levé puisqu'un
     <command>COMMIT</command> ou <command>ROLLBACK</command> qui est utilisé sans
     un <command>BEGIN</command> le précédent peut être une erreur. Si d'autres
     instructions suivent, un nouveau bloc de transaction implicite sera lancé
     pour elles.
    </para>

    <para>
     Les points de sauvegarde (<literal>SAVEPOINT</literal>) ne sont pas autorisés
     dans un bloc de transaction implicite, car ils seraient en conflit avec le
     comportement de fermeture automatique du bloc en cas d'erreur.
    </para>

    <para>
     N'oubliez pas que, quelle que soit la commande de contrôle de transaction
     présente, l'exécution du message de requête s'arrête dès la première erreur.
     Par exemple, si pour un message de requête unique l'on donne&nbsp;:
<programlisting>
BEGIN;
SELECT 1/0;
ROLLBACK;
</programlisting>
     la session sera laissée à l'intérieur d'un <quote>bloc de transaction
     normal</quote> échoué, puisque le <command>ROLLBACK</command> n'est pas
     atteint après l'erreur de la division par zéro.
     Un autre <command>ROLLBACK</command> sera donc nécessaire pour restaurer
     la session à un état utilisable.
    </para>

    <para>
     Il y a un autre comportement qu'il faut souligner, l'analyse lexicale et
     syntaxique initiale est effectuée sur toute la chaîne de la requête avant
     qu'elle ne soit exécutée. Ainsi, de simples erreurs dans une instruction
     (comme un mot-clé mal orthographié) empêchent l'exécution de toutes les
     instructions. Ceci est transparent pour les utilisateurs puisque les
     instructions seraient annulées de toute façon lorsqu'elles sont exécutées dans
     un bloc de transaction implicite. Toutefois, elle peut être visible lorsque
     vous tentez d'effectuer plusieurs transactions dans une requête multi-instructions.
     Par exemple, si une faute de frappe a transformé notre exemple précédent
     en&nbsp;:

<programlisting>
BEGIN;
INSERT INTO mytable VALUES(1);
COMMIT;
INSERT INTO mytable VALUES(2);
SELECT 1/0;
</programlisting>
     alors aucune des instructions ne sera exécutée, la différence visible est
     que le premier <command>INSERT</command> n'est pas validé (<literal>COMMIT</literal>).
     Les erreurs détectées lors de l'analyse sémantique ou plus tard, telles
     qu'un nom de table ou de colonne mal orthographié, n'ont pas cet effet.
    </para>
   </sect3>
  </sect2>

  <sect2 id="protocol-flow-ext-query">
   <title>Requête étendue</title>

   <para>
    Le protocole de requête étendu divise le protocole de requêtage simple décrit
    ci-dessus en plusieurs étapes. Les résultats des étapes de préparation
    peuvent être réutilisés plusieurs fois pour plus d'efficacité. De plus,
    des fonctionnalités supplémentaires sont disponibles, telles que la
    possibilité de fournir les valeurs des données comme des paramètres séparés
    au lieu d'avoir à les insérer directement dans une chaîne de requêtes.
   </para>

   <para>
    Dans le protocole étendu, le client envoie tout d'abord un message Parse
    qui contient une chaîne de requête, optionnellement quelques informations
    sur les types de données aux emplacements des paramètres, et le nom de
    l'objet de destination d'une instruction préparée (une chaîne vide
    sélectionne l'instruction préparée sans nom). La réponse est soit
    ParseComplete soit ErrorResponse. Les types de données des paramètres
    peuvent être spécifiés par l'OID&nbsp;; dans le cas contraire, l'analyseur
    tente d'inférer les types de données de la même façon qu'il le ferait pour
    les constantes chaînes littérales non typées.
   </para>

   <note>
    <para>
     Un type de paramètre peut être laissé non spécifié en le positionnant
     à O, ou en créant un tableau d'OID de type plus court que le nombre de
     paramètres (<literal>$</literal><replaceable>n</replaceable>) utilisés
     dans la chaîne de requête.
     Un autre cas spécial est d'utiliser <type>void</type> comme type de
     paramètre (c'est à dire l'OID du pseudo-type <type>void</type>). Cela
     permet d'utiliser des paramètres dans des fonctions en tant qu'argument
     OUT.
     Généralement, il n'y a pas de contexte dans lequel <type>void</type>
     peut être utilisé, mais si un tel paramètre apparaît dans les arguments
     d'une fonction, il sera simplement ignoré.
     Par exemple, un appel de fonction comme
     <literal>foo($1,$2,$3,$4)</literal> peut correspondre à une fonction avec
     2 arguments IN et 2 autres OUT si <literal>$3</literal> et
     <literal>$4</literal> sont spécifiés avec le type <type>void</type>.
    </para>
   </note>

   <note>
    <para>
     La chaîne contenue dans un message Parse ne peut pas inclure plus d'une
     instruction SQL, sinon une erreur de syntaxe est rapportée. Cette
     restriction n'existe pas dans le protocole de requête simple, mais est
     présente dans le protocole étendu. En effet, permettre aux instructions
     préparées ou aux portails de contenir de multiples commandes compliquerait
     inutilement le protocole.
    </para>
   </note>

   <para>
    En cas de succès de sa création, une instruction préparée nommée dure
    jusqu'à la fin de la session courante, sauf si elle est détruite
    explicitement. Une instruction préparée non nommée ne dure que jusqu'à
    la prochaine instruction Parse spécifiant l'instruction non nommée comme
    destination. Un simple message Query détruit également l'instruction non
    nommée. Les instructions préparées nommées doivent être explicitement
    closes avant de pouvoir être redéfinies par un autre message Parse. Ce n'est
    pas obligatoire pour une instruction non nommée. Il est également possible
    de créer des instructions préparées nommées, et d'y accéder, en ligne de
    commandes SQL à l'aide des instructions <command>prepare</command> et
    <command>execute</command>.
   </para>

   <para>
    Dès lors qu'une instruction préparée existe, elle est déclarée exécutable
    par un message Bind. Le message Bind donne le nom de l'instruction préparée
    source (une chaîne vide désigne l'instruction préparée non nommée), le nom
    du portail destination (une chaîne vide désigne le portail non nommé) et les
    valeurs à utiliser pour tout emplacement de paramètres présent dans
    l'instruction préparée. L'ensemble des paramètres fournis doit
    correspondre à ceux nécessaires à l'instruction préparée. Bind spécifie aussi
    le format à utiliser pour toutes les données renvoyées par la requête&nbsp;;
    le format peut être spécifié complètement ou par colonne. La réponse est, soit
    BindComplete, soit ErrorResponse.
   </para>

   <note>
    <para>
     Le choix entre sortie texte et binaire est déterminé par les codes
     de format donnés dans Bind, quel que soit la commande SQL impliquée.
     L'attribut <literal>BINARY</literal> dans les déclarations du curseur n'est pas
     pertinent lors de l'utilisation du protocole de requête étendue.
    </para>
   </note>

   <para>
    La planification de la requête survient généralement quand le message
    Bind est traité. Si la requête préparée n'a pas de paramètres ou
    si elle est exécutée de façon répétée, le serveur peut sauvegarder le
    plan créé et le ré-utiliser lors des appels suivants à Bind pour la
    même requête préparée. Néanmoins, il ne le fera que s'il estime qu'un
    plan générique peut être créé en étant pratiquement aussi efficace
    qu'un plan dépendant des valeurs des paramètres. Cela arrive de façon
    transparente en ce qui concerne le protocole
   </para>

   <para>
    En cas de succès de sa création, un objet portail nommé dure jusqu'à la fin
    de la transaction courante sauf s'il est explicitement détruit. Un
    portail non nommé est détruit à la fin de la transaction ou dès la prochaine
    instruction Bind spécifiant le portail non nommé comme destination.
    Un simple message Query détruit également le portail non nommé. Les
    portails nommés doivent être explicitement fermés avant de pouvoir être
    redéfinis par un autre message Bind. Cela n'est pas obligatoire pour le portail non
    nommé. Il est également possible de créer des portails nommés, et d'y
    accéder, en ligne de commandes SQL à l'aide des instructions
    <command>declare cursor</command> et <command>fetch</command>.
   </para>

   <para>
    Dès lors qu'un portail existe, il peut être exécuté à l'aide d'un message
    Execute. Ce message spécifie le nom du portail (une chaîne vide désigne le
    portail non nommé) et un nombre maximum de lignes de résultat (zéro
    signifiant la <quote>récupération de toutes les lignes</quote>). le nombre de lignes
    de résultat a seulement un sens pour les portails contenant des commandes
    qui renvoient des ensembles de lignes&nbsp;; dans les autres cas, la
    commande est toujours exécutée jusqu'à la fin et le nombre de lignes est
    ignoré. Les réponses possibles d'Execute sont les même que celles
    décrites ci-dessus pour les requêtes lancées via le protocole de requête
    simple, si ce n'est qu'Execute ne cause pas l'envoi de ReadyForQuery ou de
    RowDescription.
   </para>

   <para>
    Si Execute se termine avant la fin de l'exécution d'un portail (du fait
    d'un nombre de lignes de résultats différent de zéro), il enverra un
    message PortalSuspended&nbsp;; la survenue de ce message indique au client
    qu'un autre Execute devrait être lancé sur le même portail pour terminer
    l'opération. Le message CommandComplete indiquant la fin de la commande
    SQL n'est pas envoyé avant l'exécution complète du portail. Une phase
    Execute est toujours terminée par la survenue d'un seul de ces
    messages&nbsp;: CommandComplete, EmptyQueryResponse (si le portail a été
    créé à partir d'une chaîne de requête vide), ErrorResponse ou PortalSuspended.
   </para>

   <para>
    À la réalisation complète de chaque série de messages de requêtes étendues,
    le client doit lancer un message Sync. Ce message sans paramètre oblige
    le serveur à fermer la transaction courante si elle n'est pas à l'intérieur
    d'un bloc de transaction <command>begin</command>/<command>commit</command>
    (<quote>fermer</quote> signifiant valider en l'absence d'erreur ou annuler sinon).
    Une réponse ReadyForQuery est alors envoyée. Le but de Sync est de fournir
    un point de resynchronisation pour les récupérations d'erreurs. Quand une
    erreur est détectée lors du traitement d'un message de requête étendue, le
    serveur lance ErrorResponse, puis lit et annule les messages jusqu'à ce
    qu'un Sync soit atteint. Il envoie ensuite ReadyForQuery et retourne au
    traitement normal des messages. Aucun échappement n'est réalisé si une erreur
    est détectée <emphasis>lors</emphasis> du traitement de sync &mdash; l'unicité du
    ReadyForQuery envoyé pour chaque Sync est ainsi assurée.
   </para>

   <note>
    <para>
     Sync n'impose pas la fermeture d'un bloc de transactions ouvert avec
     <command>begin</command>. cette situation est détectable car le message
     ReadyForQuery inclut le statut de la transaction.
    </para>
   </note>

   <para>
    En plus de ces opérations fondamentales, requises, il y a plusieurs opérations
    optionnelles qui peuvent être utilisées avec le protocole de requête étendue.
   </para>

   <para>
    Le message Describe (variante de portail) spécifie le nom d'un portail
    existant (ou une chaîne vide pour le portail non nommé). La réponse est un
    message RowDescription décrivant les lignes qui seront renvoyées par
    l'exécution du portail&nbsp;; ou un message NoData si le portail ne contient
    pas de requête renvoyant des lignes&nbsp;; ou ErrorResponse le portail
    n'existe pas.
   </para>

   <para>
    Le message Describe (variante d'instruction) spécifie le nom d'une
    instruction préparée existante (ou une chaîne vide pour l'instruction
    préparée non nommée). La réponse est un message ParameterDescription
    décrivant les paramètres nécessaires à l'instruction, suivi d'un message
    RowDescription décrivant les lignes qui seront renvoyées lors de l'éventuelle
    exécution de l'instruction (ou un message NoData si l'instruction ne renvoie pas
    de lignes). ErrorResponse est retourné si l'instruction préparée n'existe
    pas. Comme Bind n'a pas encore été exécuté, les formats à utiliser
    pour les lignes retournées ne sont pas encore connues du serveur&nbsp;; dans
    ce cas, les champs du code de format dans le message RowDescription seront
    composés de zéros.
   </para>

   <tip>
    <para>
     Dans la plupart des scénarios, le client devra exécuter une des variantes de
     Describe avant de lancer Execute pour s'assurer qu'il sait interpréter
     les résultats reçus.
    </para>
   </tip>

   <para>
    Le message Close ferme une instruction préparée ou un portail et libère les
    ressources. L'exécution de Close sur une instruction ou un portail
    inexistant ne constitue pas une erreur. La réponse est en général
    CloseComplete mais peut être ErrorResponse si une difficulté quelconque est
    rencontrée lors de la libération des ressources. Clore une instruction
    préparée ferme implicitement  tout autre portail ouvert construit à partir
    de cette instruction.
   </para>

   <para>
    Le message Flush n'engendre pas de sortie spécifique, mais
    force le serveur à délivrer toute donnée restante dans les tampons de
    sortie. Un Flush doit être envoyé après toute commande de requête étendue,
    à l'exception de Sync, si le client souhaite examiner le résultat de cette
    commande avant de lancer d'autres commandes. Sans Flush, les messages
    retournés par le serveur seront combinés en un nombre minimum de paquets
    pour minimiser la charge réseau.
   </para>

   <note>
    <para>
     Le message Query simple est approximativement équivalent aux séries Parse,
     Bind, Describe sur un portail, Execute, Close, Sync utilisant les
     objets de l'instruction préparée ou du portail, non nommés et sans
     paramètres. Une différence est l'acceptation de plusieurs instructions SQL
     dans la chaîne de requêtes, la séquence bind/describe/execute étant
     automatiquement réalisée pour chacune, successivement. Il en diffère
     également en ne retournant pas les messages ParseComplete, BindComplete,
     CloseComplete ou NoData.
    </para>
   </note>
  </sect2>

  <sect2>
   <title>Appel de fonction</title>

   <para>
    Le sous-protocole d'appel de fonction (NDT&nbsp;: Function Call dans la
    version originale) permet au client d'effectuer un appel direct à toute
    fonction du catalogue système <structname>pg_proc</structname> de la base de
    données. Le client doit avoir le droit d'exécution de la fonction.
   </para>

   <note>
    <para>
     Le sous-protocole d'appel de fonction est une fonctionnalité qu'il vaudrait
     probablement mieux éviter dans tout nouveau code. Des résultats similaires
     peuvent être obtenus en initialisant une instruction préparée qui lance
     <literal>select function($1, ...)</literal>. le cycle de l'appel de fonction peut
     alors être remplacé par Bind/Execute.
    </para>
   </note>

   <para>
    Un cycle d'appel de fonction est initié par le client envoyant un message
    FunctionCall au serveur. Le serveur envoie alors un ou plusieurs messages de
    réponse en fonction des résultats de l'appel de la fonction et finalement un
    message de réponse ReadyForQuery. ReadyForQuery informe le client qu'il
    peut envoyer en toute sécurité une nouvelle requête ou un nouvel appel de
    fonction.
   </para>

   <para>
    Les messages de réponse possibles du serveur sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term>errorresponse</term>
      <listitem>
       <para>
        Une erreur est survenue.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>functioncallresponse</term>
      <listitem>
       <para>
        L'appel de la fonction est terminé et a retourné le résultat
        donné dans le message. Le protocole d'appel de fonction ne peut
        gérer qu'un résultat scalaire simple, pas un type ligne ou un
        ensemble de résultats.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>readyforquery</term>
      <listitem>
       <para>
        Le traitement de l'appel de fonction est terminé. ReadyForQuery sera
        toujours envoyé, que le traitement se termine avec succès ou avec une
        erreur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>noticeresponse</term>
      <listitem>
       <para>
        Un message d'avertissement relatif à l'appel de fonction a été retourné.
        Les avertissements sont complémentaires des autres réponses,
        c'est-à-dire que le serveur continuera à traiter la commande.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="protocol-copy">
   <title>Opérations copy</title>

   <para>
    La commande <command>copy</command> permet des transferts rapides de données en lot
    vers ou à partir du serveur. Les opérations Copy-in et Copy-out basculent
    chacune la connexion dans un sous-protocole distinct qui existe jusqu'à la
    fin de l'opération.
   </para>

   <para>
    Le mode Copy-in (transfert de données vers le serveur) est initié quand le
    serveur exécute une instruction SQL <command>copy from stdin</command>. le serveur
    envoie une message CopyInResponse au client. Le client peut alors envoyer
    zéro (ou plusieurs) message(s) CopyData, formant un flux de données en
    entrée (il n'est pas nécessaire que les limites du message aient un
    rapport avec les limites de la ligne, mais cela est souvent un choix
    raisonnable). Le client peut terminer le mode Copy-in en envoyant un
    message CopyDone (permettant une fin avec succès) ou un message CopyFail
    (qui causera l'échec de l'instruction SQL <command>copy</command> avec une erreur).
    Le serveur retourne alors au mode de traitement de la commande précédant le
    début de <command>copy</command>, protocole de requête simple ou étendu. il
    enverra enfin CommandComplete (en cas de succès) ou ErrorResponse (sinon).
   </para>

   <para>
    Si le serveur détecte un erreur en mode copy-in (ce qui inclut la
    réception d'un message CopyFail), il enverra un message ErrorResponse.
    Si la commande <command>copy</command> a été lancée à l'aide d'un message de
    requête étendue, le serveur annulera les messages du client jusqu'à
    ce qu'un message Sync soit reçu. Il enverra alors un message ReadyForQuery
    et retournera dans le mode de fonctionnement normal. Si la commande
    <command>copy</command> a été lancée dans un message
    simple Query, le reste de ce message est annulé et ReadyForQuery est envoyé.
    Dans tous les cas, les messages CopyData, CopyDone ou CopyFail suivants
    envoyés par l'interface seront simplement annulés.
   </para>

   <para>
    Le serveur ignorera les messages Flush et Sync reçus en mode copy-in. La
    réception de tout autre type de messages hors-copie constitue une
    erreur qui annulera l'état Copy-in, comme cela est décrit plus haut.
    L'exception pour Flush et Sync est faite pour les bibliothèques clientes
    qui envoient systématiquement Flush ou Sync après un message Execute sans
    vérifier si la commande à exécuter est <command>copy from stdin</command>.
   </para>

   <para>
    Le mode Copy-out (transfert de données à partir du serveur) est initié
    lorsque le serveur exécute une instruction SQL <command>copy to stdout</command>.
    Le moteur envoie un message CopyOutResponse au client suivi de zéro (ou
    plusieurs) message(s) CopyData (un par ligne), suivi de CopyDone.
    Le serveur retourne ensuite au mode de traitement de commande dans lequel il
    se trouvait avant le lancement de <command>copy</command> et envoie commandcomplete.
    Le client ne peut pas annuler le transfert (sauf en fermant la connexion ou en
    lançant une requête d'annulation, Cancel), mais il peut ignorer les messages
    CopyData et CopyDone non souhaités.
   </para>

   <para>
    Si le serveur détecte une erreur en mode Copy-out, il enverra un message
    ErrorResponse et retournera dans le mode de traitement normal. Le client
    devrait traiter la réception d'un message ErrorResponse comme terminant
    le mode <quote>copy-out</quote>.
   </para>

   <para>
    Il est possible que les messages NoticeResponse et ParameterStatus soient
    entremêlés avec des messages CopyData&nbsp;; les interfaces doivent gérer
    ce cas, et devraient être aussi préparées à d'autres types de messages
    asynchrones (voir <xref linkend="protocol-async"/>). Sinon, tout type
    de message autre que CopyData et CopyDone pourrait être traité comme
    terminant le mode copy-out.
   </para>

   <para>
    Il existe un autre mode relatif à Copy appelé Copy-both. Il permet
    un tansfert de données en flot à grande vitesse vers
    <emphasis>et</emphasis> à partir du serveur. Le mode Copy-both est
    initié quand un processus serveur en mode walsender exécute une
    instruction <command>START_REPLICATION</command>. Le processus
    serveur envoie un message CopyBothResponse au client. Le processus
    serveur et le client peuvent ensuite envoyer des messages CopyData
    jusqu'à ce que l'un des deux envoie un message CopyDone. Après que le client
    ait envoyé un message CopyDone, la connexion se transforme en mode copy-out,
    et le client ne peut plus envoyer des messages CopyData. De la même façon,
    quand le serveur envoie un message CopyDone, la connexion passe en mode
    copy-in et le serveur ne peut plus envoyer de messages CopyData. Une fois
    que les deux côtés ont envoyé un message CopyDone, le mode copie est terminé
    et le processus serveur retourne dans le mode de traitement des commandes.
    Si une erreur est détectée par le serveur pendant le mode copy-both, le
    processus serveur enverra un message ErrorResponse, ignorera les messages
    du client jusqu'à réception d'un message Sync message, puis enverra un
    message ReadyForQuery avant de continuer le traitement habituel. Le client
    doit traiter la réception d'un ErrorResponse comme une fin de la copie dans
    les deux sens&nbsp;; aucun CopyDone ne doit être envoyé dans ce cas. Voir
    <xref linkend="protocol-replication"/> pour plus d'informations sur le
    sous-protocole transmis pendant le mode copy-both.
   </para>

   <para>
    Les messages CopyInResponse, CopyOutResponse et CopyBothResponse
    incluent des champs qui informent le client du nombre de colonnes
    par ligne et les codes de format utilisés par chaque colonne. (Avec
    l'implémentation courante, toutes les colonnes d'une opération
    <command>COPY</command> donnée utiliseront le même format mais la
    conception du message ne le suppose pas.)
   </para>

  </sect2>

  <sect2 id="protocol-async">
   <title>Opérations asynchrones</title>

   <para>
    Il existe plusieurs cas pour lesquels le serveur enverra des messages qui ne
    sont pas spécifiquement demandés par le flux de commande du client. Les
    clients doivent être préparés à gérer ces messages à tout moment même si
    aucune requête n'est en cours. Vérifier ces cas avant de commencer à lire la
    réponse d'une requête est un minimum.
   </para>

   <para>
    Il est possible que des messages NoticeResponse soient engendrés en dehors de
    toute activité&nbsp;; par exemple, si l'administrateur de la base de données
    commande un arrêt <quote>rapide</quote> de la base de données, le serveur
    enverra un NoticeResponse l'indiquant avant de fermer la connexion. Les
    clients devraient toujours être prêts à accepter et afficher les messages
    NoticeResponse, même si la connexion est inactive.
   </para>

   <para>
    Des messages ParameterStatus seront engendrés à chaque fois que la valeur
    active d'un paramètre est modifiée, et cela pour tout paramètre que le
    serveur pense utile au client. Cela survient plus généralement en réponse à
    une commande SQL <command>set</command> exécutée par le client. ce cas est en fait
    synchrone &mdash; mais il est possible aussi que le changement de statut d'un
    paramètre survienne à la suite d'une modification par l'administrateur des
    fichiers de configuration&nbsp;; changements suivis de l'envoi du signal
    <systemitem>sighup</systemitem> au postmaster. de plus, si une commande set
    est annulée, un message ParameterStatus approprié sera engendré pour
    rapporter la valeur effective.
   </para>

   <para>
    À ce jour, il existe un certain nombre de paramètres codés en dur pour
    lesquels des messages ParameterStatus seront engendrés&nbsp;: on trouve
    <varname>server_version</varname>,
    <varname>server_encoding</varname>,
    <varname>client_encoding</varname>,
    <varname>application_name</varname>,
    <varname>is_superuser</varname>,
    <varname>session_authorization</varname> et
    <varname>session_authorization</varname>,
    <varname>DateStyle</varname>,
    <varname>IntervalStyle</varname>,
    <varname>TimeZone</varname> et
    <varname>integer_datetimes</varname>
    (<varname>server_encoding</varname>, <varname>timezone</varname> et
    <varname>integer_datetimes</varname> n'ont pas été reportés par les
    sorties avant la 8.0&nbsp;; <varname>standard_conforming_strings</varname>
    n'a pas été reporté par les sorties avant la 8.1&nbsp;;
    <varname>IntervalStyle</varname> n'a pas été reporté par les sorties
    avant la 8.4;
    <varname>application_name</varname> n'a pas été reporté par les sorties
    avant la 9.0.). Notez que
    <varname>server_version</varname>,
    <varname>server_encoding</varname> et
    <varname>integer_datetimes</varname> sont des pseudo-paramètres qui ne peuvent pas
    changer après le lancement.
    Cet ensemble pourrait changer dans le futur, voire devenir configurable.
    De toute façon, un client peut ignorer un message ParameterStatus
    pour les paramètres qu'il ne comprend pas ou qui ne le concernent pas.
   </para>

   <para>
    Si un client lance une commande <command>listen</command>, alors le serveur
    enverra un message NotificationResponse (à ne pas confondre avec
    NoticeResponse&nbsp;!) à chaque fois qu'une commande
    <command>notify</command> est exécutée pour le canal de même nom.
   </para>

   <note>
    <para>
     Actuellement, NotificationResponse ne peut être envoyé qu'à l'extérieur
     d'une transaction. Il ne surviendra donc pas au milieu d'une réponse à une
     commande, mais il peut survenir juste avant ReadyForQuery.
     Il est toutefois déconseillé de concevoir un client en partant de ce
     principe. La bonne pratique est d'être capable d'accepter
     NotificationResponse à tout moment du protocole.
    </para>
   </note>
  </sect2>

  <sect2>
   <title>Annulation de requêtes en cours</title>

   <para>
    Pendant le traitement d'une requête, le client peut demander
    l'annulation de la requête. La demande d'annulation n'est pas envoyée
    directement au serveur par la connexion ouverte pour des raisons
    d'efficacité de l'implémentation&nbsp;: il n'est pas admissible que le
    serveur vérifie constamment les messages émanant du client lors du
    traitement des requêtes. Les demandes d'annulation sont relativement
    inhabituelles&nbsp;; c'est pourquoi elles sont traitées de manière
    relativement simple afin d'éviter que ce traitement ne pénalise le
    fonctionnement normal.
   </para>

   <para>
    Pour effectuer une demande d'annulation, le client ouvre une nouvelle
    connexion au serveur et envoie un message CancelRequest à la place du
    message StartupMessage envoyé habituellement à l'ouverture d'une connexion.
    Le serveur traitera cette requête et fermera la connexion. Pour des raisons
    de sécurité, aucune réponse directe n'est faite au message de requête
    d'annulation.
   </para>

   <para>
    Un message CancelRequest sera ignoré sauf s'il contient la même donnée clé
    (PID et clé secrète) que celle passée au client lors du démarrage de la
    connexion. Si la donnée clé correspond, le traitement de la requête en cours
    est annulé (dans l'implantation existante, ceci est obtenu en envoyant un
    signal spécial au processus serveur qui traite la requête).
   </para>

   <para>
    Le signal d'annulation peut ou non être suivi d'effet &mdash; par exemple, s'il
    arrive après la fin du traitement de la requête par le serveur, il n'aura
    alors aucun effet. Si l'annulation est effective, il en résulte la fin
    précoce de la commande accompagnée d'un message d'erreur.
   </para>

   <para>
    De tout ceci, il ressort que, pour des raisons de sécurité et d'efficacité,
    le client n'a aucun moyen de savoir si la demande d'annulation a abouti.
    Il continuera d'attendre que le serveur réponde à la requête. Effectuer une
    annulation permet simplement d'augmenter la probabilité de voir la requête
    en cours finir rapidement et échouer accompagnée d'un message d'erreur
    plutôt que réussir.
   </para>

   <para>
    Comme la requête d'annulation est envoyée via une nouvelle connexion au
    serveur et non pas au travers du lien de communication client/serveur établi,
    il est possible que la requête d'annulation soit lancée par un processus
    quelconque, pas forcément celui du client pour lequel la requête doit être
    annulée. Cela peut fournir une flexibilité supplémentaire dans la
    construction d'applications multi-processus&nbsp;; mais également une faille
    de sécurité puisque des personnes non autorisées pourraient tenter d'annuler
    des requêtes. La faille de sécurité est comblée par l'exigence d'une clé
    secrète, engendrée dynamiquement, pour toute requête d'annulation.
   </para>
  </sect2>

  <sect2>
   <title>Fin</title>

   <para>
    Lors de la procédure normale de fin le client envoie un message Terminate et
    ferme immédiatement la connexion. À la réception de ce message, le
    serveur ferme la connexion et s'arrête.
   </para>

   <para>
    Dans de rares cas (tel un arrêt de la base de données par l'administrateur),
    le serveur peut se déconnecter sans demande du client. Dans de tels cas,
    le serveur tentera d'envoyer un message d'erreur ou d'avertissement en
    donnant la raison de la déconnexion avant de fermer la connexion.
   </para>

   <para>
    D'autres scénarios de fin peuvent être dus à différents cas d'échecs,
    tels qu'un <quote>core dump</quote> côté client ou serveur, la perte du lien
    de communications, la perte de synchronisation des limites du message, etc.
    Que le client ou le serveur s'aperçoive d'une fermeture de la connexion, le
    buffer sera vidé et le processus terminé. Le client a la possibilité de
    lancer un nouveau processus serveur en recontactant le serveur s'il ne
    souhaite pas se finir. Il peut également envisager de clore la
    connexion si un type de message non reconnu est reçu&nbsp;; en effet, ceci
    est probablement le résultat de la perte de synchronisation des limite de
    messages.
   </para>

   <para>
    Que la fin soit normale ou non, toute transaction ouverte est annulée, non
    pas validée. Si un client se déconnecte alors qu'une requête autre que
    <command>select</command> est en cours de traitement, le serveur terminera
    probablement la requête avant de prendre connaissance de la déconnexion.
    Si la requête est en dehors d'un bloc de transaction (séquence
    <command>begin</command> ... <command>commit</command>), il se peut que les résultats
    soient validés avant que la connexion ne soit reconnue.
   </para>
  </sect2>

  <sect2>
   <title>Chiffrement <acronym>ssl</acronym> de session</title>

   <para>
    Si <productname>postgresql</productname> a été construit avec le support de
    <acronym>ssl</acronym>, les communications client/serveur peuvent être chiffrées
    en l'utilisant. Ce chiffrement assure la sécurité de la communication
    dans les environnements où des agresseurs pourraient capturer le trafic
    de la session. Pour plus d'informations sur le cryptage des sessions
    <productname>postgresql</productname> avec <acronym>ssl</acronym>, voir
    <xref linkend="ssl-tcp"/>.
   </para>

   <para>
    Pour initier une connexion chiffrée par <acronym>ssl</acronym>, le client envoie
    initialement un message SSLRequest à la place d'un StartupMessage. Le
    serveur répond avec un seul octet contenant <literal>s</literal> ou <literal>n</literal>
    indiquant respectivement s'il souhaite ou non utiliser le <acronym>ssl</acronym>.
    Le client peut alors clore la connexion s'il n'est pas satisfait de la
    réponse. Pour continuer après un <literal>s</literal>, il faut échanger une poignée
    de main <acronym>ssl</acronym> (handshake) (non décrite ici car faisant partie de
    la spécification <acronym>ssl</acronym>) avec le serveur. en cas de succès, le
    StartupMessage habituel est envoyé. Dans ce cas, StartupMessage et toutes
    les données suivantes seront chiffrées avec <acronym>ssl</acronym>. pour continuer
    après un <literal>n</literal>, il suffit d'envoyer le startupmessage habituel et
    de continuer sans chiffrage.
   </para>

   <para>
    Le client doit être préparé à gérer une réponse ErrorMessage à un SSLRequest
    émanant du serveur. Ceci ne peut survenir que si le serveur ne dispose pas
    du support de <acronym>ssl</acronym>. (De tels servers sont maintenant
    très anciens, et ne doivent certainement plus exister.) Dans ce cas, la
    connexion doit être fermée, mais le client peut choisir d'ouvrir une
    nouvelle connexion et procéder sans <acronym>ssl</acronym>.
   </para>

   <para>
    Un SSLRequest initial peut également être utilisé dans une connexion en
    cours d'ouverture pour envoyer un message CancelRequest.
   </para>

   <para>
    Alors que le protocole lui-même ne fournit pas au serveur de moyen de
    forcer le chiffrage <acronym>ssl</acronym>, l'administrateur peut configurer le
    serveur pour rejeter les sessions non chiffrées, ce qui est une autre
    façon de vérifier l'authentification.
   </para>
  </sect2>

  <sect2>
   <title>Chiffrement <acronym>GSSAPI</acronym> de la session</title>

   <para>
    Si <productname>PostgreSQL</productname> a été compilé avec le support
    de <acronym>GSSAPI</acronym>, les communications client/serveur
    peuvent être chiffrées en utilisant <acronym>GSSAPI</acronym>.
    Cela fournit une sécurité des communications dans des environnements
    où des attaquants pourraient être capables de capturer le trafic
    de session. Pour plus d'information sur le chiffrement des
    sessions <productname>PostgreSQL</productname> avec
    <acronym>GSSAPI</acronym>, voir <xref linkend="gssapi-enc"/>.
   </para>

   <para>
    Pour initier une connexion chiffrée avec <acronym>GSSAPI</acronym>,
    le client envoie initialement un message GSSENCRequest plutôt
    qu'un StartupMessage. Le serveur répond alors avec un seul octet
    contenant <literal>G</literal> ou <literal>N</literal>, indiquant
    respectivement qu'il est d'accord ou non pour mettre en oeuvre
    un chiffrement <acronym>GSSAPI</acronym>.
    Le client peut à ce moment fermer la connexion s'il n'est pas satisfait
    de la réponse.  Pour continuer après <literal>G</literal>,
    en utilisant les appels en C de GSSAPI tel que mentionnés dans la
    RFC2744 ou équivalent, il faut faire une initialisation <acronym>GSSAPI</acronym>
    en appelant <function>gss_init_sec_context()</function> en boucle, avec un
    premier paramètre vide, puis avec le résultat du serveur, jusqu'à ce que
    ce dernier ne renvoie plus de résultat.

    L'envoi des résultats de <function>gss_init_sec_context()</function>
    au serveur doit être préfixé par la longueur du message, exprimée en un entier de
    quatre octets dans l'ordre du réseau. Après le succès de l'initialisation,
    utiliser <function>gss_wrap()</function> pour chiffrer le
    StartupMessage normal et toutes les données qui suivent, toujours
    préfixées par leur longueur exprimée en entier de quatre octets
    dans l'ordre du réseau.
    Il est à noter que le serveur acceptera uniquement du client des
    paquets chiffrés dont la longueur est inférieure à 16&nbsp;Ko;
    <function>gss_wrap_size_limit()</function> devrait être utilisée
    par le client pour déterminer quelle taille de message non chiffré
    n'excède pas cette limite, et découper les messages plus grands
    pour les passer en plusieurs appels à
    <function>gss_wrap()</function>.

    La taille typique des segments non chiffrées est de 8&nbsp;Ko, donnant des paquets
    chiffrés légèrement plus grands que 8&nbsp;Ko mais bien en-dessous du maximum de
    16&nbsp;Ko.
    Le serveur n'est pas censé envoyer des paquets chiffrés plus grands que 16&nbsp;Ko
    au client. Pour continuer après la réception du <literal>N</literal>,
    envoyer le StartupMessage usuel et continuer sans chiffrement.
   </para>

   <para>
    La partie cliente doit aussi être prête à gérer une réponse ErrorMessage
    du serveur à GSSENCRequest. Elle peut se produire uniquement si le
    serveur date d'avant le support du chiffrement <acronym>GSSAPI</acronym>
    dans <productname>PostgreSQL</productname>. Dans ce cas la connexion
    doit être fermée, mais le client peut choisir d'ouvrir une nouvelle
    connexion et continuer sans demander le chiffrement <acronym>GSSAPI</acronym>.
    Etant donné les limites de tailles spécifiées ci-dessus, la réponse
    ErrorMessage ne peut être confondue avec une réponse correcte du serveur
    d'une longueur appropriée.
   </para>

   <para>
    Un GSSENCRequest initial peut aussi être utilisé dans une connexion en
    train d'être ouverte pour envoyer un message CancelRequest.
   </para>

   <para>
    Bien que le protocole lui-même n'offre pas de moyen pour le serveur
    de forcer le chiffrement <acronym>GSSAPI</acronym>, l'administrateur
    peut configurer le serveur pour rejeter les sessions non chiffrées
    via le contrôle d'authentification.
   </para>
  </sect2>
</sect1>

<sect1 id="protocol-logical-replication">
 <title>Protocole de réplication logique en flux</title>

 <para>
  Cette section décrit le protocole de réplication logique, qui correspond au
  flot de messages lancé par la commande de réplication
  <literal>START_REPLICATION</literal> <literal>SLOT</literal> <replaceable
  class="parameter">nom_slot</replaceable> <literal>LOGICAL</literal>.
 </para>

 <para>
  Le protocole de réplication logique en flux est construit sur les primitives
  du protocole de réplication physique en flux.
 </para>

 <sect2 id="protocol-logical-replication-params">
  <title>Paramètres de la réplication logique en flux</title>

  <para>
   La commande <literal>START_REPLICATION</literal> de réplication logique
   accepte les paramètres suivants&nbsp;:

   <variablelist>
    <varlistentry>
     <term>
      proto_version
     </term>
     <listitem>
      <para>
       Version du protocole. Actuellement, seule la version <literal>1</literal>
       est supportée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      publication_names
     </term>
     <listitem>
      <para>
       Liste de noms de publications, séparés par des virgules, pour
       souscription (récupération des modifications). Les noms de publication
       individuels sont traités comme des noms d'objet standard et peuvent
       être mis entre guillemets si nécessaire.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </para>
 </sect2>

 <sect2 id="protocol-logical-messages">
  <title>Messages du protocole de réplication logique</title>

  <para>
   Les messages individuels du protocole de réplication sont discutés dans les
   sous-sections suivantes. Les messages individuels sont décrits dans <xref
   linkend="protocol-logicalrep-message-formats"/>.
  </para>

  <para>
   Tous les messages de niveau supérieur commencent avec un octet de type de
   message. Bien qu'ils soient représentés dans le code comme un caractère, il
   s'agit d'un octet signé sans encodage associé.
  </para>

  <para>
   Comme le protocole de réplication en flux fournit une longueur de message,
   il n'est pas nécessaire que les messages de niveau supérieur embarquent une
   longueur dans leur en-tête.
  </para>

 </sect2>

 <sect2 id="protocol-logical-messages-flow">
  <title>Flot des messages du protocole de réplication logique</title>

  <para>
   À l'exception de la commande <literal>START_REPLICATION</literal> et des
   messages de progression du rejeu, toutes les informations passent du
   serveur vers le client.
  </para>

  <para>
   Le protocole de réplication logique envoie les transactions individuelles
   une par une. Cela signifie que tous les messages entre une paire de
   messages Begin et Commit appartiennent à la même transaction.
  </para>

  <para>
   Chaque transaction envoyée contient zéro ou plusieurs messages DML (Insert,
   Update, Delete). Dans le cas d'une configuration en cascade, elle peut
   aussi contenir des messages Origin. Le message d'origine indiquait que la
   transaction avait pour origine un noeud de réplication différent. Comme le
   noeud de réplication dans le cas d'une réplication logique peut provenir de
   n'importe où, le seul identificateur est le nom de l'origine. C'est de la
   responsabilité du receveur de gérer cette information si nécessaire. Le
   message Origin est toujours envoyé avant tout message DML dans la
   transaction.
  </para>

  <para>
   Chaque message DML contient un identifiant arbitraire de relation qui peut
   être mis en relation avec un identifiant dans les messages Relation. Les
   messages Relation décrivent le schéma de la relation donnée. Le message
   Relation est envoyé pour une certaine relation soit parce que c'est la
   première fois qu'un message DML est envoyé pour cette relation dans la
   session courante soit parce que la définition de la relation a changé
   depuis le dernier message Relation. Le protocole suppose que le client est
   capable de mettre en cache les méta-données pour autant de relations que
   nécessaire.
  </para>
 </sect2>
</sect1>

 <sect1 id="protocol-message-types">
  <title>Types de données des messages</title>

  <para>
   Cette section décrit les types de données basiques utilisés dans les messages.

   <variablelist>

    <varlistentry>
     <term>
      Int<replaceable>n</replaceable>(<replaceable>i</replaceable>)
     </term>
     <listitem>
      <para>
       Un entier sur <replaceable>n</replaceable> bits dans l'ordre des
       octets réseau (octet le plus significatif en premier). Si
       <replaceable>i</replaceable> est spécifié, c'est exactement
       la valeur qui apparaîtra, sinon la valeur est
       variable, par exemple Int16, Int32(42).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      Int<replaceable>n</replaceable>[<replaceable>k</replaceable>]
     </term>
     <listitem>
      <para>
       Un tableau de <replaceable>k</replaceable> entiers sur
       <replaceable>n</replaceable> bits, tous dans l'ordre des octets
       réseau. La longueur <replaceable>k</replaceable> du tableau est
       toujours déterminée par un champ précédent du message, par
       exemple, Int16[M].
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      String(<replaceable>s</replaceable>)
     </term>
     <listitem>
      <para>
       Une chaîne terminée par un octet nul (chaîne style C). Il n'y
       a pas de limitation sur la longueur des chaînes. Si
       <replaceable>s</replaceable> est spécifié, c'est la valeur exacte
       qui apparaîtra, sinon la valeur est variable. Par exemple,
       String("utilisateur").
      </para>

      <note>
       <para>
        <emphasis>Il n'y a aucune limite prédéfinie</emphasis> à la longueur d'une
        chaîne retournée par le serveur. Une bonne stratégie de codage
        de client consiste à utiliser un tampon dont la taille peut croître pour que
        tout ce qui tient en mémoire puisse être accepté. Si cela n'est pas
        faisable, il faudra lire la chaîne complète et supprimer les caractères
        qui ne tiennent pas dans le tampon de taille fixe.
       </para>
      </note>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      Byte<replaceable>n</replaceable>(<replaceable>c</replaceable>)
     </term>
     <listitem>
      <para>
       Exactement <replaceable>n</replaceable> octets. si la largeur
       <replaceable>n</replaceable> du champ n'est pas une constante,
       elle peut toujours être déterminée à partir d'un champ précédent
       du message. Si <replaceable>c</replaceable> est spécifié, c'est
       la valeur exacte. Par exemple, Byte2, Byte1('\n').
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>

 </sect1>

<sect1 id="sasl-authentication">
<title>Authentification SASL</title>

<para>
<firstterm>SASL</firstterm> est un framework pour l'authentification dans les
protocoles orientés connexion. Actuellement,
<productname>PostgreSQL</productname> implémente seulement le mécanisme
d'authentification SASL, SCRAM-SHA-256 et SCRAM-SHA-256-PLUS, mais d'autres pourraient être ajoutées
dans le futur. Les étapes suivantes illustrent comment l'authentification SASL
est réalisée en général, alors que la sous-section suivant donne plus de
détails sur SCRAM-SHA-256 et SCRAM-SHA-256-PLUS.
</para>

<procedure>
<title>Flux de message d'authentification SASL</title>

<step id="sasl-auth-begin">
<para>  
  Pour commencer un échange d'authentification SASL, le serveur envoie un
  message AuthenticationSASL. Il inclut une liste de mécanismes
  d'authentification SASL que le serveur accepte, dans l'ordre de préférence
  du serveur.
</para>
</step>

<step id="sasl-auth-initial-response">
<para>
  Le client sélectionne un des mécanismes supportés dans la liste, et envoie
  un message SASLInitialResponse au serveur. Le message inclut le nom du
  mécanisme sélectionné, et un message Initial Client Response optionnel, si
  le mécanisme sélection l'utilise.
</para>
</step>

<step id="sasl-auth-continue">
<para>
  Un ou plusieurs messages question-serveur et réponse-client suivent. Chaque
  question du serveur est envoyée dans un message AuthenticationSASLContinue,
  suivie d'une réponse du client dans un message SASLResponse. Les
  particularités des messages sont spécifiques au mécanisme.
</para>
</step>

<step id="sasl-auth-end">
<para>
  Enfin, quand l'échange d'authentification se termine avec succès, le serveur
  envoie un message AuthenticationSASLFinal, suivi immédiatement d'un message
  AuthenticationOk. Le message AuthenticationSASLFinal contient des données
  supplémentaires du serveur pour le client, dont le contenu est spécifique au
  mécanisme d'authentification sélectionné. Si le mécanisme d'authentification
  n'utilise pas de données supplémentaires en fin d'authentification, le
  message AuthenticationSASLFinal n'est pas envoyé.
</para>
</step>
</procedure>

<para>
En cas d'erreur, le serveur peut annuler l'authentification à tout moment, et
peut envoyer un message ErrorMessage.
</para>

 <sect2 id="sasl-scram-sha256">
  <title>Authentification SCRAM-SHA-256</title>

  <para>
   Les mécanismes SASL implémentés pour le moment sont
   <literal>SCRAM-SHA-256</literal> et sa variante avec le <literal>channel
   binding</literal> <literal>SCRAM-SHA-256-PLUS</literal>. Ils sont décrits
   en détail dans les RFC 7677 et RFC 5802.
  </para>

  <para>
   Quand SCRAM-SHA-256 est utilisé dans PostgreSQL, le serveur ignorera le nom
   d'utilisateur que le client envoie dans le <structname>premier-message-
   client</structname>. Le nom d'utilisateur déjà envoyé dans le message de
   démarrage est utilisé à la place. <productname>PostgreSQL</productname>
   supporte plusieurs encodages de caractères alors que SCRAM requiert
   l'utilisation d'UTF-8 pour le nom de l'utilisateur.
  </para>

  <para>
   La spécification SCRAM requiert que le mot de passe soit aussi en UTF-8, et
   est traité avec l'algorithme <firstterm>SASLprep</firstterm>. Néanmoins,
   <productname>PostgreSQL</productname> ne requiert pas que UTF-8 soit
   utilisé pour le mot de passe. Lors de la configuration du mot de passe d'un
   utilisateur, ce mot de passe est traité avec SASLprep comme s'il était en
   UTF-8, quelque soit l'encodage réellement utilisé. Néanmoins, s'il ne
   s'agit pas d'une séquence UTF-8 légale d'octets ou s'il contient des
   séquences d'octets UTF-8 interdites par l'algorithme SASLprep, le mot de
   passe brut sera utilisé sans traitement par SASLprep, plutôt que de
   renvoyer une erreur. Ceci permet la normalisation du mot de passe quand ce
   dernier est en UTF-8 mais autorise aussi l'utilisation d'un mot de passe
   qui n'est pas en UTF-8 et ne nécessite pas que le système connaisse
   l'encodage utilisé par le mot de passe.
  </para>

  <para>
  La liaison de canal sécurisé (<firstterm>Channel binding</firstterm>) est
  prise en charge lorsque <productname>PostgreSQL</productname> est construit
  avec prise en charge <literal>SSL/TLS</literal>.
  Le nom du mécanisme SASL pour SCRAM avec liaison de canal est
  <literal>SCRAM-SHA-256-PLUS</literal>. Le type de liaison de canal utilisé
  par <productname>PostgreSQL</productname> est <literal>tls-server-end-point</literal>.
  </para>

  <para>
  Quand <acronym>SCRAM</acronym> est utilisé sans liaison de canal sécurisé
  <literal>(SSL/TLS)</literal>, le serveur choisit un nombre aléatoire qui est
  transmis au client pour être mélangé avec le mot de passe fourni par
  l'utilisateur dans le hachage du mot de passe transmis. Bien que cela empêche
  que le mot de passe haché puisse être retransmis avec succès dans une session
  ultérieure, cela n'empêche pas un faux serveur entre le serveur réel et le
  client de passer par la valeur aléatoire du serveur et de s'authentifier avec
  succès (attaque de l'homme du milieu (HDM)).
  </para>

  <para>
   L'utilisation de <acronym>SCRAM</acronym> avec liaison de canaux sécurisé
   empêche de telles attaques de l'homme du milieu (HDM) en mélangeant la
   signature du certificat du serveur dans le hachage du mot de passe transmis.
   Bien qu'un faux serveur puisse retransmettre le certificat du serveur réel,
   n'ayant pas d'accès à la clé privée correspondante au certificat, il ne
   pourra pas donc pas prouver qu'il en est le propriétaire provoquant ainsi
   l'échec de la connexion <literal>SSL/TLS</literal>.
  </para>

  <procedure>
   <title>Exemple</title>

   <step id="scram-begin">
    <para>
     Le serveur envoie un message AuthenticationSASL. Il inclut une liste de
     mécanismes d'authentification SASL que le serveur peut accepter.
     Cette liste contient <literal>SCRAM-SHA-256-PLUS</literal> et
     <literal>SCRAM-SHA-256</literal> si le serveur est construit avec le support du
     SSL ou juste <literal>SCRAM-SHA-256</literal> dans le cas contraire.
    </para>
   </step>

   <step id="scram-client-first">
    <para>
     Le client répond en envoyant un message SASLInitialResponse indiquant le
     mécanisme choisi, <literal>SCRAM-SHA-256</literal> ou
     <literal>SCRAM-SHA-256-PLUS</literal>. (Un client est libre de choisir l'un
     ou l'autre mécanisme, mais pour une meilleure sécurité, il devrait choisir
     la variante <literal>channel-binding</literal> s'il le supporte.). Dans le
     champ de  réponse <literal>Initial Client</literal>, le message contient le
     <structname>client-first-message</structname> (premier-message-client) SCRAM.
     Le <structname>client-first-message</structname> contient également le
     type de <literal>channel-binding</literal> choisi par le client.
    </para>
   </step>

   <step id="scram-server-first">
    <para>
     Le serveur envoie un message AuthenticationSASLContinue, avec un
     <structname>server-first message</structname> SCRAM comme contenu.
    </para>
   </step>

   <step id="scram-client-final">
    <para>
     Le client envoie un message SASLResponse, avec
     <structname>client-final-message</structname> SCRAM comme contenu.
    </para>
   </step>

   <step id="scram-server-final">
    <para>
     Le serveur envoie un message AuthenticationSASLFinal, avec
     <structname>server-final-message</structname> SCRAM, immédiatement
     suivi d'un message AuthenticationOk.
    </para>
   </step>
  </procedure>
 </sect2>
 </sect1>

 <sect1 id="protocol-replication">
  <title>Protocole de réplication en continu</title>

  <para>
   Pour initier la réplication en flux continu, le client envoie le paramètre
   <literal>replication</literal> dans son message d'ouverture. Une valeur
   booléenne <literal>true</literal> (ou <literal>on</literal>,
   <literal>yes</literal>, <literal>1</literal>) indique au processus serveur
   de basculer en mode walsender pour la réplication physique, où un petit
   ensemble de commandes de réplication, montré ci-dessous, peut être exécuté
   à la place de requêtes SQL. Seul le protocole simple de requêtes peut être
   utilisé dans le mode walsender.
  </para>

  <para>
    En passant <literal>database</literal> comme valeur du paramètre
    <literal>replication</literal>, on demande au backend de passer en mode
    walsender pour la réplication logique lors de la connexion à la base spécifiée
    dans le paramètre <literal>dbname</literal>. En mode walsender pour la
    réplication logique, les commandes de réplication montrées ci-dessous
    ainsi que les commandes SQL normales peuvent être utilisées.
  </para>

  <para>
   En mode <literal>walsender</literal> pour la réplication physique ou pour la
   réplication logique, seul le protocole d'interrogation simple peut être utilisé.
  </para>

  <para>
   Pour tester les commandes de réplication, vous pouvez réaliser une connexion
   de réplication via <application>psql</application> ou tout autre outil utilisant
   <literal>libpq</literal> avec une chaîne de connexion utilisant l'option
   <literal>replication</literal>, par exemple&nbsp;:
   <programlisting>
psql "dbname=postgres replication=database" -c "IDENTIFY_SYSTEM;"
   </programlisting>
   Néanmoins, il est souvent plus utile d'utiliser
   <xref linkend="app-pgreceivewal"/> (pour la réplication physique) ou
   <xref linkend="app-pgrecvlogical"/> (pour la réplication logique).
  </para>

  <para>
   Les commandes de réplication sont enregistrées dans le journal du serveur
   lorsque <xref linkend="guc-log-replication-commands"/> est activé.
  </para>

  <para>
   Les commandes acceptées en mode réplication sont:

   <variablelist>
    <varlistentry>
     <term><literal>IDENTIFY_SYSTEM</literal>
     <indexterm><primary>IDENTIFY_SYSTEM</primary></indexterm></term>
     <listitem>
      <para>
       Demande au serveur de s'identifier. Le serveur répond avec un set de
       résultat d'une seule ligne contenant quatre champs:
      </para>

      <para>
       <variablelist>
        <varlistentry>
         <term>
          <literal>systemid</literal> (<type>text</type>)
         </term>
         <listitem>
          <para>
           L'identifiant système unique du cluster. Il peut être utilisé pour
           vérifier que la base de sauvegarde utilisée pour initialiser le serveur
           en attente provient du même cluster.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term>
          <literal>timeline</literal> (<type>int4</type>)
         </term>
         <listitem>
          <para>
           Timeline ID courant. Tout aussi utile pour vérifier que le serveur en
           attente est consistant avec le maître.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term>
          <literal>xlogpos</literal> (<type>text</type>)
         </term>
         <listitem>
          <para>
           Emplacement de vidage courant des journaux de transactions. Utile
           pour connaître un emplacement dans les journaux de transactions à
           partir duquel le mode de réplication en flux peut commencer.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term>
          <literal>dbname</literal> (<type>text</type>)
         </term>
         <listitem>
          <para>
           Base de données connectée ou NULL.
          </para>
         </listitem>
        </varlistentry>

       </variablelist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
    <term><literal>SHOW</literal> <replaceable class="parameter">nom</replaceable>
     <indexterm><primary>SHOW</primary></indexterm>
    </term>
    <listitem>
     <para>
      Demande au serveur d'envoyer la valeur actuelle d'un paramètre. Elle est
      identique à la commande SQL <xref linkend="sql-show"/>.
     </para>

     <variablelist>
      <varlistentry>
       <term><replaceable class="parameter">nom</replaceable></term>
       <listitem>
         <para>
          Le nom d'un paramètre. Les paramètres disponibles sont documentés
          dans <xref linkend="runtime-config"/>.
         </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry>
     <term><literal>TIMELINE_HISTORY</literal> <replaceable class="parameter">tli</replaceable>
      <indexterm><primary>TIMELINE_HISTORY</primary></indexterm>
     </term>
     <listitem>
      <para>
       Demande au serveur l'envoi du fichier historique de la ligne de temps
       <replaceable class="parameter">tli</replaceable>. Le serveur répond avec
       un résultat sur une seule ligne, contenant deux champs&nbsp;:
      </para>

      <para>
       <variablelist>
        <varlistentry>
         <term>
          <literal>filename</literal> (<type>text</type>)
         </term>
         <listitem>
          <para>
           Nom du fichier de l'historique de la ligne de temps, par exemple
           <filename>00000002.history</filename>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term>
          <literal>content</literal> (<type>bytea</type>)
         </term>
         <listitem>
          <para>
           Contenu du fichier historique de la ligne de temps.
          </para>
         </listitem>
        </varlistentry>

       </variablelist>
      </para>
     </listitem>
    </varlistentry>

  <varlistentry id="protocol-replication-create-slot" xreflabel="CREATE_REPLICATION_SLOT">
   <term><literal>CREATE_REPLICATION_SLOT</literal> <replaceable class="parameter">slot_name</replaceable> [ <literal>TEMPORARY</literal> ] { <literal>PHYSICAL</literal> [ <literal>RESERVE_WAL</literal> ] | <literal>LOGICAL</literal> <replaceable class="parameter">output_plugin</replaceable> [ <literal>EXPORT_SNAPSHOT</literal> | <literal>NOEXPORT_SNAPSHOT</literal> | <literal>USE_SNAPSHOT</literal> ] }
      <indexterm><primary>CREATE_REPLICATION_SLOT</primary></indexterm>
     </term>
     <listitem>
      <para>
       Crée un slot de réplication physique ou logique. Voir <xref
       linkend="streaming-replication-slots"/> pour plus d'informations sur les
       slots de réplication.
      </para>
      <variablelist>
       <varlistentry>
        <term><replaceable class="parameter">nom_slot</replaceable></term>
        <listitem>
         <para>
          Le nom du slot à créer. Doit être un nom d'un slot de réplication
          valide (voir <xref linkend="streaming-replication-slots-manipulation"/>).
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><replaceable class="parameter">output_plugin</replaceable></term>
        <listitem>
         <para>
          Le nom d'un plugin en sortie utilisé pour le décodage logique
          (voir <xref linkend="logicaldecoding-output-plugin"/>).
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
       <term><literal>TEMPORARY</literal></term>
       <listitem>
        <para>
         Précise que ce slot de réplication est temporaire. Les slots
         temporaires ne sont pas sauvegardés sur disque, et sont
         automatiquement supprimés en cas d'erreur ou quand la session est
         terminé.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>RESERVE_WAL</literal></term>
        <listitem>
         <para>
          Spécifie que le slot de réplication physique réserve les
          <acronym>WAL</acronym> immédiatement. Dans le cas contraire, les
          <acronym>WAL</acronym> sont seulement conservés à partir de la
          connexion d'un client de réplication en flux.
         </para>
        </listitem>
       </varlistentry>

      <varlistentry>
       <term><literal>EXPORT_SNAPSHOT</literal></term>
       <term><literal>NOEXPORT_SNAPSHOT</literal></term>
       <term><literal>USE_SNAPSHOT</literal></term>
       <listitem>
        <para>
         Décide quoi faire du snapshot créé lors de l'initialisation du slot
         de réplication. <literal>EXPORT_SNAPSHOT</literal>, qui est le
         défaut, exportera le snapshot à utiliser dans les autres sessions.
         Cette option ne peut pas être utilisée dans une transaction.
         <literal>USE_SNAPSHOT</literal> utiliser le snapshot pour la
         transaction exécutant la commande. Cette option doit être utilisée
         dans une transaction, et <literal>CREATE_REPLICATION_SLOT</literal>
         doit être la première commande exécutée dans cette transaction.
         Enfin, <literal>NOEXPORT_SNAPSHOT</literal> utilisera seulement le
         snapshot pour le décodage logique, mais ne fera rien de plus avec.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      En réponse à cette commande, le serveur enverra un résultat sur une
      seule ligne contenant les champs suivants&nbsp;:

      <variablelist>
       <varlistentry>
        <term><literal>slot_name</literal> (<type>text</type>)</term>
        <listitem>
         <para>
          Le nom du nouveau slot de réplication.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>consistent_point</literal> (<type>text</type>)</term>
        <listitem>
         <para>
          L'emplacement dans les journaux à partir duquel le slot devient
          cohérent. C'est l'emplacement le plus proche à partir duquel la
          réplication en flux peut commencer sur ce slot de réplication.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>snapshot_name</literal> (<type>text</type>)</term>
        <listitem>
         <para>
          L'identifiant du snapshot exporté par la commande. Le snapshot est
          valide jusqu'à l'exécution d'une nouvelle commande sur cette
          connexion ou jusqu'à la fermeture d'une connexion de réplication.
          NULL si le slot créé est physique.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>output_plugin</literal> (<type>text</type>)</term>
        <listitem>
         <para>
          Le nom du plugin de sortie utilisé par le nouveau slot de
          réplication. NULL si le slot créé est physique.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>START_REPLICATION</literal> [ <literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable> ] [ <literal>PHYSICAL</literal> ] <replaceable class="parameter">XXX/XXX</replaceable> [ <literal>TIMELINE</literal> <replaceable class="parameter">tli</replaceable> ]
      <indexterm><primary>START_REPLICATION</primary></indexterm>
     </term>
     <listitem>
      <para>
       Demande au serveur de débuter l'envoi de WAL en continu, en commençant
       à la position <replaceable class="parameter">XXX/XXX</replaceable> dans
       le WAL. Si l'option <literal>TIMELINE</literal> est spécifiée, le flux
       commence sur la timeline <replaceable class="parameter">tli</replaceable>.
       Dans le cas contraire, la timeline actuelle du serveur est utilisée.
       Le serveur peut répondre avec une erreur, par exemple si la section de
       WAL demandée a déjà été recyclée. En cas de succès, le serveur
       répond avec un message CopyBothResponse et débute l'envoi en continu de
       WAL au client.
      </para>

      <para>
       Si un nom de slot est fourni via <replaceable
       class="parameter">nom_slot</replaceable>, il sera mis à jour au fur et
       à mesure de la progression de la réplication pour que le serveur maître
       connaisse les segments WAL qui sont toujours nécessaires au serveur
       standby. Si <varname>hot_standby_feedback</varname> est activé, la
       granularité est au niveau de chaque transaction.
      </para>

      <para>
       Si le client demande une timeline qui ne correspond pas à la dernière
       mais qui fait néanmoins partie de l'historique du serveur,
       le serveur va envoyer tous les journaux de transactions en commençant à
       partir de point de démarrage demandé sur cette timeline, jusqu'à
       arriver au moment où le serveur a changé de nouveau de timeline. Si
       le client réclame l'envoi à partir de la fin de l'ancienne timeline, le
       serveur répond immédiatement avec CommandComplete sans entrer
       en mode <literal>COPY</literal>.
      </para>

      <para>
       Après l'envoi de tous les journaux de transactions d'une timeline
       qui n'est pas la dernière, le serveur arrêtera le flux en quittant le mode
       COPY. Quand le client accepte ceci en quittant lui aussi le mode COPY, le
       serveur envoie un ensemble de résultats comprenant une ligne et deux colonnes,
       indiquant la prochaine timeline dans l'histoire de ce serveur. La première
       colonne est l'identifiant de la prochaine timeline  (type <type>int8</type>)
       et la deuxième colonne est la position XLOG où la bascule a eu lieu (type
       <type>text</type>). Généralement, la position de
       la bascule correspond à la fin du journal de transactions qui a été envoyé
       mais, il existe des cas particuliers où le serveur peut envoyer quelques
       enregistrements de journaux à partir de l'ancienne timeline qu'il n'a pas
       encore rejoué avant la promotion. Enfin, le serveur envoie la commande
       CommandComplete message, et est prêt à accepter une nouvelle commande.
      </para>

      <para>
       Les données des WAL sont envoyées en une série de messages <literal>CopyData</literal>
       (ce qui permet d'envoyer d'autres informations dans les intervalles&nbsp;;
       en particulier un serveur peut envoyer un message
       <literal>ErrorResponse</literal> s'il rencontre une erreur après le début
       de l'envoi en continu des données).
       Le contenu de chaque message <literal>CopyData</literal> à partir du
       serveur vers le client contient un message faisant partie d'un des formats
       suivants&nbsp;:
      </para>

      <para>
       <variablelist>
        <varlistentry>
         <term>
          XLogData (B)
         </term>
         <listitem>
          <para>
           <variablelist>
            <varlistentry>
             <term>
              Byte1('w')
             </term>
             <listitem>
              <para>
               Identifie le message comme une donnée de WAL.
              </para>
             </listitem>
            </varlistentry>
            <varlistentry>
             <term>
              Int64
             </term>
             <listitem>
              <para>
               Le point de départ de la donnée du WAL dans ce message.
              </para>
             </listitem>
            </varlistentry>
            <varlistentry>
             <term>
              Int64
             </term>
             <listitem>
              <para>
               Le fin courante du WAL sur le serveur.
              </para>
             </listitem>
            </varlistentry>
            <varlistentry>
             <term>
              Int64
             </term>
             <listitem>
              <para>
               L'horloge système du serveur à l'heure de la transmission, en
               microsecondes à partir du 1er janvier 2000, à minuit.
              </para>
             </listitem>
            </varlistentry>
            <varlistentry>
             <term>
              Byte<replaceable>n</replaceable>
             </term>
             <listitem>
              <para>
               Une section de donnée du flux de WAL.
              </para>
              <para>
               Un enregistrement d'un journal de transactions n'est jamais divisé en
               deux messages <literal>XLogData</literal>. Quand un enregistrement dépasse la limite d'une
               page d'un journal de transactions, et est de ce fait déjà divisé en
               utilisant les enregistrements de suivi, il peut être divisé sur la
               limite de la page. En d'autres termes, le premier enregistrement
               principal d'un journal de transactions et ses enregistrements de suivi
               peuvent être envoyés sur différents messages <literal>XLogData</literal>.
              </para>
             </listitem>
            </varlistentry>
           </variablelist>
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>
          Message principal de keepalive (B)
         </term>
         <listitem>
          <para>
           <variablelist>
            <varlistentry>
             <term>
              Byte1('k')
             </term>
             <listitem>
              <para>
               Identifie le message comme un keepalive émis.
              </para>
             </listitem>
            </varlistentry>
            <varlistentry>
             <term>
              Int64
             </term>
             <listitem>
              <para>
               La fin actuelle du journal de transactions sur le serveur.
              </para>
             </listitem>
            </varlistentry>
            <varlistentry>
             <term>
              Int64
             </term>
             <listitem>
              <para>
               L'horloge système du serveur au moment de la transmission, en
               microsecondes depuis le 1er janvier 2000 à minuit.
              </para>
             </listitem>
            </varlistentry>
            <varlistentry>
             <term>
              Byte1
             </term>
             <listitem>
              <para>
               1 signifie que le client doit répondre à ce message dès que possible
               pour éviter une déconnexion après délai. 0 dans les autres cas.
              </para>
             </listitem>
            </varlistentry>
           </variablelist>
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>

      <para>
       Le processus en réception répond à l'envoyeur à tout moment en utilisant
       un des formats de message suivants (aussi dans la charge d'un message
       <literal>CopyData</literal>)&nbsp;:
      </para>

      <para>
       <variablelist>
        <varlistentry>
         <term>
          Mise à jour du statut du serveur en standby (F)
         </term>
         <listitem>
          <para>
           <variablelist>
            <varlistentry>
             <term>
              Byte1('r')
             </term>
             <listitem>
              <para>
               Identifie le message comme une mise à jour du statut du
               réceptionneur.
              </para>
             </listitem>
            </varlistentry>
            <varlistentry>
             <term>
              Int64
             </term>
             <listitem>
              <para>
               L'emplacement du dernier octet des journaux de transactions
               + 1 reçu et écrit sur le disque du serveur en standby.
              </para>
             </listitem>
            </varlistentry>
            <varlistentry>
             <term>
              Int64
             </term>
             <listitem>
              <para>
               L'emplacement du dernier octet du journal de transactions + 1 poussé
               sur le standby.
              </para>
             </listitem>
            </varlistentry>
            <varlistentry>
             <term>
              Int64
             </term>
             <listitem>
              <para>
               L'emplacement du dernier octet du journal de transactions + 1 appliqué
               sur le standby.
              </para>
             </listitem>
            </varlistentry>
            <varlistentry>
             <term>
              Int64
             </term>
             <listitem>
              <para>
               L'horloge système du client au moment de la transmission, en
               microsecondes depuis le 1er janvier 2000 à minuit.
              </para>
             </listitem>
            </varlistentry>
            <varlistentry>
             <term>
              Byte1
             </term>
             <listitem>
              <para>
               Si 1, le client demande une réponse immédiate du serveur à ce message.
               Cela peut être utilisé pour tester si la connexion est toujours bonne.
              </para>
             </listitem>
            </varlistentry>
           </variablelist>
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>

      <para>
       <variablelist>
        <varlistentry>
         <term>
          Message de réponse Hot Standby (F)
         </term>
         <listitem>
          <para>
           <variablelist>
            <varlistentry>
             <term>
              Byte1('h')
             </term>
             <listitem>
              <para>
               Identifie le message comme un message de réponse Hot Standby.
              </para>
             </listitem>
            </varlistentry>
            <varlistentry>
             <term>
              Int64
             </term>
             <listitem>
              <para>
               L'horloge système du client au moment de la transmission, en
               microsecondes depuis le 1er janvier 2000 à minuit.
              </para>
             </listitem>
            </varlistentry>
            <varlistentry>
             <term>
              Int32
             </term>
             <listitem>
              <para>
               La valeur du xmin global actuel pour le serveur standby,
               excluant le catalog_xmin de tout slot de réplication. Si cette
               valeur et le catalog_xmin suivant valent 0, ceci est traité
               comme une notification qu'aucun retour du Hot Standby ne sera
               envoyé sur cette connexion. Les messages ultérieurs différents
               de 0 peuvent réinitialiser le mécanisme de retours d'informations.
              </para>
             </listitem>
            </varlistentry>
            <varlistentry>
             <term>
              Int32
             </term>
             <listitem>
              <para>
               La valeur epoch de l'identifiant de transaction xmin global sur
               le serveur standby.
              </para>
             </listitem>
            </varlistentry>
            <varlistentry>
             <term>
              Int32
             </term>
             <listitem>
              <para>
               La valeur minimale de catalog_xmin pour tout slot de
               réplication sur le standby. Configuré à 0 si aucun catalog_xmin
               n'existe sur le standby ou si le retour d'informations du
               serveur en Hot Standby est désactivé.
              </para>
             </listitem>
            </varlistentry>
            <varlistentry>
             <term>
              Int32
             </term>
             <listitem>
              <para>
               La valeur epoch de l'identifiant de transaction catalog_xmin
               sur le serveur standby.
              </para>
             </listitem>
            </varlistentry>
           </variablelist>
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>START_REPLICATION</literal> <literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable> <literal>LOGICAL</literal> <replaceable class="parameter">XXX/XXX</replaceable> [ ( <replaceable>option_name</replaceable> [ <replaceable>option_value</replaceable> ] [, ...] ) ]</term>
     <listitem>
      <para>
       Indique au serveur de commencer le flux de réplication pour de la
       réplication logique, en commençant à la position <replaceable
       class="parameter">XXX/XXX</replaceable> dans le journal des transactions.
       Le serveur peut répondre avec une erreur, par exemple si la section
       demandée du journal de transactions a déjà été recyclée. En cas de succès,
       le serveur répond avec un message CopyBothResponse, puis commence à
       envoyer le flux vers le client.
      </para>

      <para>
       Les messages à l'intérieur du message CopyBothResponse sont du même format
       que ceux documentés pour <literal>START_REPLICATION ... PHYSICAL</literal>.
      </para>

      <para>
       Le plugin en sortie associé avec le slot sélectionné est utilisé pour
       traiter la sortie pour le flux.
      </para>

      <variablelist>
       <varlistentry>
        <term><literal>SLOT</literal> <replaceable class="parameter">nom_slot</replaceable></term>
        <listitem>
         <para>
          Le nom du slot. Ce paramètre est requis et doit correspond à un slot
          de réplication existant créé avec <literal>CREATE_REPLICATION_SLOT</literal>
          en mode <literal>LOGICAL</literal>.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><replaceable class="parameter">XXX/XXX</replaceable></term>
        <listitem>
         <para>
          La position WAL où commencer le flux.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><replaceable class="parameter">option_name</replaceable></term>
        <listitem>
         <para>
          Le nom d'une option passée au plugin de décodage logique du slot.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><replaceable class="parameter">option_value</replaceable></term>
        <listitem>
         <para>
          Une valeur en option, sous la forme d'une chaîne de caractères, associée
          à l'option indiquée.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal>DROP_REPLICATION_SLOT</literal> <replaceable class="parameter">nom_slot</replaceable> <optional> <literal>WAIT</literal> </optional>
      <indexterm><primary>DROP_REPLICATION_SLOT</primary></indexterm>
     </term>
     <listitem>
      <para>
       Supprime un slot de réplication, libérant toute ressource réservée du côté
       serveur.
       Si le slot est un slot logique créé dans une base de données autre que celle
       où est connecté le walsender, cette commande échoue.
      </para>
      <variablelist>
       <varlistentry>
        <term><replaceable class="parameter">nom_slot</replaceable></term>
        <listitem>
         <para>
          Le nom du slot à supprimer.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>WAIT</literal></term>
        <listitem>
         <para>
          Cette option fait en sorte que la commande attende si le slot est
          actif jusqu'à ce qu'il devienne inactif. Le comportement par défaut
          revient à lever une erreur.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>BASE_BACKUP</literal> [ <literal>LABEL</literal> <replaceable>'label'</replaceable> ] [ <literal>PROGRESS</literal> ] [ <literal>FAST</literal> ] [ <literal>WAL</literal> ] [ <literal>NOWAIT</literal> ] [ <literal>MAX_RATE</literal> <replaceable>rate</replaceable> ] [ <literal>TABLESPACE_MAP</literal> ] [ <literal>NOVERIFY_CHECKSUMS</literal> ]
      <indexterm><primary>BASE_BACKUP</primary></indexterm>
     </term>
     <listitem>
      <para>
       Demande au serveur de commencer l'envoi d'une sauvegarde de base.
       Le système sera mis automatiquement en mode sauvegarde avant que
       celle-ci ne commence et en sera sorti une fois la sauvegarde
       terminée. Les options suivantes sont acceptées&nbsp;:
       <variablelist>
        <varlistentry>
         <term><literal>LABEL</literal> <replaceable>'label'</replaceable></term>
         <listitem>
          <para>
           Précise le label de la sauvegarde. Si aucun label n'est indiqué,
           le label utilisé est <literal>base backup</literal>. Les
           règles de mise entre guillemets du label sont les mêmes que
           pour une chaîne SQL standard avec <xref
           linkend="guc-standard-conforming-strings"/> activé.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>PROGRESS</literal></term>
         <listitem>
          <para>
           Demande la génération d'un rapport de progression. Cela
           enverra la taille approximative dans l'en-tête de chaque
           tablespace, qui peut être utilisé pour calculer ce qu'il
           reste à récupérer. La taille est calculée en énumérant la
           taille de tous les fichiers avant de commencer le transfert.
           Du coup, il est possible que cela ait un impact négatif sur
           les performances. En particulier, la première donnée peut
           mettre du temps à être envoyée. De plus, comme les fichiers
           de la base de données peuvent être modifiés pendant la
           sauvegarde, la taille est seulement approximative et peut
           soit grandir, soit diminuer entre le moment de son calcul
           initial et le moment où les fichiers sont envoyés.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>FAST</literal></term>
         <listitem>
          <para>
           Demande un checkpoint rapide.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>WAL</literal></term>
         <listitem>
          <para>
           Inclut les journaux de transactions nécessaires dans la
           sauvegarde. Cela inclue tous les fichiers entre le début et
           la fin de la sauvegarde de base dans le répertoire
           <filename>pg_wal</filename> dans l'archive tar.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>NOWAIT</literal></term>
         <listitem>
          <para>
           Par défaut, la sauvegarde attendra que le dernier journal de
           transactions requis soit archivé ou émettra un message
           d'avertissement si l'archivage des journaux de transactions
           n'est pas activé. Indiquer <literal>NOWAIT</literal> désactive
           les deux (l'attente et le message), laissant le client
           responsable de la disponibilité des journaux de transactions
           requis.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>MAX_RATE</literal> <replaceable>taux</replaceable></term>
         <listitem>
          <para>
           Limite la quantité maximale de données transférées du serveur au
           client par unité de temps. L'unité attendue est le Ko/s. Si cette
           option est indiquée, la valeur doit être soit égale à zéro, soit être
           comprise entre 32 Ko et 1 Go (inclus). Si zéro est passé ou que l'option
           n'est pas indiquée, aucune restriction n'est imposée sur le transfert.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>TABLESPACE_MAP</literal></term>
         <listitem>
          <para>
           Inclut les informations sur les liens symboliques présents dans le
           répertoire <filename>pg_tblspc</filename> dans un fichier nommé
           <filename>tablespace_map</filename>. Le fichier de correspondance
           des tablespaces inclut les noms des liens symboliques tels qu'ils
           existent dans le répertoire <filename>pg_tblspc/</filename> et le
           chemin complet de ce lien symbolique.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>NOVERIFY_CHECKSUMS</literal></term>
         <listitem>
          <para>
           Par défaut, les sommes de contrôle sont vérifiées pendant une
           sauvegarde de base si celles-ci sont activées. Spécifier
           <literal>NOVERIFY_CHECKSUMS</literal> désactive cette vérification.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Quand la sauvegarde est lancée, le serveur enverra tout d'abord
       deux ensembles de résultats standards, suivis par un ou plusieurs
       résultats de CopyResponse.
      </para>
      <para>
       Le premier ensemble de résultats standard contient la position de
       démarrage de la sauvegarde, dans une seule ligne avec deux colonnes. La
       première colonne contient la position de départ donnée dans le format
       XLogRecPtr, et la deuxième colonne contient l'identifiant correspondant
       de la timeline.
      </para>
      <para>
       Le deuxième ensemble de résultats standard contient une ligne pour
       chaque tablespace. Voici la liste des champs d'une telle ligne&nbsp;:
       <variablelist>
        <varlistentry>
         <term><literal>spcoid</literal> (<type>oid</type>)</term>
         <listitem>
          <para>
           L'OID du tablespace, ou <literal>null</literal> s'il s'agit du
           répertoire de données.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><literal>spclocation</literal> (<type>text</type>)</term>
         <listitem>
          <para>
           Le chemin complet du répertoire du tablespace, ou <literal>null</literal>
           s'il s'agit du répertoire de données.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><literal>size</literal> (<type>int8</type>)</term>
         <listitem>
          <para>
           La taille approximative du tablespace, si le rapport de progression
           a été demandé, <literal>null</literal> dans le cas contraire.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Après l'envoi du deuxième ensemble standard de résultats, un ou plusieurs
       résultats de type <literal>CopyResponse</literal> seront envoyés, un pour
       le répertoire de données principal et un pour chaque tablespace supplémentaire,
       autre que <literal>pg_default</literal> et <literal>pg_global</literal>.
       Les données dans les résultats de type <literal>CopyResponse</literal>
       seront dans le format tar (en suivant le <quote>format d'échange ustar</quote>
       spécifié dans le standard POSIX 1003.1-2008) du contenu du tablespace,
       sauf que les deux blocs de zéros à la fin indiqués dans le standard sont omis.
       Un fois que l'envoi des données du tar est terminé, un ensemble final
       de résultats sera envoyé, contenant la position finale de la sauvegarde
       dans les journaux de transactions, au même format que la position de départ.
      </para>

      <para>
       L'archive tar du répertoire des données et de chaque tablespace
       contiendra tous les fichiers du répertoire, que ce soit des fichiers
       <productname>PostgreSQL</productname> ou des fichiers ajoutés dans
       le même répertoire. Les seuls fichiers exclus sont&nbsp;:
       <itemizedlist spacing="compact" mark="bullet">
        <listitem>
         <para>
          <filename>postmaster.pid</filename>
         </para>
        </listitem>
        <listitem>
         <para>
          <filename>postmaster.opts</filename>
         </para>
        </listitem>
        <listitem>
         <para>
          <filename>pg_internal.init</filename> (trouvé dans plusieurs
          répertoires)
         </para>
        </listitem>
        <listitem>
         <para>
          Différents fichiers et répertoires temporaires créés pendant
          l'opération du serveur PostgreSQL, ainsi que tout fichier ou
          répertoire commençant par <filename>pgsql_tmp</filename> et les
          relations temporaires.
         </para>
        </listitem>
        <listitem>
         <para>
          Les relations non journalisées (<literal>unlogged</literal>, à
          l'exception de l'<literal>init fork</literal> qui est requis pour
          recréer une relation vide non journalisée lors la réstauration.
         </para>
        </listitem>
        <listitem>
         <para>
          <filename>pg_wal</filename>, ainsi que les sous-répertoires.
          Si la sauvegarde est lancée avec ajout des journaux de transactions,
          une version synthétisée de <filename>pg_wal</filename> sera incluse,
          mais elle ne contiendra que les fichiers nécessaires au bon
          fonctionnement de la sauvegarde, et pas le reste de son contenu.
         </para>
        </listitem>
        <listitem>
         <para>
         <filename>pg_dynshmem</filename>, <filename>pg_notify</filename>,
         <filename>pg_replslot</filename>, <filename>pg_serial</filename>,
         <filename>pg_snapshots</filename>, <filename>pg_stat_tmp</filename>
         et <filename>pg_subtrans</filename> sont copiés sous la forme de
         répertoires vides (même si ce sont des liens symboliques).
         </para>
        </listitem>
        <listitem>
         <para>
          Les fichiers autres que les fichiers standards et les répertoires,
          c'est à dire les liens symboliques (autre que les répertoires
          indiqués ci-dessus) et les fichiers de périphériques sont ignorés.
          (Les liens symboliques dans <filename>pg_tblspc</filename> sont
          maintenus.)
         </para>
        </listitem>
       </itemizedlist>
       Le propriétaire, le groupe et les droits du fichier sont conservés si le
       système de fichiers du serveur le permet.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </para>

 </sect1>

 <sect1 id="protocol-message-formats">
  <title>Formats de message</title>

  <para>
   Cette section décrit le format détaillé de chaque message. Chaque message est
   marqué pour indiquer s'il peut être envoyé par un client (F pour
   <foreignphrase>frontend</foreignphrase>), un serveur (B pour
   <foreignphrase>backend</foreignphrase>) ou les deux (F &amp; B). Bien que
   chaque message commence par son nombre d'octets, le format du message est
   défini de telle sorte que la fin du message puisse être trouvée sans ce nombre.
   Cela contribue à la vérification de la validité. Le message <literal>CopyData</literal>
   est une exception, car il constitue une partie du flux de données&nbsp;;
   le contenu d'un message <literal>CopyData</literal> individuel n'est, en soi,
   pas interprétable.
  </para>

  <variablelist>


   <varlistentry>
    <term>
     AuthenticationOk (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('R')
        </term>
        <listitem>
         <para>
          Marqueur de demande d'authentification.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(8)
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(0)
        </term>
        <listitem>
         <para>
          L'authentification a réussi.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     AuthenticationKerberosV5 (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('R')
        </term>
        <listitem>
         <para>
          Marqueur de demande d'authentification.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(8)
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(2)
        </term>
        <listitem>
         <para>
          Une authentification Kerberos V5 est requise.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     AuthenticationCleartextPassword (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('R')
        </term>
        <listitem>
         <para>
          Marqueur de demande d'authentification.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(8)
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(3)
        </term>
        <listitem>
         <para>
          Un mot de passe en clair est requis.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     AuthenticationMD5Password (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('R')
        </term>
        <listitem>
         <para>
          Marqueur de demande d'authentification.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(12)
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(5)
        </term>
        <listitem>
         <para>
          Spécifie qu'un mot de passe utilisant un hachage cryptographique par
          MD5 est requis.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Byte4
        </term>
        <listitem>
         <para>
          Composante de salage (<literal>salt</literal>) à utiliser lors du
          hachage du mot de passe.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     AuthenticationSCMCredential (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('R')
        </term>
        <listitem>
         <para>
          Marqueur de demande d'authentification.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(8)
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(6)
        </term>
        <listitem>
         <para>
          Un message d'accréditation SCM est requis.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     AuthenticationGSS (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('R')
        </term>
        <listitem>
         <para>
          Identifie le message en tant que requête d'authentification.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(8)
        </term>
        <listitem>
         <para>
          Longueur du contenu du message en octets, lui-même inclus.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(7)
        </term>
        <listitem>
         <para>
          Spécifie qu'une authentification GSSAPI est requise.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     AuthenticationSSPI (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('R')
        </term>
        <listitem>
         <para>
          Identifie le message en tant que requête d'authentification.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(8)
        </term>
        <listitem>
         <para>
          Longueur du message en octet, incluant la longueur.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(9)
        </term>
        <listitem>
         <para>
          Spécifie que l'authentification SSPI est requise.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     AuthenticationGSSContinue (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('R')
        </term>
        <listitem>
         <para>
          Identifie le message comme une requête d'authentification.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Longueur du message en octet, incluant la longueur.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(8)
        </term>
        <listitem>
         <para>
          Spécifie que ce message contient des données GSSAPI ou SSPI.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Byte<replaceable>n</replaceable>
        </term>
        <listitem>
         <para>
          Données d'authentification GSSAPI ou SSPI.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     AuthenticationSASL (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('R')
        </term>
        <listitem>
         <para>
          Identifie le message comme une demande d'authentification.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(10)
        </term>
        <listitem>
         <para>
          Précise qu'une authentification SASL est requise.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      Le corps du message est une liste de mécanismes d'authentification
      SASL dans l'ordre de préférence du serveur. Un octet zéro est requis
      comme fin de chaîne après le nom du dernier mécanisme d'authentification.
      Pour chaque mécanisme, il existe ce qui suit&nbsp;:
      <variablelist>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Nom du mécanisme d'authentification SASL.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     Bind (F)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('B')
        </term>
        <listitem>
         <para>
          Marqueur de commande Bind.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(11)
        </term>
        <listitem>
         <para>
          Précise que ce message contient un challenge SASL.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Byte<replaceable>n</replaceable>
        </term>
        <listitem>
         <para>
          Données SASL, spécifiques au mécanisme SASL utilisé.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         AuthenticationSASLFinal (B)
        </term>
        <listitem>
         <para>
          <variablelist>
           <varlistentry>
            <term>Byte1('R')</term>
           <listitem>
            <para>
             Identifie le message comme une demande d'authentification.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Indique que l'authentification SASL est terminée.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int16
        </term>
        <listitem>
         <para>
          Nombre de valeurs de paramètres qui suivent (peut valoir zéro).
          Cela doit correspondre au nombre de paramètres nécessaires à la
          requête.
         </para>
        </listitem>
       </varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                Données supplémentaires pour SASL, spécifique au mécanisme SASL utilisé.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
BackendKeyData (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('K')
</term>
<listitem>
<para>
                Identifie le message comme une donnée clé d'annulation.
                L'interface (<literal>frontend</literal>) doit sauvegarder ces
                valeurs si elle souhaite être capable d'envoyer des messages
                <literal>CancelRequest</literal> plus tard.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(12)
</term>
<listitem>
<para>
                Longueur du contenu du message en octet incluent lui-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                L'identifiant du processus serveur.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                La clé secrète de ce processus serveur.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Bind (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('B')
</term>
<listitem>
<para>
                Identifie le message comme une commande Bind.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Longueur du contenu du message en octets incluant lui-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Le nom du portail destination
                (une chaîne vide sélectionne le portail non nommé).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Le nom de l'instruction préparée source (une chaîne vide
                sélectionne l'instruction préparée sans nom).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                Le nombre de codes de format de paramètre qui suivent (dénoté
                <replaceable>C</replaceable> ci-dessous). Il peut valoir zéro
                pour indiquer qu'il n'y a pas de paramètres ou que tous les
                paramètres utilisent le format par défaut (texte)&nbsp;; il
                peut valoir un, auquel cas le code de format spécifié est
                appliqué à tous les paramètres&nbsp;; ou il peut valoir le
                nombre réel de paramètres.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>C</replaceable>]
</term>
<listitem>
<para>
                Les codes de format de la commande. Chaque code doit être
                exactement zéro (texte) ou un (binaire).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                Le nombre de valeurs de paramètre qui suivent (potentiellement
                zéro). Ceci doit correspondre au nombre de paramètres
                nécessaires à la requête.
</para>
</listitem>
</varlistentry>
</variablelist>
      Puis, le couple de champs suivant apparaît pour chaque paramètre&nbsp;:
      paramètre&nbsp;:
      <variablelist>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille de la valeur du paramètre, en octets (ce nombre
          n'inclut pas la longueur elle-même). Peut valoir zéro.
          Traité comme un cas spécial, -1 indique une valeur de paramètre
          NULL. Aucun octet de valeur ne suit le cas NULL.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Byte<replaceable>n</replaceable>
        </term>
        <listitem>
         <para>
          Valeur du paramètre, dans le format indiqué par le code de
          format associé. <replaceable>n</replaceable> est la longueur ci-dessus.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      Après le dernier paramètre, les champs suivants apparaissent&nbsp;:
      <variablelist>
       <varlistentry>
        <term>
         Int16
        </term>
        <listitem>
         <para>
          Nombre de codes de format des colonnes de résultat qui
          suivent (noté <replaceable>r</replaceable> ci-dessous). peut valoir zéro
          pour indiquer qu'il n'y a pas de colonnes de résultat ou que les
          colonnes de résultat utilisent le format par défaut
          (texte)&nbsp;; ou une, auquel cas le code de format spécifié est
          appliqué à toutes les colonnes de résultat (s'il y en a)&nbsp;;
          il peut aussi être égal au nombre de colonnes de résultat de la
          requête.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int16[<replaceable>r</replaceable>]
        </term>
        <listitem>
         <para>
          Codes de format des colonnes de résultat. Tous doivent
          valoir zéro (texte) ou un (binaire).
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     BindComplete (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('2')
        </term>
        <listitem>
         <para>
          Indicateur de Bind complet.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(4)
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     CancelRequest (F)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Int32(16)
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(80877102)
        </term>
        <listitem>
         <para>
          Code d'annulation de la requête. La valeur est choisie pour
          contenir <literal>1234</literal> dans les 16 bits les plus
          significatifs et <literal>5678</literal> dans les 16 bits les moins
          significatifs (pour éviter toute confusion, ce code ne doit pas
          être le même qu'un numéro de version de protocole).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          ID du processus du serveur cible.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Clé secrète du serveur cible.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     Close (F)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('C')
        </term>
        <listitem>
         <para>
          Marqueur de commande Close.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Byte1
        </term>
        <listitem>
         <para>
          '<literal>s</literal>' pour fermer une instruction préparée&nbsp;; ou
          '<literal>p</literal>' pour fermer un portail.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Nom de l'instruction préparée ou du portail à fermer (une
          chaîne vide sélectionne l'instruction préparée ou le portail
          non-nommé(e)).
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     CloseComplete (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('3')
        </term>
        <listitem>
         <para>
          Indicateur de complétude de Close.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(4)
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     CommandComplete (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('C')
        </term>
        <listitem>
         <para>
          Marqueur de réponse de complétude de commande.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Balise de la commande. Mot simple identifiant la commande SQL terminée.
         </para>

         <para>
          Pour une commande <command>insert</command>, la balise est
          <literal>insert <replaceable>oid</replaceable>
           <replaceable>lignes</replaceable></literal> où
          <replaceable>lignes</replaceable> est le nombre de lignes insérées.
          <replaceable>oid</replaceable> était l'id de l'objet de la ligne insérée
          si <replaceable>lignes</replaceable> vaut 1 et que la table cible a des
          OID, mais les colonnes systèmes OIDs ne sont plus
          supportées; par conséquent <replaceable>oid</replaceable>
          vaut toujours 0.
         </para>

         <para>
          Pour une commande <command>delete</command>, la balise est
          <literal>delete <replaceable>lignes</replaceable></literal> où
          <replaceable>lignes</replaceable> est le nombre de lignes supprimées.
         </para>

         <para>
          Pour une commande <command>update</command>, la balise est
          <literal>update <replaceable>lignes</replaceable></literal> où
          <replaceable>lignes</replaceable> est le nombre de lignes mises à jour.
         </para>

         <para>
          Pour les commandes <command>SELECT</command> ou <command>CREATE TABLE
           AS</command>, la balise est <literal>SELECT
           <replaceable>lignes</replaceable></literal>
          où <replaceable>lignes</replaceable> est le nombre de lignes récupérées.
         </para>

         <para>
          Pour une commande <command>move</command>, la balise est
          <literal>move <replaceable>lignes</replaceable></literal> où
          <replaceable>lignes</replaceable> est le nombre de lignes de déplacement
          du curseur.
         </para>

         <para>
          Pour une commande <command>fetch</command>, la balise est
          <literal>fetch <replaceable>lignes</replaceable></literal> où
          <replaceable>lignes</replaceable> est le nombre de lignes
          récupérées à partir du curseur.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     CopyData (F &amp; B)
    </term>
    <listitem>
     <para>
      <variablelist>
       <varlistentry>
        <term>
         Byte1('d')
        </term>
        <listitem>
         <para>
          Marqueur de données de COPY.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Byte<replaceable>n</replaceable>
        </term>
        <listitem>
         <para>
          Données formant une partie d'un flux de données
          <command>copy</command>. les messages envoyés depuis le serveur
          correspondront toujours à des lignes uniques de données, mais
          les messages envoyés par les clients peuvent diviser le flux de
          données de façon arbitraire.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     CopyDone (F &amp; B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('c')
        </term>
        <listitem>
         <para>
          Indicateur de fin de COPY.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(4)
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     CopyFail (F)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('f')
        </term>
        <listitem>
         <para>
          Indicateur d'échec de COPY.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Message d'erreur rapportant la cause d'un échec.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     CopyInResponse (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('G')
        </term>
        <listitem>
         <para>
          Marqueur de réponse de Start Copy In.
          Le client doit alors envoyer des données de copie (s'il n'est
          pas à cela, il enverra un message CopyFail).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int8
        </term>
        <listitem>
         <para>
          0 indique que le format de copie complet est textuel (lignes
          séparées par des retours chariot, colonnes séparées par des
          caractères de séparation, etc). 1 indique que le format de copie
          complet est binaire (similaire au format DataRow).
          Voir <xref linkend="sql-copy"/> pour
          plus d'informations.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int16
        </term>
        <listitem>
         <para>
          Nombre de colonnes dans les données à copier (noté
          <replaceable>n</replaceable> ci-dessous).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int16[<replaceable>n</replaceable>]
        </term>
        <listitem>
         <para>
          Codes de format à utiliser pour chaque colonne. Chacun doit
          valoir zéro (texte) ou un (binaire). Tous doivent valoir zéro si
          le format de copie complet est de type texte.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     CopyOutResponse (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('H')
        </term>
        <listitem>
         <para>
          Marqueur de réponse Start Copy Out.
          Ce message sera suivi de données copy-out.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int8
        </term>
        <listitem>
         <para>
          0 indique que le format de copie complet est textuel (lignes
          séparées par des retours chariot, colonnes séparées par des
          caractères séparateurs, etc). 1 indique que le format de copie
          complet est binaire (similaire au format DataRow).
          Voir <xref linkend="sql-copy"/> pour
          plus d'informations.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int16
        </term>
        <listitem>
         <para>
          Nombre de colonnes de données à copier (noté
          <replaceable>n</replaceable> ci-dessous).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int16[<replaceable>n</replaceable>]
        </term>
        <listitem>
         <para>
          Codes de format à utiliser pour chaque colonne. Chaque code
          doit valoir zéro (texte) ou un (binaire). Tous doivent valoir
          zéro si le format de copie complet est de type texte.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     NegotiateProtocolVersion (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('v')
        </term>
        <listitem>
         <para>
          Identifie le message comme un message de négociation de la version
          du protocole.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Longueur du contenu du message en octets, incluant la longueur
          elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Plus récente version mineure supportée par le serveur pour la
          version majeure du protocole demandée par le client.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Nombre d'options du protocole non reconnues par le serveur.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      Puis, pour chaque option du protocole non reconnue par le serveur&nbsp;:
      <variablelist>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Nom de l'option.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     CopyBothResponse (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('W')
        </term>
        <listitem>
         <para>
          Identifie le message comme une réponse Start Copy Both.
          Ce message est seulement utilisé pour la réplication en
          flux.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Longueur du contenu du message en octets, incluant
          lui-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int8
        </term>
        <listitem>
         <para>
          0 indique que le format <command>COPY</command> global
          est textuel (lignes séparées par des retours à la ligne,
          colonnes séparées par des caractères séparateurs, etc).
          1 indique que le format de copie global est binaire
          (similaire au format DataRow). Voir <xref
          linkend="sql-copy"/> pour plus d'informations.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int16
        </term>
        <listitem>
         <para>
          Le nombre de colonnes dans les données à copier
          (dénoté <replaceable>N</replaceable> ci-dessous).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int16[<replaceable>N</replaceable>]
        </term>
        <listitem>
         <para>
          Les codes de format utilisés pour chaque colonne. Chacune
          doit actuellement valoir 0 (texte) ou 1 (binaire).
          Tous doivent valoir 0 si le format de copy global est
          texte.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     DataRow (B)
    </term>
    <listitem>
     <para>
      <variablelist>
       <varlistentry>
        <term>
         Byte1('D')
        </term>
        <listitem>
         <para>
          Marqueur de ligne de données.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int16
        </term>
        <listitem>
         <para>
          Nombre de valeurs de colonnes qui suivent (peut valoir zéro).
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      Apparaît ensuite le couple de champs suivant, pour chaque colonne&nbsp;:
      <variablelist>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Longueur de la valeur de la colonne, en octets (ce nombre
          n'inclut pas la longueur elle-même). Elle peut valoir zéro.
          Traité comme un cas spécial, -1 indique une valeur NULL de
          colonne. Aucun octet de valeur ne suit le cas NULL.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Byte<replaceable>n</replaceable>
        </term>
        <listitem>
         <para>
          Valeur de la colonne dans le format indiqué par le code de
          format associé. <replaceable>n</replaceable> est la longueur
          ci-dessus.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     Describe (F)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('D')
        </term>
        <listitem>
         <para>
          Marqueur de commande Describe.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Byte1
        </term>
        <listitem>
         <para>
          '<literal>s</literal>' pour décrire une instruction préparée&nbsp;; ou
          '<literal>p</literal>' pour décrire un portail.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Nom de l'instruction préparée ou du portail à décrire (une
          chaîne vide sélectionne l'instruction préparée ou le portail
          non-nommé(e)).
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     EmptyQueryResponse (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('I')
        </term>
        <listitem>
         <para>
          Marqueur de réponse à une chaîne de requête vide (c'est un
          substitut de CommandComplete).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(4)
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     ErrorResponse (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('E')
        </term>
        <listitem>
         <para>
          Marqueur d'erreur.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      Le corps du message est constitué d'un ou plusieurs champs identifié(s),
      suivi(s) d'un octet nul comme délimiteur de fin. L'ordre des champs n'est pas
      fixé. Pour chaque champ, on trouve les informations suivantes&nbsp;:
      <variablelist>
       <varlistentry>
        <term>
         Byte1
        </term>
        <listitem>
         <para>
          Code identifiant le type de champ&nbsp;; s'il vaut zéro,
          c'est la fin du message et aucune chaîne ne suit. Les types de
          champs définis sont listés dans
          <xref linkend="protocol-error-fields"/>. De nouveaux types de
          champs pourraient être ajoutés dans le futur, les clients
          doivent donc ignorer silencieusement les types non reconnus.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Valeur du champ.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     Execute (F)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('E')
        </term>
        <listitem>
         <para>
          Marqueur de commande Execute.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Nom du portail à exécuter (une chaîne vide sélectionne le
          portail non-nommé).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Nombre maximum de lignes à retourner si le portail contient une
          requête retournant des lignes (ignoré sinon). Zéro signifie&nbsp;:
          <quote>aucune limite</quote>.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     Flush (F)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('H')
        </term>
        <listitem>
         <para>
          Marqueur de commande Flush.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(4)
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     FunctionCall (F)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('F')
        </term>
        <listitem>
         <para>
          Marqueur d'appel de fonction.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Spécifie l'ID de l'objet représentant la fonction à appeler.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int16
        </term>
        <listitem>
         <para>
          Nombre de codes de format de l'argument qui suivent
          (noté <replaceable>c</replaceable> ci-dessous). Cela peut être zéro pour
          indiquer qu'il n'y a pas d'arguments ou que tous les arguments
          utilisent le format par défaut (texte)&nbsp;; un, auquel cas
          le code de format est appliqué à tous les arguments&nbsp;; il
          peut aussi être égal au nombre réel d'arguments.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int16[<replaceable>c</replaceable>]
        </term>
        <listitem>
         <para>
          Les codes de format d'argument. Chacun doit valoir zéro
          (texte) ou un (binaire).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int16
        </term>
        <listitem>
         <para>
          Nombre d'arguments fournis à la fonction.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      Apparaît ensuite, pour chaque argument, le couple de champs suivant&nbsp;:
      <variablelist>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Longueur de la valeur de l'argument, en octets (ce nombre
          n'inclut pas la longueur elle-même). Peut valoir zéro.
          Traité comme un cas spécial, -1 indique une valeur NULL de
          l'argument. Aucun octet de valeur ne suit le cas NULL.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Byte<replaceable>n</replaceable>
        </term>
        <listitem>
         <para>
          Valeur de l'argument dans le format indiqué par le code de
          format associé. <replaceable>n</replaceable> est la longueur
          ci-dessus.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      Après le dernier argument, le champ suivant apparaît&nbsp;:
      <variablelist>
       <varlistentry>
        <term>
         Int16
        </term>
        <listitem>
         <para>
          Code du format du résultat de la fonction. Doit valoir zéro
          (texte) ou un (binaire).
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     FunctionCallResponse (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('V')
        </term>
        <listitem>
         <para>
          Marqueur de résultat d'un appel de fonction.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Longueur de la valeur du résultat de la fonction, en octets
          (ce nombre n'inclut pas la longueur elle-même). Peut valoir zéro.
          Traité comme un cas spécial, -1 indique un résultat de fonction
          NULL. Aucun octet de valeur ne suit le cas NULL.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Byte<replaceable>n</replaceable>
        </term>
        <listitem>
         <para>
          Valeur du résultat de la fonction, dans le format indiqué
          par le code de format associé. <replaceable>n</replaceable> est
          la longueur ci-dessus.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     GSSResponse (F)
    </term>
    <listitem>
     <para>
      <variablelist>
       <varlistentry>
	<term>
         Byte1('p')
	</term>
	<listitem>
	 <para>
          Identifie le message comme une réponse GSSAPI ou SSPI. Notez
          que ceci peut aussi être utilisé comme message de réponse SASL
          et password. Le type de message exact se déduit du contexte.
	 </para>
	</listitem>
       </varlistentry>
       <varlistentry>
	<term>
         Int32
	</term>
	<listitem>
	 <para>
          Longueur du contenu du message en octets, incluant lui-même.
	 </para>
	</listitem>
       </varlistentry>
       <varlistentry>
	<term>
         Byte<replaceable>n</replaceable>
	</term>
	<listitem>
	 <para>
          Données spécifiques du message GSSAPI/SSPI.
	 </para>
	</listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     NoData (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('n')
        </term>
        <listitem>
         <para>
          Indicateur d'absence de données.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(4)
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     NoticeResponse (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('N')
        </term>
        <listitem>
         <para>
          Marqueur d'avertissement.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      Le corps du message est constitué d'un ou plusieurs champs identifié(s),
      suivi(s) d'un octet zéro comme délimiteur de fin. L'ordre des champs n'est pas
      fixé. Pour chaque champ, on trouve les informations suivantes&nbsp;:
      <variablelist>
       <varlistentry>
        <term>
         Byte1
        </term>
        <listitem>
         <para>
          Code identifiant le type de champ&nbsp;; s'il vaut zéro,
          c'est la fin du message et aucune chaîne ne suit. Les types de
          champs déjà définis sont listés dans
          <xref linkend="protocol-error-fields"/>. De nouveaux types de
          champs pourraient être ajoutés dans le futur, les clients doivent
          donc ignorer silencieusement les champs de type non reconnu.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Valeur du champ.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     NotificationResponse (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('A')
        </term>
        <listitem>
         <para>
          Marqueur de réponse de notification.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          ID du processus serveur ayant procédé à la notification.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Nom du canal à l'origine de la notification.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          La chaîne <quote>embarquée</quote> passée lors de la notification
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     ParameterDescription (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('t')
        </term>
        <listitem>
         <para>
          Marqueur de description de paramètre.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int16
        </term>
        <listitem>
         <para>
          Nombre de paramètres utilisé par l'instruction (peut valoir
          zéro).
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      Pour chaque paramètre, on trouve ensuite&nbsp;:
      <variablelist>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          ID de l'objet du type de données du paramètre.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     ParameterStatus (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('S')
        </term>
        <listitem>
         <para>
          Marqueur de rapport d'état de paramètre
          d'exécution.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Nom du paramètre d'exécution dont le rapport est en cours.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Valeur actuelle du paramètre.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     Parse (F)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('P')
        </term>
        <listitem>
         <para>
          Marqueur de commande Parse.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Nom de l'instruction préparée de destination (une chaîne
          vide sélectionne l'instruction préparée non-nommée).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Chaîne de requête à analyser.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int16
        </term>
        <listitem>
         <para>
          Nombre de types de données de paramètre spécifiés (peut
          valoir zéro). Ce n'est pas une indication du nombre de
          paramètres pouvant apparaître dans la chaîne de requête,
          mais simplement le nombre de paramètres pour lesquels le client
          veut préspécifier les types.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      Pour chaque paramètre, on trouve ensuite&nbsp;:
      <variablelist>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          ID de l'objet du type de données du paramètre. La valeur zéro
          équivaut à ne pas spécifier le type.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     ParseComplete (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('1')
        </term>
        <listitem>
         <para>
          Indicateur de fin de Parse.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(4)
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     PasswordMessage (F)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('p')
        </term>
        <listitem>
         <para>
          Identifie le message comme une réponse à un mot de passe.
          Notez que c'est aussi utilisé par les messages de réponse
          GSSAPI, SSPI et SASL.
          Le type exact du message se déduit du contexte.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Mot de passe (chiffré à la demande).
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     PortalSuspended (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('s')
        </term>
        <listitem>
         <para>
          Indicateur de suspension du portail.
          Apparaît seulement si la limite du nombre de lignes d'un
          message Execute a été atteinte.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(4)
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     Query (F)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('Q')
        </term>
        <listitem>
         <para>
          Marqueur de requête simple.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          La chaîne de requête elle-même.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     ReadyForQuery (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('Z')
        </term>
        <listitem>
         <para>
          Identifie le type du message. ReadyForQuery est envoyé à chaque
          fois que le serveur est prêt pour un nouveau cycle de requêtes.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(5)
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Byte1
        </term>
        <listitem>
         <para>
          Indicateur de l'état transactionnel du serveur.
          Les valeurs possibles sont '<literal>i</literal>' s'il est en pause
          (en dehors d'un bloc de transaction)&nbsp;; '<literal>t</literal>' s'il
          est dans un bloc de transaction&nbsp;; ou '<literal>e</literal>' s'il
          est dans un bloc de transaction échouée (les requêtes seront
          rejetées jusqu'à la fin du bloc).
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     RowDescription (B)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('T')
        </term>
        <listitem>
         <para>
          Marqueur de description de ligne.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int16
        </term>
        <listitem>
         <para>
          Nombre de champs dans une ligne (peut valoir zéro).
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      On trouve, ensuite, pour chaque champ&nbsp;:
      <variablelist>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Nom du champ.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Si le champ peut être identifié comme colonne d'une table
          spécifique, l'ID de l'objet de la table&nbsp;; sinon zéro.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int16
        </term>
        <listitem>
         <para>
          Si le champ peut être identifié comme colonne d'une table
          spécifique, le numéro d'attribut de la colonne&nbsp;; sinon zéro.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          ID de l'objet du type de données du champ.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int16
        </term>
        <listitem>
         <para>
          Taille du type de données (voir <varname>pg_type.typlen</varname>).
          Les valeurs négatives indiquent des types de largeur variable.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Modificateur de type (voir <varname>pg_attribute.atttypmod</varname>).
          La signification du modificateur est spécifique au type.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int16
        </term>
        <listitem>
         <para>
          Code de format utilisé pour le champ. Zéro (texte) ou un
          (binaire), à l'heure actuelle. Dans un RowDescription retourné
          par la variante de l'instruction de Describe, le code du format
          n'est pas encore connu et vaudra toujours zéro.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     SASLInitialResponse (F)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('p')
        </term>
        <listitem>
         <para>
          Identifie le message comme une réponse SASL initiale. Notez que
          c'est aussi utilisé pour les messages de réponses pour GSSAPI, SSPI
          et password. Le type exact du message se déduit du contexte.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Longueur du contenu du message en octets incluant lui-même.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Nom du mécanisme d'authentification SASL que le client a sélectionné.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Longueur spécifique au mécanisme SASL pour le "Initial Client
          Response" qui suit, ou -1 s'il n'y a pas de réponse initiale.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term>
         Byte<replaceable>n</replaceable>
        </term>
        <listitem>
         <para>
          "Initial Response" spécifique au mécanisme SASL.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     SASLResponse (F)
    </term>
    <listitem>
     <para>
      <variablelist>
       <varlistentry>
        <term>
         Byte1('p')
        </term>
        <listitem>
         <para>
          Identifie le message comme une réponse SASL. Notez que ceci peut
          aussi être utilisé pour les messages de réponses pour GSSAPI, SSPI
          et password. Le type exact de message peut être déduit du contexte.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32
        </term>
        <listitem>
         <para>
          Longueur du contenu du message en octets, incluant sa propre
          longueur.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Byte<replaceable>n</replaceable>
        </term>
        <listitem>
         <para>
          Données du message, spécifiques au mécanisme SASL.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     SSLRequest (F)
    </term>
    <listitem>
     <para>
      <variablelist>
       <varlistentry>
        <term>
         Int32(8)
        </term>
        <listitem>
         <para>
          Longueur du contenu du message en octets, incluant sa propre
          longueur.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(80877103)
        </term>
        <listitem>
         <para>
          Le code de demande <acronym>SSL</acronym>. La valeur est choisie
          pour contenir <literal>1234</literal> dans les 16 bits les plus
          significatifs, et <literal>5679</literal> dans les 16 bits les moins
          significatifs. (Pour éviter la confusion, ce code ne doit pas être
          le même que tout numéro de version du procotole.)
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     GSSENCRequest (F)
    </term>
    <listitem>
     <para>
      <variablelist>
       <varlistentry>
        <term>
         Int32(8)
        </term>
        <listitem>
         <para>
          Longueur du contenu du message en octets, incluant sa propre
	  longueur.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(80877104)
        </term>
        <listitem>
         <para>
          Le code de demande de chiffrement <acronym>GSSAPI</acronym>.
	  La valeur est choisie pour contenir
          <literal>1234</literal> dans les 16 bits les plus significatifs,
	  et <literal>5680</literal> dans les 16 bits les moins significatifs.
          (Pour éviter toute confusion, ce code doit être différent de n'importe
	  quel numéro de version de protocole.)
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     StartupMessage (F)
    </term>
    <listitem>
     <para>
      <variablelist>
       <varlistentry>
        <term>
         Int32
        </term>
       <listitem>
        <para>
          Longueur du contenu du message en octets, incluant sa propre
          longueur.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(196608)
        </term>
        <listitem>
         <para>
          Le numéro de version du protocole. Les 16 bits les plus significatifs
          sont le numéro de version du protocole (3 pour le protocole décrit
          ici). Les 16 bits les moins significatifs sont le numéro de version
          mineure (0 pour le protocole décrit ici).
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      Le numéro de version du protocole est suivi par une ou plusieurs paires
      de nom de paramètre / chaîne de valeur. Un octet zéro est requis comme
      terminateur après la dernière paire nom/valeur. Les paramètres peuvent
      apparaître dans n'importe quel ordre. <literal>user</literal> est
      requis. Chaque paramètre est spécifié sous cette forme&nbsp;:
      <variablelist>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Le nom du paramètre. Les noms actuellement reconnus sont&nbsp;:
          <variablelist>
           <varlistentry>
            <term>
             <literal>user</literal>
            </term>
            <listitem>
             <para>
              Le nom de l'utilisateur pour la connexion. Requis, sans valeur
              par défaut.
             </para>
            </listitem>
           </varlistentry>
           <varlistentry>
            <term>
             <literal>database</literal>
            </term>
           <listitem>
            <para>
              Base de données à laquelle se connecter.
              Par défaut le nom de l'utilisateur.
             </para>
            </listitem>
           </varlistentry>
           <varlistentry>
            <term>
             <literal>options</literal>
            </term>
            <listitem>
             <para>
              Arguments en ligne de commande pour le serveur (rendu obsolète
              par l'utilisation de paramètres individuels d'exécution). Les
              espaces dans cette chaîne sont considérés séparer les arguments,
              sauf s'ils sont échappés avec un antislash
              (<literal>\</literal>). Écrire <literal>\\</literal> pour
              représenter un antislash littéral.
             </para>
            </listitem>
           </varlistentry>
           <varlistentry>
            <term>
             <literal>replication</literal>
            </term>
            <listitem>
             <para>
              Utiliser pour connecter en mode de réplication en flux, où un
              petit ensemble de commandes de réplication peuvent être
              exécutées à la place de requêtes SQL. La valeur peut être
              <literal>true</literal>, <literal>false</literal> ou
              <literal>database</literal>, mais la valeur par défaut est
              <literal>false</literal>. Voir <xref
              linkend="protocol-replication"/> pour les détails.
             </para>
            </listitem>
           </varlistentry>
          </variablelist>

          En plus de ce qui est indiqué ci-dessus, les autres paramètres
          peuvent être listés. Les noms de paramètres commençant par
          <literal>_pq_.</literal> sont réservés à être utilisés comme des
          extensions du protocole, alors que les autres sont traités comme des
          paramètres à l'exécution à configurer au démarrage de la session. De
          tels paramètres seront appliqués au lancement du processus (après
          avoir analysé les arguments de la ligne de commande) et agiront
          comme les valeurs par défaut de la session.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         String
        </term>
        <listitem>
         <para>
          Valeur du paramètre.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     Sync (F)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('S')
        </term>
        <listitem>
         <para>
          Marqueur de commande Sync.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(4)
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     Terminate (F)
    </term>
    <listitem>
     <para>

      <variablelist>
       <varlistentry>
        <term>
         Byte1('X')
        </term>
        <listitem>
         <para>
          Marqueur de fin.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         Int32(4)
        </term>
        <listitem>
         <para>
          Taille du message en octets, y compris la taille elle-même.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

     </para>
    </listitem>
   </varlistentry>


  </variablelist>

 </sect1>


 <sect1 id="protocol-error-fields">
  <title>Champs des messages d'erreur et d'avertissement</title>

  <para>
   Cette section décrit les champs qui peuvent apparaître dans les messages
   ErrorResponse et NoticeResponse. Chaque type de champ a un motif
   d'identification codé sur un octet. Tout type de champ donné doit apparaître au
   plus une fois par message.
  </para>

  <variablelist>

   <varlistentry>
    <term>
     <literal>s</literal>
    </term>
    <listitem>
     <para>
      Gravité (Severity)&nbsp;: le contenu du champ peut être
      <literal>error</literal>, <literal>fatal</literal> ou
      <literal>panic</literal> dans un message d'erreur,
      <literal>warning</literal>, <literal>notice</literal>, <literal>debug</literal>,
      <literal>info</literal> ou <literal>log</literal> dans un message d'avertissement,
      ou la traduction régionale de l'un d'eux. Toujours présent.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>V</literal>
    </term>
    <listitem>
     <para>
      Gravité&nbsp;: le contenu du champ peut être <literal>ERROR</literal>,
      <literal>FATAL</literal> ou <literal>PANIC</literal> (dans un message
      d'erreur), ou <literal>WARNING</literal>, <literal>NOTICE</literal>,
      <literal>DEBUG</literal>, <literal>INFO</literal> ou
      <literal>LOG</literal> (dans un message de notification). C'est
      identique au champ <symbol>S</symbol> sauf que le contenu n'est jamais
      traduit. C'est présent uniquement dans les rapports générés par les
      versions 9.6 et ultérieurs de <productname>PostgreSQL</productname>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>c</literal>
    </term>
    <listitem>
     <para>
      Code&nbsp;: code SQLSTATE de l'erreur (voir
      <xref linkend="errcodes-appendix"/>). non internationalisable.
      Toujours présent.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>m</literal>
    </term>
    <listitem>
     <para>
      Message&nbsp;: premier message d'erreur, en clair.
      Doit être court et précis (typiquement une ligne). Toujours présent.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>d</literal>
    </term>
    <listitem>
     <para>
      Détail&nbsp;: deuxième message d'erreur, optionnel, apportant des
      informations supplémentaires sur le problème. Peut être sur plusieurs
      lignes.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>h</literal>
    </term>
    <listitem>
     <para>
      Astuce (Hint)&nbsp;: suggestion optionnelle de résolution du
      problème. Différent de Détail parce qu'il offre un
      conseil (potentiellement inapproprié) plutôt que des faits réels.
      Peut être sur plusieurs lignes.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>p</literal>
    </term>
    <listitem>
     <para>
      Position&nbsp;: valeur du champ, entier décimal ASCII indiquant
      un curseur sur la position de l'erreur dans la chaîne de requête
      originale. Le premier caractère a l'index 1. Les positions sont mesurées
      en caractères, non pas en octets.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>p</literal>
    </term>
    <listitem>
     <para>
      Position interne&nbsp;: ceci est défini de la même façon que le champ
      <literal>p</literal> mais c'est utilisé quand la position du curseur se réfère
      à une commande générée en interne plutôt qu'une soumise par le client.
      Le champ <literal>q</literal> apparaîtra toujours quand ce champ apparaît.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>q</literal>
    </term>
    <listitem>
     <para>
      Requête interne&nbsp;: le texte d'une commande générée en interne et qui a échoué.
      Ceci pourrait être, par exemple, une requête SQL lancée par une fonction PL/pgSQL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>w</literal>
    </term>
    <listitem>
     <para>
      Où (Where)&nbsp;: indication du contexte dans lequel l'erreur est
      survenue. Inclut, actuellement, une trace de la pile des appels des
      fonctions PL actives. Cette trace comprend une entrée par ligne, la plus
      récente en premier.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>s</literal>
    </term>
    <listitem>
     <para>
      Nom du schéma&nbsp;: si l'erreur est associée à un objet spécifique
      de la base de données, le nom du schéma contenant cet objet.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>t</literal>
    </term>
    <listitem>
     <para>
      Nom de la table&nbsp;: si l'erreur est associée à une table spécifique,
      le nom de la table. (Fait référence au champ du nom du schéma pour le
      nom du schéma de la table.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>c</literal>
    </term>
    <listitem>
     <para>
      Nom de la colonne&nbsp;: si l'erreur est associée à une colonne
      spécifique, le nom de la colonne. (Fait référence aux champs des noms
      de schéma et de table pour identifier la table.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>d</literal>
    </term>
    <listitem>
     <para>
      Nom du type de données&nbsp;: si l'erreur est associée à un type de
      données spécifique, le nom du type de données. (Fait référence au champ
      du nom du schéma pour le nom du schéma du type de données.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>n</literal>
    </term>
    <listitem>
     <para>
      Nom de la contrainte&nbsp;: si l'erreur est associée à une contrainte
      spécifique, le nom de la contrainte. Cela fait référence aux champs
      listés ci-dessus pour la table ou le domaine associé. (Dans ce cadre,
      les index sont traités comme des contraintes même s'ils ont été créés
      autrement qu'avec la syntaxe des contraintes.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>F</literal>
    </term>
    <listitem>
     <para>
      Fichier (File)&nbsp;: nom du fichier de code source comportant
      l'erreur.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>L</literal>
    </term>
    <listitem>
     <para>
      Ligne (Line)&nbsp;: numéro de ligne dans le fichier de code source
      comportant l'erreur.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>R</literal>
    </term>
    <listitem>
     <para>
      Routine&nbsp;: nom de la routine dans le code source comportant
      l'erreur.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>

  <note>
   <para>
    Les champs du nom du schéma, de la table, de la colonne, du type de données
    et de la contrainte sont fournis seulement pour un nombre limité de types
    d'erreur&nbsp;; voir <xref linkend="errcodes-appendix"/>. Les clients ne
    devraient pas supposer que la présence d'un de ces champs garantisse la
    présence d'un autre champ. Le moteur observe les relations notées ci-dessus,
    mais les fonctions utilisateurs peuvent utiliser ces champs d'autres
    façons. Dans la même veine, les clients ne doivent pas supposer que ces
    champs indiquent des objets actuels dans la base de données courante.
   </para>
  </note>

  <para>
   Le client est responsable du formatage adapté à ses besoins des informations
   affichées&nbsp;; en particulier par l'ajout de retours chariot sur les lignes
   longues, si cela s'avérait nécessaire. Les caractères de retour chariot
   apparaissant dans les champs de messages d'erreur devraient être traités comme
   des changements de paragraphes, non comme des changements de lignes.
  </para>

 </sect1>

 <sect1 id="protocol-logicalrep-message-formats">
  <title>Formats des messages de la réplication logique</title>

  <para>
   Cette section décrit le format détaillé de chaque message de réplication
   logique. Ces messages sont renvoyés soit par l'interface SQL des slots
   de réplication, soit par un walsender. Dans le cas d'un walsender, ils
   sont encapsulés dans les messages WAL du protocole de réplication comme
   décrits dans <xref linkend="protocol-replication"/> et obéissent généralement
   au même flux de message que celui de la réplication physique.
  </para>

<variablelist>

<varlistentry>
<term>
Begin
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('B')
</term>
<listitem>
<para>
                Identifie le message comme un message begin.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                Options&nbsp;; actuellement inutilisé (doit valoir 0).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
                Le LSN final de la transaction.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
                Horodatage de la validation de la transaction. La valeur est
                le nombre de microsecondes depuis l'epoch PostgreSQL
                (2000-01-01).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Xid de la transaction.
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
Commit
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('C')
</term>
<listitem>
<para>
                Identifie le message comme un message de validation
                (commit).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
                Le LSN de la validation.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
                Le LSN final de la transaction.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
                Horodatage de la validation de la transaction. La valeur est
                le nombre de microsecondes depuis l'epoch PostgreSQL
                (2000-01-01).
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
Origin
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('O')
</term>
<listitem>
<para>
                Identifie le message comme un message d'origine.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
                Le LSN de la validation sur le serveur origine.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Nom de l'origine.
</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<para>
  Notez qu'il peut y avoir plusieurs messages Origin à l'intérieur d'une
  simple transaction.
</para>

</listitem>
</varlistentry>

<varlistentry>
<term>
Relation
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Identifie le message comme un message relation.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID de la relation.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Schéma (chaîne vide pour <literal>pg_catalog</literal>).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Nom de la relation.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                Configuration de l'identité du réplicat pour la relation
                (identique à <structfield>relreplident</structfield> dans
                <structname>pg_class</structname>).
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                Nombre de colonnes.
</para>
</listitem>
</varlistentry>
</variablelist>
        Ensuite, la partie suivante du message apparaît pour chaque
        colonne (excepté les colonnes générées)&nbsp;:
<variablelist>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                Drapeaux pour la colonne. Actuellement, soit 0 pour aucun
                drapeau, soit 1 pour marquer la colonne comme faisant partie
                de la clé.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Nom de la colonne.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID du type de données de la colonne.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Modifieur de type de la colonne (<structfield>atttypmod</structfield>).
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
Type
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('Y')
</term>
<listitem>
<para>
                Identifie le message comme un message type.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID du type de données.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Schéma (chaîne vide pour <literal>pg_catalog</literal>).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Nom du type de données.
</para>
</listitem>
</varlistentry>
 
</variablelist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
Insert
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('I')
</term>
<listitem>
<para>
                Identifie le message comme un message insert.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID de la relation correspondant à l'ID dans le message
                relation.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1('N')
</term>
<listitem>
<para>
                Identifie le message suivant TupleData comme une nouvelle
                ligne.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        TupleData
</term>
<listitem>
<para>
                Partie du message TupleData représentant le contenu de la
                nouvelle ligne.
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
Update
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('U')
</term>
<listitem>
<para>
                Identifie le message comme un message update.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID de la relation correspondant à l'ID dans le message
                relation.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('K')
</term>
<listitem>
<para>
                Identifie le sous-message TupleData suivant comme une clé. Ce
                champ est optionnel et seulement présent si la mise à jour a
                modifié des données dans une colonne faisant partie d'un index
                REPLICA IDENTITY.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('O')
</term>
<listitem>
<para>
                Identifie le sous-message TupleData suivant comme une ancienne
                ligne. Ce champ est optionnel et est seulement présent si la
                table dans laquelle la mise à jour est survenue a REPLICA
                IDENTITY configuré à FULL.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        TupleData
</term>
<listitem>
<para>
                Partie du message TupleData représentant le contenu de
                l'ancienne ligne ou de la clé primaire. Seulement présent si
                la partie 'O' ou 'K' est présente.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('N')
</term>
<listitem>
<para>
                Identifie le message TupleData suivant comme une nouvelle
                ligne.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        TupleData
</term>
<listitem>
<para>
                Partie du message TupleData représentant le contenu de
                la nouvelle ligne
</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<para>
    Le message Update peut contenir soit une partie message 'K' ou une partie
    message 'O' ou ni l'un ni l'autre, mais jamais les deux.
</para>

</listitem>
</varlistentry>

<varlistentry>
<term>
Delete
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('D')
</term>
<listitem>
<para>
                Identifie le message comme un message delete.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID de la relation correspondant à l'ID dans le message
                relation.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('K')
</term>
<listitem>
<para>
                Identifie le sous-message TupleData suivant comme une clé. Ce
                champ est présent si la table où survient la suppression
                utilise un index comme REPLICA IDENTITY.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('O')
</term>
<listitem>
<para>
                Identifie le message TupleData suivant comme ancienne ligne.
                Ce champ est présent si la table dans laquelle la suppression
                est survenue a REPLICA IDENTITY configuré à FULL.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        TupleData
</term>
<listitem>
<para>
                La partie du message TupleData représentant le contenu de
                l'ancienne ligne ou la clé primaire, suivant le champ
                précédent.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<para>
    Le message Delete peut contenir soit une partie message 'K' soit une
    partie message 'O', mais jamais les deux.
</para>

</listitem>
</varlistentry>

<varlistentry>
<term>
Truncate
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('T')
</term>
<listitem>
<para>
                Identifies the message as a truncate message.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Nombre de relations
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                Bits en option pour <command>TRUNCATE</command>:
                1 pour <literal>CASCADE</literal>, 2 pour <literal>RESTART IDENTITY</literal>
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID de la relation correspondant à l'ID dans le message de
                relation. Ce champ est répété pour chaque relation.
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

</variablelist>

<para>

Les parties suivantes du message sont partagées par les messages ci-dessus.

</para>

<variablelist>

<varlistentry>
<term>
TupleData
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                Nombre de colonnes.
</para>
</listitem>
</varlistentry>
</variablelist>
        Ensuite, un des sous-messages suivants apparaît pour chaque
        colonne (excepté les colonnes générées)&nbsp;:
<variablelist>
<varlistentry>
<term>
        Byte1('n')
</term>
<listitem>
<para>
                Identifie la donnée comme une valeur NULL.
</para>
</listitem>
</varlistentry>
</variablelist>
        Or
<variablelist>
<varlistentry>
<term>
        Byte1('u')
</term>
<listitem>
<para>
                Identifie une valeur TOAST non modifiée (la valeur réelle
                n'est pas envoyée).
</para>
</listitem>
</varlistentry>
</variablelist>
        Or
<variablelist>
<varlistentry>
<term>
        Byte1('t')
</term>
<listitem>
<para>
                Identifie la donnée comme une valeur formatée en texte.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Longueur de la valeur de la colonne.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                La valeur de la colonne au format texte. (Une prochaine version
                pourrait supporter des formats supplémentaires.)
                <replaceable>n</replaceable> est la longueur ci-dessus.

</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

</variablelist>

</sect1>

 <sect1 id="protocol-changes">
  <title>Résumé des modifications depuis le protocole 2.0</title>

  <para>
   Cette section fournit une liste rapide des modifications à l'attention des
   développeurs essayant d'adapter au protocole 3.0 des bibliothèques clientes
   existantes.
  </para>

  <para>
   Le paquet de démarrage initial utilise un format flexible de liste de chaînes
   au lieu d'un format fixe. Les valeurs de session par défaut des paramètres
   d'exécution peuvent même être spécifiées directement dans le paquet de démarrage
   (en fait, cela était déjà possible en utilisant le champ <literal>options</literal>&nbsp;;
   mais étant donné la largeur limitée d'<literal>options</literal> et l'impossibilité de
   mettre entre guillemets les espaces fines dans les valeurs, ce n'était pas une
   technique très sûre).
  </para>

  <para>
   Tous les messages possèdent désormais une indication de longueur qui suit
   immédiatement l'octet du type de message (sauf pour les paquets de démarrage qui
   n'ont pas d'octet de type). PasswordMessage possède à présent un octet de type.
  </para>

  <para>
   Les messages ErrorResponse et NoticeResponse ('<literal>e</literal>' et
   '<literal>n</literal>') contiennent maintenant plusieurs champs, à partir desquels le
   code client peut assembler un message d'erreur fonction du niveau de verbiage
   désiré. Des champs individuels ne se termineront plus par un retour chariot
   alors que la chaîne seule envoyée dans l'ancien protocole le faisait
   systématiquement.
  </para>

  <para>
   Le message ReadyForQuery ('<literal>z</literal>') inclut un indicateur d'état de
   la transaction.
  </para>

  <para>
   La distinction entre les types de messages BinaryRow et DataRow est supprimée&nbsp;;
   le type de message DataRow seul sert à retourner les données dans tous les
   formats. La disposition de DataRow a changé pour faciliter son analyse.
   La représentation des valeurs binaires a également été modifiée&nbsp;: elle
   n'est plus liée directement à la représentation interne du serveur.
  </para>

  <para>
   Il existe un nouveau sous-protocole pour les <quote>requêtes étendues</quote> qui
   ajoute les types de messages client Parse, Bind, Execute, Describe, Close,
   Flush et Sync et les types de messages serveur ParseComplete, BindComplete,
   PortalSuspended, ParameterDescription, NoData et CloseComplete. Les clients
   existants ne sont pas directement concernés par ce sous-protocole, mais son
   utilisation apportera des améliorations en termes de performances et de
   fonctionnalités.
  </para>

  <para>
   Les données de <command>copy</command> sont désormais encapsulées dans des messages
   CopyData et CopyDone. Il y a une façon bien définie de réparer les erreurs
   lors du <command>copy</command>. La dernière ligne spéciale <quote><literal>\.</literal></quote>
   n'est plus nécessaire et n'est pas envoyée lors de <command>copy out</command> (elle
   est toujours reconnue comme un indicateur de fin lors du <command>copy in</command>
   mais son utilisation est obsolète. Elle sera éventuellement supprimée). Le
   <command>copy</command> binaire est supporté. Les messages copyinresponse et
   CopyOutResponse incluent les champs indiquant le nombre de colonnes et le
   format de chaque colonne.
  </para>

  <para>
   La disposition des messages FunctionCall et FunctionCallResponse a changé.
   FunctionCall supporte à présent le passage aux fonctions d'arguments NULL. Il
   peut aussi gérer le passage de paramètres et la récupération de résultats aux
   formats texte et binaire. Il n'y a plus aucune raison de considérer FunctionCall
   comme une faille potentielle de sécurité, car il n'offre plus d'accès direct aux
   représentations internes des données du serveur.
  </para>

  <para>
   Le serveur envoie des messages ParameterStatus ('<literal>s</literal>') lors de
   l'initialisation de la connexion pour tous les paramètres qu'il considère
   intéressants pour la bibliothèque client. En conséquence, un message
   ParameterStatus est envoyé à chaque fois que la valeur active d'un de ces
   paramètres change.
  </para>

  <para>
   Le message RowDescription ('<literal>t</literal>') contient les nouveaux champs oid
   de table et de numéro de colonne pour chaque colonne de la ligne décrite. Il
   affiche aussi le code de format pour chaque colonne.
  </para>

  <para>
   Le message CursorResponse ('<literal>p</literal>') n'est plus engendré par le serveur.
  </para>

  <para>
   Le message NotificationResponse ('<literal>a</literal>') a un champ de type chaîne
   supplémentaire qui peut <quote>embarquer</quote> une chaîne passée par
   l'émetteur de l'événement <command>notify</command>.
  </para>

  <para>
   Le message EmptyQueryResponse ('<literal>i</literal>') nécessitait un paramètre chaîne
   vide&nbsp;; ce n'est plus le cas.
  </para>

 </sect1>


</chapter>
