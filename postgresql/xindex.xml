<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<sect1 id="xindex">
 <title>Interfacer des extensions d'index</title>

 <para>
  Les procédures décrites jusqu'à maintenant permettent de définir de nouveaux
  types, de nouvelles fonctions et de nouveaux opérateurs. Néanmoins, nous ne
  pouvons pas encore définir un index sur une colonne d'un nouveau type de
  données. Pour cela, nous devons définir une <firstterm>classe d'opérateur</firstterm>
  pour le nouveau type de données. Plus loin dans cette section, nous
  illustrerons ce concept avec un exemple&nbsp;: une nouvelle classe
  d'opérateur pour la méthode d'indexation B-tree qui enregistre et trie des
  nombres complexes dans l'ordre ascendant des valeurs absolues.
 </para>

 <para>
  Les classes d'opérateur peuvent être groupées en <firstterm>familles
   d'opérateur</firstterm> pour afficher les relations entre classes
  compatibles sémantiquement.  Quand un seul type de données est impliqué,
  une classe d'opérateur est suffisant, donc nous allons nous fixer sur ce
  cas en premier puis retourner aux familles d'opérateur.
 </para>

 <sect2 id="xindex-opclass">
  <title>Méthodes d'indexation et classes d'opérateurs</title>

  <para>
   La table <classname>pg_am</classname> contient une ligne pour chaque méthode
   d'indexation (connue en interne comme méthode d'accès). Le support pour l'accès
   normal aux tables est implémenté dans <productname>PostgreSQL</productname>
   mais toutes les méthodes d'index sont décrites dans
   <classname>pg_am</classname>. Il est possible d'ajouter une nouvelle méthode
   d'accès aux index en écrivant le code nécessaire et en ajoutant
   ensuite une ligne dans la table <classname>pg_am</classname> &mdash; mais ceci
   est au-delà du sujet de ce chapitre (voir le <xref linkend="indexam"/>).
  </para>

  <para>
   Les routines pour une méthode d'indexation n'ont pas à connaître directement
   les types de données sur lesquels opère la méthode d'indexation. Au lieu de
   cela, une <firstterm>classe d'opérateur</firstterm> identifie l'ensemble d'opérations
   que la méthode d'indexation doit utiliser pour fonctionner avec un type
   particulier de données. Les classes d'opérateurs sont ainsi dénommées parce
   qu'une de leur tâche est de spécifier l'ensemble des opérateurs de la clause
   <literal>WHERE</literal> utilisables avec un index (c'est-à-dire, qui peuvent être
   requalifiés en balayage d'index). Une classe d'opérateur peut également
   spécifier des <firstterm>procédures d'appui</firstterm>, nécessaires pour les
   opérations internes de la méthode d'indexation mais sans correspondance
   directe avec un quelconque opérateur de clause <literal>WHERE</literal> pouvant être
   utilisé avec l'index.
  </para>

  <para>
   Il est possible de définir plusieurs classes d'opérateurs pour le même
   type de données et la même méthode d'indexation. Ainsi, de multiples ensembles
   de sémantiques d'indexation peuvent être définis pour un seul type de
   données. Par exemple, un index B-tree exige qu'un tri ordonné soit défini
   pour chaque type de données auquel il peut s'appliquer. Il peut être utile
   pour un type de donnée de nombre complexe de disposer d'une classe
   d'opérateur B-tree qui trie les données selon la valeur absolue complexe, une
   autre selon la partie réelle, etc. Typiquement, une des classes d'opérateur
   sera considérée comme plus utile et sera marquée comme l'opérateur par défaut
   pour ce type de données et cette méthode d'indexation.
  </para>

  <para>
   Le même nom de classe d'opérateur peut être utilisé pour plusieurs méthodes
   d'indexation différentes (par exemple, les méthodes d'index B-tree et hash ont
   toutes les deux des classes d'opérateur nommées <literal>int4_ops</literal>)
   mais chacune de ces classes est une entité indépendante et doit être définie
   séparément.
  </para>
 </sect2>

 <sect2 id="xindex-strategies">
  <title>Stratégies des méthode d'indexation</title>

  <para>
   Les opérateurs associés à une classe d'opérateur sont identifiés par des
   <quote>numéros de stratégie</quote>, servant à identifier la sémantique de
   chaque opérateur dans le contexte de sa classe d'opérateur. Par exemple, les
   B-trees imposent un classement strict selon les clés, du plus petit au plus
   grand. Ainsi, des opérateurs comme <quote>plus petit que</quote> et <quote>plus
    grand que</quote> sont intéressants pour un B-tree. Comme
   <productname>PostgreSQL</productname> permet à l'utilisateur de définir des
   opérateurs, <productname>PostgreSQL</productname> ne peut pas rechercher le
   nom d'un opérateur (par exemple, <literal>&lt;</literal> ou <literal>&gt;=</literal>) et
   rapporter de quelle comparaison il s'agit. Au lieu de cela, la méthode
   d'indexation définit un ensemble de <quote>stratégies</quote>, qui peuvent être
   comprises comme des opérateurs généralisés. Chaque classe d'opérateur
   spécifie l'opérateur effectif correspondant à chaque stratégie pour un type
   de donnée particulier et pour une interprétation de la sémantique d'index.
  </para>

  <para>
   La méthode d'indexation B-tree définit cinq stratégies, qui sont exposées
   dans le <xref linkend="xindex-btree-strat-table"/>.
  </para>

  <table tocentry="1" id="xindex-btree-strat-table">
   <title>Stratégies B-tree</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Opération</entry>
      <entry>Numéro de stratégie</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>plus petit que</entry>
      <entry>1</entry>
     </row>
     <row>
      <entry>plus petit ou égal</entry>
      <entry>2</entry>
     </row>
     <row>
      <entry>égal</entry>
      <entry>3</entry>
     </row>
     <row>
      <entry>plus grand ou égal</entry>
      <entry>4</entry>
     </row>
     <row>
      <entry>plus grand que</entry>
      <entry>5</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les index de découpage permettent seulement des comparaisons d'égalité et
   utilisent ainsi une seule stratégie exposée dans le <xref
   linkend="xindex-hash-strat-table"/>.
  </para>

  <table tocentry="1" id="xindex-hash-strat-table">
   <title>Stratégies de découpage</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Opération</entry>
      <entry>Numéro de stratégie</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>égal à</entry>
      <entry>1</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les index GiST sont plus flexibles&nbsp;: ils n'ont pas du tout un
   ensemble fixe de stratégies. À la place, la routine de support de
   <quote>cohérence</quote> de chaque classe d'opérateur GiST interprète les
   numéros de stratégie comme elle l'entend. Comme exemple, plusieurs des classes
   d'opérateurs  GiST indexe les objets géométriques à deux dimensions
   fournissant les stratégies <quote>R-tree</quote> affichées dans
   <xref linkend="xindex-rtree-strat-table"/>. Quatre d'entre elles sont des vrais
   tests à deux dimensions (surcharge, identique, contient, contenu par)&nbsp;;
   quatre autres considèrent seulement la direction X&nbsp;; et les quatre
   dernières fournissent les mêmes tests dans la direction Y.
  </para>

  <table tocentry="1" id="xindex-rtree-strat-table">
   <title>Stratégies <quote>R-tree</quote> pour GiST à deux dimensions</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Opération</entry>
      <entry>Numéro de stratégie</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>strictement à gauche de</entry>
      <entry>1</entry>
     </row>
     <row>
      <entry>ne s'étend pas à droite de</entry>
      <entry>2</entry>
     </row>
     <row>
      <entry>surcharge</entry>
      <entry>3</entry>
     </row>
     <row>
      <entry>ne s'étend pas à gauche de</entry>
      <entry>4</entry>
     </row>
     <row>
      <entry>strictement à droite de</entry>
      <entry>5</entry>
     </row>
     <row>
      <entry>identique</entry>
      <entry>6</entry>
     </row>
     <row>
      <entry>contient</entry>
      <entry>7</entry>
     </row>
     <row>
      <entry>contenu par</entry>
      <entry>8</entry>
     </row>
     <row>
      <entry>ne s'étend pas au dessus</entry>
      <entry>9</entry>
     </row>
     <row>
      <entry>strictement en dessous</entry>
      <entry>10</entry>
     </row>
     <row>
      <entry>strictement au dessus</entry>
      <entry>11</entry>
     </row>
     <row>
      <entry>ne s'étend pas en dessous</entry>
      <entry>12</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les index SP-GiST sont similaires aux index GiST en flexibilité&nbsp;: ils n'ont
   pas un ensemble fixe de stratégie. À la place, les routines de support de
   chaque classe d'opérateur interprètent les numéros de stratégie suivant la
   définition du classe d'opérateur. Comme exemple, les numéros des stratégies
   utilisés par les classes d'opérateur sur des points sont affichés dans
   <xref linkend="xindex-spgist-point-strat-table"/>.
  </para>

  <table tocentry="1" id="xindex-spgist-point-strat-table">
   <title>Stratégies point SP-GiST</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Opération</entry>
      <entry>Numéro de stratégie</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>strictement à gauche</entry>
      <entry>1</entry>
     </row>
     <row>
      <entry>strictement à droite</entry>
      <entry>5</entry>
     </row>
     <row>
      <entry>identique</entry>
      <entry>6</entry>
     </row>
     <row>
      <entry>contenu par</entry>
      <entry>8</entry>
     </row>
     <row>
      <entry>strictement en dessous</entry>
      <entry>10</entry>
     </row>
     <row>
      <entry>strictement au dessus</entry>
      <entry>11</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les index GIN sont similaires aux index GiST et SP-GiST, dans le fait qu'ils
   n'ont pas d'ensemble fixé de stratégies. À la place, les routines support de
   chaque opérateur de classe interprètent les numéros de stratégie suivant la
   définition de la classe d'opérateur. Comme exemple, les numéros de stratégie
   utilisés par la classe d'opérateur interne pour les tableaux sont affichés
   dans <xref linkend="xindex-gin-array-strat-table"/>.
  </para>

  <table tocentry="1" id="xindex-gin-array-strat-table">
   <title>Stratégies des tableaux GIN</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Opération</entry>
      <entry>Numéro de stratégie</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>surcharge</entry>
      <entry>1</entry>
     </row>
     <row>
      <entry>contient</entry>
      <entry>2</entry>
     </row>
     <row>
      <entry>est contenu par</entry>
      <entry>3</entry>
     </row>
     <row>
      <entry>identique</entry>
      <entry>4</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les index BRIN sont similaires aux index GiST, SP-GiST et GIN dans le fait
   qu'ils n'ont pas un ensemble fixe de stratégies. À la place, les routines de
   support de chaque classe d'opérateur interprètent les numéros de stratégie
   suivant la définition de la classe d'opérateur. Par exemple, les numéros de
   stratégie utilisés par les classes d'opérateur <literal>Minmax</literal>
   sont indiqués dans <xref linkend="xindex-brin-minmax-strat-table"/>.
  </para>

   <table tocentry="1" id="xindex-brin-minmax-strat-table">
    <title>Stratégies MinMax pour BRIN</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Opération</entry>
       <entry>Numéro de stratégie</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>inférieur</entry>
       <entry>1</entry>
      </row>
      <row>
       <entry>inférieur ou égal</entry>
       <entry>2</entry>
      </row>
      <row>
       <entry>égal</entry>
       <entry>3</entry>
      </row>
      <row>
       <entry>supérieur ou égal</entry>
       <entry>4</entry>
      </row>
      <row>
       <entry>supérieur</entry>
       <entry>5</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   Notez que tous les opérateurs ci-dessus renvoient des valeurs de type
   booléen. Dans la pratique, tous les opérateurs définis comme index method
   search operators doivent renvoyer un type <type>boolean</type> puisqu'ils
   doivent apparaître au plus haut niveau d'une clause <literal>WHERE</literal> pour
   être utilisés avec un index.
   (Some index access methods also support <firstterm>ordering operators</firstterm>,
   which typically don't return Boolean values; that feature is discussed
   in <xref linkend="xindex-ordering-ops"/>.)
  </para>
 </sect2>

 <sect2 id="xindex-support">
  <title>Routines d'appui des méthodes d'indexation</title>

  <para>
   Généralement, les stratégies n'apportent pas  assez d'informations au système
   pour indiquer comment utiliser un index. Dans la pratique, les méthodes
   d'indexation demandent des routines d'appui additionnelles pour fonctionner. Par
   exemple, les méthodes d'index B-tree doivent être capables de comparer deux
   clés et de déterminer laquelle est supérieure, égale ou inférieure à l'autre.
   De la même façon, la méthode d'indexation hash doit être capable de calculer
   les codes de hachage pour les valeurs de clés. Ces opérations ne
   correspondent pas à des opérateurs utilisés dans les commandes SQL&nbsp;; ce
   sont des routines administratives utilisées en interne par des méthodes
   d'index.
  </para>

  <para>
   Comme pour les stratégies, la classe d'opérateur énumère les fonctions
   spécifiques et le rôle qu'elles doivent jouer pour un
   type de donnée donné et une interprétation sémantique donnée. La méthode d'indexation
   définit l'ensemble des fonctions dont elle a besoin et la classe d'opérateur
   identifie les fonctions exactes à utiliser en les assignant aux
   <quote>numéros de fonction d'appui</quote> spécifiés par la méthode d'indexage.
  </para>

  <para>
   Les B-trees requièrent une fonction support de comparaison et permet deux
   fonctions support supplémentaires à fournir comme option de la classe
   d'opérateur, comme indiqué dans <xref
   linkend="xindex-btree-support-table"/>. Les prérequis pour ces fonctions
   support sont expliqués en détails dans <xref
   linkend="btree-support-funcs"/>.
  </para>

  <table tocentry="1" id="xindex-btree-support-table">
   <title>Fonctions d'appui de B-tree</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Fonction</entry>
      <entry>Numéro d'appui</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       Comparer deux clés et renvoyer un entier inférieur à zéro, zéro ou
       supérieure à zéro indiquant si la première clé est inférieure, égale ou
       supérieure à la deuxième.
      </entry>
      <entry>1</entry>
     </row>
     <row>
      <entry>
       Renvoyer les adresses des fonctions de support de tri, appelables en C
       (optionnel)
      </entry>
      <entry>2</entry>
     </row>
     <row>
      <entry>
       Comparer une valeur test à une valeur de base plus/moins un décalage,
       et renvoyer true ou false suivant le résultat de la comparaison
       (optionnel)
      </entry>
      <entry>3</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les index hash requièrent une fonction d'appui, et permettent une deuxième
   fonction à fournir à la classe d'opérateur, comme indiqué dans <xref
   linkend="xindex-hash-support-table"/>.
  </para>

  <table tocentry="1" id="xindex-hash-support-table">
   <title>Fonctions d'appui pour découpage</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Fonction</entry>
      <entry>Numéro d'appui</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>Calculer la valeur de hachage 32 bits pour une clé</entry>
      <entry>1</entry>
     </row>
     <row>
      <entry>
        Calcule la valeur de hachage sur 64 bits d'une clé pour un sel de
        64 bits donné&nbsp;; si le sel vaut 0, les 32 bits de poids faible du
        résultat doivent correspondre à la valeur qui aurait été calculée par
        la fonction 1 (facultative)
      </entry>
      <entry>2</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les index GiST ont neuf fonctions d'appui, dont deux facultatives,
   exposées dans le <xref linkend="xindex-gist-support-table"/>.
   (Pour plus d'informations, voir <xref linkend="gist"/>.)
  </para>

  <table tocentry="1" id="xindex-gist-support-table">
   <title>Fonctions d'appui pour GiST</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Fonction</entry>
      <entry>Description</entry>
      <entry>Numéro d'appui</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><function>consistent</function></entry>
      <entry>
       détermine si la clé satisfait le qualifiant de la
       requête (variante Booléenne)
       (facultatif si la fonction d'appui 6 est présente)
      </entry>
      <entry>1</entry>
     </row>
     <row>
      <entry><function>union</function></entry>
      <entry>calcule l'union d'un ensemble de clés</entry>
      <entry>2</entry>
     </row>
     <row>
      <entry><function>compress</function></entry>
      <entry>calcule une représentation compressée d'une clé ou
       d'une valeur à indexer</entry>
      <entry>3</entry>
     </row>
     <row>
      <entry><function>decompress</function></entry>
      <entry>calcule une représentation décompressée d'une clé
       compressée</entry>
      <entry>4</entry>
     </row>
     <row>
      <entry><function>penalty</function></entry>
      <entry>calcule la pénalité pour l'insertion d'une nouvelle
       clé dans un sous-arbre avec la clé du sous-arbre indiqué</entry>
      <entry>5</entry>
     </row>
     <row>
      <entry><function>picksplit</function></entry>
      <entry>détermine les entrées d'une page qui sont à déplacer
       vers la nouvelle page et calcule les clés d'union pour les pages
       résultantes</entry>
      <entry>6</entry>
     </row>
     <row>
      <entry><function>equal</function></entry>
      <entry>compare deux clés et renvoie true si elles sont
       identiques</entry>
      <entry>7</entry>
     </row>
     <row>
      <entry><function>distance</function></entry>
      <entry>détermine la distance de la clé à la valeur de la requête (optionnel)</entry>
      <entry>8</entry>
     </row>
     <row>
      <entry><function>fetch</function></entry>
      <entry>calcule la représentation originale d'une clé compressée pour les
      parcours d'index seul (optionnel)</entry>
      <entry>9</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les index SP-GiST requièrent cinq fonctions de support, comme indiquées
   dans <xref linkend="xindex-spgist-support-table"/>.
   (Pour plus d'informations, voir <xref linkend="spgist"/>.)
  </para>

  <table tocentry="1" id="xindex-spgist-support-table">
   <title>Fonctions de support SP-GiST</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Fonction</entry>
      <entry>Description</entry>
      <entry>Numéro de support</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><function>config</function></entry>
      <entry>fournit des informations basiques sur la classe d'opérateur</entry>
      <entry>1</entry>
     </row>
     <row>
      <entry><function>choose</function></entry>
      <entry>détermine comment insérer une nouvelle valeur dans une ligne interne</entry>
      <entry>2</entry>
     </row>
     <row>
      <entry><function>picksplit</function></entry>
      <entry>détermine comment partitionner un ensemble de valeurs</entry>
      <entry>3</entry>
     </row>
     <row>
      <entry><function>inner_consistent</function></entry>
      <entry>détermine la sous-partition à rechercher pour une requête</entry>
      <entry>4</entry>
     </row>
     <row>
      <entry><function>leaf_consistent</function></entry>
      <entry>détermine si la clé satisfait le qualificateur de la requête</entry>
      <entry>5</entry>
     </row>
     <row>
      <entry><function>triConsistent</function></entry>
      <entry>
       détermine si la valeur satisfait le qualificateur de la requête (variante ternaire)
       (facultatif si la fonction de support 4 est présente)
      </entry>
      <entry>6</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les index GIN ont six fonctions d'appui, dont trois optionnelles,
   exposées dans le <xref linkend="xindex-gin-support-table"/>.
   (Pour plus d'informations, voir <xref linkend="gin"/>.)
  </para>

  <table tocentry="1" id="xindex-gin-support-table">
   <title>Fonctions d'appui GIN</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Fonction</entry>
      <entry>Description</entry>
      <entry>Numéro d'appui</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><function>compare</function></entry>
      <entry>
       Compare deux clés et renvoie un entier plus petit que zéro,
       zéro ou plus grand que zéro, indiquant si la première clé est plus petit,
       égal à ou plus grand que la seconde.
      </entry>
      <entry>1</entry>
     </row>
     <row>
      <entry><function>extractValue</function></entry>
      <entry>Extrait les clés à partir d'une condition de
       requête</entry>
      <entry>2</entry>
     </row>
     <row>
      <entry><function>extractQuery</function></entry>
      <entry>Extrait les clés à partir d'une condition de
       requête</entry>
      <entry>3</entry>
     </row>
     <row>
      <entry><function>consistent</function></entry>
      <entry>Détermine la valeur correspondant à la condition de
       requête</entry>
      <entry>4</entry>
     </row>
     <row>
      <entry><function>comparePartial</function></entry>
      <entry>
       compare la clé partielle
       de la requête et la clé de l'index, et renvoie un entier négatif, nul
       ou positif, indiquant si GIN doit ignorer cette entrée d'index, traiter
       l'entrée comme une correspondance ou arrêter le parcours d'index (optional)</entry>
      <entry>5</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les index BRIN ont quatre fonctions de support basiques, comme indiqué
   dans <xref linkend="xindex-brin-support-table"/>&nbsp;; ces fonctions
   basiques peuvent nécessiter des fonctions de support supplémentaires.
   (Pour plus d'informations, voir <xref linkend="brin-extensibility"/>.)
  </para>

   <table tocentry="1" id="xindex-brin-support-table">
    <title>Fonctions de support BRIN</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Fonction</entry>
       <entry>Description</entry>
       <entry>Numéro de support</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><function>opcInfo</function></entry>
       <entry>
        renvoie des informations internes décrivant les données de résumé des
        colonnes indexées
       </entry>
       <entry>1</entry>
      </row>
      <row>
       <entry><function>add_value</function></entry>
       <entry>ajoute une nouvelle valeur à un enregistrement d'index existant</entry>
       <entry>2</entry>
      </row>
      <row>
       <entry><function>consistent</function></entry>
       <entry>détermine si la valeur correspond à une condition de la requête</entry>
       <entry>3</entry>
      </row>
      <row>
       <entry><function>union</function></entry>
       <entry>
        calcule l'union de deux enregistrements résumés
       </entry>
       <entry>4</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   Contrairement aux opérateurs de recherche, les fonctions d'appui renvoient le
   type de donnée, quelqu'il soit, que la méthode d'indexation particulière
   attend, par exemple, dans le cas de la fonction de comparaison des B-trees,
   un entier signé. Le nombre et le type des arguments pour chaque fonction de
   support peuvent dépendre de la méthode d'indexage. Pour les index B-tree et
   de hachage, les fonctions de support pour la comparaison et le hachage
   prennent les mêmes types de données en entrée que les opérateurs inclus
   dans la classe d'opérateur, mais ce n'est pas le cas pour la plupart des
   fonctions de support GiST, SP-GiST, GIN et BRIN.
  </para>
 </sect2>

 <sect2 id="xindex-example">
  <title>Exemple</title>

  <para>
   Maintenant que nous avons vu les idées, voici l'exemple promis de création
   d'une nouvelle classe d'opérateur. Cette classe d'opérateur encapsule les
   opérateurs qui trient les nombres complexes selon l'ordre de la valeur
   absolue, aussi avons-nous choisi le nom de
   <literal>complex_abs_ops</literal>. En premier lieu, nous avons besoin d'un
   ensemble d'opérateurs. La procédure pour définir des opérateurs a été
   discutée dans la <xref linkend="xoper"/>.  Pour une classe d'opérateur sur les
   B-trees, nous avons besoin des opérateurs&nbsp;:

   <itemizedlist spacing="compact">
    <listitem><simpara>valeur absolue less-than (stratégie 1)&nbsp;;</simpara></listitem>
    <listitem><simpara>valeur absolue less-than-or-equal (stratégie
      2)&nbsp;;</simpara></listitem>
    <listitem><simpara>valeur absolue equal (stratégie 3)&nbsp;;</simpara></listitem>
    <listitem><simpara>valeur absolue greater-than-or-equal (stratégie
      4)&nbsp;;</simpara></listitem>
    <listitem><simpara>valeur absolue greater-than (stratégie 5)&nbsp;;</simpara></listitem>
   </itemizedlist>
  </para>

  <para>
   Le plus simple moyen de définie un ensemble d'opérateurs de comparaison est
   d'écrire en premier la fonction de comparaison B-tree, puis d'écrire les
   autres fonctions en tant que wrapper de la fonction de support. Ceci réduit
   les risques de résultats incohérents pour les cas spécifiques. En suivant
   cette approche, nous devons tout d'abord écrire&nbsp;:

   <programlisting><![CDATA[
#define Mag(c)  ((c)->x*(c)->x + (c)->y*(c)->y)

static int
complex_abs_cmp_internal(Complex *a, Complex *b)
{
    double      amag = Mag(a),
                bmag = Mag(b);

    if (amag < bmag)
        return -1;
    if (amag > bmag)
        return 1;
    return 0;
}
]]></programlisting>

   Maintenant, la fonction plus-petit-que ressemble à ceci&nbsp;:

<programlisting><![CDATA[
PG_FUNCTION_INFO_V1(complex_abs_lt);

Datum
complex_abs_lt(PG_FUNCTION_ARGS)
{
    Complex    *a = (Complex *) PG_GETARG_POINTER(0);
    Complex    *b = (Complex *) PG_GETARG_POINTER(1);

    PG_RETURN_BOOL(complex_abs_cmp_internal(a, b) < 0);
}
]]></programlisting>

   Les quatre autres fonctions diffèrent seulement sur la façon dont ils
   comparent le résultat de la fonction interne au zéro.
  </para>

  <para>
   Maintenant, déclarons en SQL les fonctions et les opérateurs basés sur ces
   fonctions&nbsp;:
<programlisting>CREATE FUNCTION complex_abs_lt(complex, complex) RETURNS bool
    AS '<replaceable>nom_fichier</replaceable>', 'complex_abs_lt'
    LANGUAGE C IMMUTABLE STRICT;

CREATE OPERATOR &lt; (
   leftarg = complex, rightarg = complex, procedure = complex_abs_lt,
   commutator = &gt; , negator = &gt;= ,
   restrict = scalarltsel, join = scalarltjoinsel
);
   </programlisting>
   Il est important de spécifier les fonctions de sélectivité de restriction et
   de jointure, sinon l'optimiseur sera incapable de faire un usage effectif de
   l'index.
  </para>

  <para>
   Voici d'autres choses importantes à noter&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Il ne peut y avoir qu'un seul opérateur nommé, disons, <literal>=</literal>
      et acceptant un type <type>complex</type> pour ses deux opérandes. Dans le
      cas présent, nous n'avons aucun autre opérateur <literal>=</literal> pour
      <type>complex</type> mais, si nous construisons un type de donnée
      fonctionnel, nous aurions certainement désiré que <literal>=</literal> soit
      l'opération ordinaire d'égalité pour les nombres complexes (et non pour
      l'égalité de leurs valeurs absolues). Dans ce cas, nous aurions eu besoin
      d'utiliser un autre nom d'opérateur pour notre fonction
      <function>complex_abs_eq</function>.
     </para>
    </listitem>

    <listitem>
     <para>
      Bien que <productname>PostgreSQL</productname> puisse se débrouiller avec
      des fonctions ayant le même nom SQL, tant qu'elles ont en argument des
      types de données différents, en C il ne peut exister qu'une fonction globale
      pour un nom donné. Aussi ne devons-nous pas donner un nom simple
      comme <filename>abs_eq</filename>. Habituellement, inclure le nom du type
      de données dans le nom de la fonction C est une bonne habitude pour ne
      pas provoquer de conflit avec des fonctions pour d'autres types de donnée.
     </para>
    </listitem>

    <listitem>
     <para>
      Nous aurions pu faire de  <filename>abs_eq</filename> le nom
      SQL de la fonction, en laissant à <productname>PostgreSQL</productname>
      le soin de la distinguer de toute autre fonction SQL de même nom par les
      types de données en argument. Pour la simplicité de l'exemple, nous
      donnerons à la fonction le même nom au niveau de C et au niveau de SQL.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   La prochaine étape est l'enregistrement de la routine d'appui nécessaire pour
   les  B-trees. Le code exemple C qui implémente ceci est dans le même fichier
   qui contient les fonctions d'opérateur. Voici comment déclarer la
   fonction&nbsp;:

   <programlisting>CREATE FUNCTION complex_abs_cmp(complex, complex)
    RETURNS integer
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C;
   </programlisting>
  </para>

  <para>
   Maintenant que nous avons les opérateurs requis et la routine d'appui, nous
   pouvons enfin créer la classe d'opérateur.

   <programlisting><![CDATA[
CREATE OPERATOR CLASS complex_abs_ops
    DEFAULT FOR TYPE complex USING btree AS
        OPERATOR        1       < ,
        OPERATOR        2       <= ,
        OPERATOR        3       = ,
        OPERATOR        4       >= ,
        OPERATOR        5       > ,
        FUNCTION        1       complex_abs_cmp(complex, complex);
]]></programlisting>
  </para>

  <para>
   Et c'est fait&nbsp;! Il devrait être possible maintenant de créer et
   d'utiliser les index B-tree sur les colonnes <type>complex</type>.
  </para>

  <para>
   Nous aurions pu écrire les entrées de l'opérateur de façon plus explicite
   comme dans&nbsp;:

   <programlisting>        OPERATOR        1       &lt; (complex, complex) ,
   </programlisting>
   mais il n'y a pas besoin de faire ainsi quand les opérateurs prennent le même
   type de donnée que celui pour lequel la classe d'opérateur a été définie.
  </para>

  <para>
   Les exemples ci-dessus supposent que vous voulez que cette nouvelle classe
   d'opérateur soit la classe d'opérateur B-tree par défaut pour le type de
   donnée <type>complex</type>. Si vous ne voulez pas, supprimez simplement le
   mot <literal>DEFAULT</literal>.
  </para>
 </sect2>

 <sect2 id="xindex-opfamily">
  <title>Classes et familles d'opérateur</title>

  <para>
   Jusqu'à maintenant, nous avons supposé implicitement qu'une classe d'opérateur
   s'occupe d'un seul type de données. Bien qu'il ne peut y avoir qu'un seul
   type de données dans une colonne d'index particulière, il est souvent utile
   d'indexer les opérations qui comparent une colonne indexée à une valeur d'un
   type de données différent. De plus, s'il est intéressant d'utiliser un
   opérateur inter-type en connexion avec une classe d'opérateur, souvent cet
   autre type de donnée a sa propre classe d'opérateur. Rendre explicite les
   connexions entre classes en relation est d'une grande aide pour que le
   planificateur optimise les requêtes SQL (tout particulièrement pour les
   classes d'opérateur B-tree car le planificateur sait bien comme les
   utiliser).
  </para>

  <para>
   Pour gérer ces besoins, <productname>PostgreSQL</productname> utilise le
   concept d'une <firstterm>famille d'opérateur</firstterm>
   <indexterm><primary>famille d'opérateur</primary></indexterm>.
   Une famille d'opérateur contient une ou plusieurs classes d'opérateur et
   peut aussi contenir des opérateurs indexables et les fonctions de support
   correspondantes appartenant à la famille entière mais pas à une classe
   particulière de la famille. Nous disons que ces opérateurs et fonctions
   sont <quote>lâches</quote> à l'intérieur de la famille, en opposition à
   être lié à une classe spécifique. Typiquement, chaque classe d'opérateur
   contient des opérateurs de types de données simples alors que les
   opérateurs inter-type sont lâches dans la famille.
  </para>

  <para>
   Tous les opérateurs et fonctions d'une famille d'opérateurs doivent avoir
   une sémantique compatible où les pré-requis de la compatibilité sont
   dictés par la méthode indexage. Du coup, vous pouvez vous demander la raison
   pour s'embarrasser de distinguer les sous-ensembles de la famille en tant
   que classes d'opérateur. En fait, dans beaucoup de cas, les divisions en
   classe sont inutiles et la famille est le seul groupe intéressant. La
   raison de la définition de classes d'opérateurs est qu'ils spécifient à
   quel point la famille est nécessaire pour supporter un index particulier.
   S'il existe un index utilisant une classe d'opérateur, alors cette classe
   d'opérateur ne peut pas être supprimée sans supprimer l'index &mdash; mais
   les autres parties de la famille d'opérateurs, donc les autres classes et
   les opérateurs lâches, peuvent être supprimées. Du coup, une classe
   d'opérateur doit être indiquée pour contenir l'ensemble minimum d'opérateurs
   et de fonctions qui sont raisonnablement nécessaire pour travailler avec
   un index sur un type de données spécifique, et ensuite les opérateurs en
   relation mais peuvent être ajoutés en tant que membres lâches de la famille
   d'opérateur.
  </para>

  <para>
   Comme exemple, <productname>PostgreSQL</productname> a une famille d'opérateur
   B-tree interne <literal>integer_ops</literal>, qui inclut les classes
   d'opérateurs <literal>int8_ops</literal>, <literal>int4_ops</literal> et
   <literal>int2_ops</literal> pour les index sur les colonnes <type>bigint</type>
   (<type>int8</type>), <type>integer</type> (<type>int4</type>) et
   <type>smallint</type> (<type>int2</type>) respectivement. La famille
   contient aussi des opérateurs de comparaison inter-type permettant la
   comparaison de deux de ces types, pour qu'un index parmi ces types puisse
   être parcouru en utilisant une valeur de comparaison d'un autre type. La
   famille peut être dupliqué par ces définitions&nbsp;:

   <programlisting><![CDATA[
CREATE OPERATOR FAMILY integer_ops USING btree;

CREATE OPERATOR CLASS int8_ops
DEFAULT FOR TYPE int8 USING btree FAMILY integer_ops AS
  -- standard int8 comparisons
  OPERATOR 1 < ,
  OPERATOR 2 <= ,
  OPERATOR 3 = ,
  OPERATOR 4 >= ,
  OPERATOR 5 > ,
  FUNCTION 1 btint8cmp(int8, int8) ,
  FUNCTION 2 btint8sortsupport(internal) ,
  FUNCTION 3 in_range(int8, int8, int8, boolean, boolean) ;

CREATE OPERATOR CLASS int4_ops
DEFAULT FOR TYPE int4 USING btree FAMILY integer_ops AS
  -- standard int4 comparisons
  OPERATOR 1 < ,
  OPERATOR 2 <= ,
  OPERATOR 3 = ,
  OPERATOR 4 >= ,
  OPERATOR 5 > ,
  FUNCTION 1 btint4cmp(int4, int4) ,
  FUNCTION 2 btint4sortsupport(internal) ,
  FUNCTION 3 in_range(int4, int4, int4, boolean, boolean) ;

CREATE OPERATOR CLASS int2_ops
DEFAULT FOR TYPE int2 USING btree FAMILY integer_ops AS
  -- standard int2 comparisons
  OPERATOR 1 < ,
  OPERATOR 2 <= ,
  OPERATOR 3 = ,
  OPERATOR 4 >= ,
  OPERATOR 5 > ,
  FUNCTION 1 btint2cmp(int2, int2) ,
  FUNCTION 2 btint2sortsupport(internal) ,
  FUNCTION 3 in_range(int2, int2, int2, boolean, boolean) ;

ALTER OPERATOR FAMILY integer_ops USING btree ADD
  -- cross-type comparisons int8 vs int2
  OPERATOR 1 < (int8, int2) ,
  OPERATOR 2 <= (int8, int2) ,
  OPERATOR 3 = (int8, int2) ,
  OPERATOR 4 >= (int8, int2) ,
  OPERATOR 5 > (int8, int2) ,
  FUNCTION 1 btint82cmp(int8, int2) ,

  -- cross-type comparisons int8 vs int4
  OPERATOR 1 < (int8, int4) ,
  OPERATOR 2 <= (int8, int4) ,
  OPERATOR 3 = (int8, int4) ,
  OPERATOR 4 >= (int8, int4) ,
  OPERATOR 5 > (int8, int4) ,
  FUNCTION 1 btint84cmp(int8, int4) ,

  -- cross-type comparisons int4 vs int2
  OPERATOR 1 < (int4, int2) ,
  OPERATOR 2 <= (int4, int2) ,
  OPERATOR 3 = (int4, int2) ,
  OPERATOR 4 >= (int4, int2) ,
  OPERATOR 5 > (int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2) ,

  -- cross-type comparisons int4 vs int8
  OPERATOR 1 < (int4, int8) ,
  OPERATOR 2 <= (int4, int8) ,
  OPERATOR 3 = (int4, int8) ,
  OPERATOR 4 >= (int4, int8) ,
  OPERATOR 5 > (int4, int8) ,
  FUNCTION 1 btint48cmp(int4, int8) ,

  -- cross-type comparisons int2 vs int8
  OPERATOR 1 < (int2, int8) ,
  OPERATOR 2 <= (int2, int8) ,
  OPERATOR 3 = (int2, int8) ,
  OPERATOR 4 >= (int2, int8) ,
  OPERATOR 5 > (int2, int8) ,
  FUNCTION 1 btint28cmp(int2, int8) ,

  -- cross-type comparisons int2 vs int4
  OPERATOR 1 < (int2, int4) ,
  OPERATOR 2 <= (int2, int4) ,
  OPERATOR 3 = (int2, int4) ,
  OPERATOR 4 >= (int2, int4) ,
  OPERATOR 5 > (int2, int4) ,
  FUNCTION 1 btint24cmp(int2, int4) ,

  -- cross-type in_range functions
  FUNCTION 3 in_range(int4, int4, int8, boolean, boolean) ,
  FUNCTION 3 in_range(int4, int4, int2, boolean, boolean) ,
  FUNCTION 3 in_range(int2, int2, int8, boolean, boolean) ,
  FUNCTION 3 in_range(int2, int2, int4, boolean, boolean) ;
]]></programlisting>

   Notez que cette définition <quote>surcharge</quote> la stratégie de
   l'opérateur et les numéros de fonction support&nbsp;: chaque numéro survient
   plusieurs fois dans la famille. Ceci est autorisé aussi longtemps que chaque
   instance d'un numéro particulier a des types de données distincts en entrée.
   Les instances qui ont les deux types en entrée égalent au type en entrée de
   la classe d'opérateur sont les opérateurs primaires et les fonctions de
   support pour cette classe d'opérateur et, dans la plupart des cas, doivent
   être déclarées comme membre de la classe d'opérateur plutôt qu'en tant que
   membres lâches de la famille.
  </para>

  <para>
   Dans une famille d'opérateur B-tree, tous les opérateurs de la famille
   doivent trier de façon compatible, comme c'est spécifié en détail dans
   <xref linkend="btree-behavior"/>. Pour chaque opérateur de la famille, il
   doit y avoir une fonction de support pour les deux mêmes types de données
   en entrée que celui de l'opérateur. Il est recommandé qu'une famille soit
   complète, c'est-à-dire que pour chaque combinaison de types de données,
   tous les opérateurs sont inclus. Chaque classe d'opérateur doit juste
   inclure les opérateurs non inter-types et les fonctions de support pour ce
   type de données.
  </para>

  <para>
   Pour construire une famille d'opérateurs de hachage pour plusieurs types de
   données, des fonctions de support de hachage compatibles doivent être créées
   pour chaque type de données supporté par la famille. Ici, compatibilité
   signifie que les fonctions sont garanties de renvoyer le même code de
   hachage pour toutes les paires de valeurs qui sont considérées égales par
   les opérateurs d'égalité de la famille, même quand les valeurs sont de type
   différent. Ceci est habituellement difficile à accomplir quand les types ont
   différentes représentations physiques, mais cela peut se faire dans la plupart
   des cas. De plus, convertir une valeur à partir d'un type de données
   représenté dans la famille d'opérateur vers un autre type de données aussi
   représenté dans la famille d'opérateur via une coercion implicite ou binaire
   ne doit pas changer la valeur calculée du hachage.
   Notez qu'il y a seulement une fonction de support par type de
   données, pas une par opérateur d'égalité. Il est recommandé qu'une famille
   soit terminée, c'est-à-dire fournit un opérateur d'égalité pour chaque
   combinaison de types de données. Chaque classe d'opérateur doit inclure
   l'opérateur d'égalité non inter-type et la fonction de support pour ce type
   de données.
  </para>

  <para>
   Les index GIN, SP-GiST et GiST n'ont pas de notion explicite d'opérations inter-types.
   L'ensemble des opérateurs supportés est simplement ce que les fonctions de
   support primaire peuvent supporter pour un opérateur donné.
  </para>

  <para>
   Dans BRIN, les pré-requis dépendent de l'ensemble de travail fourni par les
   classes d'opérateur. Pour les classes basées sur <literal>minmax</literal>,
   le comportement requis est le même que pour les familles d'opérateur
   B-tree&nbsp;: tous les opérateurs d'une famille doivent avoir un tri
   compatible, et les conversions ne doivent pas changer l'ordre de tri
   associé.
  </para>

  <note>
   <para>
    Avant <productname>PostgreSQL</productname> 8.3, le concept des familles
    d'opérateurs n'existait pas. Donc, tous les opérateurs inter-type dont le
    but était d'être utilisés avec un index étaient liés directement à la
    classe d'opérateur de l'index. Bien que cette approche fonctionne toujours,
    elle est obsolète car elle rend trop importantes les dépendances de l'index
    et parce que le planificateur peut gérer des comparaisons inter-type avec
    plus d'efficacité que quand les typdes de données ont des opérateurs dans la
    même famille d'opérateur.
   </para>
  </note>

  </sect2>

 <sect2 id="xindex-opclass-dependencies">
  <title>Dépendances du système pour les classes d'opérateur</title>

   <indexterm>
    <primary>Opérateur d'ordonnancement</primary>
   </indexterm>

  <para>
   <productname>PostgreSQL</productname> utilise les classe d'opérateur pour
   inférer les propriétés des opérateurs de plusieurs autres façons que le seul
   usage avec les index. Donc, vous pouvez créer des classes
   d'opérateur même si vous n'avez pas l'intention d'indexer une quelconque
   colonne de votre type de donnée.
  </para>

  <para>
   En particulier, il existe des caractéristiques de SQL telles que
   <literal>ORDER BY</literal> et <literal>DISTINCT</literal> qui requièrent la comparaison et
   le tri des valeurs. Pour implémenter ces caractéristiques sur un type de
   donnée défini par l'utilisateur, <productname>PostgreSQL</productname>
   recherche la classe d'opérateur B-tree par défaut pour le type de donnée. Le
   membre <quote>equals</quote> de cette classe d'opérateur définit pour le système
   la notion d'égalité des valeurs pour <literal>GROUP BY</literal> et
   <literal>DISTINCT</literal>, et le tri ordonné imposé par la classe d'opérateur
   définit le <literal>ORDER BY</literal> par défaut.
  </para>

  <para>
   S'il n'y a pas de classe d'opérateur B-tree par défaut pour le type de
   donnée, le système cherchera une classe d'opérateur de découpage. Mais
   puisque cette classe d'opérateur ne fournit que l'égalité, il est seulement
   capable de supporter le regroupement mais pas le tri.
  </para>

  <para>
   Quand il n'y a pas de classe d'opérateur par défaut pour un type de donnée,
   vous obtenez des erreurs telles que <quote>could not identify an ordering
   operator</quote> si vous essayez d'utiliser ces caractéristiques SQL avec le type
   de donnée.
  </para>

   <note>
    <para>
     Dans les versions de <productname>PostgreSQL</productname> antérieures à
     la 7.4, les opérations de tri et de groupement utilisaient implicitement
     les opérateurs nommés <literal>=</literal>, <literal>&lt;</literal> et
     <literal>&gt;</literal>. Le nouveau comportement qui repose sur les classes
     d'opérateurs par défaut évite d'avoir à faire une quelconque supposition
     sur le comportement des opérateurs avec des noms particuliers.
    </para>
   </note>

  <para>
   Trier par une classe d'opérateur B-tree qui n'est pas celle par défaut est
   possible en précisant l'opérateur inférieur-à de la classe dans une option
   <literal>USING</literal>, par exemple
<programlisting>
SELECT * FROM mytable ORDER BY somecol USING ~&lt;~;
</programlisting>
   Sinon, préciser l'opérateur supérieur-à de la classe dans un
   <literal>USING</literal> sélectionne un tri par ordre décroissant.
  </para>

  <para>
   La comparaison de tableaux d'un type de données utilisateur repose également
   sur la sémantique définie par la classe d'opérateur B-tree par défaut du
   type.  S'il n'y a pas de classe d'opérateur B-tree par défaut, mais qu'il y
   a une classe d'opérateur de type hash, alors l'égalité de tableau est
   supportéee, mais pas la comparaison pour les tris.
  </para>

  <para>
   Une autre fonctionnalité SQL qui nécessite une connaissance encore plus
   spécifique du type de données est l'option
   <literal>RANGE</literal> <replaceable>offset</replaceable>
   <literal>PRECEDING</literal>/<literal>FOLLOWING</literal> de fenêtre
   pour les fonctions de fenêtrage (voir <xref linkend="syntax-window-functions"/>).
   Pour une requête telle que
<programlisting>
SELECT sum(x) OVER (ORDER BY x RANGE BETWEEN 5 PRECEDING AND 10 FOLLOWING)
  FROM mytable;
</programlisting>
   il n'est pas suffisant de savoir comment trier par <literal>x</literal>&nbsp;;
   la base de données doit également comprendre comment
   <quote>soustraire 5</quote> ou <quote>additionner 10</quote> à la valeur de
   <literal>x</literal> de la ligne courante pour identifier les limites de la
   fenêtre courante.  Comparer les limites résultantes aux valeurs de
   <literal>x</literal> des autres lignes est possible en utilisant les
   opérateurs de comparaison fournis par la classe d'opérateur B-tree qui
   définit le tri de l'<literal>ORDER BY</literal> &mdash; mais les opérateurs
   d'addition et de soustraction ne font pas partie de la classe d'opérateur,
   alors lesquels devraient être utilisés&nbsp;?  Inscrire en dur ce choix ne serait
   pas désirable, car différents ordres de tris (différentes classes d'opérateur
   B-tree) pourraient nécessiter des comportements différents.  Ainsi, une
   classe d'opérateur B-tree peut préciser une fonction de support
   <firstterm>in_range</firstterm> qui encapsule les comportements d'addition
   et de soustraction faisant sens pour son ordre de tri.  Elle peut même
   fournir plus d'une fonction de support in_range, s'il fait sens d'utiliser
   plus d'un type de données comme offset dans la clause
   <literal>RANGE</literal>.
   Si la classe d'opérateur B-tree associée à la clause <literal>ORDER
   BY</literal> de la fenêtre n'a pas de fonction de support in_range
   correspondante, l'option
   <literal>RANGE</literal> <replaceable>offset</replaceable>
   <literal>PRECEDING</literal>/<literal>FOLLOWING</literal>
   n'est pas supportée.
  </para>

  <para>
   Un autre point important est qu'un opérateur apparaissant dans une famille
   d'opérateur de hachage est un candidat pour les jointures de hachage, les
   agrégations de hachage et les optimisations relatives. La famille
   d'opérateur de hachage est essentiel ici car elle identifie le(s)
   fonction(s) de hachage à utiliser.
  </para>
 </sect2>

 <sect2 id="xindex-ordering-ops">
  <title>Opérateurs de tri</title>

  <para>
   Certaines méthodes d'accès aux index (actuellement seulement GiST)
   supportent le concept d'<firstterm>opérateurs de tri</firstterm>. Nous
   avons discuté jusqu'à maintenant d'<firstterm>opérateurs de
   recherche</firstterm>. Un opérateur de recherche est utilisable pour
   rechercher dans un index toutes les lignes satisfaisant le prédicat
   <literal>WHERE</literal> <replaceable>colonne_indexée</replaceable>
   <replaceable>operateur</replaceable> <replaceable>constante</replaceable>.
   Notez que rien n'est promis sur l'ordre dans lequel les lignes
   correspondantes seront renvoyées. Au contraire, un opérateur de tri ne
   restreint pas l'ensemble de lignes qu'il peut renvoyer mais, à la place,
   détermine leur ordre. Un opérateur de tri est utilisé pour que l'index
   puisse être parcouru pour renvoyer les lignes dans l'ordre représenté par
   <literal>ORDER BY</literal> <replaceable>colonne_indexée</replaceable>
   <replaceable>opérateur</replaceable> <replaceable>constante</replaceable>.
   Le but de définir des opérateurs de tri de cette façon est de supporter les
   recherches du type plus-proche-voisin si l'opérateur sait mesurer les
   distances. Par exemple, une requête comme
<programlisting><![CDATA[
SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;
]]>
   </programlisting>
   trouve les dix emplacements les plus proches d'un point cible donné. Un
   index GiST sur la colonne location peut faire cela de façon efficace
   parce que <literal>&lt;-&gt;</literal> est un opérateur de tri.
  </para>

  <para>
   Bien que les opérateurs de recherche doivent renvoyer des résultats
   booléens, les opérateurs de tri renvoient habituellement d'autres types,
   tel que des float ou numeric pour les distances. Ce type n'est
   habituellement pas le même que le type de données indexé. Pour éviter les
   suppositions en dur sur le comportement des différents types de données, la
   définition d'un opérateur de tro doit nommer une famille d'opérateur B-tree
   qui spécifie l'ordre de tri du type de données résultant. Comme indiqué
   dans la section précédente, les familles d'opérateur B-tree définissent la
   notion de tri de <productname>PostgreSQL</productname>, donc c'est une
   représentation naturelle. Comme l'opérateur <literal>&lt;-&gt;</literal>
   renvoie <type>float8</type>, il peut être indiqué dans la commande de
   création d'une classe d'opérateur&nbsp;:
   <programlisting><![CDATA[
OPERATOR 15    <-> (point, point) FOR ORDER BY float_ops
]]>
   </programlisting>
   où <literal>float_ops</literal> est la famille d'opérateur interne qui
   inclut les opérations sur <type>float8</type>. Cette déclaration indique
   que l'index est capable de renvoyer des lignes dans l'ordre de valeurs de
   plus en plus hautes de l'opérateur <literal>&lt;-&gt;</literal>.
  </para>
 </sect2>

 <sect2 id="xindex-opclass-features">
  <title>Caractéristiques spéciales des classes d'opérateur</title>

  <para>
   Il y a deux caractéristiques spéciales des classes d'opérateur dont nous
   n'avons pas encore parlées, essentiellement parce qu'elles ne sont pas utiles
   avec les méthodes d'index les plus communément utilisées.
  </para>

  <para>
   Normalement, déclarer un opérateur comme membre d'une classe ou d'une famille
   d'opérateur
   signifie que la méthode d'indexation peut retrouver exactement l'ensemble de
   lignes qui satisfait la condition <literal>WHERE</literal> utilisant cet opérateur.
   Par exemple&nbsp;:
   <programlisting>SELECT * FROM table WHERE colonne_entier &lt; 4;
   </programlisting>
   peut être accompli exactement par un index B-tree sur la colonne entière.
   Mais il y a des cas où un index est utile comme un guide inexact vers la
   colonne correspondante. Par exemple, si un index GiST enregistre seulement
   les rectangles limite des objets géométriques, alors il ne peut pas exactement satisfaire
   une condition <literal>WHERE</literal> qui teste le chevauchement entre des objets
   non rectangulaires comme des polygones. Cependant, nous pourrions utiliser
   l'index pour trouver des objets dont les rectangles limites chevauchent les
   limites de l'objet cible. Dans ce cas, l'index est dit être à perte
   pour l'opérateur. Les recherches par index à perte sont implémentées en ayant
   une méthode d'indexage qui renvoie un drapeau <firstterm>recheck</firstterm>
   quand une ligne pourrait ou non satisfaire la condition de la requête. Le
   système principal testera ensuite la condition originale de la requête sur
   la ligne récupérée pour s'assurer que la correspondance est réelle. Cette
   approche fonctionne si l'index garantit de renvoyer toutes les lignes
   requises, ainsi que quelques lignes supplémentaires qui pourront être
   éliminées par la vérification. Les méthodes d'indexage qui supportent
   les recherches à perte (actuellement GiST, SP-GiST et GIN) permettent aux fonctions
   de support des classes individuelles d'opérateurs de lever le drapeau
   recheck, et donc c'est essentiellement une fonctionnalité pour les
   classes d'opérateur.
  </para>

  <para>
   Considérons à nouveau la situation où nous gardons seulement dans l'index le
   rectangle délimitant un objet complexe comme un polygone. Dans ce cas, il
   n'est pas très intéressant de conserver le polygone entier dans l'index -
   nous pouvons aussi bien conserver seulement un objet simple du type
   <type>box</type>. Cette situation est exprimée par l'option <literal>STORAGE</literal>
   dans la commande <command>CREATE OPERATOR CLASS</command>&nbsp;: nous aurons à
   écrire quelque chose comme&nbsp;:

   <programlisting>CREATE OPERATOR CLASS polygon_ops
    DEFAULT FOR TYPE polygon USING gist AS
        ...
        STORAGE box;
   </programlisting>

   Actuellement, seule les méthodes d'indexation GiST, GIN et BRIN supportent un type
   <literal>STORAGE</literal> qui soit différent du type de donnée de la
   colonne. Les routines d'appui de GiST pour la compression
   (<function>compress</function>) et la décompression
   (<function>decompress</function>) doivent s'occuper de la conversion du type
   de donnée quand <literal>STORAGE</literal> est utilisé. Avec GIN, le type
   <literal>STORAGE</literal> identifie le type des valeurs <quote>key</quote>,
   qui est normalement différent du type de la colonne indexée &mdash; par
   exemple, une classe d'opérateur pour des colonnes de tableaux d'entiers
   pourrait avoir des clés qui sont seulement des entiers. Les routines de
   support GIN <function>extractValue</function> et
   <function>extractQuery</function> sont responsables de l'extraction des clés
   à partir des valeurs indexées.
   BRIN est similaire à GIN&nbsp;: le type <literal>STORAGE</literal> identifie
   le type de valeurs résumées stockées, et les procédures de support des classes
   d'opérateur sont responsables de l'interprétation correcte des valeurs
   résumées.
  </para>
 </sect2>

</sect1>
