<?xml version="1.0" encoding="UTF-8"?>
<chapter id="brin">
 <title>Index BRIN</title>

 <indexterm>
  <primary>index</primary>
  <secondary>BRIN</secondary>
 </indexterm>

 <sect1 id="brin-intro">
  <title>Introduction</title>

  <para>
   <acronym>BRIN</acronym> signifie Block Range Index, soit index par
   intervalles de bloc. <acronym>BRIN</acronym> est conçu pour gérer de grosses
   tables dont certaines ont des colonnes ayant une corrélation naturelle avec
   leur stockage physique.
  </para>

  <para>
   <acronym>BRIN</acronym> fonctionne en terme d'<firstterm>intervalle de blocs</firstterm>
   (ou <quote>intervalle de pages</quote>).
   Un <firstterm>intervalle de bloc</firstterm> est un
   groupe de blocs physiquement adjacents dans la table&nbsp;; Pour chaque
   gamme de bloc, un résumé des informations est stocké par l'index. Un exemple
   courant est une table avec une colonne date, contenant les références des
   ventes d'un magasin. Chaque commande y serait enregistrée chronologiquement.
   Dans la plupart des cas, les données seront donc insérées dans le même ordre
   où elles apparaîtront par la suite. De la même manière, une table, avec une
   colonne code postal, pourrait avoir tous les codes d'une même ville
   rassemblés naturellement au même endroit.
  </para>

  <para>
   Les index <acronym>BRIN</acronym> peuvent répondre à des requêtes via un
   parcours d'index bitmap classique, et retourneront toutes les lignes de
   toutes les pages dans chaque intervalle si le résumé des informations
   contenues dans l'index est cohérent avec les conditions de la requête.
   L'exécuteur de la requête doit revérifier ces lignes et annuler celles qui
   ne répondent pas aux conditions initiales de la requête. En d'autres termes,
   on parle d'index à perte (<foreignphrase>lossy</foreignphrase>). Comme
   l'index <acronym>BRIN</acronym> est un petit index, parcourir cet index
   ajoute une légère surcharge par rapport à un parcours séquentiel mais permet
   d'éviter de parcourir des grandes parties de la table où on sait qu'on ne
   trouvera pas de lignes à remonter.
  </para>

  <para>
   Les données spécifiques qu'un index <acronym>BRIN</acronym> va stocker, de
   même que les requêtes spécifiques auquel l'index va pouvoir répondre
   dépendent de la classe d'opérateur choisie pour chaque colonne de l'index.
   Les types de données possédant un ordre de tri linéaire peuvent utiliser une
   classe d'opérateur qui ne conserve que la valeur minimale et la valeur
   maximale dans chaque intervalle de bloc. Par exemple, un type géométrique
   peut stocker une <foreignphrase>bounding box</foreignphrase> pour tous les
   objets de l'intervalle de bloc.
  </para>

  <para>
   La taille de l'intervalle de bloc est déterminée à la création de l'index
   par le paramètre <literal>pages_per_range</literal> Le nombre des entrées de
   l'index sera égal à la taille de la relation en page, divisée par la valeur
   sélectionnée dans <literal>pages_per_range</literal>. De ce fait, plus ce
   nombre est bas, plus l'index sera volumineux (il y a plus d'entrées d'index
   à stocker) mais, en même temps, le résumé des informations stockées pourra
   être plus précis, et un nombre plus important de blocs de données pourront
   être ignorés pendant le parcours d'index.
  </para>

  <sect2 id="brin-operation">
   <title>Maintenance de l'index</title>

   <para>
    Lors de la création de l'index, toutes les pages de la table sont
    parcourues et un résumé des lignes de l'index est créé pour chaque
    intervalle, incluant certainement aussi un intervalle incomplet à la fin.
    Lors de l'ajout de nouvelles données dans des pages déja incluses dans des
    résumés, cela va entrainer la mise à jour du résumé, avec les informations
    sur les nouvelles lignes insérées.
    Lorsqu'une nouvelle page est créée et qu'elle ne correspond à aucun des
    derniers intervalles résumés, l'intervalle auquel appartient la nouvelle
    page n'acquiert pas automatiquement un résumé&nbsp;; ces lignes restent sans
    résumé jusqu'à ce qu'une exécution de résumé soit demandée plus tard, créant
    ainsi le résumé initial pour cet intervalle.
   </para>

   <para>
    Il existe plusieurs façons de déclencher le résumé initial d'un intervalle
    de blocs. Si la table est traitée par VACUUM, soit manuellement soit par
    l'<link linkend="autovacuum">autovacuum</link>, tous les intervalles de
    blocs existants non résumés sont résumés. De plus, si le paramètre <xref
    linkend="index-reloption-autosummarize"/> de l'index est activé, ce qui
    n'est pas le cas par défaut, à chaque fois que l'autovacuum est exécuté dans
    cette base, le résumé surviendra pour tous les intervalles de blocs non
    résumés qui ont été remplis, que la table elle-même soit traitée par
    l'autovacuum ou pas&nbsp;; voir ci-dessous.
   </para>

   <para>
    Dernièrement, les fonctions suivantes peuvent être utilisées&nbsp;:
    <simplelist>
     <member>
      <function>brin_summarize_new_values(regclass)</function>
      qui résume tous les blocs sans résumé&nbsp;;
     </member>
     <member>
      <function>brin_summarize_range(regclass, bigint)</function>
      qui résume seulement l'intervalle contenant le bloc donné
      s'il n'est pas résumé.
     </member>
    </simplelist>
   </para>

   <para>
    Quand le résumé automatique est activé, une requête est envoyée à
    l'<literal>autovacuum</literal> pour exécuter un résumé cible pour un
    intervalle de bloc quand une insertion est détecté pour le premier élément
    du premier bloc du prochain intervalle de bloc, opération à réaliser la
    prochaine fois qu'un autovacuum worker finit son exécution dans la même
    base. Si la queue des demandes est remplie, la demande n'est pas
    enregistrée et un message est enregistré dans les traces du serveur&nbsp;:
    <screen>
 LOG:  request for BRIN range summarization for index "brin_wi_idx" page 128 was not recorded
    </screen>
    Quand cela arrive, l'intervalle restera non résumé jusqu'à la prochaine
    exécution d'un vacuum standard sur la table ou jusqu'à ce qu'une des
    fonctions mentionnées ci-dessus soit appelée.
   </para>

   <para>
    Inversement, un intervalle peut se voir supprimer son résumé avec la
    fonction <function>brin_desummarize_range(regclass, bigint)</function>, qui
    est utile quand l'enregistrement de l'index n'est plus une très bonne
    représentation car les valeurs existantes ont changées. Voir <xref
    linkend="functions-admin-index"/> pour les détails.
   </para>
  </sect2>
 </sect1>

 <sect1 id="brin-builtin-opclasses">
  <title>Classes d'opérateur intégrées</title>

  <para>
   La distribution du noyau <productname>PostgreSQL</productname> inclut la
   classe d'opérateur <acronym>BRIN</acronym> montrée dans <xref
   linkend="brin-builtin-opclasses-table"/>.
  </para>

  <para>
   La classe d'opérateur <firstterm>minmax</firstterm> stocke les valeurs
   minimale et maximale apparaissant dans l'intervalle de la colonne indexée.
   L'opérateur de classe <firstterm>inclusion</firstterm> stocke une valeur
   qui est incluse dans les valeurs contenues dans l'intervalle de la colonne
   indexée. Les classes d'opérateur <firstterm>bloom</firstterm> génèrent un
   filtre Bloom pour toutes les valeurs dans l'intervalle. Les classes
   d'opérateur <firstterm>minmax-multi</firstterm> conservent les multiples
   valeurs minimale et maximale, représentant les valeurs apparaissant dans
   la colonne indexée dans l'intervalle.
  </para>

  <table id="brin-builtin-opclasses-table">
   <title>Classe d'opérateur <acronym>BRIN</acronym> intégrée</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Opérateurs indexables</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry valign="middle" morerows="4"><literal>bit_minmax_ops</literal></entry>
      <entry><literal>= (bit,bit)</literal></entry>
     </row>
     <row><entry><literal>&lt; (bit,bit)</literal></entry></row>
     <row><entry><literal>&gt; (bit,bit)</literal></entry></row>
     <row><entry><literal>&lt;= (bit,bit)</literal></entry></row>
     <row><entry><literal>&gt;= (bit,bit)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="12"><literal>box_inclusion_ops</literal></entry>
      <entry><literal>@&gt; (box,point)</literal></entry>
     </row>
     <row><entry><literal>&lt;&lt; (box,box)</literal></entry></row>
     <row><entry><literal>&amp;&lt; (box,box)</literal></entry></row>
     <row><entry><literal>&amp;&gt; (box,box)</literal></entry></row>
     <row><entry><literal>&gt;&gt; (box,box)</literal></entry></row>
     <row><entry><literal>&lt;@ (box,box)</literal></entry></row>
     <row><entry><literal>@&gt; (box,box)</literal></entry></row>
     <row><entry><literal>~= (box,box)</literal></entry></row>
     <row><entry><literal>&amp;&amp; (box,box)</literal></entry></row>
     <row><entry><literal>&lt;&lt;| (box,box)</literal></entry></row>
     <row><entry><literal>&amp;&lt;| (box,box)</literal></entry></row>
     <row><entry><literal>|&amp;&gt; (box,box)</literal></entry></row>
     <row><entry><literal>|&gt;&gt; (box,box)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>bpchar_bloom_ops</literal></entry>
      <entry><literal>= (character,character)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>bpchar_minmax_ops</literal></entry>
      <entry><literal>= (character,character)</literal></entry>
     </row>
     <row><entry><literal>&lt; (character,character)</literal></entry></row>
     <row><entry><literal>&lt;= (character,character)</literal></entry></row>
     <row><entry><literal>&gt; (character,character)</literal></entry></row>
     <row><entry><literal>&gt;= (character,character)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>bytea_bloom_ops</literal></entry>
      <entry><literal>= (bytea,bytea)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>bytea_minmax_ops</literal></entry>
      <entry><literal>= (bytea,bytea)</literal></entry>
     </row>
     <row><entry><literal>&lt; (bytea,bytea)</literal></entry></row>
     <row><entry><literal>&lt;= (bytea,bytea)</literal></entry></row>
     <row><entry><literal>&gt; (bytea,bytea)</literal></entry></row>
     <row><entry><literal>&gt;= (bytea,bytea)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>char_bloom_ops</literal></entry>
      <entry><literal>= ("char","char")</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>char_minmax_ops</literal></entry>
      <entry><literal>= ("char","char")</literal></entry>
     </row>
     <row><entry><literal>&lt; ("char","char")</literal></entry></row>
     <row><entry><literal>&lt;= ("char","char")</literal></entry></row>
     <row><entry><literal>&gt; ("char","char")</literal></entry></row>
     <row><entry><literal>&gt;= ("char","char")</literal></entry></row>

     <row>
      <entry valign="middle"><literal>date_bloom_ops</literal></entry>
      <entry><literal>= (date,date)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>date_minmax_ops</literal></entry>
      <entry><literal>= (date,date)</literal></entry>
     </row>
     <row><entry><literal>&lt; (date,date)</literal></entry></row>
     <row><entry><literal>&lt;= (date,date)</literal></entry></row>
     <row><entry><literal>&gt; (date,date)</literal></entry></row>
     <row><entry><literal>&gt;= (date,date)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>date_minmax_multi_ops</literal></entry>
      <entry><literal>= (date,date)</literal></entry>
     </row>
     <row><entry><literal>&lt; (date,date)</literal></entry></row>
     <row><entry><literal>&lt;= (date,date)</literal></entry></row>
     <row><entry><literal>&gt; (date,date)</literal></entry></row>
     <row><entry><literal>&gt;= (date,date)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>float4_bloom_ops</literal></entry>
      <entry><literal>= (float4,float4)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>float4_minmax_ops</literal></entry>
      <entry><literal>= (float4,float4)</literal></entry>
     </row>
     <row><entry><literal>&lt; (float4,float4)</literal></entry></row>
     <row><entry><literal>&gt; (float4,float4)</literal></entry></row>
     <row><entry><literal>&lt;= (float4,float4)</literal></entry></row>
     <row><entry><literal>&gt;= (float4,float4)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>float4_minmax_multi_ops</literal></entry>
      <entry><literal>= (float4,float4)</literal></entry>
     </row>
     <row><entry><literal>&lt; (float4,float4)</literal></entry></row>
     <row><entry><literal>&gt; (float4,float4)</literal></entry></row>
     <row><entry><literal>&lt;= (float4,float4)</literal></entry></row>
     <row><entry><literal>&gt;= (float4,float4)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>float8_bloom_ops</literal></entry>
      <entry><literal>= (float8,float8)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>float8_minmax_ops</literal></entry>
      <entry><literal>= (float8,float8)</literal></entry>
     </row>
     <row><entry><literal>&lt; (float8,float8)</literal></entry></row>
     <row><entry><literal>&lt;= (float8,float8)</literal></entry></row>
     <row><entry><literal>&gt; (float8,float8)</literal></entry></row>
     <row><entry><literal>&gt;= (float8,float8)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>float8_minmax_multi_ops</literal></entry>
      <entry><literal>= (float8,float8)</literal></entry>
     </row>
     <row><entry><literal>&lt; (float8,float8)</literal></entry></row>
     <row><entry><literal>&lt;= (float8,float8)</literal></entry></row>
     <row><entry><literal>&gt; (float8,float8)</literal></entry></row>
     <row><entry><literal>&gt;= (float8,float8)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="5"><literal>inet_inclusion_ops</literal></entry>
      <entry><literal>&lt;&lt; (inet,inet)</literal></entry>
     </row>
     <row><entry><literal>&lt;&lt;= (inet,inet)</literal></entry></row>
     <row><entry><literal>&gt;&gt; (inet,inet)</literal></entry></row>
     <row><entry><literal>&gt;&gt;= (inet,inet)</literal></entry></row>
     <row><entry><literal>= (inet,inet)</literal></entry></row>
     <row><entry><literal>&amp;&amp; (inet,inet)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>inet_bloom_ops</literal></entry>
      <entry><literal>= (inet,inet)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>inet_minmax_ops</literal></entry>
      <entry><literal>= (inet,inet)</literal></entry>
     </row>
     <row><entry><literal>&lt; (inet,inet)</literal></entry></row>
     <row><entry><literal>&lt;= (inet,inet)</literal></entry></row>
     <row><entry><literal>&gt; (inet,inet)</literal></entry></row>
     <row><entry><literal>&gt;= (inet,inet)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>inet_minmax_multi_ops</literal></entry>
      <entry><literal>= (inet,inet)</literal></entry>
     </row>
     <row><entry><literal>&lt; (inet,inet)</literal></entry></row>
     <row><entry><literal>&lt;= (inet,inet)</literal></entry></row>
     <row><entry><literal>&gt; (inet,inet)</literal></entry></row>
     <row><entry><literal>&gt;= (inet,inet)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>int2_bloom_ops</literal></entry>
      <entry><literal>= (int2,int2)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>int2_minmax_ops</literal></entry>
      <entry><literal>= (int2,int2)</literal></entry>
     </row>
     <row><entry><literal>&lt; (int2,int2)</literal></entry></row>
     <row><entry><literal>&gt; (int2,int2)</literal></entry></row>
     <row><entry><literal>&lt;= (int2,int2)</literal></entry></row>
     <row><entry><literal>&gt;= (int2,int2)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>int2_minmax_multi_ops</literal></entry>
      <entry><literal>= (int2,int2)</literal></entry>
     </row>
     <row><entry><literal>&lt; (int2,int2)</literal></entry></row>
     <row><entry><literal>&gt; (int2,int2)</literal></entry></row>
     <row><entry><literal>&lt;= (int2,int2)</literal></entry></row>
     <row><entry><literal>&gt;= (int2,int2)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>int4_bloom_ops</literal></entry>
      <entry><literal>= (int4,int4)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>int4_minmax_ops</literal></entry>
      <entry><literal>= (int4,int4)</literal></entry>
     </row>
     <row><entry><literal>&lt; (int4,int4)</literal></entry></row>
     <row><entry><literal>&gt; (int4,int4)</literal></entry></row>
     <row><entry><literal>&lt;= (int4,int4)</literal></entry></row>
     <row><entry><literal>&gt;= (int4,int4)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>int4_minmax_multi_ops</literal></entry>
      <entry><literal>= (int4,int4)</literal></entry>
     </row>
     <row><entry><literal>&lt; (int4,int4)</literal></entry></row>
     <row><entry><literal>&gt; (int4,int4)</literal></entry></row>
     <row><entry><literal>&lt;= (int4,int4)</literal></entry></row>
     <row><entry><literal>&gt;= (int4,int4)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>int8_bloom_ops</literal></entry>
      <entry><literal>= (bigint,bigint)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>int8_minmax_ops</literal></entry>
      <entry><literal>= (bigint,bigint)</literal></entry>
     </row>
     <row><entry><literal>&lt; (bigint,bigint)</literal></entry></row>
     <row><entry><literal>&gt; (bigint,bigint)</literal></entry></row>
     <row><entry><literal>&lt;= (bigint,bigint)</literal></entry></row>
     <row><entry><literal>&gt;= (bigint,bigint)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>int8_minmax_multi_ops</literal></entry>
      <entry><literal>= (bigint,bigint)</literal></entry>
     </row>
     <row><entry><literal>&lt; (bigint,bigint)</literal></entry></row>
     <row><entry><literal>&gt; (bigint,bigint)</literal></entry></row>
     <row><entry><literal>&lt;= (bigint,bigint)</literal></entry></row>
     <row><entry><literal>&gt;= (bigint,bigint)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>interval_bloom_ops</literal></entry>
      <entry><literal>= (interval,interval)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>interval_minmax_ops</literal></entry>
      <entry><literal>= (interval,interval)</literal></entry>
     </row>
     <row><entry><literal>&lt; (interval,interval)</literal></entry></row>
     <row><entry><literal>&lt;= (interval,interval)</literal></entry></row>
     <row><entry><literal>&gt; (interval,interval)</literal></entry></row>
     <row><entry><literal>&gt;= (interval,interval)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>interval_minmax_multi_ops</literal></entry>
      <entry><literal>= (interval,interval)</literal></entry>
     </row>
     <row><entry><literal>&lt; (interval,interval)</literal></entry></row>
     <row><entry><literal>&lt;= (interval,interval)</literal></entry></row>
     <row><entry><literal>&gt; (interval,interval)</literal></entry></row>
     <row><entry><literal>&gt;= (interval,interval)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>macaddr_bloom_ops</literal></entry>
      <entry><literal>= (macaddr,macaddr)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>macaddr_minmax_ops</literal></entry>
      <entry><literal>= (macaddr,macaddr)</literal></entry>
     </row>
     <row><entry><literal>&lt; (macaddr,macaddr)</literal></entry></row>
     <row><entry><literal>&lt;= (macaddr,macaddr)</literal></entry></row>
     <row><entry><literal>&gt; (macaddr,macaddr)</literal></entry></row>
     <row><entry><literal>&gt;= (macaddr,macaddr)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>macaddr_minmax_multi_ops</literal></entry>
      <entry><literal>= (macaddr,macaddr)</literal></entry>
     </row>
     <row><entry><literal>&lt; (macaddr,macaddr)</literal></entry></row>
     <row><entry><literal>&lt;= (macaddr,macaddr)</literal></entry></row>
     <row><entry><literal>&gt; (macaddr,macaddr)</literal></entry></row>
     <row><entry><literal>&gt;= (macaddr,macaddr)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>macaddr8_bloom_ops</literal></entry>
      <entry><literal>= (macaddr8,macaddr8)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>macaddr8_minmax_ops</literal></entry>
      <entry><literal>= (macaddr8,macaddr8)</literal></entry>
     </row>
     <row><entry><literal>&lt; (macaddr8,macaddr8)</literal></entry></row>
     <row><entry><literal>&lt;= (macaddr8,macaddr8)</literal></entry></row>
     <row><entry><literal>&gt; (macaddr8,macaddr8)</literal></entry></row>
     <row><entry><literal>&gt;= (macaddr8,macaddr8)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>macaddr8_minmax_multi_ops</literal></entry>
      <entry><literal>= (macaddr8,macaddr8)</literal></entry>
     </row>
     <row><entry><literal>&lt; (macaddr8,macaddr8)</literal></entry></row>
     <row><entry><literal>&lt;= (macaddr8,macaddr8)</literal></entry></row>
     <row><entry><literal>&gt; (macaddr8,macaddr8)</literal></entry></row>
     <row><entry><literal>&gt;= (macaddr8,macaddr8)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>name_bloom_ops</literal></entry>
      <entry><literal>= (name,name)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>name_minmax_ops</literal></entry>
      <entry><literal>= (name,name)</literal></entry>
     </row>
     <row><entry><literal>&lt; (name,name)</literal></entry></row>
     <row><entry><literal>&lt;= (name,name)</literal></entry></row>
     <row><entry><literal>&gt; (name,name)</literal></entry></row>
     <row><entry><literal>&gt;= (name,name)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>numeric_bloom_ops</literal></entry>
      <entry><literal>= (numeric,numeric)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>numeric_minmax_ops</literal></entry>
      <entry><literal>= (numeric,numeric)</literal></entry>
     </row>
     <row><entry><literal>&lt; (numeric,numeric)</literal></entry></row>
     <row><entry><literal>&lt;= (numeric,numeric)</literal></entry></row>
     <row><entry><literal>&gt; (numeric,numeric)</literal></entry></row>
     <row><entry><literal>&gt;= (numeric,numeric)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>numeric_minmax_multi_ops</literal></entry>
      <entry><literal>= (numeric,numeric)</literal></entry>
     </row>
     <row><entry><literal>&lt; (numeric,numeric)</literal></entry></row>
     <row><entry><literal>&lt;= (numeric,numeric)</literal></entry></row>
     <row><entry><literal>&gt; (numeric,numeric)</literal></entry></row>
     <row><entry><literal>&gt;= (numeric,numeric)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>oid_bloom_ops</literal></entry>
      <entry><literal>= (oid,oid)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>oid_minmax_ops</literal></entry>
      <entry><literal>= (oid,oid)</literal></entry>
     </row>
     <row><entry><literal>&lt; (oid,oid)</literal></entry></row>
     <row><entry><literal>&gt; (oid,oid)</literal></entry></row>
     <row><entry><literal>&lt;= (oid,oid)</literal></entry></row>
     <row><entry><literal>&gt;= (oid,oid)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>oid_minmax_multi_ops</literal></entry>
      <entry><literal>= (oid,oid)</literal></entry>
     </row>
     <row><entry><literal>&lt; (oid,oid)</literal></entry></row>
     <row><entry><literal>&gt; (oid,oid)</literal></entry></row>
     <row><entry><literal>&lt;= (oid,oid)</literal></entry></row>
     <row><entry><literal>&gt;= (oid,oid)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>pg_lsn_bloom_ops</literal></entry>
      <entry><literal>= (pg_lsn,pg_lsn)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>pg_lsn_minmax_ops</literal></entry>
      <entry><literal>= (pg_lsn,pg_lsn)</literal></entry>
     </row>
     <row><entry><literal>&lt; (pg_lsn,pg_lsn)</literal></entry></row>
     <row><entry><literal>&gt; (pg_lsn,pg_lsn)</literal></entry></row>
     <row><entry><literal>&lt;= (pg_lsn,pg_lsn)</literal></entry></row>
     <row><entry><literal>&gt;= (pg_lsn,pg_lsn)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>pg_lsn_minmax_multi_ops</literal></entry>
      <entry><literal>= (pg_lsn,pg_lsn)</literal></entry>
     </row>
     <row><entry><literal>&lt; (pg_lsn,pg_lsn)</literal></entry></row>
     <row><entry><literal>&gt; (pg_lsn,pg_lsn)</literal></entry></row>
     <row><entry><literal>&lt;= (pg_lsn,pg_lsn)</literal></entry></row>
     <row><entry><literal>&gt;= (pg_lsn,pg_lsn)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="13"><literal>range_inclusion_ops</literal></entry>
      <entry><literal>= (anyrange,anyrange)</literal></entry>
     </row>
     <row><entry><literal>&lt; (anyrange,anyrange)</literal></entry></row>
     <row><entry><literal>&lt;= (anyrange,anyrange)</literal></entry></row>
     <row><entry><literal>&gt;= (anyrange,anyrange)</literal></entry></row>
     <row><entry><literal>&gt; (anyrange,anyrange)</literal></entry></row>
     <row><entry><literal>&amp;&amp; (anyrange,anyrange)</literal></entry></row>
     <row><entry><literal>@&gt; (anyrange,anyelement)</literal></entry></row>
     <row><entry><literal>@&gt; (anyrange,anyrange)</literal></entry></row>
     <row><entry><literal>&lt;@ (anyrange,anyrange)</literal></entry></row>
     <row><entry><literal>&lt;&lt; (anyrange,anyrange)</literal></entry></row>
     <row><entry><literal>&gt;&gt; (anyrange,anyrange)</literal></entry></row>
     <row><entry><literal>&amp;&lt; (anyrange,anyrange)</literal></entry></row>
     <row><entry><literal>&amp;&gt; (anyrange,anyrange)</literal></entry></row>
     <row><entry><literal>-|- (anyrange,anyrange)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>text_bloom_ops</literal></entry>
      <entry><literal>= (text,text)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>text_minmax_ops</literal></entry>
      <entry><literal>= (text,text)</literal></entry>
     </row>
     <row><entry><literal>&lt; (text,text)</literal></entry></row>
     <row><entry><literal>&lt;= (text,text)</literal></entry></row>
     <row><entry><literal>&gt; (text,text)</literal></entry></row>
     <row><entry><literal>&gt;= (text,text)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>tid_bloom_ops</literal></entry>
      <entry><literal>= (tid,tid)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>tid_minmax_ops</literal></entry>
      <entry><literal>= (tid,tid)</literal></entry>
     </row>
     <row><entry><literal>&lt; (tid,tid)</literal></entry></row>
     <row><entry><literal>&gt; (tid,tid)</literal></entry></row>
     <row><entry><literal>&lt;= (tid,tid)</literal></entry></row>
     <row><entry><literal>&gt;= (tid,tid)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>tid_minmax_multi_ops</literal></entry>
      <entry><literal>= (tid,tid)</literal></entry>
     </row>
     <row><entry><literal>&lt; (tid,tid)</literal></entry></row>
     <row><entry><literal>&gt; (tid,tid)</literal></entry></row>
     <row><entry><literal>&lt;= (tid,tid)</literal></entry></row>
     <row><entry><literal>&gt;= (tid,tid)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>timestamp_bloom_ops</literal></entry>
      <entry><literal>= (timestamp,timestamp)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>timestamp_minmax_ops</literal></entry>
      <entry><literal>= (timestamp,timestamp)</literal></entry>
     </row>
     <row><entry><literal>&lt; (timestamp,timestamp)</literal></entry></row>
     <row><entry><literal>&lt;= (timestamp,timestamp)</literal></entry></row>
     <row><entry><literal>&gt; (timestamp,timestamp)</literal></entry></row>
     <row><entry><literal>&gt;= (timestamp,timestamp)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>timestamp_minmax_multi_ops</literal></entry>
      <entry><literal>= (timestamp,timestamp)</literal></entry>
     </row>
     <row><entry><literal>&lt; (timestamp,timestamp)</literal></entry></row>
     <row><entry><literal>&lt;= (timestamp,timestamp)</literal></entry></row>
     <row><entry><literal>&gt; (timestamp,timestamp)</literal></entry></row>
     <row><entry><literal>&gt;= (timestamp,timestamp)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>timestamptz_bloom_ops</literal></entry>
      <entry><literal>= (timestamptz,timestamptz)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>timestamptz_minmax_ops</literal></entry>
      <entry><literal>= (timestamptz,timestamptz)</literal></entry>
     </row>
     <row><entry><literal>&lt; (timestamptz,timestamptz)</literal></entry></row>
     <row><entry><literal>&lt;= (timestamptz,timestamptz)</literal></entry></row>
     <row><entry><literal>&gt; (timestamptz,timestamptz)</literal></entry></row>
     <row><entry><literal>&gt;= (timestamptz,timestamptz)</literal></entry></row>

     <row>
     <entry valign="middle" morerows="4"><literal>timestamptz_minmax_multi_ops</literal></entry >
      <entry><literal>= (timestamptz,timestamptz)</literal></entry>
     </row>
     <row><entry><literal>&lt; (timestamptz,timestamptz)</literal></entry></row>
     <row><entry><literal>&lt;= (timestamptz,timestamptz)</literal></entry></row>
     <row><entry><literal>&gt; (timestamptz,timestamptz)</literal></entry></row>
     <row><entry><literal>&gt;= (timestamptz,timestamptz)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>time_bloom_ops</literal></entry>
      <entry><literal>= (time,time)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>time_minmax_ops</literal></entry>
      <entry><literal>= (time,time)</literal></entry>
     </row>
     <row><entry><literal>&lt; (time,time)</literal></entry></row>
     <row><entry><literal>&lt;= (time,time)</literal></entry></row>
     <row><entry><literal>&gt; (time,time)</literal></entry></row>
     <row><entry><literal>&gt;= (time,time)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>time_minmax_multi_ops</literal></entry>
      <entry><literal>= (time,time)</literal></entry>
     </row>
     <row><entry><literal>&lt; (time,time)</literal></entry></row>
     <row><entry><literal>&lt;= (time,time)</literal></entry></row>
     <row><entry><literal>&gt; (time,time)</literal></entry></row>
     <row><entry><literal>&gt;= (time,time)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>timetz_bloom_ops</literal></entry>
      <entry><literal>= (timetz,timetz)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>timetz_minmax_ops</literal></entry>
      <entry><literal>= (timetz,timetz)</literal></entry>
     </row>
     <row><entry><literal>&lt; (timetz,timetz)</literal></entry></row>
     <row><entry><literal>&lt;= (timetz,timetz)</literal></entry></row>
     <row><entry><literal>&gt; (timetz,timetz)</literal></entry></row>
     <row><entry><literal>&gt;= (timetz,timetz)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>timetz_minmax_multi_ops</literal></entry>
      <entry><literal>= (timetz,timetz)</literal></entry>
     </row>
     <row><entry><literal>&lt; (timetz,timetz)</literal></entry></row>
     <row><entry><literal>&lt;= (timetz,timetz)</literal></entry></row>
     <row><entry><literal>&gt; (timetz,timetz)</literal></entry></row>
     <row><entry><literal>&gt;= (timetz,timetz)</literal></entry></row>

     <row>
      <entry valign="middle"><literal>uuid_bloom_ops</literal></entry>
      <entry><literal>= (uuid,uuid)</literal></entry>
     </row>

     <row>
      <entry valign="middle" morerows="4"><literal>uuid_minmax_ops</literal></entry>
      <entry><literal>= (uuid,uuid)</literal></entry>
     </row>
     <row><entry><literal>&lt; (uuid,uuid)</literal></entry></row>
     <row><entry><literal>&gt; (uuid,uuid)</literal></entry></row>
     <row><entry><literal>&lt;= (uuid,uuid)</literal></entry></row>
     <row><entry><literal>&gt;= (uuid,uuid)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>uuid_minmax_multi_ops</literal></entry>
      <entry><literal>= (uuid,uuid)</literal></entry>
     </row>
     <row><entry><literal>&lt; (uuid,uuid)</literal></entry></row>
     <row><entry><literal>&gt; (uuid,uuid)</literal></entry></row>
     <row><entry><literal>&lt;= (uuid,uuid)</literal></entry></row>
     <row><entry><literal>&gt;= (uuid,uuid)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="4"><literal>varbit_minmax_ops</literal></entry>
      <entry><literal>= (varbit,varbit)</literal></entry>
      </row>
     <row><entry><literal>&lt; (varbit,varbit)</literal></entry></row>
     <row><entry><literal>&gt; (varbit,varbit)</literal></entry></row>
     <row><entry><literal>&lt;= (varbit,varbit)</literal></entry></row>
     <row><entry><literal>&gt;= (varbit,varbit)</literal></entry></row>
    </tbody>
   </tgroup>
  </table>

  <sect2 id="brin-builtin-opclasses--parameters">
   <title>Paramètres de classe d'opérateur</title>

   <para>
    Certaines des classes d'opérateur intégrées permettent aux paramétres
    spécifiés d'affecter leurs comportements. Chaque opérateur de classe a
    son propre ensemble de paramètres autorisés. Seules les classes
    d'opérateur <literal>bloom</literal> et <literal>minmax-multi</literal>
    permettent de spécifier ces paramètres&nbsp;:
   </para>

   <para>
    Les classes d'opérateur bloom acceptent ces paramètres&nbsp;:
   </para>

   <variablelist>
   <varlistentry>
    <term><literal>n_distinct_per_range</literal></term>
    <listitem>
    <para>
     Définit le nombre estimé de valeurs non NULL distinctes dans un
     intervalle de blocs, utilisé par les index bloom <acronym>BRIN</acronym>
     pour dimensionner le filtre Bloom. Il se comporte similairement à
     l'option <literal>n_distinct</literal> pour <xref
     linkend="sql-altertable"/>. Quand la valeur affectée est positive, il
     est supposé que chaque intervalle de blocs contient ce nombre de valeurs
     non NULL distinctes. Quand la valeur affectée est négative mais
     supérieure ou égale à -1, il est supposé que le nombre de valeurs non
     NULL distinctes croît linéairement avec le nombre maximum possible de
     lignes dans l'intervalle de blocs(environ 290 lignes par bloc). La
     valeur par défaut est <literal>-0,1</literal>, et le nombre minimum de
     valeurs distinctes non NULL est <literal>16</literal>.
    </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>false_positive_rate</literal></term>
    <listitem>
    <para>
     Définit le taux désiré de faux positifs utilisé par les index bloom
     <acronym>BRIN</acronym> pour dimensionner le filtre Bloom. La valeur
     doit être comprise entre 0,0001 et 0,25. La valeur par défaut est 0,01,
     ce qui correspond à 1% pour le taux de faux positifs.
    </para>
    </listitem>
   </varlistentry>

   </variablelist>

   <para>
    Les classes d'opérateur minmax-multi accepte ces paramètres&nbsp;:
   </para>

   <variablelist>
   <varlistentry>
    <term><literal>values_per_range</literal></term>
    <listitem>
    <para>
     Définit le nombre maximum de valeurs conservées par les index minmax
     <acronym>BRIN</acronym> pour résumer un intervalle de blocs. Chaque
     valeur peut représenter un point, ou une limite d'un intervalle. La
     valeur doit être comprise entre 8 et 256, et la valeur par défaut est
     32.
    </para>
    </listitem>
   </varlistentry>
   </variablelist>
  </sect2>
 </sect1>

 <sect1 id="brin-extensibility">
  <title>Extensibilité</title>

  <para>
   L'interface <acronym>BRIN</acronym> possède un niveau élevé d'abstraction,
   qui nécessite l'implémentation de la méthode d'accès rien que pour
   l'implémentation de la sémantique des types de données accédées. La couche
   <acronym>BRIN</acronym> s'occupera par contre elle-même de la concurrence,
   l'accès et la recherche dans la structure de l'index.
  </para>

  <para>
   Tout ce qu'il faut pour faire fonctionner la méthode d'accès
   <acronym>BRIN</acronym> est d'implémenter quelques méthodes utilisateurs,
   déterminant pour l'index les genre de valeurs stockées dans le résumé et la
   manière dont elles interagissent avec les nœuds du parcours. En bref,
   <acronym>BRIN</acronym> combine l'extensibilité avec la généralité, la
   réutilisation du code et une interface claire.
  </para>

  <para>
   Il y a quatre méthodes qu'un opérateur de classe pour
   <acronym>BRIN</acronym> doit fournir&nbsp;:

   <variablelist>
    <varlistentry>
     <term><function>BrinOpcInfo *opcInfo(Oid type_oid)</function></term>
     <listitem>
      <para>
       Retourne les informations internes au sujet du résumé de données de la
       colonne indexée. Cette valeur doit pointer vers une structure
       <structname>BrinOpcInfo</structname> (allouée avec la fonction palloc),
       qui a cette définition&nbsp;:
       <programlisting>
typedef struct BrinOpcInfo
{
    /* Nombre de colonnes stockées dans une colonne indexée de cette classe d'opérateur */
    uint16      oi_nstored;

    /* Pointeur opaque pour l'utilisation privée de la classe d'opérateur */
    void       *oi_opaque;

    /* Type des entrées cachées de la colonne stockées */
    TypeCacheEntry *oi_typcache[FLEXIBLE_ARRAY_MEMBER];
} BrinOpcInfo;
       </programlisting>
       <structname>BrinOpcInfo</structname>.<structfield>oi_opaque</structfield>
       peut être utilisé par les routines d'opérateur de classe pour
       transmettre des informations entre les procédures de support pendant le
       parcours de l'index.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>bool consistent(BrinDesc *bdesc, BrinValues *column,
        ScanKey *keys, int nkeys)</function></term>
     <listitem>
      <para>
       Retourne si toutes les entrées ScanKey sont cohérentes avec les valeurs
       indexées données pour cet intervalle. Le nombre d'attributs à utiliser
       est passé en tant que partie de la clé de parcours. De multiples clés
       de parcours pour un même attribut peuvent être passées en une
       fois&nbsp;; le nombre d'entrées est déterminé par le paramètre
       <literal>nkeys</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>bool consistent(BrinDesc *bdesc, BrinValues *column,
       ScanKey key)</function></term>
     <listitem>
      <para>
       Retourne la clé de parcours si elle est cohérente avec les valeurs
       indexées données pour cet intervalle. Le nombre attribué à utiliser
       est passé en tant que partie de la clé de parcours. Cette version est
       une variante pour compatibilité descendante plus ancienne de la
       fonction de cohérence.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>bool addValue(BrinDesc *bdesc, BrinValues *column,
       Datum newval, bool isnull)</function></term>
     <listitem>
      <para>
       Renvoie à une ligne indexée et une valeur indexée, modifie les
       attributs indiqués de cette ligne, de manière à ce que le cumul
       représente la nouvelle valeur. Si une modification a été apportée à la
       ligne, la valeur <literal>true</literal> est retournée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>bool unionTuples(BrinDesc *bdesc, BrinValues *a,
       BrinValues *b)</function></term>
     <listitem>
      <para>
       Consolidation de deux lignes d'index. Ceci en prenant deux lignes
       d'index et en modifiant l'attribut indiqué de la première des deux, de
       manière à ce qu'elle représente les deux lignes. La seconde ligne n'est
       pas modifiée.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Une classe d'opérateur pour <acronym>BRIN</acronym> peut indiquer en option
   la méthode suivante&nbsp;:

   <variablelist>
    <varlistentry>
     <term><function>void options(local_relopts *relopts)</function></term>
     <listitem>
      <para>
       Définit un ensemble de paramètres visibles aux utilisateurs qui
       contrôlent le comportement d'une classe d'opérateur.
      </para>

      <para>
       La fonction <function>options</function> se voit donné un pointeur
       vers une structure <structname>local_relopts</structname> qui doit
       être remplie avec un ensemble d'options spécifiques à la classe
       d'opérateur. Les options peuvent être accédées à partir des autres
       fonctions de support en utilisant les macros
       <literal>PG_HAS_OPCLASS_OPTIONS()</literal> et
       <literal>PG_GET_OPCLASS_OPTIONS()</literal>.
      </para>

      <para>
       Étant donné que l'extraction des clés des valeurs indexées et la
       représentation de la clé dans <acronym>BRIN</acronym> sont flexibles,
       elles peuvent dépendre de paramètres spécifiés par l'utilisateur.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   La distribution du noyau inclut du support pour les quatre types de classe
   d'opérateur&nbsp;: minmax, minmax-multi, inclusion et bloom. Les définitions de classes
   d'opérateur qui les utilisent sont envoyées en types de données basiques
   appropriées. Des classes d'opérateurs appropriées peuvent être définies par
   l'utilisateur pour d'autres types de données utilisant des définitions
   équivalentes, et ceci sans avoir besoin d'écrire du code source. La
   déclaration des entrées appropriées dans le catalogue est suffisante. Notez
   que les hypothèses sur les sémantiques de stratégie d'opérateurs sont
   embarquées dans les fonctions de support du code source.
  </para>

  <para>
   Les classes d'opérateurs qui implémentent des sémantiques complètement
   différentes sont utilisables. Les implémentations fournies par les quatre
   principales fonctions de support présentées ci-dessous sont écrites. Notez
   que la compatibilité ascendante entre les versions majeures n'est pas
   garantie : par exemple, les fonctions de support additionnelles peuvent
   être requises dans des versions ultérieures.
  </para>

  <para>
   Pour écrire une classe d'opérateur pour un type de données qui implémente
   un résultat complétement ordonné, il est possible d'utiliser les fonctions
   de support "minmax" avec les opérateurs correspondant tel que décrit dans
   <xref linkend="brin-extensibility-minmax-table"/>. Tous les membres de
   classe d'opérateurs (fonctions et opérateurs) sont obligatoires.
  </para>

  <table id="brin-extensibility-minmax-table">
   <title>Fonctions et numéros de support pour les classes d'opérateur Minmax</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Membre de classe d'opérateur</entry>
      <entry>Objet</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>Fonction de support 1</entry>
      <entry>Fonction interne <function>brin_minmax_opcinfo()</function></entry>
     </row>
     <row>
      <entry>Fonction de support 2</entry>
      <entry>Fonction interne <function>brin_minmax_add_value()</function></entry>
     </row>
     <row>
      <entry>Fonction de support 3</entry>
      <entry>Fonction interne <function>brin_minmax_consistent()</function></entry>
     </row>
     <row>
      <entry>Fonction de support 4</entry>
      <entry>Fonction interne <function>brin_minmax_union()</function></entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 1</entry>
      <entry>Opérateur strictement inférieur</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 2</entry>
      <entry>Opérateur inférieur</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 3</entry>
      <entry>Opérateur d'égalité</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 4</entry>
      <entry>Opérateur supérieur</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 5</entry>
      <entry>Opérateur strictement supérieur</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Pour écrire un opérateur de classe pour un type de données complexe, qui
   aurait des valeurs incluses dans un autre type, il est possible d'utiliser
   la fonction de support d'inclusion avec l'opérateur correspondant, tel que
   décrit dans <xref linkend="brin-extensibility-inclusion-table"/>. Cela
   nécessite uniquement une simple fonction d'addition, qui peut être écrite
   dans n'importe quel langage. Des fonctions supplémentaires peuvent être
   définies pour obtenir des fonctionnalités additionnelles. Tous les
   opérateurs sont optionnels. Certains opérateurs requièrent d'autres
   opérateurs, affichés en tant que dépendances de la table.
  </para>

  <table id="brin-extensibility-inclusion-table">
   <title>Fonctions et numéros de support pour les classes d'opérateur
    d'inclusion</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Membre de classe d'opérateur</entry>
      <entry>Objet</entry>
      <entry>Dépendance</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>Fonction de support 1</entry>
      <entry>Fonction interne <function>brin_inclusion_opcinfo()</function></entry>
      <entry></entry>
     </row>
     <row>
      <entry>Fonction de support 2</entry>
      <entry>Fonction interne <function>brin_inclusion_add_value()</function></entry>
      <entry></entry>
     </row>
     <row>
      <entry>Fonction de support 3</entry>
      <entry>Fonction interne <function>brin_inclusion_consistent()</function></entry>
      <entry></entry>
     </row>
     <row>
      <entry>Fonction de support 4</entry>
      <entry>Fonction interne <function>brin_inclusion_union()</function></entry>
      <entry></entry>
     </row>
     <row>
      <entry>Fonction de support 11</entry>
      <entry>Fonction de fusion de deux élements</entry>
      <entry></entry>
     </row>
     <row>
      <entry>Fonction de support 12</entry>
      <entry>Fonction optionnelle de vérification si les deux éléments peuvent être fusionnés
      </entry>
      <entry></entry>
     </row>
     <row>
      <entry>Fonction de support 13</entry>
      <entry>Fonction optionnelle de vérification si un élément est contenu dans un autre</entry>
      <entry></entry>
     </row>
     <row>
      <entry>Fonction de support 14</entry>
      <entry>Fonction optionnelle de vérification si un élement est vide</entry>
      <entry></entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 1</entry>
      <entry>Opérateur A-gauche-de </entry>
      <entry>Stratégie d'opérateur 4</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 2</entry>
      <entry>Opérateur Ne-s-etend-pas-à-la-droite-de</entry>
      <entry>Stratégie d'opérateur 5</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 3</entry>
      <entry>Opérateur chevauchement</entry>
      <entry></entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 4</entry>
      <entry>Opérateur Ne-s-etend-pas-à-la-gauche-de</entry>
      <entry>Stratégie d'opérateur 1</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 5</entry>
      <entry>Opérateur A-droite-de</entry>
      <entry>Stratégie d'opérateur 2</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 6, 18</entry>
      <entry>Opérateur Equivalent-ou-identique-à</entry>
      <entry>Stratégie d'opérateur 7</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 7, 16, 24, 25</entry>
      <entry>Opérateur Contient-ou-identique-à</entry>
      <entry></entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 8, 26, 27</entry>
      <entry>Opérateur Contient-ou-identique-à</entry>
      <entry>Stratégie d'opérateur 3</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 9</entry>
      <entry>Opérateur Ne-s-étend-pas-plus-loin</entry>
      <entry>Stratégie d'opérateur 11</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 10</entry>
      <entry>Opérateur Est-le-suivant</entry>
      <entry>Stratégie d'opérateur 12</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 11</entry>
      <entry>Opérateur Est-le-précédent</entry>
      <entry>Stratégie d'opérateur 9</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 12</entry>
      <entry>Opérateur Ne-s-étend-pas-plus-loin</entry>
      <entry>Stratégie d'opérateur 10</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 20</entry>
      <entry>Opérateur Strictement-inférieur-à</entry>
      <entry>Stratégie d'opérateur 5</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 21</entry>
      <entry>Opérateur Inférieur-à</entry>
      <entry>Stratégie d'opérateur 5</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 22</entry>
      <entry>Opérateur Strictement-supérieur-à</entry>
      <entry>Stratégie d'opérateur 1</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 23</entry>
      <entry>Opérateur supérieur-à</entry>
      <entry>Stratégie d'opérateur 1</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les numéros 1 à 10 des fonctions support sont reservés pour les fonctions
   internes BRIN, de ce fait le niveau des fonctions SQL commence à 11. La
   fonction de support 11 est la principale fonction utilisée pour construire
   l'index. Elle doit accepter deux arguments, avec le même type de données que
   la la classe d'opérateur, et renvoyer l'union des deux. La classe
   d'opérateur inclusion peut stocker des valeurs unies de types différents si
   elles sont définies avec le paramètre <literal>STORAGE</literal> La valeur
   renvoyée par la fonction union doit correspondre au type de données
   <literal>STORAGE</literal>
  </para>

  <para>
   Les numéros 12 et 14 des fonctions de support sont fournies pour supporter
   les irrégularités des types de données internes. La fonction 12 est
   utilisée pour supporter les adresses réseaux de différentes familles qui ne
   sont pas fusionnables. La fonction 14 est utilisée pour supporter les
   intervalles vides. La fonction 13 est une fonction optionnelle mais
   recommandée. Elle permet à une nouvelle valeur d'être vérifiée avant d'être
   passée à la fonction d'union. Puisque BRIN peut raccourcir certaines
   opérations lorsque l'union n'est pas modifiée, utiliser cette fonction peut
   améliorer les performances de l'index.
  </para>

  <para>
   Pour écrire une classe d'opérateur pour un type de données qui implémente
   seulement l'opérateur égalité et supporte le hachage, il est possible
   d'utiliser les procédures d'appui bloom aux côtés des opérateurs
   correspondants, comme montré dans <xref
   linkend="brin-extensibility-bloom-table"/>. Tout membre de classe
   d'opérateur (procédures et opérateurs) sont obligatoires.
  </para>

  <table id="brin-extensibility-bloom-table">
   <title>Procédures et numéros de support pour les classes d'opérateur Bloom</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Membre de la classe d'opérateur</entry>
      <entry>Objet</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>Procédure support 1</entry>
      <entry>Fonction interne <function>brin_bloom_opcinfo()</function></entry>
     </row>
     <row>
      <entry>Procédure support 2</entry>
      <entry>Fonction interne <function>brin_bloom_add_value()</function></entry>
     </row>
     <row>
      <entry>Procédure support 3</entry>
      <entry>Fonction interne <function>brin_bloom_consistent()</function></entry>
     </row>
     <row>
      <entry>Procédure support 4</entry>
      <entry>Fonction interne <function>brin_bloom_union()</function></entry>
     </row>
     <row>
      <entry>Procédure support 11</entry>
      <entry>Fonction pour calculer le hachage d'un élément</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 1</entry>
      <entry>Opérateur égal-à</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les procédures support numéros 1-10 sont réservées pour les fonctions
   internes BRIN, ainsi les fonctions au niveau SQL débutent avec le numéro
   11. La fonction support numéro 11 est la principale fonction requise pour
   construire un index. Elle doit accepter un argument avec le même type de
   données que la classe d'opérateur et retourner un hachage de la valeur.
  </para>

  <para>
   La classe d'opérateur minmax-multi est aussi prévue pour les types de
   données implémentant un ensemble totalement ordonné, et peut être vue
   comme une simple extension de la classe d'opérateur minmax. Tandis que la
   classe d'opérateur minmax résume les valeurs pour chaque intervalle de
   bloc dans un intervalle unique et contigu, minmax-multi permet de résumer
   dans de multiples intervalles plus petits pour améliorer la gestion des
   valeurs aberrantes. Il est possible d'utiliser les procédures support
   minmax-multi aux côtés des opérateurs correspondant, comme indiqué dans
   <xref linkend="brin-extensibility-minmax-multi-table"/>. Tous les membres
   de classe d'opérateur (procédures et opérateurs) sont obligatoires.
  </para>

  <table id="brin-extensibility-minmax-multi-table">
   <title>Procédure et numéros de support pour les classes d'opérateur minmax-multi</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Membre de classe d'opérateur</entry>
      <entry>Objet</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>Procédure support 1</entry>
      <entry>Fonction interne <function>brin_minmax_multi_opcinfo()</function></entry>
     </row>
     <row>
      <entry>Procédure support 2</entry>
      <entry>Fonction interne <function>brin_minmax_multi_add_value()</function></entry>
     </row>
     <row>
      <entry>Procédure support 3</entry>
      <entry>Fonction interne <function>brin_minmax_multi_consistent()</function></entry>
     </row>
     <row>
      <entry>Procédure support 4</entry>
      <entry>Fonction interne <function>brin_minmax_multi_union()</function></entry>
     </row>
     <row>
      <entry>Procédure support 11</entry>
      <entry>Fonction de calcul de distance entre deux valeurs (longueur d'un intervalle)</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 1</entry>
      <entry>Opérateur inférieur-à</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 2</entry>
      <entry>Opérateur inférieur-ou-égal-à</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 3</entry>
      <entry>Opérateur égal-à</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 4</entry>
      <entry>Opérateur supérieur-ou-égal-à</entry>
     </row>
     <row>
      <entry>Stratégie d'opérateur 5</entry>
      <entry>Opérateur supérieur-à</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les classes d'opérateur minmax et inclusion supportent les opérateurs
   utilisables sur des types de données croisés, même si cela complexifie la
   gestion des dépendances. La classe d'opérateur minmax a besoin d'un
   ensemble complet d'opérateurs pour être définie avec deux arguments qui
   auraient le même type de données. Cela permet aux types de données
   additionnels d'être supportés en définissant un ensemble d'opérateurs
   supplémentaires. Les opérateurs de la classe d'opérateur inclusion sont
   dépendants d'autres stratégies d'opérateur tel que décrit dans le <xref
   linkend=" brin-extensibility-inclusion-table"/>, ou des mêmes stratégie
   d'opérateur qu'eux-même. Cela nécessite que l'opérateur dépendant soit
   défini avec le type de données <literal>STORAGE</literal> pour l'argument
   du côté gauche, et que l'autre type de données supportée se trouve du côté
   droit de l'opérateur de support. Vous pouvez consulter
   <literal>float4_minmax_ops</literal> comme exemple pour minmax et
   <literal>box_inclusion_ops</literal> comme exemple pour inclusion.
  </para>
 </sect1>

</chapter>
