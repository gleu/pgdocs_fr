<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<sect1 id="pgbench">
 <title>pgbench</title>

 <indexterm zone="pgbench">
  <primary>pgbench</primary>
 </indexterm>

 <para>
  <application>pgbench</application> est un programme simple qui exécute un
  test de performances (<foreignphrase>benchmark</foreignphrase> en
  anglais) sur <productname>PostgreSQL</productname>. Il exécute la même
  séquence de commandes SQL de nombreuses fois, si possible dans plusieurs
  sessions en prarallèle, puis calcule le taux de transaction moyen
  (transactions par seconde). Par défaut, <application>pgbench</application>
  teste un scénario vaguement basé sur TPC-B, impliquant cinq
  <command>SELECT</command>, <command>UPDATE</command> et
  <command>INSERT</command> par transaction. Néanmoins il est facile de tester
  d'autres cas en écrivant ses propres fichiers de transaction.
 </para>

 <para>
  Voici un exemple d'affichage de pgbench&nbsp;:

 <programlisting>
transaction type: TPC-B (sort of)
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 85.184871 (including connections establishing)
tps = 85.296346 (excluding connections establishing)
 </programlisting>

  Les six premières lignes indiquent simplement certains des paramètres
  les plus importants. La ligne suivant rapporte le nombre de transactions
  terminées et souhaitées (le dernier étant juste le produit du nombre
  de clients avec le nombre de transactions par client)&nbsp;; ils doivent être égaux
  sauf si un échec est arrivé avant la fin. Les deux dernières lignes
  précisent le taux de transactions, avec et sans le temps de lancement
  de la session.
 </para>

 <sect2>
  <title>Aperçu</title>

  <para>
   Le test de transaction par défaut, ressemblant à TPC-B, nécessite des tables
   particulières qu'il faut créer. <application>pgbench</application> doit
   être appelé avec l'option <literal>-i</literal> (initialisation) pour les
   créer et les peupler. (Cette étape n'est pas nécessaire dans le cas de script
   personnalisé, mais la base doit être configurée en conséquence.)
   L'initialisation ressemble à&nbsp;:

   <programlisting>
pgbench -i <optional> <replaceable>autres-options</replaceable> </optional> <replaceable>nom_base</replaceable>
   </programlisting>

   où <replaceable>dbname</replaceable> est le nom d'une base de données déjà
   créée et à utiliser pour les tests. (Les
   options <literal>-h</literal>, <literal>-p</literal>, et/ou
   <literal>-U</literal> peuvent être utilisées pour indiquer la façon
   de se connecter au serveur de bases de données.)
  </para>

  <caution>
   <para>
    <literal>pgbench -i</literal> crée quatre tables&nbsp;:
    <structname>pgbench_accounts</structname>, <structname>pgbench_branches</structname>,
    <structname>pgbench_history</structname> et <structname>pgbench_tellers</structname>,
    détruisant toute table existante de ce nom. Il convient d'y être attentif
    s'il existe des tables de même nom&nbsp;!
   </para>
  </caution>

  <para>
   Avec un <quote>facteur d'échelle</quote> de 1, les tables contiennent
   initialement ce nombre de lignes&nbsp;:
  </para>
  <programlisting>
table                   # de lignes
-----------------------------------
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0
  </programlisting>
  <para>
   Le nombre de lignes peut être augmenté en utilisant l'option
   <literal>-s</literal> (facteur d'échelle). L'option
   <literal>-F</literal> (facteur de remplissage) peut aussi être utilisée
   à ce moment.
  </para>

  <para>
   Une fois la configuration exécutée, le
   test de performance peut être lancé avec une commande qui n'inclut pas l'option
   <literal>-i</literal>, c'est-à-dire&nbsp;:

   <programlisting>
pgbench <optional> <replaceable>options</replaceable> </optional> <replaceable>nom_base</replaceable>
   </programlisting>

   Dans la plupart des cas, vous aurez besoin de quelques options pour que
   ce test soit réellement intéressant. Les options les plus importantes
   sont <literal>-c</literal> (nombre de clients), <literal>-t</literal>
   (nombre de transactions), <literal>-T</literal> (limite de temps) et
   <literal>-f</literal> (pour spécifier un script personnalisé). Voir
   ci-dessous pour une liste complète.
  </para>

  <para>
   <xref linkend="pgbench-init-options"/> affiche les options qui sont
   utiles lors de l'initialisation de la base de données, alors que
   <xref linkend="pgbench-run-options"/> affiche celles qui sont utiles
   lors de l'exécution des tests de performance et
   <xref linkend="pgbench-common-options"/> affiches les options utiles dans
   les deux cas.
  </para>

 </sect2>

 <sect2 id="pgbench-init-options">
  <title><application>pgbench</application> Initialization Options</title>

   <para>
    <application>pgbench</application> accepts the following command-line
    initialization arguments:

    <variablelist>

     <varlistentry>
      <term><option>-F</option> <replaceable>fillfactor</replaceable></term>
      <listitem>
       <para>
        Create the <structname>pgbench_accounts</structname>,
        <structname>pgbench_tellers</structname> and
        <structname>pgbench_branches</structname> tables with the given fillfactor.
        Default is 100.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-i</option></term>
      <listitem>
       <para>
        Required to invoke initialization mode.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>scale_factor</replaceable></term>
      <listitem>
       <para>
        Multiply the number of rows generated by the scale factor.
        For example, <literal>-s 100</literal> will create 10,000,000 rows
        in the <structname>pgbench_accounts</structname> table. Default is 1.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </sect2>

 <sect2 id="pgbench-run-options">
  <title><application>pgbench</application> Benchmarking Options</title>

   <para>
    <application>pgbench</application> accepts the following command-line
    benchmarking arguments:

    <variablelist>

     <varlistentry>
      <term><option>-c</option> <replaceable>clients</replaceable></term>
      <listitem>
       <para>
        Number of clients simulated, that is, number of concurrent database
        sessions.  Default is 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-C</option></term>
      <listitem>
       <para>
        Establish a new connection for each transaction, rather than
        doing it just once per client session.
        This is useful to measure the connection overhead.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-d</option></term>
      <listitem>
       <para>
        Print debugging output.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-D</option> <replaceable>varname</replaceable><literal>=</literal><replaceable>value</replaceable></term>
      <listitem>
       <para>
        Define a variable for use by a custom script (see below).
        Multiple <literal>-D</literal> options are allowed.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-f</option> <replaceable>filename</replaceable></term>
      <listitem>
       <para>
        Read transaction script from <replaceable>filename</replaceable>.
        See below for details.
        <literal>-N</literal>, <literal>-S</literal>, and <literal>-f</literal>
        are mutually exclusive.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-j</option> <replaceable>threads</replaceable></term>
      <listitem>
       <para>
        Number of worker threads within <application>pgbench</application>.
        Using more than one thread can be helpful on multi-CPU machines.
        The number of clients must be a multiple of the number of threads,
        since each thread is given the same number of client sessions to manage.
        Default is 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-l</option></term>
      <listitem>
       <para>
        Write the time taken by each transaction to a logfile.
        See below for details.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-M</option> <replaceable>querymode</replaceable></term>
      <listitem>
       <para>
        Protocol to use for submitting queries to the server:
          <itemizedlist>
           <listitem>
            <para><literal>simple</literal>: use simple query protocol.</para>
           </listitem>
           <listitem>
            <para><literal>extended</literal>: use extended query protocol.</para>
           </listitem>
           <listitem>
            <para><literal>prepared</literal>: use extended query protocol with prepared statements.</para>
           </listitem>
          </itemizedlist>
        The default is simple query protocol.  (See <xref linkend="protocol"/>
        for more information.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <listitem>
       <para>
        Perform no vacuuming before running the test.
        This option is <emphasis>necessary</emphasis>
        if you are running a custom test scenario that does not include
        the standard tables <structname>pgbench_accounts</structname>,
        <structname>pgbench_branches</structname>, <structname>pgbench_history</structname>, and
        <structname>pgbench_tellers</structname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-N</option></term>
      <listitem>
       <para>
        Do not update <structname>pgbench_tellers</structname> and
        <structname>pgbench_branches</structname>.
        This will avoid update contention on these tables, but
        it makes the test case even less like TPC-B.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>scale_factor</replaceable></term>
      <listitem>
       <para>
        Report the specified scale factor in <application>pgbench</application>'s
        output.  With the built-in tests, this is not necessary; the
        correct scale factor will be detected by counting the number of
        rows in the <structname>pgbench_branches</structname> table.  However, when testing
        custom benchmarks (<literal>-f</literal> option), the scale factor
        will be reported as 1 unless this option is used.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-S</option></term>
      <listitem>
       <para>
        Perform select-only transactions instead of TPC-B-like test.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-t</option> <replaceable>transactions</replaceable></term>
      <listitem>
       <para>
        Number of transactions each client runs.  Default is 10.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-T</option> <replaceable>seconds</replaceable></term>
      <listitem>
       <para>
        Run the test for this many seconds, rather than a fixed number of
        transactions per client. <literal>-t</literal> and
        <literal>-T</literal> are mutually exclusive.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <listitem>
       <para>
        Vacuum all four standard tables before running the test.
        With neither <literal>-n</literal> nor <literal>-v</literal>, pgbench will vacuum the
        <structname>pgbench_tellers</structname> and <structname>pgbench_branches</structname>
        tables, and will truncate <structname>pgbench_history</structname>.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </sect2>

 <sect2 id="pgbench-common-options">
  <title><application>pgbench</application> Common Options</title>

   <para>
    <application>pgbench</application> accepts the following command-line
    common arguments:

    <variablelist>

     <varlistentry>
      <term><option>-h</option> <replaceable>hostname</replaceable></term>
      <listitem>
       <para>
        The database server's hostname
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-p</option> <replaceable>port</replaceable></term>
      <listitem>
       <para>
        The database server's port number
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-U</option> <replaceable>login</replaceable></term>
      <listitem>
       <para>
        The username to connect as
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </sect2>

 <sect2>
  <title>Quelle <quote>transaction</quote> est réalisée dans
  pgbench&nbsp;?</title>

  <para>
   Le script de transaction par défaut exécute sept commandes&nbsp;:
  </para>

  <orderedlist>
   <listitem><para><literal>BEGIN;</literal></para></listitem>
   <listitem><para><literal>UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;</literal></para></listitem>
   <listitem><para><literal>SELECT abalance FROM pgbench_accounts WHERE aid = :aid;</literal></para></listitem>
   <listitem><para><literal>UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;</literal></para></listitem>
   <listitem><para><literal>UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;</literal></para></listitem>
   <listitem><para><literal>INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);</literal></para></listitem>
   <listitem><para><literal>END;</literal></para></listitem>
  </orderedlist>

  <para>
   Si vous indiquez <literal>-N</literal>, les étapes 4 et 5 ne sont pas inclus
   dans la transaction. Si vous indiquez <literal>-S</literal>, seul le
   <command>SELECT</command> est exécuté.
  </para>
 </sect2>

 <sect2>
  <title>Scripts personnalisés</title>

  <para>
   <application>pgbench</application> sait exécuter des scénarios personnalisés
   en remplaçant le script de transaction par défaut (décrit ci-dessus) avec
   un script de transaction lu à partir d'un fichier (option
   <literal>-f</literal>). Dans ce cas, une <quote>transaction</quote> compte
   en tant qu'une exécution du fichier. Vous pouvez même indiquer plusieurs
   scripts (avec plusieurs options <literal>-f</literal>), auquel cas un
   script est choisi au hasard à chaque fois qu'une session client exécute
   une nouvelle transaction.
  </para>

  <para>
   Le fichier doit contenir une commande par ligne&nbsp;; les commandes SQL
   multi-lignes ne sont pas acceptées. Les lignes vides et les lignes
   commençant par <literal>--</literal> sont ignorées. Les lignes du fichier
   peuvent aussi contenir des <quote>meta commandes</quote>, qui sont
   interprétées par <application>pgbench</application> lui-même, comme
   décrit ci-dessous.
  </para>

  <para>
   Il existe une fonctionnalité de substitution de variables pour les fichiers.
   Les variables sont configurables par l'option <literal>-D</literal> en
   ligne de commande, comme expliqué ci-dessus, ou par les méta-commandes
   expliquées ci-dessous. En plus des variables pré-initialisées par les
   options <literal>-D</literal>, la variable <literal>scale</literal> est
   pré-initialisée avec le facteur d'échelle actuel. Une fois configurée,
   la valeur d'une variable peut être insérée dans une commande SQL en
   écrivant <literal>:</literal><replaceable>nom_variable</replaceable>.
   Lors de l'exécution de plusieurs sessions clients, chaque session a son
   propre ensemble de variables.
  </para>

  <para>
   Les méta-commandes du script commencent par un antislash
   (<literal>\</literal>). Les arguments d'une méta-commande sont séparés par
   des espaces blancs. Voici la liste des méta-commandes acceptées&nbsp;:
  </para>

  <variablelist>
   <varlistentry>
    <term>
     <literal>\set <replaceable>nom_variable</replaceable> <replaceable>operande1</replaceable> [ <replaceable>operateur</replaceable> <replaceable>operande2</replaceable> ]</literal>
    </term>

    <listitem>
     <para>
      Initialise la variable <replaceable>varname</replaceable> avec une
      valeur entière calculée.
      Chaque <replaceable>operande</replaceable> est soit une constante
      entière soit une référence
      <literal>:</literal><replaceable>nom_variable</replaceable> à une variable
      entière. L'<replaceable>operateur</replaceable> peut être
      <literal>+</literal>, <literal>-</literal>, <literal>*</literal> ou <literal>/</literal>.
     </para>

     <para>
      Exemple&nbsp;:
      <programlisting>
\set ntellers 10 * :scale
      </programlisting>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\setrandom <replaceable>nom_variable</replaceable> <replaceable>min</replaceable> <replaceable>max</replaceable></literal>
    </term>

    <listitem>
     <para>
      Initialise la variable <replaceable>nom_variable</replaceable> à une
      valeur entière prise au hasard entre les limites
      <replaceable>min</replaceable> et <replaceable>max</replaceable>,
      limites inclues.
      Chaque limite peut être soit une constante entière soit une référence
      <literal>:</literal><replaceable>nom_variable</replaceable> à une valeur
      entière.
     </para>

     <para>
      Exemple&nbsp;:
      <programlisting>
\setrandom aid 1 :naccounts
      </programlisting>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\sleep <replaceable>nombre</replaceable> [ us | ms | s ]</literal>
    </term>

    <listitem>
     <para>
      Provoque un endormissement de l'exécution du script pour la durée
      indiquée en microsecondes (<literal>us</literal>), millisecondes
      (<literal>ms</literal>) ou secondes (<literal>s</literal>). Si l'unité
      est omise, alors ce seront par défaut des secondes.
      <replaceable>nombre</replaceable> peut être soit un entier soit une
      référence <literal>:</literal><replaceable>nom_variable</replaceable> à
      un entier.
     </para>

     <para>
      Exemple&nbsp;:
      <programlisting>
\sleep 10 ms
      </programlisting>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\setshell <replaceable>nom_variable</replaceable> <replaceable>commande</replaceable> [ <replaceable>argument</replaceable> ... ]</literal>
    </term>

    <listitem>
     <para>
      Configure la variable <replaceable>nom_variable</replaceable> avec le
      résultat de la commande shell <replaceable>commande</replaceable>. La
      commande doit renvoyer une valeur entière via sa sortie standard.
     </para>

     <para>
      <replaceable>argument</replaceable> peut être soit une constante de type
      texte soit une référence
      <literal>:</literal><replaceable>nom_variable</replaceable> à une
      variable de n'importe quel type. Si vous voulez utiliser
      <replaceable>argument</replaceable> en commençant avec un signe
      deux-points, vous devez ajouer un signe deux-points supplémentaires au
      début de <replaceable>argument</replaceable>.
     </para>

     <para>
      Exemple&nbsp;:
      <programlisting>
\setshell variable_to_be_assigned command literal_argument :variable ::literal_starting_with_colon
      </programlisting>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\shell <replaceable>commande</replaceable> [ <replaceable>argument</replaceable> ... ]</literal>
    </term>

    <listitem>
     <para>
      Idem à <literal>\setshell</literal>, mais le résultat est ignoré.
     </para>

     <para>
      Exemple&nbsp;:
      <programlisting>
\shell command literal_argument :variable ::literal_starting_with_colon
      </programlisting>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   En exemple, voici la définition complète d'une transaction style
   TPC-B&nbsp;:

   <programlisting>
\set nbranches :scale
\set ntellers 10 * :scale
\set naccounts 100000 * :scale
\setrandom aid 1 :naccounts
\setrandom bid 1 :nbranches
\setrandom tid 1 :ntellers
\setrandom delta -5000 5000
BEGIN;
UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
END;
   </programlisting>

   Ce script permet à chaque itération de la transaction de référencer des
   lignes différentes, prises au hasard. (Cet exemple montre aussi pourquoi
   il est imporant que chaque session client ait ses propres variables &mdash;
   sinon elles ne traiteraient pas des lignes différentes.)
  </para>

 </sect2>

 <sect2>
  <title>Journalisation par transaction</title>

  <para>
   Avec l'option <literal>-l</literal>, <application>pgbench</application>
   écrit le temps pris par chaque transaction dans un journal applicatif.
   Le journal sera nommé
   <filename>pgbench_log.<replaceable>nnn</replaceable></filename>, où
   <replaceable>nnn</replaceable> est le PID du processus pgbench.
   Si l'option <literal>-j</literal> vaut 2 ou plus, ce qui va créer plusieurs
   threads de travail, chacun d'entre eux aura son propre journal applicatif.
   Le premier utilise le même nom de fichier que s'il avait été seul. Les
   autres fichiers des autres travailleurs seront nommés
   <filename>pgbench_log.<replaceable>nnn</replaceable>.<replaceable>mmm</replaceable></filename>,
   où <replaceable>mmm</replaceable> est un numéro séquentiel pour chaque
   travailleur et commençant à 1.
  </para>

  <para>
   Le format de ce journal est&nbsp;:

   <programlisting>
    <replaceable>client_id</replaceable> <replaceable>transaction_no</replaceable> <replaceable>time</replaceable> <replaceable>file_no</replaceable> <replaceable>time_epoch</replaceable> <replaceable>time_us</replaceable>
   </programlisting>

   où <replaceable>time</replaceable> est le durée de la transaction en
   microsecondes, <replaceable>file_no</replaceable> identifie le script qui
   a été utilisé (utile quand plusieurs scripts sont indiqués avec
   <literal>-f</literal>) et
   <replaceable>time_epoch</replaceable>/<replaceable>time_us</replaceable> sont
   une date/heure au format epoch Unix et un décalage en microsecondes
   (convenable pour la création d'un horodatage ISO 8601 avec des secondes
   en fration) indiquant la date et heure de la fin de la transaction.
  </para>

  <para>
   Voici un exemple de journal&nbsp;:
   <programlisting>
 0 199 2241 0 1175850568 995598
 0 200 2465 0 1175850568 998079
 0 201 2513 0 1175850569 608
 0 202 2038 0 1175850569 2663
   </programlisting>
  </para>
 </sect2>

 <sect2>
  <title>Bonnes practiques</title>

  <para>
   Il est très facile d'utiliser <application>pgbench</application> pour
   produire des nombres sans signification. Voici quelques lignes de conduite
   pour vous aider à obtenir des résultats intéressants.
  </para>

  <para>
   En premier lieu, ne <emphasis>jamais</emphasis> croire tout test qui ne
   s'exécute que pendant quelques secondes. Utilisez l'option
   <literal>-t</literal> ou <literal>-T</literal>
   pour que le test dure plusieurs minutes pour rendre
   le bruit insignifiant. Dans certains cas, nous avez besoin de quelques
   heures pour obtenir des chiffres reproductibles. Exécuter le test plusieurs
   fois est une bonne idée pour savoir si vos résultats sont reproductibles.
  </para>

  <para>
   Pour le scénario par défaut, style TPC-B, le facteur d'échelle à
   l'initialisation (<literal>-s</literal>) doit être au moins aussi important
   que le plus grand nombre de clients que vous souhaitez supporter
   (<literal>-c</literal>)&nbsp;; sinon vous ne ferez que mesurer la contention
   des mises à jour. Il n'y a que <literal>-s</literal> lignes dans la table
   <structname>pgbench_branches</structname>, et chaque transaction veut en mettre une
   à jour, donc les valeurs <literal>-c</literal> supérieures à 
   <literal>-s</literal> résulteront sans doute en beaucoup de transactions
   bloquées, en attente d'autres transactions.
  </para>

  <para>
   Le scénario test par défaut est aussi assez sensible du moment où les
   tables ont été initialisées&nbsp;: une accumulation de lignes morts et
   d'espace vide dans les tables modifient les résultats. Pour comprendre
   les résultats, vous devez garder trace de nombre total de mises à jour
   et des moments où un VACUUM est exécuté. Si l'autovacuum est activé,
   cela peut causer des modifications non prévisibles dans les performances
   mesurées.
  </para>

  <para>
   Une limite de <application>pgbench</application> est qu'il peut devenir
   lui-même le goulot d'étranglement lors de tentative de tests d'un grand
   nombre de sessions clients. Ceci peut se voir allégé en exécutant
   <application>pgbench</application> sur une autre machine que le serveur
   de bases de données, bien que la latence du réseau est essentielle. Il
   pourrait même être utile d'exécuter plusieurs instances
   <application>pgbench</application> en parallèle sur plusieurs machines
   client, pour le même serveur de bases de données.
  </para>
 </sect2>

</sect1>
