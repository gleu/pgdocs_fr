<?xml version="1.0" encoding="UTF-8"?>
<chapter id="fdwhandler">
 <title>Écrire un wrapper de données distantes</title>

 <indexterm zone="fdwhandler">
  <primary>wrapper de données distantes</primary>
  <secondary>gestionnaire</secondary>
 </indexterm>

 <para>
  Toutes les opérations sur une table distante sont gérées via un
  wrapper de données distantes. Ce dernier est un ensemble de fonctions
  que PostgreSQL appelle. Le wrapper de données
  distantes est responsable de la récupération des données à partir de
  le source de données distante et de leur renvoi à l'exécuteur
  <productname>PostgreSQL</productname>. Si la mise à jour de tables distantes
  doit être supporté, le wrapper doit aussi gérer cela.
  Ce chapitre indique comment
  écrire un nouveau wrapper de données distantes.
 </para>

 <para>
  Les wrappers de données distantes incluent dans la distribution
  standard sont de bons exemples lorsque vous essayez d'écrire les
  votres. Regardez dans le sous-répertoire
  <filename>contrib</filename> du répertoire des sources. La
  page de référence <xref linkend="sql-createforeigndatawrapper"/>
  contient aussi des détails utiles.
 </para>

 <note>
  <para>
   Le standard SQL spécifie une interface pour l'écriture des wrappers
   de données distantes. Néanmoins, PostgreSQL n'implémente pas cette
   API car l'effort nécessaire pour cela serait trop important. De
   toute façon, l'API standard n'est pas encore très adoptée.
  </para>
 </note>

 <sect1 id="fdw-functions">
  <title>Fonctions d'un wrapper de données distantes</title>

  <para>
   Le développeur d'un FDW doit écrire une fonction de gestion (handler)
   et, en option, une fonction de validation. Les deux fonctions doivent
   être écrites dans un langage compilé comme le C en utilisant
   l'interface version-1. Pour les détails sur les conventions d'appel
   et le chargement dynamique en langage C, voir <xref linkend="xfunc-c"/>.
  </para>

  <para>
   La fonction de gestion renvoie simplement une structure de pointeurs
   de fonctions callback qui seront appelées par le planificateur,
   l'exécuteur et différentes commandes de maintenance. La plupart du
   travail dans l'écriture d'une FDW se
   trouve dans l'implémentation de ces fonctions callback. La fonction
   de gestion doit être enregistrée dans
   <productname>PostgreSQL</productname> comme ne prenant aucun argument
   et renvoyant le pseudo-type <type>fdw_handler</type>. Les fonctions
   callback sont des fonctions en C et ne sont pas visibles ou
   appelables avec du SQL. Les fonctions callback sont décrites dans
   <xref linkend="fdw-callbacks"/>.
  </para>

  <para>
   La fonction de validation est responsable de la validation des options
   données dans les commandes <command>CREATE</command> et
   <command>ALTER</command> pour son wrapper de données distantes,
   ainsi que pour les serveurs distants, les correspondances
   d'utilisateurs et les tables distants utilisant le wrapper. La
   fonction de validation doit être enregistrée comme prenant deux
   arguments&nbsp;: un tableau de texte contenant les options à
   valider et un OID représentant le type d'objet avec lequel les
   options sont validées (sous la forme d'un OID du catalogue système
   où sera stocké l'objet, donc
   <literal>ForeignDataWrapperRelationId</literal>,
   <literal>ForeignServerRelationId</literal>,
   <literal>UserMappingRelationId</literal> ou
   <literal>ForeignTableRelationId</literal>).
   Si aucune fonction de validation n'est fournie, les options ne sont
   pas vérifiées au moment de la création ou de la modification de
   l'objet.
  </para>

 </sect1>

 <sect1 id="fdw-callbacks">
  <title>Routines callback des wrappers de données distantes</title>

  <para>
   La fonction de gestion d'une FDW renvoie une structure
   <structname>FdwRoutine</structname> allouée avec palloc. Elle
   contient des pointeurs vers les fonctions de callback décrites
   ci-dessous. Les fonctions relatives aux parcours sont requises,
   le reste est optionnel.
  </para>

  <para>
   Le type de structure <structname>FdwRoutine</structname> est déclaré dans
   <filename>src/include/foreign/fdwapi.h</filename>, où vous trouverez plus de
   détails.
  </para>

  <sect2 id="fdw-callbacks-scan">
   <title>Routines des FDW pour parcourir les tables distantes</title>

   <para>
    <programlisting>
void
GetForeignRelSize (PlannerInfo *root,
                   RelOptInfo *baserel,
                   Oid foreigntableid);
    </programlisting>

    Obtient des estimations de la taille de la relation pour une table distante.
    Elle est appelée au début de la planification d'une requête parcourant une
    table distante. <literal>root</literal> est l'information globale du
    planificateur sur la requête&nbsp;; <literal>baserel</literal> est
    l'information du planificateur sur la table&nbsp;; et
    <literal>foreigntableid</literal> est l'OID provenant de
    <structname>pg_class</structname> pour cette table distante.
    (<literal>foreigntableid</literal> pourrait être obtenu à partir de la
    structure de données du planificateur mais il est directement fourni pour
    ne pas avoir à faire cet effort.)
   </para>

   <para>
    Cette fonction doit mettre à jour <literal>baserel-&gt;rows</literal> pour
    que cela corresponde au nombre de lignes renvoyées par un parcours de table
    après avoir pris en compte le filtre réalisé par les clauses de restriction.
    La valeur initiale de <literal>baserel-&gt;rows</literal> est une estimation
    par défaut, qui doit être remplacée si possible. La fonction pourrait aussi
    choisir de mettre à jour <literal>baserel-&gt;width</literal> si elle
    peut calculer une meilleure estimation de la largeur moyenne d'une ligne du
    résultat.
    (La valeur initiale est basée sur les types de données des colonnes et sur
    les valeurs de largeur moyenne des colonnes, mesurées par le dernier
    <command>ANALYZE</command>.) De plus, cette fonction pourrait mettre à
    jour <literal>baserel-&gt;tuples</literal> s'il peut calculer une
    meilleure estimation du nombre total de lignes de ma table distante.
    (La valeur initiale provient de
    <structname>pg_class</structname>.<structfield>reltuples</structfield>
    qui représente le nombre total de lignes vues par le dernier
    <command>ANALYZE</command>.)
   </para>

   <para>
    Voir <xref linkend="fdw-planning"/> pour plus d'informations.
   </para>

   <para>
    <programlisting>
void
GetForeignPaths (PlannerInfo *root,
                 RelOptInfo *baserel,
                 Oid foreigntableid);
    </programlisting>

    Crée les chemins d'accès possibles pour un parcours sur une table distante.
    Cette fonction est appelée lors de la planification de la requête. Les
    paramètres sont identiques à ceux de <function>GetForeignRelSize</function>,
    qui a déjà été appelée.
   </para>

   <para>
    Cette fonction doit générer au moins un chemin d'accès (nœud
    <structname>ForeignPath</structname>) pour un parcours sur une table
    distante et doit appeler <function>add_path</function> pour ajouter chaque
    chemin à <literal>baserel-&gt;pathlist</literal>. Il est recommandé
    d'utiliser <function>create_foreignscan_path</function> pour construire les
    nœuds <structname>ForeignPath</structname>. La fonction peut générer plusieurs
    chemins d'accès, c'est-à-dire un chemin qui a un champ
    <literal>pathkeys</literal> valide pour représenter un résultat pré-trié.
    Chaque chemin d'accès doit contenir les estimations de coûts et peut contenir
    toute information privée au FDW qui est nécessaire pour identifier la méthode
    attendue du parcours spécifique.
   </para>

   <para>
    Voir <xref linkend="fdw-planning"/> pour plus d'informations.
   </para>

   <para>
    <programlisting>
ForeignScan *
GetForeignPlan (PlannerInfo *root,
                RelOptInfo *baserel,
                Oid foreigntableid,
                ForeignPath *best_path,
                List *tlist,
                List *scan_clauses,
                Plan *outer_plan);
    </programlisting>

    Crée un nœud de plan <structname>ForeignScan</structname> à partir du chemin
    d'accès distant sélectionné. Cette fonction est appelé à la fin de la
    planification de la requête.
    Les paramètres sont identiques à ceux de la fonction
    <function>GetForeignRelSize</function>, avec en plus le
    <structname>ForeignPath</structname> sélectionné (précédemment produit par
    <function>GetForeignPaths</function>, <function>GetForeignJoinPaths</function>
    ou <function>GetForeignUpperPaths</function>), la liste cible à émettre par le
    nœud du plan, les clauses de restriction forcées par le nœud du plan,
    et le sous-plan externe de <structname>ForeignScan</structname>, utilisé
    pour les vérifications réalisées par <function>RecheckForeignScan</function>.
    (Si le chemin est pour une jointure plutôt qu'une relation de base,
    <literal>foreigntableid</literal> est <literal>InvalidOid</literal>.)
   </para>

   <para>
    Cette fonction doit créer et renvoyer un nœud <structname>ForeignScan</structname>.
    Il est recommandé d'utiliser <function>make_foreignscan</function> pour
    construire le nœud <structname>ForeignScan</structname>.
   </para>

   <para>
    Voir <xref linkend="fdw-planning"/> pour plus d'informations.
   </para>
   </sect2>

   <sect2 id="fdw-callbacks-upper-planning">
    <title>Routines FDW pour optimiser le traitement après parcours/jointure</title>

    <para>
     Si un FDW supporte l'exécution distante de jointure après parcours, comme
     une agrégation distante, il doit fournir cette fonction callback&nbsp;:
    </para>

    <para>
<programlisting>
void
GetForeignUpperPaths(PlannerInfo *root,
                     UpperRelationKind stage,
                     RelOptInfo *input_rel,
                     RelOptInfo *output_rel,
                     void *extra);
</programlisting>
     Crée les chemins d'accès possibles pour le traitement <firstterm>relation
     de niveau supérieur</firstterm>, qui est le terme de l'optimiseur pour tout
     traitement après parcours/jointure, comme les agrégats, les fonctions de
     fenêtrage, le tri et les mises à jour de table. Cette fonction optionnelle
     est appelée lors de l'optimisation de la requête. Actuellement, elle est
     seulement appelée si toutes les relations de base impliquées appartiennent
     au même FDW. Cette fonction doit générer des chemins
     <structname>ForeignPath</structname> pour tout traitement
     post-parcours/jointure que le FDW sait réaliser à distance
     (utilisez <function>create_foreign_upper_path</function> pour les construire),
     et appeler
     <function>add_path</function> pour ajouter ces chemins à la relation
     indiquée du niveau supérieur. Tout comme
     <function>GetForeignJoinPaths</function>, il n'est pas nécessaire que
     cette fonction réussisse à créer des chemins, étant donnée qu'il est
     toujours possible d'utiliser des chemins de traitement local.
    </para>

    <para>
     Le paramètre <literal>stage</literal> identifie l'étape post-
     parcours/jointure est en cours de considération.
     <literal>output_rel</literal> est la relation supérieure devant recevoir
     les chemins représentation le traitement de cette étape, et
     <literal>input_rel</literal> est la relation représentant la source de
     cette étape. Le paramètre <literal>extra</literal> fournit des détails
     supplémentaires. Pour le moment, il est uniquement positionné pour
     <literal>UPPERREL_PARTIAL_GROUP_AGG</literal> ou
     <literal>UPPERREL_GROUP_AGG</literal>, auquel cas il pointe vers une
     structure <literal>GroupPathExtraData</literal>&nbsp;;
     ou pour <literal>UPPERREL_FINAL</literal>, auquel cas il pointe
     vers une structure <literal>FinalPathExtraData</literal>.
     (Notez que les chemins <structname>ForeignPath</structname>
     ajoutés à <literal>output_rel</literal> n'auront typiquement pas de
     dépendances directes avec les chemins de <literal>input_rel</literal> car
     leur traitement se fait en externe. Néanmoins, examiner les chemins
     précédemment générés pour l'étape de traitement précédente peut se
     révéler utile pour éviter un travail redondant de planification.)
    </para>

    <para>
     Voir <xref linkend="fdw-planning"/> pour plus d'informations.
    </para>

   <para>
    <programlisting>
void
BeginForeignScan (ForeignScanState *node,
                  int eflags);
    </programlisting>

    Commence l'exécution d'un parcours distant. L'appel se fait lors du
    démarrage de l'exécuteur. Cette fonction doit réaliser toutes les
    initialisation nécessaires avant le démarrage du parcours, mais ne
    doit pas commencer à exécuter le vrai parcours (cela se fera lors
    du premier appel à <function>IterateForeignScan</function>). Le
    n&oelig;ud <structname>ForeignScanState</structname> est déjà créé
    mais son champ <structfield>fdw_state</structfield> vaut toujours
    NULL. Les informations sur la table à parcourir sont accessibles
    via le n&oelig;ud <structname>ForeignScanState</structname> (en
    particulier à partir du n&oelig;ud sous-jacent
    <structname>ForeignScan</structname> qui contient toute information
    privée au FDW fournie par <function>GetForeignPlan</function>).
    <literal>eflags</literal> contient les bits de drapeaux décrivant le
    mode opératoire de l'exécuteur pour ce n&oelig;ud du plan.
   </para>

   <para>
    Notez que quand <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal>
    est vraie, cette fonction ne doit pas réaliser d'actions visibles
    en externe. Elle doit seulement faire le minimum requis pour que
    l'état du n&oelig;ud soit valide pour
    <function>ExplainForeignScan</function> et
    <function>EndForeignScan</function>.
   </para>

   <para>
    <programlisting>
TupleTableSlot *
IterateForeignScan (ForeignScanState *node);
    </programlisting>

    Récupère une ligne de la source distante, la renvoyant dans un
    emplacement de ligne de table (le champ
    <structfield>ScanTupleSlot</structfield> du n&oelig;ud doit être
    utilisé dans ce but). Renvoie NULL s'il n'y a plus de lignes
    disponibles. L'infrastructure d'emplacement de ligne de table permet
    qu'une ligne physique ou virtuelle soit renvoyée. Dans la plupart
    des cas, la deuxième possibilité (virtuelle), est préférable d'un
    point de vue des performances. Notez que cette fonction est appelée
    dans un contexte mémoire dont la durée de vie est très courte et
    qui sera réinitialisé entre chaque appel. Créez un contexte mémoire
    dans <function>BeginForeignScan</function> si vous avez besoin d'un
    stockage qui tient plus longtemps ou utilisez le champ
    <structfield>es_query_cxt</structfield> de <structname>EState</structname>.
   </para>

   <para>
    Les lignes renvoyées doivent correspondre à la liste cible
    <structfield>fdw_scan_tlist</structfield> si elle a été fournie,
    sinon elles doivent correspondre au type de ligne de la table distante
    parcourue. Si vous choisissez d'optimiser en récupérant d'avance des
    colonnes non nécessaires, vous devriez insérer des valeurs NULL
    dans les positions de ces colonnes, ou sinon générer une liste
    <structfield>fdw_scan_tlist</structfield> avec ces colonnes omises.
   </para>

   <para>
    Notez que l'exécuteur de <productname>PostgreSQL</productname> ne
    se préoccupe pas de savoir si les lignes renvoyées violent
    les contraintes définies sur la table distante &mdash; mais le
    planificateur s'en préoccupe, et peut optimiser les requêtes
    incorrectement si il y a des lignes visibles dans la table distante
    qui ne satisfont pas une contrainte déclarée. Si une contrainte
    est violée lorsque l'utilisateur a déclaré que la contrainte
    devrait être vrai, il peut être approprié de lever une erreur
    (de la même manière que vous devriez le faire dans le cas où les
    types de données ne correspondent pas).
   </para>

   <para>
    <programlisting>
void
ReScanForeignScan (ForeignScanState *node);
    </programlisting>

    Recommence le parcours depuis le début. Notez que les paramètres
    dont dépent le parcours peuvent avoir changés de valeur, donc le
    nouveau parcours ne va pas forcément renvoyer les mêmes lignes.
   </para>

   <para>
    <programlisting>
void
EndForeignScan (ForeignScanState *node);
    </programlisting>

    Termine le parcours et relâche les ressources. Il n'est habituellement
    pas nécessaire de relâcher la mémoire allouée via palloc. Par contre,
    les fichiers ouverts et les connexions aux serveurs distants doivent
    être nettoyés.
   </para>

  </sect2>

   <sect2 id="fdw-callbacks-join-scan">
    <title>Routines des FDW pour le parcours des jointures distantes</title>

    <para>
     Si un FDW permet d'effectuer des jointures distantes (autrement
     qu'en récupérant les données des deux tables et en faisant la
     jointure localement), il devrait fournir cette fonction callback&nbsp;:
    </para>

    <para>
<programlisting>
void
GetForeignJoinPaths (PlannerInfo *root,
                     RelOptInfo *joinrel,
                     RelOptInfo *outerrel,
                     RelOptInfo *innerrel,
                     JoinType jointype,
                     JoinPathExtraData *extra);
</programlisting>
     Crée les chemins possibles d'accès pour une jointure de
     deux (ou plus) tables distantes qui toutes proviennent du
     même serveur distant. Cette fonction optionnelle est appelée
     durant la planification de la requête. De la même façon que
     <function>GetForeignPaths</function>, cette fonction devrait
     générer des chemins <structname>ForeignPath</structname> pour
     le paramètre <literal>joinrel</literal> fourni
     (utilisez <function>create_foreign_join_path</function> pour les construire),
     et appeler la
     fonction <function>add_path</function> pour ajouter ces chemins
     à l'ensemble des chemins à considérer pour la jointure. Mais
     contrairement à <function>GetForeignPaths</function>, il n'est
     pas nécessaire que cette fonction réussisse à créer au moins
     un chemin, dans la mesure où des chemins entraînant des jointures
     locales sont toujours possibles.
    </para>

    <para>
     Notez que cette fonction sera invoquée de manière répétitive
     pour la même jointure, avec des combinaisons différentes de
     relations internes ou externes&nbsp;; il est de la responsabilité du
     FDW de minimiser les tâches dupliquées.
    </para>

    <para>
     Si un chemin <structname>ForeignPath</structname> est choisi
     pour la jointure, il représentera l'ensemble du processus
     de jointure&nbsp;; les chemins générés pour les tables qui
     la composent et les jointures auxiliaires ne seront pas
     utilisés. Les traitements suivants des chemins de jointure
     procèdent essentiellement de la même manière que pour un chemin
     parcourant une simple table distante. Une différence est que le
     <structfield>scanrelid</structfield> résultant du nœud du plan
     <structname>ForeignScan</structname> devrait être mis à zéro,
     dans la mesure où il ne représente aucune relation simple&nbsp;; à
     la place, le champ <structfield>fd_relids</structfield> du nœud
     <structname>ForeignScan</structname> représente l'ensemble des
     relations qui ont été jointes. (Le dernier champ est positionné
     automatiquement par le code interne du planificateur, et n'a pas
     besoin d'être rempli par le FDW.) Une autre différence est que,
     comme la liste des colonnes pour une jointure distante ne peut
     être trouvée dans les catalogues systèmes, le FDW doit remplir
     <structfield>fdw_scan_tlist</structfield> avec une liste appropriée
     de nœuds <structfield>TargetEntry</structfield>, représentant
     l'ensemble des colonnes qu'il fournira à l'exécution dans les
     lignes qu'il retournera.
   </para>

   <para>
    Voir <xref linkend="fdw-planning"/> pour des informations supplémentaires.
   </para>

  </sect2>

  <sect2 id="fdw-callbacks-update">
   <title>Routines FDW pour la mise à jour des tables distantes</title>

   <para>
    Si un FDW supporte la modification des tables distantes, il doit fournir
    certaines ou toutes les fonctions callback suivant les besoins et les
    capacités du FDW&nbsp;:
   </para>

   <para>
    <programlisting>
void
AddForeignUpdateTargets (Query *parsetree,
                         RangeTblEntry *target_rte,
                         Relation target_relation);
    </programlisting>

    Les opérations <command>UPDATE</command> et <command>DELETE</command> sont
    réalisées contre des lignes précédemment récupérées par des fonctions de
    parcours de table. Le FDW peut avoir besoin d'informations supplémentaires,
    comme l'identifiant de la ligne ou les valeurs des colonnes formant la clé
    primaire pour s'assurer qu'il peut identifier la ligne exacte à mettre à
    jour ou à supprimer. Pour supporter cela, cette fonction peut ajouter des
    colonnes cibles supplémentaires cachées à la liste des colonnes qui doivent
    être récupérées de la table distante pendant une opération
    <command>UPDATE</command> ou <command>DELETE</command>.
   </para>

   <para>
    Pour faire cela, ajoutez les éléments <structname>TargetEntry</structname> à
    <literal>parsetree-&gt;targetList</literal>, contenant les expressions des
    valeurs supplémentaires à récupérer. Chacun de ces entrées doit être marquée
    <structfield>resjunk</structfield> = <literal>true</literal>, et doit avoir
    un <structfield>resname</structfield> distinct qui l'identifiera à
    l'exécution. Évitez d'utiliser des noms correspondant à
    <literal>ctid<replaceable>N</replaceable></literal>,
    <literal>wholerow</literal> ou
    <literal>wholerow<replaceable>N</replaceable></literal>, car le système peut
    générer des colonnes ayant ces noms.
    Si les expressions supplémentaires sont plus complexes que de simples Vas,
    elles doivent être exécutées au travers de
    <function>eval_const_expressions</function> avant de les ajouter dans la
    liste de cibles (<literal>targetlist</literal>).
   </para>

   <para>
    Bien que cette fonction soit appelée lors de l'optimisation, les
    informations fournies sont un peu différentes de celles des routines de
    planification.
    <literal>parsetree</literal> est l'arbre d'analyse pour la commande
    <command>UPDATE</command> ou <command>DELETE</command> alors que
    <literal>target_rte</literal> et <literal>target_relation</literal>
    décrivent la table distante cible.
   </para>

   <para>
    Si le pointeur <function>AddForeignUpdateTargets</function> est initialisé
    à <literal>NULL</literal>, aucune expression cible supplémentaire ne sera
    ajoutée.
    (Ceci rend impossible l'implémentation des opérations
    <command>DELETE</command> bien que l'<command>UPDATE</command> est toujours
    faisable si le FDW se base sur une clé primaire ne changeant pas pour
    identifier les lignes.)
   </para>

   <para>
    <programlisting>
List *
PlanForeignModify (PlannerInfo *root,
                   ModifyTable *plan,
                   Index resultRelation,
                   int subplan_index);
    </programlisting>

    Réalise toute opération supplémentaire de planification nécessaire pour
    une insertion, mise à jour ou suppression sur une table distante. Cette
    fonction génère l'information privée du FDW qui sera attachée au n&oelig;ud
    du plan <structname>ModifyTable</structname> qui réalise la mise à jour.
    Cette information privée doit avoir la forme d'une
    <literal>List</literal>, et sera réalisée par
    <function>BeginForeignModify</function> lors de l'exécution.
   </para>

   <para>
    <literal>root</literal> est l'information globale du planificateur sur la
    requête.
    <literal>plan</literal> est le n&oelig;ud du plan
    <structname>ModifyTable</structname> qui est complet sauf pour le champ
    <structfield>fdwPrivLists</structfield>.
    <literal>resultRelation</literal> identifie la table distante cible par son
    index rangetable. <literal>subplan_index</literal> identifie la cible
    du n&oelig;ud de plan <structname>ModifyTable</structname> en comptant à
    partir de zéro&nbsp;; utilisez ceci si vous voulez indexer dans
    <literal>plan-&gt;plans</literal> ou toute autre sous-structure du n&oelig;ud
    <literal>plan</literal>.
   </para>

   <para>
    Voir <xref linkend="fdw-planning"/> pour plus d'informations.
   </para>

   <para>
    Si le pointeur <function>PlanForeignModify</function> est initialisé à
    <literal>NULL</literal>, aucune action supplémentaire n'est réalisée au
    moment de la planification, et la liste <literal>fdw_private</literal>
    renvoyée par <function>BeginForeignModify</function> vaudra NIL.
   </para>

   <para>
    <programlisting>
void
BeginForeignModify (ModifyTableState *mtstate,
                    ResultRelInfo *rinfo,
                    List *fdw_private,
                    int subplan_index,
                    int eflags);
    </programlisting>

    Commence l'exécution d'une opération de modification de la table distante.
    Cette routine est appelée lors du démarrage de l'exécuteur. Elle doit
    réaliser toute initialisation nécessaire avant de procéder aux modifications
    de la table. En conséquence, <function>ExecForeignInsert</function>,
    <function>ExecForeignUpdate</function> ou <function>ExecForeignDelete</function>
    seront appelées pour chaque ligne à insérer, mettre à jour ou supprimer.
   </para>

   <para>
    <literal>mtstate</literal> est l'état général du n&oelig;ud de plan
    <structname>ModifyTable</structname> en cours d'exécution&nbsp;; les
    données globales sur le plan et l'état d'exécution sont disponibles via
    cette structure.
    <literal>rinfo</literal> est la structure
    <structname>ResultRelInfo</structname> décrivant la table distante cible.
    (Le champ <structfield>ri_FdwState</structfield> de
    <structname>ResultRelInfo</structname> est disponible pour que le FDW
    enregistre tout état privé dont il aurait besoin pour réaliser cette
    opération.)
    <literal>fdw_private</literal> contient les données privées générées par
    <function>PlanForeignModify</function>.
    <literal>subplan_index</literal> identifie la cible du n&oelig;ud de
    plan <structname>ModifyTable</structname>.
    <literal>eflags</literal> contient les bits de drapeaux décrivant le mode
    opératoire de l'exécuteur pour ce n&oelig;ud de plan.
   </para>

   <para>
    Notez que quand <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal>
    est vrai, cette fonction ne devrait réaliser aucune action visible
    externe&nbsp;; il devrait seulement faire le minimum requis pour rendre
    l'état du n&oelig;ud valide pour
    <function>ExplainForeignModify</function> et
    <function>EndForeignModify</function>.
   </para>

   <para>
    Si le pointeur <function>BeginForeignModify</function> est initialisé à
    <literal>NULL</literal>, aucune action n'est prise lors du démarrage
    de l'exécuteur.
   </para>

    <para>
     Notez que cette fonction est aussi appelée lors de l'insertion de lignes
     déplacées dans une partition de type table distante ou lors de
     l'exécution de <command>COPY FROM</command> sur une table distante,
     auquel cas elle est appelée d'une façon différente que dans le cas d'un
     <command>INSERT</command>. Voir les fonctions callback décrites
     ci-dessous permettant au FDW de le supporter. described below that allow
     the FDW to support that.
    </para>

   <para>
    <programlisting>
TupleTableSlot *
ExecForeignInsert (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);
    </programlisting>

    Insère une ligne dans la table distante.
    <literal>estate</literal> est un état global de l'exécution de la requête.
    <literal>rinfo</literal> est la structure <structname>ResultRelInfo</structname>
    décrivant la table distante cible.
    <literal>slot</literal> contient la ligne à insérer&nbsp;; ça correspondra
    à la définition du type de la ligne de la table distante.
    <literal>planSlot</literal> contient la ligne qui a été générée par le
    sous-plan du n&oelig;ud <structname>ModifyTable</structname>&nbsp;; cela
    diffère du <literal>slot</literal> qui contient aussi les colonnes
    supplémentaires.
    (Le <literal>planSlot</literal> a typiquement peu d'intérêt pour
    <command>INSERT</command> mais est fourni pour être complet.)
   </para>

   <para>
    La valeur de retour est soit un emplacement contenant les données
    effectivement insérées (elles peuvent différer des données fournies, par
    exemple suite à l'action de triggers), soit NULL si aucune ligne
    n'a été insérée (là aussi typiquement le résultat d'un trigger). Le
    <literal>slot</literal> peut être ré-utilisé dans ce contexte.
   </para>

   <para>
    Les données du slot retourné ne sont utilisées que si la commande
    <command>INSERT</command> a une clause <literal>RETURNING</literal>
    ou implique une vue <literal>WITH CHECK OPTION</literal>&nbsp;;
    ou si la table étrangère a un trigger <literal>AFTER ROW</literal>.
    Les triggers ont besoin de toutes les colonnes,
    mais le FDW peut choisir d'optimiser en ne retournant que certaines colonnes,
    voire aucune, selon la clause <literal>RETURNING</literal>
    ou les contraintes <literal>WITH CHECK OPTION</literal>.
    Cependant, un slot doit être retourné pour indiquer un succès, sinon le
    nombre de lignes retournées rapporté par la requête sera faux.
   </para>

   <para>
    Si le pointeur <function>ExecForeignInsert</function> est initialisé à
    <literal>NULL</literal>, les tentatives d'insertion dans la table distante
    échoueront avec un message d'erreur.
   </para>

    <para>
     Notez que cette fonction est aussi appelée à l'insertion de lignes
     reroutées vers une partition qui est une table étrangère, ou à l'exécution
     de <command>COPY FROM</command> sur une table étrangère, auxquels cas
     elle sera appelée d'une manière différente du cas d'un
     <command>INSERT</command>. Voir les fonctions callback décrites plus bas
     qui permettent au FDW de supporter cela.
    </para>

   <para>
    <programlisting>
TupleTableSlot *
ExecForeignUpdate (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);
    </programlisting>

    Met à jour une ligne dans la table distante.
    <literal>estate</literal> est l'état global de l'exécution de la requête.
    <literal>rinfo</literal> est la structure <structname>ResultRelInfo</structname>
    décrivant la table distante cible.
    <literal>slot</literal> contient les nouvelles données de la ligne&nbsp;;
    elles correspondront à la définition du type de ligne pour la table
    distante.
    <literal>planSlot</literal> contient la ligne qui a été générée par le
    sous-plan du n&oelig;ud <structname>ModifyTable</structname>&nbsp;; il
    diffère de <literal>slot</literal> car il peut contenir des colonnes
    supplémentaires. En particulier, toute colonne supplémentaire qui était
    réclamée par <function>AddForeignUpdateTargets</function> sera disponible
    à partir de cet emplacement.
   </para>

   <para>
    La valeur de retour est soit un emplacement contenant la nouvelle ligne
    modifiée (elle peut différer des données fournies suite, par exemple, à
    l'exécution d'un trigger), ou NULL si aucune ligne n'a été réellement
    mise à jour (là-encore typiquement l'action d'un trigger).
    L'emplacement <literal>slot</literal> fourni peut être réutilisé dans
    ce contexte.
   </para>

   <para>
    Les données du slot retourné ne sont utilisées que si la commande
    <command>>UPDATE</command> a une clause <literal>RETURNING</literal>
    ou implique une vue <literal>WITH CHECK OPTION</literal>&nbsp;;
    ou si la table étrangère a un trigger <literal>AFTER ROW</literal>.
    Les triggers ont besoin de toutes les colonnes,
    mais le FDW peut choisir d'optimiser en ne retournant que certaines colonnes,
    voire aucune, selon la clause <literal>RETURNING</literal>
    ou les contraintes <literal>WITH CHECK OPTION</literal>.
    Cependant, un slot doit être retourné pour indiquer un succès, sinon le
    nombre de lignes retournées rapporté par la requête sera faux.
   </para>

   <para>
    Si le pointeur <function>ExecForeignUpdate</function> est initialisé à
    <literal>NULL</literal>, les tentatives de mise à jour de la table
    distante échoueront avec un message d'erreur.
   </para>

   <para>
    <programlisting>
TupleTableSlot *
ExecForeignDelete (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);
    </programlisting>

    Supprime une ligne de la table distante.
    <literal>estate</literal> est l'état global de l'exécution de la requête.
    <literal>rinfo</literal> est la structure <structname>ResultRelInfo</structname>
    décrivant la table distante cible.
    <literal>slot</literal> ne contient rien d'utile à l'appel de la fonction
    mais peut être utilisé pour contenir la ligne renvoyée.
    <literal>planSlot</literal> contient la ligne générée par le sous-plan du
    n&oelig;ud du plan <structname>ModifyTable</structname>&nbsp;; en particulier,
    elle contient toute colonne supplémentaire réclamée par
    <function>AddForeignUpdateTargets</function>. Les colonnes supplémentaires
    doivent être utilisées pour identifier la ligne à supprimer.
   </para>

   <para>
    La valeur de retour est soit un slot contenant la ligne supprimée soit
    NULL si aucune ligne n'a été supprimée (par exemple suite a déclenchement
    d'un trigger). Le <literal>slot</literal> fourni en référence peut être
    utilisé pour contenir la ligne à renvoyer.
   </para>

   <para>
    Les données placées dans l'emplacement sont utilisées seulement si la
    requête <command>DELETE</command> dispose de la clause
    <literal>RETURNING</literal> ou si la table externe a un trigger
    <literal>AFTER ROW</literal>. Les triggers nécessitent toutes les colonnes
    mais le FDW pourrait choisir d'optimiser en ne renvoyant que certaines
    colonnes ou toutes suivant le contenu de la clause
    <literal>RETURNING</literal>. Néanmoins, un slot doit être renvoyé pour
    indiquer le succès. Dans le cas contraire, le nombre de lignes rapporté
    par la requête sera faux.
   </para>

   <para>
    Si le pointeur <function>ExecForeignDelete</function> est initialisé à
    <literal>NULL</literal>, les tentatives de suppression dans la table
    distante échoueront avec un message d'erreur.
   </para>

   <para>
    <programlisting>
void
EndForeignModify (EState *estate,
                  ResultRelInfo *rinfo);
    </programlisting>

    Termine la mise à jour et libère les ressources. Il n'est normalement pas
    importante de libérer la mémoire prise avec palloc mais, par exemple, les
    fichiers ouverts et les connexions vers des serveurs distants doivent
    être nettoyés.
   </para>

   <para>
    Si le pointeur vers <function>EndForeignModify</function> est initialisé
    à <literal>NULL</literal>, aucune action n'a lieu pendant l'arrêt de
    l'exécuteur.
    </para>

    <para>
     Les lignes insérées dans une table partitionnée à l'aide
     d'<command>INSERT</command> ou <command>COPY FROM</command> sont redirigées
     vers les partitions. Si un FDW supporte la redirection des lignes pour
     les partitions déclarées comme table distantes, il devra également
     fournir les fonctions de callback suivantes. Ces fonctions sont également
     appelées quand <command>COPY FROM</command> est exécuté sur une table
     distante.
    </para>

    <para>
<programlisting>
void
BeginForeignInsert(ModifyTableState *mtstate,
                   ResultRelInfo *rinfo);
</programlisting>

     Débute l'exécution d'une opération d'insertion sur une table distante.
     Cette routine est appelée juste avant que la première ligne soit insérée
     dans la table distante quand il s'agit de la partition choisie par la
     redirection de ligne ou quand il s'agit de la cible spécifiée dans
     une commande <command>COPY FROM</command>.  Elle devrait effectuer toute
     initialisation nécessaire avant l'insertion elle-même.  Ensuite,
     <function>ExecForeignInsert</function> sera appelée pour chaque ligne
     devant être insérée dans la table distante.
    </para>

    <para>
     <literal>mtstate</literal> est l'état général du n&oelig;ud de plan
     <structname>ModifyTable</structname> en cours d'exécution&nbsp;;; les données
     globales sur le plan et l'état d'exécution sont disponibles via cette
     structure.
     <literal>rinfo</literal> est la structure
     <structname>ResultRelInfo</structname> décrivant la table distante cible.
     (Le champ <structfield>ri_FdwState</structfield> de
     <structname>ResultRelInfo</structname> est disponible pour que le FDW
     enregistre tout état privé dont il aurait besoin pour réaliser cette
     opération.)
    </para>

    <para>
     Quand elle est appelée par une commande <command>COPY FROM</command>, les
     données globales liées au plan contenues dans <literal>mtstate</literal>
     ne sont pas fournies et le paramètre <literal>planSlot</literal> de
     <function>ExecForeignInsert</function> appelée par la suite pour chaque
     ligne insérée vaut <literal>NULL</literal>, que la table distante soit la
     partition choisie par la redirection de ligne ou que cela soit la cible
     spécifiée dans la commande.
    </para>

    <para>
     Si le pointeur <function>BeginForeignInsert</function> est initialisé à
     <literal>NULL</literal>, aucune action n'est faite pour l'initialisation.
    </para>

    <para>
     Notez que si le FDW ne supporte pas les tables étrangères comme partitions
     routables et/ou l'exécution de <command>COPY FROM</command> sur des
     tables étrangères, cette fonction, ou
     <function>ExecForeignInsert</function> appelée après, doivent renvoyer
     une erreur si nécessaire.
    </para>

    <para>
<programlisting>
void
EndForeignInsert(EState *estate,
                 ResultRelInfo *rinfo);
</programlisting>

     Termine l'opération d'insertion et libère les ressources.  Il n'est
     habituellement pas nécessaire de libérer la mémoire allouée via palloc.
     Par contre, les fichiers ouverts et les connexions aux serveurs distants
     doivent être libérés par exemple.
    </para>

    <para>
     Si le pointeur <function>EndForeignInsert</function> est initialisé à
     <literal>NULL</literal>, aucune action n'est faite pour la fin de
     l'opération d'insertion.
   </para>

   <para>
    <programlisting>
int
IsForeignRelUpdatable (Relation rel);
    </programlisting>

    Indique les opérations de mise à jour supportées par la table distante
    indiquée. La valeur de retour doit être un masque de bits correspondant
    aux numéros d'événement des règles, indiquant les opérations supportées
    par la table disante, en utilisant l'énumération <literal>CmdType</literal>.
    Autrement dit
    <literal>(1 &lt;&lt; CMD_UPDATE) = 4</literal> pour <command>UPDATE</command>,
    <literal>(1 &lt;&lt; CMD_INSERT) = 8</literal> pour <command>INSERT</command> et
    <literal>(1 &lt;&lt; CMD_DELETE) = 16</literal> pour <command>DELETE</command>.
   </para>

   <para>
    Si le pointeur <function>IsForeignRelUpdatable</function> est configuré à
    <literal>NULL</literal>, les tables distantes sont supposées accepter les
    INSERT, UPDATE et DELETE si le connecteur FDW fournit respectivement les
    fonctions <function>ExecForeignInsert</function>,
    <function>ExecForeignUpdate</function> et
    <function>ExecForeignDelete</function>. Cette fonction est uniquement
    nécessaire si le FDW supporte quelques tables modifiables et d'autres qui
    ne le sont pas. (Et même là, il est possible de renvoyer une erreur dans la
    routine d'exécution au lieu de vérifier avec cette fonction. Néanmoins, cette
    fonction est utilisé pour déterminer l'état modifiable des tables qui sera
    affiché dans les vues <literal>information_schema</literal>.)
   </para>

    <para>
     Certaines insertions, mises à jour et suppressions vers des tables
     distantes peuvent être optimisées en implémentant un ensemble alternatif
     d'interfaces. Les interfaces habituelles pour les insertions, mises à
     jour et suppressions récupèrent les lignes du serveur distant, puis
     modifient les lignes, une par une. Dans certains cas, cette approche
     ligne par ligne est nécessaire mais elle peut s'avérer inefficace. S'il
     est possible pour le serveur distant de déterminer les lignes à modifier
     sans avoir à les récupérer, et qu'il n'y a pas de structures locales qui
     pourraient affecter l'opération (triggers locaux au niveau ligne,
     colonnes calculées automatiquement ou contraintes <literal>WITH CHECK OPTION</literal>
     provenant des vues parents), alors il est possible de s'arranger pour
     que l'opération entière soit réalisée sur le serveur distant. Les
     interfaces décrites ci-dessous rendent cela possible.
    </para>

    <para>
<programlisting>
bool
PlanDirectModify (PlannerInfo *root,
                  ModifyTable *plan,
                  Index resultRelation,
                  int subplan_index);
</programlisting>

     Décide si l'exécution d'une modification directement sur le serveur
     distant est sûre. Dans ce cas, renvoie <literal>true</literal> après
     avoir réalisé les actions d'optimisation nécessaire pour cela. Dans le
     cas contraire, renvoie <literal>false</literal>. Cette fonction
     optionnelle est appelée lors de la planification de la requête. Si cette
     fonction réussit, <function>BeginDirectModify</function>,
     <function>IterateDirectModify</function> et
     <function>EndDirectModify</function> seront appelées à l'étape
     d'exécution. Dans le cas contraire, la modification de la table sera
     exécutée en utilisant les fonctions de modification de la table décrites
     ci-dessus. Les paramètres sont les mêmes que pour
     <function>PlanForeignModify</function>.
    </para>

    <para>
     Pour exécuter la modification directe sur le serveur distant, cette
     fonction doit ré-écrire le sous-plan cible avec un nœud de plan
     <structname>ForeignScan</structname> qui exécute la modification directe
     sur le serveur distant. Le champ <structfield>operation</structfield> du
     <structname>ForeignScan</structname> doit être configuréé à l'énumération
     <literal>CmdType</literal> de façon approprié&nbsp;; c'est-à-dire
     <literal>CMD_UPDATE</literal> pour <command>UPDATE</command>,
     <literal>CMD_INSERT</literal> pour <command>INSERT</command> et
     <literal>CMD_DELETE</literal> pour <command>DELETE</command>.
    </para>

    <para>
     Voir <xref linkend="fdw-planning"/> pour plus d'informations.
    </para>

    <para>
     Si le pointeur <function>PlanDirectModify</function> est configuré à
     <literal>NULL</literal>, aucune tentative ne sera réalisée pour exécuter
     une modification directe sur le serveur distant.
    </para>

    <para>
<programlisting>
void
BeginDirectModify (ForeignScanState *node,
                   int eflags);
</programlisting>

     Prépare une exécution d'une modification directe sur le serveur distant.
     Cette fonction est appelée lors du démarrage de l'exécuteur. Elle doit
     réaliser toute initialisation nécessaire avant la modification directe,
     qui doit être réalisée lors du premier appel à
     <function>IterateDirectModify</function>). Le nœud
     <structname>ForeignScanState</structname> a déjà été créée mais son champ
     <structfield>fdw_state</structfield> vaut toujours NULL. Des informations
     sur la table à modifier sont disponibles au travers du nœud
     <structname>ForeignScanState</structname> (en particulier, à partir du
     nœud <structname>ForeignScan</structname> sous-jacent, qui contient des
     informations privées au FDW fournies par
     <function>PlanDirectModify</function>). <literal>eflags</literal>
     contient des bits d'informations décrivant le mode d'opération de
     l'exécuteur pour ce nœud de plan.
    </para>

    <para>
     Notez que quand <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal>
     est vrai, cette fonction ne doit pas réaliser d'actions visibles
     extérieurement&nbsp;; elle doit seulement faire le minimum requis pour
     rendre valide l'état du nœud pour
     <function>ExplainDirectModify</function> et
     <function>EndDirectModify</function>.
    </para>

    <para>
     Si le pointeur <function>BeginDirectModify</function> est configuré à
     <literal>NULL</literal>, aucune tentative ne sera réalisée pour exécuter
     une modification directe sur le serveur distant.
    </para>

    <para>
<programlisting>
TupleTableSlot *
IterateDirectModify (ForeignScanState *node);
</programlisting>

     Quand la requête <command>INSERT</command>, <command>UPDATE</command> ou
     <command>DELETE</command> ne contient pas de clause
     <literal>RETURNING</literal>, renvoie simplement NULL après une
     modification directe sur le serveur distant. Quand la requête contient
     cette clause, récupère un résultat contenant la donnée nécessaire pour le
     traitement du <literal>RETURNING</literal>, le renvoyant dans un slot de
     ligne de table (le champ <structfield>ScanTupleSlot</structfield> du nœud
     doit être utilisé pour cela). Les données insérées, mises à jour ou
     supprimées doivent être enregistrées dans le champ
     <literal>es_result_relation_info-&gt;ri_projectReturning-&gt;pi_exprContext-&gt;ecxt_scantuple</literal>
     du <structname>EState</structname> du nœud. Renvoie NULL s'il n'y a plus
     de lignes disponibles. Notez que cette fonction est appelée dans un
     contexte mémoire à court terme qui sera réinitialisée à chaque appel.
     Créez un contexte mémoire dans <function>BeginDirectModify</function> si
     vous avez besoin d'un stockage d'une durée de vie plus improtante ou
     utilisez <structfield>es_query_cxt</structfield> du champ
     <structname>EState</structname> du nœud.
    </para>

    <para>
     Les lignes renvoyées doivent correspondre à la liste cible
     <structfield>fdw_scan_tlist</structfield> si une liste a été fournie.
     Sinon, elles doivent correspondre au type de ligne de la table externe en
     cours de modification. Si vous choisissez d'optimiser la récupération des
     colonnes inutiles pour le traitement de <literal>RETURNING</literal>,
     vous devez placer des valeurs NULL à la position de ces colonnes ou
     générer une liste <structfield>fdw_scan_tlist</structfield> en omettant
     les colonnes inutiles.
    </para>

    <para>
     Que la requête ait la clause ou non, le nombre de lignes rapporté par la
     requête doit être incrémenté par le FDW lui-même. Quand la requête n'a
     pas de clause, le FDW doit aussi incrémenté le nombre de lignes pour le
     nœud <structname>ForeignScanState</structname> dans le cas d'un
     <command>EXPLAIN ANALYZE</command> case.
    </para>

    <para>
     Si le pointeur <function>IterateDirectModify</function> est configuré à
     <literal>NULL</literal>, aucune tentative ne sera réalisée pour exécuter
     une modification directe sur le serveur distant.
    </para>

    <para>
<programlisting>
void
EndDirectModify (ForeignScanState *node);
</programlisting>

     Nettoie après une modification directe sur le serveur distant. Il n'est
     normalement pas important de relâcher la mémoire allouée avec palloc
     mais, par exemple, des fichiers et des connexions ouvertes sur le serveur
     distant doivent fermés.
    </para>

    <para>
     Si le pointeur <function>EndDirectModify</function> est configuré à
     <literal>NULL</literal>, aucune tentative ne sera réalisée pour exécuter
     une modification directe sur le serveur distant.
    </para>

  </sect2>

   <sect2 id="fdw-callbacks-row-locking">
    <title>Routines FDW pour le verrouillage des lignes</title>

    <para>
     Si un FDW veut supporter le <firstterm>verrouillage
     tardif de lignes</firstterm> (comme décrit à <xref
     linkend="fdw-row-locking"/>), il doit fournir les fonctions callbacks
     suivantes&nbsp;:
    </para>

    <para>
<programlisting>
RowMarkType
GetForeignRowMarkType (RangeTblEntry *rte,
                       LockClauseStrength strength);
</programlisting>

     Indique quelle option de marquage de ligne utiliser pour
     une table distante. <literal>rte</literal> est le nœud
     <structname>RangeTblEntry</structname> pour la table et
     <literal>strength</literal> décrit la force du verrou
     requis par la clause <literal>FOR UPDATE/SHARE</literal>, si
     applicable. Le résultat doit être un membre du type énumération
     <literal>RowMarkType</literal>.
    </para>

    <para>
     Cette fonction est appelée durant la planification de la
     requête pour chaque table distante qui apparaît dans une
     requête <command>UPDATE</command>, <command>DELETE</command>,
     ou <command>SELECT FOR UPDATE/SHARE</command> et n'est
     pas la cible d'une commande <command>UPDATE</command> ou
     <command>DELETE</command>.
    </para>

    <para>
     Si le pointeur de fonction
     <function>GetForeignRowMarkType</function> est positionné à
     <literal>NULL</literal>, l'option <literal>ROW_MARK_COPY</literal>
     est toujours utilisée. (Ceci implique que la fonction
     <function>RefetchForeignRow</function> ne sera jamais appelée,
     aussi elle n'a pas besoin d'être fournie non plus.)
    </para>

    <para>
     Voir <xref linkend="fdw-row-locking"/> pour plus d'informations.
    </para>

    <para>
<programlisting>
void
RefetchForeignRow (EState *estate,
                   ExecRowMark *erm,
                   Datum rowid,
                   TupleTableSlot *slot,
                   bool *updated);
</programlisting>

     Récupère à nouveau une ligne à partir de
     la table distante, après l'avoir verrouillée si
     nécessaire. <literal>estate</literal> est l'état global
     d'exécution de la requête. <literal>erm</literal> est la
     structure <structname>ExecRowMark</structname> décrivant la
     table distante cible et le type de verrou ligne (si applicable)
     à prendre.
     <literal>rowid</literal> identifie la ligne à récupérer.
     <literal>slot</literal> ne contient rien d'utile lors de l'appel,
     mais peut être utilisé pour retourner l'enregistrement renvoyé.
     <literal>updated</literal> est un paramètre de sortie.
    </para>

    <para>
     Cette fonction doit renvoyer l'enregistrement dans le slot fourni à cet effet,
     ou l'effacer si le verrou sur la ligne ne peut être obtenu.
     Le type de verrou de ligne à acquérir est défini par
     <literal>erm-&gt;markType</literal>, qui est la valeur retournée
     précédemment par la fonction <function>GetForeignRowMarkType</function>.
     (<literal>ROW_MARK_REFERENCE</literal> signifie qu'il faut juste
     re-récupérer l'enregistrement sans poser aucun verrou,
     et <literal>ROW_MARK_COPY</literal> ne sera jamais envoyé à cette
     fonction.)
    </para>

    <para>
     En complément, <literal>*updated</literal> devrait être positionné
     à <literal>true</literal> si ce qui a été récupéré est une
     version mise à jour de la ligne plutôt que la même version
     obtenue précédemment. (Si le FDW ne peut être sûr à propos
     de cette information, retourner toujours <literal>true</literal>
     est recommandé.)
    </para>

    <para>
     Notez que par défaut, l'échec pour prendre un verrou ligne devrait avoir
     pour conséquence de lever une erreur&nbsp;; renvoyer un emplacement vide
     n'est approprié que si l'option <literal>SKIP LOCKED</literal> est
     spécifiée par <literal>erm-&gt;waitPolicy</literal>.
    </para>

    <para>
     <literal>rowid</literal> est la valeur de
     <structfield>ctid</structfield> précédemment lue pour la ligne
     récupérée à nouveau. Bien que la valeur <literal>rowid</literal>
     est envoyée comme type <type>Datnum</type>, elle ne peut être
     actuellement que de type <type>tid</type>. L'API de la fonction est
     choisie dans l'espoir qu'il sera possible d'autoriser d'autre types
     de données pour les identifiants des lignes dans le futur.
    </para>

    <para>
     Si le pointeur de fonction <function>RefetchForeignRow</function>
     est positionné sur <literal>NULL</literal>, les tentatives de
     récupération à nouveau des lignes échoueront avec un message
     d'erreur.
    </para>

    <para>
     Voir <xref linkend="fdw-row-locking"/> pour plus d'informations.
    </para>

    <para>
<programlisting>
bool
RecheckForeignScan (ForeignScanState *node, TupleTableSlot *slot);
</programlisting>
     Vérifie à nouveau qu'une ligne retournée précédemment
     correspond toujours au parcours et aux qualificatifs de jointures,
     et éventuellement fournit une version modifiée de la
     ligne. Pour les wrappers de données distantes qui ne supportent pas
     les jointures (<foreignphrase>join push-down</foreignphrase>), il
     sera plus pratique de positionner ce pointeur de fonction à
     <literal>NULL</literal> et, à la place, configurer
     <structfield>fdw_recheck_quals</structfield>
     de manière appropriée. Cependant lorsque des jointures
     externes sont poussées au serveur distant, il n'est pas suffisant d'appliquer à
     nouveau les vérifications applicables à toutes les tables
     de base à la ligne résultat, même si tous les attributs
     nécessaires sont présents, parce que l'impossibilité de mettre
     en correspondance certains qualificatifs pourrait résulter en la
     mise à NULL de certaines colonnes, plutôt qu'aucune ligne ne soit
     retournée. <literal>RecheckForeignScan</literal> peut vérifier
     à nouveau les qualificatifs et renvoyer true si ils sont toujours
     satisfaits et false dans le cas contraire, mais elle peut aussi
     stocker une ligne de remplacement dans l'emplacement fourni.
    </para>

    <para>
     Pour implémenter le support des jointures, un wrapper de données
     distantes construira typiquement un plan alternatif local qui est
     utilisé uniquement pour les revérifications&nbsp;; celui-ci deviendra
     le sous-plan externe de <literal>ForeignScan</literal>. Lorsqu'une
     révérification est requise, ce sous-plan peut être exécuté
     et la ligne résultante peut être stockée dans l'emplacement. Ce
     plan n'a pas besoin d'être efficace car aucune table de base ne
     retournera plus d'une ligne&nbsp;; par exemple, il peut réaliser toutes
     les jointures comme des boucles imbriquées.
     La fonction <literal>GetExistingLocalJoinPath</literal> peut être utilisée
     pour rechercher des chemins existants dans un chemin de jointure local
     convenable, qui est utilisable comme plan de jointure local alternatif.
     <literal>GetExistingLocalJoinPath</literal> recherche un chemin sans
     paramètre dans la liste de chemins de la relation de jointure spécifiée
     (si un tel chemin n'existe pas, elle renvoie NULL, ce qui fait que le FDW
     pourrait construire un chemin local lui-même ou pourrait choisir de ne pas
     créer de chemins d'accès pour cette jointure).
    </para>
   </sect2>

  <sect2 id="fdw-callbacks-explain">
   <title>Routines FDW pour <command>EXPLAIN</command></title>

   <para>
    <programlisting>
void
ExplainForeignScan (ForeignScanState *node,
                    ExplainState *es);
    </programlisting>

    Affiche une sortie <command>EXPLAIN</command> supplémentaire pour un
    parcours de table distante. Cette fonction peut faire appel à
    <function>ExplainPropertyText</function> et aux fonctions relatives pour
    ajouter des champs à la sortie d'<command>EXPLAIN</command>. Les champs
    drapeaux dans <literal>es</literal> peuvent être utilisés pour déterminer
    ce qui doit être affiché, et l'état du n&oelig;ud
    <structname>ForeignScanState</structname> peut être inspecté pour fournir
    des statistiques d'exécution dans le cas du <command>EXPLAIN
     ANALYZE</command>.
   </para>

   <para>
    Si le pointeur <function>ExplainForeignScan</function> vaut
    <literal>NULL</literal>, aucune information supplémentaire n'est affichée
    lors de l'<command>EXPLAIN</command>.
   </para>

   <para>
    <programlisting>
void
ExplainForeignModify (ModifyTableState *mtstate,
                      ResultRelInfo *rinfo,
                      List *fdw_private,
                      int subplan_index,
                      struct ExplainState *es);
    </programlisting>

    Affiche une sortie supplémentaire pour <command>EXPLAIN</command> lors
    de la mise à jour d'une table distante. Cette fonction peut appeler
    <function>ExplainPropertyText</function> et les fonctions en relation
    pour ajouter des champs à la sortie d'<command>EXPLAIN</command>. Les champs
    drapeaux de <literal>es</literal> peuvent être utilisés pour déterminer
    quoi afficher, et l'état du n&oelig;ud
    <structname>ModifyTableState</structname> peut être inspecté pour fournir
    des statistiques en exécution dans le cas du <command>EXPLAIN
     ANALYZE</command>. Les quatre premiers arguments sont les mêmes que pour
    <function>BeginForeignModify</function>.
   </para>

   <para>
    Si le pointeur <function>ExplainForeignModify</function> vaut
    <literal>NULL</literal>, aucune information supplémentaire n'est affichée
    lors de l'<command>EXPLAIN</command>.
   </para>

   <para>
<programlisting>
void
ExplainDirectModify (ForeignScanState *node,
                     ExplainState *es);
</programlisting>

     Affiche une sortie <command>EXPLAIN</command> supplémentaire pour une
     modification directe sur le serveur distant. Cette fonction peut appeler
     <function>ExplainPropertyText</function> et les fonctions relatives pour
     ajouter des champs à la sortie d'<command>EXPLAIN</command>. Les champs
     flag dans <literal>es</literal> peuvent être utilisés pour déterminer ce
     qui doit être affiché, et l'état du nœud
     <structname>ForeignScanState</structname> peut être inspecté pour fournir
     des statistiques à l'exécution dans le cas d'un <command>EXPLAIN
     ANALYZE</command>.
    </para>

    <para>
     Si le pointeur <function>ExplainDirectModify</function> est configuré à
     <literal>NULL</literal>, aucune information supplémentaire n'est affichée
     pendant un <command>EXPLAIN</command>.
    </para>

  </sect2>

  <sect2 id="fdw-callbacks-analyze">
   <title>Routines FDW pour <command>ANALYZE</command></title>

   <para>
    <programlisting>
bool
AnalyzeForeignTable (Relation relation,
                     AcquireSampleRowsFunc *func,
                     BlockNumber *totalpages);
    </programlisting>

    Cette fonction est appelée quand <xref linkend="sql-analyze"/> est exécuté
    sur une table distante. Si le wrapper de données distantes peut récupérer
    des statistiques pour cette table distante, il doit renvoyer
    <literal>true</literal>, et fournir un pointeur vers une fonction qui
    récupérera un échantillon de lignes à partir de la table dans
    <parameter>func</parameter>, ainsi que la taille estimée de la table en
    blocs dans <parameter>totalpages</parameter>. Sinon, il doit renvoyer
    <literal>false</literal>.
   </para>

   <para>
    Si le wrapper de données distantes ne supporte
    pas la récupération de statistiques quelque soit la table, le pointeur
    <function>AnalyzeForeignTable</function> doit être configuré à
    <literal>NULL</literal>.
   </para>

   <para>
    Si fourni, la fonction de récupération de l'échantillon doit avoir la
    signature suivante&nbsp;:
    <programlisting>
int
AcquireSampleRowsFunc(Relation relation,
                      int elevel,
                      HeapTuple *rows,
                      int targrows,
                      double *totalrows,
                      double *totaldeadrows);
    </programlisting>

    Un échantillon récupéré au hasard et comprenant au plus
    <parameter>targrows</parameter> lignes doit être récupéré à partir de la
    table et stocké dans le tableau <parameter>rows</parameter> fourni par
    l'appelant. Le nombre réel de lignes récupérées doit être renvoyé. De plus,
    les estimations du nombre total de lignes vivantes et mortes doivent être
    enregistrées dans les paramètres en sortie appelés
    <parameter>totalrows</parameter> et <parameter>totaldeadrows</parameter>.
    (Configurez <parameter>totaldeadrows</parameter> à zéro si le wrapper de
    données distantes ne connaît pas le concept des lignes mortes.)
   </para>

  </sect2>

   <sect2 id="fdw-callbacks-import">
    <title>Routines FDW pour <command>IMPORT FOREIGN SCHEMA</command></title>

    <para>
<programlisting>
List *
ImportForeignSchema (ImportForeignSchemaStmt *stmt, Oid serverOid);
</programlisting>

     Obtient une liste des commandes de création de tables
     distantes. Cette fonction est appelée lors de l'exécution de <xref
     linkend="sql-importforeignschema"/>, et il lui est passé l'arbre
     d'analyse pour cette instruction, ainsi que l'OID du serveur
     distant à utiliser. Elle devrait renvoyer une liste de chaînes
     C, chacune d'entre elles devant contenir une commande <xref
     linkend="sql-createforeigntable"/>. Ces chaînes seront analysées
     et exécutées par le serveur principal.
    </para>

    <para>
     À l'intérieur de la structure
     <structname>ImportForeignSchemaStmt</structname>,
     <structfield>remote_schema</structfield> est le nom
     du schéma distant à partir duquel les tables sont à
     importer. <structfield>list_type</structfield> indique comment
     filtrer les noms de tables&nbsp;: <literal>FDW_IMPORT_SCHEMA_ALL</literal>
     signifie que toutes les tables dans le schéma distant devraient
     être importées (dans ce cas, <structfield>table_list</structfield>
     est vide), <literal>FDW_IMPORT_SCHEMA_LIMIT_TO</literal>
     signifie d'inclure seulement les tables listées
     dans <structfield>table_list</structfield>, et
     <literal>FDW_IMPORT_SCHEMA_EXCEPT</literal> signifie d'exclure
     les tables listées dans <structfield>table_list</structfield>.
     <structfield>options</structfield> est une liste d'options utilisées
     pour le processus d'import. La signification des options relève du
     FDW. Par exemple, un FDW pourrait utiliser une option pour définir
     si les attributs <literal>NOT NULL</literal> des colonnes devraient
     être importés. Ces options n'ont pas besoin d'avoir une quelconque
     relation avec celles supportées par le FDW pour les objets base
     de données.
    </para>

    <para>
     Le FDW peut ignorer le champ <structfield>local_schema</structfield>
     de <structname>ImportForeignSchemaStmt</structname>, parce que
     le serveur principal insérera automatiquement ce nom dans les
     commandes <command>CREATE FOREIGN TABLE</command> analysées.
    </para>

    <para>
     Le FDW n'a pas besoin de mettre en place lui-même le
     filtrage spécifié par <structfield>list_type</structfield>
     et <structfield>table_list</structfield>, dans la mesure où
     le serveur principal ignorera automatiquement les commandes
     renvoyées pour les tables exclues selon ces options. Cependant,
     il est souvent utile d'éviter le travail de création des
     commandes pour les tables exclues dès le départ. La fonction
     <function>IsImportableForeignTable()</function> peut être utile
     pour tester si une table distante donnée passera ou pas le filtre.
    </para>

    <para>
     Si le FDW ne supporte pas l'import de définition de tables,
     le pointeur de fonction <function>ImportForeignSchema</function>
     peut être positionné à <literal>NULL</literal>.
    </para>

   </sect2>

   <sect2 id="fdw-callbacks-parallel">
    <title>Routines FDW pour une exécution parallélisée</title>
    <para>
     Un nœud <structname>ForeignScan</structname> peut, en option, supporter
     une exécution parallélisée. Un <structname>ForeignScan</structname>
     parallélisée sera exécutée par plusieurs processus et devra renvoyer
     chaque ligne une fois seulement au travers de tous les processus
     coopérant. Pour faire cela, les processus peuvent se coordonner avec des
     ensembles de taille fixe de mémoire partagée dynamique. Cette mémoire
     partagée n'est pas garantie d'être placée à la même adresse pour chaque
     processus, donc il ne doit pas contenir de pointeurs. Les fonctions
     suivantes sont toutes optionnelles général, mais elles sont requises si
     une exécution parallèle doit être supportée.
    </para>

    <para>
<programlisting>
bool
IsForeignScanParallelSafe(PlannerInfo *root, RelOptInfo *rel,
                          RangeTblEntry *rte);
</programlisting>
    Teste si un parcours peut être réaliseé avec un processus parallèle. Cette
    fonction sera seulement appelée quand le planificateur pense qu'un plan
    parallélisé est possible, et doit renvoyer true si un tel plan est sûr
    pour ce parcours. Ceci ne sera généralement pas le cas si la source de
    données distante a des sémantiques transactionnelles, sauf si la connexion
    du processus supplémentaire peut être en quelque sorte partagée dans le
    même contexte transactionnelle que celui du processus maître
    </para>

    <para>
    Si ce callback n'est pas défini, il est supposé que le parcours doit avoir
    lieu au niveau du processus maître. Notez que renvoyer true ne signifie
    pas que le parcours sera parallélisé. Cela signifie seulement qu'il est
    possible de l'effectuer avec des processus parallèles. De ce fait, il peut
    être utile de définir cette méthode même quand l'exécution parallélisée
    n'est pas supportée.
    </para>

    <para>
<programlisting>
Size
EstimateDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt);
</programlisting>
    Estime la quantité de mémoire partagée dynamique requis pour une opération
    parallélisée. Cette valeur pourrait être supérieure à la quantité
    réellement utilisée mais elle ne peut pas être inférieure. La valeur
    renvoyée est en octets. Cette fonction est optionnelle et peut être omise
    si elle n'est pas nécessaire. Mais si elle est omise, les trois fonctions
    suivantes peuvent elles-aussi être omises parce qu'aucune mémoire partagée
    ne sera allouée pour une utilisation avec le FDW.
    </para>

    <para>
<programlisting>
void
InitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,
                         void *coordinate);
</programlisting>
    Initialise la mémoire partagée dynamique qui sera requise pour une
    opération parallélisée&nbsp;; <literal>coordinate</literal> pointe vers
    une partie de mémoire partagée de même taille que la valeur de retour de
    <function>EstimateDSMForeignScan</function>. Cette fonction est
    optionnelle et peut être omise si nécessaire.
   </para>

   <para>
<programlisting>
void
ReInitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,
                           void *coordinate);
</programlisting>
    Ré-initialise la mémoire partagée dynamique requise pour les opérations
    parallélisées quand le n&oelig;ud du plan pour le parcours distant va être
    ré-exécuté. Cette fonction est optionnelle et peut être omise si
    nécessaire. La pratique recommandée est que cette fonction réinitialise
    seulement l'état partagé alors que la fonction
    <function>ReScanForeignScan</function> réinitialise seulement l'état
    local. Actuellement, cette fonction sera appelée avant
    <function>ReScanForeignScan</function> mais il est préférable de ne pas se
    baser sur cet ordre.
   </para>

   <para>
<programlisting>
void
InitializeWorkerForeignScan(ForeignScanState *node, shm_toc *toc,
                            void *coordinate);
</programlisting>
    Initialise un état local d'un processus parallèle suivant l'état partagé
    configuré dans le processus maître par
    <literal>InitializeDSMForeignScan</literal>. Cette fonction est
    optionnelle et peut être omise si nécessaire.
   </para>

   <para>
<programlisting>
void
ShutdownForeignScan(ForeignScanState *node);
</programlisting>
    Libères les ressources quand il anticpé que le nœud ne sera pas exécuté
    entièrement.  Cette fonction ne sera pas appelée dans tous les cas;
    parfois, <literal>EndForeignScan</literal> peut être appelée sans que cette
    fonction ait été appelée avant.  Puisque le segment DSM utilisé par les
    requêtes parallèles est détruit juste après que ce callback soit appelé,
    les wrappers de données distantes qui désirent effectuer des actions avant
    que le segment DSM disparaissent devraient implémenter cette méthode.
   </para>
 </sect2>

   <sect2 id="fdw-callbacks-reparameterize-paths">
    <title>FDW Routines For reparameterization of paths</title>

    <para>
<programlisting>
List *
ReparameterizeForeignPathByChild(PlannerInfo *root, List *fdw_private,
                                 RelOptInfo *child_rel);
</programlisting>
    Cette fonction est appelée lors de la conversion d'un chemin paramétré par
    le plus haut parent de la relation enfant <literal>child_rel</literal>
    spécifiée devant être paramétrée avec la relation enfant.  Cette fonction
    est utilisée pour reparamétrer n'importe quel chemin ou traduire n'importe
    quel n&oelig;ud d'expression enregistré dans le membre
    <literal>fdw_private</literal> du <structname>ForeignPath</structname>
    spécifié.  Le callback peut utiliser
    <literal>reparameterize_path_by_child</literal>,
    <literal>adjust_appendrel_attrs</literal> ou
    <literal>adjust_appendrel_attrs_multilevel</literal> selon son besoin.
    </para>
   </sect2>

 </sect1>

 <sect1 id="fdw-helpers">
  <title>Fonctions d'aide pour les wrapper de données distantes</title>

  <para>
   Plusieurs fonctions d'aide sont exportées à partir du cœur du serveur, pour
   que les auteurs de wrappers de données distantes puissent accéder facilement
   aux attributs des objets en relation avec les wrappers, comme par exemple les
   options d'un wrapper. Pour utiliser une de ces fonctions, vous avez besoin
   d'inclure le fichier en-tête <filename>foreign/foreign.h</filename> dans
   votre fichier source. Cet en-tête définit aussi les types de structures qui
   sont renvoyés par ces fonctions.
  </para>

  <para>
   <programlisting>
ForeignDataWrapper *
GetForeignDataWrapperExtended(Oid fdwid, bits16 flags);
</programlisting>

     Cette fonction renvoie un objet <structname>ForeignDataWrapper</structname>
     pour le FDW avec l'OID précisé.
     Un objet <structname>ForeignDataWrapper</structname> contient
     les propriétés du FDW (voir <filename>foreign/foreign.h</filename>
     pour les détails).
     <structfield>flags</structfield> est un masque de bit OU indiquant
     des options supplémentaires. Il peut prendre la valeur
     <literal>FDW_MISSING_OK</literal>, auquel cas un <literal>NULL</literal>
     est retourné comme résultat à l'appelant au lieu d'une erreur d'objet
     indéfini.
    </para>

    <para>
<programlisting>
ForeignDataWrapper *
GetForeignDataWrapper(Oid fdwid);
   </programlisting>

   Cette fonction renvoie un objet <structname>ForeignDataWrapper</structname>
   pour le wrapper de données distantes de l'OID spécifié. Un objet
   <structname>ForeignDataWrapper</structname> contient les propriétés du
   wrapper (voir <filename>foreign/foreign.h</filename> pour les détails).
  </para>

  <para>
   <programlisting>
ForeignServer *
GetForeignServerExtended(Oid serverid, bits16 flags);
</programlisting>

     Cette fonction renvoie un objet <structname>ForeignServer</structname>
     pour le FDW avec l'OID précisé.
     Un objet <structname>ForeignServer</structname> contient
     les propriétés du FDW (voir <filename>foreign/foreign.h</filename>
     pour les détails).
     <structfield>flags</structfield> est un masque de bit OU indiquant
     des options supplémentaires. Il peut prendre la valeur
     <literal>FSV_MISSING_OK</literal>, auquel cas un <literal>NULL</literal>
     est retourné comme résultat à l'appelant au lieu d'une erreur d'objet
     indéfini.
    </para>

    <para>
<programlisting>
ForeignServer *
GetForeignServer(Oid serverid);
   </programlisting>

   Cette fonction renvoie un objet <structname>ForeignServer</structname>
   pour le serveur distant de l'OID donné. Un objet
   <structname>ForeignServer</structname> contient les propriétés du serveur
   (voir <filename>foreign/foreign.h</filename> pour les détails).
  </para>

  <para>
   <programlisting>
UserMapping *
GetUserMapping(Oid userid, Oid serverid);
   </programlisting>

   Cette fonction renvoie un objet <structname>UserMapping</structname> pour
   la correspondance utilisateur du rôle donné sur le serveur donné.
   (S'il n'existe pas de correspondance utilisateur, la fonction renvoie
   la correspondance pour <literal>PUBLIC</literal> ou une erreur si cette
   dernière n'existe pas non plus.) Un objet
   <structname>UserMapping</structname> contient les propriétés de la
   correspondance utilisateur (voir <filename>foreign/foreign.h</filename>
   pour les détails).
  </para>

  <para>
   <programlisting>
ForeignTable *
GetForeignTable(Oid relid);
   </programlisting>

   Cette fonction renvoie un objet <structname>ForeignTable</structname> pour
   la table distante de l'OID donné. Un objet
   <structname>ForeignTable</structname> contient les propriétés de la table
   distante (voir <filename>foreign/foreign.h</filename> pour les détails).
  </para>

    <para>
<programlisting>
List *
GetForeignColumnOptions(Oid relid, AttrNumber attnum);
   </programlisting>

   Cette fonction renvoie les opérations du wrapper de données distantes par
   colonne pour l'OID de la table distante donnée et le numéro de l'attribut
   sous la forme d'une liste de <structname>DefElem</structname>. NIL est
   renvoyé sur la colonne n'a pas d'options.
  </para>

  <para>
   Certains types d'objets ont des fonctions de recherche basées sur le nom
   en plus de celles basées sur l'OID&nbsp;:
  </para>

  <para>
   <programlisting>
ForeignDataWrapper *
GetForeignDataWrapperByName(const char *name, bool missing_ok);
   </programlisting>

   Cette fonction renvoie un objet <structname>ForeignDataWrapper</structname>
   pour le wrapper de données distante du nom indiqué. Si le wrapper n'est pas
   trouvé, cette fonction renvoie NULL si missing_ok vaut true, et renvoie
   une erreur sinon.
  </para>

  <para>
   <programlisting>
ForeignServer *
GetForeignServerByName(const char *name, bool missing_ok);
   </programlisting>

   Cette fonction renvoie un objet <structname>ForeignServer</structname> pour
   le serveur distant du nom donné. Si le serveur n'est pas trouvé, cette
   fonction renvoie NULL si missing_ok vaut true, et renvoie une erreur sinon.
  </para>

 </sect1>

 <sect1 id="fdw-planning">
  <title>Planification de la requête avec un wrapper de données distantes</title>

  <para>
   Les fonctions d'appels d'un wrapper de données distantes, <function>GetForeignRelSize</function>,
   <function>GetForeignPaths</function>, <function>GetForeignPlan</function>,
   <function>PlanForeignModify</function>, <function>GetForeignJoinPaths</function>,
   <function>GetForeignUpperPaths</function> et <function>PlanDirectModify</function>
   doivent s'intégrer au fonctionnement du planificateur de
   <productname>PostgreSQL</productname>. Voici quelques notes sur ce qu'elles
   doivent faire.
  </para>

  <para>
   Les informations dans <literal>root</literal> et <literal>baserel</literal>
   peuvent être utilisées pour réduire la quantité d'informations qui doivent
   être récupérées sur la table distante (et donc réduire le coût)
   <literal>baserel-&gt;baserestrictinfo</literal> est tout particulièrement
   intéressant car il contient les qualificatifs de restriction (clauses
   <literal>WHERE</literal>) qui doivent être utilisées pour filtrer les lignes
   à récupérer. (Le wrapper lui-même n'est pas requis de respecter ces clauses
   car l'exécuteur du moteur peut les vérifier à sa place.)
   <literal>baserel-&gt;reltargetlist</literal> peut être utilisé pour
   déterminer les colonnes à récupérer&nbsp;; mais notez qu'il liste seulement
   les colonnes qui doivent être émises par le nœud
   <structname>ForeignScan</structname>, et non pas les colonnes qui sont
   utilisées pour satisfaire l'évaluation des qualificatifs et non renvoyées
   par la requête.
  </para>

  <para>
   Divers champs privés sont disponibles pour que les fonctions de planification
   du wrapper de données distantes conservent les informations. Habituellement,
   tout ce que vous stockez dans les champs privées doit avoir été alloué avec
   la fonction palloc, pour que l'espace soit récupéré à la fin de la
   planification.
  </para>

  <para>
   <literal>baserel-&gt;fdw_private</literal> est un pointeur <type>void</type>
   disponible pour que les fonctions de planification du wrapper y stockent
   des informations correspondant à la table distante spécifique. Le planificateur
   du moteur n'y touche pas sauf lors de son initialisation à NULL quand le
   nœud <literal>RelOptInfo</literal> est créé. Il est utile de passer des
   informations de <function>GetForeignRelSize</function> à
   <function>GetForeignPaths</function> et/ou <function>GetForeignPaths</function>
   à <function>GetForeignPlan</function>, évitant du coup un recalcul.
  </para>

  <para>
   <function>GetForeignPaths</function> peut identifier la signification de
   chemins d'accès différents pour enregistrer des informations privées dans
   le champ <structfield>fdw_private</structfield> des nœuds
   <structname>ForeignPath</structname>. <structfield>fdw_private</structfield>
   est déclaré comme un pointeur <type>List</type> mais peut contenir réellement
   n'importe quoi car le planificateur du moteur n'y touche pas. Néanmoins, une
   bonne pratique est d'utiliser une représentation qui est affichable par
   <function>nodeToString</function>, pour son utilisation avec le support du
   débogage disponible dans le processus.
  </para>

  <para>
   <function>GetForeignPlan</function> peut examiner le champ
   <structfield>fdw_private</structfield> du nœud
   <structname>ForeignPath</structname>, et peut générer les listes
   <structfield>fdw_exprs</structfield> et <structfield>fdw_private</structfield>
   à placer dans le nœud de plan <structname>ForeignScan</structname>, où
   elles seront disponibles au moment de l'exécution. Les deux listes doivent
   être représentées sous une forme que <function>copyObject</function> sait
   copier. La liste <structfield>fdw_private</structfield> n'a pas d'autres
   restrictions et n'est pas interprétée par le processus moteur. La liste
   <structfield>fdw_exprs</structfield>, si non NULL, devrait contenir
   les arbres d'expressions qui devront être exécutées. Ces arbres passeront
   par un post-traitement par le planificateur qui les rend complètement
   exécutables.
  </para>

  <para>
   Dans <function>GetForeignPlan</function>, habituellement, la liste cible
   fournie peut être copiée dans le nœud du plan tel quel. La liste
   <literal>scan_clauses</literal> fournie contient les mêmes clauses que
   <literal>baserel-&gt;baserestrictinfo</literal> mais ces clauses pourraient
   être ré-ordonnées pour une meilleure efficacité à l'exécution. Dans les cas
   simples, le wrapper peut seulement supprimer les nœuds
   <structname>RestrictInfo</structname> de la liste <literal>scan_clauses</literal> (en utilisant
   <function>extract_actual_clauses</function>) et placer toutes les clauses
   dans la liste des qualificatifs du nœud. Cela signifie que toutes les clauses
   seront vérifiées par l'exécuteur au moment de l'exécution. Les wrappers les
   plus complexes peuvent être capables de vérifier certaines clauses en interne,
   auquel cas ces clauses peuvent être supprimées de la liste de qualificatifs
   du nœud du plan pour que le planificateur ne perde pas de temps à les
   vérifier de nouveau.
  </para>

  <para>
   Comme exemple, le wrapper peut identifier certaines clauses de restriction
   de la forme <replaceable>variable_distante</replaceable> <literal>=</literal>
   <replaceable>sous_expression</replaceable>, qui, d'après lui, peut être
   exécuté sir le serveur distant en donnant la valeur évaluée localement de
   la <replaceable>sous_expression</replaceable>. L'identification réelle d'une
   telle clause doit survenir lors de l'exécution de
   <function>GetForeignPaths</function> car cela va affecter l'estimation ddu
   coût pour le chemin. Le champ <structfield>fdw_private</structfield> du
   chemin pourrait probablement inclure un pointeur vers le nœud
   <structname>RestrictInfo</structname> de la clause identifiée. Puis,
   <function>GetForeignPlan</function> pourrait supprimer cette clause de
   scan_clauses et ajouter la <replaceable>sous_expression</replaceable> à
   <structfield>fdw_exprs</structfield> pour s'assurer qu'elle soit convertie
   en une forme exécutable. Il pourrait aussi placer des informations de contrôle
   dans le champ <structfield>fdw_private</structfield> du nœud pour dire aux
   fonctions d'exécution ce qu'il faudra faire au moment de l'exécution. La
   requête transmise au serveur distant va impliquer quelque chose comme
   <literal>WHERE <replaceable>variable_distante</replaceable> =
    $1</literal>, avec la valeur du paramètre obtenu à l'exécution à partir de
   l'évaluation de l'arbre d'expression <structfield>fdw_exprs</structfield>.
  </para>

  <para>
   Toutes les clauses enlevées de la liste des qualificatifs
   du nœud du plan doivent être à la place ajoutées à
   <literal>fdw_recheck_quals</literal> ou verifiées à nouveau par
   <literal>RecheckForeignScan</literal> pour permettre un
   fonctionnement correct au niveau d'isolation <literal>READ
   COMMITED</literal>. Lorsqu'une mise à jour concurrente survient
   pour une autre table concernée par la requête, l'exécuteur peut
   avoir besoin de vérifier que tous les qualificatifs originaux
   sont encore satisfaits pour la ligne, éventuellement avec un
   ensemble différent de valeurs pour les paramètres. L'utilisation
   de <literal>fdw_recheck_quals</literal> est typiquement plus
   facile que de mettre en place les vérifications à l'interieur
   de <literal>RecheckForeignScan</literal>, mais cette méthode sera
   insuffisante lorsque des jointures externes ont été poussées, dans
   la mesure où les lignes jointes dans ce cas peuvent avoir certaines
   colonnes à NULL sans rejeter la ligne entièrement.
    </para>

    <para>
     Un autre champ <structname>ForeignScan</structname> qui peut être
     rempli par les FDW est <structfield>fdw_scan_tlist</structfield>,
     qui décrit les lignes renvoyées par le FDW pour ce nœud du
     plan. Pour les parcours simples de tables distantes, il peut être
     positionné à <literal>NIL</literal>, impliquant que les lignes
     renvoyées ont le type de ligne déclaré pour la table distante. Une
     valeur différente de <symbol>NIL</symbol> doit être une liste cible (liste
     de <structname>TargetEntry</structname>) contenant des variables
     et/ou expressions représentant les colonnes renvoyées. Ceci peut
     être utilisé, par exemple, pour montrer que le FDW a omis certaines
     colonnes qu'il a noté comme non nécessaire à la requête. Aussi,
     si le FDW peut calculer des expressions utilisées par la requête
     de manière moins coûteuse que localement, il pourrait ajouter ces
     expressions à <structfield>fdw_scan_tlist</structfield>. Notez que
     les plans de jointure (créés à partir des chemins construits par
     <function>GetForeignJoinPaths</function>) doivent toujours fournir
     <structfield>fdw_scand_tlist</structfield> pour décrire l'ensemble
     des colonnes qu'ils retourneront.
    </para>

    <para>
   Le wrapper de données distantes devrait toujours construire au moins un
   chemin qui dépend seulement des clauses de restriction de la table. Dans
   les requêtes de jointure, il pourrait aussi choisir de construire des
   chemins qui dépendent des clauses de jointures. Par exemple,
   <replaceable>variable_distante</replaceable> <literal>=</literal>
   <replaceable>variable_local</replaceable>. De telles clauses ne se trouveront
   pas dans <literal>baserel-&gt;baserestrictinfo</literal> mais doivent être
   dans les listes de jointures des relations. Un chemin utilisant une telle
   clause est appelé un <quote>parameterized path</quote>. Il doit identifier
   les autres relations utilisées dans le(s) clause(s) de jointure
   sélectionnée(s) avec une valeur convenable pour
   <literal>param_info</literal>&nbsp;; utilisez
   <function>get_baserel_parampathinfo</function> pour calculer cette valeur.
   Dans <function>GetForeignPlan</function>, la portion
   <replaceable>local_variable</replaceable> de la clause de jointure pourra être
   ajoutée à <structfield>fdw_exprs</structfield>, et ensuite à l'exécution, cela
   fonctionne de la même façon que pour une clause de restriction standard.
  </para>

  <para>
   Si un FDW supporte les jointures distantes,
   <function>GetForeignJoinPaths</function> devrait produire
   <structname>ForeignPath</structname> pour les jointures
   distantes potentielles essentiellement de la même manière que
   <function>GetForeignPaths</function> le fait pour les tables
   de base. L'information à propos de la jointure envisagée
   peut être passée à <function>GetForeignPlan</function>
   de la même manière que décrit ci-dessus. Cependant,
   <structfield>baserestrictinfo</structfield> n'est pas applicable
   pour les tables d'une jointure&nbsp;; à la place, les clauses de jointure
   applicables pour une jointure particulière sont passées à
   <function>GetForeignJoinPaths</function> comme un paramètre séparé
   (<literal>extra-&gt;restrictlist</literal>).
    </para>

    <para>
     Un FDW pourrait supporter en plus l'exécution direct de certaines actions
     d'un plan, qui sont au-dessus du niveau d'un parcours ou d'une jointure,
     comme par exemple un regroupement ou un agrégat. Pour proposer ce genre
     d'options, le FDW doit générer des chemins et les insérer dans la
     <firstterm>relation de niveau supérieur</firstterm> appropriée. Par
     exemple, un chemin représentant un agrégat distant doit être inséré dans
     la relation <literal>UPPERREL_GROUP_AGG</literal>, en utilisant
     <function>add_path</function>. Ce chemin sera comparé suivant son coût et
     celui d'un agrégat local réalisé en lisant un chamin de parcours simple
     de la relation externe (notez qu'un tel chemin doit aussi être fourni...
     dans le cas contraire, une erreur est renvoyée lors de l'optimisation).
     Si le chemin de l'agrégat distant gagne (ce qui sera généralement le
     cas), il sera converti en un plan standard en appelant
     <function>GetForeignPlan</function>. L'endroit recommendé pour générer de
     tels chemins est dans la fonction callback
     <function>GetForeignUpperPaths</function>, qui est appelée pour chaque
     relation supérieure (autrement dit, chaque étape de traitement
     post-parcours/jointure) si toutes les relations de base de la requête
     viennent du même FDW.
    </para>

    <para>
     <function>PlanForeignModify</function> et les autres callbacks décrits
     dans <xref linkend="fdw-callbacks-update"/> sont conçus autour de la
     supposition que la relation externe sera parcourue de la façon standard
     et qu'ensuite, les mises à jour individuelles de lignes seront réalisées
     par un nœud local <literal>ModifyTable</literal>. Cette approche est
     nécessaire dans le cas général où une mise à jour nécessite de lire des
     tables locales ainsi que des tables externes. Néanmoins, si l'opération
     pouvoit être exécutée entièrement par le serveur distant, le FDW pourrait
     générer un plan représentant cela et l'insérer dans la relation de niveau
     supérieur <literal>UPPERREL_FINAL</literal>, où il serait comparé avec
     l'approche <literal>ModifyTable</literal>. Cette approche pourrait être
     utilisé pour implémenter un <literal>SELECT FOR UPDATE</literal> distant,
     plutôt que d'utiliser les callbacks de verrouillage de ligne décrits dans
     <xref linkend="fdw-callbacks-row-locking"/>. Gardez à l'exprit qu'un
     chemin inséré dans <literal>UPPERREL_FINAL</literal> est responsable de
     l'implémentation de <emphasis>tout</emphasis> le comportement de cette
     requête.
    </para>

    <para>
   Lors de la planification d'un <command>UPDATE</command> ou d'un
   <command>DELETE</command>, <function>PlanForeignModify</function>
   et <function>PlanDirectModify</function> peuvent
   rechercher la structure <structname>RelOptInfo</structname> pour la table
   distante et utiliser la donnée
   <literal>baserel-&gt;fdw_private</literal> créée précédemment par les
   fonctions de planification de parcours. Néanmoins, pour un
   <command>INSERT</command>, la table cible n'est pas parcourue, donc il
   n'existe aucun <structname>RelOptInfo</structname> pour elle.
   La structure <structname>List</structname> renvoyée par
   <function>PlanForeignModify</function> a les mêmes restrictions que la liste
   <structfield>fdw_private</structfield> d'un n&oelig;ud de plan
   <structname>ForeignScan</structname>, c'est-à-dire qu'elle doit contenir
   seulement les structures que <function>copyObject</function> sait copier.
  </para>

  <para>
      Une commande <command>INSERT</command> avec une clause <literal>ON
      CONFLICT</literal> ne supporte pas la spécification d'une
      cible de conflit, dans la mesure où les contraintes uniques
      ou les contraintes d'exclusion sur les tables distantes ne
      sont pas localement connues. Ceci entraîne également que
      <literal>ON CONFLICT DO UPDATE</literal> n'est pas supporté
      car la spécification est obligatoire ici.
    </para>

   </sect1>

   <sect1 id="fdw-row-locking">
    <title>Le verrouillage de ligne dans les wrappers de données distantes</title>

    <para>
     Si le mécanisme de stockage sous-jacent à un FDW a un concept
     de verrouillage individuel des lignes pour prévenir des mises
     à jour concurrentes de ces lignes, il est généralement
     intéressant pour le FDW d'effectuer des verrouillages de
     niveau ligne avec une approximation aussi proche que possible
     de la sémantique utilisée pour les tables ordinaires de
     <productname>PostgreSQL</productname>. Ceci implique de multiples
     considérations.
    </para>

    <para>
     Une décision clef à prendre est si il vaut mieux
     effectuer un <firstterm>verrouillage précoce</firstterm> ou un
     <firstterm>verrouillage tardif</firstterm>. Dans le verrouillage
     précoce, une ligne est verrouillée lorsqu'elle est récupérée
     pour la première fois à partir du stockage sous-jacent, alors
     qu'avec le verrouillage tardif, la ligne est verrouillée seulement
     lorsque le besoin est connu et nécessaire. (La différence
     survient parce que certaines lignes peuvent être abandonnées
     par des restrictions vérifiées localement ou des conditions de
     jointure.) Le verrouillage précoce est beaucoup plus simple et
     évite des allers-retours supplémentaires vers le stockage distant,
     mais il peut entraîner des verrouillages de lignes qui n'auraient pas
     eu besoin de l'être, résultant en une réduction de la concurrence
     voire même des deadlocks inattendus. De plus, le verrouillage tardif
     n'est possible seulement que si la ligne à verrouiller peut être
     identifiée de manière unique à nouveau plus tard. Idéalement,
     l'identifiant de ligne devrait identifier une version spécifique
     de la ligne, comme les TID de <productname>PostgreSQL</productname>
     le font.
    </para>

    <para>
     Par défaut, <productname>PostgreSQL</productname>
     ignore les considérations de verrouillage lorsqu'il
     s'interface avec les FDW, mais un FDW peut effectuer un
     verrouillage précoce sans un support explicite du code du
     serveur principal. Les fonctions de l'API décrites dans le <xref
     linkend="fdw-callbacks-row-locking"/>, qui ont été ajoutées dans
     la version 9.5 de <productname>PostgreSQL</productname>, autorise
     un FDW à utiliser un verrouillage tardif si il le désire.
    </para>

    <para>
     Une considération supplémentaire est que dans le
     niveau d'isolation <literal>READ COMMITTED</literal>,
     <productname>PostgreSQL</productname> peut avoir besoin de vérifier
     à nouveau les restrictions et conditions de jointures avec une
     version mise à jour de certaines lignes. Vérifier à nouveau
     des conditions de jointure requiert d'obtenir à nouveau des
     copies des lignes non ciblées qui étaient auparavant jointes
     à la ligne cible. En travaillant avec des tables standards
     <productname>PostgreSQL</productname>, ceci est effectué en
     incluant les TID des tables non ciblées dans la liste des colonnes
     projetées via la jointure, puis en récupérant à nouveau les
     lignes non ciblées si nécessaire. Cette approche maintient
     l'ensemble des données jointes compact, mais il demande une
     capacité peu coûteuse de récupération à nouveau, ainsi qu'un TID
     qui peut identifier de manière unique la version de la ligne à
     récupérer à nouveau. Par défaut, donc, l'approche utilisée
     avec les tables distantes est d'inclure une copie de la ligne
     entière récupérée dans la liste de colonnes projetée via
     la jointure. Ceci n'impose rien au FDW mais peut entraîner des
     performances réduites des jointures par fusion ou hachage. Un FDW qui
     remplit les conditions pour récupérer à nouveau peut choisir de
     le faire.
    </para>

    <para>
     Pour une commande <command>UPDATE</command> ou
     <command>DELETE</command> sur une table distante, il est recommandé
     que l'opération de <literal>ForeignScan</literal> sur la table cible
     effectue un verrouillage précoce sur les lignes qu'elle récupère,
     peut-être via un équivalent de la commande <command>SELECT FOR
     UPDATE</command>. Un FDW peut détecter si une table est la cible
     d'une commande <command>UPDATE</command>/<command>DELETE</command>
     lors de la planification en comparant son relid à
     <literal>root-&gt;parse-&gt;resultRelation</literal>,
     ou lors de l'exécution en utilisant la fonction
     <function>ExecRelationIsTargetRelation()</function>. Une possibilité
     alternative est d'effectuer un verrouillage tardif à l'intérieur
     des fonctions callback <function>ExecForeignUpdate</function> ou
     <function>ExecForeignDelete</function>, mais aucun support spécial
     n'est fourni pour cela.
    </para>

    <para>
     Pour les tables distantes qui sont verrouillées par une
     commande <command>SELECT FOR UPDATE/SHARE</command>, l'opération
     <literal>ForeignScan</literal> peut encore effectuer un verrouillage
     précoce en récupérant des lignes avec l'équivalent de la commande
     <command>SELECT FOR UPDATE/SHARE</command>. Pour effectuer à la
     place un verrouillage tardif, fournissez les fonctions callback
     définies à <xref linkend="fdw-callbacks-row-locking"/>. Dans
     <function>GetForeignRowMarkType</function>, sélectionner
     l'option rowmark <literal>ROW_MARK_EXCLUSIVE</literal>,
     <literal>ROW_MARK_NOKEYEXCLUSIVE</literal>,
     <literal>ROW_MARK_SHARE</literal> ou
     <literal>ROW_MARK_KEYSHARE</literal> en fonction de la force
     du verrouillage demandé. (Le code du serveur principal agira
     de la même manière indépendamment de l'option choisie parmi
     ces quatres options.) Ailleurs, vous pouvez détecter si une
     table distante a été verrouillée par ce type de commandes en
     utilisant la fonction <function>get_plan_rowmark</function> lors de
     la planification ou la fonction <function>ExecFindRowMark</function>
     lors de l'exécution&nbsp;; vous devez vérifier non seulement si une
     structure rowmark non nulle est renvoyée, mais également que
     son champ <structfield>strength</structfield> n'est pas égal à
     <literal>LCS_NONE</literal>.
    </para>

    <para>
     Enfin, pour les tables distantes qui sont utilisées dans une
     commande <command>UPDATE</command>, <command>DELETE</command>
     ou <command>SELECT FOR UPDATE/SHARE</command> sans demande
     de verrouillage de ligne, vous pouvez passer outre le choix
     par défaut de copier les lignes entières dans la fonction
     <function>GetForeignRowMarkType</function> en sélectionnant l'option
     <literal>ROW_MARK_REFERENCE</literal> lorsqu'elle voit comme valeur
     de puissance de verrouillage <literal>LCS_NONE</literal>. Ceci aura
     pour conséquence d'appeler <function>RefetchForeignRow</function>
     avec cette valeur pour le champ <structfield>markType</structfield>&nbsp;;
     elle devrait alors récupérer à nouveau la ligne sans
     prendre aucun nouveau verrouillage. (Si vous avez une fonction
     <function>GetForeignRowMarkType</function> mais ne souhaitez
     pas récupérer à nouveau des lignes non verrouillées,
     sélectionnez l'option <literal>ROW_MARK_COPY</literal> pour
     <literal>LCS_NONE</literal>.)
    </para>

    <para>
     Voir les commentaires dans
     <filename>src/include/nodes/lockoptions.h</filename>,
     pour <type>RowMarkType</type> et dans
     <filename>src/include/nodes/plannodes.h</filename>
     pour <type>PlanRowMark</type>, et les
     commentaires pour <type>ExecRowMark</type> dans
     <filename>src/include/nodes/execnodes.h</filename> pour des
     informations complémentaires.
  </para>
 </sect1>
</chapter>
