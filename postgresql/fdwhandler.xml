<?xml version="1.0" encoding="UTF-8"?>
 <chapter id="fdwhandler">
   <title>Écrire un wrapper de données distantes</title>

   <indexterm zone="fdwhandler">
    <primary>wrapper de données distantes</primary>
    <secondary>gestionnaire</secondary>
   </indexterm>

   <para>
    Toutes les opérations sur une table distante sont gérées via un
    wrapper de données distantes. Ce dernier est un ensemble de fonctions
    que PostgreSQL appelle. Le wrapper de données
    distantes est responsable de la récupération des données à partir de
    le source de données distante et de leur renvoi à l'exécuteur
    <productname>PostgreSQL</productname>. If updating foreign
    tables is to be supported, the wrapper must handle that, too.
    Ce chapitre indique comment
    écrire un nouveau wrapper de données distantes.
   </para>

   <para>
    Les wrappers de données distantes incluent dans la distribution
    standard sont de bons exemples lorsque vous essayez d'écrire les
    votres. Regardez dans le sous-répertoire
    <filename>contrib</filename> du répertoire des sources. La
    page de référence <xref linkend="sql-createforeigndatawrapper"/>
    contient aussi des détails utiles.
   </para>

   <note>
    <para>
     Le standard SQL spécifie une interface pour l'écriture des wrappers
     de données distantes. Néanmoins, PostgreSQL n'implémente pas cette
     API car l'effort nécessaire pour cela serait trop important. De
     toute façon, l'API standard n'est pas encore très adoptée.
    </para>
   </note>

   <sect1 id="fdw-functions">
    <title>Fonctions d'un wrapper de données distantes</title>

   <para>
    Le développeur d'un FDW doit écrire une fonction de gestion (handler)
    et, en option, une fonction de validation. Les deux fonctions doivent
    être écrites dans un langage compilé comme le C en utilisant
    l'interface version-1. Pour les détails sur les conventions d'appel
    et le chargement dynamique en langage C, voir <xref linkend="xfunc-c"/>.
   </para>

   <para>
    La fonction de gestion renvoie simplement une structure de pointeurs
    de fonctions callback qui seront appelées par le planificateur,
    l'exécuteur et différentes commandes de maintenance. La plupart du
    travail dans l'écriture d'une FDW se
    trouve dans l'implémentation de ces fonctions callback. La fonction
    de gestion doit être enregistrée dans
    <productname>PostgreSQL</productname> comme ne prenant aucun argument
    et renvoyant le pseudo-type <type>fdw_handler</type>. Les fonctions
    callback sont des fonctions en C et ne sont pas visibles ou
    appelables avec du SQL. Les fonctions callback sont décrites dans
    <xref linkend="fdw-callbacks"/>.
   </para>

   <para>
	 La fonction de validation est responsable de la validation des options
	 données dans les commandes <command>CREATE</command> et
	 <command>ALTER</command> pour son wrapper de données distantes,
	 ainsi que pour les serveurs distants, les correspondances
	 d'utilisateurs et les tables distants utilisant le wrapper. La
	 fonction de validation doit être enregistrée comme prenant deux
	 arguments&nbsp;: un tableau de texte contenant les options à
	 valider et un OID représentant le type d'objet avec lequel les
	 options sont validées (sous la forme d'un OID du catalogue système
	 où sera stocké l'objet, donc
     <literal>ForeignDataWrapperRelationId</literal>,
     <literal>ForeignServerRelationId</literal>,
     <literal>UserMappingRelationId</literal> ou
     <literal>ForeignTableRelationId</literal>).
     Si aucune fonction de validation n'est fournie, les options ne sont
     pas vérifiées au moment de la création ou de la modification de
     l'objet.
   </para>

   </sect1>

   <sect1 id="fdw-callbacks">
    <title>Routines callback des wrappers de données distantes</title>

    <para>
     La fonction de gestion d'une FDW renvoie une structure
     <structname>FdwRoutine</structname> allouée avec palloc. Elle
     contient des pointeurs vers les fonctions de callback décrites
     ci-dessous
     The scan-related functions are required, the rest are optional.
    </para>

    <para>
     The <structname>FdwRoutine</structname> struct type is declared in
     <filename>src/include/foreign/fdwapi.h</filename>, which see for additional
     details.
    </para>

   <sect2 id="fdw-callbacks-scan">
    <title>FDW Routines For Scanning Foreign Tables</title>

    <para>
<programlisting>
void
GetForeignRelSize (PlannerInfo *root,
                   RelOptInfo *baserel,
                   Oid foreigntableid);
</programlisting>

     Obtient des estimations de la taille de la relation pour une table distante.
     Elle est appelée au début de la planification d'une requête parcourant une
     table distante. <literal>root</literal> est l'information globale du
     planificateur sur la requête&nbsp;; <literal>baserel</literal> est
     l'information du planificateur sur la table&nbsp;; et
     <literal>foreigntableid</literal> est l'OID provenant de
     <structname>pg_class</structname> pour cette table distante.
     (<literal>foreigntableid</literal> pourrait être obtenu à partir de la
     structure de données du planificateur mais il est directement fourni pour
     ne pas avoir à faire cet effort.)
     </para>
 
     <para>
     Cette fonction doit mettre à jour <literal>baserel-&gt;rows</literal> pour
     que cela corresponde au nombre de lignes renvoyées par un parcours de table
     après avoir pris en compte le filtre réalisé par les clauses de restriction.
     La valeur initiale de <literal>baserel-&gt;rows</literal> est une estimation
     par défaut, qui doit être remplacée si possible. La fonction pourrait aussi
     choisir de mettre à jour <literal>baserel-&gt;width</literal> si elle
     peut calculer une meilleure estimation de la largeur moyenne d'une ligne du
     résultat.
    </para>

    <para>
     Voir <xref linkend="fdw-planning"/> pour plus d'informations.
    </para>

    <para>
<programlisting>
void
GetForeignPaths (PlannerInfo *root,
                 RelOptInfo *baserel,
                 Oid foreigntableid);
</programlisting>

     Crée les chemins d'accès possibles pour un parcours sur une table distante.
     Cette fonction est appelée lors de la planification de la requête. Les
     paramètres sont identiques à ceux de <function>GetForeignRelSize</function>,
     qui a déjà été appelée.
    </para>

    <para>
     Cette fonction doit générer au moins un chemin d'accès (nœud
     <structname>ForeignPath</structname>) pour un parcours sur une table
     distante et doit appeler <function>add_path</function> pour ajouter chaque
     chemin à <literal>baserel-&gt;pathlist</literal>. Il est recommandé
     d'utiliser <function>create_foreignscan_path</function> pour construire les
     nœuds <structname>ForeignPath</structname>. La fonction peut générer plusieurs
     chemins d'accès, c'est-à-dire un chemin qui a un champ
     <literal>pathkeys</literal> valide pour représenter un résultat pré-trié.
     Chaque chemin d'accès doit contenir les estimations de coûts et peut contenir
     toute information privée au FDW qui est nécessaire pour identifier la méthode
     attendue du parcours spécifique.
    </para>

    <para>
     Voir <xref linkend="fdw-planning"/> pour plus d'informations.
    </para>

    <para>
<programlisting>
ForeignScan *
GetForeignPlan (PlannerInfo *root,
                RelOptInfo *baserel,
                Oid foreigntableid,
                ForeignPath *best_path,
                List *tlist,
                List *scan_clauses);
</programlisting>

     Crée un nœud de plan <structname>ForeignScan</structname> à partir du chemin
     d'accès distant sélectionné. Cette fonction est appelé à la fin de la
     planification de la requête.
     Les paramètres sont identiques à ceux de la fonction
     <function>GetForeignRelSize</function>, avec en plus le
     <structname>ForeignPath</structname> sélectionné (précédemment produit par
     <function>GetForeignPaths</function>), la liste cible à émettre par le
     nœud du plan, et les clauses de restriction forcées par le nœud du plan.
    </para>

    <para>
     Cette fonction doit créer et renvoyer un nœud <structname>ForeignScan</structname>.
     Il est recommandé d'utiliser <function>make_foreignscan</function> pour
     construire le nœud <structname>ForeignScan</structname>.
     </para>
 
     <para>
     Voir <xref linkend="fdw-planning"/> pour plus d'informations.
    </para>

    <para>
<programlisting>
void
BeginForeignScan (ForeignScanState *node,
                  int eflags);
</programlisting>

     Commence l'exécution d'un parcours distant. L'appel se fait lors du
     démarrage de l'exécuteur. Cette fonction doit réaliser toutes les
     initialisation nécessaires avant le démarrage du parcours, mais ne
     doit pas commencer à exécuter le vrai parcours (cela se fera lors
     du premier appel à <function>IterateForeignScan</function>). Le
     n&oelig;ud <structname>ForeignScanState</structname> est déjà créé
     mais son champ <structfield>fdw_state</structfield> vaut toujours
     NULL. Les informations sur la table à parcourir sont accessibles
     via le n&oelig;ud <structname>ForeignScanState</structname> (en
     particulier à partir du n&oelig;ud sous-jacent
     <structname>ForeignScan</structname> qui contient toute information
     privée au FDW fournie par <function>GetForeignPlan</function>).
     <literal>eflags</literal> contains flag bits describing the executor's
     operating mode for this plan node.
    </para>

    <para>
     Notez que quand <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal>
     est vraie, cette fonction ne doit pas réaliser d'actions visibles
     en externe. Elle doit seulement faire le minimum requis pour que
     l'état du n&oelig;ud soit valide pour
     <function>ExplainForeignScan</function> et
     <function>EndForeignScan</function>.
    </para>

    <para>
<programlisting>
TupleTableSlot *
IterateForeignScan (ForeignScanState *node);
</programlisting>

     Récupère une ligne de la source distante, la renvoyant dans un
     emplacement de ligne de table (le champ
     <structfield>ScanTupleSlot</structfield> du n&oelig;ud doit être
     utilisé dans ce but). Renvoie NULL s'il n'y a plus de lignes
     disponibles. L'infrastructure d'emplacement de ligne de table permet
     qu'une ligne physique ou virtuelle soit renvoyée. Dans la plupart
     des cas, la deuxième possibilité (virtuelle), est préférable d'un
     point de vue des performances. Notez que cette fonction est appelée
     dans un contexte mémoire dont la durée de vie est très courte et
     qui sera réinitialisé entre chaque appel. Créez un contexte mémoire
     dans <function>BeginForeignScan</function> si vous avez besoin d'un
     stockage qui tient plus longtemps ou utilisez le champ
     <structfield>es_query_cxt</structfield> de <structname>EState</structname>.
    </para>

    <para>
     Les lignes renvoyées doivent correspondre à la signature de la
     colonne de la table distante parcourue. Si vous préférez optimiser
     la récupération des colonnes inutiles, vous devez insérer des NULL
     dans les positions de ces colonnes
    </para>

    <para>
     Notez que l'exécuteur de <productname>PostgreSQL</productname> ne
     se préoccupe pas de savoir si les lignes renvoyées violent les
     contraintes <literal>NOT NULL</literal> définies sur les colonnes
     de la table distante. Le planificateur s'en préoccupe et pourrait
     mal optimiser les requêtes si des valeurs <literal>NULL</literal>
     sont présentes dans une colonne déclarée ne pas en contenir. Si une
     valeur <literal>NULL</literal> est découverte alors que l'utilisateur
     a déclaré qu'aucune valeur NULL ne devrait être présente, il pourrait
     être approprié de lever une erreur (exactement comme vous le feriez
     en cas d'un type de données inapproprié).
    </para>

    <para>
<programlisting>
void
ReScanForeignScan (ForeignScanState *node);
</programlisting>

     Recommence le parcours depuis le début. Notez que les paramètres
     dont dépent le parcours peuvent avoir changés de valeur, donc le
     nouveau parcours ne va pas forcément renvoyer les mêmes lignes.
    </para>

    <para>
<programlisting>
void
EndForeignScan (ForeignScanState *node);
</programlisting>

     Termine le parcours et relâche les ressources. Il n'est habituellement
     pas nécessaire de relâcher la mémoire allouée via palloc. Par contre,
     les fichiers ouverts et les connexions aux serveurs distants doivent
     être nettoyés.
    </para>

   </sect2>

   <sect2 id="fdw-callbacks-update">
    <title>FDW Routines For Updating Foreign Tables</title>

    <para>
     If an FDW supports writable foreign tables, it should provide
     some or all of the following callback functions depending on
     the needs and capabilities of the FDW:
    </para>

    <para>
<programlisting>
void
AddForeignUpdateTargets (Query *parsetree,
                         RangeTblEntry *target_rte,
                         Relation target_relation);
</programlisting>

     <command>UPDATE</command> and <command>DELETE</command> operations are performed
     against rows previously fetched by the table-scanning functions.  The
     FDW may need extra information, such as a row ID or the values of
     primary-key columns, to ensure that it can identify the exact row to
     update or delete.  To support that, this function can add extra hidden,
     or <quote>junk</quote>, target columns to the list of columns that are to be
     retrieved from the foreign table during an <command>UPDATE</command> or
     <command>DELETE</command>.
    </para>

    <para>
     To do that, add <structname>TargetEntry</structname> items to
     <literal>parsetree-&gt;targetList</literal>, containing expressions for the
     extra values to be fetched.  Each such entry must be marked
     <structfield>resjunk</structfield> = <literal>true</literal>, and must have a distinct
     <structfield>resname</structfield> that will identify it at execution time.
     Avoid using names matching <literal>ctid<replaceable>N</replaceable></literal> or
     <literal>wholerow<replaceable>N</replaceable></literal>, as the core system can
     generate junk columns of these names.
    </para>

    <para>
     This function is called in the rewriter, not the planner, so the
     information available is a bit different from that available to the
     planning routines.
     <literal>parsetree</literal> is the parse tree for the <command>UPDATE</command> or
     <command>DELETE</command> command, while <literal>target_rte</literal> and
     <literal>target_relation</literal> describe the target foreign table.
    </para>

    <para>
     If the <function>AddForeignUpdateTargets</function> pointer is set to
     <literal>NULL</literal>, no extra target expressions are added.
     (This will make it impossible to implement <command>DELETE</command>
     operations, though <command>UPDATE</command> may still be feasible if the FDW
     relies on an unchanging primary key to identify rows.)
    </para>

    <para>
<programlisting>
List *
PlanForeignModify (PlannerInfo *root,
                   ModifyTable *plan,
                   Index resultRelation,
                   int subplan_index);
</programlisting>

     Perform any additional planning actions needed for an insert, update, or
     delete on a foreign table.  This function generates the FDW-private
     information that will be attached to the <structname>ModifyTable</structname> plan
     node that performs the update action.  This private information must
     have the form of a <literal>List</literal>, and will be delivered to
     <function>BeginForeignModify</function> during the execution stage.
    </para>

    <para>
     <literal>root</literal> is the planner's global information about the query.
     <literal>plan</literal> is the <structname>ModifyTable</structname> plan node, which is
     complete except for the <structfield>fdwPrivLists</structfield> field.
     <literal>resultRelation</literal> identifies the target foreign table by its
     rangetable index.  <literal>subplan_index</literal> identifies which target of
     the <structname>ModifyTable</structname> plan node this is, counting from zero;
     use this if you want to index into <literal>plan-&gt;plans</literal> or other
     substructure of the <literal>plan</literal> node.
    </para>

    <para>
     See <xref linkend="fdw-planning"/> for additional information.
    </para>

    <para>
     If the <function>PlanForeignModify</function> pointer is set to
     <literal>NULL</literal>, no additional plan-time actions are taken, and the
     <literal>fdw_private</literal> list delivered to
     <function>BeginForeignModify</function> will be NIL.
    </para>

    <para>
<programlisting>
void
BeginForeignModify (ModifyTableState *mtstate,
                    ResultRelInfo *rinfo,
                    List *fdw_private,
                    int subplan_index,
                    int eflags);
</programlisting>

     Begin executing a foreign table modification operation.  This routine is
     called during executor startup.  It should perform any initialization
     needed prior to the actual table modifications.  Subsequently,
     <function>ExecForeignInsert</function>, <function>ExecForeignUpdate</function> or
     <function>ExecForeignDelete</function> will be called for each tuple to be
     inserted, updated, or deleted.
    </para>

    <para>
     <literal>mtstate</literal> is the overall state of the
     <structname>ModifyTable</structname> plan node being executed; global data about
     the plan and execution state is available via this structure.
     <literal>rinfo</literal> is the <structname>ResultRelInfo</structname> struct describing
     the target foreign table.  (The <structfield>ri_FdwState</structfield> field of
     <structname>ResultRelInfo</structname> is available for the FDW to store any
     private state it needs for this operation.)
     <literal>fdw_private</literal> contains the private data generated by
     <function>PlanForeignModify</function>, if any.
     <literal>subplan_index</literal> identifies which target of
     the <structname>ModifyTable</structname> plan node this is.
     <literal>eflags</literal> contains flag bits describing the executor's
     operating mode for this plan node.
    </para>

    <para>
     Note that when <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal> is
     true, this function should not perform any externally-visible actions;
     it should only do the minimum required to make the node state valid
     for <function>ExplainForeignModify</function> and <function>EndForeignModify</function>.
    </para>

    <para>
     If the <function>BeginForeignModify</function> pointer is set to
     <literal>NULL</literal>, no action is taken during executor startup.
    </para>

    <para>
<programlisting>
TupleTableSlot *
ExecForeignInsert (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);
</programlisting>

     Insert one tuple into the foreign table.
     <literal>estate</literal> is global execution state for the query.
     <literal>rinfo</literal> is the <structname>ResultRelInfo</structname> struct describing
     the target foreign table.
     <literal>slot</literal> contains the tuple to be inserted; it will match the
     rowtype definition of the foreign table.
     <literal>planSlot</literal> contains the tuple that was generated by the
     <structname>ModifyTable</structname> plan node's subplan; it differs from
     <literal>slot</literal> in possibly containing additional <quote>junk</quote>
     columns.  (The <literal>planSlot</literal> is typically of little interest
     for <command>INSERT</command> cases, but is provided for completeness.)
    </para>

    <para>
     The return value is either a slot containing the data that was actually
     inserted (this might differ from the data supplied, for example as a
     result of trigger actions), or NULL if no row was actually inserted
     (again, typically as a result of triggers).  The passed-in
     <literal>slot</literal> can be re-used for this purpose.
    </para>

    <para>
     The data in the returned slot is used only if the <command>INSERT</command>
     query has a <literal>RETURNING</literal> clause.  Hence, the FDW could choose
     to optimize away returning some or all columns depending on the contents
     of the <literal>RETURNING</literal> clause.  However, some slot must be
     returned to indicate success, or the query's reported rowcount will be
     wrong.
    </para>

    <para>
     If the <function>ExecForeignInsert</function> pointer is set to
     <literal>NULL</literal>, attempts to insert into the foreign table will fail
     with an error message.
    </para>

    <para>
<programlisting>
TupleTableSlot *
ExecForeignUpdate (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);
</programlisting>

     Update one tuple in the foreign table.
     <literal>estate</literal> is global execution state for the query.
     <literal>rinfo</literal> is the <structname>ResultRelInfo</structname> struct describing
     the target foreign table.
     <literal>slot</literal> contains the new data for the tuple; it will match the
     rowtype definition of the foreign table.
     <literal>planSlot</literal> contains the tuple that was generated by the
     <structname>ModifyTable</structname> plan node's subplan; it differs from
     <literal>slot</literal> in possibly containing additional <quote>junk</quote>
     columns.  In particular, any junk columns that were requested by
     <function>AddForeignUpdateTargets</function> will be available from this slot.
    </para>

    <para>
     The return value is either a slot containing the row as it was actually
     updated (this might differ from the data supplied, for example as a
     result of trigger actions), or NULL if no row was actually updated
     (again, typically as a result of triggers).  The passed-in
     <literal>slot</literal> can be re-used for this purpose.
    </para>

    <para>
     The data in the returned slot is used only if the <command>UPDATE</command>
     query has a <literal>RETURNING</literal> clause.  Hence, the FDW could choose
     to optimize away returning some or all columns depending on the contents
     of the <literal>RETURNING</literal> clause.  However, some slot must be
     returned to indicate success, or the query's reported rowcount will be
     wrong.
    </para>

    <para>
     If the <function>ExecForeignUpdate</function> pointer is set to
     <literal>NULL</literal>, attempts to update the foreign table will fail
     with an error message.
    </para>

    <para>
<programlisting>
TupleTableSlot *
ExecForeignDelete (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);
</programlisting>

     Delete one tuple from the foreign table.
     <literal>estate</literal> is global execution state for the query.
     <literal>rinfo</literal> is the <structname>ResultRelInfo</structname> struct describing
     the target foreign table.
     <literal>slot</literal> contains nothing useful upon call, but can be used to
     hold the returned tuple.
     <literal>planSlot</literal> contains the tuple that was generated by the
     <structname>ModifyTable</structname> plan node's subplan; in particular, it will
     carry any junk columns that were requested by
     <function>AddForeignUpdateTargets</function>.  The junk column(s) must be used
     to identify the tuple to be deleted.
    </para>

    <para>
     The return value is either a slot containing the row that was deleted,
     or NULL if no row was deleted (typically as a result of triggers).  The
     passed-in <literal>slot</literal> can be used to hold the tuple to be returned.
    </para>

    <para>
     The data in the returned slot is used only if the <command>DELETE</command>
     query has a <literal>RETURNING</literal> clause.  Hence, the FDW could choose
     to optimize away returning some or all columns depending on the contents
     of the <literal>RETURNING</literal> clause.  However, some slot must be
     returned to indicate success, or the query's reported rowcount will be
     wrong.
    </para>

    <para>
     If the <function>ExecForeignDelete</function> pointer is set to
     <literal>NULL</literal>, attempts to delete from the foreign table will fail
     with an error message.
    </para>

    <para>
<programlisting>
void
EndForeignModify (EState *estate,
                  ResultRelInfo *rinfo);
</programlisting>

     End the table update and release resources.  It is normally not important
     to release palloc'd memory, but for example open files and connections
     to remote servers should be cleaned up.
    </para>

    <para>
     If the <function>EndForeignModify</function> pointer is set to
     <literal>NULL</literal>, no action is taken during executor shutdown.
    </para>

   </sect2>

   <sect2 id="fdw-callbacks-explain">
    <title>FDW Routines for <command>EXPLAIN</command></title>

    <para>
<programlisting>
void
ExplainForeignScan (ForeignScanState *node,
                    ExplainState *es);
</programlisting>

     Print additional <command>EXPLAIN</command> output for a foreign table scan.
     This function can call <function>ExplainPropertyText</function> and
     related functions to add fields to the <command>EXPLAIN</command> output.
     The flag fields in <literal>es</literal> can be used to determine what to
     print, and the state of the <structname>ForeignScanState</structname> node
     can be inspected to provide run-time statistics in the <command>EXPLAIN
     ANALYZE</command> case.
    </para>

    <para>
     If the <function>ExplainForeignScan</function> pointer is set to
     <literal>NULL</literal>, no additional information is printed during
     <command>EXPLAIN</command>.
    </para>

    <para>
<programlisting>
void
ExplainForeignModify (ModifyTableState *mtstate,
                      ResultRelInfo *rinfo,
                      List *fdw_private,
                      int subplan_index,
                      struct ExplainState *es);
</programlisting>

     Print additional <command>EXPLAIN</command> output for a foreign table update.
     This function can call <function>ExplainPropertyText</function> and
     related functions to add fields to the <command>EXPLAIN</command> output.
     The flag fields in <literal>es</literal> can be used to determine what to
     print, and the state of the <structname>ModifyTableState</structname> node
     can be inspected to provide run-time statistics in the <command>EXPLAIN
     ANALYZE</command> case.  The first four arguments are the same as for
     <function>BeginForeignModify</function>.
    </para>

    <para>
     If the <function>ExplainForeignModify</function> pointer is set to
     <literal>NULL</literal>, no additional information is printed during
     <command>EXPLAIN</command>.
    </para>

   </sect2>

   <sect2 id="fdw-callbacks-analyze">
    <title>FDW Routines for <command>ANALYZE</command></title>

    <para>
<programlisting>
bool
AnalyzeForeignTable (Relation relation,
                     AcquireSampleRowsFunc *func,
                     BlockNumber *totalpages);
</programlisting>

     Cette fonction est appelée quand <xref linkend="sql-analyze"/> est exécuté
     sur une table distante. Si le wrapper de données distantes peut récupérer
     des statistiques pour cette table distante, il doit renvoyer
     <literal>true</literal>, et fournir un pointeur vers une fonction qui
     récupérera un échantillon de lignes à partir de la table dans
     <parameter>func</parameter>, ainsi que la taille estimée de la table en
     blocs dans <parameter>totalpages</parameter>. Sinon, il doit renvoyer
     <literal>false</literal>.
    </para>

    <para>
     Si le wrapper de données distantes ne supporte
     pas la récupération de statistiques quelque soit la table, le pointeur
     <function>AnalyzeForeignTable</function> doit être configuré à
     <literal>NULL</literal>.
    </para>

    <para>
     Si fourni, la fonction de récupération de l'échantillon doit avoir la
     signature suivante&nbsp;:
<programlisting>
int
AcquireSampleRowsFunc (Relation relation, int elevel,
                       HeapTuple *rows, int targrows,
                       double *totalrows,
                       double *totaldeadrows);
</programlisting>

     Un échantillon récupéré au hasard et comprenant au plus
     <parameter>targrows</parameter> lignes doit être récupéré à partir de la
     table et stocké dans le tableau <parameter>rows</parameter> fourni par
     l'appelant. Le nombre réel de lignes récupérées doit être renvoyé. De plus,
     les estimations du nombre total de lignes vivantes et mortes doivent être
     enregistrées dans les paramètres en sortie appelés
     <parameter>totalrows</parameter> et <parameter>totaldeadrows</parameter>.
     (Configurez <parameter>totaldeadrows</parameter> à zéro si le wrapper de
     données distantes ne connaît pas le concept des lignes mortes.)
    </para>

    </sect2>

   </sect1>

   <sect1 id="fdw-helpers">
    <title>Fonctions d'aide pour les wrapper de données distantes</title>

    <para>
     Plusieurs fonctions d'aide sont exportées à partir du cœur du serveur, pour
     que les auteurs de wrappers de données distantes puissent accéder facilement
     aux attributs des objets en relation avec les wrappers, comme par exemple les
     options d'un wrapper. Pour utiliser une de ces fonctions, vous avez besoin
     d'inclure le fichier en-tête <filename>foreign/foreign.h</filename> dans
     votre fichier source. Cet en-tête définit aussi les types de structures qui
     sont renvoyés par ces fonctions.
    </para>

    <para>
<programlisting>
ForeignDataWrapper *
GetForeignDataWrapper(Oid fdwid);
</programlisting>

     Cette fonction renvoie un objet <structname>ForeignDataWrapper</structname>
     pour le wrapper de données distantes de l'OID spécifié. Un objet
     <structname>ForeignDataWrapper</structname> contient les propriétés du
     wrapper (voir <filename>foreign/foreign.h</filename> pour les détails).
    </para>

    <para>
<programlisting>
ForeignServer *
GetForeignServer(Oid serverid);
</programlisting>

     Cette fonction renvoie un objet <structname>ForeignServer</structname>
     pour le serveur distant de l'OID donné. Un objet
     <structname>ForeignServer</structname> contient les propriétés du serveur
     (voir <filename>foreign/foreign.h</filename> pour les détails).
    </para>

    <para>
<programlisting>
UserMapping *
GetUserMapping(Oid userid, Oid serverid);
</programlisting>

     Cette fonction renvoie un objet <structname>UserMapping</structname> pour
     la correspondance utilisateur du rôle donné sur le serveur donné.
     (S'il n'existe pas de correspondance utilisateur, la fonction renvoie
     la correspondance pour <literal>PUBLIC</literal> ou une erreur si cette
     dernière n'existe pas non plus.) Un objet
     <structname>UserMapping</structname> contient les propriétés de la
     correspondance utilisateur (voir <filename>foreign/foreign.h</filename>
     pour les détails).
    </para>

    <para>
<programlisting>
ForeignTable *
GetForeignTable(Oid relid);
</programlisting>

     Cette fonction renvoie un objet <structname>ForeignTable</structname> pour
     la table distante de l'OID donné. Un objet
     <structname>ForeignTable</structname> contient les propriétés de la table
     distante (voir <filename>foreign/foreign.h</filename> pour les détails).
    </para>

    <para>
<programlisting>
List *
GetForeignColumnOptions(Oid relid, AttrNumber attnum);
</programlisting>

     Cette fonction renvoie les opérations du wrapper de données distantes par
     colonne pour l'OID de la table distante donnée et le numéro de l'attribut
     sous la forme d'une liste de <structname>DefElem</structname>. NIL est
     renvoyé sur la colonne n'a pas d'options.
    </para>

    <para>
     Certains types d'objets ont des fonctions de recherche basées sur le nom
     en plus de celles basées sur l'OID&nbsp;:
    </para>

    <para>
<programlisting>
ForeignDataWrapper *
GetForeignDataWrapperByName(const char *name, bool missing_ok);
</programlisting>

     Cette fonction renvoie un objet <structname>ForeignDataWrapper</structname>
     pour le wrapper de données distante du nom indiqué. Si le wrapper n'est pas
     trouvé, cette fonction renvoie NULL si missing_ok vaut true, et renvoie
     une erreur sinon.
    </para>

    <para>
<programlisting>
ForeignServer *
GetForeignServerByName(const char *name, bool missing_ok);
</programlisting>

     Cette fonction renvoie un objet <structname>ForeignServer</structname> pour
     le serveur distant du nom donné. Si le serveur n'est pas trouvé, cette
     fonction renvoie NULL si missing_ok vaut true, et renvoie une erreur sinon.
     </para>
 
    </sect1>
 
   <sect1 id="fdw-planning">
    <title>Planification de la requête avec un wrapper de données distantes</title>

    <para>
     Les fonctions d'appels d'un wrapper de données distantes, <function>GetForeignRelSize</function>,
     <function>GetForeignPaths</function>, <function>GetForeignPlan</function> et
     <function>PlanForeignModify</function>
     doivent s'intégrer au fonctionnement du planificateur de
     <productname>PostgreSQL</productname>. Voici quelques notes sur ce qu'elles
     doivent faire.
    </para>

    <para>
     Les informations dans <literal>root</literal> et <literal>baserel</literal>
     peuvent être utilisées pour réduire la quantité d'informations qui doivent
     être récupérées sur la table distante (et donc réduire le coût)
     <literal>baserel-&gt;baserestrictinfo</literal> est tout particulièrement
     intéressant car il contient les qualificatifs de restriction (clauses
     <literal>WHERE</literal>) qui doivent être utilisées pour filtrer les lignes
     à récupérer. (Le wrapper lui-même n'est pas requis de respecter ces clauses
     car l'exécuteur du moteur peut les vérifier à sa place.)
     <literal>baserel-&gt;reltargetlist</literal> peut être utilisé pour
     déterminer les colonnes à récupérer&nbsp;; mais notez qu'il liste seulement
     les colonnes qui doivent être émises par le nœud
     <structname>ForeignScan</structname>, et non pas les colonnes qui sont
     utilisées pour satisfaire l'évaluation des qualificatifs et non renvoyées
     par la requête.
    </para>

    <para>
     Divers champs privés sont disponibles pour que les fonctions de planification
     du wrapper de données distantes conservent les informations. Habituellement,
     tout ce que vous stockez dans les champs privées doit avoir été alloué avec
     la fonction palloc, pour que l'espace soit récupéré à la fin de la
     planification.
    </para>

    <para>
     <literal>baserel-&gt;fdw_private</literal> est un pointeur <type>void</type>
     disponible pour que les fonctions de planification du wrapper y stockent
     des informations correspondant à la table distante spécifique. Le planificateur
     du moteur n'y touche pas sauf lors de son initialisation à NULL quand le
     nœud <literal>baserel</literal> est créé. Il est utile de passer des
     informations de <function>GetForeignRelSize</function> à
     <function>GetForeignPaths</function> et/ou <function>GetForeignPaths</function>
     à <function>GetForeignPlan</function>, évitant du coup un recalcul.
    </para>

    <para>
     <function>GetForeignPaths</function> peut identifier la signification de
     chemins d'accès différents pour enregistrer des informations privées dans
     le champ <structfield>fdw_private</structfield> des nœuds
     <structname>ForeignPath</structname>. <structfield>fdw_private</structfield>
     est déclaré comme un pointeur <type>List</type> mais peut contenir réellement
     n'importe quoi car le planificateur du moteur n'y touche pas. Néanmoins, une
     bonne pratique est d'utiliser une représentation qui est affichable par
     <function>nodeToString</function>, pour son utilisation avec le support du
     débogage disponible dans le processus.
    </para>

    <para>
     <function>GetForeignPlan</function> peut examiner le champ
     <structfield>fdw_private</structfield> du nœud
     <structname>ForeignPath</structname>, et peut générer les listes
     <structfield>fdw_exprs</structfield> et <structfield>fdw_private</structfield>
     à placer dans le nœud de plan <structname>ForeignScan</structname>, où
     elles seront disponibles au moment de l'exécution. Les deux listes doivent
     être représentées sous une forme que <function>copyObject</function> sait
     copier. La liste <structfield>fdw_private</structfield> n'a pas d'autres
     restrictions et n'est pas interprétée par le processus moteur. La liste
     <structfield>fdw_exprs</structfield>, si non NULL, devrait contenir
     les arbres d'expressions qui devront être exécutées. Ces arbres passeront
     par un post-traitement par le planificateur qui les rend complètement
     exécutables.
    </para>

    <para>
     Dans <function>GetForeignPlan</function>, habituellement, la liste cible
     fournie peut être copiée dans le nœud du plan tel quel. La liste
     scan_clauses fournie contient les mêmes clauses que
     <literal>baserel-&gt;baserestrictinfo</literal> mais ces clauses pourraient
     être ré-ordonnées pour une meilleure efficacité à l'exécution. Dans les cas
     simples, le wrapper peut seulement supprimer les nœuds
     <structname>RestrictInfo</structname> de la liste scan_clauses (en utilisant
     <function>extract_actual_clauses</function>) et placer toutes les clauses
     dans la liste des qualificatifs du nœud. Cela signifie que toutes les clauses
     seront vérifiées par l'exécuteur au moment de l'exécution. Les wrappers les
     plus complexes peuvent être capables de vérifier certaines clauses en interne,
     auquel cas ces clauses peuvent être supprimées de la liste de qualificatifs
     du nœud du plan pour que le planificateur ne perde pas de temps à les
     vérifier de nouveau.
    </para>

    <para>
     Comme exemple, le wrapper peut identifier certaines clauses de restriction
     de la forme <replaceable>variable_distante</replaceable> <literal>=</literal>
     <replaceable>sous_expression</replaceable>, qui, d'après lui, peut être
     exécuté sir le serveur distant en donnant la valeur évaluée localement de
     la <replaceable>sous_expression</replaceable>. L'identification réelle d'une
     telle clause doit survenir lors de l'exécution de
     <function>GetForeignPaths</function> car cela va affecter l'estimation ddu
     coût pour le chemin. Le champ <structfield>fdw_private</structfield> du
     chemin pourrait probablement inclure un pointeur vers le nœud
     <structname>RestrictInfo</structname> de la clause identifiée. Puis,
     <function>GetForeignPlan</function> pourrait supprimer cette clause de
     scan_clauses et ajouter la <replaceable>sous_expression</replaceable> à
     <structfield>fdw_exprs</structfield> pour s'assurer qu'elle soit convertie
     en une forme exécutable. Il pourrait aussi placer des informations de contrôle
     dans le champ <structfield>fdw_private</structfield> du nœud pour dire aux
     fonctions d'exécution ce qu'il faudra faire au moment de l'exécution. La
     requête transmise au serveur distant va impliquer quelque chose comme
     <literal>WHERE <replaceable>variable_distante</replaceable> =
     $1</literal>, avec la valeur du paramètre obtenu à l'exécution à partir de
     l'évaluation de l'arbre d'expression <structfield>fdw_exprs</structfield>.
    </para>

    <para>
     Le wrapper de données distantes devrait toujours construire au moins un
     chemin qui dépend seulement des clauses de restriction de la table. Dans
     les requêtes de jointure, il pourrait aussi choisir de construire des
     chemins qui dépendent des clauses de jointures. Par exemple,
     <replaceable>variable_distante</replaceable> <literal>=</literal>
     <replaceable>variable_local</replaceable>. De telles clauses ne se trouveront
     pas dans <literal>baserel-&gt;baserestrictinfo</literal> mais doivent être
     dans les listes de jointures des relations. Un chemin utilisant une telle
     clause est appelé un <quote>parameterized path</quote>. Il doit identifier
     les autres relations utilisées dans le(s) clause(s) de jointure
     sélectionnée(s) avec une valeur convenable pour
     <literal>param_info</literal>&nbsp;; utilisez
     <function>get_baserel_parampathinfo</function> pour calculer cette valeur.
     Dans <function>GetForeignPlan</function>, la portion
     <replaceable>local_variable</replaceable> de la clause de jointure pourra être
     ajoutée à <structfield>fdw_exprs</structfield>, et ensuite à l'exécution, cela
     fonctionne de la même façon que pour une clause de restriction standard.
    </para>

    <para>
     When planning an <command>UPDATE</command> or <command>DELETE</command>,
     <function>PlanForeignModify</function> can look up the <structname>RelOptInfo</structname>
     struct for the foreign table and make use of the
     <literal>baserel-&gt;fdw_private</literal> data previously created by the
     scan-planning functions.  However, in <command>INSERT</command> the target
     table is not scanned so there is no <structname>RelOptInfo</structname> for it.
     The <structname>List</structname> returned by <function>PlanForeignModify</function> has
     the same restrictions as the <structfield>fdw_private</structfield> list of a
     <structname>ForeignScan</structname> plan node, that is it must contain only
     structures that <function>copyObject</function> knows how to copy.
    </para>

    <para>
     For an <command>UPDATE</command> or <command>DELETE</command> against an external data
     source that supports concurrent updates, it is recommended that the
     <literal>ForeignScan</literal> operation lock the rows that it fetches, perhaps
     via the equivalent of <command>SELECT FOR UPDATE</command>.  The FDW may also
     choose to lock rows at fetch time when the foreign table is referenced
     in a <command>SELECT FOR UPDATE/SHARE</command>; if it does not, the
     <literal>FOR UPDATE</literal> or <literal>FOR SHARE</literal> option is essentially a
     no-op so far as the foreign table is concerned.  This behavior may yield
     semantics slightly different from operations on local tables, where row
     locking is customarily delayed as long as possible: remote rows may get
     locked even though they subsequently fail locally-applied restriction or
     join conditions.  However, matching the local semantics exactly would
     require an additional remote access for every row, and might be
     impossible anyway depending on what locking semantics the external data
     source provides.
    </para>

  </sect1>


 </chapter>
