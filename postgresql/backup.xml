<?xml version="1.0" encoding="UTF-8"?>
<chapter id="backup">
 <title>Sauvegardes et restaurations</title>

 <indexterm zone="backup"><primary>backup</primary></indexterm>

 <para>
  Comme tout ce qui contient des données importantes, les bases de données
  <productname>PostgreSQL</productname> doivent être sauvegardées régulièrement.
  Bien que la procédure soit assez simple, il est important de comprendre les
  techniques et hypothèses sous-jacentes.
 </para>

 <para>
  Il y a trois approches fondamentalement différentes pour sauvegarder les
  données de <productname>PostgreSQL</productname>&nbsp;:
  <itemizedlist>
   <listitem><para><acronym>la sauvegarde SQL&nbsp;;</acronym></para></listitem>
   <listitem><para>la sauvegarde au niveau du système de
     fichiers&nbsp;;</para></listitem>
   <listitem><para>l'archivage continu.</para></listitem>
  </itemizedlist>
  Chacune a ses avantages et ses inconvénients.
  Elles sont toutes analysées, chacune leur tour, dans les sections suivantes.
 </para>

 <sect1 id="backup-dump">
  <title>Sauvegarde <acronym>SQL</acronym></title>

  <para>
   Le principe est de produire un fichier texte de commandes SQL (appelé
   <quote>fichier dump</quote>), qui, si on le renvoie au serveur, recrée une
   base de données identique à celle sauvegardée.
   <productname>PostgreSQL</productname> propose pour cela le programme utilitaire
   <xref linkend="app-pgdump"/>. L'usage basique est&nbsp;:
   <synopsis>pg_dump <replaceable class="parameter">base_de_donnees</replaceable> &gt; <replaceable class="parameter">fichier_sauvegarde</replaceable></synopsis>
   <application>pg_dump</application> écrit son résultat sur la
   sortie standard. Son utilité est expliquée plus loin.
   Bien que la commande ci-dessus crée un fichier texte,
   <application>pg_dump</application> peut créer des fichiers dans d'autres
   formats qui permettent le parallélisme et un contrôle plus fin de la
   restauration des objets.
  </para>

  <para>
   <application>pg_dump</application> est un programme client
   <productname>PostgreSQL</productname>
   classique (mais plutôt intelligent). Cela signifie que la
   sauvegarde peut être effectuée depuis n'importe quel ordinateur ayant accès à la base.
   Mais <application>pg_dump</application> n'a pas de droits spéciaux.
   En particulier, il doit avoir un accès en lecture à toutes les tables que
   vous voulez sauvegarder, donc pour sauvegarder une base complète, vous devez
   pratiquement toujours utiliser un superutilisateur. si vous n'avez pas les
   droits suffisants pour sauvegarder la base entière, vous pouvez toujours
   sauvegarder les parties pour lesquels vous avez le droit d'accès en utilisant
   des options telles que <option>-n <replaceable>schéma</replaceable></option>
   et <option>-t <replaceable>table</replaceable></option>.)
  </para>

  <para>
   Pour préciser le serveur de bases de données que
   <application>pg_dump</application> doit
   contacter, on utilise les options de ligne de commande
   <option>-h <replaceable>serveur</replaceable></option> et
   <option>-p <replaceable>port</replaceable></option>.
   Le serveur par défaut est le serveur local ou celui indiqué par la
   variable d'environnement <envar>PGHOST</envar>.
   De la même façon, le port par défaut est indiqué par la variable d'environnement
   <envar>PGPORT</envar> ou, en son absence, par la valeur par défaut précisée
   à la compilation. Le serveur a normalement reçu les mêmes valeurs par
   défaut à la compilation.
  </para>

  <para>
   Comme tout programme client <productname>PostgreSQL</productname>,
   <application>pg_dump</application>
   se connecte par défaut avec l'utilisateur de base de données de même nom que
   l'utilisateur système courant. L'utilisation de l'option
   <option>-U</option> ou de la variable d'environnement
   <envar>PGUSER</envar> permettent de
   modifier le comportement par défaut. Les connexions de
   <application>pg_dump</application> sont soumises aux mécanismes normaux
   d'authentification des programmes clients (décrits dans le
   <xref linkend="client-authentication"/>).
  </para>

  <para>
   Un des gros avantages de <application>pg_dump</application> sur les autres
   méthodes de sauvegarde décrites après est que la sortie de
   <application>pg_dump</application> peut être généralement re-chargée dans
   des versions plus récentes de <productname>PostgreSQL</productname>, alors
   que les sauvegardes au niveau fichier et l'archivage continu sont tous les
   deux très spécifiques à la version du serveur.
   <application>pg_dump</application> est aussi la seule méthode qui
   fonctionnera lors du transfert d'une base de données vers une machine d'une
   architecture différente (comme par exemple d'un serveur 32 bits à un serveur
   64 bits).
  </para>

  <para>
   Les sauvegardes créées par <application>pg_dump</application> sont
   cohérentes, ce qui signifie que la sauvegarde représente une image de la
   base de données au moment où commence l'exécution de
   <application>pg_dump</application>.
   <application>pg_dump</application> ne bloque pas les autres opérations sur la base
   lorsqu'il fonctionne (sauf celles qui nécessitent un verrou exclusif, comme
   la plupart des formes d'<command>ALTER TABLE</command>.)
  </para>

  <sect2 id="backup-dump-restore">
   <title>Restaurer la sauvegarde</title>

   <para>
    Les fichiers texte créés par <application>pg_dump</application> peuvent être
    lus par le programme <application>psql</application>. La syntaxe générale
    d'une commande de restauration est
<synopsis>psql <replaceable class="parameter">base_de_donnees</replaceable> &lt; <replaceable class="parameter">fichier_sauvegarde</replaceable></synopsis>
    où <replaceable class="parameter">fichier_sauvegarde</replaceable> est
    le fichier en sortie de la commande <application>pg_dump</application>. La base de données
    <replaceable class="parameter">base_de_donnees</replaceable> n'est pas créée par cette
    commande. Elle doit être créée à partir de <literal>template0</literal>
    avant d'exécuter <application>psql</application> (par exemple avec <literal>createdb -T
    template0 <replaceable class="parameter">base_de_donnees</replaceable></literal>).
    <application>psql</application> propose des options similaires à celles de
    <application>pg_dump</application> pour indiquer le serveur de bases de
    données sur lequel se connecter et le nom d'utilisateur à utiliser. La
    page de référence de <xref linkend="app-psql"/> donne plus d'informations.
    Les sauvegardes binaires sont restaurées en utilisant l'outil <xref
    linkend="app-pgrestore"/>.
    </para>

   <para>
    Tous les utilisateurs possédant des
    objets ou ayant certains droits sur les objets de la base sauvegardée
    doivent exister préalablement à la restauration de la sauvegarde. S'ils
    n'existent pas, la
    restauration échoue pour la création des objets dont ils sont
    propriétaires ou sur lesquels ils ont des droits (quelque fois, cela
    est souhaitable mais ce n'est habituellement pas le cas).
   </para>

   <para>
    Par défaut, le script <application>psql</application> continue de
    s'exécuter après la détection d'une erreur SQL. Vous pouvez exécuter
    <application>psql</application> avec la variable
    <literal>ON_ERROR_STOP</literal> configurée pour modifier ce comportement.
    <application>psql</application> quitte alors avec un
    code d'erreur 3 si une erreur SQL survient&nbsp;:
<programlisting>psql --set ON_ERROR_STOP=on <replaceable>base_de_données</replaceable> &lt; <replaceable>fichier_sauvegarde</replaceable>
   </programlisting>
   Dans tous les cas, une sauvegarde partiellement restaurée est obtenue.
   Si cela n'est pas souhaitable, il est possible d'indiquer que la sauvegarde
   complète doit être restaurée au cours d'une transaction unique. De ce
   fait, soit la restauration est validée dans son ensemble, soit elle est
   entièrement annulée. Ce mode est choisi
   en passant l'option <option>-1</option> ou <option>--single-transaction</option>
   en ligne de commande à <application>psql</application>. Dans ce mode,
   la plus petite erreur peut annuler une restauration en cours depuis
   plusieurs heures. Néanmoins, c'est probablement
   préférable au nettoyage manuel d'une base rendu complexe par une
   sauvegarde partiellement restaurée.
  </para>

  <para>
   La capacité de <application>pg_dump</application> et
   <application>psql</application> à écrire
   et à lire dans des tubes permet de sauvegarder une base de données
   directement d'un serveur sur un autre. Par exemple&nbsp;:
   <programlisting>pg_dump -h <replaceable>serveur1</replaceable> <replaceable>base_de_donnees</replaceable> | psql -h <replaceable>serveur2</replaceable> <replaceable>base_de_donnees</replaceable></programlisting>
   </para>

   <important>
    <para>
     Les fichiers de sauvegarde produits par <application>pg_dump</application> sont
     relatifs à <literal>template0</literal>. Cela signifie que chaque langage,
     procédure, etc. ajouté à <literal>template1</literal> est aussi sauvegardé
     par <application>pg_dump</application>. En conséquence, si une base
     <literal>template1</literal> modifiée est utilisée lors de la
     restauration, il faut créer la base vide à partir de
     <literal>template0</literal>, comme dans l'exemple plus haut.
    </para>
   </important>

   <para>
    Après la restauration d'une sauvegarde, il est conseillé d'exécuter
    <xref linkend="sql-analyze"/> sur chaque base
    de données pour que l'optimiseur de requêtes dispose de statistiques
    utiles&nbsp;; voir <xref
    linkend="vacuum-for-statistics"/> et
    <xref linkend="autovacuum"/> pour plus
    d'informations.
    Pour plus de conseils sur le chargement efficace de grosses quantités de
    données dans <productname>PostgreSQL</productname>, on peut se référer à la
    <xref linkend="populate"/>.
   </para>

  </sect2>

  <sect2 id="backup-dump-all">
   <title>Utilisation de <application>pg_dumpall</application></title>

   <para>
    <application>pg_dump</application> ne sauvegarde qu'une seule base à la
    fois, et ne sauvegarde pas les informations relatives aux rôles et
    <foreignphrase>tablespaces</foreignphrase> (parce que ceux-ci portent
    sur l'ensemble des bases du cluster, et non sur une base particulière).
    Pour permettre une sauvegarde aisée de tout le contenu d'un cluster, le
    programme <xref linkend="app-pg-dumpall"/> est fourni.
    <application>pg_dumpall</application> sauvegarde toutes les bases de données d'un
    cluster (ensemble des bases d'une instance) <productname>PostgreSQL</productname> et
    préserve les données communes au cluster, telles que les rôles et tablespaces.
    L'utilisation basique de cette commande est&nbsp;:
<synopsis>pg_dumpall &gt; <replaceable>fichier_sauvegarde</replaceable></synopsis>
    Le fichier de sauvegarde résultant peut être restauré avec
    <application>psql</application>&nbsp;:
<synopsis>psql -f <replaceable class="parameter">fichier_sauvegarde</replaceable> postgres</synopsis>
    (N'importe quelle base de données peut être utilisée pour la connexion
    mais si le rechargement est exécuté sur un cluster vide, il est
    préférable d'utiliser <literal>postgres</literal>.)
    Il faut obligatoirement avoir le profil superutilisateur pour restaurer
    une sauvegarde faite avec <application>pg_dumpall</application>, afin de
    pouvoir restaurer les informations sur les rôles et les tablespaces.
    Si les <foreignphrase>tablespaces</foreignphrase> sont utilisés, il faut
    s'assurer que leurs chemins sauvegardés sont appropriés à la nouvelle
    installation.
   </para>

   <para>
    <application>pg_dumpall</application> fonctionne en émettant des
    commandes pour recréer les rôles, les
    <foreignphrase>tablespaces</foreignphrase> et les bases vides, puis
    en invoquant <application>pg_dump</application> pour chaque base de
    données. Cela signifie que, bien que chaque base de données est
    cohérente en interne, les images des différentes bases de données ne sont
    pas synchronisées.
   </para>

   <para>
    Les données globales à l'instance peuvent être sauvegardées seules en
    utilisant l'option <option>--globals-only</option> de
    <application>pg_dumpall</application>. Ceci est nécessaire pour sauvegarder
    entièrement l'instance si la commande <application>pg_dump</application>
    est utilisée pour sauvegarder les bases individuelles.
   </para>
  </sect2>

  <sect2 id="backup-dump-large">
   <title>Gérer les grosses bases de données</title>

   <para>
    Certains systèmes d'exploitation ont des limites sur la taille maximum des
    fichiers qui posent des problème lors de la création de gros fichiers de
    sauvegarde avec <application>pg_dump</application>. Heureusement,
    <application>pg_dump</application> peut écrire sur la sortie standard,
    donc vous pouvez utiliser les outils Unix standards pour contourner ce
    problème potentiel. Il existe plusieurs autres méthodes&nbsp;:
   </para>

   <formalpara>
    <title>Compresser le fichier de sauvegarde</title>
    <para>
     Tout programme de compression habituel est utilisable. Par exemple
     <application>gzip</application>&nbsp;:

<programlisting>pg_dump <replaceable class="parameter">base_de_donnees</replaceable> | gzip &gt; <replaceable class="parameter">nom_fichier</replaceable>.gz</programlisting>

     Pour restaurer&nbsp;:

<programlisting>gunzip -c <replaceable class="parameter">nom_fichier</replaceable>.gz | psql <replaceable class="parameter">base_de_donnees</replaceable></programlisting>

     ou

<programlisting>cat <replaceable class="parameter">nom_fichier</replaceable>.gz | gunzip | psql <replaceable class="parameter">base_de_donnees</replaceable></programlisting>
    </para>
   </formalpara>

   <formalpara>
    <title>Couper le fichier avec <command>split</command></title>
    <para>
     La commande <command>split</command> permet de découper le fichier en
     fichiers plus petits, de taille acceptable par le système de fichiers sous-jacent.
     Par exemple, pour faire des morceaux de 1&nbsp;Mo&nbsp;:

<programlisting>pg_dump <replaceable class="parameter">base_de_donnees</replaceable> | split -b 1m - <replaceable class="parameter">nom_fichier</replaceable></programlisting>

     Pour restaurer&nbsp;:

<programlisting>cat <replaceable class="parameter">nom_fichier</replaceable>* | psql <replaceable class="parameter">base_de_donnees</replaceable></programlisting>
    </para>
   </formalpara>

   <formalpara>
    <title>Utilisation du format de sauvegarde personnalisé de
     <application>pg_dump</application></title>
    <para>
     Si <productname>PostgreSQL</productname> est installé sur un système où la
     bibliothèque de compression <application>zlib</application> est
     disponible, le format de sauvegarde personnalisé peut être utilisé pour
     compresser les données à la volée. Pour les bases de données
     volumineuses,
     cela produit un fichier de sauvegarde d'une taille comparable à celle
     du fichier produit par
     <command>gzip</command>, avec l'avantage supplémentaire de permettre de
     restaurer des tables sélectivement. La commande qui suit sauvegarde une
     base de données en utilisant ce format de sauvegarde&nbsp;:

<programlisting>pg_dump -Fc <replaceable class="parameter">base_de_donnees</replaceable> &gt; <replaceable class="parameter">nom_fichier</replaceable></programlisting>

     Le format de sauvegarde personnalisé ne produit pas un script
     utilisable par
     <application>psql</application>. Ce script doit être restauré avec
     <application>pg_restore</application>, par exemple&nbsp;:

<programlisting>
pg_restore -d <replaceable class="parameter">nom_base</replaceable> <replaceable class="parameter">nom_fichier</replaceable>
   </programlisting>

   Voir les pages de référence de
   <xref linkend="app-pgdump"/> et <xref linkend="app-pgrestore"/> pour plus de
   détails.
  </para>
 </formalpara>

 <para>
  Pour les très grosses bases de données, il peut être nécessaire de combiner
  <command>split</command> avec une des deux autres approches.
 </para>

 <formalpara>
  <title>Utiliser la fonctionnalité de sauvegarde en parallèle de
   <application>pg_dump</application>.</title>
  <para>
   Pour accélérer la sauvegarde d'une grosse base de données, vous pouvez
   utiliser le mode parallélisé de <application>pg_dump</application>. Cela
   sauvegardera plusieurs tables à la fois. Vous pouvez contrôler le degré de
   parallélisme avec le paramètre <command>-j</command>. Les sauvegardes en
   parallèle n'acceptent que le format répertoire.

   <programlisting>
pg_dump -j <replaceable class="parameter">num</replaceable> -F d -f <replaceable class="parameter">sortie.dir</replaceable> <replaceable class="parameter">nom_base</replaceable>
   </programlisting>

   Vous pouvez utiliser <command>pg_restore -j</command> pour restaurer une
   sauvegarde en parallèle. Ceci fonctionnera pour n'importe quelle archive,
   qu'elle soit dans le mode personnalisé ou répertoire. Elle n'a pas besoin
   d'avoir été créée avec le mode parallélisé de <command>pg_dump</command>.
  </para>
 </formalpara>
</sect2>
</sect1>

<sect1 id="backup-file">
<title>Sauvegarde de niveau système de fichiers</title>

<para>
 Une autre stratégie de sauvegarde consiste à copier les fichiers
 utilisés par <productname>PostgreSQL</productname> pour le stockage des données.
 Dans la <xref linkend="creating-cluster"/>, l'emplacement de ces
 fichiers est précisé. N'importe quelle
 méthode de sauvegarde peut être utilisée, par exemple&nbsp;:

 <programlisting>tar -cf sauvegarde.tar /usr/local/pgsql/data</programlisting>
  </para>

  <para>
   Cependant, deux restrictions rendent cette méthode peu pratique
   ou en tout cas inférieure à la méthode <application>pg_dump</application>.

   <orderedlist>
    <listitem>
     <para>
      Le serveur de base de données <emphasis>doit</emphasis> être arrêté pour obtenir
      une sauvegarde utilisable. Toutes les demi-mesures, comme la
      suppression des connexions, ne fonctionnent <emphasis>pas</emphasis>
      (principalement parce que <command>tar</command> et les outils similaires
      ne font pas une image atomique de l'état du système de fichiers,
      mais aussi à cause du tampon interne du serveur). Les informations concernant la façon d'arrêter
      le serveur <productname>PostgreSQL</productname> se trouvent dans la
      <xref linkend="server-shutdown"/>.
    </para>

     <para>
      Le serveur doit également être arrêté avant de restaurer les données.
      </para>
    </listitem>

    <listitem>
     <para>
      Quiconque s'est aventuré dans les détails de l'organisation de la base
      de données peut être tenté de ne sauvegarder et restaurer que certaines
      tables ou bases de données particulières. Ce n'est
      <emphasis>pas</emphasis> utilisable sans les fichiers journaux de
      validation <filename>pg_xact/*</filename> qui contiennent l'état de la
      validation de chaque transaction. Un fichier de table n'est utilisable
      qu'avec cette information. Bien entendu, il est impossible de ne
      restaurer qu'une table et les données <filename>pg_xact</filename>
      associées car cela rendrait toutes les autres tables du serveur
      inutilisables. Les sauvegardes du système de fichiers fonctionnent,
      de ce fait, uniquement pour les sauvegardes et restaurations complètes
      d'un cluster de bases de données.
     </para>
    </listitem>
   </orderedlist>
  </para>

  <para>
   Une autre approche à la sauvegarde du système de fichiers consiste à réaliser
   une <quote>image cohérente</quote> (<foreignphrase>consistent
   snapshot</foreignphrase>) du répertoire des données. Il faut
   pour cela que le système
   de fichiers supporte cette fonctionnalité (et qu'il puisse lui être fait
   confiance). La procédure typique consiste à réaliser une
   <quote>image gelée</quote> (<foreignphrase>frozen snapshot</foreignphrase>)
   du volume contenant la base de données et
   ensuite de copier entièrement le répertoire de données (pas seulement
   quelques parties, voir plus haut) de l'image sur un périphérique de sauvegarde, puis de
   libérer l'image gelée. Ceci fonctionne même si le serveur de la base de
   données est en cours d'exécution. Néanmoins, une telle sauvegarde
   copie les fichiers de la base de données dans un état où le
   serveur n'est pas correctement arrêté&nbsp;; du coup, au lancement du
   serveur à partir des données sauvegardées, PostgreSQL peut penser que le
   serveur s'est stoppé brutalement et rejouer les journaux WAL. Ce n'est
   pas un problème, mais il faut en être conscient (et s'assurer d'inclure les
   fichiers WAL dans la sauvegarde).
   Vous pouvez réaliser un <command>CHECKPOINT</command> avant de prendre la
   sauvegarde pour réduire le temps de restauration.
  </para>

  <para>
   Si la base de données est répartie sur plusieurs systèmes de fichiers,
   il n'est peut-être pas possible d'obtenir des images gelées
   exactement simultanées de tous les disques. Si les fichiers
   de données et les journaux WAL sont sur des disques différents, par
   exemple, ou si les
   tablespaces sont sur des systèmes de fichiers différents, une
   sauvegarde par images n'est probablement pas utilisable parce que ces
   dernières <emphasis>doivent</emphasis> être simultanées.
   La documentation du système de fichiers doit être étudiée avec attention
   avant de faire confiance à la technique d'images cohérentes dans de telles situations.
   <!-- Disparu de la version 8.4.1
   L'approche la plus sûre est d'arrêter
   le serveur de bases de données assez longtemps pour créer toutes les images
   gelées.-->
</para>

<para>
 S'il n'est pas possible d'obtenir des images simultanées, il est
 toujours possible d'éteindre le serveur de bases de données suffisamment
 longtemps pour établir toutes les images gelées. Une autre possibilité est
 de faire une sauvegarde de la base en archivage continu (<xref
 linkend="backup-base-backup"/>) parce que ces sauvegardes ne sont pas
 sensibles aux modifications des fichiers pendant la sauvegarde. Cela n'impose
 d'activer l'archivage en continu que pendant la période de sauvegarde&nbsp;; la
 restauration est faite en utilisant la restauration d'archive en ligne
 (<xref linkend="backup-pitr-recovery"/>).
</para>

<para>
 Une autre option consiste à utiliser <application>rsync</application> pour réaliser une
 sauvegarde du système de fichiers. Ceci se fait tout d'abord en lançant
 <application>rsync</application> alors que le serveur de bases de données est en cours
 d'exécution, puis en arrêtant le serveur juste assez longtemps pour lancer
 <command>rsync --checksum</command> une deuxième fois
 (<option>--checksum</option> est nécessaire car <command>rsync</command> n'a
 une granularité que d'une seconde quand il teste par horodatage de modification.
 Le deuxième
 <application>rsync</application> est beaucoup plus rapide que le premier car il a
 relativement peu de données à transférer et le résultat final est
 cohérent, le serveur étant arrêté. Cette méthode permet de réaliser une
 sauvegarde du système de fichiers avec un arrêt minimal.
</para>

<para>
 Une sauvegarde des fichiers de données va être généralement plus
 volumineuse qu'une sauvegarde SQL. (<application>pg_dump</application> ne sauvegarde pas le
 contenu des index, mais la commande pour les recréer). Cependant, une
 sauvegarde des fichiers de données peut être plus rapide.
</para>

</sect1>

<sect1 id="continuous-archiving">
<title>Archivage continu et récupération d'un instantané (PITR)</title>

<indexterm zone="backup">
 <primary>archivage en continu</primary>
</indexterm>

<indexterm zone="backup">
 <primary>récupération d'un instantané</primary>
</indexterm>

<indexterm zone="backup">
 <primary>PITR</primary>
</indexterm>

<para>
 <productname>PostgreSQL</productname> maintient en permanence des journaux WAL
 (<firstterm>write ahead log</firstterm>) dans le sous-répertoire
 <filename>pg_wal/</filename> du répertoire de données du cluster. Ces journaux
 enregistrent chaque modification effectuée sur les fichiers de données des
 bases. Ils existent principalement pour se prémunir des suites d'un
 arrêt brutal&nbsp;: si le système s'arrête brutalement, la base de données
 peut être restaurée dans un état cohérent en
 <quote>rejouant</quote> les entrées des journaux enregistrées depuis le dernier
 point de vérification. Néanmoins, l'existence de ces journaux rend possible
 l'utilisation d'une troisième stratégie pour la sauvegarde des bases de
 données&nbsp;: la combinaison d'une sauvegarde de niveau système de
 fichiers avec la sauvegarde des fichiers WAL. Si la récupération est
 nécessaire, la sauvegarde des fichiers est restaurée, puis les fichiers WAL sauvegardés
 sont rejoués pour amener la sauvegarde jusqu'à la date
 actuelle. Cette approche est plus complexe à administrer que toutes les
 autres approches mais elle apporte des bénéfices significatifs&nbsp;:
 <itemizedlist>
  <listitem>
   <para>
    Il n'est pas nécessaire de disposer d'une sauvegarde des fichiers parfaitement cohérente
    comme point de départ. Toute incohérence dans la sauvegarde est corrigée
    par la ré-exécution des journaux (ceci n'est pas significativement
    différent de ce qu'il se passe lors d'une récupération après un arrêt
    brutal). La fonctionnalité d'image du système de fichiers n'est alors
    pas nécessaire, <application>tar</application> ou tout
    autre outil d'archivage est suffisant.
   </para>
  </listitem>
  <listitem>
   <para>
    Puisqu'une longue séquence de fichiers WAL peut être assemblée pour
    être rejouée, une sauvegarde continue est obtenue en continuant
    simplement à archiver les fichiers WAL. C'est particulièrement
    intéressant pour les grosses bases de données dont une sauvegarde
    complète fréquente est difficilement réalisable.
   </para>
  </listitem>
  <listitem>
   <para>
    Les entrées WAL ne doivent pas obligatoirement être rejouées
    intégralement. La ré-exécution peut être stoppée en tout point, tout en
    garantissant une image cohérente de la base de données telle qu'elle
    était à ce moment-là. Ainsi, cette technique autorise la
    <firstterm>récupération d'un instantané</firstterm> (PITR)&nbsp;: il est
    possible de restaurer l'état de la base de données telle qu'elle était
    en tout point dans le temps depuis la dernière sauvegarde de base.
   </para>
  </listitem>
  <listitem>
   <para>
    Si la série de fichiers WAL est fournie en continu à une autre
    machine chargée avec le même fichier de sauvegarde de base,
    on obtient un système <quote>de reprise intermédiaire</quote>
    (<foreignphrase>warm standby</foreignphrase>)&nbsp;: à tout
    moment, la deuxième machine peut être montée et disposer d'une copie
    quasi-complète de la base de données.
   </para>
  </listitem>
 </itemizedlist>
</para>

<note>
 <para>
  <application>pg_dump</application> et
  <application>pg_dumpall</application> ne font pas de sauvegardes au
  niveau système de fichiers. Ce type de sauvegarde est qualifié de
  <emphasis>logique</emphasis> et ne contiennent pas suffisamment
  d'informations pour permettre le rejeu des journaux de transactions.
 </para>
</note>

<para>
 Tout comme la technique de sauvegarde standard du système de fichiers,
 cette méthode ne supporte que la restauration d'un cluster de bases de données
 complet, pas d'un sous-ensemble. De plus, un espace d'archivage important
 est requis&nbsp;: la sauvegarde de la base peut être volumineuse et un
 système très utilisé engendre un trafic WAL à archiver de plusieurs Mo.
 Malgré tout, c'est la technique de sauvegarde préférée dans de nombreuses
 situations où une haute fiabilité est requise.
</para>

<para>
 Une récupération fructueuse à partir de l'archivage continu
 (aussi appelé <quote>sauvegarde à chaud</quote> par certains vendeurs de SGBD) nécessite
 une séquence ininterrompue de fichiers WAL archivés qui
 s'étend au moins jusqu'au point de départ de la sauvegarde. Pour
 commencer, il faut configurer et tester la procédure d'archivage
 des journaux WAL <emphasis>avant</emphasis> d'effectuer la première sauvegarde de
 base. C'est pourquoi la suite du document commence par présenter les mécanismes
 d'archivage des fichiers WAL.
</para>

<sect2 id="backup-archiving-wal">
 <title>Configurer l'archivage WAL</title>

 <para>
  Au sens abstrait, un système <productname>PostgreSQL</productname> fonctionnel
  produit une séquence infinie d'enregistrements WAL. Le système
  divise physiquement cette séquence en <firstterm>fichiers de segment</firstterm>
  WAL de 16&nbsp;Mo chacun (en général, mais cette taille peut
  être modifiée lors de l'exécution d'<application>initdb</application>). Les
  fichiers segment reçoivent des noms numériques pour refléter leur
  position dans la séquence abstraite des WAL. Lorsque le système n'utilise
  pas l'archivage des WAL, il ne crée que quelques fichiers segment,
  qu'il <quote>recycle</quote> en renommant les fichiers devenus inutiles.
  Un fichier segment dont le contenu précède le
  dernier point de vérification est supposé inutile et peut être recyclé.
 </para>

 <para>
  Lors de l'archivage des données WAL, le contenu de
  chaque fichier segment doit être capturé dès qu'il est rempli pour
  sauvegarder les données ailleurs avant son recyclage.
  En fonction de l'application et du matériel disponible,
  <quote>sauvegarder les données ailleurs</quote> peut se faire de plusieurs
  façons&nbsp;: les fichiers segment peuvent être copiés dans un répertoire
  NFS monté sur une autre machine, être écrits sur une cartouche (après
  s'être assuré qu'il existe un moyen d'identifier le nom d'origine de chaque
  fichier) ou être groupés pour gravure sur un CD, ou toute autre chose.
  Pour fournir autant de flexibilité que possible à l'administrateur de la
  base de données, <productname>PostgreSQL</productname> essaie de ne faire aucune
  supposition sur la façon dont l'archivage est réalisé. À la place,
  <productname>PostgreSQL</productname> permet de préciser la commande
  shell à exécuter pour copier le fichier segment complet à l'endroit
  désiré. La commande peut être aussi simple qu'un
  <literal>cp</literal> ou impliquer un shell complexe &mdash;
  c'est l'utilisateur qui décide.
 </para>

 <para>
  Pour activer l'archivage des journaux de transaction, on positionne le
  paramètre de configuration <xref linkend="guc-wal-level"/> à
  <literal>replica</literal> ou supérieur,
  <xref linkend="guc-archive-mode"/> à <literal>on</literal>,
  et on précise la commande shell à utiliser dans le paramètre
  <xref linkend="guc-archive-command"/> de la configuration. En fait, ces
  paramètres seront toujours placés dans le fichier
  <filename>postgresql.conf</filename>. Dans cette chaîne, un
  <literal>%p</literal> est remplacé par le chemin absolu de
  l'archive alors qu'un <literal>%f</literal> n'est remplacé que par le
  nom du fichier. (Le nom du chemin est relatif au répertoire de travail du
  serveur, c'est-à-dire le répertoire des données du cluster.)
  <literal>%%</literal> est utilisé pour écrire le
  caractère <literal>%</literal> dans la commande. La commande la plus
  simple ressemble à&nbsp;:
  <programlisting>archive_command = 'test ! -f /mnt/serveur/repertoire_archive/%f &amp;&amp; cp %p /mnt/serveur/repertoire_archive/%f'  # Unix
archive_command = 'copy "%p" "C:\\serveur\\repertoire_archive\\%f"'  # Windows</programlisting>
    qui copie les segments WAL archivables dans le répertoire
    <filename>/mnt/serveur/repertoire_archive</filename>. (Ceci est un exemple, pas
    une recommandation, et peut ne pas fonctionner sur toutes les
    plateformes.) Après le remplacement des paramètres <literal>%p</literal>
    et <literal>%f</literal>, la commande réellement exécutée peut ressembler
    à&nbsp;:
<programlisting>test ! -f /mnt/serveur/repertoire_archive/00000001000000A900000065 &amp;&amp; cp pg_wal/00000001000000A900000065 /mnt/serveur/repertoire_archive/00000001000000A900000065
  </programlisting>
  Une commande similaire est produite pour chaque nouveau fichier à archiver.
 </para>

 <para>
  La commande d'archivage est exécutée sous l'identité de l'utilisateur
  propriétaire du serveur <productname>PostgreSQL</productname>. La série de
  fichiers WAL en cours d'archivage contient absolument tout ce qui se
  trouve dans la base de données, il convient donc de s'assurer que les
  données archivées sont protégées des autres utilisateurs&nbsp;; on peut,
  par exemple, archiver dans un répertoire sur lequel les droits de lecture
  ne sont positionnés ni pour le groupe ni pour le reste du monde.
 </para>

 <para>
  Il est important que la commande d'archivage ne renvoie le code de sortie
  zéro que si, et seulement si, l'exécution a réussi. En obtenant un résultat
  zéro, <productname>PostgreSQL</productname> suppose que le fichier segment WAL a
  été archivé avec succès et qu'il peut le supprimer ou le recycler.
  Un statut différent de zéro indique à
  <productname>PostgreSQL</productname> que le fichier n'a pas été archivé&nbsp;; il
  essaie alors périodiquement jusqu'à la réussite de l'archivage.
 </para>

 <para>
  La commande d'archivage doit, en général, être conçue pour refuser
  d'écraser tout fichier archive qui existe déjà. C'est une fonctionnalité
  de sécurité importante pour préserver l'intégrité de l'archive dans le
  cas d'une erreur de l'administrateur (comme l'envoi de la sortie de deux
  serveurs différents dans le même répertoire d'archivage).
 </para>

 <para>
  Il est conseillé de tester la commande d'archivage proposée pour
  s'assurer, qu'en effet, elle n'écrase pas un fichier existant, <emphasis>et
   qu'elle retourne un statut différent de zéro dans ce cas</emphasis>.
  La commande pour Unix en exemple ci-dessus le garantit en incluant
  une étape <command>test</command> séparée. Sur certaines plateformes
  Unix, la commande <command>cp</command> dispose d'une option, comme
  <option>-i</option> pouvant être utilisé pour faire la même chose,
  mais en moins verbeux. Cependant, vous ne devriez pas vous baser
  là-dessus sans vous assurer que le code de sortie renvoyé est le bon.
  (En particulier, la commande <command>cp</command> de GNU renvoie
  un code zéro quand <option>-i</option> est utilisé et que le fichier
  cible existe déjà, ce qui n'est <emphasis>pas</emphasis> le
  comportement désiré.)
 </para>

 <para>
  Lors de la conception de la configuration d'archivage, il faut
  considérer ce qui peut se produire si la commande d'archivage échoue de façon
  répétée, que ce soit parce qu'une intervention de l'opérateur s'avère nécessaire ou
  par manque d'espace dans le répertoire d'archivage.
  Ceci peut arriver, par exemple, lors de l'écriture sur une cartouche sans changeur
  automatique&nbsp;; quand la cartouche est pleine, rien ne peut être
  archivé tant que la cassette n'est pas changée.
  Toute erreur ou requête à un opérateur humain doit être rapportée de façon
  appropriée pour que la situation puisse être résolue
  rapidement. Le répertoire <filename>pg_wal/</filename> continue à se remplir
  de fichiers de segment WAL jusqu'à la résolution de la situation.
  (Si le système de fichiers contenant <filename>pg_wal/</filename> se
  remplit, <productname>PostgreSQL</productname> s'arrête en mode PANIC.
  Aucune transaction validée n'est perdue mais la base de données est
  inaccessible tant que de l'espace n'a pas été libéré.)
 </para>

 <para>
  La vitesse de la commande d'archivage n'est pas importante, tant qu'elle
  suit le rythme de génération des données WAL du serveur. Les
  opérations normales continuent même si le processus d'archivage est un peu
  plus lent. Si l'archivage est significativement plus lent, alors la
  quantité de données qui peut être perdue croît. Cela signifie
  aussi que le répertoire <filename>pg_wal/</filename> contient un grand nombre
  de fichiers segment non archivés, qui peuvent finir par
  dépasser l'espace disque disponible. Il est conseillé de surveiller
  le processus d'archivage pour s'assurer que tout fonctionne
  normalement.
 </para>

 <para>
  Lors de l'écriture de la commande d'archivage, il faut garder à l'esprit que les
  noms de fichier à archiver peuvent contenir jusqu'à 64 caractères et
  être composés de toute combinaison de lettres ASCII, de chiffres et de points.
  Il n'est pas nécessaire de conserver le chemin relatif original
  (<literal>%p</literal>) mais il est nécessaire de se rappeler du nom du fichier
  (<literal>%f</literal>).
 </para>

 <para>
  Bien que l'archivage WAL autorise à restaurer toute
  modification réalisée sur les données de la base, il ne restaure pas les modifications
  effectuées sur les fichiers de configuration (c'est-à-dire
  <filename>postgresql.conf</filename>, <filename>pg_hba.conf</filename> et
  <filename>pg_ident.conf</filename>) car ceux-ci sont édités manuellement
  et non au travers d'opérations SQL. Il est souhaitable de conserver les
  fichiers de configuration à un endroit où ils sont sauvegardés par les
  procédures standard de sauvegarde du système de fichiers. Voir la
  <xref linkend="runtime-config-file-locations"/> pour savoir comment
  modifier l'emplacement des fichiers de configuration.
 </para>

 <para>
  La commande d'archivage n'est appelée que sur les segments WAL complets.
  Du coup, si le serveur engendre peu de trafic WAL (ou qu'il y a des périodes
  de calme où le trafic WAL est léger), il peut y avoir un long délai
  entre la fin d'une transaction et son enregistrement sûr dans le stockage
  d'archive. Pour placer une limite sur l'ancienneté des données archivées,
  on configure <xref linkend="guc-archive-timeout"/> qui force le
  serveur à changer de fichier segment WAL passé ce délai. Les
  fichiers archivés lors d'un tel forçage ont toujours
  la même taille que les fichiers complets. Il est donc déconseillé de configurer
  un délai <varname>archive_timeout</varname> trop court &mdash; cela fait
  grossir anormalement le stockage. Une minute pour <varname>archive_timeout</varname>
  est généralement raisonnable.
 </para>

 <para>
  De plus, le changement d'un segment peut être forcé manuellement avec
  <function>pg_switch_wal</function>. Cela permet de s'assurer qu'une
  transaction tout juste terminée est archivée aussi vite que possible.
  D'autres fonctions utilitaires relatives à la gestion des WAL sont
  disponibles dans <xref linkend="functions-admin-backup-table"/>.
 </para>

 <para>
  Quand <varname>wal_level</varname> est configuré à
  <literal>minimal</literal>, certaines commandes SQL sont optimisées pour
  éviter la journalisation des transactions, de la façon décrite dans
  <xref linkend="populate-pitr"/>. Si l'archivage ou la réplication en flux
  sont activés lors de
  l'exécution d'une de ces instructions, les journaux de transaction ne
  contiennent pas suffisamment d'informations pour une récupération via les
  archives. (La récupération après un arrêt brutal n'est pas affectée.)
  Pour cette raison, <varname>wal_level</varname> ne peut être
  modifié qu'au lancement du serveur. Néanmoins,
  <varname>archive_command</varname> peut être modifié par
  rechargement du fichier de configuration. Pour arrêter
  temporairement l'archivage, on peut placer une
  chaîne vide (<literal>''</literal>) pour
  <varname>archive_command</varname>. Les journaux de transaction sont alors
  accumulés dans <filename>pg_wal/</filename> jusqu'au rétablissement
  d'un paramètre <varname>archive_command</varname> fonctionnel.
 </para>
</sect2>

<sect2 id="backup-base-backup">
 <title>Réaliser une sauvegarde de base</title>

 <para>
  La manière la plus simple pour effectuer une sauvegarde d'utiliser l'outil
  <xref linkend="app-pgbasebackup"/>. Il peut créer une sauvegarde de base
  soit sous la forme de fichiers standards, soit dans une archive tar. Pour
  les cas plus complexes, il est possible de réaliser une sauvegarde de base
  en utilisant l'API bas niveau (voir <xref linkend="backup-lowlevel-base-backup"/>).
 </para>

 <para>
  La durée d'une sauvegarde de base n'est pas toujours un critère déterminant. Toutefois,
  si vous exploitez votre serveur avec l'option  <varname>full_page_writes</varname>
  désactivée, vous constaterez une baisse des performances lorsque la sauvegarde
  est effectuée car l'option <varname>full_page_writes</varname> est
  activée de force pendant les opérations de sauvegarde.
 </para>

 <para>
  Pour utiliser une sauvegarde, vous devez conserver tous les segments WAL générés
  pendant et après la sauvegarde des fichiers. Pour vous aider dans cette tâche,
  le processus de sauvegarde crée un <firstterm>fichier historique de
   sauvegarde</firstterm> qui est immédiatement enregistré dans la zone
  d'archivage des WAL. Le nom de ce fichier reprend le nom du premier fichier
  WAL que vous devez conserver. Par exemple, si le premier fichier WAL à garder
  est <literal>0000000100001234000055CD</literal>, alors le fichier
  historique de sauvegarde sera nommé de la manière suivante
  <literal>0000000100001234000055CD.007C9330.backup</literal>. (La seconde
  partie du nom de fichier indique la position exacte à l'intérieur du fichier
  WAL. Cette information peut être ignorée). Une fois que vous avez
  archivé avec précaution la sauvegarde de base et les fichiers WAL générés
  pendant la sauvegarde (tel qu'indiqué par le fichier historique de sauvegarde),
  tous les fichiers WAL antérieurs ne sont plus nécessaires pour restaurer
  votre sauvegarde de base. Ils peuvent être supprimés. Toutefois il est conseillé
  de conserver plusieurs groupes de sauvegardes pour être absolument certain de
  récupérer vos données.
 </para>

 <para>
  Le fichier historique de sauvegarde est un simple fichier texte. Il
  contient le label que vous avez attribué à l'opération <xref linkend="app-pgbasebackup"/>,
  ainsi que les dates de début, de fin et la liste des segments WAL de
  la sauvegarde. Si vous avez utilisé le label pour identifier le
  fichier de sauvegarde associé, alors le fichier historique vous permet
  de savoir quel fichier de sauvegarde vous devez utiliser pour la restauration.
 </para>

 <para>
  Puisque vous devez archiver tous les fichiers WAL depuis votre
  dernière sauvegarde de base, l'intervalle entre deux sauvegardes de base
  doit être déterminé en fonction de l'espace de stockage que vous
  avez alloué pour l'archivage des fichiers WAL. Vous devez également
  prendre en compte le temps de restauration (le système devra rejouer
  tous les segments WAL, cela prendra un certain temps si la
  sauvegarde de base est ancienne).
 </para>
</sect2>

<sect2 id="backup-lowlevel-base-backup">
 <title>Effectuer une sauvegarde de base avec l'API bas niveau</title>
 <para>
  La procédure pour créer une sauvegarde de base en utilisant
  l'API bas niveau contient plus d'étapes que la méthode
  <xref linkend="app-pgbasebackup"/> mais elle est relativement
  simple. Il est très important que ces étapes soit exécutées
  séquentiellement et de vérifier que chaque étape s'est
  déroulée correctement avant de passer à la suivante.
 </para>
 <para>
  Les sauvegardes bas niveau peuvent être réalisées de façon exclusive ou
  non-exclusive. La méthode non-exclusive est recommandée alors que l'exclusive
  est obsolète et sera à la longue supprimée.
 </para>
 <sect3 id="backup-lowlevel-base-backup-nonexclusive">
  <title>Créer une sauvegarde non-exclusive bas niveau</title>
  <para>
   Une sauvegarde non-exclusive bas niveau permet à d'autres
   sauvegardes concurrentes d'être lancées (à la fois celles
   utilisant la même API et celles utilisant
   <xref linkend="app-pgbasebackup"/>).
  </para>
  <para>
   <orderedlist>
    <listitem>
     <para>
      S'assurer que l'archivage WAL est activé et fonctionnel.
     </para>
    </listitem>
    <listitem>
     <para>
      Se connecter au serveur (peu importe la base) en tant qu'utilisateur
      ayant les droits d'exécuter pg_start_backup (superutilisateur, ou un utilisateur
      ayant été autorisé à EXECUTE la fonction) et lancer la commande :
      <programlisting>
SELECT pg_start_backup('label', false, false);
      </programlisting>
      où <literal>label</literal> est une chaîne utilisée pour identifier de
      façon unique l'opération de sauvegarde. La connexion
      appelant <function>pg_start_backup</function> doit être maintenue jusqu'à la fin de
      la sauvegarde, ou la sauvegarde sera automatiquement avortée.
     </para>

     <para>
      Par défaut, <function>pg_start_backup</function>  peut prendre beaucoup de temps
      pour arriver à son terme.
      Ceci est dû au fait qu'il réalise un
      point de vérification (<foreignphrase>checkpoint</foreignphrase>),
      et que les entrées/sorties pour l'établissement
      de ce point de vérification seront réparties sur une grande durée,
      par défaut la moitié de l'intervalle entre deux points de
      vérification (voir le paramètre de configuration
      <xref linkend="guc-checkpoint-completion-target"/>). Habituellement,
      ce comportement est appréciable, car il minimise l'impact du traitement
      des requêtes. Pour commencer la sauvegarde dès que possible, changer le
      second paramètre à <literal>true</literal>, ce qui exécutera un
      checkpoint immédiat en utilisant autant d'entrées/sorties disque que
      disponible.
     </para>

     <para>
      Le troisième paramètre étant <literal>false</literal> signifie que
      <function>pg_start_backup</function> initiera une sauvegarde de base non-exclusive.
     </para>
    </listitem>
    <listitem>
     <para>
      Effectuer la sauvegarde à l'aide de tout outil de sauvegarde du
      système de fichiers, tel <application>tar</application> ou
      <application>cpio</application> (mais ni
      <application>pg_dump</application> ni
      <application>pg_dumpall</application>). Il
      n'est ni nécessaire ni désirable de stopper les opérations normales de
      la base de données pour cela. Voir la section
      <xref linkend="backup-lowlevel-base-backup-data"/> pour les considérations à
      prendre en compte durant cette sauvegarde.
     </para>
    </listitem>
    <listitem>
     <para>
      Dans la même connexion que précédemment, lancer la commande :
      <programlisting>
SELECT * FROM pg_stop_backup(false, true);
      </programlisting>
      Cela met fin au processus de sauvegarde. Sur un serveur primaire, cela
      réalise aussi une bascule automatique au prochain segment de journal de
      transactions. Sur un serveur secondaire (standby), il n'est pas possible
      de basculer automatiquement les segments des journaux de transactions,
      donc vous pourriez vouloir utiliser <function>pg_switch_wal</function>
      sur le primaire pour réaliser une bascule manuelle. Cette bascule est
      nécessaire pour permettre au dernier fichier de segment WAL écrit pendant
      la sauvegarde d'être immédiatement archivable.
     </para>
     <para>
      La fonction <function>pg_stop_backup</function> retournera une ligne avec
      trois valeurs. Le second de ces champs devrait être écrit dans un fichier
      nommé <filename>backup_label</filename> dans le répertoire racine de la
      sauvegarde. Le troisième champ devrait être écrit dans un fichier nommé
      <filename>tablespace_map</filename> sauf si le champ est vide. Ces
      fichiers sont vitaux pour le fonctionnement de la sauvegarde et doivent
      être écrits sans modification.
     </para>
    </listitem>
    <listitem>
     <para>
      Une fois que les fichiers de segment WAL utilisés lors de la sauvegarde
      sont archivés, c'est terminé. Le fichier identifié par le résultat de
      <function>pg_stop_backup</function> est le dernier segment nécessaire
      pour produire un jeu complet de fichiers de sauvegarde. Sur un serveur
      primaire, si <varname>archive_mode</varname> est activé et que le
      paramètre <literal>wait_for_archive</literal> est activé (valeur
      <literal>true</literal>), <function>pg_stop_backup</function> ne rend pas
      la main avant que le dernier segment n'ait été archivé. Sur un standby,
      le paramètre <varname>archive_mode</varname> doit valoir
      <literal>always</literal> pour que la fonction
      <function>pg_stop_backup</function> attende. L'archivage de ces fichiers
      est automatique puisque
      <varname>archive_command</varname> est déjà configuré. Dans la plupart des
      cas, c'est rapide, mais il est conseillé de surveiller le système d'archivage pour
      s'assurer qu'il n'y a pas de retard. Si le processus d'archivage a pris du retard
      en raison d'échecs de la commande d'archivage, il continuera d'essayer jusqu'à ce que
      l'archivage réussisse et que la sauvegarde soit complète. Pour
      positionner une limite au temps d'exécution de <function>pg_stop_backup</function>,
      il faut positionner <varname>statement_timeout</varname> à une valeur
      appropriée, mais il faut noter que si
      <function>pg_stop_backup</function> est interrompu à cause de cette configuration, la sauvegarde
      peut ne pas être correcte.
     </para>
     <para>
      Si le processus de sauvegarde surveille et s'assure que tous les fichiers
      de segment WAL nécessaires à la sauvegarde soient archivés avec succès,
      le paramètre <literal>wait_for_archive</literal> (positionné à true par
      défaut), peut être positionné à
      false pour que <function>pg_stop_backup</function> renvoie la main dès que
      l'enregistrement de fin de sauvegarde est écrit dans le WAL.  Par défaut,
      <function>pg_stop_backup</function> attendra jusqu'à ce que tous les WAL
      aient été archivés, ce qui peut prendre un certain temps.  Cette option
      doit être utilisée avec précaution : si l'archivage des WAL n'est pas
      supervisé correctement, alors la sauvegarde pourrait ne pas inclure tous
      les fichiers WAL et serait donc incomplète et impossible à restaurer.
     </para>
    </listitem>
   </orderedlist>
  </para>
 </sect3>
 <sect3 id="backup-lowlevel-base-backup-exclusive">
  <title>Créer une sauvegarde exclusive de bas niveau</title>

  <note>
   <para>
    La méthode de sauvegarde exclusive est obsolète et devrait être évitée.
    Avant <productname>PostgreSQL</productname> 9.6, il s'agissait de la
    seule méthode bas-niveau disponible, mais il est désormais recommandé
    que tous les utilisateurs mettent à jour leurs scripts pour utiliser la
    sauvegarde non-exclusive.
   </para>
  </note>

  <para>
   Le procédé pour une sauvegarde exclusive est majoritairement le même que
   pour la non-exclusive, mais il diffère en quelques étapes clés. Ce type
   de sauvegarde peut seulement être réalisé sur un serveur primaire et ne
   permet pas des sauvegardes concurrentes. De plus, le fichier backup_label
   créé sur un serveur primaire peut empêcher le redémarrage de celui-ci en
   cas de crash. D'un autre côté, la suppression à tord de ce fichier
   d'une sauvegarde ou d'un serveur secondaire est une erreur
   fréquente qui peut mener à de sérieuses corruptions de données. S'il
   était nécessaire d'utiliser cette méthode, les étapes suivantes doivent
   être respectées.
  </para>
  <para>
   <orderedlist>
    <listitem>
     <para>
      S'assurer que l'archivage des WAL est activé et fonctionnel.
     </para>
    </listitem>
    <listitem>
     <para>
      Se connecter au serveur (peu importe la base) en tant qu'utilisateur
      ayant les droits d'exécuter pg_start_backup (superutilisateur, ou un utilisateur
      ayant le droit EXECUTE sur cette fonction) et lancer la commande&nbsp;:
      <programlisting>SELECT pg_start_backup('label');</programlisting>
     où <literal>label</literal> est une chaîne utilisée pour identifier de
     façon unique l'opération de sauvegarde.
     <function>pg_start_backup</function> crée un fichier <firstterm>de label
     de sauvegarde</firstterm> nommé <filename>backup_label</filename> dans le
     répertoire du cluster. Ce fichier contient les informations de la
     sauvegarde, ceci incluant le moment du démarrage et le label. La fonction
     crée aussi un fichier <firstterm>tablespace map</firstterm>, appelé
     <filename>tablespace_map</filename>, dans le répertoire principal des
     données avec des informations sur les liens symboliques des tablespaces
     contenus dans <filename>pg_tblspc</filename> si au moins un lien est
     présent. Ces fichiers sont critiques à l'intégrité de la sauvegarde, vous
     devez vous assurer de leur restauration.
    </para>

    <para>
     Par défaut, <function>pg_start_backup</function> peut prendre beaucoup de temps
     pour arriver à son terme. Ceci est dû au fait qu'il réalise un
     point de vérification (<foreignphrase>checkpoint</foreignphrase>),
     et que les entrées/sorties pour l'établissement
     de ce point de vérification seront réparties sur une grande durée,
     par défaut la moitié de l'intervalle entre deux points de
     vérification (voir le paramètre de configuration
     <xref linkend="guc-checkpoint-completion-target"/>). Habituellement,
     ce comportement est appréciable, car il minimise l'impact du traitement
     des requêtes. Pour commencer la sauvegarde aussi rapidement
     que possible, utiliser&nbsp;:
<programlisting>
SELECT pg_start_backup('label', true);
      </programlisting>
      Cela force l'exécution du point de vérification aussi rapidement que possible.
     </para>
    </listitem>
    <listitem>
     <para>
      Effectuer la sauvegarde à l'aide de tout outil de sauvegarde du
      système de fichiers, tel <application>tar</application> ou
      <application>cpio</application> (mais ni
      <application>pg_dump</application> ni
      <application>pg_dumpall</application>). Il
      n'est ni nécessaire ni désirable de stopper les opérations normales de
      la base de données pour cela.  Voir la section
      <xref linkend="backup-lowlevel-base-backup-data"/> pour les considérations à
      prendre en compte durant cette sauvegarde.
     </para>
     <para>
      Comme il est déjà indiqué ci-dessus, si le serveur s'arrête brutalement
      lors de la sauvegarde, il pourrait ne pas être possible de recommencer
      tant que le fichier <filename>backup_label</filename> ne soit manuellement
      supprimée du répertoire <envar>PGDATA</envar>. Il est très important de
      ne jamais supprimer le fichier <filename>backup_label</filename> lors de
      la restauration d'une sauvegarde afin d'éviter toute corruption. La
      confusion concernant les cas d'usage où il est approprié de supprimer
      ce fichier est une cause fréquente de corruption de données lors de
      l'utilisation de cette méthode de sauvegarde&nbsp;; il faut s'assurer de ne
      supprimer ce fichier que sur un serveur primaire fonctionnel et jamais
      lors de la construction d'un serveur secondaire ou lors de la
      restauration d'une sauvegarde, même lors de la construction d'un serveur
      secondaire qui sera par la suite promu comme nouveau serveur primaire.
     </para>
    </listitem>
    <listitem>
     <para>
      Se connecter à nouveau à la base de données en tant qu'utilisateur ayant
      le droit d'exécuter pg_stop_backup (superutilisateur, ou un utilisateur
      ayant le droit EXECUTE sur cette fonction) et lancer la commande&nbsp;:
      <programlisting>SELECT pg_stop_backup();</programlisting>. Cette fonction
     met fin au processus de sauvegarde et réalise une bascule automatique
     vers le prochain segment WAL. Cette bascule est nécessaire pour permettre
     au dernier fichier de segment WAL écrit pendant la sauvegarde d'être
     immédiatement archivable.
    </para>
   </listitem>
   <listitem>
    <para>
     Une fois que les fichiers des segments WAL utilisés lors de la sauvegarde
     sont archivés, c'est terminé. Le fichier identifié par le résultat de
     <function>pg_stop_backup</function> est le dernier segment nécessaire pour produire
     un jeu complet de fichiers de sauvegarde.
     Si <varname>archive_mode</varname> est activé,
     <function>pg_stop_backup</function> ne rend pas la main avant que le dernier segment
     n'ait été archivé. L'archivage de ces fichiers est automatique puisque
     <varname>archive_command</varname> est configuré. Dans la plupart des
     cas, c'est rapide, mais il est conseillé de surveiller le système d'archivage pour
     s'assurer qu'il n'y a pas de retard. Si le processus d'archivage a pris du retard
     en raison d'échecs de la commande d'archivage, il continuera d'essayer jusqu'à ce que
     l'archive réussisse et que la sauvegarde soit complète.
    </para>

    <para>
     Lors de l'utilisation de la méthode de sauvegarde exclusive, il est
     absolument impératif de s'assurer que <function>pg_stop_backup</function>
     se termine correctement à la fin de la sauvegarde. Même si la sauvegarde
     elle-même échoue, par exemple à cause d'un manque d'espace disque, ne pas
     exécuter <function>pg_stop_backup</function> laisse le serveur en mode
     sauvegarde indéfiniment, empêchant la réalisation des futures sauvegardes
     et augmentant le risque que le serveur ne puisse pas redémarrer lorsque
     le fichier <filename>backup_label</filename> existe.
    </para>
   </listitem>
  </orderedlist>
    </para>
   </sect3>
   <sect3 id="backup-lowlevel-base-backup-data">
   <title>Sauvegarder le répertoire de données</title>

   <para>
    Certains outils de sauvegarde de fichiers émettent des
    messages d'avertissement ou d'erreur si les fichiers qu'ils essaient de
    copier sont modifiés au cours de la copie. Cette situation, normale lors
    de la sauvegarde d'une base active, ne doit pas être considérée comme
    une erreur&nbsp;; il suffit de s'assurer que ces messages puissent être
    distingués des autres messages. Certaines versions de
    <application>rsync</application>, par exemple, renvoient un code de sortie
    distinct en cas de <quote>disparition de fichiers source</quote>. Il est
    possible d'écrire un script qui considère ce code de sortie comme normal.
   </para>

   <para>
    De plus, certaines versions de GNU <application>tar</application>
    retournent un code d'erreur qu'on peut confondre avec une erreur fatale si
    le fichier a été tronqué pendant sa copie par
    <application>tar</application>. Heureusement, les versions 1.16 et
    suivantes de GNU <application>tar</application> retournent 1 si le fichier
    a été modifié pendant la sauvegarde et 2 pour les autres erreurs. Avec GNU
    <application>tar</application> version 1.23 et les versions ultérieures,
    vous pouvez utiliser les options d'avertissement <literal>--warning=no-file-changed
    --warning=no-file-removed</literal> pour cacher les messages d'avertissement
    en relation.
   </para>

   <para>
    La sauvegarde doit inclure tous les fichiers du répertoire
    du groupe de bases de données
    (<filename>/usr/local/pgsql/data</filename>, par exemple). Si des
    <foreignphrase>tablespaces</foreignphrase>
    qui ne se trouvent pas dans ce répertoire sont utilisés, il ne faut pas
    oublier de les inclure (et s'assurer également que la sauvegarde archive les liens
    symboliques comme des liens, sans quoi la restauration va corrompre les
    <foreignphrase>tablespaces</foreignphrase>).
   </para>

   <para>
    Néanmoins, les fichiers du sous-répertoire
    <filename>pg_wal/</filename>,
    contenu dans le répertoire du cluster, devraient être omis. Ce léger
    ajustement permet de réduire le risque d'erreurs lors de la restauration.
    C'est facile à réaliser si <filename>pg_wal/</filename> est un lien
    symbolique vers quelque endroit extérieur au répertoire du cluster,
    ce qui est toutefois une configuration courante, pour des raisons de
    performance. Il peut être intéressant d'exclure <filename>postmaster.pid</filename>
    et <filename>postmaster.opts</filename>, qui enregistrent des
    informations sur le <application>postmaster</application> en cours
    d'exécution, mais pas sur le <application>postmaster</application>
    qui va utiliser cette sauvegarde. De plus, ces fichiers peuvent poser
    problème à <application>pg_ctl</application>.
   </para>

   <para>
    C'est souvent une bonne idée d'omettre de la sauvegarde les fichiers provenant
    du répertoire <filename>pg_replslot/</filename> de l'instance, pour que les
    slots de réplication existant sur le maître ne deviennent pas partie intégrante
    de la sauvegarde. Dans le cas contraire, l'utilisation de la sauvegarde pour
    créer un esclave pourrait résulter en une rétention infinie des journaux de
    transactions sur l'esclave et aussi de la fragmentation sur le maître si les
    messages retour d'un esclave en Hot Standby sont activés, parce que les clients
    qui utilisent ces slots de réplication se connecteront toujours et mettront à
    jour les slots sur le maître et non pas sur l'esclave. Même si la sauvegarde a
    pour but d'être utilisée pour la création d'un nouveau maître, copier les slots
    de réplication n'est pas un comportement attendu car il n'a pas de raison d'être,
    le contenu de ces slots sera très probablement obsolète au moment où le nouveau
    maître sera en ligne.
   </para>

   <para>
    Le contenu des répertoires <filename>pg_dynshmem/</filename>,
    <filename>pg_notify/</filename>, <filename>pg_serial/</filename>,
    <filename>pg_snapshots/</filename>, <filename>pg_stat_tmp/</filename>, et
    <filename>pg_subtrans/</filename> (mais pas les répertoires eux-même)
    peuvent être exclu de la sauvegarde puisqu'ils seront réinitialisés au
    démarrage du postmaster. Si <xref linkend="guc-stats-temp-directory"/> est
    positionné et qu'il pointe sur un sous répertoire du répertoire de données
    alors le contenu de ce répertoire peut également être exclu.
   </para>

   <para>
    N'importe quel fichier ou répertoire commençant par
    <filename>pgsql_tmp</filename> peut être exclu de la sauvegarde. Ces
    fichiers sont supprimés au démarrage du postmaster et les répertoires seront
    recréés si nécessaire.
   </para>

   <para>
    Les fichiers <filename>pg_internal.init</filename> peuvent être omis de la
    sauvegarde quand un fichier de ce nom est trouvé. Ces fichiers contiennent
    les données de cache des relations qui est toujours reconstruit lors de
    la restauration.
   </para>

   <para>
    Le fichier de label de la sauvegarde inclut la
    chaîne de label passée à <function>pg_start_backup</function>, l'heure à
    laquelle <function>pg_start_backup</function> a été exécutée et le nom du
    fichier WAL initial. En cas de confusion, il est ainsi possible de
    regarder dans ce fichier de label et de déterminer avec précision de
    quelle session de sauvegarde il provient. Le fichier des
    tablespaces inclut les noms des liens symboliques s'ils existent dans le
    répertoire <filename>pg_tblspc/</filename> et le chemin complet de chaque
    lien symbolique. Néanmoins, ces fichiers n'existent pas uniquement pour
    vous informer. Leurs présences et contenus sont critiques au bon
    déroulement du processus de restauration.
   </para>

   <para>
    Il est aussi possible de faire une sauvegarde alors que le serveur est
    arrêté. Dans ce cas, <function>pg_start_backup</function> et
    <function>pg_stop_backup</function> ne peuvent pas être
    utilisées. L'utilisateur doit alors se débrouiller pour identifier les
    fichiers de sauvegarde et déterminer jusqu'où remonter avec les fichiers
    WAL associés. Il est généralement préférable de
    suivre la procédure d'archivage continu décrite ci-dessus.
   </para>
   </sect3>
  </sect2>

  <sect2 id="backup-pitr-recovery">
   <title>Récupération à partir d'un archivage continu</title>

   <para>
    Le pire est arrivé et il faut maintenant repartir d'une sauvegarde.
    Voici la procédure&nbsp;:
  <orderedlist>
   <listitem>
    <para>
     Arrêter le serveur s'il est en cours d'exécution.
    </para>
   </listitem>
   <listitem>
    <para>
     Si la place nécessaire est disponible, copier le répertoire complet de
     données du cluster et tous les <foreignphrase>tablespaces</foreignphrase>
     dans un emplacement temporaire en prévision d'un éventuel besoin
     ultérieur. Cette précaution nécessite qu'un espace suffisant sur le
     système soit disponible pour contenir deux copies de la base de données
     existante. S'il n'y a pas assez de place disponible, il faut au minimum
     copier le contenu du sous-répertoire <filename>pg_wal</filename> du
     répertoire des données du cluster car il peut contenir des journaux
     qui n'ont pas été archivés avant l'arrêt du serveur.
    </para>
   </listitem>
   <listitem>
    <para>
     Effacer tous les fichiers et sous-répertoires existant sous le
     répertoire des données du cluster et sous les répertoires racines des
     <foreignphrase>tablespaces</foreignphrase>.
    </para>
   </listitem>
   <listitem>
    <para>
     Restaurer les fichiers de la base de données à partir de la
     sauvegarde des fichiers. Il faut veiller à ce qu'ils soient restaurés avec le bon
     propriétaire (l'utilisateur système de la base de données, et non pas
     <literal>root</literal>&nbsp;!) et avec les bons droits. Si des
     <foreignphrase>tablespaces</foreignphrase> sont utilisés, il faut
     s'assurer que les liens symboliques dans
     <filename>pg_tblspc/</filename> ont été correctement restaurés.
    </para>
   </listitem>
   <listitem>
    <para>
     Supprimer tout fichier présent dans <filename>pg_wal/</filename>&nbsp;;
     ils proviennent de la sauvegarde et sont du coup probablement obsolètes.
     Si <filename>pg_wal/</filename> n'a pas été archivé, il suffit de
     recréer ce répertoire en faisant attention à le créer en tant que
     lien symbolique, si c'était le cas auparavant.
    </para>
   </listitem>
   <listitem>
    <para>
     Si des fichiers de segment WAL non archivés ont été sauvegardés dans
     l'étape 2, les copier dans <filename>pg_wal/</filename>. Il
     est préférable de les copier plutôt que de les déplacer afin qu'une
     version non modifiée de ces fichiers soit toujours disponible si un
     problème survient et qu'il faille recommencer.
    </para>
   </listitem>
   <listitem>
    <para>
     Configurer les commandes de récupération dans <filename>postgresql.conf</filename>
     (voir <xref linkend="runtime-config-wal-archive-recovery"/>) et créer un
     fichier <filename>recovery.signal</filename> dans le répertoire des
     données du cluster. Il peut, de
     plus, être judicieux de modifier temporairement le fichier
     <filename>pg_hba.conf</filename> pour empêcher les utilisateurs
     ordinaires de se connecter tant qu'il n'est pas certain que la
     récupération a réussi.
    </para>
   </listitem>
   <listitem>
    <para>
     Démarrer le serveur. Le serveur se trouve alors en mode récupération et
     commence la lecture des fichiers WAL archivés dont il a besoin. Si la
     récupération se termine sur une erreur externe, le serveur peut tout
     simplement être relancé. Il continue alors la récupération. À la
     fin du processus de récupération, le serveur supprime le fichier
     <filename>recovery.signal</filename>
     (pour éviter de retourner accidentellement en mode de récupération), puis
     passe en mode de fonctionnement normal.
    </para>
   </listitem>
   <listitem>
    <para>
     Inspecter le contenu de la base de données pour s'assurer que la
     récupération a bien fonctionné. Dans le cas contraire, retourner
     à l'étape 1. Si tout va bien, le fichier <filename>pg_hba.conf</filename>
     peut-être restauré pour autoriser les utilisateurs à se reconnecter.
    </para>
   </listitem>
  </orderedlist>
   </para>

     <para>
      Le point clé de tout ceci est la configuration de la restauration qui
      décrit comment et jusqu'où récupérer. La seule chose qu'il faut absolument préciser dans
      <filename>postgresql.conf</filename>, c'est <varname>restore_command</varname>
      qui indique à <productname>PostgreSQL</productname> comment récupérer les
      fichiers de segment WAL archivés. À l'instar
      d'<varname>archive_command</varname>, c'est une chaîne de commande
      shell. Elle peut contenir <literal>%f</literal>, qui est
      remplacé par le nom du journal souhaité, et <literal>%p</literal>, qui est
      remplacé par le chemin du répertoire où copier le journal.
      (Le nom du chemin est relatif au répertoire de travail du serveur,
      c'est-à-dire le répertoire des données du cluster.) Pour écrire le
      caractère <literal>%</literal> dans la commande, on utilise
      <literal>%%</literal>. La commande la plus simple ressemble à&nbsp;:
      <programlisting>restore_command = 'cp /mnt/serveur/répertoire_archive/%f %p'</programlisting>
    qui copie les segments WAL précédemment archivés à partir du répertoire
    <filename>/mnt/serveur/répertoire_archive</filename>.  Il est toujours
    possible d'utiliser une commande plus compliquée, voire même un script shell
    qui demande à l'utilisateur de monter la cassette appropriée.
   </para>

   <para>
    Il est important que la commande retourne un code de sortie différent de
    zéro en cas d'échec. Des fichiers absents de l'archive
    <emphasis>seront</emphasis> demandés à la commande&nbsp;; elle doit
    renvoyer autre chose que zéro dans ce cas. Ce n'est pas une condition
    d'erreur. Une exception est possible si la commande a été terminée par un
    signal (autre que <systemitem>SIGTERM</systemitem>, qui est utilisé pour
    l'arrêt du serveur) ou si une erreur shell (comme une commande introuvable).
    Dans ces cas, la restauration va s'arrêter et le serveur ne démarrera plus.
   </para>

   <para>
    Tous les fichiers demandés ne seront pas des segments WAL&nbsp;; vous
    pouvez aussi vous attendre à des demandes de fichiers suffixés par
    <literal>.history</literal>. Il faut également
    garder à l'esprit que le nom de base du chemin <literal>%p</literal>
    diffère de <literal>%f</literal>&nbsp;; ils ne sont pas interchangeables.
   </para>

   <para>
    Les segments WAL qui ne se trouvent pas dans l'archive sont
    recherchés dans <filename>pg_wal/</filename>&nbsp;; cela autorise l'utilisation
    de segments récents non archivés. Néanmoins, les segments disponibles
    dans l'archive sont utilisés de préférence aux fichiers contenus dans
    <filename>pg_wal/</filename>.
   </para>

   <para>
    Normalement, la récupération traite tous les segments WAL disponibles,
    restaurant du coup la base de données à l'instant présent (ou aussi proche
    que possible, en fonction des segments WAL disponibles). Une
    récupération normale se finit avec un message <quote>fichier non
    trouvé</quote>, le texte exact du message d'erreur dépendant du
    choix de <varname>restore_command</varname>. Un message d'erreur au
    début de la récupération peut également apparaître concernant un fichier nommé
    dont le nom ressemble à <filename>00000001.history</filename>. Ceci est aussi normal et
    n'indique pas un problème dans les situations de récupération habituelles. Voir
    <xref linkend="backup-timelines"/> pour plus d'informations.
   </para>

   <para>
    Pour récupérer à un moment précis (avant que le DBA junior n'ait supprimé
    la table principale), il suffit d'indiquer le <link
    linkend="runtime-config-wal-recovery-target">point d'arrêt</link> requis.
    Le point d'arrêt, aussi nommé
    <quote>recovery target</quote> (cible de récupération), peut être précisé
    par une combinaison date/heure, un point de récupération nommé ou par le
    dernier identifiant de transaction. Actuellement, seules les options
    date/heure et point de récupération nommé sont vraiment utilisables car il
    n'existe pas d'outils permettant d'identifier avec précision l'identifiant
    de transaction à utiliser.
   </para>

   <note>
     <para>
      Le point d'arrêt doit être postérieur à la fin de la sauvegarde
      de la base (le moment où <function>pg_stop_backup</function> se
      termine). Une sauvegarde ne peut pas être utilisée pour repartir d'un
      instant où elle était encore en cours (pour ce faire,
      il faut récupérer la sauvegarde précédente et rejouer à partir de là).
     </para>
    </note>

   <para>
    Si la récupération fait face à une corruption des données WAL,
    elle se termine à ce point et le serveur ne démarre pas. Dans un tel cas,
    le processus de récupération peut alors être ré-exécuté à partir du début
    en précisant une <quote>cible de récupération</quote> antérieure au point de
    récupération pour permettre à cette dernière de se terminer correctement.
    Si la récupération échoue pour une raison externe (arrêt brutal du système
    ou archive WAL devenue inaccessible), la récupération peut être
    simplement relancée. Elle redémarre alors quasiment là où elle a échoué.
    Le redémarrage de la restauration fonctionne comme les points de
    contrôle du déroulement normal&nbsp;: le serveur force une écriture
    régulière de son état sur les disques et actualise alors le fichier
    <filename>pg_control</filename> pour indiquer que les données WAL déjà
    traitées n'ont plus à être parcourues.
   </para>
  </sect2>

      <sect2 id="backup-timelines">
       <title>Lignes temporelles (<foreignphrase>Timelines</foreignphrase>)</title>

       <indexterm zone="backup">
        <primary>timelines</primary>
       </indexterm>

       <indexterm zone="backup">
        <primary>ligne temporelle</primary>
       </indexterm>

       <para>
        La possibilité de restaurer la base de données à partir d'un instantané
        crée une complexité digne des histoires de science-fiction traitant
        du voyage dans le temps et des univers parallèles.
       </para>
       <para>
        Par exemple, dans l'historique
        original de la base de données, supposez qu'une table critique ait été
        supprimée à 17h15 mardi soir, mais personne n'a réalisé cette erreur
        avant mercredi midi. Sans stress, la sauvegarde est récupérée
        et restaurée dans l'état où elle se trouvait à 17h14 mardi soir. La base
        est fonctionnelle. Dans <emphasis>cette</emphasis> histoire de l'univers de la base de
        données, la table n'a jamais été supprimée. Or, l'utilisateur
        réalise peu après que ce n'était pas une si grande idée et veut
        revenir à un quelconque moment du mercredi matin. Cela n'est pas possible,
        si, alors que la base de données est de nouveau fonctionnelle, elle
        réutilise certaines séquences de fichiers WAL qui permettent de
        retourner à ce point. Il est donc nécessaire de pouvoir distinguer les
        séries d'enregistrements WAL engendrées après la récupération de
        l'instantané de celles issues de l'historique originel de la base.
       </para>

       <para>
        Pour gérer ces difficultés, <productname>PostgreSQL</productname> inclut
        la notion de <firstterm>lignes temporelles</firstterm> (ou
        <foreignphrase>timelines</foreignphrase>). Quand une récupération
        d'archive est terminée, une nouvelle ligne temporelle est créée pour
        identifier la série d'enregistrements WAL produits après cette
        restauration. Le numéro d'identifiant de la timeline est inclus dans le
        nom des fichiers de segment WAL. De ce fait, une nouvelle timeline
        ne réécrit pas sur les données engendrées par des timelines précédentes.
        En fait, il est possible d'archiver plusieurs timelines différentes.
        Bien que cela semble être une fonctionnalité inutile, cela peut parfois
        sauver des vies. Dans une situation où l'instantané à récupérer n'est
        pas connu avec certitude, il va falloir tester les récupérations de
        différents instantanés jusqu'à trouver le meilleur.
        Sans les timelines, ce processus engendre vite un bazar ingérable.
        Avec les timelines, il est possible de récupérer
        <emphasis>n'importe quel</emphasis> état précédent, même les états de
        branches temporelles abandonnées.
       </para>

       <para>
        Chaque fois qu'une nouvelle timeline est créée,
        <productname>PostgreSQL</productname> crée un fichier
        d'<quote>historique des timelines</quote> qui indique à quelle timeline
        il est attaché, et depuis quand. Ces fichiers d'historique sont
        nécessaires pour permettre au système de choisir les bons fichiers de
        segment WAL lors de la récupération à partir d'une archive qui contient
        plusieurs timelines. Ils sont donc archivés comme tout fichier
        de segment WAL. Puisque ce sont de simples fichiers texte,
        il est peu coûteux et même judicieux de les conserver indéfiniment
        (contrairement aux fichiers de segment, volumineux). Il est possible
        d'ajouter des commentaires au fichier d'historique expliquant
        comment et pourquoi cette timeline a été créée. De tels commentaires
        s'avèrent précieux lorsque l'expérimentation conduit à de nombreuses
        timelines.
       </para>

       <para>
        Par défaut, la récupération s'effectue sur la timeline en vigueur au
        cours de la sauvegarde. Si l'on souhaite effectuer la récupération
        dans une timeline fille (c'est-à-dire retourner à un état enregistré
        après une tentative de récupération), il faut préciser l'identifiant de la timeline
        dans <xref linkend="guc-recovery-target-timeline"/>. Il n'est pas possible de
        récupérer dans des timelines antérieures à la sauvegarde.
       </para>
      </sect2>

      <sect2 id="backup-tips">
       <title>Conseils et exemples</title>

       <para>
        Quelques conseils de configuration de l'archivage continu sont donnés
        ici.
       </para>

       <sect3 id="backup-standalone">
        <title>Configuration de la récupération</title>

        <para>
         Il est possible d'utiliser les capacités de sauvegarde de
         <productname>PostgreSQL</productname>
         pour produire des sauvegardes autonomes à chaud. Ce sont des
         sauvegardes qui ne peuvent pas être utilisées pour la récupération
         à un instant donné, mais ce sont des sauvegardes qui sont typiquement
         plus rapide à obtenir et à restaurer que
         ceux issus de <application>pg_dump</application>. (Elles sont aussi bien
         plus volumineuses qu'un export <application>pg_dump</application>, il se
         peut donc que l'avantage de rapidité soit négatif.)
        </para>

        <para>
         Comme pour les sauvegarde de base, la manière la plus simple de
         créer une sauvegarde à chaud autonome est d'utiliser l'outil
         <xref linkend="app-pgbasebackup"/>. Si vous ajoutez le
         paramètre <literal>-X</literal> au lancement de la sauvegarde,
         tout l'historique de transaction ("transaction log") nécessaire
         sera inclus automatiquement dans la sauvegarde et vous n'aurez pas
         d'action supplémentaire à effectuer pour restaurer votre sauvegarde.
        </para>

        <para>
         Si vous avez besoin de plus de flexibilité pour copier les
         fichiers de sauvegarde, un processus bas niveau peut être utilisé
         pour les sauvegardes à chaud autonomes.
         En vue d'effectuer des sauvegardes à chaud autonomes, on positionne
         <varname>wal_level</varname> à
         <literal>replica</literal> ou supérieur,
         <varname>archive_mode</varname> à <literal>on</literal>, et on configure
         <varname>archive_command</varname> de telle sorte que l'archivage ne soit
         réalisé que lorsqu'un <emphasis>fichier de bascule</emphasis> existe. Par
         exemple&nbsp;:
         <programlisting>
archive_command = 'test ! -f /var/lib/pgsql/backup_in_progress || (test ! -f /var/lib/pgsql/archive/%f &amp;&amp; cp %p /var/lib/pgsql/archive/%f)'
      </programlisting>
      Cette commande réalise l'archivage dès lors que
      <filename>/var/lib/pgsql/backup_in_progress</filename> existe. Dans le
      cas contraire, elle
      renvoie silencieusement le code de statut zéro (permettant à
      <productname>PostgreSQL</productname> de recycler le journal de
      transactions non désiré).
     </para>

     <para>
      Avec cette préparation, une sauvegarde peut être prise en utilisant un
      script comme celui-ci&nbsp;:
      <programlisting>
touch /var/lib/pgsql/backup_in_progress
psql -c "select pg_start_backup('hot_backup');"
tar -cf /var/lib/pgsql/backup.tar /var/lib/pgsql/data/
psql -c "select pg_stop_backup();"
rm /var/lib/pgsql/backup_in_progress
tar -rf /var/lib/pgsql/backup.tar /var/lib/pgsql/archive/
      </programlisting>
      Le fichier de bascule,
      <filename>/var/lib/pgsql/backup_in_progress</filename>, est créé en
      premier, activant l'archivage des journaux de transactions pleins.
      Après la sauvegarde, le fichier de bascule est supprimé. Les journaux
      de transaction archivés sont ensuite ajoutés à la sauvegarde pour que
      la sauvegarde de base et les journaux requis fassent partie du même
      fichier <application>tar</application>.
      Rappelez vous d'ajouter de la gestion d'erreur à vos scripts.
     </para>

    </sect3>

    <sect3 id="compressed-archive-logs">
     <title>Compression des fichiers archives</title>

     <para>
      Si la taille du stockage des archives est un problème, vous pouvez
      utiliser <application>gzip</application> pour compresser les fichiers
      archives&nbsp;:
      <programlisting>
archive_command = 'gzip &lt; %p &gt; /var/lib/pgsql/archive/%f'
      </programlisting>
      Vous aurez alors besoin d'utiliser <application>gunzip</application>
      pendant la récupération&nbsp;:
      <programlisting>
restore_command = 'gunzip &lt; /mnt/server/archivedir/%f &gt; %p'
      </programlisting>
     </para>
    </sect3>

    <sect3 id="backup-scripts">
     <title>Scripts <varname>archive_command</varname></title>

     <para>
      Nombreux sont ceux qui choisissent d'utiliser
      des scripts pour définir leur <varname>archive_command</varname>, de
      sorte que leur <filename>postgresql.conf</filename> semble très simple&nbsp;:
      <programlisting>
archive_command = 'local_backup_script.sh "%p" "%f"'
      </programlisting>
      Utiliser un script séparé est conseillé à chaque fois qu'il est envisagé
      d'utiliser plusieurs commandes pour le processus d'archivage.
      Ainsi toute la complexité est gérée dans le script qui peut être
      écrit dans un langage de scripts populaires comme
      <application>bash</application> ou <application>perl</application>.
     </para>
     <para>
      Quelques exemples de besoins résolus dans
      un script&nbsp;:
      <itemizedlist>
       <listitem>
        <para>
         copier des données vers un stockage distant&nbsp;;
        </para>
       </listitem>
       <listitem>
        <para>
         copier les journaux de transaction en groupe pour qu'ils soient
         transférés toutes les trois heures plutôt qu'un à la fois&nbsp;;
        </para>
       </listitem>
       <listitem>
        <para>
         s'interfacer avec d'autres outils de sauvegarde et de
         récupération&nbsp;;
        </para>
       </listitem>
       <listitem>
        <para>
         s'interfacer avec un outil de surveillance pour y renvoyer
         les erreurs.
        </para>
       </listitem>
      </itemizedlist>
     </para>

     <tip>
      <para>
       Lors de l'utilisation d'un script <varname>archive_command</varname>,
       il est préférable d'activer <xref linkend="guc-logging-collector"/>.
       Tout message écrit sur <systemitem>stderr</systemitem> à partir du script
       apparaîtra ensuite dans les traces du serveur, permettant un diagnostic
       facilité de configurations complexes en cas de problème.
      </para>
     </tip>
    </sect3>
   </sect2>

   <sect2 id="continuous-archiving-caveats">
    <title>Restrictions</title>

    <para>
     Au moment où ces lignes sont écrites, plusieurs limitations
     de la technique d'archivage continu sont connues. Elles seront probablement
     corrigées dans une prochaine version&nbsp;:

     <itemizedlist>
      <listitem>
       <para>
        Si une commande
        <xref linkend="sql-createdatabase"/>
        est exécutée alors qu'une sauvegarde est en cours, et que la base de données
        modèle utilisée par l'instruction <command>CREATE DATABASE</command>
        est à son tour modifiée pendant la sauvegarde, il est
        possible que la récupération propage ces modifications
        dans la base de données créée. Pour éviter ce risque, il est préférable de
        ne pas modifier les bases de données modèle lors d'une sauvegarde de base.
       </para>
      </listitem>

      <listitem>
       <para>
        Les commandes
        <xref linkend="sql-createtablespace"/>
        sont tracées dans les WAL avec le chemin absolu et sont donc rejouées
        en tant que créations de <foreignphrase>tablespace</foreignphrase>
        suivant le même chemin absolu. Cela n'est pas forcément souhaitable si
        le journal est rejoué sur une autre machine.
        De plus, cela peut s'avérer dangereux même lorsque le journal est rejoué sur la
        même machine, mais dans un répertoire différent&nbsp;: la ré-exécution surcharge
        toujours le contenu du <foreignphrase>tablespace</foreignphrase> original.
        Pour éviter de tels problèmes, la meilleure solution consiste à
        effectuer une nouvelle sauvegarde de la base après la création ou la
        suppression de <foreignphrase>tablespace</foreignphrase>.
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     Il faut de plus garder à l'esprit que le format actuel des
     <acronym>WAL</acronym> est extrêmement volumineux car il inclut
     de nombreuses images des pages disques. Ces images de page sont conçues
     pour supporter la récupération après un arrêt brutal, puisqu'il peut
     être nécessaire de corriger des pages disque partiellement écrites.
     En fonction du matériel et des logiciels composant le système,
     le risque d'écriture partielle peut être
     suffisamment faible pour être ignoré, auquel cas le volume total des
     traces archivées peut être considérablement réduit par la désactivation
     des images de page à l'aide du paramètre <xref linkend="guc-full-page-writes"/>
     (lire les notes et avertissements dans <xref linkend="wal"/> avant
     de le faire). Désactiver les images de page n'empêche pas l'utilisation des
     traces pour les opérations PITR. Un piste éventuelle de développement
     futur consiste à compresser les données des WAL archivés en supprimant les copies
     inutiles de pages même si <varname>full_page_writes</varname> est actif. Entre
     temps, les administrateurs peuvent souhaiter réduire le nombre
     d'images de pages inclus dans WAL en augmentant autant que possible les
     paramètres d'intervalle entre les points de vérification.
    </para>
   </sect2>
  </sect1>
 </chapter>
