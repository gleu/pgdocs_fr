<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<sect1 id="lo" xreflabel="lo">
 <title>lo</title>

 <indexterm zone="lo">
  <primary>lo</primary>
 </indexterm>

 <para>
  Le module <filename>lo</filename> ajoute un support des «&nbsp;Large
  Objects&nbsp;» (aussi appelé LO ou BLOB). Il inclut le type de données
  <type>lo</type> et un trigger <function>lo_manage</function>.
 </para>

 <para>
  This module is considered <quote>trusted</quote>, that is, it can be
  installed by non-superusers who have <literal>CREATE</literal> privilege
  on the current database.
 </para>

 <sect2>
  <title>Aperçu</title>
  <para>
   Un des problèmes avec le pilote JDBC (mais cela affecte aussi le pilote
   ODBC) est que la spécification suppose que les références aux BLOB (Binary
   Large OBject) sont stockées dans une table et que, si une entrée est
   modifiée, le BLOB associé est supprimé de cette base.
  </para>
  <para>
   En l'état actuel de <productname>PostgreSQL</productname>, ceci n'arrive pas.
   Les  <quote>Large Objects</quote>
   sont traités comme des objets propres&nbsp;; une entrée de table peut
   référencer un <quote>Large Object</quote> par son OID, mais plusieurs
   tables peuvent référencer le même OID. Donc, le système ne
   supprime pas un <quote>Large Object</quote> simplement parce que vous
   modifiez ou supprimez une entrée contenant un tel OID.
  </para>
  <para>
   Ceci n'est pas un problème pour les applications spécifiques
   à <productname>PostgreSQL</productname> mais un code standard
   utilisant JDBC ou ODBC
   ne supprimera pas ces objets, ceci aboutissant à des <quote>Large
    Objects</quote> orphelins &mdash; des objets qui ne sont référencés par
   personne et occupant de la place.
  </para>

  <para>
   Le module <filename>lo</filename> permet de corriger ceci en attachant un
   trigger aux tables contenant des colonnes de référence des LO. Le trigger
   fait essentiellement un <function>lo_unlink</function> quand vous supprimez
   ou modifiez une valeur référence un <quote>Large Object</quote>. Quand
   vous utilisez ce trigger, vous supposez que, dans toute la base de données,
   il n'existe qu'une seule référence d'un <quote>Large Object</quote> référencé
   dans une colonne contrôlée par un trigger&nbsp;!
  </para>

  <para>
   Le module fournit aussi un type de données <type>lo</type>, qui n'est
   qu'un domaine sur le type <type>oid</type>. Il est utile pour
   différencier les colonnes de la base qui contiennent des références d'objet
   de ceux qui contiennent des OID sur d'autres choses. Vous n'avez pas
   besoin d'utiliser le type <type>lo</type> pour utiliser le trigger mais cela
   facilite le travail pour garder la trace des colonnes de votre base
   qui représentent des <quote>Large Objects</quote> que vous gérez avec le
   trigger. Une rumeur dit aussi que le pilote ODBC a du mal si vous
   n'utilisez pas le type <type>lo</type> pour les colonnes BLOB.
  </para>
 </sect2>

 <sect2>
  <title>Comment l'utiliser</title>

  <para>
   Voici un exemple d'utilisation&nbsp;:
  </para>

  <programlisting>
   CREATE TABLE image (title TEXT, raster lo);

   CREATE TRIGGER t_raster BEFORE UPDATE OR DELETE ON image
     FOR EACH ROW EXECUTE FUNCTION lo_manage(raster);
  </programlisting>

  <para>
   Pour chaque colonne qui contiendra des références uniques aux <quote>Large
    Objects</quote>, créez un trigger <literal>BEFORE UPDATE OR DELETE</literal>
   trigger, et donnez le nom de la colonne comme argument du trigger. Vous pouvez
   aussi restreindre le trigger pour ne s'exécuter que sur les mises à jour de
   la colonne en utilisant <literal>BEFORE UPDATE OF</literal> <replaceable
   class="parameter">nom_colonne</replaceable>. Si vous
   avez plusieurs colonnes <type>lo</type> dans la même table, créez un
   trigger séparé pour chacune en vous souvenant de donner un nom différent
   à chaque trigger sur la même table.
  </para>
 </sect2>

 <sect2>
  <title>Limites</title>

  <itemizedlist>
   <listitem>
    <para>
     Supprimer une table résultera quand même en des objets orphelins pour
     tous les objets qu'elle contient, car le trigger n'est pas exécuté. Vous
     pouvez éviter ceci en faisant précéder le <command>DROP
      TABLE</command> avec <command>DELETE FROM
      <replaceable>table</replaceable></command>.
    </para>

    <para>
     <command>TRUNCATE</command> présente le même danger.
    </para>

    <para>
     Si vous avez déjà, ou suspectez avoir, des <quote>Large Objects</quote>
     orphelins, voir le module <xref linkend="vacuumlo"/> (<xref
     linkend="vacuumlo"/>) pour vous aider à les nettoyer. Une bonne idée est
     d'exécuter <application>vacuumlo</application> occasionnellement pour
     s'assurer du ménage réalisé par le trigger <function>lo_manage</function>.
    </para>
   </listitem>

   <listitem>
    <para>
     Quelques interfaces peuvent créer leur propres tables et n'ajouteront pas
     les triggers associés. De plus, les utilisateurs peuvent oublier
     de créer les triggers, ou ne pas savoir le faire.
    </para>
   </listitem>
  </itemizedlist>
 </sect2>

 <sect2>
  <title>Auteur</title>

  <para>
   Peter Mount <email>peter@retep.org.uk</email>
  </para>
 </sect2>

</sect1>
