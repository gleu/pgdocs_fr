<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<sect1 id="xfunc">
 <title>Fonctions utilisateur</title>

 <indexterm zone="xfunc">
  <primary>fonction</primary>
  <secondary>utilisateur</secondary>
 </indexterm>

 <para>
  <productname>PostgreSQL</productname> propose quatre types de
  fonctions&nbsp;:

  <itemizedlist>
   <listitem>
    <para>
     fonctions en langage de requête (fonctions écrites en <acronym>SQL</acronym>,
     <xref linkend="xfunc-sql"/>)
    </para>
   </listitem>
   <listitem>
    <para>
     fonctions en langage procédural (fonctions écrites, par exemple, en
     <application>PL/pgSQL</application> ou <application>PL/Tcl</application>,
     <xref linkend="xfunc-pl"/>)
    </para>
   </listitem>
   <listitem>
    <para>
     fonctions internes (<xref linkend="xfunc-internal"/>)
    </para>
   </listitem>
   <listitem>
    <para>
     fonctions en langage C (<xref linkend="xfunc-c"/>)
    </para>
   </listitem>
  </itemizedlist>
 </para>

 <para>
  Chaque type de fonction peut accepter comme arguments (paramètres) des types
  de base, des types composites ou une combinaison de ceux-ci. De plus, chaque
  sorte de fonction peut renvoyer un type de base ou un type composite. Les
  fonctions pourraient aussi être définies pour renvoyer des ensembles de valeurs
  de base ou de valeurs composites.
 </para>

 <para>
  De nombreuses sortes de fonctions peuvent accepter ou renvoyer certains
  pseudo-types (comme les types polymorphes) mais avec des fonctionnalités
  variées.
  Consultez la description de chaque type de fonction pour plus de détails.
 </para>

 <para>
  Il est plus facile de définir des fonctions <acronym>SQL</acronym> aussi
  allons-nous commencer par celles-ci. La plupart des concepts présentés pour
  les fonctions <acronym>SQL</acronym> seront aussi gérés par les autres types
  de fonctions.
 </para>

 <para>
  Lors de  la lecture de ce chapitre, il peut être utile de consulter la page
  de référence de la commande <xref linkend="sql-createfunction"/> pour mieux
  comprendre les exemples. Quelques exemples extraits de ce chapitre peuvent
  être trouvés dans les fichiers <filename>funcs.sql</filename> et
  <filename>funcs.c</filename> du répertoire du tutoriel de la distribution
  source de <productname>PostgreSQL</productname>.
 </para>

</sect1>

  <sect1 id="xproc">
   <title>Procédures utilisateur</title>

  <indexterm zone="xproc">
   <primary>procédure</primary>
   <secondary>utilisateur</secondary>
  </indexterm>

   <para>
    Une procédure est un objet de base de données similaire à une fonction.
    La différence est qu'une procédure ne retourne pas de valeur, il n'y a
    donc pas de déclaration de type de retour.  Bien qu'une fonction soit appelée
    au sein d'une requête ou d'une commande DML, une procédure est appelée
    explicitement en utilisant l'ordre
    <xref linkend="sql-call"/>.
   </para>

   <para>
    Les explications présentes dans le reste de ce chapitre concernant comment
    définir des fonctions utilisateurs s'appliquent également aux procédures, à
    la différence que la commande <xref linkend="sql-createprocedure"/> est
    utilisée à la place, qu'il n'y a pas de type de retour et que certaines
    autres fonctionnalités telle que la notion <quote>STRICT</quote> ne
    s'appliquent pas.
   </para>

   <para>
    Collectivement, les fonctions et les procédures sont également appelées des
    <firstterm>routines</firstterm><indexterm><primary>routine</primary></indexterm>.
    Il y a des commandes telles que <xref linkend="sql-alterroutine"/> et
    <xref linkend="sql-droproutine"/> qui peuvent s'appliquer sur des fonctions
    ou des procédures sans avoir besoin de savoir de quel type il s'agit.
    Veuillez noter, toutefois, qu'il n'y a pas de commande
    <literal>CREATE ROUTINE</literal>.
   </para>
  </sect1>

<sect1 id="xfunc-sql">
 <title>Fonctions en langage de requêtes (<acronym>SQL</acronym>)</title>

 <indexterm zone="xfunc-sql">
  <primary>fonction</primary>
  <secondary>définie par l'utilisateur</secondary>
  <tertiary>en SQL</tertiary>
 </indexterm>

 <para>
  Les fonctions SQL exécutent une liste arbitraire d'instructions SQL et
  renvoient le résultat de la dernière requête de cette liste. Dans le cas
  d'un résultat simple (pas d'ensemble), la première ligne du résultat de la
  dernière requête sera renvoyée (gardez à l'esprit que <quote>la première
   ligne</quote> d'un résultat multiligne n'est pas bien définie à moins
  d'utiliser <literal>ORDER BY</literal>). Si la dernière requête de la liste ne
  renvoie aucune ligne, la valeur NULL est renvoyée.
 </para>

 <para>
  Une fonction SQL peut être déclarée de façon à renvoyer un ensemble
  (<quote>set</quote>, ce qui signifie un ensemble de lignes)
  en spécifiant le type renvoyé par la fonction comme <literal>SETOF
   <replaceable>un_type</replaceable></literal>, ou de façon équivalente en
  la déclarant comme  <literal>RETURNS
   TABLE(<replaceable>colonnes</replaceable>)</literal>. Dans ce
  cas, toutes les lignes de la dernière requête sont renvoyées. Des détails
  supplémentaires sont donnés plus loin dans ce chapitre.
 </para>

 <para>
  Le corps d'une fonction SQL doit être constitué d'une liste d'une ou
  de plusieurs instructions SQL séparées par des points-virgule. Un
  point-virgule après la dernière instruction est optionnel. Sauf si la
  fonction déclare renvoyer <type>void</type>, la dernière instruction doit
  être un <command>SELECT</command> ou un <command>INSERT</command>,
  <command>UPDATE</command> ou un <command>DELETE</command> qui a une clause
  <literal>RETURNING</literal>.
 </para>

 <para>
  Toute collection de commandes dans le langage <acronym>SQL</acronym> peut
  être assemblée et définie comme une fonction. En plus des requêtes
  <command>SELECT</command>, les commandes peuvent inclure des requêtes de
  modification des données (<command>INSERT</command>,
  <command>UPDATE</command> et <command>DELETE</command>) ainsi que
  d'autres commandes SQL (sans toutefois pouvoir utiliser les commandes de contrôle de transaction, telles
  que <command>COMMIT</command>, <command>SAVEPOINT</command>, et certaines commandes
  utilitaires, comme  <literal>VACUUM</literal>, dans les fonctions <acronym>SQL</acronym>).
  Néanmoins, la commande finale doit être un
  <command>SELECT</command> ou doit avoir une clause <literal>RETURNING</literal>
  qui renvoie ce qui a été spécifié comme type de retour de la fonction.
  Autrement, si vous voulez définir une fonction SQL qui réalise des actions mais n'a pas de valeur utile à renvoyer,
  vous pouvez la définir comme renvoyant <type>void</type>. Par exemple, cette fonction supprime les
  lignes avec des salaires négatifs depuis la table <literal>emp</literal>&nbsp;:

  <screen>CREATE FUNCTION nettoie_emp() RETURNS void AS '
    DELETE FROM emp WHERE salaire &lt; 0;
' LANGUAGE SQL;

SELECT nettoie_emp();

  nettoie_emp
  -----------

  (1 row)
  </screen>
 </para>

 <note>
  <para>
   Le corps entier d'une fonction SQL est analysé avant d'être exécuté. Bien
   qu'une fonction SQL puisse contenir des commandes qui modifient les
   catalogues systèmes (par exemple <command>CREATE TABLE</command>), les
   effets de telles commandes ne seront pas visibles lors de l'analyse des
   commandes suivantes dans la fonction. De ce fait, par exemple,
   <literal>CREATE TABLE foo (...); INSERT INTO foo VALUES(...);</literal>
   ne fonctionnera pas si c'est intégré dans une seule fonction SQL car
   <structname>foo</structname> n'existera pas encore quand la commande SQL
   <command>INSERT</command> sera analysée. Il est recommandé d'utiliser
   <application>PL/PgSQL</application> à la place de SQL dans ce genre de
   situations.
  </para>
 </note>

 <para>
  La syntaxe de la commande <command>CREATE FUNCTION</command> requiert que
  le corps de la fonction soit écrit comme une constante de type chaîne.
  Il est habituellement plus agréable d'utiliser les guillemets dollar
  (voir la <xref linkend="sql-syntax-dollar-quoting"/>) pour cette constante.
  Si vous choisissez d'utiliser la syntaxe habituelle avec des guillemets
  simples, vous devez doubler les marques de guillemet simple
  (<literal>'</literal>) et les antislashs (<literal>\</literal>), en supposant
  que vous utilisez la syntaxe d'échappement de chaînes, utilisés dans le corps
  de la fonction (voir la <xref linkend="sql-syntax-strings"/>).
 </para>

 <sect2 id="xfunc-sql-function-arguments">
  <title>Arguments pour les fonctions <acronym>SQL</acronym></title>

  <indexterm>
   <primary>fonction</primary>
   <secondary>argument nommé</secondary>
  </indexterm>

  <para>
   Les arguments d'une fonction SQL peuvent être référencés dans le corps de
   la fonction en utilisant soit les noms soit les numéros. Des exemples de
   chaque méthode se trouvent ci-dessous.
  </para>

  <para>
   Pour utiliser un nom, déclarez l'argument de la fonction comme ayant un
   nom, puis écrivez le nom dans le corps de la fonction. Si le nom de
   l'argument est le même que celui d'une colonne dans la commande SQL en
   cours, le nom de la colonne est prioritaire. Pour contourner ce comportement,
   qualifiez le nom de l'argument avec le nom de la fonction, autrement dit
   <literal><replaceable>nom_fonction</replaceable>.<replaceable>nom_argument</replaceable></literal>.
   (Si cela entre en conflit avec un nom de colonne qualifié, cette fois
   encore, la colonne l'emporte. Vous pouvez éviter toute ambiguïté en
   choisissant un alias différent pour la table à l'intérieur de la commande
   SQL.)
  </para>

  <para>
   Dans l'ancienne approche numérique, les arguments sont référencés en
   utilisant la syntaxe
   <literal>$<replaceable>n</replaceable></literal>&nbsp;:
   <literal>$1</literal> fait référence au premier argument,
   <literal>$2</literal> au second, et ainsi de suite. Ceci fonctionnera
   que l'argument ait été déclaré avec un nom ou pas.
  </para>

  <para>
   Si un argument est de type composite, la notation à point,
   <literal><replaceable>nom_argument</replaceable>.<replaceable>nom_champ</replaceable></literal>
   ou <literal>$1.<replaceable>nom_champ</replaceable></literal> peut
   être utilisé pour accéder aux attributs de l'argument. Encore une fois,
   vous pourriez avoir besoin de qualifier le nom de l'argument avec le nom de
   la fonction pour qu'il n'y ait pas d'ambiguité.
  </para>

  <para>
   Les arguments de fonctions SQL peuvent seulement être utilisés comme valeurs
   de données, et non pas comme identifiants. Du coup, par exemple, ceci est
   accepté&nbsp;:
   <programlisting>
 INSERT INTO mytable VALUES ($1);
   </programlisting>
   mais ceci ne fonctionnera pas&nbsp;:
   <programlisting>
 INSERT INTO $1 VALUES (42);
   </programlisting>
  </para>

  <note>
   <para>
    La possibilité d'utiliser des noms pour référencer les arguments d'une
    fonction SQL a été ajoutée à <productname>PostgreSQL</productname> 9.2.
    Les fonctions devant être utilisées sur des versions antérieures doivent
    utiliser la notation <literal>$<replaceable>n</replaceable></literal>.
   </para>
  </note>
 </sect2>

 <sect2 id="xfunc-sql-base-functions">
  <title>Fonctions <acronym>SQL</acronym> sur les types de base</title>

  <para>
   La fonction <acronym>SQL</acronym> la plus simple possible n'a pas
   d'argument et retourne un type de base tel que <type>integer</type>&nbsp;:
   <screen>CREATE FUNCTION un() RETURNS integer AS $$
    SELECT 1 AS resultat;
$$ LANGUAGE SQL;

-- Autre syntaxe pour les chaînes littérales :
CREATE FUNCTION un() RETURNS integer AS '
    SELECT 1 AS resultat;
' LANGUAGE SQL;

SELECT un();

 un
----
  1
   </screen>
  </para>

  <para>
   Notez que nous avons défini un alias de colonne avec le nom
   <literal>resultat</literal> dans le corps de la fonction pour se référer au
   résultat de la fonction mais cet alias n'est pas visible hors de la
   fonction. En effet, le résultat est nommé <literal>un</literal> au lieu de
   <literal>resultat</literal>.
  </para>

  <para>
   Il est presque aussi facile de définir des fonctions <acronym>SQL</acronym> acceptant des types
   de base comme arguments&nbsp;:

   <screen>
CREATE FUNCTION add_em(x integer, y integer) RETURNS integer AS $$
    SELECT x + y;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
--------
      3
   </screen>
  </para>

  <para>
   Autrement, nous pourrions nous passer des noms pour les arguments et utiliser
   à la place des numéros&nbsp;:

   <screen>CREATE FUNCTION ajoute(integer, integer) RETURNS integer AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;

SELECT ajoute(1, 2) AS reponse;

 reponse
---------
      3
   </screen>
  </para>

  <para>
   Voici une fonction plus utile, qui pourrait être utilisée pour débiter un
   compte bancaire&nbsp;:

   <programlisting>CREATE FUNCTION tf1 (no_compte integer, debit numeric) RETURNS numeric AS $$
     UPDATE bank
        SET balance = balance - debit
        WHERE no_compte = tf1.no_compte;
    SELECT 1;
$$ LANGUAGE SQL;
   </programlisting>

   Un utilisateur pourrait exécuter cette fonction pour débiter le compte 17 de
   100&nbsp;000&nbsp;euros ainsi&nbsp;:
   <programlisting>SELECT tf1(17, 100.000);</programlisting>
    </para>

    <para>
     Dans cet exemple, nous choisissons le nom <literal>no_compte</literal>
     comme premier argument mais ce nom est identique au nom d'une colonne
     dans la table  <literal>banque</literal>. Dans la commande
     <command>UPDATE</command>, <literal>no_compte</literal> fait référence
     à la colonne <literal>banque.no_compte</literal>, donc
     <literal>tf1.no_compte</literal> doit être utilisé pour faire référence
     à l'argument. Nous pouvons bien sûr éviter cela en utilisant un nom
     différent pour l'argument.
    </para>

    <para>
    Dans la pratique, on préférera vraisemblablement un résultat plus utile que
    la constante 1. Une définition plus probable est&nbsp;:

<programlisting>CREATE FUNCTION tf1 (no_compte integer, debit numeric) RETURNS numeric AS $$
     UPDATE bank
        SET balance = balance - debit
        WHERE no_compte = tf1.no_compte;
    SELECT balance FROM banque WHERE no_compte = tf1.no_compte;
$$ LANGUAGE SQL;
   </programlisting>

   qui ajuste le solde et renvoie sa nouvelle valeur.
   La même chose peut se faire en une commande en utilisant la clause
   <literal>RETURNING</literal>&nbsp;:

   <programlisting>CREATE FUNCTION tf1 (no_compte integer, debit numeric) RETURNS numeric AS $$
     UPDATE bank
        SET balance = balance - debit
        WHERE no_compte = tf1.no_compte
     RETURNING balance;
$$ LANGUAGE SQL;
</programlisting>
    </para>

    <para>
     Une fonction <acronym>SQL</acronym> doit retourner exactement le type de
     donnée présent dans sa définition.  Cela peut nécessiter d'insérer un
     transtypage explicite.  Par exemple, supposons que nous voulions que la
     précédente fonction <function>add_em</function> retourne un type
     <type>float8</type> à la place.  Ceci ne fonctionne pas&nbsp;:

<programlisting>
CREATE FUNCTION add_em(integer, integer) RETURNS float8 AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;
</programlisting>

     bien que dans d'autres contextes, <productname>PostgreSQL</productname>
     serait prêt à insérer un transtypage explicite pour convertir
     le type <type>integer</type> en type <type>float8</type>.
     Nous devons l'écrire ainsi&nbsp;;

<programlisting>
CREATE FUNCTION add_em(integer, integer) RETURNS float8 AS $$
    SELECT ($1 + $2)::float8;
$$ LANGUAGE SQL;
   </programlisting>
  </para>

 </sect2>

 <sect2 id="xfunc-sql-composite-functions">
  <title>Fonctions <acronym>SQL</acronym> sur les types composites</title>

  <para>
   Quand nous écrivons une fonction avec des arguments de type composite,
   nous devons non seulement spécifier l'argument utilisé,
   mais aussi spécifier l'attribut désiré de cet argument (champ). Par
   exemple, supposons que
   <type>emp</type> soit le nom d'une table contenant des données sur les
   employés et donc également le nom du type composite correspondant à chaque
   ligne de la table. Voici une fonction <function>double_salaire</function>
   qui calcule ce que serait le salaire de quelqu'un s'il était doublé&nbsp;:

   <screen>CREATE TABLE emp (
    nom         text,
    salaire     numeric,
    age         integer,
    cubicle     point
);

INSERT INTO emp VALUES ('Bill', 4200, 45, '(2,1)');

CREATE FUNCTION double_salaire(emp) RETURNS numeric AS $$
    SELECT $1.salaire * 2 AS salaire;
$$ LANGUAGE SQL;

SELECT nom, double_salaire(emp.*) AS reve
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';

 name | reve
------+-------
 Bill |  8400
   </screen>
  </para>

  <para>
   Notez l'utilisation de la syntaxe <literal>$1.salaire</literal> pour
   sélectionner un champ dans la valeur de la ligne argument. Notez également
   comment la commande <command>SELECT</command> utilise <replaceable>nom_table</replaceable><literal>.*</literal> pour
   sélectionner la ligne courante entière de la table comme une valeur composite
   (<literal>emp</literal>). La ligne de la table peut aussi être référencée en
   utilisant seulement le nom de la table ainsi&nbsp;:
   <screen>SELECT nom, double_salaire(emp) AS reve
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';
   </screen>
   mais cette utilisation est obsolète car elle est facilement obscure.
   (Voir <xref linkend="rowtypes-usage"/> pour des détails sur ces deux
   syntaxes pour la valeur composite d'une ligne de table.)
  </para>

  <para>
   Quelque fois, il est pratique de construire une valeur d'argument
   composite en direct. Ceci peut se faire avec la construction
   <literal>ROW</literal>. Par exemple, nous pouvons ajuster les données passées
   à la fonction&nbsp;:
   <screen>SELECT nom, double_salaire(ROW(nom, salaire*1.1, age, cubicle)) AS reve
	FROM emp;
   </screen>
  </para>

  <para>
   Il est aussi possible de construire une fonction qui renvoie un type
   composite. Voici un exemple de fonction renvoyant une seule ligne de type
   <type>emp</type>&nbsp;:

   <programlisting>CREATE FUNCTION nouvel_emp() RETURNS emp AS $$
    SELECT text 'Aucun' AS nom,
        1000.0 AS salaire,
        25 AS age,
        point '(2,2)' AS cubicle;
$$ LANGUAGE SQL;
   </programlisting>

   Dans cet exemple, nous avons spécifié chacun des attributs avec une valeur
   constante, mais un quelconque calcul aurait pu être substitué à ces
   valeurs.
  </para>

  <para>
   Notez deux aspects importants à propos de la définition de fonction&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      L'ordre de la liste du SELECT doit être exactement le même que celui
      dans lequel les colonnes apparaissent dans la table associée au type
      composite (donner des noms aux colonnes dans le corps de la fonction,
      comme nous l'avons
      fait dans l'exemple, n'a aucune interaction avec le système).
     </para>
    </listitem>
    <listitem>
     <para>
      Il faut s'assurer que le type de chaque expression concorde avec la
      colonne correspondante du type composite, en insérant un transtypage si
      nécessaire.  Sinon, une erreur telle que :
      <screen><computeroutput>ERROR:  function declared to return emp returns varchar instead of text at column 1</computeroutput></screen>
      sera renvoyée.  Comme pour le cas du type de base, la fonction
      n'insèrera aucun transtypage automatiquement.
     </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
      Une autre façon de définir la même fonction est&nbsp;:

      <programlisting>CREATE FUNCTION nouveau_emp() RETURNS emp AS $$
    SELECT ROW('Aucun', 1000.0, 25, '(2,2)')::emp;
$$ LANGUAGE SQL;</programlisting>

      Ici, nous écrivons un <command>SELECT</command> qui renvoie seulement une
      colonne du bon type composite. Ceci n'est pas vraiment meilleur dans
      cette situation mais c'est une alternative pratique dans certains cas
      &mdash; par exemple, si nous avons besoin de calculer le résultat en
      appelant une autre fonction qui renvoie la valeur composite désirée.
      Un autre exemple est que si nous essayons d'écrire une fonction qui
      retourne un domaine sur un type composite, plutôt qu'un simple type
      composite, il est toujours nécessaire de l'écrire comme retournant une
      seule colonne, puisqu'il n'y a aucune autre manière de produire une
      valeur qui soit exactement du type de ce domaine.
    </para>

    <para>
      Nous pouvons appeler cette fonction soit en l'utilisant dans une
      expression de valeur&nbsp;:

  <screen>SELECT nouveau_emp();

        nouveau_emp
--------------------------
 (None,1000.0,25,"(2,2)")
</screen>

     soit en l'utilisant comme une fonction table&nbsp;:

<screen>

SELECT * FROM nouveau_emp();

  nom  | salaire | age | cubicle
-------+---------+-----+---------
 Aucun |  1000.0 |  25 | (2,2)
      </screen>

      La deuxième façon est décrite plus complètement dans la <xref
      linkend="xfunc-sql-table-functions"/>.
     </para>

     <para>
      Quand vous utilisez une fonction qui renvoie un type composite, vous
      pourriez vouloir seulement un champ (attribut) depuis ce résultat. Vous
      pouvez le faire avec cette syntaxe&nbsp;:

      <screen>SELECT (nouveau_emp()).nom;

 nom
------
 None
      </screen>

      Les parenthèses supplémentaires sont nécessaires pour éviter une erreur de
      l'analyseur. Si vous essayez de le faire sans, vous obtiendrez quelque chose
      comme ceci&nbsp;:
      <screen>SELECT nouveau_emp().nom;
ERROR:  syntax error at or near "."
LINE 1: SELECT nouveau_emp().nom;
                            ^
      </screen>
     </para>

     <para>
      Une autre option est d'utiliser la notation fonctionnelle pour extraire un
      attribut&nbsp;:

      <screen>SELECT nom(nouveau_emp());

 name
------
 None
      </screen>
     </para>

     <para>
      Comme expliqué dans <xref linkend="rowtypes-usage"/>, la notation avec des
      champs et la notation fonctionnelle sont équivalentes.
     </para>
    </sect2>

    <sect2 id="xfunc-output-parameters">
     <title>Fonctions <acronym>SQL</acronym> avec des paramètres en sortie</title>

     <indexterm>
      <primary>fonction</primary>
      <secondary>paramètre en sortie</secondary>
     </indexterm>

     <para>
      Une autre façon de décrire les résultats d'une fonction est de la
      définir avec des <firstterm>paramètres en sortie</firstterm> comme dans cet
      exemple&nbsp;:

      <screen>CREATE FUNCTION ajoute (IN x int, IN y int, OUT sum int)
AS 'SELECT x + y'
LANGUAGE SQL;

SELECT ajoute(3,7);
 ajoute
--------
     10
(1 row)
      </screen>

      Ceci n'est pas vraiment différent de la version d'<literal>ajoute</literal>
      montrée dans la <xref linkend="xfunc-sql-base-functions"/>. La vraie valeur
      des paramètres en sortie est qu'ils fournissent une façon agréable de
      définir des fonctions qui renvoient plusieurs colonnes. Par exemple,

      <screen>CREATE FUNCTION ajoute_n_produit (x int, y int, OUT sum int, OUT product int)
AS 'SELECT x + y, x * y'
LANGUAGE SQL;

 SELECT * FROM sum_n_product(11,42);
 sum | product
-----+---------
  53 |     462
(1 row)
      </screen>

      Ce qui est arrivé ici est que nous avons créé un type composite anonyme
      pour le résultat de la fonction. L'exemple ci-dessus a le même résultat
      final que

      <screen>CREATE TYPE produit_ajoute AS (somme int, produit int);

CREATE FUNCTION ajoute_n_produit (int, int) RETURNS produit_ajoute
AS 'SELECT $1 + $2, $1 * $2'
LANGUAGE SQL;
      </screen>

      mais ne pas avoir à s'embêter avec la définition séparée du type
      composite est souvent agréable. Notez que les noms attachés aux paramètres
      de sortie ne sont pas juste décoratif, mais déterminent le nom des
      colonnes du type composite anonyme. (Si vous omettez un nom pour un
      paramètre en sortie, le système choisira un nom lui-même.)
     </para>

     <para>
      Notez que les paramètres en sortie ne sont pas inclus dans la liste
      d'arguments lors de l'appel d'une fonction de ce type en SQL. Ceci
      parce que <productname>PostgreSQL</productname> considère seulement les
      paramètres en entrée pour définir la signature d'appel de la fonction.
      Cela signifie aussi que seuls les paramètres en entrée sont importants
      lors de références de la fonction pour des buts comme sa suppression.
      Nous pouvons supprimer la fonction ci-dessus avec l'un des deux appels
      ci-dessous&nbsp;:

      <screen>DROP FUNCTION ajoute_n_produit (x int, y int, OUT somme int, OUT produit int);
DROP FUNCTION ajoute_n_produit (int, int);
      </screen>
     </para>

     <para>
      Les paramètres peuvent être marqués comme <literal>IN</literal> (par défaut),
      <literal>OUT</literal> ou <literal>INOUT</literal> ou
      <literal>VARIADIC</literal>.
      Un paramètre <literal>INOUT</literal>
      sert à la fois de paramètre en entrée (il fait partie de la liste
      d'arguments en appel) et comme paramètre de sortie (il fait partie du
      type d'enregistrement résultat). Les paramètres
      <literal>VARIADIC</literal> sont des paramètres en entrées, mais sont
      traités spécifiquement comme indiqué ci-dessous.
     </para>
    </sect2>

    <sect2 id="xfunc-sql-variadic-functions">
     <title>Fonctions <acronym>SQL</acronym> avec un nombre variables d'arguments</title>

     <indexterm>
      <primary>fonction</primary>
      <secondary>variadic</secondary>
     </indexterm>

     <indexterm>
      <primary>fonction variadic</primary>
     </indexterm>

     <para>
      Les fonctions <acronym>SQL</acronym> peuvent accepter un nombre variable
      d'arguments à condition que tous les arguments <quote>optionnels</quote>
      sont du même type. Les arguments optionnels seront passés à la fonction
      sous forme d'un tableau. La fonction est déclarée en marquant le dernier
      paramètre comme <literal>VARIADIC</literal>&nbsp;; ce paramètre doit être
      déclaré de type tableau. Par exemple&nbsp;:

      <screen>
CREATE FUNCTION mleast(VARIADIC arr numeric[]) RETURNS numeric AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT mleast(10, -1, 5, 4.4);
 mleast
--------
     -1
(1 row)
      </screen>

      En fait, tous les arguments à la position ou après la position de
      l'argument <literal>VARIADIC</literal> sont emballés dans un tableau à
      une dimension, comme si vous aviez écrit

      <screen>
SELECT mleast(ARRAY[10, -1, 5, 4.4]);    -- doesn't work
      </screen>

      Vous ne pouvez pas vraiment écrire cela, ou tout du moins cela ne
      correspondra pas à la définition de la fonction. Un paramètre marqué
      <literal>VARIADIC</literal> correspond à une ou plusieurs occurrences
      de son type d'élément, et non pas de son propre type.
     </para>

     <para>
      Quelque fois, il est utile de pouvoir passer un tableau déjà construit
      à une fonction variadic&nbsp;; ceci est particulièrement intéressant quand
      une fonction variadic veut passer son paramètre tableau à une autre
      fonction. En outre, il s'agit de la seule méthode sûre
      pour appeler une fonction <literal>VARIADIC</literal> trouvée dans un
      schéma qui autorise les utilisateurs qui ne sont pas de confiance à créer
      des objets&nbsp;; voir <xref linkend="typeconv-func"/>.  Vous pouvez faire cela
      en spécifiant <literal>VARIADIC</literal>
      dans l'appel&nbsp;:

      <screen>
SELECT mleast(VARIADIC ARRAY[10, -1, 5, 4.4]);
      </screen>

      Ceci empêche l'expansion du paramètre variadic de la fonction dans le
      type des éléments, ce qui permet à la valeur tableau de correspondre.
      <literal>VARIADIC</literal> peut seulement être attaché au dernier
      argument d'un appel de fonction.
     </para>

     <para>
      Spécifier <literal>VARIADIC</literal> dans l'appel est aussi la seule
      façon de passer un tableau vide à une fonction variadique. Par
      exemple&nbsp;:

      <screen>
SELECT mleast(VARIADIC ARRAY[]::numeric[]);
      </screen>

      Écrire simplement <literal>SELECT mleast()</literal> ne fonctionne pas
      car un paramètre variadique doit correspondre à au moins un argument
      réel. (Vous pouvez définir une deuxième fonction aussi nommée
      <literal>mleast</literal>, sans paramètres, si vous voulez permettre ce
      type d'appels.)
     </para>

     <para>
      Les paramètres de l'élément tableau générés à partir d'un paramètre
      variadic sont traités comme n'ayant pas de noms propres. Cela signifie
      qu'il n'est pas possible d'appeler une fonction variadic en utilisant
      des arguments nommés (<xref linkend="sql-syntax-calling-funcs"/>), sauf
      quand vous spécifiez <literal>VARIADIC</literal>. Par exemple, ceci
      fonctionnera&nbsp;:

      <screen>
SELECT mleast(VARIADIC arr =&gt; ARRAY[10, -1, 5, 4.4]);
      </screen>

      mais pas cela&nbsp;:

      <screen>
SELECT mleast(arr =&gt; 10);
SELECT mleast(arr =&gt; ARRAY[10, -1, 5, 4.4]);
      </screen>
     </para>
    </sect2>

    <sect2 id="xfunc-sql-parameter-defaults">
     <title>Fonctions <acronym>SQL</acronym> avec des valeurs par défaut
      pour les arguments</title>

     <indexterm>
      <primary>fonction</primary>
      <secondary>valeurs par défaut pour les arguments</secondary>
     </indexterm>

     <para>
      Les fonctions peuvent être déclarées avec des valeurs par défaut pour
      certains des paramètres en entrée ou pour tous. Les valeurs par défaut
      sont insérées quand la fonction est appelée avec moins d'arguments que
      à priori nécessaires. Comme les arguments peuvent seulement être omis
      à partir de la fin de la liste des arguments, tous les paramètres après
      un paramètres disposant d'une valeur par défaut disposeront eux-aussi
      d'une valeur par défaut. (Bien que l'utilisation de la notation avec des
      arguments nommés pourrait autoriser une relâche de cette restriction,
      elle est toujours forcée pour que la notation des arguments de position
      fonctionne correctement.) Que vous l'utilisez ou non, cette possibilité
      implique la nécessite de prendre des précautions lors de l'appel de
      fonctions dans les bases de données où certains utilisateurs ne font pas
      confiance à d'autres utilisateurs&nbsp;;  voir <xref linkend="typeconv-func"/>.
     </para>

     <para>
      Par exemple&nbsp;:
      <screen>
CREATE FUNCTION foo(a int, b int DEFAULT 2, c int DEFAULT 3)
RETURNS int
LANGUAGE SQL
AS $$
    SELECT $1 + $2 + $3;
$$;

SELECT foo(10, 20, 30);
 foo
-----
  60
(1 row)

SELECT foo(10, 20);
 foo
-----
  33
(1 row)

SELECT foo(10);
 foo
-----
  15
(1 row)

SELECT foo();  -- échec car il n'y a pas de valeur par défaut pour le premier argument
ERROR:  function foo() does not exist
      </screen>
      Le signe <literal>=</literal> peut aussi être utilisé à la place du mot clé
      <literal>DEFAULT</literal>,
     </para>
    </sect2>

    <sect2 id="xfunc-sql-table-functions">
     <title>Fonctions <acronym>SQL</acronym> comme sources de table</title>

     <para>
      Toutes les fonctions SQL peuvent être utilisées dans la clause
      <literal>FROM</literal> d'une requête mais ceci est particulièrement utile pour les
      fonctions renvoyant des types composite. Si la fonction est définie pour
      renvoyer un type de base, la fonction table produit une table d'une seule
      colonne. Si la fonction est définie pour renvoyer un type composite, la
      fonction  table produit une colonne pour chaque attribut du type composite.
     </para>

     <para>
      Voici un exemple&nbsp;:

      <screen>CREATE TABLE foo (fooid int, foosousid int, foonom text);
INSERT INTO foo VALUES (1, 1, 'Joe');
INSERT INTO foo VALUES (1, 2, 'Ed');
INSERT INTO foo VALUES (2, 1, 'Mary');

CREATE FUNCTION recupfoo(int) RETURNS foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT *, upper(foonom) FROM recupfoo(1) AS t1;

 fooid | foosubid | foonom | upper
-------+----------+--------+-------
     1 |        1 | Joe    | JOE
(1 row)
      </screen>

      Comme le montre cet exemple, nous pouvons travailler avec les colonnes du
      résultat de la fonction comme s'il s'agissait des colonnes d'une table
      normale.
     </para>

     <para>
      Notez que nous n'obtenons qu'une ligne comme résultat de la fonction. Ceci
      parce que nous n'avons pas utilisé l'instruction <literal>SETOF</literal>. Cette
      instruction est décrite dans la prochaine section.
     </para>
    </sect2>

    <sect2 id="xfunc-sql-functions-returning-set">
     <title>Fonctions <acronym>SQL</acronym> renvoyant un ensemble </title>

     <indexterm>
      <primary>fonction</primary>
      <secondary>avec SETOF</secondary>
     </indexterm>

     <para>
      Quand une fonction SQL est déclarée renvoyer un <literal>SETOF
       <replaceable>un_type</replaceable></literal>, la requête finale de
      la fonction est complètement exécutée et chaque ligne extraite est renvoyée
      en tant qu'élément de l'ensemble résultat.
     </para>

     <para>
      Cette caractéristique est normalement utilisée lors de l'appel d'une
      fonction dans une clause <literal>FROM</literal>. Dans ce cas, chaque ligne
      renvoyée par la fonction devient une ligne de la table vue par la requête.
      Par exemple, supposons que la table <literal>foo</literal> ait le même contenu que
      précédemment et écrivons&nbsp;:

      <programlisting>CREATE FUNCTION recupfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM recupfoo(1) AS t1;
      </programlisting>

      Alors nous obtenons&nbsp;:
      <screen> fooid | foosousid | foonom
-------+-----------+--------
     1 |         1 | Joe
     1 |         2 | Ed
(2 rows)
      </screen>
     </para>

     <para>
      Il est aussi possible de renvoyer plusieurs lignes avec les colonnes
      définies par des paramètres en sortie, comme ceci&nbsp;:

      <programlisting>
CREATE TABLE tab (y int, z int);
INSERT INTO tab VALUES (1, 2), (3, 4), (5, 6), (7, 8);

CREATE FUNCTION sum_n_product_with_tab (x int, OUT sum int, OUT product int)
RETURNS SETOF record
AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;

SELECT * FROM sum_n_product_with_tab(10);
 sum | product
-----+---------
  11 |      10
  13 |      30
  15 |      50
  17 |      70
(4 rows)
      </programlisting>

      Le point clé ici est que vous devez écrire <literal>RETURNS SETOF
       record</literal> pour indiquer que la fonction renvoie plusieurs lignes
      et non pas une seule. S'il n'y a qu'un paramètre en sortie, indiquez le
      type de paramètre plutôt que <type>record</type>.
     </para>

     <para>
      Il est souvent utile de construire le résultat d'une requête par l'appel
      répété d'une fonction retournant un ensemble, dont les paramètres varient à
      chaque appel avec les valeurs des lignes d'une table ou d'une sous-requête.
      La manière idéale de le réaliser est d'utiliser le mot clé
      <literal>LATERAL</literal>, qui est décrit dans <xref
      linkend="queries-lateral"/>. Voici un exemple de fonction retournant un
      ensemble permettant d'énumérer les éléments d'une structure en arbre&nbsp;:

      <screen>SELECT * FROM noeuds;
   nom        | parent
--------------+--------
 Haut         |
 Enfant1      | Haut
 Enfant2      | Haut
 Enfant3      | Haut
 Sous-Enfant1 | Enfant1
 Sous-Enfant2 | Enfant1
(6 rows)

CREATE FUNCTION listeenfant(text) RETURNS SETOF text AS $$
    SELECT nom FROM noeuds WHERE parent = $1
$$ LANGUAGE SQL STABLE;

SELECT * FROM listeenfant('Haut');
 listeenfant
--------------
 Enfant1
 Enfant2
 Enfant3
(3 rows)

SELECT nom, enfant FROM noeuds, LATERAL listeenfant(nom) AS enfant;
  name   |    child
---------+-------------
 Haut    | Enfant1
 Haut    | Enfant2
 Haut    | Enfant3
 Enfant1 | Sous-Enfant1
 Enfant1 | Sous-Enfant2
(5 rows)
      </screen>

      Cet exemple ne fait rien de plus que ce qui aurait été possible avec
      une simple jointure mais, dans des cas plus complexes, l'alternative
      consistant à reporter du travail dans une fonction peut se révéler assez
      pratique.
     </para>

     <para>
      Les fonctions retournant des ensembles peuvent aussi être
      appelées dans la clause select d'une requête. Pour chaque ligne que cette
      requête génère par elle-même, la fonction retournant un ensemble est
      appelée, et une ligne résultat est générée pour chaque élément de l'ensemble
      retourné par la fonction.
      L'exemple précédent peut aussi être implémenté avec des requêtes telles
      que&nbsp;:

      <screen>

SELECT listeenfant('Haut');
 listeenfant
--------------
 Enfant1
 Enfant2
 Enfant3
(3 rows)

SELECT nom, listeenfant(nom) FROM noeuds;
  nom    | listeenfant
---------+--------------
 Haut    | Enfant1
 Haut    | Enfant2
 Haut    | Enfant3
 Enfant1 | Sous-Enfant1
 Enfant1 | Sous-Enfant2
(5 rows)
      </screen>

      Notez, dans le dernier <command>SELECT</command>, qu'aucune ligne n'est
      renvoyée pour <literal>Enfant2</literal>, <literal>Enfant3</literal>, etc.
      Ceci est dû au fait que la fonction <function>listeenfant</function>
      renvoie un ensemble vide pour ces arguments et ainsi aucune ligne n'est
      générée. Ce comportement est identique à celui attendu par une requête de
      jointure interne join avec le résultat de la fonction utilisant la syntaxe
      <literal>LATERAL</literal>.
     </para>

    <para>
     Le comportement de <productname>PostgreSQL</productname> pour une
     fonction renvoyant des lignes (SETOF) dans la liste SELECT d'une requête
     est pratiquement identique à celui d'une fonction SETOF écrite dans une
     clause <literal>LATERAL FROM</literal>. Par exemple&nbsp;:
<programlisting>
SELECT x, generate_series(1,5) AS g FROM tab;
</programlisting>
     est pratiquement équivalente à&nbsp;:
<programlisting>
SELECT x, g FROM tab, LATERAL generate_series(1,5) AS g;
</programlisting>
     Ce serait exactement la même chose, sauf que dans cet exemple spécifique,
     le planificateur pourrait choisir de placer <structname>g</structname> à
     l'extérieur de la jointure de boucle imbriquée puisque
     <structname>g</structname> n'a pas de réelle dépendance latérale sur
     <structname>tab</structname>. Cela résulterait en un ordre différent des
     lignes en sortie. Les fonctions SETOF dans la liste SELECT sont toujours
     évaluées comme si elles étaient à l'intérieur d'une jointure de boucle
     imbriquée avec le reste de la clause <literal>FROM</literal>, pour que
     les fonctions soient exécutées complètement avant de considérer la
     prochaine ligne provenant de la clause <literal>FROM</literal>.
    </para>

    <para>
     S'il y a plus d'une fonction SETOF dans la liste du SELECT de la requête,
     le comportement est similaire à ce que vous obtiendriez en plaçant les
     fonctions dans une seule clause <literal>FROM</literal> de
     <literal>LATERAL ROWS FROM( ... )</literal>. Pour chaque ligne de la
     requête sous-jacente, il existe une ligne en sortie utilisant le premier
     résultat de chaque fonction, ensuite une ligne en sortie utilisant le
     deuxième résultat, et ainsi de suite. Si certaines des fonctions SETOF
     produisent moins de résultats que les autres, des valeurs NULL sont
     ajoutées pour les données manquantes, pour que le nombre total de lignes
     émises pour une ligne sous-jacente soit la même que pour la fonction
     SETOF qui a produit le plus de lignes. De ce fait, les fonctions SETOF
     s'exécutent complètement jusqu'à ce qu'elles aient terminé, puis
     l'exécution continue avec la prochaine ligne sous-jacente.
    </para>

    <para>
     Les fonctions SETOF peuvent être imbriquées dans une liste SELECT, bien
     que cela ne soit pas autorisées dans les éléments d'une clause
     <literal>FROM</literal>. Dans de tels cas, chaque niveau d'imbrication
     est traité séparément, comme s'il s'agissait d'un élément
     <literal>LATERAL ROWS FROM( ... )</literal> séparé. Par exemple, dans
<programlisting>
SELECT srf1(srf2(x), srf3(y)), srf4(srf5(z)) FROM tab;
</programlisting>
     les fonctions SETOF <function>srf2</function>, <function>srf3</function>,
     et <function>srf5</function> seront exécutées ligne par ligne pour chaque
     ligne de <structname>tab</structname>, puis <function>srf1</function> et
     <function>srf4</function> seront appliquées ligne par ligne pour chaque
     ligne produite par les fonctions inférieures.
    </para>

    <para>
     Les fonctions SETOF ne peuvent pas être utilisées à l'intérieur de
     constructions d'évaluations conditionnelles, telles que
     <literal>CASE</literal> ou <literal>COALESCE</literal>. Ce comportement
     signifie aussi que des fonctions SETOF seront évaluées même quand il
     pourrait apparaître qu'elles devraient être ignorées grâce à une
     construction d'évaluation conditionnelle, telle que
     <literal>CASE</literal> ou <literal>COALESCE</literal>. Par exemple,
     considérez&nbsp;:
<programlisting>
SELECT x, CASE WHEN x &gt; 0 THEN generate_series(1, 5) ELSE 0 END FROM tab;
</programlisting>
     Il pourrait sembler que cela produit cinq répétitions des lignes en
     entrée qui ont <literal>x &gt; 0</literal>, et une seule répétition des
     autres parce que <function>generate_series(1, 5)</function> serait
     exécuté dans un élément <literal>LATERAL FROM</literal> implicite,
     l'expression <literal>CASE</literal> est toujours évaluée, elle
     produirait cinq répétitions de chaque ligne en entrée. Pour diminuer la
     confusion, ce genre de cas renvoie une erreur au moment de l'analyse.
    </para>

     <note>
      <para>
       Si la dernière commande d'une fonction est <command>INSERT</command>,
       <command>UPDATE</command> ou <command>DELETE</command> avec une clause
       <literal>RETURNING</literal>, cette commande sera toujours exécutée
       jusqu'à sa fin, même si la fonction n'est pas déclarée avec
       <literal>SETOF</literal> ou que la requête appelante ne renvoie pas toutes
       les lignes résultats. Toutes les lignes supplémentaires produites par la
       clause <literal>RETURNING</literal> sont silencieusement abandonnées mais
       les modifications de table sont pris en compte (et sont toutes terminées
       avant que la fonction ne se termine).
      </para>
     </note>

     <note>
      <para>
      Avant <productname>PostgreSQL</productname> 10, placer plus d'une
      fonction renvoyant des lignes dans la même clause SELECT n'avait pas un
      comportement très simple, sauf si elles produisaient le même nombre de
      lignes. Dans le cas contraire, on obtenait un nombre de lignes en sortie
      égale au plus petit multiple commun du nombre de lignes produit par les
      différentes fonctions. De plus, les fonctions SETOF imbriquées ne
      fonctionnaient comme ce qui est décrit ci-dessus. À la place, une
      fonction EOF pouvait avoir tout au plus un argument SETOF, et chaque
      imbrication de fonctions SETOF était exécutée séparément. De plus, une
      exécution conditionnelle (fonctions SETOF à l'intérieur d'un
      <literal>CASE</literal>, etc) était auparavant autorisée, ce qui
      compliquait encore plus les choses. L'utilisation de la syntaxe
      <literal>LATERAL</literal> est recommandée lors de l'écriture de
      requêtes devant fonctionner avec les versions plus anciennes de
      <productname>PostgreSQL</productname> pour produire des résultats
      cohérents sur différentes versions. Si vous avez une requête qui se base
      sur une exécution conditionnelle d'une fonction SETOF, vous pourriez la
      corriger en déplaçant le test conditionnel dans une fonction SETOF
      personnalisée. Par exemple&nbsp;:
<programlisting>
SELECT x, CASE WHEN y &gt; 0 THEN generate_series(1, z) ELSE 5 END FROM tab;
</programlisting>
      pourrait devenir
<programlisting>
CREATE FUNCTION case_generate_series(cond bool, start int, fin int, els int)
  RETURNS SETOF int AS $$
BEGIN
  IF cond THEN
    RETURN QUERY SELECT generate_series(start, fin);
  ELSE
    RETURN QUERY SELECT els;
  END IF;
END$$ LANGUAGE plpgsql;

SELECT x, case_generate_series(y &gt; 0, 1, z, 5) FROM tab;
</programlisting>
      Cette formulation fonctionnera de la même façon sur toutes les versions
      de <productname>PostgreSQL</productname>.
      </para>
     </note>
    </sect2>

    <sect2 id="xfunc-sql-functions-returning-table">
     <title>Fonctions <acronym>SQL</acronym> renvoyant <literal>TABLE</literal></title>

     <indexterm>
      <primary>fonction</primary>
      <secondary>RETURNS TABLE</secondary>
     </indexterm>

     <para>
      Il existe une autre façon de déclarer une fonction comme renvoyant un
      ensemble de données. Cela passe par la syntaxe <literal>RETURNS
       TABLE(<replaceable>colonnes</replaceable>)</literal>. C'est équivalent
      à utiliser un ou plusieurs paramètres <literal>OUT</literal> et à marquer
      la fonction comme renvoyant un <literal>SETOF record</literal> (ou
      <literal>SETOF</literal> d'un type simple en sortie, comme approprié).
      Cette notation est indiquée dans les versions récentes du standard SQL
      et, du coup, devrait être plus portable que <literal>SETOF</literal>.
     </para>

     <para>
      L'exemple précédent, sum-and-product, peut se faire aussi de la façon
      suivante&nbsp;:

      <programlisting>
CREATE FUNCTION sum_n_product_with_tab (x int)
RETURNS TABLE(sum int, product int) AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;
      </programlisting>

      Il n'est pas autorisé d'utiliser explicitement des paramètres
      <literal>OUT</literal> ou <literal>INOUT</literal> avec la notation
      <literal>RETURNS TABLE</literal> &mdash; vous devez indiquer toutes les
      colonnes en sortie dans la liste <literal>TABLE</literal>.
     </para>
    </sect2>

    <sect2>
     <title>Fonctions <acronym>SQL</acronym> polymorphes</title>

     <para>
      Les fonctions <acronym>SQL</acronym> peuvent être déclarées pour accepter
      et renvoyer les types <quote>polymorphe</quote> <type>anyelement</type>,
      <type>anyarray</type>, <type>anynonarray</type>, <type>anyenum</type>
      et <type>anyrange</type>.
      Voir la <xref linkend="extend-types-polymorphic"/> pour une
      explication plus approfondie. Voici une fonction polymorphe
      <function>cree_tableau</function> qui construit un tableau à partir de
      deux éléments de type arbitraire&nbsp;:

      <screen>CREATE FUNCTION cree_tableau(anyelement, anyelement) RETURNS anyarray AS $$
    SELECT ARRAY[$1, $2];
$$ LANGUAGE SQL;
SELECT cree_tableau(1, 2) AS tableau_entier, cree_tableau('a'::text, 'b') AS
tableau_texte;

 tableau_entier | tableau_texte
----------------+---------------
 {1,2}          | {a,b}
(1 row)
      </screen>
     </para>

     <para>
      Notez l'utilisation du transtypage <literal>'a'::text</literal> pour
      spécifier le type <type>text</type> de l'argument. Ceci est nécessaire si
      l'argument est une chaîne de caractères car, autrement, il serait traité
      comme un type  <type>unknown</type>, et un tableau de type
      <type>unknown</type> n'est pas un type valide. Sans le transtypage, vous
      obtiendrez ce genre d'erreur&nbsp;:

      <screen><computeroutput>ERROR:  could not determine polymorphic type because input is UNKNOWN</computeroutput></screen>
    </para>

    <para>
     Il est permis d'avoir des arguments polymorphes avec un type de renvoi
     fixe, mais non l'inverse. Par exemple&nbsp;:

<screen>CREATE FUNCTION est_plus_grand(anyelement, anyelement) RETURNS bool AS $$
    SELECT $1 &gt; $2;
$$ LANGUAGE SQL;

SELECT est_plus_grand(1, 2);
 est_plus_grand
----------------
 f
(1 row)

CREATE FUNCTION fonction_invalide() RETURNS anyelement AS $$
    SELECT 1;
$$ LANGUAGE SQL;
ERROR:  cannot determine result datatype
DETAIL:  A function returning a polymorphic type must have at least one
polymorphic argument.
      </screen>
     </para>

     <para>
      Le polymorphisme peut être utilisé avec les fonctions qui ont des
      arguments en sortie. Par exemple&nbsp;:
      <screen>CREATE FUNCTION dup (f1 anyelement, OUT f2 anyelement, OUT f3 anyarray)
AS 'select $1, array[$1,$1]' LANGUAGE SQL;

SELECT * FROM dup(22);
 f2 |   f3
----+---------
 22 | {22,22}
(1 row)
      </screen>
     </para>

     <para>
      Le polymorphisme peut aussi être utilisé avec des fonctions variadic.
      Par exemple&nbsp;:
      <screen>
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT anyleast(10, -1, 5, 4);
 anyleast
----------
       -1
(1 row)

SELECT anyleast('abc'::text, 'def');
 anyleast
----------
 abc
(1 row)

CREATE FUNCTION concat_values(text, VARIADIC anyarray) RETURNS text AS $$
    SELECT array_to_string($2, $1);
$$ LANGUAGE SQL;

SELECT concat_values('|', 1, 4, 2);
 concat_values
---------------
 1|4|2
(1 row)
      </screen>
     </para>
    </sect2>

    <sect2>
     <title>Fonctions <acronym>SQL</acronym> et collationnement</title>

     <indexterm>
      <primary>collation</primary>
      <secondary>dans les fonctions SQL</secondary>
     </indexterm>

     <para>
      Lorsqu'une fonction SQL dispose d'un ou plusieurs paramètres d'un
      type de données collationnable, le collationnement applicable
      est déterminé pour chacun des appels à la fonction afin de
      correspondre au collationnement assigné aux arguments, tel que
      décrit à la section <xref linkend="collation"/>. Si un
      collationnement peut être correctement identifié (c'est-à-dire
      qu'il ne subsiste aucun conflit entre les collationnements
      implicites des arguments), alors l'ensemble des paramètres
      collationnables sera traité en fonction de ce collationnement. Ce
      comportement peut donc avoir une incidence sur les opérations
      sensibles aux collationnements se trouvant dans le corps de la
      fonction. Par exemple, en utilisant la fonction
      <function>anyleast</function> décrite ci-dessus, le résultat de
      <programlisting>
SELECT anyleast('abc'::text, 'ABC');
      </programlisting>
      dépendra du collationnement par défaut de l'instance. Ainsi, pour
      la locale <literal>C</literal>, le résultat sera <literal>ABC</literal>,
      alors que pour de nombreuses autres locales, la fonction retournera
      <literal>abc</literal>. L'utilisation d'un collationnement
      particulier peut être forcé lors de l'appel de la fonction en
      spécifiant la clause <literal>COLLATE</literal> pour chacun des
      arguments, par exemple
      <programlisting>
SELECT anyleast('abc'::text, 'ABC' COLLATE "C");
      </programlisting>
      Par ailleurs, si vous souhaitez qu'une fonction opère avec un
      collationnement particulier, sans tenir compte du collationnement
      des paramètres qui lui seront fournis, il faudra alors spécifier la
      clause <literal>COLLATE</literal> souhaitée lors de la définition
      de la fonction. Cette version de la fonction
      <function>anyleast</function> utilisera systématiquement la locale
      <literal>fr_FR</literal> pour la comparaison des chaines de
      caractères&nbsp;:
      <programlisting>
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i] COLLATE "fr_FR") FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;
      </programlisting>
      Mais il convient de bien noter que cette modification risque
      d'entraîner une erreur si des données d'un type non sensible au
      collationnement lui sont fournies.
     </para>

     <para>
      Si aucun collationnement commun ne peut être déterminé entre les
      arguments fournis, la fonction SQL appliquera aux paramètres le
      collationnement par défaut de leur type de donnée (qui correspond
      généralement au collationnement par défaut de l'instance, mais qui
      peut différer entre des domaines différents).
     </para>

     <para>
      Le comportement des paramètres collationnables peut donc être
      assimilé à une forme limitée de polymorphisme, uniquement
      applicable aux types de données textuels.
     </para>
    </sect2>
   </sect1>

   <sect1 id="xfunc-overload">
    <title>Surcharge des fonctions</title>

    <indexterm zone="xfunc-overload">
     <primary>surcharge</primary>
     <secondary>fonctions</secondary>
    </indexterm>

    <para>
     Plusieurs fonctions peuvent être définies avec le même nom SQL à condition
     que les arguments soient différents. En d'autres termes, les noms de
     fonction peuvent être <firstterm>surchargés</firstterm>. Que vous l'utilisiez
	 ou non, cette possibilité implique des précautions au niveau de la
	 sécurité lors de l'appel de fonctions dans les bases de données où
	 certains utilisateurs ne font pas confiance aux autres utilisateurs&nbsp;;
     voir <xref linkend="typeconv-func"/>. Quand une
     requête est exécutée, le serveur déterminera la fonction à appeler à
     partir des types de données des arguments et du nombre d'arguments. La
     surcharge peut aussi être utilisée pour simuler des fonctions avec un
     nombre variable d'arguments jusqu'à un nombre maximum fini.
    </para>

    <para>
     Lors de la création d'une famille de fonctions surchargées, vous devriez
     être attentif à ne pas créer d'ambiguïtés. Par exemple, avec les
     fonctions&nbsp;:
     <programlisting>CREATE FUNCTION test(int, real) RETURNS ...
CREATE FUNCTION test(smallint, double precision) RETURNS ...</programlisting>
      Savoir quelle fonction sera appelée avec une entrée triviale comme
      <literal>test(1, 1.5)</literal> n'est pas immédiatement clair. Les
      règles de résolution actuellement implémentées sont décrites dans le
      <xref linkend="typeconv"/> mais il est déconseillé de concevoir un
      système qui serait basé subtilement sur ce comportement.
      </para>

      <para>
        Une fonction qui prend un seul argument d'un type composite devrait
        généralement ne pas avoir le même nom que tout attribut (champ) de
        ce type. Rappelez-vous que <literal><replaceable>attribut</replaceable>(<replaceable>table</replaceable>)</literal> est
        considéré comme équivalent à <literal><replaceable>table</replaceable>.<replaceable>attribut</replaceable></literal>. Dans
        le cas où il existe une ambiguïté entre une fonction sur un type
        composite et sur un attribut d'un type composite, l'attribut sera
        toujours utilisé. Il est possible de contourner ce choix en
        qualifiant le nom de la fonction avec celui du schéma (c'est-à-dire
        <literal><replaceable>schema</replaceable>.<replaceable>fonction</replaceable>(<replaceable>table</replaceable>)</literal>)
        mais il est préférable d'éviter le problème en ne choisissant aucun nom
        conflictuel.
      </para>

      <para>
       Un autre conflit possible se trouve entre les fonctions variadic et les
       autres. En fait, il est possible de créer à la fois
       <literal>foo(numeric)</literal> et <literal>foo(VARIADIC numeric[])</literal>.
       Dans ce cas, il n'est pas simple de savoir lequel sera sélectionné lors
       d'un appel avec un seul argument numérique, par exemple
       <literal>foo(10.1)</literal>. La règle est que la fonction apparaissant
       plus tôt dans le chemin des schémas est utilisé. De même, si les deux
       fonctions sont dans le même schéma, la non variadic est préféré.
      </para>

      <para>
        Lors de la surcharge de fonctions en langage C, il existe une
        contrainte supplémentaire&nbsp;: le nom C de chaque fonction dans la
        famille des fonctions surchargées doit être différent des noms C de
        toutes les autres fonctions, soit internes soit chargées dynamiquement
        Si cette règle est violée, le comportement n'est pas portable. Vous
        pourriez obtenir une erreur de l'éditeur de lien ou une des fonctions
        sera appelée (habituellement l'interne). L'autre forme de clause
        <literal>AS</literal> pour la commande SQL <command>CREATE
        FUNCTION</command> découple le nom de la fonction SQL à partir du
        nom de la fonction dans le code source C. Par exemple&nbsp;:
<programlisting>CREATE FUNCTION test(int) RETURNS int
    AS '<replaceable>filename</replaceable>', 'test_1arg'
LANGUAGE C;
CREATE FUNCTION test(int, int) RETURNS int
    AS '<replaceable>filename</replaceable>', 'test_2arg'
LANGUAGE C;
     </programlisting>
     Les noms des fonctions C reflètent ici une des nombreuses conventions
     possibles.
    </para>
   </sect1>

   <sect1 id="xfunc-volatility">
    <title>Catégories de volatilité des fonctions</title>

    <indexterm zone="xfunc-volatility">
     <primary>volatilité</primary>
     <secondary>fonctions</secondary>
    </indexterm>
    <indexterm zone="xfunc-volatility">
     <primary>VOLATILE</primary>
    </indexterm>
    <indexterm zone="xfunc-volatility">
     <primary>STABLE</primary>
    </indexterm>
    <indexterm zone="xfunc-volatility">
     <primary>IMMUTABLE</primary>
    </indexterm>

    <para>
     Chaque fonction a une classification de volatilité
     (<firstterm>volatility</firstterm>) comprenant
     <literal>VOLATILE</literal>, <literal>STABLE</literal> ou <literal>IMMUTABLE</literal>.
     <literal>VOLATILE</literal> est la valeur par défaut si la commande
     <xref linkend="sql-createfunction"/> ne
     spécifie pas de catégorie. La catégorie de volatilité est une promesse
     à l'optimiseur sur le comportement de la fonction&nbsp;:

     <itemizedlist>
      <listitem>
       <para>
        Une fonction <literal>VOLATILE</literal> peut tout faire, y compris modifier
        la base de données. Elle peut renvoyer différents
        résultats sur des appels successifs avec les mêmes arguments.
        L'optimiseur ne fait aucune supposition sur le comportement de telles
        fonctions. Une requête utilisant une fonction volatile ré-évaluera la
        fonction à chaque ligne où sa valeur est nécessaire.
       </para>
      </listitem>
      <listitem>
       <para>
        Une fonction <literal>STABLE</literal> ne peut pas modifier la base de
        données et est garantie de renvoyer les mêmes résultats si elle est
        appelée avec les mêmes arguments pour toutes les lignes à l'intérieur
        d'une même instruction. Cette catégorie permet à l'optimiseur d'optimiser
        plusieurs appels de la fonction dans une seule requête. En particulier,
        vous pouvez utiliser en toute sécurité une expression contenant une
        telle fonction dans une condition de parcours d'index (car un parcours
        d'index évaluera la valeur de la comparaison une seule fois, pas une
        fois pour chaque ligne, utiliser une fonction <literal>VOLATILE</literal> dans
        une condition de parcours d'index n'est pas valide).
       </para>
      </listitem>
      <listitem>
       <para>
        Une fonction <literal>IMMUTABLE</literal> ne peut pas modifier la base de
        données et est garantie de toujours renvoyer les mêmes résultats si
        elle est appelée avec les mêmes arguments. Cette catégorie permet à
        l'optimiseur de pré-évaluer la fonction quand une requête l'appelle
        avec des arguments constants. Par exemple, une requête comme
        <literal>SELECT ... WHERE x = 2 + 2</literal> peut être simplifiée pour
        obtenir <literal>SELECT ... WHERE x = 4</literal> car la fonction sous-jacente
        de l'opérateur d'addition est indiquée <literal>IMMUTABLE</literal>.
       </para>
      </listitem>
     </itemizedlist>

    </para>

    <para>
     Pour une meilleure optimisation des résultats, vous devez mettre un label
     sur les fonctions avec la catégorie la plus volatile valide pour elles.
    </para>

    <para>
     Toute fonction avec des effets de bord <emphasis>doit</emphasis> être indiquée
     comme <literal>VOLATILE</literal>, de façon à ce que les appels ne puissent pas
     être optimisés. Même une fonction sans effets de bord doit être indiquée
     comme <literal>VOLATILE</literal> si sa valeur peut changer à l'intérieur
     d'une seule requête&nbsp;; quelques exemples sont <literal>random()</literal>,
     <literal>currval()</literal>, <literal>timeofday()</literal>.
    </para>

    <para>
     Un autre exemple important est que la famille de fonctions
     <function>current_timestamp</function> est qualifiée comme
     <literal>STABLE</literal> car leurs valeurs ne changent pas à l'intérieur
     d'une transaction.
    </para>

    <para>
     Il y a relativement peu de différences entre les catégories
     <literal>STABLE</literal> et <literal>IMMUTABLE</literal> en considérant les requêtes
     interactives qui sont planifiées et immédiatement exécutées&nbsp;: il
     importe peu que la fonction soit exécutée une fois lors de la
     planification ou une fois au lancement de l'exécution de la requête mais
     cela fait une grosse différence si le plan est sauvegardé et utilisé plus
     tard. Placer un label <literal>IMMUTABLE</literal> sur une fonction quand elle
     ne l'est pas vraiment pourrait avoir comme conséquence de la considérer
     prématurément comme une constante lors de la planification et résulterait en une valeur
     erronée lors d'une utilisation ultérieure de ce plan d'exécution.
     C'est un danger qui arrive lors de l'utilisattion d'instructions préparées
     ou avec l'utilisation de langages de fonctions mettant les plans d'exécutions
     en cache (comme
     <application>PL/pgSQL</application>).
    </para>

    <para>
     Pour les fonctions écrites en SQL ou dans tout autre langage de procédure
     standard, la catégorie de volatibilité détermine une deuxième propriété
     importante, à savoir la visibilité de toute modification de données
     effectuées par la commande SQL qui a appelé la fonction. Une fonction
     <literal>VOLATILE</literal> verra les changements, une fonction
     <literal>STABLE</literal> ou <literal>IMMUTABLE</literal> ne les verra pas.
     Ce comportement est implantée en utilisant le comportement par images de
     MVCC (voir <xref linkend="mvcc"/>)&nbsp;: les fonctions
     <literal>STABLE</literal> et <literal>IMMUTABLE</literal> utilisent une
     image établie au lancement de la requête appelante alors que les fonctions
     <literal>VOLATILE</literal> obtiennent une image fraiche au début de chaque
     requête qu'elles exécutent.
    </para>

    <note>
     <para>
      Les fonctions écrites en C peuvent gérer les images de la façon qu'elles
      le souhaitent, mais il est préférable de coder les fonctions C de la même
      façon.
     </para>
    </note>

    <para>
     À cause du comportement à base d'images, une fonction contenant seulement des commandes
     <command>SELECT</command> peut être indiquée <literal>STABLE</literal> en toute sécurité
     même s'il sélectionne des données à partir de tables qui pourraient
     avoir subi des modifications entre temps par des requêtes concurrentes.
     <productname>PostgreSQL</productname> exécutera toutes les commandes d'une fonction
     <literal>STABLE</literal> en utilisant l'image établie par la requête appelante et
     n'aura qu'une vision figée de la base de données au cours de la requête.
    </para>

    <para>
     Ce même comportement d'images est utilisé pour les commandes
     <command>SELECT</command> à l'intérieur de fonctions <literal>IMMUTABLE</literal>. Il
     est généralement déconseillé de sélectionner des tables de la base de
     données à l'intérieur de fonctions <literal>IMMUTABLE</literal> car
     l'immutabilité sera rompue si le contenu de la table change. Néanmoins,
     <productname>PostgreSQL</productname> ne vous force pas à ne pas le faire.
    </para>

    <para>
     Une erreur commune est de placer un label sur une fonction
     <literal>IMMUTABLE</literal> quand son résultat dépend d'un paramètre de
     configuration. Par exemple, une fonction qui manipule des types date/heure
     pourrait bien avoir des résultats dépendant du paramètre
     <xref linkend="guc-timezone"/>. Pour être sécurisées, de telles
     fonctions devraient avoir le label <literal>STABLE</literal> à la place.
    </para>

    <note>
     <para>
      <productname>PostgreSQL</productname> requiert que les fonctions
      <literal>STABLE</literal> et <literal>IMMUTABLE</literal> ne contiennent
      aucune commande SQL autre que <command>SELECT</command> pour éviter les
      modifications de données (ceci n'a pas été complètement testé car de
      telles fonctions pourraient toujours appeler des fonctions
      <literal>VOLATILE</literal> qui modifient la base de données. Si vous le
      faites, vous trouverez que la fonction <literal>STABLE</literal> ou
      <literal>IMMUTABLE</literal> n'est pas au courant des modifications
      effectuées sur la base de données par la fonction appelée, car elles
      sont cachées depuis son image).
     </para>
    </note>
   </sect1>

   <sect1 id="xfunc-pl">
    <title>Fonctions en langage de procédures</title>

    <para>
     <productname>PostgreSQL</productname> autorise l'écriture de fonctions
     définies par l'utilisateur dans d'autres langages que SQL et C. Ces autres
     langages sont appelés des <firstterm>langages de procédure</firstterm>
     (<acronym>PL</acronym>). Les langages de procédures ne sont pas compilés dans le
     serveur <productname>PostgreSQL</productname>&nbsp;; ils sont fournis comme
     des modules chargeables. Voir le <xref linkend="xplang"/> et les chapitres
     suivants pour plus d'informations.
    </para>

    <para>
     Il y a actuellement quatre langages de procédures disponibles dans la
     distribution <productname>PostgreSQL</productname> standard&nbsp;:
     <application>PL/pgSQL</application>, <application>PL/Tcl</application>,
     <application>PL/Perl</application> et <application>PL/Python</application>.

     Référez-vous au <xref linkend="xplang"/> pour plus d'informations. D'autres
     langages peuvent être définis par les utilisateurs. Les bases du
     développement d'un nouveau langage de procédures sont traitées dans le <xref
     linkend="plhandler"/>.
    </para>

   </sect1>

   <sect1 id="xfunc-internal">
    <title>Fonctions internes</title>

    <indexterm zone="xfunc-internal"><primary>fonction</primary><secondary>interne</secondary></indexterm>

    <para>
     Les fonctions internes sont des fonctions écrites en C qui ont été liées de
     façon statique dans le serveur <productname>PostgreSQL</productname>. Le
     <quote>corps</quote> de la définition de la fonction spécifie le nom en
     langage C de la fonction, qui n'est pas obligatoirement le même que le nom
     déclaré pour l'utilisation en SQL (pour des raisons de rétro compatibilité,
     un corps vide est accepté pour signifier que le nom de la fonction en
     langage C est le même que le nom SQL).

    </para>

    <para>
     Normalement, toutes les fonctions internes présentes dans le serveur sont
     déclarées pendant l'initialisation du groupe de base de données
     (voir <xref linkend="creating-cluster"/>) mais un utilisateur peut utiliser la commande
     <command>CREATE FUNCTION</command> pour créer des noms d'alias
     supplémentaires pour une fonction interne. Les fonctions internes sont
     déclarées dans la commande <command>CREATE FUNCTION</command> avec le nom
     de langage <literal>internal</literal>. Par exemple, pour créer un alias
     de la fonction <function>sqrt</function>&nbsp;:

     <programlisting>CREATE FUNCTION racine_carree(double precision) RETURNS double precision    AS
'dsqrt'
LANGUAGE internal    STRICT;
     </programlisting>

     (la plupart des fonctions internes doivent être déclarées
     <quote>STRICT</quote>)
    </para>

    <note>
     <para>
      Toutes les fonctions <quote>prédéfinies</quote> ne sont pas internes (au
      sens explicité ci-dessus). Quelques fonctions prédéfinies sont écrites en
      SQL.
     </para>
    </note>
   </sect1>

   <sect1 id="xfunc-c">
    <title>Fonctions en langage C</title>

    <indexterm zone="xfunc-c">
     <primary>fonction</primary>
     <secondary>définie par l'utilisateur</secondary>
     <tertiary>en C</tertiary>
    </indexterm>

    <para>
     Les fonctions définies par l'utilisateur peuvent être écrites en C (ou dans
     un langage pouvant être rendu compatible avec C, comme le C++). Ces fonctions
     sont compilées en objets dynamiques chargeables (encore appelés
     bibliothèques partagées) et sont chargées par le serveur à la demande. Cette
     caractéristique de chargement dynamique est ce qui distingue les fonctions
     en <quote>langage C</quote> des fonctions <quote>internes</quote> &mdash; les véritables
     conventions de codage sont essentiellement les mêmes pour les deux (c'est
     pourquoi la bibliothèque standard de fonctions internes est une source
     abondante d'exemples de code pour les fonctions C définies par
     l'utilisateur).
    </para>

    <para>
     Actuellement, seule une convention d'appel est utilisée pour les
     fonctions C (<quote>version 1</quote>). Le support pour cette convention
     d'appel est indiqué en ajoutant un appel à la macro
     <literal>PG_FUNCTION_INFO_V1()</literal> pour la fonction, comme illustré
     ci-dessous.
    </para>

    <sect2 id="xfunc-c-dynload">
     <title>Chargement dynamique</title>

     <indexterm zone="xfunc-c-dynload">
      <primary>dynamic loading</primary>
     </indexterm>

     <para>
      La première fois qu'une fonction définie par l'utilisateur dans un fichier
      objet particulier chargeable est appelée dans une session, le chargeur
      dynamique charge ce fichier objet en mémoire de telle sorte que la fonction
      peut être appelée. La commande <command>CREATE FUNCTION</command> pour une
      fonction en C définie par l'utilisateur doit par conséquent spécifier deux
      éléments d'information pour la fonction&nbsp;: le nom du fichier objet
      chargeable et le nom en C (lien symbolique) de la fonction spécifique à
      appeler à l'intérieur de ce fichier objet. Si le nom en C n'est pas
      explicitement spécifié, il est supposé être le même que le nom de la
      fonction SQL.
     </para>

     <para>
      L'algorithme suivant, basé sur le nom donné dans la commande
      <command>CREATE FUNCTION</command>, est utilisé pour localiser le fichier
      objet partagé&nbsp;:

      <orderedlist>
       <listitem>
        <para>
         Si le nom est un chemin absolu, le fichier est chargé.
        </para>
       </listitem>

       <listitem>
        <para>
         Si le nom commence par la chaîne <literal>$libdir</literal>, cette chaîne
         est remplacée par le nom du répertoire de la bibliothèque du paquetage
         <productname>PostgreSQL</productname>, qui est déterminé au moment de la
         compilation. <indexterm><primary>$libdir</primary></indexterm>
        </para>
       </listitem>

       <listitem>
        <para>
         Si le nom ne contient pas de partie répertoire, le fichier est recherché
         par le chemin spécifié dans la variable de configuration
         <xref linkend="guc-dynamic-library-path"/>.
         <indexterm><primary>dynamic_library_path</primary></indexterm>
        </para>
       </listitem>

       <listitem>
        <para>
         Dans les autres cas, (nom de fichier non trouvé dans le chemin ou ne
         contenant pas de partie répertoire non absolu), le chargeur dynamique
         essaiera d'utiliser le nom donné, ce qui échouera très vraisemblablement
         (dépendre du répertoire de travail en cours n'est pas fiable).
        </para>
       </listitem>
      </orderedlist>

      Si cette séquence ne fonctionne pas, l'extension pour les noms de fichier
      des bibliothèques partagées spécifique à la plateforme (souvent
      <filename>.so</filename>) est ajoutée au nom attribué et la séquence est à
      nouveau tentée. En cas de nouvel échec, le chargement échoue.
     </para>

     <para>
      Il est recommandé de localiser les bibliothèques partagées soit relativement
      à <literal>$libdir</literal> ou via le chemin dynamique des bibliothèques.
      Ceci simplifie les mises à jour de versions si la nouvelle installation est
      à un emplacement différent. Le répertoire actuel représenté par
      <literal>$libdir</literal> est trouvable avec la commande
      <literal>pg_config --pkglibdir</literal>.
     </para>

     <para>
      L'identifiant utilisateur sous lequel fonctionne le serveur
      <productname>PostgreSQL</productname> doit pouvoir suivre le chemin
      jusqu'au fichier que vous essayez de charger. Une erreur fréquente revient
      à définir le fichier ou un répertoire supérieur comme non lisible et/ou
      non exécutable par l'utilisateur <systemitem>postgres</systemitem>.
     </para>

     <para>
      Dans tous les cas, le nom de fichier donné dans la commande <command>CREATE
       FUNCTION</command> est enregistré littéralement dans les catalogues
      systèmes, de sorte que, si le fichier doit être à nouveau chargé, la même
      procédure sera appliquée.
     </para>

     <note>
      <para>
       <productname>PostgreSQL</productname> ne compilera pas une fonction C
       automatiquement. Le fichier objet doit être compilé avant d'être référencé
       dans une commande <command>CREATE FUNCTION</command>. Voir la <xref
       linkend="dfunc"/> pour des informations complémentaires.
      </para>
     </note>

     <indexterm zone="xfunc-c-dynload">
      <primary>bloc magique</primary>
     </indexterm>

     <para>
      Pour s'assurer qu'un fichier objet chargeable dynamiquement n'est pas chargé
      dans un serveur incompatible, <productname>PostgreSQL</productname> vérifie
      que le fichier contient un <quote>bloc magique</quote> avec un contenu
      approprié. Ceci permet au serveur de détecter les incompatibilités évidentes
      comme du code compilet pour une version majeure différente de
      <productname>PostgreSQL</productname>. Pour inclure un bloc magique,
      écrivez ceci dans un (et seulement un) des fichiers source du module, après
      avoir inclus l'en-tête <filename>fmgr.h</filename>&nbsp;:

      <programlisting>PG_MODULE_MAGIC;</programlisting>
     </para>

     <para>
      Après avoir été utilisé pour la première fois, un fichier objet chargé
      dynamiquement est conservé en mémoire. Les futurs appels de fonction(s) dans
      ce fichier pendant la même session provoqueront seulement une légère
      surcharge due à la consultation d'une table de symboles. Si vous devez
      forcer le chargement d'un fichier objet, par exemple après une
      recompilation, commencez une nouvelle session.
     </para>

     <indexterm zone="xfunc-c-dynload">
      <primary>_PG_init</primary>
     </indexterm>
     <indexterm zone="xfunc-c-dynload">
      <primary>_PG_fini</primary>
     </indexterm>
     <indexterm zone="xfunc-c-dynload">
      <primary>fonction d'initialisation de la bibliothèque</primary>
     </indexterm>
     <indexterm zone="xfunc-c-dynload">
      <primary>fonction de terminaison de la bibliothèque</primary>
     </indexterm>

     <para>
      De façon optionnelle, un fichier chargé dynamiquement peut contenir des
      fonctions d'initialisation et de terminaison. Si le fichier inclut une
      fonction nommée <function>_PG_init</function>, cette fonction sera appelée
      immédiatement après le chargement du fichier. La fonction ne reçoit
      aucun paramètre et doit renvoyer void. Si le fichier inclut une fonction
      nommée <function>_PG_fini</function>, cette fonction sera appelée tout juste
      avant le déchargement du fichier. De la même façon, la fonction ne reçoit
      aucun paramètre et doit renvoyer void. Notez que <function>_PG_fini</function>
      sera seulement appelée lors du déchargement du fichier, pas au moment de la
      fin du processus. (Actuellement, les déchargements sont désactivés et ne
      surviendront jamais, bien que cela puisse changer un jour.)
     </para>

    </sect2>

    <sect2 id="xfunc-c-basetype">
     <title>Types de base dans les fonctions en langage C</title>

     <indexterm zone="xfunc-c-basetype">
      <primary>type de données</primary>
      <secondary>organisation interne</secondary>
     </indexterm>

     <para>
      Pour savoir comment écrire des fonctions en langage C, vous devez savoir
      comment <productname>PostgreSQL</productname> représente en interne les
      types de données de base et comment elles peuvent être passés vers et
      depuis les fonctions. En interne, <productname>PostgreSQL</productname>
      considère un type de base comme un <quote>blob de mémoire</quote>. Les
      fonctions que vous définissez sur un type définissent à leur tour la façon
      que <productname>PostgreSQL</productname> opère sur lui. C'est-à-dire
      que <productname>PostgreSQL</productname> ne fera que conserver et retrouver
      les données sur le disque et utilisera votre fonction pour entrer, traiter
      et restituer les données.
     </para>

     <para>
      Les types de base peuvent avoir un des trois formats internes
      suivants&nbsp;:
      <itemizedlist>
       <listitem>
        <para>
         passage par valeur, longueur fixe&nbsp;;
        </para>
       </listitem>
       <listitem>
        <para>
         passage par référence, longueur fixe&nbsp;;
        </para>
       </listitem>
       <listitem>
        <para>
         passage par référence, longueur variable.
        </para>
       </listitem>
      </itemizedlist>
     </para>

     <para>
      Les types par valeur peuvent seulement avoir une longueur de 1, 2 ou 4
      octets (également 8 octets si <literal>sizeof(Datum)</literal> est de huit
      octets sur votre machine). Vous devriez être attentif lors de la
      définition de vos types de sorte à qu'ils aient la même taille sur toutes
      les architectures. Par exemple, le type <literal>long</literal> est
      dangereux car il a une taille de quatre octets sur certaines machines et
      huit octets sur d'autres, alors que le type <type>int</type> est de quatre
      octets sur la plupart des machines Unix. Une implémentation raisonnable du
      type <type>int4</type> sur une machine Unix pourrait être

      <programlisting>/* entier sur quatre octets, passé par valeur */
typedef int int4;
      </programlisting>

      (le code C de PostgreSQL appelle ce type <type>int32</type> car il
      existe une convention en C disant que <type>int<replaceable>XX</replaceable></type>
      signifie <replaceable>XX</replaceable> <emphasis>bits</emphasis>. Il est
      à noter toutefois que le type C <type>int8</type> a une taille d'un octet.
      Le type SQL <type>int8</type> est appelé <type>int64</type> en C. Voir
      aussi <xref linkend="xfunc-c-type-table"/>.)
     </para>

     <para>
      D'autre part, les types à longueur fixe d'une taille quelconque peuvent
      être passés par référence. Par exemple, voici l'implémentation d'un type
      <productname>PostgreSQL</productname>&nbsp;:

      <programlisting>/* structure de 16 octets, passée par référence */
typedef struct
{
    double  x, y;
} Point;
      </programlisting>

      Seuls des pointeurs vers de tels types peuvent être utilisés en les passant
      dans et hors des fonctions <productname>PostgreSQL</productname>. Pour
      renvoyer une valeur d'un tel type, allouez la quantité appropriée de
      mémoire avec <literal>palloc</literal>, remplissez la mémoire allouée et
      renvoyez un pointeur vers elle (de plus, si vous souhaitez seulement
      renvoyer la même valeur qu'un de vos arguments en entrée qui se trouve du
      même type, vous pouvez passer le <literal>palloc</literal>
      supplémentaire et simplement renvoyer le pointeur vers la valeur en
      entrée).
     </para>

     <para>
      Enfin, tous les types à longueur variable doivent aussi être passés par
      référence. Tous les types à longueur variable doivent commencer avec un
      champ d'une longueur d'exactement quatre octets, qui sera initialisé à
      <symbol>SET_VARSIZE</symbol>&nbsp;; ne jamais configurer ce champ directement&nbsp;!
      Toutes les données
      devant être stockées dans ce type doivent être localisées dans la mémoire à
      la suite immédiate de ce champ longueur. Le champ longueur contient la
      longueur totale de la structure, c'est-à-dire incluant la longueur du
      champ longueur lui-même.
     </para>

     <para>
      Un autre point important est d'éviter de laisser des bits non initialisés
      dans les structures de types de données&nbsp;;; par exemple, prenez bien soin
      de remplir avec des zéros tous les octets de remplissage qui sont présents
      dans les structures de données à des fins d'alignement. A défaut, des
      constantes logiquement équivalentes de vos types de données pourraient
      être considérées comme inégales par l'optimiseur, impliquant une
      planification inefficace (bien que les résultats puissent malgré tout
      être corrects).
     </para>

     <warning>
      <para>
       Ne <emphasis>jamais</emphasis> modifier le contenu d'une valeur en entrée passée
       par référence. Si vous le faites, il y a de forts risques pour que
       vous réussissiez à corrompre les données sur disque car le pointeur que
       vous avez reçu pourrait bien pointer directement vers un tampon disque.
       La seule exception à cette règle est expliquée dans la <xref
       linkend="xaggr"/>.
      </para>
     </warning>

     <para>
      Comme exemple, nous pouvons définir le type <type>text</type> comme
      ceci&nbsp;:

      <programlisting>typedef struct {
    int32 length;
    char data[FLEXIBLE_ARRAY_MEMBER];
} text;
      </programlisting>

     La notation <literal>[FLEXIBLE_ARRAY_MEMBER]</literal> signifie que la
     longueur actuelle de la donnée n'est pas indiquée par cette déclaration.
     </para>

     <para>
      En manipulant les types à longueur variable, nous devons être attentifs à
      allouer la quantité correcte de mémoire et à fixer correctement le champ
      longueur. Par exemple, si nous voulons stocker 40 octets dans une structure
      <structname>text</structname>, nous devrions utiliser un fragment de code comme
      celui-ci&nbsp;:

      <programlisting><![CDATA[#include "postgres.h"
...
char buffer[40]; /* notre donnée source */
...
text *destination = (text *) palloc(VARHDRSZ + 40);
SET_VARSIZE(destination, VARHDRSZ + 40);
memcpy(destination->data, buffer, 40);
...
]]></programlisting>

     <literal>VARHDRSZ</literal> est équivalent à <literal>sizeof(int32)</literal> mais
     est considéré comme une meilleure tournure de référence à la taille de
     l'overhead pour un type à longueur variable.
     De plus, le champ de longueur <emphasis>doit</emphasis> être configuré en utilisant
     la macro <literal>SET_VARSIZE</literal>, pas une simple affectation.
    </para>

    <para>
     Le <xref linkend="xfunc-c-type-table"/> spécifie la correspondance entre
     les types C et les types SQL quand on écrit une fonction en langage C
     utilisant les types internes de <productname>PostgreSQL</productname>. La colonne
     <quote>Défini dans</quote> donne le fichier d'en-tête devant être inclus
     pour accéder à la définition du type (la définition effective peut se
     trouver dans un fichier différent inclus dans le fichier indiqué. Il
     est recommandé que les utilisateurs s'en tiennent à l'interface définie).
     Notez que vous devriez toujours inclure <filename>postgres.h</filename> en
     premier dans tout fichier source car il déclare un grand nombre d'éléments
     dont vous aurez besoin de toute façon.
    </para>

    <table tocentry="1" id="xfunc-c-type-table">
      <title>Équivalence des types C et des types SQL intégrés</title>
      <tgroup cols="3">
       <colspec colnum="1" colwidth="0.7*"/>
       <colspec colnum="2" colwidth="0.5*"/>
       <colspec colnum="3" colwidth="1.8*"/>
       <thead>
	<row>
	 <entry>
	  Type SQL
	 </entry>
	 <entry>
	  Type C
	 </entry>
	 <entry>
	  Défini dans
	 </entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry><type>boolean</type></entry>
	 <entry><type>bool</type></entry>
	 <entry><filename>postgres.h</filename> (intégration au
	  compilateur)</entry>
	</row>
	<row>
	 <entry><type>box</type></entry>
	 <entry><type>BOX*</type></entry>
	 <entry><filename>utils/geo_decls.h</filename></entry>
	</row>
	<row>
	 <entry><type>bytea</type></entry>
	 <entry><type>bytea*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>"char"</type></entry>
	 <entry><type>char</type></entry>
	 <entry>(intégré au compilateur)</entry>
	</row>
	<row>
	 <entry><type>character</type></entry>
	 <entry><type>BpChar*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>cid</type></entry>
	 <entry><type>CommandId</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>date</type></entry>
	 <entry><type>DateADT</type></entry>
	 <entry><filename>utils/date.h</filename></entry>
	</row>
	<row>
	 <entry><type>smallint</type> (<type>int2</type>)</entry>
	 <entry><type>int16</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>int2vector</type></entry>
	 <entry><type>int2vector*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>integer</type> (<type>int4</type>)</entry>
	 <entry><type>int32</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>real</type> (<type>float4</type>)</entry>
	 <entry><type>float4*</type></entry>
	<entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>double precision</type> (<type>float8</type>)</entry>
	 <entry><type>float8*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>interval</type></entry>
	 <entry><type>Interval*</type></entry>
	 <entry><filename>datatype/timestamp.h</filename></entry>
	</row>
	<row>
	 <entry><type>lseg</type></entry>
	 <entry><type>LSEG*</type></entry>
	 <entry><filename>utils/geo_decls.h</filename></entry>
	</row>
	<row>
	 <entry><type>name</type></entry>
	 <entry><type>Name</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>oid</type></entry>
	 <entry><type>Oid</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>oidvector</type></entry>
	 <entry><type>oidvector*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>path</type></entry>
	 <entry><type>PATH*</type></entry>
	 <entry><filename>utils/geo_decls.h</filename></entry>
	</row>
	<row>
	 <entry><type>point</type></entry>
	 <entry><type>POINT*</type></entry>
	 <entry><filename>utils/geo_decls.h</filename></entry>
	</row>
	<row>
	 <entry><type>regproc</type></entry>
	 <entry><type>regproc</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>text</type></entry>
	 <entry><type>text*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>tid</type></entry>
	 <entry><type>ItemPointer</type></entry>
	 <entry><filename>storage/itemptr.h</filename></entry>
	</row>
	<row>
	 <entry><type>time</type></entry>
	 <entry><type>TimeADT</type></entry>
	 <entry><filename>utils/date.h</filename></entry>
	</row>
	<row>
	 <entry><type>time with time zone</type></entry>
	 <entry><type>TimeTzADT</type></entry>
	 <entry><filename>utils/date.h</filename></entry>
	</row>
	<row>
	 <entry><type>timestamp</type></entry>
	 <entry><type>Timestamp*</type></entry>
	 <entry><filename>datatype/timestamp.h</filename></entry>
	</row>
	<row>
	 <entry><type>varchar</type></entry>
	 <entry><type>VarChar*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>xid</type></entry>
	 <entry><type>TransactionId</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
       </tbody>
      </tgroup>
     </table>

    <para>
     Maintenant que nous avons passé en revue toutes les structures possibles
     pour les types de base, nous pouvons donner quelques exemples de vraies
     fonctions.
 </para>
   </sect2>

    <sect2>
     <title>Conventions d'appel de la version 1</title>

     <para>
      La convention d'appel version-1 repose sur des macros pour supprimer la
      plus grande partie de la complexité du passage d'arguments et de résultats.
      La déclaration C d'une fonction en version-1 est toujours&nbsp;:

      <programlisting>Datum nom_fonction(PG_FUNCTION_ARGS)
      </programlisting>

      De plus, la macro d'appel&nbsp;:
      <programlisting>PG_FUNCTION_INFO_V1(nom_fonction);
      </programlisting>
      doit apparaître dans le même fichier source (par convention, elle est
      écrite juste avant la fonction elle-même). Cette macro n'est pas nécessaire
      pour les fonctions <literal>internal</literal> puisque <productname>PostgreSQL</productname>
      assume que toutes les fonctions internes utilisent la convention version-1.
      Elle est toutefois requise pour les fonctions chargées dynamiquement.
     </para>

     <para>
      Dans une fonction version-1, chaque argument existant est traité par une
      macro <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>
      correspondant au type de donnée de l'argument. (Dans les fonctions non
      strictes, il est nécessaire d'avoir une vérification précédente sur la
      possibilité que l'argument soit NULL en utilisant
      <function>PG_ARGISNULL()</function>&nbsp;; voir ci-dessous.)
      Le résultat est renvoyé par une macro
      <function>PG_RETURN_<replaceable>xxx</replaceable>()</function>
      correspondant au type renvoyé.
      <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>
      prend comme argument le nombre d'arguments de la fonction à parcourir, le
      compteur commençant à 0.
      <function>PG_RETURN_<replaceable>xxx</replaceable>()</function> prend comme
      argument la valeur effective à renvoyer.
     </para>

     <para>
      Voici quelques exemples utilisant la convention d'appel version-1&nbsp;:
     </para>

      <programlisting><![CDATA[#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"

PG_MODULE_MAGIC;

/* par valeur */

PG_FUNCTION_INFO_V1(add_one);

Datum
add_one(PG_FUNCTION_ARGS)
{
    int32   arg = PG_GETARG_INT32(0);

    PG_RETURN_INT32(arg + 1);
}

/* par référence, longueur fixe */

PG_FUNCTION_INFO_V1(add_one_float8);

Datum
add_one_float8(PG_FUNCTION_ARGS)
{
    /* La macro pour FLOAT8 cache sa nature de passage par référence. */
    float8   arg = PG_GETARG_FLOAT8(0);

    PG_RETURN_FLOAT8(arg + 1.0);
}

PG_FUNCTION_INFO_V1(makepoint);

Datum
makepoint(PG_FUNCTION_ARGS)
{
    /* Ici, la nature de passage par référence de Point n'est pas cachée. */
    Point     *pointx = PG_GETARG_POINT_P(0);
    Point     *pointy = PG_GETARG_POINT_P(1);
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point->x = pointx->x;
    new_point->y = pointy->y;

    PG_RETURN_POINT_P(new_point);
}

/* par référence, longueur variable */

PG_FUNCTION_INFO_V1(copytext);

Datum
copytext(PG_FUNCTION_ARGS)
{
    text     *t = PG_GETARG_TEXT_PP(0);
    /*
     * VARSIZE_ANY_EXHDR is the size of the struct in bytes, minus the
     * VARHDRSZ or VARHDRSZ_SHORT of its header.  Construct the copy with a
     * full-length header.
     */
    text     *new_t = (text *) palloc(VARSIZE_ANY_EXHDR(t) + VARHDRSZ);
    SET_VARSIZE(new_t, VARSIZE_ANY_EXHDR(t) + VARHDRSZ);

    /*
     * VARDATA is a pointer to the data region of the new struct.  The source
     * could be a short datum, so retrieve its data through VARDATA_ANY.
     */
    memcpy((void *) VARDATA(new_t), /* destination */
           (void *) VARDATA_ANY(t), /* source */
           VARSIZE_ANY_EXHDR(t));   /* how many bytes */
    PG_RETURN_TEXT_P(new_t);
}

PG_FUNCTION_INFO_V1(concat_text);

Datum
concat_text(PG_FUNCTION_ARGS)
{
    text  *arg1 = PG_GETARG_TEXT_PP(0);
    text  *arg2 = PG_GETARG_TEXT_PP(1);
    int32 arg1_size = VARSIZE_ANY_EXHDR(arg1);
    int32 arg2_size = VARSIZE_ANY_EXHDR(arg2);
    int32 new_text_size = arg1_size + arg2_size + VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    SET_VARSIZE(new_text, new_text_size);
    memcpy(VARDATA(new_text), VARDATA_ANY(arg1), arg1_size);
    memcpy(VARDATA(new_text) + arg1_size, VARDATA_ANY(arg2), arg2_size);
    PG_RETURN_TEXT_P(new_text);
}
]]></programlisting>

    <para>
     En supposant que le code ci-dessus a été enregistré dans le fichier
     <filename>funcs.c</filename> et compilé en un objet partagé, nous pouvons
     définir les fonctions dans <productname>PostgreSQL</productname> avec les
     commandes suivantes&nbsp;:
    </para>

<programlisting>
CREATE FUNCTION add_one(integer) RETURNS integer
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one'
     LANGUAGE C STRICT;

-- note overloading of SQL function name "add_one"
CREATE FUNCTION add_one(double precision) RETURNS double precision
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one_float8'
     LANGUAGE C STRICT;

CREATE FUNCTION makepoint(point, point) RETURNS point
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'makepoint'
     LANGUAGE C STRICT;

CREATE FUNCTION copytext(text) RETURNS text
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'copytext'
     LANGUAGE C STRICT;

CREATE FUNCTION concat_text(text, text) RETURNS text
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'concat_text'
     LANGUAGE C STRICT;
</programlisting>

    <para>
     Ici, <replaceable>DIRECTORY</replaceable> indique le répertoire de la
     bibliothèque partagée (par exemple le répertoire du tutoriel
     <productname>PostgreSQL</productname> qui contient le code des exemples
     utilisés dans cette section). (Il serait préférable d'utiliser seulement
     <literal>'funcs'</literal> dans la clause <literal>AS</literal>, après
     avoir ajouté <replaceable>DIRECTORY</replaceable> au chemin de
     recherches. Dans tous les cas, nous pouvons omettre l'extension
     spécifique du système pour une bibliothèque partagée, généralement
     <literal>.so</literal>.)
    </para>

    <para>
     Notez que nous avons spécifié les fonctionns comme <quote>strict</quote>,
     ceci signifiant que le système pourrait automatiquement supposer un
     résultat NULL si une des valeurs en entrée était NULL. En le faisant,
     nous évitons la vérification des entrées NULL dans le code de la
     fonction. Sans cela, nous devrions vérifier les valeurs NULL
     explicitement en utilisant la macro <function>PG_ARGISNULL()</function>.
    </para>

    <para>
     La macro
     <function>PG_ARGISNULL(<replaceable>n</replaceable>)</function> permet à une fonction
     de tester si chaque entrée est NULL (évidemment, ceci n'est nécessaire que
     pour les fonctions déclarées non <quote>STRICT</quote>). Comme avec les macros
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>, les
     arguments en entrée sont comptés à partir de zéro. Notez qu'on doit se
     garder d'exécuter
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function> jusqu'à
     ce qu'on ait vérifié que l'argument n'est pas NULL. Pour renvoyer un
     résultat NULL, exécutez la fonction
     <function>PG_RETURN_NULL()</function>&nbsp;; ceci convient aussi bien dans
     les fonctions STRICT que non STRICT.
    </para>

    <para>
     Au premier coup d'&oelig;ud, les conventions de codage version-1
     pourraient ressembler à de l'obscurantisme sans raison. Il pourrait
     sembler préférable d'utiliser les conventions d'appel
     <literal>C</literal>. Néanmoins, elles permettent de gérer des valeurs
     NULL pour les arguments et la valeur de retour calling, ainsi que des
     valeurs TOAST (compressées ou hors-ligne).
    </para>

    <para>
     Les autres options proposées dans l'interface version 1 sont deux
     variantes des macros
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>. La
     première d'entre elles,
     <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>,
     garantit le renvoi d'une copie de l'argument spécifié où nous pouvons
     écrire en toute sécurité (les macros normales peuvent parfois renvoyer
     un pointeur vers une valeur physiquement mise en mémoire dans une table qui
     ne doit pas être modifiée. En utilisant les macros
     <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>, on
     garantit l'écriture du résultat). La seconde variante se compose des macros
     <function>PG_GETARG_<replaceable>xxx</replaceable>_SLICE()</function>
     qui prennent trois arguments. Le premier est le nombre d'arguments de la
     fonction (comme ci-dessus). Le second et le troisième sont le décalage et
     la longueur du segment qui doit être renvoyé. Les décalages sont comptés à
     partir de zéro et une longueur négative demande le renvoi du reste de la
     valeur. Ces macros procurent un accès plus efficace à des parties de
     valeurs à grande dimension dans le cas où elles ont un type de stockage en
     mémoire <quote>external</quote> (le type de stockage d'une colonne peut
     être spécifié en utilisant <literal>ALTER TABLE
     <replaceable>nom_table</replaceable> ALTER COLUMN
     <replaceable>nom_colonne</replaceable> SET STORAGE
     <replaceable>typestockage</replaceable></literal>.
     <replaceable>typestockage</replaceable> est un type parmi
     <literal>plain</literal>, <literal>external</literal>, <literal>extended</literal> ou
     <literal>main</literal>).
    </para>

    <para>
     Enfin, les conventions d'appels de la version-1 rendent possible le renvoi
     de résultats d'ensemble (<xref linkend="xfunc-c-return-set"/>),
     l'implémentation de fonctions déclencheurs (<xref
     linkend="triggers"/>) et d'opérateurs d'appel de langage procédural (<xref
     linkend="plhandler"/>). Pour plus de détails, voir
     <filename>src/backend/utils/fmgr/README</filename> dans les fichiers
     sources de la distribution.
    </para>

   </sect2>

   <sect2>
    <title>Écriture du code</title>

    <para>
     Avant de nous intéresser à des sujets plus avancés, nous devons discuter de
     quelques règles de codage des fonctions en langage C de
     <productname>PostgreSQL</productname>.  Bien qu'il soit possible de charger
     des fonctions écrites dans des langages autre que le C dans
     <productname>PostgreSQL</productname>, c'est habituellement difficile
     (quand c'est possible) parce que les autres langages comme C++, FORTRAN ou
     Pascal ne suivent pas fréquemment les mêmes conventions de nommage que le
     C. C'est-à-dire que les autres langages ne passent pas les arguments et ne
     renvoient pas les valeurs entre fonctions de la même manière. Pour cette
     raison, nous supposerons que nos fonctions en langage C sont réellement
     écrites en C.
 </para>
    <para>
     Les règles de base pour l'écriture de fonctions C sont les suivantes&nbsp;:

     <itemizedlist>
      <listitem>
       <para>
        Utilisez <literal>pg_config
        --includedir-server</literal><indexterm><primary>pg_config</primary><secondary>
        avec des fonctions C définies par l'utilisateur</secondary></indexterm> pour découvrir où
        sont installés les fichiers d'en-tête du serveur
        <productname>PostgreSQL</productname> sur votre système (ou sur le système de vos
        utilisateurs).
       </para>
      </listitem>

      <listitem>
       <para>
        Compilez et liez votre code de façon à ce qu'il soit chargé dynamiquement
	dans <productname>PostgreSQL</productname>, ce qui requiert des informations
	spéciales. Voir <xref linkend="dfunc"/> pour une explication détaillée
	sur la façon de le faire pour votre système d'exploitation spécifique.
       </para>
      </listitem>

      <listitem>
       <para>
        Rappelez-vous de définir un <quote>bloc magique</quote> pour votre
	bibliothèque partagée, comme décrit dans <xref linkend="xfunc-c-dynload"/>.
       </para>
      </listitem>

      <listitem>
       <para>
        Quand vous allouez de la mémoire, utilisez les fonctions
        <productname>PostgreSQL</productname>
        <function>palloc</function><indexterm><primary>palloc</primary></indexterm> et
        <function>pfree</function><indexterm><primary>pfree</primary></indexterm>
        au lieu des fonctions correspondantes <function>malloc</function> et
        <function>free</function> de la bibliothèque C. La mémoire allouée par
        <function>palloc</function> sera libérée automatiquement à la fin de
        chaque transaction, empêchant des débordements de mémoire.
       </para>
      </listitem>

      <listitem>
       <para>
        Remettez toujours à zéro les octets de vos structures en utilisant
        <function>memset</function>
        (ou allouez les avec la fonction <function>palloc0</function>).
	Même si vous assignez chacun des champs de votre structure, il
	pourrait rester des espaces de remplissage (trous dans la structure)
	afin de respecter l'alignement des données qui contiennent des
	valeurs parasites. Sans cela, il sera difficile de calculer des hachages
	pour les index ou les jointures, dans la mesure où vous devrez
	uniquement tenir compte des octets significatifs de vos structures
	de données pour calculer ces hachages.
	Le planificateur se base également sur des comparaisons de constantes
	via des égalités de bits, aussi vous pouvez obtenir des planifications
	incorrectes si des valeurs logiquement équivalentes ne sont pas
	identiques bit à bit.
       </para>
      </listitem>

      <listitem>
       <para>
        La plupart des types internes <productname>PostgreSQL</productname>
        sont déclarés dans <filename>postgres.h</filename> alors que les
        interfaces de gestion des fonctions
        (<symbol>PG_FUNCTION_ARGS</symbol>, etc.) sont dans
        <filename>fmgr.h</filename>. Du coup, vous aurez besoin d'inclure au
        moins ces deux fichiers. Pour des raisons de portabilité, il vaut
        mieux inclure <filename>postgres.h</filename> <emphasis>en premier</emphasis>
        avant tout autre fichier d'en-tête système ou utilisateur. En incluant
        <filename>postgres.h</filename>, il incluera également
        <filename>elog.h</filename> et <filename>palloc.h</filename> pour vous.
       </para>
      </listitem>

      <listitem>
       <para>
        Les noms de symboles définis dans les objets ne doivent pas entrer en
        conflit entre eux ou avec les symboles définis dans les exécutables du
        serveur <productname>PostgreSQL</productname>. Vous aurez à renommer vos
        fonctions ou variables si vous recevez un message d'erreur à cet effet.
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>

&dfunc;

   <sect2>
    <title>Arguments de type composite</title>

    <para>
     Les types composites n'ont pas une organisation fixe comme les structures
     en C. Des instances d'un type composite peuvent contenir des champs NULL.
     De plus, les types composites faisant partie d'une hiérarchie d'héritage
     peuvent avoir des champs différents des autres membres de la même
     hiérarchie. En conséquence, <productname>PostgreSQL</productname> propose
     une interface de fonction pour accéder depuis le C aux champs des types
     composites.
    </para>

    <para>
     Supposons que nous voulions écrire une fonction pour répondre à la requête&nbsp;:
<programlisting>SELECT nom, c_surpaye(emp, 1500) AS surpaye
    FROM emp
    WHERE nom = 'Bill' OR nom = 'Sam';
      </programlisting>

      En utilisant les conventions d'appel de la version 1, nous pouvons définir
      <function>c_surpaye</function> comme&nbsp;:

      <programlisting><![CDATA[#include "postgres.h"
#include "executor/executor.h"  /* pour GetAttributeByName() */

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(c_surpaye);

Datum
c_surpaye(PG_FUNCTION_ARGS)
{
    HeapTupleHeader  *t = (HeapTupleHeader *) PG_GETARG_HEAPTUPLEHEADER(0);
    int32            limite = PG_GETARG_INT32(1);
    bool isNULL;
    Datum salaire;

    salaire = GetAttributeByName(t, "salaire", &isNULL);
    if (isNULL)
        PG_RETURN_BOOL(false);
    /* Autrement, nous pourrions préférer de lancer PG_RETURN_NULL() pour un
       salaire NULL.
    */

    PG_RETURN_BOOL(DatumGetInt32(salaire) > limite);
}
]]></programlisting>
    </para>

    <para>
     <function>GetAttributeByName</function> est la fonction système
     <productname>PostgreSQL</productname> qui renvoie les attributs depuis une
     colonne spécifiée. Elle a trois arguments&nbsp;: l'argument de type
     <type>HeapTupleHeader</type> passé à la fonction, le nom de l'attribut
     recherché et un paramètre de retour qui indique si l'attribut est NULL.
     <function>GetAttributeByName</function> renvoie une valeur de type
     <type>Datum</type> que vous pouvez convertir dans un type voulu en
     utilisant la macro appropriée
     <function>DatumGet<replaceable>XXX</replaceable>()</function>. Notez que
     la valeur de retour est insignifiante si le commutateur NULL est
     positionné&nbsp;; il faut toujours vérifier le commutateur NULL avant de commencer
     à faire quelque chose avec le résultat.
    </para>

    <para>
     Il y a aussi <function>GetAttributeByNum</function>, qui sélectionne
     l'attribut cible par le numéro de colonne au lieu de son nom.
    </para>

    <para>
     La commande suivante déclare la fonction <function>c_surpaye</function>
     en SQL&nbsp;:

<programlisting>CREATE FUNCTION c_surpaye(emp, integer) RETURNS boolean
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'c_surpaye'
    LANGUAGE C STRICT;
      </programlisting>

      Notez que nous avons utilisé <literal>STRICT</literal> pour que nous n'ayons pas à
      vérifier si les arguments en entrée sont NULL.
     </para>
    </sect2>

    <sect2>
     <title>Renvoi de lignes (types composites)</title>

     <para>
      Pour renvoyer une ligne ou une valeur de type composite à partir d'une
      fonction en langage C, vous pouvez utiliser une API spéciale qui fournit
      les macros et les fonctions dissimulant en grande partie la complexité
      liée à la construction de types de données composites. Pour utiliser cette
      API, le fichier source doit inclure&nbsp;:
      <programlisting>#include "funcapi.h"</programlisting>
    </para>

    <para>
	 Il existe deux façons de construire une valeur de données composites
	 (autrement dit un <quote>tuple</quote>)&nbsp;: vous pouvez le construire à
	 partir d'un tableau de valeurs Datum ou à partir d'un tableau de
	 chaînes C qui peuvent passer dans les fonctions de conversion des types
	 de données du tuple. Quelque soit le cas, vous avez d'abord besoin
	 d'obtenir et de construire un descripteur <structname>TupleDesc</structname> pour
	 la structure du tuple. En travaillant avec des Datums, vous passez le
     <structname>TupleDesc</structname> à <function>BlessTupleDesc</function>, puis vous appelez
     <function>heap_form_tuple</function> pour chaque ligne. En travaillant avec des
     chaînes C, vous passez <structname>TupleDesc</structname> à
     <function>TupleDescGetAttInMetadata</function>, puis vous appelez
     <function>BuildTupleFromCStrings</function> pour chaque ligne. Dans le cas d'une
     fonction renvoyant un ensemble de tuple, les étapes de configuration
     peuvent toutes être entreprises une fois lors du premier appel à la
     fonction.
    </para>

    <para>
     Plusieurs fonctions d'aide sont disponibles pour configurer le
     <structname>TupleDesc</structname> requis. La façon recommandée de le faire dans la
     plupart des fonctions renvoyant des valeurs composites est d'appeler&nbsp;:
<programlisting>TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo,
                                   Oid *resultTypeId,
                                   TupleDesc *resultTupleDesc)
      </programlisting>
      en passant la même structure <literal>fcinfo</literal> que celle passée à la
      fonction appelante (ceci requiert bien sûr que vous utilisez les
      conventions d'appel version-1). <varname>resultTypeId</varname> peut être
      spécifié comme <literal>NULL</literal> ou comme l'adresse d'une variable locale
      pour recevoir l'OID du type de résultat de la fonction.
      <varname>resultTupleDesc</varname> devrait être l'adresse d'une variable
      <structname>TupleDesc</structname> locale. Vérifiez que le résultat est
      <literal>TYPEFUNC_COMPOSITE</literal>&nbsp;; dans ce cas,
      <varname>resultTupleDesc</varname> a été rempli avec le
      <structname>TupleDesc</structname> requis (si ce n'est pas le cas, vous pouvez
      rapporter une erreur pour une <quote>fonction renvoyant un enregistrement
       appelé dans un contexte qui ne peut pas accepter ce type
       enregistrement</quote>).
     </para>

     <tip>
      <para>
       <function>get_call_result_type</function> peut résoudre le vrai type du
       résultat d'une fonction polymorphique&nbsp;; donc, il est utile pour les
       fonctions qui renvoient des résultats scalaires polymorphiques, pas
       seulement les fonctions qui renvoient des types composites. Le résultat
       <varname>resultTypeId</varname> est principalement utile pour les fonctions
       renvoyant des scalaires polymorphiques.
      </para>
     </tip>

     <note>
      <para>
       <function>get_call_result_type</function> a une fonction cousine
       <function>get_expr_result_type</function>, qui peut être utilisée pour résoudre
       le tupe attendu en sortie en un appel de fonction représenté par
       un arbre d'expressions. Ceci peut être utilisé pour tenter de déterminer
       le type de résultat sans entrer dans la fonction elle-même. Il existe
       aussi <function>get_func_result_type</function>, qui peut seulement être utilisée
       quand l'OID de la fonction est disponible. Néanmoins, ces fonctions ne
       sont pas capables de gérer les fonctions déclarées renvoyer des
       enregistrements (<structname>record</structname>).
       <function>get_func_result_type</function> ne peut pas résoudre les types
       polymorphiques, donc vous devriez utiliser de préférence
       <function>get_call_result_type</function>.
      </para>
     </note>

     <para>
      Les fonctions anciennes, et maintenant obsolètes, qui permettent d'obtenir des
      <structname>TupleDesc</structname> sont&nbsp;:
      <programlisting>TupleDesc RelationNameGetTupleDesc(const char *relname)
      </programlisting>
      pour obtenir un <structname>TupleDesc</structname> pour le type de ligne d'une
      relation nommée ou&nbsp;:
      <programlisting>TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)
      </programlisting>
      pour obtenir une <structname>TupleDesc</structname> basée sur l'OID d'un type. Ceci
      peut être utilisé pour obtenir un <structname>TupleDesc</structname> soit pour un
      type de base, soit pour un type composite. Néanmoins, cela ne fonctionnera
      pas pour une fonction qui renvoie <structname>record</structname> et cela ne résoudra
      pas les types polymorphiques.
     </para>

     <para>
      Une fois que vous avez un <structname>TupleDesc</structname>, appelez&nbsp;:
      <programlisting>TupleDesc BlessTupleDesc(TupleDesc tupdesc)
      </programlisting>
      si vous pensez travailler avec des Datums ou&nbsp;:
      <programlisting>AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)
      </programlisting>
      si vous pensez travailler avec des chaînes C. Si vous écrivez une
      fonction renvoyant un ensemble, vous pouvez sauvegarder les résultats
      de ces fonctions dans la structure dans le
      <structname>FuncCallContext</structname> &mdash; utilisez le champ
      <structfield>tuple_desc</structfield> ou <structfield>attinmeta</structfield> respectivement.
     </para>

     <para>
      Lorsque vous fonctionnez avec des Datums, utilisez&nbsp;:
      <programlisting>HeapTuple heap_form_tuple(TupleDesc tupdesc, Datum *values, bool *isnull)
      </programlisting>
      pour construire une donnée utilisateur <structname>HeapTuple</structname> indiquée
      dans le format Datum.
     </para>

     <para>
      Lorsque vous travaillez avec des chaînes C, utilisez&nbsp;:
      <programlisting>HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)
      </programlisting>
      pour construire une donnée utilisateur <structname>HeapTuple</structname> indiquée
      dans le format des chaînes C. <parameter>values</parameter> est un tableau de
      chaîne C, une pour chaque attribut de la ligne renvoyée. Chaque chaîne
      C doit être de la forme attendue par la fonction d'entrée du type de
      donnée de l'attribut. Afin de renvoyer une valeur NULL pour un des
      attributs, le pointeur correspondant dans le tableau de valeurs
      (<parameter>values</parameter>) doit être fixé à <symbol>NULL</symbol>. Cette fonction
      demandera à être appelée pour chaque ligne que vous renvoyez.
     </para>

     <para>
      Une fois que vous avez construit un tuple devant être renvoyé par votre
      fonction, vous devez le convertir en type <type>Datum</type>. Utilisez&nbsp;:
      <programlisting>HeapTupleGetDatum(HeapTuple tuple)
      </programlisting>
      pour convertir un type <type>HeapTuple</type> en un Datum valide.
      Ce <type>Datum</type> peut être renvoyé directement si vous envisagez de
      renvoyer juste une simple ligne ou bien il peut être utilisé pour renvoyer
      la valeur courante dans une fonction renvoyant un ensemble.
     </para>

     <para>
      Un exemple figure dans la section suivante.
     </para>

    </sect2>

    <sect2 id="xfunc-c-return-set">
     <title>Renvoi d'ensembles</title>

     <para>
      Les fonctions en langage C ont deux options pour renvoyer des ensembles
      (plusieurs lignes). Dans la première méthode, appelée mode
      <firstterm>ValuePerCall</firstterm>,  une fonction renvoyant un ensemble
      de lignes est appelée de façon répétée (en passant les mêmes arguments à
      chaque fois) et elle renvoit une nouvelle ligne pour chaque appel,
      jusqu'à ce qu'il n'y ait plus de lignes à renvoyer et qu'elle le signale
      en renvoyant NULL. La fonction <acronym>SRF</acronym> doit de ce fait
      sauvegarder l'état entre appels pour se rappeler ce qu'elle faisait et
      renvoyer le bon prochain élément à chaque appel. Dans l'autre méthode,
      appelée mode <firstterm>Materialize</firstterm>, une SRF remplit et
      renvoit un objet <foreignphrase>tuplestore</foreignphrase> contenant le
      résultat entier. Un seul appel survient pour le résultat complet, et il
      n'est pas nécessaire de conserver l'état entre appels.
     </para>

     <para>
      Lors de l'utilisation du mode ValuePerCall, il est important de se
      rappeler que la requête n'est pas garantie de se terminer&nbsp;;
      c'est-à-dire, avec des options telles que <literal>LIMIT</literal>,
      l'exécuteur pourrait stopper les appels à la fonction SRF avant que
      toutes les lignes ne soient récupérées. Ceci signifie qu'il ne faut pas
      utiliser le dernier appel pour nettoyer l'activité réalisée, car ce
      dernier appel pourrait bien ne jamais survenir. Il est recommandé
      d'utiliser le mode Materialize pour les fonctions ayant besoin d'accéder
      aux ressources externes, tels que des descripteurs de fichiers.
     </para>

     <para>
      Le reste de cette section documente un ensemble de macros d'aide qui
      sont communément utilisées (bien que non requis pour être utilisés) pour
      les SRF utilisant le mode ValuePerCall. Des détails supplémentaires sur
      le mode Materialize peuvent être trouvés dans
      <filename>src/backend/utils/fmgr/README</filename>. De plus, les modules
      <filename>contrib</filename> dans la distribution des sources de the
      <productname>PostgreSQL</productname> contiennent de nombreux exemples
      de SRF utilisant à la fois les modes ValuePerCall et Materialize.
     </para>

     <para>
      Pour utiliser les macros de support ValuePerCall décrites ici, inclure
      <filename>funcapi.h</filename>. Ces macros fonctionnent avec une
      structure <structname>FuncCallContext</structname> qui contient l'état
      devant être sauvegardé au travers des appels. À l'intérieur de la SRF
      appelante, <literal>fcinfo-&gt;flinfo-&gt;fn_extra</literal> est utilisé
      pour détenir un pointeur vers <structname>FuncCallContext</structname>
      entre les appels. Les macros remplissent automatiquement ce champ à la
      première utilisation et s'attendent à y trouver le même pointeur lors
      des prochains appels.

      <programlisting>typedef struct FuncCallContext
{
    /*
     * Number of times we've been called before
     *
     * call_cntr is initialized to 0 for you by SRF_FIRSTCALL_INIT(), and
     * incremented for you every time SRF_RETURN_NEXT() is called.
     */
    uint64 call_cntr;

    /*
     * OPTIONAL maximum number of calls
     *
     * max_calls is here for convenience only and setting it is optional.
     * If not set, you must provide alternative means to know when the
     * function is done.
     */
    uint64 max_calls;

    /*
     * OPTIONAL pointer to miscellaneous user-provided context information
     *
     * user_fctx is for use as a pointer to your own data to retain
     * arbitrary context information between calls of your function.
     */
    void *user_fctx;

    /*
     * OPTIONAL pointer to struct containing attribute type input metadata
     *
     * attinmeta is for use when returning tuples (i.e., composite data types)
     * and is not used when returning base data types. It is only needed
     * if you intend to use BuildTupleFromCStrings() to create the return
     * tuple.
     */
    AttInMetadata *attinmeta;

    /*
     * memory context used for structures that must live for multiple calls
     *
     * multi_call_memory_ctx is set by SRF_FIRSTCALL_INIT() for you, and used
     * by SRF_RETURN_DONE() for cleanup. It is the most appropriate memory
     * context for any memory that is to be reused across multiple calls
     * of the SRF.
     */
    MemoryContext multi_call_memory_ctx;

    /*
    * OPTIONAL pointer to struct containing tuple description
    *
    * tuple_desc is for use when returning tuples (i.e. composite data types)
    * and is only needed if you are going to build the tuples with
    * heap_form_tuple() rather than with BuildTupleFromCStrings().  Note that
    * the TupleDesc pointer stored here should usually have been run through
    * BlessTupleDesc() first.
    */
    TupleDesc tuple_desc;

} FuncCallContext;
      </programlisting>
     </para>

     <para>
      Les macros à utiliser par une <acronym>SRF</acronym> utilisant cette
      infrastructure sont&nbsp;:
      <programlisting>SRF_IS_FIRSTCALL()
      </programlisting>
      Utilisez ceci pour déterminer si votre fonction est appelée pour la
      première fois ou la prochaine fois. Au premier appel (seulement),
      utilisez&nbsp;:
      <programlisting>SRF_FIRSTCALL_INIT()
      </programlisting>
      pour initialiser la structure <structname>FuncCallContext</structname>.
      À chaque appel de fonction, y compris le premier, utilisez&nbsp;:
      <programlisting>SRF_PERCALL_SETUP()
      </programlisting>
      pour configurer l'utilisation de <structname>FuncCallContext</structname>.
     </para>

     <para>
      Si votre fonction a des données à renvoyer dans l'appel courant,
      utilisez&nbsp;:
      <programlisting>SRF_RETURN_NEXT(funcctx, result)
      </programlisting>
      pour les renvoyer à l'appelant. (<literal>result</literal> doit être de type
      <type>Datum</type>, soit une valeur simple, soit un tuple préparé comme décrit
      ci-dessus.) Enfin, quand votre fonction a fini de renvoyer des données,
      utilisez&nbsp;:
      <programlisting>SRF_RETURN_DONE(funcctx)
      </programlisting>
      pour nettoyer et terminer la <acronym>SRF</acronym>.
     </para>

     <para>
      Lors de l'appel de la <acronym>SRF</acronym>, le contexte mémoire courant est un
      contexte transitoire qui est effacé entre les appels. Cela signifie que
      vous n'avez pas besoin d'appeler <function>pfree</function> sur tout ce que vous
      avez alloué en utilisant <function>palloc</function>&nbsp;; ce sera supprimé de
      toute façon. Toutefois, si vous voulez allouer des structures de données
      devant persister tout au long des appels, vous avez besoin de les conserver
      quelque part. Le contexte mémoire référencé par
      <structfield>multi_call_memory_ctx</structfield> est un endroit approprié pour toute
      donnée devant survivre jusqu'à l'achèvement de la fonction <acronym>SRF</acronym>.
      Dans la plupart des cas, cela signifie que vous devrez basculer vers
      <structfield>multi_call_memory_ctx</structfield> au moment de la préparation du
      premier appel. Utilisez <literal>funcctx-&gt;user_fctx</literal> pour
      récupérer un pointeur vers de telles structures de données inter-appels
      (les données que vous allouez dans
      <structfield>multi_call_memory_ctx</structfield> partiront
      automatiquement à la fin de la requête, donc il n'est pas nécessaire de
      libérer cette donnée manuellement).
     </para>

     <warning>
      <para>
       Quand les arguments réels de la fonction restent inchangés entre les
       appels, si vous lisez la valeur des arguments (ce qui se fait de façon
       transparente par la macro
       <function>PG_GETARG_<replaceable>xxx</replaceable></function>) dans le
       contexte, alors les copies seront libérées sur chaque cycle. De la même
       façon, si vous conservez des références vers de telles valeurs dans
       votre <structfield>user_fctx</structfield>, vous devez soit les copier
       dans <structfield>multi_call_memory_ctx</structfield>, soit vous
       assurer que vous procédez vous-même au traitement des valeurs dans ce
       contexte.
      </para>
     </warning>

     <para>
      Voici un exemple complet de pseudo-code&nbsp;:
      <programlisting>Datum
my_set_returning_function(PG_FUNCTION_ARGS)
{
    FuncCallContext  *funcctx;
    Datum             result;
    <replaceable>further declarations as needed</replaceable>

    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext oldcontext;

        funcctx = SRF_FIRSTCALL_INIT();
        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);
        /* One-time setup code appears here: */
        <replaceable>user code</replaceable>
        <replaceable>if returning composite</replaceable>
            <replaceable>build TupleDesc, and perhaps AttInMetadata</replaceable>
        <replaceable>endif returning composite</replaceable>
        <replaceable>user code</replaceable>
        MemoryContextSwitchTo(oldcontext);
    }

    /* Each-time setup code appears here: */
    <replaceable>user code</replaceable>
    funcctx = SRF_PERCALL_SETUP();
    <replaceable>user code</replaceable>

    /* this is just one way we might test whether we are done: */
    if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)
    {
        /* Here we want to return another item: */
        <replaceable>user code</replaceable>
        <replaceable>obtain result Datum</replaceable>
        SRF_RETURN_NEXT(funcctx, result);
    }
    else
    {
        /* Here we are done returning items, so just report that fact. */
        /* (Resist the temptation to put cleanup code here.) */
        SRF_RETURN_DONE(funcctx);
    }
}
      </programlisting>
     </para>

     <para>
      Et voici un exemple complet d'une simple <acronym>SRF</acronym> retournant un
      type composite&nbsp;:
      <programlisting><![CDATA[PG_FUNCTION_INFO_V1(retcomposite);

Datum
retcomposite(PG_FUNCTION_ARGS)
{
    FuncCallContext     *funcctx;
    int                  call_cntr;
    int                  max_calls;
    TupleDesc            tupdesc;
    AttInMetadata       *attinmeta;

     /* stuff done only on the first call of the function */
     if (SRF_IS_FIRSTCALL())
     {
        MemoryContext	oldcontext;

        /* create a function context for cross-call persistence */
        funcctx = SRF_FIRSTCALL_INIT();

        /* switch to memory context appropriate for multiple function calls */
        oldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);

        /* total number of tuples to be returned */
        funcctx->max_calls = PG_GETARG_UINT32(0);

        /* Build a tuple descriptor for our result type */
        if (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)
            ereport(ERROR,
                    (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                     errmsg("function returning record called in context "
                            "that cannot accept type record")));

        /*
         * generate attribute metadata needed later to produce tuples from raw
         * C strings
         */
        attinmeta = TupleDescGetAttInMetadata(tupdesc);
        funcctx->attinmeta = attinmeta;

        MemoryContextSwitchTo(oldcontext);
    }

    /* stuff done on every call of the function */
    funcctx = SRF_PERCALL_SETUP();

    call_cntr = funcctx->call_cntr;
    max_calls = funcctx->max_calls;
    attinmeta = funcctx->attinmeta;

    if (call_cntr < max_calls)    /* do when there is more left to send */
    {
        char       **values;
        HeapTuple    tuple;
        Datum        result;

        /*
	* Prepare a values array for building the returned tuple.
         * This should be an array of C strings which will
         * be processed later by the type input functions.
         */
        values = (char **) palloc(3 * sizeof(char *));
        values[0] = (char *) palloc(16 * sizeof(char));
        values[1] = (char *) palloc(16 * sizeof(char));
        values[2] = (char *) palloc(16 * sizeof(char));

        snprintf(values[0], 16, "%d", 1 * PG_GETARG_INT32(1));
        snprintf(values[1], 16, "%d", 2 * PG_GETARG_INT32(1));
        snprintf(values[2], 16, "%d", 3 * PG_GETARG_INT32(1));

        /* build a tuple */
        tuple = BuildTupleFromCStrings(attinmeta, values);

        /* make the tuple into a datum */
        result = HeapTupleGetDatum(tuple);

        /* clean up (this is not really necessary) */
        pfree(values[0]);
        pfree(values[1]);
        pfree(values[2]);
        pfree(values);

        SRF_RETURN_NEXT(funcctx, result);
    }
    else    /* do when there is no more left */
    {
        SRF_RETURN_DONE(funcctx);
    }
}
]]></programlisting>

     Voici une façon de déclarer cette fonction en SQL&nbsp;:

<programlisting>CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer);

CREATE OR REPLACE FUNCTION retcomposite(integer, integer)
    RETURNS SETOF __retcomposite
    AS '<replaceable>filename</replaceable>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;
      </programlisting>
      Une façon différente de le faire est d'utiliser des paramètres OUT&nbsp;:
      <programlisting>CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer,
    OUT f1 integer, OUT f2 integer, OUT f3 integer)
    RETURNS SETOF record
    AS '<replaceable>filename</replaceable>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;
      </programlisting>
      Notez que dans cette méthode le type en sortie de la fonction est du type
      <structname>record</structname> anonyme.
     </para>
    </sect2>

    <sect2>
     <title>Arguments polymorphes et types renvoyés</title>

     <para>
      Les fonctions en langage C peuvent être déclarées pour accepter et renvoyer
      les types <quote>polymorphes</quote> <type>anyelement</type>,
      <type>anyarray</type>, <type>anynonarray</type>, <type>anyenum</type> et
      <type>anyrange</type>. Voir la <xref linkend="extend-types-polymorphic"/> pour une
      explication plus détaillée des fonctions polymorphes. Si les types des
      arguments ou du renvoi de la fonction sont définis comme polymorphes,
      l'auteur de la fonction ne peut pas savoir à l'avance quel type de données
      sera appelé ou bien quel type doit être renvoyé. Il y a deux routines
      offertes par <filename>fmgr.h</filename>  qui permettent à une fonction en
      version-1 de découvrir les types de données effectifs de ses arguments et
      le type qu'elle doit renvoyer. Ces routines s'appellent
      <literal>get_fn_expr_rettype(FmgrInfo *flinfo)</literal> et
      <literal>get_fn_expr_argtype(FmgrInfo *flinfo, int argnum)</literal>. Elles
      renvoient l'OID du type du résultat ou de l'argument ou InvalidOID si
      l'information n'est pas disponible. L'accès à la structure
      <literal>flinfo</literal> se fait normalement avec
      <literal>fcinfo-&gt;flinfo</literal>. Le paramètre <literal>argnum</literal> est basé à
      partir de zéro. <function>get_call_result_type</function> peut aussi être utilisé
      comme alternative à <function>get_fn_expr_rettype</function>.
      Il existe aussi <function>get_fn_expr_variadic</function>, qui peut être
      utilisé pour trouver les arguments variables en nombre qui ont été assemblés
      en un tableau. C'est principalement utiledans le cadre des fonctions
      <literal>VARIADIC "any"</literal> car de tels assemblages surviendront
      toujours pour les fonctions variadiques prenant des types de tableaux
      ordinaires.
     </para>

     <para>
      Par exemple, supposons que nous voulions écrire une fonction qui accepte un
      argument de n'importe quel type et qui renvoie un tableau uni-dimensionnel
      de ce type&nbsp;:

      <programlisting>PG_FUNCTION_INFO_V1(make_array);
Datum
make_array(PG_FUNCTION_ARGS)
{
    ArrayType  *result;
    Oid         element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);
    Datum       element;
    bool        isnull;
    int16       typlen;
    bool        typbyval;
    char        typalign;
    int         ndims;
    int         dims[MAXDIM];
    int         lbs[MAXDIM];

    if (!OidIsValid(element_type))
        elog(ERROR, "could not determine data type of input");

    /* get the provided element, being careful in case it's NULL */
    isnull = PG_ARGISNULL(0);
    if (isnull)
        element = (Datum) 0;
    else
        element = PG_GETARG_DATUM(0);

    /* we have one dimension */
    ndims = 1;
    /* and one element */
    dims[0] = 1;
    /* and lower bound is 1 */
    lbs[0] = 1;

    /* get required info about the element type */
    get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval,
&amp;typalign);

    /* now build the array */
    result = construct_md_array(&amp;element, &amp;isnull, ndims, dims, lbs,
                                element_type, typlen, typbyval, typalign);

    PG_RETURN_ARRAYTYPE_P(result);
}
      </programlisting>
     </para>

     <para>
      La commande suivante déclare la fonction <function>make_array</function> en
      SQL&nbsp;:

      <programlisting>CREATE FUNCTION make_array(anyelement)
    RETURNS anyarray
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'make_array'
    LANGUAGE 'C' IMMUTABLE;
      </programlisting>

      Notez l'utilisation de STRICT&nbsp;; ceci est primordial car le code ne se
      préoccupe pas de tester une entrée NULL.
     </para>

     <para>
      Il existe une variante du polymorphisme qui est seulement disponible pour
      les fonctions en langage C&nbsp;: elles peuvent être déclarées prendre des
      paramètres de type <literal>"any"</literal>. (Notez que ce nom de type doit
      être placé entre des guillemets doubles car il s'agit d'un mot SQL réservé.)
      Ceci fonctionne comme <type>anyelement</type> sauf qu'il ne contraint pas
      les différents arguments <literal>"any"</literal> à être du même type, pas
      plus qu'ils n'aident à déterminer le type de résultat de la fonction. Une
      fonction en langage C peut aussi déclarer son paramètre final ainsi&nbsp;:
      <literal>VARIADIC "any"</literal>.  Cela correspondra à un ou plusieurs
      arguments réels de tout type (pas nécessairement le même type). Ces
      arguments ne seront <emphasis>pas</emphasis> placés dans un tableau
      comme c'est le cas pour les fonctions variadic normales&nbsp;; ils seront
      passés séparément à la fonction. La macro <function>PG_NARGS()</function>
      et les méthodes décrites ci-dessus doivent être utilisées pour déterminer
      le nombre d'arguments réels et leur type lors de l'utilisation de cette
      fonctionnalité. Ainsi, les utilisateurs d'une telle fonction voudront
      probablement utilisé le mot-clé <literal>VARIADIC</literal> dans leur
      appel de fonction, de manière à ce que la fonction traite les éléments
      du tableau comme des arguments séparés. La fonction elle-même doit
      implémenter ce comportement si nécessaire, après avoir utilisé
      <function>get_fn_expr_variadic</function> pour savoir si les arguments
      actuels ont été marqués avec <literal>VARIADIC</literal>.
     </para>
    </sect2>

    <sect2>
     <title>Mémoire partagée et LWLocks</title>

     <para>
      Les modules peuvent réserver des LWLocks et allouer de la mémoire partagée
      au lancement du serveur. La bibliothèque partagée du module doit être
      préchargée en l'ajoutant <xref
      linkend="guc-shared-preload-libraries"/><indexterm><primary>shared_preload_libraries</primary></indexterm>.
      La mémoire partagée est réservée en appelant&nbsp;:
      <programlisting>void RequestAddinShmemSpace(int size)
      </programlisting>
      à partir de votre fonction <function>_PG_init</function>.
     </para>
     <para>
      Les LWLocks sont réservés en appelant&nbsp;:
      <programlisting>
void RequestNamedLWLockTranche(const char *tranche_name, int num_lwlocks)
      </programlisting>
      à partir de <function>_PG_init</function>. Ceci assurera qu'un tableau de
      <literal>num_lwlocks</literal> LWLocks est disponible sous le nom de
      <literal>tranche_name</literal>. Utilisez
      <function>GetNamedLWLockTranche</function> pour obtenir un pointeur vers
      ce tableau.
     </para>
     <para>
      Pour éviter des cas rares possibles, chaque moteur devrait utiliser la
      fonction <function>AddinShmemInitLock</function> lors de la connexion et
      de l'initialisation de la mémoire partagée, comme indiquée ci-dessous&nbsp;:
      <programlisting>
        static mystruct *ptr = NULL;

        if (!ptr)
        {
                bool    found;

                LWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);
                ptr = ShmemInitStruct("my struct name", size, &amp;found);
                if (!found)
                {
                        initialize contents of shmem area;
                        acquire any requested LWLocks using:
                        ptr-&gt;locks = GetNamedLWLockTranche("my tranche name");
                }
                LWLockRelease(AddinShmemInitLock);
        }
      </programlisting>
     </para>
    </sect2>


    <sect2 id="extend-Cpp">
     <title>Coder des extensions en  C++</title>

     <indexterm zone="extend-Cpp">
      <primary>C++</primary>
     </indexterm>

     <para>
      Bien que le moteur <productname>PostgreSQL</productname> soit écrit en
      C, il est possible de coder des extensions en C++ si les lignes de conduite suivantes sont
      respectées :

      <itemizedlist>
       <listitem>
        <para>
         Toutes les fonctions accessibles par le serveur doivent
         présenter une interface en C&nbsp;;
         seules ces fonctions C pourront alors appeler du code C++.
         Ainsi, l'édition de liens <literal>extern C</literal> est nécessaire
         pour les fonctions appelées par le serveur. Ceci est également obligatoire
         pour toutes les fonctions passées comme pointeur entre le serveur et du
         code C++.
        </para>
       </listitem>
       <listitem>
        <para>
         Libérez la mémoire en utilisant la méthode de désallocation appropriée.
         Par exemple, la majeure partie de la mémoire allouée par le serveur l'est
         par appel de la fonction <function>palloc()</function>, aussi, il convient
         de libérer ces zones mémoire en utilisant la fonction <function>pfree()</function>.
         L'utilisation de la fonction C++ <function>delete</function> échouerait
         pour ces blocs de mémoire.
        </para>
       </listitem>
       <listitem>
        <para>
         Évitez la propagation d'exceptions dans le code C (utilisez un bloc
         catch-all au niveau le plus haut de toute fonction <literal>extern C</literal>.
         Ceci est nécessaire, même si le code C++ n'émet explicitement aucune
         exception, dans la mesure où la survenue d'événements tels qu'un manque de mémoire
         peut toujours lancer une exception. Toutes les exceptions devront être gérées
         et les erreurs correspondantes transmises via l'interface du code C.
         Si possible, compilez le code C++ avec l'option <option>-fno-exceptions</option>
         afin d'éliminer entièrement la venue d'exceptions&nbsp;; dans ce cas, vous
         devrez effectuer vous-même les vérifications correspondantes dans votre code C++,
         par exemple, vérifier les éventuels paramètres NULL retournés par la fonction
         <function>new()</function>.
        </para>
       </listitem>
       <listitem>
        <para>
         Si vous appelez des fonctions du serveur depuis du code C++, assurez vous que
         la pile d'appels ne contienne que des structures C (<acronym>POD</acronym>).
         Ceci est nécessaire dans la mesure où les erreurs au niveau du serveur génèrent un
         saut via l'instruction <function>longjmp()</function> qui ne peut dépiler proprement
         une pile d'appels C++ comportant des objets non-POD.
        </para>
       </listitem>
      </itemizedlist>
     </para>

     <para>
      Pour résumer, le code C++ doit donc être placé derrière un rempart  de fonctions
      <literal>extern C</literal> qui fourniront l'interface avec le serveur, et devra éviter
      toute fuite de mécanismes propres au C++ (exceptions, allocation/libération de mémoire
      et objets non-POD dans la pile).
     </para>
    </sect2>

   </sect1>

  <sect1 id="xfunc-optimization">
   <title>Informations d'optimisation de fonction</title>

  <indexterm zone="xfunc-optimization">
   <primary>informations d'optimisation</primary>
   <secondary>pour les fonctions</secondary>
  </indexterm>

   <para>
    Par défaut, une fonction est juste une <quote>boîte noire</quote>
    dont la base de données connait très peu le comportement. De ce fait,
    il peut arriver que les requêtes utilisant la fonction se trouvent
    exécutées beaucoup moins efficacement qu'elles ne pourraient.
    Il est possible de fournir une connaissance supplémentaire qui aide
    le planificateur à optimiser les appels de fonctions.
   </para>

   <para>
    Quelques indications basiques peuvent être données via les annotations
    déclaratives présentes dans la commande <xref linkend="sql-createfunction"/>.
    La plus importante de celles-ci est la <link linkend="xfunc-volatility">
    catégorie de volatilité</link> (<literal>IMMUTABLE</literal>, <literal>STABLE</literal>,
    ou <literal>VOLATILE</literal>)&nbsp;; on doit toujours être très soucieux
    de la spécifier correctement lorsqu'on définit une fonction.
    La propriété de sûreté face au parallélisme (<literal>PARALLEL
    UNSAFE</literal>, <literal>PARALLEL RESTRICTED</literal>, ou
    <literal>PARALLEL SAFE</literal>) doit également être spécifiée
    pour espérer utiliser la fonction dans des requêtes parallélisées.
    Il peut aussi être utile de spécifier le coût estimé de l'exécution
    de la fonction, et le nombre de lignes qu'une fonction
    renvoyant un ensemble d'enregistrements est estimée renvoyer.
    Toutefois, la manière déclarative de spécifier ces deux informations
    ne permet seulement que de donner une valeur constante, ce qui est
    souvent inadéquat.
   </para>

   <para>
    Il est aussi possible de rattacher une <firstterm>fonction
    de support de planification</firstterm> à une fonction appelable
    en SQL (appelée <firstterm>fonction cible</firstterm>), et
    ainsi de fournir sur la fonction cible une connaissance
    qui serait trop complexe à être représentée déclarativement.
    Les fonctions de support de planification doivent être écrites en
    C (alors que leurs fonctions cibles peuvent ne pas l'être), ce qui en
    fait une fonctionnalité avancée que relativement peu de personnes
    utiliseront.
   </para>

   <para>
    Une fonction de support de planification doit avoir la signature SQL
<programlisting>
supportfn(internal) returns internal
</programlisting>
    Elle est rattachée à sa fonction cible en spécifiant la clause
    <literal>SUPPORT</literal> dans la création de la fonction cible.
   </para>

   <para>
    Les détails de l'API des fonctions de support de planification
    se trouvent dans le fichier
    <filename>src/include/nodes/supportnodes.h</filename> dans le code
    source de <productname>PostgreSQL</productname>. Ici, on ne fournit
    qu'une vue d'ensemble de ce que les fonctions de support de planification
    peuvent faire.
    L'ensemble des demandes possibles adressables à une fonction de support
    est extensible, si bien que d'autres choses seront possibles dans
    des versions ultérieures.
   </para>

   <para>
    Certains appels de fonctions peuvent être simplifiés lors de la
    planification en se basant sur les propriétés spécifiques de la fonction.
    Par exemple, <literal>int4mul(n, 1)</literal> pourrait être simplifié par
    <literal>n</literal>. Ce type de transformation peut être exécuté
    par une fonction de support de planification, en lui faisant implémenter
    le type de demande <literal>SupportRequestSimplify</literal>.
    La fonction de support va être appelée pour chaque instance de la
    fonction cible trouvée dans l'arbre d'analyse de la requête.
    Si elle trouve qu'un appel particulier peut être simplifié en
    une autre forme, elle est capable de construire et renvoyer
    un arbre d'analyse représentant cette expression. Cela fonctionnera
    automatiquement pour les opérateurs basés sur cette fonction,
    également &mdash; dans l'exemple juste ci-dessus, <literal>n * 1</literal>
    serait aussi simplifié en <literal>n</literal>.
    (Mais notez que c'est juste un exemple&nbsp;; cette optimisation particulière
    n'est pas réellement mise en oeuvre par <productname>PostgreSQL</productname>.)
    Nous ne garantissons pas que <productname>PostgreSQL</productname> n'appelera
    jamais la fonction cible dans les cas que la fonction de support pourrait
    simplifier. Assurez-vous d'une équivalence rigoureuse entre l'expression
    simplifiée et l'exécution réelle de la fonction cible.
   </para>

   <para>
    Pour les fonctions cible qui renvoient un booléen, il est souvent utile
    d'estimer la fraction des lignes qui vont être sélectionnées par une clause
    <literal>WHERE</literal> utilisant cette fonction. Ceci est réalisable avec
    une fonction de support qui implémente le type de demande
    <literal>SupportRequestSelectivity</literal>.
   </para>

   <para>
    Si le temps d'exécution d'une fonction cible est très dépendant
    de ses entrées, il peut être utile de fournir un coût d'exécution
    non constant pour celle-ci.
    Ceci est réalisable avec une fonction de support implémentant
    le type de demande <literal>SupportRequestCost</literal>.
   </para>

   <para>
    Pour les fonctions cibles qui renvoient des ensembles de lignes,
    il est souvent utile de fournir une estimation non constante du
    nombre de lignes renvoyées.
    Ceci est réalisable avec une fonction de support implémentant
    le type de demande <literal>SupportRequestRows</literal>.
   </para>

   <para>
    Pour les fonctions cibles qui renvoient un booléen, il est envisageable
    de convertir un appel de fonction au niveau d'un <literal>WHERE</literal> vers une ou
    plusieurs clauses d'un opérateur indexable. Ces clauses peuvent être
    exactement équivalentes à la condition de la fonction, ou bien elle peuvent
    être plus faibles (c'est-à-dire qu'elles peuvent accepter certaines
    valeurs que la condition via la fonction n'accepte pas).
    Dans ce dernier cas, la condition d'index est dite
    <firstterm>avec perte</firstterm>; elle peut toujours être utilisée
    pour un parcours d'index, mais la fonction devra être appelée pour chaque
    ligne renvoyée par l'index pour vérifier qu'elle satisfait la condition
    <literal>WHERE</literal>.
    Pour créer de telles conditions, la fonction de support doit implémenter
    le type de demande <literal>SupportRequestIndexCondition</literal>.
   </para>
  </sect1>
