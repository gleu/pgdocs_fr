<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

 <chapter id="mvcc">
  <title>Contrôle d'accès simultané</title>

  <indexterm>
   <primary>concurrence</primary>
  </indexterm>

  <para>
   Ce chapitre décrit le comportement de <productname>PostgreSQL</productname>
   lorsque deux sessions, ou plus, essaient d'accéder aux mêmes données au
   même moment. Le but dans cette situation est de permettre un accès
   efficace pour toutes les sessions tout en maintenant une intégrité stricte
   des données. Chaque développeur d'applications utilisant des bases de
   données doit avoir une bonne compréhension des thèmes couverts dans ce
   chapitre.
  </para>

  <sect1 id="mvcc-intro">
   <title>Introduction</title>

   <indexterm>
    <primary>Multiversion Concurrency Control</primary>
   </indexterm>

   <indexterm>
    <primary>MVCC</primary>
   </indexterm>

   <indexterm>
    <primary>Serializable Snapshot Isolation</primary>
   </indexterm>

   <indexterm>
    <primary>SSI</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> fournit un ensemble d'outils
    pour les développeurs qui souhaitent gérer des accès simulatnés aux données.
    En interne, la cohérence des données est obtenue avec l'utilisation d'un
    modèle multiversion (Multiversion Concurrency Control, <acronym>MVCC</acronym>).
    Ceci signifie que, lors de l'envoi d'une requête à la
    base de données, chaque transaction voit une image des données (une
    <firstterm>version de la base de données</firstterm>) telle qu'elles
    étaient quelque temps auparavant, quel que soit l'état actuel des données
    sous-jacentes. Ceci protège la transaction de données incohérentes,
    causées par des mises à jour effectuées par une (autre) transaction
    simultanée sur les mêmes lignes de données, fournissant ainsi une
    <firstterm>isolation des transactions</firstterm> pour chaque session de la
    base de données. <acronym>MVCC</acronym>, en évitant les méthodes des verrous
    des systèmes de bases de données traditionnels, minimise la
    durée des verrous pour permettre des performances raisonnables dans
    des environnements multiutilisateurs.
   </para>

   <para>
    Le principal avantage de l'utilisation du modèle <acronym>MVCC</acronym> 
    pour le contrôle des accès simultanés, contrairement au verrouillage, est que, dans
    les verrous acquis par <acronym>MVCC</acronym> pour récupérer (en lecture)
    des données, aucun conflit n'intervient avec les verrous acquis pour écrire
    des données. Du coup, lire ne bloque jamais l'écriture et écrire ne bloque
    jamais la lecture.
    <productname>PostgreSQL</productname> maintient cette garantie même quand
    il fournit le niveau d'isolation le plus strict au moyen d'un niveau
    <firstterm>Serializable Snapshot Isolation</firstterm> (<acronym>SSI</acronym>)
    innovant.
   </para>

   <para>
    Des possibilités de verrouillage des tables ou des lignes sont aussi disponibles
    dans <productname>PostgreSQL</productname> pour les applications qui n'ont
    pas besoin en général d'une isolation complète des transactions et
    préfèrent gérer explicitement les points de conflits particuliers. Néanmoins,
    un bon usage de <acronym>MVCC</acronym> fournira généralement de
    meilleures performances que les verrous. De plus, les verrous informatifs
    définis par l'utilisateur fournissent un mécanisme d'acquisition de verrous
    qui n'est pas lié à une transaction.
   </para>
  </sect1>

  <sect1 id="transaction-iso">
   <title>Isolation des transactions</title>

   <indexterm>
    <primary>isolation des transactions</primary>
   </indexterm>

   <para>
    Le standard <acronym>SQL</acronym> définit quatre niveaux d'isolation de
    transaction.
    Le plus strict est Serializable, qui est défini par le standard dans
    un paragraphe qui déclare que toute exécution concurrente d'un jeu
    de transactions sérialisables doit apporter la garantie de produire
    le même effet que l'exécution consécutive de chacun d'entre eux
    dans un certain ordre. Les trois autres niveaux sont définis en terme
    de phénomènes, résultant de l'intéraction entre les transactions
    concurrentes, qui ne doivent pas se produire à chaque niveau. Le
    standard note qu'en raison de la définition de Serializable, aucun
    de ces phénomènes n'est possible à ce niveau. (Cela n'a rien de
    surprenant -- si l'effet des transactions doit être cohérent avec
    l'exécution consécutive de chacune d'entre elles, comment pourriez
    vous voir un phénomène causé par des interactions?).
   </para>

   <para>
    Les phénomènes qui sont interdits à chaque niveau sont:

    <variablelist>
     <varlistentry>
      <term>
       lecture sale
       <indexterm><primary>lecture sale</primary></indexterm>
      </term>
     <listitem>
      <para>
	Une transaction lit des données écrites par une transaction concurrente
	non validée (dirty read).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       lecture non reproductible
       <indexterm><primary>lecture non reproductible</primary></indexterm>
      </term>
     <listitem>
      <para>
	Une transaction relit des données qu'elle a lu
	précédemment et trouve que les données ont été modifiées par une autre
	transaction (validée depuis la lecture initiale) (non repeatable read).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       lecture fantôme
       <indexterm><primary>lecture fantôme</primary></indexterm>
      </term>
     <listitem>
      <para>
	Une transaction ré-exécute une requête renvoyant un ensemble de lignes
	satisfaisant une condition de recherche et trouve que l'ensemble des
	lignes satisfaisant la condition a changé du fait d'une autre transaction
	récemment validée (phantom read).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    <indexterm>
     <primary>niveau d'isolation de transaction</primary>
    </indexterm>
    Les quatre niveaux d'isolation de transaction et les comportements
    correspondants sont décrits dans le <xref linkend="mvcc-isolevel-table"/>.
   </para>

    <table tocentry="1" id="mvcc-isolevel-table">
     <title>Niveaux d'isolation standards des transactions <acronym>SQL</acronym></title>
     <tgroup cols="4">
     <colspec colnum="1" colwidth="2.2*"/>
     <colspec colnum="2" colwidth="0.6*"/>
     <colspec colnum="3" colwidth="0.6*"/>
     <colspec colnum="4" colwidth="0.6*"/>
      <thead>
       <row>
	<entry>
         Niveau d'isolation
	</entry>
	<entry>
	 Lecture sale
	</entry>
	<entry>
	 Lecture non reproductible
	</entry>
	<entry>
	 Lecture fantôme
	</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>
	 Uncommited Read (en français, <quote>Lecture de données non validées</quote>)
	</entry>
	<entry>
	 Possible
	</entry>
	<entry>
	 Possible
	</entry>
	<entry>
	 Possible
	</entry>
       </row>

       <row>
	<entry>
	 Commited Read (en français, <quote>Lecture de données validées</quote>)
	</entry>
	<entry>
	 Impossible
	</entry>
	<entry>
	 Possible
	</entry>
	<entry>
	 Possible
	</entry>
       </row>

       <row>
	<entry>
	 Repeatable Read (en français, <quote>Lecture répétée</quote>)
	</entry>
	<entry>
	 Impossible
	</entry>
	<entry>
	 Impossible
	</entry>
	<entry>
	 Possible
	</entry>
       </row>

       <row>
	<entry>
	 Serializable (en français, <quote>Sérialisable</quote>)
	</entry>
	<entry>
	 Impossible
	</entry>
	<entry>
	 Impossible
	</entry>
	<entry>
	 Impossible
	</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>
    Dans <productname>PostgreSQL</productname>, vous pouvez demander un des
    quatre niveaux standards d'isolation de transaction. Mais, en interne,
    il existe seulement trois niveaux distincts d'isolation, qui correspondent
    aux niveaux Read Committed et Repeatable Read, and Serializable. Lorsque vous sélectionnez le
    niveau Read Uncommitted, vous obtenez réellement Read Committed, et
    les lectures fantômes ne sont pas possibles dans l'implémentation
    <productname>PostgreSQL</productname> de Repeatable Read.
    Le niveau d'isolation actuel pourrait donc être plus strict que ce que vous
    sélectionnez. Ceci est permis par le standard SQL. Les quatre niveaux
    d'isolation définissent seulement quel phénomène ne doit pas survenir, ils
    ne définissent pas ce qui doit arriver. La raison pour laquelle
    <productname>PostgreSQL</productname> fournit seulement trois niveaux d'isolation est
    qu'il s'agit de la seule façon raisonnable de faire correspondre les niveaux
    d'isolation standards avec l'architecture de contrôle des accès simultanés
    multiversion. Le comportement des niveaux standards d'isolation est détaillé
    dans les sous-sections suivantes.
    </para>

    <para>
    Pour initialiser le niveau d'isolation d'une transaction, utilisez la
    commande <xref linkend="sql-set-transaction"/>.
    </para>

  <sect2 id="xact-read-committed">
   <title>Niveau d'isolation Read committed (lecture uniquement des données validées)</title>

   <indexterm>
    <primary>niveau d'isolation de transaction</primary>
    <secondary>lecture validée</secondary>
   </indexterm>

   <indexterm>
    <primary>read committed</primary>
   </indexterm>

   <para>
    <firstterm>Read Committed</firstterm> est le niveau d'isolation par défaut
    dans <productname>PostgreSQL</productname>. Quand une transaction utilise
    ce niveau d'isolation, une requête <command>SELECT</command> (sans clause
    <literal>FOR UPDATE/SHARE</literal>) voit seulement les données validées
    avant le début de la requête&nbsp;; il ne voit jamais les données non
    validées et les modifications validées pendant l'exécution de la requête
    par des transactions exécutées en parallèle. En effet, une requête
    <command>SELECT</command> voit une image de la base de données datant du
    moment où l'exécution de la requête commence. Néanmoins,
    <command>SELECT</command> voit les effets de mises à jour précédentes
    exécutées dans sa propre transaction, même si celles-ci n'ont pas encore
    été validées. De plus, notez que deux commandes <command>SELECT</command>
    successives peuvent voir des données différentes, même si elles sont
    exécutées dans la même transaction si d'autres transactions valident des
    modifications pendant l'exécution du premier <command>SELECT</command>.
   </para>

   <para>
    Les commandes <command>UPDATE</command>, <command>DELETE</command>,
    <command>SELECT FOR UPDATE</command> et <command>SELECT FOR SHARE</command>
    se comportent de la même façon que
    <command>SELECT</command> en ce qui concerne la recherche des lignes
    cibles&nbsp;: elles ne trouveront que les lignes cibles qui ont été validées
    avant le début de la commande. Néanmoins, une telle ligne cible pourrait
    avoir déjà été mise à jour (ou supprimée ou verrouillée) par
    une autre transaction concurrente au moment où elle est découverte. Dans ce
    cas, le processus de mise à jour attendra que la première transaction 
    soit validée ou annulée (si elle est toujours en cours). Si la
    première mise à jour est annulée, alors ses effets sont niés et le
    deuxième processus peut exécuter la mise à jour des lignes originellement
    trouvées. Si la première mise à jour est validée, la deuxième mise à jour
    ignorera la ligne si la première mise à jour l'a supprimée, sinon elle
    essaiera d'appliquer son opération à la version mise à jour de la ligne. La
    condition de la recherche de la commande (la clause <literal>WHERE</literal>) est
    ré-évaluée pour savoir si la version mise à jour de la ligne correspond
    toujours à la condition de recherche. Dans ce cas, la deuxième mise à jour
    continue son opération en utilisant la version mise à jour de la
    ligne. Dans le cas des commandes <command>SELECT FOR UPDATE</command> et
    <command>SELECT FOR SHARE</command>, cela signifie que la version mise à
    jour de la ligne est verrouillée et renvoyée au client.
   </para>

   <para>
    À cause de la règle ci-dessus, une commande de mise à jour a la
    possibilité de voir une image non cohérente&nbsp;: elle peut voir les effets
    de commandes de mises à jour concurrentes sur les mêmes lignes que
    celles qu'elle essaie de mettre à jour mais elle ne voit pas les effets de
    ces commandes sur les autres lignes de la base de données. Ce comportement
    rend le mode de lecture validée non convenable pour les commandes qui
    impliquent des conditions de recherche complexes&nbsp;; néanmoins, il est
    intéressant pour
    les cas simples. Par exemple, considérons la mise à jour de balances de
    banque avec des transactions comme&nbsp;:

<screen>BEGIN;
UPDATE comptes SET balance = balance + 100.00 WHERE no_compte = 12345;
UPDATE comptes SET balance = balance - 100.00 WHERE no_compte = 7534;
COMMIT;</screen>

    Si deux transactions comme celle-ci essaient de modifier en même temps la balance du
    compte 12345, nous voulons clairement que la deuxième transaction commence à
    partir de la version mise à jour de la ligne du compte. Comme chaque commande 
    n'affecte qu'une ligne prédéterminée, la laisser voir la
    version mise à jour de la ligne ne crée pas de soucis de cohérence.
   </para>

   <para>
    Des utilisations plus complexes peuvent produire des résultats non désirés
    dans le mode Read Committed. Par exemple, considérez une commande
    <command>DELETE</command> opérant sur des données qui sont à la fois ajoutées
    et supprimées du critère de restriction par une autre commande. Supposons que
    <literal>website</literal> est une table sur deux lignes avec
    <literal>website.hits</literal> valant <literal>9</literal> et
    <literal>10</literal>&nbsp;:

<screen>
BEGIN;
UPDATE website SET hits = hits + 1;
-- exécuté par une autre session :  DELETE FROM website WHERE hits = 10;
COMMIT;
</screen>

    La commande <command>DELETE</command> n'aura pas d'effet même s'il existe
    une ligne <literal>website.hits = 10</literal> avant et après la commande
    <command>UPDATE</command>. Cela survient parce que la valeur
    <literal>9</literal> de la ligne avant mise à jour est ignorée et que
    lorsque l'<command>UPDATE</command> termine et que <command>DELETE</command>
    obtient un verrou, la nouvelle valeur de la ligne n'est plus
    <literal>10</literal>, mais <literal>11</literal>, ce qui ne correspond
    plus au critère.
   </para>

   <para>
    Comme le mode Read Committed commence chaque commande avec une nouvelle
    image qui inclut toutes les transactions validées jusqu'à cet instant,
    les commandes suivantes dans la même transaction verront les effets de
    la transaction validée en parallèle dans tous les cas. Le problème en
    question est de savoir si une <emphasis>seule</emphasis> commande voit
    une vue absolument cohérente ou non de la base de données.
   </para>

   <para>
    L'isolation partielle des transactions fournie par le mode Read Committed
    est adéquate pour de nombreuses applications, et ce mode est rapide et
    simple à utiliser. Néanmoins, il n'est pas suffisant dans tous les cas.
    Les applications qui exécutent des requêtes et des mises à jour complexes
    pourraient avoir besoin d'une vue plus rigoureusement cohérente de la base
    de données, une vue que le mode Read Committed ne fournit pas.
   </para>
  </sect2>

  <sect2 id="xact-repeatable-read">
   <title>Repeatable Read Isolation Level</title>

   <indexterm>
    <primary>niveau d'isolation de transaction</primary>
    <secondary>repeatable read</secondary>
   </indexterm>

   <indexterm>
    <primary>repeatable read</primary>
   </indexterm>

   <para>
    Le niveau d'isolation <firstterm>Repeatable Read</firstterm> ne
    voit que les données validées avant que la transaction ait démarré; il ne
    voit jamais ni les données non validées, ni les données validées par
    des transactions concurrentes durant son exécution. (Toutefois, la requête
    voit les effets de mises à jour précédentes effectuées dans sa propre
    transaction, bien qu'elles ne soient pas encore validées). C'est une
    garantie plus élevée que requise par le standard <acronym>SQL</acronym>
    pour ce niveau d'isolation, et elle évite le phénomène décrit dans
    <xref linkend="mvcc-isolevel-table"/>. Comme mentionné plus haut, c'est 
    permis par le standard, qui ne définit que la protection
    <emphasis>minimale</emphasis> que chaque niveau d'isolation doit fournir.
   </para>

   <para>
    Ce niveau est différent de Read Committed parce qu'une requête dans
    une transaction repeatable read voit un instantané au début de la
    <emphasis>transaction</emphasis>,
    et non pas du début de la requête en cours à l'intérieur de la transaction.
    Du coup, les commandes <command>SELECT</command> successives à l'intérieur
    d'une <emphasis>seule</emphasis> transaction voient toujours les mêmes données,
    c'est-à-dire qu'elles ne voient jamais les modifications faites par les autres
    transactions qui ont validé après le début de leur propre transaction.
   </para>

   <para>
    Les applications utilisant ce niveau d'isolation doivent être préparées
    à retenter des transactions à cause d'échecs de sérialisation.
   </para>

   <para>
    Les commandes <command>UPDATE</command>, <command>DELETE</command>,
    <command>SELECT FOR UPDATE</command> et <command>SELECT FOR SHARE</command>
    se comportent de la même façon que
    <command>SELECT</command> en ce qui concerne la recherche de lignes
    cibles&nbsp;: elles trouveront seulement les lignes cibles qui ont été
    validées avant le début de la transaction. Néanmoins, une telle ligne cible
    pourrait avoir été mise à jour (ou supprimée ou verrouillée)
    par une autre transaction concurrente au moment où elle est utilisée. Dans
    ce cas, la transaction repeatable read attendra que la première transaction de
    mise à jour soit validée ou annulée (si celle-ci est toujours en
    cours). Si la première mise à jour est annulée, les effets sont inversés et
    la transaction repeatable read peut continuer avec la mise à jour de la ligne
    trouvée à l'origine. Mais si la mise à jour est validée (et que
    la ligne est mise à jour ou supprimée, pas simplement verrouillée),
    alors la transaction repeatable read sera annulée avec le message

<screen>ERROR:  could not serialize access due to concurrent update</screen>

    parce qu'une transaction sérialisable ne peut pas modifier ou verrouiller
    les lignes changées par d'autres transactions après que la transaction
    sérialisable ait commencé.
   </para>

   <para>
    Quand une application reçoit ce message d'erreurs, elle devrait annuler la
    transaction actuelle et ré-essayer la transaction complète. La seconde fois,
    la transaction voit les modifications déjà validées comme faisant partie de
    sa vue initiale de la base de données, donc il n'y a pas de conflit logique
    en utilisant la nouvelle version de la ligne comme point de départ pour la
    mise à jour de la nouvelle transaction.
   </para>

   <para>
    Notez que seules les transactions de modifications ont besoin d'être
    tentées de nouveau&nbsp;; les transactions en lecture seule n'auront jamais
    de conflits de sérialisation.
   </para>

   <para>
    Le mode Repeatable Repeatable fournit une garantie rigoureuse que chaque
    transaction voit un état complètement stable de la base de données. Toutefois
    cette vue ne sera pas nécessairement toujours cohérente avec l'exécution sérielle
    (un à la fois) de transactions concurrentes du même niveau d'isolation.
    Par exemple, même une transaction en lecture seule à ce niveau
    pourrait voire un enregistrement de contrôle mis à jour pour indiquer qu'un
    traitement par lot a été terminé mais <emphasis>ne pas</emphasis> voir un
    des enregistrements de détail qui est une partie logique du traitement par lot
    parce qu'il a lu une ancienne version de l'enregistrement de contrôle.
    L'implémentation correcte de règles de gestion par des transactions
    s'exécutant à ce niveau d'isolation risque de ne pas marcher correctement
    sans une utilisation prudente de verrouillages explicites qui bloquent
    les transactions en conflits.
   </para>

    <para>
     Avant la version 9.1 de <productname>PostgreSQL</productname>, une
     demande d'isolation de transaction Serializable fournissait exactement
     le comportement décrit ici. Pour maintenir l'ancien niveau Serializable,
     il faudra maintenant demander Repeatable Read.
    </para>
  </sect2>

  <sect2 id="xact-serializable">
   <title>Niveau d'Isolation Serializable</title>

   <indexterm>
    <primary>niveau d'isolation de transaction</primary>
    <secondary>serializable</secondary>
   </indexterm>
 
    <indexterm>
    <primary>serializable</primary>
    </indexterm>
 
    <indexterm>
     <primary>verrouillage de prédicat</primary>
    </indexterm>
 
   <indexterm>
    <primary>anomalie de sérialisation</primary>
   </indexterm>

     <para>
    Le niveau d'isolation <firstterm>Serializable</firstterm> fournit
    le niveau d'isolation le plus strict. Ce niveau émule l'exécution
    sérielle de transaction, comme si les transactions avaient été
    exécutées les unes après les autres, séquentiellement, plutôt
    que simultanément. Toutefois, comme pour le niveau Repeatable Read,
    les applications utilisant ce niveau d'isolation doivent être prêtes
    à répéter leurs transactions en cas d'échec de sérialisation. En
    fait, ce niveau d'isolation fonctionne exactement comme Repeatable
    Read, excepté qu'il surveille les conditions qui pourraient amener
    l'exécution d'un jeu de transactions concurrentes à se comporter
    d'une manière incomptible avec les exécutions sérielles (une à
    la fois) de toutes ces transactions. Cette surveillance n'introduit
    aucun blocage supplémentaire par rapport à repeatable read, mais il
    y a un coût à cette surveillance, et la détection des conditions
    pouvant amener une <firstterm>anomalie de sérialisation</firstterm>
    déclenchera un <firstterm>échec de sérialisation</firstterm>.
   </para>

   <para>
      Comme exemple, considérez
      la table <structname>ma_table</structname>, contenant initialement
   <screen> classe | valeur
--------+-------
     1  |    10
     1  |    20
     2  |   100
     2  |   200</screen>
      Supposons que la transaction sérialisable A traite
   <screen>SELECT SUM(valeur) FROM ma_table WHERE classe = 1;</screen>
      puis insère le résultat (30) comme <structfield>valeur</structfield> dans une
      nouvelle ligne avec <structfield>classe</structfield> <literal>= 2</literal>. Simultanément, la
      transaction serialisable B traite
<screen>SELECT SUM(valeur) FROM ma_table WHERE classe = 2;</screen>
      et obtient le résultat 300, qu'il insère dans une nouvelle ligne avec
      <structfield>classe</structfield> <literal>= 1</literal>.  À ce moment là les deux transactions essayent de valider.
      Si l'une des transactions fonctionnait au niveau d'isolation Repeatable Read,
      les deux seraient autorisées à valider; mais puisqu'il n'y a pas d'ordre d'exécution
      sériel cohérent avec le résultat, l'utilisation de transactions Serializable
      permettra à une des deux transactions de valider, et annulera l'autre avec ce message:

<screen>
ERREUR:  n'a pas pu sérialiser un accès à cause d'une mise à jour en parallèle"
</screen>

    C'est parce que si A a été exécuté avant B, B aurait trouvé la somme 330, et non pas 300.
      De façon similaire, l'autre ordre aurait eu comme résultat une somme
      différente pour le calcul par A.
     </para>

     <para>
    Pour garantir une vraie sérialisation
    <productname>PostgreSQL</productname> utilise le
    <firstterm>verrouillage de prédicats</firstterm>, ce qui signifie
    qu'il conserve des verrous qui permettent de déterminer quand
    une écriture aurait eu un impact sur le résultat d'une lecture
    antérieure par une transaction concurrente, si elle s'était
    exécutée d'abord. Dans <productname>PostgreSQL</productname>,
    ces verrous ne causent pas de blocage et ne peuvent donc
    <emphasis>pas</emphasis> jouer un rôle dans l'avènement d'un
    verrou mortel (deadlock). Ils sont utilisés pour identifier et
    marquer les dépendances entre des transactions sérialisables
    concurrentes qui dans certaines combinaisons peuvent entrainer des
    anomalies de sérialisation. Par contraste, une transaction Read
    Committed ou Repeatable Read qui voudrait garantir la cohérence
    des données devra prendre un verrou sur la table entière, ce
    qui pourrait bloquer d'autres utilisateurs voulant utiliser cette
    table, ou pourrait utiliser <literal>SELECT FOR UPDATE</literal> ou
    <literal>SELECT FOR SELECT</literal> qui non seulement peut bloquer
    d'autres transactions, mais entraîne un accès au disque.
   </para>

   <para>
    Les verrous de prédicats dans <productname>PostgreSQL</productname>,
    comme dans la plupart des autres systèmes de bases de données,
    s'appuient sur les données réellement accédées par une
    transaction. Ils seront visibles dans la vue système <link
    linkend="view-pg-locks"><structname>pg_locks</structname></link> avec
    un <literal>mode</literal> de <literal>SIReadLock</literal>. Les
    verrous acquis pendant l'exécution d'une requête dépendront
    du plan utilisé par la requête, et plusieurs verrous fins (par
    exemple, des verrous d'enregistrement) pourraient être combinés en
    verrous plus grossiers (par exemple, des verrous de page) pendant le
    déroulement de la transaction afin d'éviter d'épuiser la mémoire
    utilisée pour suivre les verrous. Une transaction <literal>READ
    ONLY</literal> pourra libérer ses verrous SIRead avant sa fin, si
    elle détecte qu'aucun conflit ne peut encore se produire pouvant
    potentiellement entrainer une anomalie de sérialisation. En fait,
    les transaction <literal>READ ONLY</literal> seront souvent capable
    d'établir ce fait au moment de leur démarrage, et ainsi éviter
    de prendre des verrous de prédicat. Si vous demandez explicitement
    une transaction <literal>SERIALIZABLE READ ONLY DEFERRABLE</literal>,
    elle bloquera jusqu'à ce qu'elle puisse établir ce fait. (C'est le
    <emphasis>seul</emphasis> cas où_une transaction Serializable bloque
    mais pas une transaction Repeatable Read.) D'autre part, les verrous
    SIRead doivent souvent être gardés après la fin d'une transaction,
    jusqu'à ce que toutes les lectures-écritures s'étant déroulées
    simultanément soient terminées.
    </para>
 
    <para>
    L'utilisation systématique de transactions Serializable peut
    simplifier le développement. La garantie que n'importe quel jeu
    de transactions concurrentes aura le même effet que si elles
    s'exécutent une seule à la fois signifie que si vous pouvez
    démontrer qu'une transaction seule, comme elle est écrite,
    effectuera ce qui est attendu quand elle est exécutée seule, vous
    pouvez être sûr qu'elle effectuera ce qui est attendu quelques
    soient les autres transactions serializable qui s'exécutent en
    même temps, même sans aucune information sur ce que ces autres
    transactions pourraient faire. Il est important qu'un environnement
    qui utilise cette technique ait une façon généralisée de
    traiter les erreurs de sérialisation (qui retournent toujours
    un SQLSTATE valant '40001'), parce qu'il sera très difficile de
    prédire exactement quelles transactions pourraient contribuer à des
    dépendances lecture/écriture et auront besoin d'être annulées
    pour éviter les anomalies de sérialisation. La surveillance des
    dépendances lecture/écriture a un coût, tout comme l'échec,
    mais mis en face du coût et du blocage entrainés par les verrous
    explicites et <literal>SELECT FOR UPDATE</literal> ou <literal>SELECT
    FOR SHARE</literal>, les transactions serializable sont le meilleur
    choix en termes de performances pour certains environnements.
    </para>

   <para>
    Pour une performance optimale quand on s'appuie sur les transactions
    Serializable pour le contrôle de la concurrence, ces points doivent
    être pris en considération:

    <itemizedlist>
     <listitem>
      <para>
       Déclarer les transactions comme <literal>READ ONLY</literal> quand
       c'est possible.
      </para>
     </listitem>
     <listitem>
      <para>
       Contrôler le nombre de connexions actives, en utilisant un pool de
       connexions si nécessaire. C'est toujours un point important pour les
       performances, mais cela peut être particulièrement important pour un
       système chargé qui utilise des transactions Serializable.
      </para>
     </listitem>
     <listitem>
      <para>
       Ne mettez jamais plus dans une transaction seule qu'il n'est nécessaire
       dans un but d'intégrité.
      </para>
     </listitem>
     <listitem>
      <para>
       Ne laissez pas des connexions trainer en <quote>idle in transaction</quote>
       plus longtemps que nécessaire.
      </para>
     </listitem>
     <listitem>
      <para>
       Supprimez les verrous explicites, <literal>SELECT FOR UPDATE</literal>, et
       <literal>SELECT FOR SHARE</literal> qui ne sont plus nécessaires grâce
       aux protections fournies automatiquement par les transactions Serializable.
      </para>
     </listitem>
     <listitem>
      <para>
       Quand le système est forcé à combiner plusieurs verrous de prédicat
       au niveau page en un seul verrou de prédicat au niveau relation
       (si la table des verrous de prédicat est à court de mémoire), une
       augmentation du taux d'échecs de sérialisation peut survenir. Vous
       pouvez éviter ceci en augmentant <xref
       linkend="guc-max-pred-locks-per-transaction"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       Un parcours séquentiel nécessitera toujours un verrou de prédicat
       au niveau relation. Ceci peut résulter en un taux plus important
       d'échecs de sérialisation. Il peut être utile d'encourager
       l'utilisation de parcours d'index en diminuant <xref
       linkend="guc-random-page-cost"/> et/ou en augmentant <xref
       linkend="guc-cpu-tuple-cost"/>. Assurez-vous de bien mesurer toute
       diminution du nombre d'annulation de transactions et restarts
       against any overall change in query execution time.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <warning>
    <para>
     Le support pour le niveau d'isolation Serializable n'a pas encore
     été ajouté aux cibles de réplication Hot Standby (décrites dans
     <xref linkend="hot-standby"/>). Bien que les écritures permanentes
     dans la base effectuées dans des transactions Serializable sur le
     maître garantiront que toutes les standbys atteindront un état
     cohérent, une transaction Repeatable Read sur la standby pourra
     quelquefois voir un état transitoire qui sera incohérent avec
     une exécution sérielle sur le maître.
    </para>
   </warning>
  </sect2>
 </sect1>

  <sect1 id="explicit-locking">
   <title>Verrouillage explicite</title>

   <indexterm>
    <primary>verrou</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> fournit de nombreux modes de verrous
    pour contrôler les accès simultanés aux données des tables. Ces modes
    peuvent être utilisés pour contrôler le verrouillage par l'application dans
    des situations où <acronym>MVCC</acronym> n'a pas le comportement désiré. De
    plus, la plupart des commandes <productname>PostgreSQL</productname>
    acquièrent automatiquement des verrous avec les modes appropriés pour
    s'assurer que les tables référencées ne sont pas supprimées ou modifiées de
    façon incompatible lorsque la commande s'exécute (par exemple,
    <command>TRUNCATE</command> ne peut pas être exécuté de façon sûr en
    même temps que d'autres opérations sur la même table, donc il obtient un
    verrou exclusif sur la table pour s'assurer d'une bonne exécution).
   </para>

   <para>
    Pour examiner une liste des verrous en cours, utilisez la vue système <link
    linkend="view-pg-locks"><structname>pg_locks</structname></link>. Pour plus
    d'informations sur la surveillance du statut du sous-système de gestion des
    verrous, référez-vous au <xref linkend="monitoring"/>.
   </para>

  <sect2 id="locking-tables">
   <title>Verrous de niveau table</title>

   <indexterm zone="locking-tables">
    <primary>LOCK</primary>
   </indexterm>

   <para>
    La liste ci-dessous affiche les modes de verrous disponibles et les
    contextes dans lesquels ils sont automatiquement utilisés par
    <productname>PostgreSQL</productname>. Vous pouvez aussi acquérir
    explicitement n'importe lequel de ces verrous avec la commande <xref
    linkend="sql-lock"/>. Rappelez-vous que tous ces modes de
    verrous sont des verrous au niveau table, même si le nom contient le mot
    <quote>row</quote> (NdT&nbsp;: ligne)&nbsp;; les noms des modes de verrous
    sont historiques. Dans une certaine mesure, les noms reflètent l'utilisation
    typique de chaque mode de verrou &mdash; mais la sémantique est identique. La
    seule vraie différence entre un mode verrou et un autre est l'ensemble des
    modes verrous avec lesquels ils rentrent en conflit
    (voir <xref linkend="table-lock-compatibility"/>). Deux transactions ne
    peuvent pas conserver des verrous de modes en conflit sur la même table au
    même moment (néanmoins, une transaction n'entre jamais en conflit avec
    elle-même. Par exemple, elle pourrait acquérir un verrou <literal>ACCESS
    EXCLUSIVE</literal> et acquérir plus tard un verrou <literal>ACCESS
    SHARE</literal> sur la même table). Des modes de verrou sans conflit
    peuvent être détenus en même temps par plusieurs transactions. Notez, en
    particulier, que certains modes de verrous sont en conflit avec eux-même (par
    exemple, un verrou <literal>ACCESS EXCLUSIVE</literal> ne peut pas être
    détenu par plus d'une transaction à la fois) alors que d'autres n'entrent
    pas en conflit avec eux-même (par exemple, un verrou <literal>ACCESS
    SHARE</literal> peut être détenu par plusieurs transactions).
   </para>

     <variablelist>
      <title>Modes de verrous au niveau table</title>
      <varlistentry>
       <term>
	<literal>ACCESS SHARE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec le mode verrou <literal>ACCESS EXCLUSIVE</literal>.
	</para>

	<para>
	 Les commandes <command>SELECT</command> acquièrent un verrou de ce
	 mode avec les tables référencées. En général, tout requête <emphasis>lisant</emphasis>
	 seulement une table et ne la modifiant pas obtient ce mode de verrou.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>ROW SHARE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec les modes de verrous <literal>EXCLUSIVE</literal> et
	 <literal>ACCESS EXCLUSIVE</literal>.
	</para>

	<para>
	 La commande <command>SELECT FOR UPDATE</command> et <command>SELECT
	 FOR SHARE</command> acquièrent un verrou de ce mode
	 avec la table cible (en plus des verrous <literal>ACCESS
	 SHARE</literal> des autres tables référencées mais pas
	 sélectionnées <option>FOR UPDATE/FOR SHARE</option>).
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>ROW EXCLUSIVE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec les modes de verrous <literal>SHARE</literal>,
	 <literal>SHARE ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal>
	 et <literal>ACCESS EXCLUSIVE</literal>.
	</para>

	<para>
	 Les commandes <command>UPDATE</command>,
	 <command>DELETE</command> et <command>INSERT</command> acquièrent ce
	 mode de verrou sur la table cible (en plus des verrous <literal>ACCESS
	 SHARE</literal> sur toutes les autres tables référencées). En général,
	 ce mode de verrouillage sera acquis par toute commande <emphasis>modifiant</emphasis> des
	 données de la table.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>SHARE UPDATE EXCLUSIVE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec les modes de verrous <literal>SHARE UPDATE
	 EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE ROW
	 EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
	 <literal>ACCESS EXCLUSIVE</literal>. Ce mode protège une table contre
	 les modifications simultanées de schéma et l'exécution d'un
	 <command>VACUUM</command>.
	</para>

	<para>
	 Acquis par <command>VACUUM</command> (sans <option>FULL</option>),
	 <command>ANALYZE</command>, <command>CREATE INDEX CONCURRENTLY</command>, and
     some forms of <command>ALTER TABLE</command>.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>SHARE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec les modes de verrous <literal>ROW EXCLUSIVE</literal>,
         <literal>SHARE UPDATE EXCLUSIVE</literal>, <literal>SHARE ROW
         EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
         <literal>ACCESS EXCLUSIVE</literal>. Ce mode protège une table
	 contre les modifications simultanées des données.
	</para>

	<para>
	 Acquis par <command>CREATE INDEX</command> (sans <option>CONCURRENTLY</option>).
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>SHARE ROW EXCLUSIVE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec les modes de verrous <literal>ROW EXCLUSIVE</literal>,
         <literal>SHARE UPDATE EXCLUSIVE</literal>,
         <literal>SHARE</literal>, <literal>SHARE ROW
         EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
         <literal>ACCESS EXCLUSIVE</literal>.
	 Ce mode protège une table contre les modifications concurrentes de données,
	 et est en conflit avec elle-même, afin qu'une seule session puisse le
	 posséder à un moment donné.
	</para>

	<para>
     Ce mode de verrouillage n'est pas acquis automatiquement par une
     commande <productname>PostgreSQL</productname>.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>EXCLUSIVE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec les modes de verrous <literal>ROW SHARE</literal>,
	 <literal>ROW EXCLUSIVE</literal>, <literal>SHARE UPDATE
         EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE
         ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
         <literal>ACCESS EXCLUSIVE</literal>. Ce mode autorise uniquement les
	 verrous <literal>ACCESS SHARE</literal> concurrents, c'est-à-dire que
	 seules les lectures à partir de la table peuvent être effectuées en
	 parallèle avec une transaction contenant ce mode de verrouillage.
	</para>

	<para>
	 Ce mode de verrouillage n'est acquis automatiquement sur
	 des tables par aucune commande <productname>PostgreSQL</productname>.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>ACCESS EXCLUSIVE</literal>
       </term>
       <listitem>
	<para>
	 Entre en conflit avec tous les modes (<literal>ACCESS
         SHARE</literal>, <literal>ROW SHARE</literal>, <literal>ROW
         EXCLUSIVE</literal>, <literal>SHARE UPDATE
         EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE
         ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
         <literal>ACCESS EXCLUSIVE</literal>).
	 Ce mode garantit que le détenteur est la seule transaction à accéder à
	 la table de quelque façon que ce soit.
	</para>

	<para>
	 Acquis par les commandes <command>ALTER TABLE</command>, <command>DROP
	 TABLE</command>, <command>TRUNCATE</command>, <command>REINDEX</command>,
	 <command>CLUSTER</command> et <command>VACUUM FULL</command>. C'est
	 aussi le mode de verrou par défaut des instructions <command>LOCK
	 TABLE</command> qui ne spécifient pas explicitement de mode de verrouillage.
	</para>
       </listitem>
      </varlistentry>
     </variablelist>

     <tip>
      <para>
       Seul un verrou <literal>ACCESS EXCLUSIVE</literal> bloque une instruction
       <command>SELECT</command> (sans <option>FOR UPDATE/SHARE</option>).
      </para>
     </tip>

   <para>
    Une fois acquis, un verrou est normalement détenu jusqu'à la fin de la
    transaction. Mais si un verrou est acquis après l'établissement d'un point
    de sauvegarde, le verrou est relâché immédiatement si le point de sauvegarde
    est annulé. Ceci est cohérent avec le principe du <command>ROLLBACK</command>
    annulant tous les effets des commandes depuis le dernier point de sauvegarde.
    Il se passe la même chose pour les verrous acquis à l'intérieur d'un bloc
    d'exception <application>PL/pgSQL</application>&nbsp;: un échappement
    d'erreur à partir du bloc lâche les verrous acquis dans le bloc.
   </para>

    <table tocentry="1" id="table-lock-compatibility">
     <title>Modes de verrou conflictuels</title>
     <tgroup cols="9">
      <colspec colnum="2" colname="lockst" />
      <colspec colnum="9" colname="lockend" />
      <spanspec namest="lockst" nameend="lockend" spanname="lockreq"/>
      <thead>
       <row>
        <entry morerows="1">Verrou demandé</entry>
        <entry spanname="lockreq">Verrou déjà détenu</entry>
       </row>
       <row>
        <entry>ACCESS SHARE</entry>
        <entry>ROW SHARE</entry>
        <entry>ROW EXCLUSIVE</entry>
        <entry>SHARE UPDATE EXCLUSIVE</entry>
        <entry>SHARE</entry>
        <entry>SHARE ROW EXCLUSIVE</entry>
        <entry>EXCLUSIVE</entry>
        <entry>ACCESS EXCLUSIVE</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>ACCESS SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>ROW SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>ROW EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>SHARE UPDATE EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>SHARE ROW EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>ACCESS EXCLUSIVE</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="locking-rows">
    <title>Verrous au niveau ligne</title>

    <para>
     En plus des verrous au niveau table, il existe des verrous au niveau
     ligne, qui peuvent être des verrous exclusifs ou partagés. Un verrou
     exclusif sur une ligne spécifique est automatiquement acquis
     lorsque la ligne est mise à jour ou supprimée. Le verrou est détenu jusqu'à
     la fin de la transaction, que ce soit une validation ou une annulation, de
     la même façon que les verrous de niveau table. Les verrous au niveau ligne
     n'affectent pas les requêtes sur les données&nbsp;; ils bloquent seulement
     les <emphasis>modifieurs d'une même ligne</emphasis>.
    </para>

    <para>
     Pour acquérir un verrou exclusif
     au niveau ligne sans modifier réellement la ligne, sélectionnez la ligne
     avec <command>SELECT FOR UPDATE</command>. Notez qu'une fois le verrou au
     niveau ligne acquis, la transaction pourrait mettre à jour la ligne
     plusieurs fois sans peur des conflits.
    </para>

    <para>
     Pour acquérir un verrou partagé niveau ligne sur une ligne spécifique,
     sélectionnez la ligne avec <command>SELECT FOR SHARE</command>.  Un verrou
     partagé n'empêche pas les autres transactions d'obtenir le même verrou
     partagé. Néanmoins, aucune transaction n'est autorisée à mettre à jour,
     supprimer ou verrouiller exclusivement une ligne dont une autre
     transaction a obtenu un verrou partagé. Toute tentative de le faire
     bloque tant que les verrous partagés n'ont pas été enlevés.
    </para>

    <para>
     <productname>PostgreSQL</productname> ne garde en mémoire aucune information
     sur les lignes modifiées, il n'y a donc aucune limite sur le
     nombre de lignes verrouillées à un moment donné. Néanmoins, verrouiller une
     ligne peut causer une écriture disque&nbsp;; ainsi, par exemple,
     <command>SELECT FOR UPDATE</command> modifie les lignes sélectionnées
     pour les marquer verrouillées et cela aboutit à des écritures disques.
    </para>

    <para>
     En plus des verrous tables et lignes, les verrous partagés/exclusifs sur
     les pages sont utilisés pour contrôler la lecture et l'écriture des pages
     de table dans l'ensemble des tampons partagées. Ces verrous sont
     immédiatement relâchés une fois la ligne récupérée ou mise à jour. Les
     développeurs d'applications ne sont normalement pas concernés par les
     verrous au niveau page mais nous les mentionnons dans un souci d'exhaustivité.
    </para>

   </sect2>

   <sect2 id="locking-deadlocks">
    <title>Verrous morts (blocage)</title>

    <indexterm zone="locking-deadlocks">
     <primary>verrou mort</primary>
    </indexterm>

    <indexterm zone="locking-deadlocks">
     <primary>blocage de verrous</primary>
    </indexterm>

    <para>
     L'utilisation de verrous explicites accroît le risque de
     <firstterm>verrous morts</firstterm> lorsque deux transactions (voire plus) détiennent
     chacune un verrou que l'autre convoite. Par exemple, si la transaction 1 a
     acquis un verrou exclusif sur la table A puis essaie d'acquérir un verrou
     exclusif sur la table B alors que la transaction 2 possède déjà un verrou
     exclusif sur la table B et souhaite maintenant un verrou exclusif sur la
     table A, alors aucun des deux ne peut continuer.
     <productname>PostgreSQL</productname> détecte automatiquement ces
     situations de blocage et les résout en annulant une des transactions
     impliquées, permettant ainsi à l'autre (aux autres) de se terminer
     (quelle est exactement la transaction annulée est difficile à prévoir mais
     vous ne devriez pas vous en préoccuper).
    </para>

    <para>
     Notez que les verrous morts peuvent aussi se produire en conséquence à
     des verrous de niveau ligne (et du coup, ils peuvent se produire même si
     le verrouillage explicite n'est pas utilisé). Considérons le cas où il
     existe deux transactions concurrentes modifiant une table. La première
     transaction exécute&nbsp;:

<screen>UPDATE comptes SET balance = balance + 100.00 WHERE no_compte = 11111;</screen>

     Elle acquiert un verrou au niveau ligne sur la ligne spécifiée par 
     le numéro de compte (no_compte). Ensuite, la deuxième transaction
     exécute&nbsp;:

<screen>UPDATE comptes SET balance = balance + 100.00 WHERE no_compte = 22222;
UPDATE comptes SET balance = balance - 100.00 WHERE no_compte = 11111;</screen>

     La première instruction <command>UPDATE</command> acquiert avec succès un
verrou au niveau ligne sur la ligne spécifiée, donc elle réussit à mettre à jour
la ligne. Néanmoins, la deuxième instruction <command>UPDATE</command> trouve
que la ligne qu'elle essaie de mettre à jour a déjà été verrouillée, alors elle
attend la fin de la transaction ayant acquis le verrou. Maintenant, la première
transaction exécute&nbsp;:

<screen>UPDATE comptes SET balance = balance - 100.00 WHERE no_compte = 22222;</screen>

     La première transaction essaie d'acquérir un verrou au niveau ligne sur 
     la ligne spécifiée mais ne le peut pas&nbsp;: la deuxième transaction
     détient déjà un verrou. Donc, elle attend la fin de la transaction deux. Du
     coup, la première transaction est bloquée par la deuxième et la deuxième
     est bloquée par la première&nbsp;: une condition de blocage, un verrou
     mort. <productname>PostgreSQL</productname> détectera cette situation et
     annulera une des transactions.
    </para>

    <para>
     La meilleure défense contre les verrous morts est généralement de les
     éviter en s'assurant que toutes les applications utilisant une base de
     données acquièrent des verrous sur des objets multiples dans un ordre
     cohérent. Dans l'exemple ci-dessus, si les deux transactions avaient mis
     à jour les lignes dans le même ordre, aucun blocage n'aurait eu lieu.
     Vous devez vous assurer que le premier verrou acquis sur un objet dans
     une transaction est dans le mode le plus restrictif pour cet objet. S'il
     n'est pas possible de vérifier ceci à l'avance, alors les blocages doivent
     être gérés à l'exécution en ré-essayant les transactions annulées à cause
     de blocage.
    </para>

    <para>
     Tant qu'aucune situation de blocage n'est détectée, une transaction
     cherchant soit un verrou de niveau table soit un verrou de niveau ligne
     attend indéfiniment que les verrous en conflit soient relâchés. Ceci
     signifie que maintenir des transactions ouvertes sur une longue période
     de temps (par exemple en attendant une saisie de l'utilisateur) est
     parfois une mauvaise idée.
    </para>
   </sect2>

   <sect2 id="advisory-locks">
    <title>Verrous informatifs</title>

    <indexterm zone="advisory-locks">
     <primary>advisory lock</primary>
    </indexterm>

    <indexterm zone="advisory-locks">
     <primary>lock</primary>
     <secondary>advisory</secondary>
    </indexterm>

    <indexterm zone="advisory-locks">
     <primary>verrou</primary>
     <secondary>informatif</secondary>
    </indexterm>

    <para>
     <productname>PostgreSQL</productname> fournit un moyen pour créer des
     verrous qui ont une signification définie par l'application. Ils sont
     qualifiés d'<firstterm>informatifs</firstterm> car le système ne force
     pas leur utilisation &mdash; c'est à l'application de les utiliser
     correctement. Les verrous informatifs peuvent être utiles pour
     des manières d'utiliser le verrouillage qui ne sont pas en phase avec
     le modèle MVCC. Par exemple, une utilisation habituelle des verrous
     informations est l'émulation de stratégie de verrouillage pessimiste
     typique des systèmes de gestion de données à partir de <quote>fichiers
     à plat</quote>. Bien qu'un drapeau stocké dans une table puisse être
     utilisé pour la même raison, les verrous informatifs sont plus rapides,
     évitent la fragmentation de la table et sont nettoyés automatiquement
     par le serveur à la fin de la session.
    </para>

    <para>
     Il existe deux façons pour acquérir un verrou informatif dans
     <productname>PostgreSQL</productname>&nbsp;: au niveau de la session
     ou au niveau de la transaction. Une fois acquis au niveau de la
     session, un verrou information est détenu jusqu'à ce que le verrou
     soit explicitement relâché ou à la fin de la session. Contrairement
     aux demandes de verrou standard, les demandes de verrous informatifs
     au niveau session n'honorent pas la sémantique de la transaction&nbsp;:
     un verrou acquis lors d'une transaction qui est annulée plus tard
     sera toujours acquis après le ROLLBACK, et de la même façon, un verrou
     relâché reste valide même si la transaction appelante a échoué après.
     Un verrou peut être acquis plusieurs fois par le processus qui le
     détient&nbsp;; pour chaque demande de verrou terminée, il doit y avoir
     une demande de relâche du verrou correspondant avant que ce dernier
     ne soit réellement relâché.
     D'un autre côté, les demandes de verrou au niveau transaction se comportent
     plutôt comme des demandes de verrous standards&nbsp;: les verrous sont
     automatiquement relâchés à la fin de la transaction, et il n'y a pas
     d'opération explicite de déverrouillage. Ce comportement est souvent
     plus intéressant que le comportement au niveau session pour un usage
     rapide d'un verrou informatif.
     Les demandes de verrou au niveau session et transaction pour le même
     identifiant de verrou informatif se bloqueront de la façon attendue.
     Si une session détient déjà un verrou informatif donné, les demandes
     supplémentaires par le même processus réussiront toujours, même si
     d'autres sessions sont en attente&nbsp;; ceci est vrai quelque soit
     le niveau (session ou transaction) du verrou détenu et des verrous
     demandés.
    </para>

    <para>
     Comme tous les verrous dans <productname>PostgreSQL</productname>, une
     liste complète des verrous informatifs détenus actuellement par toute
     session est disponible dans la vue système <link
     linkend="view-pg-locks"><structname>pg_locks</structname></link>.
    </para>

    <para>
     Les verrous informatifs et les verrous standards sont stockés dans une
     partie de la mémoire partagée, dont la taille est définie par les
     variables de configuration <xref linkend="guc-max-locks-per-transaction"/>
     et <xref linkend="guc-max-connections"/>. Attention à ne pas vider cette
     mémoire, sinon le serveur ne serait plus capable d'accorder des verrous.
     Ceci impose une limite supérieure au nombre de verrous informatifs que le
     serveur peut accorder, typiquement entre des dizaines et des centaines de
     milliers suivant la façon dont le serveur est configuré.
    </para>

    <para>
     Dans certains cas utilisant
     cette méthode, tout spécialement les requêtes impliquant un tri explicite
     et des clauses <literal>LIMIT</literal>, une grande attention doit être
     portée au contrôle des verrous acquis, à cause de l'ordre dans lequel les
     expressions SQL sont évaluées. Par exemple&nbsp;:
<screen>SELECT pg_advisory_lock(id) FROM foo WHERE id = 12345; -- ok
SELECT pg_advisory_lock(id) FROM foo WHERE id &gt; 12345 LIMIT 100; -- danger !
SELECT pg_advisory_lock(q.id) FROM
(
  SELECT id FROM foo WHERE id &gt; 12345 LIMIT 100
) q; -- ok
</screen>
     Dans les requêtes ci-dessus, la deuxième forme est dangereuse parce qu'il 
     n'est pas garanti que l'application de <literal>LIMIT</literal> ait lieu avant que la
     fonction du verrou soit exécutée. Ceci pourrait entraîner l'acquisition 
     de certains verrous que l'application n'attendait pas, donc qu'elle
     ne pourrait, du coup, pas relâcher (sauf à la fin de la session). Du point de vue de
     l'application, de tels verrous sont en attente, bien qu'ils soient visibles dans
     <structname>pg_locks</structname>.
    </para>

    <para>
     Les fonctions fournies pour manipuler les verrous informatifs sont décrites dans
     <xref linkend="functions-advisory-locks"/>.
    </para>
   </sect2>

  </sect1>

  <sect1 id="applevel-consistency">
   <title>Vérification de cohérence des données au niveau de l'application</title>

   <para>
    Il est très difficile d'implémenter des règles de gestion sur l'intégrité
    des données en utilisant des transactions Read Committed parce que la vue
    des données est changeante avec chaque ordre, met même un seul ordre peut
    ne pas se cantonner à son propre instantané si un conflit en écriture
    se produit.
    </para>
 
    <para>
    Bien qu'une transaction Repeatable Read ait une vue stable des
    données dans toute la durée de son exécution, il y a un problème
    subtil quand on utilise les instantanés <acronym>MVCC</acronym> pour
    vérifier la cohérence des données, impliquant quelque chose connu
    sous le nom de <firstterm>conflits lecture/écriture</firstterm>. Si
    une transaction écrit des données et qu'une transaction
    concurrent essaye de lire la même donnée (que ce soit avant ou
    après l'écriture), elle ne peut pas voir le travail de l'autre
    transaction. Le lecteur donne donc l'impression de s'être exécuté
    le premier quel que soit celui qui a commencé le premier ou qui a
    validé le premier. Si on s'en tient là, ce n'est pas un problème,
    mais si le lecteur écrit aussi des données qui sont lues par
    une transaction concurrente il y a maintenant une transaction qui
    semble s'être exécutée avant les transactions précédemment
    mentionnées. Si la transaction qui semble s'être exécutée en
    dernier valide en premier, il est très facile qu'un cycle apparaisse
    dans l'ordre d'exécution des transactions. Quand un cycle de ce
    genre apparaît, les contrôles d'intégrité ne fonctionneront pas
    correctement sans aide.
    </para>
 
    <para>
    Comme mentionné dans <xref linkend="xact-serializable"/>, les
    transactions Serializable ne sont que des transactions Repeatable
    Read qui ajoutent une supervision no-bloquante de formes dangereuses
    de conflits lecture/écriture. Quand une de ces formes est détectée
    qui pourrait entraîner un cycle dans l'ordre apparent d'exécution,
    une des transactions impliquées est annulée pour casser le cycle.
    </para>
 
   <sect2 id="serializable-consistency">
    <title>Garantir la Cohérence avec Des Transactions Serializable</title>
 
    <para>
     Si le niveau d'isolation de transactions Serializable est utilisé
     pour toutes les écritures et toutes les lectures qui ont besoin
     d'une vue cohérente des données, aucun autre effort n'est requis
     pour garantir la cohérence. Un logiciel d'un autre environnement
     écrit pour utiliser des transactions serializable pour garantir
     la cohérence devrait <quote>fonctionner sans modification</quote>
     de ce point de vue dans <productname>PostgreSQL</productname>.
    </para>

    <para>
     L'utilisation de cette technique évitera de créer une
     charge de travail inutile aux développeurs d'applications
     si le logiciel utilise un framework qui réessaye le
     s transactions annulées pour échec de sérialisation
     automatiquement. Cela pourrait être une bonne idée de
     positionner <literal>default_transaction_isolation</literal> à
     <literal>serializable</literal>. Il serait sage, par ailleurs, de
     vous assurer qu'aucun autre niveau d'isolation n'est utilisé, soit
     par inadvertance, soit pour contourner les contrôles d'intégrité,
     en vérifiant les niveaux d'isolations dans les triggers.
    </para>

    <para>
     Voyez <xref linkend="xact-serializable"/> pour des suggestions sur
     les performances.
    </para>

    <warning>
     <para>
      Ce niveau de protection de protection de l'intégrité en utilisant
      des transactions Serializable ne s'étend pour le moment pas
      jusqu'au mode standby (<xref linkend="hot-standby"/>). Pour cette
      raison, les utilisateurs du hot standby voudront peut-être utiliser
      Repeatable Read et un verrouillage explicite sur le maître.
     </para>
    </warning>
   </sect2>

   <sect2 id="non-serializable-consistency">
    <title>Garantir la Cohérence avec des Verrous Bloquants Explicites</title>

    <para>
     Quand des écritures non-sérialisables sont possibles, pour garantir
     la validité courante d'un enregistrement et le protéger contre
     des mises à jour concurrentes, on doit utiliser <command>SELECT
     FOR UPDATE</command>, <command>SELECT FOR SHARE</command>, ou un
     ordre <command>LOCK TABLE</command> approprié. (<command>SELECT
     FOR UPDATE</command> et <command>SELECT FOR SELECT</command> ne
     verrouillent que les lignes retournées contre les mises à jour
     concurrentes, tandis que <command>LOCK TABLE</command> verrouille
     toute la table.) Cela doit être pris en considération quand
     vous portez des applications <productname>PostgreSQL</productname>
     à partir d'autres environnements.
    </para>

    <para>
     Il est aussi important de noter pour ceux qui convertissent à
     partir d'autres environnements le fait que <command>SELECT
     FOR UPDATE</command> ne garantit pas qu'une transaction
     concurrente ne mettra pas à jour ou n'effacera
     pas l'enregistrement selectionné. Pour faire cela dans
     <productname>PostgreSQL</productname> vous devez réellement modifier
     l'enregistrement, même si vous n'avez pas besoin de modifier une
     valeur. <command>SELECT FOR UPDATE</command> <emphasis>empêche
     temporairement</emphasis> les autres transactions d'acquérir
     le même verrou ou d'exécuter un <command>UPDATE</command>
     ou <command>DELETE</command> qui modifierait l'enregistrement
     verrouillé, mais une fois que la transaction possédant ce verrou
     valide ou annule, une transaction bloquée pourra continuer avec son
     opération en conflit sauf si un réel <command>UPDATE</command>
     de l'enregistement a été effectué pendant que le verrou était
     possédé.
    </para>

    <para>
     Les verrifications globales de validité demandent davantage de
     réflexion sous un <acronym>MVCC</acronym> non sérialisable. Par
     exemple, une application bancaire pourrait vouloir vérifier que
     la somme de tous les crédits d'une table est égale à la somme
     de tous les débits d'une autre, alors que les deux tables sont
     en cours de mise à jour. La comparaison des résultas de deux
     <literal>SELECT sum(...)</literal> successifs ne fonctionnera pas
     correctement en mode Read Committed, puisque la seconde requête
     incluera probablement les résultats de transactions pas prises en
     compte dans la première. Effectuer les deux sommes dans une seule
     transaction repeatable read donnera une image précise des effets
     d'uniquement les transactions  qui ont validé avant le début de la
     transaction repeatable read $mdash; mais on pourrait légitimement
     se demander si la réponse est toujours valide au moment où elle
     est fournie. Si la transaction repeatable read a elle même effectué
     des modifications avant d'effectuer le test de cohérence, l'utilité
     de la vérification devient encore plus sujette à caution, puisque
     maintenant elle inclut des modifications depuis le début de la
     transaction, mais pas toutes. Dans ce genre de cas, une personne
     prudente pourra vouloir verrouiller toutes les tables nécessaires
     à la vérification, afin d'avoir une vision incontestable de
     la réalité courante. Un mode <literal>SHARE</literal> (ou plus
     élevé) garantit qu'il n'y a pas de changements non validés dans
     la table verrouillée, autres que ceux de la transaction courante.
    </para>

    <para>
     Notez aussi que si on se fie au verrouillage explicite pour
     empêcher les mises à jour concurrentes, on devrait soit utiliser
     Read Committed, soit utiliser Repeatable Read et faire attenion
     à obtenir les verrous avant d'effectuer les requêtes. Un verrou
     obtenu par une transaction repeatable read guarantit qu'aucune autre
     transaction modifiant la table n'est en cours d'exécution, mais si
     l'instantané vu par la transaction est antérieur à l'obtention du
     verrou, il pourrait aussi précéder des modifications maintenant
     validées dans la table. Un instantané de transaction repeatable
     read est en fait figé à l'exécution de sa première requête ou
     commande de modification de données (<literal>SELECT</literal>,
     <literal>INSERT</literal>, <literal>UPDATE</literal>, ou
     <literal>DELETE</literal>), il est donc possible d'obtenir les
     verrous explicitement avant que l'instantané ne soit figé.
    </para>
   </sect2>
  </sect1>

  <sect1 id="locking-indexes">
   <title>Locking and Indexes</title>

   <indexterm zone="locking-indexes">
    <primary>index</primary>
    <secondary>locks</secondary>
   </indexterm>

   <para>
    Though <productname>PostgreSQL</productname>
    provides nonblocking read/write access to table
    data, nonblocking read/write access is not currently offered for every
    index access method implemented
    in <productname>PostgreSQL</productname>.
    The various index types are handled as follows:

    <variablelist>
     <varlistentry>
      <term>
       B-tree, <acronym>GiST</acronym> and <acronym>SP-GiST</acronym> indexes
      </term>
      <listitem>
       <para>
        Short-term share/exclusive page-level locks are used for
        read/write access. Locks are released immediately after each
        index row is fetched or inserted.  These index types provide
        the highest concurrency without deadlock conditions.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       Hash indexes
      </term>
      <listitem>
       <para>
        Share/exclusive hash-bucket-level locks are used for read/write
        access.  Locks are released after the whole bucket is processed.
        Bucket-level locks provide better concurrency than index-level
        ones, but deadlock is possible since the locks are held longer
        than one index operation.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <acronym>GIN</acronym> indexes
      </term>
      <listitem>
       <para>
        Short-term share/exclusive page-level locks are used for
        read/write access. Locks are released immediately after each
        index row is fetched or inserted. But note that insertion of a
        GIN-indexed value usually produces several index key insertions
        per row, so GIN might do substantial work for a single value's
        insertion.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Currently, B-tree indexes offer the best performance for concurrent
    applications; since they also have more features than hash
    indexes, they are the recommended index type for concurrent
    applications that need to index scalar data. When dealing with
    non-scalar data, B-trees are not useful, and GiST, SP-GiST or GIN
    indexes should be used instead.
   </para>
  </sect1>
 </chapter>
