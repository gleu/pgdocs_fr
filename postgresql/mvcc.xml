<?xml version="1.0" encoding="UTF-8"?>

<chapter id="mvcc">
 <title>Contrôle d'accès simultané</title>

 <indexterm>
  <primary>concurrence</primary>
 </indexterm>

 <para>
  Ce chapitre décrit le comportement de <productname>PostgreSQL</productname>
  lorsque deux sessions, ou plus essaient d'accéder aux mêmes données au
  même moment. Le but dans cette situation est de permettre un accès
  efficace pour toutes les sessions tout en maintenant une intégrité stricte
  des données. Chaque développeur d'applications utilisant des bases de
  données doit avoir une bonne compréhension des thèmes couverts dans ce
  chapitre.
 </para>

 <sect1 id="mvcc-intro">
  <title>Introduction</title>

  <indexterm>
   <primary>Multiversion Concurrency Control</primary>
  </indexterm>

  <indexterm>
   <primary>MVCC</primary>
  </indexterm>

  <indexterm>
   <primary>Serializable Snapshot Isolation</primary>
  </indexterm>

  <indexterm>
   <primary>SSI</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> fournit un ensemble d'outils
   pour les développeurs qui souhaitent gérer des accès simultanés aux données.
   En interne, la cohérence des données est obtenue avec l'utilisation d'un
   modèle multiversion (Multiversion Concurrency Control, <acronym>MVCC</acronym>).
   Cela signifie que chaque requête SQL voit une image des données (une
   <firstterm>version de la base de données</firstterm>) telle qu'elles
   étaient quelques temps auparavant, quel que soit l'état actuel des données
   sous-jacentes.
   Cela évite que les requêtes puissent voir des données non cohérentes
   produites par des transactions concurrentes effectuant des mises à jour
   sur les mêmes lignes de données, fournissant ainsi une
   <firstterm>isolation des transactions</firstterm> pour chaque session de la
   base de données. <acronym>MVCC</acronym>, en évitant les méthodes des verrous
   des systèmes de bases de données traditionnels, minimise la
   durée des verrous pour permettre des performances raisonnables dans
   des environnements multiutilisateurs.
  </para>

  <para>
   Le principal avantage de l'utilisation du modèle <acronym>MVCC</acronym>
   pour le contrôle des accès simultanés, contrairement au verrouillage, est que, dans
   les verrous acquis par <acronym>MVCC</acronym> pour récupérer (en lecture)
   des données, aucun conflit n'intervient avec les verrous acquis pour écrire
   des données. Du coup, lire ne bloque jamais l'écriture et écrire ne bloque
   jamais la lecture.
   <productname>PostgreSQL</productname> maintient cette garantie même quand
   il fournit le niveau d'isolation le plus strict au moyen d'un niveau
   <firstterm>Serializable Snapshot Isolation</firstterm> (<acronym>SSI</acronym>)
   innovant.
  </para>

  <para>
   Des possibilités de verrouillage des tables ou des lignes sont aussi disponibles
   dans <productname>PostgreSQL</productname> pour les applications qui n'ont
   pas besoin en général d'une isolation complète des transactions et
   préfèrent gérer explicitement les points de conflits particuliers. Néanmoins,
   un bon usage de <acronym>MVCC</acronym> fournira généralement de
   meilleures performances que les verrous. De plus, les verrous informatifs
   définis par l'utilisateur fournissent un mécanisme d'acquisition de verrous
   qui n'est pas lié à une transaction.
  </para>
 </sect1>

 <sect1 id="transaction-iso">
  <title>Isolation des transactions</title>

  <indexterm>
   <primary>isolation des transactions</primary>
  </indexterm>

  <para>
   Le standard <acronym>SQL</acronym> définit quatre niveaux d'isolation de
   transaction.
   Le plus strict est Serializable, qui est défini par le standard dans
   un paragraphe qui déclare que toute exécution concurrente d'un jeu
   de transactions sérialisables doit apporter la garantie de produire
   le même effet que l'exécution consécutive de chacune d'entre elles
   dans un certain ordre. Les trois autres niveaux sont définis en termes
   de phénomènes résultant de l'interaction entre les transactions
   concurrentes, qui ne doivent pas se produire à chaque niveau. Le
   standard note qu'en raison de la définition de Serializable, aucun
   de ces phénomènes n'est possible à ce niveau. (Cela n'a rien de
   surprenant -- si l'effet des transactions doit être cohérent avec
   l'exécution consécutive de chacune d'entre elles, comment pourriez-vous
   voir un phénomène causé par des interactions?).
  </para>

  <para>
   Les phénomènes qui sont interdits à chaque niveau sont:

   <variablelist>
    <varlistentry>
     <term>
      lecture sale
      <indexterm><primary>lecture sale</primary></indexterm>
     </term>
     <listitem>
      <para>
       Une transaction lit des données écrites par une transaction concurrente
       non validée (dirty read).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      lecture non reproductible
      <indexterm><primary>lecture non reproductible</primary></indexterm>
     </term>
     <listitem>
      <para>
       Une transaction relit des données qu'elle a lues
       précédemment et trouve que les données ont été modifiées par une autre
       transaction (validée depuis la lecture initiale) (non repeatable read).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      lecture fantôme
      <indexterm><primary>lecture fantôme</primary></indexterm>
     </term>
     <listitem>
      <para>
       Une transaction réexécute une requête renvoyant un ensemble de lignes
       satisfaisant une condition de recherche et trouve que l'ensemble des
       lignes satisfaisant la condition a changé du fait d'une autre transaction
       récemment validée (phantom read).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      anomalie de sérialisation
      <indexterm><primary>anomalie de sérialisation</primary></indexterm>
     </term>
     <listitem>
      <para>
       Le résultat de la validation réussie d'un groupe de transactions
       est incohérent avec tous les ordres possibles d'exécutions de ces
       transactions, une par une.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   <indexterm>
    <primary>niveau d'isolation de transaction</primary>
   </indexterm>
   Les niveaux d'isolation des transactions proposés par le standard SQL
   et implémentés par PostgreSQL sont décrits dans le <xref
   linkend="mvcc-isolevel-table"/>.
  </para>

  <table tocentry="1" id="mvcc-isolevel-table">
   <title>Niveaux d'isolation des transactions</title>
   <tgroup cols="5">
    <colspec colnum="1" colwidth="2.2*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="0.6*"/>
    <colspec colnum="4" colwidth="0.6*"/>
    <colspec colnum="4" colwidth="0.6*"/>
    <thead>
     <row>
      <entry>
       Niveau d'isolation
      </entry>
      <entry>
       Lecture sale
      </entry>
      <entry>
       Lecture non reproductible
      </entry>
      <entry>
       Lecture fantôme
      </entry>
      <entry>
       Anomalie de sérialisation
      </entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       Read Uncommited (en français, <quote>Lecture de données non validées</quote>)
      </entry>
      <entry>
       Autorisé, mais pas dans PostgreSQL
      </entry>
      <entry>
       Possible
      </entry>
      <entry>
       Possible
      </entry>
      <entry>
       Possible
      </entry>
     </row>

     <row>
      <entry>
       Read Commited (en français, <quote>Lecture de données validées</quote>)
      </entry>
      <entry>
       Impossible
      </entry>
      <entry>
       Possible
      </entry>
      <entry>
       Possible
      </entry>
      <entry>
       Possible
      </entry>
     </row>

     <row>
      <entry>
       Repeatable Read (en français, <quote>Lecture répétée</quote>)
      </entry>
      <entry>
       Impossible
      </entry>
      <entry>
       Impossible
      </entry>
      <entry>
       Autorisé, mais pas dans PostgreSQL
      </entry>
      <entry>
       Possible
      </entry>
     </row>

     <row>
      <entry>
       Serializable (en français, <quote>Sérialisable</quote>)
      </entry>
      <entry>
       Impossible
      </entry>
      <entry>
       Impossible
      </entry>
      <entry>
       Impossible
      </entry>
      <entry>
       Impossible
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Dans <productname>PostgreSQL</productname>, vous pouvez demander un des
   quatre niveaux standards d'isolation des transactions, mais seuls trois
   niveaux distincts sont implémentés (le mode Read Uncommited de PostgreSQL
   se comporte comme le mode Read Commited). Ceci est dû au fait qu'il
   s'agit de la seule façon logique de faire correspondre les niveaux
   d'isolation standards à l'architecture de contrôle de la concurrence de
   PostgreSQL.
  </para>

  <para>
   Le tableau montre aussi que l'implémentation Repeatable Read de PostgreSQL
   n'autorise pas les lectures fantômes. Un comportement plus strict est
   autorisé par le standard SQL&nbsp;: les quatre niveaux d'isolation
   définissent seulement les phénomènes qui ne doivent pas survenir, et non
   pas les phénomènes qui <emphasis>doivent</emphasis> survenir. Le
   comportement des niveaux d'isolation disponibles est détaillé dans les
   sous-sections suivantes.
  </para>

  <para>
   Pour initialiser le niveau d'isolation d'une transaction, utilisez la
   commande <xref linkend="sql-set-transaction"/>.
  </para>

  <important>
   <para>
    Certains types de données et certaines fonctions de
    <productname>PostgreSQL</productname> ont des règles spéciales sur le
    comportement des transactions. En particulier, les modifications réalisées
    sur une séquence (et du coup sur le compteur d'une
    colonne déclarée <type>serial</type>) sont immédiatement visibles
    de toutes les autres transactions et ne sont pas annulées si la transaction
    qui a fait la modification est annulée. Voir
    <xref linkend="functions-sequence"/> et <xref linkend="datatype-serial"/>.
   </para>
  </important>

  <sect2 id="xact-read-committed">
   <title>Niveau d'isolation Read committed (lecture uniquement des données validées)</title>

   <indexterm>
    <primary>niveau d'isolation de transaction</primary>
    <secondary>lecture validée</secondary>
   </indexterm>

   <indexterm>
    <primary>read committed</primary>
   </indexterm>

   <para>
    <firstterm>Read Committed</firstterm> est le niveau d'isolation par défaut
    dans <productname>PostgreSQL</productname>. Quand une transaction utilise
    ce niveau d'isolation, une requête <command>SELECT</command> (sans clause
    <literal>FOR UPDATE/SHARE</literal>) voit seulement les données validées
    avant le début de la requête&nbsp;; il ne voit jamais les données non
    validées et les modifications validées pendant l'exécution de la requête
    par des transactions exécutées en parallèle. En effet, une requête
    <command>SELECT</command> voit une image de la base de données datant du
    moment où l'exécution de la requête commence. Néanmoins,
    <command>SELECT</command> voit les effets de mises à jour précédentes
    exécutées dans sa propre transaction, même si celles-ci n'ont pas encore
    été validées. De plus, notez que deux commandes <command>SELECT</command>
    successives peuvent voir des données différentes, même si elles sont
    exécutées dans la même transaction si d'autres transactions valident des
    modifications après que le premier <command>SELECT</command> a démarré
    et avant que le second <command>SELECT</command> ne commence.
   </para>

   <para>
    Les commandes <command>UPDATE</command>, <command>DELETE</command>,
    <command>SELECT FOR UPDATE</command> et <command>SELECT FOR SHARE</command>
    se comportent de la même façon que
    <command>SELECT</command> en ce qui concerne la recherche des lignes
    cibles&nbsp;: elles ne trouveront que les lignes cibles qui ont été validées
    avant le début de la commande. Néanmoins, une telle ligne cible pourrait
    avoir déjà été mise à jour (ou supprimée ou verrouillée) par
    une autre transaction concurrente au moment où elle est découverte. Dans ce
    cas, le processus de mise à jour attendra que la première transaction
    soit validée ou annulée (si elle est toujours en cours). Si la
    première mise à jour est annulée, alors ses effets sont niés et le
    deuxième processus peut exécuter la mise à jour des lignes originellement
    trouvées. Si la première mise à jour est validée, la deuxième mise à jour
    ignorera la ligne si la première mise à jour l'a supprimée, sinon elle
    essaiera d'appliquer son opération à la version mise à jour de la ligne. La
    condition de la recherche de la commande (la clause <literal>WHERE</literal>) est
    réévaluée pour savoir si la version mise à jour de la ligne correspond
    toujours à la condition de recherche. Dans ce cas, la deuxième mise à jour
    continue son opération en utilisant la version mise à jour de la
    ligne. Dans le cas des commandes <command>SELECT FOR UPDATE</command> et
    <command>SELECT FOR SHARE</command>, cela signifie que la version mise à
    jour de la ligne est verrouillée et renvoyée au client.
   </para>

   <para>
    <command>INSERT</command> avec une clause <literal>ON CONFLICT DO
     UPDATE</literal> se comporte de la même façon. Dans le mode Read Committed,
    chaque ligne proposée à l'insertion sera soit insérée soit mise à jour. Sauf
    s'il y a des erreurs sans rapport, une des deux solutions est garantie. Si
    un conflit survient d'une autre transaction dont les effets ne sont pas
    encore visibles à <command>INSERT</command>, la clause
    <command>UPDATE</command> affectera cette ligne, même s'il est possible
    qu'il n'existe <emphasis>pas</emphasis> de version de cette ligne visible
    à cette commande.
   </para>

   <para>
    <command>INSERT</command> avec une clause <literal>ON CONFLICT DO
     NOTHING</literal> pourrait avoir une insertion non terminée pour une ligne
    à cause du résultat d'une autre transaction dont les effets ne sont pas
    visibles à l'image de base de la commande <command>INSERT</command>. Là
    encore, c'est seulement le cas du mode Read Committed.
   </para>

   <para>
    À cause de la règle ci-dessus, une commande de mise à jour a la
    possibilité de voir une image non cohérente&nbsp;: elle peut voir les effets
    de commandes de mises à jour concurrentes sur les mêmes lignes que
    celles qu'elle essaie de mettre à jour, mais elle ne voit pas les effets de
    ces commandes sur les autres lignes de la base de données. Ce comportement
    rend le mode de lecture validée non convenable pour les commandes qui
    impliquent des conditions de recherche complexes&nbsp;; néanmoins, il est
    intéressant pour
    les cas simples. Par exemple, considérons la mise à jour de balances de
    banque avec des transactions comme&nbsp;:

    <screen>BEGIN;
UPDATE comptes SET balance = balance + 100.00 WHERE no_compte = 12345;
UPDATE comptes SET balance = balance - 100.00 WHERE no_compte = 7534;
COMMIT;</screen>

    Si deux transactions comme celle-ci essaient de modifier en même temps la balance du
    compte 12345, nous voulons clairement que la deuxième transaction commence à
    partir de la version mise à jour de la ligne du compte. Comme chaque commande
    n'affecte qu'une ligne prédéterminée, la laisser voir la
    version mise à jour de la ligne ne crée pas de soucis de cohérence.
   </para>

   <para>
    Des utilisations plus complexes peuvent produire des résultats non désirés
    dans le mode Read Committed. Par exemple, considérez une commande
    <command>DELETE</command> opérant sur des données qui sont à la fois ajoutées
    et supprimées du critère de restriction par une autre commande. Supposons que
    <literal>website</literal> est une table sur deux lignes avec
    <literal>website.hits</literal> valant <literal>9</literal> et
    <literal>10</literal>&nbsp;:

<screen>
BEGIN;
UPDATE website SET hits = hits + 1;
-- exécuté par une autre session :  DELETE FROM website WHERE hits = 10;
COMMIT;
    </screen>

    La commande <command>DELETE</command> n'aura pas d'effet même s'il existe
    une ligne <literal>website.hits = 10</literal> avant et après la commande
    <command>UPDATE</command>. Cela survient parce que la valeur
    <literal>9</literal> de la ligne avant mise à jour est ignorée et que
    lorsque l'<command>UPDATE</command> termine et que <command>DELETE</command>
    obtient un verrou, la nouvelle valeur de la ligne n'est plus
    <literal>10</literal>, mais <literal>11</literal>, ce qui ne correspond
    plus au critère.
   </para>

   <para>
    Comme le mode Read Committed commence chaque commande avec une nouvelle
    image qui inclut toutes les transactions validées jusqu'à cet instant,
    les commandes suivantes dans la même transaction verront les effets de
    la transaction validée en parallèle dans tous les cas. Le problème en
    question est de savoir si une <emphasis>seule</emphasis> commande voit
    une vue absolument cohérente ou non de la base de données.
   </para>

   <para>
    L'isolation partielle des transactions fournie par le mode Read Committed
    est adéquate pour de nombreuses applications, et ce mode est rapide et
    simple à utiliser. Néanmoins, il n'est pas suffisant dans tous les cas.
    Les applications qui exécutent des requêtes et des mises à jour complexes
    pourraient avoir besoin d'une vue plus rigoureusement cohérente de la base
    de données, une vue que le mode Read Committed ne fournit pas.
   </para>
  </sect2>

  <sect2 id="xact-repeatable-read">
   <title>Repeatable Read Isolation Level</title>

   <indexterm>
    <primary>niveau d'isolation de transaction</primary>
    <secondary>repeatable read</secondary>
   </indexterm>

   <indexterm>
    <primary>repeatable read</primary>
   </indexterm>

   <para>
    Le niveau d'isolation <firstterm>Repeatable Read</firstterm> ne
    voit que les données validées avant que la transaction ait démarré; il ne
    voit jamais ni les données non validées, ni les données validées par
    des transactions concurrentes durant son exécution. (Toutefois, la requête
    voit les effets de mises à jour précédentes effectuées dans sa propre
    transaction, bien qu'elles ne soient pas encore validées). C'est une
    garantie plus élevée que celle requise par le standard <acronym>SQL</acronym>
    pour ce niveau d'isolation, et elle évite le phénomène décrit dans
    <xref linkend="mvcc-isolevel-table"/> sauf pour les anomalies de
    sérialisation. Comme mentionné plus haut, c'est
    permis par le standard, qui ne définit que la protection
    <emphasis>minimale</emphasis> que chaque niveau d'isolation doit fournir.
   </para>

   <para>
    Ce niveau est différent de Read Committed parce qu'une requête dans
    une transaction repeatable read voit un instantané au début de la
    <emphasis>transaction</emphasis>,
    et non pas du début de la requête en cours à l'intérieur de la transaction.
    Du coup, les commandes <command>SELECT</command> successives à l'intérieur
    d'une <emphasis>seule</emphasis> transaction voient toujours les mêmes données,
    c'est-à-dire qu'elles ne voient jamais les modifications faites par les autres
    transactions qui ont été validées après le début de leur propre transaction.
   </para>

   <para>
    Les applications utilisant ce niveau d'isolation doivent être préparées
    à retenter des transactions à cause d'échecs de sérialisation.
   </para>

   <para>
    Les commandes <command>UPDATE</command>, <command>DELETE</command>,
    <command>SELECT FOR UPDATE</command> et <command>SELECT FOR SHARE</command>
    se comportent de la même façon que
    <command>SELECT</command> en ce qui concerne la recherche de lignes
    cibles&nbsp;: elles trouveront seulement les lignes cibles qui ont été
    validées avant le début de la transaction. Néanmoins, une telle ligne cible
    pourrait avoir été mise à jour (ou supprimée ou verrouillée)
    par une autre transaction concurrente au moment où elle est utilisée. Dans
    ce cas, la transaction repeatable read attendra que la première transaction de
    mise à jour soit validée ou annulée (si celle-ci est toujours en
    cours). Si la première mise à jour est annulée, les effets sont inversés et
    la transaction repeatable read peut continuer avec la mise à jour de la ligne
    trouvée à l'origine. Mais si la mise à jour est validée (et que
    la ligne est mise à jour ou supprimée, pas simplement verrouillée),
    alors la transaction repeatable read sera annulée avec le message

    <screen>ERROR:  could not serialize access due to concurrent update</screen>

    parce qu'une transaction sérialisable ne peut pas modifier ou verrouiller
    les lignes changées par d'autres transactions après que la transaction
    sérialisable a commencé.
   </para>

   <para>
    Quand une application reçoit ce message d'erreurs, elle devrait annuler la
    transaction actuelle et réessayer la transaction complète. La seconde fois,
    la transaction voit les modifications déjà validées comme faisant partie de
    sa vue initiale de la base de données, donc il n'y a pas de conflit logique
    en utilisant la nouvelle version de la ligne comme point de départ pour la
    mise à jour de la nouvelle transaction.
   </para>

   <para>
    Notez que seules les transactions de modifications ont besoin d'être
    tentées de nouveau&nbsp;; les transactions en lecture seule n'auront jamais
    de conflits de sérialisation.
   </para>

   <para>
    Le mode Repeatable Read fournit une garantie rigoureuse que chaque
    transaction voit un état complètement stable de la base de données. Toutefois
    cette vue ne sera pas nécessairement toujours cohérente avec l'exécution sérielle
    (un à la fois) de transactions concurrentes du même niveau d'isolation.
    Par exemple, même une transaction en lecture seule à ce niveau
    pourrait voir un enregistrement de contrôle mis à jour pour indiquer qu'un
    traitement par lot a été terminé, mais <emphasis>ne pas</emphasis> voir un
    des enregistrements de détail qui est une partie logique du traitement par lot
    parce qu'il a lu une ancienne version de l'enregistrement de contrôle.
    L'implémentation correcte de règles de gestion par des transactions
    s'exécutant à ce niveau d'isolation risque de ne pas marcher correctement
    sans une utilisation prudente de verrouillages explicites qui bloquent
    les transactions en conflit.
   </para>

   <para>
    Le niveau d'isolation Repeatable Read est implémenté en utilisant une
    technique connue dans la littérature académique des bases de données et
    dans certains autres produits de bases de données comme
    l'<firstterm>isolation de snapshots</firstterm> (<foreignphrase>Snapshot
    Isolation</foreignphrase>). Les différences en comportement et performance
    peuvent être observées en comparant avec les systèmes utilisant une
    technique traditionnelle de verrouillage qui réduit la concurrence.
    Certains autres systèmes offrent même les niveaux Repeatable Read et
    Snapshot Isolation comme des niveaux d'isolation distinct avec des
    comportements différents. Le phénomène qui permet cette distinction des
    deux techniques n'a pas été formalisé par les chercheurs en base de
    données jusqu'au développement du standard SQL et sont en dehors du
    périmètre de ce manuel. Pour un traitement complet, merci de lire <xref
    linkend="berenson95"/>.
   </para>

   <para>
    Avant la version 9.1 de <productname>PostgreSQL</productname>, une
    demande d'isolation de transaction Serializable fournissait exactement
    le comportement décrit ici. Pour maintenir l'ancien niveau Serializable,
    il faudra maintenant demander Repeatable Read.
   </para>
  </sect2>

  <sect2 id="xact-serializable">
   <title>Niveau d'Isolation Serializable</title>

   <indexterm>
    <primary>niveau d'isolation de transaction</primary>
    <secondary>serializable</secondary>
   </indexterm>

    <indexterm>
    <primary>serializable</primary>
    </indexterm>

    <indexterm>
     <primary>verrouillage de prédicat</primary>
    </indexterm>

   <indexterm>
    <primary>anomalie de sérialisation</primary>
   </indexterm>

     <para>
    Le niveau d'isolation <firstterm>Serializable</firstterm> fournit
    le niveau d'isolation le plus strict. Ce niveau émule l'exécution
    sérielle de transactions pour toutes les transactions validées, comme si
    les transactions avaient été
    exécutées les unes après les autres, séquentiellement, plutôt
    que simultanément. Toutefois, comme pour le niveau Repeatable Read,
    les applications utilisant ce niveau d'isolation doivent être prêtes
    à répéter leurs transactions en cas d'échec de sérialisation. En
    fait, ce niveau d'isolation fonctionne exactement comme Repeatable
    Read, excepté qu'il surveille les conditions qui pourraient amener
    l'exécution d'un jeu de transactions concurrentes à se comporter
    d'une manière incompatible avec les exécutions séquentielles (une à
    la fois) de toutes ces transactions. Cette surveillance n'introduit
    aucun blocage supplémentaire par rapport à repeatable read, mais il
    y a un coût à cette surveillance, et la détection des conditions
    pouvant amener une <firstterm>anomalie de sérialisation</firstterm>
    déclenchera un <firstterm>échec de sérialisation</firstterm>.
   </para>

   <para>
      Comme exemple, considérons
      la table <structname>ma_table</structname>, contenant initialement&nbsp;:
   <screen> classe | valeur
--------+-------
     1  |    10
     1  |    20
     2  |   100
     2  |   200</screen>
      Supposons que la transaction sérialisable A calcule&nbsp;:
   <screen>SELECT SUM(valeur) FROM ma_table WHERE classe = 1;</screen>
      puis insère le résultat (30) comme <structfield>valeur</structfield>
      dans une nouvelle ligne avec <structfield>classe</structfield>
      <literal>= 2</literal>.
      En même temps, la transaction sérialisable B calcule&nbsp;:
<screen>SELECT SUM(valeur) FROM ma_table WHERE classe = 2;</screen>
      et obtient le résultat 300, qu'elle insère dans une nouvelle ligne avec
      <structfield>classe</structfield> <literal>= 1</literal>.
      Puis, les deux transactions essaient de valider.
      Si l'une des transactions fonctionnait au niveau d'isolation Repeatable Read,
      les deux seraient autorisées à valider&nbsp;;
      mais puisqu'il n'y a pas d'ordre d'exécution séquentiel cohérent
      avec le résultat, l'utilisation de transactions Serializable
      permettra à une des deux transactions de valider,
      et annulera l'autre avec ce message&nbsp;:

<screen>
ERREUR:  n'a pas pu sérialiser un accès à cause d'une mise à jour en parallèle"
    </screen>

    En effet, si A avait été exécuté avant B, B aurait trouvé la somme 330, et non pas 300.
    De façon similaire, l'autre ordre aurait eu comme résultat une somme
    différente pour le calcul par A.
   </para>

   <para>
    Si on se fie aux transactions sérialisées pour empêcher les anomalies, il
    est important que toute donnée lue depuis une table utilisateur
    permanente ne soit pas considérée comme valide,
    et ce jusqu'à ce que la transaction qui l'a lue
    soit validée avec succès. Ceci est vrai même pour les transactions en
    lecture, sauf pour les données lues dans une transaction en lecture seule
    et <firstterm>déferrable</firstterm>, dont les données sont considérées
    valides dès leur lecture. En effet, une telle transaction,
    avant de lire quoi que ce soit, attend jusqu'à
    l'obtention d'une image garantie libre de tout problème.
    Dans tous les autres cas, les applications ne doivent pas dépendre des
    lectures d'une transaction annulée par la suite. Elles doivent plutôt
    retenter la transaction jusqu'à ce qu'elle réussisse.
   </para>

   <para>
    Pour garantir une vraie sérialisation
    <productname>PostgreSQL</productname> utilise le
    <firstterm>verrouillage de prédicats</firstterm>, ce qui signifie
    qu'il conserve des verrous qui lui permettent de déterminer si
    une écriture aurait eu un impact sur le résultat d'une lecture
    antérieure par une transaction concurrente, si elle s'était
    exécutée d'abord. Dans <productname>PostgreSQL</productname>,
    ces verrous ne causent pas de blocage, et ne peuvent donc
    <emphasis>pas</emphasis> jouer un rôle dans un
    verrou mortel (deadlock). Ces verrous sont utilisés pour identifier et
    marquer les dépendances entre des transactions sérialisables
    concurrentes qui, dans certaines combinaisons, peuvent entraîner des
    anomalies de sérialisation. Par contraste, une transaction Read
    Committed ou Repeatable Read qui voudrait garantir la cohérence
    des données devra prendre un verrou sur la table entière, ce
    qui pourrait bloquer d'autres utilisateurs voulant utiliser cette
    table, ou pourrait utiliser <literal>SELECT FOR UPDATE</literal> ou
    <literal>SELECT FOR SHARE</literal> qui non seulement peut bloquer
    d'autres transactions, mais entraîne un accès au disque.
   </para>

   <para>
    Les verrous de prédicats dans <productname>PostgreSQL</productname>,
    comme dans la plupart des autres systèmes de bases de données,
    s'appuient sur les données réellement accédées par une
    transaction. Ils seront visibles dans la vue système <link
    linkend="view-pg-locks"><structname>pg_locks</structname></link> avec
    un <literal>mode</literal> de <literal>SIReadLock</literal>. Les
    verrous acquis pendant l'exécution d'une requête dépendront
    du plan utilisé par la requête, et plusieurs verrous fins (par
    exemple des verrous d'enregistrement) peuvent être combinés en
    verrous plus grossiers (comme des verrous de page) pendant le
    déroulement de la transaction, pour éviter d'épuiser la mémoire
    utilisée par le suivi des verrous. Une transaction <literal>READ
     ONLY</literal> peut libérer ses verrous SIRead avant sa fin, si
    elle détecte que ne peut plus se produire un conflit
    qui entraînerait une anomalie de sérialisation. En fait,
    les transactions <literal>READ ONLY</literal> seront souvent capables
    d'établir ce fait dès leur démarrage, et ainsi éviteront
    de prendre des verrous de prédicat. Si vous demandez explicitement
    une transaction <literal>SERIALIZABLE READ ONLY DEFERRABLE</literal>,
    elle bloquera jusqu'à ce qu'elle puisse établir ce fait. (C'est le
    <emphasis>seul</emphasis> cas où une transaction Serializable bloque,
    mais pas une transaction Repeatable Read.) D'autre part, les verrous
    SIRead doivent souvent être gardés après la fin d'une transaction,
    jusqu'à ce que toutes les lectures-écritures s'étant déroulées
    simultanément soient terminées.
   </para>

   <para>
    L'utilisation systématique de transactions Serializable peut
    simplifier le développement. La garantie que tout ensemble de
    transactions sérialisées, concurrentes, et validées avec succès,
    aura le même effet que si elles avaient été exécutées une
    par une signifie que, si vous pouvez démontrer qu'une
    transaction exécutée seule est correcte, alors
    vous pouvez être certain qu'elle le restera dans tout
    mélange de transactions sérialisées, même sans informations sur
    ce que font les autres transactions, ou qu'elle ne sera pas validée.
    Il est important qu'un environnement
    qui utilise cette technique ait une méthode générale pour
    traiter les erreurs de sérialisation (qui retournent toujours
    un SQLSTATE valant '40001'). En effet, il sera très difficile de
    prédire correctement quelles transactions pourront contribuer à des
    dépendances lecture/écriture, et auront besoin d'être annulées
    pour éviter les anomalies de sérialisation. La surveillance des
    dépendances lecture/écriture a un coût, tout comme la répétition
    des transactions annulées pour un échec de sérialisation.
    Mais les transactions sérialisables sont le meilleur
    choix en termes de performances pour certains environnements,
    en regard du coût et du blocage de verrous explicites,
    de <literal>SELECT FOR UPDATE</literal> ou de <literal>SELECT
     FOR SHARE</literal>, .
   </para>

   <para>
    Bien que le niveau d'isolation Serializable de
    <productname>PostgreSQL</productname> ne permette à des transactions
    parallèles de valider leurs modifications que s'il est prouvé qu'une
    exécution dans l'ordre produirait le même résultat, il n'empêche pas
    toujours la levée d'erreurs qui ne surviendraient pas dans une véritable
    exécution en série. En particulier, il est possible de voir des violations
    de contraintes uniques suite à des conflits entre transactions
    Serializable qui se surchargent, même vérification explicite que
    la clé n'est pas présente avant de tenter de l'insérer. Ceci peut
    s'éviter en s'assurant que <emphasis>toutes</emphasis> les transactions
    Serializable qui peuvent insérer des clés en conflit vérifient
    explicitement avant si elles peuvent l'insérer. Par exemple, imaginez une
    application qui demande à un utilisateur une nouvelle clé, puis vérifie si
    elle n'existe pas déjà en cherchant à la lire d'abord,
    ou génère une nouvelle clé en sélectionnant la clé pré-existante
    la plus grande puis en ajoutant un. Si certaines
    transactions Serializable insèrent de nouvelles clés directement sans
    suivre ce protocole, des violations de contraintes uniques peuvent être
    rapportées, même dans des cas où elles ne pourraient pas survenir dans le
    cas d'une exécution en série de transactions concurrentes.
   </para>

   <para>
    Pour une performance optimale quand on s'appuie sur les transactions
    Serializable pour le contrôle de la concurrence, ces points doivent
    être pris en considération&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       Déclarer les transactions comme <literal>READ ONLY</literal> quand
       c'est possible.
      </para>
     </listitem>
     <listitem>
      <para>
       Contrôler le nombre de connexions actives, au besoin en utilisant un pool de
       connexions. C'est toujours un point important pour les
       performances, mais cela peut être particulièrement important pour un
       système chargé qui utilise des transactions Serializable.
      </para>
     </listitem>
     <listitem>
      <para>
       Ne mettez pas plus dans une transaction seule qu'il n'est nécessaire
       pour l'intégrité.
      </para>
     </listitem>
     <listitem>
      <para>
       Ne laissez pas des connexions traîner en <quote>idle in transaction</quote>
       plus longtemps que nécessaire. Le paramètre de configuration
       <xref linkend="guc-idle-in-transaction-session-timeout"/> peut être
       utilisé pour déconnecter automatiquement les sessions persistantes.
      </para>
     </listitem>
     <listitem>
      <para>
       Supprimez les verrous explicites, <literal>SELECT FOR UPDATE</literal>, et
       <literal>SELECT FOR SHARE</literal>, quand ils ne sont plus nécessaires grâce
       aux protections fournies automatiquement par les transactions Serializable.
      </para>
     </listitem>
     <listitem>
      <para>
       Quand le système est forcé à combiner plusieurs verrous de prédicat
       de niveau page en un seul verrou de niveau relation
       (parce que la table des verrous de prédicat est à court de mémoire), une
       augmentation du taux d'échecs de sérialisation peut survenir. Vous
       pouvez éviter ceci en augmentant <xref
       linkend="guc-max-pred-locks-per-transaction"/>,
       <xref linkend="guc-max-pred-locks-per-relation"/>, et/ou
       <xref linkend="guc-max-pred-locks-per-page"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       Un parcours séquentiel nécessitera toujours un verrou de prédicat
       au niveau relation. Ceci peut résulter en un taux plus important
       d'échecs de sérialisation. Il peut être utile d'encourager
       l'utilisation de parcours d'index en diminuant <xref
       linkend="guc-random-page-cost"/> et/ou en augmentant <xref
       linkend="guc-cpu-tuple-cost"/>. Assurez-vous de bien mettre en balance
       toute diminution du nombre d'annulations et de redémarrages de transactions
       et l'évolution globale du temps d'exécution des requêtes.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Le niveau d'isolation Serializable est implémenté en utilisant une
    technique connue sous le nom de <foreignphrase>
     Serializable Snapshot Isolation</foreignphrase>
    dans la littérature académique des bases de données. Elle se base
    sur l'isolation par snapshot et ajoute des vérifications pour les
    anomalies de sérialisation. Quelques différences de comportement et de
    performance peuvent être observées lors de la comparaison avec d'autres
    systèmes qui utilisent une technique de verrouillage traditionnelle. Merci
    de lire <xref linkend="ports12"/> pour des informations détaillées.
   </para>
  </sect2>
 </sect1>

 <sect1 id="explicit-locking">
  <title>Verrouillage explicite</title>

  <indexterm>
   <primary>verrou</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> fournit de nombreux modes de verrous
   pour contrôler les accès simultanés aux données des tables. Ces modes
   peuvent être utilisés pour contrôler le verrouillage par l'application dans
   des situations où <acronym>MVCC</acronym> n'a pas le comportement désiré. De
   plus, la plupart des commandes <productname>PostgreSQL</productname>
   acquièrent automatiquement des verrous avec les modes appropriés pour
   s'assurer que les tables référencées ne sont pas supprimées ou modifiées de
   façon incompatible lorsque la commande s'exécute (par exemple,
   <command>TRUNCATE</command> ne peut pas être exécuté de façon sûre en
   même temps que d'autres opérations sur la même table, donc il obtient un
   verrou de type <literal>ACCESS EXCLUSIVE</literal> sur la table pour
   s'assurer d'une bonne exécution).
  </para>

  <para>
   Pour examiner une liste des verrous en cours, utilisez la vue système <link
   linkend="view-pg-locks"><structname>pg_locks</structname></link>. Pour plus
   d'informations sur la surveillance du statut du sous-système de gestion des
   verrous, référez-vous au <xref linkend="monitoring"/>.
  </para>

  <sect2 id="locking-tables">
   <title>Verrous de niveau table</title>

   <indexterm zone="locking-tables">
    <primary>LOCK</primary>
   </indexterm>

   <para>
    La liste ci-dessous affiche les modes de verrous disponibles et les
    contextes dans lesquels ils sont automatiquement utilisés par
    <productname>PostgreSQL</productname>. Vous pouvez aussi acquérir
    explicitement n'importe lequel de ces verrous avec la commande <xref
    linkend="sql-lock"/>. Rappelez-vous que tous ces modes de
    verrous sont des verrous au niveau table, même si le nom contient le mot
    <quote>row</quote> (NdT&nbsp;: ligne)&nbsp;; les noms des modes de verrous
    sont historiques. Dans une certaine mesure, les noms reflètent l'utilisation
    typique de chaque mode de verrou &mdash; mais la sémantique est identique. La
    seule vraie différence entre un mode verrou et un autre est l'ensemble des
    modes verrous avec lesquels ils rentrent en conflit
    (voir <xref linkend="table-lock-compatibility"/>). Deux transactions ne
    peuvent pas conserver des verrous de modes en conflit sur la même table au
    même moment (néanmoins, une transaction n'entre jamais en conflit avec
    elle-même. Par exemple, elle pourrait acquérir un verrou <literal>ACCESS
     EXCLUSIVE</literal> et acquérir plus tard un verrou <literal>ACCESS
     SHARE</literal> sur la même table). Des modes de verrou sans conflit
    peuvent être détenus en même temps par plusieurs transactions. Notez, en
    particulier, que certains modes de verrous sont en conflit avec eux-mêmes (par
    exemple, un verrou <literal>ACCESS EXCLUSIVE</literal> ne peut pas être
    détenu par plus d'une transaction à la fois) alors que d'autres n'entrent
    pas en conflit avec eux-mêmes (par exemple, un verrou <literal>ACCESS
     SHARE</literal> peut être détenu par plusieurs transactions).
   </para>

   <variablelist>
    <title>Modes de verrous au niveau table</title>
    <varlistentry>
     <term>
      <literal>ACCESS SHARE</literal>
     </term>
     <listitem>
      <para>
       En conflit avec le mode verrou <literal>ACCESS EXCLUSIVE</literal>.
      </para>

      <para>
       Les commandes <command>SELECT</command> acquièrent un verrou de ce
       mode avec les tables référencées. En général, toute requête <emphasis>lisant</emphasis>
       seulement une table et ne la modifiant pas obtient ce mode de verrou.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal>ROW SHARE</literal>
     </term>
     <listitem>
      <para>
       En conflit avec les modes de verrous <literal>EXCLUSIVE</literal> et
       <literal>ACCESS EXCLUSIVE</literal>.
      </para>

      <para>
       La commande <command>SELECT FOR UPDATE</command> et <command>SELECT
        FOR SHARE</command> acquièrent un verrou de ce mode
       avec la table cible (en plus des verrous <literal>ACCESS
        SHARE</literal> des autres tables référencées, mais pas
       sélectionnées <option>FOR UPDATE/FOR SHARE</option>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal>ROW EXCLUSIVE</literal>
     </term>
     <listitem>
      <para>
       En conflit avec les modes de verrous <literal>SHARE</literal>,
       <literal>SHARE ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal>
       et <literal>ACCESS EXCLUSIVE</literal>.
      </para>

      <para>
       Les commandes <command>UPDATE</command>,
       <command>DELETE</command> et <command>INSERT</command> acquièrent ce
       mode de verrou sur la table cible (en plus des verrous <literal>ACCESS
        SHARE</literal> sur toutes les autres tables référencées). En général,
       ce mode de verrouillage sera acquis par toute commande <emphasis>modifiant</emphasis> des
       données de la table.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal>SHARE UPDATE EXCLUSIVE</literal>
     </term>
     <listitem>
      <para>
       En conflit avec les modes de verrous <literal>SHARE UPDATE
        EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE ROW
        EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
       <literal>ACCESS EXCLUSIVE</literal>. Ce mode protège une table contre
       les modifications simultanées de schéma et l'exécution d'un
       <command>VACUUM</command>.
      </para>

      <para>
       Acquis par <command>VACUUM</command> (sans <option>FULL</option>),
       <command>ANALYZE</command>, <command>CREATE INDEX CONCURRENTLY</command>,
       <command>CREATE STATISTICS</command>, <command>COMMENT ON</command>,
       <command>REINDEX CONCURRENTLY</command>, et certaines variantes de <link
       linkend="sql-alterindex"><command>ALTER INDEX</command></link> et <link
       linkend="sql-altertable"><command>ALTER TABLE</command></link> (pour plus
       de détails, voir la documentation de ces commandes).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal>SHARE</literal>
     </term>
     <listitem>
      <para>
       En conflit avec les modes de verrous <literal>ROW EXCLUSIVE</literal>,
       <literal>SHARE UPDATE EXCLUSIVE</literal>, <literal>SHARE ROW
        EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
       <literal>ACCESS EXCLUSIVE</literal>. Ce mode protège une table
       contre les modifications simultanées des données.
      </para>

      <para>
       Acquis par <command>CREATE INDEX</command> (sans <option>CONCURRENTLY</option>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal>SHARE ROW EXCLUSIVE</literal>
     </term>
     <listitem>
      <para>
       En conflit avec les modes de verrous <literal>ROW EXCLUSIVE</literal>,
       <literal>SHARE UPDATE EXCLUSIVE</literal>,
       <literal>SHARE</literal>, <literal>SHARE ROW
        EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
       <literal>ACCESS EXCLUSIVE</literal>.
       Ce mode protège une table contre les modifications concurrentes de données,
       et est en conflit avec elle-même, afin qu'une seule session puisse le
       posséder à un moment donné.
      </para>

      <para>
       Acquis par <command>CREATE TRIGGER</command> et différentes formes de
       <link linkend="sql-altertable"><command>ALTER TABLE</command></link>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal>EXCLUSIVE</literal>
     </term>
     <listitem>
      <para>
       En conflit avec les modes de verrous <literal>ROW SHARE</literal>,
       <literal>ROW EXCLUSIVE</literal>, <literal>SHARE UPDATE
        EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE
        ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
       <literal>ACCESS EXCLUSIVE</literal>. Ce mode autorise uniquement les
       verrous <literal>ACCESS SHARE</literal> concurrents, c'est-à-dire que
       seules les lectures à partir de la table peuvent être effectuées en
       parallèle avec une transaction contenant ce mode de verrouillage.
      </para>

      <para>
       Acquis par <command>REFRESH MATERIALIZED VIEW CONCURRENTLY</command>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal>ACCESS EXCLUSIVE</literal>
     </term>
     <listitem>
      <para>
       Entre en conflit avec tous les modes (<literal>ACCESS
        SHARE</literal>, <literal>ROW SHARE</literal>, <literal>ROW
        EXCLUSIVE</literal>, <literal>SHARE UPDATE
        EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE
        ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
       <literal>ACCESS EXCLUSIVE</literal>).
       Ce mode garantit que le détenteur est la seule transaction à accéder à
       la table de quelque façon que ce soit.
      </para>

      <para>
       Acquis par les commandes <command>DROP TABLE</command>,
       <command>TRUNCATE</command>, <command>REINDEX</command>,
       <command>CLUSTER</command>, <command>VACUUM FULL</command>,
       <command>REFRESH MATERIALIZED VIEW</command> (sans l'option
       <option>CONCURRENTLY</option>). De nombreuses formes d'<command>ALTER
        INDEX</command> et d'<command>ALTER TABLE</command> acquièrent
       également un verrou de ce niveau. C'est aussi le mode de verrou par
       défaut des instructions <command>LOCK TABLE</command> qui ne spécifient
       pas explicitement de mode de verrouillage.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   <tip>
    <para>
     Seul un verrou <literal>ACCESS EXCLUSIVE</literal> bloque une instruction
     <command>SELECT</command> (sans <option>FOR UPDATE/SHARE</option>).
    </para>
   </tip>

   <para>
    Une fois acquis, un verrou est normalement détenu jusqu'à la fin de la
    transaction. Mais si un verrou est acquis après l'établissement d'un point
    de sauvegarde, le verrou est relâché immédiatement si le point de sauvegarde
    est annulé. Ceci est cohérent avec le principe du <command>ROLLBACK</command>
    annulant tous les effets des commandes depuis le dernier point de sauvegarde.
    Il se passe la même chose pour les verrous acquis à l'intérieur d'un bloc
    d'exception <application>PL/pgSQL</application>&nbsp;: un échappement
    d'erreur à partir du bloc lâche les verrous acquis dans le bloc.
   </para>

   <table tocentry="1" id="table-lock-compatibility">
    <title>Modes de verrou conflictuels</title>
    <tgroup cols="9">
     <colspec colnum="1" colwidth="1.25*"/>
     <colspec colnum="2" colwidth="1*" colname="lockst"/>
     <colspec colnum="3" colwidth="1*"/>
     <colspec colnum="4" colwidth="1*"/>
     <colspec colnum="5" colwidth="1*"/>
     <colspec colnum="6" colwidth="1*"/>
     <colspec colnum="7" colwidth="1*"/>
     <colspec colnum="8" colwidth="1*"/>
     <colspec colnum="9" colwidth="1*" colname="lockend"/>
     <spanspec spanname="lockreq" namest="lockst" nameend="lockend" align="center"/>
     <thead>
      <row>
       <entry morerows="1">Verrou demandé</entry>
       <entry spanname="lockreq">Mode verrou existant</entry>
      </row>
      <row>
       <entry><literal>ACCESS SHARE</literal></entry>
       <entry><literal>ROW SHARE</literal></entry>
       <entry><literal>ROW EXCL.</literal></entry>
       <entry><literal>SHARE UPDATE EXCL.</literal></entry>
       <entry><literal>SHARE</literal></entry>
       <entry><literal>SHARE ROW EXCL.</literal></entry>
       <entry><literal>EXCL.</literal></entry>
       <entry><literal>ACCESS EXCL.</literal></entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>ACCESS SHARE</literal></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center">X</entry>
      </row>
      <row>
       <entry><literal>ROW SHARE</literal></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
      </row>
      <row>
       <entry><literal>ROW EXCLUSIVE</literal></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
      </row>
      <row>
       <entry><literal>SHARE UPDATE EXCLUSIVE</literal></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
      </row>
      <row>
       <entry><literal>SHARE</literal></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center"></entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
      </row>
      <row>
       <entry><literal>SHARE ROW EXCLUSIVE</literal></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
      </row>
      <row>
       <entry><literal>EXCLUSIVE</literal></entry>
       <entry align="center"></entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
      </row>
      <row>
       <entry><literal>ACCESS EXCLUSIVE</literal></entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

  <sect2 id="locking-rows">
   <title>Verrous au niveau ligne</title>

   <para>
    En plus des verrous au niveau table, il existe des verrous au niveau
    ligne. Ils sont listés ci-dessous, avec les contextes de leur
    utilisation automatique par <productname>PostgreSQL</productname>. Voir
    <xref linkend="row-lock-compatibility"/> pour une table complète des
    conflits de verrou niveau ligne. Notez qu'une transaction peut détenir
    des verrous en conflit sur la même ligne, y compris sur des sous-transactions
    différentes&nbsp;; mais en dehors de cela, deux transactions ne peuvent
    jamais détenir des verrous en conflit pour la même ligne. Les verrous
    au niveau ligne n'affectent pas les lectures des données&nbsp;; elles
    bloquent seulement les <emphasis>écrivains et verrouilleurs</emphasis>
    sur la même ligne. Les verrous au niveau ligne sont relachés à la fin
    de la transaction ou lors de l'annulation du savepoint, tout comme
    les verrous de niveau table.
   </para>

   <variablelist>
    <title>Modes des verrous au niveau ligne</title>
    <varlistentry>
     <term>
      <literal>FOR UPDATE</literal>
     </term>
     <listitem>
      <para>
       <literal>FOR UPDATE</literal> verrouille pour modification les lignes
       récupérées par l'instruction <command>SELECT</command>. Cela les empêche
       d'être modifiées ou supprimées par les autres transactions jusqu'à la fin
       de la transaction en cours. Les autres transactions qui tentent des
       <command>UPDATE</command>, <command>DELETE</command>, <command>SELECT
        FOR UPDATE</command>, <command>SELECT FOR NO KEY UPDATE</command>,
       <command>SELECT FOR SHARE</command> ou <command>SELECT FOR KEY
        SHARE</command> sur ces lignes sont bloquées jusqu'à la fin de la
       transaction courante&nbsp;; et inversement, <command>SELECT FOR
        UPDATE</command> attendra après une transaction concurrente qui a exécuté
       une de ces commandes sur la même ligne et qui verrouillera et renverra
       la ligne mise à jour (ou aucune ligne si elle a été supprimée).
       Néanmoins, à l'intérieur d'une transaction <literal>REPEATABLE READ</literal>
       ou <literal>SERIALIZABLE</literal>, une erreur sera renvoyée si une
       ligne à verrouiller a changé depuis que la transaction a commencé.
       Pour plus de détails, voir <xref linkend="applevel-consistency"/>.
      </para>
      <para>
       Le mode de verrouillage <literal>FOR UPDATE</literal>
       est aussi acquis par toute commande <command>DELETE</command> sur une ligne
       ainsi que par un <command>UPDATE</command> qui modifie les valeurs de
       certaines colonnes. Actuellement, l'ensemble de colonnes considéré par le
       cas <command>UPDATE</command> est celui qui a un index unique lors de son
       utilisation par une clé étrangère (donc les index partiels et fonctionnels
       ne sont pas considérés), mais cela pourra être modifié dans le futur.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal>FOR NO KEY UPDATE</literal>
     </term>
     <listitem>
      <para>
       <literal>FOR NO KEY UPDATE</literal> se comporte de la même façon que
       <literal>FOR UPDATE</literal> sauf que le verrou acquis est moins
       fort&nbsp;: ce verrou ne bloquera pas les commandes <literal>SELECT FOR
        KEY SHARE</literal> qui tenteraient d'acquérir un verrou sur les mêmes
       lignes. Ce mode de verrou est aussi acquis par tout
       <command>UPDATE</command> qui ne nécessite pas un verrou <literal>FOR
        UPDATE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal>FOR SHARE</literal>
     </term>
     <listitem>
      <para>
       <literal>FOR SHARE</literal> a un comportement similaire à
       <literal>FOR NO KEY UPDATE</literal>, sauf qu'il obtient un verrou
       partagé plutôt qu'un verrou exclusif sur chaque ligne récupérée.
       Un verrou partagé bloque les autres transactions réalisant des
       <command>UPDATE</command>, <command>DELETE</command>,
       <command>SELECT FOR UPDATE</command> et <command>SELECT FOR NO KEY
        UPDATE</command> sur ces lignes, mais il n'empêche pas les <command>SELECT
        FOR SHARE</command> et <command>SELECT FOR KEY SHARE</command>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal>FOR KEY SHARE</literal>
     </term>
     <listitem>
      <para>
       <literal>FOR KEY SHARE</literal> a un comportement similaire à <literal>FOR
        SHARE</literal>, sauf que le verrou est plus faible&nbsp;: <literal>SELECT
        FOR UPDATE</literal> est bloqué alors que <literal>SELECT FOR NO KEY
        UPDATE</literal> ne l'est pas. Un verrou à clé partagée bloque les autres
       transactions lors de l'exécution d'un <command>DELETE</command> ou d'un
       <command>UPDATE</command> qui modifie les valeurs clés, mais pas les autres
       <command>UPDATE</command>. Il n'empêche pas non plus les <command>SELECT FOR
        NO KEY UPDATE</command>, <command>SELECT FOR SHARE</command> et
       <command>SELECT FOR KEY SHARE</command>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   <para>
    <productname>PostgreSQL</productname> ne garde en mémoire aucune information
    sur les lignes modifiées, il n'y a donc aucune limite sur le
    nombre de lignes verrouillées à un moment donné. Néanmoins, verrouiller une
    ligne peut causer une écriture disque&nbsp;; ainsi,
    <command>SELECT FOR UPDATE</command> modifie les lignes sélectionnées
    pour les marquer verrouillées et cela aboutit à des écritures disques.
   </para>

   <table tocentry="1" id="row-lock-compatibility">
    <title>Verrous en conflit au niveau ligne</title>
    <tgroup cols="5">
     <colspec colname="col1"    colwidth="1.5*"/>
     <colspec colname="lockst"  colwidth="1*"/>
     <colspec colname="col3"    colwidth="1*"/>
     <colspec colname="col4"    colwidth="1*"/>
     <colspec colname="lockend" colwidth="1*"/>
     <spanspec namest="lockst" nameend="lockend" spanname="lockreq"/>
     <thead>
      <row>
       <entry morerows="1">Verrou demandé</entry>
       <entry spanname="lockreq">Verrou en cours</entry>
      </row>
      <row>
       <entry>FOR KEY SHARE</entry>
       <entry>FOR SHARE</entry>
       <entry>FOR NO KEY UPDATE</entry>
       <entry>FOR UPDATE</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>FOR KEY SHARE</entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center">X</entry>
      </row>
      <row>
       <entry>FOR SHARE</entry>
       <entry align="center"></entry>
       <entry align="center"></entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
      </row>
      <row>
       <entry>FOR NO KEY UPDATE</entry>
       <entry align="center"></entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
      </row>
      <row>
       <entry>FOR UPDATE</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
       <entry align="center">X</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

  <sect2 id="locking-pages">
   <title>Verrous au niveau page</title>

   <para>
    En plus des verrous tables et lignes, les verrous partagés/exclusifs sur
    les pages sont utilisés pour contrôler la lecture et l'écriture des pages
    de table dans l'ensemble des tampons partagées. Ces verrous sont
    immédiatement relâchés une fois la ligne récupérée ou mise à jour. Les
    développeurs d'applications ne sont normalement pas concernés par les
    verrous au niveau page, mais nous les mentionnons dans un souci d'exhaustivité.
   </para>

  </sect2>

  <sect2 id="locking-deadlocks">
   <title>Verrous morts (blocage)</title>

   <indexterm zone="locking-deadlocks">
    <primary>verrou mort</primary>
   </indexterm>

   <indexterm zone="locking-deadlocks">
    <primary>blocage de verrous</primary>
   </indexterm>

   <para>
    L'utilisation de verrous explicites accroît le risque de
    <firstterm>verrous morts</firstterm> lorsque deux transactions (voire plus) détiennent
    chacune un verrou que l'autre convoite. Par exemple, si la transaction 1 a
    acquis un verrou exclusif sur la table A puis essaie d'acquérir un verrou
    exclusif sur la table B alors que la transaction 2 possède déjà un verrou
    exclusif sur la table B et souhaite maintenant un verrou exclusif sur la
    table A, alors aucun des deux ne peut continuer.
    <productname>PostgreSQL</productname> détecte automatiquement ces
    situations de blocage et les résout en annulant une des transactions
    impliquées, permettant ainsi à l'autre (aux autres) de se terminer
    (savoir quelle transaction est réellement annulée est difficile à prévoir, mais
    vous ne devriez pas vous en préoccuper).
   </para>

   <para>
    Notez que les verrous morts peuvent aussi se produire suite à
    des verrous de niveau ligne (et du coup, ils peuvent se produire même si
    le verrouillage explicite n'est pas utilisé). Considérons le cas où il
    existe deux transactions concurrentes modifiant une table. La première
    transaction exécute&nbsp;:

    <screen>UPDATE comptes SET balance = balance + 100.00 WHERE no_compte = 11111;</screen>

     Elle acquiert un verrou au niveau ligne sur la ligne spécifiée par
     le numéro de compte (no_compte). Ensuite, la deuxième transaction
     exécute&nbsp;:

<screen>UPDATE comptes SET balance = balance + 100.00 WHERE no_compte = 22222;
UPDATE comptes SET balance = balance - 100.00 WHERE no_compte = 11111;</screen>

     La première instruction <command>UPDATE</command> acquiert avec succès un
verrou au niveau ligne sur la ligne spécifiée, donc elle réussit à mettre à jour
la ligne. Néanmoins, la deuxième instruction <command>UPDATE</command> trouve
que la ligne qu'elle essaie de mettre à jour a déjà été verrouillée, alors elle
attend la fin de la transaction ayant acquis le verrou. Maintenant, la première
transaction exécute&nbsp;:

<screen>UPDATE comptes SET balance = balance - 100.00 WHERE no_compte = 22222;</screen>

     La première transaction essaie d'acquérir un verrou au niveau ligne sur
     la ligne spécifiée, mais ne le peut pas&nbsp;: la deuxième transaction
     détient déjà un verrou. Donc, elle attend la fin de la transaction deux. Du
     coup, la première transaction est bloquée par la deuxième et la deuxième
     est bloquée par la première&nbsp;: une condition de blocage, un verrou
     mort. <productname>PostgreSQL</productname> détectera cette situation et
     annulera une des transactions.
    </para>

   <para>
    Le niveau d'isolation Repeatable Read est implémenté en utilisant une
    technique connue dans la littérature académique sur les bases de données
    et dans certains produits de bases de données sous le nom de
    <firstterm>Snapshot Isolation</firstterm>. Des différences en comportement
    et en performance peuvent être observées lors de comparaisons avec des
    systèmes qui utilisent une technique de verrouillage traditionnelle qui
    réduit la concurrence. Quelques autres systèmes peuvent même proposer
    Repeatable Read et Snapshot Isolation sous la forme de niveaux d'isolation
    distincts avec des comportements différents. Les phénomènes qui
    distinguent les deux techniques n'ont pas été formalisés par les
    chercheurs en bases de données jusqu'à ce que le standard SQL ne soit
    écrit. Pour un traitement complet, voir <xref linkend="berenson95"/>.
   </para>

    <para>
     La meilleure défense contre les verrous morts est généralement de les
     éviter en s'assurant que toutes les applications utilisant une base de
     données acquièrent des verrous sur des objets multiples dans un ordre
     cohérent. Dans l'exemple ci-dessus, si les deux transactions avaient mis
     à jour les lignes dans le même ordre, aucun blocage n'aurait eu lieu.
     Vous devez vous assurer que le premier verrou acquis sur un objet dans
     une transaction est dans le mode le plus restrictif pour cet objet. S'il
     n'est pas possible de vérifier ceci à l'avance, alors les blocages doivent
     être gérés à l'exécution en réessayant les transactions annulées à cause
     du blocage.
    </para>

    <para>
     Tant qu'aucune situation de blocage n'est détectée, une transaction
     cherchant soit un verrou de niveau table soit un verrou de niveau ligne
     attend indéfiniment que les verrous en conflit soient relâchés. Ceci
     signifie que maintenir des transactions ouvertes sur une longue période
     de temps (par exemple en attendant une saisie de l'utilisateur) est
     parfois une mauvaise idée.
    </para>
   </sect2>

   <sect2 id="advisory-locks">
    <title>Verrous informatifs</title>

    <indexterm zone="advisory-locks">
     <primary>verrou informatif</primary>
    </indexterm>

    <indexterm zone="advisory-locks">
     <primary>lock</primary>
     <secondary>advisory</secondary>
    </indexterm>

    <indexterm zone="advisory-locks">
     <primary>verrou</primary>
     <secondary>informatif</secondary>
    </indexterm>

    <para>
     <productname>PostgreSQL</productname> fournit un moyen pour créer des
     verrous qui ont une signification définie par l'application. Ils sont
     qualifiés d'<firstterm>informatifs</firstterm>, car le système ne force
     pas leur utilisation &mdash; c'est à l'application de les utiliser
     correctement. Les verrous informatifs peuvent être utiles pour
     des manières d'utiliser le verrouillage qui ne sont pas en phase avec
     le modèle MVCC. Par exemple, une utilisation habituelle des verrous
     informatifs est l'émulation de stratégie de verrouillage pessimiste
     typique des systèmes de gestion de données à partir de <quote>fichiers
     à plat</quote>. Bien qu'un drapeau stocké dans une table puisse être
     utilisé pour la même raison, les verrous informatifs sont plus rapides,
     évitent la fragmentation de la table et sont nettoyés automatiquement
     par le serveur à la fin de la session.
    </para>

    <para>
     Il existe deux façons pour acquérir un verrou informatif dans
     <productname>PostgreSQL</productname>&nbsp;: au niveau de la session
     ou au niveau de la transaction. Une fois acquis au niveau de la
     session, un verrou informatif est détenu jusqu'à ce que le verrou
     soit explicitement relâché ou à la fin de la session. Contrairement
     aux demandes de verrou standard, les demandes de verrous informatifs
     au niveau session n'honorent pas la sémantique de la transaction&nbsp;:
     un verrou acquis lors d'une transaction qui est annulée plus tard
     sera toujours acquis après le ROLLBACK, et de la même façon, un verrou
     relâché reste valide même si la transaction appelante a échoué après.
     Un verrou peut être acquis plusieurs fois par le processus qui le
     détient&nbsp;; pour chaque demande de verrou terminée, il doit y avoir
     une demande de relâche du verrou correspondant avant que ce dernier
     ne soit réellement relâché.
     D'un autre côté, les demandes de verrou au niveau transaction se comportent
     plutôt comme des demandes de verrous standards&nbsp;: les verrous sont
     automatiquement relâchés à la fin de la transaction, et il n'y a pas
     d'opération explicite de déverrouillage. Ce comportement est souvent
     plus intéressant que le comportement au niveau session pour un usage
     rapide d'un verrou informatif.
     Les demandes de verrou au niveau session et transaction pour le même
     identifiant de verrou informatif se bloqueront de la façon attendue.
     Si une session détient déjà un verrou informatif donné, les demandes
     supplémentaires par le même processus réussiront toujours, même si
     d'autres sessions sont en attente&nbsp;; ceci est vrai, quel que soit
     le niveau (session ou transaction) du verrou détenu et des verrous
     demandés.
    </para>

    <para>
     Comme tous les verrous dans <productname>PostgreSQL</productname>, une
     liste complète des verrous informatifs détenus actuellement par toute
     session est disponible dans la vue système <link
     linkend="view-pg-locks"><structname>pg_locks</structname></link>.
    </para>

    <para>
     Les verrous informatifs et les verrous standards sont stockés dans une
     partie de la mémoire partagée, dont la taille est définie par les
     variables de configuration <xref linkend="guc-max-locks-per-transaction"/>
     et <xref linkend="guc-max-connections"/>. Attention à ne pas vider cette
     mémoire, sinon le serveur ne serait plus capable d'accorder des verrous.
     Ceci impose une limite supérieure au nombre de verrous informatifs que le
     serveur peut accorder, typiquement entre des dizaines et des centaines de
     milliers suivant la façon dont le serveur est configuré.
    </para>

    <para>
     Dans certains cas utilisant
     cette méthode, tout spécialement les requêtes impliquant un tri explicite
     et des clauses <literal>LIMIT</literal>, une grande attention doit être
     portée au contrôle des verrous acquis, à cause de l'ordre dans lequel les
     expressions SQL sont évaluées. Par exemple&nbsp;:
<screen>SELECT pg_advisory_lock(id) FROM foo WHERE id = 12345; -- ok
SELECT pg_advisory_lock(id) FROM foo WHERE id &gt; 12345 LIMIT 100; -- danger !
SELECT pg_advisory_lock(q.id) FROM
(
  SELECT id FROM foo WHERE id &gt; 12345 LIMIT 100
) q; -- ok
    </screen>
    Dans les requêtes ci-dessus, la deuxième forme est dangereuse parce qu'il
    n'est pas garanti que l'application de <literal>LIMIT</literal> ait lieu avant que la
    fonction du verrou soit exécutée. Ceci pourrait entraîner l'acquisition
    de certains verrous que l'application n'attendait pas, donc qu'elle
    ne pourrait, du coup, pas relâcher (sauf à la fin de la session). Du point de vue de
    l'application, de tels verrous sont en attente, bien qu'ils soient visibles dans
    <structname>pg_locks</structname>.
   </para>

   <para>
    Les fonctions fournies pour manipuler les verrous informatifs sont décrites dans
    <xref linkend="functions-advisory-locks"/>.
   </para>
  </sect2>

 </sect1>

 <sect1 id="applevel-consistency">
  <title>Vérification de cohérence des données au niveau de l'application</title>

  <para>
   Il est très difficile d'implémenter des règles de gestion sur l'intégrité
   des données en utilisant des transactions Read Committed parce que la vue
   des données est changeante avec chaque ordre, et même un seul ordre peut
   ne pas se cantonner à son propre instantané si un conflit en écriture
   se produit.
  </para>

  <para>
   Bien qu'une transaction Repeatable Read ait une vue stable des
   données dans toute la durée de son exécution, il y a un problème
   subtil quand on utilise les instantanés <acronym>MVCC</acronym> pour
   vérifier la cohérence des données, impliquant quelque chose connu
   sous le nom de <firstterm>conflits lecture/écriture</firstterm>. Si
   une transaction écrit des données et qu'une transaction
   concurrente essaie de lire la même donnée (que ce soit avant ou
   après l'écriture), elle ne peut pas voir le travail de l'autre
   transaction. Le lecteur donne donc l'impression de s'être exécuté
   le premier, quel que soit celui qui a commencé le premier ou qui a
   validé le premier. Si on s'en tient là, ce n'est pas un problème,
   mais si le lecteur écrit aussi des données qui sont lues par
   une transaction concurrente, il y a maintenant une transaction qui
   semble s'être exécutée avant les transactions précédemment
   mentionnées. Si la transaction qui semble s'être exécutée en
   dernier valide en premier, il est très facile qu'un cycle apparaisse
   dans l'ordre d'exécution des transactions. Quand un cycle de ce
   genre apparaît, les contrôles d'intégrité ne fonctionneront pas
   correctement sans aide.
  </para>

  <para>
   Comme mentionné dans <xref linkend="xact-serializable"/>, les
   transactions Serializable ne sont que des transactions Repeatable
   Read qui ajoutent une supervision non bloquante de formes dangereuses
   de conflits lecture/écriture. Quand une de ces formes est détectée
   qui pourrait entraîner un cycle dans l'ordre apparent d'exécution,
   une des transactions impliquées est annulée pour casser le cycle.
  </para>

  <sect2 id="serializable-consistency">
   <title>Garantir la Cohérence avec des Transactions Serializable</title>

   <para>
    Si le niveau d'isolation de transactions Serializable est utilisé
    pour toutes les écritures et toutes les lectures qui ont besoin
    d'une vue cohérente des données, aucun autre effort n'est requis
    pour garantir la cohérence. Un logiciel d'un autre environnement
    écrit pour utiliser des transactions Serializable pour garantir
    la cohérence devrait <quote>fonctionner sans modification</quote>
    de ce point de vue dans <productname>PostgreSQL</productname>.
   </para>

   <para>
    L'utilisation de cette technique évitera de créer une
    charge de travail inutile aux développeurs d'applications
    si le logiciel utilise un framework qui réessaie automatiquement
    les transactions annulées pour échec de sérialisation.
    Cela pourrait être une bonne idée de
    positionner <literal>default_transaction_isolation</literal> à
    <literal>serializable</literal>. Il serait sage, par ailleurs, de
    vous assurer qu'aucun autre niveau d'isolation n'est utilisé, soit
    par inadvertance, soit pour contourner les contrôles d'intégrité,
    en vérifiant les niveaux d'isolations dans les triggers.
   </para>

   <para>
    Voyez <xref linkend="xact-serializable"/> pour des suggestions sur
    les performances.
   </para>

   <warning>
    <para>
     Ce niveau de protection de l'intégrité en utilisant
     des transactions Serializable ne s'étend pour le moment pas
     jusqu'au mode standby (<xref linkend="hot-standby"/>). Pour cette
     raison, les utilisateurs du hot standby voudront peut-être utiliser
     Repeatable Read et un verrouillage explicite sur le primaire.
    </para>
   </warning>
  </sect2>

  <sect2 id="non-serializable-consistency">
   <title>Garantir la Cohérence avec des Verrous Bloquants Explicites</title>

   <para>
    Quand des écritures non sérialisables sont possibles, pour garantir
    la validité courante d'un enregistrement et le protéger contre
    des mises à jour concurrentes, on doit utiliser <command>SELECT
     FOR UPDATE</command>, <command>SELECT FOR SHARE</command>, ou un
    ordre <command>LOCK TABLE</command> approprié. (<command>SELECT
     FOR UPDATE</command> et <command>SELECT FOR SELECT</command> ne
    verrouillent que les lignes retournées contre les mises à jour
    concurrentes, tandis que <command>LOCK TABLE</command> verrouille
    toute la table.) Cela doit être pris en considération quand
    vous portez des applications <productname>PostgreSQL</productname>
    à partir d'autres environnements.
   </para>

   <para>
    Il est aussi important de noter pour ceux qui convertissent à
    partir d'autres environnements le fait que <command>SELECT
     FOR UPDATE</command> ne garantit pas qu'une transaction
    concurrente ne mettra pas à jour ou n'effacera
    pas l'enregistrement sélectionné. Pour faire cela dans
    <productname>PostgreSQL</productname>, vous devez réellement modifier
    l'enregistrement, même si vous n'avez pas besoin de modifier une
    valeur. <command>SELECT FOR UPDATE</command> <emphasis>empêche
     temporairement</emphasis> les autres transactions d'acquérir
    le même verrou ou d'exécuter un <command>UPDATE</command>
    ou <command>DELETE</command> qui modifierait l'enregistrement
    verrouillé, mais une fois que la transaction possédant ce verrou
    valide ou annule, une transaction bloquée pourra continuer avec son
    opération en conflit, sauf si un réel <command>UPDATE</command>
    de l'enregistrement a été effectué pendant que le verrou était
    possédé.
   </para>

   <para>
    Les vérifications globales de validité demandent davantage de
    réflexion sous un <acronym>MVCC</acronym> non sérialisable. Par
    exemple, une application bancaire pourrait vouloir vérifier que
    la somme de tous les crédits d'une table est égale à la somme
    de tous les débits d'une autre, alors que les deux tables sont
    en cours de mise à jour. La comparaison des résultats de deux
    <literal>SELECT sum(...)</literal> successifs ne fonctionnera pas
    correctement en mode Read Committed, puisque la seconde requête
    inclura probablement les résultats de transactions non prises en
    compte dans la première. Effectuer les deux sommes dans une seule
    transaction repeatable read donnera uniquement une image précise des effets
    des transactions qui ont validé avant le début de la
    transaction repeatable read — mais on pourrait légitimement
    se demander si la réponse est toujours valide au moment où elle
    est fournie. Si la transaction repeatable read a elle-même effectué
    des modifications avant d'effectuer le test de cohérence, l'utilité
    de la vérification devient encore plus sujette à caution, puisque
    maintenant elle inclut des modifications depuis le début de la
    transaction, mais pas toutes. Dans ce genre de cas, une personne
    prudente pourra vouloir verrouiller toutes les tables nécessaires
    à la vérification, afin d'avoir une vision incontestable de
    la réalité courante. Un mode <literal>SHARE</literal> (ou plus
    élevé) garantit qu'il n'y a pas de changements non validés dans
    la table verrouillée, autres que ceux de la transaction courante.
   </para>

   <para>
    Notez aussi que si on se fie au verrouillage explicite pour
    empêcher les mises à jour concurrentes, on devrait soit utiliser
    Read Committed, soit utiliser Repeatable Read et faire attention
    à obtenir les verrous avant d'effectuer les requêtes. Un verrou
    obtenu par une transaction repeatable read garantit qu'aucune autre
    transaction modifiant la table n'est en cours d'exécution, mais si
    l'instantané vu par la transaction est antérieur à l'obtention du
    verrou, il pourrait aussi précéder des modifications maintenant
    validées dans la table. Un instantané de transaction repeatable
    read est en fait figé à l'exécution de sa première requête ou
    commande de modification de données (<literal>SELECT</literal>,
    <literal>INSERT</literal>, <literal>UPDATE</literal>, ou
    <literal>DELETE</literal>), il est donc possible d'obtenir les
    verrous explicitement avant que l'instantané ne soit figé.
   </para>

   <para>
    Le niveau d'isolation Serializable est implémenté en utilisant une
    technique connue dans la littérature académique sur les bases de données
    sous le nom de Serializable Snapshot Isolation, qui ajoute à une isolation
    de snapshot en ajoutant des vérifications sur les anomalies de
    sérialisation. Quelques différences dans le comportement et les
    performances sont observables si on le compare à d'autres systèmes qui
    utilisent une technique de verrouillage traditionnelle. Merci de lire
    <xref linkend="ports12"/> pour des informations détaillées.
   </para>
  </sect2>
 </sect1>

 <sect1 id="mvcc-caveats">
  <title>Avertissements</title>

  <para>
   Certaines commandes DDL, actuellement seulement
   <link linkend="sql-truncate"><command>TRUNCATE</command></link> et les formes
   d'<link linkend="sql-altertable"><command>ALTER TABLE</command></link>
   qui réécrivent la table, ne sont pas sûres au niveau MVCC. Ceci signifie
   que, après la validation d'une troncature ou d'une réécriture, la table
   apparaîtra vide aux transactions concurrentes si elles utilisaient une
   image de la base datant d'avant la validation de la commande DDL. Ceci ne
   sera un problème que pour une transaction qui n'a pas encore accédé à la
   table en question avant le lancement de la commande DDL &mdash; toute
   transaction qui a fait cela détiendra au moins un verrou de type
   <literal>ACCESS SHARE</literal> sur la table, ce qui bloquera la commande
   DDL jusqu'à la fin de la transaction. Donc ces commandes ne causeront pas
   d'incohérence apparente dans le contenu de la table pour des requêtes
   successives sur la table cible, mais elles seront la cause d'incohérence
   visible entre le contenu de la table cible et les autres tables de la
   base.
  </para>

  <para>
   L'accès interne aux catalogues système n'est pas faite en utilisant le
   niveau d'isolation de la transaction actuelle. Ceci signifie que les objets
   de base nouvellement créés, comme des tables, sont visibles aux
   transactions concurrentes en Repeatable Read et en Serializable, même si
   les lignes qu'elles contiennent ne le sont pas. À l'inverse les requêtes
   qui examinent les catalogues systèmes ne voient pas les lignes représentant
   les objets créés en concurrence dans les plus haut niveaux d'isolation.
  </para>
 </sect1>

 <sect1 id="locking-indexes">
  <title>Verrous et index</title>

  <indexterm zone="locking-indexes">
   <primary>index</primary>
   <secondary>verrous</secondary>
  </indexterm>

  <para>
   Bien que <productname>PostgreSQL</productname> fournisse un accès en
   lecture/écriture non bloquant aux données de la table, l'accès en
   lecture/écriture non bloquant n'est pas proposé pour chaque méthode
   d'accès aux index implémentés dans <productname>PostgreSQL</productname>.
   Les différents types d'index sont gérés ainsi&nbsp;:

   <variablelist>
    <varlistentry>
     <term>
      Index B-tree, <acronym>GiST</acronym> et <acronym>SP-GiST</acronym>
     </term>
     <listitem>
      <para>
       Des verrous partagés/exclusifs au niveau page à court terme sont
       utilisés pour les accès en lecture/écriture. Les verrous sont
       relâchés immédiatement après que chaque ligne d'index est
       lue ou insérée. Ces types d'index fournissent la plus grande
       concurrence d'accès, sans condition de verrous mortels.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      Index hash
     </term>
     <listitem>
      <para>
       Des verrous partagés/exclusifs au niveau des blocs de hachage sont
       utilisés pour l'accès en lecture/écriture. Les verrous sont relâchés
       après qu'un bloc a été traité entièrement. Les verrous au niveau bloc
       fournissent une meilleur concurrence d'accès que les verrous au
       niveau index, mais les verrous mortels sont possibles, car les
       verrous sont détenus plus longtemps que l'opération sur l'index.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      Index <acronym>GIN</acronym>
     </term>
     <listitem>
      <para>
       Des verrous partagés/exclusifs au niveau page à court terme sont
       utilisés pour les accès en lecture/écriture. Les verrous sont
       relâchés immédiatement après que chaque ligne d'index est
       lue ou insérée. Cependant, notez que l'insertion d'une valeur indexée
       par GIN produit généralement plusieurs insertions de clés d'index
       par ligne, donc GIN peut avoir un travail important à réaliser
       pour l'insertion d'une seule valeur.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Actuellement, les index B-tree offrent les meilleures performances pour les
   applications concurrentes. Comme ils ont plus de fonctionnalités que les
   index hash, ils sont le type d'index recommandé pour les applications
   concurrentes qui ont besoin d'indexer des données scalaires. Lors du
   traitement de données non scalaires, les index B-tree ne sont pas utiles.
   Les index GiST, SP-GiST ou GIN doivent être utilisés à la place.
  </para>

  <para>
   L'accès interne aux catalogues systèmes n'est pas réalisée en utilisant le
   niveau d'isolation de la transaction courante. Cela signifie que les objets
   nouvellement créés d'une base, comme les tables, sont visibles aux
   transactions Repeatable Read et Serializable, même si les lignes qu'elles
   contiennent ne le sont pas. À l'inverse, les requêtes qui examinent
   explicitement les catalogues systèmes ne voient pas les lignes représentant
   les objets nouvellement créés en concurrence, dans les plus hauts niveaux
   d'isolation.
  </para>
 </sect1>
</chapter>
